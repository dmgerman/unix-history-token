begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2011 The FreeBSD Project. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/* Based on:  * SHA512-based Unix crypt implementation. Released into the Public Domain by  * Ulrich Drepper<drepper@redhat.com>. */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<sha512.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"crypt.h"
end_include

begin_comment
comment|/* Define our magic string to mark salt for SHA512 "encryption" replacement. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sha512_salt_prefix
index|[]
init|=
literal|"$6$"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prefix for optional rounds specification. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sha512_rounds_prefix
index|[]
init|=
literal|"rounds="
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum salt string length. */
end_comment

begin_define
define|#
directive|define
name|SALT_LEN_MAX
value|16
end_define

begin_comment
comment|/* Default number of rounds if not explicitly specified. */
end_comment

begin_define
define|#
directive|define
name|ROUNDS_DEFAULT
value|5000
end_define

begin_comment
comment|/* Minimum number of rounds. */
end_comment

begin_define
define|#
directive|define
name|ROUNDS_MIN
value|1000
end_define

begin_comment
comment|/* Maximum number of rounds. */
end_comment

begin_define
define|#
directive|define
name|ROUNDS_MAX
value|999999999
end_define

begin_function
specifier|static
name|char
modifier|*
name|sha512_crypt_r
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|salt
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|buflen
parameter_list|)
block|{
name|u_long
name|srounds
decl_stmt|;
name|int
name|n
decl_stmt|;
name|uint8_t
name|alt_result
index|[
literal|64
index|]
decl_stmt|,
name|temp_result
index|[
literal|64
index|]
decl_stmt|;
name|SHA512_CTX
name|ctx
decl_stmt|,
name|alt_ctx
decl_stmt|;
name|size_t
name|salt_len
decl_stmt|,
name|key_len
decl_stmt|,
name|cnt
decl_stmt|,
name|rounds
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|copied_key
decl_stmt|,
modifier|*
name|copied_salt
decl_stmt|,
modifier|*
name|p_bytes
decl_stmt|,
modifier|*
name|s_bytes
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
specifier|const
name|char
modifier|*
name|num
decl_stmt|;
name|bool
name|rounds_custom
decl_stmt|;
name|copied_key
operator|=
name|NULL
expr_stmt|;
name|copied_salt
operator|=
name|NULL
expr_stmt|;
comment|/* Default number of rounds. */
name|rounds
operator|=
name|ROUNDS_DEFAULT
expr_stmt|;
name|rounds_custom
operator|=
name|false
expr_stmt|;
comment|/* Find beginning of salt string. The prefix should normally always 	 * be present. Just in case it is not. */
if|if
condition|(
name|strncmp
argument_list|(
name|sha512_salt_prefix
argument_list|,
name|salt
argument_list|,
sizeof|sizeof
argument_list|(
name|sha512_salt_prefix
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
comment|/* Skip salt prefix. */
name|salt
operator|+=
sizeof|sizeof
argument_list|(
name|sha512_salt_prefix
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|salt
argument_list|,
name|sha512_rounds_prefix
argument_list|,
sizeof|sizeof
argument_list|(
name|sha512_rounds_prefix
argument_list|)
operator|-
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|num
operator|=
name|salt
operator|+
sizeof|sizeof
argument_list|(
name|sha512_rounds_prefix
argument_list|)
operator|-
literal|1
expr_stmt|;
name|srounds
operator|=
name|strtoul
argument_list|(
name|num
argument_list|,
operator|&
name|endp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endp
operator|==
literal|'$'
condition|)
block|{
name|salt
operator|=
name|endp
operator|+
literal|1
expr_stmt|;
name|rounds
operator|=
name|MAX
argument_list|(
name|ROUNDS_MIN
argument_list|,
name|MIN
argument_list|(
name|srounds
argument_list|,
name|ROUNDS_MAX
argument_list|)
argument_list|)
expr_stmt|;
name|rounds_custom
operator|=
name|true
expr_stmt|;
block|}
block|}
name|salt_len
operator|=
name|MIN
argument_list|(
name|strcspn
argument_list|(
name|salt
argument_list|,
literal|"$"
argument_list|)
argument_list|,
name|SALT_LEN_MAX
argument_list|)
expr_stmt|;
name|key_len
operator|=
name|strlen
argument_list|(
name|key
argument_list|)
expr_stmt|;
comment|/* Prepare for the real work. */
name|SHA512_Init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
comment|/* Add the key string. */
name|SHA512_Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|key
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
comment|/* The last part is the salt string. This must be at most 8 	 * characters and it ends at the first `$' character (for 	 * compatibility with existing implementations). */
name|SHA512_Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|salt
argument_list|,
name|salt_len
argument_list|)
expr_stmt|;
comment|/* Compute alternate SHA512 sum with input KEY, SALT, and KEY. The 	 * final result will be added to the first context. */
name|SHA512_Init
argument_list|(
operator|&
name|alt_ctx
argument_list|)
expr_stmt|;
comment|/* Add key. */
name|SHA512_Update
argument_list|(
operator|&
name|alt_ctx
argument_list|,
name|key
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
comment|/* Add salt. */
name|SHA512_Update
argument_list|(
operator|&
name|alt_ctx
argument_list|,
name|salt
argument_list|,
name|salt_len
argument_list|)
expr_stmt|;
comment|/* Add key again. */
name|SHA512_Update
argument_list|(
operator|&
name|alt_ctx
argument_list|,
name|key
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
comment|/* Now get result of this (64 bytes) and add it to the other context. */
name|SHA512_Final
argument_list|(
name|alt_result
argument_list|,
operator|&
name|alt_ctx
argument_list|)
expr_stmt|;
comment|/* Add for any character in the key one byte of the alternate sum. */
for|for
control|(
name|cnt
operator|=
name|key_len
init|;
name|cnt
operator|>
literal|64
condition|;
name|cnt
operator|-=
literal|64
control|)
name|SHA512_Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|alt_result
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|SHA512_Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|alt_result
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
comment|/* Take the binary representation of the length of the key and for 	 * every 1 add the alternate sum, for every 0 the key. */
for|for
control|(
name|cnt
operator|=
name|key_len
init|;
name|cnt
operator|>
literal|0
condition|;
name|cnt
operator|>>=
literal|1
control|)
if|if
condition|(
operator|(
name|cnt
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|SHA512_Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|alt_result
argument_list|,
literal|64
argument_list|)
expr_stmt|;
else|else
name|SHA512_Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|key
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
comment|/* Create intermediate result. */
name|SHA512_Final
argument_list|(
name|alt_result
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
comment|/* Start computation of P byte sequence. */
name|SHA512_Init
argument_list|(
operator|&
name|alt_ctx
argument_list|)
expr_stmt|;
comment|/* For every character in the password add the entire password. */
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|key_len
condition|;
operator|++
name|cnt
control|)
name|SHA512_Update
argument_list|(
operator|&
name|alt_ctx
argument_list|,
name|key
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
comment|/* Finish the digest. */
name|SHA512_Final
argument_list|(
name|temp_result
argument_list|,
operator|&
name|alt_ctx
argument_list|)
expr_stmt|;
comment|/* Create byte sequence P. */
name|cp
operator|=
name|p_bytes
operator|=
name|alloca
argument_list|(
name|key_len
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
name|key_len
init|;
name|cnt
operator|>=
literal|64
condition|;
name|cnt
operator|-=
literal|64
control|)
block|{
name|memcpy
argument_list|(
name|cp
argument_list|,
name|temp_result
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|cp
operator|+=
literal|64
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|cp
argument_list|,
name|temp_result
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
comment|/* Start computation of S byte sequence. */
name|SHA512_Init
argument_list|(
operator|&
name|alt_ctx
argument_list|)
expr_stmt|;
comment|/* For every character in the password add the entire password. */
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
literal|16
operator|+
name|alt_result
index|[
literal|0
index|]
condition|;
operator|++
name|cnt
control|)
name|SHA512_Update
argument_list|(
operator|&
name|alt_ctx
argument_list|,
name|salt
argument_list|,
name|salt_len
argument_list|)
expr_stmt|;
comment|/* Finish the digest. */
name|SHA512_Final
argument_list|(
name|temp_result
argument_list|,
operator|&
name|alt_ctx
argument_list|)
expr_stmt|;
comment|/* Create byte sequence S. */
name|cp
operator|=
name|s_bytes
operator|=
name|alloca
argument_list|(
name|salt_len
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
name|salt_len
init|;
name|cnt
operator|>=
literal|64
condition|;
name|cnt
operator|-=
literal|64
control|)
block|{
name|memcpy
argument_list|(
name|cp
argument_list|,
name|temp_result
argument_list|,
literal|64
argument_list|)
expr_stmt|;
name|cp
operator|+=
literal|64
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|cp
argument_list|,
name|temp_result
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
comment|/* Repeatedly run the collected hash value through SHA512 to burn CPU 	 * cycles. */
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|rounds
condition|;
operator|++
name|cnt
control|)
block|{
comment|/* New context. */
name|SHA512_Init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
comment|/* Add key or last result. */
if|if
condition|(
operator|(
name|cnt
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|SHA512_Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|p_bytes
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
else|else
name|SHA512_Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|alt_result
argument_list|,
literal|64
argument_list|)
expr_stmt|;
comment|/* Add salt for numbers not divisible by 3. */
if|if
condition|(
name|cnt
operator|%
literal|3
operator|!=
literal|0
condition|)
name|SHA512_Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|s_bytes
argument_list|,
name|salt_len
argument_list|)
expr_stmt|;
comment|/* Add key for numbers not divisible by 7. */
if|if
condition|(
name|cnt
operator|%
literal|7
operator|!=
literal|0
condition|)
name|SHA512_Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|p_bytes
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
comment|/* Add key or last result. */
if|if
condition|(
operator|(
name|cnt
operator|&
literal|1
operator|)
operator|!=
literal|0
condition|)
name|SHA512_Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|alt_result
argument_list|,
literal|64
argument_list|)
expr_stmt|;
else|else
name|SHA512_Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|p_bytes
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
comment|/* Create intermediate result. */
name|SHA512_Final
argument_list|(
name|alt_result
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
block|}
comment|/* Now we can construct the result string. It consists of three 	 * parts. */
name|cp
operator|=
name|stpncpy
argument_list|(
name|buffer
argument_list|,
name|sha512_salt_prefix
argument_list|,
name|MAX
argument_list|(
literal|0
argument_list|,
name|buflen
argument_list|)
argument_list|)
expr_stmt|;
name|buflen
operator|-=
sizeof|sizeof
argument_list|(
name|sha512_salt_prefix
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|rounds_custom
condition|)
block|{
name|n
operator|=
name|snprintf
argument_list|(
name|cp
argument_list|,
name|MAX
argument_list|(
literal|0
argument_list|,
name|buflen
argument_list|)
argument_list|,
literal|"%s%zu$"
argument_list|,
name|sha512_rounds_prefix
argument_list|,
name|rounds
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
block|}
name|cp
operator|=
name|stpncpy
argument_list|(
name|cp
argument_list|,
name|salt
argument_list|,
name|MIN
argument_list|(
operator|(
name|size_t
operator|)
name|MAX
argument_list|(
literal|0
argument_list|,
name|buflen
argument_list|)
argument_list|,
name|salt_len
argument_list|)
argument_list|)
expr_stmt|;
name|buflen
operator|-=
name|MIN
argument_list|(
operator|(
name|size_t
operator|)
name|MAX
argument_list|(
literal|0
argument_list|,
name|buflen
argument_list|)
argument_list|,
name|salt_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buflen
operator|>
literal|0
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'$'
expr_stmt|;
operator|--
name|buflen
expr_stmt|;
block|}
name|b64_from_24bit
argument_list|(
name|alt_result
index|[
literal|0
index|]
argument_list|,
name|alt_result
index|[
literal|21
index|]
argument_list|,
name|alt_result
index|[
literal|42
index|]
argument_list|,
literal|4
argument_list|,
operator|&
name|buflen
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|b64_from_24bit
argument_list|(
name|alt_result
index|[
literal|22
index|]
argument_list|,
name|alt_result
index|[
literal|43
index|]
argument_list|,
name|alt_result
index|[
literal|1
index|]
argument_list|,
literal|4
argument_list|,
operator|&
name|buflen
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|b64_from_24bit
argument_list|(
name|alt_result
index|[
literal|44
index|]
argument_list|,
name|alt_result
index|[
literal|2
index|]
argument_list|,
name|alt_result
index|[
literal|23
index|]
argument_list|,
literal|4
argument_list|,
operator|&
name|buflen
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|b64_from_24bit
argument_list|(
name|alt_result
index|[
literal|3
index|]
argument_list|,
name|alt_result
index|[
literal|24
index|]
argument_list|,
name|alt_result
index|[
literal|45
index|]
argument_list|,
literal|4
argument_list|,
operator|&
name|buflen
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|b64_from_24bit
argument_list|(
name|alt_result
index|[
literal|25
index|]
argument_list|,
name|alt_result
index|[
literal|46
index|]
argument_list|,
name|alt_result
index|[
literal|4
index|]
argument_list|,
literal|4
argument_list|,
operator|&
name|buflen
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|b64_from_24bit
argument_list|(
name|alt_result
index|[
literal|47
index|]
argument_list|,
name|alt_result
index|[
literal|5
index|]
argument_list|,
name|alt_result
index|[
literal|26
index|]
argument_list|,
literal|4
argument_list|,
operator|&
name|buflen
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|b64_from_24bit
argument_list|(
name|alt_result
index|[
literal|6
index|]
argument_list|,
name|alt_result
index|[
literal|27
index|]
argument_list|,
name|alt_result
index|[
literal|48
index|]
argument_list|,
literal|4
argument_list|,
operator|&
name|buflen
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|b64_from_24bit
argument_list|(
name|alt_result
index|[
literal|28
index|]
argument_list|,
name|alt_result
index|[
literal|49
index|]
argument_list|,
name|alt_result
index|[
literal|7
index|]
argument_list|,
literal|4
argument_list|,
operator|&
name|buflen
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|b64_from_24bit
argument_list|(
name|alt_result
index|[
literal|50
index|]
argument_list|,
name|alt_result
index|[
literal|8
index|]
argument_list|,
name|alt_result
index|[
literal|29
index|]
argument_list|,
literal|4
argument_list|,
operator|&
name|buflen
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|b64_from_24bit
argument_list|(
name|alt_result
index|[
literal|9
index|]
argument_list|,
name|alt_result
index|[
literal|30
index|]
argument_list|,
name|alt_result
index|[
literal|51
index|]
argument_list|,
literal|4
argument_list|,
operator|&
name|buflen
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|b64_from_24bit
argument_list|(
name|alt_result
index|[
literal|31
index|]
argument_list|,
name|alt_result
index|[
literal|52
index|]
argument_list|,
name|alt_result
index|[
literal|10
index|]
argument_list|,
literal|4
argument_list|,
operator|&
name|buflen
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|b64_from_24bit
argument_list|(
name|alt_result
index|[
literal|53
index|]
argument_list|,
name|alt_result
index|[
literal|11
index|]
argument_list|,
name|alt_result
index|[
literal|32
index|]
argument_list|,
literal|4
argument_list|,
operator|&
name|buflen
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|b64_from_24bit
argument_list|(
name|alt_result
index|[
literal|12
index|]
argument_list|,
name|alt_result
index|[
literal|33
index|]
argument_list|,
name|alt_result
index|[
literal|54
index|]
argument_list|,
literal|4
argument_list|,
operator|&
name|buflen
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|b64_from_24bit
argument_list|(
name|alt_result
index|[
literal|34
index|]
argument_list|,
name|alt_result
index|[
literal|55
index|]
argument_list|,
name|alt_result
index|[
literal|13
index|]
argument_list|,
literal|4
argument_list|,
operator|&
name|buflen
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|b64_from_24bit
argument_list|(
name|alt_result
index|[
literal|56
index|]
argument_list|,
name|alt_result
index|[
literal|14
index|]
argument_list|,
name|alt_result
index|[
literal|35
index|]
argument_list|,
literal|4
argument_list|,
operator|&
name|buflen
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|b64_from_24bit
argument_list|(
name|alt_result
index|[
literal|15
index|]
argument_list|,
name|alt_result
index|[
literal|36
index|]
argument_list|,
name|alt_result
index|[
literal|57
index|]
argument_list|,
literal|4
argument_list|,
operator|&
name|buflen
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|b64_from_24bit
argument_list|(
name|alt_result
index|[
literal|37
index|]
argument_list|,
name|alt_result
index|[
literal|58
index|]
argument_list|,
name|alt_result
index|[
literal|16
index|]
argument_list|,
literal|4
argument_list|,
operator|&
name|buflen
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|b64_from_24bit
argument_list|(
name|alt_result
index|[
literal|59
index|]
argument_list|,
name|alt_result
index|[
literal|17
index|]
argument_list|,
name|alt_result
index|[
literal|38
index|]
argument_list|,
literal|4
argument_list|,
operator|&
name|buflen
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|b64_from_24bit
argument_list|(
name|alt_result
index|[
literal|18
index|]
argument_list|,
name|alt_result
index|[
literal|39
index|]
argument_list|,
name|alt_result
index|[
literal|60
index|]
argument_list|,
literal|4
argument_list|,
operator|&
name|buflen
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|b64_from_24bit
argument_list|(
name|alt_result
index|[
literal|40
index|]
argument_list|,
name|alt_result
index|[
literal|61
index|]
argument_list|,
name|alt_result
index|[
literal|19
index|]
argument_list|,
literal|4
argument_list|,
operator|&
name|buflen
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|b64_from_24bit
argument_list|(
name|alt_result
index|[
literal|62
index|]
argument_list|,
name|alt_result
index|[
literal|20
index|]
argument_list|,
name|alt_result
index|[
literal|41
index|]
argument_list|,
literal|4
argument_list|,
operator|&
name|buflen
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|b64_from_24bit
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|alt_result
index|[
literal|63
index|]
argument_list|,
literal|2
argument_list|,
operator|&
name|buflen
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|buflen
operator|<=
literal|0
condition|)
block|{
name|errno
operator|=
name|ERANGE
expr_stmt|;
name|buffer
operator|=
name|NULL
expr_stmt|;
block|}
else|else
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* Terminate the string. */
comment|/* Clear the buffer for the intermediate result so that people 	 * attaching to processes or reading core dumps cannot get any 	 * information. We do it in this way to clear correct_words[] inside 	 * the SHA512 implementation as well. */
name|SHA512_Init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|SHA512_Final
argument_list|(
name|alt_result
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|temp_result
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|temp_result
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p_bytes
argument_list|,
literal|'\0'
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|s_bytes
argument_list|,
literal|'\0'
argument_list|,
name|salt_len
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ctx
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|alt_ctx
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
name|alt_ctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|copied_key
operator|!=
name|NULL
condition|)
name|memset
argument_list|(
name|copied_key
argument_list|,
literal|'\0'
argument_list|,
name|key_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|copied_salt
operator|!=
name|NULL
condition|)
name|memset
argument_list|(
name|copied_salt
argument_list|,
literal|'\0'
argument_list|,
name|salt_len
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function

begin_comment
comment|/* This entry point is equivalent to crypt(3). */
end_comment

begin_function
name|char
modifier|*
name|sha512_crypt
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|salt
parameter_list|)
block|{
comment|/* We don't want to have an arbitrary limit in the size of the 	 * password. We can compute an upper bound for the size of the 	 * result in advance and so we can prepare the buffer we pass to 	 * `sha512_crypt_r'. */
specifier|static
name|char
modifier|*
name|buffer
decl_stmt|;
specifier|static
name|int
name|buflen
decl_stmt|;
name|int
name|needed
decl_stmt|;
name|char
modifier|*
name|new_buffer
decl_stmt|;
name|needed
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|sha512_salt_prefix
argument_list|)
operator|-
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|sha512_rounds_prefix
argument_list|)
operator|+
literal|9
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|salt
argument_list|)
operator|+
literal|1
operator|+
literal|86
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|buflen
operator|<
name|needed
condition|)
block|{
name|new_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|buffer
argument_list|,
name|needed
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_buffer
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|buffer
operator|=
name|new_buffer
expr_stmt|;
name|buflen
operator|=
name|needed
expr_stmt|;
block|}
return|return
name|sha512_crypt_r
argument_list|(
name|key
argument_list|,
name|salt
argument_list|,
name|buffer
argument_list|,
name|buflen
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|TEST
end_ifdef

begin_struct
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|input
decl_stmt|;
specifier|const
name|char
name|result
index|[
literal|64
index|]
decl_stmt|;
block|}
name|tests
index|[]
init|=
block|{
comment|/* Test vectors from FIPS 180-2: appendix C.1. */
block|{
literal|"abc"
block|,
literal|"\xdd\xaf\x35\xa1\x93\x61\x7a\xba\xcc\x41\x73\x49\xae\x20\x41\x31"
literal|"\x12\xe6\xfa\x4e\x89\xa9\x7e\xa2\x0a\x9e\xee\xe6\x4b\x55\xd3\x9a"
literal|"\x21\x92\x99\x2a\x27\x4f\xc1\xa8\x36\xba\x3c\x23\xa3\xfe\xeb\xbd"
literal|"\x45\x4d\x44\x23\x64\x3c\xe8\x0e\x2a\x9a\xc9\x4f\xa5\x4c\xa4\x9f"
block|}
block|,
comment|/* Test vectors from FIPS 180-2: appendix C.2. */
block|{
literal|"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmn"
literal|"hijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu"
block|,
literal|"\x8e\x95\x9b\x75\xda\xe3\x13\xda\x8c\xf4\xf7\x28\x14\xfc\x14\x3f"
literal|"\x8f\x77\x79\xc6\xeb\x9f\x7f\xa1\x72\x99\xae\xad\xb6\x88\x90\x18"
literal|"\x50\x1d\x28\x9e\x49\x00\xf7\xe4\x33\x1b\x99\xde\xc4\xb5\x43\x3a"
literal|"\xc7\xd3\x29\xee\xb6\xdd\x26\x54\x5e\x96\xe5\x5b\x87\x4b\xe9\x09"
block|}
block|,
comment|/* Test vectors from the NESSIE project. */
block|{
literal|""
block|,
literal|"\xcf\x83\xe1\x35\x7e\xef\xb8\xbd\xf1\x54\x28\x50\xd6\x6d\x80\x07"
literal|"\xd6\x20\xe4\x05\x0b\x57\x15\xdc\x83\xf4\xa9\x21\xd3\x6c\xe9\xce"
literal|"\x47\xd0\xd1\x3c\x5d\x85\xf2\xb0\xff\x83\x18\xd2\x87\x7e\xec\x2f"
literal|"\x63\xb9\x31\xbd\x47\x41\x7a\x81\xa5\x38\x32\x7a\xf9\x27\xda\x3e"
block|}
block|,
block|{
literal|"a"
block|,
literal|"\x1f\x40\xfc\x92\xda\x24\x16\x94\x75\x09\x79\xee\x6c\xf5\x82\xf2"
literal|"\xd5\xd7\xd2\x8e\x18\x33\x5d\xe0\x5a\xbc\x54\xd0\x56\x0e\x0f\x53"
literal|"\x02\x86\x0c\x65\x2b\xf0\x8d\x56\x02\x52\xaa\x5e\x74\x21\x05\x46"
literal|"\xf3\x69\xfb\xbb\xce\x8c\x12\xcf\xc7\x95\x7b\x26\x52\xfe\x9a\x75"
block|}
block|,
block|{
literal|"message digest"
block|,
literal|"\x10\x7d\xbf\x38\x9d\x9e\x9f\x71\xa3\xa9\x5f\x6c\x05\x5b\x92\x51"
literal|"\xbc\x52\x68\xc2\xbe\x16\xd6\xc1\x34\x92\xea\x45\xb0\x19\x9f\x33"
literal|"\x09\xe1\x64\x55\xab\x1e\x96\x11\x8e\x8a\x90\x5d\x55\x97\xb7\x20"
literal|"\x38\xdd\xb3\x72\xa8\x98\x26\x04\x6d\xe6\x66\x87\xbb\x42\x0e\x7c"
block|}
block|,
block|{
literal|"abcdefghijklmnopqrstuvwxyz"
block|,
literal|"\x4d\xbf\xf8\x6c\xc2\xca\x1b\xae\x1e\x16\x46\x8a\x05\xcb\x98\x81"
literal|"\xc9\x7f\x17\x53\xbc\xe3\x61\x90\x34\x89\x8f\xaa\x1a\xab\xe4\x29"
literal|"\x95\x5a\x1b\xf8\xec\x48\x3d\x74\x21\xfe\x3c\x16\x46\x61\x3a\x59"
literal|"\xed\x54\x41\xfb\x0f\x32\x13\x89\xf7\x7f\x48\xa8\x79\xc7\xb1\xf1"
block|}
block|,
block|{
literal|"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"
block|,
literal|"\x20\x4a\x8f\xc6\xdd\xa8\x2f\x0a\x0c\xed\x7b\xeb\x8e\x08\xa4\x16"
literal|"\x57\xc1\x6e\xf4\x68\xb2\x28\xa8\x27\x9b\xe3\x31\xa7\x03\xc3\x35"
literal|"\x96\xfd\x15\xc1\x3b\x1b\x07\xf9\xaa\x1d\x3b\xea\x57\x78\x9c\xa0"
literal|"\x31\xad\x85\xc7\xa7\x1d\xd7\x03\x54\xec\x63\x12\x38\xca\x34\x45"
block|}
block|,
block|{
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
block|,
literal|"\x1e\x07\xbe\x23\xc2\x6a\x86\xea\x37\xea\x81\x0c\x8e\xc7\x80\x93"
literal|"\x52\x51\x5a\x97\x0e\x92\x53\xc2\x6f\x53\x6c\xfc\x7a\x99\x96\xc4"
literal|"\x5c\x83\x70\x58\x3e\x0a\x78\xfa\x4a\x90\x04\x1d\x71\xa4\xce\xab"
literal|"\x74\x23\xf1\x9c\x71\xb9\xd5\xa3\xe0\x12\x49\xf0\xbe\xbd\x58\x94"
block|}
block|,
block|{
literal|"123456789012345678901234567890123456789012345678901234567890"
literal|"12345678901234567890"
block|,
literal|"\x72\xec\x1e\xf1\x12\x4a\x45\xb0\x47\xe8\xb7\xc7\x5a\x93\x21\x95"
literal|"\x13\x5b\xb6\x1d\xe2\x4e\xc0\xd1\x91\x40\x42\x24\x6e\x0a\xec\x3a"
literal|"\x23\x54\xe0\x93\xd7\x6f\x30\x48\xb4\x56\x76\x43\x46\x90\x0c\xb1"
literal|"\x30\xd2\xa4\xfd\x5d\xd1\x6a\xbb\x5e\x30\xbc\xb8\x50\xde\xe8\x43"
block|}
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ntests
value|(sizeof (tests) / sizeof (tests[0]))
end_define

begin_struct
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|salt
decl_stmt|;
specifier|const
name|char
modifier|*
name|input
decl_stmt|;
specifier|const
name|char
modifier|*
name|expected
decl_stmt|;
block|}
name|tests2
index|[]
init|=
block|{
block|{
literal|"$6$saltstring"
block|,
literal|"Hello world!"
block|,
literal|"$6$saltstring$svn8UoSVapNtMuq1ukKS4tPQd8iKwSMHWjl/O817G3uBnIFNjnQJu"
literal|"esI68u4OTLiBFdcbYEdFCoEOfaS35inz1"
block|}
block|,
block|{
literal|"$6$rounds=10000$saltstringsaltstring"
block|,
literal|"Hello world!"
block|,
literal|"$6$rounds=10000$saltstringsaltst$OW1/O6BYHV6BcXZu8QVeXbDWra3Oeqh0sb"
literal|"HbbMCVNSnCM/UrjmM0Dp8vOuZeHBy/YTBmSK6H9qs/y3RnOaw5v."
block|}
block|,
block|{
literal|"$6$rounds=5000$toolongsaltstring"
block|,
literal|"This is just a test"
block|,
literal|"$6$rounds=5000$toolongsaltstrin$lQ8jolhgVRVhY4b5pZKaysCLi0QBxGoNeKQ"
literal|"zQ3glMhwllF7oGDZxUhx1yxdYcz/e1JSbq3y6JMxxl8audkUEm0"
block|}
block|,
block|{
literal|"$6$rounds=1400$anotherlongsaltstring"
block|,
literal|"a very much longer text to encrypt.  This one even stretches over more"
literal|"than one line."
block|,
literal|"$6$rounds=1400$anotherlongsalts$POfYwTEok97VWcjxIiSOjiykti.o/pQs.wP"
literal|"vMxQ6Fm7I6IoYN3CmLs66x9t0oSwbtEW7o7UmJEiDwGqd8p4ur1"
block|}
block|,
block|{
literal|"$6$rounds=77777$short"
block|,
literal|"we have a short salt string but not a short password"
block|,
literal|"$6$rounds=77777$short$WuQyW2YR.hBNpjjRhpYD/ifIw05xdfeEyQoMxIXbkvr0g"
literal|"ge1a1x3yRULJ5CCaUeOxFmtlcGZelFl5CxtgfiAc0"
block|}
block|,
block|{
literal|"$6$rounds=123456$asaltof16chars.."
block|,
literal|"a short string"
block|,
literal|"$6$rounds=123456$asaltof16chars..$BtCwjqMJGx5hrJhZywWvt0RLE8uZ4oPwc"
literal|"elCjmw2kSYu.Ec6ycULevoBK25fs2xXgMNrCzIMVcgEJAstJeonj1"
block|}
block|,
block|{
literal|"$6$rounds=10$roundstoolow"
block|,
literal|"the minimum number is still observed"
block|,
literal|"$6$rounds=1000$roundstoolow$kUMsbe306n21p9R.FRkW3IGn.S9NPN0x50YhH1x"
literal|"hLsPuWGsUSklZt58jaTfF4ZEQpyUNGc0dqbpBYYBaHHrsX."
block|}
block|, }
struct|;
end_struct

begin_define
define|#
directive|define
name|ntests2
value|(sizeof (tests2) / sizeof (tests2[0]))
end_define

begin_function
name|int
name|main
parameter_list|(
name|void
parameter_list|)
block|{
name|SHA512_CTX
name|ctx
decl_stmt|;
name|uint8_t
name|sum
index|[
literal|64
index|]
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|,
name|cnt
decl_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
operator|(
name|int
operator|)
name|ntests
condition|;
operator|++
name|cnt
control|)
block|{
name|SHA512_Init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|SHA512_Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|tests
index|[
name|cnt
index|]
operator|.
name|input
argument_list|,
name|strlen
argument_list|(
name|tests
index|[
name|cnt
index|]
operator|.
name|input
argument_list|)
argument_list|)
expr_stmt|;
name|SHA512_Final
argument_list|(
name|sum
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|tests
index|[
name|cnt
index|]
operator|.
name|result
argument_list|,
name|sum
argument_list|,
literal|64
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"test %d run %d failed\n"
argument_list|,
name|cnt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
block|}
name|SHA512_Init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|tests
index|[
name|cnt
index|]
operator|.
name|input
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
operator|++
name|i
control|)
name|SHA512_Update
argument_list|(
operator|&
name|ctx
argument_list|,
operator|&
name|tests
index|[
name|cnt
index|]
operator|.
name|input
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|SHA512_Final
argument_list|(
name|sum
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|tests
index|[
name|cnt
index|]
operator|.
name|result
argument_list|,
name|sum
argument_list|,
literal|64
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"test %d run %d failed\n"
argument_list|,
name|cnt
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Test vector from FIPS 180-2: appendix C.3. */
name|char
name|buf
index|[
literal|1000
index|]
decl_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|'a'
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|SHA512_Init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|1000
condition|;
operator|++
name|i
control|)
name|SHA512_Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|SHA512_Final
argument_list|(
name|sum
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
specifier|static
specifier|const
name|char
name|expected
index|[
literal|64
index|]
init|=
literal|"\xe7\x18\x48\x3d\x0c\xe7\x69\x64\x4e\x2e\x42\xc7\xbc\x15\xb4\x63"
literal|"\x8e\x1f\x98\xb1\x3b\x20\x44\x28\x56\x32\xa8\x03\xaf\xa9\x73\xeb"
literal|"\xde\x0f\xf2\x44\x87\x7e\xa6\x0a\x4c\xb0\x43\x2c\xe5\x77\xc3\x1b"
literal|"\xeb\x00\x9c\x5c\x2c\x49\xaa\x2e\x4e\xad\xb2\x17\xad\x8c\xc0\x9b"
decl_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|expected
argument_list|,
name|sum
argument_list|,
literal|64
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"test %d failed\n"
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|ntests2
condition|;
operator|++
name|cnt
control|)
block|{
name|char
modifier|*
name|cp
init|=
name|sha512_crypt
argument_list|(
name|tests2
index|[
name|cnt
index|]
operator|.
name|input
argument_list|,
name|tests2
index|[
name|cnt
index|]
operator|.
name|salt
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
name|tests2
index|[
name|cnt
index|]
operator|.
name|expected
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"test %d: expected \"%s\", got \"%s\"\n"
argument_list|,
name|cnt
argument_list|,
name|tests2
index|[
name|cnt
index|]
operator|.
name|expected
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|result
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|result
operator|==
literal|0
condition|)
name|puts
argument_list|(
literal|"all tests OK"
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* TEST */
end_comment

end_unit

