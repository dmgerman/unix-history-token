begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ----------------------------------------------------------------------------  * "THE BEER-WARE LICENSE" (Revision 42):  *<phk@login.dknet.dk> wrote this file.  As long as you retain this notice you  * can do whatever you want with this stuff. If we meet some day, and you think  * this stuff is worth it, you can buy me a beer in return.   Poul-Henning Kamp  * ----------------------------------------------------------------------------  */
end_comment

begin_comment
comment|/*  * It has since been changed by Brandon Gillespie, the end result is not  * too clean, but it is clear and modular; there is no need for crypt()  * to be optimized (and actually a desire for the opposite) so I am not  * overly concerned.  */
end_comment

begin_comment
comment|/*  * Assumptions made with the format of passwords:  *  *   + Any password beginning with a dollar-sign is assumed to be in  *     the Modular Crypt Format (MCF), namely: $tag$salt$hash.  Any  *     algorithms added will also use this format.  Other MCF assumptions:  *     + The algorithm tag (field 1) will be less than five characters  *       long (yay, arbitrary limits).  Anything longer is ignored.  *       New algorithm names are not allowed to be fully numeric as  *       anything fully numeric is mapped from other OS's not following  *       our standard, and from older versions of this standard (such as  *       $1$ for MD5 passwords, rather than $MD5$).  *     + The salt can be up to 16 characters in length (more arbitrary  *       limits).  *   + An invalid or unrecognized algorithm tag will default to use the  *     'best' encryption method--whatever that may be at the time.  *   + If the MCF is not specified, use the 'best' method, unless DES  *     is installed--then use DES.  *   + Any password beginning with an underscore '_' is assumed to be  *     the Extended DES Format, which has its own salt requirements,  *     and is not the same as the MCF.  *   + Salt must be limited to the same ascii64 character set the hash  *     is encoded in (namely "./0-9A-Za-z").  */
end_comment

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_define
define|#
directive|define
name|_CRYPT_C_
end_define

begin_include
include|#
directive|include
file|"crypt.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|TRUE
end_ifndef

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FALSE
end_ifndef

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * commonly used througout all algorithms  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|ascii64
index|[]
init|=
comment|/* 0 ... 63 => ascii - 64 */
literal|"./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|to64
parameter_list|(
name|s
parameter_list|,
name|v
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|long
name|v
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
operator|*
name|s
operator|++
operator|=
name|ascii64
index|[
name|v
operator|&
literal|0x3f
index|]
expr_stmt|;
name|v
operator|>>=
literal|6
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|hash_word
parameter_list|(
name|password
parameter_list|,
name|salt
parameter_list|,
name|output
parameter_list|)
specifier|const
name|char
modifier|*
name|password
decl_stmt|;
specifier|const
name|char
modifier|*
name|salt
decl_stmt|;
name|char
modifier|*
name|output
decl_stmt|;
block|{
name|unsigned
name|char
name|spbuf
index|[
name|_CRYPT_MAX_SALT_LEN
operator|+
literal|1
index|]
decl_stmt|,
name|pwbuf
index|[
name|_CRYPT_OUTPUT_SIZE
operator|+
literal|1
index|]
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|sp
decl_stmt|,
modifier|*
name|pw
decl_stmt|;
name|unsigned
name|int
name|sl
decl_stmt|,
name|pl
decl_stmt|,
name|tag
init|=
name|_CRYPT_DEFAULT_VERSION
decl_stmt|,
name|mcf
init|=
name|FALSE
decl_stmt|;
name|memset
argument_list|(
name|spbuf
argument_list|,
literal|0
argument_list|,
name|_CRYPT_MAX_SALT_LEN
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|pwbuf
argument_list|,
literal|0
argument_list|,
name|_CRYPT_MAX_SALT_LEN
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|spbuf
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|salt
argument_list|,
name|_CRYPT_MAX_SALT_LEN
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pwbuf
argument_list|,
operator|(
name|unsigned
name|char
operator|*
operator|)
name|password
argument_list|,
name|_CRYPT_OUTPUT_SIZE
argument_list|)
expr_stmt|;
name|sp
operator|=
operator|&
name|spbuf
index|[
literal|0
index|]
expr_stmt|;
name|pw
operator|=
operator|&
name|pwbuf
index|[
literal|0
index|]
expr_stmt|;
name|pl
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pw
argument_list|)
expr_stmt|;
comment|/* figure out what type of crypt is wanted */
if|if
condition|(
name|sp
operator|&&
name|sp
index|[
literal|0
index|]
operator|==
literal|'$'
condition|)
block|{
name|mcf
operator|=
name|TRUE
expr_stmt|;
name|sp
operator|++
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sp
argument_list|,
literal|"MD5$"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tag
operator|=
name|_MD5_CRYPT
expr_stmt|;
name|sp
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sp
argument_list|,
literal|"1$"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tag
operator|=
name|_MD5_CRYPT_OLD
expr_stmt|;
name|sp
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncasecmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sp
argument_list|,
literal|"SHA1$"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tag
operator|=
name|_SHS_CRYPT
expr_stmt|;
name|sp
operator|+=
literal|5
expr_stmt|;
block|}
else|else
block|{
name|tag
operator|=
name|_CRYPT_DEFAULT_VERSION
expr_stmt|;
while|while
condition|(
operator|*
name|sp
operator|&&
operator|*
name|sp
operator|!=
literal|'$'
condition|)
name|sp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|sp
operator|==
literal|'$'
condition|)
name|sp
operator|++
expr_stmt|;
block|}
block|}
comment|/* Refine the salt. Go to the end, it stops at the first '$' or NULL */
for|for
control|(
name|ep
operator|=
name|sp
init|;
operator|*
name|ep
operator|&&
operator|*
name|ep
operator|!=
literal|'$'
condition|;
name|ep
operator|++
control|)
continue|continue;
comment|/* we have to do this so we dont overflow _PASSWORD_LEN */
if|if
condition|(
operator|(
name|ep
operator|-
name|sp
operator|)
operator|>
literal|16
condition|)
block|{
name|sl
operator|=
literal|16
expr_stmt|;
name|sp
index|[
literal|16
index|]
operator|=
operator|(
name|char
operator|)
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|sl
operator|=
name|ep
operator|-
name|sp
expr_stmt|;
block|}
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|_MD5_CRYPT_OLD
case|:
return|return
name|crypt_md5
argument_list|(
name|pw
argument_list|,
name|pl
argument_list|,
name|sp
argument_list|,
name|sl
argument_list|,
name|output
argument_list|,
literal|"$1$"
argument_list|)
return|;
case|case
name|_MD5_CRYPT
case|:
return|return
name|crypt_md5
argument_list|(
name|pw
argument_list|,
name|pl
argument_list|,
name|sp
argument_list|,
name|sl
argument_list|,
name|output
argument_list|,
literal|"$MD5$"
argument_list|)
return|;
ifdef|#
directive|ifdef
name|DES_CRYPT
case|case
name|_DES_CRYPT
case|:
return|return
name|crypt_des
argument_list|(
name|pw
argument_list|,
name|pl
argument_list|,
name|sp
argument_list|,
name|sl
argument_list|,
name|output
argument_list|,
literal|""
argument_list|)
return|;
endif|#
directive|endif
comment|/* dropping a DES password through will likely cause problems,              but at least crypt() will return as it says it will (we cannot              return an error condition) */
case|case
name|_SHS_CRYPT
case|:
default|default:
return|return
name|crypt_shs
argument_list|(
name|pw
argument_list|,
name|pl
argument_list|,
name|sp
argument_list|,
name|sl
argument_list|,
name|output
argument_list|,
literal|"$SHA1$"
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|crypt
parameter_list|(
name|password
parameter_list|,
name|salt
parameter_list|)
specifier|const
name|char
modifier|*
name|password
decl_stmt|;
specifier|const
name|char
modifier|*
name|salt
decl_stmt|;
block|{
specifier|static
name|char
name|output
index|[
name|_CRYPT_OUTPUT_SIZE
index|]
decl_stmt|;
return|return
name|hash_word
argument_list|(
name|password
argument_list|,
name|salt
argument_list|,
name|output
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|malloc_crypt
parameter_list|(
name|password
parameter_list|,
name|salt
parameter_list|)
specifier|const
name|char
modifier|*
name|password
decl_stmt|;
specifier|const
name|char
modifier|*
name|salt
decl_stmt|;
block|{
name|char
modifier|*
name|output
decl_stmt|;
name|output
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
name|_CRYPT_OUTPUT_SIZE
argument_list|)
expr_stmt|;
return|return
name|hash_word
argument_list|(
name|password
argument_list|,
name|salt
argument_list|,
name|output
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|match_crypted
parameter_list|(
name|possible
parameter_list|,
name|crypted
parameter_list|)
specifier|const
name|char
modifier|*
name|possible
decl_stmt|,
decl|*
name|crypted
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|pc
decl_stmt|;
name|int
name|match
decl_stmt|;
name|pc
operator|=
name|malloc_crypt
argument_list|(
name|possible
argument_list|,
name|crypted
argument_list|)
expr_stmt|;
name|match
operator|=
operator|!
name|strcmp
argument_list|(
name|pc
argument_list|,
name|crypted
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pc
argument_list|)
expr_stmt|;
return|return
name|match
return|;
block|}
end_block

begin_undef
undef|#
directive|undef
name|_CRYPT_C_
end_undef

end_unit

