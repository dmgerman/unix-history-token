begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1995  *	Paul Richards.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,   *    verbatim and that no modifications are made prior to this   *    point in the file.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Paul Richards.  * 4. The name Paul Richards may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY PAUL RICHARDS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL PAUL RICHARDS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<forms.h>
end_include

begin_include
include|#
directive|include
file|<ncurses.h>
end_include

begin_include
include|#
directive|include
file|"internal.h"
end_include

begin_decl_stmt
name|unsigned
name|int
name|f_keymap
index|[]
init|=
block|{
name|KEY_UP
block|,
comment|/* F_UP */
name|KEY_DOWN
block|,
comment|/* F_DOWN */
literal|9
block|,
comment|/* F_RIGHT */
literal|8
block|,
comment|/* F_LEFT */
literal|10
block|,
comment|/* F_NEXT */
name|KEY_LEFT
block|,
comment|/* F_CLEFT */
name|KEY_RIGHT
block|,
comment|/* F_CRIGHT */
name|KEY_HOME
block|,
comment|/* F_CHOME */
name|KEY_END
block|,
comment|/* F_CEND */
literal|263
block|,
comment|/* F_CBS */
literal|330
block|,
comment|/* F_CDEL */
literal|10
comment|/* F_ACCEPT */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|done
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|initfrm
parameter_list|(
name|struct
name|form
modifier|*
name|form
parameter_list|)
block|{
name|struct
name|field
modifier|*
name|field
init|=
operator|&
name|form
operator|->
name|field
index|[
literal|0
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|has_colors
argument_list|()
condition|)
block|{
name|start_color
argument_list|()
expr_stmt|;
if|if
condition|(
name|form
operator|->
name|color_table
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|form
operator|->
name|color_table
index|[
name|i
index|]
operator|.
name|f
operator|!=
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|init_pair
argument_list|(
name|i
operator|+
literal|1
argument_list|,
name|form
operator|->
name|color_table
index|[
name|i
index|]
operator|.
name|f
argument_list|,
name|form
operator|->
name|color_table
index|[
name|i
index|]
operator|.
name|b
argument_list|)
expr_stmt|;
block|}
block|}
name|cbreak
argument_list|()
expr_stmt|;
name|noecho
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|form
operator|->
name|height
condition|)
name|form
operator|->
name|height
operator|=
name|LINES
expr_stmt|;
if|if
condition|(
operator|!
name|form
operator|->
name|width
condition|)
name|form
operator|->
name|width
operator|=
name|COLS
expr_stmt|;
name|form
operator|->
name|window
operator|=
name|newwin
argument_list|(
name|form
operator|->
name|height
argument_list|,
name|form
operator|->
name|width
argument_list|,
name|form
operator|->
name|y
argument_list|,
name|form
operator|->
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|form
operator|->
name|window
condition|)
block|{
name|print_status
argument_list|(
literal|"Couldn't open window, closing form"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERR
operator|)
return|;
block|}
name|form
operator|->
name|no_fields
operator|=
literal|0
expr_stmt|;
name|keypad
argument_list|(
name|form
operator|->
name|window
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
while|while
condition|(
name|field
operator|->
name|type
operator|!=
name|F_END
condition|)
block|{
if|if
condition|(
name|field
operator|->
name|type
operator|==
name|F_INPUT
condition|)
block|{
name|field
operator|->
name|field
operator|.
name|input
operator|->
name|input
operator|=
name|malloc
argument_list|(
name|field
operator|->
name|field
operator|.
name|input
operator|->
name|limit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|field
operator|->
name|field
operator|.
name|input
operator|->
name|input
condition|)
block|{
name|print_status
argument_list|(
literal|"Couldn't allocate memory, closing form"
argument_list|)
expr_stmt|;
name|endfrm
argument_list|(
name|form
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERR
operator|)
return|;
block|}
comment|/* 			 * If it's a label then clear the input string 			 * otherwise copy the default string to the input string. 			 */
if|if
condition|(
name|field
operator|->
name|field
operator|.
name|input
operator|->
name|lbl_flag
condition|)
name|field
operator|->
name|field
operator|.
name|input
operator|->
name|input
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
elseif|else
if|if
condition|(
name|field
operator|->
name|field
operator|.
name|input
operator|->
name|label
condition|)
block|{
name|strncpy
argument_list|(
name|field
operator|->
name|field
operator|.
name|input
operator|->
name|input
argument_list|,
name|field
operator|->
name|field
operator|.
name|input
operator|->
name|label
argument_list|,
name|field
operator|->
name|field
operator|.
name|input
operator|->
name|limit
argument_list|)
expr_stmt|;
name|field
operator|->
name|field
operator|.
name|input
operator|->
name|input
index|[
name|field
operator|->
name|field
operator|.
name|input
operator|->
name|limit
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|field
operator|->
name|type
operator|!=
name|F_TEXT
operator|)
operator|&&
operator|(
name|field
operator|->
name|type
operator|!=
name|F_MENU
operator|)
operator|&&
operator|(
name|field
operator|->
name|type
operator|!=
name|F_ACTION
operator|)
condition|)
block|{
name|print_status
argument_list|(
literal|"Unknown field type, closing form"
argument_list|)
expr_stmt|;
name|endfrm
argument_list|(
name|form
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERR
operator|)
return|;
block|}
name|form
operator|->
name|no_fields
operator|++
expr_stmt|;
name|field
operator|=
operator|&
name|form
operator|->
name|field
index|[
name|form
operator|->
name|no_fields
index|]
expr_stmt|;
block|}
name|form
operator|->
name|current_field
operator|=
name|form
operator|->
name|start_field
expr_stmt|;
name|show_form
argument_list|(
name|form
argument_list|)
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
end_function

begin_function
name|void
name|endfrm
parameter_list|(
name|struct
name|form
modifier|*
name|form
parameter_list|)
block|{
name|struct
name|field
modifier|*
name|field
init|=
operator|&
name|form
operator|->
name|field
index|[
literal|0
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|delwin
argument_list|(
name|form
operator|->
name|window
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|form
operator|->
name|no_fields
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|field
operator|->
name|type
operator|==
name|F_INPUT
condition|)
name|free
argument_list|(
name|field
operator|->
name|field
operator|.
name|input
operator|->
name|input
argument_list|)
expr_stmt|;
name|field
operator|=
operator|&
name|form
operator|->
name|field
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|update_form
parameter_list|(
name|struct
name|form
modifier|*
name|form
parameter_list|)
block|{
name|show_form
argument_list|(
name|form
argument_list|)
expr_stmt|;
if|if
condition|(
name|form
operator|->
name|current_field
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|F_CANCEL
operator|)
return|;
name|wattrset
argument_list|(
name|form
operator|->
name|window
argument_list|,
name|form
operator|->
name|field
index|[
name|form
operator|->
name|current_field
index|]
operator|.
name|selattr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|form
operator|->
name|field
index|[
name|form
operator|->
name|current_field
index|]
operator|.
name|type
condition|)
block|{
case|case
name|F_MENU
case|:
name|field_menu
argument_list|(
name|form
argument_list|)
expr_stmt|;
break|break;
case|case
name|F_INPUT
case|:
name|field_input
argument_list|(
name|form
argument_list|)
expr_stmt|;
break|break;
case|case
name|F_ACTION
case|:
name|field_action
argument_list|(
name|form
argument_list|)
expr_stmt|;
break|break;
case|case
name|F_TEXT
case|:
default|default:
name|print_status
argument_list|(
literal|"Error, current field is invalid"
argument_list|)
expr_stmt|;
return|return
operator|(
name|F_CANCEL
operator|)
return|;
block|}
name|wattrset
argument_list|(
name|form
operator|->
name|window
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|done
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|show_form
parameter_list|(
name|struct
name|form
modifier|*
name|form
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|wattrset
argument_list|(
name|form
operator|->
name|window
argument_list|,
name|form
operator|->
name|attr
argument_list|)
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|form
operator|->
name|height
condition|;
name|y
operator|++
control|)
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|form
operator|->
name|width
condition|;
name|x
operator|++
control|)
name|mvwaddch
argument_list|(
name|form
operator|->
name|window
argument_list|,
name|y
argument_list|,
name|x
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|form
operator|->
name|no_fields
condition|;
name|i
operator|++
control|)
block|{
name|wattrset
argument_list|(
name|form
operator|->
name|window
argument_list|,
name|form
operator|->
name|field
index|[
name|i
index|]
operator|.
name|attr
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|form
operator|->
name|window
argument_list|,
name|form
operator|->
name|field
index|[
name|i
index|]
operator|.
name|y
argument_list|,
name|form
operator|->
name|field
index|[
name|i
index|]
operator|.
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|form
operator|->
name|field
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
case|case
name|F_TEXT
case|:
name|disp_text
argument_list|(
name|form
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|F_MENU
case|:
name|disp_menu
argument_list|(
name|form
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|F_INPUT
case|:
name|disp_input
argument_list|(
name|form
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|F_ACTION
case|:
name|disp_action
argument_list|(
name|form
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|F_END
case|:
default|default:
break|break;
block|}
block|}
name|wattrset
argument_list|(
name|form
operator|->
name|window
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|form
operator|->
name|window
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|disp_text
parameter_list|(
name|struct
name|form
modifier|*
name|form
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|struct
name|field
modifier|*
name|field
init|=
operator|&
name|form
operator|->
name|field
index|[
name|index
index|]
decl_stmt|;
if|if
condition|(
name|print_string
argument_list|(
name|form
operator|->
name|window
argument_list|,
name|field
operator|->
name|y
argument_list|,
name|field
operator|->
name|x
argument_list|,
name|field
operator|->
name|height
argument_list|,
name|field
operator|->
name|width
argument_list|,
name|field
operator|->
name|field
operator|.
name|text
operator|->
name|text
argument_list|)
operator|==
name|ERR
condition|)
name|print_status
argument_list|(
literal|"Illegal scroll in print_string"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|disp_input
parameter_list|(
name|struct
name|form
modifier|*
name|form
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|struct
name|field
modifier|*
name|field
init|=
operator|&
name|form
operator|->
name|field
index|[
name|index
index|]
decl_stmt|;
if|if
condition|(
name|field
operator|->
name|field
operator|.
name|input
operator|->
name|lbl_flag
condition|)
block|{
if|if
condition|(
name|print_string
argument_list|(
name|form
operator|->
name|window
argument_list|,
name|field
operator|->
name|y
argument_list|,
name|field
operator|->
name|x
argument_list|,
name|field
operator|->
name|height
argument_list|,
name|field
operator|->
name|width
argument_list|,
name|field
operator|->
name|field
operator|.
name|input
operator|->
name|label
argument_list|)
operator|==
name|ERR
condition|)
name|print_status
argument_list|(
literal|"Illegal scroll in print_string"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|print_string
argument_list|(
name|form
operator|->
name|window
argument_list|,
name|field
operator|->
name|y
argument_list|,
name|field
operator|->
name|x
argument_list|,
name|field
operator|->
name|height
argument_list|,
name|field
operator|->
name|width
argument_list|,
name|field
operator|->
name|field
operator|.
name|input
operator|->
name|input
argument_list|)
operator|==
name|ERR
condition|)
name|print_status
argument_list|(
literal|"Illegal scroll in print_string"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|disp_menu
parameter_list|(
name|struct
name|form
modifier|*
name|form
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|struct
name|field
modifier|*
name|field
init|=
operator|&
name|form
operator|->
name|field
index|[
name|index
index|]
decl_stmt|;
if|if
condition|(
name|print_string
argument_list|(
name|form
operator|->
name|window
argument_list|,
name|field
operator|->
name|y
argument_list|,
name|field
operator|->
name|x
argument_list|,
name|field
operator|->
name|height
argument_list|,
name|field
operator|->
name|width
argument_list|,
name|field
operator|->
name|field
operator|.
name|menu
operator|->
name|options
index|[
name|field
operator|->
name|field
operator|.
name|menu
operator|->
name|selected
index|]
argument_list|)
operator|==
name|ERR
condition|)
name|print_status
argument_list|(
literal|"Illegal scroll in print_string"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|disp_action
parameter_list|(
name|struct
name|form
modifier|*
name|form
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|struct
name|field
modifier|*
name|field
init|=
operator|&
name|form
operator|->
name|field
index|[
name|index
index|]
decl_stmt|;
if|if
condition|(
name|print_string
argument_list|(
name|form
operator|->
name|window
argument_list|,
name|field
operator|->
name|y
argument_list|,
name|field
operator|->
name|x
argument_list|,
name|field
operator|->
name|height
argument_list|,
name|field
operator|->
name|width
argument_list|,
name|field
operator|->
name|field
operator|.
name|action
operator|->
name|text
argument_list|)
operator|==
name|ERR
condition|)
name|print_status
argument_list|(
literal|"Illegal scroll in print_string"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|field_action
parameter_list|(
name|struct
name|form
modifier|*
name|form
parameter_list|)
block|{
name|struct
name|field
modifier|*
name|field
init|=
operator|&
name|form
operator|->
name|field
index|[
name|form
operator|->
name|current_field
index|]
decl_stmt|;
name|int
name|ch
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|disp_action
argument_list|(
name|form
argument_list|,
name|form
operator|->
name|current_field
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|form
operator|->
name|window
argument_list|,
name|field
operator|->
name|y
argument_list|,
name|field
operator|->
name|x
argument_list|)
expr_stmt|;
name|ch
operator|=
name|wgetch
argument_list|(
name|form
operator|->
name|window
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|F_ACCEPT
condition|)
block|{
call|(
modifier|*
name|field
operator|->
name|field
operator|.
name|action
operator|->
name|fn
call|)
argument_list|()
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|next_field
argument_list|(
name|form
argument_list|,
name|ch
argument_list|)
condition|)
name|beep
argument_list|()
expr_stmt|;
else|else
return|return;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|field_menu
parameter_list|(
name|struct
name|form
modifier|*
name|form
parameter_list|)
block|{
name|struct
name|field
modifier|*
name|field
init|=
operator|&
name|form
operator|->
name|field
index|[
name|form
operator|->
name|current_field
index|]
decl_stmt|;
name|int
name|ch
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|disp_menu
argument_list|(
name|form
argument_list|,
name|form
operator|->
name|current_field
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|form
operator|->
name|window
argument_list|,
name|field
operator|->
name|y
argument_list|,
name|field
operator|->
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ch
operator|=
name|wgetch
argument_list|(
name|form
operator|->
name|window
argument_list|)
condition|)
block|{
case|case
literal|' '
case|:
name|print_status
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|field
operator|->
name|field
operator|.
name|menu
operator|->
name|selected
operator|++
expr_stmt|;
if|if
condition|(
name|field
operator|->
name|field
operator|.
name|menu
operator|->
name|selected
operator|>=
name|field
operator|->
name|field
operator|.
name|menu
operator|->
name|no_options
condition|)
name|field
operator|->
name|field
operator|.
name|menu
operator|->
name|selected
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
name|next_field
argument_list|(
name|form
argument_list|,
name|ch
argument_list|)
condition|)
block|{
name|print_status
argument_list|(
literal|"Hit the space bar to toggle through options"
argument_list|)
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
block|}
else|else
return|return;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|next_field
parameter_list|(
name|struct
name|form
modifier|*
name|form
parameter_list|,
name|int
name|ch
parameter_list|)
block|{
name|struct
name|field
modifier|*
name|field
init|=
operator|&
name|form
operator|->
name|field
index|[
name|form
operator|->
name|current_field
index|]
decl_stmt|;
if|if
condition|(
name|ch
operator|==
name|F_UP
condition|)
block|{
if|if
condition|(
name|field
operator|->
name|up
operator|==
operator|-
literal|1
condition|)
block|{
name|print_status
argument_list|(
literal|"Can't go up from here"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
name|form
operator|->
name|current_field
operator|=
name|field
operator|->
name|up
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|F_DOWN
condition|)
block|{
if|if
condition|(
name|field
operator|->
name|down
operator|==
operator|-
literal|1
condition|)
block|{
name|print_status
argument_list|(
literal|"Can't go down from here"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
name|form
operator|->
name|current_field
operator|=
name|field
operator|->
name|down
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|F_NEXT
condition|)
block|{
if|if
condition|(
name|field
operator|->
name|next
operator|==
operator|-
literal|1
condition|)
block|{
name|print_status
argument_list|(
literal|"Can't go to next from here"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
name|form
operator|->
name|current_field
operator|=
name|field
operator|->
name|next
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|F_RIGHT
condition|)
block|{
if|if
condition|(
name|field
operator|->
name|right
operator|==
operator|-
literal|1
condition|)
block|{
name|print_status
argument_list|(
literal|"Can't go right from here"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
name|form
operator|->
name|current_field
operator|=
name|field
operator|->
name|right
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|F_LEFT
condition|)
block|{
if|if
condition|(
name|field
operator|->
name|left
operator|==
operator|-
literal|1
condition|)
block|{
name|print_status
argument_list|(
literal|"Can't go left from here"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
name|form
operator|->
name|current_field
operator|=
name|field
operator|->
name|left
expr_stmt|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
name|print_status
argument_list|(
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|print_string
parameter_list|(
name|WINDOW
modifier|*
name|window
parameter_list|,
name|int
name|y
parameter_list|,
name|int
name|x
parameter_list|,
name|int
name|height
parameter_list|,
name|int
name|fwidth
parameter_list|,
name|char
modifier|*
name|string
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|int
name|width
decl_stmt|;
if|if
condition|(
operator|!
name|string
condition|)
name|len
operator|=
operator|-
literal|1
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|wmove
argument_list|(
name|window
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
operator|==
name|ERR
condition|)
return|return
operator|(
name|ERR
operator|)
return|;
while|while
condition|(
name|height
operator|--
condition|)
block|{
name|width
operator|=
name|fwidth
expr_stmt|;
while|while
condition|(
name|width
operator|--
condition|)
block|{
if|if
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|waddch
argument_list|(
name|window
argument_list|,
operator|*
name|string
operator|++
argument_list|)
operator|==
name|ERR
condition|)
return|return
operator|(
name|ERR
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|waddch
argument_list|(
name|window
argument_list|,
literal|' '
argument_list|)
operator|==
name|ERR
condition|)
return|return
operator|(
name|ERR
operator|)
return|;
block|}
if|if
condition|(
name|wmove
argument_list|(
name|window
argument_list|,
operator|++
name|y
argument_list|,
name|x
argument_list|)
operator|==
name|ERR
condition|)
return|return
operator|(
name|ERR
operator|)
return|;
block|}
return|return
operator|(
name|OK
operator|)
return|;
block|}
end_function

begin_function
name|void
name|print_status
parameter_list|(
name|char
modifier|*
name|msg
parameter_list|)
block|{
if|if
condition|(
name|wmove
argument_list|(
name|stdscr
argument_list|,
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
operator|==
name|ERR
condition|)
block|{
name|endwin
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|wclrtoeol
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
name|wstandout
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
if|if
condition|(
name|wprintw
argument_list|(
name|stdscr
argument_list|,
literal|"%s"
argument_list|,
name|msg
argument_list|)
operator|==
name|ERR
condition|)
block|{
name|endwin
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|wstandend
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|field_input
parameter_list|(
name|struct
name|form
modifier|*
name|form
parameter_list|)
block|{
name|struct
name|field
modifier|*
name|field
init|=
operator|&
name|form
operator|->
name|field
index|[
name|form
operator|->
name|current_field
index|]
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|int
name|disp_off
init|=
literal|0
decl_stmt|,
name|abspos
init|=
literal|0
decl_stmt|,
name|cursor
init|=
literal|0
decl_stmt|;
define|#
directive|define
name|DISPOFF
value|((len< field->width) ? 0 : len - field->width)
define|#
directive|define
name|CURSPOS
value|((len< field->width) ? len : field->width)
name|len
operator|=
name|strlen
argument_list|(
name|field
operator|->
name|field
operator|.
name|input
operator|->
name|input
argument_list|)
expr_stmt|;
name|disp_input
argument_list|(
name|form
argument_list|,
name|form
operator|->
name|current_field
argument_list|)
expr_stmt|;
name|cursor
operator|=
name|CURSPOS
expr_stmt|;
name|abspos
operator|=
name|cursor
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|wmove
argument_list|(
name|form
operator|->
name|window
argument_list|,
name|field
operator|->
name|y
argument_list|,
name|field
operator|->
name|x
operator|+
name|cursor
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|form
operator|->
name|window
argument_list|)
expr_stmt|;
name|ch
operator|=
name|wgetch
argument_list|(
name|form
operator|->
name|window
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_field
argument_list|(
name|form
argument_list|,
name|ch
argument_list|)
condition|)
block|{
name|print_string
argument_list|(
name|form
operator|->
name|window
argument_list|,
name|field
operator|->
name|y
argument_list|,
name|field
operator|->
name|x
argument_list|,
name|field
operator|->
name|height
argument_list|,
name|field
operator|->
name|width
argument_list|,
name|field
operator|->
name|field
operator|.
name|input
operator|->
name|input
operator|+
name|DISPOFF
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|field
operator|->
name|field
operator|.
name|input
operator|->
name|lbl_flag
condition|)
block|{
name|field
operator|->
name|field
operator|.
name|input
operator|->
name|lbl_flag
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ch
operator|==
name|F_CHOME
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'
literal|'
operator|)
condition|)
block|{
name|disp_off
operator|=
literal|0
expr_stmt|;
name|cursor
operator|=
literal|0
expr_stmt|;
name|abspos
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ch
operator|==
name|F_CEND
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'
literal|'
operator|)
condition|)
block|{
name|disp_off
operator|=
name|DISPOFF
expr_stmt|;
name|abspos
operator|=
name|len
expr_stmt|;
name|cursor
operator|=
name|CURSPOS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
name|F_CDEL
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|len
operator|-
name|abspos
operator|)
condition|)
name|beep
argument_list|()
expr_stmt|;
else|else
block|{
name|bcopy
argument_list|(
name|field
operator|->
name|field
operator|.
name|input
operator|->
name|input
operator|+
name|abspos
operator|+
literal|1
argument_list|,
name|field
operator|->
name|field
operator|.
name|input
operator|->
name|input
operator|+
name|abspos
argument_list|,
name|len
operator|-
name|abspos
argument_list|)
expr_stmt|;
operator|--
name|len
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ch
operator|==
name|F_CLEFT
operator|)
operator|||
operator|(
name|ch
operator|==
name|F_CBS
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'
literal|'
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|abspos
condition|)
name|beep
argument_list|()
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ch
operator|==
name|F_CBS
condition|)
block|{
name|bcopy
argument_list|(
name|field
operator|->
name|field
operator|.
name|input
operator|->
name|input
operator|+
name|abspos
argument_list|,
name|field
operator|->
name|field
operator|.
name|input
operator|->
name|input
operator|+
name|abspos
operator|-
literal|1
argument_list|,
name|len
operator|-
name|abspos
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|--
name|len
expr_stmt|;
block|}
operator|--
name|abspos
expr_stmt|;
operator|--
name|cursor
expr_stmt|;
if|if
condition|(
operator|(
name|disp_off
operator|)
operator|&&
operator|(
name|cursor
operator|<
literal|0
operator|)
condition|)
block|{
operator|--
name|disp_off
expr_stmt|;
operator|++
name|cursor
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ch
operator|==
name|F_CRIGHT
operator|)
operator|||
operator|(
name|ch
operator|==
literal|'
literal|'
operator|)
condition|)
block|{
if|if
condition|(
name|abspos
operator|==
name|len
condition|)
name|beep
argument_list|()
expr_stmt|;
else|else
block|{
operator|++
name|abspos
expr_stmt|;
if|if
condition|(
operator|++
name|cursor
operator|==
name|field
operator|->
name|width
condition|)
block|{
operator|++
name|disp_off
expr_stmt|;
operator|--
name|cursor
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|isprint
argument_list|(
name|ch
argument_list|)
operator|)
operator|&&
operator|(
name|len
operator|<
name|field
operator|->
name|field
operator|.
name|input
operator|->
name|limit
operator|)
condition|)
block|{
name|bcopy
argument_list|(
name|field
operator|->
name|field
operator|.
name|input
operator|->
name|input
operator|+
name|abspos
argument_list|,
name|field
operator|->
name|field
operator|.
name|input
operator|->
name|input
operator|+
name|abspos
operator|+
literal|1
argument_list|,
name|len
operator|-
name|abspos
operator|+
literal|1
argument_list|)
expr_stmt|;
name|field
operator|->
name|field
operator|.
name|input
operator|->
name|input
index|[
name|abspos
operator|++
index|]
operator|=
name|ch
expr_stmt|;
name|len
operator|++
expr_stmt|;
if|if
condition|(
operator|++
name|cursor
operator|>
name|field
operator|->
name|width
condition|)
block|{
operator|++
name|disp_off
expr_stmt|;
operator|--
name|cursor
expr_stmt|;
block|}
block|}
else|else
block|{
name|beep
argument_list|()
expr_stmt|;
block|}
name|print_string
argument_list|(
name|form
operator|->
name|window
argument_list|,
name|field
operator|->
name|y
argument_list|,
name|field
operator|->
name|x
argument_list|,
name|field
operator|->
name|height
argument_list|,
name|field
operator|->
name|width
argument_list|,
name|field
operator|->
name|field
operator|.
name|input
operator|->
name|input
operator|+
name|disp_off
argument_list|)
expr_stmt|;
block|}
comment|/* Not Reached */
block|}
end_function

begin_function
name|void
name|exit_form
parameter_list|(
name|void
parameter_list|)
block|{
name|done
operator|=
name|F_DONE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cancel_form
parameter_list|(
name|void
parameter_list|)
block|{
name|done
operator|=
name|F_CANCEL
expr_stmt|;
block|}
end_function

end_unit

