begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//======- CFLGraph.h - Abstract stratified sets implementation. --------======//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|/// \file
end_comment

begin_comment
comment|/// This file defines CFLGraph, an auxiliary data structure used by CFL-based
end_comment

begin_comment
comment|/// alias analysis.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ANALYSIS_CFLGRAPH_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ANALYSIS_CFLGRAPH_H
end_define

begin_include
include|#
directive|include
file|"AliasAnalysisSummary.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallPtrSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Analysis/MemoryBuiltins.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/InstVisitor.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Instructions.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|namespace
name|cflaa
block|{
comment|/// \brief The Program Expression Graph (PEG) of CFL analysis
comment|/// CFLGraph is auxiliary data structure used by CFL-based alias analysis to
comment|/// describe flow-insensitive pointer-related behaviors. Given an LLVM function,
comment|/// the main purpose of this graph is to abstract away unrelated facts and
comment|/// translate the rest into a form that can be easily digested by CFL analyses.
comment|/// Each Node in the graph is an InstantiatedValue, and each edge represent a
comment|/// pointer assignment between InstantiatedValue. Pointer
comment|/// references/dereferences are not explicitly stored in the graph: we
comment|/// implicitly assume that for each node (X, I) it has a dereference edge to (X,
comment|/// I+1) and a reference edge to (X, I-1).
name|class
name|CFLGraph
block|{
name|public
label|:
typedef|typedef
name|InstantiatedValue
name|Node
typedef|;
struct|struct
name|Edge
block|{
name|Node
name|Other
decl_stmt|;
block|}
struct|;
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|Edge
operator|>
name|EdgeList
expr_stmt|;
struct|struct
name|NodeInfo
block|{
name|EdgeList
name|Edges
decl_stmt|,
name|ReverseEdges
decl_stmt|;
name|AliasAttrs
name|Attr
decl_stmt|;
block|}
struct|;
name|class
name|ValueInfo
block|{
name|std
operator|::
name|vector
operator|<
name|NodeInfo
operator|>
name|Levels
expr_stmt|;
name|public
label|:
name|bool
name|addNodeToLevel
parameter_list|(
name|unsigned
name|Level
parameter_list|)
block|{
name|auto
name|NumLevels
init|=
name|Levels
operator|.
name|size
argument_list|()
decl_stmt|;
if|if
condition|(
name|NumLevels
operator|>
name|Level
condition|)
return|return
name|false
return|;
name|Levels
operator|.
name|resize
argument_list|(
name|Level
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|NodeInfo
modifier|&
name|getNodeInfoAtLevel
parameter_list|(
name|unsigned
name|Level
parameter_list|)
block|{
name|assert
argument_list|(
name|Level
operator|<
name|Levels
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|Levels
index|[
name|Level
index|]
return|;
block|}
specifier|const
name|NodeInfo
modifier|&
name|getNodeInfoAtLevel
argument_list|(
name|unsigned
name|Level
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|Level
operator|<
name|Levels
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|Levels
index|[
name|Level
index|]
return|;
block|}
name|unsigned
name|getNumLevels
argument_list|()
specifier|const
block|{
return|return
name|Levels
operator|.
name|size
argument_list|()
return|;
block|}
block|}
empty_stmt|;
name|private
label|:
typedef|typedef
name|DenseMap
operator|<
name|Value
operator|*
operator|,
name|ValueInfo
operator|>
name|ValueMap
expr_stmt|;
name|ValueMap
name|ValueImpls
decl_stmt|;
name|NodeInfo
modifier|*
name|getNode
parameter_list|(
name|Node
name|N
parameter_list|)
block|{
name|auto
name|Itr
init|=
name|ValueImpls
operator|.
name|find
argument_list|(
name|N
operator|.
name|Val
argument_list|)
decl_stmt|;
if|if
condition|(
name|Itr
operator|==
name|ValueImpls
operator|.
name|end
argument_list|()
operator|||
name|Itr
operator|->
name|second
operator|.
name|getNumLevels
argument_list|()
operator|<=
name|N
operator|.
name|DerefLevel
condition|)
return|return
name|nullptr
return|;
return|return
operator|&
name|Itr
operator|->
name|second
operator|.
name|getNodeInfoAtLevel
argument_list|(
name|N
operator|.
name|DerefLevel
argument_list|)
return|;
block|}
name|public
label|:
typedef|typedef
name|ValueMap
operator|::
name|const_iterator
name|const_value_iterator
expr_stmt|;
name|bool
name|addNode
parameter_list|(
name|Node
name|N
parameter_list|,
name|AliasAttrs
name|Attr
init|=
name|AliasAttrs
argument_list|()
parameter_list|)
block|{
name|assert
argument_list|(
name|N
operator|.
name|Val
operator|!=
name|nullptr
argument_list|)
expr_stmt|;
name|auto
operator|&
name|ValInfo
operator|=
name|ValueImpls
index|[
name|N
operator|.
name|Val
index|]
expr_stmt|;
name|auto
name|Changed
init|=
name|ValInfo
operator|.
name|addNodeToLevel
argument_list|(
name|N
operator|.
name|DerefLevel
argument_list|)
decl_stmt|;
name|ValInfo
operator|.
name|getNodeInfoAtLevel
argument_list|(
name|N
operator|.
name|DerefLevel
argument_list|)
operator|.
name|Attr
operator||=
name|Attr
expr_stmt|;
return|return
name|Changed
return|;
block|}
name|void
name|addAttr
parameter_list|(
name|Node
name|N
parameter_list|,
name|AliasAttrs
name|Attr
parameter_list|)
block|{
name|auto
operator|*
name|Info
operator|=
name|getNode
argument_list|(
name|N
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|Info
operator|!=
name|nullptr
argument_list|)
expr_stmt|;
name|Info
operator|->
name|Attr
operator||=
name|Attr
expr_stmt|;
block|}
name|void
name|addEdge
parameter_list|(
name|Node
name|From
parameter_list|,
name|Node
name|To
parameter_list|,
name|int64_t
name|Offset
init|=
literal|0
parameter_list|)
block|{
name|auto
operator|*
name|FromInfo
operator|=
name|getNode
argument_list|(
name|From
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|FromInfo
operator|!=
name|nullptr
argument_list|)
expr_stmt|;
name|auto
operator|*
name|ToInfo
operator|=
name|getNode
argument_list|(
name|To
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ToInfo
operator|!=
name|nullptr
argument_list|)
expr_stmt|;
name|FromInfo
operator|->
name|Edges
operator|.
name|push_back
argument_list|(
name|Edge
block|{
name|To
block|}
argument_list|)
expr_stmt|;
name|ToInfo
operator|->
name|ReverseEdges
operator|.
name|push_back
argument_list|(
name|Edge
block|{
name|From
block|}
argument_list|)
expr_stmt|;
block|}
specifier|const
name|NodeInfo
modifier|*
name|getNode
argument_list|(
name|Node
name|N
argument_list|)
decl|const
block|{
name|auto
name|Itr
init|=
name|ValueImpls
operator|.
name|find
argument_list|(
name|N
operator|.
name|Val
argument_list|)
decl_stmt|;
if|if
condition|(
name|Itr
operator|==
name|ValueImpls
operator|.
name|end
argument_list|()
operator|||
name|Itr
operator|->
name|second
operator|.
name|getNumLevels
argument_list|()
operator|<=
name|N
operator|.
name|DerefLevel
condition|)
return|return
name|nullptr
return|;
return|return
operator|&
name|Itr
operator|->
name|second
operator|.
name|getNodeInfoAtLevel
argument_list|(
name|N
operator|.
name|DerefLevel
argument_list|)
return|;
block|}
name|AliasAttrs
name|attrFor
argument_list|(
name|Node
name|N
argument_list|)
decl|const
block|{
name|auto
operator|*
name|Info
operator|=
name|getNode
argument_list|(
name|N
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|Info
operator|!=
name|nullptr
argument_list|)
expr_stmt|;
return|return
name|Info
operator|->
name|Attr
return|;
block|}
name|iterator_range
operator|<
name|const_value_iterator
operator|>
name|value_mappings
argument_list|()
specifier|const
block|{
return|return
name|make_range
operator|<
name|const_value_iterator
operator|>
operator|(
name|ValueImpls
operator|.
name|begin
argument_list|()
operator|,
name|ValueImpls
operator|.
name|end
argument_list|()
operator|)
return|;
block|}
block|}
empty_stmt|;
comment|///\brief A builder class used to create CFLGraph instance from a given function
comment|/// The CFL-AA that uses this builder must provide its own type as a template
comment|/// argument. This is necessary for interprocedural processing: CFLGraphBuilder
comment|/// needs a way of obtaining the summary of other functions when callinsts are
comment|/// encountered.
comment|/// As a result, we expect the said CFL-AA to expose a getAliasSummary() public
comment|/// member function that takes a Function& and returns the corresponding summary
comment|/// as a const AliasSummary*.
name|template
operator|<
name|typename
name|CFLAA
operator|>
name|class
name|CFLGraphBuilder
block|{
comment|// Input of the builder
name|CFLAA
operator|&
name|Analysis
block|;
specifier|const
name|TargetLibraryInfo
operator|&
name|TLI
block|;
comment|// Output of the builder
name|CFLGraph
name|Graph
block|;
name|SmallVector
operator|<
name|Value
operator|*
block|,
literal|4
operator|>
name|ReturnedValues
block|;
comment|// Helper class
comment|/// Gets the edges our graph should have, based on an Instruction*
name|class
name|GetEdgesVisitor
operator|:
name|public
name|InstVisitor
operator|<
name|GetEdgesVisitor
block|,
name|void
operator|>
block|{
name|CFLAA
operator|&
name|AA
block|;
specifier|const
name|TargetLibraryInfo
operator|&
name|TLI
block|;
name|CFLGraph
operator|&
name|Graph
block|;
name|SmallVectorImpl
operator|<
name|Value
operator|*
operator|>
operator|&
name|ReturnValues
block|;
specifier|static
name|bool
name|hasUsefulEdges
argument_list|(
argument|ConstantExpr *CE
argument_list|)
block|{
comment|// ConstantExpr doesn't have terminators, invokes, or fences, so only
comment|// needs
comment|// to check for compares.
return|return
name|CE
operator|->
name|getOpcode
argument_list|()
operator|!=
name|Instruction
operator|::
name|ICmp
operator|&&
name|CE
operator|->
name|getOpcode
argument_list|()
operator|!=
name|Instruction
operator|::
name|FCmp
return|;
block|}
comment|// Returns possible functions called by CS into the given SmallVectorImpl.
comment|// Returns true if targets found, false otherwise.
specifier|static
name|bool
name|getPossibleTargets
argument_list|(
argument|CallSite CS
argument_list|,
argument|SmallVectorImpl<Function *>&Output
argument_list|)
block|{
if|if
condition|(
name|auto
operator|*
name|Fn
operator|=
name|CS
operator|.
name|getCalledFunction
argument_list|()
condition|)
block|{
name|Output
operator|.
name|push_back
argument_list|(
name|Fn
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
comment|// TODO: If the call is indirect, we might be able to enumerate all
comment|// potential
comment|// targets of the call and return them, rather than just failing.
return|return
name|false
return|;
block|}
name|void
name|addNode
argument_list|(
argument|Value *Val
argument_list|,
argument|AliasAttrs Attr = AliasAttrs()
argument_list|)
block|{
name|assert
argument_list|(
name|Val
operator|!=
name|nullptr
operator|&&
name|Val
operator|->
name|getType
argument_list|()
operator|->
name|isPointerTy
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|auto
name|GVal
init|=
name|dyn_cast
operator|<
name|GlobalValue
operator|>
operator|(
name|Val
operator|)
condition|)
block|{
if|if
condition|(
name|Graph
operator|.
name|addNode
argument_list|(
name|InstantiatedValue
block|{
name|GVal
operator|,
literal|0
block|}
operator|,
name|getGlobalOrArgAttrFromValue
argument_list|(
operator|*
name|GVal
argument_list|)
block|)
block|)
name|Graph
operator|.
name|addNode
argument_list|(
name|InstantiatedValue
block|{
name|GVal
block|,
literal|1
block|}
argument_list|,
name|getAttrUnknown
argument_list|()
argument_list|)
block|;       }
elseif|else
if|if
condition|(
name|auto
name|CExpr
init|=
name|dyn_cast
operator|<
name|ConstantExpr
operator|>
operator|(
name|Val
operator|)
condition|)
block|{
if|if
condition|(
name|hasUsefulEdges
argument_list|(
name|CExpr
argument_list|)
condition|)
block|{
if|if
condition|(
name|Graph
operator|.
name|addNode
argument_list|(
name|InstantiatedValue
block|{
name|CExpr
operator|,
literal|0
block|}
block|)
block|)
name|visitConstantExpr
argument_list|(
name|CExpr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|Graph
operator|.
name|addNode
argument_list|(
name|InstantiatedValue
block|{
name|Val
block|,
literal|0
block|}
argument_list|,
name|Attr
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|void
name|addAssignEdge
parameter_list|(
name|Value
modifier|*
name|From
parameter_list|,
name|Value
modifier|*
name|To
parameter_list|,
name|int64_t
name|Offset
init|=
literal|0
parameter_list|)
block|{
name|assert
argument_list|(
name|From
operator|!=
name|nullptr
operator|&&
name|To
operator|!=
name|nullptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|From
operator|->
name|getType
argument_list|()
operator|->
name|isPointerTy
argument_list|()
operator|||
operator|!
name|To
operator|->
name|getType
argument_list|()
operator|->
name|isPointerTy
argument_list|()
condition|)
return|return;
name|addNode
argument_list|(
name|From
argument_list|)
expr_stmt|;
if|if
condition|(
name|To
operator|!=
name|From
condition|)
block|{
name|addNode
argument_list|(
name|To
argument_list|)
expr_stmt|;
name|Graph
operator|.
name|addEdge
argument_list|(
name|InstantiatedValue
block|{
name|From
block|,
literal|0
block|}
argument_list|,
name|InstantiatedValue
block|{
name|To
block|,
literal|0
block|}
argument_list|,
name|Offset
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|addDerefEdge
parameter_list|(
name|Value
modifier|*
name|From
parameter_list|,
name|Value
modifier|*
name|To
parameter_list|,
name|bool
name|IsRead
parameter_list|)
block|{
name|assert
argument_list|(
name|From
operator|!=
name|nullptr
operator|&&
name|To
operator|!=
name|nullptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|From
operator|->
name|getType
argument_list|()
operator|->
name|isPointerTy
argument_list|()
operator|||
operator|!
name|To
operator|->
name|getType
argument_list|()
operator|->
name|isPointerTy
argument_list|()
condition|)
return|return;
name|addNode
argument_list|(
name|From
argument_list|)
expr_stmt|;
name|addNode
argument_list|(
name|To
argument_list|)
expr_stmt|;
if|if
condition|(
name|IsRead
condition|)
block|{
name|Graph
operator|.
name|addNode
argument_list|(
name|InstantiatedValue
block|{
name|From
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|Graph
operator|.
name|addEdge
argument_list|(
name|InstantiatedValue
block|{
name|From
block|,
literal|1
block|}
argument_list|,
name|InstantiatedValue
block|{
name|To
block|,
literal|0
block|}
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Graph
operator|.
name|addNode
argument_list|(
name|InstantiatedValue
block|{
name|To
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
name|Graph
operator|.
name|addEdge
argument_list|(
name|InstantiatedValue
block|{
name|From
block|,
literal|0
block|}
argument_list|,
name|InstantiatedValue
block|{
name|To
block|,
literal|1
block|}
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|addLoadEdge
parameter_list|(
name|Value
modifier|*
name|From
parameter_list|,
name|Value
modifier|*
name|To
parameter_list|)
block|{
name|addDerefEdge
argument_list|(
name|From
argument_list|,
name|To
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|addStoreEdge
parameter_list|(
name|Value
modifier|*
name|From
parameter_list|,
name|Value
modifier|*
name|To
parameter_list|)
block|{
name|addDerefEdge
argument_list|(
name|From
argument_list|,
name|To
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_label
name|public
label|:
end_label

begin_expr_stmt
name|GetEdgesVisitor
argument_list|(
name|CFLGraphBuilder
operator|&
name|Builder
argument_list|)
operator|:
name|AA
argument_list|(
name|Builder
operator|.
name|Analysis
argument_list|)
operator|,
name|TLI
argument_list|(
name|Builder
operator|.
name|TLI
argument_list|)
operator|,
name|Graph
argument_list|(
name|Builder
operator|.
name|Graph
argument_list|)
operator|,
name|ReturnValues
argument_list|(
argument|Builder.ReturnedValues
argument_list|)
block|{}
name|void
name|visitInstruction
argument_list|(
argument|Instruction&
argument_list|)
block|{
name|llvm_unreachable
argument_list|(
literal|"Unsupported instruction encountered"
argument_list|)
block|;     }
name|void
name|visitReturnInst
argument_list|(
argument|ReturnInst&Inst
argument_list|)
block|{
if|if
condition|(
name|auto
name|RetVal
init|=
name|Inst
operator|.
name|getReturnValue
argument_list|()
condition|)
block|{
if|if
condition|(
name|RetVal
operator|->
name|getType
argument_list|()
operator|->
name|isPointerTy
argument_list|()
condition|)
block|{
name|addNode
argument_list|(
name|RetVal
argument_list|)
expr_stmt|;
name|ReturnValues
operator|.
name|push_back
argument_list|(
name|RetVal
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_function
unit|}     }
name|void
name|visitPtrToIntInst
parameter_list|(
name|PtrToIntInst
modifier|&
name|Inst
parameter_list|)
block|{
name|auto
operator|*
name|Ptr
operator|=
name|Inst
operator|.
name|getOperand
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|addNode
argument_list|(
name|Ptr
argument_list|,
name|getAttrEscaped
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|visitIntToPtrInst
parameter_list|(
name|IntToPtrInst
modifier|&
name|Inst
parameter_list|)
block|{
name|auto
operator|*
name|Ptr
operator|=
operator|&
name|Inst
expr_stmt|;
name|addNode
argument_list|(
name|Ptr
argument_list|,
name|getAttrUnknown
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|visitCastInst
parameter_list|(
name|CastInst
modifier|&
name|Inst
parameter_list|)
block|{
name|auto
operator|*
name|Src
operator|=
name|Inst
operator|.
name|getOperand
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|addAssignEdge
argument_list|(
name|Src
argument_list|,
operator|&
name|Inst
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|visitBinaryOperator
parameter_list|(
name|BinaryOperator
modifier|&
name|Inst
parameter_list|)
block|{
name|auto
operator|*
name|Op1
operator|=
name|Inst
operator|.
name|getOperand
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|auto
operator|*
name|Op2
operator|=
name|Inst
operator|.
name|getOperand
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|addAssignEdge
argument_list|(
name|Op1
argument_list|,
operator|&
name|Inst
argument_list|)
expr_stmt|;
name|addAssignEdge
argument_list|(
name|Op2
argument_list|,
operator|&
name|Inst
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|visitAtomicCmpXchgInst
parameter_list|(
name|AtomicCmpXchgInst
modifier|&
name|Inst
parameter_list|)
block|{
name|auto
operator|*
name|Ptr
operator|=
name|Inst
operator|.
name|getPointerOperand
argument_list|()
expr_stmt|;
name|auto
operator|*
name|Val
operator|=
name|Inst
operator|.
name|getNewValOperand
argument_list|()
expr_stmt|;
name|addStoreEdge
argument_list|(
name|Val
argument_list|,
name|Ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|visitAtomicRMWInst
parameter_list|(
name|AtomicRMWInst
modifier|&
name|Inst
parameter_list|)
block|{
name|auto
operator|*
name|Ptr
operator|=
name|Inst
operator|.
name|getPointerOperand
argument_list|()
expr_stmt|;
name|auto
operator|*
name|Val
operator|=
name|Inst
operator|.
name|getValOperand
argument_list|()
expr_stmt|;
name|addStoreEdge
argument_list|(
name|Val
argument_list|,
name|Ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|visitPHINode
parameter_list|(
name|PHINode
modifier|&
name|Inst
parameter_list|)
block|{
for|for
control|(
name|Value
modifier|*
name|Val
range|:
name|Inst
operator|.
name|incoming_values
argument_list|()
control|)
name|addAssignEdge
argument_list|(
name|Val
argument_list|,
operator|&
name|Inst
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|visitGetElementPtrInst
parameter_list|(
name|GetElementPtrInst
modifier|&
name|Inst
parameter_list|)
block|{
name|auto
operator|*
name|Op
operator|=
name|Inst
operator|.
name|getPointerOperand
argument_list|()
expr_stmt|;
name|addAssignEdge
argument_list|(
name|Op
argument_list|,
operator|&
name|Inst
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|visitSelectInst
parameter_list|(
name|SelectInst
modifier|&
name|Inst
parameter_list|)
block|{
comment|// Condition is not processed here (The actual statement producing
comment|// the condition result is processed elsewhere). For select, the
comment|// condition is evaluated, but not loaded, stored, or assigned
comment|// simply as a result of being the condition of a select.
name|auto
operator|*
name|TrueVal
operator|=
name|Inst
operator|.
name|getTrueValue
argument_list|()
expr_stmt|;
name|auto
operator|*
name|FalseVal
operator|=
name|Inst
operator|.
name|getFalseValue
argument_list|()
expr_stmt|;
name|addAssignEdge
argument_list|(
name|TrueVal
argument_list|,
operator|&
name|Inst
argument_list|)
expr_stmt|;
name|addAssignEdge
argument_list|(
name|FalseVal
argument_list|,
operator|&
name|Inst
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|visitAllocaInst
parameter_list|(
name|AllocaInst
modifier|&
name|Inst
parameter_list|)
block|{
name|addNode
argument_list|(
operator|&
name|Inst
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|visitLoadInst
parameter_list|(
name|LoadInst
modifier|&
name|Inst
parameter_list|)
block|{
name|auto
operator|*
name|Ptr
operator|=
name|Inst
operator|.
name|getPointerOperand
argument_list|()
expr_stmt|;
name|auto
operator|*
name|Val
operator|=
operator|&
name|Inst
expr_stmt|;
name|addLoadEdge
argument_list|(
name|Ptr
argument_list|,
name|Val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|visitStoreInst
parameter_list|(
name|StoreInst
modifier|&
name|Inst
parameter_list|)
block|{
name|auto
operator|*
name|Ptr
operator|=
name|Inst
operator|.
name|getPointerOperand
argument_list|()
expr_stmt|;
name|auto
operator|*
name|Val
operator|=
name|Inst
operator|.
name|getValueOperand
argument_list|()
expr_stmt|;
name|addStoreEdge
argument_list|(
name|Val
argument_list|,
name|Ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|visitVAArgInst
parameter_list|(
name|VAArgInst
modifier|&
name|Inst
parameter_list|)
block|{
comment|// We can't fully model va_arg here. For *Ptr = Inst.getOperand(0), it
comment|// does
comment|// two things:
comment|//  1. Loads a value from *((T*)*Ptr).
comment|//  2. Increments (stores to) *Ptr by some target-specific amount.
comment|// For now, we'll handle this like a landingpad instruction (by placing
comment|// the
comment|// result in its own group, and having that group alias externals).
name|addNode
argument_list|(
operator|&
name|Inst
argument_list|,
name|getAttrUnknown
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|isFunctionExternal
parameter_list|(
name|Function
modifier|*
name|Fn
parameter_list|)
block|{
return|return
operator|!
name|Fn
operator|->
name|hasExactDefinition
argument_list|()
return|;
block|}
end_function

begin_decl_stmt
name|bool
name|tryInterproceduralAnalysis
argument_list|(
name|CallSite
name|CS
argument_list|,
specifier|const
name|SmallVectorImpl
operator|<
name|Function
operator|*
operator|>
operator|&
name|Fns
argument_list|)
block|{
name|assert
argument_list|(
name|Fns
operator|.
name|size
argument_list|()
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|CS
operator|.
name|arg_size
argument_list|()
operator|>
name|MaxSupportedArgsInSummary
condition|)
return|return
name|false
return|;
comment|// Exit early if we'll fail anyway
for|for
control|(
name|auto
operator|*
name|Fn
operator|:
name|Fns
control|)
block|{
if|if
condition|(
name|isFunctionExternal
argument_list|(
name|Fn
argument_list|)
operator|||
name|Fn
operator|->
name|isVarArg
argument_list|()
condition|)
return|return
name|false
return|;
comment|// Fail if the caller does not provide enough arguments
name|assert
argument_list|(
name|Fn
operator|->
name|arg_size
argument_list|()
operator|<=
name|CS
operator|.
name|arg_size
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|AA
operator|.
name|getAliasSummary
argument_list|(
operator|*
name|Fn
argument_list|)
condition|)
return|return
name|false
return|;
block|}
for|for
control|(
name|auto
operator|*
name|Fn
operator|:
name|Fns
control|)
block|{
name|auto
name|Summary
init|=
name|AA
operator|.
name|getAliasSummary
argument_list|(
operator|*
name|Fn
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|Summary
operator|!=
name|nullptr
argument_list|)
expr_stmt|;
name|auto
operator|&
name|RetParamRelations
operator|=
name|Summary
operator|->
name|RetParamRelations
expr_stmt|;
for|for
control|(
name|auto
operator|&
name|Relation
operator|:
name|RetParamRelations
control|)
block|{
name|auto
name|IRelation
init|=
name|instantiateExternalRelation
argument_list|(
name|Relation
argument_list|,
name|CS
argument_list|)
decl_stmt|;
if|if
condition|(
name|IRelation
operator|.
name|hasValue
argument_list|()
condition|)
block|{
name|Graph
operator|.
name|addNode
argument_list|(
name|IRelation
operator|->
name|From
argument_list|)
expr_stmt|;
name|Graph
operator|.
name|addNode
argument_list|(
name|IRelation
operator|->
name|To
argument_list|)
expr_stmt|;
name|Graph
operator|.
name|addEdge
argument_list|(
name|IRelation
operator|->
name|From
argument_list|,
name|IRelation
operator|->
name|To
argument_list|)
expr_stmt|;
block|}
block|}
name|auto
operator|&
name|RetParamAttributes
operator|=
name|Summary
operator|->
name|RetParamAttributes
expr_stmt|;
for|for
control|(
name|auto
operator|&
name|Attribute
operator|:
name|RetParamAttributes
control|)
block|{
name|auto
name|IAttr
init|=
name|instantiateExternalAttribute
argument_list|(
name|Attribute
argument_list|,
name|CS
argument_list|)
decl_stmt|;
if|if
condition|(
name|IAttr
operator|.
name|hasValue
argument_list|()
condition|)
name|Graph
operator|.
name|addNode
argument_list|(
name|IAttr
operator|->
name|IValue
argument_list|,
name|IAttr
operator|->
name|Attr
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|true
return|;
block|}
end_decl_stmt

begin_function
name|void
name|visitCallSite
parameter_list|(
name|CallSite
name|CS
parameter_list|)
block|{
name|auto
name|Inst
init|=
name|CS
operator|.
name|getInstruction
argument_list|()
decl_stmt|;
comment|// Make sure all arguments and return value are added to the graph first
for|for
control|(
name|Value
modifier|*
name|V
range|:
name|CS
operator|.
name|args
argument_list|()
control|)
if|if
condition|(
name|V
operator|->
name|getType
argument_list|()
operator|->
name|isPointerTy
argument_list|()
condition|)
name|addNode
argument_list|(
name|V
argument_list|)
expr_stmt|;
if|if
condition|(
name|Inst
operator|->
name|getType
argument_list|()
operator|->
name|isPointerTy
argument_list|()
condition|)
name|addNode
argument_list|(
name|Inst
argument_list|)
expr_stmt|;
comment|// Check if Inst is a call to a library function that
comment|// allocates/deallocates
comment|// on the heap. Those kinds of functions do not introduce any aliases.
comment|// TODO: address other common library functions such as realloc(),
comment|// strdup(),
comment|// etc.
if|if
condition|(
name|isMallocLikeFn
argument_list|(
name|Inst
argument_list|,
operator|&
name|TLI
argument_list|)
operator|||
name|isCallocLikeFn
argument_list|(
name|Inst
argument_list|,
operator|&
name|TLI
argument_list|)
operator|||
name|isFreeCall
argument_list|(
name|Inst
argument_list|,
operator|&
name|TLI
argument_list|)
condition|)
return|return;
comment|// TODO: Add support for noalias args/all the other fun function
comment|// attributes
comment|// that we can tack on.
name|SmallVector
operator|<
name|Function
operator|*
operator|,
literal|4
operator|>
name|Targets
expr_stmt|;
if|if
condition|(
name|getPossibleTargets
argument_list|(
name|CS
argument_list|,
name|Targets
argument_list|)
condition|)
if|if
condition|(
name|tryInterproceduralAnalysis
argument_list|(
name|CS
argument_list|,
name|Targets
argument_list|)
condition|)
return|return;
comment|// Because the function is opaque, we need to note that anything
comment|// could have happened to the arguments (unless the function is marked
comment|// readonly or readnone), and that the result could alias just about
comment|// anything, too (unless the result is marked noalias).
if|if
condition|(
operator|!
name|CS
operator|.
name|onlyReadsMemory
argument_list|()
condition|)
for|for
control|(
name|Value
modifier|*
name|V
range|:
name|CS
operator|.
name|args
argument_list|()
control|)
block|{
if|if
condition|(
name|V
operator|->
name|getType
argument_list|()
operator|->
name|isPointerTy
argument_list|()
condition|)
block|{
comment|// The argument itself escapes.
name|Graph
operator|.
name|addAttr
argument_list|(
name|InstantiatedValue
block|{
name|V
block|,
literal|0
block|}
argument_list|,
name|getAttrEscaped
argument_list|()
argument_list|)
expr_stmt|;
comment|// The fate of argument memory is unknown. Note that since
comment|// AliasAttrs is transitive with respect to dereference, we only
comment|// need to specify it for the first-level memory.
name|Graph
operator|.
name|addNode
argument_list|(
name|InstantiatedValue
block|{
name|V
block|,
literal|1
block|}
argument_list|,
name|getAttrUnknown
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Inst
operator|->
name|getType
argument_list|()
operator|->
name|isPointerTy
argument_list|()
condition|)
block|{
name|auto
operator|*
name|Fn
operator|=
name|CS
operator|.
name|getCalledFunction
argument_list|()
expr_stmt|;
if|if
condition|(
name|Fn
operator|==
name|nullptr
operator|||
operator|!
name|Fn
operator|->
name|doesNotAlias
argument_list|(
literal|0
argument_list|)
condition|)
comment|// No need to call addNode() since we've added Inst at the
comment|// beginning of this function and we know it is not a global.
name|Graph
operator|.
name|addAttr
argument_list|(
name|InstantiatedValue
block|{
name|Inst
block|,
literal|0
block|}
argument_list|,
name|getAttrUnknown
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/// Because vectors/aggregates are immutable and unaddressable, there's
end_comment

begin_comment
comment|/// nothing we can do to coax a value out of them, other than calling
end_comment

begin_comment
comment|/// Extract{Element,Value}. We can effectively treat them as pointers to
end_comment

begin_comment
comment|/// arbitrary memory locations we can store in and load from.
end_comment

begin_function
name|void
name|visitExtractElementInst
parameter_list|(
name|ExtractElementInst
modifier|&
name|Inst
parameter_list|)
block|{
name|auto
operator|*
name|Ptr
operator|=
name|Inst
operator|.
name|getVectorOperand
argument_list|()
expr_stmt|;
name|auto
operator|*
name|Val
operator|=
operator|&
name|Inst
expr_stmt|;
name|addLoadEdge
argument_list|(
name|Ptr
argument_list|,
name|Val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|visitInsertElementInst
parameter_list|(
name|InsertElementInst
modifier|&
name|Inst
parameter_list|)
block|{
name|auto
operator|*
name|Vec
operator|=
name|Inst
operator|.
name|getOperand
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|auto
operator|*
name|Val
operator|=
name|Inst
operator|.
name|getOperand
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|addAssignEdge
argument_list|(
name|Vec
argument_list|,
operator|&
name|Inst
argument_list|)
expr_stmt|;
name|addStoreEdge
argument_list|(
name|Val
argument_list|,
operator|&
name|Inst
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|visitLandingPadInst
parameter_list|(
name|LandingPadInst
modifier|&
name|Inst
parameter_list|)
block|{
comment|// Exceptions come from "nowhere", from our analysis' perspective.
comment|// So we place the instruction its own group, noting that said group may
comment|// alias externals
name|addNode
argument_list|(
operator|&
name|Inst
argument_list|,
name|getAttrUnknown
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|visitInsertValueInst
parameter_list|(
name|InsertValueInst
modifier|&
name|Inst
parameter_list|)
block|{
name|auto
operator|*
name|Agg
operator|=
name|Inst
operator|.
name|getOperand
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|auto
operator|*
name|Val
operator|=
name|Inst
operator|.
name|getOperand
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|addAssignEdge
argument_list|(
name|Agg
argument_list|,
operator|&
name|Inst
argument_list|)
expr_stmt|;
name|addStoreEdge
argument_list|(
name|Val
argument_list|,
operator|&
name|Inst
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|visitExtractValueInst
parameter_list|(
name|ExtractValueInst
modifier|&
name|Inst
parameter_list|)
block|{
name|auto
operator|*
name|Ptr
operator|=
name|Inst
operator|.
name|getAggregateOperand
argument_list|()
expr_stmt|;
name|addLoadEdge
argument_list|(
name|Ptr
argument_list|,
operator|&
name|Inst
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|visitShuffleVectorInst
parameter_list|(
name|ShuffleVectorInst
modifier|&
name|Inst
parameter_list|)
block|{
name|auto
operator|*
name|From1
operator|=
name|Inst
operator|.
name|getOperand
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|auto
operator|*
name|From2
operator|=
name|Inst
operator|.
name|getOperand
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|addAssignEdge
argument_list|(
name|From1
argument_list|,
operator|&
name|Inst
argument_list|)
expr_stmt|;
name|addAssignEdge
argument_list|(
name|From2
argument_list|,
operator|&
name|Inst
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|visitConstantExpr
parameter_list|(
name|ConstantExpr
modifier|*
name|CE
parameter_list|)
block|{
switch|switch
condition|(
name|CE
operator|->
name|getOpcode
argument_list|()
condition|)
block|{
default|default:
name|llvm_unreachable
argument_list|(
literal|"Unknown instruction type encountered!"
argument_list|)
expr_stmt|;
comment|// Build the switch statement using the Instruction.def file.
define|#
directive|define
name|HANDLE_INST
parameter_list|(
name|NUM
parameter_list|,
name|OPCODE
parameter_list|,
name|CLASS
parameter_list|)
define|\
value|case Instruction::OPCODE:                                                    \     this->visit##OPCODE(*(CLASS *)CE);                                         \     break;
include|#
directive|include
file|"llvm/IR/Instruction.def"
block|}
block|}
end_function

begin_comment
unit|};
comment|// Helper functions
end_comment

begin_comment
comment|// Determines whether or not we an instruction is useless to us (e.g.
end_comment

begin_comment
comment|// FenceInst)
end_comment

begin_function
specifier|static
name|bool
name|hasUsefulEdges
parameter_list|(
name|Instruction
modifier|*
name|Inst
parameter_list|)
block|{
name|bool
name|IsNonInvokeRetTerminator
init|=
name|isa
operator|<
name|TerminatorInst
operator|>
operator|(
name|Inst
operator|)
operator|&&
operator|!
name|isa
operator|<
name|InvokeInst
operator|>
operator|(
name|Inst
operator|)
operator|&&
operator|!
name|isa
operator|<
name|ReturnInst
operator|>
operator|(
name|Inst
operator|)
decl_stmt|;
return|return
operator|!
name|isa
operator|<
name|CmpInst
operator|>
operator|(
name|Inst
operator|)
operator|&&
operator|!
name|isa
operator|<
name|FenceInst
operator|>
operator|(
name|Inst
operator|)
operator|&&
operator|!
name|IsNonInvokeRetTerminator
return|;
block|}
end_function

begin_function
name|void
name|addArgumentToGraph
parameter_list|(
name|Argument
modifier|&
name|Arg
parameter_list|)
block|{
if|if
condition|(
name|Arg
operator|.
name|getType
argument_list|()
operator|->
name|isPointerTy
argument_list|()
condition|)
block|{
name|Graph
operator|.
name|addNode
argument_list|(
name|InstantiatedValue
block|{
operator|&
name|Arg
block|,
literal|0
block|}
argument_list|,
name|getGlobalOrArgAttrFromValue
argument_list|(
name|Arg
argument_list|)
argument_list|)
expr_stmt|;
comment|// Pointees of a formal parameter is known to the caller
name|Graph
operator|.
name|addNode
argument_list|(
name|InstantiatedValue
block|{
operator|&
name|Arg
block|,
literal|1
block|}
argument_list|,
name|getAttrCaller
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|// Given an Instruction, this will add it to the graph, along with any
end_comment

begin_comment
comment|// Instructions that are potentially only available from said Instruction
end_comment

begin_comment
comment|// For example, given the following line:
end_comment

begin_comment
comment|//   %0 = load i16* getelementptr ([1 x i16]* @a, 0, 0), align 2
end_comment

begin_comment
comment|// addInstructionToGraph would add both the `load` and `getelementptr`
end_comment

begin_comment
comment|// instructions to the graph appropriately.
end_comment

begin_function
name|void
name|addInstructionToGraph
parameter_list|(
name|GetEdgesVisitor
modifier|&
name|Visitor
parameter_list|,
name|Instruction
modifier|&
name|Inst
parameter_list|)
block|{
if|if
condition|(
operator|!
name|hasUsefulEdges
argument_list|(
operator|&
name|Inst
argument_list|)
condition|)
return|return;
name|Visitor
operator|.
name|visit
argument_list|(
name|Inst
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// Builds the graph needed for constructing the StratifiedSets for the given
end_comment

begin_comment
comment|// function
end_comment

begin_function
name|void
name|buildGraphFrom
parameter_list|(
name|Function
modifier|&
name|Fn
parameter_list|)
block|{
name|GetEdgesVisitor
name|Visitor
argument_list|(
operator|*
name|this
argument_list|)
decl_stmt|;
for|for
control|(
name|auto
operator|&
name|Bb
operator|:
name|Fn
operator|.
name|getBasicBlockList
argument_list|()
control|)
for|for
control|(
name|auto
operator|&
name|Inst
operator|:
name|Bb
operator|.
name|getInstList
argument_list|()
control|)
name|addInstructionToGraph
argument_list|(
name|Visitor
argument_list|,
name|Inst
argument_list|)
expr_stmt|;
for|for
control|(
name|auto
operator|&
name|Arg
operator|:
name|Fn
operator|.
name|args
argument_list|()
control|)
name|addArgumentToGraph
argument_list|(
name|Arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_label
name|public
label|:
end_label

begin_expr_stmt
name|CFLGraphBuilder
argument_list|(
name|CFLAA
operator|&
name|Analysis
argument_list|,
specifier|const
name|TargetLibraryInfo
operator|&
name|TLI
argument_list|,
name|Function
operator|&
name|Fn
argument_list|)
operator|:
name|Analysis
argument_list|(
name|Analysis
argument_list|)
operator|,
name|TLI
argument_list|(
argument|TLI
argument_list|)
block|{
name|buildGraphFrom
argument_list|(
name|Fn
argument_list|)
block|;   }
specifier|const
name|CFLGraph
operator|&
name|getCFLGraph
argument_list|()
specifier|const
block|{
return|return
name|Graph
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|const
name|SmallVector
operator|<
name|Value
operator|*
operator|,
literal|4
operator|>
operator|&
name|getReturnValues
argument_list|()
specifier|const
block|{
return|return
name|ReturnedValues
return|;
block|}
end_expr_stmt

begin_endif
unit|}; } }
endif|#
directive|endif
end_endif

end_unit

