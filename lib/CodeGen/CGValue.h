begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- CGValue.h - LLVM CodeGen wrappers for llvm::Value* ------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// These classes implement wrappers around llvm::Value in order to
end_comment

begin_comment
comment|// fully represent the range of values for C L- and R- values.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CLANG_CODEGEN_CGVALUE_H
end_ifndef

begin_define
define|#
directive|define
name|CLANG_CODEGEN_CGVALUE_H
end_define

begin_include
include|#
directive|include
file|"clang/AST/Type.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|Constant
decl_stmt|;
name|class
name|Value
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|ObjCPropertyRefExpr
decl_stmt|;
name|class
name|ObjCKVCRefExpr
decl_stmt|;
name|namespace
name|CodeGen
block|{
comment|/// RValue - This trivial value class is used to represent the result of an
comment|/// expression that is evaluated.  It can be one of three things: either a
comment|/// simple LLVM SSA value, a pair of SSA values for complex numbers, or the
comment|/// address of an aggregate value in memory.
name|class
name|RValue
block|{
name|llvm
operator|::
name|Value
operator|*
name|V1
operator|,
operator|*
name|V2
expr_stmt|;
comment|// TODO: Encode this into the low bit of pointer for more efficient
comment|// return-by-value.
enum|enum
block|{
name|Scalar
block|,
name|Complex
block|,
name|Aggregate
block|}
name|Flavor
enum|;
name|bool
name|Volatile
range|:
literal|1
decl_stmt|;
name|public
label|:
name|bool
name|isScalar
argument_list|()
specifier|const
block|{
return|return
name|Flavor
operator|==
name|Scalar
return|;
block|}
name|bool
name|isComplex
argument_list|()
specifier|const
block|{
return|return
name|Flavor
operator|==
name|Complex
return|;
block|}
name|bool
name|isAggregate
argument_list|()
specifier|const
block|{
return|return
name|Flavor
operator|==
name|Aggregate
return|;
block|}
name|bool
name|isVolatileQualified
argument_list|()
specifier|const
block|{
return|return
name|Volatile
return|;
block|}
comment|/// getScalar() - Return the Value* of this scalar value.
name|llvm
operator|::
name|Value
operator|*
name|getScalarVal
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isScalar
argument_list|()
operator|&&
literal|"Not a scalar!"
argument_list|)
block|;
return|return
name|V1
return|;
block|}
comment|/// getComplexVal - Return the real/imag components of this complex value.
comment|///
name|std
operator|::
name|pair
operator|<
name|llvm
operator|::
name|Value
operator|*
operator|,
name|llvm
operator|::
name|Value
operator|*
operator|>
name|getComplexVal
argument_list|()
specifier|const
block|{
return|return
name|std
operator|::
name|pair
operator|<
name|llvm
operator|::
name|Value
operator|*
operator|,
name|llvm
operator|::
name|Value
operator|*
operator|>
operator|(
name|V1
operator|,
name|V2
operator|)
return|;
block|}
comment|/// getAggregateAddr() - Return the Value* of the address of the aggregate.
name|llvm
operator|::
name|Value
operator|*
name|getAggregateAddr
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isAggregate
argument_list|()
operator|&&
literal|"Not an aggregate!"
argument_list|)
block|;
return|return
name|V1
return|;
block|}
specifier|static
name|RValue
name|get
argument_list|(
name|llvm
operator|::
name|Value
operator|*
name|V
argument_list|)
block|{
name|RValue
name|ER
decl_stmt|;
name|ER
operator|.
name|V1
operator|=
name|V
expr_stmt|;
name|ER
operator|.
name|Flavor
operator|=
name|Scalar
expr_stmt|;
name|ER
operator|.
name|Volatile
operator|=
name|false
expr_stmt|;
return|return
name|ER
return|;
block|}
specifier|static
name|RValue
name|getComplex
argument_list|(
name|llvm
operator|::
name|Value
operator|*
name|V1
argument_list|,
name|llvm
operator|::
name|Value
operator|*
name|V2
argument_list|)
block|{
name|RValue
name|ER
decl_stmt|;
name|ER
operator|.
name|V1
operator|=
name|V1
expr_stmt|;
name|ER
operator|.
name|V2
operator|=
name|V2
expr_stmt|;
name|ER
operator|.
name|Flavor
operator|=
name|Complex
expr_stmt|;
name|ER
operator|.
name|Volatile
operator|=
name|false
expr_stmt|;
return|return
name|ER
return|;
block|}
specifier|static
name|RValue
name|getComplex
argument_list|(
specifier|const
name|std
operator|::
name|pair
operator|<
name|llvm
operator|::
name|Value
operator|*
argument_list|,
name|llvm
operator|::
name|Value
operator|*
operator|>
operator|&
name|C
argument_list|)
block|{
name|RValue
name|ER
decl_stmt|;
name|ER
operator|.
name|V1
operator|=
name|C
operator|.
name|first
expr_stmt|;
name|ER
operator|.
name|V2
operator|=
name|C
operator|.
name|second
expr_stmt|;
name|ER
operator|.
name|Flavor
operator|=
name|Complex
expr_stmt|;
name|ER
operator|.
name|Volatile
operator|=
name|false
expr_stmt|;
return|return
name|ER
return|;
block|}
comment|// FIXME: Aggregate rvalues need to retain information about whether they are
comment|// volatile or not.  Remove default to find all places that probably get this
comment|// wrong.
specifier|static
name|RValue
name|getAggregate
argument_list|(
name|llvm
operator|::
name|Value
operator|*
name|V
argument_list|,
name|bool
name|Vol
operator|=
name|false
argument_list|)
block|{
name|RValue
name|ER
decl_stmt|;
name|ER
operator|.
name|V1
operator|=
name|V
expr_stmt|;
name|ER
operator|.
name|Flavor
operator|=
name|Aggregate
expr_stmt|;
name|ER
operator|.
name|Volatile
operator|=
name|Vol
expr_stmt|;
return|return
name|ER
return|;
block|}
block|}
empty_stmt|;
comment|/// LValue - This represents an lvalue references.  Because C/C++ allow
comment|/// bitfields, this is not a simple LLVM pointer, it may be a pointer plus a
comment|/// bitrange.
name|class
name|LValue
block|{
comment|// FIXME: alignment?
enum|enum
block|{
name|Simple
block|,
comment|// This is a normal l-value, use getAddress().
name|VectorElt
block|,
comment|// This is a vector element l-value (V[i]), use getVector*
name|BitField
block|,
comment|// This is a bitfield l-value, use getBitfield*.
name|ExtVectorElt
block|,
comment|// This is an extended vector subset, use getExtVectorComp
name|PropertyRef
block|,
comment|// This is an Objective-C property reference, use
comment|// getPropertyRefExpr
name|KVCRef
comment|// This is an objective-c 'implicit' property ref,
comment|// use getKVCRefExpr
block|}
name|LVType
enum|;
enum|enum
name|ObjCType
block|{
name|None
init|=
literal|0
block|,
comment|// object with no gc attribute.
name|Weak
block|,
comment|// __weak object expression
name|Strong
comment|// __strong object expression
block|}
enum|;
name|llvm
operator|::
name|Value
operator|*
name|V
expr_stmt|;
union|union
block|{
comment|// Index into a vector subscript: V[i]
name|llvm
operator|::
name|Value
operator|*
name|VectorIdx
expr_stmt|;
comment|// ExtVector element subset: V.xyx
name|llvm
operator|::
name|Constant
operator|*
name|VectorElts
expr_stmt|;
comment|// BitField start bit and size
struct|struct
block|{
name|unsigned
name|short
name|StartBit
decl_stmt|;
name|unsigned
name|short
name|Size
decl_stmt|;
name|bool
name|IsSigned
decl_stmt|;
block|}
name|BitfieldData
struct|;
comment|// Obj-C property reference expression
specifier|const
name|ObjCPropertyRefExpr
modifier|*
name|PropertyRefExpr
decl_stmt|;
comment|// ObjC 'implicit' property reference expression
specifier|const
name|ObjCKVCRefExpr
modifier|*
name|KVCRefExpr
decl_stmt|;
block|}
union|;
name|bool
name|Volatile
range|:
literal|1
decl_stmt|;
comment|// FIXME: set but never used, what effect should it have?
name|bool
name|Restrict
range|:
literal|1
decl_stmt|;
comment|// objective-c's ivar
name|bool
name|Ivar
range|:
literal|1
decl_stmt|;
comment|// LValue is non-gc'able for any reason, including being a parameter or local
comment|// variable.
name|bool
name|NonGC
range|:
literal|1
decl_stmt|;
comment|// Lvalue is a global reference of an objective-c object
name|bool
name|GlobalObjCRef
range|:
literal|1
decl_stmt|;
comment|// objective-c's gc attributes
name|unsigned
name|ObjCType
range|:
literal|2
decl_stmt|;
name|private
label|:
specifier|static
name|void
name|SetQualifiers
parameter_list|(
name|unsigned
name|Qualifiers
parameter_list|,
name|LValue
modifier|&
name|R
parameter_list|)
block|{
name|R
operator|.
name|Volatile
operator|=
operator|(
name|Qualifiers
operator|&
name|QualType
operator|::
name|Volatile
operator|)
operator|!=
literal|0
expr_stmt|;
name|R
operator|.
name|Restrict
operator|=
operator|(
name|Qualifiers
operator|&
name|QualType
operator|::
name|Restrict
operator|)
operator|!=
literal|0
expr_stmt|;
comment|// FIXME: Convenient place to set objc flags to 0. This should really be
comment|// done in a user-defined constructor instead.
name|R
operator|.
name|ObjCType
operator|=
name|None
expr_stmt|;
name|R
operator|.
name|Ivar
operator|=
name|R
operator|.
name|NonGC
operator|=
name|R
operator|.
name|GlobalObjCRef
operator|=
name|false
expr_stmt|;
block|}
name|public
label|:
name|bool
name|isSimple
argument_list|()
specifier|const
block|{
return|return
name|LVType
operator|==
name|Simple
return|;
block|}
name|bool
name|isVectorElt
argument_list|()
specifier|const
block|{
return|return
name|LVType
operator|==
name|VectorElt
return|;
block|}
name|bool
name|isBitfield
argument_list|()
specifier|const
block|{
return|return
name|LVType
operator|==
name|BitField
return|;
block|}
name|bool
name|isExtVectorElt
argument_list|()
specifier|const
block|{
return|return
name|LVType
operator|==
name|ExtVectorElt
return|;
block|}
name|bool
name|isPropertyRef
argument_list|()
specifier|const
block|{
return|return
name|LVType
operator|==
name|PropertyRef
return|;
block|}
name|bool
name|isKVCRef
argument_list|()
specifier|const
block|{
return|return
name|LVType
operator|==
name|KVCRef
return|;
block|}
name|bool
name|isVolatileQualified
argument_list|()
specifier|const
block|{
return|return
name|Volatile
return|;
block|}
name|bool
name|isRestrictQualified
argument_list|()
specifier|const
block|{
return|return
name|Restrict
return|;
block|}
name|unsigned
name|getQualifiers
argument_list|()
specifier|const
block|{
return|return
operator|(
name|Volatile
operator|?
name|QualType
operator|::
name|Volatile
operator|:
literal|0
operator|)
operator||
operator|(
name|Restrict
operator|?
name|QualType
operator|::
name|Restrict
operator|:
literal|0
operator|)
return|;
block|}
name|bool
name|isObjCIvar
argument_list|()
specifier|const
block|{
return|return
name|Ivar
return|;
block|}
name|bool
name|isNonGC
argument_list|()
specifier|const
block|{
return|return
name|NonGC
return|;
block|}
name|bool
name|isGlobalObjCRef
argument_list|()
specifier|const
block|{
return|return
name|GlobalObjCRef
return|;
block|}
name|bool
name|isObjCWeak
argument_list|()
specifier|const
block|{
return|return
name|ObjCType
operator|==
name|Weak
return|;
block|}
name|bool
name|isObjCStrong
argument_list|()
specifier|const
block|{
return|return
name|ObjCType
operator|==
name|Strong
return|;
block|}
specifier|static
name|void
name|SetObjCIvar
parameter_list|(
name|LValue
modifier|&
name|R
parameter_list|,
name|bool
name|iValue
parameter_list|)
block|{
name|R
operator|.
name|Ivar
operator|=
name|iValue
expr_stmt|;
block|}
specifier|static
name|void
name|SetGlobalObjCRef
parameter_list|(
name|LValue
modifier|&
name|R
parameter_list|,
name|bool
name|iValue
parameter_list|)
block|{
name|R
operator|.
name|GlobalObjCRef
operator|=
name|iValue
expr_stmt|;
block|}
specifier|static
name|void
name|SetObjCNonGC
parameter_list|(
name|LValue
modifier|&
name|R
parameter_list|,
name|bool
name|iValue
parameter_list|)
block|{
name|R
operator|.
name|NonGC
operator|=
name|iValue
expr_stmt|;
block|}
specifier|static
name|void
name|SetObjCType
argument_list|(
name|QualType
operator|::
name|GCAttrTypes
name|GCAttrs
argument_list|,
name|LValue
operator|&
name|R
argument_list|)
block|{
if|if
condition|(
name|GCAttrs
operator|==
name|QualType
operator|::
name|Weak
condition|)
name|R
operator|.
name|ObjCType
operator|=
name|Weak
expr_stmt|;
elseif|else
if|if
condition|(
name|GCAttrs
operator|==
name|QualType
operator|::
name|Strong
condition|)
name|R
operator|.
name|ObjCType
operator|=
name|Strong
expr_stmt|;
else|else
name|R
operator|.
name|ObjCType
operator|=
name|None
expr_stmt|;
block|}
comment|// simple lvalue
name|llvm
operator|::
name|Value
operator|*
name|getAddress
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isSimple
argument_list|()
argument_list|)
block|;
return|return
name|V
return|;
block|}
comment|// vector elt lvalue
name|llvm
operator|::
name|Value
operator|*
name|getVectorAddr
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isVectorElt
argument_list|()
argument_list|)
block|;
return|return
name|V
return|;
block|}
name|llvm
operator|::
name|Value
operator|*
name|getVectorIdx
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isVectorElt
argument_list|()
argument_list|)
block|;
return|return
name|VectorIdx
return|;
block|}
comment|// extended vector elements.
name|llvm
operator|::
name|Value
operator|*
name|getExtVectorAddr
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isExtVectorElt
argument_list|()
argument_list|)
block|;
return|return
name|V
return|;
block|}
name|llvm
operator|::
name|Constant
operator|*
name|getExtVectorElts
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isExtVectorElt
argument_list|()
argument_list|)
block|;
return|return
name|VectorElts
return|;
block|}
comment|// bitfield lvalue
name|llvm
operator|::
name|Value
operator|*
name|getBitfieldAddr
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isBitfield
argument_list|()
argument_list|)
block|;
return|return
name|V
return|;
block|}
name|unsigned
name|short
name|getBitfieldStartBit
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isBitfield
argument_list|()
argument_list|)
block|;
return|return
name|BitfieldData
operator|.
name|StartBit
return|;
block|}
name|unsigned
name|short
name|getBitfieldSize
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isBitfield
argument_list|()
argument_list|)
block|;
return|return
name|BitfieldData
operator|.
name|Size
return|;
block|}
name|bool
name|isBitfieldSigned
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isBitfield
argument_list|()
argument_list|)
block|;
return|return
name|BitfieldData
operator|.
name|IsSigned
return|;
block|}
comment|// property ref lvalue
specifier|const
name|ObjCPropertyRefExpr
operator|*
name|getPropertyRefExpr
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isPropertyRef
argument_list|()
argument_list|)
block|;
return|return
name|PropertyRefExpr
return|;
block|}
comment|// 'implicit' property ref lvalue
specifier|const
name|ObjCKVCRefExpr
operator|*
name|getKVCRefExpr
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isKVCRef
argument_list|()
argument_list|)
block|;
return|return
name|KVCRefExpr
return|;
block|}
specifier|static
name|LValue
name|MakeAddr
argument_list|(
name|llvm
operator|::
name|Value
operator|*
name|V
argument_list|,
name|unsigned
name|Qualifiers
argument_list|,
name|QualType
operator|::
name|GCAttrTypes
name|GCAttrs
operator|=
name|QualType
operator|::
name|GCNone
argument_list|)
block|{
name|LValue
name|R
decl_stmt|;
name|R
operator|.
name|LVType
operator|=
name|Simple
expr_stmt|;
name|R
operator|.
name|V
operator|=
name|V
expr_stmt|;
name|SetQualifiers
argument_list|(
name|Qualifiers
argument_list|,
name|R
argument_list|)
expr_stmt|;
name|SetObjCType
argument_list|(
name|GCAttrs
argument_list|,
name|R
argument_list|)
expr_stmt|;
return|return
name|R
return|;
block|}
specifier|static
name|LValue
name|MakeVectorElt
argument_list|(
name|llvm
operator|::
name|Value
operator|*
name|Vec
argument_list|,
name|llvm
operator|::
name|Value
operator|*
name|Idx
argument_list|,
name|unsigned
name|Qualifiers
argument_list|)
block|{
name|LValue
name|R
decl_stmt|;
name|R
operator|.
name|LVType
operator|=
name|VectorElt
expr_stmt|;
name|R
operator|.
name|V
operator|=
name|Vec
expr_stmt|;
name|R
operator|.
name|VectorIdx
operator|=
name|Idx
expr_stmt|;
name|SetQualifiers
argument_list|(
name|Qualifiers
argument_list|,
name|R
argument_list|)
expr_stmt|;
return|return
name|R
return|;
block|}
specifier|static
name|LValue
name|MakeExtVectorElt
argument_list|(
name|llvm
operator|::
name|Value
operator|*
name|Vec
argument_list|,
name|llvm
operator|::
name|Constant
operator|*
name|Elts
argument_list|,
name|unsigned
name|Qualifiers
argument_list|)
block|{
name|LValue
name|R
decl_stmt|;
name|R
operator|.
name|LVType
operator|=
name|ExtVectorElt
expr_stmt|;
name|R
operator|.
name|V
operator|=
name|Vec
expr_stmt|;
name|R
operator|.
name|VectorElts
operator|=
name|Elts
expr_stmt|;
name|SetQualifiers
argument_list|(
name|Qualifiers
argument_list|,
name|R
argument_list|)
expr_stmt|;
return|return
name|R
return|;
block|}
specifier|static
name|LValue
name|MakeBitfield
argument_list|(
name|llvm
operator|::
name|Value
operator|*
name|V
argument_list|,
name|unsigned
name|short
name|StartBit
argument_list|,
name|unsigned
name|short
name|Size
argument_list|,
name|bool
name|IsSigned
argument_list|,
name|unsigned
name|Qualifiers
argument_list|)
block|{
name|LValue
name|R
decl_stmt|;
name|R
operator|.
name|LVType
operator|=
name|BitField
expr_stmt|;
name|R
operator|.
name|V
operator|=
name|V
expr_stmt|;
name|R
operator|.
name|BitfieldData
operator|.
name|StartBit
operator|=
name|StartBit
expr_stmt|;
name|R
operator|.
name|BitfieldData
operator|.
name|Size
operator|=
name|Size
expr_stmt|;
name|R
operator|.
name|BitfieldData
operator|.
name|IsSigned
operator|=
name|IsSigned
expr_stmt|;
name|SetQualifiers
argument_list|(
name|Qualifiers
argument_list|,
name|R
argument_list|)
expr_stmt|;
return|return
name|R
return|;
block|}
comment|// FIXME: It is probably bad that we aren't emitting the target when we build
comment|// the lvalue. However, this complicates the code a bit, and I haven't figured
comment|// out how to make it go wrong yet.
specifier|static
name|LValue
name|MakePropertyRef
parameter_list|(
specifier|const
name|ObjCPropertyRefExpr
modifier|*
name|E
parameter_list|,
name|unsigned
name|Qualifiers
parameter_list|)
block|{
name|LValue
name|R
decl_stmt|;
name|R
operator|.
name|LVType
operator|=
name|PropertyRef
expr_stmt|;
name|R
operator|.
name|PropertyRefExpr
operator|=
name|E
expr_stmt|;
name|SetQualifiers
argument_list|(
name|Qualifiers
argument_list|,
name|R
argument_list|)
expr_stmt|;
return|return
name|R
return|;
block|}
specifier|static
name|LValue
name|MakeKVCRef
parameter_list|(
specifier|const
name|ObjCKVCRefExpr
modifier|*
name|E
parameter_list|,
name|unsigned
name|Qualifiers
parameter_list|)
block|{
name|LValue
name|R
decl_stmt|;
name|R
operator|.
name|LVType
operator|=
name|KVCRef
expr_stmt|;
name|R
operator|.
name|KVCRefExpr
operator|=
name|E
expr_stmt|;
name|SetQualifiers
argument_list|(
name|Qualifiers
argument_list|,
name|R
argument_list|)
expr_stmt|;
return|return
name|R
return|;
block|}
block|}
empty_stmt|;
block|}
comment|// end namespace CodeGen
block|}
end_decl_stmt

begin_comment
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

