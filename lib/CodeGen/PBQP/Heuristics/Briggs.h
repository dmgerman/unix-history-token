begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- Briggs.h --- Briggs Heuristic for PBQP ------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This class implements the Briggs test for "allocability" of nodes in a
end_comment

begin_comment
comment|// PBQP graph representing a register allocation problem. Nodes which can be
end_comment

begin_comment
comment|// proven allocable (by a safe and relatively accurate test) are removed from
end_comment

begin_comment
comment|// the PBQP graph first. If no provably allocable node is present in the graph
end_comment

begin_comment
comment|// then the node with the minimal spill-cost to degree ratio is removed.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_PBQP_HEURISTICS_BRIGGS_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_PBQP_HEURISTICS_BRIGGS_H
end_define

begin_include
include|#
directive|include
file|"../HeuristicSolver.h"
end_include

begin_include
include|#
directive|include
file|<set>
end_include

begin_decl_stmt
name|namespace
name|PBQP
block|{
name|namespace
name|Heuristics
block|{
name|class
name|Briggs
block|{
name|public
label|:
name|class
name|NodeData
decl_stmt|;
name|class
name|EdgeData
decl_stmt|;
name|private
label|:
typedef|typedef
name|HeuristicSolverImpl
operator|<
name|Briggs
operator|>
name|Solver
expr_stmt|;
typedef|typedef
name|HSITypes
operator|<
name|NodeData
operator|,
name|EdgeData
operator|>
name|HSIT
expr_stmt|;
typedef|typedef
name|HSIT
operator|::
name|SolverGraph
name|SolverGraph
expr_stmt|;
typedef|typedef
name|HSIT
operator|::
name|GraphNodeIterator
name|GraphNodeIterator
expr_stmt|;
typedef|typedef
name|HSIT
operator|::
name|GraphEdgeIterator
name|GraphEdgeIterator
expr_stmt|;
name|class
name|LinkDegreeComparator
block|{
name|public
label|:
name|LinkDegreeComparator
argument_list|()
operator|:
name|g
argument_list|(
literal|0
argument_list|)
block|{}
name|LinkDegreeComparator
argument_list|(
name|SolverGraph
operator|*
name|g
argument_list|)
operator|:
name|g
argument_list|(
argument|g
argument_list|)
block|{}
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|GraphNodeIterator
operator|&
name|node1Itr
operator|,
specifier|const
name|GraphNodeIterator
operator|&
name|node2Itr
operator|)
specifier|const
block|{
name|assert
argument_list|(
operator|(
name|g
operator|!=
literal|0
operator|)
operator|&&
literal|"Graph object not set, cannot access node data."
argument_list|)
block|;
name|unsigned
name|n1Degree
operator|=
name|g
operator|->
name|getNodeData
argument_list|(
name|node1Itr
argument_list|)
operator|.
name|getLinkDegree
argument_list|()
block|,
name|n2Degree
operator|=
name|g
operator|->
name|getNodeData
argument_list|(
name|node2Itr
argument_list|)
operator|.
name|getLinkDegree
argument_list|()
block|;
if|if
condition|(
name|n1Degree
operator|>
name|n2Degree
condition|)
block|{
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|n1Degree
operator|<
name|n2Degree
condition|)
block|{
return|return
name|false
return|;
block|}
comment|// else they're "equal" by degree, differentiate based on ID.
return|return
name|g
operator|->
name|getNodeID
argument_list|(
name|node1Itr
argument_list|)
operator|<
name|g
operator|->
name|getNodeID
argument_list|(
name|node2Itr
argument_list|)
return|;
block|}
name|private
label|:
name|SolverGraph
modifier|*
name|g
decl_stmt|;
block|}
empty_stmt|;
name|class
name|SpillPriorityComparator
block|{
name|public
label|:
name|SpillPriorityComparator
argument_list|()
operator|:
name|g
argument_list|(
literal|0
argument_list|)
block|{}
name|SpillPriorityComparator
argument_list|(
name|SolverGraph
operator|*
name|g
argument_list|)
operator|:
name|g
argument_list|(
argument|g
argument_list|)
block|{}
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|GraphNodeIterator
operator|&
name|node1Itr
operator|,
specifier|const
name|GraphNodeIterator
operator|&
name|node2Itr
operator|)
specifier|const
block|{
name|assert
argument_list|(
operator|(
name|g
operator|!=
literal|0
operator|)
operator|&&
literal|"Graph object not set, cannot access node data."
argument_list|)
block|;
name|PBQPNum
name|cost1
operator|=
name|g
operator|->
name|getNodeCosts
argument_list|(
name|node1Itr
argument_list|)
index|[
literal|0
index|]
operator|/
name|g
operator|->
name|getNodeData
argument_list|(
name|node1Itr
argument_list|)
operator|.
name|getLinkDegree
argument_list|()
block|,
name|cost2
operator|=
name|g
operator|->
name|getNodeCosts
argument_list|(
name|node2Itr
argument_list|)
index|[
literal|0
index|]
operator|/
name|g
operator|->
name|getNodeData
argument_list|(
name|node2Itr
argument_list|)
operator|.
name|getLinkDegree
argument_list|()
block|;
if|if
condition|(
name|cost1
operator|<
name|cost2
condition|)
block|{
return|return
name|true
return|;
block|}
elseif|else
if|if
condition|(
name|cost1
operator|>
name|cost2
condition|)
block|{
return|return
name|false
return|;
block|}
comment|// else they'er "equal" again, differentiate based on address again.
return|return
name|g
operator|->
name|getNodeID
argument_list|(
name|node1Itr
argument_list|)
operator|<
name|g
operator|->
name|getNodeID
argument_list|(
name|node2Itr
argument_list|)
return|;
block|}
name|private
label|:
name|SolverGraph
modifier|*
name|g
decl_stmt|;
block|}
empty_stmt|;
typedef|typedef
name|std
operator|::
name|set
operator|<
name|GraphNodeIterator
operator|,
name|LinkDegreeComparator
operator|>
name|RNAllocableNodeList
expr_stmt|;
typedef|typedef
name|RNAllocableNodeList
operator|::
name|iterator
name|RNAllocableNodeListIterator
expr_stmt|;
typedef|typedef
name|std
operator|::
name|set
operator|<
name|GraphNodeIterator
operator|,
name|SpillPriorityComparator
operator|>
name|RNUnallocableNodeList
expr_stmt|;
typedef|typedef
name|RNUnallocableNodeList
operator|::
name|iterator
name|RNUnallocableNodeListIterator
expr_stmt|;
name|public
label|:
name|class
name|NodeData
block|{
name|private
label|:
name|RNAllocableNodeListIterator
name|rNAllocableNodeListItr
decl_stmt|;
name|RNUnallocableNodeListIterator
name|rNUnallocableNodeListItr
decl_stmt|;
name|unsigned
name|numRegOptions
decl_stmt|,
name|numDenied
decl_stmt|,
name|numSafe
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
name|unsafeDegrees
expr_stmt|;
name|bool
name|allocable
decl_stmt|;
name|void
name|addRemoveLink
parameter_list|(
name|SolverGraph
modifier|&
name|g
parameter_list|,
specifier|const
name|GraphNodeIterator
modifier|&
name|nodeItr
parameter_list|,
specifier|const
name|GraphEdgeIterator
modifier|&
name|edgeItr
parameter_list|,
name|bool
name|add
parameter_list|)
block|{
comment|//assume we're adding...
name|unsigned
name|udTarget
init|=
literal|0
decl_stmt|,
name|dir
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|!
name|add
condition|)
block|{
name|udTarget
operator|=
literal|1
expr_stmt|;
name|dir
operator|=
operator|~
literal|0
expr_stmt|;
block|}
name|EdgeData
modifier|&
name|linkEdgeData
init|=
name|g
operator|.
name|getEdgeData
argument_list|(
name|edgeItr
argument_list|)
operator|.
name|getHeuristicData
argument_list|()
decl_stmt|;
name|EdgeData
operator|::
name|ConstUnsafeIterator
name|edgeUnsafeBegin
operator|,
name|edgeUnsafeEnd
expr_stmt|;
if|if
condition|(
name|nodeItr
operator|==
name|g
operator|.
name|getEdgeNode1Itr
argument_list|(
name|edgeItr
argument_list|)
condition|)
block|{
name|numDenied
operator|+=
operator|(
name|dir
operator|*
name|linkEdgeData
operator|.
name|getWorstDegree
argument_list|()
operator|)
expr_stmt|;
name|edgeUnsafeBegin
operator|=
name|linkEdgeData
operator|.
name|unsafeBegin
argument_list|()
expr_stmt|;
name|edgeUnsafeEnd
operator|=
name|linkEdgeData
operator|.
name|unsafeEnd
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|numDenied
operator|+=
operator|(
name|dir
operator|*
name|linkEdgeData
operator|.
name|getReverseWorstDegree
argument_list|()
operator|)
expr_stmt|;
name|edgeUnsafeBegin
operator|=
name|linkEdgeData
operator|.
name|reverseUnsafeBegin
argument_list|()
expr_stmt|;
name|edgeUnsafeEnd
operator|=
name|linkEdgeData
operator|.
name|reverseUnsafeEnd
argument_list|()
expr_stmt|;
block|}
name|assert
argument_list|(
operator|(
name|unsafeDegrees
operator|.
name|size
argument_list|()
operator|==
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|std
operator|::
name|distance
argument_list|(
name|edgeUnsafeBegin
argument_list|,
name|edgeUnsafeEnd
argument_list|)
operator|)
operator|)
operator|&&
literal|"Unsafe array size mismatch."
argument_list|)
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
operator|::
name|iterator
name|unsafeDegreesItr
operator|=
name|unsafeDegrees
operator|.
name|begin
argument_list|()
expr_stmt|;
for|for
control|(
name|EdgeData
operator|::
name|ConstUnsafeIterator
name|edgeUnsafeItr
operator|=
name|edgeUnsafeBegin
init|;
name|edgeUnsafeItr
operator|!=
name|edgeUnsafeEnd
condition|;
operator|++
name|edgeUnsafeItr
operator|,
operator|++
name|unsafeDegreesItr
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|edgeUnsafeItr
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|*
name|unsafeDegreesItr
operator|==
name|udTarget
operator|)
condition|)
block|{
name|numSafe
operator|-=
name|dir
expr_stmt|;
block|}
operator|*
name|unsafeDegreesItr
operator|+=
operator|(
name|dir
operator|*
operator|(
operator|*
name|edgeUnsafeItr
operator|)
operator|)
expr_stmt|;
block|}
name|allocable
operator|=
operator|(
name|numDenied
operator|<
name|numRegOptions
operator|)
operator|||
operator|(
name|numSafe
operator|>
literal|0
operator|)
expr_stmt|;
block|}
name|public
label|:
name|void
name|setup
parameter_list|(
name|SolverGraph
modifier|&
name|g
parameter_list|,
specifier|const
name|GraphNodeIterator
modifier|&
name|nodeItr
parameter_list|)
block|{
name|numRegOptions
operator|=
name|g
operator|.
name|getNodeCosts
argument_list|(
name|nodeItr
argument_list|)
operator|.
name|getLength
argument_list|()
operator|-
literal|1
expr_stmt|;
name|numSafe
operator|=
name|numRegOptions
expr_stmt|;
comment|// Optimistic, correct below.
name|numDenied
operator|=
literal|0
expr_stmt|;
comment|// Also optimistic.
name|unsafeDegrees
operator|.
name|resize
argument_list|(
name|numRegOptions
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|HSIT
operator|::
name|NodeData
operator|&
name|nodeData
operator|=
name|g
operator|.
name|getNodeData
argument_list|(
name|nodeItr
argument_list|)
expr_stmt|;
for|for
control|(
name|HSIT
operator|::
name|NodeData
operator|::
name|AdjLinkIterator
name|adjLinkItr
operator|=
name|nodeData
operator|.
name|adjLinksBegin
argument_list|()
operator|,
name|adjLinkEnd
operator|=
name|nodeData
operator|.
name|adjLinksEnd
argument_list|()
init|;
name|adjLinkItr
operator|!=
name|adjLinkEnd
condition|;
operator|++
name|adjLinkItr
control|)
block|{
name|addRemoveLink
argument_list|(
name|g
argument_list|,
name|nodeItr
argument_list|,
operator|*
name|adjLinkItr
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
name|bool
name|isAllocable
argument_list|()
specifier|const
block|{
return|return
name|allocable
return|;
block|}
name|void
name|handleAddLink
parameter_list|(
name|SolverGraph
modifier|&
name|g
parameter_list|,
specifier|const
name|GraphNodeIterator
modifier|&
name|nodeItr
parameter_list|,
specifier|const
name|GraphEdgeIterator
modifier|&
name|adjEdge
parameter_list|)
block|{
name|addRemoveLink
argument_list|(
name|g
argument_list|,
name|nodeItr
argument_list|,
name|adjEdge
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
name|void
name|handleRemoveLink
parameter_list|(
name|SolverGraph
modifier|&
name|g
parameter_list|,
specifier|const
name|GraphNodeIterator
modifier|&
name|nodeItr
parameter_list|,
specifier|const
name|GraphEdgeIterator
modifier|&
name|adjEdge
parameter_list|)
block|{
name|addRemoveLink
argument_list|(
name|g
argument_list|,
name|nodeItr
argument_list|,
name|adjEdge
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
name|void
name|setRNAllocableNodeListItr
parameter_list|(
specifier|const
name|RNAllocableNodeListIterator
modifier|&
name|rNAllocableNodeListItr
parameter_list|)
block|{
name|this
operator|->
name|rNAllocableNodeListItr
operator|=
name|rNAllocableNodeListItr
expr_stmt|;
block|}
name|RNAllocableNodeListIterator
name|getRNAllocableNodeListItr
argument_list|()
specifier|const
block|{
return|return
name|rNAllocableNodeListItr
return|;
block|}
name|void
name|setRNUnallocableNodeListItr
parameter_list|(
specifier|const
name|RNUnallocableNodeListIterator
modifier|&
name|rNUnallocableNodeListItr
parameter_list|)
block|{
name|this
operator|->
name|rNUnallocableNodeListItr
operator|=
name|rNUnallocableNodeListItr
expr_stmt|;
block|}
name|RNUnallocableNodeListIterator
name|getRNUnallocableNodeListItr
argument_list|()
specifier|const
block|{
return|return
name|rNUnallocableNodeListItr
return|;
block|}
block|}
empty_stmt|;
name|class
name|EdgeData
block|{
name|private
label|:
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
name|UnsafeArray
expr_stmt|;
name|unsigned
name|worstDegree
decl_stmt|,
name|reverseWorstDegree
decl_stmt|;
name|UnsafeArray
name|unsafe
decl_stmt|,
name|reverseUnsafe
decl_stmt|;
name|public
label|:
name|EdgeData
argument_list|()
operator|:
name|worstDegree
argument_list|(
literal|0
argument_list|)
operator|,
name|reverseWorstDegree
argument_list|(
literal|0
argument_list|)
block|{}
typedef|typedef
name|UnsafeArray
operator|::
name|const_iterator
name|ConstUnsafeIterator
expr_stmt|;
name|void
name|setup
parameter_list|(
name|SolverGraph
modifier|&
name|g
parameter_list|,
specifier|const
name|GraphEdgeIterator
modifier|&
name|edgeItr
parameter_list|)
block|{
specifier|const
name|Matrix
modifier|&
name|edgeCosts
init|=
name|g
operator|.
name|getEdgeCosts
argument_list|(
name|edgeItr
argument_list|)
decl_stmt|;
name|unsigned
name|numRegs
init|=
name|edgeCosts
operator|.
name|getRows
argument_list|()
operator|-
literal|1
decl_stmt|,
name|numReverseRegs
init|=
name|edgeCosts
operator|.
name|getCols
argument_list|()
operator|-
literal|1
decl_stmt|;
name|unsafe
operator|.
name|resize
argument_list|(
name|numRegs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|reverseUnsafe
operator|.
name|resize
argument_list|(
name|numReverseRegs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|unsigned
operator|>
name|rowInfCounts
argument_list|(
name|numRegs
argument_list|,
literal|0
argument_list|)
operator|,
name|colInfCounts
argument_list|(
name|numReverseRegs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|numRegs
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|unsigned
name|j
init|=
literal|0
init|;
name|j
operator|<
name|numReverseRegs
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|edgeCosts
index|[
name|i
operator|+
literal|1
index|]
index|[
name|j
operator|+
literal|1
index|]
operator|==
name|std
operator|::
name|numeric_limits
operator|<
name|PBQPNum
operator|>
operator|::
name|infinity
argument_list|()
condition|)
block|{
name|unsafe
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|reverseUnsafe
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
operator|++
name|rowInfCounts
index|[
name|i
index|]
expr_stmt|;
operator|++
name|colInfCounts
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|colInfCounts
index|[
name|j
index|]
operator|>
name|worstDegree
condition|)
block|{
name|worstDegree
operator|=
name|colInfCounts
index|[
name|j
index|]
expr_stmt|;
block|}
if|if
condition|(
name|rowInfCounts
index|[
name|i
index|]
operator|>
name|reverseWorstDegree
condition|)
block|{
name|reverseWorstDegree
operator|=
name|rowInfCounts
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
name|unsigned
name|getWorstDegree
argument_list|()
specifier|const
block|{
return|return
name|worstDegree
return|;
block|}
name|unsigned
name|getReverseWorstDegree
argument_list|()
specifier|const
block|{
return|return
name|reverseWorstDegree
return|;
block|}
name|ConstUnsafeIterator
name|unsafeBegin
argument_list|()
specifier|const
block|{
return|return
name|unsafe
operator|.
name|begin
argument_list|()
return|;
block|}
name|ConstUnsafeIterator
name|unsafeEnd
argument_list|()
specifier|const
block|{
return|return
name|unsafe
operator|.
name|end
argument_list|()
return|;
block|}
name|ConstUnsafeIterator
name|reverseUnsafeBegin
argument_list|()
specifier|const
block|{
return|return
name|reverseUnsafe
operator|.
name|begin
argument_list|()
return|;
block|}
name|ConstUnsafeIterator
name|reverseUnsafeEnd
argument_list|()
specifier|const
block|{
return|return
name|reverseUnsafe
operator|.
name|end
argument_list|()
return|;
block|}
block|}
empty_stmt|;
name|void
name|initialise
parameter_list|(
name|Solver
modifier|&
name|solver
parameter_list|)
block|{
name|this
operator|->
name|s
operator|=
operator|&
name|solver
expr_stmt|;
name|g
operator|=
operator|&
name|s
operator|->
name|getGraph
argument_list|()
expr_stmt|;
name|rNAllocableBucket
operator|=
name|RNAllocableNodeList
argument_list|(
name|LinkDegreeComparator
argument_list|(
name|g
argument_list|)
argument_list|)
expr_stmt|;
name|rNUnallocableBucket
operator|=
name|RNUnallocableNodeList
argument_list|(
name|SpillPriorityComparator
argument_list|(
name|g
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|GraphEdgeIterator
name|edgeItr
init|=
name|g
operator|->
name|edgesBegin
argument_list|()
init|,
name|edgeEnd
init|=
name|g
operator|->
name|edgesEnd
argument_list|()
init|;
name|edgeItr
operator|!=
name|edgeEnd
condition|;
operator|++
name|edgeItr
control|)
block|{
name|g
operator|->
name|getEdgeData
argument_list|(
name|edgeItr
argument_list|)
operator|.
name|getHeuristicData
argument_list|()
operator|.
name|setup
argument_list|(
operator|*
name|g
argument_list|,
name|edgeItr
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|GraphNodeIterator
name|nodeItr
init|=
name|g
operator|->
name|nodesBegin
argument_list|()
init|,
name|nodeEnd
init|=
name|g
operator|->
name|nodesEnd
argument_list|()
init|;
name|nodeItr
operator|!=
name|nodeEnd
condition|;
operator|++
name|nodeItr
control|)
block|{
name|g
operator|->
name|getNodeData
argument_list|(
name|nodeItr
argument_list|)
operator|.
name|getHeuristicData
argument_list|()
operator|.
name|setup
argument_list|(
operator|*
name|g
argument_list|,
name|nodeItr
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|addToRNBucket
parameter_list|(
specifier|const
name|GraphNodeIterator
modifier|&
name|nodeItr
parameter_list|)
block|{
name|NodeData
modifier|&
name|nodeData
init|=
name|g
operator|->
name|getNodeData
argument_list|(
name|nodeItr
argument_list|)
operator|.
name|getHeuristicData
argument_list|()
decl_stmt|;
if|if
condition|(
name|nodeData
operator|.
name|isAllocable
argument_list|()
condition|)
block|{
name|nodeData
operator|.
name|setRNAllocableNodeListItr
argument_list|(
name|rNAllocableBucket
operator|.
name|insert
argument_list|(
name|rNAllocableBucket
operator|.
name|begin
argument_list|()
argument_list|,
name|nodeItr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nodeData
operator|.
name|setRNUnallocableNodeListItr
argument_list|(
name|rNUnallocableBucket
operator|.
name|insert
argument_list|(
name|rNUnallocableBucket
operator|.
name|begin
argument_list|()
argument_list|,
name|nodeItr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|removeFromRNBucket
parameter_list|(
specifier|const
name|GraphNodeIterator
modifier|&
name|nodeItr
parameter_list|)
block|{
name|NodeData
modifier|&
name|nodeData
init|=
name|g
operator|->
name|getNodeData
argument_list|(
name|nodeItr
argument_list|)
operator|.
name|getHeuristicData
argument_list|()
decl_stmt|;
if|if
condition|(
name|nodeData
operator|.
name|isAllocable
argument_list|()
condition|)
block|{
name|rNAllocableBucket
operator|.
name|erase
argument_list|(
name|nodeData
operator|.
name|getRNAllocableNodeListItr
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rNUnallocableBucket
operator|.
name|erase
argument_list|(
name|nodeData
operator|.
name|getRNUnallocableNodeListItr
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|handleAddLink
parameter_list|(
specifier|const
name|GraphEdgeIterator
modifier|&
name|edgeItr
parameter_list|)
block|{
comment|// We assume that if we got here this edge is attached to at least
comment|// one high degree node.
name|g
operator|->
name|getEdgeData
argument_list|(
name|edgeItr
argument_list|)
operator|.
name|getHeuristicData
argument_list|()
operator|.
name|setup
argument_list|(
operator|*
name|g
argument_list|,
name|edgeItr
argument_list|)
expr_stmt|;
name|GraphNodeIterator
name|n1Itr
init|=
name|g
operator|->
name|getEdgeNode1Itr
argument_list|(
name|edgeItr
argument_list|)
decl_stmt|,
name|n2Itr
init|=
name|g
operator|->
name|getEdgeNode2Itr
argument_list|(
name|edgeItr
argument_list|)
decl_stmt|;
name|HSIT
operator|::
name|NodeData
operator|&
name|n1Data
operator|=
name|g
operator|->
name|getNodeData
argument_list|(
name|n1Itr
argument_list|)
operator|,
operator|&
name|n2Data
operator|=
name|g
operator|->
name|getNodeData
argument_list|(
name|n2Itr
argument_list|)
expr_stmt|;
if|if
condition|(
name|n1Data
operator|.
name|getLinkDegree
argument_list|()
operator|>
literal|2
condition|)
block|{
name|n1Data
operator|.
name|getHeuristicData
argument_list|()
operator|.
name|handleAddLink
argument_list|(
operator|*
name|g
argument_list|,
name|n1Itr
argument_list|,
name|edgeItr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n2Data
operator|.
name|getLinkDegree
argument_list|()
operator|>
literal|2
condition|)
block|{
name|n2Data
operator|.
name|getHeuristicData
argument_list|()
operator|.
name|handleAddLink
argument_list|(
operator|*
name|g
argument_list|,
name|n2Itr
argument_list|,
name|edgeItr
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|handleRemoveLink
parameter_list|(
specifier|const
name|GraphEdgeIterator
modifier|&
name|edgeItr
parameter_list|,
specifier|const
name|GraphNodeIterator
modifier|&
name|nodeItr
parameter_list|)
block|{
name|NodeData
modifier|&
name|nodeData
init|=
name|g
operator|->
name|getNodeData
argument_list|(
name|nodeItr
argument_list|)
operator|.
name|getHeuristicData
argument_list|()
decl_stmt|;
name|nodeData
operator|.
name|handleRemoveLink
argument_list|(
operator|*
name|g
argument_list|,
name|nodeItr
argument_list|,
name|edgeItr
argument_list|)
expr_stmt|;
block|}
name|void
name|processRN
parameter_list|()
block|{
if|if
condition|(
operator|!
name|rNAllocableBucket
operator|.
name|empty
argument_list|()
condition|)
block|{
name|GraphNodeIterator
name|selectedNodeItr
init|=
operator|*
name|rNAllocableBucket
operator|.
name|begin
argument_list|()
decl_stmt|;
comment|//std::cerr<< "RN safely pushing "<< g->getNodeID(selectedNodeItr)<< "\n";
name|rNAllocableBucket
operator|.
name|erase
argument_list|(
name|rNAllocableBucket
operator|.
name|begin
argument_list|()
argument_list|)
expr_stmt|;
name|s
operator|->
name|pushStack
argument_list|(
name|selectedNodeItr
argument_list|)
expr_stmt|;
name|s
operator|->
name|unlinkNode
argument_list|(
name|selectedNodeItr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|GraphNodeIterator
name|selectedNodeItr
init|=
operator|*
name|rNUnallocableBucket
operator|.
name|begin
argument_list|()
decl_stmt|;
comment|//std::cerr<< "RN optimistically pushing "<< g->getNodeID(selectedNodeItr)<< "\n";
name|rNUnallocableBucket
operator|.
name|erase
argument_list|(
name|rNUnallocableBucket
operator|.
name|begin
argument_list|()
argument_list|)
expr_stmt|;
name|s
operator|->
name|pushStack
argument_list|(
name|selectedNodeItr
argument_list|)
expr_stmt|;
name|s
operator|->
name|unlinkNode
argument_list|(
name|selectedNodeItr
argument_list|)
expr_stmt|;
block|}
block|}
name|bool
name|rNBucketEmpty
argument_list|()
specifier|const
block|{
return|return
operator|(
name|rNAllocableBucket
operator|.
name|empty
argument_list|()
operator|&&
name|rNUnallocableBucket
operator|.
name|empty
argument_list|()
operator|)
return|;
block|}
name|private
label|:
name|Solver
modifier|*
name|s
decl_stmt|;
name|SolverGraph
modifier|*
name|g
decl_stmt|;
name|RNAllocableNodeList
name|rNAllocableBucket
decl_stmt|;
name|RNUnallocableNodeList
name|rNUnallocableBucket
decl_stmt|;
block|}
empty_stmt|;
block|}
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_CODEGEN_PBQP_HEURISTICS_BRIGGS_H
end_comment

end_unit

