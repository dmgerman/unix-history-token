begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- GraphBase.h - Abstract Base PBQP Graph ------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Base class for PBQP Graphs.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_PBQP_GRAPHBASE_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_PBQP_GRAPHBASE_H
end_define

begin_include
include|#
directive|include
file|"PBQPMath.h"
end_include

begin_include
include|#
directive|include
file|<list>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|PBQP
block|{
comment|// UGLY, but I'm not sure there's a good way around this: We need to be able to
comment|// look up a Node's "adjacent edge list" structure type before the Node type is
comment|// fully constructed.  We can enable this by pushing the choice of data type
comment|// out into this traits class.
name|template
operator|<
name|typename
name|Graph
operator|>
name|class
name|NodeBaseTraits
block|{
name|public
operator|:
typedef|typedef
name|std
operator|::
name|list
operator|<
name|typename
name|Graph
operator|::
name|EdgeIterator
operator|>
name|AdjEdgeList
expr_stmt|;
typedef|typedef
name|typename
name|AdjEdgeList
operator|::
name|iterator
name|AdjEdgeIterator
expr_stmt|;
typedef|typedef
name|typename
name|AdjEdgeList
operator|::
name|const_iterator
name|ConstAdjEdgeIterator
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// \brief Base for concrete graph classes. Provides a basic set of graph
end_comment

begin_comment
comment|///        operations which are useful for PBQP solvers.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|NodeEntry
operator|,
name|typename
name|EdgeEntry
operator|>
name|class
name|GraphBase
block|{
name|private
operator|:
typedef|typedef
name|GraphBase
operator|<
name|NodeEntry
operator|,
name|EdgeEntry
operator|>
name|ThisGraphT
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|std
operator|::
name|list
operator|<
name|NodeEntry
operator|>
name|NodeList
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|std
operator|::
name|list
operator|<
name|EdgeEntry
operator|>
name|EdgeList
expr_stmt|;
end_typedef

begin_decl_stmt
name|NodeList
name|nodeList
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|nodeListSize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|EdgeList
name|edgeList
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|edgeListSize
decl_stmt|;
end_decl_stmt

begin_macro
name|GraphBase
argument_list|(
argument|const ThisGraphT&other
argument_list|)
end_macro

begin_block
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|void
name|operator
init|=
operator|(
specifier|const
name|ThisGraphT
operator|&
name|other
operator|)
block|{
name|abort
argument_list|()
block|; }
name|public
operator|:
end_decl_stmt

begin_comment
comment|/// \brief Iterates over the nodes of a graph.
end_comment

begin_typedef
typedef|typedef
name|typename
name|NodeList
operator|::
name|iterator
name|NodeIterator
expr_stmt|;
end_typedef

begin_comment
comment|/// \brief Iterates over the nodes of a const graph.
end_comment

begin_typedef
typedef|typedef
name|typename
name|NodeList
operator|::
name|const_iterator
name|ConstNodeIterator
expr_stmt|;
end_typedef

begin_comment
comment|/// \brief Iterates over the edges of a graph.
end_comment

begin_typedef
typedef|typedef
name|typename
name|EdgeList
operator|::
name|iterator
name|EdgeIterator
expr_stmt|;
end_typedef

begin_comment
comment|/// \brief Iterates over the edges of a const graph.
end_comment

begin_typedef
typedef|typedef
name|typename
name|EdgeList
operator|::
name|const_iterator
name|ConstEdgeIterator
expr_stmt|;
end_typedef

begin_comment
comment|/// \brief Iterates over the edges attached to a node.
end_comment

begin_typedef
typedef|typedef
name|typename
name|NodeBaseTraits
operator|<
name|ThisGraphT
operator|>
operator|::
name|AdjEdgeIterator
name|AdjEdgeIterator
expr_stmt|;
end_typedef

begin_comment
comment|/// \brief Iterates over the edges attached to a node in a const graph.
end_comment

begin_typedef
typedef|typedef
name|typename
name|NodeBaseTraits
operator|<
name|ThisGraphT
operator|>
operator|::
name|ConstAdjEdgeIterator
name|ConstAdjEdgeIterator
expr_stmt|;
end_typedef

begin_label
name|private
label|:
end_label

begin_typedef
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|NodeIterator
operator|>
name|IDToNodeMap
expr_stmt|;
end_typedef

begin_decl_stmt
name|IDToNodeMap
name|idToNodeMap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|nodeIDsValid
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|invalidateNodeIDs
parameter_list|()
block|{
if|if
condition|(
name|nodeIDsValid
condition|)
block|{
name|idToNodeMap
operator|.
name|clear
argument_list|()
expr_stmt|;
name|nodeIDsValid
operator|=
name|false
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
name|template
operator|<
name|typename
name|ItrT
operator|>
name|bool
name|iteratorInRange
argument_list|(
argument|ItrT itr
argument_list|,
argument|const ItrT&begin
argument_list|,
argument|const ItrT&end
argument_list|)
block|{
for|for
control|(
name|ItrT
name|t
init|=
name|begin
init|;
name|t
operator|!=
name|end
condition|;
operator|++
name|t
control|)
block|{
if|if
condition|(
name|itr
operator|==
name|t
condition|)
return|return
name|true
return|;
block|}
end_expr_stmt

begin_return
return|return
name|false
return|;
end_return

begin_expr_stmt
unit|}  protected:
name|GraphBase
argument_list|()
operator|:
name|nodeListSize
argument_list|(
literal|0
argument_list|)
operator|,
name|edgeListSize
argument_list|(
literal|0
argument_list|)
operator|,
name|nodeIDsValid
argument_list|(
argument|false
argument_list|)
block|{}
name|NodeEntry
operator|&
name|getNodeEntry
argument_list|(
argument|const NodeIterator&nodeItr
argument_list|)
block|{
return|return
operator|*
name|nodeItr
return|;
block|}
end_expr_stmt

begin_decl_stmt
specifier|const
name|NodeEntry
modifier|&
name|getNodeEntry
argument_list|(
specifier|const
name|ConstNodeIterator
operator|&
name|nodeItr
argument_list|)
decl|const
block|{
return|return
operator|*
name|nodeItr
return|;
block|}
end_decl_stmt

begin_function
name|EdgeEntry
modifier|&
name|getEdgeEntry
parameter_list|(
specifier|const
name|EdgeIterator
modifier|&
name|edgeItr
parameter_list|)
block|{
return|return
operator|*
name|edgeItr
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|EdgeEntry
modifier|&
name|getEdgeEntry
argument_list|(
specifier|const
name|ConstEdgeIterator
operator|&
name|edgeItr
argument_list|)
decl|const
block|{
return|return
operator|*
name|edgeItr
return|;
block|}
end_decl_stmt

begin_function
name|NodeIterator
name|addConstructedNode
parameter_list|(
specifier|const
name|NodeEntry
modifier|&
name|nodeEntry
parameter_list|)
block|{
operator|++
name|nodeListSize
expr_stmt|;
name|invalidateNodeIDs
argument_list|()
expr_stmt|;
name|NodeIterator
name|newNodeItr
init|=
name|nodeList
operator|.
name|insert
argument_list|(
name|nodeList
operator|.
name|end
argument_list|()
argument_list|,
name|nodeEntry
argument_list|)
decl_stmt|;
return|return
name|newNodeItr
return|;
block|}
end_function

begin_function
name|EdgeIterator
name|addConstructedEdge
parameter_list|(
specifier|const
name|EdgeEntry
modifier|&
name|edgeEntry
parameter_list|)
block|{
name|assert
argument_list|(
operator|(
name|findEdge
argument_list|(
name|edgeEntry
operator|.
name|getNode1Itr
argument_list|()
argument_list|,
name|edgeEntry
operator|.
name|getNode2Itr
argument_list|()
argument_list|)
operator|==
name|edgeList
operator|.
name|end
argument_list|()
operator|)
operator|&&
literal|"Attempt to add duplicate edge."
argument_list|)
expr_stmt|;
operator|++
name|edgeListSize
expr_stmt|;
comment|// Add the edge to the graph.
name|EdgeIterator
name|edgeItr
init|=
name|edgeList
operator|.
name|insert
argument_list|(
name|edgeList
operator|.
name|end
argument_list|()
argument_list|,
name|edgeEntry
argument_list|)
decl_stmt|;
comment|// Get a reference to the version in the graph.
name|EdgeEntry
modifier|&
name|newEdgeEntry
init|=
name|getEdgeEntry
argument_list|(
name|edgeItr
argument_list|)
decl_stmt|;
comment|// Node entries:
name|NodeEntry
modifier|&
name|node1Entry
init|=
name|getNodeEntry
argument_list|(
name|newEdgeEntry
operator|.
name|getNode1Itr
argument_list|()
argument_list|)
decl_stmt|,
modifier|&
name|node2Entry
init|=
name|getNodeEntry
argument_list|(
name|newEdgeEntry
operator|.
name|getNode2Itr
argument_list|()
argument_list|)
decl_stmt|;
comment|// Sanity check on matrix dimensions.
name|assert
argument_list|(
operator|(
name|node1Entry
operator|.
name|getCosts
argument_list|()
operator|.
name|getLength
argument_list|()
operator|==
name|newEdgeEntry
operator|.
name|getCosts
argument_list|()
operator|.
name|getRows
argument_list|()
operator|)
operator|&&
operator|(
name|node2Entry
operator|.
name|getCosts
argument_list|()
operator|.
name|getLength
argument_list|()
operator|==
name|newEdgeEntry
operator|.
name|getCosts
argument_list|()
operator|.
name|getCols
argument_list|()
operator|)
operator|&&
literal|"Matrix dimensions do not match cost vector dimensions."
argument_list|)
expr_stmt|;
comment|// Create links between nodes and edges.
name|newEdgeEntry
operator|.
name|setNode1ThisEdgeItr
argument_list|(
name|node1Entry
operator|.
name|addAdjEdge
argument_list|(
name|edgeItr
argument_list|)
argument_list|)
expr_stmt|;
name|newEdgeEntry
operator|.
name|setNode2ThisEdgeItr
argument_list|(
name|node2Entry
operator|.
name|addAdjEdge
argument_list|(
name|edgeItr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|edgeItr
return|;
block|}
end_function

begin_label
name|public
label|:
end_label

begin_comment
comment|/// \brief Returns the number of nodes in this graph.
end_comment

begin_expr_stmt
name|unsigned
name|getNumNodes
argument_list|()
specifier|const
block|{
return|return
name|nodeListSize
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief Returns the number of edges in this graph.
end_comment

begin_expr_stmt
name|unsigned
name|getNumEdges
argument_list|()
specifier|const
block|{
return|return
name|edgeListSize
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief Return the cost vector for the given node.
end_comment

begin_function
name|Vector
modifier|&
name|getNodeCosts
parameter_list|(
specifier|const
name|NodeIterator
modifier|&
name|nodeItr
parameter_list|)
block|{
return|return
name|getNodeEntry
argument_list|(
name|nodeItr
argument_list|)
operator|.
name|getCosts
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/// \brief Return the cost vector for the give node.
end_comment

begin_decl_stmt
specifier|const
name|Vector
modifier|&
name|getNodeCosts
argument_list|(
specifier|const
name|ConstNodeIterator
operator|&
name|nodeItr
argument_list|)
decl|const
block|{
return|return
name|getNodeEntry
argument_list|(
name|nodeItr
argument_list|)
operator|.
name|getCosts
argument_list|()
return|;
block|}
end_decl_stmt

begin_comment
comment|/// \brief Return the degree of the given node.
end_comment

begin_decl_stmt
name|unsigned
name|getNodeDegree
argument_list|(
specifier|const
name|NodeIterator
operator|&
name|nodeItr
argument_list|)
decl|const
block|{
return|return
name|getNodeEntry
argument_list|(
name|nodeItr
argument_list|)
operator|.
name|getDegree
argument_list|()
return|;
block|}
end_decl_stmt

begin_comment
comment|/// \brief Assigns sequential IDs to the nodes, starting at 0, which
end_comment

begin_comment
comment|/// remain valid until the next addition or removal of a node.
end_comment

begin_function
name|void
name|assignNodeIDs
parameter_list|()
block|{
name|unsigned
name|curID
init|=
literal|0
decl_stmt|;
name|idToNodeMap
operator|.
name|resize
argument_list|(
name|getNumNodes
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|NodeIterator
name|nodeItr
init|=
name|nodesBegin
argument_list|()
init|,
name|nodeEnd
init|=
name|nodesEnd
argument_list|()
init|;
name|nodeItr
operator|!=
name|nodeEnd
condition|;
operator|++
name|nodeItr
operator|,
operator|++
name|curID
control|)
block|{
name|getNodeEntry
argument_list|(
name|nodeItr
argument_list|)
operator|.
name|setID
argument_list|(
name|curID
argument_list|)
expr_stmt|;
name|idToNodeMap
index|[
name|curID
index|]
operator|=
name|nodeItr
expr_stmt|;
block|}
name|nodeIDsValid
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/// \brief Assigns sequential IDs to the nodes using the ordering of the
end_comment

begin_comment
comment|/// given vector.
end_comment

begin_decl_stmt
name|void
name|assignNodeIDs
argument_list|(
specifier|const
name|std
operator|::
name|vector
operator|<
name|NodeIterator
operator|>
operator|&
name|nodeOrdering
argument_list|)
block|{
name|assert
argument_list|(
operator|(
name|getNumNodes
argument_list|()
operator|==
name|nodeOrdering
operator|.
name|size
argument_list|()
operator|)
operator|&&
literal|"Wrong number of nodes in node ordering."
argument_list|)
expr_stmt|;
name|idToNodeMap
operator|=
name|nodeOrdering
expr_stmt|;
for|for
control|(
name|unsigned
name|nodeID
init|=
literal|0
init|;
name|nodeID
operator|<
name|idToNodeMap
operator|.
name|size
argument_list|()
condition|;
operator|++
name|nodeID
control|)
block|{
name|getNodeEntry
argument_list|(
name|idToNodeMap
index|[
name|nodeID
index|]
argument_list|)
operator|.
name|setID
argument_list|(
name|nodeID
argument_list|)
expr_stmt|;
block|}
name|nodeIDsValid
operator|=
name|true
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/// \brief Returns true if valid node IDs are assigned, false otherwise.
end_comment

begin_expr_stmt
name|bool
name|areNodeIDsValid
argument_list|()
specifier|const
block|{
return|return
name|nodeIDsValid
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief Return the numeric ID of the given node.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Calls to this method will result in an assertion failure if there have
end_comment

begin_comment
comment|/// been any node additions or removals since the last call to
end_comment

begin_comment
comment|/// assignNodeIDs().
end_comment

begin_decl_stmt
name|unsigned
name|getNodeID
argument_list|(
specifier|const
name|ConstNodeIterator
operator|&
name|nodeItr
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|nodeIDsValid
operator|&&
literal|"Attempt to retrieve invalid ID."
argument_list|)
expr_stmt|;
return|return
name|getNodeEntry
argument_list|(
name|nodeItr
argument_list|)
operator|.
name|getID
argument_list|()
return|;
block|}
end_decl_stmt

begin_comment
comment|/// \brief Returns the iterator associated with the given node ID.
end_comment

begin_function
name|NodeIterator
name|getNodeItr
parameter_list|(
name|unsigned
name|nodeID
parameter_list|)
block|{
name|assert
argument_list|(
name|nodeIDsValid
operator|&&
literal|"Attempt to retrieve iterator with invalid ID."
argument_list|)
expr_stmt|;
return|return
name|idToNodeMap
index|[
name|nodeID
index|]
return|;
block|}
end_function

begin_comment
comment|/// \brief Returns the iterator associated with the given node ID.
end_comment

begin_decl_stmt
name|ConstNodeIterator
name|getNodeItr
argument_list|(
name|unsigned
name|nodeID
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|nodeIDsValid
operator|&&
literal|"Attempt to retrieve iterator with invalid ID."
argument_list|)
expr_stmt|;
return|return
name|idToNodeMap
index|[
name|nodeID
index|]
return|;
block|}
end_decl_stmt

begin_comment
comment|/// \brief Removes the given node (and all attached edges) from the graph.
end_comment

begin_function
name|void
name|removeNode
parameter_list|(
specifier|const
name|NodeIterator
modifier|&
name|nodeItr
parameter_list|)
block|{
name|assert
argument_list|(
name|iteratorInRange
argument_list|(
name|nodeItr
argument_list|,
name|nodeList
operator|.
name|begin
argument_list|()
argument_list|,
name|nodeList
operator|.
name|end
argument_list|()
argument_list|)
operator|&&
literal|"Iterator does not belong to this graph!"
argument_list|)
expr_stmt|;
name|invalidateNodeIDs
argument_list|()
expr_stmt|;
name|NodeEntry
modifier|&
name|nodeEntry
init|=
name|getNodeEntry
argument_list|(
name|nodeItr
argument_list|)
decl_stmt|;
comment|// We need to copy this out because it will be destroyed as the edges are
comment|// removed.
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|EdgeIterator
operator|>
name|AdjEdgeList
expr_stmt|;
typedef|typedef
name|typename
name|AdjEdgeList
operator|::
name|iterator
name|AdjEdgeListItr
expr_stmt|;
name|AdjEdgeList
name|adjEdges
decl_stmt|;
name|adjEdges
operator|.
name|reserve
argument_list|(
name|nodeEntry
operator|.
name|getDegree
argument_list|()
argument_list|)
expr_stmt|;
name|std
operator|::
name|copy
argument_list|(
name|nodeEntry
operator|.
name|adjEdgesBegin
argument_list|()
argument_list|,
name|nodeEntry
operator|.
name|adjEdgesEnd
argument_list|()
argument_list|,
name|std
operator|::
name|back_inserter
argument_list|(
name|adjEdges
argument_list|)
argument_list|)
expr_stmt|;
comment|// Iterate over the copied out edges and remove them from the graph.
for|for
control|(
name|AdjEdgeListItr
name|itr
init|=
name|adjEdges
operator|.
name|begin
argument_list|()
init|,
name|end
init|=
name|adjEdges
operator|.
name|end
argument_list|()
init|;
name|itr
operator|!=
name|end
condition|;
operator|++
name|itr
control|)
block|{
name|removeEdge
argument_list|(
operator|*
name|itr
argument_list|)
expr_stmt|;
block|}
comment|// Erase the node from the nodelist.
name|nodeList
operator|.
name|erase
argument_list|(
name|nodeItr
argument_list|)
expr_stmt|;
operator|--
name|nodeListSize
expr_stmt|;
block|}
end_function

begin_function
name|NodeIterator
name|nodesBegin
parameter_list|()
block|{
return|return
name|nodeList
operator|.
name|begin
argument_list|()
return|;
block|}
end_function

begin_expr_stmt
name|ConstNodeIterator
name|nodesBegin
argument_list|()
specifier|const
block|{
return|return
name|nodeList
operator|.
name|begin
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
name|NodeIterator
name|nodesEnd
parameter_list|()
block|{
return|return
name|nodeList
operator|.
name|end
argument_list|()
return|;
block|}
end_function

begin_expr_stmt
name|ConstNodeIterator
name|nodesEnd
argument_list|()
specifier|const
block|{
return|return
name|nodeList
operator|.
name|end
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
name|AdjEdgeIterator
name|adjEdgesBegin
parameter_list|(
specifier|const
name|NodeIterator
modifier|&
name|nodeItr
parameter_list|)
block|{
return|return
name|getNodeEntry
argument_list|(
name|nodeItr
argument_list|)
operator|.
name|adjEdgesBegin
argument_list|()
return|;
block|}
end_function

begin_decl_stmt
name|ConstAdjEdgeIterator
name|adjEdgesBegin
argument_list|(
specifier|const
name|ConstNodeIterator
operator|&
name|nodeItr
argument_list|)
decl|const
block|{
return|return
name|getNodeEntry
argument_list|(
name|nodeItr
argument_list|)
operator|.
name|adjEdgesBegin
argument_list|()
return|;
block|}
end_decl_stmt

begin_function
name|AdjEdgeIterator
name|adjEdgesEnd
parameter_list|(
specifier|const
name|NodeIterator
modifier|&
name|nodeItr
parameter_list|)
block|{
return|return
name|getNodeEntry
argument_list|(
name|nodeItr
argument_list|)
operator|.
name|adjEdgesEnd
argument_list|()
return|;
block|}
end_function

begin_decl_stmt
name|ConstAdjEdgeIterator
name|adjEdgesEnd
argument_list|(
specifier|const
name|ConstNodeIterator
operator|&
name|nodeItr
argument_list|)
decl|const
block|{
name|getNodeEntry
argument_list|(
name|nodeItr
argument_list|)
operator|.
name|adjEdgesEnd
argument_list|()
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|EdgeIterator
name|findEdge
parameter_list|(
specifier|const
name|NodeIterator
modifier|&
name|node1Itr
parameter_list|,
specifier|const
name|NodeIterator
modifier|&
name|node2Itr
parameter_list|)
block|{
for|for
control|(
name|AdjEdgeIterator
name|adjEdgeItr
init|=
name|adjEdgesBegin
argument_list|(
name|node1Itr
argument_list|)
init|,
name|adjEdgeEnd
init|=
name|adjEdgesEnd
argument_list|(
name|node1Itr
argument_list|)
init|;
name|adjEdgeItr
operator|!=
name|adjEdgeEnd
condition|;
operator|++
name|adjEdgeItr
control|)
block|{
if|if
condition|(
operator|(
name|getEdgeNode1Itr
argument_list|(
operator|*
name|adjEdgeItr
argument_list|)
operator|==
name|node2Itr
operator|)
operator|||
operator|(
name|getEdgeNode2Itr
argument_list|(
operator|*
name|adjEdgeItr
argument_list|)
operator|==
name|node2Itr
operator|)
condition|)
block|{
return|return
operator|*
name|adjEdgeItr
return|;
block|}
block|}
return|return
name|edgeList
operator|.
name|end
argument_list|()
return|;
block|}
end_function

begin_decl_stmt
name|ConstEdgeIterator
name|findEdge
argument_list|(
specifier|const
name|ConstNodeIterator
operator|&
name|node1Itr
argument_list|,
specifier|const
name|ConstNodeIterator
operator|&
name|node2Itr
argument_list|)
decl|const
block|{
for|for
control|(
name|ConstAdjEdgeIterator
name|adjEdgeItr
init|=
name|adjEdgesBegin
argument_list|(
name|node1Itr
argument_list|)
init|,
name|adjEdgeEnd
init|=
name|adjEdgesEnd
argument_list|(
name|node1Itr
argument_list|)
init|;
name|adjEdgeItr
operator|!=
name|adjEdgeEnd
condition|;
operator|++
name|adjEdgeItr
control|)
block|{
if|if
condition|(
operator|(
name|getEdgeNode1Itr
argument_list|(
operator|*
name|adjEdgeItr
argument_list|)
operator|==
name|node2Itr
operator|)
operator|||
operator|(
name|getEdgeNode2Itr
argument_list|(
operator|*
name|adjEdgeItr
argument_list|)
operator|==
name|node2Itr
operator|)
condition|)
block|{
return|return
operator|*
name|adjEdgeItr
return|;
block|}
block|}
return|return
name|edgeList
operator|.
name|end
argument_list|()
return|;
block|}
end_decl_stmt

begin_function
name|Matrix
modifier|&
name|getEdgeCosts
parameter_list|(
specifier|const
name|EdgeIterator
modifier|&
name|edgeItr
parameter_list|)
block|{
return|return
name|getEdgeEntry
argument_list|(
name|edgeItr
argument_list|)
operator|.
name|getCosts
argument_list|()
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|Matrix
modifier|&
name|getEdgeCosts
argument_list|(
specifier|const
name|ConstEdgeIterator
operator|&
name|edgeItr
argument_list|)
decl|const
block|{
return|return
name|getEdgeEntry
argument_list|(
name|edgeItr
argument_list|)
operator|.
name|getCosts
argument_list|()
return|;
block|}
end_decl_stmt

begin_function
name|NodeIterator
name|getEdgeNode1Itr
parameter_list|(
specifier|const
name|EdgeIterator
modifier|&
name|edgeItr
parameter_list|)
block|{
return|return
name|getEdgeEntry
argument_list|(
name|edgeItr
argument_list|)
operator|.
name|getNode1Itr
argument_list|()
return|;
block|}
end_function

begin_decl_stmt
name|ConstNodeIterator
name|getEdgeNode1Itr
argument_list|(
specifier|const
name|ConstEdgeIterator
operator|&
name|edgeItr
argument_list|)
decl|const
block|{
return|return
name|getEdgeEntry
argument_list|(
name|edgeItr
argument_list|)
operator|.
name|getNode1Itr
argument_list|()
return|;
block|}
end_decl_stmt

begin_function
name|NodeIterator
name|getEdgeNode2Itr
parameter_list|(
specifier|const
name|EdgeIterator
modifier|&
name|edgeItr
parameter_list|)
block|{
return|return
name|getEdgeEntry
argument_list|(
name|edgeItr
argument_list|)
operator|.
name|getNode2Itr
argument_list|()
return|;
block|}
end_function

begin_decl_stmt
name|ConstNodeIterator
name|getEdgeNode2Itr
argument_list|(
specifier|const
name|ConstEdgeIterator
operator|&
name|edgeItr
argument_list|)
decl|const
block|{
return|return
name|getEdgeEntry
argument_list|(
name|edgeItr
argument_list|)
operator|.
name|getNode2Itr
argument_list|()
return|;
block|}
end_decl_stmt

begin_function
name|NodeIterator
name|getEdgeOtherNode
parameter_list|(
specifier|const
name|EdgeIterator
modifier|&
name|edgeItr
parameter_list|,
specifier|const
name|NodeIterator
modifier|&
name|nodeItr
parameter_list|)
block|{
name|EdgeEntry
modifier|&
name|edgeEntry
init|=
name|getEdgeEntry
argument_list|(
name|edgeItr
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodeItr
operator|==
name|edgeEntry
operator|.
name|getNode1Itr
argument_list|()
condition|)
block|{
return|return
name|edgeEntry
operator|.
name|getNode2Itr
argument_list|()
return|;
block|}
comment|//else
return|return
name|edgeEntry
operator|.
name|getNode1Itr
argument_list|()
return|;
block|}
end_function

begin_decl_stmt
name|ConstNodeIterator
name|getEdgeOtherNode
argument_list|(
specifier|const
name|ConstEdgeIterator
operator|&
name|edgeItr
argument_list|,
specifier|const
name|ConstNodeIterator
operator|&
name|nodeItr
argument_list|)
decl|const
block|{
specifier|const
name|EdgeEntry
modifier|&
name|edgeEntry
init|=
name|getEdgeEntry
argument_list|(
name|edgeItr
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodeItr
operator|==
name|edgeEntry
operator|.
name|getNode1Itr
argument_list|()
condition|)
block|{
return|return
name|edgeEntry
operator|.
name|getNode2Itr
argument_list|()
return|;
block|}
comment|//else
return|return
name|edgeEntry
operator|.
name|getNode1Itr
argument_list|()
return|;
block|}
end_decl_stmt

begin_function
name|void
name|removeEdge
parameter_list|(
specifier|const
name|EdgeIterator
modifier|&
name|edgeItr
parameter_list|)
block|{
name|assert
argument_list|(
name|iteratorInRange
argument_list|(
name|edgeItr
argument_list|,
name|edgeList
operator|.
name|begin
argument_list|()
argument_list|,
name|edgeList
operator|.
name|end
argument_list|()
argument_list|)
operator|&&
literal|"Iterator does not belong to this graph!"
argument_list|)
expr_stmt|;
operator|--
name|edgeListSize
expr_stmt|;
comment|// Get the edge entry.
name|EdgeEntry
modifier|&
name|edgeEntry
init|=
name|getEdgeEntry
argument_list|(
name|edgeItr
argument_list|)
decl_stmt|;
comment|// Get the nodes entry.
name|NodeEntry
modifier|&
name|node1Entry
argument_list|(
name|getNodeEntry
argument_list|(
name|edgeEntry
operator|.
name|getNode1Itr
argument_list|()
argument_list|)
argument_list|)
decl_stmt|,
modifier|&
name|node2Entry
argument_list|(
name|getNodeEntry
argument_list|(
name|edgeEntry
operator|.
name|getNode2Itr
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
comment|// Disconnect the edge from the nodes.
name|node1Entry
operator|.
name|removeAdjEdge
argument_list|(
name|edgeEntry
operator|.
name|getNode1ThisEdgeItr
argument_list|()
argument_list|)
expr_stmt|;
name|node2Entry
operator|.
name|removeAdjEdge
argument_list|(
name|edgeEntry
operator|.
name|getNode2ThisEdgeItr
argument_list|()
argument_list|)
expr_stmt|;
comment|// Remove the edge from the graph.
name|edgeList
operator|.
name|erase
argument_list|(
name|edgeItr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|EdgeIterator
name|edgesBegin
parameter_list|()
block|{
return|return
name|edgeList
operator|.
name|begin
argument_list|()
return|;
block|}
end_function

begin_expr_stmt
name|ConstEdgeIterator
name|edgesBegin
argument_list|()
specifier|const
block|{
return|return
name|edgeList
operator|.
name|begin
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
name|EdgeIterator
name|edgesEnd
parameter_list|()
block|{
return|return
name|edgeList
operator|.
name|end
argument_list|()
return|;
block|}
end_function

begin_expr_stmt
name|ConstEdgeIterator
name|edgesEnd
argument_list|()
specifier|const
block|{
return|return
name|edgeList
operator|.
name|end
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
name|void
name|clear
parameter_list|()
block|{
name|nodeList
operator|.
name|clear
argument_list|()
expr_stmt|;
name|nodeListSize
operator|=
literal|0
expr_stmt|;
name|edgeList
operator|.
name|clear
argument_list|()
expr_stmt|;
name|edgeListSize
operator|=
literal|0
expr_stmt|;
name|idToNodeMap
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|template
operator|<
name|typename
name|OStream
operator|>
name|void
name|printDot
argument_list|(
argument|OStream&os
argument_list|)
specifier|const
block|{
name|assert
argument_list|(
name|areNodeIDsValid
argument_list|()
operator|&&
literal|"Cannot print a .dot of a graph unless IDs have been assigned."
argument_list|)
block|;
name|os
operator|<<
literal|"graph {\n"
block|;
for|for
control|(
name|ConstNodeIterator
name|nodeItr
init|=
name|nodesBegin
argument_list|()
init|,
name|nodeEnd
init|=
name|nodesEnd
argument_list|()
init|;
name|nodeItr
operator|!=
name|nodeEnd
condition|;
operator|++
name|nodeItr
control|)
block|{
name|os
operator|<<
literal|"  node"
operator|<<
name|getNodeID
argument_list|(
name|nodeItr
argument_list|)
operator|<<
literal|" [ label=\""
operator|<<
name|getNodeID
argument_list|(
name|nodeItr
argument_list|)
operator|<<
literal|": "
operator|<<
name|getNodeCosts
argument_list|(
name|nodeItr
argument_list|)
operator|<<
literal|"\" ]\n"
expr_stmt|;
block|}
name|os
operator|<<
literal|"  edge [ len="
operator|<<
name|getNumNodes
argument_list|()
operator|<<
literal|" ]\n"
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|ConstEdgeIterator
name|edgeItr
init|=
name|edgesBegin
argument_list|()
init|,
name|edgeEnd
init|=
name|edgesEnd
argument_list|()
init|;
name|edgeItr
operator|!=
name|edgeEnd
condition|;
operator|++
name|edgeItr
control|)
block|{
name|os
operator|<<
literal|"  node"
operator|<<
name|getNodeID
argument_list|(
name|getEdgeNode1Itr
argument_list|(
name|edgeItr
argument_list|)
argument_list|)
operator|<<
literal|" -- node"
operator|<<
name|getNodeID
argument_list|(
name|getEdgeNode2Itr
argument_list|(
name|edgeItr
argument_list|)
argument_list|)
operator|<<
literal|" [ label=\""
expr_stmt|;
specifier|const
name|Matrix
modifier|&
name|edgeCosts
init|=
name|getEdgeCosts
argument_list|(
name|edgeItr
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|edgeCosts
operator|.
name|getRows
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
name|os
operator|<<
name|edgeCosts
operator|.
name|getRowAsVector
argument_list|(
name|i
argument_list|)
operator|<<
literal|"\\n"
expr_stmt|;
block|}
name|os
operator|<<
literal|"\" ]\n"
expr_stmt|;
block|}
end_for

begin_expr_stmt
name|os
operator|<<
literal|"}\n"
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}    template
operator|<
name|typename
name|OStream
operator|>
name|void
name|printDot
argument_list|(
argument|OStream&os
argument_list|)
block|{
if|if
condition|(
operator|!
name|areNodeIDsValid
argument_list|()
condition|)
block|{
name|assignNodeIDs
argument_list|()
expr_stmt|;
block|}
name|const_cast
operator|<
specifier|const
name|ThisGraphT
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|printDot
argument_list|(
name|os
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}    template
operator|<
name|typename
name|OStream
operator|>
name|void
name|dumpTo
argument_list|(
argument|OStream&os
argument_list|)
specifier|const
block|{
typedef|typedef
name|ConstNodeIterator
name|ConstNodeID
typedef|;
name|assert
argument_list|(
name|areNodeIDsValid
argument_list|()
operator|&&
literal|"Cannot dump a graph unless IDs have been assigned."
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|ConstNodeIterator
name|nItr
init|=
name|nodesBegin
argument_list|()
init|,
name|nEnd
init|=
name|nodesEnd
argument_list|()
init|;
name|nItr
operator|!=
name|nEnd
condition|;
operator|++
name|nItr
control|)
block|{
name|os
operator|<<
name|getNodeID
argument_list|(
name|nItr
argument_list|)
operator|<<
literal|"\n"
expr_stmt|;
block|}
end_for

begin_decl_stmt
name|unsigned
name|edgeNumber
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_for
for|for
control|(
name|ConstEdgeIterator
name|eItr
init|=
name|edgesBegin
argument_list|()
init|,
name|eEnd
init|=
name|edgesEnd
argument_list|()
init|;
name|eItr
operator|!=
name|eEnd
condition|;
operator|++
name|eItr
control|)
block|{
name|os
operator|<<
name|edgeNumber
operator|++
operator|<<
literal|": { "
operator|<<
name|getNodeID
argument_list|(
name|getEdgeNode1Itr
argument_list|(
name|eItr
argument_list|)
argument_list|)
operator|<<
literal|", "
operator|<<
name|getNodeID
argument_list|(
name|getEdgeNode2Itr
argument_list|(
name|eItr
argument_list|)
argument_list|)
operator|<<
literal|" }\n"
expr_stmt|;
block|}
end_for

begin_expr_stmt
unit|}    template
operator|<
name|typename
name|OStream
operator|>
name|void
name|dumpTo
argument_list|(
argument|OStream&os
argument_list|)
block|{
if|if
condition|(
operator|!
name|areNodeIDsValid
argument_list|()
condition|)
block|{
name|assignNodeIDs
argument_list|()
expr_stmt|;
block|}
name|const_cast
operator|<
specifier|const
name|ThisGraphT
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|dumpTo
argument_list|(
name|os
argument_list|)
expr_stmt|;
end_expr_stmt

begin_empty_stmt
unit|}  }
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// \brief Provides a base from which to derive nodes for GraphBase.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|NodeImpl
operator|,
name|typename
name|EdgeImpl
operator|>
name|class
name|NodeBase
block|{
name|private
operator|:
typedef|typedef
name|GraphBase
operator|<
name|NodeImpl
operator|,
name|EdgeImpl
operator|>
name|GraphBaseT
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|NodeBaseTraits
operator|<
name|GraphBaseT
operator|>
name|ThisNodeBaseTraits
expr_stmt|;
end_typedef

begin_label
name|public
label|:
end_label

begin_typedef
typedef|typedef
name|typename
name|GraphBaseT
operator|::
name|EdgeIterator
name|EdgeIterator
expr_stmt|;
end_typedef

begin_label
name|private
label|:
end_label

begin_typedef
typedef|typedef
name|typename
name|ThisNodeBaseTraits
operator|::
name|AdjEdgeList
name|AdjEdgeList
expr_stmt|;
end_typedef

begin_decl_stmt
name|unsigned
name|degree
decl_stmt|,
name|id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Vector
name|costs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|AdjEdgeList
name|adjEdges
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|operator
init|=
operator|(
specifier|const
name|NodeBase
operator|&
name|other
operator|)
block|{
name|assert
argument_list|(
name|false
operator|&&
literal|"Can't assign NodeEntrys."
argument_list|)
block|;   }
name|public
operator|:
end_decl_stmt

begin_typedef
typedef|typedef
name|typename
name|ThisNodeBaseTraits
operator|::
name|AdjEdgeIterator
name|AdjEdgeIterator
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|ThisNodeBaseTraits
operator|::
name|ConstAdjEdgeIterator
name|ConstAdjEdgeIterator
expr_stmt|;
end_typedef

begin_expr_stmt
name|NodeBase
argument_list|(
specifier|const
name|Vector
operator|&
name|costs
argument_list|)
operator|:
name|degree
argument_list|(
literal|0
argument_list|)
operator|,
name|costs
argument_list|(
argument|costs
argument_list|)
block|{
name|assert
argument_list|(
operator|(
name|costs
operator|.
name|getLength
argument_list|()
operator|>
literal|0
operator|)
operator|&&
literal|"Can't have zero-length cost vector."
argument_list|)
block|;   }
name|Vector
operator|&
name|getCosts
argument_list|()
block|{
return|return
name|costs
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|const
name|Vector
operator|&
name|getCosts
argument_list|()
specifier|const
block|{
return|return
name|costs
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|unsigned
name|getDegree
argument_list|()
specifier|const
block|{
return|return
name|degree
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setID
parameter_list|(
name|unsigned
name|id
parameter_list|)
block|{
name|this
operator|->
name|id
operator|=
name|id
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|unsigned
name|getID
argument_list|()
specifier|const
block|{
return|return
name|id
return|;
block|}
end_expr_stmt

begin_function
name|AdjEdgeIterator
name|addAdjEdge
parameter_list|(
specifier|const
name|EdgeIterator
modifier|&
name|edgeItr
parameter_list|)
block|{
operator|++
name|degree
expr_stmt|;
return|return
name|adjEdges
operator|.
name|insert
argument_list|(
name|adjEdges
operator|.
name|end
argument_list|()
argument_list|,
name|edgeItr
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|removeAdjEdge
parameter_list|(
specifier|const
name|AdjEdgeIterator
modifier|&
name|adjEdgeItr
parameter_list|)
block|{
operator|--
name|degree
expr_stmt|;
name|adjEdges
operator|.
name|erase
argument_list|(
name|adjEdgeItr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|AdjEdgeIterator
name|adjEdgesBegin
parameter_list|()
block|{
return|return
name|adjEdges
operator|.
name|begin
argument_list|()
return|;
block|}
end_function

begin_expr_stmt
name|ConstAdjEdgeIterator
name|adjEdgesBegin
argument_list|()
specifier|const
block|{
return|return
name|adjEdges
operator|.
name|begin
argument_list|()
return|;
block|}
end_expr_stmt

begin_function
name|AdjEdgeIterator
name|adjEdgesEnd
parameter_list|()
block|{
return|return
name|adjEdges
operator|.
name|end
argument_list|()
return|;
block|}
end_function

begin_expr_stmt
name|ConstAdjEdgeIterator
name|adjEdgesEnd
argument_list|()
specifier|const
block|{
return|return
name|adjEdges
operator|.
name|end
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|NodeImpl
operator|,
name|typename
name|EdgeImpl
operator|>
name|class
name|EdgeBase
block|{
name|public
operator|:
typedef|typedef
name|typename
name|GraphBase
operator|<
name|NodeImpl
operator|,
name|EdgeImpl
operator|>
operator|::
name|NodeIterator
name|NodeIterator
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|GraphBase
operator|<
name|NodeImpl
operator|,
name|EdgeImpl
operator|>
operator|::
name|EdgeIterator
name|EdgeIterator
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|NodeImpl
operator|::
name|AdjEdgeIterator
name|NodeAdjEdgeIterator
expr_stmt|;
end_typedef

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|NodeIterator
name|node1Itr
decl_stmt|,
name|node2Itr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|NodeAdjEdgeIterator
name|node1ThisEdgeItr
decl_stmt|,
name|node2ThisEdgeItr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Matrix
name|costs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|operator
init|=
operator|(
specifier|const
name|EdgeBase
operator|&
name|other
operator|)
block|{
name|assert
argument_list|(
name|false
operator|&&
literal|"Can't assign EdgeEntrys."
argument_list|)
block|;   }
name|public
operator|:
name|EdgeBase
argument_list|(
specifier|const
name|NodeIterator
operator|&
name|node1Itr
argument_list|,
specifier|const
name|NodeIterator
operator|&
name|node2Itr
argument_list|,
specifier|const
name|Matrix
operator|&
name|costs
argument_list|)
operator|:
name|node1Itr
argument_list|(
name|node1Itr
argument_list|)
decl_stmt|,
name|node2Itr
argument_list|(
name|node2Itr
argument_list|)
decl_stmt|,
name|costs
argument_list|(
name|costs
argument_list|)
block|{
name|assert
argument_list|(
operator|(
name|costs
operator|.
name|getRows
argument_list|()
operator|>
literal|0
operator|)
operator|&&
operator|(
name|costs
operator|.
name|getCols
argument_list|()
operator|>
literal|0
operator|)
operator|&&
literal|"Can't have zero-dimensioned cost matrices"
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|Matrix
modifier|&
name|getCosts
parameter_list|()
block|{
return|return
name|costs
return|;
block|}
end_function

begin_expr_stmt
specifier|const
name|Matrix
operator|&
name|getCosts
argument_list|()
specifier|const
block|{
return|return
name|costs
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|const
name|NodeIterator
operator|&
name|getNode1Itr
argument_list|()
specifier|const
block|{
return|return
name|node1Itr
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|const
name|NodeIterator
operator|&
name|getNode2Itr
argument_list|()
specifier|const
block|{
return|return
name|node2Itr
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setNode1ThisEdgeItr
parameter_list|(
specifier|const
name|NodeAdjEdgeIterator
modifier|&
name|node1ThisEdgeItr
parameter_list|)
block|{
name|this
operator|->
name|node1ThisEdgeItr
operator|=
name|node1ThisEdgeItr
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|const
name|NodeAdjEdgeIterator
operator|&
name|getNode1ThisEdgeItr
argument_list|()
specifier|const
block|{
return|return
name|node1ThisEdgeItr
return|;
block|}
end_expr_stmt

begin_function
name|void
name|setNode2ThisEdgeItr
parameter_list|(
specifier|const
name|NodeAdjEdgeIterator
modifier|&
name|node2ThisEdgeItr
parameter_list|)
block|{
name|this
operator|->
name|node2ThisEdgeItr
operator|=
name|node2ThisEdgeItr
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|const
name|NodeAdjEdgeIterator
operator|&
name|getNode2ThisEdgeItr
argument_list|()
specifier|const
block|{
return|return
name|node2ThisEdgeItr
return|;
block|}
end_expr_stmt

begin_endif
unit|};   }
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_CODEGEN_PBQP_GRAPHBASE_HPP
end_comment

end_unit

