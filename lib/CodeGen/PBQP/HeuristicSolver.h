begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- HeuristicSolver.h - Heuristic PBQP Solver --------------*- C++ --*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Heuristic PBQP solver. This solver is able to perform optimal reductions for
end_comment

begin_comment
comment|// nodes of degree 0, 1 or 2. For nodes of degree>2 a plugable heuristic is
end_comment

begin_comment
comment|// used to to select a node for reduction.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_PBQP_HEURISTICSOLVER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_PBQP_HEURISTICSOLVER_H
end_define

begin_include
include|#
directive|include
file|"Solver.h"
end_include

begin_include
include|#
directive|include
file|"AnnotatedGraph.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/raw_ostream.h"
end_include

begin_include
include|#
directive|include
file|<limits>
end_include

begin_decl_stmt
name|namespace
name|PBQP
block|{
comment|/// \brief Important types for the HeuristicSolverImpl.
comment|///
comment|/// Declared seperately to allow access to heuristic classes before the solver
comment|/// is fully constructed.
name|template
operator|<
name|typename
name|HeuristicNodeData
operator|,
name|typename
name|HeuristicEdgeData
operator|>
name|class
name|HSITypes
block|{
name|public
operator|:
name|class
name|NodeData
block|;
name|class
name|EdgeData
block|;
typedef|typedef
name|AnnotatedGraph
operator|<
name|NodeData
operator|,
name|EdgeData
operator|>
name|SolverGraph
expr_stmt|;
typedef|typedef
name|typename
name|SolverGraph
operator|::
name|NodeIterator
name|GraphNodeIterator
expr_stmt|;
typedef|typedef
name|typename
name|SolverGraph
operator|::
name|EdgeIterator
name|GraphEdgeIterator
expr_stmt|;
typedef|typedef
name|typename
name|SolverGraph
operator|::
name|AdjEdgeIterator
name|GraphAdjEdgeIterator
expr_stmt|;
typedef|typedef
name|std
operator|::
name|list
operator|<
name|GraphNodeIterator
operator|>
name|NodeList
expr_stmt|;
typedef|typedef
name|typename
name|NodeList
operator|::
name|iterator
name|NodeListIterator
expr_stmt|;
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|GraphNodeIterator
operator|>
name|NodeStack
expr_stmt|;
typedef|typedef
name|typename
name|NodeStack
operator|::
name|iterator
name|NodeStackIterator
expr_stmt|;
name|class
name|NodeData
block|{
name|friend
name|class
name|EdgeData
decl_stmt|;
name|private
label|:
typedef|typedef
name|std
operator|::
name|list
operator|<
name|GraphEdgeIterator
operator|>
name|LinksList
expr_stmt|;
name|unsigned
name|numLinks
decl_stmt|;
name|LinksList
name|links
decl_stmt|,
name|solvedLinks
decl_stmt|;
name|NodeListIterator
name|bucketItr
decl_stmt|;
name|HeuristicNodeData
name|heuristicData
decl_stmt|;
name|public
label|:
typedef|typedef
name|typename
name|LinksList
operator|::
name|iterator
name|AdjLinkIterator
expr_stmt|;
name|private
label|:
name|AdjLinkIterator
name|addLink
parameter_list|(
specifier|const
name|GraphEdgeIterator
modifier|&
name|edgeItr
parameter_list|)
block|{
operator|++
name|numLinks
expr_stmt|;
return|return
name|links
operator|.
name|insert
argument_list|(
name|links
operator|.
name|end
argument_list|()
argument_list|,
name|edgeItr
argument_list|)
return|;
block|}
name|void
name|delLink
parameter_list|(
specifier|const
name|AdjLinkIterator
modifier|&
name|adjLinkItr
parameter_list|)
block|{
operator|--
name|numLinks
expr_stmt|;
name|links
operator|.
name|erase
argument_list|(
name|adjLinkItr
argument_list|)
expr_stmt|;
block|}
name|public
label|:
name|NodeData
argument_list|()
operator|:
name|numLinks
argument_list|(
literal|0
argument_list|)
block|{}
name|unsigned
name|getLinkDegree
argument_list|()
specifier|const
block|{
return|return
name|numLinks
return|;
block|}
name|HeuristicNodeData
modifier|&
name|getHeuristicData
parameter_list|()
block|{
return|return
name|heuristicData
return|;
block|}
specifier|const
name|HeuristicNodeData
operator|&
name|getHeuristicData
argument_list|()
specifier|const
block|{
return|return
name|heuristicData
return|;
block|}
name|void
name|setBucketItr
parameter_list|(
specifier|const
name|NodeListIterator
modifier|&
name|bucketItr
parameter_list|)
block|{
name|this
operator|->
name|bucketItr
operator|=
name|bucketItr
expr_stmt|;
block|}
specifier|const
name|NodeListIterator
operator|&
name|getBucketItr
argument_list|()
specifier|const
block|{
return|return
name|bucketItr
return|;
block|}
name|AdjLinkIterator
name|adjLinksBegin
parameter_list|()
block|{
return|return
name|links
operator|.
name|begin
argument_list|()
return|;
block|}
name|AdjLinkIterator
name|adjLinksEnd
parameter_list|()
block|{
return|return
name|links
operator|.
name|end
argument_list|()
return|;
block|}
name|void
name|addSolvedLink
parameter_list|(
specifier|const
name|GraphEdgeIterator
modifier|&
name|solvedLinkItr
parameter_list|)
block|{
name|solvedLinks
operator|.
name|push_back
argument_list|(
name|solvedLinkItr
argument_list|)
expr_stmt|;
block|}
name|AdjLinkIterator
name|solvedLinksBegin
parameter_list|()
block|{
return|return
name|solvedLinks
operator|.
name|begin
argument_list|()
return|;
block|}
name|AdjLinkIterator
name|solvedLinksEnd
parameter_list|()
block|{
return|return
name|solvedLinks
operator|.
name|end
argument_list|()
return|;
block|}
block|}
empty_stmt|;
name|class
name|EdgeData
block|{
name|private
label|:
name|SolverGraph
modifier|&
name|g
decl_stmt|;
name|GraphNodeIterator
name|node1Itr
decl_stmt|,
name|node2Itr
decl_stmt|;
name|HeuristicEdgeData
name|heuristicData
decl_stmt|;
name|typename
name|NodeData
operator|::
name|AdjLinkIterator
name|node1ThisEdgeItr
operator|,
name|node2ThisEdgeItr
expr_stmt|;
name|public
label|:
name|EdgeData
argument_list|(
name|SolverGraph
operator|&
name|g
argument_list|)
operator|:
name|g
argument_list|(
argument|g
argument_list|)
block|{}
name|HeuristicEdgeData
operator|&
name|getHeuristicData
argument_list|()
block|{
return|return
name|heuristicData
return|;
block|}
specifier|const
name|HeuristicEdgeData
operator|&
name|getHeuristicData
argument_list|()
specifier|const
block|{
return|return
name|heuristicData
return|;
block|}
name|void
name|setup
parameter_list|(
specifier|const
name|GraphEdgeIterator
modifier|&
name|thisEdgeItr
parameter_list|)
block|{
name|node1Itr
operator|=
name|g
operator|.
name|getEdgeNode1Itr
argument_list|(
name|thisEdgeItr
argument_list|)
expr_stmt|;
name|node2Itr
operator|=
name|g
operator|.
name|getEdgeNode2Itr
argument_list|(
name|thisEdgeItr
argument_list|)
expr_stmt|;
name|node1ThisEdgeItr
operator|=
name|g
operator|.
name|getNodeData
argument_list|(
name|node1Itr
argument_list|)
operator|.
name|addLink
argument_list|(
name|thisEdgeItr
argument_list|)
expr_stmt|;
name|node2ThisEdgeItr
operator|=
name|g
operator|.
name|getNodeData
argument_list|(
name|node2Itr
argument_list|)
operator|.
name|addLink
argument_list|(
name|thisEdgeItr
argument_list|)
expr_stmt|;
block|}
name|void
name|unlink
parameter_list|()
block|{
name|g
operator|.
name|getNodeData
argument_list|(
name|node1Itr
argument_list|)
operator|.
name|delLink
argument_list|(
name|node1ThisEdgeItr
argument_list|)
expr_stmt|;
name|g
operator|.
name|getNodeData
argument_list|(
name|node2Itr
argument_list|)
operator|.
name|delLink
argument_list|(
name|node2ThisEdgeItr
argument_list|)
expr_stmt|;
block|}
block|}
empty_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Heuristic
operator|>
name|class
name|HeuristicSolverImpl
block|{
name|public
operator|:
comment|// Typedefs to make life easier:
typedef|typedef
name|HSITypes
operator|<
name|typename
name|Heuristic
operator|::
name|NodeData
operator|,
name|typename
name|Heuristic
operator|::
name|EdgeData
operator|>
name|HSIT
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|HSIT
operator|::
name|SolverGraph
name|SolverGraph
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|HSIT
operator|::
name|NodeData
name|NodeData
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|HSIT
operator|::
name|EdgeData
name|EdgeData
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|HSIT
operator|::
name|GraphNodeIterator
name|GraphNodeIterator
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|HSIT
operator|::
name|GraphEdgeIterator
name|GraphEdgeIterator
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|HSIT
operator|::
name|GraphAdjEdgeIterator
name|GraphAdjEdgeIterator
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|HSIT
operator|::
name|NodeList
name|NodeList
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|HSIT
operator|::
name|NodeListIterator
name|NodeListIterator
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|GraphNodeIterator
operator|>
name|NodeStack
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|NodeStack
operator|::
name|iterator
name|NodeStackIterator
expr_stmt|;
end_typedef

begin_comment
comment|/// \brief Constructor, which performs all the actual solver work.
end_comment

begin_expr_stmt
name|HeuristicSolverImpl
argument_list|(
specifier|const
name|SimpleGraph
operator|&
name|orig
argument_list|)
operator|:
name|solution
argument_list|(
argument|orig.getNumNodes()
argument_list|,
argument|true
argument_list|)
block|{
name|copyGraph
argument_list|(
name|orig
argument_list|)
block|;
name|simplify
argument_list|()
block|;
name|setup
argument_list|()
block|;
name|computeSolution
argument_list|()
block|;
name|computeSolutionCost
argument_list|(
name|orig
argument_list|)
block|;   }
comment|/// \brief Returns the graph for this solver.
name|SolverGraph
operator|&
name|getGraph
argument_list|()
block|{
return|return
name|g
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief Return the solution found by this solver.
end_comment

begin_expr_stmt
specifier|const
name|Solution
operator|&
name|getSolution
argument_list|()
specifier|const
block|{
return|return
name|solution
return|;
block|}
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_comment
comment|/// \brief Add the given node to the appropriate bucket for its link
end_comment

begin_comment
comment|/// degree.
end_comment

begin_function
name|void
name|addToBucket
parameter_list|(
specifier|const
name|GraphNodeIterator
modifier|&
name|nodeItr
parameter_list|)
block|{
name|NodeData
modifier|&
name|nodeData
init|=
name|g
operator|.
name|getNodeData
argument_list|(
name|nodeItr
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|nodeData
operator|.
name|getLinkDegree
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
name|nodeData
operator|.
name|setBucketItr
argument_list|(
name|r0Bucket
operator|.
name|insert
argument_list|(
name|r0Bucket
operator|.
name|end
argument_list|()
argument_list|,
name|nodeItr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|nodeData
operator|.
name|setBucketItr
argument_list|(
name|r1Bucket
operator|.
name|insert
argument_list|(
name|r1Bucket
operator|.
name|end
argument_list|()
argument_list|,
name|nodeItr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|nodeData
operator|.
name|setBucketItr
argument_list|(
name|r2Bucket
operator|.
name|insert
argument_list|(
name|r2Bucket
operator|.
name|end
argument_list|()
argument_list|,
name|nodeItr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|heuristic
operator|.
name|addToRNBucket
argument_list|(
name|nodeItr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/// \brief Remove the given node from the appropriate bucket for its link
end_comment

begin_comment
comment|/// degree.
end_comment

begin_function
name|void
name|removeFromBucket
parameter_list|(
specifier|const
name|GraphNodeIterator
modifier|&
name|nodeItr
parameter_list|)
block|{
name|NodeData
modifier|&
name|nodeData
init|=
name|g
operator|.
name|getNodeData
argument_list|(
name|nodeItr
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|nodeData
operator|.
name|getLinkDegree
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
name|r0Bucket
operator|.
name|erase
argument_list|(
name|nodeData
operator|.
name|getBucketItr
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|r1Bucket
operator|.
name|erase
argument_list|(
name|nodeData
operator|.
name|getBucketItr
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|r2Bucket
operator|.
name|erase
argument_list|(
name|nodeData
operator|.
name|getBucketItr
argument_list|()
argument_list|)
expr_stmt|;
break|break;
default|default:
name|heuristic
operator|.
name|removeFromRNBucket
argument_list|(
name|nodeItr
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_label
name|public
label|:
end_label

begin_comment
comment|/// \brief Add a link.
end_comment

begin_function
name|void
name|addLink
parameter_list|(
specifier|const
name|GraphEdgeIterator
modifier|&
name|edgeItr
parameter_list|)
block|{
name|g
operator|.
name|getEdgeData
argument_list|(
name|edgeItr
argument_list|)
operator|.
name|setup
argument_list|(
name|edgeItr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|g
operator|.
name|getNodeData
argument_list|(
name|g
operator|.
name|getEdgeNode1Itr
argument_list|(
name|edgeItr
argument_list|)
argument_list|)
operator|.
name|getLinkDegree
argument_list|()
operator|>
literal|2
operator|)
operator|||
operator|(
name|g
operator|.
name|getNodeData
argument_list|(
name|g
operator|.
name|getEdgeNode2Itr
argument_list|(
name|edgeItr
argument_list|)
argument_list|)
operator|.
name|getLinkDegree
argument_list|()
operator|>
literal|2
operator|)
condition|)
block|{
name|heuristic
operator|.
name|handleAddLink
argument_list|(
name|edgeItr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/// \brief Remove link, update info for node.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Only updates information for the given node, since usually the other
end_comment

begin_comment
comment|/// is about to be removed.
end_comment

begin_function
name|void
name|removeLink
parameter_list|(
specifier|const
name|GraphEdgeIterator
modifier|&
name|edgeItr
parameter_list|,
specifier|const
name|GraphNodeIterator
modifier|&
name|nodeItr
parameter_list|)
block|{
if|if
condition|(
name|g
operator|.
name|getNodeData
argument_list|(
name|nodeItr
argument_list|)
operator|.
name|getLinkDegree
argument_list|()
operator|>
literal|2
condition|)
block|{
name|heuristic
operator|.
name|handleRemoveLink
argument_list|(
name|edgeItr
argument_list|,
name|nodeItr
argument_list|)
expr_stmt|;
block|}
name|g
operator|.
name|getEdgeData
argument_list|(
name|edgeItr
argument_list|)
operator|.
name|unlink
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/// \brief Remove link, update info for both nodes. Useful for R2 only.
end_comment

begin_function
name|void
name|removeLinkR2
parameter_list|(
specifier|const
name|GraphEdgeIterator
modifier|&
name|edgeItr
parameter_list|)
block|{
name|GraphNodeIterator
name|node1Itr
init|=
name|g
operator|.
name|getEdgeNode1Itr
argument_list|(
name|edgeItr
argument_list|)
decl_stmt|;
if|if
condition|(
name|g
operator|.
name|getNodeData
argument_list|(
name|node1Itr
argument_list|)
operator|.
name|getLinkDegree
argument_list|()
operator|>
literal|2
condition|)
block|{
name|heuristic
operator|.
name|handleRemoveLink
argument_list|(
name|edgeItr
argument_list|,
name|node1Itr
argument_list|)
expr_stmt|;
block|}
name|removeLink
argument_list|(
name|edgeItr
argument_list|,
name|g
operator|.
name|getEdgeNode2Itr
argument_list|(
name|edgeItr
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// \brief Removes all links connected to the given node.
end_comment

begin_function
name|void
name|unlinkNode
parameter_list|(
specifier|const
name|GraphNodeIterator
modifier|&
name|nodeItr
parameter_list|)
block|{
name|NodeData
modifier|&
name|nodeData
init|=
name|g
operator|.
name|getNodeData
argument_list|(
name|nodeItr
argument_list|)
decl_stmt|;
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|GraphEdgeIterator
operator|>
name|TempEdgeList
expr_stmt|;
name|TempEdgeList
name|edgesToUnlink
decl_stmt|;
name|edgesToUnlink
operator|.
name|reserve
argument_list|(
name|nodeData
operator|.
name|getLinkDegree
argument_list|()
argument_list|)
expr_stmt|;
comment|// Copy adj edges into a temp vector. We want to destroy them during
comment|// the unlink, and we can't do that while we're iterating over them.
name|std
operator|::
name|copy
argument_list|(
name|nodeData
operator|.
name|adjLinksBegin
argument_list|()
argument_list|,
name|nodeData
operator|.
name|adjLinksEnd
argument_list|()
argument_list|,
name|std
operator|::
name|back_inserter
argument_list|(
name|edgesToUnlink
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|typename
name|TempEdgeList
operator|::
name|iterator
name|edgeItr
operator|=
name|edgesToUnlink
operator|.
name|begin
argument_list|()
operator|,
name|edgeEnd
operator|=
name|edgesToUnlink
operator|.
name|end
argument_list|()
init|;
name|edgeItr
operator|!=
name|edgeEnd
condition|;
operator|++
name|edgeItr
control|)
block|{
name|GraphNodeIterator
name|otherNode
init|=
name|g
operator|.
name|getEdgeOtherNode
argument_list|(
operator|*
name|edgeItr
argument_list|,
name|nodeItr
argument_list|)
decl_stmt|;
name|removeFromBucket
argument_list|(
name|otherNode
argument_list|)
expr_stmt|;
name|removeLink
argument_list|(
operator|*
name|edgeItr
argument_list|,
name|otherNode
argument_list|)
expr_stmt|;
name|addToBucket
argument_list|(
name|otherNode
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/// \brief Push the given node onto the stack to be solved with
end_comment

begin_comment
comment|/// backpropagation.
end_comment

begin_function
name|void
name|pushStack
parameter_list|(
specifier|const
name|GraphNodeIterator
modifier|&
name|nodeItr
parameter_list|)
block|{
name|stack
operator|.
name|push_back
argument_list|(
name|nodeItr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// \brief Set the solution of the given node.
end_comment

begin_function
name|void
name|setSolution
parameter_list|(
specifier|const
name|GraphNodeIterator
modifier|&
name|nodeItr
parameter_list|,
name|unsigned
name|solIndex
parameter_list|)
block|{
name|solution
operator|.
name|setSelection
argument_list|(
name|g
operator|.
name|getNodeID
argument_list|(
name|nodeItr
argument_list|)
argument_list|,
name|solIndex
argument_list|)
expr_stmt|;
for|for
control|(
name|GraphAdjEdgeIterator
name|adjEdgeItr
init|=
name|g
operator|.
name|adjEdgesBegin
argument_list|(
name|nodeItr
argument_list|)
init|,
name|adjEdgeEnd
init|=
name|g
operator|.
name|adjEdgesEnd
argument_list|(
name|nodeItr
argument_list|)
init|;
name|adjEdgeItr
operator|!=
name|adjEdgeEnd
condition|;
operator|++
name|adjEdgeItr
control|)
block|{
name|GraphEdgeIterator
name|edgeItr
argument_list|(
operator|*
name|adjEdgeItr
argument_list|)
decl_stmt|;
name|GraphNodeIterator
name|adjNodeItr
argument_list|(
name|g
operator|.
name|getEdgeOtherNode
argument_list|(
name|edgeItr
argument_list|,
name|nodeItr
argument_list|)
argument_list|)
decl_stmt|;
name|g
operator|.
name|getNodeData
argument_list|(
name|adjNodeItr
argument_list|)
operator|.
name|addSolvedLink
argument_list|(
name|edgeItr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|SolverGraph
name|g
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Heuristic
name|heuristic
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Solution
name|solution
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|NodeList
name|r0Bucket
decl_stmt|,
name|r1Bucket
decl_stmt|,
name|r2Bucket
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|NodeStack
name|stack
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Copy the SimpleGraph into an annotated graph which we can use for reduction.
end_comment

begin_function
name|void
name|copyGraph
parameter_list|(
specifier|const
name|SimpleGraph
modifier|&
name|orig
parameter_list|)
block|{
name|assert
argument_list|(
operator|(
name|g
operator|.
name|getNumEdges
argument_list|()
operator|==
literal|0
operator|)
operator|&&
operator|(
name|g
operator|.
name|getNumNodes
argument_list|()
operator|==
literal|0
operator|)
operator|&&
literal|"Graph should be empty prior to solver setup."
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|orig
operator|.
name|areNodeIDsValid
argument_list|()
operator|&&
literal|"Cannot copy from a graph with invalid node IDs."
argument_list|)
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|GraphNodeIterator
operator|>
name|newNodeItrs
expr_stmt|;
for|for
control|(
name|unsigned
name|nodeID
init|=
literal|0
init|;
name|nodeID
operator|<
name|orig
operator|.
name|getNumNodes
argument_list|()
condition|;
operator|++
name|nodeID
control|)
block|{
name|newNodeItrs
operator|.
name|push_back
argument_list|(
name|g
operator|.
name|addNode
argument_list|(
name|orig
operator|.
name|getNodeCosts
argument_list|(
name|orig
operator|.
name|getNodeItr
argument_list|(
name|nodeID
argument_list|)
argument_list|)
argument_list|,
name|NodeData
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|SimpleGraph
operator|::
name|ConstEdgeIterator
name|origEdgeItr
operator|=
name|orig
operator|.
name|edgesBegin
argument_list|()
operator|,
name|origEdgeEnd
operator|=
name|orig
operator|.
name|edgesEnd
argument_list|()
init|;
name|origEdgeItr
operator|!=
name|origEdgeEnd
condition|;
operator|++
name|origEdgeItr
control|)
block|{
name|unsigned
name|id1
init|=
name|orig
operator|.
name|getNodeID
argument_list|(
name|orig
operator|.
name|getEdgeNode1Itr
argument_list|(
name|origEdgeItr
argument_list|)
argument_list|)
decl_stmt|,
name|id2
init|=
name|orig
operator|.
name|getNodeID
argument_list|(
name|orig
operator|.
name|getEdgeNode2Itr
argument_list|(
name|origEdgeItr
argument_list|)
argument_list|)
decl_stmt|;
name|g
operator|.
name|addEdge
argument_list|(
name|newNodeItrs
index|[
name|id1
index|]
argument_list|,
name|newNodeItrs
index|[
name|id2
index|]
argument_list|,
name|orig
operator|.
name|getEdgeCosts
argument_list|(
name|origEdgeItr
argument_list|)
argument_list|,
name|EdgeData
argument_list|(
name|g
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Assign IDs to the new nodes using the ordering from the old graph,
comment|// this will lead to nodes in the new graph getting the same ID as the
comment|// corresponding node in the old graph.
name|g
operator|.
name|assignNodeIDs
argument_list|(
name|newNodeItrs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|// Simplify the annotated graph by eliminating independent edges and trivial
end_comment

begin_comment
comment|// nodes.
end_comment

begin_function
name|void
name|simplify
parameter_list|()
block|{
name|disconnectTrivialNodes
argument_list|()
expr_stmt|;
name|eliminateIndependentEdges
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|// Eliminate trivial nodes.
end_comment

begin_function
name|void
name|disconnectTrivialNodes
parameter_list|()
block|{
for|for
control|(
name|GraphNodeIterator
name|nodeItr
init|=
name|g
operator|.
name|nodesBegin
argument_list|()
init|,
name|nodeEnd
init|=
name|g
operator|.
name|nodesEnd
argument_list|()
init|;
name|nodeItr
operator|!=
name|nodeEnd
condition|;
operator|++
name|nodeItr
control|)
block|{
if|if
condition|(
name|g
operator|.
name|getNodeCosts
argument_list|(
name|nodeItr
argument_list|)
operator|.
name|getLength
argument_list|()
operator|==
literal|1
condition|)
block|{
name|std
operator|::
name|vector
operator|<
name|GraphEdgeIterator
operator|>
name|edgesToRemove
expr_stmt|;
for|for
control|(
name|GraphAdjEdgeIterator
name|adjEdgeItr
init|=
name|g
operator|.
name|adjEdgesBegin
argument_list|(
name|nodeItr
argument_list|)
init|,
name|adjEdgeEnd
init|=
name|g
operator|.
name|adjEdgesEnd
argument_list|(
name|nodeItr
argument_list|)
init|;
name|adjEdgeItr
operator|!=
name|adjEdgeEnd
condition|;
operator|++
name|adjEdgeItr
control|)
block|{
name|GraphEdgeIterator
name|edgeItr
init|=
operator|*
name|adjEdgeItr
decl_stmt|;
if|if
condition|(
name|g
operator|.
name|getEdgeNode1Itr
argument_list|(
name|edgeItr
argument_list|)
operator|==
name|nodeItr
condition|)
block|{
name|GraphNodeIterator
name|otherNodeItr
init|=
name|g
operator|.
name|getEdgeNode2Itr
argument_list|(
name|edgeItr
argument_list|)
decl_stmt|;
name|g
operator|.
name|getNodeCosts
argument_list|(
name|otherNodeItr
argument_list|)
operator|+=
name|g
operator|.
name|getEdgeCosts
argument_list|(
name|edgeItr
argument_list|)
operator|.
name|getRowAsVector
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|GraphNodeIterator
name|otherNodeItr
init|=
name|g
operator|.
name|getEdgeNode1Itr
argument_list|(
name|edgeItr
argument_list|)
decl_stmt|;
name|g
operator|.
name|getNodeCosts
argument_list|(
name|otherNodeItr
argument_list|)
operator|+=
name|g
operator|.
name|getEdgeCosts
argument_list|(
name|edgeItr
argument_list|)
operator|.
name|getColAsVector
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|edgesToRemove
operator|.
name|push_back
argument_list|(
name|edgeItr
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|edgesToRemove
operator|.
name|empty
argument_list|()
condition|)
block|{
name|g
operator|.
name|removeEdge
argument_list|(
name|edgesToRemove
operator|.
name|back
argument_list|()
argument_list|)
expr_stmt|;
name|edgesToRemove
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|eliminateIndependentEdges
parameter_list|()
block|{
name|std
operator|::
name|vector
operator|<
name|GraphEdgeIterator
operator|>
name|edgesToProcess
expr_stmt|;
for|for
control|(
name|GraphEdgeIterator
name|edgeItr
init|=
name|g
operator|.
name|edgesBegin
argument_list|()
init|,
name|edgeEnd
init|=
name|g
operator|.
name|edgesEnd
argument_list|()
init|;
name|edgeItr
operator|!=
name|edgeEnd
condition|;
operator|++
name|edgeItr
control|)
block|{
name|edgesToProcess
operator|.
name|push_back
argument_list|(
name|edgeItr
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|!
name|edgesToProcess
operator|.
name|empty
argument_list|()
condition|)
block|{
name|tryToEliminateEdge
argument_list|(
name|edgesToProcess
operator|.
name|back
argument_list|()
argument_list|)
expr_stmt|;
name|edgesToProcess
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|tryToEliminateEdge
parameter_list|(
specifier|const
name|GraphEdgeIterator
modifier|&
name|edgeItr
parameter_list|)
block|{
if|if
condition|(
name|tryNormaliseEdgeMatrix
argument_list|(
name|edgeItr
argument_list|)
condition|)
block|{
name|g
operator|.
name|removeEdge
argument_list|(
name|edgeItr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|bool
name|tryNormaliseEdgeMatrix
parameter_list|(
specifier|const
name|GraphEdgeIterator
modifier|&
name|edgeItr
parameter_list|)
block|{
name|Matrix
modifier|&
name|edgeCosts
init|=
name|g
operator|.
name|getEdgeCosts
argument_list|(
name|edgeItr
argument_list|)
decl_stmt|;
name|Vector
modifier|&
name|uCosts
init|=
name|g
operator|.
name|getNodeCosts
argument_list|(
name|g
operator|.
name|getEdgeNode1Itr
argument_list|(
name|edgeItr
argument_list|)
argument_list|)
decl_stmt|,
modifier|&
name|vCosts
init|=
name|g
operator|.
name|getNodeCosts
argument_list|(
name|g
operator|.
name|getEdgeNode2Itr
argument_list|(
name|edgeItr
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|r
init|=
literal|0
init|;
name|r
operator|<
name|edgeCosts
operator|.
name|getRows
argument_list|()
condition|;
operator|++
name|r
control|)
block|{
name|PBQPNum
name|rowMin
init|=
name|edgeCosts
operator|.
name|getRowMin
argument_list|(
name|r
argument_list|)
decl_stmt|;
name|uCosts
index|[
name|r
index|]
operator|+=
name|rowMin
expr_stmt|;
if|if
condition|(
name|rowMin
operator|!=
name|std
operator|::
name|numeric_limits
operator|<
name|PBQPNum
operator|>
operator|::
name|infinity
argument_list|()
condition|)
block|{
name|edgeCosts
operator|.
name|subFromRow
argument_list|(
name|r
argument_list|,
name|rowMin
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|edgeCosts
operator|.
name|setRow
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|unsigned
name|c
init|=
literal|0
init|;
name|c
operator|<
name|edgeCosts
operator|.
name|getCols
argument_list|()
condition|;
operator|++
name|c
control|)
block|{
name|PBQPNum
name|colMin
init|=
name|edgeCosts
operator|.
name|getColMin
argument_list|(
name|c
argument_list|)
decl_stmt|;
name|vCosts
index|[
name|c
index|]
operator|+=
name|colMin
expr_stmt|;
if|if
condition|(
name|colMin
operator|!=
name|std
operator|::
name|numeric_limits
operator|<
name|PBQPNum
operator|>
operator|::
name|infinity
argument_list|()
condition|)
block|{
name|edgeCosts
operator|.
name|subFromCol
argument_list|(
name|c
argument_list|,
name|colMin
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|edgeCosts
operator|.
name|setCol
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|edgeCosts
operator|.
name|isZero
argument_list|()
return|;
block|}
end_function

begin_function
name|void
name|setup
parameter_list|()
block|{
name|setupLinks
argument_list|()
expr_stmt|;
name|heuristic
operator|.
name|initialise
argument_list|(
operator|*
name|this
argument_list|)
expr_stmt|;
name|setupBuckets
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setupLinks
parameter_list|()
block|{
for|for
control|(
name|GraphEdgeIterator
name|edgeItr
init|=
name|g
operator|.
name|edgesBegin
argument_list|()
init|,
name|edgeEnd
init|=
name|g
operator|.
name|edgesEnd
argument_list|()
init|;
name|edgeItr
operator|!=
name|edgeEnd
condition|;
operator|++
name|edgeItr
control|)
block|{
name|g
operator|.
name|getEdgeData
argument_list|(
name|edgeItr
argument_list|)
operator|.
name|setup
argument_list|(
name|edgeItr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|setupBuckets
parameter_list|()
block|{
for|for
control|(
name|GraphNodeIterator
name|nodeItr
init|=
name|g
operator|.
name|nodesBegin
argument_list|()
init|,
name|nodeEnd
init|=
name|g
operator|.
name|nodesEnd
argument_list|()
init|;
name|nodeItr
operator|!=
name|nodeEnd
condition|;
operator|++
name|nodeItr
control|)
block|{
name|addToBucket
argument_list|(
name|nodeItr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|computeSolution
parameter_list|()
block|{
name|assert
argument_list|(
name|g
operator|.
name|areNodeIDsValid
argument_list|()
operator|&&
literal|"Nodes cannot be added/removed during reduction."
argument_list|)
expr_stmt|;
name|reduce
argument_list|()
expr_stmt|;
name|computeTrivialSolutions
argument_list|()
expr_stmt|;
name|backpropagate
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|printNode
parameter_list|(
specifier|const
name|GraphNodeIterator
modifier|&
name|nodeItr
parameter_list|)
block|{
name|llvm
operator|::
name|errs
argument_list|()
operator|<<
literal|"Node "
operator|<<
name|g
operator|.
name|getNodeID
argument_list|(
name|nodeItr
argument_list|)
operator|<<
literal|" ("
operator|<<
operator|&
operator|*
name|nodeItr
operator|<<
literal|"):\n"
operator|<<
literal|"  costs = "
operator|<<
name|g
operator|.
name|getNodeCosts
argument_list|(
name|nodeItr
argument_list|)
operator|<<
literal|"\n"
operator|<<
literal|"  link degree = "
operator|<<
name|g
operator|.
name|getNodeData
argument_list|(
name|nodeItr
argument_list|)
operator|.
name|getLinkDegree
argument_list|()
operator|<<
literal|"\n"
operator|<<
literal|"  links = [ "
expr_stmt|;
for|for
control|(
name|typename
name|HSIT
operator|::
name|NodeData
operator|::
name|AdjLinkIterator
name|aeItr
operator|=
name|g
operator|.
name|getNodeData
argument_list|(
name|nodeItr
argument_list|)
operator|.
name|adjLinksBegin
argument_list|()
operator|,
name|aeEnd
operator|=
name|g
operator|.
name|getNodeData
argument_list|(
name|nodeItr
argument_list|)
operator|.
name|adjLinksEnd
argument_list|()
init|;
name|aeItr
operator|!=
name|aeEnd
condition|;
operator|++
name|aeItr
control|)
block|{
name|llvm
operator|::
name|errs
argument_list|()
operator|<<
literal|"("
operator|<<
name|g
operator|.
name|getNodeID
argument_list|(
name|g
operator|.
name|getEdgeNode1Itr
argument_list|(
operator|*
name|aeItr
argument_list|)
argument_list|)
operator|<<
literal|", "
operator|<<
name|g
operator|.
name|getNodeID
argument_list|(
name|g
operator|.
name|getEdgeNode2Itr
argument_list|(
operator|*
name|aeItr
argument_list|)
argument_list|)
operator|<<
literal|") "
expr_stmt|;
block|}
name|llvm
operator|::
name|errs
argument_list|()
operator|<<
literal|"]\n"
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dumpState
parameter_list|()
block|{
name|llvm
operator|::
name|errs
argument_list|()
operator|<<
literal|"\n"
expr_stmt|;
for|for
control|(
name|GraphNodeIterator
name|nodeItr
init|=
name|g
operator|.
name|nodesBegin
argument_list|()
init|,
name|nodeEnd
init|=
name|g
operator|.
name|nodesEnd
argument_list|()
init|;
name|nodeItr
operator|!=
name|nodeEnd
condition|;
operator|++
name|nodeItr
control|)
block|{
name|printNode
argument_list|(
name|nodeItr
argument_list|)
expr_stmt|;
block|}
name|NodeList
modifier|*
name|buckets
index|[]
init|=
block|{
operator|&
name|r0Bucket
block|,
operator|&
name|r1Bucket
block|,
operator|&
name|r2Bucket
block|}
decl_stmt|;
for|for
control|(
name|unsigned
name|b
init|=
literal|0
init|;
name|b
operator|<
literal|3
condition|;
operator|++
name|b
control|)
block|{
name|NodeList
modifier|&
name|bucket
init|=
operator|*
name|buckets
index|[
name|b
index|]
decl_stmt|;
name|llvm
operator|::
name|errs
argument_list|()
operator|<<
literal|"Bucket "
operator|<<
name|b
operator|<<
literal|": [ "
expr_stmt|;
for|for
control|(
name|NodeListIterator
name|nItr
init|=
name|bucket
operator|.
name|begin
argument_list|()
init|,
name|nEnd
init|=
name|bucket
operator|.
name|end
argument_list|()
init|;
name|nItr
operator|!=
name|nEnd
condition|;
operator|++
name|nItr
control|)
block|{
name|llvm
operator|::
name|errs
argument_list|()
operator|<<
name|g
operator|.
name|getNodeID
argument_list|(
operator|*
name|nItr
argument_list|)
operator|<<
literal|" "
expr_stmt|;
block|}
name|llvm
operator|::
name|errs
argument_list|()
operator|<<
literal|"]\n"
expr_stmt|;
block|}
name|llvm
operator|::
name|errs
argument_list|()
operator|<<
literal|"Stack: [ "
expr_stmt|;
for|for
control|(
name|NodeStackIterator
name|nsItr
init|=
name|stack
operator|.
name|begin
argument_list|()
init|,
name|nsEnd
init|=
name|stack
operator|.
name|end
argument_list|()
init|;
name|nsItr
operator|!=
name|nsEnd
condition|;
operator|++
name|nsItr
control|)
block|{
name|llvm
operator|::
name|errs
argument_list|()
operator|<<
name|g
operator|.
name|getNodeID
argument_list|(
operator|*
name|nsItr
argument_list|)
operator|<<
literal|" "
expr_stmt|;
block|}
name|llvm
operator|::
name|errs
argument_list|()
operator|<<
literal|"]\n"
expr_stmt|;
block|}
end_function

begin_function
name|void
name|reduce
parameter_list|()
block|{
name|bool
name|reductionFinished
init|=
name|r1Bucket
operator|.
name|empty
argument_list|()
operator|&&
name|r2Bucket
operator|.
name|empty
argument_list|()
operator|&&
name|heuristic
operator|.
name|rNBucketEmpty
argument_list|()
decl_stmt|;
while|while
condition|(
operator|!
name|reductionFinished
condition|)
block|{
if|if
condition|(
operator|!
name|r1Bucket
operator|.
name|empty
argument_list|()
condition|)
block|{
name|processR1
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|r2Bucket
operator|.
name|empty
argument_list|()
condition|)
block|{
name|processR2
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|heuristic
operator|.
name|rNBucketEmpty
argument_list|()
condition|)
block|{
name|solution
operator|.
name|setProvedOptimal
argument_list|(
name|false
argument_list|)
expr_stmt|;
name|solution
operator|.
name|incRNReductions
argument_list|()
expr_stmt|;
name|heuristic
operator|.
name|processRN
argument_list|()
expr_stmt|;
block|}
else|else
name|reductionFinished
operator|=
name|true
expr_stmt|;
block|}
block|}
end_function

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_function
name|void
name|processR1
parameter_list|()
block|{
comment|// Remove the first node in the R0 bucket:
name|GraphNodeIterator
name|xNodeItr
init|=
name|r1Bucket
operator|.
name|front
argument_list|()
decl_stmt|;
name|r1Bucket
operator|.
name|pop_front
argument_list|()
expr_stmt|;
name|solution
operator|.
name|incR1Reductions
argument_list|()
expr_stmt|;
comment|//llvm::errs()<< "Applying R1 to "<< g.getNodeID(xNodeItr)<< "\n";
name|assert
argument_list|(
operator|(
name|g
operator|.
name|getNodeData
argument_list|(
name|xNodeItr
argument_list|)
operator|.
name|getLinkDegree
argument_list|()
operator|==
literal|1
operator|)
operator|&&
literal|"Node in R1 bucket has degree != 1"
argument_list|)
expr_stmt|;
name|GraphEdgeIterator
name|edgeItr
init|=
operator|*
name|g
operator|.
name|getNodeData
argument_list|(
name|xNodeItr
argument_list|)
operator|.
name|adjLinksBegin
argument_list|()
decl_stmt|;
specifier|const
name|Matrix
modifier|&
name|edgeCosts
init|=
name|g
operator|.
name|getEdgeCosts
argument_list|(
name|edgeItr
argument_list|)
decl_stmt|;
specifier|const
name|Vector
modifier|&
name|xCosts
init|=
name|g
operator|.
name|getNodeCosts
argument_list|(
name|xNodeItr
argument_list|)
decl_stmt|;
name|unsigned
name|xLen
init|=
name|xCosts
operator|.
name|getLength
argument_list|()
decl_stmt|;
comment|// Duplicate a little code to avoid transposing matrices:
if|if
condition|(
name|xNodeItr
operator|==
name|g
operator|.
name|getEdgeNode1Itr
argument_list|(
name|edgeItr
argument_list|)
condition|)
block|{
name|GraphNodeIterator
name|yNodeItr
init|=
name|g
operator|.
name|getEdgeNode2Itr
argument_list|(
name|edgeItr
argument_list|)
decl_stmt|;
name|Vector
modifier|&
name|yCosts
init|=
name|g
operator|.
name|getNodeCosts
argument_list|(
name|yNodeItr
argument_list|)
decl_stmt|;
name|unsigned
name|yLen
init|=
name|yCosts
operator|.
name|getLength
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|j
init|=
literal|0
init|;
name|j
operator|<
name|yLen
condition|;
operator|++
name|j
control|)
block|{
name|PBQPNum
name|min
init|=
name|edgeCosts
index|[
literal|0
index|]
index|[
name|j
index|]
operator|+
name|xCosts
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|1
init|;
name|i
operator|<
name|xLen
condition|;
operator|++
name|i
control|)
block|{
name|PBQPNum
name|c
init|=
name|edgeCosts
index|[
name|i
index|]
index|[
name|j
index|]
operator|+
name|xCosts
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|<
name|min
condition|)
name|min
operator|=
name|c
expr_stmt|;
block|}
name|yCosts
index|[
name|j
index|]
operator|+=
name|min
expr_stmt|;
block|}
block|}
else|else
block|{
name|GraphNodeIterator
name|yNodeItr
init|=
name|g
operator|.
name|getEdgeNode1Itr
argument_list|(
name|edgeItr
argument_list|)
decl_stmt|;
name|Vector
modifier|&
name|yCosts
init|=
name|g
operator|.
name|getNodeCosts
argument_list|(
name|yNodeItr
argument_list|)
decl_stmt|;
name|unsigned
name|yLen
init|=
name|yCosts
operator|.
name|getLength
argument_list|()
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|yLen
condition|;
operator|++
name|i
control|)
block|{
name|PBQPNum
name|min
init|=
name|edgeCosts
index|[
name|i
index|]
index|[
literal|0
index|]
operator|+
name|xCosts
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|unsigned
name|j
init|=
literal|1
init|;
name|j
operator|<
name|xLen
condition|;
operator|++
name|j
control|)
block|{
name|PBQPNum
name|c
init|=
name|edgeCosts
index|[
name|i
index|]
index|[
name|j
index|]
operator|+
name|xCosts
index|[
name|j
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|<
name|min
condition|)
name|min
operator|=
name|c
expr_stmt|;
block|}
name|yCosts
index|[
name|i
index|]
operator|+=
name|min
expr_stmt|;
block|}
block|}
name|unlinkNode
argument_list|(
name|xNodeItr
argument_list|)
expr_stmt|;
name|pushStack
argument_list|(
name|xNodeItr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|processR2
parameter_list|()
block|{
name|GraphNodeIterator
name|xNodeItr
init|=
name|r2Bucket
operator|.
name|front
argument_list|()
decl_stmt|;
name|r2Bucket
operator|.
name|pop_front
argument_list|()
expr_stmt|;
name|solution
operator|.
name|incR2Reductions
argument_list|()
expr_stmt|;
comment|// Unlink is unsafe here. At some point it may optimistically more a node
comment|// to a lower-degree list when its degree will later rise, or vice versa,
comment|// violating the assumption that node degrees monotonically decrease
comment|// during the reduction phase. Instead we'll bucket shuffle manually.
name|pushStack
argument_list|(
name|xNodeItr
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|g
operator|.
name|getNodeData
argument_list|(
name|xNodeItr
argument_list|)
operator|.
name|getLinkDegree
argument_list|()
operator|==
literal|2
operator|)
operator|&&
literal|"Node in R2 bucket has degree != 2"
argument_list|)
expr_stmt|;
specifier|const
name|Vector
modifier|&
name|xCosts
init|=
name|g
operator|.
name|getNodeCosts
argument_list|(
name|xNodeItr
argument_list|)
decl_stmt|;
name|typename
name|NodeData
operator|::
name|AdjLinkIterator
name|tempItr
operator|=
name|g
operator|.
name|getNodeData
argument_list|(
name|xNodeItr
argument_list|)
operator|.
name|adjLinksBegin
argument_list|()
expr_stmt|;
name|GraphEdgeIterator
name|yxEdgeItr
init|=
operator|*
name|tempItr
decl_stmt|,
name|zxEdgeItr
init|=
operator|*
operator|(
operator|++
name|tempItr
operator|)
decl_stmt|;
name|GraphNodeIterator
name|yNodeItr
init|=
name|g
operator|.
name|getEdgeOtherNode
argument_list|(
name|yxEdgeItr
argument_list|,
name|xNodeItr
argument_list|)
decl_stmt|,
name|zNodeItr
init|=
name|g
operator|.
name|getEdgeOtherNode
argument_list|(
name|zxEdgeItr
argument_list|,
name|xNodeItr
argument_list|)
decl_stmt|;
name|removeFromBucket
argument_list|(
name|yNodeItr
argument_list|)
expr_stmt|;
name|removeFromBucket
argument_list|(
name|zNodeItr
argument_list|)
expr_stmt|;
name|removeLink
argument_list|(
name|yxEdgeItr
argument_list|,
name|yNodeItr
argument_list|)
expr_stmt|;
name|removeLink
argument_list|(
name|zxEdgeItr
argument_list|,
name|zNodeItr
argument_list|)
expr_stmt|;
comment|// Graph some of the costs:
name|bool
name|flipEdge1
init|=
operator|(
name|g
operator|.
name|getEdgeNode1Itr
argument_list|(
name|yxEdgeItr
argument_list|)
operator|==
name|xNodeItr
operator|)
decl_stmt|,
name|flipEdge2
init|=
operator|(
name|g
operator|.
name|getEdgeNode1Itr
argument_list|(
name|zxEdgeItr
argument_list|)
operator|==
name|xNodeItr
operator|)
decl_stmt|;
specifier|const
name|Matrix
modifier|*
name|yxCosts
init|=
name|flipEdge1
condition|?
name|new
name|Matrix
argument_list|(
name|g
operator|.
name|getEdgeCosts
argument_list|(
name|yxEdgeItr
argument_list|)
operator|.
name|transpose
argument_list|()
argument_list|)
else|:
operator|&
name|g
operator|.
name|getEdgeCosts
argument_list|(
name|yxEdgeItr
argument_list|)
decl_stmt|,
modifier|*
name|zxCosts
init|=
name|flipEdge2
condition|?
name|new
name|Matrix
argument_list|(
name|g
operator|.
name|getEdgeCosts
argument_list|(
name|zxEdgeItr
argument_list|)
operator|.
name|transpose
argument_list|()
argument_list|)
else|:
operator|&
name|g
operator|.
name|getEdgeCosts
argument_list|(
name|zxEdgeItr
argument_list|)
decl_stmt|;
name|unsigned
name|xLen
init|=
name|xCosts
operator|.
name|getLength
argument_list|()
decl_stmt|,
name|yLen
init|=
name|yxCosts
operator|->
name|getRows
argument_list|()
decl_stmt|,
name|zLen
init|=
name|zxCosts
operator|->
name|getRows
argument_list|()
decl_stmt|;
comment|// Compute delta:
name|Matrix
name|delta
argument_list|(
name|yLen
argument_list|,
name|zLen
argument_list|)
decl_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|yLen
condition|;
operator|++
name|i
control|)
block|{
for|for
control|(
name|unsigned
name|j
init|=
literal|0
init|;
name|j
operator|<
name|zLen
condition|;
operator|++
name|j
control|)
block|{
name|PBQPNum
name|min
init|=
operator|(
operator|*
name|yxCosts
operator|)
index|[
name|i
index|]
index|[
literal|0
index|]
operator|+
operator|(
operator|*
name|zxCosts
operator|)
index|[
name|j
index|]
index|[
literal|0
index|]
operator|+
name|xCosts
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|unsigned
name|k
init|=
literal|1
init|;
name|k
operator|<
name|xLen
condition|;
operator|++
name|k
control|)
block|{
name|PBQPNum
name|c
init|=
operator|(
operator|*
name|yxCosts
operator|)
index|[
name|i
index|]
index|[
name|k
index|]
operator|+
operator|(
operator|*
name|zxCosts
operator|)
index|[
name|j
index|]
index|[
name|k
index|]
operator|+
name|xCosts
index|[
name|k
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|<
name|min
condition|)
block|{
name|min
operator|=
name|c
expr_stmt|;
block|}
block|}
name|delta
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|min
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flipEdge1
condition|)
name|delete
name|yxCosts
decl_stmt|;
if|if
condition|(
name|flipEdge2
condition|)
name|delete
name|zxCosts
decl_stmt|;
comment|// Deal with the potentially induced yz edge.
name|GraphEdgeIterator
name|yzEdgeItr
init|=
name|g
operator|.
name|findEdge
argument_list|(
name|yNodeItr
argument_list|,
name|zNodeItr
argument_list|)
decl_stmt|;
if|if
condition|(
name|yzEdgeItr
operator|==
name|g
operator|.
name|edgesEnd
argument_list|()
condition|)
block|{
name|yzEdgeItr
operator|=
name|g
operator|.
name|addEdge
argument_list|(
name|yNodeItr
argument_list|,
name|zNodeItr
argument_list|,
name|delta
argument_list|,
name|EdgeData
argument_list|(
name|g
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// There was an edge, but we're going to screw with it. Delete the old
comment|// link, update the costs. We'll re-link it later.
name|removeLinkR2
argument_list|(
name|yzEdgeItr
argument_list|)
expr_stmt|;
name|g
operator|.
name|getEdgeCosts
argument_list|(
name|yzEdgeItr
argument_list|)
operator|+=
operator|(
name|yNodeItr
operator|==
name|g
operator|.
name|getEdgeNode1Itr
argument_list|(
name|yzEdgeItr
argument_list|)
operator|)
condition|?
name|delta
else|:
name|delta
operator|.
name|transpose
argument_list|()
expr_stmt|;
block|}
name|bool
name|nullCostEdge
init|=
name|tryNormaliseEdgeMatrix
argument_list|(
name|yzEdgeItr
argument_list|)
decl_stmt|;
comment|// Nulled the edge, remove it entirely.
if|if
condition|(
name|nullCostEdge
condition|)
block|{
name|g
operator|.
name|removeEdge
argument_list|(
name|yzEdgeItr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Edge remains - re-link it.
name|addLink
argument_list|(
name|yzEdgeItr
argument_list|)
expr_stmt|;
block|}
name|addToBucket
argument_list|(
name|yNodeItr
argument_list|)
expr_stmt|;
name|addToBucket
argument_list|(
name|zNodeItr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|computeTrivialSolutions
parameter_list|()
block|{
for|for
control|(
name|NodeListIterator
name|r0Itr
init|=
name|r0Bucket
operator|.
name|begin
argument_list|()
init|,
name|r0End
init|=
name|r0Bucket
operator|.
name|end
argument_list|()
init|;
name|r0Itr
operator|!=
name|r0End
condition|;
operator|++
name|r0Itr
control|)
block|{
name|GraphNodeIterator
name|nodeItr
init|=
operator|*
name|r0Itr
decl_stmt|;
name|solution
operator|.
name|incR0Reductions
argument_list|()
expr_stmt|;
name|setSolution
argument_list|(
name|nodeItr
argument_list|,
name|g
operator|.
name|getNodeCosts
argument_list|(
name|nodeItr
argument_list|)
operator|.
name|minIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|backpropagate
parameter_list|()
block|{
while|while
condition|(
operator|!
name|stack
operator|.
name|empty
argument_list|()
condition|)
block|{
name|computeSolution
argument_list|(
name|stack
operator|.
name|back
argument_list|()
argument_list|)
expr_stmt|;
name|stack
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|computeSolution
parameter_list|(
specifier|const
name|GraphNodeIterator
modifier|&
name|nodeItr
parameter_list|)
block|{
name|NodeData
modifier|&
name|nodeData
init|=
name|g
operator|.
name|getNodeData
argument_list|(
name|nodeItr
argument_list|)
decl_stmt|;
name|Vector
name|v
argument_list|(
name|g
operator|.
name|getNodeCosts
argument_list|(
name|nodeItr
argument_list|)
argument_list|)
decl_stmt|;
comment|// Solve based on existing links.
for|for
control|(
name|typename
name|NodeData
operator|::
name|AdjLinkIterator
name|solvedLinkItr
operator|=
name|nodeData
operator|.
name|solvedLinksBegin
argument_list|()
operator|,
name|solvedLinkEnd
operator|=
name|nodeData
operator|.
name|solvedLinksEnd
argument_list|()
init|;
name|solvedLinkItr
operator|!=
name|solvedLinkEnd
condition|;
operator|++
name|solvedLinkItr
control|)
block|{
name|GraphEdgeIterator
name|solvedEdgeItr
argument_list|(
operator|*
name|solvedLinkItr
argument_list|)
decl_stmt|;
name|Matrix
modifier|&
name|edgeCosts
init|=
name|g
operator|.
name|getEdgeCosts
argument_list|(
name|solvedEdgeItr
argument_list|)
decl_stmt|;
if|if
condition|(
name|nodeItr
operator|==
name|g
operator|.
name|getEdgeNode1Itr
argument_list|(
name|solvedEdgeItr
argument_list|)
condition|)
block|{
name|GraphNodeIterator
name|adjNode
argument_list|(
name|g
operator|.
name|getEdgeNode2Itr
argument_list|(
name|solvedEdgeItr
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|adjSolution
init|=
name|solution
operator|.
name|getSelection
argument_list|(
name|g
operator|.
name|getNodeID
argument_list|(
name|adjNode
argument_list|)
argument_list|)
decl_stmt|;
name|v
operator|+=
name|edgeCosts
operator|.
name|getColAsVector
argument_list|(
name|adjSolution
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|GraphNodeIterator
name|adjNode
argument_list|(
name|g
operator|.
name|getEdgeNode1Itr
argument_list|(
name|solvedEdgeItr
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
name|adjSolution
init|=
name|solution
operator|.
name|getSelection
argument_list|(
name|g
operator|.
name|getNodeID
argument_list|(
name|adjNode
argument_list|)
argument_list|)
decl_stmt|;
name|v
operator|+=
name|edgeCosts
operator|.
name|getRowAsVector
argument_list|(
name|adjSolution
argument_list|)
expr_stmt|;
block|}
block|}
name|setSolution
argument_list|(
name|nodeItr
argument_list|,
name|v
operator|.
name|minIndex
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|computeSolutionCost
parameter_list|(
specifier|const
name|SimpleGraph
modifier|&
name|orig
parameter_list|)
block|{
name|PBQPNum
name|cost
init|=
literal|0.0
decl_stmt|;
for|for
control|(
name|SimpleGraph
operator|::
name|ConstNodeIterator
name|nodeItr
operator|=
name|orig
operator|.
name|nodesBegin
argument_list|()
operator|,
name|nodeEnd
operator|=
name|orig
operator|.
name|nodesEnd
argument_list|()
init|;
name|nodeItr
operator|!=
name|nodeEnd
condition|;
operator|++
name|nodeItr
control|)
block|{
name|unsigned
name|nodeId
init|=
name|orig
operator|.
name|getNodeID
argument_list|(
name|nodeItr
argument_list|)
decl_stmt|;
name|cost
operator|+=
name|orig
operator|.
name|getNodeCosts
argument_list|(
name|nodeItr
argument_list|)
index|[
name|solution
operator|.
name|getSelection
argument_list|(
name|nodeId
argument_list|)
index|]
expr_stmt|;
block|}
for|for
control|(
name|SimpleGraph
operator|::
name|ConstEdgeIterator
name|edgeItr
operator|=
name|orig
operator|.
name|edgesBegin
argument_list|()
operator|,
name|edgeEnd
operator|=
name|orig
operator|.
name|edgesEnd
argument_list|()
init|;
name|edgeItr
operator|!=
name|edgeEnd
condition|;
operator|++
name|edgeItr
control|)
block|{
name|SimpleGraph
operator|::
name|ConstNodeIterator
name|n1
operator|=
name|orig
operator|.
name|getEdgeNode1Itr
argument_list|(
name|edgeItr
argument_list|)
operator|,
name|n2
operator|=
name|orig
operator|.
name|getEdgeNode2Itr
argument_list|(
name|edgeItr
argument_list|)
expr_stmt|;
name|unsigned
name|sol1
init|=
name|solution
operator|.
name|getSelection
argument_list|(
name|orig
operator|.
name|getNodeID
argument_list|(
name|n1
argument_list|)
argument_list|)
decl_stmt|,
name|sol2
init|=
name|solution
operator|.
name|getSelection
argument_list|(
name|orig
operator|.
name|getNodeID
argument_list|(
name|n2
argument_list|)
argument_list|)
decl_stmt|;
name|cost
operator|+=
name|orig
operator|.
name|getEdgeCosts
argument_list|(
name|edgeItr
argument_list|)
index|[
name|sol1
index|]
index|[
name|sol2
index|]
expr_stmt|;
block|}
name|solution
operator|.
name|setSolutionCost
argument_list|(
name|cost
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|typename
name|Heuristic
operator|>
name|class
name|HeuristicSolver
operator|:
name|public
name|Solver
block|{
name|public
operator|:
name|Solution
name|solve
argument_list|(
argument|const SimpleGraph&g
argument_list|)
specifier|const
block|{
name|HeuristicSolverImpl
operator|<
name|Heuristic
operator|>
name|solverImpl
argument_list|(
name|g
argument_list|)
block|;
return|return
name|solverImpl
operator|.
name|getSolution
argument_list|()
return|;
block|}
end_expr_stmt

begin_endif
unit|};  }
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_CODEGEN_PBQP_HEURISTICSOLVER_H
end_comment

end_unit

