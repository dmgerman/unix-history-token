begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- ExhaustiveSolver.h - Brute Force PBQP Solver -----------*- C++ --*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Uses a trivial brute force algorithm to solve a PBQP problem.
end_comment

begin_comment
comment|// PBQP is NP-HARD - This solver should only be used for debugging small
end_comment

begin_comment
comment|// problems.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_PBQP_EXHAUSTIVESOLVER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_PBQP_EXHAUSTIVESOLVER_H
end_define

begin_include
include|#
directive|include
file|"Solver.h"
end_include

begin_decl_stmt
name|namespace
name|PBQP
block|{
comment|/// A brute force PBQP solver. This solver takes exponential time. It should
comment|/// only be used for debugging purposes.
name|class
name|ExhaustiveSolverImpl
block|{
name|private
label|:
specifier|const
name|SimpleGraph
modifier|&
name|g
decl_stmt|;
name|PBQPNum
name|getSolutionCost
argument_list|(
specifier|const
name|Solution
operator|&
name|solution
argument_list|)
decl|const
block|{
name|PBQPNum
name|cost
init|=
literal|0.0
decl_stmt|;
for|for
control|(
name|SimpleGraph
operator|::
name|ConstNodeIterator
name|nodeItr
operator|=
name|g
operator|.
name|nodesBegin
argument_list|()
operator|,
name|nodeEnd
operator|=
name|g
operator|.
name|nodesEnd
argument_list|()
init|;
name|nodeItr
operator|!=
name|nodeEnd
condition|;
operator|++
name|nodeItr
control|)
block|{
name|unsigned
name|nodeId
init|=
name|g
operator|.
name|getNodeID
argument_list|(
name|nodeItr
argument_list|)
decl_stmt|;
name|cost
operator|+=
name|g
operator|.
name|getNodeCosts
argument_list|(
name|nodeItr
argument_list|)
index|[
name|solution
operator|.
name|getSelection
argument_list|(
name|nodeId
argument_list|)
index|]
expr_stmt|;
block|}
for|for
control|(
name|SimpleGraph
operator|::
name|ConstEdgeIterator
name|edgeItr
operator|=
name|g
operator|.
name|edgesBegin
argument_list|()
operator|,
name|edgeEnd
operator|=
name|g
operator|.
name|edgesEnd
argument_list|()
init|;
name|edgeItr
operator|!=
name|edgeEnd
condition|;
operator|++
name|edgeItr
control|)
block|{
name|SimpleGraph
operator|::
name|ConstNodeIterator
name|n1
operator|=
name|g
operator|.
name|getEdgeNode1Itr
argument_list|(
name|edgeItr
argument_list|)
operator|,
name|n2
operator|=
name|g
operator|.
name|getEdgeNode2Itr
argument_list|(
name|edgeItr
argument_list|)
expr_stmt|;
name|unsigned
name|sol1
init|=
name|solution
operator|.
name|getSelection
argument_list|(
name|g
operator|.
name|getNodeID
argument_list|(
name|n1
argument_list|)
argument_list|)
decl_stmt|,
name|sol2
init|=
name|solution
operator|.
name|getSelection
argument_list|(
name|g
operator|.
name|getNodeID
argument_list|(
name|n2
argument_list|)
argument_list|)
decl_stmt|;
name|cost
operator|+=
name|g
operator|.
name|getEdgeCosts
argument_list|(
name|edgeItr
argument_list|)
index|[
name|sol1
index|]
index|[
name|sol2
index|]
expr_stmt|;
block|}
return|return
name|cost
return|;
block|}
name|public
label|:
name|ExhaustiveSolverImpl
argument_list|(
specifier|const
name|SimpleGraph
operator|&
name|g
argument_list|)
operator|:
name|g
argument_list|(
argument|g
argument_list|)
block|{}
name|Solution
name|solve
argument_list|()
specifier|const
block|{
name|Solution
name|current
argument_list|(
name|g
operator|.
name|getNumNodes
argument_list|()
argument_list|,
name|true
argument_list|)
block|,
name|optimal
argument_list|(
name|current
argument_list|)
block|;
name|PBQPNum
name|bestCost
operator|=
name|std
operator|::
name|numeric_limits
operator|<
name|PBQPNum
operator|>
operator|::
name|infinity
argument_list|()
block|;
name|bool
name|finished
operator|=
name|false
block|;
while|while
condition|(
operator|!
name|finished
condition|)
block|{
name|PBQPNum
name|currentCost
init|=
name|getSolutionCost
argument_list|(
name|current
argument_list|)
decl_stmt|;
if|if
condition|(
name|currentCost
operator|<
name|bestCost
condition|)
block|{
name|optimal
operator|=
name|current
expr_stmt|;
name|bestCost
operator|=
name|currentCost
expr_stmt|;
block|}
comment|// assume we're done.
name|finished
operator|=
name|true
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|g
operator|.
name|getNumNodes
argument_list|()
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|current
operator|.
name|getSelection
argument_list|(
name|i
argument_list|)
operator|==
operator|(
name|g
operator|.
name|getNodeCosts
argument_list|(
name|g
operator|.
name|getNodeItr
argument_list|(
name|i
argument_list|)
argument_list|)
operator|.
name|getLength
argument_list|()
operator|-
literal|1
operator|)
condition|)
block|{
name|current
operator|.
name|setSelection
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|current
operator|.
name|setSelection
argument_list|(
name|i
argument_list|,
name|current
operator|.
name|getSelection
argument_list|(
name|i
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|finished
operator|=
name|false
expr_stmt|;
break|break;
block|}
block|}
block|}
name|optimal
operator|.
name|setSolutionCost
argument_list|(
name|bestCost
argument_list|)
expr_stmt|;
return|return
name|optimal
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|class
name|ExhaustiveSolver
range|:
name|public
name|Solver
block|{
name|public
operator|:
operator|~
name|ExhaustiveSolver
argument_list|()
block|{}
name|Solution
name|solve
argument_list|(
argument|const SimpleGraph&g
argument_list|)
specifier|const
block|{
name|ExhaustiveSolverImpl
name|solver
argument_list|(
name|g
argument_list|)
block|;
return|return
name|solver
operator|.
name|solve
argument_list|()
return|;
block|}
expr|}
block|;  }
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_CODGEN_PBQP_EXHAUSTIVESOLVER_HPP
end_comment

end_unit

