begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- SelectionDAGBuilder.h - Selection-DAG building --------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This implements routines for translating from LLVM IR into SelectionDAG IR.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SELECTIONDAGBUILDER_H
end_ifndef

begin_define
define|#
directive|define
name|SELECTIONDAGBUILDER_H
end_define

begin_include
include|#
directive|include
file|"llvm/Constants.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/SelectionDAG.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/APInt.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NDEBUG
end_ifndef

begin_include
include|#
directive|include
file|"llvm/ADT/SmallSet.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"llvm/CodeGen/SelectionDAGNodes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/CodeGen/ValueTypes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/CallSite.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_include
include|#
directive|include
file|<set>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|AliasAnalysis
decl_stmt|;
name|class
name|AllocaInst
decl_stmt|;
name|class
name|BasicBlock
decl_stmt|;
name|class
name|BitCastInst
decl_stmt|;
name|class
name|BranchInst
decl_stmt|;
name|class
name|CallInst
decl_stmt|;
name|class
name|ExtractElementInst
decl_stmt|;
name|class
name|ExtractValueInst
decl_stmt|;
name|class
name|FCmpInst
decl_stmt|;
name|class
name|FPExtInst
decl_stmt|;
name|class
name|FPToSIInst
decl_stmt|;
name|class
name|FPToUIInst
decl_stmt|;
name|class
name|FPTruncInst
decl_stmt|;
name|class
name|Function
decl_stmt|;
name|class
name|FunctionLoweringInfo
decl_stmt|;
name|class
name|GetElementPtrInst
decl_stmt|;
name|class
name|GCFunctionInfo
decl_stmt|;
name|class
name|ICmpInst
decl_stmt|;
name|class
name|IntToPtrInst
decl_stmt|;
name|class
name|IndirectBrInst
decl_stmt|;
name|class
name|InvokeInst
decl_stmt|;
name|class
name|InsertElementInst
decl_stmt|;
name|class
name|InsertValueInst
decl_stmt|;
name|class
name|Instruction
decl_stmt|;
name|class
name|LoadInst
decl_stmt|;
name|class
name|MachineBasicBlock
decl_stmt|;
name|class
name|MachineFunction
decl_stmt|;
name|class
name|MachineInstr
decl_stmt|;
name|class
name|MachineRegisterInfo
decl_stmt|;
name|class
name|PHINode
decl_stmt|;
name|class
name|PtrToIntInst
decl_stmt|;
name|class
name|ReturnInst
decl_stmt|;
name|class
name|SDISelAsmOperandInfo
decl_stmt|;
name|class
name|SExtInst
decl_stmt|;
name|class
name|SelectInst
decl_stmt|;
name|class
name|ShuffleVectorInst
decl_stmt|;
name|class
name|SIToFPInst
decl_stmt|;
name|class
name|StoreInst
decl_stmt|;
name|class
name|SwitchInst
decl_stmt|;
name|class
name|TargetData
decl_stmt|;
name|class
name|TargetLowering
decl_stmt|;
name|class
name|TruncInst
decl_stmt|;
name|class
name|UIToFPInst
decl_stmt|;
name|class
name|UnreachableInst
decl_stmt|;
name|class
name|UnwindInst
decl_stmt|;
name|class
name|VAArgInst
decl_stmt|;
name|class
name|ZExtInst
decl_stmt|;
comment|//===----------------------------------------------------------------------===//
comment|/// SelectionDAGBuilder - This is the common target-independent lowering
comment|/// implementation that is parameterized by a TargetLowering object.
comment|/// Also, targets can overload any lowering method.
comment|///
name|class
name|SelectionDAGBuilder
block|{
name|MachineBasicBlock
modifier|*
name|CurMBB
decl_stmt|;
comment|/// CurDebugLoc - current file + line number.  Changes as we build the DAG.
name|DebugLoc
name|CurDebugLoc
decl_stmt|;
name|DenseMap
operator|<
specifier|const
name|Value
operator|*
operator|,
name|SDValue
operator|>
name|NodeMap
expr_stmt|;
name|public
label|:
comment|/// PendingLoads - Loads are not emitted to the program immediately.  We bunch
comment|/// them up and then emit token factor nodes when possible.  This allows us to
comment|/// get simple disambiguation between loads without worrying about alias
comment|/// analysis.
name|SmallVector
operator|<
name|SDValue
operator|,
literal|8
operator|>
name|PendingLoads
expr_stmt|;
name|private
label|:
comment|/// PendingExports - CopyToReg nodes that copy values to virtual registers
comment|/// for export to other blocks need to be emitted before any terminator
comment|/// instruction, but they have no other ordering requirements. We bunch them
comment|/// up and the emit a single tokenfactor for them just before terminator
comment|/// instructions.
name|SmallVector
operator|<
name|SDValue
operator|,
literal|8
operator|>
name|PendingExports
expr_stmt|;
comment|/// SDNodeOrder - A unique monotonically increasing number used to order the
comment|/// SDNodes we create.
name|unsigned
name|SDNodeOrder
decl_stmt|;
comment|/// Case - A struct to record the Value for a switch case, and the
comment|/// case's target basic block.
struct|struct
name|Case
block|{
name|Constant
modifier|*
name|Low
decl_stmt|;
name|Constant
modifier|*
name|High
decl_stmt|;
name|MachineBasicBlock
modifier|*
name|BB
decl_stmt|;
name|Case
argument_list|()
operator|:
name|Low
argument_list|(
literal|0
argument_list|)
operator|,
name|High
argument_list|(
literal|0
argument_list|)
operator|,
name|BB
argument_list|(
literal|0
argument_list|)
block|{ }
name|Case
argument_list|(
name|Constant
operator|*
name|low
argument_list|,
name|Constant
operator|*
name|high
argument_list|,
name|MachineBasicBlock
operator|*
name|bb
argument_list|)
operator|:
name|Low
argument_list|(
name|low
argument_list|)
operator|,
name|High
argument_list|(
name|high
argument_list|)
operator|,
name|BB
argument_list|(
argument|bb
argument_list|)
block|{ }
name|APInt
name|size
argument_list|()
specifier|const
block|{
specifier|const
name|APInt
operator|&
name|rHigh
operator|=
name|cast
operator|<
name|ConstantInt
operator|>
operator|(
name|High
operator|)
operator|->
name|getValue
argument_list|()
block|;
specifier|const
name|APInt
operator|&
name|rLow
operator|=
name|cast
operator|<
name|ConstantInt
operator|>
operator|(
name|Low
operator|)
operator|->
name|getValue
argument_list|()
block|;
return|return
operator|(
name|rHigh
operator|-
name|rLow
operator|+
literal|1ULL
operator|)
return|;
block|}
block|}
struct|;
struct|struct
name|CaseBits
block|{
name|uint64_t
name|Mask
decl_stmt|;
name|MachineBasicBlock
modifier|*
name|BB
decl_stmt|;
name|unsigned
name|Bits
decl_stmt|;
name|CaseBits
argument_list|(
argument|uint64_t mask
argument_list|,
argument|MachineBasicBlock* bb
argument_list|,
argument|unsigned bits
argument_list|)
block|:
name|Mask
argument_list|(
name|mask
argument_list|)
operator|,
name|BB
argument_list|(
name|bb
argument_list|)
operator|,
name|Bits
argument_list|(
argument|bits
argument_list|)
block|{ }
block|}
struct|;
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|Case
operator|>
name|CaseVector
expr_stmt|;
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|CaseBits
operator|>
name|CaseBitsVector
expr_stmt|;
typedef|typedef
name|CaseVector
operator|::
name|iterator
name|CaseItr
expr_stmt|;
typedef|typedef
name|std
operator|::
name|pair
operator|<
name|CaseItr
operator|,
name|CaseItr
operator|>
name|CaseRange
expr_stmt|;
comment|/// CaseRec - A struct with ctor used in lowering switches to a binary tree
comment|/// of conditional branches.
struct|struct
name|CaseRec
block|{
name|CaseRec
argument_list|(
argument|MachineBasicBlock *bb
argument_list|,
argument|Constant *lt
argument_list|,
argument|Constant *ge
argument_list|,
argument|CaseRange r
argument_list|)
block|:
name|CaseBB
argument_list|(
name|bb
argument_list|)
operator|,
name|LT
argument_list|(
name|lt
argument_list|)
operator|,
name|GE
argument_list|(
name|ge
argument_list|)
operator|,
name|Range
argument_list|(
argument|r
argument_list|)
block|{}
comment|/// CaseBB - The MBB in which to emit the compare and branch
name|MachineBasicBlock
operator|*
name|CaseBB
expr_stmt|;
comment|/// LT, GE - If nonzero, we know the current case value must be less-than or
comment|/// greater-than-or-equal-to these Constants.
name|Constant
modifier|*
name|LT
decl_stmt|;
name|Constant
modifier|*
name|GE
decl_stmt|;
comment|/// Range - A pair of iterators representing the range of case values to be
comment|/// processed at this point in the binary search tree.
name|CaseRange
name|Range
decl_stmt|;
block|}
struct|;
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|CaseRec
operator|>
name|CaseRecVector
expr_stmt|;
comment|/// The comparison function for sorting the switch case values in the vector.
comment|/// WARNING: Case ranges should be disjoint!
struct|struct
name|CaseCmp
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|Case
operator|&
name|C1
operator|,
specifier|const
name|Case
operator|&
name|C2
operator|)
block|{
name|assert
argument_list|(
name|isa
operator|<
name|ConstantInt
operator|>
operator|(
name|C1
operator|.
name|Low
operator|)
operator|&&
name|isa
operator|<
name|ConstantInt
operator|>
operator|(
name|C2
operator|.
name|High
operator|)
argument_list|)
block|;
specifier|const
name|ConstantInt
operator|*
name|CI1
operator|=
name|cast
operator|<
specifier|const
name|ConstantInt
operator|>
operator|(
name|C1
operator|.
name|Low
operator|)
block|;
specifier|const
name|ConstantInt
operator|*
name|CI2
operator|=
name|cast
operator|<
specifier|const
name|ConstantInt
operator|>
operator|(
name|C2
operator|.
name|High
operator|)
block|;
return|return
name|CI1
operator|->
name|getValue
argument_list|()
operator|.
name|slt
argument_list|(
name|CI2
operator|->
name|getValue
argument_list|()
argument_list|)
return|;
block|}
block|}
struct|;
struct|struct
name|CaseBitsCmp
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|CaseBits
operator|&
name|C1
operator|,
specifier|const
name|CaseBits
operator|&
name|C2
operator|)
block|{
return|return
name|C1
operator|.
name|Bits
operator|>
name|C2
operator|.
name|Bits
return|;
block|}
block|}
struct|;
name|size_t
name|Clusterify
parameter_list|(
name|CaseVector
modifier|&
name|Cases
parameter_list|,
specifier|const
name|SwitchInst
modifier|&
name|SI
parameter_list|)
function_decl|;
comment|/// CaseBlock - This structure is used to communicate between
comment|/// SelectionDAGBuilder and SDISel for the code generation of additional basic
comment|/// blocks needed by multi-case switch statements.
struct|struct
name|CaseBlock
block|{
name|CaseBlock
argument_list|(
argument|ISD::CondCode cc
argument_list|,
argument|Value *cmplhs
argument_list|,
argument|Value *cmprhs
argument_list|,
argument|Value *cmpmiddle
argument_list|,
argument|MachineBasicBlock *truebb
argument_list|,
argument|MachineBasicBlock *falsebb
argument_list|,
argument|MachineBasicBlock *me
argument_list|)
block|:
name|CC
argument_list|(
name|cc
argument_list|)
operator|,
name|CmpLHS
argument_list|(
name|cmplhs
argument_list|)
operator|,
name|CmpMHS
argument_list|(
name|cmpmiddle
argument_list|)
operator|,
name|CmpRHS
argument_list|(
name|cmprhs
argument_list|)
operator|,
name|TrueBB
argument_list|(
name|truebb
argument_list|)
operator|,
name|FalseBB
argument_list|(
name|falsebb
argument_list|)
operator|,
name|ThisBB
argument_list|(
argument|me
argument_list|)
block|{}
comment|// CC - the condition code to use for the case block's setcc node
name|ISD
operator|::
name|CondCode
name|CC
expr_stmt|;
comment|// CmpLHS/CmpRHS/CmpMHS - The LHS/MHS/RHS of the comparison to emit.
comment|// Emit by default LHS op RHS. MHS is used for range comparisons:
comment|// If MHS is not null: (LHS<= MHS) and (MHS<= RHS).
name|Value
modifier|*
name|CmpLHS
decl_stmt|,
modifier|*
name|CmpMHS
decl_stmt|,
modifier|*
name|CmpRHS
decl_stmt|;
comment|// TrueBB/FalseBB - the block to branch to if the setcc is true/false.
name|MachineBasicBlock
modifier|*
name|TrueBB
decl_stmt|,
modifier|*
name|FalseBB
decl_stmt|;
comment|// ThisBB - the block into which to emit the code for the setcc and branches
name|MachineBasicBlock
modifier|*
name|ThisBB
decl_stmt|;
block|}
struct|;
struct|struct
name|JumpTable
block|{
name|JumpTable
argument_list|(
argument|unsigned R
argument_list|,
argument|unsigned J
argument_list|,
argument|MachineBasicBlock *M
argument_list|,
argument|MachineBasicBlock *D
argument_list|)
block|:
name|Reg
argument_list|(
name|R
argument_list|)
operator|,
name|JTI
argument_list|(
name|J
argument_list|)
operator|,
name|MBB
argument_list|(
name|M
argument_list|)
operator|,
name|Default
argument_list|(
argument|D
argument_list|)
block|{}
comment|/// Reg - the virtual register containing the index of the jump table entry
comment|//. to jump to.
name|unsigned
name|Reg
expr_stmt|;
comment|/// JTI - the JumpTableIndex for this jump table in the function.
name|unsigned
name|JTI
decl_stmt|;
comment|/// MBB - the MBB into which to emit the code for the indirect jump.
name|MachineBasicBlock
modifier|*
name|MBB
decl_stmt|;
comment|/// Default - the MBB of the default bb, which is a successor of the range
comment|/// check MBB.  This is when updating PHI nodes in successors.
name|MachineBasicBlock
modifier|*
name|Default
decl_stmt|;
block|}
struct|;
struct|struct
name|JumpTableHeader
block|{
name|JumpTableHeader
argument_list|(
argument|APInt F
argument_list|,
argument|APInt L
argument_list|,
argument|Value* SV
argument_list|,
argument|MachineBasicBlock* H
argument_list|,
argument|bool E = false
argument_list|)
block|:
name|First
argument_list|(
name|F
argument_list|)
operator|,
name|Last
argument_list|(
name|L
argument_list|)
operator|,
name|SValue
argument_list|(
name|SV
argument_list|)
operator|,
name|HeaderBB
argument_list|(
name|H
argument_list|)
operator|,
name|Emitted
argument_list|(
argument|E
argument_list|)
block|{}
name|APInt
name|First
expr_stmt|;
name|APInt
name|Last
decl_stmt|;
name|Value
modifier|*
name|SValue
decl_stmt|;
name|MachineBasicBlock
modifier|*
name|HeaderBB
decl_stmt|;
name|bool
name|Emitted
decl_stmt|;
block|}
struct|;
typedef|typedef
name|std
operator|::
name|pair
operator|<
name|JumpTableHeader
operator|,
name|JumpTable
operator|>
name|JumpTableBlock
expr_stmt|;
struct|struct
name|BitTestCase
block|{
name|BitTestCase
argument_list|(
argument|uint64_t M
argument_list|,
argument|MachineBasicBlock* T
argument_list|,
argument|MachineBasicBlock* Tr
argument_list|)
block|:
name|Mask
argument_list|(
name|M
argument_list|)
operator|,
name|ThisBB
argument_list|(
name|T
argument_list|)
operator|,
name|TargetBB
argument_list|(
argument|Tr
argument_list|)
block|{ }
name|uint64_t
name|Mask
expr_stmt|;
name|MachineBasicBlock
modifier|*
name|ThisBB
decl_stmt|;
name|MachineBasicBlock
modifier|*
name|TargetBB
decl_stmt|;
block|}
struct|;
typedef|typedef
name|SmallVector
operator|<
name|BitTestCase
operator|,
literal|3
operator|>
name|BitTestInfo
expr_stmt|;
struct|struct
name|BitTestBlock
block|{
name|BitTestBlock
argument_list|(
argument|APInt F
argument_list|,
argument|APInt R
argument_list|,
argument|Value* SV
argument_list|,
argument|unsigned Rg
argument_list|,
argument|bool E
argument_list|,
argument|MachineBasicBlock* P
argument_list|,
argument|MachineBasicBlock* D
argument_list|,
argument|const BitTestInfo& C
argument_list|)
block|:
name|First
argument_list|(
name|F
argument_list|)
operator|,
name|Range
argument_list|(
name|R
argument_list|)
operator|,
name|SValue
argument_list|(
name|SV
argument_list|)
operator|,
name|Reg
argument_list|(
name|Rg
argument_list|)
operator|,
name|Emitted
argument_list|(
name|E
argument_list|)
operator|,
name|Parent
argument_list|(
name|P
argument_list|)
operator|,
name|Default
argument_list|(
name|D
argument_list|)
operator|,
name|Cases
argument_list|(
argument|C
argument_list|)
block|{ }
name|APInt
name|First
expr_stmt|;
name|APInt
name|Range
decl_stmt|;
name|Value
modifier|*
name|SValue
decl_stmt|;
name|unsigned
name|Reg
decl_stmt|;
name|bool
name|Emitted
decl_stmt|;
name|MachineBasicBlock
modifier|*
name|Parent
decl_stmt|;
name|MachineBasicBlock
modifier|*
name|Default
decl_stmt|;
name|BitTestInfo
name|Cases
decl_stmt|;
block|}
struct|;
name|public
label|:
comment|// TLI - This is information that describes the available target features we
comment|// need for lowering.  This indicates when operations are unavailable,
comment|// implemented with a libcall, etc.
name|TargetLowering
modifier|&
name|TLI
decl_stmt|;
name|SelectionDAG
modifier|&
name|DAG
decl_stmt|;
specifier|const
name|TargetData
modifier|*
name|TD
decl_stmt|;
name|AliasAnalysis
modifier|*
name|AA
decl_stmt|;
comment|/// SwitchCases - Vector of CaseBlock structures used to communicate
comment|/// SwitchInst code generation information.
name|std
operator|::
name|vector
operator|<
name|CaseBlock
operator|>
name|SwitchCases
expr_stmt|;
comment|/// JTCases - Vector of JumpTable structures used to communicate
comment|/// SwitchInst code generation information.
name|std
operator|::
name|vector
operator|<
name|JumpTableBlock
operator|>
name|JTCases
expr_stmt|;
comment|/// BitTestCases - Vector of BitTestBlock structures used to communicate
comment|/// SwitchInst code generation information.
name|std
operator|::
name|vector
operator|<
name|BitTestBlock
operator|>
name|BitTestCases
expr_stmt|;
comment|/// PHINodesToUpdate - A list of phi instructions whose operand list will
comment|/// be updated after processing the current basic block.
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|MachineInstr
operator|*
operator|,
name|unsigned
operator|>
expr|>
name|PHINodesToUpdate
expr_stmt|;
comment|/// EdgeMapping - If an edge from CurMBB to any MBB is changed (e.g. due to
comment|/// scheduler custom lowering), track the change here.
name|DenseMap
operator|<
name|MachineBasicBlock
operator|*
operator|,
name|MachineBasicBlock
operator|*
operator|>
name|EdgeMapping
expr_stmt|;
comment|// Emit PHI-node-operand constants only once even if used by multiple
comment|// PHI nodes.
name|DenseMap
operator|<
name|Constant
operator|*
operator|,
name|unsigned
operator|>
name|ConstantsOut
expr_stmt|;
comment|/// FuncInfo - Information about the function as a whole.
comment|///
name|FunctionLoweringInfo
modifier|&
name|FuncInfo
decl_stmt|;
comment|/// OptLevel - What optimization level we're generating code for.
comment|///
name|CodeGenOpt
operator|::
name|Level
name|OptLevel
expr_stmt|;
comment|/// GFI - Garbage collection metadata for the function.
name|GCFunctionInfo
modifier|*
name|GFI
decl_stmt|;
comment|/// HasTailCall - This is set to true if a call in the current
comment|/// block has been translated as a tail call. In this case,
comment|/// no subsequent DAG nodes should be created.
comment|///
name|bool
name|HasTailCall
decl_stmt|;
name|LLVMContext
modifier|*
name|Context
decl_stmt|;
name|SelectionDAGBuilder
argument_list|(
argument|SelectionDAG&dag
argument_list|,
argument|TargetLowering&tli
argument_list|,
argument|FunctionLoweringInfo&funcinfo
argument_list|,
argument|CodeGenOpt::Level ol
argument_list|)
block|:
name|CurDebugLoc
argument_list|(
name|DebugLoc
operator|::
name|getUnknownLoc
argument_list|()
argument_list|)
operator|,
name|SDNodeOrder
argument_list|(
literal|0
argument_list|)
operator|,
name|TLI
argument_list|(
name|tli
argument_list|)
operator|,
name|DAG
argument_list|(
name|dag
argument_list|)
operator|,
name|FuncInfo
argument_list|(
name|funcinfo
argument_list|)
operator|,
name|OptLevel
argument_list|(
name|ol
argument_list|)
operator|,
name|HasTailCall
argument_list|(
name|false
argument_list|)
operator|,
name|Context
argument_list|(
argument|dag.getContext()
argument_list|)
block|{   }
name|void
name|init
argument_list|(
name|GCFunctionInfo
operator|*
name|gfi
argument_list|,
name|AliasAnalysis
operator|&
name|aa
argument_list|)
expr_stmt|;
comment|/// clear - Clear out the curret SelectionDAG and the associated
comment|/// state and prepare this SelectionDAGBuilder object to be used
comment|/// for a new block. This doesn't clear out information about
comment|/// additional blocks that are needed to complete switch lowering
comment|/// or PHI node updating; that information is cleared out as it is
comment|/// consumed.
name|void
name|clear
parameter_list|()
function_decl|;
comment|/// getRoot - Return the current virtual root of the Selection DAG,
comment|/// flushing any PendingLoad items. This must be done before emitting
comment|/// a store or any other node that may need to be ordered after any
comment|/// prior load instructions.
comment|///
name|SDValue
name|getRoot
parameter_list|()
function_decl|;
comment|/// getControlRoot - Similar to getRoot, but instead of flushing all the
comment|/// PendingLoad items, flush all the PendingExports items. It is necessary
comment|/// to do this before emitting a terminator instruction.
comment|///
name|SDValue
name|getControlRoot
parameter_list|()
function_decl|;
name|DebugLoc
name|getCurDebugLoc
argument_list|()
specifier|const
block|{
return|return
name|CurDebugLoc
return|;
block|}
name|void
name|setCurDebugLoc
parameter_list|(
name|DebugLoc
name|dl
parameter_list|)
block|{
name|CurDebugLoc
operator|=
name|dl
expr_stmt|;
block|}
name|unsigned
name|getSDNodeOrder
argument_list|()
specifier|const
block|{
return|return
name|SDNodeOrder
return|;
block|}
name|void
name|CopyValueToVirtualRegister
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|unsigned
name|Reg
parameter_list|)
function_decl|;
name|void
name|visit
parameter_list|(
name|Instruction
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visit
parameter_list|(
name|unsigned
name|Opcode
parameter_list|,
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|setCurrentBasicBlock
parameter_list|(
name|MachineBasicBlock
modifier|*
name|MBB
parameter_list|)
block|{
name|CurMBB
operator|=
name|MBB
expr_stmt|;
block|}
name|SDValue
name|getValue
parameter_list|(
specifier|const
name|Value
modifier|*
name|V
parameter_list|)
function_decl|;
name|void
name|setValue
parameter_list|(
specifier|const
name|Value
modifier|*
name|V
parameter_list|,
name|SDValue
name|NewN
parameter_list|)
block|{
name|SDValue
modifier|&
name|N
init|=
name|NodeMap
index|[
name|V
index|]
decl_stmt|;
name|assert
argument_list|(
name|N
operator|.
name|getNode
argument_list|()
operator|==
literal|0
operator|&&
literal|"Already set a value for this node!"
argument_list|)
expr_stmt|;
name|N
operator|=
name|NewN
expr_stmt|;
block|}
name|void
name|GetRegistersForValue
argument_list|(
name|SDISelAsmOperandInfo
operator|&
name|OpInfo
argument_list|,
name|std
operator|::
name|set
operator|<
name|unsigned
operator|>
operator|&
name|OutputRegs
argument_list|,
name|std
operator|::
name|set
operator|<
name|unsigned
operator|>
operator|&
name|InputRegs
argument_list|)
decl_stmt|;
name|void
name|FindMergedConditions
parameter_list|(
name|Value
modifier|*
name|Cond
parameter_list|,
name|MachineBasicBlock
modifier|*
name|TBB
parameter_list|,
name|MachineBasicBlock
modifier|*
name|FBB
parameter_list|,
name|MachineBasicBlock
modifier|*
name|CurBB
parameter_list|,
name|unsigned
name|Opc
parameter_list|)
function_decl|;
name|void
name|EmitBranchForMergedCondition
parameter_list|(
name|Value
modifier|*
name|Cond
parameter_list|,
name|MachineBasicBlock
modifier|*
name|TBB
parameter_list|,
name|MachineBasicBlock
modifier|*
name|FBB
parameter_list|,
name|MachineBasicBlock
modifier|*
name|CurBB
parameter_list|)
function_decl|;
name|bool
name|ShouldEmitAsBranches
argument_list|(
specifier|const
name|std
operator|::
name|vector
operator|<
name|CaseBlock
operator|>
operator|&
name|Cases
argument_list|)
decl_stmt|;
name|bool
name|isExportableFromCurrentBlock
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
specifier|const
name|BasicBlock
modifier|*
name|FromBB
parameter_list|)
function_decl|;
name|void
name|CopyToExportRegsIfNeeded
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|)
function_decl|;
name|void
name|ExportFromCurrentBlock
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|)
function_decl|;
name|void
name|LowerCallTo
parameter_list|(
name|CallSite
name|CS
parameter_list|,
name|SDValue
name|Callee
parameter_list|,
name|bool
name|IsTailCall
parameter_list|,
name|MachineBasicBlock
modifier|*
name|LandingPad
init|=
name|NULL
parameter_list|)
function_decl|;
name|private
label|:
comment|// Terminator instructions.
name|void
name|visitRet
parameter_list|(
name|ReturnInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitBr
parameter_list|(
name|BranchInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitSwitch
parameter_list|(
name|SwitchInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitIndirectBr
parameter_list|(
name|IndirectBrInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitUnreachable
parameter_list|(
name|UnreachableInst
modifier|&
name|I
parameter_list|)
block|{
comment|/* noop */
block|}
comment|// Helpers for visitSwitch
name|bool
name|handleSmallSwitchRange
parameter_list|(
name|CaseRec
modifier|&
name|CR
parameter_list|,
name|CaseRecVector
modifier|&
name|WorkList
parameter_list|,
name|Value
modifier|*
name|SV
parameter_list|,
name|MachineBasicBlock
modifier|*
name|Default
parameter_list|)
function_decl|;
name|bool
name|handleJTSwitchCase
parameter_list|(
name|CaseRec
modifier|&
name|CR
parameter_list|,
name|CaseRecVector
modifier|&
name|WorkList
parameter_list|,
name|Value
modifier|*
name|SV
parameter_list|,
name|MachineBasicBlock
modifier|*
name|Default
parameter_list|)
function_decl|;
name|bool
name|handleBTSplitSwitchCase
parameter_list|(
name|CaseRec
modifier|&
name|CR
parameter_list|,
name|CaseRecVector
modifier|&
name|WorkList
parameter_list|,
name|Value
modifier|*
name|SV
parameter_list|,
name|MachineBasicBlock
modifier|*
name|Default
parameter_list|)
function_decl|;
name|bool
name|handleBitTestsSwitchCase
parameter_list|(
name|CaseRec
modifier|&
name|CR
parameter_list|,
name|CaseRecVector
modifier|&
name|WorkList
parameter_list|,
name|Value
modifier|*
name|SV
parameter_list|,
name|MachineBasicBlock
modifier|*
name|Default
parameter_list|)
function_decl|;
name|public
label|:
name|void
name|visitSwitchCase
parameter_list|(
name|CaseBlock
modifier|&
name|CB
parameter_list|)
function_decl|;
name|void
name|visitBitTestHeader
parameter_list|(
name|BitTestBlock
modifier|&
name|B
parameter_list|)
function_decl|;
name|void
name|visitBitTestCase
parameter_list|(
name|MachineBasicBlock
modifier|*
name|NextMBB
parameter_list|,
name|unsigned
name|Reg
parameter_list|,
name|BitTestCase
modifier|&
name|B
parameter_list|)
function_decl|;
name|void
name|visitJumpTable
parameter_list|(
name|JumpTable
modifier|&
name|JT
parameter_list|)
function_decl|;
name|void
name|visitJumpTableHeader
parameter_list|(
name|JumpTable
modifier|&
name|JT
parameter_list|,
name|JumpTableHeader
modifier|&
name|JTH
parameter_list|)
function_decl|;
name|private
label|:
comment|// These all get lowered before this pass.
name|void
name|visitInvoke
parameter_list|(
name|InvokeInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitUnwind
parameter_list|(
name|UnwindInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitBinary
parameter_list|(
name|User
modifier|&
name|I
parameter_list|,
name|unsigned
name|OpCode
parameter_list|)
function_decl|;
name|void
name|visitShift
parameter_list|(
name|User
modifier|&
name|I
parameter_list|,
name|unsigned
name|Opcode
parameter_list|)
function_decl|;
name|void
name|visitAdd
parameter_list|(
name|User
modifier|&
name|I
parameter_list|)
block|{
name|visitBinary
argument_list|(
name|I
argument_list|,
name|ISD
operator|::
name|ADD
argument_list|)
expr_stmt|;
block|}
name|void
name|visitFAdd
parameter_list|(
name|User
modifier|&
name|I
parameter_list|)
block|{
name|visitBinary
argument_list|(
name|I
argument_list|,
name|ISD
operator|::
name|FADD
argument_list|)
expr_stmt|;
block|}
name|void
name|visitSub
parameter_list|(
name|User
modifier|&
name|I
parameter_list|)
block|{
name|visitBinary
argument_list|(
name|I
argument_list|,
name|ISD
operator|::
name|SUB
argument_list|)
expr_stmt|;
block|}
name|void
name|visitFSub
parameter_list|(
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitMul
parameter_list|(
name|User
modifier|&
name|I
parameter_list|)
block|{
name|visitBinary
argument_list|(
name|I
argument_list|,
name|ISD
operator|::
name|MUL
argument_list|)
expr_stmt|;
block|}
name|void
name|visitFMul
parameter_list|(
name|User
modifier|&
name|I
parameter_list|)
block|{
name|visitBinary
argument_list|(
name|I
argument_list|,
name|ISD
operator|::
name|FMUL
argument_list|)
expr_stmt|;
block|}
name|void
name|visitURem
parameter_list|(
name|User
modifier|&
name|I
parameter_list|)
block|{
name|visitBinary
argument_list|(
name|I
argument_list|,
name|ISD
operator|::
name|UREM
argument_list|)
expr_stmt|;
block|}
name|void
name|visitSRem
parameter_list|(
name|User
modifier|&
name|I
parameter_list|)
block|{
name|visitBinary
argument_list|(
name|I
argument_list|,
name|ISD
operator|::
name|SREM
argument_list|)
expr_stmt|;
block|}
name|void
name|visitFRem
parameter_list|(
name|User
modifier|&
name|I
parameter_list|)
block|{
name|visitBinary
argument_list|(
name|I
argument_list|,
name|ISD
operator|::
name|FREM
argument_list|)
expr_stmt|;
block|}
name|void
name|visitUDiv
parameter_list|(
name|User
modifier|&
name|I
parameter_list|)
block|{
name|visitBinary
argument_list|(
name|I
argument_list|,
name|ISD
operator|::
name|UDIV
argument_list|)
expr_stmt|;
block|}
name|void
name|visitSDiv
parameter_list|(
name|User
modifier|&
name|I
parameter_list|)
block|{
name|visitBinary
argument_list|(
name|I
argument_list|,
name|ISD
operator|::
name|SDIV
argument_list|)
expr_stmt|;
block|}
name|void
name|visitFDiv
parameter_list|(
name|User
modifier|&
name|I
parameter_list|)
block|{
name|visitBinary
argument_list|(
name|I
argument_list|,
name|ISD
operator|::
name|FDIV
argument_list|)
expr_stmt|;
block|}
name|void
name|visitAnd
parameter_list|(
name|User
modifier|&
name|I
parameter_list|)
block|{
name|visitBinary
argument_list|(
name|I
argument_list|,
name|ISD
operator|::
name|AND
argument_list|)
expr_stmt|;
block|}
name|void
name|visitOr
parameter_list|(
name|User
modifier|&
name|I
parameter_list|)
block|{
name|visitBinary
argument_list|(
name|I
argument_list|,
name|ISD
operator|::
name|OR
argument_list|)
expr_stmt|;
block|}
name|void
name|visitXor
parameter_list|(
name|User
modifier|&
name|I
parameter_list|)
block|{
name|visitBinary
argument_list|(
name|I
argument_list|,
name|ISD
operator|::
name|XOR
argument_list|)
expr_stmt|;
block|}
name|void
name|visitShl
parameter_list|(
name|User
modifier|&
name|I
parameter_list|)
block|{
name|visitShift
argument_list|(
name|I
argument_list|,
name|ISD
operator|::
name|SHL
argument_list|)
expr_stmt|;
block|}
name|void
name|visitLShr
parameter_list|(
name|User
modifier|&
name|I
parameter_list|)
block|{
name|visitShift
argument_list|(
name|I
argument_list|,
name|ISD
operator|::
name|SRL
argument_list|)
expr_stmt|;
block|}
name|void
name|visitAShr
parameter_list|(
name|User
modifier|&
name|I
parameter_list|)
block|{
name|visitShift
argument_list|(
name|I
argument_list|,
name|ISD
operator|::
name|SRA
argument_list|)
expr_stmt|;
block|}
name|void
name|visitICmp
parameter_list|(
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitFCmp
parameter_list|(
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
comment|// Visit the conversion instructions
name|void
name|visitTrunc
parameter_list|(
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitZExt
parameter_list|(
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitSExt
parameter_list|(
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitFPTrunc
parameter_list|(
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitFPExt
parameter_list|(
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitFPToUI
parameter_list|(
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitFPToSI
parameter_list|(
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitUIToFP
parameter_list|(
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitSIToFP
parameter_list|(
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitPtrToInt
parameter_list|(
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitIntToPtr
parameter_list|(
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitBitCast
parameter_list|(
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitExtractElement
parameter_list|(
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitInsertElement
parameter_list|(
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitShuffleVector
parameter_list|(
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitExtractValue
parameter_list|(
name|ExtractValueInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitInsertValue
parameter_list|(
name|InsertValueInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitGetElementPtr
parameter_list|(
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitSelect
parameter_list|(
name|User
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitAlloca
parameter_list|(
name|AllocaInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitLoad
parameter_list|(
name|LoadInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitStore
parameter_list|(
name|StoreInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitPHI
parameter_list|(
name|PHINode
modifier|&
name|I
parameter_list|)
block|{ }
comment|// PHI nodes are handled specially.
name|void
name|visitCall
parameter_list|(
name|CallInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|bool
name|visitMemCmpCall
parameter_list|(
name|CallInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitInlineAsm
parameter_list|(
name|CallSite
name|CS
parameter_list|)
function_decl|;
specifier|const
name|char
modifier|*
name|visitIntrinsicCall
parameter_list|(
name|CallInst
modifier|&
name|I
parameter_list|,
name|unsigned
name|Intrinsic
parameter_list|)
function_decl|;
name|void
name|visitTargetIntrinsic
parameter_list|(
name|CallInst
modifier|&
name|I
parameter_list|,
name|unsigned
name|Intrinsic
parameter_list|)
function_decl|;
name|void
name|visitPow
parameter_list|(
name|CallInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitExp2
parameter_list|(
name|CallInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitExp
parameter_list|(
name|CallInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitLog
parameter_list|(
name|CallInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitLog2
parameter_list|(
name|CallInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitLog10
parameter_list|(
name|CallInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitVAStart
parameter_list|(
name|CallInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitVAArg
parameter_list|(
name|VAArgInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitVAEnd
parameter_list|(
name|CallInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitVACopy
parameter_list|(
name|CallInst
modifier|&
name|I
parameter_list|)
function_decl|;
name|void
name|visitUserOp1
parameter_list|(
name|Instruction
modifier|&
name|I
parameter_list|)
block|{
name|llvm_unreachable
argument_list|(
literal|"UserOp1 should not exist at instruction selection time!"
argument_list|)
expr_stmt|;
block|}
name|void
name|visitUserOp2
parameter_list|(
name|Instruction
modifier|&
name|I
parameter_list|)
block|{
name|llvm_unreachable
argument_list|(
literal|"UserOp2 should not exist at instruction selection time!"
argument_list|)
expr_stmt|;
block|}
specifier|const
name|char
modifier|*
name|implVisitBinaryAtomic
argument_list|(
name|CallInst
operator|&
name|I
argument_list|,
name|ISD
operator|::
name|NodeType
name|Op
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|implVisitAluOverflow
argument_list|(
name|CallInst
operator|&
name|I
argument_list|,
name|ISD
operator|::
name|NodeType
name|Op
argument_list|)
decl_stmt|;
block|}
empty_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// end namespace llvm
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

