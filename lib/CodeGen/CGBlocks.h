begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- CGBlocks.h - state for LLVM CodeGen for blocks ----------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This is the internal state used for llvm translation for block literals.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_LIB_CODEGEN_CGBLOCKS_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_LIB_CODEGEN_CGBLOCKS_H
end_define

begin_include
include|#
directive|include
file|"CGBuilder.h"
end_include

begin_include
include|#
directive|include
file|"CGCall.h"
end_include

begin_include
include|#
directive|include
file|"CGValue.h"
end_include

begin_include
include|#
directive|include
file|"CodeGenFunction.h"
end_include

begin_include
include|#
directive|include
file|"CodeGenTypes.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/CharUnits.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/Expr.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/ExprCXX.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/ExprObjC.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/Type.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/TargetInfo.h"
end_include

begin_include
include|#
directive|include
file|"llvm/IR/Module.h"
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|Module
decl_stmt|;
name|class
name|Constant
decl_stmt|;
name|class
name|Function
decl_stmt|;
name|class
name|GlobalValue
decl_stmt|;
name|class
name|DataLayout
decl_stmt|;
name|class
name|FunctionType
decl_stmt|;
name|class
name|PointerType
decl_stmt|;
name|class
name|Value
decl_stmt|;
name|class
name|LLVMContext
decl_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|clang
block|{
name|namespace
name|CodeGen
block|{
name|class
name|CodeGenModule
decl_stmt|;
name|class
name|CGBlockInfo
decl_stmt|;
comment|// Flags stored in __block variables.
enum|enum
name|BlockByrefFlags
block|{
name|BLOCK_BYREF_HAS_COPY_DISPOSE
init|=
operator|(
literal|1
operator|<<
literal|25
operator|)
block|,
comment|// compiler
name|BLOCK_BYREF_LAYOUT_MASK
init|=
operator|(
literal|0xF
operator|<<
literal|28
operator|)
block|,
comment|// compiler
name|BLOCK_BYREF_LAYOUT_EXTENDED
init|=
operator|(
literal|1
operator|<<
literal|28
operator|)
block|,
name|BLOCK_BYREF_LAYOUT_NON_OBJECT
init|=
operator|(
literal|2
operator|<<
literal|28
operator|)
block|,
name|BLOCK_BYREF_LAYOUT_STRONG
init|=
operator|(
literal|3
operator|<<
literal|28
operator|)
block|,
name|BLOCK_BYREF_LAYOUT_WEAK
init|=
operator|(
literal|4
operator|<<
literal|28
operator|)
block|,
name|BLOCK_BYREF_LAYOUT_UNRETAINED
init|=
operator|(
literal|5
operator|<<
literal|28
operator|)
block|}
enum|;
enum|enum
name|BlockLiteralFlags
block|{
name|BLOCK_HAS_COPY_DISPOSE
init|=
operator|(
literal|1
operator|<<
literal|25
operator|)
block|,
name|BLOCK_HAS_CXX_OBJ
init|=
operator|(
literal|1
operator|<<
literal|26
operator|)
block|,
name|BLOCK_IS_GLOBAL
init|=
operator|(
literal|1
operator|<<
literal|28
operator|)
block|,
name|BLOCK_USE_STRET
init|=
operator|(
literal|1
operator|<<
literal|29
operator|)
block|,
name|BLOCK_HAS_SIGNATURE
init|=
operator|(
literal|1
operator|<<
literal|30
operator|)
block|,
name|BLOCK_HAS_EXTENDED_LAYOUT
init|=
operator|(
literal|1
operator|<<
literal|31
operator|)
block|}
enum|;
name|class
name|BlockFlags
block|{
name|uint32_t
name|flags
decl_stmt|;
name|public
label|:
name|BlockFlags
argument_list|(
argument|uint32_t flags
argument_list|)
block|:
name|flags
argument_list|(
argument|flags
argument_list|)
block|{}
name|BlockFlags
argument_list|()
operator|:
name|flags
argument_list|(
literal|0
argument_list|)
block|{}
name|BlockFlags
argument_list|(
argument|BlockLiteralFlags flag
argument_list|)
operator|:
name|flags
argument_list|(
argument|flag
argument_list|)
block|{}
name|BlockFlags
argument_list|(
argument|BlockByrefFlags flag
argument_list|)
operator|:
name|flags
argument_list|(
argument|flag
argument_list|)
block|{}
name|uint32_t
name|getBitMask
argument_list|()
specifier|const
block|{
return|return
name|flags
return|;
block|}
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|flags
operator|==
literal|0
return|;
block|}
name|friend
name|BlockFlags
name|operator
operator||
operator|(
name|BlockFlags
name|l
operator|,
name|BlockFlags
name|r
operator|)
block|{
return|return
name|BlockFlags
argument_list|(
name|l
operator|.
name|flags
operator||
name|r
operator|.
name|flags
argument_list|)
return|;
block|}
name|friend
name|BlockFlags
operator|&
name|operator
operator||=
operator|(
name|BlockFlags
operator|&
name|l
operator|,
name|BlockFlags
name|r
operator|)
block|{
name|l
operator|.
name|flags
operator||=
name|r
operator|.
name|flags
block|;
return|return
name|l
return|;
block|}
name|friend
name|bool
name|operator
function|&(
name|BlockFlags
name|l
function|,
name|BlockFlags
function|r
block|)
block|{
return|return
operator|(
name|l
operator|.
name|flags
operator|&
name|r
operator|.
name|flags
operator|)
return|;
block|}
name|bool
name|operator
operator|==
operator|(
name|BlockFlags
name|r
operator|)
block|{
return|return
operator|(
name|flags
operator|==
name|r
operator|.
name|flags
operator|)
return|;
block|}
block|}
empty_stmt|;
specifier|inline
name|BlockFlags
name|operator
operator||
operator|(
name|BlockLiteralFlags
name|l
operator|,
name|BlockLiteralFlags
name|r
operator|)
block|{
return|return
name|BlockFlags
argument_list|(
name|l
argument_list|)
operator||
name|BlockFlags
argument_list|(
name|r
argument_list|)
return|;
block|}
enum|enum
name|BlockFieldFlag_t
block|{
name|BLOCK_FIELD_IS_OBJECT
init|=
literal|0x03
block|,
comment|/* id, NSObject, __attribute__((NSObject)),                                     block, ... */
name|BLOCK_FIELD_IS_BLOCK
init|=
literal|0x07
block|,
comment|/* a block variable */
name|BLOCK_FIELD_IS_BYREF
init|=
literal|0x08
block|,
comment|/* the on stack structure holding the __block                                     variable */
name|BLOCK_FIELD_IS_WEAK
init|=
literal|0x10
block|,
comment|/* declared __weak, only used in byref copy                                     helpers */
name|BLOCK_FIELD_IS_ARC
init|=
literal|0x40
block|,
comment|/* field has ARC-specific semantics */
name|BLOCK_BYREF_CALLER
init|=
literal|128
block|,
comment|/* called from __block (byref) copy/dispose                                       support routines */
name|BLOCK_BYREF_CURRENT_MAX
init|=
literal|256
block|}
enum|;
name|class
name|BlockFieldFlags
block|{
name|uint32_t
name|flags
decl_stmt|;
name|BlockFieldFlags
argument_list|(
argument|uint32_t flags
argument_list|)
block|:
name|flags
argument_list|(
argument|flags
argument_list|)
block|{}
name|public
label|:
name|BlockFieldFlags
argument_list|()
operator|:
name|flags
argument_list|(
literal|0
argument_list|)
block|{}
name|BlockFieldFlags
argument_list|(
argument|BlockFieldFlag_t flag
argument_list|)
operator|:
name|flags
argument_list|(
argument|flag
argument_list|)
block|{}
name|uint32_t
name|getBitMask
argument_list|()
specifier|const
block|{
return|return
name|flags
return|;
block|}
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|flags
operator|==
literal|0
return|;
block|}
comment|/// Answers whether the flags indicate that this field is an object
comment|/// or block pointer that requires _Block_object_assign/dispose.
name|bool
name|isSpecialPointer
argument_list|()
specifier|const
block|{
return|return
name|flags
operator|&
name|BLOCK_FIELD_IS_OBJECT
return|;
block|}
name|friend
name|BlockFieldFlags
name|operator
operator||
operator|(
name|BlockFieldFlags
name|l
operator|,
name|BlockFieldFlags
name|r
operator|)
block|{
return|return
name|BlockFieldFlags
argument_list|(
name|l
operator|.
name|flags
operator||
name|r
operator|.
name|flags
argument_list|)
return|;
block|}
name|friend
name|BlockFieldFlags
operator|&
name|operator
operator||=
operator|(
name|BlockFieldFlags
operator|&
name|l
operator|,
name|BlockFieldFlags
name|r
operator|)
block|{
name|l
operator|.
name|flags
operator||=
name|r
operator|.
name|flags
block|;
return|return
name|l
return|;
block|}
name|friend
name|bool
name|operator
function|&(
name|BlockFieldFlags
name|l
function|,
name|BlockFieldFlags
function|r
block|)
block|{
return|return
operator|(
name|l
operator|.
name|flags
operator|&
name|r
operator|.
name|flags
operator|)
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
specifier|inline
name|BlockFieldFlags
name|operator
operator||
operator|(
name|BlockFieldFlag_t
name|l
operator|,
name|BlockFieldFlag_t
name|r
operator|)
block|{
return|return
name|BlockFieldFlags
argument_list|(
name|l
argument_list|)
operator||
name|BlockFieldFlags
argument_list|(
name|r
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// CGBlockInfo - Information to generate a block literal.
end_comment

begin_decl_stmt
name|class
name|CGBlockInfo
block|{
name|public
label|:
comment|/// Name - The name of the block, kindof.
name|StringRef
name|Name
decl_stmt|;
comment|/// The field index of 'this' within the block, if there is one.
name|unsigned
name|CXXThisIndex
decl_stmt|;
name|class
name|Capture
block|{
name|uintptr_t
name|Data
decl_stmt|;
name|EHScopeStack
operator|::
name|stable_iterator
name|Cleanup
expr_stmt|;
name|public
label|:
name|bool
name|isIndex
argument_list|()
specifier|const
block|{
return|return
operator|(
name|Data
operator|&
literal|1
operator|)
operator|!=
literal|0
return|;
block|}
name|bool
name|isConstant
argument_list|()
specifier|const
block|{
return|return
operator|!
name|isIndex
argument_list|()
return|;
block|}
name|unsigned
name|getIndex
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isIndex
argument_list|()
argument_list|)
block|;
return|return
name|Data
operator|>>
literal|1
return|;
block|}
name|llvm
operator|::
name|Value
operator|*
name|getConstant
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isConstant
argument_list|()
argument_list|)
block|;
return|return
name|reinterpret_cast
operator|<
name|llvm
operator|::
name|Value
operator|*
operator|>
operator|(
name|Data
operator|)
return|;
block|}
name|EHScopeStack
operator|::
name|stable_iterator
name|getCleanup
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|isIndex
argument_list|()
argument_list|)
block|;
return|return
name|Cleanup
return|;
block|}
name|void
name|setCleanup
argument_list|(
name|EHScopeStack
operator|::
name|stable_iterator
name|cleanup
argument_list|)
block|{
name|assert
argument_list|(
name|isIndex
argument_list|()
argument_list|)
expr_stmt|;
name|Cleanup
operator|=
name|cleanup
expr_stmt|;
block|}
specifier|static
name|Capture
name|makeIndex
parameter_list|(
name|unsigned
name|index
parameter_list|)
block|{
name|Capture
name|v
decl_stmt|;
name|v
operator|.
name|Data
operator|=
operator|(
name|index
operator|<<
literal|1
operator|)
operator||
literal|1
expr_stmt|;
return|return
name|v
return|;
block|}
specifier|static
name|Capture
name|makeConstant
argument_list|(
name|llvm
operator|::
name|Value
operator|*
name|value
argument_list|)
block|{
name|Capture
name|v
decl_stmt|;
name|v
operator|.
name|Data
operator|=
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|value
operator|)
expr_stmt|;
return|return
name|v
return|;
block|}
block|}
empty_stmt|;
comment|/// CanBeGlobal - True if the block can be global, i.e. it has
comment|/// no non-constant captures.
name|bool
name|CanBeGlobal
range|:
literal|1
decl_stmt|;
comment|/// True if the block needs a custom copy or dispose function.
name|bool
name|NeedsCopyDispose
range|:
literal|1
decl_stmt|;
comment|/// HasCXXObject - True if the block's custom copy/dispose functions
comment|/// need to be run even in GC mode.
name|bool
name|HasCXXObject
range|:
literal|1
decl_stmt|;
comment|/// UsesStret : True if the block uses an stret return.  Mutable
comment|/// because it gets set later in the block-creation process.
name|mutable
name|bool
name|UsesStret
range|:
literal|1
decl_stmt|;
comment|/// HasCapturedVariableLayout : True if block has captured variables
comment|/// and their layout meta-data has been generated.
name|bool
name|HasCapturedVariableLayout
range|:
literal|1
decl_stmt|;
comment|/// The mapping of allocated indexes within the block.
name|llvm
operator|::
name|DenseMap
operator|<
specifier|const
name|VarDecl
operator|*
operator|,
name|Capture
operator|>
name|Captures
expr_stmt|;
name|llvm
operator|::
name|AllocaInst
operator|*
name|Address
expr_stmt|;
name|llvm
operator|::
name|StructType
operator|*
name|StructureType
expr_stmt|;
specifier|const
name|BlockDecl
modifier|*
name|Block
decl_stmt|;
specifier|const
name|BlockExpr
modifier|*
name|BlockExpression
decl_stmt|;
name|CharUnits
name|BlockSize
decl_stmt|;
name|CharUnits
name|BlockAlign
decl_stmt|;
comment|// Offset of the gap caused by block header having a smaller
comment|// alignment than the alignment of the block descriptor. This
comment|// is the gap offset before the first capturued field.
name|CharUnits
name|BlockHeaderForcedGapOffset
decl_stmt|;
comment|// Gap size caused by aligning first field after block header.
comment|// This could be zero if no forced alignment is required.
name|CharUnits
name|BlockHeaderForcedGapSize
decl_stmt|;
comment|/// An instruction which dominates the full-expression that the
comment|/// block is inside.
name|llvm
operator|::
name|Instruction
operator|*
name|DominatingIP
expr_stmt|;
comment|/// The next block in the block-info chain.  Invalid if this block
comment|/// info is not part of the CGF's block-info chain, which is true
comment|/// if it corresponds to a global block or a block whose expression
comment|/// has been encountered.
name|CGBlockInfo
modifier|*
name|NextBlockInfo
decl_stmt|;
specifier|const
name|Capture
modifier|&
name|getCapture
argument_list|(
specifier|const
name|VarDecl
operator|*
name|var
argument_list|)
decl|const
block|{
return|return
name|const_cast
operator|<
name|CGBlockInfo
operator|*
operator|>
operator|(
name|this
operator|)
operator|->
name|getCapture
argument_list|(
name|var
argument_list|)
return|;
block|}
name|Capture
modifier|&
name|getCapture
parameter_list|(
specifier|const
name|VarDecl
modifier|*
name|var
parameter_list|)
block|{
name|llvm
operator|::
name|DenseMap
operator|<
specifier|const
name|VarDecl
operator|*
operator|,
name|Capture
operator|>
operator|::
name|iterator
name|it
operator|=
name|Captures
operator|.
name|find
argument_list|(
name|var
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|it
operator|!=
name|Captures
operator|.
name|end
argument_list|()
operator|&&
literal|"no entry for variable!"
argument_list|)
expr_stmt|;
return|return
name|it
operator|->
name|second
return|;
block|}
specifier|const
name|BlockDecl
operator|*
name|getBlockDecl
argument_list|()
specifier|const
block|{
return|return
name|Block
return|;
block|}
specifier|const
name|BlockExpr
operator|*
name|getBlockExpr
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|BlockExpression
argument_list|)
block|;
name|assert
argument_list|(
name|BlockExpression
operator|->
name|getBlockDecl
argument_list|()
operator|==
name|Block
argument_list|)
block|;
return|return
name|BlockExpression
return|;
block|}
name|CGBlockInfo
argument_list|(
argument|const BlockDecl *blockDecl
argument_list|,
argument|StringRef Name
argument_list|)
empty_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// end namespace CodeGen
end_comment

begin_comment
unit|}
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

