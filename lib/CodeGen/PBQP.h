begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===---------------- PBQP.cpp --------- PBQP Solver ------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Developed by:                   Bernhard Scholz
end_comment

begin_comment
comment|//                             The University of Sydney
end_comment

begin_comment
comment|//                         http://www.it.usyd.edu.au/~scholz
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// TODO:
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  * Default to null costs on vector initialisation?
end_comment

begin_comment
comment|//  * C++-ify the rest of the solver.
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CODEGEN_PBQPSOLVER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CODEGEN_PBQPSOLVER_H
end_define

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<functional>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|//! \brief Floating point type to use in PBQP solver.
typedef|typedef
name|double
name|PBQPNum
typedef|;
comment|//! \brief PBQP Vector class.
name|class
name|PBQPVector
block|{
name|public
label|:
comment|//! \brief Construct a PBQP vector of the given size.
name|explicit
name|PBQPVector
argument_list|(
argument|unsigned length
argument_list|)
block|:
name|length
argument_list|(
name|length
argument_list|)
operator|,
name|data
argument_list|(
argument|new PBQPNum[length]
argument_list|)
block|{
name|std
operator|::
name|fill
argument_list|(
name|data
argument_list|,
name|data
operator|+
name|length
argument_list|,
literal|0
argument_list|)
block|;   }
comment|//! \brief Copy construct a PBQP vector.
name|PBQPVector
argument_list|(
specifier|const
name|PBQPVector
operator|&
name|v
argument_list|)
operator|:
name|length
argument_list|(
name|v
operator|.
name|length
argument_list|)
operator|,
name|data
argument_list|(
argument|new PBQPNum[length]
argument_list|)
block|{
name|std
operator|::
name|copy
argument_list|(
name|v
operator|.
name|data
argument_list|,
name|v
operator|.
name|data
operator|+
name|length
argument_list|,
name|data
argument_list|)
block|;   }
operator|~
name|PBQPVector
argument_list|()
block|{
name|delete
index|[]
name|data
block|; }
comment|//! \brief Assignment operator.
name|PBQPVector
operator|&
name|operator
operator|=
operator|(
specifier|const
name|PBQPVector
operator|&
name|v
operator|)
block|{
name|delete
index|[]
name|data
block|;
name|length
operator|=
name|v
operator|.
name|length
block|;
name|data
operator|=
name|new
name|PBQPNum
index|[
name|length
index|]
block|;
name|std
operator|::
name|copy
argument_list|(
name|v
operator|.
name|data
argument_list|,
name|v
operator|.
name|data
operator|+
name|length
argument_list|,
name|data
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
comment|//! \brief Return the length of the vector
name|unsigned
name|getLength
argument_list|()
specifier|const
name|throw
argument_list|()
block|{
return|return
name|length
return|;
block|}
comment|//! \brief Element access.
name|PBQPNum
modifier|&
name|operator
function|[]
parameter_list|(
name|unsigned
name|index
parameter_list|)
block|{
name|assert
argument_list|(
name|index
operator|<
name|length
operator|&&
literal|"PBQPVector element access out of bounds."
argument_list|)
expr_stmt|;
return|return
name|data
index|[
name|index
index|]
return|;
block|}
comment|//! \brief Const element access.
specifier|const
name|PBQPNum
modifier|&
name|operator
index|[]
argument_list|(
name|unsigned
name|index
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|index
operator|<
name|length
operator|&&
literal|"PBQPVector element access out of bounds."
argument_list|)
expr_stmt|;
return|return
name|data
index|[
name|index
index|]
return|;
block|}
comment|//! \brief Add another vector to this one.
name|PBQPVector
operator|&
name|operator
operator|+=
operator|(
specifier|const
name|PBQPVector
operator|&
name|v
operator|)
block|{
name|assert
argument_list|(
name|length
operator|==
name|v
operator|.
name|length
operator|&&
literal|"PBQPVector length mismatch."
argument_list|)
block|;
name|std
operator|::
name|transform
argument_list|(
name|data
argument_list|,
name|data
operator|+
name|length
argument_list|,
name|v
operator|.
name|data
argument_list|,
name|data
argument_list|,
name|std
operator|::
name|plus
operator|<
name|PBQPNum
operator|>
operator|(
operator|)
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
comment|//! \brief Subtract another vector from this one.
name|PBQPVector
operator|&
name|operator
operator|-=
operator|(
specifier|const
name|PBQPVector
operator|&
name|v
operator|)
block|{
name|assert
argument_list|(
name|length
operator|==
name|v
operator|.
name|length
operator|&&
literal|"PBQPVector length mismatch."
argument_list|)
block|;
name|std
operator|::
name|transform
argument_list|(
name|data
argument_list|,
name|data
operator|+
name|length
argument_list|,
name|v
operator|.
name|data
argument_list|,
name|data
argument_list|,
name|std
operator|::
name|minus
operator|<
name|PBQPNum
operator|>
operator|(
operator|)
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
comment|//! \brief Returns the index of the minimum value in this vector
name|unsigned
name|minIndex
argument_list|()
specifier|const
block|{
return|return
name|std
operator|::
name|min_element
argument_list|(
name|data
argument_list|,
name|data
operator|+
name|length
argument_list|)
operator|-
name|data
return|;
block|}
name|private
label|:
name|unsigned
name|length
decl_stmt|;
name|PBQPNum
modifier|*
name|data
decl_stmt|;
block|}
empty_stmt|;
comment|//! \brief PBQP Matrix class
name|class
name|PBQPMatrix
block|{
name|public
label|:
comment|//! \brief Construct a PBQP Matrix with the given dimensions.
name|PBQPMatrix
argument_list|(
argument|unsigned rows
argument_list|,
argument|unsigned cols
argument_list|)
block|:
name|rows
argument_list|(
name|rows
argument_list|)
operator|,
name|cols
argument_list|(
name|cols
argument_list|)
operator|,
name|data
argument_list|(
argument|new PBQPNum[rows * cols]
argument_list|)
block|{
name|std
operator|::
name|fill
argument_list|(
name|data
argument_list|,
name|data
operator|+
operator|(
name|rows
operator|*
name|cols
operator|)
argument_list|,
literal|0
argument_list|)
block|;   }
comment|//! \brief Copy construct a PBQP matrix.
name|PBQPMatrix
argument_list|(
specifier|const
name|PBQPMatrix
operator|&
name|m
argument_list|)
operator|:
name|rows
argument_list|(
name|m
operator|.
name|rows
argument_list|)
operator|,
name|cols
argument_list|(
name|m
operator|.
name|cols
argument_list|)
operator|,
name|data
argument_list|(
argument|new PBQPNum[rows * cols]
argument_list|)
block|{
name|std
operator|::
name|copy
argument_list|(
name|m
operator|.
name|data
argument_list|,
name|m
operator|.
name|data
operator|+
operator|(
name|rows
operator|*
name|cols
operator|)
argument_list|,
name|data
argument_list|)
block|;     }
operator|~
name|PBQPMatrix
argument_list|()
block|{
name|delete
index|[]
name|data
block|; }
comment|//! \brief Assignment operator.
name|PBQPMatrix
operator|&
name|operator
operator|=
operator|(
specifier|const
name|PBQPMatrix
operator|&
name|m
operator|)
block|{
name|delete
index|[]
name|data
block|;
name|rows
operator|=
name|m
operator|.
name|rows
block|;
name|cols
operator|=
name|m
operator|.
name|cols
block|;
name|data
operator|=
name|new
name|PBQPNum
index|[
name|rows
operator|*
name|cols
index|]
block|;
name|std
operator|::
name|copy
argument_list|(
name|m
operator|.
name|data
argument_list|,
name|m
operator|.
name|data
operator|+
operator|(
name|rows
operator|*
name|cols
operator|)
argument_list|,
name|data
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
comment|//! \brief Return the number of rows in this matrix.
name|unsigned
name|getRows
argument_list|()
specifier|const
name|throw
argument_list|()
block|{
return|return
name|rows
return|;
block|}
comment|//! \brief Return the number of cols in this matrix.
name|unsigned
name|getCols
argument_list|()
specifier|const
name|throw
argument_list|()
block|{
return|return
name|cols
return|;
block|}
comment|//! \brief Matrix element access.
name|PBQPNum
modifier|*
name|operator
function|[]
parameter_list|(
name|unsigned
name|r
parameter_list|)
block|{
name|assert
argument_list|(
name|r
operator|<
name|rows
operator|&&
literal|"Row out of bounds."
argument_list|)
expr_stmt|;
return|return
name|data
operator|+
operator|(
name|r
operator|*
name|cols
operator|)
return|;
block|}
comment|//! \brief Matrix element access.
specifier|const
name|PBQPNum
modifier|*
name|operator
index|[]
argument_list|(
name|unsigned
name|r
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|r
operator|<
name|rows
operator|&&
literal|"Row out of bounds."
argument_list|)
expr_stmt|;
return|return
name|data
operator|+
operator|(
name|r
operator|*
name|cols
operator|)
return|;
block|}
comment|//! \brief Returns the given row as a vector.
name|PBQPVector
name|getRowAsVector
argument_list|(
name|unsigned
name|r
argument_list|)
decl|const
block|{
name|PBQPVector
name|v
parameter_list|(
name|cols
parameter_list|)
function_decl|;
for|for
control|(
name|unsigned
name|c
init|=
literal|0
init|;
name|c
operator|<
name|cols
condition|;
operator|++
name|c
control|)
name|v
index|[
name|c
index|]
operator|=
operator|(
operator|*
name|this
operator|)
index|[
name|r
index|]
index|[
name|c
index|]
expr_stmt|;
return|return
name|v
return|;
block|}
comment|//! \brief Reset the matrix to the given value.
name|PBQPMatrix
modifier|&
name|reset
parameter_list|(
name|PBQPNum
name|val
init|=
literal|0
parameter_list|)
block|{
name|std
operator|::
name|fill
argument_list|(
name|data
argument_list|,
name|data
operator|+
operator|(
name|rows
operator|*
name|cols
operator|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
comment|//! \brief Set a single row of this matrix to the given value.
name|PBQPMatrix
modifier|&
name|setRow
parameter_list|(
name|unsigned
name|r
parameter_list|,
name|PBQPNum
name|val
parameter_list|)
block|{
name|assert
argument_list|(
name|r
operator|<
name|rows
operator|&&
literal|"Row out of bounds."
argument_list|)
expr_stmt|;
name|std
operator|::
name|fill
argument_list|(
name|data
operator|+
operator|(
name|r
operator|*
name|cols
operator|)
argument_list|,
name|data
operator|+
operator|(
operator|(
name|r
operator|+
literal|1
operator|)
operator|*
name|cols
operator|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
comment|//! \brief Set a single column of this matrix to the given value.
name|PBQPMatrix
modifier|&
name|setCol
parameter_list|(
name|unsigned
name|c
parameter_list|,
name|PBQPNum
name|val
parameter_list|)
block|{
name|assert
argument_list|(
name|c
operator|<
name|cols
operator|&&
literal|"Column out of bounds."
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|r
init|=
literal|0
init|;
name|r
operator|<
name|rows
condition|;
operator|++
name|r
control|)
operator|(
operator|*
name|this
operator|)
index|[
name|r
index|]
index|[
name|c
index|]
operator|=
name|val
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
comment|//! \brief Matrix transpose.
name|PBQPMatrix
name|transpose
argument_list|()
specifier|const
block|{
name|PBQPMatrix
name|m
argument_list|(
name|cols
argument_list|,
name|rows
argument_list|)
block|;
for|for
control|(
name|unsigned
name|r
init|=
literal|0
init|;
name|r
operator|<
name|rows
condition|;
operator|++
name|r
control|)
for|for
control|(
name|unsigned
name|c
init|=
literal|0
init|;
name|c
operator|<
name|cols
condition|;
operator|++
name|c
control|)
name|m
index|[
name|c
index|]
index|[
name|r
index|]
operator|=
operator|(
operator|*
name|this
operator|)
index|[
name|r
index|]
index|[
name|c
index|]
expr_stmt|;
return|return
name|m
return|;
block|}
comment|//! \brief Returns the diagonal of the matrix as a vector.
comment|//!
comment|//! Matrix must be square.
name|PBQPVector
name|diagonalize
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|rows
operator|==
name|cols
operator|&&
literal|"Attempt to diagonalize non-square matrix."
argument_list|)
block|;
name|PBQPVector
name|v
argument_list|(
name|rows
argument_list|)
block|;
for|for
control|(
name|unsigned
name|r
init|=
literal|0
init|;
name|r
operator|<
name|rows
condition|;
operator|++
name|r
control|)
name|v
index|[
name|r
index|]
operator|=
operator|(
operator|*
name|this
operator|)
index|[
name|r
index|]
index|[
name|r
index|]
expr_stmt|;
return|return
name|v
return|;
block|}
end_decl_stmt

begin_comment
comment|//! \brief Add the given matrix to this one.
end_comment

begin_expr_stmt
name|PBQPMatrix
operator|&
name|operator
operator|+=
operator|(
specifier|const
name|PBQPMatrix
operator|&
name|m
operator|)
block|{
name|assert
argument_list|(
name|rows
operator|==
name|m
operator|.
name|rows
operator|&&
name|cols
operator|==
name|m
operator|.
name|cols
operator|&&
literal|"Matrix dimensions mismatch."
argument_list|)
block|;
name|std
operator|::
name|transform
argument_list|(
name|data
argument_list|,
name|data
operator|+
operator|(
name|rows
operator|*
name|cols
operator|)
argument_list|,
name|m
operator|.
name|data
argument_list|,
name|data
argument_list|,
name|std
operator|::
name|plus
operator|<
name|PBQPNum
operator|>
operator|(
operator|)
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_comment
comment|//! \brief Returns the minimum of the given row
end_comment

begin_decl_stmt
name|PBQPNum
name|getRowMin
argument_list|(
name|unsigned
name|r
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|r
operator|<
name|rows
operator|&&
literal|"Row out of bounds"
argument_list|)
expr_stmt|;
return|return
operator|*
name|std
operator|::
name|min_element
argument_list|(
name|data
operator|+
operator|(
name|r
operator|*
name|cols
operator|)
argument_list|,
name|data
operator|+
operator|(
operator|(
name|r
operator|+
literal|1
operator|)
operator|*
name|cols
operator|)
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|//! \brief Returns the minimum of the given column
end_comment

begin_decl_stmt
name|PBQPNum
name|getColMin
argument_list|(
name|unsigned
name|c
argument_list|)
decl|const
block|{
name|PBQPNum
name|minElem
init|=
operator|(
operator|*
name|this
operator|)
index|[
literal|0
index|]
index|[
name|c
index|]
decl_stmt|;
for|for
control|(
name|unsigned
name|r
init|=
literal|1
init|;
name|r
operator|<
name|rows
condition|;
operator|++
name|r
control|)
if|if
condition|(
operator|(
operator|*
name|this
operator|)
index|[
name|r
index|]
index|[
name|c
index|]
operator|<
name|minElem
condition|)
name|minElem
operator|=
operator|(
operator|*
name|this
operator|)
index|[
name|r
index|]
index|[
name|c
index|]
expr_stmt|;
return|return
name|minElem
return|;
block|}
end_decl_stmt

begin_comment
comment|//! \brief Subtracts the given scalar from the elements of the given row.
end_comment

begin_function
name|PBQPMatrix
modifier|&
name|subFromRow
parameter_list|(
name|unsigned
name|r
parameter_list|,
name|PBQPNum
name|val
parameter_list|)
block|{
name|assert
argument_list|(
name|r
operator|<
name|rows
operator|&&
literal|"Row out of bounds"
argument_list|)
expr_stmt|;
name|std
operator|::
name|transform
argument_list|(
name|data
operator|+
operator|(
name|r
operator|*
name|cols
operator|)
argument_list|,
name|data
operator|+
operator|(
operator|(
name|r
operator|+
literal|1
operator|)
operator|*
name|cols
operator|)
argument_list|,
name|data
operator|+
operator|(
name|r
operator|*
name|cols
operator|)
argument_list|,
name|std
operator|::
name|bind2nd
argument_list|(
name|std
operator|::
name|minus
operator|<
name|PBQPNum
operator|>
operator|(
operator|)
argument_list|,
name|val
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function

begin_comment
comment|//! \brief Subtracts the given scalar from the elements of the given column.
end_comment

begin_function
name|PBQPMatrix
modifier|&
name|subFromCol
parameter_list|(
name|unsigned
name|c
parameter_list|,
name|PBQPNum
name|val
parameter_list|)
block|{
for|for
control|(
name|unsigned
name|r
init|=
literal|0
init|;
name|r
operator|<
name|rows
condition|;
operator|++
name|r
control|)
operator|(
operator|*
name|this
operator|)
index|[
name|r
index|]
index|[
name|c
index|]
operator|-=
name|val
expr_stmt|;
return|return
operator|*
name|this
return|;
block|}
end_function

begin_comment
comment|//! \brief Returns true if this is a zero matrix.
end_comment

begin_expr_stmt
name|bool
name|isZero
argument_list|()
specifier|const
block|{
return|return
name|find_if
argument_list|(
name|data
argument_list|,
name|data
operator|+
operator|(
name|rows
operator|*
name|cols
operator|)
argument_list|,
name|std
operator|::
name|bind2nd
argument_list|(
name|std
operator|::
name|not_equal_to
operator|<
name|PBQPNum
operator|>
operator|(
operator|)
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|data
operator|+
operator|(
name|rows
operator|*
name|cols
operator|)
return|;
block|}
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|unsigned
name|rows
decl_stmt|,
name|cols
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PBQPNum
modifier|*
name|data
decl_stmt|;
end_decl_stmt

begin_define
unit|};
define|#
directive|define
name|EPS
value|(1E-8)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|PBQP_TYPE
end_ifndef

begin_define
define|#
directive|define
name|PBQP_TYPE
end_define

begin_struct_decl
struct_decl|struct
name|pbqp
struct_decl|;
end_struct_decl

begin_typedef
typedef|typedef
name|struct
name|pbqp
name|pbqp
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*****************  * PBQP routines *  *****************/
end_comment

begin_comment
comment|/* allocate pbqp problem */
end_comment

begin_function_decl
name|pbqp
modifier|*
name|alloc_pbqp
parameter_list|(
name|int
name|num
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* add node costs */
end_comment

begin_function_decl
name|void
name|add_pbqp_nodecosts
parameter_list|(
name|pbqp
modifier|*
name|this_
parameter_list|,
name|int
name|u
parameter_list|,
name|PBQPVector
modifier|*
name|costs
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* add edge mat */
end_comment

begin_function_decl
name|void
name|add_pbqp_edgecosts
parameter_list|(
name|pbqp
modifier|*
name|this_
parameter_list|,
name|int
name|u
parameter_list|,
name|int
name|v
parameter_list|,
name|PBQPMatrix
modifier|*
name|costs
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* solve PBQP problem */
end_comment

begin_function_decl
name|void
name|solve_pbqp
parameter_list|(
name|pbqp
modifier|*
name|this_
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* get solution of a node */
end_comment

begin_function_decl
name|int
name|get_pbqp_solution
parameter_list|(
name|pbqp
modifier|*
name|this_
parameter_list|,
name|int
name|u
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* alloc PBQP */
end_comment

begin_function_decl
name|pbqp
modifier|*
name|alloc_pbqp
parameter_list|(
name|int
name|num
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* free PBQP */
end_comment

begin_function_decl
name|void
name|free_pbqp
parameter_list|(
name|pbqp
modifier|*
name|this_
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* is optimal */
end_comment

begin_function_decl
name|bool
name|is_pbqp_optimal
parameter_list|(
name|pbqp
modifier|*
name|this_
parameter_list|)
function_decl|;
end_function_decl

begin_endif
unit|}
endif|#
directive|endif
end_endif

end_unit

