begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- xray_fdr_logging_impl.h ---------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is a part of XRay, a dynamic runtime instrumentation system.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Here we implement the thread local state management and record i/o for Flight
end_comment

begin_comment
comment|// Data Recorder mode for XRay, where we use compact structures to store records
end_comment

begin_comment
comment|// in memory as well as when writing out the data to files.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|XRAY_XRAY_FDR_LOGGING_IMPL_H
end_ifndef

begin_define
define|#
directive|define
name|XRAY_XRAY_FDR_LOGGING_IMPL_H
end_define

begin_include
include|#
directive|include
file|<cassert>
end_include

begin_include
include|#
directive|include
file|<cstdint>
end_include

begin_include
include|#
directive|include
file|<cstring>
end_include

begin_include
include|#
directive|include
file|<limits>
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_include
include|#
directive|include
file|<string>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"sanitizer_common/sanitizer_common.h"
end_include

begin_include
include|#
directive|include
file|"xray/xray_log_interface.h"
end_include

begin_include
include|#
directive|include
file|"xray_buffer_queue.h"
end_include

begin_include
include|#
directive|include
file|"xray_defs.h"
end_include

begin_include
include|#
directive|include
file|"xray_fdr_log_records.h"
end_include

begin_include
include|#
directive|include
file|"xray_flags.h"
end_include

begin_include
include|#
directive|include
file|"xray_tsc.h"
end_include

begin_decl_stmt
name|namespace
name|__xray
block|{
comment|/// We expose some of the state transitions when FDR logging mode is operating
comment|/// such that we can simulate a series of log events that may occur without
comment|/// and test with determinism without worrying about the real CPU time.
comment|///
comment|/// Because the code uses thread_local allocation extensively as part of its
comment|/// design, callers that wish to test events occuring on different threads
comment|/// will actually have to run them on different threads.
comment|///
comment|/// This also means that it is possible to break invariants maintained by
comment|/// cooperation with xray_fdr_logging class, so be careful and think twice.
name|namespace
name|__xray_fdr_internal
block|{
comment|/// Writes the new buffer record and wallclock time that begin a buffer for a
comment|/// thread to MemPtr and increments MemPtr. Bypasses the thread local state
comment|/// machine and writes directly to memory without checks.
specifier|static
name|void
name|writeNewBufferPreamble
parameter_list|(
name|pid_t
name|Tid
parameter_list|,
name|timespec
name|TS
parameter_list|,
name|char
modifier|*
modifier|&
name|MemPtr
parameter_list|)
function_decl|;
comment|/// Write a metadata record to switch to a new CPU to MemPtr and increments
comment|/// MemPtr. Bypasses the thread local state machine and writes directly to
comment|/// memory without checks.
specifier|static
name|void
name|writeNewCPUIdMetadata
parameter_list|(
name|uint16_t
name|CPU
parameter_list|,
name|uint64_t
name|TSC
parameter_list|,
name|char
modifier|*
modifier|&
name|MemPtr
parameter_list|)
function_decl|;
comment|/// Writes an EOB metadata record to MemPtr and increments MemPtr. Bypasses the
comment|/// thread local state machine and writes directly to memory without checks.
specifier|static
name|void
name|writeEOBMetadata
parameter_list|(
name|char
modifier|*
modifier|&
name|MemPtr
parameter_list|)
function_decl|;
comment|/// Writes a TSC Wrap metadata record to MemPtr and increments MemPtr. Bypasses
comment|/// the thread local state machine and directly writes to memory without checks.
specifier|static
name|void
name|writeTSCWrapMetadata
parameter_list|(
name|uint64_t
name|TSC
parameter_list|,
name|char
modifier|*
modifier|&
name|MemPtr
parameter_list|)
function_decl|;
comment|/// Writes a Function Record to MemPtr and increments MemPtr. Bypasses the
comment|/// thread local state machine and writes the function record directly to
comment|/// memory.
specifier|static
name|void
name|writeFunctionRecord
parameter_list|(
name|int
name|FuncId
parameter_list|,
name|uint32_t
name|TSCDelta
parameter_list|,
name|XRayEntryType
name|EntryType
parameter_list|,
name|char
modifier|*
modifier|&
name|MemPtr
parameter_list|)
function_decl|;
comment|/// Sets up a new buffer in thread_local storage and writes a preamble. The
comment|/// wall_clock_reader function is used to populate the WallTimeRecord entry.
specifier|static
name|void
name|setupNewBuffer
parameter_list|(
name|int
function_decl|(
modifier|*
name|wall_clock_reader
function_decl|)
parameter_list|(
name|clockid_t
parameter_list|,
name|struct
name|timespec
modifier|*
parameter_list|)
parameter_list|)
function_decl|;
comment|/// Called to record CPU time for a new CPU within the current thread.
specifier|static
name|void
name|writeNewCPUIdMetadata
parameter_list|(
name|uint16_t
name|CPU
parameter_list|,
name|uint64_t
name|TSC
parameter_list|)
function_decl|;
comment|/// Called to close the buffer when the thread exhausts the buffer or when the
comment|/// thread exits (via a thread local variable destructor).
specifier|static
name|void
name|writeEOBMetadata
parameter_list|()
function_decl|;
comment|/// TSC Wrap records are written when a TSC delta encoding scheme overflows.
specifier|static
name|void
name|writeTSCWrapMetadata
parameter_list|(
name|uint64_t
name|TSC
parameter_list|)
function_decl|;
comment|/// Here's where the meat of the processing happens. The writer captures
comment|/// function entry, exit and tail exit points with a time and will create
comment|/// TSCWrap, NewCPUId and Function records as necessary. The writer might
comment|/// walk backward through its buffer and erase trivial functions to avoid
comment|/// polluting the log and may use the buffer queue to obtain or release a
comment|/// buffer.
specifier|static
name|void
name|processFunctionHook
argument_list|(
name|int32_t
name|FuncId
argument_list|,
name|XRayEntryType
name|Entry
argument_list|,
name|uint64_t
name|TSC
argument_list|,
name|unsigned
name|char
name|CPU
argument_list|,
name|int
argument_list|(
operator|*
name|wall_clock_reader
argument_list|)
argument_list|(
name|clockid_t
argument_list|,
expr|struct
name|timespec
operator|*
argument_list|)
argument_list|,
name|__sanitizer
operator|::
name|atomic_sint32_t
operator|&
name|LoggingStatus
argument_list|,
specifier|const
name|std
operator|::
name|shared_ptr
operator|<
name|BufferQueue
operator|>
operator|&
name|BQ
argument_list|)
decl_stmt|;
comment|//-----------------------------------------------------------------------------|
comment|// The rest of the file is implementation.                                     |
comment|//-----------------------------------------------------------------------------|
comment|// Functions are implemented in the header for inlining since we don't want    |
comment|// to grow the stack when we've hijacked the binary for logging.               |
comment|//-----------------------------------------------------------------------------|
name|namespace
block|{
name|thread_local
name|BufferQueue
operator|::
name|Buffer
name|Buffer
expr_stmt|;
name|thread_local
name|char
modifier|*
name|RecordPtr
init|=
name|nullptr
decl_stmt|;
comment|// The number of FunctionEntry records immediately preceding RecordPtr.
name|thread_local
name|uint8_t
name|NumConsecutiveFnEnters
init|=
literal|0
decl_stmt|;
comment|// The number of adjacent, consecutive pairs of FunctionEntry, Tail Exit
comment|// records preceding RecordPtr.
name|thread_local
name|uint8_t
name|NumTailCalls
init|=
literal|0
decl_stmt|;
name|constexpr
specifier|auto
name|MetadataRecSize
init|=
sizeof|sizeof
argument_list|(
name|MetadataRecord
argument_list|)
decl_stmt|;
name|constexpr
specifier|auto
name|FunctionRecSize
init|=
sizeof|sizeof
argument_list|(
name|FunctionRecord
argument_list|)
decl_stmt|;
name|class
name|ThreadExitBufferCleanup
block|{
name|std
operator|::
name|weak_ptr
operator|<
name|BufferQueue
operator|>
name|Buffers
expr_stmt|;
name|BufferQueue
operator|::
name|Buffer
operator|&
name|Buffer
expr_stmt|;
name|public
label|:
name|explicit
name|ThreadExitBufferCleanup
argument_list|(
name|std
operator|::
name|weak_ptr
operator|<
name|BufferQueue
operator|>
name|BQ
argument_list|,
name|BufferQueue
operator|::
name|Buffer
operator|&
name|Buffer
argument_list|)
name|XRAY_NEVER_INSTRUMENT
range|:
name|Buffers
argument_list|(
name|BQ
argument_list|)
decl_stmt|,
name|Buffer
argument_list|(
name|Buffer
argument_list|)
block|{}
operator|~
name|ThreadExitBufferCleanup
argument_list|()
name|noexcept
name|XRAY_NEVER_INSTRUMENT
block|{
if|if
condition|(
name|RecordPtr
operator|==
name|nullptr
condition|)
return|return;
comment|// We make sure that upon exit, a thread will write out the EOB
comment|// MetadataRecord in the thread-local log, and also release the buffer to
comment|// the queue.
name|assert
argument_list|(
operator|(
name|RecordPtr
operator|+
name|MetadataRecSize
operator|)
operator|-
name|static_cast
operator|<
name|char
operator|*
operator|>
operator|(
name|Buffer
operator|.
name|Buffer
operator|)
operator|>=
name|static_cast
operator|<
name|ptrdiff_t
operator|>
operator|(
name|MetadataRecSize
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|auto
name|BQ
init|=
name|Buffers
operator|.
name|lock
argument_list|()
condition|)
block|{
name|writeEOBMetadata
argument_list|()
expr_stmt|;
name|auto
name|EC
init|=
name|BQ
operator|->
name|releaseBuffer
argument_list|(
name|Buffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|EC
operator|!=
name|BufferQueue
operator|::
name|ErrorCode
operator|::
name|Ok
condition|)
name|Report
argument_list|(
literal|"Failed to release buffer at %p; error=%s\n"
argument_list|,
name|Buffer
operator|.
name|Buffer
argument_list|,
name|BufferQueue
operator|::
name|getErrorString
argument_list|(
name|EC
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
empty_stmt|;
name|class
name|RecursionGuard
block|{
name|bool
modifier|&
name|Running
decl_stmt|;
specifier|const
name|bool
name|Valid
decl_stmt|;
name|public
label|:
name|explicit
name|RecursionGuard
argument_list|(
name|bool
operator|&
name|R
argument_list|)
operator|:
name|Running
argument_list|(
name|R
argument_list|)
operator|,
name|Valid
argument_list|(
argument|!R
argument_list|)
block|{
if|if
condition|(
name|Valid
condition|)
name|Running
operator|=
name|true
expr_stmt|;
block|}
name|RecursionGuard
argument_list|(
specifier|const
name|RecursionGuard
operator|&
argument_list|)
operator|=
name|delete
expr_stmt|;
name|RecursionGuard
argument_list|(
name|RecursionGuard
operator|&&
argument_list|)
operator|=
name|delete
expr_stmt|;
name|RecursionGuard
modifier|&
name|operator
init|=
operator|(
specifier|const
name|RecursionGuard
operator|&
operator|)
operator|=
name|delete
decl_stmt|;
name|RecursionGuard
modifier|&
name|operator
init|=
operator|(
name|RecursionGuard
operator|&&
operator|)
operator|=
name|delete
decl_stmt|;
name|explicit
name|operator
name|bool
argument_list|()
specifier|const
block|{
return|return
name|Valid
return|;
block|}
operator|~
name|RecursionGuard
argument_list|()
name|noexcept
block|{
if|if
condition|(
name|Valid
condition|)
name|Running
operator|=
name|false
expr_stmt|;
block|}
block|}
empty_stmt|;
specifier|static
specifier|inline
name|bool
name|loggingInitialized
argument_list|(
specifier|const
name|__sanitizer
operator|::
name|atomic_sint32_t
operator|&
name|LoggingStatus
argument_list|)
name|XRAY_NEVER_INSTRUMENT
block|{
return|return
name|__sanitizer
operator|::
name|atomic_load
argument_list|(
operator|&
name|LoggingStatus
argument_list|,
name|__sanitizer
operator|::
name|memory_order_acquire
argument_list|)
operator|==
name|XRayLogInitStatus
operator|::
name|XRAY_LOG_INITIALIZED
return|;
block|}
block|}
comment|// namespace
specifier|static
specifier|inline
name|void
name|writeNewBufferPreamble
parameter_list|(
name|pid_t
name|Tid
parameter_list|,
name|timespec
name|TS
parameter_list|,
name|char
modifier|*
modifier|&
name|MemPtr
parameter_list|)
function|XRAY_NEVER_INSTRUMENT
block|{
specifier|static
name|constexpr
name|int
name|InitRecordsCount
init|=
literal|2
decl_stmt|;
name|std
operator|::
name|aligned_storage
operator|<
sizeof|sizeof
argument_list|(
name|MetadataRecord
argument_list|)
operator|>
operator|::
name|type
name|Records
index|[
name|InitRecordsCount
index|]
expr_stmt|;
block|{
comment|// Write out a MetadataRecord to signify that this is the start of a new
comment|// buffer, associated with a particular thread, with a new CPU.  For the
comment|// data, we have 15 bytes to squeeze as much information as we can.  At this
comment|// point we only write down the following bytes:
comment|//   - Thread ID (pid_t, 4 bytes)
name|auto
operator|&
name|NewBuffer
operator|=
operator|*
name|reinterpret_cast
operator|<
name|MetadataRecord
operator|*
operator|>
operator|(
operator|&
name|Records
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|NewBuffer
operator|.
name|Type
operator|=
name|uint8_t
argument_list|(
name|RecordType
operator|::
name|Metadata
argument_list|)
expr_stmt|;
name|NewBuffer
operator|.
name|RecordKind
operator|=
name|uint8_t
argument_list|(
name|MetadataRecord
operator|::
name|RecordKinds
operator|::
name|NewBuffer
argument_list|)
expr_stmt|;
name|std
operator|::
name|memcpy
argument_list|(
operator|&
name|NewBuffer
operator|.
name|Data
argument_list|,
operator|&
name|Tid
argument_list|,
sizeof|sizeof
argument_list|(
name|pid_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// Also write the WalltimeMarker record.
block|{
name|static_assert
argument_list|(
sizeof|sizeof
argument_list|(
name|time_t
argument_list|)
operator|<=
literal|8
argument_list|,
literal|"time_t needs to be at most 8 bytes"
argument_list|)
expr_stmt|;
name|auto
operator|&
name|WalltimeMarker
operator|=
operator|*
name|reinterpret_cast
operator|<
name|MetadataRecord
operator|*
operator|>
operator|(
operator|&
name|Records
index|[
literal|1
index|]
operator|)
expr_stmt|;
name|WalltimeMarker
operator|.
name|Type
operator|=
name|uint8_t
argument_list|(
name|RecordType
operator|::
name|Metadata
argument_list|)
expr_stmt|;
name|WalltimeMarker
operator|.
name|RecordKind
operator|=
name|uint8_t
argument_list|(
name|MetadataRecord
operator|::
name|RecordKinds
operator|::
name|WalltimeMarker
argument_list|)
expr_stmt|;
comment|// We only really need microsecond precision here, and enforce across
comment|// platforms that we need 64-bit seconds and 32-bit microseconds encoded in
comment|// the Metadata record.
name|int32_t
name|Micros
init|=
name|TS
operator|.
name|tv_nsec
operator|/
literal|1000
decl_stmt|;
name|int64_t
name|Seconds
init|=
name|TS
operator|.
name|tv_sec
decl_stmt|;
name|std
operator|::
name|memcpy
argument_list|(
name|WalltimeMarker
operator|.
name|Data
argument_list|,
operator|&
name|Seconds
argument_list|,
sizeof|sizeof
argument_list|(
name|Seconds
argument_list|)
argument_list|)
expr_stmt|;
name|std
operator|::
name|memcpy
argument_list|(
name|WalltimeMarker
operator|.
name|Data
operator|+
sizeof|sizeof
argument_list|(
name|Seconds
argument_list|)
argument_list|,
operator|&
name|Micros
argument_list|,
sizeof|sizeof
argument_list|(
name|Micros
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|std
operator|::
name|memcpy
argument_list|(
name|MemPtr
argument_list|,
name|Records
argument_list|,
sizeof|sizeof
argument_list|(
name|MetadataRecord
argument_list|)
operator|*
name|InitRecordsCount
argument_list|)
expr_stmt|;
name|MemPtr
operator|+=
sizeof|sizeof
argument_list|(
name|MetadataRecord
argument_list|)
operator|*
name|InitRecordsCount
expr_stmt|;
name|NumConsecutiveFnEnters
operator|=
literal|0
expr_stmt|;
name|NumTailCalls
operator|=
literal|0
expr_stmt|;
block|}
specifier|static
specifier|inline
name|void
name|setupNewBuffer
parameter_list|(
name|int
function_decl|(
modifier|*
name|wall_clock_reader
function_decl|)
parameter_list|(
name|clockid_t
parameter_list|,
name|struct
name|timespec
modifier|*
parameter_list|)
parameter_list|)
function|XRAY_NEVER_INSTRUMENT
block|{
name|RecordPtr
operator|=
name|static_cast
operator|<
name|char
operator|*
operator|>
operator|(
name|Buffer
operator|.
name|Buffer
operator|)
expr_stmt|;
name|pid_t
name|Tid
init|=
name|syscall
argument_list|(
name|SYS_gettid
argument_list|)
decl_stmt|;
name|timespec
name|TS
block|{
literal|0
operator|,
literal|0
block|}
empty_stmt|;
comment|// This is typically clock_gettime, but callers have injection ability.
name|wall_clock_reader
argument_list|(
name|CLOCK_MONOTONIC
argument_list|,
operator|&
name|TS
argument_list|)
expr_stmt|;
name|writeNewBufferPreamble
argument_list|(
name|Tid
argument_list|,
name|TS
argument_list|,
name|RecordPtr
argument_list|)
expr_stmt|;
name|NumConsecutiveFnEnters
operator|=
literal|0
expr_stmt|;
name|NumTailCalls
operator|=
literal|0
expr_stmt|;
block|}
specifier|static
specifier|inline
name|void
name|writeNewCPUIdMetadata
parameter_list|(
name|uint16_t
name|CPU
parameter_list|,
name|uint64_t
name|TSC
parameter_list|,
name|char
modifier|*
modifier|&
name|MemPtr
parameter_list|)
function|XRAY_NEVER_INSTRUMENT
block|{
name|MetadataRecord
name|NewCPUId
decl_stmt|;
name|NewCPUId
operator|.
name|Type
operator|=
name|uint8_t
argument_list|(
name|RecordType
operator|::
name|Metadata
argument_list|)
expr_stmt|;
name|NewCPUId
operator|.
name|RecordKind
operator|=
name|uint8_t
argument_list|(
name|MetadataRecord
operator|::
name|RecordKinds
operator|::
name|NewCPUId
argument_list|)
expr_stmt|;
comment|// The data for the New CPU will contain the following bytes:
comment|//   - CPU ID (uint16_t, 2 bytes)
comment|//   - Full TSC (uint64_t, 8 bytes)
comment|// Total = 10 bytes.
name|std
operator|::
name|memcpy
argument_list|(
operator|&
name|NewCPUId
operator|.
name|Data
argument_list|,
operator|&
name|CPU
argument_list|,
sizeof|sizeof
argument_list|(
name|CPU
argument_list|)
argument_list|)
expr_stmt|;
name|std
operator|::
name|memcpy
argument_list|(
operator|&
name|NewCPUId
operator|.
name|Data
index|[
sizeof|sizeof
argument_list|(
name|CPU
argument_list|)
index|]
argument_list|,
operator|&
name|TSC
argument_list|,
sizeof|sizeof
argument_list|(
name|TSC
argument_list|)
argument_list|)
expr_stmt|;
name|std
operator|::
name|memcpy
argument_list|(
name|MemPtr
argument_list|,
operator|&
name|NewCPUId
argument_list|,
sizeof|sizeof
argument_list|(
name|MetadataRecord
argument_list|)
argument_list|)
expr_stmt|;
name|MemPtr
operator|+=
sizeof|sizeof
argument_list|(
name|MetadataRecord
argument_list|)
expr_stmt|;
name|NumConsecutiveFnEnters
operator|=
literal|0
expr_stmt|;
name|NumTailCalls
operator|=
literal|0
expr_stmt|;
block|}
specifier|static
specifier|inline
name|void
name|writeNewCPUIdMetadata
parameter_list|(
name|uint16_t
name|CPU
parameter_list|,
name|uint64_t
name|TSC
parameter_list|)
function|XRAY_NEVER_INSTRUMENT
block|{
name|writeNewCPUIdMetadata
argument_list|(
name|CPU
argument_list|,
name|TSC
argument_list|,
name|RecordPtr
argument_list|)
expr_stmt|;
block|}
specifier|static
specifier|inline
name|void
name|writeEOBMetadata
parameter_list|(
name|char
modifier|*
modifier|&
name|MemPtr
parameter_list|)
function|XRAY_NEVER_INSTRUMENT
block|{
name|MetadataRecord
name|EOBMeta
decl_stmt|;
name|EOBMeta
operator|.
name|Type
operator|=
name|uint8_t
argument_list|(
name|RecordType
operator|::
name|Metadata
argument_list|)
expr_stmt|;
name|EOBMeta
operator|.
name|RecordKind
operator|=
name|uint8_t
argument_list|(
name|MetadataRecord
operator|::
name|RecordKinds
operator|::
name|EndOfBuffer
argument_list|)
expr_stmt|;
comment|// For now we don't write any bytes into the Data field.
name|std
operator|::
name|memcpy
argument_list|(
name|MemPtr
argument_list|,
operator|&
name|EOBMeta
argument_list|,
sizeof|sizeof
argument_list|(
name|MetadataRecord
argument_list|)
argument_list|)
expr_stmt|;
name|MemPtr
operator|+=
sizeof|sizeof
argument_list|(
name|MetadataRecord
argument_list|)
expr_stmt|;
name|NumConsecutiveFnEnters
operator|=
literal|0
expr_stmt|;
name|NumTailCalls
operator|=
literal|0
expr_stmt|;
block|}
specifier|static
specifier|inline
name|void
name|writeEOBMetadata
parameter_list|()
function|XRAY_NEVER_INSTRUMENT
block|{
name|writeEOBMetadata
argument_list|(
name|RecordPtr
argument_list|)
expr_stmt|;
block|}
specifier|static
specifier|inline
name|void
name|writeTSCWrapMetadata
parameter_list|(
name|uint64_t
name|TSC
parameter_list|,
name|char
modifier|*
modifier|&
name|MemPtr
parameter_list|)
function|XRAY_NEVER_INSTRUMENT
block|{
name|MetadataRecord
name|TSCWrap
decl_stmt|;
name|TSCWrap
operator|.
name|Type
operator|=
name|uint8_t
argument_list|(
name|RecordType
operator|::
name|Metadata
argument_list|)
expr_stmt|;
name|TSCWrap
operator|.
name|RecordKind
operator|=
name|uint8_t
argument_list|(
name|MetadataRecord
operator|::
name|RecordKinds
operator|::
name|TSCWrap
argument_list|)
expr_stmt|;
comment|// The data for the TSCWrap record contains the following bytes:
comment|//   - Full TSC (uint64_t, 8 bytes)
comment|// Total = 8 bytes.
name|std
operator|::
name|memcpy
argument_list|(
operator|&
name|TSCWrap
operator|.
name|Data
argument_list|,
operator|&
name|TSC
argument_list|,
sizeof|sizeof
argument_list|(
name|TSC
argument_list|)
argument_list|)
expr_stmt|;
name|std
operator|::
name|memcpy
argument_list|(
name|MemPtr
argument_list|,
operator|&
name|TSCWrap
argument_list|,
sizeof|sizeof
argument_list|(
name|MetadataRecord
argument_list|)
argument_list|)
expr_stmt|;
name|MemPtr
operator|+=
sizeof|sizeof
argument_list|(
name|MetadataRecord
argument_list|)
expr_stmt|;
name|NumConsecutiveFnEnters
operator|=
literal|0
expr_stmt|;
name|NumTailCalls
operator|=
literal|0
expr_stmt|;
block|}
specifier|static
specifier|inline
name|void
name|writeTSCWrapMetadata
parameter_list|(
name|uint64_t
name|TSC
parameter_list|)
function|XRAY_NEVER_INSTRUMENT
block|{
name|writeTSCWrapMetadata
argument_list|(
name|TSC
argument_list|,
name|RecordPtr
argument_list|)
expr_stmt|;
block|}
specifier|static
specifier|inline
name|void
name|writeFunctionRecord
parameter_list|(
name|int
name|FuncId
parameter_list|,
name|uint32_t
name|TSCDelta
parameter_list|,
name|XRayEntryType
name|EntryType
parameter_list|,
name|char
modifier|*
modifier|&
name|MemPtr
parameter_list|)
function|XRAY_NEVER_INSTRUMENT
block|{
name|std
operator|::
name|aligned_storage
operator|<
sizeof|sizeof
argument_list|(
name|FunctionRecord
argument_list|)
operator|,
name|alignof
argument_list|(
name|FunctionRecord
argument_list|)
operator|>
operator|::
name|type
name|AlignedFuncRecordBuffer
expr_stmt|;
name|auto
operator|&
name|FuncRecord
operator|=
operator|*
name|reinterpret_cast
operator|<
name|FunctionRecord
operator|*
operator|>
operator|(
operator|&
name|AlignedFuncRecordBuffer
operator|)
expr_stmt|;
name|FuncRecord
operator|.
name|Type
operator|=
name|uint8_t
argument_list|(
name|RecordType
operator|::
name|Function
argument_list|)
expr_stmt|;
comment|// Only take 28 bits of the function id.
name|FuncRecord
operator|.
name|FuncId
operator|=
name|FuncId
operator|&
operator|~
operator|(
literal|0x0F
operator|<<
literal|28
operator|)
expr_stmt|;
name|FuncRecord
operator|.
name|TSCDelta
operator|=
name|TSCDelta
expr_stmt|;
switch|switch
condition|(
name|EntryType
condition|)
block|{
case|case
name|XRayEntryType
operator|::
name|ENTRY
case|:
operator|++
name|NumConsecutiveFnEnters
expr_stmt|;
name|FuncRecord
operator|.
name|RecordKind
operator|=
name|uint8_t
argument_list|(
name|FunctionRecord
operator|::
name|RecordKinds
operator|::
name|FunctionEnter
argument_list|)
expr_stmt|;
break|break;
case|case
name|XRayEntryType
operator|::
name|LOG_ARGS_ENTRY
case|:
comment|// We should not rewind functions with logged args.
name|NumConsecutiveFnEnters
operator|=
literal|0
expr_stmt|;
name|NumTailCalls
operator|=
literal|0
expr_stmt|;
name|FuncRecord
operator|.
name|RecordKind
operator|=
name|uint8_t
argument_list|(
name|FunctionRecord
operator|::
name|RecordKinds
operator|::
name|FunctionEnter
argument_list|)
expr_stmt|;
break|break;
case|case
name|XRayEntryType
operator|::
name|EXIT
case|:
comment|// If we've decided to log the function exit, we will never erase the log
comment|// before it.
name|NumConsecutiveFnEnters
operator|=
literal|0
expr_stmt|;
name|NumTailCalls
operator|=
literal|0
expr_stmt|;
name|FuncRecord
operator|.
name|RecordKind
operator|=
name|uint8_t
argument_list|(
name|FunctionRecord
operator|::
name|RecordKinds
operator|::
name|FunctionExit
argument_list|)
expr_stmt|;
break|break;
case|case
name|XRayEntryType
operator|::
name|TAIL
case|:
comment|// If we just entered the function we're tail exiting from or erased every
comment|// invocation since then, this function entry tail pair is a candidate to
comment|// be erased when the child function exits.
if|if
condition|(
name|NumConsecutiveFnEnters
operator|>
literal|0
condition|)
block|{
operator|++
name|NumTailCalls
expr_stmt|;
name|NumConsecutiveFnEnters
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|// We will never be able to erase this tail call since we have logged
comment|// something in between the function entry and tail exit.
name|NumTailCalls
operator|=
literal|0
expr_stmt|;
name|NumConsecutiveFnEnters
operator|=
literal|0
expr_stmt|;
block|}
name|FuncRecord
operator|.
name|RecordKind
operator|=
name|uint8_t
argument_list|(
name|FunctionRecord
operator|::
name|RecordKinds
operator|::
name|FunctionTailExit
argument_list|)
expr_stmt|;
break|break;
block|}
name|std
operator|::
name|memcpy
argument_list|(
name|MemPtr
argument_list|,
operator|&
name|AlignedFuncRecordBuffer
argument_list|,
sizeof|sizeof
argument_list|(
name|FunctionRecord
argument_list|)
argument_list|)
expr_stmt|;
name|MemPtr
operator|+=
sizeof|sizeof
argument_list|(
name|FunctionRecord
argument_list|)
expr_stmt|;
block|}
specifier|static
name|uint64_t
name|thresholdTicks
parameter_list|()
block|{
specifier|static
name|uint64_t
name|TicksPerSec
init|=
name|probeRequiredCPUFeatures
argument_list|()
condition|?
name|getTSCFrequency
argument_list|()
else|:
name|__xray
operator|::
name|NanosecondsPerSecond
decl_stmt|;
specifier|static
specifier|const
name|uint64_t
name|ThresholdTicks
init|=
name|TicksPerSec
operator|*
name|flags
argument_list|()
operator|->
name|xray_fdr_log_func_duration_threshold_us
operator|/
literal|1000000
decl_stmt|;
return|return
name|ThresholdTicks
return|;
block|}
comment|// Re-point the thread local pointer into this thread's Buffer before the recent
comment|// "Function Entry" record and any "Tail Call Exit" records after that.
specifier|static
name|void
name|rewindRecentCall
parameter_list|(
name|uint64_t
name|TSC
parameter_list|,
name|uint64_t
modifier|&
name|LastTSC
parameter_list|,
name|uint64_t
modifier|&
name|LastFunctionEntryTSC
parameter_list|,
name|int32_t
name|FuncId
parameter_list|)
block|{
name|using
name|AlignedFuncStorage
init|=
name|std
operator|::
name|aligned_storage
operator|<
sizeof|sizeof
argument_list|(
name|FunctionRecord
argument_list|)
decl_stmt|,
name|alignof
argument_list|(
name|FunctionRecord
argument_list|)
decl|>::
name|type
decl_stmt|;
name|RecordPtr
operator|-=
name|FunctionRecSize
expr_stmt|;
name|AlignedFuncStorage
name|AlignedFuncRecordBuffer
decl_stmt|;
specifier|const
specifier|auto
modifier|&
name|FuncRecord
init|=
operator|*
name|reinterpret_cast
operator|<
name|FunctionRecord
operator|*
operator|>
operator|(
name|std
operator|::
name|memcpy
argument_list|(
operator|&
name|AlignedFuncRecordBuffer
argument_list|,
name|RecordPtr
argument_list|,
name|FunctionRecSize
argument_list|)
operator|)
decl_stmt|;
name|assert
argument_list|(
name|FuncRecord
operator|.
name|RecordKind
operator|==
name|uint8_t
argument_list|(
name|FunctionRecord
operator|::
name|RecordKinds
operator|::
name|FunctionEnter
argument_list|)
operator|&&
literal|"Expected to find function entry recording when rewinding."
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|FuncRecord
operator|.
name|FuncId
operator|==
operator|(
name|FuncId
operator|&
operator|~
operator|(
literal|0x0F
operator|<<
literal|28
operator|)
operator|)
operator|&&
literal|"Expected matching function id when rewinding Exit"
argument_list|)
expr_stmt|;
operator|--
name|NumConsecutiveFnEnters
expr_stmt|;
name|LastTSC
operator|-=
name|FuncRecord
operator|.
name|TSCDelta
expr_stmt|;
comment|// We unwound one call. Update the state and return without writing a log.
if|if
condition|(
name|NumConsecutiveFnEnters
operator|!=
literal|0
condition|)
block|{
name|LastFunctionEntryTSC
operator|-=
name|FuncRecord
operator|.
name|TSCDelta
expr_stmt|;
return|return;
block|}
comment|// Otherwise we've rewound the stack of all function entries, we might be
comment|// able to rewind further by erasing tail call functions that are being
comment|// exited from via this exit.
name|LastFunctionEntryTSC
operator|=
literal|0
expr_stmt|;
name|auto
name|RewindingTSC
init|=
name|LastTSC
decl_stmt|;
name|auto
name|RewindingRecordPtr
init|=
name|RecordPtr
operator|-
name|FunctionRecSize
decl_stmt|;
while|while
condition|(
name|NumTailCalls
operator|>
literal|0
condition|)
block|{
name|AlignedFuncStorage
name|TailExitRecordBuffer
decl_stmt|;
comment|// Rewind the TSC back over the TAIL EXIT record.
specifier|const
specifier|auto
modifier|&
name|ExpectedTailExit
init|=
operator|*
name|reinterpret_cast
operator|<
name|FunctionRecord
operator|*
operator|>
operator|(
name|std
operator|::
name|memcpy
argument_list|(
operator|&
name|TailExitRecordBuffer
argument_list|,
name|RewindingRecordPtr
argument_list|,
name|FunctionRecSize
argument_list|)
operator|)
decl_stmt|;
name|assert
argument_list|(
name|ExpectedTailExit
operator|.
name|RecordKind
operator|==
name|uint8_t
argument_list|(
name|FunctionRecord
operator|::
name|RecordKinds
operator|::
name|FunctionTailExit
argument_list|)
operator|&&
literal|"Expected to find tail exit when rewinding."
argument_list|)
expr_stmt|;
name|RewindingRecordPtr
operator|-=
name|FunctionRecSize
expr_stmt|;
name|RewindingTSC
operator|-=
name|ExpectedTailExit
operator|.
name|TSCDelta
expr_stmt|;
name|AlignedFuncStorage
name|FunctionEntryBuffer
decl_stmt|;
specifier|const
specifier|auto
modifier|&
name|ExpectedFunctionEntry
init|=
operator|*
name|reinterpret_cast
operator|<
name|FunctionRecord
operator|*
operator|>
operator|(
name|std
operator|::
name|memcpy
argument_list|(
operator|&
name|FunctionEntryBuffer
argument_list|,
name|RewindingRecordPtr
argument_list|,
name|FunctionRecSize
argument_list|)
operator|)
decl_stmt|;
name|assert
argument_list|(
name|ExpectedFunctionEntry
operator|.
name|RecordKind
operator|==
name|uint8_t
argument_list|(
name|FunctionRecord
operator|::
name|RecordKinds
operator|::
name|FunctionEnter
argument_list|)
operator|&&
literal|"Expected to find function entry when rewinding tail call."
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ExpectedFunctionEntry
operator|.
name|FuncId
operator|==
name|ExpectedTailExit
operator|.
name|FuncId
operator|&&
literal|"Expected funcids to match when rewinding tail call."
argument_list|)
expr_stmt|;
comment|// This tail call exceeded the threshold duration. It will not be erased.
if|if
condition|(
operator|(
name|TSC
operator|-
name|RewindingTSC
operator|)
operator|>=
name|thresholdTicks
argument_list|()
condition|)
block|{
name|NumTailCalls
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|// We can erase a tail exit pair that we're exiting through since
comment|// its duration is under threshold.
operator|--
name|NumTailCalls
expr_stmt|;
name|RewindingRecordPtr
operator|-=
name|FunctionRecSize
expr_stmt|;
name|RewindingTSC
operator|-=
name|ExpectedFunctionEntry
operator|.
name|TSCDelta
expr_stmt|;
name|RecordPtr
operator|-=
literal|2
operator|*
name|FunctionRecSize
expr_stmt|;
name|LastTSC
operator|=
name|RewindingTSC
expr_stmt|;
block|}
block|}
specifier|static
specifier|inline
name|bool
name|releaseThreadLocalBuffer
parameter_list|(
name|BufferQueue
modifier|*
name|BQ
parameter_list|)
block|{
name|auto
name|EC
init|=
name|BQ
operator|->
name|releaseBuffer
argument_list|(
name|Buffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|EC
operator|!=
name|BufferQueue
operator|::
name|ErrorCode
operator|::
name|Ok
condition|)
block|{
name|Report
argument_list|(
literal|"Failed to release buffer at %p; error=%s\n"
argument_list|,
name|Buffer
operator|.
name|Buffer
argument_list|,
name|BufferQueue
operator|::
name|getErrorString
argument_list|(
name|EC
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|true
return|;
block|}
specifier|static
specifier|inline
name|void
name|processFunctionHook
argument_list|(
name|int32_t
name|FuncId
argument_list|,
name|XRayEntryType
name|Entry
argument_list|,
name|uint64_t
name|TSC
argument_list|,
name|unsigned
name|char
name|CPU
argument_list|,
name|int
argument_list|(
operator|*
name|wall_clock_reader
argument_list|)
argument_list|(
name|clockid_t
argument_list|,
expr|struct
name|timespec
operator|*
argument_list|)
argument_list|,
name|__sanitizer
operator|::
name|atomic_sint32_t
operator|&
name|LoggingStatus
argument_list|,
specifier|const
name|std
operator|::
name|shared_ptr
operator|<
name|BufferQueue
operator|>
operator|&
name|BQ
argument_list|)
name|XRAY_NEVER_INSTRUMENT
block|{
comment|// Bail out right away if logging is not initialized yet.
comment|// We should take the opportunity to release the buffer though.
name|auto
name|Status
init|=
name|__sanitizer
operator|::
name|atomic_load
argument_list|(
operator|&
name|LoggingStatus
argument_list|,
name|__sanitizer
operator|::
name|memory_order_acquire
argument_list|)
decl_stmt|;
if|if
condition|(
name|Status
operator|!=
name|XRayLogInitStatus
operator|::
name|XRAY_LOG_INITIALIZED
condition|)
block|{
if|if
condition|(
name|RecordPtr
operator|!=
name|nullptr
operator|&&
operator|(
name|Status
operator|==
name|XRayLogInitStatus
operator|::
name|XRAY_LOG_FINALIZING
operator|||
name|Status
operator|==
name|XRayLogInitStatus
operator|::
name|XRAY_LOG_FINALIZED
operator|)
condition|)
block|{
name|writeEOBMetadata
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|releaseThreadLocalBuffer
argument_list|(
name|BQ
operator|.
name|get
argument_list|()
argument_list|)
condition|)
return|return;
name|RecordPtr
operator|=
name|nullptr
expr_stmt|;
block|}
return|return;
block|}
comment|// We use a thread_local variable to keep track of which CPUs we've already
comment|// run, and the TSC times for these CPUs. This allows us to stop repeating the
comment|// CPU field in the function records.
comment|//
comment|// We assume that we'll support only 65536 CPUs for x86_64.
name|thread_local
name|uint16_t
name|CurrentCPU
init|=
name|std
operator|::
name|numeric_limits
operator|<
name|uint16_t
operator|>
operator|::
name|max
argument_list|()
decl_stmt|;
name|thread_local
name|uint64_t
name|LastTSC
init|=
literal|0
decl_stmt|;
name|thread_local
name|uint64_t
name|LastFunctionEntryTSC
init|=
literal|0
decl_stmt|;
comment|// Make sure a thread that's ever called handleArg0 has a thread-local
comment|// live reference to the buffer queue for this particular instance of
comment|// FDRLogging, and that we're going to clean it up when the thread exits.
name|thread_local
specifier|auto
name|LocalBQ
init|=
name|BQ
decl_stmt|;
name|thread_local
name|ThreadExitBufferCleanup
name|Cleanup
parameter_list|(
name|LocalBQ
parameter_list|,
name|Buffer
parameter_list|)
function_decl|;
comment|// Prevent signal handler recursion, so in case we're already in a log writing
comment|// mode and the signal handler comes in (and is also instrumented) then we
comment|// don't want to be clobbering potentially partial writes already happening in
comment|// the thread. We use a simple thread_local latch to only allow one on-going
comment|// handleArg0 to happen at any given time.
name|thread_local
name|bool
name|Running
init|=
name|false
decl_stmt|;
name|RecursionGuard
name|Guard
block|{
name|Running
block|}
empty_stmt|;
if|if
condition|(
operator|!
name|Guard
condition|)
block|{
name|assert
argument_list|(
name|Running
operator|==
name|true
operator|&&
literal|"RecursionGuard is buggy!"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|loggingInitialized
argument_list|(
name|LoggingStatus
argument_list|)
operator|||
name|LocalBQ
operator|->
name|finalizing
argument_list|()
condition|)
block|{
name|writeEOBMetadata
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|releaseThreadLocalBuffer
argument_list|(
name|BQ
operator|.
name|get
argument_list|()
argument_list|)
condition|)
return|return;
name|RecordPtr
operator|=
name|nullptr
expr_stmt|;
block|}
if|if
condition|(
name|Buffer
operator|.
name|Buffer
operator|==
name|nullptr
condition|)
block|{
name|auto
name|EC
init|=
name|LocalBQ
operator|->
name|getBuffer
argument_list|(
name|Buffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|EC
operator|!=
name|BufferQueue
operator|::
name|ErrorCode
operator|::
name|Ok
condition|)
block|{
name|auto
name|LS
init|=
name|__sanitizer
operator|::
name|atomic_load
argument_list|(
operator|&
name|LoggingStatus
argument_list|,
name|__sanitizer
operator|::
name|memory_order_acquire
argument_list|)
decl_stmt|;
if|if
condition|(
name|LS
operator|!=
name|XRayLogInitStatus
operator|::
name|XRAY_LOG_FINALIZING
operator|&&
name|LS
operator|!=
name|XRayLogInitStatus
operator|::
name|XRAY_LOG_FINALIZED
condition|)
name|Report
argument_list|(
literal|"Failed to acquire a buffer; error=%s\n"
argument_list|,
name|BufferQueue
operator|::
name|getErrorString
argument_list|(
name|EC
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|setupNewBuffer
argument_list|(
name|wall_clock_reader
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CurrentCPU
operator|==
name|std
operator|::
name|numeric_limits
operator|<
name|uint16_t
operator|>
operator|::
name|max
argument_list|()
condition|)
block|{
comment|// This means this is the first CPU this thread has ever run on. We set the
comment|// current CPU and record this as the first TSC we've seen.
name|CurrentCPU
operator|=
name|CPU
expr_stmt|;
name|writeNewCPUIdMetadata
argument_list|(
name|CPU
argument_list|,
name|TSC
argument_list|)
expr_stmt|;
block|}
comment|// Before we go setting up writing new function entries, we need to be really
comment|// careful about the pointer math we're doing. This means we need to ensure
comment|// that the record we are about to write is going to fit into the buffer,
comment|// without overflowing the buffer.
comment|//
comment|// To do this properly, we use the following assumptions:
comment|//
comment|//   - The least number of bytes we will ever write is 8
comment|//     (sizeof(FunctionRecord)) only if the delta between the previous entry
comment|//     and this entry is within 32 bits.
comment|//   - The most number of bytes we will ever write is 8 + 16 = 24. This is
comment|//     computed by:
comment|//
comment|//       sizeof(FunctionRecord) + sizeof(MetadataRecord)
comment|//
comment|//     These arise in the following cases:
comment|//
comment|//       1. When the delta between the TSC we get and the previous TSC for the
comment|//          same CPU is outside of the uint32_t range, we end up having to
comment|//          write a MetadataRecord to indicate a "tsc wrap" before the actual
comment|//          FunctionRecord.
comment|//       2. When we learn that we've moved CPUs, we need to write a
comment|//          MetadataRecord to indicate a "cpu change", and thus write out the
comment|//          current TSC for that CPU before writing out the actual
comment|//          FunctionRecord.
comment|//       3. When we learn about a new CPU ID, we need to write down a "new cpu
comment|//          id" MetadataRecord before writing out the actual FunctionRecord.
comment|//
comment|//   - An End-of-Buffer (EOB) MetadataRecord is 16 bytes.
comment|//
comment|// So the math we need to do is to determine whether writing 24 bytes past the
comment|// current pointer leaves us with enough bytes to write the EOB
comment|// MetadataRecord. If we don't have enough space after writing as much as 24
comment|// bytes in the end of the buffer, we need to write out the EOB, get a new
comment|// Buffer, set it up properly before doing any further writing.
comment|//
name|char
modifier|*
name|BufferStart
init|=
name|static_cast
operator|<
name|char
operator|*
operator|>
operator|(
name|Buffer
operator|.
name|Buffer
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|RecordPtr
operator|+
operator|(
name|MetadataRecSize
operator|+
name|FunctionRecSize
operator|)
operator|)
operator|-
name|BufferStart
operator|<
name|static_cast
operator|<
name|ptrdiff_t
operator|>
operator|(
name|MetadataRecSize
operator|)
condition|)
block|{
name|writeEOBMetadata
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|releaseThreadLocalBuffer
argument_list|(
name|LocalBQ
operator|.
name|get
argument_list|()
argument_list|)
condition|)
return|return;
name|auto
name|EC
init|=
name|LocalBQ
operator|->
name|getBuffer
argument_list|(
name|Buffer
argument_list|)
decl_stmt|;
if|if
condition|(
name|EC
operator|!=
name|BufferQueue
operator|::
name|ErrorCode
operator|::
name|Ok
condition|)
block|{
name|Report
argument_list|(
literal|"Failed to acquire a buffer; error=%s\n"
argument_list|,
name|BufferQueue
operator|::
name|getErrorString
argument_list|(
name|EC
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|setupNewBuffer
argument_list|(
name|wall_clock_reader
argument_list|)
expr_stmt|;
block|}
comment|// By this point, we are now ready to write at most 24 bytes (one metadata
comment|// record and one function record).
name|BufferStart
operator|=
name|static_cast
operator|<
name|char
operator|*
operator|>
operator|(
name|Buffer
operator|.
name|Buffer
operator|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|RecordPtr
operator|+
operator|(
name|MetadataRecSize
operator|+
name|FunctionRecSize
operator|)
operator|)
operator|-
name|BufferStart
operator|>=
name|static_cast
operator|<
name|ptrdiff_t
operator|>
operator|(
name|MetadataRecSize
operator|)
operator|&&
literal|"Misconfigured BufferQueue provided; Buffer size not large enough."
argument_list|)
expr_stmt|;
comment|// Here we compute the TSC Delta. There are a few interesting situations we
comment|// need to account for:
comment|//
comment|//   - The thread has migrated to a different CPU. If this is the case, then
comment|//     we write down the following records:
comment|//
comment|//       1. A 'NewCPUId' Metadata record.
comment|//       2. A FunctionRecord with a 0 for the TSCDelta field.
comment|//
comment|//   - The TSC delta is greater than the 32 bits we can store in a
comment|//     FunctionRecord. In this case we write down the following records:
comment|//
comment|//       1. A 'TSCWrap' Metadata record.
comment|//       2. A FunctionRecord with a 0 for the TSCDelta field.
comment|//
comment|//   - The TSC delta is representable within the 32 bits we can store in a
comment|//     FunctionRecord. In this case we write down just a FunctionRecord with
comment|//     the correct TSC delta.
comment|//
name|uint32_t
name|RecordTSCDelta
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|CPU
operator|!=
name|CurrentCPU
condition|)
block|{
comment|// We've moved to a new CPU.
name|writeNewCPUIdMetadata
argument_list|(
name|CPU
argument_list|,
name|TSC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// If the delta is greater than the range for a uint32_t, then we write out
comment|// the TSC wrap metadata entry with the full TSC, and the TSC for the
comment|// function record be 0.
name|auto
name|Delta
init|=
name|TSC
operator|-
name|LastTSC
decl_stmt|;
if|if
condition|(
name|Delta
operator|>
operator|(
literal|1ULL
operator|<<
literal|32
operator|)
operator|-
literal|1
condition|)
name|writeTSCWrapMetadata
argument_list|(
name|TSC
argument_list|)
expr_stmt|;
else|else
name|RecordTSCDelta
operator|=
name|Delta
expr_stmt|;
block|}
name|LastTSC
operator|=
name|TSC
expr_stmt|;
name|CurrentCPU
operator|=
name|CPU
expr_stmt|;
switch|switch
condition|(
name|Entry
condition|)
block|{
case|case
name|XRayEntryType
operator|::
name|ENTRY
case|:
case|case
name|XRayEntryType
operator|::
name|LOG_ARGS_ENTRY
case|:
comment|// Update the thread local state for the next invocation.
name|LastFunctionEntryTSC
operator|=
name|TSC
expr_stmt|;
break|break;
case|case
name|XRayEntryType
operator|::
name|TAIL
case|:
break|break;
case|case
name|XRayEntryType
operator|::
name|EXIT
case|:
comment|// Break out and write the exit record if we can't erase any functions.
if|if
condition|(
name|NumConsecutiveFnEnters
operator|==
literal|0
operator|||
operator|(
name|TSC
operator|-
name|LastFunctionEntryTSC
operator|)
operator|>=
name|thresholdTicks
argument_list|()
condition|)
break|break;
name|rewindRecentCall
argument_list|(
name|TSC
argument_list|,
name|LastTSC
argument_list|,
name|LastFunctionEntryTSC
argument_list|,
name|FuncId
argument_list|)
expr_stmt|;
return|return;
comment|// without writing log.
block|}
name|writeFunctionRecord
argument_list|(
name|FuncId
argument_list|,
name|RecordTSCDelta
argument_list|,
name|Entry
argument_list|,
name|RecordPtr
argument_list|)
expr_stmt|;
comment|// If we've exhausted the buffer by this time, we then release the buffer to
comment|// make sure that other threads may start using this buffer.
if|if
condition|(
operator|(
name|RecordPtr
operator|+
name|MetadataRecSize
operator|)
operator|-
name|BufferStart
operator|==
name|MetadataRecSize
condition|)
block|{
name|writeEOBMetadata
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|releaseThreadLocalBuffer
argument_list|(
name|LocalBQ
operator|.
name|get
argument_list|()
argument_list|)
condition|)
return|return;
name|RecordPtr
operator|=
name|nullptr
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_comment
comment|// namespace __xray_fdr_internal
end_comment

begin_comment
unit|}
comment|// namespace __xray
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// XRAY_XRAY_FDR_LOGGING_IMPL_H
end_comment

end_unit

