begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- scudo_allocator_secondary.h -----------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Scudo Secondary Allocator.
end_comment

begin_comment
comment|/// This services allocation that are too large to be serviced by the Primary
end_comment

begin_comment
comment|/// Allocator. It is directly backed by the memory mapping functions of the
end_comment

begin_comment
comment|/// operating system.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SCUDO_ALLOCATOR_SECONDARY_H_
end_ifndef

begin_define
define|#
directive|define
name|SCUDO_ALLOCATOR_SECONDARY_H_
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|SCUDO_ALLOCATOR_H_
end_ifndef

begin_error
error|#
directive|error
literal|"This file must be included inside scudo_allocator.h."
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|class
name|ScudoLargeMmapAllocator
block|{
name|public
label|:
name|void
name|Init
parameter_list|(
name|bool
name|AllocatorMayReturnNull
parameter_list|)
block|{
name|PageSize
operator|=
name|GetPageSizeCached
argument_list|()
expr_stmt|;
name|atomic_store
argument_list|(
operator|&
name|MayReturnNull
argument_list|,
name|AllocatorMayReturnNull
argument_list|,
name|memory_order_relaxed
argument_list|)
expr_stmt|;
block|}
name|void
modifier|*
name|Allocate
parameter_list|(
name|AllocatorStats
modifier|*
name|Stats
parameter_list|,
name|uptr
name|Size
parameter_list|,
name|uptr
name|Alignment
parameter_list|)
block|{
comment|// The Scudo frontend prevents us from allocating more than
comment|// MaxAllowedMallocSize, so integer overflow checks would be superfluous.
name|uptr
name|MapSize
init|=
name|Size
operator|+
name|SecondaryHeaderSize
decl_stmt|;
name|MapSize
operator|=
name|RoundUpTo
argument_list|(
name|MapSize
argument_list|,
name|PageSize
argument_list|)
expr_stmt|;
comment|// Account for 2 guard pages, one before and one after the chunk.
name|MapSize
operator|+=
literal|2
operator|*
name|PageSize
expr_stmt|;
comment|// The size passed to the Secondary comprises the alignment, if large
comment|// enough. Subtract it here to get the requested size, including header.
if|if
condition|(
name|Alignment
operator|>
name|MinAlignment
condition|)
name|Size
operator|-=
name|Alignment
expr_stmt|;
name|uptr
name|MapBeg
init|=
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|MmapNoAccess
argument_list|(
name|MapSize
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
name|MapBeg
operator|==
operator|~
name|static_cast
operator|<
name|uptr
operator|>
operator|(
literal|0
operator|)
condition|)
return|return
name|ReturnNullOrDieOnOOM
argument_list|()
return|;
comment|// A page-aligned pointer is assumed after that, so check it now.
name|CHECK
argument_list|(
name|IsAligned
argument_list|(
name|MapBeg
argument_list|,
name|PageSize
argument_list|)
argument_list|)
expr_stmt|;
name|uptr
name|MapEnd
init|=
name|MapBeg
operator|+
name|MapSize
decl_stmt|;
comment|// The beginning of the user area for that allocation comes after the
comment|// initial guard page, and both headers. This is the pointer that has to
comment|// abide by alignment requirements.
name|uptr
name|UserBeg
init|=
name|MapBeg
operator|+
name|PageSize
operator|+
name|HeadersSize
decl_stmt|;
comment|// In the rare event of larger alignments, we will attempt to fit the mmap
comment|// area better and unmap extraneous memory. This will also ensure that the
comment|// offset and unused bytes field of the header stay small.
if|if
condition|(
name|Alignment
operator|>
name|MinAlignment
condition|)
block|{
if|if
condition|(
name|UserBeg
operator|&
operator|(
name|Alignment
operator|-
literal|1
operator|)
condition|)
name|UserBeg
operator|+=
name|Alignment
operator|-
operator|(
name|UserBeg
operator|&
operator|(
name|Alignment
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|CHECK_GE
argument_list|(
name|UserBeg
argument_list|,
name|MapBeg
argument_list|)
expr_stmt|;
name|uptr
name|NewMapBeg
init|=
name|RoundDownTo
argument_list|(
name|UserBeg
operator|-
name|HeadersSize
argument_list|,
name|PageSize
argument_list|)
operator|-
name|PageSize
decl_stmt|;
name|CHECK_GE
argument_list|(
name|NewMapBeg
argument_list|,
name|MapBeg
argument_list|)
expr_stmt|;
name|uptr
name|NewMapEnd
init|=
name|RoundUpTo
argument_list|(
name|UserBeg
operator|+
operator|(
name|Size
operator|-
name|AlignedChunkHeaderSize
operator|)
argument_list|,
name|PageSize
argument_list|)
operator|+
name|PageSize
decl_stmt|;
name|CHECK_LE
argument_list|(
name|NewMapEnd
argument_list|,
name|MapEnd
argument_list|)
expr_stmt|;
comment|// Unmap the extra memory if it's large enough, on both sides.
name|uptr
name|Diff
init|=
name|NewMapBeg
operator|-
name|MapBeg
decl_stmt|;
if|if
condition|(
name|Diff
operator|>
name|PageSize
condition|)
name|UnmapOrDie
argument_list|(
name|reinterpret_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|MapBeg
operator|)
argument_list|,
name|Diff
argument_list|)
expr_stmt|;
name|Diff
operator|=
name|MapEnd
operator|-
name|NewMapEnd
expr_stmt|;
if|if
condition|(
name|Diff
operator|>
name|PageSize
condition|)
name|UnmapOrDie
argument_list|(
name|reinterpret_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|NewMapEnd
operator|)
argument_list|,
name|Diff
argument_list|)
expr_stmt|;
name|MapBeg
operator|=
name|NewMapBeg
expr_stmt|;
name|MapEnd
operator|=
name|NewMapEnd
expr_stmt|;
name|MapSize
operator|=
name|NewMapEnd
operator|-
name|NewMapBeg
expr_stmt|;
block|}
name|uptr
name|UserEnd
init|=
name|UserBeg
operator|+
operator|(
name|Size
operator|-
name|AlignedChunkHeaderSize
operator|)
decl_stmt|;
name|CHECK_LE
argument_list|(
name|UserEnd
argument_list|,
name|MapEnd
operator|-
name|PageSize
argument_list|)
expr_stmt|;
comment|// Actually mmap the memory, preserving the guard pages on either side.
name|CHECK_EQ
argument_list|(
name|MapBeg
operator|+
name|PageSize
argument_list|,
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|MmapFixedOrDie
argument_list|(
name|MapBeg
operator|+
name|PageSize
argument_list|,
name|MapSize
operator|-
literal|2
operator|*
name|PageSize
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|uptr
name|Ptr
init|=
name|UserBeg
operator|-
name|AlignedChunkHeaderSize
decl_stmt|;
name|SecondaryHeader
modifier|*
name|Header
init|=
name|getHeader
argument_list|(
name|Ptr
argument_list|)
decl_stmt|;
name|Header
operator|->
name|MapBeg
operator|=
name|MapBeg
expr_stmt|;
name|Header
operator|->
name|MapSize
operator|=
name|MapSize
expr_stmt|;
comment|// The primary adds the whole class size to the stats when allocating a
comment|// chunk, so we will do something similar here. But we will not account for
comment|// the guard pages.
block|{
name|SpinMutexLock
name|l
argument_list|(
operator|&
name|StatsMutex
argument_list|)
decl_stmt|;
name|Stats
operator|->
name|Add
argument_list|(
name|AllocatorStatAllocated
argument_list|,
name|MapSize
operator|-
literal|2
operator|*
name|PageSize
argument_list|)
expr_stmt|;
name|Stats
operator|->
name|Add
argument_list|(
name|AllocatorStatMapped
argument_list|,
name|MapSize
operator|-
literal|2
operator|*
name|PageSize
argument_list|)
expr_stmt|;
block|}
return|return
name|reinterpret_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|UserBeg
operator|)
return|;
block|}
name|void
modifier|*
name|ReturnNullOrDieOnBadRequest
parameter_list|()
block|{
if|if
condition|(
name|atomic_load
argument_list|(
operator|&
name|MayReturnNull
argument_list|,
name|memory_order_acquire
argument_list|)
condition|)
return|return
name|nullptr
return|;
name|ReportAllocatorCannotReturnNull
argument_list|(
name|false
argument_list|)
expr_stmt|;
block|}
name|void
modifier|*
name|ReturnNullOrDieOnOOM
parameter_list|()
block|{
if|if
condition|(
name|atomic_load
argument_list|(
operator|&
name|MayReturnNull
argument_list|,
name|memory_order_acquire
argument_list|)
condition|)
return|return
name|nullptr
return|;
name|ReportAllocatorCannotReturnNull
argument_list|(
name|true
argument_list|)
expr_stmt|;
block|}
name|void
name|SetMayReturnNull
parameter_list|(
name|bool
name|AllocatorMayReturnNull
parameter_list|)
block|{
name|atomic_store
argument_list|(
operator|&
name|MayReturnNull
argument_list|,
name|AllocatorMayReturnNull
argument_list|,
name|memory_order_release
argument_list|)
expr_stmt|;
block|}
name|void
name|Deallocate
parameter_list|(
name|AllocatorStats
modifier|*
name|Stats
parameter_list|,
name|void
modifier|*
name|Ptr
parameter_list|)
block|{
name|SecondaryHeader
modifier|*
name|Header
init|=
name|getHeader
argument_list|(
name|Ptr
argument_list|)
decl_stmt|;
block|{
name|SpinMutexLock
name|l
argument_list|(
operator|&
name|StatsMutex
argument_list|)
decl_stmt|;
name|Stats
operator|->
name|Sub
argument_list|(
name|AllocatorStatAllocated
argument_list|,
name|Header
operator|->
name|MapSize
operator|-
literal|2
operator|*
name|PageSize
argument_list|)
expr_stmt|;
name|Stats
operator|->
name|Sub
argument_list|(
name|AllocatorStatMapped
argument_list|,
name|Header
operator|->
name|MapSize
operator|-
literal|2
operator|*
name|PageSize
argument_list|)
expr_stmt|;
block|}
name|UnmapOrDie
argument_list|(
name|reinterpret_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|Header
operator|->
name|MapBeg
operator|)
argument_list|,
name|Header
operator|->
name|MapSize
argument_list|)
expr_stmt|;
block|}
name|uptr
name|TotalMemoryUsed
parameter_list|()
block|{
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
block|}
name|bool
name|PointerIsMine
parameter_list|(
specifier|const
name|void
modifier|*
name|Ptr
parameter_list|)
block|{
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
block|}
name|uptr
name|GetActuallyAllocatedSize
parameter_list|(
name|void
modifier|*
name|Ptr
parameter_list|)
block|{
name|SecondaryHeader
modifier|*
name|Header
init|=
name|getHeader
argument_list|(
name|Ptr
argument_list|)
decl_stmt|;
comment|// Deduct PageSize as MapSize includes the trailing guard page.
name|uptr
name|MapEnd
init|=
name|Header
operator|->
name|MapBeg
operator|+
name|Header
operator|->
name|MapSize
operator|-
name|PageSize
decl_stmt|;
return|return
name|MapEnd
operator|-
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|Ptr
operator|)
return|;
block|}
name|void
modifier|*
name|GetMetaData
parameter_list|(
specifier|const
name|void
modifier|*
name|Ptr
parameter_list|)
block|{
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
block|}
name|void
modifier|*
name|GetBlockBegin
parameter_list|(
specifier|const
name|void
modifier|*
name|Ptr
parameter_list|)
block|{
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
block|}
name|void
modifier|*
name|GetBlockBeginFastLocked
parameter_list|(
name|void
modifier|*
name|Ptr
parameter_list|)
block|{
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
block|}
name|void
name|PrintStats
parameter_list|()
block|{
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
block|}
name|void
name|ForceLock
parameter_list|()
block|{
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
block|}
name|void
name|ForceUnlock
parameter_list|()
block|{
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
block|}
name|void
name|ForEachChunk
parameter_list|(
name|ForEachChunkCallback
name|Callback
parameter_list|,
name|void
modifier|*
name|Arg
parameter_list|)
block|{
name|UNIMPLEMENTED
argument_list|()
expr_stmt|;
block|}
name|private
label|:
comment|// A Secondary allocated chunk header contains the base of the mapping and
comment|// its size. Currently, the base is always a page before the header, but
comment|// we might want to extend that number in the future based on the size of
comment|// the allocation.
struct|struct
name|SecondaryHeader
block|{
name|uptr
name|MapBeg
decl_stmt|;
name|uptr
name|MapSize
decl_stmt|;
block|}
struct|;
comment|// Check that sizeof(SecondaryHeader) is a multiple of MinAlignment.
name|COMPILER_CHECK
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
name|SecondaryHeader
argument_list|)
operator|&
operator|(
name|MinAlignment
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|SecondaryHeader
modifier|*
name|getHeader
parameter_list|(
name|uptr
name|Ptr
parameter_list|)
block|{
return|return
name|reinterpret_cast
operator|<
name|SecondaryHeader
operator|*
operator|>
operator|(
name|Ptr
operator|-
sizeof|sizeof
argument_list|(
name|SecondaryHeader
argument_list|)
operator|)
return|;
block|}
name|SecondaryHeader
modifier|*
name|getHeader
parameter_list|(
specifier|const
name|void
modifier|*
name|Ptr
parameter_list|)
block|{
return|return
name|getHeader
argument_list|(
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|Ptr
operator|)
argument_list|)
return|;
block|}
specifier|const
name|uptr
name|SecondaryHeaderSize
init|=
sizeof|sizeof
argument_list|(
name|SecondaryHeader
argument_list|)
decl_stmt|;
specifier|const
name|uptr
name|HeadersSize
init|=
name|SecondaryHeaderSize
operator|+
name|AlignedChunkHeaderSize
decl_stmt|;
name|uptr
name|PageSize
decl_stmt|;
name|SpinMutex
name|StatsMutex
decl_stmt|;
name|atomic_uint8_t
name|MayReturnNull
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// SCUDO_ALLOCATOR_SECONDARY_H_
end_comment

end_unit

