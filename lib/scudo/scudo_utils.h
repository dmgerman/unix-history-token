begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- scudo_utils.h -------------------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Header for scudo_utils.cpp.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SCUDO_UTILS_H_
end_ifndef

begin_define
define|#
directive|define
name|SCUDO_UTILS_H_
end_define

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"sanitizer_common/sanitizer_common.h"
end_include

begin_decl_stmt
name|namespace
name|__scudo
block|{
name|template
operator|<
name|class
name|Dest
operator|,
name|class
name|Source
operator|>
specifier|inline
name|Dest
name|bit_cast
argument_list|(
argument|const Source& source
argument_list|)
block|{
name|static_assert
argument_list|(
sizeof|sizeof
argument_list|(
name|Dest
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|Source
argument_list|)
argument_list|,
literal|"Sizes are not equal!"
argument_list|)
block|;
name|Dest
name|dest
block|;
name|memcpy
argument_list|(
operator|&
name|dest
argument_list|,
operator|&
name|source
argument_list|,
sizeof|sizeof
argument_list|(
name|dest
argument_list|)
argument_list|)
block|;
return|return
name|dest
return|;
block|}
name|void
name|NORETURN
name|dieWithMessage
parameter_list|(
specifier|const
name|char
modifier|*
name|Format
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
enum|enum
name|CPUFeature
block|{
name|CRC32CPUFeature
init|=
literal|0
block|,
name|MaxCPUFeature
block|, }
enum|;
name|bool
name|testCPUFeature
parameter_list|(
name|CPUFeature
name|feature
parameter_list|)
function_decl|;
name|INLINE
name|u64
name|rotl
parameter_list|(
specifier|const
name|u64
name|X
parameter_list|,
name|int
name|K
parameter_list|)
block|{
return|return
operator|(
name|X
operator|<<
name|K
operator|)
operator||
operator|(
name|X
operator|>>
operator|(
literal|64
operator|-
name|K
operator|)
operator|)
return|;
block|}
comment|// XoRoShiRo128+ PRNG (http://xoroshiro.di.unimi.it/).
struct|struct
name|XoRoShiRo128Plus
block|{
name|public
label|:
name|void
name|init
parameter_list|()
block|{
if|if
condition|(
name|UNLIKELY
argument_list|(
operator|!
name|GetRandom
argument_list|(
name|reinterpret_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|State
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|State
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
comment|// Early processes (eg: init) do not have /dev/urandom yet, but we still
comment|// have to provide them with some degree of entropy. Not having a secure
comment|// seed is not as problematic for them, as they are less likely to be
comment|// the target of heap based vulnerabilities exploitation attempts.
name|State
index|[
literal|0
index|]
operator|=
name|NanoTime
argument_list|()
expr_stmt|;
name|State
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|fillCache
argument_list|()
expr_stmt|;
block|}
name|u8
name|getU8
parameter_list|()
block|{
if|if
condition|(
name|UNLIKELY
argument_list|(
name|isCacheEmpty
argument_list|()
argument_list|)
condition|)
name|fillCache
argument_list|()
expr_stmt|;
specifier|const
name|u8
name|Result
init|=
name|static_cast
operator|<
name|u8
operator|>
operator|(
name|CachedBytes
operator|&
literal|0xff
operator|)
decl_stmt|;
name|CachedBytes
operator|>>=
literal|8
expr_stmt|;
name|CachedBytesAvailable
operator|--
expr_stmt|;
return|return
name|Result
return|;
block|}
name|u64
name|getU64
parameter_list|()
block|{
return|return
name|next
argument_list|()
return|;
block|}
name|private
label|:
name|u8
name|CachedBytesAvailable
decl_stmt|;
name|u64
name|CachedBytes
decl_stmt|;
name|u64
name|State
index|[
literal|2
index|]
decl_stmt|;
name|u64
name|next
parameter_list|()
block|{
specifier|const
name|u64
name|S0
init|=
name|State
index|[
literal|0
index|]
decl_stmt|;
name|u64
name|S1
init|=
name|State
index|[
literal|1
index|]
decl_stmt|;
specifier|const
name|u64
name|Result
init|=
name|S0
operator|+
name|S1
decl_stmt|;
name|S1
operator|^=
name|S0
expr_stmt|;
name|State
index|[
literal|0
index|]
operator|=
name|rotl
argument_list|(
name|S0
argument_list|,
literal|55
argument_list|)
operator|^
name|S1
operator|^
operator|(
name|S1
operator|<<
literal|14
operator|)
expr_stmt|;
name|State
index|[
literal|1
index|]
operator|=
name|rotl
argument_list|(
name|S1
argument_list|,
literal|36
argument_list|)
expr_stmt|;
return|return
name|Result
return|;
block|}
name|bool
name|isCacheEmpty
parameter_list|()
block|{
return|return
name|CachedBytesAvailable
operator|==
literal|0
return|;
block|}
name|void
name|fillCache
parameter_list|()
block|{
name|CachedBytes
operator|=
name|next
argument_list|()
expr_stmt|;
name|CachedBytesAvailable
operator|=
sizeof|sizeof
argument_list|(
name|CachedBytes
argument_list|)
expr_stmt|;
block|}
block|}
struct|;
typedef|typedef
name|XoRoShiRo128Plus
name|ScudoPrng
typedef|;
block|}
end_decl_stmt

begin_comment
comment|// namespace __scudo
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// SCUDO_UTILS_H_
end_comment

end_unit

