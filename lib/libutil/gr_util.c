begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2008 Sean C. Farley<scf@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<libutil.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|lockfd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|group_dir
index|[
name|PATH_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|group_file
index|[
name|PATH_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|tempname
index|[
name|PATH_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|initialized
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|size_t
name|grmemlen
parameter_list|(
specifier|const
name|struct
name|group
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|group
modifier|*
name|grcopy
parameter_list|(
specifier|const
name|struct
name|group
modifier|*
name|gr
parameter_list|,
name|char
modifier|*
name|mem
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
name|ndx
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Initialize statics  */
end_comment

begin_function
name|int
name|gr_init
parameter_list|(
specifier|const
name|char
modifier|*
name|dir
parameter_list|,
specifier|const
name|char
modifier|*
name|group
parameter_list|)
block|{
if|if
condition|(
name|dir
operator|==
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|group_dir
argument_list|,
name|_PATH_ETC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|strlen
argument_list|(
name|dir
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|group_dir
argument_list|)
condition|)
block|{
name|errno
operator|=
name|ENAMETOOLONG
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|group_dir
argument_list|,
name|dir
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|group
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|dir
operator|==
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|group_file
argument_list|,
name|_PATH_GROUP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|snprintf
argument_list|(
name|group_file
argument_list|,
sizeof|sizeof
argument_list|(
name|group_file
argument_list|)
argument_list|,
literal|"%s/group"
argument_list|,
name|group_dir
argument_list|)
operator|>
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|group_file
argument_list|)
condition|)
block|{
name|errno
operator|=
name|ENAMETOOLONG
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|strlen
argument_list|(
name|group
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|group_file
argument_list|)
condition|)
block|{
name|errno
operator|=
name|ENAMETOOLONG
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|group_file
argument_list|,
name|group
argument_list|)
expr_stmt|;
block|}
name|initialized
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lock the group file  */
end_comment

begin_function
name|int
name|gr_lock
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|*
name|group_file
operator|==
literal|'\0'
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|lockfd
operator|=
name|flopen
argument_list|(
name|group_file
argument_list|,
name|O_RDONLY
operator||
name|O_NONBLOCK
operator||
name|O_CLOEXEC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lockfd
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EWOULDBLOCK
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"the group file is busy"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
argument_list|(
literal|1
argument_list|,
literal|"could not lock the group file: "
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|fstat
argument_list|(
name|lockfd
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"fstat() failed: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|.
name|st_nlink
operator|!=
literal|0
condition|)
break|break;
name|close
argument_list|(
name|lockfd
argument_list|)
expr_stmt|;
name|lockfd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|lockfd
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create and open a presmuably safe temp file for editing group data  */
end_comment

begin_function
name|int
name|gr_tmp
parameter_list|(
name|int
name|mfd
parameter_list|)
block|{
name|char
name|buf
index|[
literal|8192
index|]
decl_stmt|;
name|ssize_t
name|nr
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|tfd
decl_stmt|;
if|if
condition|(
operator|*
name|group_file
operator|==
literal|'\0'
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|group_file
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
operator|++
name|p
expr_stmt|;
else|else
name|p
operator|=
name|group_file
expr_stmt|;
if|if
condition|(
name|snprintf
argument_list|(
name|tempname
argument_list|,
sizeof|sizeof
argument_list|(
name|tempname
argument_list|)
argument_list|,
literal|"%.*sgroup.XXXXXX"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|p
operator|-
name|group_file
argument_list|)
argument_list|,
name|group_file
argument_list|)
operator|>=
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|tempname
argument_list|)
condition|)
block|{
name|errno
operator|=
name|ENAMETOOLONG
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|tfd
operator|=
name|mkostemp
argument_list|(
name|tempname
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|mfd
operator|!=
operator|-
literal|1
condition|)
block|{
while|while
condition|(
operator|(
name|nr
operator|=
name|read
argument_list|(
name|mfd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
if|if
condition|(
name|write
argument_list|(
name|tfd
argument_list|,
name|buf
argument_list|,
operator|(
name|size_t
operator|)
name|nr
argument_list|)
operator|!=
name|nr
condition|)
break|break;
if|if
condition|(
name|nr
operator|!=
literal|0
condition|)
block|{
name|unlink
argument_list|(
name|tempname
argument_list|)
expr_stmt|;
operator|*
name|tempname
operator|=
literal|'\0'
expr_stmt|;
name|close
argument_list|(
name|tfd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
name|tfd
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy the group file from one descriptor to another, replacing, deleting  * or adding a single record on the way.  */
end_comment

begin_function
name|int
name|gr_copy
parameter_list|(
name|int
name|ffd
parameter_list|,
name|int
name|tfd
parameter_list|,
specifier|const
name|struct
name|group
modifier|*
name|gr
parameter_list|,
name|struct
name|group
modifier|*
name|old_gr
parameter_list|)
block|{
name|char
name|buf
index|[
literal|8192
index|]
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|line
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|r
decl_stmt|,
name|t
decl_stmt|;
name|struct
name|group
modifier|*
name|fgr
decl_stmt|;
specifier|const
name|struct
name|group
modifier|*
name|sgr
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|eof
decl_stmt|,
name|readlen
decl_stmt|;
if|if
condition|(
name|old_gr
operator|==
name|NULL
operator|&&
name|gr
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|sgr
operator|=
name|old_gr
expr_stmt|;
comment|/* deleting a group */
if|if
condition|(
name|gr
operator|==
name|NULL
condition|)
block|{
name|line
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|line
operator|=
name|gr_make
argument_list|(
name|gr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* adding a group */
if|if
condition|(
name|sgr
operator|==
name|NULL
condition|)
name|sgr
operator|=
name|gr
expr_stmt|;
name|eof
operator|=
literal|0
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|q
operator|=
name|end
operator|=
name|buf
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* find the end of the current line */
for|for
control|(
name|p
operator|=
name|q
init|;
name|q
operator|<
name|end
operator|&&
operator|*
name|q
operator|!=
literal|'\0'
condition|;
operator|++
name|q
control|)
if|if
condition|(
operator|*
name|q
operator|==
literal|'\n'
condition|)
break|break;
comment|/* if we don't have a complete line, fill up the buffer */
if|if
condition|(
name|q
operator|>=
name|end
condition|)
block|{
if|if
condition|(
name|eof
condition|)
break|break;
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|q
operator|-
name|p
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"group line too long"
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
comment|/* hack */
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|p
operator|<
name|end
condition|)
block|{
name|q
operator|=
name|memmove
argument_list|(
name|buf
argument_list|,
name|p
argument_list|,
name|end
operator|-
name|p
argument_list|)
expr_stmt|;
name|end
operator|-=
name|p
operator|-
name|buf
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|q
operator|=
name|end
operator|=
name|buf
expr_stmt|;
block|}
name|readlen
operator|=
name|read
argument_list|(
name|ffd
argument_list|,
name|end
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
operator|(
name|end
operator|-
name|buf
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|readlen
operator|==
operator|-
literal|1
condition|)
goto|goto
name|err
goto|;
else|else
name|len
operator|=
operator|(
name|size_t
operator|)
name|readlen
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
operator|&&
name|p
operator|==
name|buf
condition|)
break|break;
name|end
operator|+=
name|len
expr_stmt|;
name|len
operator|=
name|end
operator|-
name|buf
expr_stmt|;
if|if
condition|(
name|len
operator|<
operator|(
name|ssize_t
operator|)
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
block|{
name|eof
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|buf
index|[
name|len
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
operator|++
name|len
operator|,
operator|*
name|end
operator|++
operator|=
literal|'\n'
expr_stmt|;
block|}
continue|continue;
block|}
comment|/* is it a blank line or a comment? */
for|for
control|(
name|r
operator|=
name|p
init|;
name|r
operator|<
name|q
operator|&&
name|isspace
argument_list|(
operator|*
name|r
argument_list|)
condition|;
operator|++
name|r
control|)
comment|/* nothing */
empty_stmt|;
if|if
condition|(
name|r
operator|==
name|q
operator|||
operator|*
name|r
operator|==
literal|'#'
condition|)
block|{
comment|/* yep */
if|if
condition|(
name|write
argument_list|(
name|tfd
argument_list|,
name|p
argument_list|,
name|q
operator|-
name|p
operator|+
literal|1
argument_list|)
operator|!=
name|q
operator|-
name|p
operator|+
literal|1
condition|)
goto|goto
name|err
goto|;
operator|++
name|q
expr_stmt|;
continue|continue;
block|}
comment|/* is it the one we're looking for? */
name|t
operator|=
operator|*
name|q
expr_stmt|;
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
name|fgr
operator|=
name|gr_scan
argument_list|(
name|r
argument_list|)
expr_stmt|;
comment|/* fgr is either a struct group for the current line, 		 * or NULL if the line is malformed. 		 */
operator|*
name|q
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|fgr
operator|==
name|NULL
operator|||
name|fgr
operator|->
name|gr_gid
operator|!=
name|sgr
operator|->
name|gr_gid
condition|)
block|{
comment|/* nope */
if|if
condition|(
name|fgr
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|fgr
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|tfd
argument_list|,
name|p
argument_list|,
name|q
operator|-
name|p
operator|+
literal|1
argument_list|)
operator|!=
name|q
operator|-
name|p
operator|+
literal|1
condition|)
goto|goto
name|err
goto|;
operator|++
name|q
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|old_gr
operator|&&
operator|!
name|gr_equal
argument_list|(
name|fgr
argument_list|,
name|old_gr
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"entry inconsistent"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fgr
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
comment|/* hack */
goto|goto
name|err
goto|;
block|}
name|free
argument_list|(
name|fgr
argument_list|)
expr_stmt|;
comment|/* it is, replace or remove it */
if|if
condition|(
name|line
operator|!=
name|NULL
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|tfd
argument_list|,
name|line
argument_list|,
name|len
argument_list|)
operator|!=
operator|(
name|int
operator|)
name|len
condition|)
goto|goto
name|err
goto|;
block|}
else|else
block|{
comment|/* when removed, avoid the \n */
name|q
operator|++
expr_stmt|;
block|}
comment|/* we're done, just copy the rest over */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|write
argument_list|(
name|tfd
argument_list|,
name|q
argument_list|,
name|end
operator|-
name|q
argument_list|)
operator|!=
name|end
operator|-
name|q
condition|)
goto|goto
name|err
goto|;
name|q
operator|=
name|buf
expr_stmt|;
name|readlen
operator|=
name|read
argument_list|(
name|ffd
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|readlen
operator|==
literal|0
condition|)
break|break;
else|else
name|len
operator|=
operator|(
name|size_t
operator|)
name|readlen
expr_stmt|;
if|if
condition|(
name|readlen
operator|==
operator|-
literal|1
condition|)
goto|goto
name|err
goto|;
name|end
operator|=
name|buf
operator|+
name|len
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
comment|/* if we got here, we didn't find the old entry */
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|write
argument_list|(
name|tfd
argument_list|,
name|line
argument_list|,
name|len
argument_list|)
operator|!=
name|len
operator|||
name|write
argument_list|(
name|tfd
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
goto|goto
name|err
goto|;
name|done
label|:
if|if
condition|(
name|line
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err
label|:
if|if
condition|(
name|line
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Regenerate the group file  */
end_comment

begin_function
name|int
name|gr_mkdb
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|tempname
argument_list|,
literal|0644
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|rename
argument_list|(
name|tempname
argument_list|,
name|group_file
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * Make sure new group file is safe on disk. To improve performance we 	 * will call fsync() to the directory where file lies 	 */
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|group_dir
argument_list|,
name|O_RDONLY
operator||
name|O_DIRECTORY
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|fsync
argument_list|(
name|fd
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clean up. Preserves errno for the caller's convenience.  */
end_comment

begin_function
name|void
name|gr_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|serrno
decl_stmt|;
if|if
condition|(
operator|!
name|initialized
condition|)
return|return;
name|initialized
operator|=
literal|0
expr_stmt|;
name|serrno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
operator|*
name|tempname
operator|!=
literal|'\0'
condition|)
block|{
name|unlink
argument_list|(
name|tempname
argument_list|)
expr_stmt|;
operator|*
name|tempname
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|lockfd
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|lockfd
argument_list|)
expr_stmt|;
name|errno
operator|=
name|serrno
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compares two struct group's.  */
end_comment

begin_function
name|int
name|gr_equal
parameter_list|(
specifier|const
name|struct
name|group
modifier|*
name|gr1
parameter_list|,
specifier|const
name|struct
name|group
modifier|*
name|gr2
parameter_list|)
block|{
name|int
name|gr1_ndx
decl_stmt|;
name|int
name|gr2_ndx
decl_stmt|;
comment|/* Check that the non-member information is the same. */
if|if
condition|(
name|gr1
operator|->
name|gr_name
operator|==
name|NULL
operator|||
name|gr2
operator|->
name|gr_name
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|gr1
operator|->
name|gr_name
operator|!=
name|gr2
operator|->
name|gr_name
condition|)
return|return
operator|(
name|false
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|gr1
operator|->
name|gr_name
argument_list|,
name|gr2
operator|->
name|gr_name
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|gr1
operator|->
name|gr_passwd
operator|==
name|NULL
operator|||
name|gr2
operator|->
name|gr_passwd
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|gr1
operator|->
name|gr_passwd
operator|!=
name|gr2
operator|->
name|gr_passwd
condition|)
return|return
operator|(
name|false
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|gr1
operator|->
name|gr_passwd
argument_list|,
name|gr2
operator|->
name|gr_passwd
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
name|gr1
operator|->
name|gr_gid
operator|!=
name|gr2
operator|->
name|gr_gid
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* Check all members in both groups. 	 * getgrnam can return gr_mem with a pointer to NULL. 	 * gr_dup and gr_add strip out this superfluous NULL, setting 	 * gr_mem to NULL for no members. 	*/
if|if
condition|(
name|gr1
operator|->
name|gr_mem
operator|!=
name|NULL
operator|&&
name|gr2
operator|->
name|gr_mem
operator|!=
name|NULL
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|gr1
operator|->
name|gr_mem
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|gr1
operator|->
name|gr_mem
index|[
name|i
index|]
argument_list|,
name|gr2
operator|->
name|gr_mem
index|[
name|i
index|]
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|false
operator|)
return|;
block|}
block|}
comment|/* Count number of members in both structs */
name|gr2_ndx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gr2
operator|->
name|gr_mem
operator|!=
name|NULL
condition|)
for|for
control|(
init|;
name|gr2
operator|->
name|gr_mem
index|[
name|gr2_ndx
index|]
operator|!=
name|NULL
condition|;
name|gr2_ndx
operator|++
control|)
comment|/* empty */
empty_stmt|;
name|gr1_ndx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gr1
operator|->
name|gr_mem
operator|!=
name|NULL
condition|)
for|for
control|(
init|;
name|gr1
operator|->
name|gr_mem
index|[
name|gr1_ndx
index|]
operator|!=
name|NULL
condition|;
name|gr1_ndx
operator|++
control|)
comment|/* empty */
empty_stmt|;
if|if
condition|(
name|gr1_ndx
operator|!=
name|gr2_ndx
condition|)
return|return
operator|(
name|false
operator|)
return|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make a group line out of a struct group.  */
end_comment

begin_function
name|char
modifier|*
name|gr_make
parameter_list|(
specifier|const
name|struct
name|group
modifier|*
name|gr
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|group_line_format
init|=
literal|"%s:%s:%ju:"
decl_stmt|;
specifier|const
name|char
modifier|*
name|sep
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|line_size
decl_stmt|;
name|int
name|ndx
decl_stmt|;
comment|/* Calculate the length of the group line. */
name|line_size
operator|=
name|snprintf
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|group_line_format
argument_list|,
name|gr
operator|->
name|gr_name
argument_list|,
name|gr
operator|->
name|gr_passwd
argument_list|,
operator|(
name|uintmax_t
operator|)
name|gr
operator|->
name|gr_gid
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|gr
operator|->
name|gr_mem
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|ndx
operator|=
literal|0
init|;
name|gr
operator|->
name|gr_mem
index|[
name|ndx
index|]
operator|!=
name|NULL
condition|;
name|ndx
operator|++
control|)
name|line_size
operator|+=
name|strlen
argument_list|(
name|gr
operator|->
name|gr_mem
index|[
name|ndx
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|ndx
operator|>
literal|0
condition|)
name|line_size
operator|--
expr_stmt|;
block|}
comment|/* Create the group line and fill it. */
if|if
condition|(
operator|(
name|line
operator|=
name|p
operator|=
name|malloc
argument_list|(
name|line_size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|p
operator|+=
name|sprintf
argument_list|(
name|p
argument_list|,
name|group_line_format
argument_list|,
name|gr
operator|->
name|gr_name
argument_list|,
name|gr
operator|->
name|gr_passwd
argument_list|,
operator|(
name|uintmax_t
operator|)
name|gr
operator|->
name|gr_gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|gr
operator|->
name|gr_mem
operator|!=
name|NULL
condition|)
block|{
name|sep
operator|=
literal|""
expr_stmt|;
for|for
control|(
name|ndx
operator|=
literal|0
init|;
name|gr
operator|->
name|gr_mem
index|[
name|ndx
index|]
operator|!=
name|NULL
condition|;
name|ndx
operator|++
control|)
block|{
name|p
operator|=
name|stpcpy
argument_list|(
name|p
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|p
operator|=
name|stpcpy
argument_list|(
name|p
argument_list|,
name|gr
operator|->
name|gr_mem
index|[
name|ndx
index|]
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|","
expr_stmt|;
block|}
block|}
return|return
operator|(
name|line
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Duplicate a struct group.  */
end_comment

begin_function
name|struct
name|group
modifier|*
name|gr_dup
parameter_list|(
specifier|const
name|struct
name|group
modifier|*
name|gr
parameter_list|)
block|{
return|return
operator|(
name|gr_add
argument_list|(
name|gr
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a new member name to a struct group.  */
end_comment

begin_function
name|struct
name|group
modifier|*
name|gr_add
parameter_list|(
specifier|const
name|struct
name|group
modifier|*
name|gr
parameter_list|,
specifier|const
name|char
modifier|*
name|newmember
parameter_list|)
block|{
name|char
modifier|*
name|mem
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|num_mem
decl_stmt|;
name|num_mem
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|grmemlen
argument_list|(
name|gr
argument_list|,
name|newmember
argument_list|,
operator|&
name|num_mem
argument_list|)
expr_stmt|;
comment|/* Create new group and copy old group into it. */
if|if
condition|(
operator|(
name|mem
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|grcopy
argument_list|(
name|gr
argument_list|,
name|mem
argument_list|,
name|newmember
argument_list|,
name|num_mem
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* It is safer to walk the pointers given at gr_mem since there is no  * guarantee the gr_mem + strings are contiguous in the given struct group  * but compactify the new group into the following form.  *  * The new struct is laid out like this in memory. The example given is  * for a group with two members only.  *  * {  * (char *name)  * (char *passwd)  * (int gid)  * (gr_mem * newgrp + sizeof(struct group) + sizeof(**)) points to gr_mem area  * gr_mem area  * (member1 *)   * (member2 *)  * (NULL)  * (name string)  * (passwd string)  * (member1 string)  * (member2 string)  * }  */
end_comment

begin_comment
comment|/*  * Copy the contents of a group plus given name to a preallocated group struct  */
end_comment

begin_function
specifier|static
name|struct
name|group
modifier|*
name|grcopy
parameter_list|(
specifier|const
name|struct
name|group
modifier|*
name|gr
parameter_list|,
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|ndx
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|group
modifier|*
name|newgr
decl_stmt|;
name|newgr
operator|=
operator|(
expr|struct
name|group
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|dst
expr_stmt|;
comment|/* avoid alignment warning */
name|dst
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|newgr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ndx
operator|!=
literal|0
condition|)
block|{
name|newgr
operator|->
name|gr_mem
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
name|dst
operator|)
expr_stmt|;
comment|/* avoid alignment warning */
name|dst
operator|+=
operator|(
name|ndx
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|newgr
operator|->
name|gr_mem
argument_list|)
expr_stmt|;
block|}
else|else
name|newgr
operator|->
name|gr_mem
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|gr
operator|->
name|gr_name
operator|!=
name|NULL
condition|)
block|{
name|newgr
operator|->
name|gr_name
operator|=
name|dst
expr_stmt|;
name|dst
operator|=
name|stpcpy
argument_list|(
name|dst
argument_list|,
name|gr
operator|->
name|gr_name
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|newgr
operator|->
name|gr_name
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|gr
operator|->
name|gr_passwd
operator|!=
name|NULL
condition|)
block|{
name|newgr
operator|->
name|gr_passwd
operator|=
name|dst
expr_stmt|;
name|dst
operator|=
name|stpcpy
argument_list|(
name|dst
argument_list|,
name|gr
operator|->
name|gr_passwd
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|newgr
operator|->
name|gr_passwd
operator|=
name|NULL
expr_stmt|;
name|newgr
operator|->
name|gr_gid
operator|=
name|gr
operator|->
name|gr_gid
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/* Original group struct might have a NULL gr_mem */
if|if
condition|(
name|gr
operator|->
name|gr_mem
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
init|;
name|gr
operator|->
name|gr_mem
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|newgr
operator|->
name|gr_mem
index|[
name|i
index|]
operator|=
name|dst
expr_stmt|;
name|dst
operator|=
name|stpcpy
argument_list|(
name|dst
argument_list|,
name|gr
operator|->
name|gr_mem
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/* If name is not NULL, newgr->gr_mem is known to be not NULL */
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
name|newgr
operator|->
name|gr_mem
index|[
name|i
operator|++
index|]
operator|=
name|dst
expr_stmt|;
name|dst
operator|=
name|stpcpy
argument_list|(
name|dst
argument_list|,
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
comment|/* if newgr->gr_mem is not NULL add NULL marker */
if|if
condition|(
name|newgr
operator|->
name|gr_mem
operator|!=
name|NULL
condition|)
name|newgr
operator|->
name|gr_mem
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|newgr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Calculate length of a struct group + given name  */
end_comment

begin_function
specifier|static
name|size_t
name|grmemlen
parameter_list|(
specifier|const
name|struct
name|group
modifier|*
name|gr
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
modifier|*
name|num_mem
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|gr
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Calculate size of the group. */
name|len
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|gr
argument_list|)
expr_stmt|;
if|if
condition|(
name|gr
operator|->
name|gr_name
operator|!=
name|NULL
condition|)
name|len
operator|+=
name|strlen
argument_list|(
name|gr
operator|->
name|gr_name
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|gr
operator|->
name|gr_passwd
operator|!=
name|NULL
condition|)
name|len
operator|+=
name|strlen
argument_list|(
name|gr
operator|->
name|gr_passwd
argument_list|)
operator|+
literal|1
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gr
operator|->
name|gr_mem
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
init|;
name|gr
operator|->
name|gr_mem
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|len
operator|+=
name|strlen
argument_list|(
name|gr
operator|->
name|gr_mem
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|gr
operator|->
name|gr_mem
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|name
operator|!=
name|NULL
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|len
operator|+=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|gr
operator|->
name|gr_mem
argument_list|)
expr_stmt|;
block|}
comment|/* Allow for NULL pointer */
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|len
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|gr
operator|->
name|gr_mem
argument_list|)
expr_stmt|;
operator|*
name|num_mem
operator|=
name|i
expr_stmt|;
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Scan a line and place it into a group structure.  */
end_comment

begin_function
specifier|static
name|bool
name|__gr_scan
parameter_list|(
name|char
modifier|*
name|line
parameter_list|,
name|struct
name|group
modifier|*
name|gr
parameter_list|)
block|{
name|char
modifier|*
name|loc
decl_stmt|;
name|int
name|ndx
decl_stmt|;
comment|/* Assign non-member information to structure. */
name|gr
operator|->
name|gr_name
operator|=
name|line
expr_stmt|;
if|if
condition|(
operator|(
name|loc
operator|=
name|strchr
argument_list|(
name|line
argument_list|,
literal|':'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|false
operator|)
return|;
operator|*
name|loc
operator|=
literal|'\0'
expr_stmt|;
name|gr
operator|->
name|gr_passwd
operator|=
name|loc
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|gr
operator|->
name|gr_passwd
operator|==
literal|':'
condition|)
operator|*
name|gr
operator|->
name|gr_passwd
operator|=
literal|'\0'
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|loc
operator|=
name|strchr
argument_list|(
name|loc
operator|+
literal|1
argument_list|,
literal|':'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|false
operator|)
return|;
operator|*
name|loc
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|sscanf
argument_list|(
name|loc
operator|+
literal|1
argument_list|,
literal|"%u"
argument_list|,
operator|&
name|gr
operator|->
name|gr_gid
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* Assign member information to structure. */
if|if
condition|(
operator|(
name|loc
operator|=
name|strchr
argument_list|(
name|loc
operator|+
literal|1
argument_list|,
literal|':'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|false
operator|)
return|;
name|line
operator|=
name|loc
operator|+
literal|1
expr_stmt|;
name|gr
operator|->
name|gr_mem
operator|=
name|NULL
expr_stmt|;
name|ndx
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|gr
operator|->
name|gr_mem
operator|=
name|reallocf
argument_list|(
name|gr
operator|->
name|gr_mem
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|gr
operator|->
name|gr_mem
argument_list|)
operator|*
operator|(
name|ndx
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|gr
operator|->
name|gr_mem
operator|==
name|NULL
condition|)
return|return
operator|(
name|false
operator|)
return|;
comment|/* Skip locations without members (i.e., empty string). */
do|do
block|{
name|gr
operator|->
name|gr_mem
index|[
name|ndx
index|]
operator|=
name|strsep
argument_list|(
operator|&
name|line
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|gr
operator|->
name|gr_mem
index|[
name|ndx
index|]
operator|!=
name|NULL
operator|&&
operator|*
name|gr
operator|->
name|gr_mem
index|[
name|ndx
index|]
operator|==
literal|'\0'
condition|)
do|;
block|}
do|while
condition|(
name|gr
operator|->
name|gr_mem
index|[
name|ndx
operator|++
index|]
operator|!=
name|NULL
condition|)
do|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a struct group from a line.  */
end_comment

begin_function
name|struct
name|group
modifier|*
name|gr_scan
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|)
block|{
name|struct
name|group
name|gr
decl_stmt|;
name|char
modifier|*
name|line_copy
decl_stmt|;
name|struct
name|group
modifier|*
name|new_gr
decl_stmt|;
if|if
condition|(
operator|(
name|line_copy
operator|=
name|strdup
argument_list|(
name|line
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|!
name|__gr_scan
argument_list|(
name|line_copy
argument_list|,
operator|&
name|gr
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|line_copy
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|new_gr
operator|=
name|gr_dup
argument_list|(
operator|&
name|gr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line_copy
argument_list|)
expr_stmt|;
if|if
condition|(
name|gr
operator|.
name|gr_mem
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|gr
operator|.
name|gr_mem
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_gr
operator|)
return|;
block|}
end_function

end_unit

