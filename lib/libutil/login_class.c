begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1996 by  * Sean Eric Fagan<sef@kithrup.com>  * David Nugent<davidn@blaze.net.au>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, is permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice immediately at the beginning of the file, without modification,  *    this list of conditions, and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. This work was done expressly for inclusion into FreeBSD.  Other use  *    is permitted provided this notation is included.  * 4. Absolutely no warranty of function or purpose is made by the authors.  * 5. Modifications may be freely made to this file providing the above  *    conditions are met.  *  * High-level routines relating to use of the user capabilities database  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/mac.h>
end_include

begin_include
include|#
directive|include
file|<sys/rtprio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<login_cap.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_struct
specifier|static
struct|struct
name|login_res
block|{
specifier|const
name|char
modifier|*
name|what
decl_stmt|;
name|rlim_t
function_decl|(
modifier|*
name|who
function_decl|)
parameter_list|(
name|login_cap_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|rlim_t
parameter_list|,
name|rlim_t
parameter_list|)
function_decl|;
name|int
name|why
decl_stmt|;
block|}
name|resources
index|[]
init|=
block|{
block|{
literal|"cputime"
block|,
name|login_getcaptime
block|,
name|RLIMIT_CPU
block|}
block|,
block|{
literal|"filesize"
block|,
name|login_getcapsize
block|,
name|RLIMIT_FSIZE
block|}
block|,
block|{
literal|"datasize"
block|,
name|login_getcapsize
block|,
name|RLIMIT_DATA
block|}
block|,
block|{
literal|"stacksize"
block|,
name|login_getcapsize
block|,
name|RLIMIT_STACK
block|}
block|,
block|{
literal|"memoryuse"
block|,
name|login_getcapsize
block|,
name|RLIMIT_RSS
block|}
block|,
block|{
literal|"memorylocked"
block|,
name|login_getcapsize
block|,
name|RLIMIT_MEMLOCK
block|}
block|,
block|{
literal|"maxproc"
block|,
name|login_getcapnum
block|,
name|RLIMIT_NPROC
block|}
block|,
block|{
literal|"openfiles"
block|,
name|login_getcapnum
block|,
name|RLIMIT_NOFILE
block|}
block|,
block|{
literal|"coredumpsize"
block|,
name|login_getcapsize
block|,
name|RLIMIT_CORE
block|}
block|,
block|{
literal|"sbsize"
block|,
name|login_getcapsize
block|,
name|RLIMIT_SBSIZE
block|}
block|,
block|{
literal|"vmemoryuse"
block|,
name|login_getcapsize
block|,
name|RLIMIT_VMEM
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_function
name|void
name|setclassresources
parameter_list|(
name|login_cap_t
modifier|*
name|lc
parameter_list|)
block|{
name|struct
name|login_res
modifier|*
name|lr
decl_stmt|;
if|if
condition|(
name|lc
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|lr
operator|=
name|resources
init|;
name|lr
operator|->
name|what
operator|!=
name|NULL
condition|;
operator|++
name|lr
control|)
block|{
name|struct
name|rlimit
name|rlim
decl_stmt|;
comment|/* 	 * The login.conf file can have<limit>,<limit>-max, and 	 *<limit>-cur entries. 	 * What we do is get the current current- and maximum- limits. 	 * Then, we try to get an entry for<limit> from the capability, 	 * using the current and max limits we just got as the 	 * default/error values. 	 * *Then*, we try looking for<limit>-cur and<limit>-max, 	 * again using the appropriate values as the default/error 	 * conditions. 	 */
if|if
condition|(
name|getrlimit
argument_list|(
name|lr
operator|->
name|why
argument_list|,
operator|&
name|rlim
argument_list|)
operator|!=
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getting %s resource limit: %m"
argument_list|,
name|lr
operator|->
name|what
argument_list|)
expr_stmt|;
else|else
block|{
name|char
name|name_cur
index|[
literal|40
index|]
decl_stmt|;
name|char
name|name_max
index|[
literal|40
index|]
decl_stmt|;
name|rlim_t
name|rcur
init|=
name|rlim
operator|.
name|rlim_cur
decl_stmt|;
name|rlim_t
name|rmax
init|=
name|rlim
operator|.
name|rlim_max
decl_stmt|;
name|sprintf
argument_list|(
name|name_cur
argument_list|,
literal|"%s-cur"
argument_list|,
name|lr
operator|->
name|what
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name_max
argument_list|,
literal|"%s-max"
argument_list|,
name|lr
operator|->
name|what
argument_list|)
expr_stmt|;
name|rcur
operator|=
call|(
modifier|*
name|lr
operator|->
name|who
call|)
argument_list|(
name|lc
argument_list|,
name|lr
operator|->
name|what
argument_list|,
name|rcur
argument_list|,
name|rcur
argument_list|)
expr_stmt|;
name|rmax
operator|=
call|(
modifier|*
name|lr
operator|->
name|who
call|)
argument_list|(
name|lc
argument_list|,
name|lr
operator|->
name|what
argument_list|,
name|rmax
argument_list|,
name|rmax
argument_list|)
expr_stmt|;
name|rlim
operator|.
name|rlim_cur
operator|=
call|(
modifier|*
name|lr
operator|->
name|who
call|)
argument_list|(
name|lc
argument_list|,
name|name_cur
argument_list|,
name|rcur
argument_list|,
name|rcur
argument_list|)
expr_stmt|;
name|rlim
operator|.
name|rlim_max
operator|=
call|(
modifier|*
name|lr
operator|->
name|who
call|)
argument_list|(
name|lc
argument_list|,
name|name_max
argument_list|,
name|rmax
argument_list|,
name|rmax
argument_list|)
expr_stmt|;
if|if
condition|(
name|setrlimit
argument_list|(
name|lr
operator|->
name|why
argument_list|,
operator|&
name|rlim
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"set class '%s' resource limit %s: %m"
argument_list|,
name|lc
operator|->
name|lc_class
argument_list|,
name|lr
operator|->
name|what
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_struct
specifier|static
struct|struct
name|login_vars
block|{
specifier|const
name|char
modifier|*
name|tag
decl_stmt|;
specifier|const
name|char
modifier|*
name|var
decl_stmt|;
specifier|const
name|char
modifier|*
name|def
decl_stmt|;
name|int
name|overwrite
decl_stmt|;
block|}
name|pathvars
index|[]
init|=
block|{
block|{
literal|"path"
block|,
literal|"PATH"
block|,
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"cdpath"
block|,
literal|"CDPATH"
block|,
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"manpath"
block|,
literal|"MANPATH"
block|,
name|NULL
block|,
literal|1
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
struct|,
name|envars
index|[]
init|=
block|{
block|{
literal|"lang"
block|,
literal|"LANG"
block|,
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"charset"
block|,
literal|"MM_CHARSET"
block|,
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"timezone"
block|,
literal|"TZ"
block|,
name|NULL
block|,
literal|1
block|}
block|,
block|{
literal|"term"
block|,
literal|"TERM"
block|,
name|NULL
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|char
modifier|*
name|substvar
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|struct
name|passwd
modifier|*
name|pwd
parameter_list|,
name|int
name|hlen
parameter_list|,
name|int
name|pch
parameter_list|,
name|int
name|nlen
parameter_list|)
block|{
name|char
modifier|*
name|np
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|var
operator|!=
name|NULL
condition|)
block|{
name|int
name|tildes
init|=
literal|0
decl_stmt|;
name|int
name|dollas
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|pwd
operator|!=
name|NULL
condition|)
block|{
comment|/* Count the number of ~'s in var to substitute */
for|for
control|(
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|var
init|;
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'~'
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
operator|++
name|tildes
expr_stmt|;
comment|/* Count the number of $'s in var to substitute */
for|for
control|(
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|var
init|;
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'$'
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|p
operator|++
control|)
operator|++
name|dollas
expr_stmt|;
block|}
name|np
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|var
argument_list|)
operator|+
operator|(
name|dollas
operator|*
name|nlen
operator|)
operator|-
name|dollas
operator|+
operator|(
name|tildes
operator|*
operator|(
name|pch
operator|+
name|hlen
operator|)
operator|)
operator|-
name|tildes
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|strcpy
argument_list|(
name|np
argument_list|,
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * This loop does user username and homedir substitutions 		 * for unescaped $ (username) and ~ (homedir) 		 */
while|while
condition|(
operator|*
operator|(
name|p
operator|+=
name|strcspn
argument_list|(
name|p
argument_list|,
literal|"~$"
argument_list|)
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|int
name|l
init|=
name|strlen
argument_list|(
name|p
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|>
name|np
operator|&&
operator|*
operator|(
name|p
operator|-
literal|1
operator|)
operator|==
literal|'\\'
condition|)
comment|/* Escaped: */
name|memmove
argument_list|(
name|p
operator|-
literal|1
argument_list|,
name|p
argument_list|,
name|l
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Slide-out the backslash */
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'~'
condition|)
block|{
name|int
name|v
init|=
name|pch
operator|&&
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|!=
literal|'/'
decl_stmt|;
comment|/* Avoid double // */
name|memmove
argument_list|(
name|p
operator|+
name|hlen
operator|+
name|v
argument_list|,
name|p
operator|+
literal|1
argument_list|,
name|l
argument_list|)
expr_stmt|;
comment|/* Subst homedir */
name|memmove
argument_list|(
name|p
argument_list|,
name|pwd
operator|->
name|pw_dir
argument_list|,
name|hlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
condition|)
name|p
index|[
name|hlen
index|]
operator|=
literal|'/'
expr_stmt|;
name|p
operator|+=
name|hlen
operator|+
name|v
expr_stmt|;
block|}
else|else
comment|/* if (*p == '$') */
block|{
name|memmove
argument_list|(
name|p
operator|+
name|nlen
argument_list|,
name|p
operator|+
literal|1
argument_list|,
name|l
argument_list|)
expr_stmt|;
comment|/* Subst username */
name|memmove
argument_list|(
name|p
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
name|p
operator|+=
name|nlen
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|np
return|;
block|}
end_function

begin_function
name|void
name|setclassenvironment
parameter_list|(
name|login_cap_t
modifier|*
name|lc
parameter_list|,
specifier|const
name|struct
name|passwd
modifier|*
name|pwd
parameter_list|,
name|int
name|paths
parameter_list|)
block|{
name|struct
name|login_vars
modifier|*
name|vars
init|=
name|paths
condition|?
name|pathvars
else|:
name|envars
decl_stmt|;
name|int
name|hlen
init|=
name|pwd
condition|?
name|strlen
argument_list|(
name|pwd
operator|->
name|pw_dir
argument_list|)
else|:
literal|0
decl_stmt|;
name|int
name|nlen
init|=
name|pwd
condition|?
name|strlen
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|)
else|:
literal|0
decl_stmt|;
name|char
name|pch
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|hlen
operator|&&
name|pwd
operator|->
name|pw_dir
index|[
name|hlen
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
operator|++
name|pch
expr_stmt|;
while|while
condition|(
name|vars
operator|->
name|tag
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|var
init|=
name|paths
condition|?
name|login_getpath
argument_list|(
name|lc
argument_list|,
name|vars
operator|->
name|tag
argument_list|,
name|NULL
argument_list|)
else|:
name|login_getcapstr
argument_list|(
name|lc
argument_list|,
name|vars
operator|->
name|tag
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
name|char
modifier|*
name|np
init|=
name|substvar
argument_list|(
name|var
argument_list|,
name|pwd
argument_list|,
name|hlen
argument_list|,
name|pch
argument_list|,
name|nlen
argument_list|)
decl_stmt|;
if|if
condition|(
name|np
operator|!=
name|NULL
condition|)
block|{
name|setenv
argument_list|(
name|vars
operator|->
name|var
argument_list|,
name|np
argument_list|,
name|vars
operator|->
name|overwrite
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vars
operator|->
name|def
operator|!=
name|NULL
condition|)
block|{
name|setenv
argument_list|(
name|vars
operator|->
name|var
argument_list|,
name|vars
operator|->
name|def
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
operator|++
name|vars
expr_stmt|;
block|}
comment|/*      * If we're not processing paths, then see if there is a setenv list by      * which the admin and/or user may set an arbitrary set of env vars.      */
if|if
condition|(
operator|!
name|paths
condition|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|set_env
init|=
name|login_getcaplist
argument_list|(
name|lc
argument_list|,
literal|"setenv"
argument_list|,
literal|","
argument_list|)
decl_stmt|;
if|if
condition|(
name|set_env
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|*
name|set_env
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|p
init|=
name|strchr
argument_list|(
operator|*
name|set_env
argument_list|,
literal|'='
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
comment|/* Discard invalid entries */
name|char
modifier|*
name|np
decl_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|np
operator|=
name|substvar
argument_list|(
name|p
argument_list|,
name|pwd
argument_list|,
name|hlen
argument_list|,
name|pch
argument_list|,
name|nlen
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|setenv
argument_list|(
operator|*
name|set_env
argument_list|,
name|np
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
block|}
operator|++
name|set_env
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * setclasscontext()  *  * For the login class<class>, set various class context values  * (limits, mainly) to the values for that class.  Which values are  * set are controlled by<flags> -- see<login_class.h> for the  * possible values.  *  * setclasscontext() can only set resources, priority, and umask.  */
end_comment

begin_function
name|int
name|setclasscontext
parameter_list|(
specifier|const
name|char
modifier|*
name|classname
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|int
name|rc
decl_stmt|;
name|login_cap_t
modifier|*
name|lc
decl_stmt|;
name|lc
operator|=
name|login_getclassbyname
argument_list|(
name|classname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|flags
operator|&=
name|LOGIN_SETRESOURCES
operator||
name|LOGIN_SETPRIORITY
operator||
name|LOGIN_SETUMASK
operator||
name|LOGIN_SETPATH
expr_stmt|;
name|rc
operator|=
name|lc
condition|?
name|setusercontext
argument_list|(
name|lc
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|flags
argument_list|)
else|:
operator|-
literal|1
expr_stmt|;
name|login_close
argument_list|(
name|lc
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
end_function

begin_comment
comment|/*  * Private function which takes care of processing  */
end_comment

begin_function
specifier|static
name|mode_t
name|setlogincontext
parameter_list|(
name|login_cap_t
modifier|*
name|lc
parameter_list|,
specifier|const
name|struct
name|passwd
modifier|*
name|pwd
parameter_list|,
name|mode_t
name|mymask
parameter_list|,
name|unsigned
name|long
name|flags
parameter_list|)
block|{
if|if
condition|(
name|lc
condition|)
block|{
comment|/* Set resources */
if|if
condition|(
name|flags
operator|&
name|LOGIN_SETRESOURCES
condition|)
name|setclassresources
argument_list|(
name|lc
argument_list|)
expr_stmt|;
comment|/* See if there's a umask override */
if|if
condition|(
name|flags
operator|&
name|LOGIN_SETUMASK
condition|)
name|mymask
operator|=
operator|(
name|mode_t
operator|)
name|login_getcapnum
argument_list|(
name|lc
argument_list|,
literal|"umask"
argument_list|,
name|mymask
argument_list|,
name|mymask
argument_list|)
expr_stmt|;
comment|/* Set paths */
if|if
condition|(
name|flags
operator|&
name|LOGIN_SETPATH
condition|)
name|setclassenvironment
argument_list|(
name|lc
argument_list|,
name|pwd
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Set environment */
if|if
condition|(
name|flags
operator|&
name|LOGIN_SETENV
condition|)
name|setclassenvironment
argument_list|(
name|lc
argument_list|,
name|pwd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
name|mymask
return|;
block|}
end_function

begin_comment
comment|/*  * setusercontext()  *  * Given a login class<lc> and a user in<pwd>, with a uid<uid>,  * set the context as in setclasscontext().<flags> controls which  * values are set.  *  * The difference between setclasscontext() and setusercontext() is  * that the former sets things up for an already-existing process,  * while the latter sets things up from a root context.  Such as might  * be called from login(1).  *  */
end_comment

begin_function
name|int
name|setusercontext
parameter_list|(
name|login_cap_t
modifier|*
name|lc
parameter_list|,
specifier|const
name|struct
name|passwd
modifier|*
name|pwd
parameter_list|,
name|uid_t
name|uid
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|quad_t
name|p
decl_stmt|;
name|mode_t
name|mymask
decl_stmt|;
name|login_cap_t
modifier|*
name|llc
init|=
name|NULL
decl_stmt|;
name|struct
name|rtprio
name|rtp
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|lc
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|pwd
operator|!=
name|NULL
operator|&&
operator|(
name|lc
operator|=
name|login_getpwclass
argument_list|(
name|pwd
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|llc
operator|=
name|lc
expr_stmt|;
comment|/* free this when we're done */
block|}
if|if
condition|(
name|flags
operator|&
name|LOGIN_SETPATH
condition|)
name|pathvars
index|[
literal|0
index|]
operator|.
name|def
operator|=
name|uid
condition|?
name|_PATH_DEFPATH
else|:
name|_PATH_STDPATH
expr_stmt|;
comment|/* we need a passwd entry to set these */
if|if
condition|(
name|pwd
operator|==
name|NULL
condition|)
name|flags
operator|&=
operator|~
operator|(
name|LOGIN_SETGROUP
operator||
name|LOGIN_SETLOGIN
operator||
name|LOGIN_SETMAC
operator|)
expr_stmt|;
comment|/* Set the process priority */
if|if
condition|(
name|flags
operator|&
name|LOGIN_SETPRIORITY
condition|)
block|{
name|p
operator|=
name|login_getcapnum
argument_list|(
name|lc
argument_list|,
literal|"priority"
argument_list|,
name|LOGIN_DEFPRI
argument_list|,
name|LOGIN_DEFPRI
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|>
name|PRIO_MAX
condition|)
block|{
name|rtp
operator|.
name|type
operator|=
name|RTP_PRIO_IDLE
expr_stmt|;
name|rtp
operator|.
name|prio
operator|=
name|p
operator|-
name|PRIO_MAX
operator|-
literal|1
expr_stmt|;
name|p
operator|=
operator|(
name|rtp
operator|.
name|prio
operator|>
name|RTP_PRIO_MAX
operator|)
condition|?
literal|31
else|:
name|p
expr_stmt|;
if|if
condition|(
name|rtprio
argument_list|(
name|RTP_SET
argument_list|,
literal|0
argument_list|,
operator|&
name|rtp
argument_list|)
condition|)
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"rtprio '%s' (%s): %m"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
name|lc
condition|?
name|lc
operator|->
name|lc_class
else|:
name|LOGIN_DEFCLASS
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|<
name|PRIO_MIN
condition|)
block|{
name|rtp
operator|.
name|type
operator|=
name|RTP_PRIO_REALTIME
expr_stmt|;
name|rtp
operator|.
name|prio
operator|=
name|abs
argument_list|(
name|p
operator|-
name|PRIO_MIN
operator|+
name|RTP_PRIO_MAX
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|rtp
operator|.
name|prio
operator|>
name|RTP_PRIO_MAX
operator|)
condition|?
literal|1
else|:
name|p
expr_stmt|;
if|if
condition|(
name|rtprio
argument_list|(
name|RTP_SET
argument_list|,
literal|0
argument_list|,
operator|&
name|rtp
argument_list|)
condition|)
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"rtprio '%s' (%s): %m"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
name|lc
condition|?
name|lc
operator|->
name|lc_class
else|:
name|LOGIN_DEFCLASS
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|setpriority
argument_list|(
name|PRIO_PROCESS
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|p
argument_list|)
operator|!=
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"setpriority '%s' (%s): %m"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
name|lc
condition|?
name|lc
operator|->
name|lc_class
else|:
name|LOGIN_DEFCLASS
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Setup the user's group permissions */
if|if
condition|(
name|flags
operator|&
name|LOGIN_SETGROUP
condition|)
block|{
if|if
condition|(
name|setgid
argument_list|(
name|pwd
operator|->
name|pw_gid
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setgid(%lu): %m"
argument_list|,
operator|(
name|u_long
operator|)
name|pwd
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
name|login_close
argument_list|(
name|llc
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|initgroups
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|,
name|pwd
operator|->
name|pw_gid
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"initgroups(%s,%lu): %m"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
operator|(
name|u_long
operator|)
name|pwd
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
name|login_close
argument_list|(
name|llc
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
comment|/* Set up the user's MAC label. */
if|if
condition|(
operator|(
name|flags
operator|&
name|LOGIN_SETMAC
operator|)
operator|&&
name|mac_is_present
argument_list|(
name|NULL
argument_list|)
operator|==
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|label_string
decl_stmt|;
name|mac_t
name|label
decl_stmt|;
name|label_string
operator|=
name|login_getcapstr
argument_list|(
name|lc
argument_list|,
literal|"label"
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|label_string
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|mac_from_text
argument_list|(
operator|&
name|label
argument_list|,
name|label_string
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mac_from_text('%s') for %s: %m"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
name|label_string
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|mac_set_proc
argument_list|(
name|label
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
operator|=
name|errno
expr_stmt|;
else|else
name|error
operator|=
literal|0
expr_stmt|;
name|mac_free
argument_list|(
name|label
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"mac_set_proc('%s') for %s: %s"
argument_list|,
name|label_string
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|,
name|strerror
argument_list|(
name|error
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
comment|/* Set the sessions login */
if|if
condition|(
operator|(
name|flags
operator|&
name|LOGIN_SETLOGIN
operator|)
operator|&&
name|setlogin
argument_list|(
name|pwd
operator|->
name|pw_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setlogin(%s): %m"
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|login_close
argument_list|(
name|llc
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|mymask
operator|=
operator|(
name|flags
operator|&
name|LOGIN_SETUMASK
operator|)
condition|?
name|umask
argument_list|(
name|LOGIN_DEFUMASK
argument_list|)
else|:
literal|0
expr_stmt|;
name|mymask
operator|=
name|setlogincontext
argument_list|(
name|lc
argument_list|,
name|pwd
argument_list|,
name|mymask
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|login_close
argument_list|(
name|llc
argument_list|)
expr_stmt|;
comment|/* This needs to be done after anything that needs root privs */
if|if
condition|(
operator|(
name|flags
operator|&
name|LOGIN_SETUSER
operator|)
operator|&&
name|setuid
argument_list|(
name|uid
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"setuid(%lu): %m"
argument_list|,
operator|(
name|u_long
operator|)
name|uid
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* Paranoia again */
block|}
comment|/*      * Now, we repeat some of the above for the user's private entries      */
if|if
condition|(
operator|(
name|lc
operator|=
name|login_getuserclass
argument_list|(
name|pwd
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|mymask
operator|=
name|setlogincontext
argument_list|(
name|lc
argument_list|,
name|pwd
argument_list|,
name|mymask
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|login_close
argument_list|(
name|lc
argument_list|)
expr_stmt|;
block|}
comment|/* Finally, set any umask we've found */
if|if
condition|(
name|flags
operator|&
name|LOGIN_SETUMASK
condition|)
name|umask
argument_list|(
name|mymask
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

