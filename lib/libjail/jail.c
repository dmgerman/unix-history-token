begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009 James Gritton.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/jail.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"jail.h"
end_include

begin_define
define|#
directive|define
name|SJPARAM
value|"security.jail.param"
end_define

begin_define
define|#
directive|define
name|JPS_IN_ADDR
value|1
end_define

begin_define
define|#
directive|define
name|JPS_IN6_ADDR
value|2
end_define

begin_define
define|#
directive|define
name|ARRAY_SANITY
value|5
end_define

begin_define
define|#
directive|define
name|ARRAY_SLOP
value|5
end_define

begin_function_decl
specifier|static
name|int
name|jailparam_import_enum
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|values
parameter_list|,
name|int
name|nvalues
parameter_list|,
specifier|const
name|char
modifier|*
name|valstr
parameter_list|,
name|size_t
name|valsize
parameter_list|,
name|int
modifier|*
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|jailparam_type
parameter_list|(
name|struct
name|jailparam
modifier|*
name|jp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|noname
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|nononame
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|char
name|jail_errmsg
index|[
name|JAIL_ERRMSGLEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|bool_values
index|[]
init|=
block|{
literal|"false"
block|,
literal|"true"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|jailsys_values
index|[]
init|=
block|{
literal|"disable"
block|,
literal|"new"
block|,
literal|"inherit"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Import a null-terminated parameter list and set a jail with the flags  * and parameters.  */
end_comment

begin_function
name|int
name|jail_setv
parameter_list|(
name|int
name|flags
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|,
name|tap
decl_stmt|;
name|struct
name|jailparam
modifier|*
name|jp
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|value
decl_stmt|;
name|int
name|njp
decl_stmt|,
name|jid
decl_stmt|;
comment|/* Create the parameter list and import the parameters. */
name|va_start
argument_list|(
name|ap
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|va_copy
argument_list|(
name|tap
argument_list|,
name|ap
argument_list|)
expr_stmt|;
for|for
control|(
name|njp
operator|=
literal|0
init|;
name|va_arg
argument_list|(
name|tap
argument_list|,
name|char
operator|*
argument_list|)
operator|!=
name|NULL
condition|;
name|njp
operator|++
control|)
operator|(
name|void
operator|)
name|va_arg
argument_list|(
name|tap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|tap
argument_list|)
expr_stmt|;
name|jp
operator|=
name|alloca
argument_list|(
name|njp
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|jailparam
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|njp
operator|=
literal|0
init|;
operator|(
name|name
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|njp
operator|++
control|)
block|{
name|value
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|jailparam_init
argument_list|(
name|jp
operator|+
name|njp
argument_list|,
name|name
argument_list|)
operator|<
literal|0
operator|||
name|jailparam_import
argument_list|(
name|jp
operator|+
name|njp
argument_list|,
name|value
argument_list|)
operator|<
literal|0
condition|)
block|{
name|jailparam_free
argument_list|(
name|jp
argument_list|,
name|njp
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|jid
operator|=
name|jailparam_set
argument_list|(
name|jp
argument_list|,
name|njp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|jailparam_free
argument_list|(
name|jp
argument_list|,
name|njp
argument_list|)
expr_stmt|;
return|return
operator|(
name|jid
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read a null-terminated parameter list, get the referenced jail, and export  * the parameters to the list.  */
end_comment

begin_function
name|int
name|jail_getv
parameter_list|(
name|int
name|flags
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|,
name|tap
decl_stmt|;
name|struct
name|jailparam
modifier|*
name|jp
decl_stmt|,
modifier|*
name|jp_lastjid
decl_stmt|,
modifier|*
name|jp_jid
decl_stmt|,
modifier|*
name|jp_name
decl_stmt|,
modifier|*
name|jp_key
decl_stmt|;
name|char
modifier|*
name|valarg
decl_stmt|,
modifier|*
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|key_value
decl_stmt|,
modifier|*
name|lastjid_value
decl_stmt|,
modifier|*
name|jid_value
decl_stmt|,
modifier|*
name|name_value
decl_stmt|;
name|int
name|njp
decl_stmt|,
name|i
decl_stmt|,
name|jid
decl_stmt|;
comment|/* Create the parameter list and find the key. */
name|va_start
argument_list|(
name|ap
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|va_copy
argument_list|(
name|tap
argument_list|,
name|ap
argument_list|)
expr_stmt|;
for|for
control|(
name|njp
operator|=
literal|0
init|;
name|va_arg
argument_list|(
name|tap
argument_list|,
name|char
operator|*
argument_list|)
operator|!=
name|NULL
condition|;
name|njp
operator|++
control|)
operator|(
name|void
operator|)
name|va_arg
argument_list|(
name|tap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|tap
argument_list|)
expr_stmt|;
name|jp
operator|=
name|alloca
argument_list|(
name|njp
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|jailparam
argument_list|)
argument_list|)
expr_stmt|;
name|va_copy
argument_list|(
name|tap
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|jp_lastjid
operator|=
name|jp_jid
operator|=
name|jp_name
operator|=
name|NULL
expr_stmt|;
name|lastjid_value
operator|=
name|jid_value
operator|=
name|name_value
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|njp
operator|=
literal|0
init|;
operator|(
name|name
operator|=
name|va_arg
argument_list|(
name|tap
argument_list|,
name|char
operator|*
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|njp
operator|++
control|)
block|{
name|value
operator|=
name|va_arg
argument_list|(
name|tap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|jailparam_init
argument_list|(
name|jp
operator|+
name|njp
argument_list|,
name|name
argument_list|)
operator|<
literal|0
condition|)
block|{
name|va_end
argument_list|(
name|tap
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|jp
index|[
name|njp
index|]
operator|.
name|jp_name
argument_list|,
literal|"lastjid"
argument_list|)
condition|)
block|{
name|jp_lastjid
operator|=
name|jp
operator|+
name|njp
expr_stmt|;
name|lastjid_value
operator|=
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|jp
index|[
name|njp
index|]
operator|.
name|jp_name
argument_list|,
literal|"jid"
argument_list|)
condition|)
block|{
name|jp_jid
operator|=
name|jp
operator|+
name|njp
expr_stmt|;
name|jid_value
operator|=
name|value
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|jp
index|[
name|njp
index|]
operator|.
name|jp_name
argument_list|,
literal|"name"
argument_list|)
condition|)
block|{
name|jp_name
operator|=
name|jp
operator|+
name|njp
expr_stmt|;
name|name_value
operator|=
name|value
expr_stmt|;
block|}
block|}
name|va_end
argument_list|(
name|tap
argument_list|)
expr_stmt|;
comment|/* Import the key parameter. */
if|if
condition|(
name|jp_lastjid
operator|!=
name|NULL
condition|)
block|{
name|jp_key
operator|=
name|jp_lastjid
expr_stmt|;
name|key_value
operator|=
name|lastjid_value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|jp_jid
operator|!=
name|NULL
operator|&&
name|strtol
argument_list|(
name|jid_value
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|jp_key
operator|=
name|jp_jid
expr_stmt|;
name|key_value
operator|=
name|jid_value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|jp_name
operator|!=
name|NULL
condition|)
block|{
name|jp_key
operator|=
name|jp_name
expr_stmt|;
name|key_value
operator|=
name|name_value
expr_stmt|;
block|}
else|else
block|{
name|strlcpy
argument_list|(
name|jail_errmsg
argument_list|,
literal|"no jail specified"
argument_list|,
name|JAIL_ERRMSGLEN
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|jailparam_import
argument_list|(
name|jp_key
argument_list|,
name|key_value
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|error
goto|;
comment|/* Get the jail and export the parameters. */
name|jid
operator|=
name|jailparam_get
argument_list|(
name|jp
argument_list|,
name|njp
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|jid
operator|<
literal|0
condition|)
goto|goto
name|error
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|njp
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|valarg
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|jp
operator|+
name|i
operator|!=
name|jp_key
condition|)
block|{
comment|/* It's up to the caller to ensure there's room. */
if|if
condition|(
operator|(
name|jp
index|[
name|i
index|]
operator|.
name|jp_ctltype
operator|&
name|CTLTYPE
operator|)
operator|==
name|CTLTYPE_STRING
condition|)
name|strcpy
argument_list|(
name|valarg
argument_list|,
name|jp
index|[
name|i
index|]
operator|.
name|jp_value
argument_list|)
expr_stmt|;
else|else
block|{
name|value
operator|=
name|jailparam_export
argument_list|(
name|jp
operator|+
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
name|strcpy
argument_list|(
name|valarg
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|jailparam_free
argument_list|(
name|jp
argument_list|,
name|njp
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|jid
operator|)
return|;
name|error
label|:
name|jailparam_free
argument_list|(
name|jp
argument_list|,
name|njp
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return a list of all known parameters.  */
end_comment

begin_function
name|int
name|jailparam_all
parameter_list|(
name|struct
name|jailparam
modifier|*
modifier|*
name|jpp
parameter_list|)
block|{
name|struct
name|jailparam
modifier|*
name|jp
decl_stmt|;
name|size_t
name|mlen1
decl_stmt|,
name|mlen2
decl_stmt|,
name|buflen
decl_stmt|;
name|int
name|njp
decl_stmt|,
name|nlist
decl_stmt|;
name|int
name|mib1
index|[
name|CTL_MAXNAME
index|]
decl_stmt|,
name|mib2
index|[
name|CTL_MAXNAME
operator|-
literal|2
index|]
decl_stmt|;
name|char
name|buf
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|njp
operator|=
literal|0
expr_stmt|;
name|nlist
operator|=
literal|32
expr_stmt|;
name|jp
operator|=
name|malloc
argument_list|(
name|nlist
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|jp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|jp
operator|==
name|NULL
condition|)
block|{
name|strerror_r
argument_list|(
name|errno
argument_list|,
name|jail_errmsg
argument_list|,
name|JAIL_ERRMSGLEN
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mib1
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|mib1
index|[
literal|1
index|]
operator|=
literal|2
expr_stmt|;
name|mlen1
operator|=
name|CTL_MAXNAME
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|sysctlnametomib
argument_list|(
name|SJPARAM
argument_list|,
name|mib1
operator|+
literal|2
argument_list|,
operator|&
name|mlen1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|jail_errmsg
argument_list|,
name|JAIL_ERRMSGLEN
argument_list|,
literal|"sysctlnametomib("
name|SJPARAM
literal|"): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
for|for
control|(
init|;
condition|;
name|njp
operator|++
control|)
block|{
comment|/* Get the next parameter. */
name|mlen2
operator|=
sizeof|sizeof
argument_list|(
name|mib2
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib1
argument_list|,
name|mlen1
operator|+
literal|2
argument_list|,
name|mib2
argument_list|,
operator|&
name|mlen2
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|jail_errmsg
argument_list|,
name|JAIL_ERRMSGLEN
argument_list|,
literal|"sysctl(0.2): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|mib2
index|[
literal|0
index|]
operator|!=
name|mib1
index|[
literal|2
index|]
operator|||
name|mib2
index|[
literal|1
index|]
operator|!=
name|mib1
index|[
literal|3
index|]
operator|||
name|mib2
index|[
literal|2
index|]
operator|!=
name|mib1
index|[
literal|4
index|]
condition|)
break|break;
comment|/* Convert it to an ascii name. */
name|memcpy
argument_list|(
name|mib1
operator|+
literal|2
argument_list|,
name|mib2
argument_list|,
name|mlen2
argument_list|)
expr_stmt|;
name|mlen1
operator|=
name|mlen2
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|mib1
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|buflen
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib1
argument_list|,
name|mlen1
operator|+
literal|2
argument_list|,
name|buf
argument_list|,
operator|&
name|buflen
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|jail_errmsg
argument_list|,
name|JAIL_ERRMSGLEN
argument_list|,
literal|"sysctl(0.1): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|error
goto|;
block|}
if|if
condition|(
name|buf
index|[
name|buflen
operator|-
literal|2
index|]
operator|==
literal|'.'
condition|)
name|buf
index|[
name|buflen
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Add the parameter to the list */
if|if
condition|(
name|njp
operator|>=
name|nlist
condition|)
block|{
name|nlist
operator|*=
literal|2
expr_stmt|;
name|jp
operator|=
name|realloc
argument_list|(
name|jp
argument_list|,
name|nlist
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|jp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|jp
operator|==
name|NULL
condition|)
block|{
name|jailparam_free
argument_list|(
name|jp
argument_list|,
name|njp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|jailparam_init
argument_list|(
name|jp
operator|+
name|njp
argument_list|,
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|SJPARAM
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|error
goto|;
name|mib1
index|[
literal|1
index|]
operator|=
literal|2
expr_stmt|;
block|}
name|jp
operator|=
name|realloc
argument_list|(
name|jp
argument_list|,
name|njp
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|jp
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|jpp
operator|=
name|jp
expr_stmt|;
return|return
operator|(
name|njp
operator|)
return|;
name|error
label|:
name|jailparam_free
argument_list|(
name|jp
argument_list|,
name|njp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|jp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clear a jail parameter and copy in its name.  */
end_comment

begin_function
name|int
name|jailparam_init
parameter_list|(
name|struct
name|jailparam
modifier|*
name|jp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|memset
argument_list|(
name|jp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|jp
argument_list|)
argument_list|)
expr_stmt|;
name|jp
operator|->
name|jp_name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|jp
operator|->
name|jp_name
operator|==
name|NULL
condition|)
block|{
name|strerror_r
argument_list|(
name|errno
argument_list|,
name|jail_errmsg
argument_list|,
name|JAIL_ERRMSGLEN
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|jailparam_type
argument_list|(
name|jp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|jailparam_free
argument_list|(
name|jp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Put a name and value into a jail parameter element, converting the value  * to internal form.  */
end_comment

begin_function
name|int
name|jailparam_import
parameter_list|(
name|struct
name|jailparam
modifier|*
name|jp
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|tvalue
decl_stmt|;
specifier|const
name|char
modifier|*
name|avalue
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nval
decl_stmt|,
name|fw
decl_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|jp
operator|->
name|jp_ctltype
operator|&
name|CTLTYPE
operator|)
operator|==
name|CTLTYPE_STRING
condition|)
block|{
name|jp
operator|->
name|jp_value
operator|=
name|strdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|jp
operator|->
name|jp_value
operator|==
name|NULL
condition|)
block|{
name|strerror_r
argument_list|(
name|errno
argument_list|,
name|jail_errmsg
argument_list|,
name|JAIL_ERRMSGLEN
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|nval
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|jp
operator|->
name|jp_elemlen
condition|)
block|{
if|if
condition|(
name|value
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|value
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|value
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|jp
operator|->
name|jp_value
operator|=
name|strdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|jp
operator|->
name|jp_value
operator|==
name|NULL
condition|)
block|{
name|strerror_r
argument_list|(
name|errno
argument_list|,
name|jail_errmsg
argument_list|,
name|JAIL_ERRMSGLEN
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|jp
operator|->
name|jp_valuelen
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|p
operator|=
name|strchr
argument_list|(
name|value
argument_list|,
literal|','
argument_list|)
init|;
name|p
condition|;
name|p
operator|=
name|strchr
argument_list|(
name|p
operator|+
literal|1
argument_list|,
literal|','
argument_list|)
control|)
name|nval
operator|++
expr_stmt|;
name|jp
operator|->
name|jp_valuelen
operator|=
name|jp
operator|->
name|jp_elemlen
operator|*
name|nval
expr_stmt|;
block|}
name|jp
operator|->
name|jp_value
operator|=
name|malloc
argument_list|(
name|jp
operator|->
name|jp_valuelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|jp
operator|->
name|jp_value
operator|==
name|NULL
condition|)
block|{
name|strerror_r
argument_list|(
name|errno
argument_list|,
name|jail_errmsg
argument_list|,
name|JAIL_ERRMSGLEN
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|avalue
operator|=
name|value
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nval
condition|;
name|i
operator|++
control|)
block|{
name|fw
operator|=
name|nval
operator|==
literal|1
condition|?
name|strlen
argument_list|(
name|avalue
argument_list|)
else|:
name|strcspn
argument_list|(
name|avalue
argument_list|,
literal|","
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|jp
operator|->
name|jp_ctltype
operator|&
name|CTLTYPE
condition|)
block|{
case|case
name|CTLTYPE_INT
case|:
if|if
condition|(
name|jp
operator|->
name|jp_flags
operator|&
operator|(
name|JP_BOOL
operator||
name|JP_NOBOOL
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|jailparam_import_enum
argument_list|(
name|bool_values
argument_list|,
literal|2
argument_list|,
name|avalue
argument_list|,
name|fw
argument_list|,
operator|&
operator|(
operator|(
name|int
operator|*
operator|)
name|jp
operator|->
name|jp_value
operator|)
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|snprintf
argument_list|(
name|jail_errmsg
argument_list|,
name|JAIL_ERRMSGLEN
argument_list|,
literal|"%s: "
literal|"unknown boolean value \"%.*s\""
argument_list|,
name|jp
operator|->
name|jp_name
argument_list|,
name|fw
argument_list|,
name|avalue
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|error
goto|;
block|}
break|break;
block|}
if|if
condition|(
name|jp
operator|->
name|jp_flags
operator|&
name|JP_JAILSYS
condition|)
block|{
comment|/* 				 * Allow setting a jailsys parameter to "new" 				 * in a booleanesque fashion. 				 */
if|if
condition|(
name|value
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
operator|(
operator|(
name|int
operator|*
operator|)
name|jp
operator|->
name|jp_value
operator|)
index|[
name|i
index|]
operator|=
name|JAIL_SYS_NEW
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|jailparam_import_enum
argument_list|(
name|jailsys_values
argument_list|,
sizeof|sizeof
argument_list|(
name|jailsys_values
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|jailsys_values
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|avalue
argument_list|,
name|fw
argument_list|,
operator|&
operator|(
operator|(
name|int
operator|*
operator|)
name|jp
operator|->
name|jp_value
operator|)
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|snprintf
argument_list|(
name|jail_errmsg
argument_list|,
name|JAIL_ERRMSGLEN
argument_list|,
literal|"%s: "
literal|"unknown jailsys value \"%.*s\""
argument_list|,
name|jp
operator|->
name|jp_name
argument_list|,
name|fw
argument_list|,
name|avalue
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|error
goto|;
block|}
break|break;
block|}
operator|(
operator|(
name|int
operator|*
operator|)
name|jp
operator|->
name|jp_value
operator|)
index|[
name|i
index|]
operator|=
name|strtol
argument_list|(
name|avalue
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|integer_test
label|:
if|if
condition|(
name|ep
operator|!=
name|avalue
operator|+
name|fw
condition|)
block|{
name|snprintf
argument_list|(
name|jail_errmsg
argument_list|,
name|JAIL_ERRMSGLEN
argument_list|,
literal|"%s: non-integer value \"%.*s\""
argument_list|,
name|jp
operator|->
name|jp_name
argument_list|,
name|fw
argument_list|,
name|avalue
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|error
goto|;
block|}
break|break;
case|case
name|CTLTYPE_UINT
case|:
operator|(
operator|(
name|unsigned
operator|*
operator|)
name|jp
operator|->
name|jp_value
operator|)
index|[
name|i
index|]
operator|=
name|strtoul
argument_list|(
name|avalue
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
goto|goto
name|integer_test
goto|;
case|case
name|CTLTYPE_LONG
case|:
operator|(
operator|(
name|long
operator|*
operator|)
name|jp
operator|->
name|jp_value
operator|)
index|[
name|i
index|]
operator|=
name|strtol
argument_list|(
name|avalue
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
goto|goto
name|integer_test
goto|;
case|case
name|CTLTYPE_ULONG
case|:
operator|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|jp
operator|->
name|jp_value
operator|)
index|[
name|i
index|]
operator|=
name|strtoul
argument_list|(
name|avalue
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
goto|goto
name|integer_test
goto|;
case|case
name|CTLTYPE_S64
case|:
operator|(
operator|(
name|int64_t
operator|*
operator|)
name|jp
operator|->
name|jp_value
operator|)
index|[
name|i
index|]
operator|=
name|strtoimax
argument_list|(
name|avalue
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
goto|goto
name|integer_test
goto|;
case|case
name|CTLTYPE_U64
case|:
operator|(
operator|(
name|uint64_t
operator|*
operator|)
name|jp
operator|->
name|jp_value
operator|)
index|[
name|i
index|]
operator|=
name|strtoumax
argument_list|(
name|avalue
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
goto|goto
name|integer_test
goto|;
case|case
name|CTLTYPE_STRUCT
case|:
name|tvalue
operator|=
name|alloca
argument_list|(
name|fw
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|tvalue
argument_list|,
name|avalue
argument_list|,
name|fw
operator|+
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|jp
operator|->
name|jp_structtype
condition|)
block|{
case|case
name|JPS_IN_ADDR
case|:
if|if
condition|(
name|inet_pton
argument_list|(
name|AF_INET
argument_list|,
name|tvalue
argument_list|,
operator|&
operator|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|jp
operator|->
name|jp_value
operator|)
index|[
name|i
index|]
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|jail_errmsg
argument_list|,
name|JAIL_ERRMSGLEN
argument_list|,
literal|"%s: not an IPv4 address: %s"
argument_list|,
name|jp
operator|->
name|jp_name
argument_list|,
name|tvalue
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|error
goto|;
block|}
break|break;
case|case
name|JPS_IN6_ADDR
case|:
if|if
condition|(
name|inet_pton
argument_list|(
name|AF_INET6
argument_list|,
name|tvalue
argument_list|,
operator|&
operator|(
operator|(
expr|struct
name|in6_addr
operator|*
operator|)
name|jp
operator|->
name|jp_value
operator|)
index|[
name|i
index|]
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|snprintf
argument_list|(
name|jail_errmsg
argument_list|,
name|JAIL_ERRMSGLEN
argument_list|,
literal|"%s: not an IPv6 address: %s"
argument_list|,
name|jp
operator|->
name|jp_name
argument_list|,
name|tvalue
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|error
goto|;
block|}
break|break;
default|default:
goto|goto
name|unknown_type
goto|;
block|}
break|break;
default|default:
name|unknown_type
label|:
name|snprintf
argument_list|(
name|jail_errmsg
argument_list|,
name|JAIL_ERRMSGLEN
argument_list|,
literal|"unknown type for %s"
argument_list|,
name|jp
operator|->
name|jp_name
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|avalue
operator|+=
name|fw
operator|+
literal|1
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|free
argument_list|(
name|jp
operator|->
name|jp_value
argument_list|)
expr_stmt|;
name|jp
operator|->
name|jp_value
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|jailparam_import_enum
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|values
parameter_list|,
name|int
name|nvalues
parameter_list|,
specifier|const
name|char
modifier|*
name|valstr
parameter_list|,
name|size_t
name|valsize
parameter_list|,
name|int
modifier|*
name|value
parameter_list|)
block|{
name|char
modifier|*
name|ep
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nvalues
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|valsize
operator|==
name|strlen
argument_list|(
name|values
index|[
name|i
index|]
argument_list|)
operator|&&
operator|!
name|strncasecmp
argument_list|(
name|valstr
argument_list|,
name|values
index|[
name|i
index|]
argument_list|,
name|valsize
argument_list|)
condition|)
block|{
operator|*
name|value
operator|=
name|i
expr_stmt|;
return|return
literal|1
return|;
block|}
operator|*
name|value
operator|=
name|strtol
argument_list|(
name|valstr
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
return|return
operator|(
name|ep
operator|==
name|valstr
operator|+
name|valsize
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Put a name and value into a jail parameter element, copying the value  * but not altering it.  */
end_comment

begin_function
name|int
name|jailparam_import_raw
parameter_list|(
name|struct
name|jailparam
modifier|*
name|jp
parameter_list|,
name|void
modifier|*
name|value
parameter_list|,
name|size_t
name|valuelen
parameter_list|)
block|{
name|jp
operator|->
name|jp_value
operator|=
name|value
expr_stmt|;
name|jp
operator|->
name|jp_valuelen
operator|=
name|valuelen
expr_stmt|;
name|jp
operator|->
name|jp_flags
operator||=
name|JP_RAWVALUE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Run the jail_set and jail_get system calls on a parameter list.  */
end_comment

begin_function
name|int
name|jailparam_set
parameter_list|(
name|struct
name|jailparam
modifier|*
name|jp
parameter_list|,
name|unsigned
name|njp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|iovec
modifier|*
name|jiov
decl_stmt|;
name|char
modifier|*
name|nname
decl_stmt|;
name|int
name|i
decl_stmt|,
name|jid
decl_stmt|,
name|bool0
decl_stmt|;
name|unsigned
name|j
decl_stmt|;
name|jiov
operator|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|iovec
argument_list|)
operator|*
literal|2
operator|*
operator|(
name|njp
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|bool0
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|njp
condition|;
name|j
operator|++
control|)
block|{
name|jiov
index|[
name|i
index|]
operator|.
name|iov_base
operator|=
name|jp
index|[
name|j
index|]
operator|.
name|jp_name
expr_stmt|;
name|jiov
index|[
name|i
index|]
operator|.
name|iov_len
operator|=
name|strlen
argument_list|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_flags
operator|&
operator|(
name|JP_BOOL
operator||
name|JP_NOBOOL
operator|)
condition|)
block|{
comment|/* 			 * Set booleans without values.  If one has a value of 			 * zero, change it to (or from) its "no" counterpart. 			 */
name|jiov
index|[
name|i
index|]
operator|.
name|iov_base
operator|=
name|NULL
expr_stmt|;
name|jiov
index|[
name|i
index|]
operator|.
name|iov_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_value
operator|!=
name|NULL
operator|&&
name|jp
index|[
name|j
index|]
operator|.
name|jp_valuelen
operator|==
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|&&
operator|!
operator|*
operator|(
name|int
operator|*
operator|)
name|jp
index|[
name|j
index|]
operator|.
name|jp_value
condition|)
block|{
name|bool0
operator|=
literal|1
expr_stmt|;
name|nname
operator|=
name|jp
index|[
name|j
index|]
operator|.
name|jp_flags
operator|&
name|JP_BOOL
condition|?
name|noname
argument_list|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_name
argument_list|)
else|:
name|nononame
argument_list|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|nname
operator|==
name|NULL
condition|)
block|{
name|njp
operator|=
name|j
expr_stmt|;
name|jid
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|jiov
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|iov_base
operator|=
name|nname
expr_stmt|;
name|jiov
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|iov_len
operator|=
name|strlen
argument_list|(
name|nname
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * Try to fill in missing values with an empty string. 			 */
if|if
condition|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_value
operator|==
name|NULL
operator|&&
name|jp
index|[
name|j
index|]
operator|.
name|jp_valuelen
operator|>
literal|0
operator|&&
name|jailparam_import
argument_list|(
name|jp
operator|+
name|j
argument_list|,
literal|""
argument_list|)
operator|<
literal|0
condition|)
block|{
name|njp
operator|=
name|j
expr_stmt|;
name|jid
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|jiov
index|[
name|i
index|]
operator|.
name|iov_base
operator|=
name|jp
index|[
name|j
index|]
operator|.
name|jp_value
expr_stmt|;
name|jiov
index|[
name|i
index|]
operator|.
name|iov_len
operator|=
operator|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_ctltype
operator|&
name|CTLTYPE
operator|)
operator|==
name|CTLTYPE_STRING
condition|?
name|strlen
argument_list|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_value
argument_list|)
operator|+
literal|1
else|:
name|jp
index|[
name|j
index|]
operator|.
name|jp_valuelen
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
block|}
operator|*
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
operator|&
name|jiov
index|[
name|i
index|]
operator|.
name|iov_base
operator|=
literal|"errmsg"
expr_stmt|;
name|jiov
index|[
name|i
index|]
operator|.
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
literal|"errmsg"
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|jiov
index|[
name|i
index|]
operator|.
name|iov_base
operator|=
name|jail_errmsg
expr_stmt|;
name|jiov
index|[
name|i
index|]
operator|.
name|iov_len
operator|=
name|JAIL_ERRMSGLEN
expr_stmt|;
name|i
operator|++
expr_stmt|;
name|jail_errmsg
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|jid
operator|=
name|jail_set
argument_list|(
name|jiov
argument_list|,
name|i
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|jid
operator|<
literal|0
operator|&&
operator|!
name|jail_errmsg
index|[
literal|0
index|]
condition|)
name|snprintf
argument_list|(
name|jail_errmsg
argument_list|,
sizeof|sizeof
argument_list|(
name|jail_errmsg
argument_list|)
argument_list|,
literal|"jail_set: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|done
label|:
if|if
condition|(
name|bool0
condition|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|njp
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_flags
operator|&
operator|(
name|JP_BOOL
operator||
name|JP_NOBOOL
operator|)
operator|)
operator|&&
name|jp
index|[
name|j
index|]
operator|.
name|jp_value
operator|!=
name|NULL
operator|&&
name|jp
index|[
name|j
index|]
operator|.
name|jp_valuelen
operator|==
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|&&
operator|!
operator|*
operator|(
name|int
operator|*
operator|)
name|jp
index|[
name|j
index|]
operator|.
name|jp_value
condition|)
name|free
argument_list|(
name|jiov
index|[
name|j
operator|*
literal|2
index|]
operator|.
name|iov_base
argument_list|)
expr_stmt|;
return|return
operator|(
name|jid
operator|)
return|;
block|}
end_function

begin_function
name|int
name|jailparam_get
parameter_list|(
name|struct
name|jailparam
modifier|*
name|jp
parameter_list|,
name|unsigned
name|njp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|iovec
modifier|*
name|jiov
decl_stmt|;
name|struct
name|jailparam
modifier|*
name|jp_lastjid
decl_stmt|,
modifier|*
name|jp_jid
decl_stmt|,
modifier|*
name|jp_name
decl_stmt|,
modifier|*
name|jp_key
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ai
decl_stmt|,
name|ki
decl_stmt|,
name|jid
decl_stmt|,
name|arrays
decl_stmt|,
name|sanity
decl_stmt|;
name|unsigned
name|j
decl_stmt|;
comment|/* 	 * Get the types for all parameters. 	 * Find the key and any array parameters. 	 */
name|jiov
operator|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|iovec
argument_list|)
operator|*
literal|2
operator|*
operator|(
name|njp
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|jp_lastjid
operator|=
name|jp_jid
operator|=
name|jp_name
operator|=
name|NULL
expr_stmt|;
name|arrays
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ai
operator|=
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|njp
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_name
argument_list|,
literal|"lastjid"
argument_list|)
condition|)
name|jp_lastjid
operator|=
name|jp
operator|+
name|j
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_name
argument_list|,
literal|"jid"
argument_list|)
condition|)
name|jp_jid
operator|=
name|jp
operator|+
name|j
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_name
argument_list|,
literal|"name"
argument_list|)
condition|)
name|jp_name
operator|=
name|jp
operator|+
name|j
expr_stmt|;
elseif|else
if|if
condition|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_elemlen
operator|&&
operator|!
operator|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_flags
operator|&
name|JP_RAWVALUE
operator|)
condition|)
block|{
name|arrays
operator|=
literal|1
expr_stmt|;
name|jiov
index|[
name|ai
index|]
operator|.
name|iov_base
operator|=
name|jp
index|[
name|j
index|]
operator|.
name|jp_name
expr_stmt|;
name|jiov
index|[
name|ai
index|]
operator|.
name|iov_len
operator|=
name|strlen
argument_list|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ai
operator|++
expr_stmt|;
name|jiov
index|[
name|ai
index|]
operator|.
name|iov_base
operator|=
name|NULL
expr_stmt|;
name|jiov
index|[
name|ai
index|]
operator|.
name|iov_len
operator|=
literal|0
expr_stmt|;
name|ai
operator|++
expr_stmt|;
block|}
block|}
name|jp_key
operator|=
name|jp_lastjid
condition|?
name|jp_lastjid
else|:
name|jp_jid
operator|&&
name|jp_jid
operator|->
name|jp_valuelen
operator|==
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|&&
name|jp_jid
operator|->
name|jp_value
operator|&&
operator|*
operator|(
name|int
operator|*
operator|)
name|jp_jid
operator|->
name|jp_value
condition|?
name|jp_jid
else|:
name|jp_name
expr_stmt|;
if|if
condition|(
name|jp_key
operator|==
name|NULL
operator|||
name|jp_key
operator|->
name|jp_value
operator|==
name|NULL
condition|)
block|{
name|strlcpy
argument_list|(
name|jail_errmsg
argument_list|,
literal|"no jail specified"
argument_list|,
name|JAIL_ERRMSGLEN
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOENT
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ki
operator|=
name|ai
expr_stmt|;
name|jiov
index|[
name|ki
index|]
operator|.
name|iov_base
operator|=
name|jp_key
operator|->
name|jp_name
expr_stmt|;
name|jiov
index|[
name|ki
index|]
operator|.
name|iov_len
operator|=
name|strlen
argument_list|(
name|jp_key
operator|->
name|jp_name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ki
operator|++
expr_stmt|;
name|jiov
index|[
name|ki
index|]
operator|.
name|iov_base
operator|=
name|jp_key
operator|->
name|jp_value
expr_stmt|;
name|jiov
index|[
name|ki
index|]
operator|.
name|iov_len
operator|=
operator|(
name|jp_key
operator|->
name|jp_ctltype
operator|&
name|CTLTYPE
operator|)
operator|==
name|CTLTYPE_STRING
condition|?
name|strlen
argument_list|(
name|jp_key
operator|->
name|jp_value
argument_list|)
operator|+
literal|1
else|:
name|jp_key
operator|->
name|jp_valuelen
expr_stmt|;
name|ki
operator|++
expr_stmt|;
operator|*
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
operator|&
name|jiov
index|[
name|ki
index|]
operator|.
name|iov_base
operator|=
literal|"errmsg"
expr_stmt|;
name|jiov
index|[
name|ki
index|]
operator|.
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
literal|"errmsg"
argument_list|)
expr_stmt|;
name|ki
operator|++
expr_stmt|;
name|jiov
index|[
name|ki
index|]
operator|.
name|iov_base
operator|=
name|jail_errmsg
expr_stmt|;
name|jiov
index|[
name|ki
index|]
operator|.
name|iov_len
operator|=
name|JAIL_ERRMSGLEN
expr_stmt|;
name|ki
operator|++
expr_stmt|;
name|jail_errmsg
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|arrays
operator|&&
name|jail_get
argument_list|(
name|jiov
argument_list|,
name|ki
argument_list|,
name|flags
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|jail_errmsg
index|[
literal|0
index|]
condition|)
name|snprintf
argument_list|(
name|jail_errmsg
argument_list|,
sizeof|sizeof
argument_list|(
name|jail_errmsg
argument_list|)
argument_list|,
literal|"jail_get: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Allocate storage for all parameters. */
for|for
control|(
name|ai
operator|=
name|j
operator|=
literal|0
operator|,
name|i
operator|=
name|ki
init|;
name|j
operator|<
name|njp
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_elemlen
operator|&&
operator|!
operator|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_flags
operator|&
name|JP_RAWVALUE
operator|)
condition|)
block|{
name|ai
operator|++
expr_stmt|;
name|jiov
index|[
name|ai
index|]
operator|.
name|iov_len
operator|+=
name|jp
index|[
name|j
index|]
operator|.
name|jp_elemlen
operator|*
name|ARRAY_SLOP
expr_stmt|;
if|if
condition|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_valuelen
operator|>=
name|jiov
index|[
name|ai
index|]
operator|.
name|iov_len
condition|)
name|jiov
index|[
name|ai
index|]
operator|.
name|iov_len
operator|=
name|jp
index|[
name|j
index|]
operator|.
name|jp_valuelen
expr_stmt|;
else|else
block|{
name|jp
index|[
name|j
index|]
operator|.
name|jp_valuelen
operator|=
name|jiov
index|[
name|ai
index|]
operator|.
name|iov_len
expr_stmt|;
if|if
condition|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_value
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_value
argument_list|)
expr_stmt|;
name|jp
index|[
name|j
index|]
operator|.
name|jp_value
operator|=
name|malloc
argument_list|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_valuelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_value
operator|==
name|NULL
condition|)
block|{
name|strerror_r
argument_list|(
name|errno
argument_list|,
name|jail_errmsg
argument_list|,
name|JAIL_ERRMSGLEN
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|jiov
index|[
name|ai
index|]
operator|.
name|iov_base
operator|=
name|jp
index|[
name|j
index|]
operator|.
name|jp_value
expr_stmt|;
name|memset
argument_list|(
name|jiov
index|[
name|ai
index|]
operator|.
name|iov_base
argument_list|,
literal|0
argument_list|,
name|jiov
index|[
name|ai
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
name|ai
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|jp
operator|+
name|j
operator|!=
name|jp_key
condition|)
block|{
name|jiov
index|[
name|i
index|]
operator|.
name|iov_base
operator|=
name|jp
index|[
name|j
index|]
operator|.
name|jp_name
expr_stmt|;
name|jiov
index|[
name|i
index|]
operator|.
name|iov_len
operator|=
name|strlen
argument_list|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_value
operator|==
name|NULL
operator|&&
operator|!
operator|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_flags
operator|&
name|JP_RAWVALUE
operator|)
condition|)
block|{
name|jp
index|[
name|j
index|]
operator|.
name|jp_value
operator|=
name|malloc
argument_list|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_valuelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_value
operator|==
name|NULL
condition|)
block|{
name|strerror_r
argument_list|(
name|errno
argument_list|,
name|jail_errmsg
argument_list|,
name|JAIL_ERRMSGLEN
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|jiov
index|[
name|i
index|]
operator|.
name|iov_base
operator|=
name|jp
index|[
name|j
index|]
operator|.
name|jp_value
expr_stmt|;
name|jiov
index|[
name|i
index|]
operator|.
name|iov_len
operator|=
name|jp
index|[
name|j
index|]
operator|.
name|jp_valuelen
expr_stmt|;
name|memset
argument_list|(
name|jiov
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|,
literal|0
argument_list|,
name|jiov
index|[
name|i
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * Get the prison.  If there are array elements, retry a few times 	 * in case their sizes changed from under us. 	 */
for|for
control|(
name|sanity
operator|=
literal|0
init|;
condition|;
name|sanity
operator|++
control|)
block|{
name|jid
operator|=
name|jail_get
argument_list|(
name|jiov
argument_list|,
name|i
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|jid
operator|>=
literal|0
operator|||
operator|!
name|arrays
operator|||
name|sanity
operator|==
name|ARRAY_SANITY
operator|||
name|errno
operator|!=
name|EINVAL
operator|||
name|jail_errmsg
index|[
literal|0
index|]
condition|)
break|break;
for|for
control|(
name|ai
operator|=
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|njp
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_elemlen
operator|&&
operator|!
operator|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_flags
operator|&
name|JP_RAWVALUE
operator|)
condition|)
block|{
name|ai
operator|++
expr_stmt|;
name|jiov
index|[
name|ai
index|]
operator|.
name|iov_base
operator|=
name|NULL
expr_stmt|;
name|jiov
index|[
name|ai
index|]
operator|.
name|iov_len
operator|=
literal|0
expr_stmt|;
name|ai
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|jail_get
argument_list|(
name|jiov
argument_list|,
name|ki
argument_list|,
name|flags
argument_list|)
operator|<
literal|0
condition|)
break|break;
for|for
control|(
name|ai
operator|=
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|njp
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_elemlen
operator|&&
operator|!
operator|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_flags
operator|&
name|JP_RAWVALUE
operator|)
condition|)
block|{
name|ai
operator|++
expr_stmt|;
name|jiov
index|[
name|ai
index|]
operator|.
name|iov_len
operator|+=
name|jp
index|[
name|j
index|]
operator|.
name|jp_elemlen
operator|*
name|ARRAY_SLOP
expr_stmt|;
if|if
condition|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_valuelen
operator|>=
name|jiov
index|[
name|ai
index|]
operator|.
name|iov_len
condition|)
name|jiov
index|[
name|ai
index|]
operator|.
name|iov_len
operator|=
name|jp
index|[
name|j
index|]
operator|.
name|jp_valuelen
expr_stmt|;
else|else
block|{
name|jp
index|[
name|j
index|]
operator|.
name|jp_valuelen
operator|=
name|jiov
index|[
name|ai
index|]
operator|.
name|iov_len
expr_stmt|;
if|if
condition|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_value
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_value
argument_list|)
expr_stmt|;
name|jp
index|[
name|j
index|]
operator|.
name|jp_value
operator|=
name|malloc
argument_list|(
name|jiov
index|[
name|ai
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_value
operator|==
name|NULL
condition|)
block|{
name|strerror_r
argument_list|(
name|errno
argument_list|,
name|jail_errmsg
argument_list|,
name|JAIL_ERRMSGLEN
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|jiov
index|[
name|ai
index|]
operator|.
name|iov_base
operator|=
name|jp
index|[
name|j
index|]
operator|.
name|jp_value
expr_stmt|;
name|memset
argument_list|(
name|jiov
index|[
name|ai
index|]
operator|.
name|iov_base
argument_list|,
literal|0
argument_list|,
name|jiov
index|[
name|ai
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
name|ai
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|jid
operator|<
literal|0
operator|&&
operator|!
name|jail_errmsg
index|[
literal|0
index|]
condition|)
name|snprintf
argument_list|(
name|jail_errmsg
argument_list|,
sizeof|sizeof
argument_list|(
name|jail_errmsg
argument_list|)
argument_list|,
literal|"jail_get: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ai
operator|=
name|j
operator|=
literal|0
operator|,
name|i
operator|=
name|ki
init|;
name|j
operator|<
name|njp
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_elemlen
operator|&&
operator|!
operator|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_flags
operator|&
name|JP_RAWVALUE
operator|)
condition|)
block|{
name|ai
operator|++
expr_stmt|;
name|jp
index|[
name|j
index|]
operator|.
name|jp_valuelen
operator|=
name|jiov
index|[
name|ai
index|]
operator|.
name|iov_len
expr_stmt|;
name|ai
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|jp
operator|+
name|j
operator|!=
name|jp_key
condition|)
block|{
name|i
operator|++
expr_stmt|;
name|jp
index|[
name|j
index|]
operator|.
name|jp_valuelen
operator|=
name|jiov
index|[
name|i
index|]
operator|.
name|iov_len
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|jid
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a jail parameter's value to external form.  */
end_comment

begin_function
name|char
modifier|*
name|jailparam_export
parameter_list|(
name|struct
name|jailparam
modifier|*
name|jp
parameter_list|)
block|{
name|size_t
modifier|*
name|valuelens
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|,
modifier|*
name|tvalue
decl_stmt|,
modifier|*
modifier|*
name|values
decl_stmt|;
name|size_t
name|valuelen
decl_stmt|;
name|int
name|i
decl_stmt|,
name|nval
decl_stmt|,
name|ival
decl_stmt|;
name|char
name|valbuf
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|jp
operator|->
name|jp_ctltype
operator|&
name|CTLTYPE
operator|)
operator|==
name|CTLTYPE_STRING
condition|)
block|{
name|value
operator|=
name|strdup
argument_list|(
name|jp
operator|->
name|jp_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
name|strerror_r
argument_list|(
name|errno
argument_list|,
name|jail_errmsg
argument_list|,
name|JAIL_ERRMSGLEN
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
name|nval
operator|=
name|jp
operator|->
name|jp_elemlen
condition|?
name|jp
operator|->
name|jp_valuelen
operator|/
name|jp
operator|->
name|jp_elemlen
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|nval
operator|==
literal|0
condition|)
block|{
name|value
operator|=
name|strdup
argument_list|(
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
name|strerror_r
argument_list|(
name|errno
argument_list|,
name|jail_errmsg
argument_list|,
name|JAIL_ERRMSGLEN
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
name|values
operator|=
name|alloca
argument_list|(
name|nval
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|valuelens
operator|=
name|alloca
argument_list|(
name|nval
operator|*
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
expr_stmt|;
name|valuelen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nval
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|jp
operator|->
name|jp_ctltype
operator|&
name|CTLTYPE
condition|)
block|{
case|case
name|CTLTYPE_INT
case|:
name|ival
operator|=
operator|(
operator|(
name|int
operator|*
operator|)
name|jp
operator|->
name|jp_value
operator|)
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|jp
operator|->
name|jp_flags
operator|&
operator|(
name|JP_BOOL
operator||
name|JP_NOBOOL
operator|)
operator|)
operator|&&
operator|(
name|unsigned
operator|)
name|ival
operator|<
literal|2
condition|)
block|{
name|strlcpy
argument_list|(
name|valbuf
argument_list|,
name|bool_values
index|[
name|ival
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|valbuf
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|jp
operator|->
name|jp_flags
operator|&
name|JP_JAILSYS
operator|)
operator|&&
operator|(
name|unsigned
operator|)
name|ival
operator|<
sizeof|sizeof
argument_list|(
name|jailsys_values
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|jailsys_values
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|strlcpy
argument_list|(
name|valbuf
argument_list|,
name|jailsys_values
index|[
name|ival
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|valbuf
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|snprintf
argument_list|(
name|valbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|valbuf
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|ival
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTLTYPE_UINT
case|:
name|snprintf
argument_list|(
name|valbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|valbuf
argument_list|)
argument_list|,
literal|"%u"
argument_list|,
operator|(
operator|(
name|unsigned
operator|*
operator|)
name|jp
operator|->
name|jp_value
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTLTYPE_LONG
case|:
name|snprintf
argument_list|(
name|valbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|valbuf
argument_list|)
argument_list|,
literal|"%ld"
argument_list|,
operator|(
operator|(
name|long
operator|*
operator|)
name|jp
operator|->
name|jp_value
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTLTYPE_ULONG
case|:
name|snprintf
argument_list|(
name|valbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|valbuf
argument_list|)
argument_list|,
literal|"%lu"
argument_list|,
operator|(
operator|(
name|unsigned
name|long
operator|*
operator|)
name|jp
operator|->
name|jp_value
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTLTYPE_S64
case|:
name|snprintf
argument_list|(
name|valbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|valbuf
argument_list|)
argument_list|,
literal|"%jd"
argument_list|,
call|(
name|intmax_t
call|)
argument_list|(
operator|(
name|int64_t
operator|*
operator|)
name|jp
operator|->
name|jp_value
argument_list|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTLTYPE_U64
case|:
name|snprintf
argument_list|(
name|valbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|valbuf
argument_list|)
argument_list|,
literal|"%ju"
argument_list|,
call|(
name|uintmax_t
call|)
argument_list|(
operator|(
name|uint64_t
operator|*
operator|)
name|jp
operator|->
name|jp_value
argument_list|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTLTYPE_STRUCT
case|:
switch|switch
condition|(
name|jp
operator|->
name|jp_structtype
condition|)
block|{
case|case
name|JPS_IN_ADDR
case|:
if|if
condition|(
name|inet_ntop
argument_list|(
name|AF_INET
argument_list|,
operator|&
operator|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|jp
operator|->
name|jp_value
operator|)
index|[
name|i
index|]
argument_list|,
name|valbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|valbuf
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|strerror_r
argument_list|(
name|errno
argument_list|,
name|jail_errmsg
argument_list|,
name|JAIL_ERRMSGLEN
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
break|break;
case|case
name|JPS_IN6_ADDR
case|:
if|if
condition|(
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
operator|(
operator|(
expr|struct
name|in6_addr
operator|*
operator|)
name|jp
operator|->
name|jp_value
operator|)
index|[
name|i
index|]
argument_list|,
name|valbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|valbuf
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|strerror_r
argument_list|(
name|errno
argument_list|,
name|jail_errmsg
argument_list|,
name|JAIL_ERRMSGLEN
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
break|break;
default|default:
goto|goto
name|unknown_type
goto|;
block|}
break|break;
default|default:
name|unknown_type
label|:
name|snprintf
argument_list|(
name|jail_errmsg
argument_list|,
name|JAIL_ERRMSGLEN
argument_list|,
literal|"unknown type for %s"
argument_list|,
name|jp
operator|->
name|jp_name
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOENT
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|valuelens
index|[
name|i
index|]
operator|=
name|strlen
argument_list|(
name|valbuf
argument_list|)
operator|+
literal|1
expr_stmt|;
name|valuelen
operator|+=
name|valuelens
index|[
name|i
index|]
expr_stmt|;
name|values
index|[
name|i
index|]
operator|=
name|alloca
argument_list|(
name|valuelens
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|values
index|[
name|i
index|]
argument_list|,
name|valbuf
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|malloc
argument_list|(
name|valuelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
name|strerror_r
argument_list|(
name|errno
argument_list|,
name|jail_errmsg
argument_list|,
name|JAIL_ERRMSGLEN
argument_list|)
expr_stmt|;
else|else
block|{
name|tvalue
operator|=
name|value
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nval
condition|;
name|i
operator|++
control|)
block|{
name|strcpy
argument_list|(
name|tvalue
argument_list|,
name|values
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|nval
operator|-
literal|1
condition|)
block|{
name|tvalue
operator|+=
name|valuelens
index|[
name|i
index|]
expr_stmt|;
name|tvalue
index|[
operator|-
literal|1
index|]
operator|=
literal|','
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free the contents of a jail parameter list (but not the list itself).  */
end_comment

begin_function
name|void
name|jailparam_free
parameter_list|(
name|struct
name|jailparam
modifier|*
name|jp
parameter_list|,
name|unsigned
name|njp
parameter_list|)
block|{
name|unsigned
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|njp
condition|;
name|j
operator|++
control|)
block|{
name|free
argument_list|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_flags
operator|&
name|JP_RAWVALUE
operator|)
condition|)
name|free
argument_list|(
name|jp
index|[
name|j
index|]
operator|.
name|jp_value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Find a parameter's type and size from its MIB.  */
end_comment

begin_function
specifier|static
name|int
name|jailparam_type
parameter_list|(
name|struct
name|jailparam
modifier|*
name|jp
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|nname
decl_stmt|;
name|size_t
name|miblen
decl_stmt|,
name|desclen
decl_stmt|;
name|int
name|isarray
decl_stmt|;
struct|struct
block|{
name|int
name|i
decl_stmt|;
name|char
name|s
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
block|}
name|desc
struct|;
name|int
name|mib
index|[
name|CTL_MAXNAME
index|]
decl_stmt|;
comment|/* The "lastjid" parameter isn't real. */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|jp
operator|->
name|jp_name
argument_list|,
literal|"lastjid"
argument_list|)
condition|)
block|{
name|jp
operator|->
name|jp_valuelen
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|jp
operator|->
name|jp_ctltype
operator|=
name|CTLTYPE_INT
operator||
name|CTLFLAG_WR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Find the sysctl that describes the parameter. */
name|mib
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|mib
index|[
literal|1
index|]
operator|=
literal|3
expr_stmt|;
name|snprintf
argument_list|(
name|desc
operator|.
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
operator|.
name|s
argument_list|)
argument_list|,
name|SJPARAM
literal|".%s"
argument_list|,
name|jp
operator|->
name|jp_name
argument_list|)
expr_stmt|;
name|miblen
operator|=
sizeof|sizeof
argument_list|(
name|mib
argument_list|)
operator|-
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|2
argument_list|,
name|mib
operator|+
literal|2
argument_list|,
operator|&
name|miblen
argument_list|,
name|desc
operator|.
name|s
argument_list|,
name|strlen
argument_list|(
name|desc
operator|.
name|s
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|snprintf
argument_list|(
name|jail_errmsg
argument_list|,
name|JAIL_ERRMSGLEN
argument_list|,
literal|"sysctl(0.3.%s): %s"
argument_list|,
name|jp
operator|->
name|jp_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 		 * The parameter probably doesn't exist.  But it might be 		 * the "no" counterpart to a boolean. 		 */
name|nname
operator|=
name|nononame
argument_list|(
name|jp
operator|->
name|jp_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|nname
operator|!=
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|desc
operator|.
name|s
argument_list|,
sizeof|sizeof
argument_list|(
name|desc
operator|.
name|s
argument_list|)
argument_list|,
name|SJPARAM
literal|".%s"
argument_list|,
name|nname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|nname
argument_list|)
expr_stmt|;
name|miblen
operator|=
sizeof|sizeof
argument_list|(
name|mib
argument_list|)
operator|-
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|2
argument_list|,
name|mib
operator|+
literal|2
argument_list|,
operator|&
name|miblen
argument_list|,
name|desc
operator|.
name|s
argument_list|,
name|strlen
argument_list|(
name|desc
operator|.
name|s
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|mib
index|[
literal|1
index|]
operator|=
literal|4
expr_stmt|;
name|desclen
operator|=
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
operator|(
name|miblen
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|+
literal|2
argument_list|,
operator|&
name|desc
argument_list|,
operator|&
name|desclen
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|jail_errmsg
argument_list|,
name|JAIL_ERRMSGLEN
argument_list|,
literal|"sysctl(0.4.%s): %s"
argument_list|,
name|desc
operator|.
name|s
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|desc
operator|.
name|i
operator|&
name|CTLTYPE
operator|)
operator|==
name|CTLTYPE_INT
operator|&&
name|desc
operator|.
name|s
index|[
literal|0
index|]
operator|==
literal|'B'
condition|)
block|{
name|jp
operator|->
name|jp_ctltype
operator|=
name|desc
operator|.
name|i
expr_stmt|;
name|jp
operator|->
name|jp_flags
operator||=
name|JP_NOBOOL
expr_stmt|;
name|jp
operator|->
name|jp_valuelen
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
name|unknown_parameter
label|:
name|snprintf
argument_list|(
name|jail_errmsg
argument_list|,
name|JAIL_ERRMSGLEN
argument_list|,
literal|"unknown parameter: %s"
argument_list|,
name|jp
operator|->
name|jp_name
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOENT
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mib_desc
label|:
name|mib
index|[
literal|1
index|]
operator|=
literal|4
expr_stmt|;
name|desclen
operator|=
sizeof|sizeof
argument_list|(
name|desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
operator|(
name|miblen
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|+
literal|2
argument_list|,
operator|&
name|desc
argument_list|,
operator|&
name|desclen
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|jail_errmsg
argument_list|,
name|JAIL_ERRMSGLEN
argument_list|,
literal|"sysctl(0.4.%s): %s"
argument_list|,
name|jp
operator|->
name|jp_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* See if this is an array type. */
name|p
operator|=
name|strchr
argument_list|(
name|desc
operator|.
name|s
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
name|isarray
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|-
literal|2
operator|<
name|desc
operator|.
name|s
operator|||
name|strcmp
argument_list|(
name|p
operator|-
literal|2
argument_list|,
literal|",a"
argument_list|)
condition|)
name|isarray
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|isarray
operator|=
literal|1
expr_stmt|;
name|p
index|[
operator|-
literal|2
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Look for types we understand. */
name|jp
operator|->
name|jp_ctltype
operator|=
name|desc
operator|.
name|i
expr_stmt|;
switch|switch
condition|(
name|desc
operator|.
name|i
operator|&
name|CTLTYPE
condition|)
block|{
case|case
name|CTLTYPE_INT
case|:
if|if
condition|(
name|desc
operator|.
name|s
index|[
literal|0
index|]
operator|==
literal|'B'
condition|)
name|jp
operator|->
name|jp_flags
operator||=
name|JP_BOOL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|desc
operator|.
name|s
argument_list|,
literal|"E,jailsys"
argument_list|)
condition|)
name|jp
operator|->
name|jp_flags
operator||=
name|JP_JAILSYS
expr_stmt|;
case|case
name|CTLTYPE_UINT
case|:
name|jp
operator|->
name|jp_valuelen
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTLTYPE_LONG
case|:
case|case
name|CTLTYPE_ULONG
case|:
name|jp
operator|->
name|jp_valuelen
operator|=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTLTYPE_S64
case|:
case|case
name|CTLTYPE_U64
case|:
name|jp
operator|->
name|jp_valuelen
operator|=
sizeof|sizeof
argument_list|(
name|int64_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTLTYPE_STRING
case|:
name|desc
operator|.
name|s
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|desclen
operator|=
sizeof|sizeof
argument_list|(
name|desc
operator|.
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
operator|+
literal|2
argument_list|,
name|miblen
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|desc
operator|.
name|s
argument_list|,
operator|&
name|desclen
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|jail_errmsg
argument_list|,
name|JAIL_ERRMSGLEN
argument_list|,
literal|"sysctl("
name|SJPARAM
literal|".%s): %s"
argument_list|,
name|jp
operator|->
name|jp_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|jp
operator|->
name|jp_valuelen
operator|=
name|strtoul
argument_list|(
name|desc
operator|.
name|s
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
break|break;
case|case
name|CTLTYPE_STRUCT
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|desc
operator|.
name|s
argument_list|,
literal|"S,in_addr"
argument_list|)
condition|)
block|{
name|jp
operator|->
name|jp_structtype
operator|=
name|JPS_IN_ADDR
expr_stmt|;
name|jp
operator|->
name|jp_valuelen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|desc
operator|.
name|s
argument_list|,
literal|"S,in6_addr"
argument_list|)
condition|)
block|{
name|jp
operator|->
name|jp_structtype
operator|=
name|JPS_IN6_ADDR
expr_stmt|;
name|jp
operator|->
name|jp_valuelen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|desclen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
operator|+
literal|2
argument_list|,
name|miblen
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|jp
operator|->
name|jp_valuelen
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|jail_errmsg
argument_list|,
name|JAIL_ERRMSGLEN
argument_list|,
literal|"sysctl("
name|SJPARAM
literal|".%s): %s"
argument_list|,
name|jp
operator|->
name|jp_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
break|break;
case|case
name|CTLTYPE_NODE
case|:
comment|/* A node might be described by an empty-named child. */
name|mib
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|mib
index|[
operator|(
name|miblen
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|+
literal|2
index|]
operator|=
name|mib
index|[
operator|(
name|miblen
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|+
literal|1
index|]
operator|-
literal|1
expr_stmt|;
name|miblen
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|desclen
operator|=
sizeof|sizeof
argument_list|(
name|desc
operator|.
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
operator|(
name|miblen
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|)
operator|+
literal|2
argument_list|,
name|desc
operator|.
name|s
argument_list|,
operator|&
name|desclen
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|jail_errmsg
argument_list|,
name|JAIL_ERRMSGLEN
argument_list|,
literal|"sysctl(0.1): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|desc
operator|.
name|s
index|[
name|desclen
operator|-
literal|2
index|]
operator|!=
literal|'.'
condition|)
goto|goto
name|unknown_parameter
goto|;
goto|goto
name|mib_desc
goto|;
default|default:
name|snprintf
argument_list|(
name|jail_errmsg
argument_list|,
name|JAIL_ERRMSGLEN
argument_list|,
literal|"unknown type for %s"
argument_list|,
name|jp
operator|->
name|jp_name
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOENT
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|isarray
condition|)
block|{
name|jp
operator|->
name|jp_elemlen
operator|=
name|jp
operator|->
name|jp_valuelen
expr_stmt|;
name|jp
operator|->
name|jp_valuelen
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Change a boolean parameter name into its "no" counterpart or vice versa.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|noname
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|nname
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|nname
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|nname
operator|==
name|NULL
condition|)
block|{
name|strerror_r
argument_list|(
name|errno
argument_list|,
name|jail_errmsg
argument_list|,
name|JAIL_ERRMSGLEN
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|p
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|sprintf
argument_list|(
name|nname
argument_list|,
literal|"%.*s.no%s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|p
operator|-
name|name
argument_list|)
argument_list|,
name|name
argument_list|,
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|nname
argument_list|,
literal|"no%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|nname
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|nononame
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|nname
decl_stmt|;
name|p
operator|=
name|strrchr
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|p
condition|?
name|p
operator|+
literal|1
else|:
name|name
argument_list|,
literal|"no"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|snprintf
argument_list|(
name|jail_errmsg
argument_list|,
sizeof|sizeof
argument_list|(
name|jail_errmsg
argument_list|)
argument_list|,
literal|"mismatched boolean: %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|nname
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nname
operator|==
name|NULL
condition|)
block|{
name|strerror_r
argument_list|(
name|errno
argument_list|,
name|jail_errmsg
argument_list|,
name|JAIL_ERRMSGLEN
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|sprintf
argument_list|(
name|nname
argument_list|,
literal|"%.*s.%s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|p
operator|-
name|name
argument_list|)
argument_list|,
name|name
argument_list|,
name|p
operator|+
literal|3
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|nname
argument_list|,
name|name
operator|+
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
name|nname
operator|)
return|;
block|}
end_function

end_unit

