begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- cpu_model.c - Support for __cpu_model builtin  ------------*- C -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file is based on LLVM's lib/Support/Host.cpp.
end_comment

begin_comment
comment|//  It implements the operating system Host concept and builtin
end_comment

begin_comment
comment|//  __cpu_model for the compiler_rt library, for x86 only.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|__i386__
argument_list|)
operator|||
name|defined
argument_list|(
name|_M_IX86
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|__x86_64__
argument_list|)
operator|||
name|defined
argument_list|(
name|_M_X64
argument_list|)
operator|)
operator|&&
expr|\
operator|(
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__clang__
argument_list|)
operator|||
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|)
end_if

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_define
define|#
directive|define
name|bool
value|int
end_define

begin_define
define|#
directive|define
name|true
value|1
end_define

begin_define
define|#
directive|define
name|false
value|0
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|_MSC_VER
end_ifdef

begin_include
include|#
directive|include
file|<intrin.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__has_attribute
end_ifndef

begin_define
define|#
directive|define
name|__has_attribute
parameter_list|(
name|attr
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_enum
enum|enum
name|VendorSignatures
block|{
name|SIG_INTEL
init|=
literal|0x756e6547
comment|/* Genu */
block|,
name|SIG_AMD
init|=
literal|0x68747541
comment|/* Auth */
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ProcessorVendors
block|{
name|VENDOR_INTEL
init|=
literal|1
block|,
name|VENDOR_AMD
block|,
name|VENDOR_OTHER
block|,
name|VENDOR_MAX
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ProcessorTypes
block|{
name|INTEL_BONNELL
init|=
literal|1
block|,
name|INTEL_CORE2
block|,
name|INTEL_COREI7
block|,
name|AMDFAM10H
block|,
name|AMDFAM15H
block|,
name|INTEL_SILVERMONT
block|,
name|INTEL_KNL
block|,
name|AMD_BTVER1
block|,
name|AMD_BTVER2
block|,
name|AMDFAM17H
block|,
name|CPU_TYPE_MAX
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ProcessorSubtypes
block|{
name|INTEL_COREI7_NEHALEM
init|=
literal|1
block|,
name|INTEL_COREI7_WESTMERE
block|,
name|INTEL_COREI7_SANDYBRIDGE
block|,
name|AMDFAM10H_BARCELONA
block|,
name|AMDFAM10H_SHANGHAI
block|,
name|AMDFAM10H_ISTANBUL
block|,
name|AMDFAM15H_BDVER1
block|,
name|AMDFAM15H_BDVER2
block|,
name|AMDFAM15H_BDVER3
block|,
name|AMDFAM15H_BDVER4
block|,
name|AMDFAM17H_ZNVER1
block|,
name|INTEL_COREI7_IVYBRIDGE
block|,
name|INTEL_COREI7_HASWELL
block|,
name|INTEL_COREI7_BROADWELL
block|,
name|INTEL_COREI7_SKYLAKE
block|,
name|INTEL_COREI7_SKYLAKE_AVX512
block|,
name|CPU_SUBTYPE_MAX
block|}
enum|;
end_enum

begin_enum
enum|enum
name|ProcessorFeatures
block|{
name|FEATURE_CMOV
init|=
literal|0
block|,
name|FEATURE_MMX
block|,
name|FEATURE_POPCNT
block|,
name|FEATURE_SSE
block|,
name|FEATURE_SSE2
block|,
name|FEATURE_SSE3
block|,
name|FEATURE_SSSE3
block|,
name|FEATURE_SSE4_1
block|,
name|FEATURE_SSE4_2
block|,
name|FEATURE_AVX
block|,
name|FEATURE_AVX2
block|,
name|FEATURE_SSE4_A
block|,
name|FEATURE_FMA4
block|,
name|FEATURE_XOP
block|,
name|FEATURE_FMA
block|,
name|FEATURE_AVX512F
block|,
name|FEATURE_BMI
block|,
name|FEATURE_BMI2
block|,
name|FEATURE_AES
block|,
name|FEATURE_PCLMUL
block|,
name|FEATURE_AVX512VL
block|,
name|FEATURE_AVX512BW
block|,
name|FEATURE_AVX512DQ
block|,
name|FEATURE_AVX512CD
block|,
name|FEATURE_AVX512ER
block|,
name|FEATURE_AVX512PF
block|,
name|FEATURE_AVX512VBMI
block|,
name|FEATURE_AVX512IFMA
block|,
name|FEATURE_AVX5124VNNIW
block|,
name|FEATURE_AVX5124FMAPS
block|,
name|FEATURE_AVX512VPOPCNTDQ
block|}
enum|;
end_enum

begin_comment
comment|// The check below for i386 was copied from clang's cpuid.h (__get_cpuid_max).
end_comment

begin_comment
comment|// Check motivated by bug reports for OpenSSL crashing on CPUs without CPUID
end_comment

begin_comment
comment|// support. Consequently, for i386, the presence of CPUID is checked first
end_comment

begin_comment
comment|// via the corresponding eflags bit.
end_comment

begin_function
specifier|static
name|bool
name|isCpuIdSupported
parameter_list|()
block|{
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__clang__
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
name|int
name|__cpuid_supported
decl_stmt|;
asm|__asm__("  pushfl\n"           "  popl   %%eax\n"           "  movl   %%eax,%%ecx\n"           "  xorl   $0x00200000,%%eax\n"           "  pushl  %%eax\n"           "  popfl\n"           "  pushfl\n"           "  popl   %%eax\n"           "  movl   $0,%0\n"           "  cmpl   %%eax,%%ecx\n"           "  je     1f\n"           "  movl   $1,%0\n"           "1:"           : "=r"(__cpuid_supported)           :           : "eax", "ecx");
if|if
condition|(
operator|!
name|__cpuid_supported
condition|)
return|return
name|false
return|;
endif|#
directive|endif
return|return
name|true
return|;
endif|#
directive|endif
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|// This code is copied from lib/Support/Host.cpp.
end_comment

begin_comment
comment|// Changes to either file should be mirrored in the other.
end_comment

begin_comment
comment|/// getX86CpuIDAndInfo - Execute the specified cpuid and return the 4 values in
end_comment

begin_comment
comment|/// the specified arguments.  If we can't run cpuid on the host, return true.
end_comment

begin_function
specifier|static
name|bool
name|getX86CpuIDAndInfo
parameter_list|(
name|unsigned
name|value
parameter_list|,
name|unsigned
modifier|*
name|rEAX
parameter_list|,
name|unsigned
modifier|*
name|rEBX
parameter_list|,
name|unsigned
modifier|*
name|rECX
parameter_list|,
name|unsigned
modifier|*
name|rEDX
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__clang__
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|__x86_64__
argument_list|)
comment|// gcc doesn't know cpuid would clobber ebx/rbx. Preserve it manually.
comment|// FIXME: should we save this for Clang?
asm|__asm__("movq\t%%rbx, %%rsi\n\t"           "cpuid\n\t"           "xchgq\t%%rbx, %%rsi\n\t"           : "=a"(*rEAX), "=S"(*rEBX), "=c"(*rECX), "=d"(*rEDX)           : "a"(value));
return|return
name|false
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|__i386__
argument_list|)
asm|__asm__("movl\t%%ebx, %%esi\n\t"           "cpuid\n\t"           "xchgl\t%%ebx, %%esi\n\t"           : "=a"(*rEAX), "=S"(*rEBX), "=c"(*rECX), "=d"(*rEDX)           : "a"(value));
return|return
name|false
return|;
else|#
directive|else
return|return
name|true
return|;
endif|#
directive|endif
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
comment|// The MSVC intrinsic is portable across x86 and x64.
name|int
name|registers
index|[
literal|4
index|]
decl_stmt|;
name|__cpuid
argument_list|(
name|registers
argument_list|,
name|value
argument_list|)
expr_stmt|;
operator|*
name|rEAX
operator|=
name|registers
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|rEBX
operator|=
name|registers
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|rECX
operator|=
name|registers
index|[
literal|2
index|]
expr_stmt|;
operator|*
name|rEDX
operator|=
name|registers
index|[
literal|3
index|]
expr_stmt|;
return|return
name|false
return|;
else|#
directive|else
return|return
name|true
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/// getX86CpuIDAndInfoEx - Execute the specified cpuid with subleaf and return
end_comment

begin_comment
comment|/// the 4 values in the specified arguments.  If we can't run cpuid on the host,
end_comment

begin_comment
comment|/// return true.
end_comment

begin_function
specifier|static
name|bool
name|getX86CpuIDAndInfoEx
parameter_list|(
name|unsigned
name|value
parameter_list|,
name|unsigned
name|subleaf
parameter_list|,
name|unsigned
modifier|*
name|rEAX
parameter_list|,
name|unsigned
modifier|*
name|rEBX
parameter_list|,
name|unsigned
modifier|*
name|rECX
parameter_list|,
name|unsigned
modifier|*
name|rEDX
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__clang__
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|__x86_64__
argument_list|)
comment|// gcc doesn't know cpuid would clobber ebx/rbx. Preserve it manually.
comment|// FIXME: should we save this for Clang?
asm|__asm__("movq\t%%rbx, %%rsi\n\t"           "cpuid\n\t"           "xchgq\t%%rbx, %%rsi\n\t"           : "=a"(*rEAX), "=S"(*rEBX), "=c"(*rECX), "=d"(*rEDX)           : "a"(value), "c"(subleaf));
return|return
name|false
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|__i386__
argument_list|)
asm|__asm__("movl\t%%ebx, %%esi\n\t"           "cpuid\n\t"           "xchgl\t%%ebx, %%esi\n\t"           : "=a"(*rEAX), "=S"(*rEBX), "=c"(*rECX), "=d"(*rEDX)           : "a"(value), "c"(subleaf));
return|return
name|false
return|;
else|#
directive|else
return|return
name|true
return|;
endif|#
directive|endif
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
name|int
name|registers
index|[
literal|4
index|]
decl_stmt|;
name|__cpuidex
argument_list|(
name|registers
argument_list|,
name|value
argument_list|,
name|subleaf
argument_list|)
expr_stmt|;
operator|*
name|rEAX
operator|=
name|registers
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|rEBX
operator|=
name|registers
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|rECX
operator|=
name|registers
index|[
literal|2
index|]
expr_stmt|;
operator|*
name|rEDX
operator|=
name|registers
index|[
literal|3
index|]
expr_stmt|;
return|return
name|false
return|;
else|#
directive|else
return|return
name|true
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|// Read control register 0 (XCR0). Used to detect features such as AVX.
end_comment

begin_function
specifier|static
name|bool
name|getX86XCR0
parameter_list|(
name|unsigned
modifier|*
name|rEAX
parameter_list|,
name|unsigned
modifier|*
name|rEDX
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__clang__
argument_list|)
comment|// Check xgetbv; this uses a .byte sequence instead of the instruction
comment|// directly because older assemblers do not include support for xgetbv and
comment|// there is no easy way to conditionally compile based on the assembler used.
asm|__asm__(".byte 0x0f, 0x01, 0xd0" : "=a"(*rEAX), "=d"(*rEDX) : "c"(0));
return|return
name|false
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_FULL_VER
argument_list|)
operator|&&
name|defined
argument_list|(
name|_XCR_XFEATURE_ENABLED_MASK
argument_list|)
name|unsigned
name|long
name|long
name|Result
init|=
name|_xgetbv
argument_list|(
name|_XCR_XFEATURE_ENABLED_MASK
argument_list|)
decl_stmt|;
operator|*
name|rEAX
operator|=
name|Result
expr_stmt|;
operator|*
name|rEDX
operator|=
name|Result
operator|>>
literal|32
expr_stmt|;
return|return
name|false
return|;
else|#
directive|else
return|return
name|true
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|detectX86FamilyModel
parameter_list|(
name|unsigned
name|EAX
parameter_list|,
name|unsigned
modifier|*
name|Family
parameter_list|,
name|unsigned
modifier|*
name|Model
parameter_list|)
block|{
operator|*
name|Family
operator|=
operator|(
name|EAX
operator|>>
literal|8
operator|)
operator|&
literal|0xf
expr_stmt|;
comment|// Bits 8 - 11
operator|*
name|Model
operator|=
operator|(
name|EAX
operator|>>
literal|4
operator|)
operator|&
literal|0xf
expr_stmt|;
comment|// Bits 4 - 7
if|if
condition|(
operator|*
name|Family
operator|==
literal|6
operator|||
operator|*
name|Family
operator|==
literal|0xf
condition|)
block|{
if|if
condition|(
operator|*
name|Family
operator|==
literal|0xf
condition|)
comment|// Examine extended family ID if family ID is F.
operator|*
name|Family
operator|+=
operator|(
name|EAX
operator|>>
literal|20
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|// Bits 20 - 27
comment|// Examine extended model ID if family ID is 6 or F.
operator|*
name|Model
operator|+=
operator|(
operator|(
name|EAX
operator|>>
literal|16
operator|)
operator|&
literal|0xf
operator|)
operator|<<
literal|4
expr_stmt|;
comment|// Bits 16 - 19
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|getIntelProcessorTypeAndSubtype
parameter_list|(
name|unsigned
name|Family
parameter_list|,
name|unsigned
name|Model
parameter_list|,
name|unsigned
name|Brand_id
parameter_list|,
name|unsigned
name|Features
parameter_list|,
name|unsigned
modifier|*
name|Type
parameter_list|,
name|unsigned
modifier|*
name|Subtype
parameter_list|)
block|{
if|if
condition|(
name|Brand_id
operator|!=
literal|0
condition|)
return|return;
switch|switch
condition|(
name|Family
condition|)
block|{
case|case
literal|6
case|:
switch|switch
condition|(
name|Model
condition|)
block|{
case|case
literal|0x0f
case|:
comment|// Intel Core 2 Duo processor, Intel Core 2 Duo mobile
comment|// processor, Intel Core 2 Quad processor, Intel Core 2 Quad
comment|// mobile processor, Intel Core 2 Extreme processor, Intel
comment|// Pentium Dual-Core processor, Intel Xeon processor, model
comment|// 0Fh. All processors are manufactured using the 65 nm process.
case|case
literal|0x16
case|:
comment|// Intel Celeron processor model 16h. All processors are
comment|// manufactured using the 65 nm process
case|case
literal|0x17
case|:
comment|// Intel Core 2 Extreme processor, Intel Xeon processor, model
comment|// 17h. All processors are manufactured using the 45 nm process.
comment|//
comment|// 45nm: Penryn , Wolfdale, Yorkfield (XE)
case|case
literal|0x1d
case|:
comment|// Intel Xeon processor MP. All processors are manufactured using
comment|// the 45 nm process.
operator|*
name|Type
operator|=
name|INTEL_CORE2
expr_stmt|;
comment|// "penryn"
break|break;
case|case
literal|0x1a
case|:
comment|// Intel Core i7 processor and Intel Xeon processor. All
comment|// processors are manufactured using the 45 nm process.
case|case
literal|0x1e
case|:
comment|// Intel(R) Core(TM) i7 CPU         870  @ 2.93GHz.
comment|// As found in a Summer 2010 model iMac.
case|case
literal|0x1f
case|:
case|case
literal|0x2e
case|:
comment|// Nehalem EX
operator|*
name|Type
operator|=
name|INTEL_COREI7
expr_stmt|;
comment|// "nehalem"
operator|*
name|Subtype
operator|=
name|INTEL_COREI7_NEHALEM
expr_stmt|;
break|break;
case|case
literal|0x25
case|:
comment|// Intel Core i7, laptop version.
case|case
literal|0x2c
case|:
comment|// Intel Core i7 processor and Intel Xeon processor. All
comment|// processors are manufactured using the 32 nm process.
case|case
literal|0x2f
case|:
comment|// Westmere EX
operator|*
name|Type
operator|=
name|INTEL_COREI7
expr_stmt|;
comment|// "westmere"
operator|*
name|Subtype
operator|=
name|INTEL_COREI7_WESTMERE
expr_stmt|;
break|break;
case|case
literal|0x2a
case|:
comment|// Intel Core i7 processor. All processors are manufactured
comment|// using the 32 nm process.
case|case
literal|0x2d
case|:
operator|*
name|Type
operator|=
name|INTEL_COREI7
expr_stmt|;
comment|//"sandybridge"
operator|*
name|Subtype
operator|=
name|INTEL_COREI7_SANDYBRIDGE
expr_stmt|;
break|break;
case|case
literal|0x3a
case|:
case|case
literal|0x3e
case|:
comment|// Ivy Bridge EP
operator|*
name|Type
operator|=
name|INTEL_COREI7
expr_stmt|;
comment|// "ivybridge"
operator|*
name|Subtype
operator|=
name|INTEL_COREI7_IVYBRIDGE
expr_stmt|;
break|break;
comment|// Haswell:
case|case
literal|0x3c
case|:
case|case
literal|0x3f
case|:
case|case
literal|0x45
case|:
case|case
literal|0x46
case|:
operator|*
name|Type
operator|=
name|INTEL_COREI7
expr_stmt|;
comment|// "haswell"
operator|*
name|Subtype
operator|=
name|INTEL_COREI7_HASWELL
expr_stmt|;
break|break;
comment|// Broadwell:
case|case
literal|0x3d
case|:
case|case
literal|0x47
case|:
case|case
literal|0x4f
case|:
case|case
literal|0x56
case|:
operator|*
name|Type
operator|=
name|INTEL_COREI7
expr_stmt|;
comment|// "broadwell"
operator|*
name|Subtype
operator|=
name|INTEL_COREI7_BROADWELL
expr_stmt|;
break|break;
comment|// Skylake:
case|case
literal|0x4e
case|:
comment|// Skylake mobile
case|case
literal|0x5e
case|:
comment|// Skylake desktop
case|case
literal|0x8e
case|:
comment|// Kaby Lake mobile
case|case
literal|0x9e
case|:
comment|// Kaby Lake desktop
operator|*
name|Type
operator|=
name|INTEL_COREI7
expr_stmt|;
comment|// "skylake"
operator|*
name|Subtype
operator|=
name|INTEL_COREI7_SKYLAKE
expr_stmt|;
break|break;
comment|// Skylake Xeon:
case|case
literal|0x55
case|:
operator|*
name|Type
operator|=
name|INTEL_COREI7
expr_stmt|;
operator|*
name|Subtype
operator|=
name|INTEL_COREI7_SKYLAKE_AVX512
expr_stmt|;
comment|// "skylake-avx512"
break|break;
case|case
literal|0x1c
case|:
comment|// Most 45 nm Intel Atom processors
case|case
literal|0x26
case|:
comment|// 45 nm Atom Lincroft
case|case
literal|0x27
case|:
comment|// 32 nm Atom Medfield
case|case
literal|0x35
case|:
comment|// 32 nm Atom Midview
case|case
literal|0x36
case|:
comment|// 32 nm Atom Midview
operator|*
name|Type
operator|=
name|INTEL_BONNELL
expr_stmt|;
break|break;
comment|// "bonnell"
comment|// Atom Silvermont codes from the Intel software optimization guide.
case|case
literal|0x37
case|:
case|case
literal|0x4a
case|:
case|case
literal|0x4d
case|:
case|case
literal|0x5a
case|:
case|case
literal|0x5d
case|:
case|case
literal|0x4c
case|:
comment|// really airmont
operator|*
name|Type
operator|=
name|INTEL_SILVERMONT
expr_stmt|;
break|break;
comment|// "silvermont"
case|case
literal|0x57
case|:
operator|*
name|Type
operator|=
name|INTEL_KNL
expr_stmt|;
comment|// knl
break|break;
default|default:
comment|// Unknown family 6 CPU.
break|break;
break|break;
block|}
default|default:
break|break;
comment|// Unknown.
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|getAMDProcessorTypeAndSubtype
parameter_list|(
name|unsigned
name|Family
parameter_list|,
name|unsigned
name|Model
parameter_list|,
name|unsigned
name|Features
parameter_list|,
name|unsigned
modifier|*
name|Type
parameter_list|,
name|unsigned
modifier|*
name|Subtype
parameter_list|)
block|{
comment|// FIXME: this poorly matches the generated SubtargetFeatureKV table.  There
comment|// appears to be no way to generate the wide variety of AMD-specific targets
comment|// from the information returned from CPUID.
switch|switch
condition|(
name|Family
condition|)
block|{
case|case
literal|16
case|:
operator|*
name|Type
operator|=
name|AMDFAM10H
expr_stmt|;
comment|// "amdfam10"
switch|switch
condition|(
name|Model
condition|)
block|{
case|case
literal|2
case|:
operator|*
name|Subtype
operator|=
name|AMDFAM10H_BARCELONA
expr_stmt|;
break|break;
case|case
literal|4
case|:
operator|*
name|Subtype
operator|=
name|AMDFAM10H_SHANGHAI
expr_stmt|;
break|break;
case|case
literal|8
case|:
operator|*
name|Subtype
operator|=
name|AMDFAM10H_ISTANBUL
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|20
case|:
operator|*
name|Type
operator|=
name|AMD_BTVER1
expr_stmt|;
break|break;
comment|// "btver1";
case|case
literal|21
case|:
operator|*
name|Type
operator|=
name|AMDFAM15H
expr_stmt|;
if|if
condition|(
name|Model
operator|>=
literal|0x60
operator|&&
name|Model
operator|<=
literal|0x7f
condition|)
block|{
operator|*
name|Subtype
operator|=
name|AMDFAM15H_BDVER4
expr_stmt|;
break|break;
comment|// "bdver4"; 60h-7Fh: Excavator
block|}
if|if
condition|(
name|Model
operator|>=
literal|0x30
operator|&&
name|Model
operator|<=
literal|0x3f
condition|)
block|{
operator|*
name|Subtype
operator|=
name|AMDFAM15H_BDVER3
expr_stmt|;
break|break;
comment|// "bdver3"; 30h-3Fh: Steamroller
block|}
if|if
condition|(
name|Model
operator|>=
literal|0x10
operator|&&
name|Model
operator|<=
literal|0x1f
condition|)
block|{
operator|*
name|Subtype
operator|=
name|AMDFAM15H_BDVER2
expr_stmt|;
break|break;
comment|// "bdver2"; 10h-1Fh: Piledriver
block|}
if|if
condition|(
name|Model
operator|<=
literal|0x0f
condition|)
block|{
operator|*
name|Subtype
operator|=
name|AMDFAM15H_BDVER1
expr_stmt|;
break|break;
comment|// "bdver1"; 00h-0Fh: Bulldozer
block|}
break|break;
case|case
literal|22
case|:
operator|*
name|Type
operator|=
name|AMD_BTVER2
expr_stmt|;
break|break;
comment|// "btver2"
case|case
literal|23
case|:
operator|*
name|Type
operator|=
name|AMDFAM17H
expr_stmt|;
operator|*
name|Subtype
operator|=
name|AMDFAM17H_ZNVER1
expr_stmt|;
break|break;
default|default:
break|break;
comment|// "generic"
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|getAvailableFeatures
parameter_list|(
name|unsigned
name|ECX
parameter_list|,
name|unsigned
name|EDX
parameter_list|,
name|unsigned
name|MaxLeaf
parameter_list|,
name|unsigned
modifier|*
name|FeaturesOut
parameter_list|)
block|{
name|unsigned
name|Features
init|=
literal|0
decl_stmt|;
name|unsigned
name|EAX
decl_stmt|,
name|EBX
decl_stmt|;
if|if
condition|(
operator|(
name|EDX
operator|>>
literal|15
operator|)
operator|&
literal|1
condition|)
name|Features
operator||=
literal|1
operator|<<
name|FEATURE_CMOV
expr_stmt|;
if|if
condition|(
operator|(
name|EDX
operator|>>
literal|23
operator|)
operator|&
literal|1
condition|)
name|Features
operator||=
literal|1
operator|<<
name|FEATURE_MMX
expr_stmt|;
if|if
condition|(
operator|(
name|EDX
operator|>>
literal|25
operator|)
operator|&
literal|1
condition|)
name|Features
operator||=
literal|1
operator|<<
name|FEATURE_SSE
expr_stmt|;
if|if
condition|(
operator|(
name|EDX
operator|>>
literal|26
operator|)
operator|&
literal|1
condition|)
name|Features
operator||=
literal|1
operator|<<
name|FEATURE_SSE2
expr_stmt|;
if|if
condition|(
operator|(
name|ECX
operator|>>
literal|0
operator|)
operator|&
literal|1
condition|)
name|Features
operator||=
literal|1
operator|<<
name|FEATURE_SSE3
expr_stmt|;
if|if
condition|(
operator|(
name|ECX
operator|>>
literal|1
operator|)
operator|&
literal|1
condition|)
name|Features
operator||=
literal|1
operator|<<
name|FEATURE_PCLMUL
expr_stmt|;
if|if
condition|(
operator|(
name|ECX
operator|>>
literal|9
operator|)
operator|&
literal|1
condition|)
name|Features
operator||=
literal|1
operator|<<
name|FEATURE_SSSE3
expr_stmt|;
if|if
condition|(
operator|(
name|ECX
operator|>>
literal|12
operator|)
operator|&
literal|1
condition|)
name|Features
operator||=
literal|1
operator|<<
name|FEATURE_FMA
expr_stmt|;
if|if
condition|(
operator|(
name|ECX
operator|>>
literal|19
operator|)
operator|&
literal|1
condition|)
name|Features
operator||=
literal|1
operator|<<
name|FEATURE_SSE4_1
expr_stmt|;
if|if
condition|(
operator|(
name|ECX
operator|>>
literal|20
operator|)
operator|&
literal|1
condition|)
name|Features
operator||=
literal|1
operator|<<
name|FEATURE_SSE4_2
expr_stmt|;
if|if
condition|(
operator|(
name|ECX
operator|>>
literal|23
operator|)
operator|&
literal|1
condition|)
name|Features
operator||=
literal|1
operator|<<
name|FEATURE_POPCNT
expr_stmt|;
if|if
condition|(
operator|(
name|ECX
operator|>>
literal|25
operator|)
operator|&
literal|1
condition|)
name|Features
operator||=
literal|1
operator|<<
name|FEATURE_AES
expr_stmt|;
comment|// If CPUID indicates support for XSAVE, XRESTORE and AVX, and XGETBV
comment|// indicates that the AVX registers will be saved and restored on context
comment|// switch, then we have full AVX support.
specifier|const
name|unsigned
name|AVXBits
init|=
operator|(
literal|1
operator|<<
literal|27
operator|)
operator||
operator|(
literal|1
operator|<<
literal|28
operator|)
decl_stmt|;
name|bool
name|HasAVX
init|=
operator|(
operator|(
name|ECX
operator|&
name|AVXBits
operator|)
operator|==
name|AVXBits
operator|)
operator|&&
operator|!
name|getX86XCR0
argument_list|(
operator|&
name|EAX
argument_list|,
operator|&
name|EDX
argument_list|)
operator|&&
operator|(
operator|(
name|EAX
operator|&
literal|0x6
operator|)
operator|==
literal|0x6
operator|)
decl_stmt|;
name|bool
name|HasAVX512Save
init|=
name|HasAVX
operator|&&
operator|(
operator|(
name|EAX
operator|&
literal|0xe0
operator|)
operator|==
literal|0xe0
operator|)
decl_stmt|;
if|if
condition|(
name|HasAVX
condition|)
name|Features
operator||=
literal|1
operator|<<
name|FEATURE_AVX
expr_stmt|;
name|bool
name|HasLeaf7
init|=
name|MaxLeaf
operator|>=
literal|0x7
operator|&&
operator|!
name|getX86CpuIDAndInfoEx
argument_list|(
literal|0x7
argument_list|,
literal|0x0
argument_list|,
operator|&
name|EAX
argument_list|,
operator|&
name|EBX
argument_list|,
operator|&
name|ECX
argument_list|,
operator|&
name|EDX
argument_list|)
decl_stmt|;
if|if
condition|(
name|HasLeaf7
operator|&&
operator|(
operator|(
name|EBX
operator|>>
literal|3
operator|)
operator|&
literal|1
operator|)
condition|)
name|Features
operator||=
literal|1
operator|<<
name|FEATURE_BMI
expr_stmt|;
if|if
condition|(
name|HasLeaf7
operator|&&
operator|(
operator|(
name|EBX
operator|>>
literal|5
operator|)
operator|&
literal|1
operator|)
operator|&&
name|HasAVX
condition|)
name|Features
operator||=
literal|1
operator|<<
name|FEATURE_AVX2
expr_stmt|;
if|if
condition|(
name|HasLeaf7
operator|&&
operator|(
operator|(
name|EBX
operator|>>
literal|9
operator|)
operator|&
literal|1
operator|)
condition|)
name|Features
operator||=
literal|1
operator|<<
name|FEATURE_BMI2
expr_stmt|;
if|if
condition|(
name|HasLeaf7
operator|&&
operator|(
operator|(
name|EBX
operator|>>
literal|16
operator|)
operator|&
literal|1
operator|)
operator|&&
name|HasAVX512Save
condition|)
name|Features
operator||=
literal|1
operator|<<
name|FEATURE_AVX512F
expr_stmt|;
if|if
condition|(
name|HasLeaf7
operator|&&
operator|(
operator|(
name|EBX
operator|>>
literal|17
operator|)
operator|&
literal|1
operator|)
operator|&&
name|HasAVX512Save
condition|)
name|Features
operator||=
literal|1
operator|<<
name|FEATURE_AVX512DQ
expr_stmt|;
if|if
condition|(
name|HasLeaf7
operator|&&
operator|(
operator|(
name|EBX
operator|>>
literal|21
operator|)
operator|&
literal|1
operator|)
operator|&&
name|HasAVX512Save
condition|)
name|Features
operator||=
literal|1
operator|<<
name|FEATURE_AVX512IFMA
expr_stmt|;
if|if
condition|(
name|HasLeaf7
operator|&&
operator|(
operator|(
name|EBX
operator|>>
literal|26
operator|)
operator|&
literal|1
operator|)
operator|&&
name|HasAVX512Save
condition|)
name|Features
operator||=
literal|1
operator|<<
name|FEATURE_AVX512PF
expr_stmt|;
if|if
condition|(
name|HasLeaf7
operator|&&
operator|(
operator|(
name|EBX
operator|>>
literal|27
operator|)
operator|&
literal|1
operator|)
operator|&&
name|HasAVX512Save
condition|)
name|Features
operator||=
literal|1
operator|<<
name|FEATURE_AVX512ER
expr_stmt|;
if|if
condition|(
name|HasLeaf7
operator|&&
operator|(
operator|(
name|EBX
operator|>>
literal|28
operator|)
operator|&
literal|1
operator|)
operator|&&
name|HasAVX512Save
condition|)
name|Features
operator||=
literal|1
operator|<<
name|FEATURE_AVX512CD
expr_stmt|;
if|if
condition|(
name|HasLeaf7
operator|&&
operator|(
operator|(
name|EBX
operator|>>
literal|30
operator|)
operator|&
literal|1
operator|)
operator|&&
name|HasAVX512Save
condition|)
name|Features
operator||=
literal|1
operator|<<
name|FEATURE_AVX512BW
expr_stmt|;
if|if
condition|(
name|HasLeaf7
operator|&&
operator|(
operator|(
name|EBX
operator|>>
literal|31
operator|)
operator|&
literal|1
operator|)
operator|&&
name|HasAVX512Save
condition|)
name|Features
operator||=
literal|1
operator|<<
name|FEATURE_AVX512VL
expr_stmt|;
if|if
condition|(
name|HasLeaf7
operator|&&
operator|(
operator|(
name|ECX
operator|>>
literal|1
operator|)
operator|&
literal|1
operator|)
operator|&&
name|HasAVX512Save
condition|)
name|Features
operator||=
literal|1
operator|<<
name|FEATURE_AVX512VBMI
expr_stmt|;
if|if
condition|(
name|HasLeaf7
operator|&&
operator|(
operator|(
name|ECX
operator|>>
literal|14
operator|)
operator|&
literal|1
operator|)
operator|&&
name|HasAVX512Save
condition|)
name|Features
operator||=
literal|1
operator|<<
name|FEATURE_AVX512VPOPCNTDQ
expr_stmt|;
if|if
condition|(
name|HasLeaf7
operator|&&
operator|(
operator|(
name|EDX
operator|>>
literal|2
operator|)
operator|&
literal|1
operator|)
operator|&&
name|HasAVX512Save
condition|)
name|Features
operator||=
literal|1
operator|<<
name|FEATURE_AVX5124VNNIW
expr_stmt|;
if|if
condition|(
name|HasLeaf7
operator|&&
operator|(
operator|(
name|EDX
operator|>>
literal|3
operator|)
operator|&
literal|1
operator|)
operator|&&
name|HasAVX512Save
condition|)
name|Features
operator||=
literal|1
operator|<<
name|FEATURE_AVX5124FMAPS
expr_stmt|;
name|unsigned
name|MaxExtLevel
decl_stmt|;
name|getX86CpuIDAndInfo
argument_list|(
literal|0x80000000
argument_list|,
operator|&
name|MaxExtLevel
argument_list|,
operator|&
name|EBX
argument_list|,
operator|&
name|ECX
argument_list|,
operator|&
name|EDX
argument_list|)
expr_stmt|;
name|bool
name|HasExtLeaf1
init|=
name|MaxExtLevel
operator|>=
literal|0x80000001
operator|&&
operator|!
name|getX86CpuIDAndInfo
argument_list|(
literal|0x80000001
argument_list|,
operator|&
name|EAX
argument_list|,
operator|&
name|EBX
argument_list|,
operator|&
name|ECX
argument_list|,
operator|&
name|EDX
argument_list|)
decl_stmt|;
if|if
condition|(
name|HasExtLeaf1
operator|&&
operator|(
operator|(
name|ECX
operator|>>
literal|6
operator|)
operator|&
literal|1
operator|)
condition|)
name|Features
operator||=
literal|1
operator|<<
name|FEATURE_SSE4_A
expr_stmt|;
if|if
condition|(
name|HasExtLeaf1
operator|&&
operator|(
operator|(
name|ECX
operator|>>
literal|11
operator|)
operator|&
literal|1
operator|)
condition|)
name|Features
operator||=
literal|1
operator|<<
name|FEATURE_XOP
expr_stmt|;
if|if
condition|(
name|HasExtLeaf1
operator|&&
operator|(
operator|(
name|ECX
operator|>>
literal|16
operator|)
operator|&
literal|1
operator|)
condition|)
name|Features
operator||=
literal|1
operator|<<
name|FEATURE_FMA4
expr_stmt|;
operator|*
name|FeaturesOut
operator|=
name|Features
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_INIT_PRIORITY
argument_list|)
end_if

begin_define
define|#
directive|define
name|CONSTRUCTOR_ATTRIBUTE
value|__attribute__((__constructor__ 101))
end_define

begin_elif
elif|#
directive|elif
name|__has_attribute
argument_list|(
name|__constructor__
argument_list|)
end_elif

begin_define
define|#
directive|define
name|CONSTRUCTOR_ATTRIBUTE
value|__attribute__((__constructor__))
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|// FIXME: For MSVC, we should make a function pointer global in .CRT$X?? so that
end_comment

begin_comment
comment|// this runs during initialization.
end_comment

begin_define
define|#
directive|define
name|CONSTRUCTOR_ATTRIBUTE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|__cpu_indicator_init
argument_list|(
name|void
argument_list|)
name|CONSTRUCTOR_ATTRIBUTE
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|__processor_model
block|{
name|unsigned
name|int
name|__cpu_vendor
decl_stmt|;
name|unsigned
name|int
name|__cpu_type
decl_stmt|;
name|unsigned
name|int
name|__cpu_subtype
decl_stmt|;
name|unsigned
name|int
name|__cpu_features
index|[
literal|1
index|]
decl_stmt|;
block|}
name|__cpu_model
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
block|{
literal|0
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* A constructor function that is sets __cpu_model and __cpu_features with    the right values.  This needs to run only once.  This constructor is    given the highest priority and it should run before constructors without    the priority set.  However, it still runs after ifunc initializers and    needs to be called explicitly there.  */
end_comment

begin_function
name|int
name|CONSTRUCTOR_ATTRIBUTE
name|__cpu_indicator_init
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|EAX
decl_stmt|,
name|EBX
decl_stmt|,
name|ECX
decl_stmt|,
name|EDX
decl_stmt|;
name|unsigned
name|MaxLeaf
init|=
literal|5
decl_stmt|;
name|unsigned
name|Vendor
decl_stmt|;
name|unsigned
name|Model
decl_stmt|,
name|Family
decl_stmt|,
name|Brand_id
decl_stmt|;
name|unsigned
name|Features
init|=
literal|0
decl_stmt|;
comment|/* This function needs to run just once.  */
if|if
condition|(
name|__cpu_model
operator|.
name|__cpu_vendor
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|isCpuIdSupported
argument_list|()
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Assume cpuid insn present. Run in level 0 to get vendor id. */
if|if
condition|(
name|getX86CpuIDAndInfo
argument_list|(
literal|0
argument_list|,
operator|&
name|MaxLeaf
argument_list|,
operator|&
name|Vendor
argument_list|,
operator|&
name|ECX
argument_list|,
operator|&
name|EDX
argument_list|)
operator|||
name|MaxLeaf
operator|<
literal|1
condition|)
block|{
name|__cpu_model
operator|.
name|__cpu_vendor
operator|=
name|VENDOR_OTHER
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|getX86CpuIDAndInfo
argument_list|(
literal|1
argument_list|,
operator|&
name|EAX
argument_list|,
operator|&
name|EBX
argument_list|,
operator|&
name|ECX
argument_list|,
operator|&
name|EDX
argument_list|)
expr_stmt|;
name|detectX86FamilyModel
argument_list|(
name|EAX
argument_list|,
operator|&
name|Family
argument_list|,
operator|&
name|Model
argument_list|)
expr_stmt|;
name|Brand_id
operator|=
name|EBX
operator|&
literal|0xff
expr_stmt|;
comment|/* Find available features. */
name|getAvailableFeatures
argument_list|(
name|ECX
argument_list|,
name|EDX
argument_list|,
name|MaxLeaf
argument_list|,
operator|&
name|Features
argument_list|)
expr_stmt|;
name|__cpu_model
operator|.
name|__cpu_features
index|[
literal|0
index|]
operator|=
name|Features
expr_stmt|;
if|if
condition|(
name|Vendor
operator|==
name|SIG_INTEL
condition|)
block|{
comment|/* Get CPU type.  */
name|getIntelProcessorTypeAndSubtype
argument_list|(
name|Family
argument_list|,
name|Model
argument_list|,
name|Brand_id
argument_list|,
name|Features
argument_list|,
operator|&
operator|(
name|__cpu_model
operator|.
name|__cpu_type
operator|)
argument_list|,
operator|&
operator|(
name|__cpu_model
operator|.
name|__cpu_subtype
operator|)
argument_list|)
expr_stmt|;
name|__cpu_model
operator|.
name|__cpu_vendor
operator|=
name|VENDOR_INTEL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Vendor
operator|==
name|SIG_AMD
condition|)
block|{
comment|/* Get CPU type.  */
name|getAMDProcessorTypeAndSubtype
argument_list|(
name|Family
argument_list|,
name|Model
argument_list|,
name|Features
argument_list|,
operator|&
operator|(
name|__cpu_model
operator|.
name|__cpu_type
operator|)
argument_list|,
operator|&
operator|(
name|__cpu_model
operator|.
name|__cpu_subtype
operator|)
argument_list|)
expr_stmt|;
name|__cpu_model
operator|.
name|__cpu_vendor
operator|=
name|VENDOR_AMD
expr_stmt|;
block|}
else|else
name|__cpu_model
operator|.
name|__cpu_vendor
operator|=
name|VENDOR_OTHER
expr_stmt|;
name|assert
argument_list|(
name|__cpu_model
operator|.
name|__cpu_vendor
operator|<
name|VENDOR_MAX
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|__cpu_model
operator|.
name|__cpu_type
operator|<
name|CPU_TYPE_MAX
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|__cpu_model
operator|.
name|__cpu_subtype
operator|<
name|CPU_SUBTYPE_MAX
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

