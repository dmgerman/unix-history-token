begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004-2007  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 2001-2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: check.c,v 1.44.18.35 2007/09/13 05:04:01 each Exp $ */
end_comment

begin_comment
comment|/*! \file */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<isc/buffer.h>
end_include

begin_include
include|#
directive|include
file|<isc/log.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/netaddr.h>
end_include

begin_include
include|#
directive|include
file|<isc/parseint.h>
end_include

begin_include
include|#
directive|include
file|<isc/region.h>
end_include

begin_include
include|#
directive|include
file|<isc/result.h>
end_include

begin_include
include|#
directive|include
file|<isc/sockaddr.h>
end_include

begin_include
include|#
directive|include
file|<isc/string.h>
end_include

begin_include
include|#
directive|include
file|<isc/symtab.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<dns/acl.h>
end_include

begin_include
include|#
directive|include
file|<dns/fixedname.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdataclass.h>
end_include

begin_include
include|#
directive|include
file|<dns/rdatatype.h>
end_include

begin_include
include|#
directive|include
file|<dns/secalg.h>
end_include

begin_include
include|#
directive|include
file|<isccfg/aclconf.h>
end_include

begin_include
include|#
directive|include
file|<isccfg/cfg.h>
end_include

begin_include
include|#
directive|include
file|<bind9/check.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|DNS_RDATASET_FIXED
end_ifndef

begin_define
define|#
directive|define
name|DNS_RDATASET_FIXED
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|freekey
parameter_list|(
name|char
modifier|*
name|key
parameter_list|,
name|unsigned
name|int
name|type
parameter_list|,
name|isc_symvalue_t
name|value
parameter_list|,
name|void
modifier|*
name|userarg
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|isc_mem_free
argument_list|(
name|userarg
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|check_orderent
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|ent
parameter_list|,
name|isc_log_t
modifier|*
name|logctx
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_result_t
name|tresult
decl_stmt|;
name|isc_textregion_t
name|r
decl_stmt|;
name|dns_fixedname_t
name|fixed
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|obj
decl_stmt|;
name|dns_rdataclass_t
name|rdclass
decl_stmt|;
name|dns_rdatatype_t
name|rdtype
decl_stmt|;
name|isc_buffer_t
name|b
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|obj
operator|=
name|cfg_tuple_get
argument_list|(
name|ent
argument_list|,
literal|"class"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg_obj_isstring
argument_list|(
name|obj
argument_list|)
condition|)
block|{
name|DE_CONST
argument_list|(
name|cfg_obj_asstring
argument_list|(
name|obj
argument_list|)
argument_list|,
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
name|r
operator|.
name|length
operator|=
name|strlen
argument_list|(
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|dns_rdataclass_fromtext
argument_list|(
operator|&
name|rdclass
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"rrset-order: invalid class '%s'"
argument_list|,
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
block|}
name|obj
operator|=
name|cfg_tuple_get
argument_list|(
name|ent
argument_list|,
literal|"type"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg_obj_isstring
argument_list|(
name|obj
argument_list|)
condition|)
block|{
name|DE_CONST
argument_list|(
name|cfg_obj_asstring
argument_list|(
name|obj
argument_list|)
argument_list|,
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
name|r
operator|.
name|length
operator|=
name|strlen
argument_list|(
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|dns_rdatatype_fromtext
argument_list|(
operator|&
name|rdtype
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"rrset-order: invalid type '%s'"
argument_list|,
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
block|}
name|obj
operator|=
name|cfg_tuple_get
argument_list|(
name|ent
argument_list|,
literal|"name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg_obj_isstring
argument_list|(
name|obj
argument_list|)
condition|)
block|{
name|str
operator|=
name|cfg_obj_asstring
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|b
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|dns_name_fromtext
argument_list|(
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
argument_list|,
operator|&
name|b
argument_list|,
name|dns_rootname
argument_list|,
name|ISC_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"rrset-order: invalid name '%s'"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
block|}
name|obj
operator|=
name|cfg_tuple_get
argument_list|(
name|ent
argument_list|,
literal|"order"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cfg_obj_isstring
argument_list|(
name|obj
argument_list|)
operator|||
name|strcasecmp
argument_list|(
literal|"order"
argument_list|,
name|cfg_obj_asstring
argument_list|(
name|obj
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|ent
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"rrset-order: keyword 'order' missing"
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
name|obj
operator|=
name|cfg_tuple_get
argument_list|(
name|ent
argument_list|,
literal|"ordering"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cfg_obj_isstring
argument_list|(
name|obj
argument_list|)
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|ent
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"rrset-order: missing ordering"
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|cfg_obj_asstring
argument_list|(
name|obj
argument_list|)
argument_list|,
literal|"fixed"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
operator|!
name|DNS_RDATASET_FIXED
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"rrset-order: order 'fixed' not fully implemented"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|cfg_obj_asstring
argument_list|(
name|obj
argument_list|)
argument_list|,
literal|"random"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcasecmp
argument_list|(
name|cfg_obj_asstring
argument_list|(
name|obj
argument_list|)
argument_list|,
literal|"cyclic"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"rrset-order: invalid order '%s'"
argument_list|,
name|cfg_obj_asstring
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|check_order
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|options
parameter_list|,
name|isc_log_t
modifier|*
name|logctx
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_result_t
name|tresult
decl_stmt|;
specifier|const
name|cfg_listelt_t
modifier|*
name|element
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|cfg_map_get
argument_list|(
name|options
argument_list|,
literal|"rrset-order"
argument_list|,
operator|&
name|obj
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
for|for
control|(
name|element
operator|=
name|cfg_list_first
argument_list|(
name|obj
argument_list|)
init|;
name|element
operator|!=
name|NULL
condition|;
name|element
operator|=
name|cfg_list_next
argument_list|(
name|element
argument_list|)
control|)
block|{
name|tresult
operator|=
name|check_orderent
argument_list|(
name|cfg_listelt_value
argument_list|(
name|element
argument_list|)
argument_list|,
name|logctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|check_dual_stack
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|options
parameter_list|,
name|isc_log_t
modifier|*
name|logctx
parameter_list|)
block|{
specifier|const
name|cfg_listelt_t
modifier|*
name|element
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|alternates
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|value
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|obj
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|isc_buffer_t
name|buffer
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_result_t
name|tresult
decl_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|options
argument_list|,
literal|"dual-stack-servers"
argument_list|,
operator|&
name|alternates
argument_list|)
expr_stmt|;
if|if
condition|(
name|alternates
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|obj
operator|=
name|cfg_tuple_get
argument_list|(
name|alternates
argument_list|,
literal|"port"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg_obj_isuint32
argument_list|(
name|obj
argument_list|)
condition|)
block|{
name|isc_uint32_t
name|val
init|=
name|cfg_obj_asuint32
argument_list|(
name|obj
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|>
name|ISC_UINT16_MAX
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"port '%u' out of range"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
block|}
name|obj
operator|=
name|cfg_tuple_get
argument_list|(
name|alternates
argument_list|,
literal|"addresses"
argument_list|)
expr_stmt|;
for|for
control|(
name|element
operator|=
name|cfg_list_first
argument_list|(
name|obj
argument_list|)
init|;
name|element
operator|!=
name|NULL
condition|;
name|element
operator|=
name|cfg_list_next
argument_list|(
name|element
argument_list|)
control|)
block|{
name|value
operator|=
name|cfg_listelt_value
argument_list|(
name|element
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg_obj_issockaddr
argument_list|(
name|value
argument_list|)
condition|)
continue|continue;
name|obj
operator|=
name|cfg_tuple_get
argument_list|(
name|value
argument_list|,
literal|"name"
argument_list|)
expr_stmt|;
name|str
operator|=
name|cfg_obj_asstring
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|buffer
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|buffer
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|dns_name_fromtext
argument_list|(
name|name
argument_list|,
operator|&
name|buffer
argument_list|,
name|dns_rootname
argument_list|,
name|ISC_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"bad name '%s'"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
name|obj
operator|=
name|cfg_tuple_get
argument_list|(
name|value
argument_list|,
literal|"port"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg_obj_isuint32
argument_list|(
name|obj
argument_list|)
condition|)
block|{
name|isc_uint32_t
name|val
init|=
name|cfg_obj_asuint32
argument_list|(
name|obj
argument_list|)
decl_stmt|;
if|if
condition|(
name|val
operator|>
name|ISC_UINT16_MAX
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"port '%u' out of range"
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|check_forward
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|options
parameter_list|,
name|isc_log_t
modifier|*
name|logctx
parameter_list|)
block|{
specifier|const
name|cfg_obj_t
modifier|*
name|forward
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|forwarders
init|=
name|NULL
decl_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|options
argument_list|,
literal|"forward"
argument_list|,
operator|&
name|forward
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|options
argument_list|,
literal|"forwarders"
argument_list|,
operator|&
name|forwarders
argument_list|)
expr_stmt|;
if|if
condition|(
name|forward
operator|!=
name|NULL
operator|&&
name|forwarders
operator|==
name|NULL
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|forward
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"no matching 'forwarders' statement"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|disabled_algorithms
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|disabled
parameter_list|,
name|isc_log_t
modifier|*
name|logctx
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_result_t
name|tresult
decl_stmt|;
specifier|const
name|cfg_listelt_t
modifier|*
name|element
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|isc_buffer_t
name|b
decl_stmt|;
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|obj
decl_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|obj
operator|=
name|cfg_tuple_get
argument_list|(
name|disabled
argument_list|,
literal|"name"
argument_list|)
expr_stmt|;
name|str
operator|=
name|cfg_obj_asstring
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|b
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|dns_name_fromtext
argument_list|(
name|name
argument_list|,
operator|&
name|b
argument_list|,
name|dns_rootname
argument_list|,
name|ISC_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"bad domain name '%s'"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|result
operator|=
name|tresult
expr_stmt|;
block|}
name|obj
operator|=
name|cfg_tuple_get
argument_list|(
name|disabled
argument_list|,
literal|"algorithms"
argument_list|)
expr_stmt|;
for|for
control|(
name|element
operator|=
name|cfg_list_first
argument_list|(
name|obj
argument_list|)
init|;
name|element
operator|!=
name|NULL
condition|;
name|element
operator|=
name|cfg_list_next
argument_list|(
name|element
argument_list|)
control|)
block|{
name|isc_textregion_t
name|r
decl_stmt|;
name|dns_secalg_t
name|alg
decl_stmt|;
name|isc_result_t
name|tresult
decl_stmt|;
name|DE_CONST
argument_list|(
name|cfg_obj_asstring
argument_list|(
name|cfg_listelt_value
argument_list|(
name|element
argument_list|)
argument_list|)
argument_list|,
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
name|r
operator|.
name|length
operator|=
name|strlen
argument_list|(
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|dns_secalg_fromtext
argument_list|(
operator|&
name|alg
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_uint8_t
name|ui
decl_stmt|;
name|result
operator|=
name|isc_parse_uint8
argument_list|(
operator|&
name|ui
argument_list|,
name|r
operator|.
name|base
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|cfg_listelt_value
argument_list|(
name|element
argument_list|)
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"invalid algorithm '%s'"
argument_list|,
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
name|result
operator|=
name|tresult
expr_stmt|;
block|}
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|nameexist
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|value
parameter_list|,
name|isc_symtab_t
modifier|*
name|symtab
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|isc_log_t
modifier|*
name|logctx
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|char
modifier|*
name|key
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_symvalue_t
name|symvalue
decl_stmt|;
name|key
operator|=
name|isc_mem_strdup
argument_list|(
name|mctx
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|symvalue
operator|.
name|as_cpointer
operator|=
name|obj
expr_stmt|;
name|result
operator|=
name|isc_symtab_define
argument_list|(
name|symtab
argument_list|,
name|key
argument_list|,
name|value
argument_list|,
name|symvalue
argument_list|,
name|isc_symexists_reject
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_EXISTS
condition|)
block|{
name|RUNTIME_CHECK
argument_list|(
name|isc_symtab_lookup
argument_list|(
name|symtab
argument_list|,
name|key
argument_list|,
name|value
argument_list|,
operator|&
name|symvalue
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|file
operator|=
name|cfg_obj_file
argument_list|(
name|symvalue
operator|.
name|as_cpointer
argument_list|)
expr_stmt|;
name|line
operator|=
name|cfg_obj_line
argument_list|(
name|symvalue
operator|.
name|as_cpointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
name|file
operator|=
literal|"<unknown file>"
expr_stmt|;
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
name|fmt
argument_list|,
name|key
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_EXISTS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_mem_free
argument_list|(
name|mctx
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|mustbesecure
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|secure
parameter_list|,
name|isc_symtab_t
modifier|*
name|symtab
parameter_list|,
name|isc_log_t
modifier|*
name|logctx
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
specifier|const
name|cfg_obj_t
modifier|*
name|obj
decl_stmt|;
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|isc_buffer_t
name|b
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|obj
operator|=
name|cfg_tuple_get
argument_list|(
name|secure
argument_list|,
literal|"name"
argument_list|)
expr_stmt|;
name|str
operator|=
name|cfg_obj_asstring
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|b
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_name_fromtext
argument_list|(
name|name
argument_list|,
operator|&
name|b
argument_list|,
name|dns_rootname
argument_list|,
name|ISC_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"bad domain name '%s'"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dns_name_format
argument_list|(
name|name
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|nameexist
argument_list|(
name|secure
argument_list|,
name|namebuf
argument_list|,
literal|1
argument_list|,
name|symtab
argument_list|,
literal|"dnssec-must-be-secure '%s': already "
literal|"exists previous definition: %s:%u"
argument_list|,
name|logctx
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|checkacl
parameter_list|(
specifier|const
name|char
modifier|*
name|aclname
parameter_list|,
name|cfg_aclconfctx_t
modifier|*
name|actx
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|zconfig
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|voptions
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|config
parameter_list|,
name|isc_log_t
modifier|*
name|logctx
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|aclobj
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|options
decl_stmt|;
name|dns_acl_t
modifier|*
name|acl
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|zconfig
operator|!=
name|NULL
condition|)
block|{
name|options
operator|=
name|cfg_tuple_get
argument_list|(
name|zconfig
argument_list|,
literal|"options"
argument_list|)
expr_stmt|;
name|cfg_map_get
argument_list|(
name|options
argument_list|,
name|aclname
argument_list|,
operator|&
name|aclobj
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|voptions
operator|!=
name|NULL
operator|&&
name|aclobj
operator|==
name|NULL
condition|)
name|cfg_map_get
argument_list|(
name|voptions
argument_list|,
name|aclname
argument_list|,
operator|&
name|aclobj
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|!=
name|NULL
operator|&&
name|aclobj
operator|==
name|NULL
condition|)
block|{
name|options
operator|=
name|NULL
expr_stmt|;
name|cfg_map_get
argument_list|(
name|config
argument_list|,
literal|"options"
argument_list|,
operator|&
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|!=
name|NULL
condition|)
name|cfg_map_get
argument_list|(
name|options
argument_list|,
name|aclname
argument_list|,
operator|&
name|aclobj
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aclobj
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|result
operator|=
name|cfg_acl_fromconfig
argument_list|(
name|aclobj
argument_list|,
name|config
argument_list|,
name|logctx
argument_list|,
name|actx
argument_list|,
name|mctx
argument_list|,
operator|&
name|acl
argument_list|)
expr_stmt|;
if|if
condition|(
name|acl
operator|!=
name|NULL
condition|)
name|dns_acl_detach
argument_list|(
operator|&
name|acl
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|check_viewacls
parameter_list|(
name|cfg_aclconfctx_t
modifier|*
name|actx
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|voptions
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|config
parameter_list|,
name|isc_log_t
modifier|*
name|logctx
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|,
name|tresult
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|acls
index|[]
init|=
block|{
literal|"allow-query"
block|,
literal|"allow-query-cache"
block|,
literal|"allow-recursion"
block|,
literal|"blackhole"
block|,
literal|"match-clients"
block|,
literal|"match-destinations"
block|,
literal|"sortlist"
block|,
name|NULL
block|}
decl_stmt|;
while|while
condition|(
name|acls
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|tresult
operator|=
name|checkacl
argument_list|(
name|acls
index|[
name|i
operator|++
index|]
argument_list|,
name|actx
argument_list|,
name|NULL
argument_list|,
name|voptions
argument_list|,
name|config
argument_list|,
name|logctx
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|int
name|scale
decl_stmt|;
name|unsigned
name|int
name|max
decl_stmt|;
block|}
name|intervaltable
typedef|;
end_typedef

begin_function
specifier|static
name|isc_result_t
name|check_options
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|options
parameter_list|,
name|isc_log_t
modifier|*
name|logctx
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_result_t
name|tresult
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_listelt_t
modifier|*
name|element
decl_stmt|;
name|isc_symtab_t
modifier|*
name|symtab
init|=
name|NULL
decl_stmt|;
name|dns_fixedname_t
name|fixed
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|isc_buffer_t
name|b
decl_stmt|;
specifier|static
name|intervaltable
name|intervals
index|[]
init|=
block|{
block|{
literal|"cleaning-interval"
block|,
literal|60
block|,
literal|28
operator|*
literal|24
operator|*
literal|60
block|}
block|,
comment|/* 28 days */
block|{
literal|"heartbeat-interval"
block|,
literal|60
block|,
literal|28
operator|*
literal|24
operator|*
literal|60
block|}
block|,
comment|/* 28 days */
block|{
literal|"interface-interval"
block|,
literal|60
block|,
literal|28
operator|*
literal|24
operator|*
literal|60
block|}
block|,
comment|/* 28 days */
block|{
literal|"max-transfer-idle-in"
block|,
literal|60
block|,
literal|28
operator|*
literal|24
operator|*
literal|60
block|}
block|,
comment|/* 28 days */
block|{
literal|"max-transfer-idle-out"
block|,
literal|60
block|,
literal|28
operator|*
literal|24
operator|*
literal|60
block|}
block|,
comment|/* 28 days */
block|{
literal|"max-transfer-time-in"
block|,
literal|60
block|,
literal|28
operator|*
literal|24
operator|*
literal|60
block|}
block|,
comment|/* 28 days */
block|{
literal|"max-transfer-time-out"
block|,
literal|60
block|,
literal|28
operator|*
literal|24
operator|*
literal|60
block|}
block|,
comment|/* 28 days */
block|{
literal|"sig-validity-interval"
block|,
literal|86400
block|,
literal|10
operator|*
literal|366
block|}
block|,
comment|/* 10 years */
block|{
literal|"statistics-interval"
block|,
literal|60
block|,
literal|28
operator|*
literal|24
operator|*
literal|60
block|}
block|,
comment|/* 28 days */
block|}
decl_stmt|;
comment|/* 	 * Check that fields specified in units of time other than seconds 	 * have reasonable values. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|intervals
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|intervals
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|isc_uint32_t
name|val
decl_stmt|;
name|obj
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|options
argument_list|,
name|intervals
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
continue|continue;
name|val
operator|=
name|cfg_obj_asuint32
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|>
name|intervals
index|[
name|i
index|]
operator|.
name|max
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"%s '%u' is out of range (0..%u)"
argument_list|,
name|intervals
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|val
argument_list|,
name|intervals
index|[
name|i
index|]
operator|.
name|max
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_RANGE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|val
operator|>
operator|(
name|ISC_UINT32_MAX
operator|/
name|intervals
index|[
name|i
index|]
operator|.
name|scale
operator|)
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"%s '%d' is out of range"
argument_list|,
name|intervals
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_RANGE
expr_stmt|;
block|}
block|}
name|obj
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|options
argument_list|,
literal|"preferred-glue"
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|str
operator|=
name|cfg_obj_asstring
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"a"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"aaaa"
argument_list|)
operator|!=
literal|0
operator|&&
name|strcasecmp
argument_list|(
name|str
argument_list|,
literal|"none"
argument_list|)
operator|!=
literal|0
condition|)
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"preferred-glue unexpected value '%s'"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
name|obj
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|options
argument_list|,
literal|"root-delegation-only"
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|cfg_obj_isvoid
argument_list|(
name|obj
argument_list|)
condition|)
block|{
specifier|const
name|cfg_listelt_t
modifier|*
name|element
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|exclude
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|dns_fixedname_t
name|fixed
decl_stmt|;
name|dns_name_t
modifier|*
name|name
decl_stmt|;
name|isc_buffer_t
name|b
decl_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
for|for
control|(
name|element
operator|=
name|cfg_list_first
argument_list|(
name|obj
argument_list|)
init|;
name|element
operator|!=
name|NULL
condition|;
name|element
operator|=
name|cfg_list_next
argument_list|(
name|element
argument_list|)
control|)
block|{
name|exclude
operator|=
name|cfg_listelt_value
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|str
operator|=
name|cfg_obj_asstring
argument_list|(
name|exclude
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|b
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|dns_name_fromtext
argument_list|(
name|name
argument_list|,
operator|&
name|b
argument_list|,
name|dns_rootname
argument_list|,
name|ISC_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"bad domain name '%s'"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|result
operator|=
name|tresult
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 	 * Set supported DNSSEC algorithms. 	 */
name|obj
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|options
argument_list|,
literal|"disable-algorithms"
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|element
operator|=
name|cfg_list_first
argument_list|(
name|obj
argument_list|)
init|;
name|element
operator|!=
name|NULL
condition|;
name|element
operator|=
name|cfg_list_next
argument_list|(
name|element
argument_list|)
control|)
block|{
name|obj
operator|=
name|cfg_listelt_value
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|disabled_algorithms
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
block|}
block|}
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|name
operator|=
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
comment|/* 	 * Check the DLV zone name. 	 */
name|obj
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|options
argument_list|,
literal|"dnssec-lookaside"
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|!=
name|NULL
condition|)
block|{
name|tresult
operator|=
name|isc_symtab_create
argument_list|(
name|mctx
argument_list|,
literal|100
argument_list|,
name|freekey
argument_list|,
name|mctx
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
for|for
control|(
name|element
operator|=
name|cfg_list_first
argument_list|(
name|obj
argument_list|)
init|;
name|element
operator|!=
name|NULL
condition|;
name|element
operator|=
name|cfg_list_next
argument_list|(
name|element
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|dlv
decl_stmt|;
name|obj
operator|=
name|cfg_listelt_value
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|dlv
operator|=
name|cfg_obj_asstring
argument_list|(
name|cfg_tuple_get
argument_list|(
name|obj
argument_list|,
literal|"domain"
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|dlv
argument_list|,
name|strlen
argument_list|(
name|dlv
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|b
argument_list|,
name|strlen
argument_list|(
name|dlv
argument_list|)
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|dns_name_fromtext
argument_list|(
name|name
argument_list|,
operator|&
name|b
argument_list|,
name|dns_rootname
argument_list|,
name|ISC_TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"bad domain name '%s'"
argument_list|,
name|dlv
argument_list|)
expr_stmt|;
name|result
operator|=
name|tresult
expr_stmt|;
block|}
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
block|{
name|tresult
operator|=
name|nameexist
argument_list|(
name|obj
argument_list|,
name|dlv
argument_list|,
literal|1
argument_list|,
name|symtab
argument_list|,
literal|"dnssec-lookaside '%s': "
literal|"already exists previous "
literal|"definition: %s:%u"
argument_list|,
name|logctx
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
block|}
comment|/* 			 * XXXMPA to be removed when multiple lookaside 			 * namespaces are supported. 			 */
if|if
condition|(
operator|!
name|dns_name_equal
argument_list|(
name|dns_rootname
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"dnssec-lookaside '%s': "
literal|"non-root not yet supported"
argument_list|,
name|dlv
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
name|dlv
operator|=
name|cfg_obj_asstring
argument_list|(
name|cfg_tuple_get
argument_list|(
name|obj
argument_list|,
literal|"trust-anchor"
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|dlv
argument_list|,
name|strlen
argument_list|(
name|dlv
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|b
argument_list|,
name|strlen
argument_list|(
name|dlv
argument_list|)
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|dns_name_fromtext
argument_list|(
name|name
argument_list|,
operator|&
name|b
argument_list|,
name|dns_rootname
argument_list|,
name|ISC_TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"bad domain name '%s'"
argument_list|,
name|dlv
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
block|}
block|}
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
name|isc_symtab_destroy
argument_list|(
operator|&
name|symtab
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check dnssec-must-be-secure. 	 */
name|obj
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|options
argument_list|,
literal|"dnssec-must-be-secure"
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|!=
name|NULL
condition|)
block|{
name|isc_symtab_t
modifier|*
name|symtab
init|=
name|NULL
decl_stmt|;
name|tresult
operator|=
name|isc_symtab_create
argument_list|(
name|mctx
argument_list|,
literal|100
argument_list|,
name|freekey
argument_list|,
name|mctx
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
for|for
control|(
name|element
operator|=
name|cfg_list_first
argument_list|(
name|obj
argument_list|)
init|;
name|element
operator|!=
name|NULL
condition|;
name|element
operator|=
name|cfg_list_next
argument_list|(
name|element
argument_list|)
control|)
block|{
name|obj
operator|=
name|cfg_listelt_value
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|mustbesecure
argument_list|(
name|obj
argument_list|,
name|symtab
argument_list|,
name|logctx
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
block|}
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
name|isc_symtab_destroy
argument_list|(
operator|&
name|symtab
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check empty zone configuration. 	 */
name|obj
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|options
argument_list|,
literal|"empty-server"
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|!=
name|NULL
condition|)
block|{
name|str
operator|=
name|cfg_obj_asstring
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|b
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|dns_name_fromtext
argument_list|(
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
argument_list|,
operator|&
name|b
argument_list|,
name|dns_rootname
argument_list|,
name|ISC_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"empty-server: invalid name '%s'"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
block|}
name|obj
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|options
argument_list|,
literal|"empty-contact"
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|!=
name|NULL
condition|)
block|{
name|str
operator|=
name|cfg_obj_asstring
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|b
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|dns_name_fromtext
argument_list|(
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
argument_list|,
operator|&
name|b
argument_list|,
name|dns_rootname
argument_list|,
name|ISC_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"empty-contact: invalid name '%s'"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
block|}
name|obj
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|options
argument_list|,
literal|"disable-empty-zone"
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
for|for
control|(
name|element
operator|=
name|cfg_list_first
argument_list|(
name|obj
argument_list|)
init|;
name|element
operator|!=
name|NULL
condition|;
name|element
operator|=
name|cfg_list_next
argument_list|(
name|element
argument_list|)
control|)
block|{
name|obj
operator|=
name|cfg_listelt_value
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|str
operator|=
name|cfg_obj_asstring
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|b
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|dns_name_fromtext
argument_list|(
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
argument_list|,
operator|&
name|b
argument_list|,
name|dns_rootname
argument_list|,
name|ISC_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"disable-empty-zone: invalid name '%s'"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|get_masters_def
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|cctx
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
modifier|*
name|ret
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|masters
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_listelt_t
modifier|*
name|elt
decl_stmt|;
name|result
operator|=
name|cfg_map_get
argument_list|(
name|cctx
argument_list|,
literal|"masters"
argument_list|,
operator|&
name|masters
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
for|for
control|(
name|elt
operator|=
name|cfg_list_first
argument_list|(
name|masters
argument_list|)
init|;
name|elt
operator|!=
name|NULL
condition|;
name|elt
operator|=
name|cfg_list_next
argument_list|(
name|elt
argument_list|)
control|)
block|{
specifier|const
name|cfg_obj_t
modifier|*
name|list
decl_stmt|;
specifier|const
name|char
modifier|*
name|listname
decl_stmt|;
name|list
operator|=
name|cfg_listelt_value
argument_list|(
name|elt
argument_list|)
expr_stmt|;
name|listname
operator|=
name|cfg_obj_asstring
argument_list|(
name|cfg_tuple_get
argument_list|(
name|list
argument_list|,
literal|"name"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|listname
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|ret
operator|=
name|list
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|validate_masters
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|obj
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|config
parameter_list|,
name|isc_uint32_t
modifier|*
name|countp
parameter_list|,
name|isc_log_t
modifier|*
name|logctx
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_result_t
name|tresult
decl_stmt|;
name|isc_uint32_t
name|count
init|=
literal|0
decl_stmt|;
name|isc_symtab_t
modifier|*
name|symtab
init|=
name|NULL
decl_stmt|;
name|isc_symvalue_t
name|symvalue
decl_stmt|;
specifier|const
name|cfg_listelt_t
modifier|*
name|element
decl_stmt|;
specifier|const
name|cfg_listelt_t
modifier|*
modifier|*
name|stack
init|=
name|NULL
decl_stmt|;
name|isc_uint32_t
name|stackcount
init|=
literal|0
decl_stmt|,
name|pushed
init|=
literal|0
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|list
decl_stmt|;
name|REQUIRE
argument_list|(
name|countp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_symtab_create
argument_list|(
name|mctx
argument_list|,
literal|100
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
operator|*
name|countp
operator|=
name|count
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|newlist
label|:
name|list
operator|=
name|cfg_tuple_get
argument_list|(
name|obj
argument_list|,
literal|"addresses"
argument_list|)
expr_stmt|;
name|element
operator|=
name|cfg_list_first
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|resume
label|:
for|for
control|(
init|;
name|element
operator|!=
name|NULL
condition|;
name|element
operator|=
name|cfg_list_next
argument_list|(
name|element
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|listname
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|addr
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|key
decl_stmt|;
name|addr
operator|=
name|cfg_tuple_get
argument_list|(
name|cfg_listelt_value
argument_list|(
name|element
argument_list|)
argument_list|,
literal|"masterselement"
argument_list|)
expr_stmt|;
name|key
operator|=
name|cfg_tuple_get
argument_list|(
name|cfg_listelt_value
argument_list|(
name|element
argument_list|)
argument_list|,
literal|"key"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg_obj_issockaddr
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|count
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|cfg_obj_isvoid
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|key
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"unexpected token '%s'"
argument_list|,
name|cfg_obj_asstring
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
name|listname
operator|=
name|cfg_obj_asstring
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|symvalue
operator|.
name|as_cpointer
operator|=
name|addr
expr_stmt|;
name|tresult
operator|=
name|isc_symtab_define
argument_list|(
name|symtab
argument_list|,
name|listname
argument_list|,
literal|1
argument_list|,
name|symvalue
argument_list|,
name|isc_symexists_reject
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|==
name|ISC_R_EXISTS
condition|)
continue|continue;
name|tresult
operator|=
name|get_masters_def
argument_list|(
name|config
argument_list|,
name|listname
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
name|cfg_obj_log
argument_list|(
name|addr
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"unable to find masters list '%s'"
argument_list|,
name|listname
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Grow stack? */
if|if
condition|(
name|stackcount
operator|==
name|pushed
condition|)
block|{
name|void
modifier|*
name|new
decl_stmt|;
name|isc_uint32_t
name|newlen
init|=
name|stackcount
operator|+
literal|16
decl_stmt|;
name|size_t
name|newsize
decl_stmt|,
name|oldsize
decl_stmt|;
name|newsize
operator|=
name|newlen
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|stack
argument_list|)
expr_stmt|;
name|oldsize
operator|=
name|stackcount
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|stack
argument_list|)
expr_stmt|;
name|new
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|stackcount
operator|!=
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|new
argument_list|,
name|stack
argument_list|,
name|oldsize
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|stack
argument_list|,
name|oldsize
argument_list|)
expr_stmt|;
block|}
name|stack
operator|=
name|new
expr_stmt|;
name|stackcount
operator|=
name|newlen
expr_stmt|;
block|}
name|stack
index|[
name|pushed
operator|++
index|]
operator|=
name|cfg_list_next
argument_list|(
name|element
argument_list|)
expr_stmt|;
goto|goto
name|newlist
goto|;
block|}
if|if
condition|(
name|pushed
operator|!=
literal|0
condition|)
block|{
name|element
operator|=
name|stack
index|[
operator|--
name|pushed
index|]
expr_stmt|;
goto|goto
name|resume
goto|;
block|}
name|cleanup
label|:
if|if
condition|(
name|stack
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|stack
argument_list|,
name|stackcount
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|stack
argument_list|)
argument_list|)
expr_stmt|;
name|isc_symtab_destroy
argument_list|(
operator|&
name|symtab
argument_list|)
expr_stmt|;
operator|*
name|countp
operator|=
name|count
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|check_update_policy
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|policy
parameter_list|,
name|isc_log_t
modifier|*
name|logctx
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_result_t
name|tresult
decl_stmt|;
specifier|const
name|cfg_listelt_t
modifier|*
name|element
decl_stmt|;
specifier|const
name|cfg_listelt_t
modifier|*
name|element2
decl_stmt|;
name|dns_fixedname_t
name|fixed
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|isc_buffer_t
name|b
decl_stmt|;
for|for
control|(
name|element
operator|=
name|cfg_list_first
argument_list|(
name|policy
argument_list|)
init|;
name|element
operator|!=
name|NULL
condition|;
name|element
operator|=
name|cfg_list_next
argument_list|(
name|element
argument_list|)
control|)
block|{
specifier|const
name|cfg_obj_t
modifier|*
name|stmt
init|=
name|cfg_listelt_value
argument_list|(
name|element
argument_list|)
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|identity
init|=
name|cfg_tuple_get
argument_list|(
name|stmt
argument_list|,
literal|"identity"
argument_list|)
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|matchtype
init|=
name|cfg_tuple_get
argument_list|(
name|stmt
argument_list|,
literal|"matchtype"
argument_list|)
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|dname
init|=
name|cfg_tuple_get
argument_list|(
name|stmt
argument_list|,
literal|"name"
argument_list|)
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|typelist
init|=
name|cfg_tuple_get
argument_list|(
name|stmt
argument_list|,
literal|"types"
argument_list|)
decl_stmt|;
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|str
operator|=
name|cfg_obj_asstring
argument_list|(
name|identity
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|b
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|dns_name_fromtext
argument_list|(
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
argument_list|,
operator|&
name|b
argument_list|,
name|dns_rootname
argument_list|,
name|ISC_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|identity
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"'%s' is not a valid name"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|result
operator|=
name|tresult
expr_stmt|;
block|}
name|dns_fixedname_init
argument_list|(
operator|&
name|fixed
argument_list|)
expr_stmt|;
name|str
operator|=
name|cfg_obj_asstring
argument_list|(
name|dname
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|b
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|dns_name_fromtext
argument_list|(
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
argument_list|,
operator|&
name|b
argument_list|,
name|dns_rootname
argument_list|,
name|ISC_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|dname
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"'%s' is not a valid name"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|result
operator|=
name|tresult
expr_stmt|;
block|}
if|if
condition|(
name|tresult
operator|==
name|ISC_R_SUCCESS
operator|&&
name|strcasecmp
argument_list|(
name|cfg_obj_asstring
argument_list|(
name|matchtype
argument_list|)
argument_list|,
literal|"wildcard"
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|dns_name_iswildcard
argument_list|(
name|dns_fixedname_name
argument_list|(
operator|&
name|fixed
argument_list|)
argument_list|)
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|identity
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"'%s' is not a wildcard"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
for|for
control|(
name|element2
operator|=
name|cfg_list_first
argument_list|(
name|typelist
argument_list|)
init|;
name|element2
operator|!=
name|NULL
condition|;
name|element2
operator|=
name|cfg_list_next
argument_list|(
name|element2
argument_list|)
control|)
block|{
specifier|const
name|cfg_obj_t
modifier|*
name|typeobj
decl_stmt|;
name|isc_textregion_t
name|r
decl_stmt|;
name|dns_rdatatype_t
name|type
decl_stmt|;
name|typeobj
operator|=
name|cfg_listelt_value
argument_list|(
name|element2
argument_list|)
expr_stmt|;
name|DE_CONST
argument_list|(
name|cfg_obj_asstring
argument_list|(
name|typeobj
argument_list|)
argument_list|,
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
name|r
operator|.
name|length
operator|=
name|strlen
argument_list|(
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|dns_rdatatype_fromtext
argument_list|(
operator|&
name|type
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|typeobj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"'%s' is not a valid type"
argument_list|,
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
name|result
operator|=
name|tresult
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MASTERZONE
value|1
end_define

begin_define
define|#
directive|define
name|SLAVEZONE
value|2
end_define

begin_define
define|#
directive|define
name|STUBZONE
value|4
end_define

begin_define
define|#
directive|define
name|HINTZONE
value|8
end_define

begin_define
define|#
directive|define
name|FORWARDZONE
value|16
end_define

begin_define
define|#
directive|define
name|DELEGATIONZONE
value|32
end_define

begin_define
define|#
directive|define
name|CHECKACL
value|64
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|allowed
decl_stmt|;
block|}
name|optionstable
typedef|;
end_typedef

begin_function
specifier|static
name|isc_result_t
name|check_zoneconf
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|zconfig
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|voptions
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|config
parameter_list|,
name|isc_symtab_t
modifier|*
name|symtab
parameter_list|,
name|dns_rdataclass_t
name|defclass
parameter_list|,
name|cfg_aclconfctx_t
modifier|*
name|actx
parameter_list|,
name|isc_log_t
modifier|*
name|logctx
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|zname
decl_stmt|;
specifier|const
name|char
modifier|*
name|typestr
decl_stmt|;
name|unsigned
name|int
name|ztype
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|zoptions
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|obj
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_result_t
name|tresult
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|dns_rdataclass_t
name|zclass
decl_stmt|;
name|dns_fixedname_t
name|fixedname
decl_stmt|;
name|isc_buffer_t
name|b
decl_stmt|;
specifier|static
name|optionstable
name|options
index|[]
init|=
block|{
block|{
literal|"allow-query"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
operator||
name|STUBZONE
operator||
name|CHECKACL
block|}
block|,
block|{
literal|"allow-notify"
block|,
name|SLAVEZONE
operator||
name|CHECKACL
block|}
block|,
block|{
literal|"allow-transfer"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
operator||
name|CHECKACL
block|}
block|,
block|{
literal|"notify"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
block|}
block|,
block|{
literal|"also-notify"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
block|}
block|,
block|{
literal|"dialup"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
operator||
name|STUBZONE
block|}
block|,
block|{
literal|"delegation-only"
block|,
name|HINTZONE
operator||
name|STUBZONE
block|}
block|,
block|{
literal|"forward"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
operator||
name|STUBZONE
operator||
name|FORWARDZONE
block|}
block|,
block|{
literal|"forwarders"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
operator||
name|STUBZONE
operator||
name|FORWARDZONE
block|}
block|,
block|{
literal|"maintain-ixfr-base"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
block|}
block|,
block|{
literal|"max-ixfr-log-size"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
block|}
block|,
block|{
literal|"notify-source"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
block|}
block|,
block|{
literal|"notify-source-v6"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
block|}
block|,
block|{
literal|"transfer-source"
block|,
name|SLAVEZONE
operator||
name|STUBZONE
block|}
block|,
block|{
literal|"transfer-source-v6"
block|,
name|SLAVEZONE
operator||
name|STUBZONE
block|}
block|,
block|{
literal|"max-transfer-time-in"
block|,
name|SLAVEZONE
operator||
name|STUBZONE
block|}
block|,
block|{
literal|"max-transfer-time-out"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
block|}
block|,
block|{
literal|"max-transfer-idle-in"
block|,
name|SLAVEZONE
operator||
name|STUBZONE
block|}
block|,
block|{
literal|"max-transfer-idle-out"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
block|}
block|,
block|{
literal|"max-retry-time"
block|,
name|SLAVEZONE
operator||
name|STUBZONE
block|}
block|,
block|{
literal|"min-retry-time"
block|,
name|SLAVEZONE
operator||
name|STUBZONE
block|}
block|,
block|{
literal|"max-refresh-time"
block|,
name|SLAVEZONE
operator||
name|STUBZONE
block|}
block|,
block|{
literal|"min-refresh-time"
block|,
name|SLAVEZONE
operator||
name|STUBZONE
block|}
block|,
block|{
literal|"sig-validity-interval"
block|,
name|MASTERZONE
block|}
block|,
block|{
literal|"zone-statistics"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
operator||
name|STUBZONE
block|}
block|,
block|{
literal|"allow-update"
block|,
name|MASTERZONE
operator||
name|CHECKACL
block|}
block|,
block|{
literal|"allow-update-forwarding"
block|,
name|SLAVEZONE
operator||
name|CHECKACL
block|}
block|,
block|{
literal|"file"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
operator||
name|STUBZONE
operator||
name|HINTZONE
block|}
block|,
block|{
literal|"journal"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
block|}
block|,
block|{
literal|"ixfr-base"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
block|}
block|,
block|{
literal|"ixfr-tmp-file"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
block|}
block|,
block|{
literal|"masters"
block|,
name|SLAVEZONE
operator||
name|STUBZONE
block|}
block|,
block|{
literal|"pubkey"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
operator||
name|STUBZONE
block|}
block|,
block|{
literal|"update-policy"
block|,
name|MASTERZONE
block|}
block|,
block|{
literal|"database"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
operator||
name|STUBZONE
block|}
block|,
block|{
literal|"key-directory"
block|,
name|MASTERZONE
block|}
block|,
block|{
literal|"check-wildcard"
block|,
name|MASTERZONE
block|}
block|,
block|{
literal|"check-mx"
block|,
name|MASTERZONE
block|}
block|,
block|{
literal|"integrity-check"
block|,
name|MASTERZONE
block|}
block|,
block|{
literal|"check-mx-cname"
block|,
name|MASTERZONE
block|}
block|,
block|{
literal|"check-srv-cname"
block|,
name|MASTERZONE
block|}
block|,
block|{
literal|"masterfile-format"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
operator||
name|STUBZONE
operator||
name|HINTZONE
block|}
block|,
block|{
literal|"update-check-ksk"
block|,
name|MASTERZONE
block|}
block|, 	}
decl_stmt|;
specifier|static
name|optionstable
name|dialups
index|[]
init|=
block|{
block|{
literal|"notify"
block|,
name|MASTERZONE
operator||
name|SLAVEZONE
block|}
block|,
block|{
literal|"notify-passive"
block|,
name|SLAVEZONE
block|}
block|,
block|{
literal|"refresh"
block|,
name|SLAVEZONE
operator||
name|STUBZONE
block|}
block|,
block|{
literal|"passive"
block|,
name|SLAVEZONE
operator||
name|STUBZONE
block|}
block|, 	}
decl_stmt|;
name|zname
operator|=
name|cfg_obj_asstring
argument_list|(
name|cfg_tuple_get
argument_list|(
name|zconfig
argument_list|,
literal|"name"
argument_list|)
argument_list|)
expr_stmt|;
name|zoptions
operator|=
name|cfg_tuple_get
argument_list|(
name|zconfig
argument_list|,
literal|"options"
argument_list|)
expr_stmt|;
name|obj
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|zoptions
argument_list|,
literal|"type"
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|zconfig
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone '%s': type not present"
argument_list|,
name|zname
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
name|typestr
operator|=
name|cfg_obj_asstring
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|typestr
argument_list|,
literal|"master"
argument_list|)
operator|==
literal|0
condition|)
name|ztype
operator|=
name|MASTERZONE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|typestr
argument_list|,
literal|"slave"
argument_list|)
operator|==
literal|0
condition|)
name|ztype
operator|=
name|SLAVEZONE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|typestr
argument_list|,
literal|"stub"
argument_list|)
operator|==
literal|0
condition|)
name|ztype
operator|=
name|STUBZONE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|typestr
argument_list|,
literal|"forward"
argument_list|)
operator|==
literal|0
condition|)
name|ztype
operator|=
name|FORWARDZONE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|typestr
argument_list|,
literal|"hint"
argument_list|)
operator|==
literal|0
condition|)
name|ztype
operator|=
name|HINTZONE
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|typestr
argument_list|,
literal|"delegation-only"
argument_list|)
operator|==
literal|0
condition|)
name|ztype
operator|=
name|DELEGATIONZONE
expr_stmt|;
else|else
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone '%s': invalid type %s"
argument_list|,
name|zname
argument_list|,
name|typestr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
name|obj
operator|=
name|cfg_tuple_get
argument_list|(
name|zconfig
argument_list|,
literal|"class"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg_obj_isstring
argument_list|(
name|obj
argument_list|)
condition|)
block|{
name|isc_textregion_t
name|r
decl_stmt|;
name|DE_CONST
argument_list|(
name|cfg_obj_asstring
argument_list|(
name|obj
argument_list|)
argument_list|,
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
name|r
operator|.
name|length
operator|=
name|strlen
argument_list|(
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
name|result
operator|=
name|dns_rdataclass_fromtext
argument_list|(
operator|&
name|zclass
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone '%s': invalid class %s"
argument_list|,
name|zname
argument_list|,
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
if|if
condition|(
name|zclass
operator|!=
name|defclass
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone '%s': class '%s' does not "
literal|"match view/default class"
argument_list|,
name|zname
argument_list|,
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
block|}
comment|/* 	 * Look for an already existing zone. 	 * We need to make this cannonical as isc_symtab_define() 	 * deals with strings. 	 */
name|dns_fixedname_init
argument_list|(
operator|&
name|fixedname
argument_list|)
expr_stmt|;
name|isc_buffer_init
argument_list|(
operator|&
name|b
argument_list|,
name|zname
argument_list|,
name|strlen
argument_list|(
name|zname
argument_list|)
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
operator|&
name|b
argument_list|,
name|strlen
argument_list|(
name|zname
argument_list|)
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|dns_name_fromtext
argument_list|(
name|dns_fixedname_name
argument_list|(
operator|&
name|fixedname
argument_list|)
argument_list|,
operator|&
name|b
argument_list|,
name|dns_rootname
argument_list|,
name|ISC_TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|zconfig
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone '%s': is not a valid name"
argument_list|,
name|zname
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
else|else
block|{
name|char
name|namebuf
index|[
name|DNS_NAME_FORMATSIZE
index|]
decl_stmt|;
name|dns_name_format
argument_list|(
name|dns_fixedname_name
argument_list|(
operator|&
name|fixedname
argument_list|)
argument_list|,
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|namebuf
argument_list|)
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|nameexist
argument_list|(
name|zconfig
argument_list|,
name|namebuf
argument_list|,
name|ztype
operator|==
name|HINTZONE
condition|?
literal|1
else|:
literal|2
argument_list|,
name|symtab
argument_list|,
literal|"zone '%s': already exists "
literal|"previous definition: %s:%u"
argument_list|,
name|logctx
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
block|}
comment|/* 	 * Look for inappropriate options for the given zone type. 	 * Check that ACLs expand correctly. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|options
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|options
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|obj
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|options
index|[
name|i
index|]
operator|.
name|allowed
operator|&
name|ztype
operator|)
operator|==
literal|0
operator|&&
name|cfg_map_get
argument_list|(
name|zoptions
argument_list|,
name|options
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|&
name|obj
argument_list|)
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|options
index|[
name|i
index|]
operator|.
name|name
argument_list|,
literal|"allow-update"
argument_list|)
operator|!=
literal|0
operator|||
name|ztype
operator|!=
name|SLAVEZONE
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"option '%s' is not allowed "
literal|"in '%s' zone '%s'"
argument_list|,
name|options
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|typestr
argument_list|,
name|zname
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
else|else
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"option '%s' is not allowed "
literal|"in '%s' zone '%s'"
argument_list|,
name|options
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|typestr
argument_list|,
name|zname
argument_list|)
expr_stmt|;
block|}
name|obj
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|options
index|[
name|i
index|]
operator|.
name|allowed
operator|&
name|ztype
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|options
index|[
name|i
index|]
operator|.
name|allowed
operator|&
name|CHECKACL
operator|)
operator|!=
literal|0
condition|)
block|{
name|tresult
operator|=
name|checkacl
argument_list|(
name|options
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|actx
argument_list|,
name|zconfig
argument_list|,
name|voptions
argument_list|,
name|config
argument_list|,
name|logctx
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
block|}
block|}
comment|/* 	 * Slave& stub zones must have a "masters" field. 	 */
if|if
condition|(
name|ztype
operator|==
name|SLAVEZONE
operator|||
name|ztype
operator|==
name|STUBZONE
condition|)
block|{
name|obj
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cfg_map_get
argument_list|(
name|zoptions
argument_list|,
literal|"masters"
argument_list|,
operator|&
name|obj
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|zoptions
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone '%s': missing 'masters' entry"
argument_list|,
name|zname
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
else|else
block|{
name|isc_uint32_t
name|count
decl_stmt|;
name|tresult
operator|=
name|validate_masters
argument_list|(
name|obj
argument_list|,
name|config
argument_list|,
operator|&
name|count
argument_list|,
name|logctx
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
operator|&&
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
if|if
condition|(
name|tresult
operator|==
name|ISC_R_SUCCESS
operator|&&
name|count
operator|==
literal|0
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|zoptions
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone '%s': empty 'masters' entry"
argument_list|,
name|zname
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Master zones can't have both "allow-update" and "update-policy". 	 */
if|if
condition|(
name|ztype
operator|==
name|MASTERZONE
condition|)
block|{
name|isc_result_t
name|res1
decl_stmt|,
name|res2
decl_stmt|;
name|obj
operator|=
name|NULL
expr_stmt|;
name|res1
operator|=
name|cfg_map_get
argument_list|(
name|zoptions
argument_list|,
literal|"allow-update"
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
name|obj
operator|=
name|NULL
expr_stmt|;
name|res2
operator|=
name|cfg_map_get
argument_list|(
name|zoptions
argument_list|,
literal|"update-policy"
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|res1
operator|==
name|ISC_R_SUCCESS
operator|&&
name|res2
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone '%s': 'allow-update' is ignored "
literal|"when 'update-policy' is present"
argument_list|,
name|zname
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|res2
operator|==
name|ISC_R_SUCCESS
operator|&&
name|check_update_policy
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
comment|/* 	 * Check the excessively complicated "dialup" option. 	 */
if|if
condition|(
name|ztype
operator|==
name|MASTERZONE
operator|||
name|ztype
operator|==
name|SLAVEZONE
operator|||
name|ztype
operator|==
name|STUBZONE
condition|)
block|{
specifier|const
name|cfg_obj_t
modifier|*
name|dialup
init|=
name|NULL
decl_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|zoptions
argument_list|,
literal|"dialup"
argument_list|,
operator|&
name|dialup
argument_list|)
expr_stmt|;
if|if
condition|(
name|dialup
operator|!=
name|NULL
operator|&&
name|cfg_obj_isstring
argument_list|(
name|dialup
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|str
init|=
name|cfg_obj_asstring
argument_list|(
name|dialup
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|dialups
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|dialups
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|dialups
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|str
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|(
name|dialups
index|[
name|i
index|]
operator|.
name|allowed
operator|&
name|ztype
operator|)
operator|==
literal|0
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"dialup type '%s' is not "
literal|"allowed in '%s' "
literal|"zone '%s'"
argument_list|,
name|str
argument_list|,
name|typestr
argument_list|,
name|zname
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|i
operator|==
sizeof|sizeof
argument_list|(
name|dialups
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|dialups
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"invalid dialup type '%s' in zone "
literal|"'%s'"
argument_list|,
name|str
argument_list|,
name|zname
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Check that forwarding is reasonable. 	 */
if|if
condition|(
name|check_forward
argument_list|(
name|zoptions
argument_list|,
name|logctx
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
comment|/* 	 * Check various options. 	 */
name|tresult
operator|=
name|check_options
argument_list|(
name|zoptions
argument_list|,
name|logctx
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
comment|/* 	 * If the zone type is rbt/rbt64 then master/hint zones 	 * require file clauses. 	 */
name|obj
operator|=
name|NULL
expr_stmt|;
name|tresult
operator|=
name|cfg_map_get
argument_list|(
name|zoptions
argument_list|,
literal|"database"
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|==
name|ISC_R_NOTFOUND
operator|||
operator|(
name|tresult
operator|==
name|ISC_R_SUCCESS
operator|&&
operator|(
name|strcmp
argument_list|(
literal|"rbt"
argument_list|,
name|cfg_obj_asstring
argument_list|(
name|obj
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
literal|"rbt64"
argument_list|,
name|cfg_obj_asstring
argument_list|(
name|obj
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|obj
operator|=
name|NULL
expr_stmt|;
name|tresult
operator|=
name|cfg_map_get
argument_list|(
name|zoptions
argument_list|,
literal|"file"
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
operator|&&
operator|(
name|ztype
operator|==
name|MASTERZONE
operator|||
name|ztype
operator|==
name|HINTZONE
operator|)
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|zconfig
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"zone '%s': missing 'file' entry"
argument_list|,
name|zname
argument_list|)
expr_stmt|;
name|result
operator|=
name|tresult
expr_stmt|;
block|}
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|keyalgorithms
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|isc_uint16_t
name|size
decl_stmt|;
block|}
name|algorithmtable
typedef|;
end_typedef

begin_function
name|isc_result_t
name|bind9_check_key
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|key
parameter_list|,
name|isc_log_t
modifier|*
name|logctx
parameter_list|)
block|{
specifier|const
name|cfg_obj_t
modifier|*
name|algobj
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|secretobj
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|keyname
init|=
name|cfg_obj_asstring
argument_list|(
name|cfg_map_getname
argument_list|(
name|key
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|algorithm
decl_stmt|;
name|int
name|i
decl_stmt|;
name|size_t
name|len
init|=
literal|0
decl_stmt|;
specifier|static
specifier|const
name|algorithmtable
name|algorithms
index|[]
init|=
block|{
block|{
literal|"hmac-md5"
block|,
literal|128
block|}
block|,
block|{
literal|"hmac-md5.sig-alg.reg.int"
block|,
literal|0
block|}
block|,
block|{
literal|"hmac-md5.sig-alg.reg.int."
block|,
literal|0
block|}
block|,
block|{
literal|"hmac-sha1"
block|,
literal|160
block|}
block|,
block|{
literal|"hmac-sha224"
block|,
literal|224
block|}
block|,
block|{
literal|"hmac-sha256"
block|,
literal|256
block|}
block|,
block|{
literal|"hmac-sha384"
block|,
literal|384
block|}
block|,
block|{
literal|"hmac-sha512"
block|,
literal|512
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|key
argument_list|,
literal|"algorithm"
argument_list|,
operator|&
name|algobj
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|key
argument_list|,
literal|"secret"
argument_list|,
operator|&
name|secretobj
argument_list|)
expr_stmt|;
if|if
condition|(
name|secretobj
operator|==
name|NULL
operator|||
name|algobj
operator|==
name|NULL
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|key
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"key '%s' must have both 'secret' and "
literal|"'algorithm' defined"
argument_list|,
name|keyname
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
name|algorithm
operator|=
name|cfg_obj_asstring
argument_list|(
name|algobj
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|algorithms
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|algorithms
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|algorithms
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|algorithm
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|algorithm
index|[
name|len
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|algorithms
index|[
name|i
index|]
operator|.
name|size
operator|!=
literal|0
operator|&&
name|algorithm
index|[
name|len
index|]
operator|==
literal|'-'
operator|)
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|algorithms
index|[
name|i
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|algobj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"unknown algorithm '%s'"
argument_list|,
name|algorithm
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
block|}
if|if
condition|(
name|algorithm
index|[
name|len
index|]
operator|==
literal|'-'
condition|)
block|{
name|isc_uint16_t
name|digestbits
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|isc_parse_uint16
argument_list|(
operator|&
name|digestbits
argument_list|,
name|algorithm
operator|+
name|len
operator|+
literal|1
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
operator|||
name|result
operator|==
name|ISC_R_RANGE
condition|)
block|{
if|if
condition|(
name|result
operator|==
name|ISC_R_RANGE
operator|||
name|digestbits
operator|>
name|algorithms
index|[
name|i
index|]
operator|.
name|size
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|algobj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"key '%s' digest-bits too large "
literal|"[%u..%u]"
argument_list|,
name|keyname
argument_list|,
name|algorithms
index|[
name|i
index|]
operator|.
name|size
operator|/
literal|2
argument_list|,
name|algorithms
index|[
name|i
index|]
operator|.
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_RANGE
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|digestbits
operator|%
literal|8
operator|)
operator|!=
literal|0
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|algobj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"key '%s' digest-bits not multiple"
literal|" of 8"
argument_list|,
name|keyname
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_RANGE
operator|)
return|;
block|}
comment|/* 			 * Recommended minima for hmac algorithms. 			 */
if|if
condition|(
operator|(
name|digestbits
operator|<
operator|(
name|algorithms
index|[
name|i
index|]
operator|.
name|size
operator|/
literal|2U
operator|)
operator|||
operator|(
name|digestbits
operator|<
literal|80U
operator|)
operator|)
condition|)
name|cfg_obj_log
argument_list|(
name|algobj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"key '%s' digest-bits too small "
literal|"[<%u]"
argument_list|,
name|keyname
argument_list|,
name|algorithms
index|[
name|i
index|]
operator|.
name|size
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cfg_obj_log
argument_list|(
name|algobj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"key '%s': unable to parse digest-bits"
argument_list|,
name|keyname
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|check_keylist
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|keys
parameter_list|,
name|isc_symtab_t
modifier|*
name|symtab
parameter_list|,
name|isc_log_t
modifier|*
name|logctx
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_result_t
name|tresult
decl_stmt|;
specifier|const
name|cfg_listelt_t
modifier|*
name|element
decl_stmt|;
for|for
control|(
name|element
operator|=
name|cfg_list_first
argument_list|(
name|keys
argument_list|)
init|;
name|element
operator|!=
name|NULL
condition|;
name|element
operator|=
name|cfg_list_next
argument_list|(
name|element
argument_list|)
control|)
block|{
specifier|const
name|cfg_obj_t
modifier|*
name|key
init|=
name|cfg_listelt_value
argument_list|(
name|element
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|keyname
init|=
name|cfg_obj_asstring
argument_list|(
name|cfg_map_getname
argument_list|(
name|key
argument_list|)
argument_list|)
decl_stmt|;
name|isc_symvalue_t
name|symvalue
decl_stmt|;
name|tresult
operator|=
name|bind9_check_key
argument_list|(
name|key
argument_list|,
name|logctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|tresult
operator|)
return|;
name|symvalue
operator|.
name|as_cpointer
operator|=
name|key
expr_stmt|;
name|tresult
operator|=
name|isc_symtab_define
argument_list|(
name|symtab
argument_list|,
name|keyname
argument_list|,
literal|1
argument_list|,
name|symvalue
argument_list|,
name|isc_symexists_reject
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|==
name|ISC_R_EXISTS
condition|)
block|{
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|isc_symtab_lookup
argument_list|(
name|symtab
argument_list|,
name|keyname
argument_list|,
literal|1
argument_list|,
operator|&
name|symvalue
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|file
operator|=
name|cfg_obj_file
argument_list|(
name|symvalue
operator|.
name|as_cpointer
argument_list|)
expr_stmt|;
name|line
operator|=
name|cfg_obj_line
argument_list|(
name|symvalue
operator|.
name|as_cpointer
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
name|file
operator|=
literal|"<unknown file>"
expr_stmt|;
name|cfg_obj_log
argument_list|(
name|key
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"key '%s': already exists "
literal|"previous definition: %s:%u"
argument_list|,
name|keyname
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|result
operator|=
name|tresult
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|tresult
operator|)
return|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_struct
specifier|static
struct|struct
block|{
specifier|const
name|char
modifier|*
name|v4
decl_stmt|;
specifier|const
name|char
modifier|*
name|v6
decl_stmt|;
block|}
name|sources
index|[]
init|=
block|{
block|{
literal|"transfer-source"
block|,
literal|"transfer-source-v6"
block|}
block|,
block|{
literal|"notify-source"
block|,
literal|"notify-source-v6"
block|}
block|,
block|{
literal|"query-source"
block|,
literal|"query-source-v6"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|isc_result_t
name|check_servers
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|servers
parameter_list|,
name|isc_log_t
modifier|*
name|logctx
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_result_t
name|tresult
decl_stmt|;
specifier|const
name|cfg_listelt_t
modifier|*
name|e1
decl_stmt|,
modifier|*
name|e2
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|v1
decl_stmt|,
modifier|*
name|v2
decl_stmt|;
name|isc_netaddr_t
name|n1
decl_stmt|,
name|n2
decl_stmt|;
name|unsigned
name|int
name|p1
decl_stmt|,
name|p2
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|obj
decl_stmt|;
name|char
name|buf
index|[
name|ISC_NETADDR_FORMATSIZE
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|xfr
decl_stmt|;
name|int
name|source
decl_stmt|;
for|for
control|(
name|e1
operator|=
name|cfg_list_first
argument_list|(
name|servers
argument_list|)
init|;
name|e1
operator|!=
name|NULL
condition|;
name|e1
operator|=
name|cfg_list_next
argument_list|(
name|e1
argument_list|)
control|)
block|{
name|v1
operator|=
name|cfg_listelt_value
argument_list|(
name|e1
argument_list|)
expr_stmt|;
name|cfg_obj_asnetprefix
argument_list|(
name|cfg_map_getname
argument_list|(
name|v1
argument_list|)
argument_list|,
operator|&
name|n1
argument_list|,
operator|&
name|p1
argument_list|)
expr_stmt|;
comment|/* 		 * Check that unused bits are zero. 		 */
name|tresult
operator|=
name|isc_netaddr_prefixok
argument_list|(
operator|&
name|n1
argument_list|,
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|INSIST
argument_list|(
name|tresult
operator|==
name|ISC_R_FAILURE
argument_list|)
expr_stmt|;
name|isc_netaddr_format
argument_list|(
operator|&
name|n1
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|cfg_obj_log
argument_list|(
name|v1
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"server '%s/%u': invalid prefix "
literal|"(extra bits specified)"
argument_list|,
name|buf
argument_list|,
name|p1
argument_list|)
expr_stmt|;
name|result
operator|=
name|tresult
expr_stmt|;
block|}
name|source
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|obj
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|n1
operator|.
name|family
operator|==
name|AF_INET
condition|)
name|xfr
operator|=
name|sources
index|[
name|source
index|]
operator|.
name|v6
expr_stmt|;
else|else
name|xfr
operator|=
name|sources
index|[
name|source
index|]
operator|.
name|v4
expr_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|v1
argument_list|,
name|xfr
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|!=
name|NULL
condition|)
block|{
name|isc_netaddr_format
argument_list|(
operator|&
name|n1
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|cfg_obj_log
argument_list|(
name|v1
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"server '%s': %s not legal"
argument_list|,
name|buf
argument_list|,
name|xfr
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
block|}
do|while
condition|(
name|sources
index|[
operator|++
name|source
index|]
operator|.
name|v4
operator|!=
name|NULL
condition|)
do|;
name|e2
operator|=
name|e1
expr_stmt|;
while|while
condition|(
operator|(
name|e2
operator|=
name|cfg_list_next
argument_list|(
name|e2
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|v2
operator|=
name|cfg_listelt_value
argument_list|(
name|e2
argument_list|)
expr_stmt|;
name|cfg_obj_asnetprefix
argument_list|(
name|cfg_map_getname
argument_list|(
name|v2
argument_list|)
argument_list|,
operator|&
name|n2
argument_list|,
operator|&
name|p2
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|==
name|p2
operator|&&
name|isc_netaddr_equal
argument_list|(
operator|&
name|n1
argument_list|,
operator|&
name|n2
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|file
init|=
name|cfg_obj_file
argument_list|(
name|v1
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|line
init|=
name|cfg_obj_line
argument_list|(
name|v1
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
name|file
operator|=
literal|"<unknown file>"
expr_stmt|;
name|isc_netaddr_format
argument_list|(
operator|&
name|n2
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|cfg_obj_log
argument_list|(
name|v2
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"server '%s/%u': already exists "
literal|"previous definition: %s:%u"
argument_list|,
name|buf
argument_list|,
name|p2
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|check_viewconf
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|config
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|voptions
parameter_list|,
name|dns_rdataclass_t
name|vclass
parameter_list|,
name|isc_log_t
modifier|*
name|logctx
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
specifier|const
name|cfg_obj_t
modifier|*
name|servers
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|zones
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|keys
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_listelt_t
modifier|*
name|element
decl_stmt|;
name|isc_symtab_t
modifier|*
name|symtab
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_result_t
name|tresult
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|cfg_aclconfctx_t
name|actx
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|obj
decl_stmt|;
name|isc_boolean_t
name|enablednssec
decl_stmt|,
name|enablevalidation
decl_stmt|;
comment|/* 	 * Check that all zone statements are syntactically correct and 	 * there are no duplicate zones. 	 */
name|tresult
operator|=
name|isc_symtab_create
argument_list|(
name|mctx
argument_list|,
literal|100
argument_list|,
name|freekey
argument_list|,
name|mctx
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|cfg_aclconfctx_init
argument_list|(
operator|&
name|actx
argument_list|)
expr_stmt|;
if|if
condition|(
name|voptions
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|voptions
argument_list|,
literal|"zone"
argument_list|,
operator|&
name|zones
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|config
argument_list|,
literal|"zone"
argument_list|,
operator|&
name|zones
argument_list|)
expr_stmt|;
for|for
control|(
name|element
operator|=
name|cfg_list_first
argument_list|(
name|zones
argument_list|)
init|;
name|element
operator|!=
name|NULL
condition|;
name|element
operator|=
name|cfg_list_next
argument_list|(
name|element
argument_list|)
control|)
block|{
name|isc_result_t
name|tresult
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|zone
init|=
name|cfg_listelt_value
argument_list|(
name|element
argument_list|)
decl_stmt|;
name|tresult
operator|=
name|check_zoneconf
argument_list|(
name|zone
argument_list|,
name|voptions
argument_list|,
name|config
argument_list|,
name|symtab
argument_list|,
name|vclass
argument_list|,
operator|&
name|actx
argument_list|,
name|logctx
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
name|isc_symtab_destroy
argument_list|(
operator|&
name|symtab
argument_list|)
expr_stmt|;
comment|/* 	 * Check that all key statements are syntactically correct and 	 * there are no duplicate keys. 	 */
name|tresult
operator|=
name|isc_symtab_create
argument_list|(
name|mctx
argument_list|,
literal|100
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|config
argument_list|,
literal|"key"
argument_list|,
operator|&
name|keys
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|check_keylist
argument_list|(
name|keys
argument_list|,
name|symtab
argument_list|,
name|logctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|==
name|ISC_R_EXISTS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
elseif|else
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_symtab_destroy
argument_list|(
operator|&
name|symtab
argument_list|)
expr_stmt|;
return|return
operator|(
name|tresult
operator|)
return|;
block|}
if|if
condition|(
name|voptions
operator|!=
name|NULL
condition|)
block|{
name|keys
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|voptions
argument_list|,
literal|"key"
argument_list|,
operator|&
name|keys
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|check_keylist
argument_list|(
name|keys
argument_list|,
name|symtab
argument_list|,
name|logctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|==
name|ISC_R_EXISTS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
elseif|else
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_symtab_destroy
argument_list|(
operator|&
name|symtab
argument_list|)
expr_stmt|;
return|return
operator|(
name|tresult
operator|)
return|;
block|}
block|}
name|isc_symtab_destroy
argument_list|(
operator|&
name|symtab
argument_list|)
expr_stmt|;
comment|/* 	 * Check that forwarding is reasonable. 	 */
if|if
condition|(
name|voptions
operator|==
name|NULL
condition|)
block|{
specifier|const
name|cfg_obj_t
modifier|*
name|options
init|=
name|NULL
decl_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|config
argument_list|,
literal|"options"
argument_list|,
operator|&
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|!=
name|NULL
condition|)
if|if
condition|(
name|check_forward
argument_list|(
name|options
argument_list|,
name|logctx
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|check_forward
argument_list|(
name|voptions
argument_list|,
name|logctx
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
comment|/* 	 * Check that dual-stack-servers is reasonable. 	 */
if|if
condition|(
name|voptions
operator|==
name|NULL
condition|)
block|{
specifier|const
name|cfg_obj_t
modifier|*
name|options
init|=
name|NULL
decl_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|config
argument_list|,
literal|"options"
argument_list|,
operator|&
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|!=
name|NULL
condition|)
if|if
condition|(
name|check_dual_stack
argument_list|(
name|options
argument_list|,
name|logctx
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|check_dual_stack
argument_list|(
name|voptions
argument_list|,
name|logctx
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
comment|/* 	 * Check that rrset-order is reasonable. 	 */
if|if
condition|(
name|voptions
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|check_order
argument_list|(
name|voptions
argument_list|,
name|logctx
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
if|if
condition|(
name|voptions
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|voptions
argument_list|,
literal|"server"
argument_list|,
operator|&
name|servers
argument_list|)
expr_stmt|;
if|if
condition|(
name|servers
operator|!=
name|NULL
operator|&&
name|check_servers
argument_list|(
name|servers
argument_list|,
name|logctx
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
comment|/* 	 * Check that dnssec-enable/dnssec-validation are sensible. 	 */
name|obj
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|voptions
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|voptions
argument_list|,
literal|"dnssec-enable"
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|config
argument_list|,
literal|"dnssec-enable"
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
name|enablednssec
operator|=
name|ISC_TRUE
expr_stmt|;
else|else
name|enablednssec
operator|=
name|cfg_obj_asboolean
argument_list|(
name|obj
argument_list|)
expr_stmt|;
name|obj
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|voptions
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|voptions
argument_list|,
literal|"dnssec-validation"
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|config
argument_list|,
literal|"dnssec-validation"
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|==
name|NULL
condition|)
name|enablevalidation
operator|=
name|ISC_FALSE
expr_stmt|;
comment|/* XXXMPA Change for 9.5. */
else|else
name|enablevalidation
operator|=
name|cfg_obj_asboolean
argument_list|(
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|enablevalidation
operator|&&
operator|!
name|enablednssec
condition|)
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"'dnssec-validation yes;' and 'dnssec-enable no;'"
argument_list|)
expr_stmt|;
if|if
condition|(
name|voptions
operator|!=
name|NULL
condition|)
name|tresult
operator|=
name|check_options
argument_list|(
name|voptions
argument_list|,
name|logctx
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
else|else
name|tresult
operator|=
name|check_options
argument_list|(
name|config
argument_list|,
name|logctx
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
name|tresult
operator|=
name|check_viewacls
argument_list|(
operator|&
name|actx
argument_list|,
name|voptions
argument_list|,
name|config
argument_list|,
name|logctx
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
name|cfg_aclconfctx_destroy
argument_list|(
operator|&
name|actx
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|default_channels
index|[]
init|=
block|{
literal|"default_syslog"
block|,
literal|"default_stderr"
block|,
literal|"default_debug"
block|,
literal|"null"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|isc_result_t
name|bind9_check_logging
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|config
parameter_list|,
name|isc_log_t
modifier|*
name|logctx
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
specifier|const
name|cfg_obj_t
modifier|*
name|categories
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|category
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|channels
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|channel
decl_stmt|;
specifier|const
name|cfg_listelt_t
modifier|*
name|element
decl_stmt|;
specifier|const
name|cfg_listelt_t
modifier|*
name|delement
decl_stmt|;
specifier|const
name|char
modifier|*
name|channelname
decl_stmt|;
specifier|const
name|char
modifier|*
name|catname
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|fileobj
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|syslogobj
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|nullobj
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|stderrobj
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|logobj
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_result_t
name|tresult
decl_stmt|;
name|isc_symtab_t
modifier|*
name|symtab
init|=
name|NULL
decl_stmt|;
name|isc_symvalue_t
name|symvalue
decl_stmt|;
name|int
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|config
argument_list|,
literal|"logging"
argument_list|,
operator|&
name|logobj
argument_list|)
expr_stmt|;
if|if
condition|(
name|logobj
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|result
operator|=
name|isc_symtab_create
argument_list|(
name|mctx
argument_list|,
literal|100
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ISC_FALSE
argument_list|,
operator|&
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|symvalue
operator|.
name|as_cpointer
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|default_channels
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|tresult
operator|=
name|isc_symtab_define
argument_list|(
name|symtab
argument_list|,
name|default_channels
index|[
name|i
index|]
argument_list|,
literal|1
argument_list|,
name|symvalue
argument_list|,
name|isc_symexists_replace
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
block|}
name|cfg_map_get
argument_list|(
name|logobj
argument_list|,
literal|"channel"
argument_list|,
operator|&
name|channels
argument_list|)
expr_stmt|;
for|for
control|(
name|element
operator|=
name|cfg_list_first
argument_list|(
name|channels
argument_list|)
init|;
name|element
operator|!=
name|NULL
condition|;
name|element
operator|=
name|cfg_list_next
argument_list|(
name|element
argument_list|)
control|)
block|{
name|channel
operator|=
name|cfg_listelt_value
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|channelname
operator|=
name|cfg_obj_asstring
argument_list|(
name|cfg_map_getname
argument_list|(
name|channel
argument_list|)
argument_list|)
expr_stmt|;
name|fileobj
operator|=
name|syslogobj
operator|=
name|nullobj
operator|=
name|stderrobj
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|channel
argument_list|,
literal|"file"
argument_list|,
operator|&
name|fileobj
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|channel
argument_list|,
literal|"syslog"
argument_list|,
operator|&
name|syslogobj
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|channel
argument_list|,
literal|"null"
argument_list|,
operator|&
name|nullobj
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|channel
argument_list|,
literal|"stderr"
argument_list|,
operator|&
name|stderrobj
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fileobj
operator|!=
name|NULL
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|syslogobj
operator|!=
name|NULL
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|nullobj
operator|!=
name|NULL
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|stderrobj
operator|!=
name|NULL
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|1
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|channel
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"channel '%s': exactly one of file, syslog, "
literal|"null, and stderr must be present"
argument_list|,
name|channelname
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
name|tresult
operator|=
name|isc_symtab_define
argument_list|(
name|symtab
argument_list|,
name|channelname
argument_list|,
literal|1
argument_list|,
name|symvalue
argument_list|,
name|isc_symexists_replace
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
block|}
name|cfg_map_get
argument_list|(
name|logobj
argument_list|,
literal|"category"
argument_list|,
operator|&
name|categories
argument_list|)
expr_stmt|;
for|for
control|(
name|element
operator|=
name|cfg_list_first
argument_list|(
name|categories
argument_list|)
init|;
name|element
operator|!=
name|NULL
condition|;
name|element
operator|=
name|cfg_list_next
argument_list|(
name|element
argument_list|)
control|)
block|{
name|category
operator|=
name|cfg_listelt_value
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|catname
operator|=
name|cfg_obj_asstring
argument_list|(
name|cfg_tuple_get
argument_list|(
name|category
argument_list|,
literal|"name"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_log_categorybyname
argument_list|(
name|logctx
argument_list|,
name|catname
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|category
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"undefined category: '%s'"
argument_list|,
name|catname
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
name|channels
operator|=
name|cfg_tuple_get
argument_list|(
name|category
argument_list|,
literal|"destinations"
argument_list|)
expr_stmt|;
for|for
control|(
name|delement
operator|=
name|cfg_list_first
argument_list|(
name|channels
argument_list|)
init|;
name|delement
operator|!=
name|NULL
condition|;
name|delement
operator|=
name|cfg_list_next
argument_list|(
name|delement
argument_list|)
control|)
block|{
name|channel
operator|=
name|cfg_listelt_value
argument_list|(
name|delement
argument_list|)
expr_stmt|;
name|channelname
operator|=
name|cfg_obj_asstring
argument_list|(
name|channel
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|isc_symtab_lookup
argument_list|(
name|symtab
argument_list|,
name|channelname
argument_list|,
literal|1
argument_list|,
operator|&
name|symvalue
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|channel
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"undefined channel: '%s'"
argument_list|,
name|channelname
argument_list|)
expr_stmt|;
name|result
operator|=
name|tresult
expr_stmt|;
block|}
block|}
block|}
name|isc_symtab_destroy
argument_list|(
operator|&
name|symtab
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|key_exists
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|keylist
parameter_list|,
specifier|const
name|char
modifier|*
name|keyname
parameter_list|)
block|{
specifier|const
name|cfg_listelt_t
modifier|*
name|element
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|obj
decl_stmt|;
if|if
condition|(
name|keylist
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
for|for
control|(
name|element
operator|=
name|cfg_list_first
argument_list|(
name|keylist
argument_list|)
init|;
name|element
operator|!=
name|NULL
condition|;
name|element
operator|=
name|cfg_list_next
argument_list|(
name|element
argument_list|)
control|)
block|{
name|obj
operator|=
name|cfg_listelt_value
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|str
operator|=
name|cfg_obj_asstring
argument_list|(
name|cfg_map_getname
argument_list|(
name|obj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|str
argument_list|,
name|keyname
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|bind9_check_controlskeys
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|control
parameter_list|,
specifier|const
name|cfg_obj_t
modifier|*
name|keylist
parameter_list|,
name|isc_log_t
modifier|*
name|logctx
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|,
name|tresult
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|control_keylist
decl_stmt|;
specifier|const
name|cfg_listelt_t
modifier|*
name|element
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|key
decl_stmt|;
name|control_keylist
operator|=
name|cfg_tuple_get
argument_list|(
name|control
argument_list|,
literal|"keys"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cfg_obj_isvoid
argument_list|(
name|control_keylist
argument_list|)
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
for|for
control|(
name|element
operator|=
name|cfg_list_first
argument_list|(
name|control_keylist
argument_list|)
init|;
name|element
operator|!=
name|NULL
condition|;
name|element
operator|=
name|cfg_list_next
argument_list|(
name|element
argument_list|)
control|)
block|{
name|key
operator|=
name|cfg_listelt_value
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|key_exists
argument_list|(
name|keylist
argument_list|,
name|cfg_obj_asstring
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|key
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"unknown key '%s'"
argument_list|,
name|cfg_obj_asstring
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|tresult
expr_stmt|;
block|}
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|bind9_check_controls
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|config
parameter_list|,
name|isc_log_t
modifier|*
name|logctx
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|,
name|tresult
decl_stmt|;
name|cfg_aclconfctx_t
name|actx
decl_stmt|;
specifier|const
name|cfg_listelt_t
modifier|*
name|element
decl_stmt|,
modifier|*
name|element2
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|allow
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|control
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|controls
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|controlslist
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|inetcontrols
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|unixcontrols
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|keylist
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|isc_uint32_t
name|perm
decl_stmt|,
name|mask
decl_stmt|;
name|dns_acl_t
modifier|*
name|acl
init|=
name|NULL
decl_stmt|;
name|isc_sockaddr_t
name|addr
decl_stmt|;
name|int
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|config
argument_list|,
literal|"controls"
argument_list|,
operator|&
name|controlslist
argument_list|)
expr_stmt|;
if|if
condition|(
name|controlslist
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|config
argument_list|,
literal|"key"
argument_list|,
operator|&
name|keylist
argument_list|)
expr_stmt|;
name|cfg_aclconfctx_init
argument_list|(
operator|&
name|actx
argument_list|)
expr_stmt|;
comment|/* 	 * INET: Check allow clause. 	 * UNIX: Check "perm" for sanity, check path length. 	 */
for|for
control|(
name|element
operator|=
name|cfg_list_first
argument_list|(
name|controlslist
argument_list|)
init|;
name|element
operator|!=
name|NULL
condition|;
name|element
operator|=
name|cfg_list_next
argument_list|(
name|element
argument_list|)
control|)
block|{
name|controls
operator|=
name|cfg_listelt_value
argument_list|(
name|element
argument_list|)
expr_stmt|;
name|unixcontrols
operator|=
name|NULL
expr_stmt|;
name|inetcontrols
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|controls
argument_list|,
literal|"unix"
argument_list|,
operator|&
name|unixcontrols
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|controls
argument_list|,
literal|"inet"
argument_list|,
operator|&
name|inetcontrols
argument_list|)
expr_stmt|;
for|for
control|(
name|element2
operator|=
name|cfg_list_first
argument_list|(
name|inetcontrols
argument_list|)
init|;
name|element2
operator|!=
name|NULL
condition|;
name|element2
operator|=
name|cfg_list_next
argument_list|(
name|element2
argument_list|)
control|)
block|{
name|control
operator|=
name|cfg_listelt_value
argument_list|(
name|element2
argument_list|)
expr_stmt|;
name|allow
operator|=
name|cfg_tuple_get
argument_list|(
name|control
argument_list|,
literal|"allow"
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|cfg_acl_fromconfig
argument_list|(
name|allow
argument_list|,
name|config
argument_list|,
name|logctx
argument_list|,
operator|&
name|actx
argument_list|,
name|mctx
argument_list|,
operator|&
name|acl
argument_list|)
expr_stmt|;
if|if
condition|(
name|acl
operator|!=
name|NULL
condition|)
name|dns_acl_detach
argument_list|(
operator|&
name|acl
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
name|tresult
operator|=
name|bind9_check_controlskeys
argument_list|(
name|control
argument_list|,
name|keylist
argument_list|,
name|logctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
block|}
for|for
control|(
name|element2
operator|=
name|cfg_list_first
argument_list|(
name|unixcontrols
argument_list|)
init|;
name|element2
operator|!=
name|NULL
condition|;
name|element2
operator|=
name|cfg_list_next
argument_list|(
name|element2
argument_list|)
control|)
block|{
name|control
operator|=
name|cfg_listelt_value
argument_list|(
name|element2
argument_list|)
expr_stmt|;
name|path
operator|=
name|cfg_obj_asstring
argument_list|(
name|cfg_tuple_get
argument_list|(
name|control
argument_list|,
literal|"path"
argument_list|)
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|isc_sockaddr_frompath
argument_list|(
operator|&
name|addr
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|==
name|ISC_R_NOSPACE
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|control
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"unix control '%s': path too long"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_NOSPACE
expr_stmt|;
block|}
name|perm
operator|=
name|cfg_obj_asuint32
argument_list|(
name|cfg_tuple_get
argument_list|(
name|control
argument_list|,
literal|"perm"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|NEED_SECURE_DIRECTORY
name|mask
operator|=
operator|(
literal|0x1
operator|<<
operator|(
name|i
operator|*
literal|3
operator|)
operator|)
expr_stmt|;
comment|/* SEARCH */
else|#
directive|else
name|mask
operator|=
operator|(
literal|0x6
operator|<<
operator|(
name|i
operator|*
literal|3
operator|)
operator|)
expr_stmt|;
comment|/* READ + WRITE */
endif|#
directive|endif
if|if
condition|(
operator|(
name|perm
operator|&
name|mask
operator|)
operator|==
name|mask
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|control
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"unix control '%s' allows access "
literal|"to everyone"
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|3
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|control
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"unix control '%s' allows access "
literal|"to nobody"
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
name|tresult
operator|=
name|bind9_check_controlskeys
argument_list|(
name|control
argument_list|,
name|keylist
argument_list|,
name|logctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
block|}
block|}
name|cfg_aclconfctx_destroy
argument_list|(
operator|&
name|actx
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|bind9_check_namedconf
parameter_list|(
specifier|const
name|cfg_obj_t
modifier|*
name|config
parameter_list|,
name|isc_log_t
modifier|*
name|logctx
parameter_list|,
name|isc_mem_t
modifier|*
name|mctx
parameter_list|)
block|{
specifier|const
name|cfg_obj_t
modifier|*
name|options
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|servers
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|views
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|acls
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|kals
init|=
name|NULL
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|obj
decl_stmt|;
specifier|const
name|cfg_listelt_t
modifier|*
name|velement
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_result_t
name|tresult
decl_stmt|;
name|isc_symtab_t
modifier|*
name|symtab
init|=
name|NULL
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|builtin
index|[]
init|=
block|{
literal|"localhost"
block|,
literal|"localnets"
block|,
literal|"any"
block|,
literal|"none"
block|}
decl_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|config
argument_list|,
literal|"options"
argument_list|,
operator|&
name|options
argument_list|)
expr_stmt|;
if|if
condition|(
name|options
operator|!=
name|NULL
operator|&&
name|check_options
argument_list|(
name|options
argument_list|,
name|logctx
argument_list|,
name|mctx
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|config
argument_list|,
literal|"server"
argument_list|,
operator|&
name|servers
argument_list|)
expr_stmt|;
if|if
condition|(
name|servers
operator|!=
name|NULL
operator|&&
name|check_servers
argument_list|(
name|servers
argument_list|,
name|logctx
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
if|if
condition|(
name|bind9_check_logging
argument_list|(
name|config
argument_list|,
name|logctx
argument_list|,
name|mctx
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
if|if
condition|(
name|bind9_check_controls
argument_list|(
name|config
argument_list|,
name|logctx
argument_list|,
name|mctx
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
if|if
condition|(
name|options
operator|!=
name|NULL
operator|&&
name|check_order
argument_list|(
name|options
argument_list|,
name|logctx
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|config
argument_list|,
literal|"view"
argument_list|,
operator|&
name|views
argument_list|)
expr_stmt|;
if|if
condition|(
name|views
operator|!=
name|NULL
operator|&&
name|options
operator|!=
name|NULL
condition|)
if|if
condition|(
name|check_dual_stack
argument_list|(
name|options
argument_list|,
name|logctx
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
if|if
condition|(
name|views
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|check_viewconf
argument_list|(
name|config
argument_list|,
name|NULL
argument_list|,
name|dns_rdataclass_in
argument_list|,
name|logctx
argument_list|,
name|mctx
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|cfg_obj_t
modifier|*
name|zones
init|=
name|NULL
decl_stmt|;
operator|(
name|void
operator|)
name|cfg_map_get
argument_list|(
name|config
argument_list|,
literal|"zone"
argument_list|,
operator|&
name|zones
argument_list|)
expr_stmt|;
if|if
condition|(
name|zones
operator|!=
name|NULL
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|zones
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"when using 'view' statements, "
literal|"all zones must be in views"
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
block|}
name|tresult
operator|=
name|isc_symtab_create
argument_list|(
name|mctx
argument_list|,
literal|100
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ISC_TRUE
argument_list|,
operator|&
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
for|for
control|(
name|velement
operator|=
name|cfg_list_first
argument_list|(
name|views
argument_list|)
init|;
name|velement
operator|!=
name|NULL
condition|;
name|velement
operator|=
name|cfg_list_next
argument_list|(
name|velement
argument_list|)
control|)
block|{
specifier|const
name|cfg_obj_t
modifier|*
name|view
init|=
name|cfg_listelt_value
argument_list|(
name|velement
argument_list|)
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|vname
init|=
name|cfg_tuple_get
argument_list|(
name|view
argument_list|,
literal|"name"
argument_list|)
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|voptions
init|=
name|cfg_tuple_get
argument_list|(
name|view
argument_list|,
literal|"options"
argument_list|)
decl_stmt|;
specifier|const
name|cfg_obj_t
modifier|*
name|vclassobj
init|=
name|cfg_tuple_get
argument_list|(
name|view
argument_list|,
literal|"class"
argument_list|)
decl_stmt|;
name|dns_rdataclass_t
name|vclass
init|=
name|dns_rdataclass_in
decl_stmt|;
name|isc_result_t
name|tresult
init|=
name|ISC_R_SUCCESS
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
init|=
name|cfg_obj_asstring
argument_list|(
name|vname
argument_list|)
decl_stmt|;
name|isc_symvalue_t
name|symvalue
decl_stmt|;
if|if
condition|(
name|cfg_obj_isstring
argument_list|(
name|vclassobj
argument_list|)
condition|)
block|{
name|isc_textregion_t
name|r
decl_stmt|;
name|DE_CONST
argument_list|(
name|cfg_obj_asstring
argument_list|(
name|vclassobj
argument_list|)
argument_list|,
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
name|r
operator|.
name|length
operator|=
name|strlen
argument_list|(
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|dns_rdataclass_fromtext
argument_list|(
operator|&
name|vclass
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
name|cfg_obj_log
argument_list|(
name|vclassobj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"view '%s': invalid class %s"
argument_list|,
name|cfg_obj_asstring
argument_list|(
name|vname
argument_list|)
argument_list|,
name|r
operator|.
name|base
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tresult
operator|==
name|ISC_R_SUCCESS
operator|&&
name|symtab
operator|!=
name|NULL
condition|)
block|{
name|symvalue
operator|.
name|as_cpointer
operator|=
name|view
expr_stmt|;
name|tresult
operator|=
name|isc_symtab_define
argument_list|(
name|symtab
argument_list|,
name|key
argument_list|,
name|vclass
argument_list|,
name|symvalue
argument_list|,
name|isc_symexists_reject
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|==
name|ISC_R_EXISTS
condition|)
block|{
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|unsigned
name|int
name|line
decl_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|isc_symtab_lookup
argument_list|(
name|symtab
argument_list|,
name|key
argument_list|,
name|vclass
argument_list|,
operator|&
name|symvalue
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|file
operator|=
name|cfg_obj_file
argument_list|(
name|symvalue
operator|.
name|as_cpointer
argument_list|)
expr_stmt|;
name|line
operator|=
name|cfg_obj_line
argument_list|(
name|symvalue
operator|.
name|as_cpointer
argument_list|)
expr_stmt|;
name|cfg_obj_log
argument_list|(
name|view
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"view '%s': already exists "
literal|"previous definition: %s:%u"
argument_list|,
name|key
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|result
operator|=
name|tresult
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|result
operator|=
name|tresult
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|strcasecmp
argument_list|(
name|key
argument_list|,
literal|"_bind"
argument_list|)
operator|==
literal|0
operator|&&
name|vclass
operator|==
name|dns_rdataclass_ch
operator|)
operator|||
operator|(
name|strcasecmp
argument_list|(
name|key
argument_list|,
literal|"_default"
argument_list|)
operator|==
literal|0
operator|&&
name|vclass
operator|==
name|dns_rdataclass_in
operator|)
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|view
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"attempt to redefine builtin view "
literal|"'%s'"
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_EXISTS
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tresult
operator|==
name|ISC_R_SUCCESS
condition|)
name|tresult
operator|=
name|check_viewconf
argument_list|(
name|config
argument_list|,
name|voptions
argument_list|,
name|vclass
argument_list|,
name|logctx
argument_list|,
name|mctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|ISC_R_SUCCESS
condition|)
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
if|if
condition|(
name|symtab
operator|!=
name|NULL
condition|)
name|isc_symtab_destroy
argument_list|(
operator|&
name|symtab
argument_list|)
expr_stmt|;
if|if
condition|(
name|views
operator|!=
name|NULL
operator|&&
name|options
operator|!=
name|NULL
condition|)
block|{
name|obj
operator|=
name|NULL
expr_stmt|;
name|tresult
operator|=
name|cfg_map_get
argument_list|(
name|options
argument_list|,
literal|"cache-file"
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|obj
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"'cache-file' cannot be a global "
literal|"option if views are present"
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
block|}
name|tresult
operator|=
name|cfg_map_get
argument_list|(
name|config
argument_list|,
literal|"acl"
argument_list|,
operator|&
name|acls
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
specifier|const
name|cfg_listelt_t
modifier|*
name|elt
decl_stmt|;
specifier|const
name|cfg_listelt_t
modifier|*
name|elt2
decl_stmt|;
specifier|const
name|char
modifier|*
name|aclname
decl_stmt|;
for|for
control|(
name|elt
operator|=
name|cfg_list_first
argument_list|(
name|acls
argument_list|)
init|;
name|elt
operator|!=
name|NULL
condition|;
name|elt
operator|=
name|cfg_list_next
argument_list|(
name|elt
argument_list|)
control|)
block|{
specifier|const
name|cfg_obj_t
modifier|*
name|acl
init|=
name|cfg_listelt_value
argument_list|(
name|elt
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
name|aclname
operator|=
name|cfg_obj_asstring
argument_list|(
name|cfg_tuple_get
argument_list|(
name|acl
argument_list|,
literal|"name"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|builtin
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|builtin
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcasecmp
argument_list|(
name|aclname
argument_list|,
name|builtin
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cfg_obj_log
argument_list|(
name|acl
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"attempt to redefine "
literal|"builtin acl '%s'"
argument_list|,
name|aclname
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
break|break;
block|}
for|for
control|(
name|elt2
operator|=
name|cfg_list_next
argument_list|(
name|elt
argument_list|)
init|;
name|elt2
operator|!=
name|NULL
condition|;
name|elt2
operator|=
name|cfg_list_next
argument_list|(
name|elt2
argument_list|)
control|)
block|{
specifier|const
name|cfg_obj_t
modifier|*
name|acl2
init|=
name|cfg_listelt_value
argument_list|(
name|elt2
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|cfg_obj_asstring
argument_list|(
name|cfg_tuple_get
argument_list|(
name|acl2
argument_list|,
literal|"name"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|aclname
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|file
init|=
name|cfg_obj_file
argument_list|(
name|acl
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|line
init|=
name|cfg_obj_line
argument_list|(
name|acl
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
name|file
operator|=
literal|"<unknown file>"
expr_stmt|;
name|cfg_obj_log
argument_list|(
name|acl2
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"attempt to redefine "
literal|"acl '%s' previous "
literal|"definition: %s:%u"
argument_list|,
name|name
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
block|}
block|}
block|}
name|tresult
operator|=
name|cfg_map_get
argument_list|(
name|config
argument_list|,
literal|"kal"
argument_list|,
operator|&
name|kals
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
specifier|const
name|cfg_listelt_t
modifier|*
name|elt
decl_stmt|;
specifier|const
name|cfg_listelt_t
modifier|*
name|elt2
decl_stmt|;
specifier|const
name|char
modifier|*
name|aclname
decl_stmt|;
for|for
control|(
name|elt
operator|=
name|cfg_list_first
argument_list|(
name|kals
argument_list|)
init|;
name|elt
operator|!=
name|NULL
condition|;
name|elt
operator|=
name|cfg_list_next
argument_list|(
name|elt
argument_list|)
control|)
block|{
specifier|const
name|cfg_obj_t
modifier|*
name|acl
init|=
name|cfg_listelt_value
argument_list|(
name|elt
argument_list|)
decl_stmt|;
name|aclname
operator|=
name|cfg_obj_asstring
argument_list|(
name|cfg_tuple_get
argument_list|(
name|acl
argument_list|,
literal|"name"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|elt2
operator|=
name|cfg_list_next
argument_list|(
name|elt
argument_list|)
init|;
name|elt2
operator|!=
name|NULL
condition|;
name|elt2
operator|=
name|cfg_list_next
argument_list|(
name|elt2
argument_list|)
control|)
block|{
specifier|const
name|cfg_obj_t
modifier|*
name|acl2
init|=
name|cfg_listelt_value
argument_list|(
name|elt2
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|cfg_obj_asstring
argument_list|(
name|cfg_tuple_get
argument_list|(
name|acl2
argument_list|,
literal|"name"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|aclname
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|file
init|=
name|cfg_obj_file
argument_list|(
name|acl
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|line
init|=
name|cfg_obj_line
argument_list|(
name|acl
argument_list|)
decl_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
name|file
operator|=
literal|"<unknown file>"
expr_stmt|;
name|cfg_obj_log
argument_list|(
name|acl2
argument_list|,
name|logctx
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"attempt to redefine "
literal|"kal '%s' previous "
literal|"definition: %s:%u"
argument_list|,
name|name
argument_list|,
name|file
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

end_unit

