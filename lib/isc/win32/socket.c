begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004-2012  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 2000-2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id$ */
end_comment

begin_comment
comment|/* This code uses functions which are only available on Server 2003 and  * higher, and Windows XP and higher.  *  * This code is by nature multithreaded and takes advantage of various  * features to pass on information through the completion port for  * when I/O is completed.  All sends, receives, accepts, and connects are  * completed through the completion port.  *  * The number of Completion Port Worker threads used is the total number  * of CPU's + 1. This increases the likelihood that a Worker Thread is  * available for processing a completed request.  *  * XXXPDM 5 August, 2002  */
end_comment

begin_define
define|#
directive|define
name|MAKE_EXTERNAL
value|1
end_define

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_WINSOCKAPI_
end_ifndef

begin_define
define|#
directive|define
name|_WINSOCKAPI_
end_define

begin_comment
comment|/* Prevent inclusion of winsock.h in windows.h */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_include
include|#
directive|include
file|<isc/buffer.h>
end_include

begin_include
include|#
directive|include
file|<isc/bufferlist.h>
end_include

begin_include
include|#
directive|include
file|<isc/condition.h>
end_include

begin_include
include|#
directive|include
file|<isc/list.h>
end_include

begin_include
include|#
directive|include
file|<isc/log.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/msgs.h>
end_include

begin_include
include|#
directive|include
file|<isc/mutex.h>
end_include

begin_include
include|#
directive|include
file|<isc/net.h>
end_include

begin_include
include|#
directive|include
file|<isc/once.h>
end_include

begin_include
include|#
directive|include
file|<isc/os.h>
end_include

begin_include
include|#
directive|include
file|<isc/platform.h>
end_include

begin_include
include|#
directive|include
file|<isc/print.h>
end_include

begin_include
include|#
directive|include
file|<isc/region.h>
end_include

begin_include
include|#
directive|include
file|<isc/socket.h>
end_include

begin_include
include|#
directive|include
file|<isc/stats.h>
end_include

begin_include
include|#
directive|include
file|<isc/strerror.h>
end_include

begin_include
include|#
directive|include
file|<isc/syslog.h>
end_include

begin_include
include|#
directive|include
file|<isc/task.h>
end_include

begin_include
include|#
directive|include
file|<isc/thread.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<isc/win32os.h>
end_include

begin_include
include|#
directive|include
file|<mswsock.h>
end_include

begin_include
include|#
directive|include
file|"errno2result.h"
end_include

begin_comment
comment|/*  * How in the world can Microsoft exist with APIs like this?  * We can't actually call this directly, because it turns out  * no library exports this function.  Instead, we need to  * issue a runtime call to get the address.  */
end_comment

begin_decl_stmt
name|LPFN_CONNECTEX
name|ISCConnectEx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LPFN_ACCEPTEX
name|ISCAcceptEx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|LPFN_GETACCEPTEXSOCKADDRS
name|ISCGetAcceptExSockaddrs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Run expensive internal consistency checks.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ISC_SOCKET_CONSISTENCY_CHECKS
end_ifdef

begin_define
define|#
directive|define
name|CONSISTENT
parameter_list|(
name|sock
parameter_list|)
value|consistent(sock)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|CONSISTENT
parameter_list|(
name|sock
parameter_list|)
value|do {} while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|consistent
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Define this macro to control the behavior of connection  * resets on UDP sockets.  See Microsoft KnowledgeBase Article Q263823  * for details.  * NOTE: This requires that Windows 2000 systems install Service Pack 2  * or later.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIO_UDP_CONNRESET
end_ifndef

begin_define
define|#
directive|define
name|SIO_UDP_CONNRESET
value|_WSAIOW(IOC_VENDOR,12)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Some systems define the socket length argument as an int, some as size_t,  * some as socklen_t.  This is here so it can be easily changed if needed.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ISC_SOCKADDR_LEN_T
end_ifndef

begin_define
define|#
directive|define
name|ISC_SOCKADDR_LEN_T
value|unsigned int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Define what the possible "soft" errors can be.  These are non-fatal returns  * of various network related functions, like recv() and so on.  */
end_comment

begin_define
define|#
directive|define
name|SOFT_ERROR
parameter_list|(
name|e
parameter_list|)
value|((e) == WSAEINTR || \ 			 (e) == WSAEWOULDBLOCK || \ 			 (e) == EWOULDBLOCK || \ 			 (e) == EINTR || \ 			 (e) == EAGAIN || \ 			 (e) == 0)
end_define

begin_comment
comment|/*  * Pending errors are not really errors and should be  * kept separate  */
end_comment

begin_define
define|#
directive|define
name|PENDING_ERROR
parameter_list|(
name|e
parameter_list|)
value|((e) == WSA_IO_PENDING || (e) == 0)
end_define

begin_define
define|#
directive|define
name|DOIO_SUCCESS
value|0
end_define

begin_comment
comment|/* i/o ok, event sent */
end_comment

begin_define
define|#
directive|define
name|DOIO_SOFT
value|1
end_define

begin_comment
comment|/* i/o ok, soft error, no event sent */
end_comment

begin_define
define|#
directive|define
name|DOIO_HARD
value|2
end_define

begin_comment
comment|/* i/o error, event sent */
end_comment

begin_define
define|#
directive|define
name|DOIO_EOF
value|3
end_define

begin_comment
comment|/* EOF, no event sent */
end_comment

begin_define
define|#
directive|define
name|DOIO_PENDING
value|4
end_define

begin_comment
comment|/* status when i/o is in process */
end_comment

begin_define
define|#
directive|define
name|DOIO_NEEDMORE
value|5
end_define

begin_comment
comment|/* IO was processed, but we need more due to minimum */
end_comment

begin_define
define|#
directive|define
name|DLVL
parameter_list|(
name|x
parameter_list|)
value|ISC_LOGCATEGORY_GENERAL, ISC_LOGMODULE_SOCKET, ISC_LOG_DEBUG(x)
end_define

begin_comment
comment|/*  * DLVL(90)  --  Function entry/exit and other tracing.  * DLVL(70)  --  Socket "correctness" -- including returning of events, etc.  * DLVL(60)  --  Socket data send/receive  * DLVL(50)  --  Event tracing, including receiving/sending completion events.  * DLVL(20)  --  Socket creation/destruction.  */
end_comment

begin_define
define|#
directive|define
name|TRACE_LEVEL
value|90
end_define

begin_define
define|#
directive|define
name|CORRECTNESS_LEVEL
value|70
end_define

begin_define
define|#
directive|define
name|IOEVENT_LEVEL
value|60
end_define

begin_define
define|#
directive|define
name|EVENT_LEVEL
value|50
end_define

begin_define
define|#
directive|define
name|CREATION_LEVEL
value|20
end_define

begin_define
define|#
directive|define
name|TRACE
value|DLVL(TRACE_LEVEL)
end_define

begin_define
define|#
directive|define
name|CORRECTNESS
value|DLVL(CORRECTNESS_LEVEL)
end_define

begin_define
define|#
directive|define
name|IOEVENT
value|DLVL(IOEVENT_LEVEL)
end_define

begin_define
define|#
directive|define
name|EVENT
value|DLVL(EVENT_LEVEL)
end_define

begin_define
define|#
directive|define
name|CREATION
value|DLVL(CREATION_LEVEL)
end_define

begin_typedef
typedef|typedef
name|isc_event_t
name|intev_t
typedef|;
end_typedef

begin_comment
comment|/*  * Socket State  */
end_comment

begin_enum
enum|enum
block|{
name|SOCK_INITIALIZED
block|,
comment|/* Socket Initialized */
name|SOCK_OPEN
block|,
comment|/* Socket opened but nothing yet to do */
name|SOCK_DATA
block|,
comment|/* Socket sending or receiving data */
name|SOCK_LISTEN
block|,
comment|/* TCP Socket listening for connects */
name|SOCK_ACCEPT
block|,
comment|/* TCP socket is waiting to accept */
name|SOCK_CONNECT
block|,
comment|/* TCP Socket connecting */
name|SOCK_CLOSED
block|,
comment|/* Socket has been closed */
block|}
enum|;
end_enum

begin_define
define|#
directive|define
name|SOCKET_MAGIC
value|ISC_MAGIC('I', 'O', 'i', 'o')
end_define

begin_define
define|#
directive|define
name|VALID_SOCKET
parameter_list|(
name|t
parameter_list|)
value|ISC_MAGIC_VALID(t, SOCKET_MAGIC)
end_define

begin_comment
comment|/*  * IPv6 control information.  If the socket is an IPv6 socket we want  * to collect the destination address and interface so the client can  * set them on outgoing packets.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ISC_PLATFORM_HAVEIPV6
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|USE_CMSG
end_ifndef

begin_define
define|#
directive|define
name|USE_CMSG
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * We really  don't want to try and use these control messages. Win32  * doesn't have this mechanism before XP.  */
end_comment

begin_undef
undef|#
directive|undef
name|USE_CMSG
end_undef

begin_comment
comment|/*  * Message header for recvmsg and sendmsg calls.  * Used value-result for recvmsg, value only for sendmsg.  */
end_comment

begin_struct
struct|struct
name|msghdr
block|{
name|SOCKADDR_STORAGE
name|to_addr
decl_stmt|;
comment|/* UDP send/recv address */
name|int
name|to_addr_len
decl_stmt|;
comment|/* length of the address */
name|WSABUF
modifier|*
name|msg_iov
decl_stmt|;
comment|/* scatter/gather array */
name|u_int
name|msg_iovlen
decl_stmt|;
comment|/* # elements in msg_iov */
name|void
modifier|*
name|msg_control
decl_stmt|;
comment|/* ancillary data, see below */
name|u_int
name|msg_controllen
decl_stmt|;
comment|/* ancillary data buffer len */
name|int
name|msg_totallen
decl_stmt|;
comment|/* total length of this message */
block|}
name|msghdr
struct|;
end_struct

begin_comment
comment|/*  * The size to raise the receive buffer to.  */
end_comment

begin_define
define|#
directive|define
name|RCVBUFSIZE
value|(32*1024)
end_define

begin_comment
comment|/*  * The number of times a send operation is repeated if the result  * is WSAEINTR.  */
end_comment

begin_define
define|#
directive|define
name|NRETRIES
value|10
end_define

begin_struct
struct|struct
name|isc_socket
block|{
comment|/* Not locked. */
name|unsigned
name|int
name|magic
decl_stmt|;
name|isc_socketmgr_t
modifier|*
name|manager
decl_stmt|;
name|isc_mutex_t
name|lock
decl_stmt|;
name|isc_sockettype_t
name|type
decl_stmt|;
comment|/* Pointers to scatter/gather buffers */
name|WSABUF
name|iov
index|[
name|ISC_SOCKET_MAXSCATTERGATHER
index|]
decl_stmt|;
comment|/* Locked by socket lock. */
name|ISC_LINK
argument_list|(
argument|isc_socket_t
argument_list|)
name|link
expr_stmt|;
name|unsigned
name|int
name|references
decl_stmt|;
comment|/* EXTERNAL references */
name|SOCKET
name|fd
decl_stmt|;
comment|/* file handle */
name|int
name|pf
decl_stmt|;
comment|/* protocol family */
name|char
name|name
index|[
literal|16
index|]
decl_stmt|;
name|void
modifier|*
name|tag
decl_stmt|;
comment|/* 	 * Each recv() call uses this buffer.  It is a per-socket receive 	 * buffer that allows us to decouple the system recv() from the 	 * recv_list done events.  This means the items on the recv_list 	 * can be removed without having to cancel pending system recv() 	 * calls.  It also allows us to read-ahead in some cases. 	 */
struct|struct
block|{
name|SOCKADDR_STORAGE
name|from_addr
decl_stmt|;
comment|// UDP send/recv address
name|int
name|from_addr_len
decl_stmt|;
comment|// length of the address
name|char
modifier|*
name|base
decl_stmt|;
comment|// the base of the buffer
name|char
modifier|*
name|consume_position
decl_stmt|;
comment|// where to start copying data from next
name|unsigned
name|int
name|len
decl_stmt|;
comment|// the actual size of this buffer
name|unsigned
name|int
name|remaining
decl_stmt|;
comment|// the number of bytes remaining
block|}
name|recvbuf
struct|;
name|ISC_LIST
argument_list|(
argument|isc_socketevent_t
argument_list|)
name|send_list
expr_stmt|;
name|ISC_LIST
argument_list|(
argument|isc_socketevent_t
argument_list|)
name|recv_list
expr_stmt|;
name|ISC_LIST
argument_list|(
argument|isc_socket_newconnev_t
argument_list|)
name|accept_list
expr_stmt|;
name|isc_socket_connev_t
modifier|*
name|connect_ev
decl_stmt|;
name|isc_sockaddr_t
name|address
decl_stmt|;
comment|/* remote address */
name|unsigned
name|int
name|listener
range|:
literal|1
decl_stmt|,
comment|/* listener socket */
name|connected
range|:
literal|1
decl_stmt|,
name|pending_connect
range|:
literal|1
decl_stmt|,
comment|/* connect pending */
name|bound
range|:
literal|1
decl_stmt|,
comment|/* bound to local addr */
name|dupped
range|:
literal|1
decl_stmt|;
comment|/* created by isc_socket_dup() */
name|unsigned
name|int
name|pending_iocp
decl_stmt|;
comment|/* Should equal the counters below. Debug. */
name|unsigned
name|int
name|pending_recv
decl_stmt|;
comment|/* Number of outstanding recv() calls. */
name|unsigned
name|int
name|pending_send
decl_stmt|;
comment|/* Number of outstanding send() calls. */
name|unsigned
name|int
name|pending_accept
decl_stmt|;
comment|/* Number of outstanding accept() calls. */
name|unsigned
name|int
name|state
decl_stmt|;
comment|/* Socket state. Debugging and consistency checking. */
name|int
name|state_lineno
decl_stmt|;
comment|/* line which last touched state */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|_set_state
parameter_list|(
name|sock
parameter_list|,
name|_state
parameter_list|)
value|do { (sock)->state = (_state); (sock)->state_lineno = __LINE__; } while (0)
end_define

begin_comment
comment|/*  * Buffer structure  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|buflist
name|buflist_t
typedef|;
end_typedef

begin_struct
struct|struct
name|buflist
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|int
name|buflen
decl_stmt|;
name|ISC_LINK
argument_list|(
argument|buflist_t
argument_list|)
name|link
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * I/O Completion ports Info structures  */
end_comment

begin_decl_stmt
specifier|static
name|HANDLE
name|hHeapHandle
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|IoCompletionInfo
block|{
name|OVERLAPPED
name|overlapped
decl_stmt|;
name|isc_socketevent_t
modifier|*
name|dev
decl_stmt|;
comment|/* send()/recv() done event */
name|isc_socket_connev_t
modifier|*
name|cdev
decl_stmt|;
comment|/* connect() done event */
name|isc_socket_newconnev_t
modifier|*
name|adev
decl_stmt|;
comment|/* accept() done event */
name|void
modifier|*
name|acceptbuffer
decl_stmt|;
name|DWORD
name|received_bytes
decl_stmt|;
name|int
name|request_type
decl_stmt|;
name|struct
name|msghdr
name|messagehdr
decl_stmt|;
name|ISC_LIST
argument_list|(
argument|buflist_t
argument_list|)
name|bufferlist
expr_stmt|;
comment|/*%< list of buffers */
block|}
name|IoCompletionInfo
typedef|;
end_typedef

begin_comment
comment|/*  * Define a maximum number of I/O Completion Port worker threads  * to handle the load on the Completion Port. The actual number  * used is the number of CPU's + 1.  */
end_comment

begin_define
define|#
directive|define
name|MAX_IOCPTHREADS
value|20
end_define

begin_define
define|#
directive|define
name|SOCKET_MANAGER_MAGIC
value|ISC_MAGIC('I', 'O', 'm', 'g')
end_define

begin_define
define|#
directive|define
name|VALID_MANAGER
parameter_list|(
name|m
parameter_list|)
value|ISC_MAGIC_VALID(m, SOCKET_MANAGER_MAGIC)
end_define

begin_struct
struct|struct
name|isc_socketmgr
block|{
comment|/* Not locked. */
name|unsigned
name|int
name|magic
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|isc_mutex_t
name|lock
decl_stmt|;
name|isc_stats_t
modifier|*
name|stats
decl_stmt|;
comment|/* Locked by manager lock. */
name|ISC_LIST
argument_list|(
argument|isc_socket_t
argument_list|)
name|socklist
expr_stmt|;
name|isc_boolean_t
name|bShutdown
decl_stmt|;
name|isc_condition_t
name|shutdown_ok
decl_stmt|;
name|HANDLE
name|hIoCompletionPort
decl_stmt|;
name|int
name|maxIOCPThreads
decl_stmt|;
name|HANDLE
name|hIOCPThreads
index|[
name|MAX_IOCPTHREADS
index|]
decl_stmt|;
name|DWORD
name|dwIOCPThreadIds
index|[
name|MAX_IOCPTHREADS
index|]
decl_stmt|;
comment|/* 	 * Debugging. 	 * Modified by InterlockedIncrement() and InterlockedDecrement() 	 */
name|LONG
name|totalSockets
decl_stmt|;
name|LONG
name|iocp_total
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
block|{
name|SOCKET_RECV
block|,
name|SOCKET_SEND
block|,
name|SOCKET_ACCEPT
block|,
name|SOCKET_CONNECT
block|}
enum|;
end_enum

begin_comment
comment|/*  * send() and recv() iovec counts  */
end_comment

begin_define
define|#
directive|define
name|MAXSCATTERGATHER_SEND
value|(ISC_SOCKET_MAXSCATTERGATHER)
end_define

begin_define
define|#
directive|define
name|MAXSCATTERGATHER_RECV
value|(ISC_SOCKET_MAXSCATTERGATHER)
end_define

begin_function_decl
specifier|static
name|isc_result_t
name|socket_create
parameter_list|(
name|isc_socketmgr_t
modifier|*
name|manager0
parameter_list|,
name|int
name|pf
parameter_list|,
name|isc_sockettype_t
name|type
parameter_list|,
name|isc_socket_t
modifier|*
modifier|*
name|socketp
parameter_list|,
name|isc_socket_t
modifier|*
name|dup_socket
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_threadresult_t
name|WINAPI
name|SocketIoThread
parameter_list|(
name|LPVOID
name|ThreadContext
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|maybe_free_socket
parameter_list|(
name|isc_socket_t
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_socket
parameter_list|(
name|isc_socket_t
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_boolean_t
name|senddone_is_active
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socketevent_t
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_boolean_t
name|acceptdone_is_active
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socket_newconnev_t
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_boolean_t
name|connectdone_is_active
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socket_connev_t
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|send_recvdone_event
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socketevent_t
modifier|*
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|send_senddone_event
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socketevent_t
modifier|*
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|send_acceptdone_event
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socket_newconnev_t
modifier|*
modifier|*
name|adev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|send_connectdone_event
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socket_connev_t
modifier|*
modifier|*
name|cdev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|send_recvdone_abort
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_result_t
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|queue_receive_event
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_socketevent_t
modifier|*
name|dev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|queue_receive_request
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * This is used to dump the contents of the sock structure  * You should make sure that the sock is locked before  * dumping it. Since the code uses simple printf() statements  * it should only be used interactively.  */
end_comment

begin_function
name|void
name|sock_dump
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|)
block|{
name|isc_socketevent_t
modifier|*
name|ldev
decl_stmt|;
name|isc_socket_newconnev_t
modifier|*
name|ndev
decl_stmt|;
if|#
directive|if
literal|0
block|isc_sockaddr_t addr; 	char socktext[256];  	isc_socket_getpeername(sock,&addr); 	isc_sockaddr_format(&addr, socktext, sizeof(socktext)); 	printf("Remote Socket: %s\n", socktext); 	isc_socket_getsockname(sock,&addr); 	isc_sockaddr_format(&addr, socktext, sizeof(socktext)); 	printf("This Socket: %s\n", socktext);
endif|#
directive|endif
name|printf
argument_list|(
literal|"\n\t\tSock Dump\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t\tfd: %u\n"
argument_list|,
name|sock
operator|->
name|fd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t\treferences: %d\n"
argument_list|,
name|sock
operator|->
name|references
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t\tpending_accept: %d\n"
argument_list|,
name|sock
operator|->
name|pending_accept
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t\tconnecting: %d\n"
argument_list|,
name|sock
operator|->
name|pending_connect
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t\tconnected: %d\n"
argument_list|,
name|sock
operator|->
name|connected
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t\tbound: %d\n"
argument_list|,
name|sock
operator|->
name|bound
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t\tpending_iocp: %d\n"
argument_list|,
name|sock
operator|->
name|pending_iocp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t\tsocket type: %d\n"
argument_list|,
name|sock
operator|->
name|type
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\t\tSock Recv List\n"
argument_list|)
expr_stmt|;
name|ldev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|ldev
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"\t\tdev: %p\n"
argument_list|,
name|ldev
argument_list|)
expr_stmt|;
name|ldev
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|ldev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n\t\tSock Send List\n"
argument_list|)
expr_stmt|;
name|ldev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sock
operator|->
name|send_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|ldev
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"\t\tdev: %p\n"
argument_list|,
name|ldev
argument_list|)
expr_stmt|;
name|ldev
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|ldev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n\t\tSock Accept List\n"
argument_list|)
expr_stmt|;
name|ndev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sock
operator|->
name|accept_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|ndev
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"\t\tdev: %p\n"
argument_list|,
name|ldev
argument_list|)
expr_stmt|;
name|ndev
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|ndev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function_decl
specifier|static
name|void
name|socket_log
parameter_list|(
name|int
name|lineno
parameter_list|,
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|address
parameter_list|,
name|isc_logcategory_t
modifier|*
name|category
parameter_list|,
name|isc_logmodule_t
modifier|*
name|module
parameter_list|,
name|int
name|level
parameter_list|,
name|isc_msgcat_t
modifier|*
name|msgcat
parameter_list|,
name|int
name|msgset
parameter_list|,
name|int
name|message
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|ISC_FORMAT_PRINTF
parameter_list|(
function_decl|9
operator|,
function_decl|10
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_comment
comment|/*  This function will add an entry to the I/O completion port  *  that will signal the I/O thread to exit (gracefully)  */
end_comment

begin_function
specifier|static
name|void
name|signal_iocompletionport_exit
parameter_list|(
name|isc_socketmgr_t
modifier|*
name|manager
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|errval
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|manager
operator|->
name|maxIOCPThreads
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|PostQueuedCompletionStatus
argument_list|(
name|manager
operator|->
name|hIoCompletionPort
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|errval
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
name|isc__strerror
argument_list|(
name|errval
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|FATAL_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"Can't request service thread to exit: %s"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Create the worker threads for the I/O Completion Port  */
end_comment

begin_function
name|void
name|iocompletionport_createthreads
parameter_list|(
name|int
name|total_threads
parameter_list|,
name|isc_socketmgr_t
modifier|*
name|manager
parameter_list|)
block|{
name|int
name|errval
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|INSIST
argument_list|(
name|total_threads
operator|>
literal|0
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * We need at least one 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|total_threads
condition|;
name|i
operator|++
control|)
block|{
name|manager
operator|->
name|hIOCPThreads
index|[
name|i
index|]
operator|=
name|CreateThread
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|SocketIoThread
argument_list|,
name|manager
argument_list|,
literal|0
argument_list|,
operator|&
name|manager
operator|->
name|dwIOCPThreadIds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|hIOCPThreads
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|errval
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
name|isc__strerror
argument_list|(
name|errval
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|FATAL_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"Can't create IOCP thread: %s"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  *  Create/initialise the I/O completion port  */
end_comment

begin_function
name|void
name|iocompletionport_init
parameter_list|(
name|isc_socketmgr_t
modifier|*
name|manager
parameter_list|)
block|{
name|int
name|errval
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Create a private heap to handle the socket overlapped structure 	 * The minimum number of structures is 10, there is no maximum 	 */
name|hHeapHandle
operator|=
name|HeapCreate
argument_list|(
literal|0
argument_list|,
literal|10
operator|*
sizeof|sizeof
argument_list|(
name|IoCompletionInfo
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hHeapHandle
operator|==
name|NULL
condition|)
block|{
name|errval
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
name|isc__strerror
argument_list|(
name|errval
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|FATAL_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"HeapCreate() failed during "
literal|"initialization: %s"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|manager
operator|->
name|maxIOCPThreads
operator|=
name|min
argument_list|(
name|isc_os_ncpus
argument_list|()
operator|+
literal|1
argument_list|,
name|MAX_IOCPTHREADS
argument_list|)
expr_stmt|;
comment|/* Now Create the Completion Port */
name|manager
operator|->
name|hIoCompletionPort
operator|=
name|CreateIoCompletionPort
argument_list|(
name|INVALID_HANDLE_VALUE
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|manager
operator|->
name|maxIOCPThreads
argument_list|)
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|hIoCompletionPort
operator|==
name|NULL
condition|)
block|{
name|errval
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
name|isc__strerror
argument_list|(
name|errval
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|FATAL_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"CreateIoCompletionPort() failed "
literal|"during initialization: %s"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Worker threads for servicing the I/O 	 */
name|iocompletionport_createthreads
argument_list|(
name|manager
operator|->
name|maxIOCPThreads
argument_list|,
name|manager
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Associate a socket with an IO Completion Port.  This allows us to queue events for it  * and have our worker pool of threads process them.  */
end_comment

begin_function
name|void
name|iocompletionport_update
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|)
block|{
name|HANDLE
name|hiocp
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|hiocp
operator|=
name|CreateIoCompletionPort
argument_list|(
operator|(
name|HANDLE
operator|)
name|sock
operator|->
name|fd
argument_list|,
name|sock
operator|->
name|manager
operator|->
name|hIoCompletionPort
argument_list|,
operator|(
name|ULONG_PTR
operator|)
name|sock
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|hiocp
operator|==
name|NULL
condition|)
block|{
name|DWORD
name|errval
init|=
name|GetLastError
argument_list|()
decl_stmt|;
name|isc__strerror
argument_list|(
name|errval
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_iwrite
argument_list|(
name|isc_lctx
argument_list|,
name|ISC_LOGCATEGORY_GENERAL
argument_list|,
name|ISC_LOGMODULE_SOCKET
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_TOOMANYHANDLES
argument_list|,
literal|"iocompletionport_update: failed to open"
literal|" io completion port: %s"
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
comment|/* XXXMLG temporary hack to make failures detected. 		 * This function should return errors to the caller, not 		 * exit here. 		 */
name|FATAL_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"CreateIoCompletionPort() failed "
literal|"during initialization: %s"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|InterlockedIncrement
argument_list|(
operator|&
name|sock
operator|->
name|manager
operator|->
name|iocp_total
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Routine to cleanup and then close the socket.  * Only close the socket here if it is NOT associated  * with an event, otherwise the WSAWaitForMultipleEvents  * may fail due to the fact that the Wait should not  * be running while closing an event or a socket.  * The socket is locked before calling this function  */
end_comment

begin_function
name|void
name|socket_close
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|sock
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|fd
operator|!=
name|INVALID_SOCKET
condition|)
block|{
name|closesocket
argument_list|(
name|sock
operator|->
name|fd
argument_list|)
expr_stmt|;
name|sock
operator|->
name|fd
operator|=
name|INVALID_SOCKET
expr_stmt|;
name|_set_state
argument_list|(
name|sock
argument_list|,
name|SOCK_CLOSED
argument_list|)
expr_stmt|;
name|InterlockedDecrement
argument_list|(
operator|&
name|sock
operator|->
name|manager
operator|->
name|totalSockets
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|isc_once_t
name|initialise_once
init|=
name|ISC_ONCE_INIT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|isc_boolean_t
name|initialised
init|=
name|ISC_FALSE
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|initialise
parameter_list|(
name|void
parameter_list|)
block|{
name|WORD
name|wVersionRequested
decl_stmt|;
name|WSADATA
name|wsaData
decl_stmt|;
name|int
name|err
decl_stmt|;
name|SOCKET
name|sock
decl_stmt|;
name|GUID
name|GUIDConnectEx
init|=
name|WSAID_CONNECTEX
decl_stmt|;
name|GUID
name|GUIDAcceptEx
init|=
name|WSAID_ACCEPTEX
decl_stmt|;
name|GUID
name|GUIDGetAcceptExSockaddrs
init|=
name|WSAID_GETACCEPTEXSOCKADDRS
decl_stmt|;
name|DWORD
name|dwBytes
decl_stmt|;
comment|/* Need Winsock 2.2 or better */
name|wVersionRequested
operator|=
name|MAKEWORD
argument_list|(
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|err
operator|=
name|WSAStartup
argument_list|(
name|wVersionRequested
argument_list|,
operator|&
name|wsaData
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|isc__strerror
argument_list|(
name|err
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|FATAL_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"WSAStartup() %s: %s"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The following APIs do not exist as functions in a library, but we must 	 * ask winsock for them.  They are "extensions" -- but why they cannot be 	 * actual functions is beyond me.  So, ask winsock for the pointers to the 	 * functions we need. 	 */
name|sock
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|!=
name|INVALID_SOCKET
argument_list|)
expr_stmt|;
name|err
operator|=
name|WSAIoctl
argument_list|(
name|sock
argument_list|,
name|SIO_GET_EXTENSION_FUNCTION_POINTER
argument_list|,
operator|&
name|GUIDConnectEx
argument_list|,
sizeof|sizeof
argument_list|(
name|GUIDConnectEx
argument_list|)
argument_list|,
operator|&
name|ISCConnectEx
argument_list|,
sizeof|sizeof
argument_list|(
name|ISCConnectEx
argument_list|)
argument_list|,
operator|&
name|dwBytes
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|err
operator|==
literal|0
argument_list|)
expr_stmt|;
name|err
operator|=
name|WSAIoctl
argument_list|(
name|sock
argument_list|,
name|SIO_GET_EXTENSION_FUNCTION_POINTER
argument_list|,
operator|&
name|GUIDAcceptEx
argument_list|,
sizeof|sizeof
argument_list|(
name|GUIDAcceptEx
argument_list|)
argument_list|,
operator|&
name|ISCAcceptEx
argument_list|,
sizeof|sizeof
argument_list|(
name|ISCAcceptEx
argument_list|)
argument_list|,
operator|&
name|dwBytes
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|err
operator|==
literal|0
argument_list|)
expr_stmt|;
name|err
operator|=
name|WSAIoctl
argument_list|(
name|sock
argument_list|,
name|SIO_GET_EXTENSION_FUNCTION_POINTER
argument_list|,
operator|&
name|GUIDGetAcceptExSockaddrs
argument_list|,
sizeof|sizeof
argument_list|(
name|GUIDGetAcceptExSockaddrs
argument_list|)
argument_list|,
operator|&
name|ISCGetAcceptExSockaddrs
argument_list|,
sizeof|sizeof
argument_list|(
name|ISCGetAcceptExSockaddrs
argument_list|)
argument_list|,
operator|&
name|dwBytes
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|err
operator|==
literal|0
argument_list|)
expr_stmt|;
name|closesocket
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|initialised
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Initialize socket services  */
end_comment

begin_function
name|void
name|InitSockets
parameter_list|(
name|void
parameter_list|)
block|{
name|RUNTIME_CHECK
argument_list|(
name|isc_once_do
argument_list|(
operator|&
name|initialise_once
argument_list|,
name|initialise
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|initialised
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|internal_sendmsg
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|IoCompletionInfo
modifier|*
name|lpo
parameter_list|,
name|struct
name|msghdr
modifier|*
name|messagehdr
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|Error
parameter_list|)
block|{
name|int
name|Result
decl_stmt|;
name|DWORD
name|BytesSent
decl_stmt|;
name|DWORD
name|Flags
init|=
name|flags
decl_stmt|;
name|int
name|total_sent
decl_stmt|;
operator|*
name|Error
operator|=
literal|0
expr_stmt|;
name|Result
operator|=
name|WSASendTo
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|messagehdr
operator|->
name|msg_iov
argument_list|,
name|messagehdr
operator|->
name|msg_iovlen
argument_list|,
operator|&
name|BytesSent
argument_list|,
name|Flags
argument_list|,
operator|(
name|SOCKADDR
operator|*
operator|)
operator|&
name|messagehdr
operator|->
name|to_addr
argument_list|,
name|messagehdr
operator|->
name|to_addr_len
argument_list|,
operator|(
name|LPWSAOVERLAPPED
operator|)
name|lpo
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|total_sent
operator|=
operator|(
name|int
operator|)
name|BytesSent
expr_stmt|;
comment|/* Check for errors.*/
if|if
condition|(
name|Result
operator|==
name|SOCKET_ERROR
condition|)
block|{
operator|*
name|Error
operator|=
name|WSAGetLastError
argument_list|()
expr_stmt|;
switch|switch
condition|(
operator|*
name|Error
condition|)
block|{
case|case
name|WSA_IO_INCOMPLETE
case|:
case|case
name|WSA_WAIT_IO_COMPLETION
case|:
case|case
name|WSA_IO_PENDING
case|:
case|case
name|NO_ERROR
case|:
comment|/* Strange, but okay */
name|sock
operator|->
name|pending_iocp
operator|++
expr_stmt|;
name|sock
operator|->
name|pending_send
operator|++
expr_stmt|;
break|break;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
break|break;
block|}
block|}
else|else
block|{
name|sock
operator|->
name|pending_iocp
operator|++
expr_stmt|;
name|sock
operator|->
name|pending_send
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|lpo
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|total_sent
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|queue_receive_request
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|)
block|{
name|DWORD
name|Flags
init|=
literal|0
decl_stmt|;
name|DWORD
name|NumBytes
init|=
literal|0
decl_stmt|;
name|int
name|total_bytes
init|=
literal|0
decl_stmt|;
name|int
name|Result
decl_stmt|;
name|int
name|Error
decl_stmt|;
name|int
name|need_retry
decl_stmt|;
name|WSABUF
name|iov
index|[
literal|1
index|]
decl_stmt|;
name|IoCompletionInfo
modifier|*
name|lpo
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|isc_result
decl_stmt|;
name|retry
label|:
name|need_retry
operator|=
name|ISC_FALSE
expr_stmt|;
comment|/* 	 * If we already have a receive pending, do nothing. 	 */
if|if
condition|(
name|sock
operator|->
name|pending_recv
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|lpo
operator|!=
name|NULL
condition|)
name|HeapFree
argument_list|(
name|hHeapHandle
argument_list|,
literal|0
argument_list|,
name|lpo
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * If no one is waiting, do nothing. 	 */
if|if
condition|(
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|)
condition|)
block|{
if|if
condition|(
name|lpo
operator|!=
name|NULL
condition|)
name|HeapFree
argument_list|(
name|hHeapHandle
argument_list|,
literal|0
argument_list|,
name|lpo
argument_list|)
expr_stmt|;
return|return;
block|}
name|INSIST
argument_list|(
name|sock
operator|->
name|recvbuf
operator|.
name|remaining
operator|==
literal|0
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|fd
operator|!=
name|INVALID_SOCKET
argument_list|)
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|len
operator|=
name|sock
operator|->
name|recvbuf
operator|.
name|len
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|buf
operator|=
name|sock
operator|->
name|recvbuf
operator|.
name|base
expr_stmt|;
if|if
condition|(
name|lpo
operator|==
name|NULL
condition|)
block|{
name|lpo
operator|=
operator|(
name|IoCompletionInfo
operator|*
operator|)
name|HeapAlloc
argument_list|(
name|hHeapHandle
argument_list|,
name|HEAP_ZERO_MEMORY
argument_list|,
sizeof|sizeof
argument_list|(
name|IoCompletionInfo
argument_list|)
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|lpo
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
name|ZeroMemory
argument_list|(
name|lpo
argument_list|,
sizeof|sizeof
argument_list|(
name|IoCompletionInfo
argument_list|)
argument_list|)
expr_stmt|;
name|lpo
operator|->
name|request_type
operator|=
name|SOCKET_RECV
expr_stmt|;
name|sock
operator|->
name|recvbuf
operator|.
name|from_addr_len
operator|=
sizeof|sizeof
argument_list|(
name|sock
operator|->
name|recvbuf
operator|.
name|from_addr
argument_list|)
expr_stmt|;
name|Error
operator|=
literal|0
expr_stmt|;
name|Result
operator|=
name|WSARecvFrom
argument_list|(
operator|(
name|SOCKET
operator|)
name|sock
operator|->
name|fd
argument_list|,
name|iov
argument_list|,
literal|1
argument_list|,
operator|&
name|NumBytes
argument_list|,
operator|&
name|Flags
argument_list|,
operator|(
name|SOCKADDR
operator|*
operator|)
operator|&
name|sock
operator|->
name|recvbuf
operator|.
name|from_addr
argument_list|,
operator|&
name|sock
operator|->
name|recvbuf
operator|.
name|from_addr_len
argument_list|,
operator|(
name|LPWSAOVERLAPPED
operator|)
name|lpo
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Check for errors. */
if|if
condition|(
name|Result
operator|==
name|SOCKET_ERROR
condition|)
block|{
name|Error
operator|=
name|WSAGetLastError
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|Error
condition|)
block|{
case|case
name|WSA_IO_PENDING
case|:
name|sock
operator|->
name|pending_iocp
operator|++
expr_stmt|;
name|sock
operator|->
name|pending_recv
operator|++
expr_stmt|;
break|break;
comment|/* direct error: no completion event */
case|case
name|ERROR_HOST_UNREACHABLE
case|:
case|case
name|WSAENETRESET
case|:
case|case
name|WSAECONNRESET
case|:
if|if
condition|(
operator|!
name|sock
operator|->
name|connected
condition|)
block|{
comment|/* soft error */
name|need_retry
operator|=
name|ISC_TRUE
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
default|default:
name|isc_result
operator|=
name|isc__errno2result
argument_list|(
name|Error
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_result
operator|==
name|ISC_R_UNEXPECTED
condition|)
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"WSARecvFrom: Windows error code: %d, isc result %d"
argument_list|,
name|Error
argument_list|,
name|isc_result
argument_list|)
expr_stmt|;
name|send_recvdone_abort
argument_list|(
name|sock
argument_list|,
name|isc_result
argument_list|)
expr_stmt|;
name|HeapFree
argument_list|(
name|hHeapHandle
argument_list|,
literal|0
argument_list|,
name|lpo
argument_list|)
expr_stmt|;
name|lpo
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* 		 * The recv() finished immediately, but we will still get 		 * a completion event.  Rather than duplicate code, let 		 * that thread handle sending the data along its way. 		 */
name|sock
operator|->
name|pending_iocp
operator|++
expr_stmt|;
name|sock
operator|->
name|pending_recv
operator|++
expr_stmt|;
block|}
name|socket_log
argument_list|(
name|__LINE__
argument_list|,
name|sock
argument_list|,
name|NULL
argument_list|,
name|IOEVENT
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_DOIORECV
argument_list|,
literal|"queue_io_request: fd %d result %d error %d"
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|Result
argument_list|,
name|Error
argument_list|)
expr_stmt|;
name|CONSISTENT
argument_list|(
name|sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_retry
condition|)
goto|goto
name|retry
goto|;
block|}
end_function

begin_function
specifier|static
name|void
name|manager_log
parameter_list|(
name|isc_socketmgr_t
modifier|*
name|sockmgr
parameter_list|,
name|isc_logcategory_t
modifier|*
name|category
parameter_list|,
name|isc_logmodule_t
modifier|*
name|module
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|msgbuf
index|[
literal|2048
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
operator|!
name|isc_log_wouldlog
argument_list|(
name|isc_lctx
argument_list|,
name|level
argument_list|)
condition|)
return|return;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|msgbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|isc_lctx
argument_list|,
name|category
argument_list|,
name|module
argument_list|,
name|level
argument_list|,
literal|"sockmgr %p: %s"
argument_list|,
name|sockmgr
argument_list|,
name|msgbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|socket_log
parameter_list|(
name|int
name|lineno
parameter_list|,
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|address
parameter_list|,
name|isc_logcategory_t
modifier|*
name|category
parameter_list|,
name|isc_logmodule_t
modifier|*
name|module
parameter_list|,
name|int
name|level
parameter_list|,
name|isc_msgcat_t
modifier|*
name|msgcat
parameter_list|,
name|int
name|msgset
parameter_list|,
name|int
name|message
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|msgbuf
index|[
literal|2048
index|]
decl_stmt|;
name|char
name|peerbuf
index|[
literal|256
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
operator|!
name|isc_log_wouldlog
argument_list|(
name|isc_lctx
argument_list|,
name|level
argument_list|)
condition|)
return|return;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|msgbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|address
operator|==
name|NULL
condition|)
block|{
name|isc_log_iwrite
argument_list|(
name|isc_lctx
argument_list|,
name|category
argument_list|,
name|module
argument_list|,
name|level
argument_list|,
name|msgcat
argument_list|,
name|msgset
argument_list|,
name|message
argument_list|,
literal|"socket %p line %d: %s"
argument_list|,
name|sock
argument_list|,
name|lineno
argument_list|,
name|msgbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isc_sockaddr_format
argument_list|(
name|address
argument_list|,
name|peerbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|peerbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_iwrite
argument_list|(
name|isc_lctx
argument_list|,
name|category
argument_list|,
name|module
argument_list|,
name|level
argument_list|,
name|msgcat
argument_list|,
name|msgset
argument_list|,
name|message
argument_list|,
literal|"socket %p line %d peer %s: %s"
argument_list|,
name|sock
argument_list|,
name|lineno
argument_list|,
name|peerbuf
argument_list|,
name|msgbuf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Make an fd SOCKET non-blocking.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|make_nonblock
parameter_list|(
name|SOCKET
name|fd
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|unsigned
name|long
name|flags
init|=
literal|1
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
comment|/* Set the socket to non-blocking */
name|ret
operator|=
name|ioctlsocket
argument_list|(
name|fd
argument_list|,
name|FIONBIO
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"ioctlsocket(%d, FIOBIO, %d): %s"
argument_list|,
name|fd
argument_list|,
name|flags
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Windows 2000 systems incorrectly cause UDP sockets using WSARecvFrom  * to not work correctly, returning a WSACONNRESET error when a WSASendTo  * fails with an "ICMP port unreachable" response and preventing the  * socket from using the WSARecvFrom in subsequent operations.  * The function below fixes this, but requires that Windows 2000  * Service Pack 2 or later be installed on the system.  NT 4.0  * systems are not affected by this and work correctly.  * See Microsoft Knowledge Base Article Q263823 for details of this.  */
end_comment

begin_function
name|isc_result_t
name|connection_reset_fix
parameter_list|(
name|SOCKET
name|fd
parameter_list|)
block|{
name|DWORD
name|dwBytesReturned
init|=
literal|0
decl_stmt|;
name|BOOL
name|bNewBehavior
init|=
name|FALSE
decl_stmt|;
name|DWORD
name|status
decl_stmt|;
if|if
condition|(
name|isc_win32os_majorversion
argument_list|()
operator|<
literal|5
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
comment|/*  NT 4.0 has no problem */
comment|/* disable bad behavior using IOCTL: SIO_UDP_CONNRESET */
name|status
operator|=
name|WSAIoctl
argument_list|(
name|fd
argument_list|,
name|SIO_UDP_CONNRESET
argument_list|,
operator|&
name|bNewBehavior
argument_list|,
sizeof|sizeof
argument_list|(
name|bNewBehavior
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
operator|&
name|dwBytesReturned
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|SOCKET_ERROR
condition|)
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
else|else
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"WSAIoctl(SIO_UDP_CONNRESET, oldBehaviour) %s"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Construct an iov array and attach it to the msghdr passed in.  This is  * the SEND constructor, which will use the used region of the buffer  * (if using a buffer list) or will use the internal region (if a single  * buffer I/O is requested).  *  * Nothing can be NULL, and the done event must list at least one buffer  * on the buffer linked list for this function to be meaningful.  */
end_comment

begin_function
specifier|static
name|void
name|build_msghdr_send
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socketevent_t
modifier|*
name|dev
parameter_list|,
name|struct
name|msghdr
modifier|*
name|msg
parameter_list|,
name|char
modifier|*
name|cmsg
parameter_list|,
name|WSABUF
modifier|*
name|iov
parameter_list|,
name|IoCompletionInfo
modifier|*
name|lpo
parameter_list|)
block|{
name|unsigned
name|int
name|iovcount
decl_stmt|;
name|isc_buffer_t
modifier|*
name|buffer
decl_stmt|;
name|buflist_t
modifier|*
name|cpbuffer
decl_stmt|;
name|isc_region_t
name|used
decl_stmt|;
name|size_t
name|write_count
decl_stmt|;
name|size_t
name|skip_count
decl_stmt|;
name|memset
argument_list|(
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|msg
operator|->
name|to_addr
argument_list|,
operator|&
name|dev
operator|->
name|address
operator|.
name|type
argument_list|,
name|dev
operator|->
name|address
operator|.
name|length
argument_list|)
expr_stmt|;
name|msg
operator|->
name|to_addr_len
operator|=
name|dev
operator|->
name|address
operator|.
name|length
expr_stmt|;
name|buffer
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|dev
operator|->
name|bufferlist
argument_list|)
expr_stmt|;
name|write_count
operator|=
literal|0
expr_stmt|;
name|iovcount
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Single buffer I/O?  Skip what we've done so far in this region. 	 */
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
name|write_count
operator|=
name|dev
operator|->
name|region
operator|.
name|length
operator|-
name|dev
operator|->
name|n
expr_stmt|;
name|cpbuffer
operator|=
name|HeapAlloc
argument_list|(
name|hHeapHandle
argument_list|,
name|HEAP_ZERO_MEMORY
argument_list|,
sizeof|sizeof
argument_list|(
name|buflist_t
argument_list|)
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|cpbuffer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|cpbuffer
operator|->
name|buf
operator|=
name|HeapAlloc
argument_list|(
name|hHeapHandle
argument_list|,
name|HEAP_ZERO_MEMORY
argument_list|,
name|write_count
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|cpbuffer
operator|->
name|buf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|socket_log
argument_list|(
name|__LINE__
argument_list|,
name|sock
argument_list|,
name|NULL
argument_list|,
name|TRACE
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_ACCEPTLOCK
argument_list|,
literal|"alloc_buffer %p %d %p %d"
argument_list|,
name|cpbuffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buflist_t
argument_list|)
argument_list|,
name|cpbuffer
operator|->
name|buf
argument_list|,
name|write_count
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cpbuffer
operator|->
name|buf
argument_list|,
operator|(
name|dev
operator|->
name|region
operator|.
name|base
operator|+
name|dev
operator|->
name|n
operator|)
argument_list|,
name|write_count
argument_list|)
expr_stmt|;
name|cpbuffer
operator|->
name|buflen
operator|=
name|write_count
expr_stmt|;
name|ISC_LIST_ENQUEUE
argument_list|(
name|lpo
operator|->
name|bufferlist
argument_list|,
name|cpbuffer
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|buf
operator|=
name|cpbuffer
operator|->
name|buf
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|len
operator|=
name|write_count
expr_stmt|;
name|iovcount
operator|=
literal|1
expr_stmt|;
goto|goto
name|config
goto|;
block|}
comment|/* 	 * Multibuffer I/O. 	 * Skip the data in the buffer list that we have already written. 	 */
name|skip_count
operator|=
name|dev
operator|->
name|n
expr_stmt|;
while|while
condition|(
name|buffer
operator|!=
name|NULL
condition|)
block|{
name|REQUIRE
argument_list|(
name|ISC_BUFFER_VALID
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip_count
operator|<
name|isc_buffer_usedlength
argument_list|(
name|buffer
argument_list|)
condition|)
break|break;
name|skip_count
operator|-=
name|isc_buffer_usedlength
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|buffer
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|buffer
operator|!=
name|NULL
condition|)
block|{
name|INSIST
argument_list|(
name|iovcount
operator|<
name|MAXSCATTERGATHER_SEND
argument_list|)
expr_stmt|;
name|isc_buffer_usedregion
argument_list|(
name|buffer
argument_list|,
operator|&
name|used
argument_list|)
expr_stmt|;
if|if
condition|(
name|used
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|int
name|uselen
init|=
name|used
operator|.
name|length
operator|-
name|skip_count
decl_stmt|;
name|cpbuffer
operator|=
name|HeapAlloc
argument_list|(
name|hHeapHandle
argument_list|,
name|HEAP_ZERO_MEMORY
argument_list|,
sizeof|sizeof
argument_list|(
name|buflist_t
argument_list|)
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|cpbuffer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|cpbuffer
operator|->
name|buf
operator|=
name|HeapAlloc
argument_list|(
name|hHeapHandle
argument_list|,
name|HEAP_ZERO_MEMORY
argument_list|,
name|uselen
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|cpbuffer
operator|->
name|buf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|socket_log
argument_list|(
name|__LINE__
argument_list|,
name|sock
argument_list|,
name|NULL
argument_list|,
name|TRACE
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_ACCEPTLOCK
argument_list|,
literal|"alloc_buffer %p %d %p %d"
argument_list|,
name|cpbuffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buflist_t
argument_list|)
argument_list|,
name|cpbuffer
operator|->
name|buf
argument_list|,
name|write_count
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cpbuffer
operator|->
name|buf
argument_list|,
operator|(
name|used
operator|.
name|base
operator|+
name|skip_count
operator|)
argument_list|,
name|uselen
argument_list|)
expr_stmt|;
name|cpbuffer
operator|->
name|buflen
operator|=
name|uselen
expr_stmt|;
name|iov
index|[
name|iovcount
index|]
operator|.
name|buf
operator|=
name|cpbuffer
operator|->
name|buf
expr_stmt|;
name|iov
index|[
name|iovcount
index|]
operator|.
name|len
operator|=
name|used
operator|.
name|length
operator|-
name|skip_count
expr_stmt|;
name|write_count
operator|+=
name|uselen
expr_stmt|;
name|skip_count
operator|=
literal|0
expr_stmt|;
name|iovcount
operator|++
expr_stmt|;
block|}
name|buffer
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|buffer
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|INSIST
argument_list|(
name|skip_count
operator|==
literal|0
argument_list|)
expr_stmt|;
name|config
label|:
name|msg
operator|->
name|msg_iov
operator|=
name|iov
expr_stmt|;
name|msg
operator|->
name|msg_iovlen
operator|=
name|iovcount
expr_stmt|;
name|msg
operator|->
name|msg_totallen
operator|=
name|write_count
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_dev_address
parameter_list|(
name|isc_sockaddr_t
modifier|*
name|address
parameter_list|,
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socketevent_t
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_udp
condition|)
block|{
if|if
condition|(
name|address
operator|!=
name|NULL
condition|)
name|dev
operator|->
name|address
operator|=
operator|*
name|address
expr_stmt|;
else|else
name|dev
operator|->
name|address
operator|=
name|sock
operator|->
name|address
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_tcp
condition|)
block|{
name|INSIST
argument_list|(
name|address
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|dev
operator|->
name|address
operator|=
name|sock
operator|->
name|address
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|destroy_socketevent
parameter_list|(
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|isc_socketevent_t
modifier|*
name|ev
init|=
operator|(
name|isc_socketevent_t
operator|*
operator|)
name|event
decl_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|ev
operator|->
name|bufferlist
argument_list|)
argument_list|)
expr_stmt|;
call|(
name|ev
operator|->
name|destroy
call|)
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_socketevent_t
modifier|*
name|allocate_socketevent
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_eventtype_t
name|eventtype
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|isc_socketevent_t
modifier|*
name|ev
decl_stmt|;
name|ev
operator|=
operator|(
name|isc_socketevent_t
operator|*
operator|)
name|isc_event_allocate
argument_list|(
name|sock
operator|->
name|manager
operator|->
name|mctx
argument_list|,
name|sock
argument_list|,
name|eventtype
argument_list|,
name|action
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ev
operator|->
name|result
operator|=
name|ISC_R_IOERROR
expr_stmt|;
comment|// XXXMLG temporary change to detect failure to set
name|ISC_LINK_INIT
argument_list|(
name|ev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|ev
operator|->
name|bufferlist
argument_list|)
expr_stmt|;
name|ev
operator|->
name|region
operator|.
name|base
operator|=
name|NULL
expr_stmt|;
name|ev
operator|->
name|n
operator|=
literal|0
expr_stmt|;
name|ev
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|ev
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
name|ev
operator|->
name|destroy
operator|=
name|ev
operator|->
name|ev_destroy
expr_stmt|;
name|ev
operator|->
name|ev_destroy
operator|=
name|destroy_socketevent
expr_stmt|;
return|return
operator|(
name|ev
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ISC_SOCKET_DEBUG
argument_list|)
end_if

begin_function
specifier|static
name|void
name|dump_msg
parameter_list|(
name|struct
name|msghdr
modifier|*
name|msg
parameter_list|,
name|isc_socket_t
modifier|*
name|sock
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"MSGHDR %p, Socket #: %u\n"
argument_list|,
name|msg
argument_list|,
name|sock
operator|->
name|fd
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tname %p, namelen %d\n"
argument_list|,
name|msg
operator|->
name|msg_name
argument_list|,
name|msg
operator|->
name|msg_namelen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tiov %p, iovlen %d\n"
argument_list|,
name|msg
operator|->
name|msg_iov
argument_list|,
name|msg
operator|->
name|msg_iovlen
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|unsigned
name|int
operator|)
name|msg
operator|->
name|msg_iovlen
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"\t\t%d\tbase %p, len %d\n"
argument_list|,
name|i
argument_list|,
name|msg
operator|->
name|msg_iov
index|[
name|i
index|]
operator|.
name|buf
argument_list|,
name|msg
operator|->
name|msg_iov
index|[
name|i
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * map the error code  */
end_comment

begin_function
name|int
name|map_socket_error
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|int
name|windows_errno
parameter_list|,
name|int
modifier|*
name|isc_errno
parameter_list|,
name|char
modifier|*
name|errorstring
parameter_list|,
name|size_t
name|bufsize
parameter_list|)
block|{
name|int
name|doreturn
decl_stmt|;
switch|switch
condition|(
name|windows_errno
condition|)
block|{
case|case
name|WSAECONNREFUSED
case|:
operator|*
name|isc_errno
operator|=
name|ISC_R_CONNREFUSED
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|connected
condition|)
name|doreturn
operator|=
name|DOIO_HARD
expr_stmt|;
else|else
name|doreturn
operator|=
name|DOIO_SOFT
expr_stmt|;
break|break;
case|case
name|WSAENETUNREACH
case|:
case|case
name|ERROR_NETWORK_UNREACHABLE
case|:
operator|*
name|isc_errno
operator|=
name|ISC_R_NETUNREACH
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|connected
condition|)
name|doreturn
operator|=
name|DOIO_HARD
expr_stmt|;
else|else
name|doreturn
operator|=
name|DOIO_SOFT
expr_stmt|;
break|break;
case|case
name|ERROR_PORT_UNREACHABLE
case|:
case|case
name|ERROR_HOST_UNREACHABLE
case|:
case|case
name|WSAEHOSTUNREACH
case|:
operator|*
name|isc_errno
operator|=
name|ISC_R_HOSTUNREACH
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|connected
condition|)
name|doreturn
operator|=
name|DOIO_HARD
expr_stmt|;
else|else
name|doreturn
operator|=
name|DOIO_SOFT
expr_stmt|;
break|break;
case|case
name|WSAENETDOWN
case|:
operator|*
name|isc_errno
operator|=
name|ISC_R_NETDOWN
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|connected
condition|)
name|doreturn
operator|=
name|DOIO_HARD
expr_stmt|;
else|else
name|doreturn
operator|=
name|DOIO_SOFT
expr_stmt|;
break|break;
case|case
name|WSAEHOSTDOWN
case|:
operator|*
name|isc_errno
operator|=
name|ISC_R_HOSTDOWN
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|connected
condition|)
name|doreturn
operator|=
name|DOIO_HARD
expr_stmt|;
else|else
name|doreturn
operator|=
name|DOIO_SOFT
expr_stmt|;
break|break;
case|case
name|WSAEACCES
case|:
operator|*
name|isc_errno
operator|=
name|ISC_R_NOPERM
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|connected
condition|)
name|doreturn
operator|=
name|DOIO_HARD
expr_stmt|;
else|else
name|doreturn
operator|=
name|DOIO_SOFT
expr_stmt|;
break|break;
case|case
name|WSAECONNRESET
case|:
case|case
name|WSAENETRESET
case|:
case|case
name|WSAECONNABORTED
case|:
case|case
name|WSAEDISCON
case|:
operator|*
name|isc_errno
operator|=
name|ISC_R_CONNECTIONRESET
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|connected
condition|)
name|doreturn
operator|=
name|DOIO_HARD
expr_stmt|;
else|else
name|doreturn
operator|=
name|DOIO_SOFT
expr_stmt|;
break|break;
case|case
name|WSAENOTCONN
case|:
operator|*
name|isc_errno
operator|=
name|ISC_R_NOTCONNECTED
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|connected
condition|)
name|doreturn
operator|=
name|DOIO_HARD
expr_stmt|;
else|else
name|doreturn
operator|=
name|DOIO_SOFT
expr_stmt|;
break|break;
case|case
name|ERROR_OPERATION_ABORTED
case|:
case|case
name|ERROR_CONNECTION_ABORTED
case|:
case|case
name|ERROR_REQUEST_ABORTED
case|:
operator|*
name|isc_errno
operator|=
name|ISC_R_CONNECTIONRESET
expr_stmt|;
name|doreturn
operator|=
name|DOIO_HARD
expr_stmt|;
break|break;
case|case
name|WSAENOBUFS
case|:
operator|*
name|isc_errno
operator|=
name|ISC_R_NORESOURCES
expr_stmt|;
name|doreturn
operator|=
name|DOIO_HARD
expr_stmt|;
break|break;
case|case
name|WSAEAFNOSUPPORT
case|:
operator|*
name|isc_errno
operator|=
name|ISC_R_FAMILYNOSUPPORT
expr_stmt|;
name|doreturn
operator|=
name|DOIO_HARD
expr_stmt|;
break|break;
case|case
name|WSAEADDRNOTAVAIL
case|:
operator|*
name|isc_errno
operator|=
name|ISC_R_ADDRNOTAVAIL
expr_stmt|;
name|doreturn
operator|=
name|DOIO_HARD
expr_stmt|;
break|break;
case|case
name|WSAEDESTADDRREQ
case|:
operator|*
name|isc_errno
operator|=
name|ISC_R_BADADDRESSFORM
expr_stmt|;
name|doreturn
operator|=
name|DOIO_HARD
expr_stmt|;
break|break;
case|case
name|ERROR_NETNAME_DELETED
case|:
operator|*
name|isc_errno
operator|=
name|ISC_R_NETDOWN
expr_stmt|;
name|doreturn
operator|=
name|DOIO_HARD
expr_stmt|;
break|break;
default|default:
operator|*
name|isc_errno
operator|=
name|ISC_R_IOERROR
expr_stmt|;
name|doreturn
operator|=
name|DOIO_HARD
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|doreturn
operator|==
name|DOIO_HARD
condition|)
block|{
name|isc__strerror
argument_list|(
name|windows_errno
argument_list|,
name|errorstring
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|doreturn
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fill_recv
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socketevent_t
modifier|*
name|dev
parameter_list|)
block|{
name|isc_region_t
name|r
decl_stmt|;
name|int
name|copylen
decl_stmt|;
name|isc_buffer_t
modifier|*
name|buffer
decl_stmt|;
name|INSIST
argument_list|(
name|dev
operator|->
name|n
operator|<
name|dev
operator|->
name|minimum
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|recvbuf
operator|.
name|remaining
operator|>
literal|0
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|pending_recv
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_udp
condition|)
block|{
name|dev
operator|->
name|address
operator|.
name|length
operator|=
name|sock
operator|->
name|recvbuf
operator|.
name|from_addr_len
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|dev
operator|->
name|address
operator|.
name|type
argument_list|,
operator|&
name|sock
operator|->
name|recvbuf
operator|.
name|from_addr
argument_list|,
name|sock
operator|->
name|recvbuf
operator|.
name|from_addr_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_sockaddr_getport
argument_list|(
operator|&
name|dev
operator|->
name|address
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|isc_log_wouldlog
argument_list|(
name|isc_lctx
argument_list|,
name|IOEVENT_LEVEL
argument_list|)
condition|)
block|{
name|socket_log
argument_list|(
name|__LINE__
argument_list|,
name|sock
argument_list|,
operator|&
name|dev
operator|->
name|address
argument_list|,
name|IOEVENT
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_ZEROPORT
argument_list|,
literal|"dropping source port zero packet"
argument_list|)
expr_stmt|;
block|}
name|sock
operator|->
name|recvbuf
operator|.
name|remaining
operator|=
literal|0
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_tcp
condition|)
block|{
name|dev
operator|->
name|address
operator|=
name|sock
operator|->
name|address
expr_stmt|;
block|}
comment|/* 	 * Run through the list of buffers we were given, and find the 	 * first one with space.  Once it is found, loop through, filling 	 * the buffers as much as possible. 	 */
name|buffer
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|dev
operator|->
name|bufferlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|!=
name|NULL
condition|)
block|{
comment|// Multi-buffer receive
while|while
condition|(
name|buffer
operator|!=
name|NULL
operator|&&
name|sock
operator|->
name|recvbuf
operator|.
name|remaining
operator|>
literal|0
condition|)
block|{
name|REQUIRE
argument_list|(
name|ISC_BUFFER_VALID
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_buffer_availablelength
argument_list|(
name|buffer
argument_list|)
operator|>
literal|0
condition|)
block|{
name|isc_buffer_availableregion
argument_list|(
name|buffer
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|copylen
operator|=
name|min
argument_list|(
name|r
operator|.
name|length
argument_list|,
name|sock
operator|->
name|recvbuf
operator|.
name|remaining
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|r
operator|.
name|base
argument_list|,
name|sock
operator|->
name|recvbuf
operator|.
name|consume_position
argument_list|,
name|copylen
argument_list|)
expr_stmt|;
name|sock
operator|->
name|recvbuf
operator|.
name|consume_position
operator|+=
name|copylen
expr_stmt|;
name|sock
operator|->
name|recvbuf
operator|.
name|remaining
operator|-=
name|copylen
expr_stmt|;
name|isc_buffer_add
argument_list|(
name|buffer
argument_list|,
name|copylen
argument_list|)
expr_stmt|;
name|dev
operator|->
name|n
operator|+=
name|copylen
expr_stmt|;
block|}
name|buffer
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|buffer
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Single-buffer receive
name|copylen
operator|=
name|min
argument_list|(
name|dev
operator|->
name|region
operator|.
name|length
operator|-
name|dev
operator|->
name|n
argument_list|,
name|sock
operator|->
name|recvbuf
operator|.
name|remaining
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dev
operator|->
name|region
operator|.
name|base
operator|+
name|dev
operator|->
name|n
argument_list|,
name|sock
operator|->
name|recvbuf
operator|.
name|consume_position
argument_list|,
name|copylen
argument_list|)
expr_stmt|;
name|sock
operator|->
name|recvbuf
operator|.
name|consume_position
operator|+=
name|copylen
expr_stmt|;
name|sock
operator|->
name|recvbuf
operator|.
name|remaining
operator|-=
name|copylen
expr_stmt|;
name|dev
operator|->
name|n
operator|+=
name|copylen
expr_stmt|;
block|}
comment|/* 	 * UDP receives are all-consuming.  That is, if we have 4k worth of 	 * data in our receive buffer, and the caller only gave us 	 * 1k of space, we will toss the remaining 3k of data.  TCP 	 * will keep the extra data around and use it for later requests. 	 */
if|if
condition|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_udp
condition|)
name|sock
operator|->
name|recvbuf
operator|.
name|remaining
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Copy out as much data from the internal buffer to done events.  * As each done event is filled, send it along its way.  */
end_comment

begin_function
specifier|static
name|void
name|completeio_recv
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|)
block|{
name|isc_socketevent_t
modifier|*
name|dev
decl_stmt|;
comment|/* 	 * If we are in the process of filling our buffer, we cannot 	 * touch it yet, so don't. 	 */
if|if
condition|(
name|sock
operator|->
name|pending_recv
operator|>
literal|0
condition|)
return|return;
while|while
condition|(
name|sock
operator|->
name|recvbuf
operator|.
name|remaining
operator|>
literal|0
operator|&&
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|)
condition|)
block|{
name|dev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|)
expr_stmt|;
comment|/* 		 * See if we have sufficient data in our receive buffer 		 * to handle this.  If we do, copy out the data. 		 */
name|fill_recv
argument_list|(
name|sock
argument_list|,
name|dev
argument_list|)
expr_stmt|;
comment|/* 		 * Did we satisfy it? 		 */
if|if
condition|(
name|dev
operator|->
name|n
operator|>=
name|dev
operator|->
name|minimum
condition|)
block|{
name|dev
operator|->
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|send_recvdone_event
argument_list|(
name|sock
argument_list|,
operator|&
name|dev
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Returns:  *	DOIO_SUCCESS	The operation succeeded.  dev->result contains  *			ISC_R_SUCCESS.  *  *	DOIO_HARD	A hard or unexpected I/O error was encountered.  *			dev->result contains the appropriate error.  *  *	DOIO_SOFT	A soft I/O error was encountered.  No senddone  *			event was sent.  The operation should be retried.  *  *	No other return values are possible.  */
end_comment

begin_function
specifier|static
name|int
name|completeio_send
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socketevent_t
modifier|*
name|dev
parameter_list|,
name|struct
name|msghdr
modifier|*
name|messagehdr
parameter_list|,
name|int
name|cc
parameter_list|,
name|int
name|send_errno
parameter_list|)
block|{
name|char
name|addrbuf
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
if|if
condition|(
name|send_errno
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|SOFT_ERROR
argument_list|(
name|send_errno
argument_list|)
condition|)
return|return
operator|(
name|DOIO_SOFT
operator|)
return|;
return|return
operator|(
name|map_socket_error
argument_list|(
name|sock
argument_list|,
name|send_errno
argument_list|,
operator|&
name|dev
operator|->
name|result
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
operator|)
return|;
comment|/* 		 * The other error types depend on whether or not the 		 * socket is UDP or TCP.  If it is UDP, some errors 		 * that we expect to be fatal under TCP are merely 		 * annoying, and are really soft errors. 		 * 		 * However, these soft errors are still returned as 		 * a status. 		 */
name|isc_sockaddr_format
argument_list|(
operator|&
name|dev
operator|->
name|address
argument_list|,
name|addrbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|addrbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc__strerror
argument_list|(
name|send_errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"completeio_send: %s: %s"
argument_list|,
name|addrbuf
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
name|dev
operator|->
name|result
operator|=
name|isc__errno2result
argument_list|(
name|send_errno
argument_list|)
expr_stmt|;
return|return
operator|(
name|DOIO_HARD
operator|)
return|;
block|}
comment|/* 	 * If we write less than we expected, update counters, poke. 	 */
name|dev
operator|->
name|n
operator|+=
name|cc
expr_stmt|;
if|if
condition|(
name|cc
operator|!=
name|messagehdr
operator|->
name|msg_totallen
condition|)
return|return
operator|(
name|DOIO_SOFT
operator|)
return|;
comment|/* 	 * Exactly what we wanted to write.  We're done with this 	 * entry.  Post its completion event. 	 */
name|dev
operator|->
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
return|return
operator|(
name|DOIO_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|startio_send
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socketevent_t
modifier|*
name|dev
parameter_list|,
name|int
modifier|*
name|nbytes
parameter_list|,
name|int
modifier|*
name|send_errno
parameter_list|)
block|{
name|char
modifier|*
name|cmsg
init|=
name|NULL
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|IoCompletionInfo
modifier|*
name|lpo
decl_stmt|;
name|int
name|status
decl_stmt|;
name|struct
name|msghdr
modifier|*
name|msghdr
decl_stmt|;
name|lpo
operator|=
operator|(
name|IoCompletionInfo
operator|*
operator|)
name|HeapAlloc
argument_list|(
name|hHeapHandle
argument_list|,
name|HEAP_ZERO_MEMORY
argument_list|,
sizeof|sizeof
argument_list|(
name|IoCompletionInfo
argument_list|)
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|lpo
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|lpo
operator|->
name|request_type
operator|=
name|SOCKET_SEND
expr_stmt|;
name|lpo
operator|->
name|dev
operator|=
name|dev
expr_stmt|;
name|msghdr
operator|=
operator|&
name|lpo
operator|->
name|messagehdr
expr_stmt|;
name|memset
argument_list|(
name|msghdr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|msghdr
argument_list|)
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|lpo
operator|->
name|bufferlist
argument_list|)
expr_stmt|;
name|build_msghdr_send
argument_list|(
name|sock
argument_list|,
name|dev
argument_list|,
name|msghdr
argument_list|,
name|cmsg
argument_list|,
name|sock
operator|->
name|iov
argument_list|,
name|lpo
argument_list|)
expr_stmt|;
operator|*
name|nbytes
operator|=
name|internal_sendmsg
argument_list|(
name|sock
argument_list|,
name|lpo
argument_list|,
name|msghdr
argument_list|,
literal|0
argument_list|,
name|send_errno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|nbytes
operator|<
literal|0
condition|)
block|{
comment|/* 		 * I/O has been initiated 		 * completion will be through the completion port 		 */
if|if
condition|(
name|PENDING_ERROR
argument_list|(
operator|*
name|send_errno
argument_list|)
condition|)
block|{
name|status
operator|=
name|DOIO_PENDING
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|SOFT_ERROR
argument_list|(
operator|*
name|send_errno
argument_list|)
condition|)
block|{
name|status
operator|=
name|DOIO_SOFT
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 		 * If we got this far then something is wrong 		 */
if|if
condition|(
name|isc_log_wouldlog
argument_list|(
name|isc_lctx
argument_list|,
name|IOEVENT_LEVEL
argument_list|)
condition|)
block|{
name|isc__strerror
argument_list|(
operator|*
name|send_errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|socket_log
argument_list|(
name|__LINE__
argument_list|,
name|sock
argument_list|,
name|NULL
argument_list|,
name|IOEVENT
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_INTERNALSEND
argument_list|,
literal|"startio_send: internal_sendmsg(%d) %d "
literal|"bytes, err %d/%s"
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
operator|*
name|nbytes
argument_list|,
operator|*
name|send_errno
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|DOIO_HARD
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|dev
operator|->
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|status
operator|=
name|DOIO_SOFT
expr_stmt|;
name|done
label|:
name|_set_state
argument_list|(
name|sock
argument_list|,
name|SOCK_DATA
argument_list|)
expr_stmt|;
return|return
operator|(
name|status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|allocate_socket
parameter_list|(
name|isc_socketmgr_t
modifier|*
name|manager
parameter_list|,
name|isc_sockettype_t
name|type
parameter_list|,
name|isc_socket_t
modifier|*
modifier|*
name|socketp
parameter_list|)
block|{
name|isc_socket_t
modifier|*
name|sock
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|sock
operator|=
name|isc_mem_get
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|sock
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|sock
operator|->
name|references
operator|=
literal|0
expr_stmt|;
name|sock
operator|->
name|manager
operator|=
name|manager
expr_stmt|;
name|sock
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|sock
operator|->
name|fd
operator|=
name|INVALID_SOCKET
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|sock
argument_list|,
name|link
argument_list|)
expr_stmt|;
comment|/* 	 * set up list of readers and writers to be initially empty 	 */
name|ISC_LIST_INIT
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|sock
operator|->
name|send_list
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|sock
operator|->
name|accept_list
argument_list|)
expr_stmt|;
name|sock
operator|->
name|connect_ev
operator|=
name|NULL
expr_stmt|;
name|sock
operator|->
name|pending_accept
operator|=
literal|0
expr_stmt|;
name|sock
operator|->
name|pending_recv
operator|=
literal|0
expr_stmt|;
name|sock
operator|->
name|pending_send
operator|=
literal|0
expr_stmt|;
name|sock
operator|->
name|pending_iocp
operator|=
literal|0
expr_stmt|;
name|sock
operator|->
name|listener
operator|=
literal|0
expr_stmt|;
name|sock
operator|->
name|connected
operator|=
literal|0
expr_stmt|;
name|sock
operator|->
name|pending_connect
operator|=
literal|0
expr_stmt|;
name|sock
operator|->
name|bound
operator|=
literal|0
expr_stmt|;
name|sock
operator|->
name|dupped
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|sock
operator|->
name|name
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sock
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|// zero the name field
name|_set_state
argument_list|(
name|sock
argument_list|,
name|SOCK_INITIALIZED
argument_list|)
expr_stmt|;
name|sock
operator|->
name|recvbuf
operator|.
name|len
operator|=
literal|65536
expr_stmt|;
name|sock
operator|->
name|recvbuf
operator|.
name|consume_position
operator|=
name|sock
operator|->
name|recvbuf
operator|.
name|base
expr_stmt|;
name|sock
operator|->
name|recvbuf
operator|.
name|remaining
operator|=
literal|0
expr_stmt|;
name|sock
operator|->
name|recvbuf
operator|.
name|base
operator|=
name|isc_mem_get
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|sock
operator|->
name|recvbuf
operator|.
name|len
argument_list|)
expr_stmt|;
comment|// max buffer size
if|if
condition|(
name|sock
operator|->
name|recvbuf
operator|.
name|base
operator|==
name|NULL
condition|)
block|{
name|sock
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* 	 * initialize the lock 	 */
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|sock
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|isc_mem_put
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|sock
operator|->
name|recvbuf
operator|.
name|base
argument_list|,
name|sock
operator|->
name|recvbuf
operator|.
name|len
argument_list|)
expr_stmt|;
name|sock
operator|->
name|recvbuf
operator|.
name|base
operator|=
name|NULL
expr_stmt|;
goto|goto
name|error
goto|;
block|}
name|socket_log
argument_list|(
name|__LINE__
argument_list|,
name|sock
argument_list|,
name|NULL
argument_list|,
name|EVENT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"allocated"
argument_list|)
expr_stmt|;
name|sock
operator|->
name|magic
operator|=
name|SOCKET_MAGIC
expr_stmt|;
operator|*
name|socketp
operator|=
name|sock
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|error
label|:
name|isc_mem_put
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|sock
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sock
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Verify that the socket state is consistent.  */
end_comment

begin_function
specifier|static
name|void
name|consistent
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|)
block|{
name|isc_socketevent_t
modifier|*
name|dev
decl_stmt|;
name|isc_socket_newconnev_t
modifier|*
name|nev
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
name|char
modifier|*
name|crash_reason
decl_stmt|;
name|isc_boolean_t
name|crash
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|sock
operator|->
name|pending_iocp
operator|==
name|sock
operator|->
name|pending_recv
operator|+
name|sock
operator|->
name|pending_send
operator|+
name|sock
operator|->
name|pending_accept
operator|+
name|sock
operator|->
name|pending_connect
argument_list|)
expr_stmt|;
name|dev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sock
operator|->
name|send_list
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|dev
operator|!=
name|NULL
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|dev
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|dev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>
name|sock
operator|->
name|pending_send
condition|)
block|{
name|crash
operator|=
name|ISC_TRUE
expr_stmt|;
name|crash_reason
operator|=
literal|"send_list> sock->pending_send"
expr_stmt|;
block|}
name|nev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sock
operator|->
name|accept_list
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|nev
operator|!=
name|NULL
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|nev
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|nev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|>
name|sock
operator|->
name|pending_accept
condition|)
block|{
name|crash
operator|=
name|ISC_TRUE
expr_stmt|;
name|crash_reason
operator|=
literal|"send_list> sock->pending_send"
expr_stmt|;
block|}
if|if
condition|(
name|crash
condition|)
block|{
name|socket_log
argument_list|(
name|__LINE__
argument_list|,
name|sock
argument_list|,
name|NULL
argument_list|,
name|CREATION
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_DESTROYING
argument_list|,
literal|"SOCKET INCONSISTENT: %s"
argument_list|,
name|crash_reason
argument_list|)
expr_stmt|;
name|sock_dump
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|crash
operator|==
name|ISC_FALSE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Maybe free the socket.  *  * This function will verify tht the socket is no longer in use in any way,  * either internally or externally.  This is the only place where this  * check is to be made; if some bit of code believes that IT is done with  * the socket (e.g., some reference counter reaches zero), it should call  * this function.  *  * When calling this function, the socket must be locked, and the manager  * must be unlocked.  *  * When this function returns, *socketp will be NULL.  No tricks to try  * to hold on to this pointer are allowed.  */
end_comment

begin_function
specifier|static
name|void
name|maybe_free_socket
parameter_list|(
name|isc_socket_t
modifier|*
modifier|*
name|socketp
parameter_list|,
name|int
name|lineno
parameter_list|)
block|{
name|isc_socket_t
modifier|*
name|sock
init|=
operator|*
name|socketp
decl_stmt|;
operator|*
name|socketp
operator|=
name|NULL
expr_stmt|;
name|INSIST
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|CONSISTENT
argument_list|(
name|sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|pending_iocp
operator|>
literal|0
operator|||
name|sock
operator|->
name|pending_recv
operator|>
literal|0
operator|||
name|sock
operator|->
name|pending_send
operator|>
literal|0
operator|||
name|sock
operator|->
name|pending_accept
operator|>
literal|0
operator|||
name|sock
operator|->
name|references
operator|>
literal|0
operator|||
name|sock
operator|->
name|pending_connect
operator|==
literal|1
operator|||
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|)
operator|||
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|send_list
argument_list|)
operator|||
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|accept_list
argument_list|)
operator|||
name|sock
operator|->
name|fd
operator|!=
name|INVALID_SOCKET
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free_socket
argument_list|(
operator|&
name|sock
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|free_socket
parameter_list|(
name|isc_socket_t
modifier|*
modifier|*
name|sockp
parameter_list|,
name|int
name|lineno
parameter_list|)
block|{
name|isc_socketmgr_t
modifier|*
name|manager
decl_stmt|;
name|isc_socket_t
modifier|*
name|sock
init|=
operator|*
name|sockp
decl_stmt|;
operator|*
name|sockp
operator|=
name|NULL
expr_stmt|;
name|manager
operator|=
name|sock
operator|->
name|manager
expr_stmt|;
comment|/* 	 * Seems we can free the socket after all. 	 */
name|manager
operator|=
name|sock
operator|->
name|manager
expr_stmt|;
name|socket_log
argument_list|(
name|__LINE__
argument_list|,
name|sock
argument_list|,
name|NULL
argument_list|,
name|CREATION
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_DESTROYING
argument_list|,
literal|"freeing socket line %d fd %d lock %p semaphore %p"
argument_list|,
name|lineno
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
operator|&
name|sock
operator|->
name|lock
argument_list|,
name|sock
operator|->
name|lock
operator|.
name|LockSemaphore
argument_list|)
expr_stmt|;
name|sock
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|recvbuf
operator|.
name|base
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|sock
operator|->
name|recvbuf
operator|.
name|base
argument_list|,
name|sock
operator|->
name|recvbuf
operator|.
name|len
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISC_LINK_LINKED
argument_list|(
name|sock
argument_list|,
name|link
argument_list|)
condition|)
name|ISC_LIST_UNLINK
argument_list|(
name|manager
operator|->
name|socklist
argument_list|,
name|sock
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|sock
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISC_LIST_EMPTY
argument_list|(
name|manager
operator|->
name|socklist
argument_list|)
condition|)
name|SIGNAL
argument_list|(
operator|&
name|manager
operator|->
name|shutdown_ok
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create a new 'type' socket managed by 'manager'.  Events  * will be posted to 'task' and when dispatched 'action' will be  * called with 'arg' as the arg value.  The new socket is returned  * in 'socketp'.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|socket_create
parameter_list|(
name|isc_socketmgr_t
modifier|*
name|manager
parameter_list|,
name|int
name|pf
parameter_list|,
name|isc_sockettype_t
name|type
parameter_list|,
name|isc_socket_t
modifier|*
modifier|*
name|socketp
parameter_list|,
name|isc_socket_t
modifier|*
name|dup_socket
parameter_list|)
block|{
name|isc_socket_t
modifier|*
name|sock
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_CMSG
argument_list|)
name|int
name|on
init|=
literal|1
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SO_RCVBUF
argument_list|)
name|ISC_SOCKADDR_LEN_T
name|optlen
decl_stmt|;
name|int
name|size
decl_stmt|;
endif|#
directive|endif
name|int
name|socket_errno
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|socketp
operator|!=
name|NULL
operator|&&
operator|*
name|socketp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|type
operator|!=
name|isc_sockettype_fdwatch
argument_list|)
expr_stmt|;
if|if
condition|(
name|dup_socket
operator|!=
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
name|result
operator|=
name|allocate_socket
argument_list|(
name|manager
argument_list|,
name|type
argument_list|,
operator|&
name|sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|sock
operator|->
name|pf
operator|=
name|pf
expr_stmt|;
if|#
directive|if
literal|0
block|if (dup_socket == NULL) {
endif|#
directive|endif
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|isc_sockettype_udp
case|:
name|sock
operator|->
name|fd
operator|=
name|socket
argument_list|(
name|pf
argument_list|,
name|SOCK_DGRAM
argument_list|,
name|IPPROTO_UDP
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|fd
operator|!=
name|INVALID_SOCKET
condition|)
block|{
name|result
operator|=
name|connection_reset_fix
argument_list|(
name|sock
operator|->
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|socket_log
argument_list|(
name|__LINE__
argument_list|,
name|sock
argument_list|,
name|NULL
argument_list|,
name|EVENT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"closed %d %d %d "
literal|"con_reset_fix_failed"
argument_list|,
name|sock
operator|->
name|pending_recv
argument_list|,
name|sock
operator|->
name|pending_send
argument_list|,
name|sock
operator|->
name|references
argument_list|)
expr_stmt|;
name|closesocket
argument_list|(
name|sock
operator|->
name|fd
argument_list|)
expr_stmt|;
name|_set_state
argument_list|(
name|sock
argument_list|,
name|SOCK_CLOSED
argument_list|)
expr_stmt|;
name|sock
operator|->
name|fd
operator|=
name|INVALID_SOCKET
expr_stmt|;
name|free_socket
argument_list|(
operator|&
name|sock
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
block|}
break|break;
case|case
name|isc_sockettype_tcp
case|:
name|sock
operator|->
name|fd
operator|=
name|socket
argument_list|(
name|pf
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
break|break;
block|}
if|#
directive|if
literal|0
block|} else {
comment|/* 		 * XXX: dup() is deprecated in windows, use _dup() 		 * instead.  In future we may want to investigate 		 * WSADuplicateSocket(). 		 */
block|sock->fd = _dup(dup_socket->fd); 		sock->dupped = 1; 		sock->bound = dup_socket->bound; 	}
endif|#
directive|endif
if|if
condition|(
name|sock
operator|->
name|fd
operator|==
name|INVALID_SOCKET
condition|)
block|{
name|socket_errno
operator|=
name|WSAGetLastError
argument_list|()
expr_stmt|;
name|free_socket
argument_list|(
operator|&
name|sock
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|socket_errno
condition|)
block|{
case|case
name|WSAEMFILE
case|:
case|case
name|WSAENOBUFS
case|:
return|return
operator|(
name|ISC_R_NORESOURCES
operator|)
return|;
case|case
name|WSAEPROTONOSUPPORT
case|:
case|case
name|WSAEPFNOSUPPORT
case|:
case|case
name|WSAEAFNOSUPPORT
case|:
return|return
operator|(
name|ISC_R_FAMILYNOSUPPORT
operator|)
return|;
default|default:
name|isc__strerror
argument_list|(
name|socket_errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"socket() %s: %s"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
block|}
name|result
operator|=
name|make_nonblock
argument_list|(
name|sock
operator|->
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|socket_log
argument_list|(
name|__LINE__
argument_list|,
name|sock
argument_list|,
name|NULL
argument_list|,
name|EVENT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"closed %d %d %d make_nonblock_failed"
argument_list|,
name|sock
operator|->
name|pending_recv
argument_list|,
name|sock
operator|->
name|pending_send
argument_list|,
name|sock
operator|->
name|references
argument_list|)
expr_stmt|;
name|closesocket
argument_list|(
name|sock
operator|->
name|fd
argument_list|)
expr_stmt|;
name|sock
operator|->
name|fd
operator|=
name|INVALID_SOCKET
expr_stmt|;
name|free_socket
argument_list|(
operator|&
name|sock
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|USE_CMSG
argument_list|)
operator|||
name|defined
argument_list|(
name|SO_RCVBUF
argument_list|)
if|if
condition|(
name|type
operator|==
name|isc_sockettype_udp
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|USE_CMSG
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|ISC_PLATFORM_HAVEIPV6
argument_list|)
ifdef|#
directive|ifdef
name|IPV6_RECVPKTINFO
comment|/* 2292bis */
if|if
condition|(
operator|(
name|pf
operator|==
name|AF_INET6
operator|)
operator|&&
operator|(
name|setsockopt
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_RECVPKTINFO
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|isc__strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"setsockopt(%d, IPV6_RECVPKTINFO) "
literal|"%s: %s"
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* 2292 */
if|if
condition|(
operator|(
name|pf
operator|==
name|AF_INET6
operator|)
operator|&&
operator|(
name|setsockopt
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_PKTINFO
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|isc__strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"setsockopt(%d, IPV6_PKTINFO) %s: %s"
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* IPV6_RECVPKTINFO */
ifdef|#
directive|ifdef
name|IPV6_USE_MIN_MTU
comment|/*2292bis, not too common yet*/
comment|/* use minimum MTU */
if|if
condition|(
name|pf
operator|==
name|AF_INET6
condition|)
block|{
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_USE_MIN_MTU
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* ISC_PLATFORM_HAVEIPV6 */
endif|#
directive|endif
comment|/* defined(USE_CMSG) */
if|#
directive|if
name|defined
argument_list|(
name|SO_RCVBUF
argument_list|)
name|optlen
operator|=
sizeof|sizeof
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockopt
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_RCVBUF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|size
argument_list|,
operator|&
name|optlen
argument_list|)
operator|>=
literal|0
operator|&&
name|size
operator|<
name|RCVBUFSIZE
condition|)
block|{
name|size
operator|=
name|RCVBUFSIZE
expr_stmt|;
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_RCVBUF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* defined(USE_CMSG) || defined(SO_RCVBUF) */
name|_set_state
argument_list|(
name|sock
argument_list|,
name|SOCK_OPEN
argument_list|)
expr_stmt|;
name|sock
operator|->
name|references
operator|=
literal|1
expr_stmt|;
operator|*
name|socketp
operator|=
name|sock
expr_stmt|;
name|iocompletionport_update
argument_list|(
name|sock
argument_list|)
expr_stmt|;
comment|/* 	 * Note we don't have to lock the socket like we normally would because 	 * there are no external references to it yet. 	 */
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|manager
operator|->
name|socklist
argument_list|,
name|sock
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|InterlockedIncrement
argument_list|(
operator|&
name|manager
operator|->
name|totalSockets
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|socket_log
argument_list|(
name|__LINE__
argument_list|,
name|sock
argument_list|,
name|NULL
argument_list|,
name|CREATION
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_CREATED
argument_list|,
literal|"created %u type %u"
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc__socket_create
parameter_list|(
name|isc_socketmgr_t
modifier|*
name|manager
parameter_list|,
name|int
name|pf
parameter_list|,
name|isc_sockettype_t
name|type
parameter_list|,
name|isc_socket_t
modifier|*
modifier|*
name|socketp
parameter_list|)
block|{
return|return
operator|(
name|socket_create
argument_list|(
name|manager
argument_list|,
name|pf
argument_list|,
name|type
argument_list|,
name|socketp
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc__socket_dup
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socket_t
modifier|*
modifier|*
name|socketp
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|socketp
operator|!=
name|NULL
operator|&&
operator|*
name|socketp
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
literal|1
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|socket_create
argument_list|(
name|sock
operator|->
name|manager
argument_list|,
name|sock
operator|->
name|pf
argument_list|,
name|sock
operator|->
name|type
argument_list|,
name|socketp
argument_list|,
name|sock
argument_list|)
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|isc_result_t
name|isc_socket_open
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sock
operator|->
name|type
operator|!=
name|isc_sockettype_fdwatch
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach to a socket.  Caller must explicitly detach when it is done.  */
end_comment

begin_function
name|void
name|isc__socket_attach
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socket_t
modifier|*
modifier|*
name|socketp
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|socketp
operator|!=
name|NULL
operator|&&
operator|*
name|socketp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|CONSISTENT
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|sock
operator|->
name|references
operator|++
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|*
name|socketp
operator|=
name|sock
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dereference a socket.  If this is the last reference to it, clean things  * up by destroying the socket.  */
end_comment

begin_function
name|void
name|isc__socket_detach
parameter_list|(
name|isc_socket_t
modifier|*
modifier|*
name|socketp
parameter_list|)
block|{
name|isc_socket_t
modifier|*
name|sock
decl_stmt|;
name|isc_boolean_t
name|kill_socket
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|socketp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sock
operator|=
operator|*
name|socketp
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sock
operator|->
name|type
operator|!=
name|isc_sockettype_fdwatch
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|CONSISTENT
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sock
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|sock
operator|->
name|references
operator|--
expr_stmt|;
name|socket_log
argument_list|(
name|__LINE__
argument_list|,
name|sock
argument_list|,
name|NULL
argument_list|,
name|EVENT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"detach_socket %d %d %d"
argument_list|,
name|sock
operator|->
name|pending_recv
argument_list|,
name|sock
operator|->
name|pending_send
argument_list|,
name|sock
operator|->
name|references
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|references
operator|==
literal|0
operator|&&
name|sock
operator|->
name|fd
operator|!=
name|INVALID_SOCKET
condition|)
block|{
name|closesocket
argument_list|(
name|sock
operator|->
name|fd
argument_list|)
expr_stmt|;
name|sock
operator|->
name|fd
operator|=
name|INVALID_SOCKET
expr_stmt|;
name|_set_state
argument_list|(
name|sock
argument_list|,
name|SOCK_CLOSED
argument_list|)
expr_stmt|;
block|}
name|maybe_free_socket
argument_list|(
operator|&
name|sock
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
operator|*
name|socketp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|isc_socket_close
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sock
operator|->
name|type
operator|!=
name|isc_sockettype_fdwatch
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dequeue an item off the given socket's read queue, set the result code  * in the done event to the one provided, and send it to the task it was  * destined for.  *  * If the event to be sent is on a list, remove it before sending.  If  * asked to, send and detach from the task as well.  *  * Caller must have the socket locked if the event is attached to the socket.  */
end_comment

begin_function
specifier|static
name|void
name|send_recvdone_event
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socketevent_t
modifier|*
modifier|*
name|dev
parameter_list|)
block|{
name|isc_task_t
modifier|*
name|task
decl_stmt|;
name|task
operator|=
operator|(
operator|*
name|dev
operator|)
operator|->
name|ev_sender
expr_stmt|;
operator|(
operator|*
name|dev
operator|)
operator|->
name|ev_sender
operator|=
name|sock
expr_stmt|;
if|if
condition|(
name|ISC_LINK_LINKED
argument_list|(
operator|*
name|dev
argument_list|,
name|ev_link
argument_list|)
condition|)
name|ISC_LIST_DEQUEUE
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|,
operator|*
name|dev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|*
name|dev
operator|)
operator|->
name|attributes
operator|&
name|ISC_SOCKEVENTATTR_ATTACHED
operator|)
operator|==
name|ISC_SOCKEVENTATTR_ATTACHED
condition|)
name|isc_task_sendanddetach
argument_list|(
operator|&
name|task
argument_list|,
operator|(
name|isc_event_t
operator|*
operator|*
operator|)
name|dev
argument_list|)
expr_stmt|;
else|else
name|isc_task_send
argument_list|(
name|task
argument_list|,
operator|(
name|isc_event_t
operator|*
operator|*
operator|)
name|dev
argument_list|)
expr_stmt|;
name|CONSISTENT
argument_list|(
name|sock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * See comments for send_recvdone_event() above.  */
end_comment

begin_function
specifier|static
name|void
name|send_senddone_event
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socketevent_t
modifier|*
modifier|*
name|dev
parameter_list|)
block|{
name|isc_task_t
modifier|*
name|task
decl_stmt|;
name|INSIST
argument_list|(
name|dev
operator|!=
name|NULL
operator|&&
operator|*
name|dev
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|task
operator|=
operator|(
operator|*
name|dev
operator|)
operator|->
name|ev_sender
expr_stmt|;
operator|(
operator|*
name|dev
operator|)
operator|->
name|ev_sender
operator|=
name|sock
expr_stmt|;
if|if
condition|(
name|ISC_LINK_LINKED
argument_list|(
operator|*
name|dev
argument_list|,
name|ev_link
argument_list|)
condition|)
name|ISC_LIST_DEQUEUE
argument_list|(
name|sock
operator|->
name|send_list
argument_list|,
operator|*
name|dev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|*
name|dev
operator|)
operator|->
name|attributes
operator|&
name|ISC_SOCKEVENTATTR_ATTACHED
operator|)
operator|==
name|ISC_SOCKEVENTATTR_ATTACHED
condition|)
name|isc_task_sendanddetach
argument_list|(
operator|&
name|task
argument_list|,
operator|(
name|isc_event_t
operator|*
operator|*
operator|)
name|dev
argument_list|)
expr_stmt|;
else|else
name|isc_task_send
argument_list|(
name|task
argument_list|,
operator|(
name|isc_event_t
operator|*
operator|*
operator|)
name|dev
argument_list|)
expr_stmt|;
name|CONSISTENT
argument_list|(
name|sock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * See comments for send_recvdone_event() above.  */
end_comment

begin_function
specifier|static
name|void
name|send_acceptdone_event
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socket_newconnev_t
modifier|*
modifier|*
name|adev
parameter_list|)
block|{
name|isc_task_t
modifier|*
name|task
decl_stmt|;
name|INSIST
argument_list|(
name|adev
operator|!=
name|NULL
operator|&&
operator|*
name|adev
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|task
operator|=
operator|(
operator|*
name|adev
operator|)
operator|->
name|ev_sender
expr_stmt|;
operator|(
operator|*
name|adev
operator|)
operator|->
name|ev_sender
operator|=
name|sock
expr_stmt|;
if|if
condition|(
name|ISC_LINK_LINKED
argument_list|(
operator|*
name|adev
argument_list|,
name|ev_link
argument_list|)
condition|)
name|ISC_LIST_DEQUEUE
argument_list|(
name|sock
operator|->
name|accept_list
argument_list|,
operator|*
name|adev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
name|isc_task_sendanddetach
argument_list|(
operator|&
name|task
argument_list|,
operator|(
name|isc_event_t
operator|*
operator|*
operator|)
name|adev
argument_list|)
expr_stmt|;
name|CONSISTENT
argument_list|(
name|sock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * See comments for send_recvdone_event() above.  */
end_comment

begin_function
specifier|static
name|void
name|send_connectdone_event
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socket_connev_t
modifier|*
modifier|*
name|cdev
parameter_list|)
block|{
name|isc_task_t
modifier|*
name|task
decl_stmt|;
name|INSIST
argument_list|(
name|cdev
operator|!=
name|NULL
operator|&&
operator|*
name|cdev
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|task
operator|=
operator|(
operator|*
name|cdev
operator|)
operator|->
name|ev_sender
expr_stmt|;
operator|(
operator|*
name|cdev
operator|)
operator|->
name|ev_sender
operator|=
name|sock
expr_stmt|;
name|sock
operator|->
name|connect_ev
operator|=
name|NULL
expr_stmt|;
name|isc_task_sendanddetach
argument_list|(
operator|&
name|task
argument_list|,
operator|(
name|isc_event_t
operator|*
operator|*
operator|)
name|cdev
argument_list|)
expr_stmt|;
name|CONSISTENT
argument_list|(
name|sock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * On entry to this function, the event delivered is the internal  * readable event, and the first item on the accept_list should be  * the done event we want to send.  If the list is empty, this is a no-op,  * so just close the new connection, unlock, and return.  *  * Note the socket is locked before entering here  */
end_comment

begin_function
specifier|static
name|void
name|internal_accept
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|IoCompletionInfo
modifier|*
name|lpo
parameter_list|,
name|int
name|accept_errno
parameter_list|)
block|{
name|isc_socket_newconnev_t
modifier|*
name|adev
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|isc_socket_t
modifier|*
name|nsock
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|localaddr
decl_stmt|;
name|int
name|localaddr_len
init|=
sizeof|sizeof
argument_list|(
operator|*
name|localaddr
argument_list|)
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|remoteaddr
decl_stmt|;
name|int
name|remoteaddr_len
init|=
sizeof|sizeof
argument_list|(
operator|*
name|remoteaddr
argument_list|)
decl_stmt|;
name|INSIST
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|CONSISTENT
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|socket_log
argument_list|(
name|__LINE__
argument_list|,
name|sock
argument_list|,
name|NULL
argument_list|,
name|TRACE
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_ACCEPTLOCK
argument_list|,
literal|"internal_accept called"
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|listener
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|pending_iocp
operator|>
literal|0
argument_list|)
expr_stmt|;
name|sock
operator|->
name|pending_iocp
operator|--
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|pending_accept
operator|>
literal|0
argument_list|)
expr_stmt|;
name|sock
operator|->
name|pending_accept
operator|--
expr_stmt|;
name|adev
operator|=
name|lpo
operator|->
name|adev
expr_stmt|;
comment|/* 	 * If the event is no longer in the list we can just return. 	 */
if|if
condition|(
operator|!
name|acceptdone_is_active
argument_list|(
name|sock
argument_list|,
name|adev
argument_list|)
condition|)
goto|goto
name|done
goto|;
name|nsock
operator|=
name|adev
operator|->
name|newsocket
expr_stmt|;
comment|/* 	 * Pull off the done event. 	 */
name|ISC_LIST_UNLINK
argument_list|(
name|sock
operator|->
name|accept_list
argument_list|,
name|adev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
comment|/* 	 * Extract the addresses from the socket, copy them into the structure, 	 * and return the new socket. 	 */
name|ISCGetAcceptExSockaddrs
argument_list|(
name|lpo
operator|->
name|acceptbuffer
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|SOCKADDR_STORAGE
argument_list|)
operator|+
literal|16
argument_list|,
sizeof|sizeof
argument_list|(
name|SOCKADDR_STORAGE
argument_list|)
operator|+
literal|16
argument_list|,
operator|(
name|LPSOCKADDR
operator|*
operator|)
operator|&
name|localaddr
argument_list|,
operator|&
name|localaddr_len
argument_list|,
operator|(
name|LPSOCKADDR
operator|*
operator|)
operator|&
name|remoteaddr
argument_list|,
operator|&
name|remoteaddr_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|adev
operator|->
name|address
operator|.
name|type
argument_list|,
name|remoteaddr
argument_list|,
name|remoteaddr_len
argument_list|)
expr_stmt|;
name|adev
operator|->
name|address
operator|.
name|length
operator|=
name|remoteaddr_len
expr_stmt|;
name|nsock
operator|->
name|address
operator|=
name|adev
operator|->
name|address
expr_stmt|;
name|nsock
operator|->
name|pf
operator|=
name|adev
operator|->
name|address
operator|.
name|type
operator|.
name|sa
operator|.
name|sa_family
expr_stmt|;
name|socket_log
argument_list|(
name|__LINE__
argument_list|,
name|nsock
argument_list|,
operator|&
name|nsock
operator|->
name|address
argument_list|,
name|TRACE
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_ACCEPTLOCK
argument_list|,
literal|"internal_accept parent %p"
argument_list|,
name|sock
argument_list|)
expr_stmt|;
name|result
operator|=
name|make_nonblock
argument_list|(
name|adev
operator|->
name|newsocket
operator|->
name|fd
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|result
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|setsockopt
argument_list|(
name|nsock
operator|->
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_UPDATE_ACCEPT_CONTEXT
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sock
operator|->
name|fd
argument_list|,
sizeof|sizeof
argument_list|(
name|sock
operator|->
name|fd
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Hook it up into the manager. 	 */
name|nsock
operator|->
name|bound
operator|=
literal|1
expr_stmt|;
name|nsock
operator|->
name|connected
operator|=
literal|1
expr_stmt|;
name|_set_state
argument_list|(
name|nsock
argument_list|,
name|SOCK_OPEN
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|nsock
operator|->
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|nsock
operator|->
name|manager
operator|->
name|socklist
argument_list|,
name|nsock
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|InterlockedIncrement
argument_list|(
operator|&
name|nsock
operator|->
name|manager
operator|->
name|totalSockets
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|nsock
operator|->
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|socket_log
argument_list|(
name|__LINE__
argument_list|,
name|sock
argument_list|,
operator|&
name|nsock
operator|->
name|address
argument_list|,
name|CREATION
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_ACCEPTEDCXN
argument_list|,
literal|"accepted_connection new_socket %p fd %d"
argument_list|,
name|nsock
argument_list|,
name|nsock
operator|->
name|fd
argument_list|)
expr_stmt|;
name|adev
operator|->
name|result
operator|=
name|result
expr_stmt|;
name|send_acceptdone_event
argument_list|(
name|sock
argument_list|,
operator|&
name|adev
argument_list|)
expr_stmt|;
name|done
label|:
name|CONSISTENT
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|HeapFree
argument_list|(
name|hHeapHandle
argument_list|,
literal|0
argument_list|,
name|lpo
operator|->
name|acceptbuffer
argument_list|)
expr_stmt|;
name|lpo
operator|->
name|acceptbuffer
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called when a socket with a pending connect() finishes.  * Note that the socket is locked before entering.  */
end_comment

begin_function
specifier|static
name|void
name|internal_connect
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|IoCompletionInfo
modifier|*
name|lpo
parameter_list|,
name|int
name|connect_errno
parameter_list|)
block|{
name|isc_socket_connev_t
modifier|*
name|cdev
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|INSIST
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|pending_iocp
operator|>
literal|0
argument_list|)
expr_stmt|;
name|sock
operator|->
name|pending_iocp
operator|--
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|pending_connect
operator|==
literal|1
argument_list|)
expr_stmt|;
name|sock
operator|->
name|pending_connect
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Has this event been canceled? 	 */
name|cdev
operator|=
name|lpo
operator|->
name|cdev
expr_stmt|;
if|if
condition|(
operator|!
name|connectdone_is_active
argument_list|(
name|sock
argument_list|,
name|cdev
argument_list|)
condition|)
block|{
name|sock
operator|->
name|pending_connect
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|fd
operator|!=
name|INVALID_SOCKET
condition|)
block|{
name|closesocket
argument_list|(
name|sock
operator|->
name|fd
argument_list|)
expr_stmt|;
name|sock
operator|->
name|fd
operator|=
name|INVALID_SOCKET
expr_stmt|;
name|_set_state
argument_list|(
name|sock
argument_list|,
name|SOCK_CLOSED
argument_list|)
expr_stmt|;
block|}
name|CONSISTENT
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Check possible Windows network event error status here. 	 */
if|if
condition|(
name|connect_errno
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * If the error is SOFT, just try again on this 		 * fd and pretend nothing strange happened. 		 */
if|if
condition|(
name|SOFT_ERROR
argument_list|(
name|connect_errno
argument_list|)
operator|||
name|connect_errno
operator|==
name|WSAEINPROGRESS
condition|)
block|{
name|sock
operator|->
name|pending_connect
operator|=
literal|1
expr_stmt|;
name|CONSISTENT
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 		 * Translate other errors into ISC_R_* flavors. 		 */
switch|switch
condition|(
name|connect_errno
condition|)
block|{
define|#
directive|define
name|ERROR_MATCH
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|case a: cdev->result = b; break;
name|ERROR_MATCH
argument_list|(
name|WSAEACCES
argument_list|,
name|ISC_R_NOPERM
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|WSAEADDRNOTAVAIL
argument_list|,
name|ISC_R_ADDRNOTAVAIL
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|WSAEAFNOSUPPORT
argument_list|,
name|ISC_R_ADDRNOTAVAIL
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|WSAECONNREFUSED
argument_list|,
name|ISC_R_CONNREFUSED
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|WSAEHOSTUNREACH
argument_list|,
name|ISC_R_HOSTUNREACH
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|WSAEHOSTDOWN
argument_list|,
name|ISC_R_HOSTDOWN
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|WSAENETUNREACH
argument_list|,
name|ISC_R_NETUNREACH
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|WSAENETDOWN
argument_list|,
name|ISC_R_NETDOWN
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|WSAENOBUFS
argument_list|,
name|ISC_R_NORESOURCES
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|WSAECONNRESET
argument_list|,
name|ISC_R_CONNECTIONRESET
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|WSAECONNABORTED
argument_list|,
name|ISC_R_CONNECTIONRESET
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|WSAETIMEDOUT
argument_list|,
name|ISC_R_TIMEDOUT
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|ERROR_MATCH
default|default:
name|cdev
operator|->
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
name|isc__strerror
argument_list|(
name|connect_errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"internal_connect: connect() %s"
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|INSIST
argument_list|(
name|setsockopt
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_UPDATE_CONNECT_CONTEXT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|cdev
operator|->
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|sock
operator|->
name|connected
operator|=
literal|1
expr_stmt|;
name|socket_log
argument_list|(
name|__LINE__
argument_list|,
name|sock
argument_list|,
operator|&
name|sock
operator|->
name|address
argument_list|,
name|IOEVENT
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_ACCEPTEDCXN
argument_list|,
literal|"internal_connect: success"
argument_list|)
expr_stmt|;
block|}
name|send_connectdone_event
argument_list|(
name|sock
argument_list|,
operator|&
name|cdev
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Loop through the socket, returning ISC_R_EOF for each done event pending.  */
end_comment

begin_function
specifier|static
name|void
name|send_recvdone_abort
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_result_t
name|result
parameter_list|)
block|{
name|isc_socketevent_t
modifier|*
name|dev
decl_stmt|;
while|while
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|)
condition|)
block|{
name|dev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|)
expr_stmt|;
name|dev
operator|->
name|result
operator|=
name|result
expr_stmt|;
name|send_recvdone_event
argument_list|(
name|sock
argument_list|,
operator|&
name|dev
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Take the data we received in our private buffer, and if any recv() calls on  * our list are satisfied, send the corresponding done event.  *  * If we need more data (there are still items on the recv_list after we consume all  * our data) then arrange for another system recv() call to fill our buffers.  */
end_comment

begin_function
specifier|static
name|void
name|internal_recv
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|int
name|nbytes
parameter_list|)
block|{
name|INSIST
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|CONSISTENT
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|socket_log
argument_list|(
name|__LINE__
argument_list|,
name|sock
argument_list|,
name|NULL
argument_list|,
name|IOEVENT
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_INTERNALRECV
argument_list|,
literal|"internal_recv: %d bytes received"
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
comment|/* 	 * If we got here, the I/O operation succeeded.  However, we might still have removed this 	 * event from our notification list (or never placed it on it due to immediate completion.) 	 * Handle the reference counting here, and handle the cancellation event just after. 	 */
name|INSIST
argument_list|(
name|sock
operator|->
name|pending_iocp
operator|>
literal|0
argument_list|)
expr_stmt|;
name|sock
operator|->
name|pending_iocp
operator|--
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|pending_recv
operator|>
literal|0
argument_list|)
expr_stmt|;
name|sock
operator|->
name|pending_recv
operator|--
expr_stmt|;
comment|/* 	 * The only way we could have gotten here is that our I/O has successfully completed. 	 * Update our pointers, and move on.  The only odd case here is that we might not 	 * have received enough data on a TCP stream to satisfy the minimum requirements.  If 	 * this is the case, we will re-issue the recv() call for what we need. 	 * 	 * We do check for a recv() of 0 bytes on a TCP stream.  This means the remote end 	 * has closed. 	 */
if|if
condition|(
name|nbytes
operator|==
literal|0
operator|&&
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_tcp
condition|)
block|{
name|send_recvdone_abort
argument_list|(
name|sock
argument_list|,
name|ISC_R_EOF
argument_list|)
expr_stmt|;
name|maybe_free_socket
argument_list|(
operator|&
name|sock
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
return|return;
block|}
name|sock
operator|->
name|recvbuf
operator|.
name|remaining
operator|=
name|nbytes
expr_stmt|;
name|sock
operator|->
name|recvbuf
operator|.
name|consume_position
operator|=
name|sock
operator|->
name|recvbuf
operator|.
name|base
expr_stmt|;
name|completeio_recv
argument_list|(
name|sock
argument_list|)
expr_stmt|;
comment|/* 	 * If there are more receivers waiting for data, queue another receive 	 * here. 	 */
name|queue_receive_request
argument_list|(
name|sock
argument_list|)
expr_stmt|;
comment|/* 	 * Unlock and/or destroy if we are the last thing this socket has left to do. 	 */
name|maybe_free_socket
argument_list|(
operator|&
name|sock
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|internal_send
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socketevent_t
modifier|*
name|dev
parameter_list|,
name|struct
name|msghdr
modifier|*
name|messagehdr
parameter_list|,
name|int
name|nbytes
parameter_list|,
name|int
name|send_errno
parameter_list|,
name|IoCompletionInfo
modifier|*
name|lpo
parameter_list|)
block|{
name|buflist_t
modifier|*
name|buffer
decl_stmt|;
comment|/* 	 * Find out what socket this is and lock it. 	 */
name|INSIST
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|CONSISTENT
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|socket_log
argument_list|(
name|__LINE__
argument_list|,
name|sock
argument_list|,
name|NULL
argument_list|,
name|IOEVENT
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_INTERNALSEND
argument_list|,
literal|"internal_send: task got socket event %p"
argument_list|,
name|dev
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|lpo
operator|->
name|bufferlist
argument_list|)
expr_stmt|;
while|while
condition|(
name|buffer
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_DEQUEUE
argument_list|(
name|lpo
operator|->
name|bufferlist
argument_list|,
name|buffer
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|socket_log
argument_list|(
name|__LINE__
argument_list|,
name|sock
argument_list|,
name|NULL
argument_list|,
name|TRACE
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_ACCEPTLOCK
argument_list|,
literal|"free_buffer %p %p"
argument_list|,
name|buffer
argument_list|,
name|buffer
operator|->
name|buf
argument_list|)
expr_stmt|;
name|HeapFree
argument_list|(
name|hHeapHandle
argument_list|,
literal|0
argument_list|,
name|buffer
operator|->
name|buf
argument_list|)
expr_stmt|;
name|HeapFree
argument_list|(
name|hHeapHandle
argument_list|,
literal|0
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|lpo
operator|->
name|bufferlist
argument_list|)
expr_stmt|;
block|}
name|INSIST
argument_list|(
name|sock
operator|->
name|pending_iocp
operator|>
literal|0
argument_list|)
expr_stmt|;
name|sock
operator|->
name|pending_iocp
operator|--
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|pending_send
operator|>
literal|0
argument_list|)
expr_stmt|;
name|sock
operator|->
name|pending_send
operator|--
expr_stmt|;
comment|/* If the event is no longer in the list we can just return */
if|if
condition|(
operator|!
name|senddone_is_active
argument_list|(
name|sock
argument_list|,
name|dev
argument_list|)
condition|)
goto|goto
name|done
goto|;
comment|/* 	 * Set the error code and send things on its way. 	 */
switch|switch
condition|(
name|completeio_send
argument_list|(
name|sock
argument_list|,
name|dev
argument_list|,
name|messagehdr
argument_list|,
name|nbytes
argument_list|,
name|send_errno
argument_list|)
condition|)
block|{
case|case
name|DOIO_SOFT
case|:
break|break;
case|case
name|DOIO_HARD
case|:
case|case
name|DOIO_SUCCESS
case|:
name|send_senddone_event
argument_list|(
name|sock
argument_list|,
operator|&
name|dev
argument_list|)
expr_stmt|;
break|break;
block|}
name|done
label|:
name|maybe_free_socket
argument_list|(
operator|&
name|sock
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * These return if the done event passed in is on the list (or for connect, is  * the one we're waiting for.  Using these ensures we will not double-send an  * event.  */
end_comment

begin_function
specifier|static
name|isc_boolean_t
name|senddone_is_active
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socketevent_t
modifier|*
name|dev
parameter_list|)
block|{
name|isc_socketevent_t
modifier|*
name|ldev
decl_stmt|;
name|ldev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sock
operator|->
name|send_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|ldev
operator|!=
name|NULL
operator|&&
name|ldev
operator|!=
name|dev
condition|)
name|ldev
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|ldev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
return|return
operator|(
name|ldev
operator|==
name|NULL
condition|?
name|ISC_FALSE
else|:
name|ISC_TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|acceptdone_is_active
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socket_newconnev_t
modifier|*
name|dev
parameter_list|)
block|{
name|isc_socket_newconnev_t
modifier|*
name|ldev
decl_stmt|;
name|ldev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sock
operator|->
name|accept_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|ldev
operator|!=
name|NULL
operator|&&
name|ldev
operator|!=
name|dev
condition|)
name|ldev
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|ldev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
return|return
operator|(
name|ldev
operator|==
name|NULL
condition|?
name|ISC_FALSE
else|:
name|ISC_TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_boolean_t
name|connectdone_is_active
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socket_connev_t
modifier|*
name|dev
parameter_list|)
block|{
return|return
operator|(
name|sock
operator|->
name|connect_ev
operator|==
name|dev
condition|?
name|ISC_TRUE
else|:
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|//
end_comment

begin_comment
comment|// The Windows network stack seems to have two very distinct paths depending
end_comment

begin_comment
comment|// on what is installed.  Specifically, if something is looking at network
end_comment

begin_comment
comment|// connections (like an anti-virus or anti-malware application, such as
end_comment

begin_comment
comment|// McAfee products) Windows may return additional error conditions which
end_comment

begin_comment
comment|// were not previously returned.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// One specific one is when a TCP SYN scan is used.  In this situation,
end_comment

begin_comment
comment|// Windows responds with the SYN-ACK, but the scanner never responds with
end_comment

begin_comment
comment|// the 3rd packet, the ACK.  Windows consiers this a partially open connection.
end_comment

begin_comment
comment|// Most Unix networking stacks, and Windows without McAfee installed, will
end_comment

begin_comment
comment|// not return this to the caller.  However, with this product installed,
end_comment

begin_comment
comment|// Windows returns this as a failed status on the Accept() call.  Here, we
end_comment

begin_comment
comment|// will just re-issue the ISCAcceptEx() call as if nothing had happened.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This code should only be called when the listening socket has received
end_comment

begin_comment
comment|// such an error.  Additionally, the "parent" socket must be locked.
end_comment

begin_comment
comment|// Additionally, the lpo argument is re-used here, and must not be freed
end_comment

begin_comment
comment|// by the caller.
end_comment

begin_comment
comment|//
end_comment

begin_function
specifier|static
name|isc_result_t
name|restart_accept
parameter_list|(
name|isc_socket_t
modifier|*
name|parent
parameter_list|,
name|IoCompletionInfo
modifier|*
name|lpo
parameter_list|)
block|{
name|isc_socket_t
modifier|*
name|nsock
init|=
name|lpo
operator|->
name|adev
operator|->
name|newsocket
decl_stmt|;
name|SOCKET
name|new_fd
decl_stmt|;
comment|/* 	 * AcceptEx() requires we pass in a socket.  Note that we carefully 	 * do not close the previous socket in case of an error message returned by 	 * our new socket() call.  If we return an error here, our caller will 	 * clean up. 	 */
name|new_fd
operator|=
name|socket
argument_list|(
name|parent
operator|->
name|pf
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsock
operator|->
name|fd
operator|==
name|INVALID_SOCKET
condition|)
block|{
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
comment|// parent will ask windows for error message
block|}
name|closesocket
argument_list|(
name|nsock
operator|->
name|fd
argument_list|)
expr_stmt|;
name|nsock
operator|->
name|fd
operator|=
name|new_fd
expr_stmt|;
name|memset
argument_list|(
operator|&
name|lpo
operator|->
name|overlapped
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|lpo
operator|->
name|overlapped
argument_list|)
argument_list|)
expr_stmt|;
name|ISCAcceptEx
argument_list|(
name|parent
operator|->
name|fd
argument_list|,
name|nsock
operator|->
name|fd
argument_list|,
comment|/* Accepted Socket */
name|lpo
operator|->
name|acceptbuffer
argument_list|,
comment|/* Buffer for initial Recv */
literal|0
argument_list|,
comment|/* Length of Buffer */
sizeof|sizeof
argument_list|(
name|SOCKADDR_STORAGE
argument_list|)
operator|+
literal|16
argument_list|,
comment|/* Local address length + 16 */
sizeof|sizeof
argument_list|(
name|SOCKADDR_STORAGE
argument_list|)
operator|+
literal|16
argument_list|,
comment|/* Remote address lengh + 16 */
operator|(
name|LPDWORD
operator|)
operator|&
name|lpo
operator|->
name|received_bytes
argument_list|,
comment|/* Bytes Recved */
operator|(
name|LPOVERLAPPED
operator|)
name|lpo
comment|/* Overlapped structure */
argument_list|)
expr_stmt|;
name|InterlockedDecrement
argument_list|(
operator|&
name|nsock
operator|->
name|manager
operator|->
name|iocp_total
argument_list|)
expr_stmt|;
name|iocompletionport_update
argument_list|(
name|nsock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is the I/O Completion Port Worker Function. It loops forever  * waiting for I/O to complete and then forwards them for further  * processing. There are a number of these in separate threads.  */
end_comment

begin_function
specifier|static
name|isc_threadresult_t
name|WINAPI
name|SocketIoThread
parameter_list|(
name|LPVOID
name|ThreadContext
parameter_list|)
block|{
name|isc_socketmgr_t
modifier|*
name|manager
init|=
name|ThreadContext
decl_stmt|;
name|BOOL
name|bSuccess
init|=
name|FALSE
decl_stmt|;
name|DWORD
name|nbytes
decl_stmt|;
name|IoCompletionInfo
modifier|*
name|lpo
init|=
name|NULL
decl_stmt|;
name|isc_socket_t
modifier|*
name|sock
init|=
name|NULL
decl_stmt|;
name|int
name|request
decl_stmt|;
name|struct
name|msghdr
modifier|*
name|messagehdr
init|=
name|NULL
decl_stmt|;
name|int
name|errval
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|int
name|errstatus
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Set the thread priority high enough so I/O will 	 * preempt normal recv packet processing, but not 	 * higher than the timer sync thread. 	 */
if|if
condition|(
operator|!
name|SetThreadPriority
argument_list|(
name|GetCurrentThread
argument_list|()
argument_list|,
name|THREAD_PRIORITY_ABOVE_NORMAL
argument_list|)
condition|)
block|{
name|errval
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
name|isc__strerror
argument_list|(
name|errval
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|FATAL_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"Can't set thread priority: %s"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Loop forever waiting on I/O Completions and then processing them 	 */
while|while
condition|(
name|TRUE
condition|)
block|{
name|wait_again
label|:
name|bSuccess
operator|=
name|GetQueuedCompletionStatus
argument_list|(
name|manager
operator|->
name|hIoCompletionPort
argument_list|,
operator|&
name|nbytes
argument_list|,
operator|(
name|LPDWORD
operator|)
operator|&
name|sock
argument_list|,
operator|(
name|LPWSAOVERLAPPED
operator|*
operator|)
operator|&
name|lpo
argument_list|,
name|INFINITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|lpo
operator|==
name|NULL
condition|)
comment|/* Received request to exit */
break|break;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|request
operator|=
name|lpo
operator|->
name|request_type
expr_stmt|;
name|errstatus
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|bSuccess
condition|)
block|{
name|isc_result_t
name|isc_result
decl_stmt|;
comment|/* 			 * Did the I/O operation complete? 			 */
name|errstatus
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
name|isc_result
operator|=
name|isc__errno2resultx
argument_list|(
name|errstatus
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|CONSISTENT
argument_list|(
name|sock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|request
condition|)
block|{
case|case
name|SOCKET_RECV
case|:
name|INSIST
argument_list|(
name|sock
operator|->
name|pending_iocp
operator|>
literal|0
argument_list|)
expr_stmt|;
name|sock
operator|->
name|pending_iocp
operator|--
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|pending_recv
operator|>
literal|0
argument_list|)
expr_stmt|;
name|sock
operator|->
name|pending_recv
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|sock
operator|->
name|connected
operator|&&
operator|(
operator|(
name|errstatus
operator|==
name|ERROR_HOST_UNREACHABLE
operator|)
operator|||
operator|(
name|errstatus
operator|==
name|WSAENETRESET
operator|)
operator|||
operator|(
name|errstatus
operator|==
name|WSAECONNRESET
operator|)
operator|)
condition|)
block|{
comment|/* ignore soft errors */
name|queue_receive_request
argument_list|(
name|sock
argument_list|)
expr_stmt|;
break|break;
block|}
name|send_recvdone_abort
argument_list|(
name|sock
argument_list|,
name|isc_result
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_result
operator|==
name|ISC_R_UNEXPECTED
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"SOCKET_RECV: Windows error code: %d, returning ISC error %d"
argument_list|,
name|errstatus
argument_list|,
name|isc_result
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SOCKET_SEND
case|:
name|INSIST
argument_list|(
name|sock
operator|->
name|pending_iocp
operator|>
literal|0
argument_list|)
expr_stmt|;
name|sock
operator|->
name|pending_iocp
operator|--
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|pending_send
operator|>
literal|0
argument_list|)
expr_stmt|;
name|sock
operator|->
name|pending_send
operator|--
expr_stmt|;
if|if
condition|(
name|senddone_is_active
argument_list|(
name|sock
argument_list|,
name|lpo
operator|->
name|dev
argument_list|)
condition|)
block|{
name|lpo
operator|->
name|dev
operator|->
name|result
operator|=
name|isc_result
expr_stmt|;
name|socket_log
argument_list|(
name|__LINE__
argument_list|,
name|sock
argument_list|,
name|NULL
argument_list|,
name|EVENT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"canceled_send"
argument_list|)
expr_stmt|;
name|send_senddone_event
argument_list|(
name|sock
argument_list|,
operator|&
name|lpo
operator|->
name|dev
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SOCKET_ACCEPT
case|:
name|INSIST
argument_list|(
name|sock
operator|->
name|pending_iocp
operator|>
literal|0
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|pending_accept
operator|>
literal|0
argument_list|)
expr_stmt|;
name|socket_log
argument_list|(
name|__LINE__
argument_list|,
name|sock
argument_list|,
name|NULL
argument_list|,
name|EVENT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"Accept: errstatus=%d isc_result=%d"
argument_list|,
name|errstatus
argument_list|,
name|isc_result
argument_list|)
expr_stmt|;
if|if
condition|(
name|acceptdone_is_active
argument_list|(
name|sock
argument_list|,
name|lpo
operator|->
name|adev
argument_list|)
condition|)
block|{
if|if
condition|(
name|restart_accept
argument_list|(
name|sock
argument_list|,
name|lpo
argument_list|)
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
goto|goto
name|wait_again
goto|;
block|}
else|else
block|{
name|errstatus
operator|=
name|GetLastError
argument_list|()
expr_stmt|;
name|isc_result
operator|=
name|isc__errno2resultx
argument_list|(
name|errstatus
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|socket_log
argument_list|(
name|__LINE__
argument_list|,
name|sock
argument_list|,
name|NULL
argument_list|,
name|EVENT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"restart_accept() failed: errstatus=%d isc_result=%d"
argument_list|,
name|errstatus
argument_list|,
name|isc_result
argument_list|)
expr_stmt|;
block|}
block|}
name|sock
operator|->
name|pending_iocp
operator|--
expr_stmt|;
name|sock
operator|->
name|pending_accept
operator|--
expr_stmt|;
if|if
condition|(
name|acceptdone_is_active
argument_list|(
name|sock
argument_list|,
name|lpo
operator|->
name|adev
argument_list|)
condition|)
block|{
name|closesocket
argument_list|(
name|lpo
operator|->
name|adev
operator|->
name|newsocket
operator|->
name|fd
argument_list|)
expr_stmt|;
name|lpo
operator|->
name|adev
operator|->
name|newsocket
operator|->
name|fd
operator|=
name|INVALID_SOCKET
expr_stmt|;
name|lpo
operator|->
name|adev
operator|->
name|newsocket
operator|->
name|references
operator|--
expr_stmt|;
name|free_socket
argument_list|(
operator|&
name|lpo
operator|->
name|adev
operator|->
name|newsocket
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|lpo
operator|->
name|adev
operator|->
name|result
operator|=
name|isc_result
expr_stmt|;
name|socket_log
argument_list|(
name|__LINE__
argument_list|,
name|sock
argument_list|,
name|NULL
argument_list|,
name|EVENT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"canceled_accept"
argument_list|)
expr_stmt|;
name|send_acceptdone_event
argument_list|(
name|sock
argument_list|,
operator|&
name|lpo
operator|->
name|adev
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|SOCKET_CONNECT
case|:
name|INSIST
argument_list|(
name|sock
operator|->
name|pending_iocp
operator|>
literal|0
argument_list|)
expr_stmt|;
name|sock
operator|->
name|pending_iocp
operator|--
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|pending_connect
operator|==
literal|1
argument_list|)
expr_stmt|;
name|sock
operator|->
name|pending_connect
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|connectdone_is_active
argument_list|(
name|sock
argument_list|,
name|lpo
operator|->
name|cdev
argument_list|)
condition|)
block|{
name|lpo
operator|->
name|cdev
operator|->
name|result
operator|=
name|isc_result
expr_stmt|;
name|socket_log
argument_list|(
name|__LINE__
argument_list|,
name|sock
argument_list|,
name|NULL
argument_list|,
name|EVENT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"canceled_connect"
argument_list|)
expr_stmt|;
name|send_connectdone_event
argument_list|(
name|sock
argument_list|,
operator|&
name|lpo
operator|->
name|cdev
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|maybe_free_socket
argument_list|(
operator|&
name|sock
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
if|if
condition|(
name|lpo
operator|!=
name|NULL
condition|)
name|HeapFree
argument_list|(
name|hHeapHandle
argument_list|,
literal|0
argument_list|,
name|lpo
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|messagehdr
operator|=
operator|&
name|lpo
operator|->
name|messagehdr
expr_stmt|;
switch|switch
condition|(
name|request
condition|)
block|{
case|case
name|SOCKET_RECV
case|:
name|internal_recv
argument_list|(
name|sock
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
break|break;
case|case
name|SOCKET_SEND
case|:
name|internal_send
argument_list|(
name|sock
argument_list|,
name|lpo
operator|->
name|dev
argument_list|,
name|messagehdr
argument_list|,
name|nbytes
argument_list|,
name|errstatus
argument_list|,
name|lpo
argument_list|)
expr_stmt|;
break|break;
case|case
name|SOCKET_ACCEPT
case|:
name|internal_accept
argument_list|(
name|sock
argument_list|,
name|lpo
argument_list|,
name|errstatus
argument_list|)
expr_stmt|;
break|break;
case|case
name|SOCKET_CONNECT
case|:
name|internal_connect
argument_list|(
name|sock
argument_list|,
name|lpo
argument_list|,
name|errstatus
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|lpo
operator|!=
name|NULL
condition|)
name|HeapFree
argument_list|(
name|hHeapHandle
argument_list|,
literal|0
argument_list|,
name|lpo
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Exit Completion Port Thread 	 */
name|manager_log
argument_list|(
name|manager
argument_list|,
name|TRACE
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_EXITING
argument_list|,
literal|"SocketIoThread exiting"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|isc_threadresult_t
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a new socket manager.  */
end_comment

begin_function
name|isc_result_t
name|isc__socketmgr_create
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|isc_socketmgr_t
modifier|*
modifier|*
name|managerp
parameter_list|)
block|{
return|return
operator|(
name|isc_socketmgr_create2
argument_list|(
name|mctx
argument_list|,
name|managerp
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc__socketmgr_create2
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|isc_socketmgr_t
modifier|*
modifier|*
name|managerp
parameter_list|,
name|unsigned
name|int
name|maxsocks
parameter_list|)
block|{
name|isc_socketmgr_t
modifier|*
name|manager
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|managerp
operator|!=
name|NULL
operator|&&
operator|*
name|managerp
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxsocks
operator|!=
literal|0
condition|)
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
name|manager
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|manager
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|manager
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|InitSockets
argument_list|()
expr_stmt|;
name|manager
operator|->
name|magic
operator|=
name|SOCKET_MANAGER_MAGIC
expr_stmt|;
name|manager
operator|->
name|mctx
operator|=
name|NULL
expr_stmt|;
name|manager
operator|->
name|stats
operator|=
name|NULL
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|manager
operator|->
name|socklist
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|manager
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
if|if
condition|(
name|isc_condition_init
argument_list|(
operator|&
name|manager
operator|->
name|shutdown_ok
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|DESTROYLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_condition_init() %s"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
name|isc_mem_attach
argument_list|(
name|mctx
argument_list|,
operator|&
name|manager
operator|->
name|mctx
argument_list|)
expr_stmt|;
name|iocompletionport_init
argument_list|(
name|manager
argument_list|)
expr_stmt|;
comment|/* Create the Completion Ports */
name|manager
operator|->
name|bShutdown
operator|=
name|ISC_FALSE
expr_stmt|;
name|manager
operator|->
name|totalSockets
operator|=
literal|0
expr_stmt|;
name|manager
operator|->
name|iocp_total
operator|=
literal|0
expr_stmt|;
operator|*
name|managerp
operator|=
name|manager
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc__socketmgr_getmaxsockets
parameter_list|(
name|isc_socketmgr_t
modifier|*
name|manager
parameter_list|,
name|unsigned
name|int
modifier|*
name|nsockp
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|nsockp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc__socketmgr_setstats
parameter_list|(
name|isc_socketmgr_t
modifier|*
name|manager
parameter_list|,
name|isc_stats_t
modifier|*
name|stats
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|manager
operator|->
name|socklist
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|manager
operator|->
name|stats
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|isc_stats_ncounters
argument_list|(
name|stats
argument_list|)
operator|==
name|isc_sockstatscounter_max
argument_list|)
expr_stmt|;
name|isc_stats_attach
argument_list|(
name|stats
argument_list|,
operator|&
name|manager
operator|->
name|stats
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isc__socketmgr_destroy
parameter_list|(
name|isc_socketmgr_t
modifier|*
modifier|*
name|managerp
parameter_list|)
block|{
name|isc_socketmgr_t
modifier|*
name|manager
decl_stmt|;
name|int
name|i
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
comment|/* 	 * Destroy a socket manager. 	 */
name|REQUIRE
argument_list|(
name|managerp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|manager
operator|=
operator|*
name|managerp
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for all sockets to be destroyed. 	 */
while|while
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|manager
operator|->
name|socklist
argument_list|)
condition|)
block|{
name|manager_log
argument_list|(
name|manager
argument_list|,
name|CREATION
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_SOCKETSREMAIN
argument_list|,
literal|"sockets exist"
argument_list|)
argument_list|)
expr_stmt|;
name|WAIT
argument_list|(
operator|&
name|manager
operator|->
name|shutdown_ok
argument_list|,
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Here, we need to had some wait code for the completion port 	 * thread. 	 */
name|signal_iocompletionport_exit
argument_list|(
name|manager
argument_list|)
expr_stmt|;
name|manager
operator|->
name|bShutdown
operator|=
name|ISC_TRUE
expr_stmt|;
comment|/* 	 * Wait for threads to exit. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|manager
operator|->
name|maxIOCPThreads
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|isc_thread_join
argument_list|(
operator|(
name|isc_thread_t
operator|)
name|manager
operator|->
name|hIOCPThreads
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_thread_join() for Completion Port %s"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Clean up. 	 */
name|CloseHandle
argument_list|(
name|manager
operator|->
name|hIoCompletionPort
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|isc_condition_destroy
argument_list|(
operator|&
name|manager
operator|->
name|shutdown_ok
argument_list|)
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|stats
operator|!=
name|NULL
condition|)
name|isc_stats_detach
argument_list|(
operator|&
name|manager
operator|->
name|stats
argument_list|)
expr_stmt|;
name|manager
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
name|mctx
operator|=
name|manager
operator|->
name|mctx
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_detach
argument_list|(
operator|&
name|mctx
argument_list|)
expr_stmt|;
operator|*
name|managerp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|queue_receive_event
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_socketevent_t
modifier|*
name|dev
parameter_list|)
block|{
name|isc_task_t
modifier|*
name|ntask
init|=
name|NULL
decl_stmt|;
name|isc_task_attach
argument_list|(
name|task
argument_list|,
operator|&
name|ntask
argument_list|)
expr_stmt|;
name|dev
operator|->
name|attributes
operator||=
name|ISC_SOCKEVENTATTR_ATTACHED
expr_stmt|;
comment|/* 	 * Enqueue the request. 	 */
name|INSIST
argument_list|(
operator|!
name|ISC_LINK_LINKED
argument_list|(
name|dev
argument_list|,
name|ev_link
argument_list|)
argument_list|)
expr_stmt|;
name|ISC_LIST_ENQUEUE
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|,
name|dev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
name|socket_log
argument_list|(
name|__LINE__
argument_list|,
name|sock
argument_list|,
name|NULL
argument_list|,
name|EVENT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"queue_receive_event: event %p -> task %p"
argument_list|,
name|dev
argument_list|,
name|ntask
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check the pending receive queue, and if we have data pending, give it to this  * caller.  If we have none, queue an I/O request.  If this caller is not the first  * on the list, then we will just queue this event and return.  *  * Caller must have the socket locked.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|socket_recv
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socketevent_t
modifier|*
name|dev
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|int
name|cc
init|=
literal|0
decl_stmt|;
name|isc_task_t
modifier|*
name|ntask
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|int
name|recv_errno
init|=
literal|0
decl_stmt|;
name|dev
operator|->
name|ev_sender
operator|=
name|task
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|fd
operator|==
name|INVALID_SOCKET
condition|)
return|return
operator|(
name|ISC_R_EOF
operator|)
return|;
comment|/* 	 * Queue our event on the list of things to do.  Call our function to 	 * attempt to fill buffers as much as possible, and return done events. 	 * We are going to lie about our handling of the ISC_SOCKFLAG_IMMEDIATE 	 * here and tell our caller that we could not satisfy it immediately. 	 */
name|queue_receive_event
argument_list|(
name|sock
argument_list|,
name|task
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|ISC_SOCKFLAG_IMMEDIATE
operator|)
operator|!=
literal|0
condition|)
name|result
operator|=
name|ISC_R_INPROGRESS
expr_stmt|;
name|completeio_recv
argument_list|(
name|sock
argument_list|)
expr_stmt|;
comment|/* 	 * If there are more receivers waiting for data, queue another receive 	 * here.  If the 	 */
name|queue_receive_request
argument_list|(
name|sock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc__socket_recvv
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_bufferlist_t
modifier|*
name|buflist
parameter_list|,
name|unsigned
name|int
name|minimum
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|isc_socketevent_t
modifier|*
name|dev
decl_stmt|;
name|isc_socketmgr_t
modifier|*
name|manager
decl_stmt|;
name|unsigned
name|int
name|iocount
decl_stmt|;
name|isc_buffer_t
modifier|*
name|buffer
decl_stmt|;
name|isc_result_t
name|ret
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|CONSISTENT
argument_list|(
name|sock
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure that the socket is not closed.  XXXMLG change error here? 	 */
if|if
condition|(
name|sock
operator|->
name|fd
operator|==
name|INVALID_SOCKET
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_CONNREFUSED
operator|)
return|;
block|}
name|REQUIRE
argument_list|(
name|buflist
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
operator|*
name|buflist
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|task
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|action
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|manager
operator|=
name|sock
operator|->
name|manager
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|iocount
operator|=
name|isc_bufferlist_availablecount
argument_list|(
name|buflist
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|iocount
operator|>
literal|0
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|bound
argument_list|)
expr_stmt|;
name|dev
operator|=
name|allocate_socketevent
argument_list|(
name|sock
argument_list|,
name|ISC_SOCKEVENT_RECVDONE
argument_list|,
name|action
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
comment|/* 	 * UDP sockets are always partial read 	 */
if|if
condition|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_udp
condition|)
name|dev
operator|->
name|minimum
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|minimum
operator|==
literal|0
condition|)
name|dev
operator|->
name|minimum
operator|=
name|iocount
expr_stmt|;
else|else
name|dev
operator|->
name|minimum
operator|=
name|minimum
expr_stmt|;
block|}
comment|/* 	 * Move each buffer from the passed in list to our internal one. 	 */
name|buffer
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|buflist
argument_list|)
expr_stmt|;
while|while
condition|(
name|buffer
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_DEQUEUE
argument_list|(
operator|*
name|buflist
argument_list|,
name|buffer
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_ENQUEUE
argument_list|(
name|dev
operator|->
name|bufferlist
argument_list|,
name|buffer
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|buflist
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|socket_recv
argument_list|(
name|sock
argument_list|,
name|dev
argument_list|,
name|task
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc__socket_recv
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_region_t
modifier|*
name|region
parameter_list|,
name|unsigned
name|int
name|minimum
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|isc_socketevent_t
modifier|*
name|dev
decl_stmt|;
name|isc_socketmgr_t
modifier|*
name|manager
decl_stmt|;
name|isc_result_t
name|ret
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|CONSISTENT
argument_list|(
name|sock
argument_list|)
expr_stmt|;
comment|/* 	 * make sure that the socket's not closed 	 */
if|if
condition|(
name|sock
operator|->
name|fd
operator|==
name|INVALID_SOCKET
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_CONNREFUSED
operator|)
return|;
block|}
name|REQUIRE
argument_list|(
name|action
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|manager
operator|=
name|sock
operator|->
name|manager
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|bound
argument_list|)
expr_stmt|;
name|dev
operator|=
name|allocate_socketevent
argument_list|(
name|sock
argument_list|,
name|ISC_SOCKEVENT_RECVDONE
argument_list|,
name|action
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|ret
operator|=
name|isc_socket_recv2
argument_list|(
name|sock
argument_list|,
name|region
argument_list|,
name|minimum
argument_list|,
name|task
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc__socket_recv2
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_region_t
modifier|*
name|region
parameter_list|,
name|unsigned
name|int
name|minimum
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_socketevent_t
modifier|*
name|event
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|isc_result_t
name|ret
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|CONSISTENT
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|event
operator|->
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
name|event
operator|->
name|ev_sender
operator|=
name|sock
expr_stmt|;
comment|/* 	 * make sure that the socket's not closed 	 */
if|if
condition|(
name|sock
operator|->
name|fd
operator|==
name|INVALID_SOCKET
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_CONNREFUSED
operator|)
return|;
block|}
name|ISC_LIST_INIT
argument_list|(
name|event
operator|->
name|bufferlist
argument_list|)
expr_stmt|;
name|event
operator|->
name|region
operator|=
operator|*
name|region
expr_stmt|;
name|event
operator|->
name|n
operator|=
literal|0
expr_stmt|;
name|event
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|event
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
comment|/* 	 * UDP sockets are always partial read. 	 */
if|if
condition|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_udp
condition|)
name|event
operator|->
name|minimum
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|minimum
operator|==
literal|0
condition|)
name|event
operator|->
name|minimum
operator|=
name|region
operator|->
name|length
expr_stmt|;
else|else
name|event
operator|->
name|minimum
operator|=
name|minimum
expr_stmt|;
block|}
name|ret
operator|=
name|socket_recv
argument_list|(
name|sock
argument_list|,
name|event
argument_list|,
name|task
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Caller must have the socket locked.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|socket_send
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socketevent_t
modifier|*
name|dev
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|address
parameter_list|,
name|struct
name|in6_pktinfo
modifier|*
name|pktinfo
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|int
name|io_state
decl_stmt|;
name|int
name|send_errno
init|=
literal|0
decl_stmt|;
name|int
name|cc
init|=
literal|0
decl_stmt|;
name|isc_task_t
modifier|*
name|ntask
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|dev
operator|->
name|ev_sender
operator|=
name|task
expr_stmt|;
name|set_dev_address
argument_list|(
name|address
argument_list|,
name|sock
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|pktinfo
operator|!=
name|NULL
condition|)
block|{
name|socket_log
argument_list|(
name|__LINE__
argument_list|,
name|sock
argument_list|,
name|NULL
argument_list|,
name|TRACE
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_PKTINFOPROVIDED
argument_list|,
literal|"pktinfo structure provided, ifindex %u (set to 0)"
argument_list|,
name|pktinfo
operator|->
name|ipi6_ifindex
argument_list|)
expr_stmt|;
name|dev
operator|->
name|attributes
operator||=
name|ISC_SOCKEVENTATTR_PKTINFO
expr_stmt|;
name|dev
operator|->
name|pktinfo
operator|=
operator|*
name|pktinfo
expr_stmt|;
comment|/* 		 * Set the pktinfo index to 0 here, to let the kernel decide 		 * what interface it should send on. 		 */
name|dev
operator|->
name|pktinfo
operator|.
name|ipi6_ifindex
operator|=
literal|0
expr_stmt|;
block|}
name|io_state
operator|=
name|startio_send
argument_list|(
name|sock
argument_list|,
name|dev
argument_list|,
operator|&
name|cc
argument_list|,
operator|&
name|send_errno
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|io_state
condition|)
block|{
case|case
name|DOIO_PENDING
case|:
comment|/* I/O started. Nothing more to do */
case|case
name|DOIO_SOFT
case|:
comment|/* 		 * We couldn't send all or part of the request right now, so 		 * queue it unless ISC_SOCKFLAG_NORETRY is set. 		 */
if|if
condition|(
operator|(
name|flags
operator|&
name|ISC_SOCKFLAG_NORETRY
operator|)
operator|==
literal|0
condition|)
block|{
name|isc_task_attach
argument_list|(
name|task
argument_list|,
operator|&
name|ntask
argument_list|)
expr_stmt|;
name|dev
operator|->
name|attributes
operator||=
name|ISC_SOCKEVENTATTR_ATTACHED
expr_stmt|;
comment|/* 			 * Enqueue the request. 			 */
name|INSIST
argument_list|(
operator|!
name|ISC_LINK_LINKED
argument_list|(
name|dev
argument_list|,
name|ev_link
argument_list|)
argument_list|)
expr_stmt|;
name|ISC_LIST_ENQUEUE
argument_list|(
name|sock
operator|->
name|send_list
argument_list|,
name|dev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
name|socket_log
argument_list|(
name|__LINE__
argument_list|,
name|sock
argument_list|,
name|NULL
argument_list|,
name|EVENT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"socket_send: event %p -> task %p"
argument_list|,
name|dev
argument_list|,
name|ntask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|ISC_SOCKFLAG_IMMEDIATE
operator|)
operator|!=
literal|0
condition|)
name|result
operator|=
name|ISC_R_INPROGRESS
expr_stmt|;
break|break;
block|}
case|case
name|DOIO_SUCCESS
case|:
break|break;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc__socket_send
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_region_t
modifier|*
name|region
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* 	 * REQUIRE() checking is performed in isc_socket_sendto(). 	 */
return|return
operator|(
name|isc_socket_sendto
argument_list|(
name|sock
argument_list|,
name|region
argument_list|,
name|task
argument_list|,
name|action
argument_list|,
name|arg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc__socket_sendto
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_region_t
modifier|*
name|region
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|address
parameter_list|,
name|struct
name|in6_pktinfo
modifier|*
name|pktinfo
parameter_list|)
block|{
name|isc_socketevent_t
modifier|*
name|dev
decl_stmt|;
name|isc_socketmgr_t
modifier|*
name|manager
decl_stmt|;
name|isc_result_t
name|ret
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sock
operator|->
name|type
operator|!=
name|isc_sockettype_fdwatch
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|CONSISTENT
argument_list|(
name|sock
argument_list|)
expr_stmt|;
comment|/* 	 * make sure that the socket's not closed 	 */
if|if
condition|(
name|sock
operator|->
name|fd
operator|==
name|INVALID_SOCKET
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_CONNREFUSED
operator|)
return|;
block|}
name|REQUIRE
argument_list|(
name|region
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|task
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|action
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|manager
operator|=
name|sock
operator|->
name|manager
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|bound
argument_list|)
expr_stmt|;
name|dev
operator|=
name|allocate_socketevent
argument_list|(
name|sock
argument_list|,
name|ISC_SOCKEVENT_SENDDONE
argument_list|,
name|action
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|dev
operator|->
name|region
operator|=
operator|*
name|region
expr_stmt|;
name|ret
operator|=
name|socket_send
argument_list|(
name|sock
argument_list|,
name|dev
argument_list|,
name|task
argument_list|,
name|address
argument_list|,
name|pktinfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc__socket_sendv
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_bufferlist_t
modifier|*
name|buflist
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
operator|(
name|isc_socket_sendtov
argument_list|(
name|sock
argument_list|,
name|buflist
argument_list|,
name|task
argument_list|,
name|action
argument_list|,
name|arg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc__socket_sendtov
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_bufferlist_t
modifier|*
name|buflist
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|address
parameter_list|,
name|struct
name|in6_pktinfo
modifier|*
name|pktinfo
parameter_list|)
block|{
name|isc_socketevent_t
modifier|*
name|dev
decl_stmt|;
name|isc_socketmgr_t
modifier|*
name|manager
decl_stmt|;
name|unsigned
name|int
name|iocount
decl_stmt|;
name|isc_buffer_t
modifier|*
name|buffer
decl_stmt|;
name|isc_result_t
name|ret
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|CONSISTENT
argument_list|(
name|sock
argument_list|)
expr_stmt|;
comment|/* 	 * make sure that the socket's not closed 	 */
if|if
condition|(
name|sock
operator|->
name|fd
operator|==
name|INVALID_SOCKET
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_CONNREFUSED
operator|)
return|;
block|}
name|REQUIRE
argument_list|(
name|buflist
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
operator|*
name|buflist
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|task
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|action
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|manager
operator|=
name|sock
operator|->
name|manager
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|iocount
operator|=
name|isc_bufferlist_usedcount
argument_list|(
name|buflist
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|iocount
operator|>
literal|0
argument_list|)
expr_stmt|;
name|dev
operator|=
name|allocate_socketevent
argument_list|(
name|sock
argument_list|,
name|ISC_SOCKEVENT_SENDDONE
argument_list|,
name|action
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
comment|/* 	 * Move each buffer from the passed in list to our internal one. 	 */
name|buffer
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|buflist
argument_list|)
expr_stmt|;
while|while
condition|(
name|buffer
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_DEQUEUE
argument_list|(
operator|*
name|buflist
argument_list|,
name|buffer
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_ENQUEUE
argument_list|(
name|dev
operator|->
name|bufferlist
argument_list|,
name|buffer
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|buflist
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|socket_send
argument_list|(
name|sock
argument_list|,
name|dev
argument_list|,
name|task
argument_list|,
name|address
argument_list|,
name|pktinfo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc__socket_sendto2
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_region_t
modifier|*
name|region
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|address
parameter_list|,
name|struct
name|in6_pktinfo
modifier|*
name|pktinfo
parameter_list|,
name|isc_socketevent_t
modifier|*
name|event
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|isc_result_t
name|ret
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|CONSISTENT
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|(
name|flags
operator|&
operator|~
operator|(
name|ISC_SOCKFLAG_IMMEDIATE
operator||
name|ISC_SOCKFLAG_NORETRY
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|ISC_SOCKFLAG_NORETRY
operator|)
operator|!=
literal|0
condition|)
name|REQUIRE
argument_list|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_udp
argument_list|)
expr_stmt|;
name|event
operator|->
name|ev_sender
operator|=
name|sock
expr_stmt|;
name|event
operator|->
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
comment|/* 	 * make sure that the socket's not closed 	 */
if|if
condition|(
name|sock
operator|->
name|fd
operator|==
name|INVALID_SOCKET
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_CONNREFUSED
operator|)
return|;
block|}
name|ISC_LIST_INIT
argument_list|(
name|event
operator|->
name|bufferlist
argument_list|)
expr_stmt|;
name|event
operator|->
name|region
operator|=
operator|*
name|region
expr_stmt|;
name|event
operator|->
name|n
operator|=
literal|0
expr_stmt|;
name|event
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|event
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|socket_send
argument_list|(
name|sock
argument_list|,
name|event
argument_list|,
name|task
argument_list|,
name|address
argument_list|,
name|pktinfo
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc__socket_bind
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|sockaddr
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|)
block|{
name|int
name|bind_errno
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|int
name|on
init|=
literal|1
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|CONSISTENT
argument_list|(
name|sock
argument_list|)
expr_stmt|;
comment|/* 	 * make sure that the socket's not closed 	 */
if|if
condition|(
name|sock
operator|->
name|fd
operator|==
name|INVALID_SOCKET
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_CONNREFUSED
operator|)
return|;
block|}
name|INSIST
argument_list|(
operator|!
name|sock
operator|->
name|bound
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|sock
operator|->
name|dupped
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|pf
operator|!=
name|sockaddr
operator|->
name|type
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAMILYMISMATCH
operator|)
return|;
block|}
comment|/* 	 * Only set SO_REUSEADDR when we want a specific port. 	 */
if|if
condition|(
operator|(
name|options
operator|&
name|ISC_SOCKET_REUSEADDRESS
operator|)
operator|!=
literal|0
operator|&&
name|isc_sockaddr_getport
argument_list|(
name|sockaddr
argument_list|)
operator|!=
operator|(
name|in_port_t
operator|)
literal|0
operator|&&
name|setsockopt
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"setsockopt(%d) %s"
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Press on... */
block|}
if|if
condition|(
name|bind
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
operator|&
name|sockaddr
operator|->
name|type
operator|.
name|sa
argument_list|,
name|sockaddr
operator|->
name|length
argument_list|)
operator|<
literal|0
condition|)
block|{
name|bind_errno
operator|=
name|WSAGetLastError
argument_list|()
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bind_errno
condition|)
block|{
case|case
name|WSAEACCES
case|:
return|return
operator|(
name|ISC_R_NOPERM
operator|)
return|;
case|case
name|WSAEADDRNOTAVAIL
case|:
return|return
operator|(
name|ISC_R_ADDRNOTAVAIL
operator|)
return|;
case|case
name|WSAEADDRINUSE
case|:
return|return
operator|(
name|ISC_R_ADDRINUSE
operator|)
return|;
case|case
name|WSAEINVAL
case|:
return|return
operator|(
name|ISC_R_BOUND
operator|)
return|;
default|default:
name|isc__strerror
argument_list|(
name|bind_errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"bind: %s"
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
block|}
name|socket_log
argument_list|(
name|__LINE__
argument_list|,
name|sock
argument_list|,
name|sockaddr
argument_list|,
name|TRACE
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_BOUND
argument_list|,
literal|"bound"
argument_list|)
expr_stmt|;
name|sock
operator|->
name|bound
operator|=
literal|1
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc__socket_filter
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
specifier|const
name|char
modifier|*
name|filter
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|filter
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set up to listen on a given socket.  We do this by creating an internal  * event that will be dispatched when the socket has read activity.  The  * watcher will send the internal event to the task when there is a new  * connection.  *  * Unlike in read, we don't preallocate a done event here.  Every time there  * is a new connection we'll have to allocate a new one anyway, so we might  * as well keep things simple rather than having to track them.  */
end_comment

begin_function
name|isc_result_t
name|isc__socket_listen
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|unsigned
name|int
name|backlog
parameter_list|)
block|{
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|CONSISTENT
argument_list|(
name|sock
argument_list|)
expr_stmt|;
comment|/* 	 * make sure that the socket's not closed 	 */
if|if
condition|(
name|sock
operator|->
name|fd
operator|==
name|INVALID_SOCKET
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_CONNREFUSED
operator|)
return|;
block|}
name|REQUIRE
argument_list|(
operator|!
name|sock
operator|->
name|listener
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sock
operator|->
name|bound
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_tcp
argument_list|)
expr_stmt|;
if|if
condition|(
name|backlog
operator|==
literal|0
condition|)
name|backlog
operator|=
name|SOMAXCONN
expr_stmt|;
if|if
condition|(
name|listen
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
operator|(
name|int
operator|)
name|backlog
argument_list|)
operator|<
literal|0
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isc__strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"listen: %s"
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
name|socket_log
argument_list|(
name|__LINE__
argument_list|,
name|sock
argument_list|,
name|NULL
argument_list|,
name|TRACE
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_BOUND
argument_list|,
literal|"listening"
argument_list|)
expr_stmt|;
name|sock
operator|->
name|listener
operator|=
literal|1
expr_stmt|;
name|_set_state
argument_list|(
name|sock
argument_list|,
name|SOCK_LISTEN
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This should try to do aggressive accept() XXXMLG  */
end_comment

begin_function
name|isc_result_t
name|isc__socket_accept
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|isc_socket_newconnev_t
modifier|*
name|adev
decl_stmt|;
name|isc_socketmgr_t
modifier|*
name|manager
decl_stmt|;
name|isc_task_t
modifier|*
name|ntask
init|=
name|NULL
decl_stmt|;
name|isc_socket_t
modifier|*
name|nsock
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|IoCompletionInfo
modifier|*
name|lpo
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|manager
operator|=
name|sock
operator|->
name|manager
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|CONSISTENT
argument_list|(
name|sock
argument_list|)
expr_stmt|;
comment|/* 	 * make sure that the socket's not closed 	 */
if|if
condition|(
name|sock
operator|->
name|fd
operator|==
name|INVALID_SOCKET
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_CONNREFUSED
operator|)
return|;
block|}
name|REQUIRE
argument_list|(
name|sock
operator|->
name|listener
argument_list|)
expr_stmt|;
comment|/* 	 * Sender field is overloaded here with the task we will be sending 	 * this event to.  Just before the actual event is delivered the 	 * actual ev_sender will be touched up to be the socket. 	 */
name|adev
operator|=
operator|(
name|isc_socket_newconnev_t
operator|*
operator|)
name|isc_event_allocate
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|task
argument_list|,
name|ISC_SOCKEVENT_NEWCONN
argument_list|,
name|action
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|adev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|adev
operator|==
name|NULL
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|ISC_LINK_INIT
argument_list|(
name|adev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
name|result
operator|=
name|allocate_socket
argument_list|(
name|manager
argument_list|,
name|sock
operator|->
name|type
argument_list|,
operator|&
name|nsock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_event_free
argument_list|(
operator|(
name|isc_event_t
operator|*
operator|*
operator|)
operator|&
name|adev
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
comment|/* 	 * AcceptEx() requires we pass in a socket. 	 */
name|nsock
operator|->
name|fd
operator|=
name|socket
argument_list|(
name|sock
operator|->
name|pf
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsock
operator|->
name|fd
operator|==
name|INVALID_SOCKET
condition|)
block|{
name|free_socket
argument_list|(
operator|&
name|nsock
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
operator|(
name|isc_event_t
operator|*
operator|*
operator|)
operator|&
name|adev
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
comment|// XXXMLG need real error message
block|}
comment|/* 	 * Attach to socket and to task. 	 */
name|isc_task_attach
argument_list|(
name|task
argument_list|,
operator|&
name|ntask
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_task_exiting
argument_list|(
name|ntask
argument_list|)
condition|)
block|{
name|free_socket
argument_list|(
operator|&
name|nsock
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|isc_task_detach
argument_list|(
operator|&
name|ntask
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
name|ISC_EVENT_PTR
argument_list|(
operator|&
name|adev
argument_list|)
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SHUTTINGDOWN
operator|)
return|;
block|}
name|nsock
operator|->
name|references
operator|++
expr_stmt|;
name|adev
operator|->
name|ev_sender
operator|=
name|ntask
expr_stmt|;
name|adev
operator|->
name|newsocket
operator|=
name|nsock
expr_stmt|;
name|_set_state
argument_list|(
name|nsock
argument_list|,
name|SOCK_ACCEPT
argument_list|)
expr_stmt|;
comment|/* 	 * Queue io completion for an accept(). 	 */
name|lpo
operator|=
operator|(
name|IoCompletionInfo
operator|*
operator|)
name|HeapAlloc
argument_list|(
name|hHeapHandle
argument_list|,
name|HEAP_ZERO_MEMORY
argument_list|,
sizeof|sizeof
argument_list|(
name|IoCompletionInfo
argument_list|)
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|lpo
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|lpo
operator|->
name|acceptbuffer
operator|=
operator|(
name|void
operator|*
operator|)
name|HeapAlloc
argument_list|(
name|hHeapHandle
argument_list|,
name|HEAP_ZERO_MEMORY
argument_list|,
operator|(
sizeof|sizeof
argument_list|(
name|SOCKADDR_STORAGE
argument_list|)
operator|+
literal|16
operator|)
operator|*
literal|2
argument_list|)
expr_stmt|;
name|RUNTIME_CHECK
argument_list|(
name|lpo
operator|->
name|acceptbuffer
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|lpo
operator|->
name|adev
operator|=
name|adev
expr_stmt|;
name|lpo
operator|->
name|request_type
operator|=
name|SOCKET_ACCEPT
expr_stmt|;
name|ISCAcceptEx
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|nsock
operator|->
name|fd
argument_list|,
comment|/* Accepted Socket */
name|lpo
operator|->
name|acceptbuffer
argument_list|,
comment|/* Buffer for initial Recv */
literal|0
argument_list|,
comment|/* Length of Buffer */
sizeof|sizeof
argument_list|(
name|SOCKADDR_STORAGE
argument_list|)
operator|+
literal|16
argument_list|,
comment|/* Local address length + 16 */
sizeof|sizeof
argument_list|(
name|SOCKADDR_STORAGE
argument_list|)
operator|+
literal|16
argument_list|,
comment|/* Remote address lengh + 16 */
operator|(
name|LPDWORD
operator|)
operator|&
name|lpo
operator|->
name|received_bytes
argument_list|,
comment|/* Bytes Recved */
operator|(
name|LPOVERLAPPED
operator|)
name|lpo
comment|/* Overlapped structure */
argument_list|)
expr_stmt|;
name|iocompletionport_update
argument_list|(
name|nsock
argument_list|)
expr_stmt|;
name|socket_log
argument_list|(
name|__LINE__
argument_list|,
name|sock
argument_list|,
name|NULL
argument_list|,
name|TRACE
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_BOUND
argument_list|,
literal|"accepting for nsock %p fd %d"
argument_list|,
name|nsock
argument_list|,
name|nsock
operator|->
name|fd
argument_list|)
expr_stmt|;
comment|/* 	 * Enqueue the event 	 */
name|ISC_LIST_ENQUEUE
argument_list|(
name|sock
operator|->
name|accept_list
argument_list|,
name|adev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
name|sock
operator|->
name|pending_accept
operator|++
expr_stmt|;
name|sock
operator|->
name|pending_iocp
operator|++
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc__socket_connect
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|addr
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|isc_socket_connev_t
modifier|*
name|cdev
decl_stmt|;
name|isc_task_t
modifier|*
name|ntask
init|=
name|NULL
decl_stmt|;
name|isc_socketmgr_t
modifier|*
name|manager
decl_stmt|;
name|IoCompletionInfo
modifier|*
name|lpo
decl_stmt|;
name|int
name|bind_errno
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|addr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|task
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|action
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|manager
operator|=
name|sock
operator|->
name|manager
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|addr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_sockaddr_ismulticast
argument_list|(
name|addr
argument_list|)
condition|)
return|return
operator|(
name|ISC_R_MULTICAST
operator|)
return|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|CONSISTENT
argument_list|(
name|sock
argument_list|)
expr_stmt|;
comment|/* 	 * make sure that the socket's not closed 	 */
if|if
condition|(
name|sock
operator|->
name|fd
operator|==
name|INVALID_SOCKET
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_CONNREFUSED
operator|)
return|;
block|}
comment|/* 	 * Windows sockets won't connect unless the socket is bound. 	 */
if|if
condition|(
operator|!
name|sock
operator|->
name|bound
condition|)
block|{
name|isc_sockaddr_t
name|any
decl_stmt|;
name|isc_sockaddr_anyofpf
argument_list|(
operator|&
name|any
argument_list|,
name|isc_sockaddr_pf
argument_list|(
name|addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
operator|&
name|any
operator|.
name|type
operator|.
name|sa
argument_list|,
name|any
operator|.
name|length
argument_list|)
operator|<
literal|0
condition|)
block|{
name|bind_errno
operator|=
name|WSAGetLastError
argument_list|()
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bind_errno
condition|)
block|{
case|case
name|WSAEACCES
case|:
return|return
operator|(
name|ISC_R_NOPERM
operator|)
return|;
case|case
name|WSAEADDRNOTAVAIL
case|:
return|return
operator|(
name|ISC_R_ADDRNOTAVAIL
operator|)
return|;
case|case
name|WSAEADDRINUSE
case|:
return|return
operator|(
name|ISC_R_ADDRINUSE
operator|)
return|;
case|case
name|WSAEINVAL
case|:
return|return
operator|(
name|ISC_R_BOUND
operator|)
return|;
default|default:
name|isc__strerror
argument_list|(
name|bind_errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"bind: %s"
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
block|}
name|sock
operator|->
name|bound
operator|=
literal|1
expr_stmt|;
block|}
name|REQUIRE
argument_list|(
operator|!
name|sock
operator|->
name|pending_connect
argument_list|)
expr_stmt|;
name|cdev
operator|=
operator|(
name|isc_socket_connev_t
operator|*
operator|)
name|isc_event_allocate
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|sock
argument_list|,
name|ISC_SOCKEVENT_CONNECT
argument_list|,
name|action
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cdev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdev
operator|==
name|NULL
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|ISC_LINK_INIT
argument_list|(
name|cdev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_tcp
condition|)
block|{
comment|/* 		 * Queue io completion for an accept(). 		 */
name|lpo
operator|=
operator|(
name|IoCompletionInfo
operator|*
operator|)
name|HeapAlloc
argument_list|(
name|hHeapHandle
argument_list|,
name|HEAP_ZERO_MEMORY
argument_list|,
sizeof|sizeof
argument_list|(
name|IoCompletionInfo
argument_list|)
argument_list|)
expr_stmt|;
name|lpo
operator|->
name|cdev
operator|=
name|cdev
expr_stmt|;
name|lpo
operator|->
name|request_type
operator|=
name|SOCKET_CONNECT
expr_stmt|;
name|sock
operator|->
name|address
operator|=
operator|*
name|addr
expr_stmt|;
name|ISCConnectEx
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
operator|&
name|addr
operator|->
name|type
operator|.
name|sa
argument_list|,
name|addr
operator|->
name|length
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
operator|(
name|LPOVERLAPPED
operator|)
name|lpo
argument_list|)
expr_stmt|;
comment|/* 		 * Attach to task. 		 */
name|isc_task_attach
argument_list|(
name|task
argument_list|,
operator|&
name|ntask
argument_list|)
expr_stmt|;
name|cdev
operator|->
name|ev_sender
operator|=
name|ntask
expr_stmt|;
name|sock
operator|->
name|pending_connect
operator|=
literal|1
expr_stmt|;
name|_set_state
argument_list|(
name|sock
argument_list|,
name|SOCK_CONNECT
argument_list|)
expr_stmt|;
comment|/* 		 * Enqueue the request. 		 */
name|sock
operator|->
name|connect_ev
operator|=
name|cdev
expr_stmt|;
name|sock
operator|->
name|pending_iocp
operator|++
expr_stmt|;
block|}
else|else
block|{
name|WSAConnect
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
operator|&
name|addr
operator|->
name|type
operator|.
name|sa
argument_list|,
name|addr
operator|->
name|length
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cdev
operator|->
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|isc_task_send
argument_list|(
name|task
argument_list|,
operator|(
name|isc_event_t
operator|*
operator|*
operator|)
operator|&
name|cdev
argument_list|)
expr_stmt|;
block|}
name|CONSISTENT
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc__socket_getpeername
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|addressp
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|addressp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|CONSISTENT
argument_list|(
name|sock
argument_list|)
expr_stmt|;
comment|/* 	 * make sure that the socket's not closed 	 */
if|if
condition|(
name|sock
operator|->
name|fd
operator|==
name|INVALID_SOCKET
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_CONNREFUSED
operator|)
return|;
block|}
if|if
condition|(
name|sock
operator|->
name|connected
condition|)
block|{
operator|*
name|addressp
operator|=
name|sock
operator|->
name|address
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|ISC_R_NOTCONNECTED
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc__socket_getsockname
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|addressp
parameter_list|)
block|{
name|ISC_SOCKADDR_LEN_T
name|len
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|addressp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|CONSISTENT
argument_list|(
name|sock
argument_list|)
expr_stmt|;
comment|/* 	 * make sure that the socket's not closed 	 */
if|if
condition|(
name|sock
operator|->
name|fd
operator|==
name|INVALID_SOCKET
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_CONNREFUSED
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|sock
operator|->
name|bound
condition|)
block|{
name|result
operator|=
name|ISC_R_NOTBOUND
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|addressp
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
operator|&
name|addressp
operator|->
name|type
operator|.
name|sa
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|isc__strerror
argument_list|(
name|WSAGetLastError
argument_list|()
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"getsockname: %s"
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|addressp
operator|->
name|length
operator|=
operator|(
name|unsigned
name|int
operator|)
name|len
expr_stmt|;
name|out
label|:
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Run through the list of events on this socket, and cancel the ones  * queued for task "task" of type "how".  "how" is a bitmask.  */
end_comment

begin_function
name|void
name|isc__socket_cancel
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|unsigned
name|int
name|how
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Quick exit if there is nothing to do.  Don't even bother locking 	 * in this case. 	 */
if|if
condition|(
name|how
operator|==
literal|0
condition|)
return|return;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|CONSISTENT
argument_list|(
name|sock
argument_list|)
expr_stmt|;
comment|/* 	 * make sure that the socket's not closed 	 */
if|if
condition|(
name|sock
operator|->
name|fd
operator|==
name|INVALID_SOCKET
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * All of these do the same thing, more or less. 	 * Each will: 	 *	o If the internal event is marked as "posted" try to 	 *	  remove it from the task's queue.  If this fails, mark it 	 *	  as canceled instead, and let the task clean it up later. 	 *	o For each I/O request for that task of that type, post 	 *	  its done event with status of "ISC_R_CANCELED". 	 *	o Reset any state needed. 	 */
if|if
condition|(
operator|(
name|how
operator|&
name|ISC_SOCKCANCEL_RECV
operator|)
operator|==
name|ISC_SOCKCANCEL_RECV
condition|)
block|{
name|isc_socketevent_t
modifier|*
name|dev
decl_stmt|;
name|isc_socketevent_t
modifier|*
name|next
decl_stmt|;
name|isc_task_t
modifier|*
name|current_task
decl_stmt|;
name|dev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|dev
operator|!=
name|NULL
condition|)
block|{
name|current_task
operator|=
name|dev
operator|->
name|ev_sender
expr_stmt|;
name|next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|dev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|task
operator|==
name|NULL
operator|)
operator|||
operator|(
name|task
operator|==
name|current_task
operator|)
condition|)
block|{
name|dev
operator|->
name|result
operator|=
name|ISC_R_CANCELED
expr_stmt|;
name|send_recvdone_event
argument_list|(
name|sock
argument_list|,
operator|&
name|dev
argument_list|)
expr_stmt|;
block|}
name|dev
operator|=
name|next
expr_stmt|;
block|}
block|}
name|how
operator|&=
operator|~
name|ISC_SOCKCANCEL_RECV
expr_stmt|;
if|if
condition|(
operator|(
name|how
operator|&
name|ISC_SOCKCANCEL_SEND
operator|)
operator|==
name|ISC_SOCKCANCEL_SEND
condition|)
block|{
name|isc_socketevent_t
modifier|*
name|dev
decl_stmt|;
name|isc_socketevent_t
modifier|*
name|next
decl_stmt|;
name|isc_task_t
modifier|*
name|current_task
decl_stmt|;
name|dev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sock
operator|->
name|send_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|dev
operator|!=
name|NULL
condition|)
block|{
name|current_task
operator|=
name|dev
operator|->
name|ev_sender
expr_stmt|;
name|next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|dev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|task
operator|==
name|NULL
operator|)
operator|||
operator|(
name|task
operator|==
name|current_task
operator|)
condition|)
block|{
name|dev
operator|->
name|result
operator|=
name|ISC_R_CANCELED
expr_stmt|;
name|send_senddone_event
argument_list|(
name|sock
argument_list|,
operator|&
name|dev
argument_list|)
expr_stmt|;
block|}
name|dev
operator|=
name|next
expr_stmt|;
block|}
block|}
name|how
operator|&=
operator|~
name|ISC_SOCKCANCEL_SEND
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|how
operator|&
name|ISC_SOCKCANCEL_ACCEPT
operator|)
operator|==
name|ISC_SOCKCANCEL_ACCEPT
operator|)
operator|&&
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|accept_list
argument_list|)
condition|)
block|{
name|isc_socket_newconnev_t
modifier|*
name|dev
decl_stmt|;
name|isc_socket_newconnev_t
modifier|*
name|next
decl_stmt|;
name|isc_task_t
modifier|*
name|current_task
decl_stmt|;
name|dev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sock
operator|->
name|accept_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|dev
operator|!=
name|NULL
condition|)
block|{
name|current_task
operator|=
name|dev
operator|->
name|ev_sender
expr_stmt|;
name|next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|dev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|task
operator|==
name|NULL
operator|)
operator|||
operator|(
name|task
operator|==
name|current_task
operator|)
condition|)
block|{
name|dev
operator|->
name|newsocket
operator|->
name|references
operator|--
expr_stmt|;
name|closesocket
argument_list|(
name|dev
operator|->
name|newsocket
operator|->
name|fd
argument_list|)
expr_stmt|;
name|dev
operator|->
name|newsocket
operator|->
name|fd
operator|=
name|INVALID_SOCKET
expr_stmt|;
name|free_socket
argument_list|(
operator|&
name|dev
operator|->
name|newsocket
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
name|dev
operator|->
name|result
operator|=
name|ISC_R_CANCELED
expr_stmt|;
name|send_acceptdone_event
argument_list|(
name|sock
argument_list|,
operator|&
name|dev
argument_list|)
expr_stmt|;
block|}
name|dev
operator|=
name|next
expr_stmt|;
block|}
block|}
name|how
operator|&=
operator|~
name|ISC_SOCKCANCEL_ACCEPT
expr_stmt|;
comment|/* 	 * Connecting is not a list. 	 */
if|if
condition|(
operator|(
operator|(
name|how
operator|&
name|ISC_SOCKCANCEL_CONNECT
operator|)
operator|==
name|ISC_SOCKCANCEL_CONNECT
operator|)
operator|&&
name|sock
operator|->
name|connect_ev
operator|!=
name|NULL
condition|)
block|{
name|isc_socket_connev_t
modifier|*
name|dev
decl_stmt|;
name|isc_task_t
modifier|*
name|current_task
decl_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|pending_connect
argument_list|)
expr_stmt|;
name|dev
operator|=
name|sock
operator|->
name|connect_ev
expr_stmt|;
name|current_task
operator|=
name|dev
operator|->
name|ev_sender
expr_stmt|;
if|if
condition|(
operator|(
name|task
operator|==
name|NULL
operator|)
operator|||
operator|(
name|task
operator|==
name|current_task
operator|)
condition|)
block|{
name|closesocket
argument_list|(
name|sock
operator|->
name|fd
argument_list|)
expr_stmt|;
name|sock
operator|->
name|fd
operator|=
name|INVALID_SOCKET
expr_stmt|;
name|_set_state
argument_list|(
name|sock
argument_list|,
name|SOCK_CLOSED
argument_list|)
expr_stmt|;
name|sock
operator|->
name|connect_ev
operator|=
name|NULL
expr_stmt|;
name|dev
operator|->
name|result
operator|=
name|ISC_R_CANCELED
expr_stmt|;
name|send_connectdone_event
argument_list|(
name|sock
argument_list|,
operator|&
name|dev
argument_list|)
expr_stmt|;
block|}
block|}
name|how
operator|&=
operator|~
name|ISC_SOCKCANCEL_CONNECT
expr_stmt|;
name|maybe_free_socket
argument_list|(
operator|&
name|sock
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_sockettype_t
name|isc__socket_gettype
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|)
block|{
name|isc_sockettype_t
name|type
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * make sure that the socket's not closed 	 */
if|if
condition|(
name|sock
operator|->
name|fd
operator|==
name|INVALID_SOCKET
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_CONNREFUSED
operator|)
return|;
block|}
name|type
operator|=
name|sock
operator|->
name|type
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|type
operator|)
return|;
block|}
end_function

begin_function
name|isc_boolean_t
name|isc__socket_isbound
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|)
block|{
name|isc_boolean_t
name|val
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|CONSISTENT
argument_list|(
name|sock
argument_list|)
expr_stmt|;
comment|/* 	 * make sure that the socket's not closed 	 */
if|if
condition|(
name|sock
operator|->
name|fd
operator|==
name|INVALID_SOCKET
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
name|val
operator|=
operator|(
operator|(
name|sock
operator|->
name|bound
operator|)
condition|?
name|ISC_TRUE
else|:
name|ISC_FALSE
operator|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc__socket_ipv6only
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_boolean_t
name|yes
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|IPV6_V6ONLY
argument_list|)
name|int
name|onoff
init|=
name|yes
condition|?
literal|1
else|:
literal|0
decl_stmt|;
else|#
directive|else
name|UNUSED
argument_list|(
name|yes
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPV6_V6ONLY
if|if
condition|(
name|sock
operator|->
name|pf
operator|==
name|AF_INET6
condition|)
block|{
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_V6ONLY
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|onoff
argument_list|,
sizeof|sizeof
argument_list|(
name|onoff
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|isc__socket_cleanunix
parameter_list|(
name|isc_sockaddr_t
modifier|*
name|addr
parameter_list|,
name|isc_boolean_t
name|active
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|active
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|isc_result_t
name|isc__socket_permunix
parameter_list|(
name|isc_sockaddr_t
modifier|*
name|addr
parameter_list|,
name|isc_uint32_t
name|perm
parameter_list|,
name|isc_uint32_t
name|owner
parameter_list|,
name|isc_uint32_t
name|group
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|perm
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|owner
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|group
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc__socket_setname
parameter_list|(
name|isc_socket_t
modifier|*
name|socket
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
comment|/* 	 * Name 'socket'. 	 */
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|socket
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|socket
operator|->
name|lock
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|socket
operator|->
name|name
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|socket
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|socket
operator|->
name|name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|socket
operator|->
name|name
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|socket
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|socket
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|isc__socket_getname
parameter_list|(
name|isc_socket_t
modifier|*
name|socket
parameter_list|)
block|{
return|return
operator|(
name|socket
operator|->
name|name
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|isc__socket_gettag
parameter_list|(
name|isc_socket_t
modifier|*
name|socket
parameter_list|)
block|{
return|return
operator|(
name|socket
operator|->
name|tag
operator|)
return|;
block|}
end_function

begin_function
name|int
name|isc__socket_getfd
parameter_list|(
name|isc_socket_t
modifier|*
name|socket
parameter_list|)
block|{
return|return
operator|(
operator|(
name|short
operator|)
name|socket
operator|->
name|fd
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc__socketmgr_setreserved
parameter_list|(
name|isc_socketmgr_t
modifier|*
name|manager
parameter_list|,
name|isc_uint32_t
name|reserved
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|manager
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|reserved
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isc___socketmgr_maxudp
parameter_list|(
name|isc_socketmgr_t
modifier|*
name|manager
parameter_list|,
name|int
name|maxudp
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|manager
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|maxudp
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIBXML2
end_ifdef

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|_socktype
parameter_list|(
name|isc_sockettype_t
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|isc_sockettype_udp
condition|)
return|return
operator|(
literal|"udp"
operator|)
return|;
elseif|else
if|if
condition|(
name|type
operator|==
name|isc_sockettype_tcp
condition|)
return|return
operator|(
literal|"tcp"
operator|)
return|;
elseif|else
if|if
condition|(
name|type
operator|==
name|isc_sockettype_unix
condition|)
return|return
operator|(
literal|"unix"
operator|)
return|;
elseif|else
if|if
condition|(
name|type
operator|==
name|isc_sockettype_fdwatch
condition|)
return|return
operator|(
literal|"fdwatch"
operator|)
return|;
else|else
return|return
operator|(
literal|"not-initialized"
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc_socketmgr_renderxml
parameter_list|(
name|isc_socketmgr_t
modifier|*
name|mgr
parameter_list|,
name|xmlTextWriterPtr
name|writer
parameter_list|)
block|{
name|isc_socket_t
modifier|*
name|sock
decl_stmt|;
name|char
name|peerbuf
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
name|isc_sockaddr_t
name|addr
decl_stmt|;
name|ISC_SOCKADDR_LEN_T
name|len
decl_stmt|;
name|LOCK
argument_list|(
operator|&
name|mgr
operator|->
name|lock
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ISC_PLATFORM_USETHREADS
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"references"
argument_list|)
expr_stmt|;
name|xmlTextWriterWriteFormatString
argument_list|(
name|writer
argument_list|,
literal|"%d"
argument_list|,
name|mgr
operator|->
name|refs
argument_list|)
expr_stmt|;
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"sockets"
argument_list|)
expr_stmt|;
name|sock
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|mgr
operator|->
name|socklist
argument_list|)
expr_stmt|;
while|while
condition|(
name|sock
operator|!=
name|NULL
condition|)
block|{
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"socket"
argument_list|)
expr_stmt|;
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"id"
argument_list|)
expr_stmt|;
name|xmlTextWriterWriteFormatString
argument_list|(
name|writer
argument_list|,
literal|"%p"
argument_list|,
name|sock
argument_list|)
expr_stmt|;
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"name"
argument_list|)
expr_stmt|;
name|xmlTextWriterWriteFormatString
argument_list|(
name|writer
argument_list|,
literal|"%s"
argument_list|,
name|sock
operator|->
name|name
argument_list|)
expr_stmt|;
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
expr_stmt|;
comment|/* name */
block|}
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"references"
argument_list|)
expr_stmt|;
name|xmlTextWriterWriteFormatString
argument_list|(
name|writer
argument_list|,
literal|"%d"
argument_list|,
name|sock
operator|->
name|references
argument_list|)
expr_stmt|;
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
expr_stmt|;
name|xmlTextWriterWriteElement
argument_list|(
argument|writer
argument_list|,
argument|ISC_XMLCHAR
literal|"type"
argument_list|,
argument|ISC_XMLCHAR _socktype(sock->type)
argument_list|)
empty_stmt|;
if|if
condition|(
name|sock
operator|->
name|connected
condition|)
block|{
name|isc_sockaddr_format
argument_list|(
operator|&
name|sock
operator|->
name|address
argument_list|,
name|peerbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|peerbuf
argument_list|)
argument_list|)
expr_stmt|;
name|xmlTextWriterWriteElement
argument_list|(
argument|writer
argument_list|,
argument|ISC_XMLCHAR
literal|"peer-address"
argument_list|,
argument|ISC_XMLCHAR peerbuf
argument_list|)
empty_stmt|;
block|}
name|len
operator|=
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
operator|&
name|addr
operator|.
name|type
operator|.
name|sa
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|isc_sockaddr_format
argument_list|(
operator|&
name|addr
argument_list|,
name|peerbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|peerbuf
argument_list|)
argument_list|)
expr_stmt|;
name|xmlTextWriterWriteElement
argument_list|(
argument|writer
argument_list|,
argument|ISC_XMLCHAR
literal|"local-address"
argument_list|,
argument|ISC_XMLCHAR peerbuf
argument_list|)
empty_stmt|;
block|}
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"states"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|pending_recv
condition|)
name|xmlTextWriterWriteElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"state"
argument_list|,
name|ISC_XMLCHAR
literal|"pending-receive"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|pending_send
condition|)
name|xmlTextWriterWriteElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"state"
argument_list|,
name|ISC_XMLCHAR
literal|"pending-send"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|pending_accept
condition|)
name|xmlTextWriterWriteElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"state"
argument_list|,
name|ISC_XMLCHAR
literal|"pending_accept"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|listener
condition|)
name|xmlTextWriterWriteElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"state"
argument_list|,
name|ISC_XMLCHAR
literal|"listener"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|connected
condition|)
name|xmlTextWriterWriteElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"state"
argument_list|,
name|ISC_XMLCHAR
literal|"connected"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|pending_connect
condition|)
name|xmlTextWriterWriteElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"state"
argument_list|,
name|ISC_XMLCHAR
literal|"connecting"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|bound
condition|)
name|xmlTextWriterWriteElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"state"
argument_list|,
name|ISC_XMLCHAR
literal|"bound"
argument_list|)
expr_stmt|;
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
expr_stmt|;
comment|/* states */
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
expr_stmt|;
comment|/* socket */
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|sock
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|sock
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
expr_stmt|;
comment|/* sockets */
name|UNLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_LIBXML2 */
end_comment

end_unit

