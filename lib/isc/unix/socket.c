begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2004-2011  Internet Systems Consortium, Inc. ("ISC")  * Copyright (C) 1998-2003  Internet Software Consortium.  *  * Permission to use, copy, modify, and/or distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND ISC DISCLAIMS ALL WARRANTIES WITH  * REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY  * AND FITNESS.  IN NO EVENT SHALL ISC BE LIABLE FOR ANY SPECIAL, DIRECT,  * INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM  * LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE  * OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR  * PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/* $Id: socket.c,v 1.333.14.9 2011-07-29 02:19:20 marka Exp $ */
end_comment

begin_comment
comment|/*! \file */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<isc/buffer.h>
end_include

begin_include
include|#
directive|include
file|<isc/bufferlist.h>
end_include

begin_include
include|#
directive|include
file|<isc/condition.h>
end_include

begin_include
include|#
directive|include
file|<isc/formatcheck.h>
end_include

begin_include
include|#
directive|include
file|<isc/list.h>
end_include

begin_include
include|#
directive|include
file|<isc/log.h>
end_include

begin_include
include|#
directive|include
file|<isc/mem.h>
end_include

begin_include
include|#
directive|include
file|<isc/msgs.h>
end_include

begin_include
include|#
directive|include
file|<isc/mutex.h>
end_include

begin_include
include|#
directive|include
file|<isc/net.h>
end_include

begin_include
include|#
directive|include
file|<isc/once.h>
end_include

begin_include
include|#
directive|include
file|<isc/platform.h>
end_include

begin_include
include|#
directive|include
file|<isc/print.h>
end_include

begin_include
include|#
directive|include
file|<isc/region.h>
end_include

begin_include
include|#
directive|include
file|<isc/socket.h>
end_include

begin_include
include|#
directive|include
file|<isc/stats.h>
end_include

begin_include
include|#
directive|include
file|<isc/strerror.h>
end_include

begin_include
include|#
directive|include
file|<isc/task.h>
end_include

begin_include
include|#
directive|include
file|<isc/thread.h>
end_include

begin_include
include|#
directive|include
file|<isc/util.h>
end_include

begin_include
include|#
directive|include
file|<isc/xml.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ISC_PLATFORM_HAVESYSUNH
end_ifdef

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ISC_PLATFORM_HAVEKQUEUE
end_ifdef

begin_include
include|#
directive|include
file|<sys/event.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ISC_PLATFORM_HAVEEPOLL
end_ifdef

begin_include
include|#
directive|include
file|<sys/epoll.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|ISC_PLATFORM_HAVEDEVPOLL
end_ifdef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_SYS_DEVPOLL_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/devpoll.h>
end_include

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_DEVPOLL_H
argument_list|)
end_elif

begin_include
include|#
directive|include
file|<devpoll.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"errno2result.h"
end_include

begin_comment
comment|/* See task.c about the following definition: */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BIND9
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
end_ifdef

begin_define
define|#
directive|define
name|USE_WATCHER_THREAD
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|USE_SHARED_MANAGER
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISC_PLATFORM_USETHREADS */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BIND9 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|USE_WATCHER_THREAD
end_ifndef

begin_include
include|#
directive|include
file|"socket_p.h"
end_include

begin_include
include|#
directive|include
file|"../task_p.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_WATCHER_THREAD */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SO_BSDCOMPAT
argument_list|)
operator|&&
name|defined
argument_list|(
name|__linux__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*%  * Choose the most preferable multiplex method.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ISC_PLATFORM_HAVEKQUEUE
end_ifdef

begin_define
define|#
directive|define
name|USE_KQUEUE
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|ISC_PLATFORM_HAVEEPOLL
argument_list|)
end_elif

begin_define
define|#
directive|define
name|USE_EPOLL
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|ISC_PLATFORM_HAVEDEVPOLL
argument_list|)
end_elif

begin_define
define|#
directive|define
name|USE_DEVPOLL
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|int
name|want_read
range|:
literal|1
decl_stmt|,
name|want_write
range|:
literal|1
decl_stmt|;
block|}
name|pollinfo_t
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|USE_SELECT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISC_PLATFORM_HAVEKQUEUE */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|USE_WATCHER_THREAD
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_KQUEUE
argument_list|)
operator|||
name|defined
argument_list|(
name|USE_EPOLL
argument_list|)
operator|||
name|defined
argument_list|(
name|USE_DEVPOLL
argument_list|)
end_if

begin_struct
struct|struct
name|isc_socketwait
block|{
name|int
name|nevents
decl_stmt|;
block|}
struct|;
end_struct

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|USE_SELECT
argument_list|)
end_elif

begin_struct
struct|struct
name|isc_socketwait
block|{
name|fd_set
modifier|*
name|readset
decl_stmt|;
name|fd_set
modifier|*
name|writeset
decl_stmt|;
name|int
name|nfds
decl_stmt|;
name|int
name|maxfd
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_KQUEUE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !USE_WATCHER_THREAD */
end_comment

begin_comment
comment|/*%  * Maximum number of allowable open sockets.  This is also the maximum  * allowable socket file descriptor.  *  * Care should be taken before modifying this value for select():  * The API standard doesn't ensure select() accept more than (the system default  * of) FD_SETSIZE descriptors, and the default size should in fact be fine in  * the vast majority of cases.  This constant should therefore be increased only  * when absolutely necessary and possible, i.e., the server is exhausting all  * available file descriptors (up to FD_SETSIZE) and the select() function  * and FD_xxx macros support larger values than FD_SETSIZE (which may not  * always by true, but we keep using some of them to ensure as much  * portability as possible).  Note also that overall server performance  * may be rather worsened with a larger value of this constant due to  * inherent scalability problems of select().  *  * As a special note, this value shouldn't have to be touched if  * this is a build for an authoritative only DNS server.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ISC_SOCKET_MAXSOCKETS
end_ifndef

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_KQUEUE
argument_list|)
operator|||
name|defined
argument_list|(
name|USE_EPOLL
argument_list|)
operator|||
name|defined
argument_list|(
name|USE_DEVPOLL
argument_list|)
end_if

begin_define
define|#
directive|define
name|ISC_SOCKET_MAXSOCKETS
value|4096
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|USE_SELECT
argument_list|)
end_elif

begin_define
define|#
directive|define
name|ISC_SOCKET_MAXSOCKETS
value|FD_SETSIZE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_KQUEUE... */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISC_SOCKET_MAXSOCKETS */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_SELECT
end_ifdef

begin_comment
comment|/*%  * Mac OS X needs a special definition to support larger values in select().  * We always define this because a larger value can be specified run-time.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__APPLE__
end_ifdef

begin_define
define|#
directive|define
name|_DARWIN_UNLIMITED_SELECT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __APPLE__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_SELECT */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ISC_SOCKET_USE_POLLWATCH
end_ifdef

begin_comment
comment|/*%  * If this macro is defined, enable workaround for a Solaris /dev/poll kernel  * bug: DP_POLL ioctl could keep sleeping even if socket I/O is possible for  * some of the specified FD.  The idea is based on the observation that it's  * likely for a busy server to keep receiving packets.  It specifically works  * as follows: the socket watcher is first initialized with the state of  * "poll_idle".  While it's in the idle state it keeps sleeping until a socket  * event occurs.  When it wakes up for a socket I/O event, it moves to the  * poll_active state, and sets the poll timeout to a short period  * (ISC_SOCKET_POLLWATCH_TIMEOUT msec).  If timeout occurs in this state, the  * watcher goes to the poll_checking state with the same timeout period.  * In this state, the watcher tries to detect whether this is a break  * during intermittent events or the kernel bug is triggered.  If the next  * polling reports an event within the short period, the previous timeout is  * likely to be a kernel bug, and so the watcher goes back to the active state.  * Otherwise, it moves to the idle state again.  *  * It's not clear whether this is a thread-related bug, but since we've only  * seen this with threads, this workaround is used only when enabling threads.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|poll_idle
block|,
name|poll_active
block|,
name|poll_checking
block|}
name|pollstate_t
typedef|;
end_typedef

begin_ifndef
ifndef|#
directive|ifndef
name|ISC_SOCKET_POLLWATCH_TIMEOUT
end_ifndef

begin_define
define|#
directive|define
name|ISC_SOCKET_POLLWATCH_TIMEOUT
value|10
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISC_SOCKET_POLLWATCH_TIMEOUT */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISC_SOCKET_USE_POLLWATCH */
end_comment

begin_comment
comment|/*%  * Size of per-FD lock buckets.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
end_ifdef

begin_define
define|#
directive|define
name|FDLOCK_COUNT
value|1024
end_define

begin_define
define|#
directive|define
name|FDLOCK_ID
parameter_list|(
name|fd
parameter_list|)
value|((fd) % FDLOCK_COUNT)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FDLOCK_COUNT
value|1
end_define

begin_define
define|#
directive|define
name|FDLOCK_ID
parameter_list|(
name|fd
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ISC_PLATFORM_USETHREADS */
end_comment

begin_comment
comment|/*%  * Maximum number of events communicated with the kernel.  There should normally  * be no need for having a large number.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_KQUEUE
argument_list|)
operator|||
name|defined
argument_list|(
name|USE_EPOLL
argument_list|)
operator|||
name|defined
argument_list|(
name|USE_DEVPOLL
argument_list|)
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|ISC_SOCKET_MAXEVENTS
end_ifndef

begin_define
define|#
directive|define
name|ISC_SOCKET_MAXEVENTS
value|64
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*%  * Some systems define the socket length argument as an int, some as size_t,  * some as socklen_t.  This is here so it can be easily changed if needed.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ISC_SOCKADDR_LEN_T
end_ifndef

begin_define
define|#
directive|define
name|ISC_SOCKADDR_LEN_T
value|unsigned int
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*%  * Define what the possible "soft" errors can be.  These are non-fatal returns  * of various network related functions, like recv() and so on.  *  * For some reason, BSDI (and perhaps others) will sometimes return<0  * from recv() but will have errno==0.  This is broken, but we have to  * work around it here.  */
end_comment

begin_define
define|#
directive|define
name|SOFT_ERROR
parameter_list|(
name|e
parameter_list|)
value|((e) == EAGAIN || \ 			 (e) == EWOULDBLOCK || \ 			 (e) == EINTR || \ 			 (e) == 0)
end_define

begin_define
define|#
directive|define
name|DLVL
parameter_list|(
name|x
parameter_list|)
value|ISC_LOGCATEGORY_GENERAL, ISC_LOGMODULE_SOCKET, ISC_LOG_DEBUG(x)
end_define

begin_comment
comment|/*!<  * DLVL(90)  --  Function entry/exit and other tracing.  * DLVL(70)  --  Socket "correctness" -- including returning of events, etc.  * DLVL(60)  --  Socket data send/receive  * DLVL(50)  --  Event tracing, including receiving/sending completion events.  * DLVL(20)  --  Socket creation/destruction.  */
end_comment

begin_define
define|#
directive|define
name|TRACE_LEVEL
value|90
end_define

begin_define
define|#
directive|define
name|CORRECTNESS_LEVEL
value|70
end_define

begin_define
define|#
directive|define
name|IOEVENT_LEVEL
value|60
end_define

begin_define
define|#
directive|define
name|EVENT_LEVEL
value|50
end_define

begin_define
define|#
directive|define
name|CREATION_LEVEL
value|20
end_define

begin_define
define|#
directive|define
name|TRACE
value|DLVL(TRACE_LEVEL)
end_define

begin_define
define|#
directive|define
name|CORRECTNESS
value|DLVL(CORRECTNESS_LEVEL)
end_define

begin_define
define|#
directive|define
name|IOEVENT
value|DLVL(IOEVENT_LEVEL)
end_define

begin_define
define|#
directive|define
name|EVENT
value|DLVL(EVENT_LEVEL)
end_define

begin_define
define|#
directive|define
name|CREATION
value|DLVL(CREATION_LEVEL)
end_define

begin_typedef
typedef|typedef
name|isc_event_t
name|intev_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|SOCKET_MAGIC
value|ISC_MAGIC('I', 'O', 'i', 'o')
end_define

begin_define
define|#
directive|define
name|VALID_SOCKET
parameter_list|(
name|s
parameter_list|)
value|ISC_MAGIC_VALID(s, SOCKET_MAGIC)
end_define

begin_comment
comment|/*!  * IPv6 control information.  If the socket is an IPv6 socket we want  * to collect the destination address and interface so the client can  * set them on outgoing packets.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|ISC_PLATFORM_HAVEIN6PKTINFO
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|USE_CMSG
end_ifndef

begin_define
define|#
directive|define
name|USE_CMSG
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*%  * NetBSD and FreeBSD can timestamp packets.  XXXMLG Should we have  * a setsockopt() like interface to request timestamps, and if the OS  * doesn't do it for us, call gettimeofday() on every UDP receive?  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SO_TIMESTAMP
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|USE_CMSG
end_ifndef

begin_define
define|#
directive|define
name|USE_CMSG
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*%  * The size to raise the receive buffer to (from BIND 8).  */
end_comment

begin_define
define|#
directive|define
name|RCVBUFSIZE
value|(32*1024)
end_define

begin_comment
comment|/*%  * The number of times a send operation is repeated if the result is EINTR.  */
end_comment

begin_define
define|#
directive|define
name|NRETRIES
value|10
end_define

begin_typedef
typedef|typedef
name|struct
name|isc__socket
name|isc__socket_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|isc__socketmgr
name|isc__socketmgr_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|NEWCONNSOCK
parameter_list|(
name|ev
parameter_list|)
value|((isc__socket_t *)(ev)->newsocket)
end_define

begin_struct
struct|struct
name|isc__socket
block|{
comment|/* Not locked. */
name|isc_socket_t
name|common
decl_stmt|;
name|isc__socketmgr_t
modifier|*
name|manager
decl_stmt|;
name|isc_mutex_t
name|lock
decl_stmt|;
name|isc_sockettype_t
name|type
decl_stmt|;
specifier|const
name|isc_statscounter_t
modifier|*
name|statsindex
decl_stmt|;
comment|/* Locked by socket lock. */
name|ISC_LINK
argument_list|(
argument|isc__socket_t
argument_list|)
name|link
expr_stmt|;
name|unsigned
name|int
name|references
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|pf
decl_stmt|;
name|char
name|name
index|[
literal|16
index|]
decl_stmt|;
name|void
modifier|*
name|tag
decl_stmt|;
name|ISC_LIST
argument_list|(
argument|isc_socketevent_t
argument_list|)
name|send_list
expr_stmt|;
name|ISC_LIST
argument_list|(
argument|isc_socketevent_t
argument_list|)
name|recv_list
expr_stmt|;
name|ISC_LIST
argument_list|(
argument|isc_socket_newconnev_t
argument_list|)
name|accept_list
expr_stmt|;
name|isc_socket_connev_t
modifier|*
name|connect_ev
decl_stmt|;
comment|/* 	 * Internal events.  Posted when a descriptor is readable or 	 * writable.  These are statically allocated and never freed. 	 * They will be set to non-purgable before use. 	 */
name|intev_t
name|readable_ev
decl_stmt|;
name|intev_t
name|writable_ev
decl_stmt|;
name|isc_sockaddr_t
name|peer_address
decl_stmt|;
comment|/* remote address */
name|unsigned
name|int
name|pending_recv
range|:
literal|1
decl_stmt|,
name|pending_send
range|:
literal|1
decl_stmt|,
name|pending_accept
range|:
literal|1
decl_stmt|,
name|listener
range|:
literal|1
decl_stmt|,
comment|/* listener socket */
name|connected
range|:
literal|1
decl_stmt|,
name|connecting
range|:
literal|1
decl_stmt|,
comment|/* connect pending */
name|bound
range|:
literal|1
decl_stmt|;
comment|/* bound to local addr */
ifdef|#
directive|ifdef
name|ISC_NET_RECVOVERFLOW
name|unsigned
name|char
name|overflow
decl_stmt|;
comment|/* used for MSG_TRUNC fake */
endif|#
directive|endif
name|char
modifier|*
name|recvcmsgbuf
decl_stmt|;
name|ISC_SOCKADDR_LEN_T
name|recvcmsgbuflen
decl_stmt|;
name|char
modifier|*
name|sendcmsgbuf
decl_stmt|;
name|ISC_SOCKADDR_LEN_T
name|sendcmsgbuflen
decl_stmt|;
name|void
modifier|*
name|fdwatcharg
decl_stmt|;
name|isc_sockfdwatch_t
name|fdwatchcb
decl_stmt|;
name|int
name|fdwatchflags
decl_stmt|;
name|isc_task_t
modifier|*
name|fdwatchtask
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|SOCKET_MANAGER_MAGIC
value|ISC_MAGIC('I', 'O', 'm', 'g')
end_define

begin_define
define|#
directive|define
name|VALID_MANAGER
parameter_list|(
name|m
parameter_list|)
value|ISC_MAGIC_VALID(m, SOCKET_MANAGER_MAGIC)
end_define

begin_struct
struct|struct
name|isc__socketmgr
block|{
comment|/* Not locked. */
name|isc_socketmgr_t
name|common
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
name|isc_mutex_t
name|lock
decl_stmt|;
name|isc_mutex_t
modifier|*
name|fdlock
decl_stmt|;
name|isc_stats_t
modifier|*
name|stats
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_KQUEUE
name|int
name|kqueue_fd
decl_stmt|;
name|int
name|nevents
decl_stmt|;
name|struct
name|kevent
modifier|*
name|events
decl_stmt|;
endif|#
directive|endif
comment|/* USE_KQUEUE */
ifdef|#
directive|ifdef
name|USE_EPOLL
name|int
name|epoll_fd
decl_stmt|;
name|int
name|nevents
decl_stmt|;
name|struct
name|epoll_event
modifier|*
name|events
decl_stmt|;
endif|#
directive|endif
comment|/* USE_EPOLL */
ifdef|#
directive|ifdef
name|USE_DEVPOLL
name|int
name|devpoll_fd
decl_stmt|;
name|int
name|nevents
decl_stmt|;
name|struct
name|pollfd
modifier|*
name|events
decl_stmt|;
endif|#
directive|endif
comment|/* USE_DEVPOLL */
ifdef|#
directive|ifdef
name|USE_SELECT
name|int
name|fd_bufsize
decl_stmt|;
endif|#
directive|endif
comment|/* USE_SELECT */
name|unsigned
name|int
name|maxsocks
decl_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
name|int
name|pipe_fds
index|[
literal|2
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* Locked by fdlock. */
name|isc__socket_t
modifier|*
modifier|*
name|fds
decl_stmt|;
name|int
modifier|*
name|fdstate
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_DEVPOLL
name|pollinfo_t
modifier|*
name|fdpollinfo
decl_stmt|;
endif|#
directive|endif
comment|/* Locked by manager lock. */
name|ISC_LIST
argument_list|(
argument|isc__socket_t
argument_list|)
name|socklist
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_SELECT
name|fd_set
modifier|*
name|read_fds
decl_stmt|;
name|fd_set
modifier|*
name|read_fds_copy
decl_stmt|;
name|fd_set
modifier|*
name|write_fds
decl_stmt|;
name|fd_set
modifier|*
name|write_fds_copy
decl_stmt|;
name|int
name|maxfd
decl_stmt|;
endif|#
directive|endif
comment|/* USE_SELECT */
name|int
name|reserved
decl_stmt|;
comment|/* unlocked */
ifdef|#
directive|ifdef
name|USE_WATCHER_THREAD
name|isc_thread_t
name|watcher
decl_stmt|;
name|isc_condition_t
name|shutdown_ok
decl_stmt|;
else|#
directive|else
comment|/* USE_WATCHER_THREAD */
name|unsigned
name|int
name|refs
decl_stmt|;
endif|#
directive|endif
comment|/* USE_WATCHER_THREAD */
name|int
name|maxudp
decl_stmt|;
block|}
struct|;
end_struct

begin_ifdef
ifdef|#
directive|ifdef
name|USE_SHARED_MANAGER
end_ifdef

begin_decl_stmt
specifier|static
name|isc__socketmgr_t
modifier|*
name|socketmgr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_SHARED_MANAGER */
end_comment

begin_define
define|#
directive|define
name|CLOSED
value|0
end_define

begin_comment
comment|/* this one must be zero */
end_comment

begin_define
define|#
directive|define
name|MANAGED
value|1
end_define

begin_define
define|#
directive|define
name|CLOSE_PENDING
value|2
end_define

begin_comment
comment|/*  * send() and recv() iovec counts  */
end_comment

begin_define
define|#
directive|define
name|MAXSCATTERGATHER_SEND
value|(ISC_SOCKET_MAXSCATTERGATHER)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|ISC_NET_RECVOVERFLOW
end_ifdef

begin_define
define|#
directive|define
name|MAXSCATTERGATHER_RECV
value|(ISC_SOCKET_MAXSCATTERGATHER + 1)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MAXSCATTERGATHER_RECV
value|(ISC_SOCKET_MAXSCATTERGATHER)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|send_recvdone_event
parameter_list|(
name|isc__socket_t
modifier|*
parameter_list|,
name|isc_socketevent_t
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|send_senddone_event
parameter_list|(
name|isc__socket_t
modifier|*
parameter_list|,
name|isc_socketevent_t
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_socket
parameter_list|(
name|isc__socket_t
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|isc_result_t
name|allocate_socket
parameter_list|(
name|isc__socketmgr_t
modifier|*
parameter_list|,
name|isc_sockettype_t
parameter_list|,
name|isc__socket_t
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|destroy
parameter_list|(
name|isc__socket_t
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|internal_accept
parameter_list|(
name|isc_task_t
modifier|*
parameter_list|,
name|isc_event_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|internal_connect
parameter_list|(
name|isc_task_t
modifier|*
parameter_list|,
name|isc_event_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|internal_recv
parameter_list|(
name|isc_task_t
modifier|*
parameter_list|,
name|isc_event_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|internal_send
parameter_list|(
name|isc_task_t
modifier|*
parameter_list|,
name|isc_event_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|internal_fdwatch_write
parameter_list|(
name|isc_task_t
modifier|*
parameter_list|,
name|isc_event_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|internal_fdwatch_read
parameter_list|(
name|isc_task_t
modifier|*
parameter_list|,
name|isc_event_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_cmsg
parameter_list|(
name|isc__socket_t
modifier|*
parameter_list|,
name|struct
name|msghdr
modifier|*
parameter_list|,
name|isc_socketevent_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_msghdr_send
parameter_list|(
name|isc__socket_t
modifier|*
parameter_list|,
name|isc_socketevent_t
modifier|*
parameter_list|,
name|struct
name|msghdr
modifier|*
parameter_list|,
name|struct
name|iovec
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|build_msghdr_recv
parameter_list|(
name|isc__socket_t
modifier|*
parameter_list|,
name|isc_socketevent_t
modifier|*
parameter_list|,
name|struct
name|msghdr
modifier|*
parameter_list|,
name|struct
name|iovec
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|USE_WATCHER_THREAD
end_ifdef

begin_function_decl
specifier|static
name|isc_boolean_t
name|process_ctlfd
parameter_list|(
name|isc__socketmgr_t
modifier|*
name|manager
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*%  * The following can be either static or public, depending on build environment.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BIND9
end_ifdef

begin_define
define|#
directive|define
name|ISC_SOCKETFUNC_SCOPE
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ISC_SOCKETFUNC_SCOPE
value|static
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_create
parameter_list|(
name|isc_socketmgr_t
modifier|*
name|manager
parameter_list|,
name|int
name|pf
parameter_list|,
name|isc_sockettype_t
name|type
parameter_list|,
name|isc_socket_t
modifier|*
modifier|*
name|socketp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_SOCKETFUNC_SCOPE
name|void
name|isc__socket_attach
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socket_t
modifier|*
modifier|*
name|socketp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_SOCKETFUNC_SCOPE
name|void
name|isc__socket_detach
parameter_list|(
name|isc_socket_t
modifier|*
modifier|*
name|socketp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socketmgr_create
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|isc_socketmgr_t
modifier|*
modifier|*
name|managerp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socketmgr_create2
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|isc_socketmgr_t
modifier|*
modifier|*
name|managerp
parameter_list|,
name|unsigned
name|int
name|maxsocks
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_SOCKETFUNC_SCOPE
name|void
name|isc__socketmgr_destroy
parameter_list|(
name|isc_socketmgr_t
modifier|*
modifier|*
name|managerp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_recvv
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_bufferlist_t
modifier|*
name|buflist
parameter_list|,
name|unsigned
name|int
name|minimum
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_recv
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_region_t
modifier|*
name|region
parameter_list|,
name|unsigned
name|int
name|minimum
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_recv2
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_region_t
modifier|*
name|region
parameter_list|,
name|unsigned
name|int
name|minimum
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_socketevent_t
modifier|*
name|event
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_send
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_region_t
modifier|*
name|region
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_sendto
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_region_t
modifier|*
name|region
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|address
parameter_list|,
name|struct
name|in6_pktinfo
modifier|*
name|pktinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_sendv
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_bufferlist_t
modifier|*
name|buflist
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_sendtov
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_bufferlist_t
modifier|*
name|buflist
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|address
parameter_list|,
name|struct
name|in6_pktinfo
modifier|*
name|pktinfo
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_sendto2
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_region_t
modifier|*
name|region
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|address
parameter_list|,
name|struct
name|in6_pktinfo
modifier|*
name|pktinfo
parameter_list|,
name|isc_socketevent_t
modifier|*
name|event
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_SOCKETFUNC_SCOPE
name|void
name|isc__socket_cleanunix
parameter_list|(
name|isc_sockaddr_t
modifier|*
name|sockaddr
parameter_list|,
name|isc_boolean_t
name|active
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_permunix
parameter_list|(
name|isc_sockaddr_t
modifier|*
name|sockaddr
parameter_list|,
name|isc_uint32_t
name|perm
parameter_list|,
name|isc_uint32_t
name|owner
parameter_list|,
name|isc_uint32_t
name|group
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_bind
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|sockaddr
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_filter
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
specifier|const
name|char
modifier|*
name|filter
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_listen
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|unsigned
name|int
name|backlog
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_accept
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_connect
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|addr
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_getpeername
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|addressp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_getsockname
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|addressp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_SOCKETFUNC_SCOPE
name|void
name|isc__socket_cancel
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|unsigned
name|int
name|how
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_SOCKETFUNC_SCOPE
name|isc_sockettype_t
name|isc__socket_gettype
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_SOCKETFUNC_SCOPE
name|isc_boolean_t
name|isc__socket_isbound
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_SOCKETFUNC_SCOPE
name|void
name|isc__socket_ipv6only
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_boolean_t
name|yes
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_LIBXML2
argument_list|)
operator|&&
name|defined
argument_list|(
name|BIND9
argument_list|)
end_if

begin_function_decl
name|ISC_SOCKETFUNC_SCOPE
name|void
name|isc__socketmgr_renderxml
parameter_list|(
name|isc_socketmgr_t
modifier|*
name|mgr0
parameter_list|,
name|xmlTextWriterPtr
name|writer
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_fdwatchcreate
parameter_list|(
name|isc_socketmgr_t
modifier|*
name|manager
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|flags
parameter_list|,
name|isc_sockfdwatch_t
name|callback
parameter_list|,
name|void
modifier|*
name|cbarg
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_socket_t
modifier|*
modifier|*
name|socketp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_fdwatchpoke
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_struct
specifier|static
struct|struct
block|{
name|isc_socketmethods_t
name|methods
decl_stmt|;
comment|/*% 	 * The following are defined just for avoiding unused static functions. 	 */
ifndef|#
directive|ifndef
name|BIND9
name|void
modifier|*
name|recvv
decl_stmt|,
modifier|*
name|send
decl_stmt|,
modifier|*
name|sendv
decl_stmt|,
modifier|*
name|sendto2
decl_stmt|,
modifier|*
name|cleanunix
decl_stmt|,
modifier|*
name|permunix
decl_stmt|,
modifier|*
name|filter
decl_stmt|,
modifier|*
name|listen
decl_stmt|,
modifier|*
name|accept
decl_stmt|,
modifier|*
name|getpeername
decl_stmt|,
modifier|*
name|isbound
decl_stmt|;
endif|#
directive|endif
block|}
name|socketmethods
init|=
block|{
block|{
name|isc__socket_attach
block|,
name|isc__socket_detach
block|,
name|isc__socket_bind
block|,
name|isc__socket_sendto
block|,
name|isc__socket_connect
block|,
name|isc__socket_recv
block|,
name|isc__socket_cancel
block|,
name|isc__socket_getsockname
block|,
name|isc__socket_gettype
block|,
name|isc__socket_ipv6only
block|,
name|isc__socket_fdwatchpoke
block|}
ifndef|#
directive|ifndef
name|BIND9
block|,
operator|(
name|void
operator|*
operator|)
name|isc__socket_recvv
block|,
operator|(
name|void
operator|*
operator|)
name|isc__socket_send
block|,
operator|(
name|void
operator|*
operator|)
name|isc__socket_sendv
block|,
operator|(
name|void
operator|*
operator|)
name|isc__socket_sendto2
block|,
operator|(
name|void
operator|*
operator|)
name|isc__socket_cleanunix
block|,
operator|(
name|void
operator|*
operator|)
name|isc__socket_permunix
block|,
operator|(
name|void
operator|*
operator|)
name|isc__socket_filter
block|,
operator|(
name|void
operator|*
operator|)
name|isc__socket_listen
block|,
operator|(
name|void
operator|*
operator|)
name|isc__socket_accept
block|,
operator|(
name|void
operator|*
operator|)
name|isc__socket_getpeername
block|,
operator|(
name|void
operator|*
operator|)
name|isc__socket_isbound
endif|#
directive|endif
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|isc_socketmgrmethods_t
name|socketmgrmethods
init|=
block|{
name|isc__socketmgr_destroy
block|,
name|isc__socket_create
block|,
name|isc__socket_fdwatchcreate
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SELECT_POKE_SHUTDOWN
value|(-1)
end_define

begin_define
define|#
directive|define
name|SELECT_POKE_NOTHING
value|(-2)
end_define

begin_define
define|#
directive|define
name|SELECT_POKE_READ
value|(-3)
end_define

begin_define
define|#
directive|define
name|SELECT_POKE_ACCEPT
value|(-3)
end_define

begin_comment
comment|/*%< Same as _READ */
end_comment

begin_define
define|#
directive|define
name|SELECT_POKE_WRITE
value|(-4)
end_define

begin_define
define|#
directive|define
name|SELECT_POKE_CONNECT
value|(-4)
end_define

begin_comment
comment|/*%< Same as _WRITE */
end_comment

begin_define
define|#
directive|define
name|SELECT_POKE_CLOSE
value|(-5)
end_define

begin_define
define|#
directive|define
name|SOCK_DEAD
parameter_list|(
name|s
parameter_list|)
value|((s)->references == 0)
end_define

begin_comment
comment|/*%  * Shortcut index arrays to get access to statistics counters.  */
end_comment

begin_enum
enum|enum
block|{
name|STATID_OPEN
init|=
literal|0
block|,
name|STATID_OPENFAIL
init|=
literal|1
block|,
name|STATID_CLOSE
init|=
literal|2
block|,
name|STATID_BINDFAIL
init|=
literal|3
block|,
name|STATID_CONNECTFAIL
init|=
literal|4
block|,
name|STATID_CONNECT
init|=
literal|5
block|,
name|STATID_ACCEPTFAIL
init|=
literal|6
block|,
name|STATID_ACCEPT
init|=
literal|7
block|,
name|STATID_SENDFAIL
init|=
literal|8
block|,
name|STATID_RECVFAIL
init|=
literal|9
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
specifier|const
name|isc_statscounter_t
name|upd4statsindex
index|[]
init|=
block|{
name|isc_sockstatscounter_udp4open
block|,
name|isc_sockstatscounter_udp4openfail
block|,
name|isc_sockstatscounter_udp4close
block|,
name|isc_sockstatscounter_udp4bindfail
block|,
name|isc_sockstatscounter_udp4connectfail
block|,
name|isc_sockstatscounter_udp4connect
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|isc_sockstatscounter_udp4sendfail
block|,
name|isc_sockstatscounter_udp4recvfail
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|isc_statscounter_t
name|upd6statsindex
index|[]
init|=
block|{
name|isc_sockstatscounter_udp6open
block|,
name|isc_sockstatscounter_udp6openfail
block|,
name|isc_sockstatscounter_udp6close
block|,
name|isc_sockstatscounter_udp6bindfail
block|,
name|isc_sockstatscounter_udp6connectfail
block|,
name|isc_sockstatscounter_udp6connect
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|isc_sockstatscounter_udp6sendfail
block|,
name|isc_sockstatscounter_udp6recvfail
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|isc_statscounter_t
name|tcp4statsindex
index|[]
init|=
block|{
name|isc_sockstatscounter_tcp4open
block|,
name|isc_sockstatscounter_tcp4openfail
block|,
name|isc_sockstatscounter_tcp4close
block|,
name|isc_sockstatscounter_tcp4bindfail
block|,
name|isc_sockstatscounter_tcp4connectfail
block|,
name|isc_sockstatscounter_tcp4connect
block|,
name|isc_sockstatscounter_tcp4acceptfail
block|,
name|isc_sockstatscounter_tcp4accept
block|,
name|isc_sockstatscounter_tcp4sendfail
block|,
name|isc_sockstatscounter_tcp4recvfail
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|isc_statscounter_t
name|tcp6statsindex
index|[]
init|=
block|{
name|isc_sockstatscounter_tcp6open
block|,
name|isc_sockstatscounter_tcp6openfail
block|,
name|isc_sockstatscounter_tcp6close
block|,
name|isc_sockstatscounter_tcp6bindfail
block|,
name|isc_sockstatscounter_tcp6connectfail
block|,
name|isc_sockstatscounter_tcp6connect
block|,
name|isc_sockstatscounter_tcp6acceptfail
block|,
name|isc_sockstatscounter_tcp6accept
block|,
name|isc_sockstatscounter_tcp6sendfail
block|,
name|isc_sockstatscounter_tcp6recvfail
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|isc_statscounter_t
name|unixstatsindex
index|[]
init|=
block|{
name|isc_sockstatscounter_unixopen
block|,
name|isc_sockstatscounter_unixopenfail
block|,
name|isc_sockstatscounter_unixclose
block|,
name|isc_sockstatscounter_unixbindfail
block|,
name|isc_sockstatscounter_unixconnectfail
block|,
name|isc_sockstatscounter_unixconnect
block|,
name|isc_sockstatscounter_unixacceptfail
block|,
name|isc_sockstatscounter_unixaccept
block|,
name|isc_sockstatscounter_unixsendfail
block|,
name|isc_sockstatscounter_unixrecvfail
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|isc_statscounter_t
name|fdwatchstatsindex
index|[]
init|=
block|{
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|isc_sockstatscounter_fdwatchclose
block|,
name|isc_sockstatscounter_fdwatchbindfail
block|,
name|isc_sockstatscounter_fdwatchconnectfail
block|,
name|isc_sockstatscounter_fdwatchconnect
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
name|isc_sockstatscounter_fdwatchsendfail
block|,
name|isc_sockstatscounter_fdwatchrecvfail
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|USE_KQUEUE
argument_list|)
operator|||
name|defined
argument_list|(
name|USE_EPOLL
argument_list|)
operator|||
name|defined
argument_list|(
name|USE_DEVPOLL
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|USE_WATCHER_THREAD
argument_list|)
end_if

begin_function_decl
specifier|static
name|void
name|manager_log
parameter_list|(
name|isc__socketmgr_t
modifier|*
name|sockmgr
parameter_list|,
name|isc_logcategory_t
modifier|*
name|category
parameter_list|,
name|isc_logmodule_t
modifier|*
name|module
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|ISC_FORMAT_PRINTF
parameter_list|(
function_decl|5
operator|,
function_decl|6
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
name|void
name|manager_log
parameter_list|(
name|isc__socketmgr_t
modifier|*
name|sockmgr
parameter_list|,
name|isc_logcategory_t
modifier|*
name|category
parameter_list|,
name|isc_logmodule_t
modifier|*
name|module
parameter_list|,
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|msgbuf
index|[
literal|2048
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
operator|!
name|isc_log_wouldlog
argument_list|(
name|isc_lctx
argument_list|,
name|level
argument_list|)
condition|)
return|return;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|msgbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|isc_lctx
argument_list|,
name|category
argument_list|,
name|module
argument_list|,
name|level
argument_list|,
literal|"sockmgr %p: %s"
argument_list|,
name|sockmgr
argument_list|,
name|msgbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|socket_log
parameter_list|(
name|isc__socket_t
modifier|*
name|sock
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|address
parameter_list|,
name|isc_logcategory_t
modifier|*
name|category
parameter_list|,
name|isc_logmodule_t
modifier|*
name|module
parameter_list|,
name|int
name|level
parameter_list|,
name|isc_msgcat_t
modifier|*
name|msgcat
parameter_list|,
name|int
name|msgset
parameter_list|,
name|int
name|message
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|ISC_FORMAT_PRINTF
parameter_list|(
function_decl|9
operator|,
function_decl|10
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function
specifier|static
name|void
name|socket_log
parameter_list|(
name|isc__socket_t
modifier|*
name|sock
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|address
parameter_list|,
name|isc_logcategory_t
modifier|*
name|category
parameter_list|,
name|isc_logmodule_t
modifier|*
name|module
parameter_list|,
name|int
name|level
parameter_list|,
name|isc_msgcat_t
modifier|*
name|msgcat
parameter_list|,
name|int
name|msgset
parameter_list|,
name|int
name|message
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|msgbuf
index|[
literal|2048
index|]
decl_stmt|;
name|char
name|peerbuf
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
operator|!
name|isc_log_wouldlog
argument_list|(
name|isc_lctx
argument_list|,
name|level
argument_list|)
condition|)
return|return;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|msgbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|msgbuf
argument_list|)
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|address
operator|==
name|NULL
condition|)
block|{
name|isc_log_iwrite
argument_list|(
name|isc_lctx
argument_list|,
name|category
argument_list|,
name|module
argument_list|,
name|level
argument_list|,
name|msgcat
argument_list|,
name|msgset
argument_list|,
name|message
argument_list|,
literal|"socket %p: %s"
argument_list|,
name|sock
argument_list|,
name|msgbuf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isc_sockaddr_format
argument_list|(
name|address
argument_list|,
name|peerbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|peerbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_iwrite
argument_list|(
name|isc_lctx
argument_list|,
name|category
argument_list|,
name|module
argument_list|,
name|level
argument_list|,
name|msgcat
argument_list|,
name|msgset
argument_list|,
name|message
argument_list|,
literal|"socket %p %s: %s"
argument_list|,
name|sock
argument_list|,
name|peerbuf
argument_list|,
name|msgbuf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_AIX
argument_list|)
operator|&&
name|defined
argument_list|(
name|ISC_NET_BSD44MSGHDR
argument_list|)
operator|&&
expr|\
name|defined
argument_list|(
name|USE_CMSG
argument_list|)
operator|&&
name|defined
argument_list|(
name|IPV6_RECVPKTINFO
argument_list|)
end_if

begin_comment
comment|/*  * AIX has a kernel bug where IPV6_RECVPKTINFO gets cleared by  * setting IPV6_V6ONLY.  */
end_comment

begin_function
specifier|static
name|void
name|FIX_IPV6_RECVPKTINFO
parameter_list|(
name|isc__socket_t
modifier|*
name|sock
parameter_list|)
block|{
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|int
name|on
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|sock
operator|->
name|pf
operator|!=
name|AF_INET6
operator|||
name|sock
operator|->
name|type
operator|!=
name|isc_sockettype_udp
condition|)
return|return;
if|if
condition|(
name|setsockopt
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_RECVPKTINFO
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"setsockopt(%d, IPV6_RECVPKTINFO) "
literal|"%s: %s"
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|FIX_IPV6_RECVPKTINFO
parameter_list|(
name|sock
parameter_list|)
value|(void)0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*%  * Increment socket-related statistics counters.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|inc_stats
parameter_list|(
name|isc_stats_t
modifier|*
name|stats
parameter_list|,
name|isc_statscounter_t
name|counterid
parameter_list|)
block|{
name|REQUIRE
argument_list|(
name|counterid
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|stats
operator|!=
name|NULL
condition|)
name|isc_stats_increment
argument_list|(
name|stats
argument_list|,
name|counterid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|watch_fd
parameter_list|(
name|isc__socketmgr_t
modifier|*
name|manager
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|msg
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_KQUEUE
name|struct
name|kevent
name|evchange
decl_stmt|;
name|memset
argument_list|(
operator|&
name|evchange
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|evchange
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|SELECT_POKE_READ
condition|)
name|evchange
operator|.
name|filter
operator|=
name|EVFILT_READ
expr_stmt|;
else|else
name|evchange
operator|.
name|filter
operator|=
name|EVFILT_WRITE
expr_stmt|;
name|evchange
operator|.
name|flags
operator|=
name|EV_ADD
expr_stmt|;
name|evchange
operator|.
name|ident
operator|=
name|fd
expr_stmt|;
if|if
condition|(
name|kevent
argument_list|(
name|manager
operator|->
name|kqueue_fd
argument_list|,
operator|&
name|evchange
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
name|result
operator|=
name|isc__errno2result
argument_list|(
name|errno
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|USE_EPOLL
argument_list|)
name|struct
name|epoll_event
name|event
decl_stmt|;
if|if
condition|(
name|msg
operator|==
name|SELECT_POKE_READ
condition|)
name|event
operator|.
name|events
operator|=
name|EPOLLIN
expr_stmt|;
else|else
name|event
operator|.
name|events
operator|=
name|EPOLLOUT
expr_stmt|;
name|memset
argument_list|(
operator|&
name|event
operator|.
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|event
operator|.
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|.
name|data
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
name|epoll_ctl
argument_list|(
name|manager
operator|->
name|epoll_fd
argument_list|,
name|EPOLL_CTL_ADD
argument_list|,
name|fd
argument_list|,
operator|&
name|event
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|EEXIST
condition|)
block|{
name|result
operator|=
name|isc__errno2result
argument_list|(
name|errno
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|USE_DEVPOLL
argument_list|)
name|struct
name|pollfd
name|pfd
decl_stmt|;
name|int
name|lockid
init|=
name|FDLOCK_ID
argument_list|(
name|fd
argument_list|)
decl_stmt|;
name|memset
argument_list|(
operator|&
name|pfd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pfd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|SELECT_POKE_READ
condition|)
name|pfd
operator|.
name|events
operator|=
name|POLLIN
expr_stmt|;
else|else
name|pfd
operator|.
name|events
operator|=
name|POLLOUT
expr_stmt|;
name|pfd
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
name|pfd
operator|.
name|revents
operator|=
literal|0
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|fdlock
index|[
name|lockid
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|manager
operator|->
name|devpoll_fd
argument_list|,
operator|&
name|pfd
argument_list|,
sizeof|sizeof
argument_list|(
name|pfd
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|result
operator|=
name|isc__errno2result
argument_list|(
name|errno
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|msg
operator|==
name|SELECT_POKE_READ
condition|)
name|manager
operator|->
name|fdpollinfo
index|[
name|fd
index|]
operator|.
name|want_read
operator|=
literal|1
expr_stmt|;
else|else
name|manager
operator|->
name|fdpollinfo
index|[
name|fd
index|]
operator|.
name|want_write
operator|=
literal|1
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|fdlock
index|[
name|lockid
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|USE_SELECT
argument_list|)
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|SELECT_POKE_READ
condition|)
name|FD_SET
argument_list|(
name|fd
argument_list|,
name|manager
operator|->
name|read_fds
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|SELECT_POKE_WRITE
condition|)
name|FD_SET
argument_list|(
name|fd
argument_list|,
name|manager
operator|->
name|write_fds
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
specifier|inline
name|isc_result_t
name|unwatch_fd
parameter_list|(
name|isc__socketmgr_t
modifier|*
name|manager
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|msg
parameter_list|)
block|{
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_KQUEUE
name|struct
name|kevent
name|evchange
decl_stmt|;
name|memset
argument_list|(
operator|&
name|evchange
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|evchange
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|SELECT_POKE_READ
condition|)
name|evchange
operator|.
name|filter
operator|=
name|EVFILT_READ
expr_stmt|;
else|else
name|evchange
operator|.
name|filter
operator|=
name|EVFILT_WRITE
expr_stmt|;
name|evchange
operator|.
name|flags
operator|=
name|EV_DELETE
expr_stmt|;
name|evchange
operator|.
name|ident
operator|=
name|fd
expr_stmt|;
if|if
condition|(
name|kevent
argument_list|(
name|manager
operator|->
name|kqueue_fd
argument_list|,
operator|&
name|evchange
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
name|result
operator|=
name|isc__errno2result
argument_list|(
name|errno
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|USE_EPOLL
argument_list|)
name|struct
name|epoll_event
name|event
decl_stmt|;
if|if
condition|(
name|msg
operator|==
name|SELECT_POKE_READ
condition|)
name|event
operator|.
name|events
operator|=
name|EPOLLIN
expr_stmt|;
else|else
name|event
operator|.
name|events
operator|=
name|EPOLLOUT
expr_stmt|;
name|memset
argument_list|(
operator|&
name|event
operator|.
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|event
operator|.
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|event
operator|.
name|data
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
name|epoll_ctl
argument_list|(
name|manager
operator|->
name|epoll_fd
argument_list|,
name|EPOLL_CTL_DEL
argument_list|,
name|fd
argument_list|,
operator|&
name|event
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"epoll_ctl(DEL), %d: %s"
argument_list|,
name|fd
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|USE_DEVPOLL
argument_list|)
name|struct
name|pollfd
name|pfds
index|[
literal|2
index|]
decl_stmt|;
name|size_t
name|writelen
init|=
sizeof|sizeof
argument_list|(
name|pfds
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|int
name|lockid
init|=
name|FDLOCK_ID
argument_list|(
name|fd
argument_list|)
decl_stmt|;
name|memset
argument_list|(
name|pfds
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pfds
argument_list|)
argument_list|)
expr_stmt|;
name|pfds
index|[
literal|0
index|]
operator|.
name|events
operator|=
name|POLLREMOVE
expr_stmt|;
name|pfds
index|[
literal|0
index|]
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
comment|/* 	 * Canceling read or write polling via /dev/poll is tricky.  Since it 	 * only provides a way of canceling per FD, we may need to re-poll the 	 * socket for the other operation. 	 */
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|fdlock
index|[
name|lockid
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|SELECT_POKE_READ
operator|&&
name|manager
operator|->
name|fdpollinfo
index|[
name|fd
index|]
operator|.
name|want_write
operator|==
literal|1
condition|)
block|{
name|pfds
index|[
literal|1
index|]
operator|.
name|events
operator|=
name|POLLOUT
expr_stmt|;
name|pfds
index|[
literal|1
index|]
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
name|writelen
operator|+=
sizeof|sizeof
argument_list|(
name|pfds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msg
operator|==
name|SELECT_POKE_WRITE
operator|&&
name|manager
operator|->
name|fdpollinfo
index|[
name|fd
index|]
operator|.
name|want_read
operator|==
literal|1
condition|)
block|{
name|pfds
index|[
literal|1
index|]
operator|.
name|events
operator|=
name|POLLIN
expr_stmt|;
name|pfds
index|[
literal|1
index|]
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
name|writelen
operator|+=
sizeof|sizeof
argument_list|(
name|pfds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|write
argument_list|(
name|manager
operator|->
name|devpoll_fd
argument_list|,
name|pfds
argument_list|,
name|writelen
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|result
operator|=
name|isc__errno2result
argument_list|(
name|errno
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|msg
operator|==
name|SELECT_POKE_READ
condition|)
name|manager
operator|->
name|fdpollinfo
index|[
name|fd
index|]
operator|.
name|want_read
operator|=
literal|0
expr_stmt|;
else|else
name|manager
operator|->
name|fdpollinfo
index|[
name|fd
index|]
operator|.
name|want_write
operator|=
literal|0
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|fdlock
index|[
name|lockid
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|USE_SELECT
argument_list|)
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|SELECT_POKE_READ
condition|)
name|FD_CLR
argument_list|(
name|fd
argument_list|,
name|manager
operator|->
name|read_fds
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|msg
operator|==
name|SELECT_POKE_WRITE
condition|)
name|FD_CLR
argument_list|(
name|fd
argument_list|,
name|manager
operator|->
name|write_fds
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|wakeup_socket
parameter_list|(
name|isc__socketmgr_t
modifier|*
name|manager
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|msg
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|int
name|lockid
init|=
name|FDLOCK_ID
argument_list|(
name|fd
argument_list|)
decl_stmt|;
comment|/* 	 * This is a wakeup on a socket.  If the socket is not in the 	 * process of being closed, start watching it for either reads 	 * or writes. 	 */
name|INSIST
argument_list|(
name|fd
operator|>=
literal|0
operator|&&
name|fd
operator|<
operator|(
name|int
operator|)
name|manager
operator|->
name|maxsocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|SELECT_POKE_CLOSE
condition|)
block|{
comment|/* No one should be updating fdstate, so no need to lock it */
name|INSIST
argument_list|(
name|manager
operator|->
name|fdstate
index|[
name|fd
index|]
operator|==
name|CLOSE_PENDING
argument_list|)
expr_stmt|;
name|manager
operator|->
name|fdstate
index|[
name|fd
index|]
operator|=
name|CLOSED
expr_stmt|;
operator|(
name|void
operator|)
name|unwatch_fd
argument_list|(
name|manager
argument_list|,
name|fd
argument_list|,
name|SELECT_POKE_READ
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unwatch_fd
argument_list|(
name|manager
argument_list|,
name|fd
argument_list|,
name|SELECT_POKE_WRITE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|fdlock
index|[
name|lockid
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|fdstate
index|[
name|fd
index|]
operator|==
name|CLOSE_PENDING
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|fdlock
index|[
name|lockid
index|]
argument_list|)
expr_stmt|;
comment|/* 		 * We accept (and ignore) any error from unwatch_fd() as we are 		 * closing the socket, hoping it doesn't leave dangling state in 		 * the kernel. 		 * Note that unwatch_fd() must be called after releasing the 		 * fdlock; otherwise it could cause deadlock due to a lock order 		 * reversal. 		 */
operator|(
name|void
operator|)
name|unwatch_fd
argument_list|(
name|manager
argument_list|,
name|fd
argument_list|,
name|SELECT_POKE_READ
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unwatch_fd
argument_list|(
name|manager
argument_list|,
name|fd
argument_list|,
name|SELECT_POKE_WRITE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|manager
operator|->
name|fdstate
index|[
name|fd
index|]
operator|!=
name|MANAGED
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|fdlock
index|[
name|lockid
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|fdlock
index|[
name|lockid
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Set requested bit. 	 */
name|result
operator|=
name|watch_fd
argument_list|(
name|manager
argument_list|,
name|fd
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
comment|/* 		 * XXXJT: what should we do?  Ignoring the failure of watching 		 * a socket will make the application dysfunctional, but there 		 * seems to be no reasonable recovery process. 		 */
name|isc_log_write
argument_list|(
name|isc_lctx
argument_list|,
name|ISC_LOGCATEGORY_GENERAL
argument_list|,
name|ISC_LOGMODULE_SOCKET
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"failed to start watching FD (%d): %s"
argument_list|,
name|fd
argument_list|,
name|isc_result_totext
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_WATCHER_THREAD
end_ifdef

begin_comment
comment|/*  * Poke the select loop when there is something for us to do.  * The write is required (by POSIX) to complete.  That is, we  * will not get partial writes.  */
end_comment

begin_function
specifier|static
name|void
name|select_poke
parameter_list|(
name|isc__socketmgr_t
modifier|*
name|mgr
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|msg
parameter_list|)
block|{
name|int
name|cc
decl_stmt|;
name|int
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
name|fd
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
name|msg
expr_stmt|;
do|do
block|{
name|cc
operator|=
name|write
argument_list|(
name|mgr
operator|->
name|pipe_fds
index|[
literal|1
index|]
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENOSR
comment|/* 		 * Treat ENOSR as EAGAIN but loop slowly as it is 		 * unlikely to clear fast. 		 */
if|if
condition|(
name|cc
operator|<
literal|0
operator|&&
name|errno
operator|==
name|ENOSR
condition|)
block|{
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EAGAIN
expr_stmt|;
block|}
endif|#
directive|endif
block|}
do|while
condition|(
name|cc
operator|<
literal|0
operator|&&
name|SOFT_ERROR
argument_list|(
name|errno
argument_list|)
condition|)
do|;
if|if
condition|(
name|cc
operator|<
literal|0
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|FATAL_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_WRITEFAILED
argument_list|,
literal|"write() failed "
literal|"during watcher poke: %s"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
block|}
name|INSIST
argument_list|(
name|cc
operator|==
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read a message on the internal fd.  */
end_comment

begin_function
specifier|static
name|void
name|select_readmsg
parameter_list|(
name|isc__socketmgr_t
modifier|*
name|mgr
parameter_list|,
name|int
modifier|*
name|fd
parameter_list|,
name|int
modifier|*
name|msg
parameter_list|)
block|{
name|int
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|int
name|cc
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|cc
operator|=
name|read
argument_list|(
name|mgr
operator|->
name|pipe_fds
index|[
literal|0
index|]
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|<
literal|0
condition|)
block|{
operator|*
name|msg
operator|=
name|SELECT_POKE_NOTHING
expr_stmt|;
operator|*
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Silence compiler. */
if|if
condition|(
name|SOFT_ERROR
argument_list|(
name|errno
argument_list|)
condition|)
return|return;
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|FATAL_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_READFAILED
argument_list|,
literal|"read() failed "
literal|"during watcher poke: %s"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
return|return;
block|}
name|INSIST
argument_list|(
name|cc
operator|==
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|fd
operator|=
name|buf
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|msg
operator|=
name|buf
index|[
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* USE_WATCHER_THREAD */
end_comment

begin_comment
comment|/*  * Update the state of the socketmgr when something changes.  */
end_comment

begin_function
specifier|static
name|void
name|select_poke
parameter_list|(
name|isc__socketmgr_t
modifier|*
name|manager
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|msg
parameter_list|)
block|{
if|if
condition|(
name|msg
operator|==
name|SELECT_POKE_SHUTDOWN
condition|)
return|return;
elseif|else
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
name|wakeup_socket
argument_list|(
name|manager
argument_list|,
name|fd
argument_list|,
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_WATCHER_THREAD */
end_comment

begin_comment
comment|/*  * Make a fd non-blocking.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|make_nonblock
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_FIONBIO_IOCTL
name|int
name|on
init|=
literal|1
decl_stmt|;
name|ret
operator|=
name|ioctl
argument_list|(
name|fd
argument_list|,
name|FIONBIO
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|)
expr_stmt|;
else|#
directive|else
name|flags
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|flags
operator||=
name|PORT_NONBLOCK
expr_stmt|;
name|ret
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_SETFL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
ifdef|#
directive|ifdef
name|USE_FIONBIO_IOCTL
literal|"ioctl(%d, FIONBIO,&on): %s"
argument_list|,
name|fd
argument_list|,
else|#
directive|else
literal|"fcntl(%d, F_SETFL, %d): %s"
argument_list|,
name|fd
argument_list|,
name|flags
argument_list|,
endif|#
directive|endif
name|strbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_CMSG
end_ifdef

begin_comment
comment|/*  * Not all OSes support advanced CMSG macros: CMSG_LEN and CMSG_SPACE.  * In order to ensure as much portability as possible, we provide wrapper  * functions of these macros.  * Note that cmsg_space() could run slow on OSes that do not have  * CMSG_SPACE.  */
end_comment

begin_function
specifier|static
specifier|inline
name|ISC_SOCKADDR_LEN_T
name|cmsg_len
parameter_list|(
name|ISC_SOCKADDR_LEN_T
name|len
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CMSG_LEN
return|return
operator|(
name|CMSG_LEN
argument_list|(
name|len
argument_list|)
operator|)
return|;
else|#
directive|else
name|ISC_SOCKADDR_LEN_T
name|hdrlen
decl_stmt|;
comment|/* 	 * Cast NULL so that any pointer arithmetic performed by CMSG_DATA 	 * is correct. 	 */
name|hdrlen
operator|=
operator|(
name|ISC_SOCKADDR_LEN_T
operator|)
name|CMSG_DATA
argument_list|(
operator|(
operator|(
expr|struct
name|cmsghdr
operator|*
operator|)
name|NULL
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|hdrlen
operator|+
name|len
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
specifier|inline
name|ISC_SOCKADDR_LEN_T
name|cmsg_space
parameter_list|(
name|ISC_SOCKADDR_LEN_T
name|len
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|CMSG_SPACE
return|return
operator|(
name|CMSG_SPACE
argument_list|(
name|len
argument_list|)
operator|)
return|;
else|#
directive|else
name|struct
name|msghdr
name|msg
decl_stmt|;
name|struct
name|cmsghdr
modifier|*
name|cmsgp
decl_stmt|;
comment|/* 	 * XXX: The buffer length is an ad-hoc value, but should be enough 	 * in a practical sense. 	 */
name|char
name|dummybuf
index|[
sizeof|sizeof
argument_list|(
expr|struct
name|cmsghdr
argument_list|)
operator|+
literal|1024
index|]
decl_stmt|;
name|memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|.
name|msg_control
operator|=
name|dummybuf
expr_stmt|;
name|msg
operator|.
name|msg_controllen
operator|=
sizeof|sizeof
argument_list|(
name|dummybuf
argument_list|)
expr_stmt|;
name|cmsgp
operator|=
operator|(
expr|struct
name|cmsghdr
operator|*
operator|)
name|dummybuf
expr_stmt|;
name|cmsgp
operator|->
name|cmsg_len
operator|=
name|cmsg_len
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|cmsgp
operator|=
name|CMSG_NXTHDR
argument_list|(
operator|&
name|msg
argument_list|,
name|cmsgp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmsgp
operator|!=
name|NULL
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|cmsgp
operator|-
operator|(
name|char
operator|*
operator|)
name|msg
operator|.
name|msg_control
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_CMSG */
end_comment

begin_comment
comment|/*  * Process control messages received on a socket.  */
end_comment

begin_function
specifier|static
name|void
name|process_cmsg
parameter_list|(
name|isc__socket_t
modifier|*
name|sock
parameter_list|,
name|struct
name|msghdr
modifier|*
name|msg
parameter_list|,
name|isc_socketevent_t
modifier|*
name|dev
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_CMSG
name|struct
name|cmsghdr
modifier|*
name|cmsgp
decl_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_HAVEIN6PKTINFO
name|struct
name|in6_pktinfo
modifier|*
name|pktinfop
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SO_TIMESTAMP
name|struct
name|timeval
modifier|*
name|timevalp
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* 	 * sock is used only when ISC_NET_BSD44MSGHDR and USE_CMSG are defined. 	 * msg and dev are used only when ISC_NET_BSD44MSGHDR is defined. 	 * They are all here, outside of the CPP tests, because it is 	 * more consistent with the usual ISC coding style. 	 */
name|UNUSED
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|dev
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_NET_BSD44MSGHDR
ifdef|#
directive|ifdef
name|MSG_TRUNC
if|if
condition|(
operator|(
name|msg
operator|->
name|msg_flags
operator|&
name|MSG_TRUNC
operator|)
operator|==
name|MSG_TRUNC
condition|)
name|dev
operator|->
name|attributes
operator||=
name|ISC_SOCKEVENTATTR_TRUNC
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MSG_CTRUNC
if|if
condition|(
operator|(
name|msg
operator|->
name|msg_flags
operator|&
name|MSG_CTRUNC
operator|)
operator|==
name|MSG_CTRUNC
condition|)
name|dev
operator|->
name|attributes
operator||=
name|ISC_SOCKEVENTATTR_CTRUNC
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|USE_CMSG
return|return;
else|#
directive|else
if|if
condition|(
name|msg
operator|->
name|msg_controllen
operator|==
literal|0U
operator|||
name|msg
operator|->
name|msg_control
operator|==
name|NULL
condition|)
return|return;
ifdef|#
directive|ifdef
name|SO_TIMESTAMP
name|timevalp
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ISC_PLATFORM_HAVEIN6PKTINFO
name|pktinfop
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|cmsgp
operator|=
name|CMSG_FIRSTHDR
argument_list|(
name|msg
argument_list|)
expr_stmt|;
while|while
condition|(
name|cmsgp
operator|!=
name|NULL
condition|)
block|{
name|socket_log
argument_list|(
name|sock
argument_list|,
name|NULL
argument_list|,
name|TRACE
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_PROCESSCMSG
argument_list|,
literal|"processing cmsg %p"
argument_list|,
name|cmsgp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_HAVEIN6PKTINFO
if|if
condition|(
name|cmsgp
operator|->
name|cmsg_level
operator|==
name|IPPROTO_IPV6
operator|&&
name|cmsgp
operator|->
name|cmsg_type
operator|==
name|IPV6_PKTINFO
condition|)
block|{
name|pktinfop
operator|=
operator|(
expr|struct
name|in6_pktinfo
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|cmsgp
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|dev
operator|->
name|pktinfo
argument_list|,
name|pktinfop
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_pktinfo
argument_list|)
argument_list|)
expr_stmt|;
name|dev
operator|->
name|attributes
operator||=
name|ISC_SOCKEVENTATTR_PKTINFO
expr_stmt|;
name|socket_log
argument_list|(
name|sock
argument_list|,
name|NULL
argument_list|,
name|TRACE
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_IFRECEIVED
argument_list|,
literal|"interface received on ifindex %u"
argument_list|,
name|dev
operator|->
name|pktinfo
operator|.
name|ipi6_ifindex
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|pktinfop
operator|->
name|ipi6_addr
argument_list|)
condition|)
name|dev
operator|->
name|attributes
operator||=
name|ISC_SOCKEVENTATTR_MULTICAST
expr_stmt|;
goto|goto
name|next
goto|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SO_TIMESTAMP
if|if
condition|(
name|cmsgp
operator|->
name|cmsg_level
operator|==
name|SOL_SOCKET
operator|&&
name|cmsgp
operator|->
name|cmsg_type
operator|==
name|SCM_TIMESTAMP
condition|)
block|{
name|timevalp
operator|=
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|cmsgp
argument_list|)
expr_stmt|;
name|dev
operator|->
name|timestamp
operator|.
name|seconds
operator|=
name|timevalp
operator|->
name|tv_sec
expr_stmt|;
name|dev
operator|->
name|timestamp
operator|.
name|nanoseconds
operator|=
name|timevalp
operator|->
name|tv_usec
operator|*
literal|1000
expr_stmt|;
name|dev
operator|->
name|attributes
operator||=
name|ISC_SOCKEVENTATTR_TIMESTAMP
expr_stmt|;
goto|goto
name|next
goto|;
block|}
endif|#
directive|endif
name|next
label|:
name|cmsgp
operator|=
name|CMSG_NXTHDR
argument_list|(
name|msg
argument_list|,
name|cmsgp
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USE_CMSG */
endif|#
directive|endif
comment|/* ISC_NET_BSD44MSGHDR */
block|}
end_function

begin_comment
comment|/*  * Construct an iov array and attach it to the msghdr passed in.  This is  * the SEND constructor, which will use the used region of the buffer  * (if using a buffer list) or will use the internal region (if a single  * buffer I/O is requested).  *  * Nothing can be NULL, and the done event must list at least one buffer  * on the buffer linked list for this function to be meaningful.  *  * If write_countp != NULL, *write_countp will hold the number of bytes  * this transaction can send.  */
end_comment

begin_function
specifier|static
name|void
name|build_msghdr_send
parameter_list|(
name|isc__socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socketevent_t
modifier|*
name|dev
parameter_list|,
name|struct
name|msghdr
modifier|*
name|msg
parameter_list|,
name|struct
name|iovec
modifier|*
name|iov
parameter_list|,
name|size_t
modifier|*
name|write_countp
parameter_list|)
block|{
name|unsigned
name|int
name|iovcount
decl_stmt|;
name|isc_buffer_t
modifier|*
name|buffer
decl_stmt|;
name|isc_region_t
name|used
decl_stmt|;
name|size_t
name|write_count
decl_stmt|;
name|size_t
name|skip_count
decl_stmt|;
name|memset
argument_list|(
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sock
operator|->
name|connected
condition|)
block|{
name|msg
operator|->
name|msg_name
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|dev
operator|->
name|address
operator|.
name|type
operator|.
name|sa
expr_stmt|;
name|msg
operator|->
name|msg_namelen
operator|=
name|dev
operator|->
name|address
operator|.
name|length
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|->
name|msg_name
operator|=
name|NULL
expr_stmt|;
name|msg
operator|->
name|msg_namelen
operator|=
literal|0
expr_stmt|;
block|}
name|buffer
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|dev
operator|->
name|bufferlist
argument_list|)
expr_stmt|;
name|write_count
operator|=
literal|0
expr_stmt|;
name|iovcount
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Single buffer I/O?  Skip what we've done so far in this region. 	 */
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
name|write_count
operator|=
name|dev
operator|->
name|region
operator|.
name|length
operator|-
name|dev
operator|->
name|n
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|dev
operator|->
name|region
operator|.
name|base
operator|+
name|dev
operator|->
name|n
operator|)
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
name|write_count
expr_stmt|;
name|iovcount
operator|=
literal|1
expr_stmt|;
goto|goto
name|config
goto|;
block|}
comment|/* 	 * Multibuffer I/O. 	 * Skip the data in the buffer list that we have already written. 	 */
name|skip_count
operator|=
name|dev
operator|->
name|n
expr_stmt|;
while|while
condition|(
name|buffer
operator|!=
name|NULL
condition|)
block|{
name|REQUIRE
argument_list|(
name|ISC_BUFFER_VALID
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip_count
operator|<
name|isc_buffer_usedlength
argument_list|(
name|buffer
argument_list|)
condition|)
break|break;
name|skip_count
operator|-=
name|isc_buffer_usedlength
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|buffer
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|buffer
operator|!=
name|NULL
condition|)
block|{
name|INSIST
argument_list|(
name|iovcount
operator|<
name|MAXSCATTERGATHER_SEND
argument_list|)
expr_stmt|;
name|isc_buffer_usedregion
argument_list|(
name|buffer
argument_list|,
operator|&
name|used
argument_list|)
expr_stmt|;
if|if
condition|(
name|used
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|iov
index|[
name|iovcount
index|]
operator|.
name|iov_base
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|used
operator|.
name|base
operator|+
name|skip_count
operator|)
expr_stmt|;
name|iov
index|[
name|iovcount
index|]
operator|.
name|iov_len
operator|=
name|used
operator|.
name|length
operator|-
name|skip_count
expr_stmt|;
name|write_count
operator|+=
operator|(
name|used
operator|.
name|length
operator|-
name|skip_count
operator|)
expr_stmt|;
name|skip_count
operator|=
literal|0
expr_stmt|;
name|iovcount
operator|++
expr_stmt|;
block|}
name|buffer
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|buffer
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|INSIST
argument_list|(
name|skip_count
operator|==
literal|0U
argument_list|)
expr_stmt|;
name|config
label|:
name|msg
operator|->
name|msg_iov
operator|=
name|iov
expr_stmt|;
name|msg
operator|->
name|msg_iovlen
operator|=
name|iovcount
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_NET_BSD44MSGHDR
name|msg
operator|->
name|msg_control
operator|=
name|NULL
expr_stmt|;
name|msg
operator|->
name|msg_controllen
operator|=
literal|0
expr_stmt|;
name|msg
operator|->
name|msg_flags
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_CMSG
argument_list|)
operator|&&
name|defined
argument_list|(
name|ISC_PLATFORM_HAVEIN6PKTINFO
argument_list|)
if|if
condition|(
operator|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_udp
operator|)
operator|&&
operator|(
operator|(
name|dev
operator|->
name|attributes
operator|&
name|ISC_SOCKEVENTATTR_PKTINFO
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|IPV6_USE_MIN_MTU
argument_list|)
name|int
name|use_min_mtu
init|=
literal|1
decl_stmt|;
comment|/* -1, 0, 1 */
endif|#
directive|endif
name|struct
name|cmsghdr
modifier|*
name|cmsgp
decl_stmt|;
name|struct
name|in6_pktinfo
modifier|*
name|pktinfop
decl_stmt|;
name|socket_log
argument_list|(
name|sock
argument_list|,
name|NULL
argument_list|,
name|TRACE
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_SENDTODATA
argument_list|,
literal|"sendto pktinfo data, ifindex %u"
argument_list|,
name|dev
operator|->
name|pktinfo
operator|.
name|ipi6_ifindex
argument_list|)
expr_stmt|;
name|msg
operator|->
name|msg_controllen
operator|=
name|cmsg_space
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_pktinfo
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|msg
operator|->
name|msg_controllen
operator|<=
name|sock
operator|->
name|sendcmsgbuflen
argument_list|)
expr_stmt|;
name|msg
operator|->
name|msg_control
operator|=
operator|(
name|void
operator|*
operator|)
name|sock
operator|->
name|sendcmsgbuf
expr_stmt|;
name|cmsgp
operator|=
operator|(
expr|struct
name|cmsghdr
operator|*
operator|)
name|sock
operator|->
name|sendcmsgbuf
expr_stmt|;
name|cmsgp
operator|->
name|cmsg_level
operator|=
name|IPPROTO_IPV6
expr_stmt|;
name|cmsgp
operator|->
name|cmsg_type
operator|=
name|IPV6_PKTINFO
expr_stmt|;
name|cmsgp
operator|->
name|cmsg_len
operator|=
name|cmsg_len
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_pktinfo
argument_list|)
argument_list|)
expr_stmt|;
name|pktinfop
operator|=
operator|(
expr|struct
name|in6_pktinfo
operator|*
operator|)
name|CMSG_DATA
argument_list|(
name|cmsgp
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pktinfop
argument_list|,
operator|&
name|dev
operator|->
name|pktinfo
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_pktinfo
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|IPV6_USE_MIN_MTU
argument_list|)
comment|/* 		 * Set IPV6_USE_MIN_MTU as a per packet option as FreeBSD 		 * ignores setsockopt(IPV6_USE_MIN_MTU) when IPV6_PKTINFO 		 * is used. 		 */
name|cmsgp
operator|=
operator|(
expr|struct
name|cmsghdr
operator|*
operator|)
operator|(
name|sock
operator|->
name|sendcmsgbuf
operator|+
name|msg
operator|->
name|msg_controllen
operator|)
expr_stmt|;
name|msg
operator|->
name|msg_controllen
operator|+=
name|cmsg_space
argument_list|(
sizeof|sizeof
argument_list|(
name|use_min_mtu
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|msg
operator|->
name|msg_controllen
operator|<=
name|sock
operator|->
name|sendcmsgbuflen
argument_list|)
expr_stmt|;
name|cmsgp
operator|->
name|cmsg_level
operator|=
name|IPPROTO_IPV6
expr_stmt|;
name|cmsgp
operator|->
name|cmsg_type
operator|=
name|IPV6_USE_MIN_MTU
expr_stmt|;
name|cmsgp
operator|->
name|cmsg_len
operator|=
name|cmsg_len
argument_list|(
sizeof|sizeof
argument_list|(
name|use_min_mtu
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|CMSG_DATA
argument_list|(
name|cmsgp
argument_list|)
argument_list|,
operator|&
name|use_min_mtu
argument_list|,
sizeof|sizeof
argument_list|(
name|use_min_mtu
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* USE_CMSG&& ISC_PLATFORM_HAVEIPV6 */
else|#
directive|else
comment|/* ISC_NET_BSD44MSGHDR */
name|msg
operator|->
name|msg_accrights
operator|=
name|NULL
expr_stmt|;
name|msg
operator|->
name|msg_accrightslen
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_NET_BSD44MSGHDR */
if|if
condition|(
name|write_countp
operator|!=
name|NULL
condition|)
operator|*
name|write_countp
operator|=
name|write_count
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Construct an iov array and attach it to the msghdr passed in.  This is  * the RECV constructor, which will use the available region of the buffer  * (if using a buffer list) or will use the internal region (if a single  * buffer I/O is requested).  *  * Nothing can be NULL, and the done event must list at least one buffer  * on the buffer linked list for this function to be meaningful.  *  * If read_countp != NULL, *read_countp will hold the number of bytes  * this transaction can receive.  */
end_comment

begin_function
specifier|static
name|void
name|build_msghdr_recv
parameter_list|(
name|isc__socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socketevent_t
modifier|*
name|dev
parameter_list|,
name|struct
name|msghdr
modifier|*
name|msg
parameter_list|,
name|struct
name|iovec
modifier|*
name|iov
parameter_list|,
name|size_t
modifier|*
name|read_countp
parameter_list|)
block|{
name|unsigned
name|int
name|iovcount
decl_stmt|;
name|isc_buffer_t
modifier|*
name|buffer
decl_stmt|;
name|isc_region_t
name|available
decl_stmt|;
name|size_t
name|read_count
decl_stmt|;
name|memset
argument_list|(
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|msghdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_udp
condition|)
block|{
name|memset
argument_list|(
operator|&
name|dev
operator|->
name|address
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dev
operator|->
name|address
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BROKEN_RECVMSG
if|if
condition|(
name|sock
operator|->
name|pf
operator|==
name|AF_INET
condition|)
block|{
name|msg
operator|->
name|msg_name
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|dev
operator|->
name|address
operator|.
name|type
operator|.
name|sin
expr_stmt|;
name|msg
operator|->
name|msg_namelen
operator|=
sizeof|sizeof
argument_list|(
name|dev
operator|->
name|address
operator|.
name|type
operator|.
name|sin6
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sock
operator|->
name|pf
operator|==
name|AF_INET6
condition|)
block|{
name|msg
operator|->
name|msg_name
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|dev
operator|->
name|address
operator|.
name|type
operator|.
name|sin6
expr_stmt|;
name|msg
operator|->
name|msg_namelen
operator|=
sizeof|sizeof
argument_list|(
name|dev
operator|->
name|address
operator|.
name|type
operator|.
name|sin6
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_PLATFORM_HAVESYSUNH
block|}
elseif|else
if|if
condition|(
name|sock
operator|->
name|pf
operator|==
name|AF_UNIX
condition|)
block|{
name|msg
operator|->
name|msg_name
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|dev
operator|->
name|address
operator|.
name|type
operator|.
name|sunix
expr_stmt|;
name|msg
operator|->
name|msg_namelen
operator|=
sizeof|sizeof
argument_list|(
name|dev
operator|->
name|address
operator|.
name|type
operator|.
name|sunix
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|msg
operator|->
name|msg_name
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|dev
operator|->
name|address
operator|.
name|type
operator|.
name|sa
expr_stmt|;
name|msg
operator|->
name|msg_namelen
operator|=
sizeof|sizeof
argument_list|(
name|dev
operator|->
name|address
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|msg
operator|->
name|msg_name
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|dev
operator|->
name|address
operator|.
name|type
operator|.
name|sa
expr_stmt|;
name|msg
operator|->
name|msg_namelen
operator|=
sizeof|sizeof
argument_list|(
name|dev
operator|->
name|address
operator|.
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ISC_NET_RECVOVERFLOW
comment|/* If needed, steal one iovec for overflow detection. */
name|maxiov
operator|--
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* TCP */
name|msg
operator|->
name|msg_name
operator|=
name|NULL
expr_stmt|;
name|msg
operator|->
name|msg_namelen
operator|=
literal|0
expr_stmt|;
name|dev
operator|->
name|address
operator|=
name|sock
operator|->
name|peer_address
expr_stmt|;
block|}
name|buffer
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|dev
operator|->
name|bufferlist
argument_list|)
expr_stmt|;
name|read_count
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Single buffer I/O?  Skip what we've done so far in this region. 	 */
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
name|read_count
operator|=
name|dev
operator|->
name|region
operator|.
name|length
operator|-
name|dev
operator|->
name|n
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|dev
operator|->
name|region
operator|.
name|base
operator|+
name|dev
operator|->
name|n
operator|)
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
name|read_count
expr_stmt|;
name|iovcount
operator|=
literal|1
expr_stmt|;
goto|goto
name|config
goto|;
block|}
comment|/* 	 * Multibuffer I/O. 	 * Skip empty buffers. 	 */
while|while
condition|(
name|buffer
operator|!=
name|NULL
condition|)
block|{
name|REQUIRE
argument_list|(
name|ISC_BUFFER_VALID
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_buffer_availablelength
argument_list|(
name|buffer
argument_list|)
operator|!=
literal|0
condition|)
break|break;
name|buffer
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|buffer
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|iovcount
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|buffer
operator|!=
name|NULL
condition|)
block|{
name|INSIST
argument_list|(
name|iovcount
operator|<
name|MAXSCATTERGATHER_RECV
argument_list|)
expr_stmt|;
name|isc_buffer_availableregion
argument_list|(
name|buffer
argument_list|,
operator|&
name|available
argument_list|)
expr_stmt|;
if|if
condition|(
name|available
operator|.
name|length
operator|>
literal|0
condition|)
block|{
name|iov
index|[
name|iovcount
index|]
operator|.
name|iov_base
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|available
operator|.
name|base
operator|)
expr_stmt|;
name|iov
index|[
name|iovcount
index|]
operator|.
name|iov_len
operator|=
name|available
operator|.
name|length
expr_stmt|;
name|read_count
operator|+=
name|available
operator|.
name|length
expr_stmt|;
name|iovcount
operator|++
expr_stmt|;
block|}
name|buffer
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|buffer
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|config
label|:
comment|/* 	 * If needed, set up to receive that one extra byte.  Note that 	 * we know there is at least one iov left, since we stole it 	 * at the top of this function. 	 */
ifdef|#
directive|ifdef
name|ISC_NET_RECVOVERFLOW
if|if
condition|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_udp
condition|)
block|{
name|iov
index|[
name|iovcount
index|]
operator|.
name|iov_base
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|&
name|sock
operator|->
name|overflow
operator|)
expr_stmt|;
name|iov
index|[
name|iovcount
index|]
operator|.
name|iov_len
operator|=
literal|1
expr_stmt|;
name|iovcount
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
name|msg
operator|->
name|msg_iov
operator|=
name|iov
expr_stmt|;
name|msg
operator|->
name|msg_iovlen
operator|=
name|iovcount
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_NET_BSD44MSGHDR
name|msg
operator|->
name|msg_control
operator|=
name|NULL
expr_stmt|;
name|msg
operator|->
name|msg_controllen
operator|=
literal|0
expr_stmt|;
name|msg
operator|->
name|msg_flags
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_CMSG
argument_list|)
if|if
condition|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_udp
condition|)
block|{
name|msg
operator|->
name|msg_control
operator|=
name|sock
operator|->
name|recvcmsgbuf
expr_stmt|;
name|msg
operator|->
name|msg_controllen
operator|=
name|sock
operator|->
name|recvcmsgbuflen
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USE_CMSG */
else|#
directive|else
comment|/* ISC_NET_BSD44MSGHDR */
name|msg
operator|->
name|msg_accrights
operator|=
name|NULL
expr_stmt|;
name|msg
operator|->
name|msg_accrightslen
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_NET_BSD44MSGHDR */
if|if
condition|(
name|read_countp
operator|!=
name|NULL
condition|)
operator|*
name|read_countp
operator|=
name|read_count
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_dev_address
parameter_list|(
name|isc_sockaddr_t
modifier|*
name|address
parameter_list|,
name|isc__socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socketevent_t
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_udp
condition|)
block|{
if|if
condition|(
name|address
operator|!=
name|NULL
condition|)
name|dev
operator|->
name|address
operator|=
operator|*
name|address
expr_stmt|;
else|else
name|dev
operator|->
name|address
operator|=
name|sock
operator|->
name|peer_address
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_tcp
condition|)
block|{
name|INSIST
argument_list|(
name|address
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|dev
operator|->
name|address
operator|=
name|sock
operator|->
name|peer_address
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|destroy_socketevent
parameter_list|(
name|isc_event_t
modifier|*
name|event
parameter_list|)
block|{
name|isc_socketevent_t
modifier|*
name|ev
init|=
operator|(
name|isc_socketevent_t
operator|*
operator|)
name|event
decl_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|ev
operator|->
name|bufferlist
argument_list|)
argument_list|)
expr_stmt|;
call|(
name|ev
operator|->
name|destroy
call|)
argument_list|(
name|event
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_socketevent_t
modifier|*
name|allocate_socketevent
parameter_list|(
name|isc__socket_t
modifier|*
name|sock
parameter_list|,
name|isc_eventtype_t
name|eventtype
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|isc_socketevent_t
modifier|*
name|ev
decl_stmt|;
name|ev
operator|=
operator|(
name|isc_socketevent_t
operator|*
operator|)
name|isc_event_allocate
argument_list|(
name|sock
operator|->
name|manager
operator|->
name|mctx
argument_list|,
name|sock
argument_list|,
name|eventtype
argument_list|,
name|action
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ev
operator|->
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|ev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|ev
operator|->
name|bufferlist
argument_list|)
expr_stmt|;
name|ev
operator|->
name|region
operator|.
name|base
operator|=
name|NULL
expr_stmt|;
name|ev
operator|->
name|n
operator|=
literal|0
expr_stmt|;
name|ev
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|ev
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
name|ev
operator|->
name|destroy
operator|=
name|ev
operator|->
name|ev_destroy
expr_stmt|;
name|ev
operator|->
name|ev_destroy
operator|=
name|destroy_socketevent
expr_stmt|;
return|return
operator|(
name|ev
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ISC_SOCKET_DEBUG
argument_list|)
end_if

begin_function
specifier|static
name|void
name|dump_msg
parameter_list|(
name|struct
name|msghdr
modifier|*
name|msg
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"MSGHDR %p\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tname %p, namelen %ld\n"
argument_list|,
name|msg
operator|->
name|msg_name
argument_list|,
operator|(
name|long
operator|)
name|msg
operator|->
name|msg_namelen
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tiov %p, iovlen %ld\n"
argument_list|,
name|msg
operator|->
name|msg_iov
argument_list|,
operator|(
name|long
operator|)
name|msg
operator|->
name|msg_iovlen
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|unsigned
name|int
operator|)
name|msg
operator|->
name|msg_iovlen
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"\t\t%d\tbase %p, len %ld\n"
argument_list|,
name|i
argument_list|,
name|msg
operator|->
name|msg_iov
index|[
name|i
index|]
operator|.
name|iov_base
argument_list|,
operator|(
name|long
operator|)
name|msg
operator|->
name|msg_iov
index|[
name|i
index|]
operator|.
name|iov_len
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ISC_NET_BSD44MSGHDR
name|printf
argument_list|(
literal|"\tcontrol %p, controllen %ld\n"
argument_list|,
name|msg
operator|->
name|msg_control
argument_list|,
operator|(
name|long
operator|)
name|msg
operator|->
name|msg_controllen
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DOIO_SUCCESS
value|0
end_define

begin_comment
comment|/* i/o ok, event sent */
end_comment

begin_define
define|#
directive|define
name|DOIO_SOFT
value|1
end_define

begin_comment
comment|/* i/o ok, soft error, no event sent */
end_comment

begin_define
define|#
directive|define
name|DOIO_HARD
value|2
end_define

begin_comment
comment|/* i/o error, event sent */
end_comment

begin_define
define|#
directive|define
name|DOIO_EOF
value|3
end_define

begin_comment
comment|/* EOF, no event sent */
end_comment

begin_function
specifier|static
name|int
name|doio_recv
parameter_list|(
name|isc__socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socketevent_t
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|cc
decl_stmt|;
name|struct
name|iovec
name|iov
index|[
name|MAXSCATTERGATHER_RECV
index|]
decl_stmt|;
name|size_t
name|read_count
decl_stmt|;
name|size_t
name|actual_count
decl_stmt|;
name|struct
name|msghdr
name|msghdr
decl_stmt|;
name|isc_buffer_t
modifier|*
name|buffer
decl_stmt|;
name|int
name|recv_errno
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|build_msghdr_recv
argument_list|(
name|sock
argument_list|,
name|dev
argument_list|,
operator|&
name|msghdr
argument_list|,
name|iov
argument_list|,
operator|&
name|read_count
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ISC_SOCKET_DEBUG
argument_list|)
name|dump_msg
argument_list|(
operator|&
name|msghdr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cc
operator|=
name|recvmsg
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
operator|&
name|msghdr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|recv_errno
operator|=
name|errno
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|ISC_SOCKET_DEBUG
argument_list|)
name|dump_msg
argument_list|(
operator|&
name|msghdr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cc
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|SOFT_ERROR
argument_list|(
name|recv_errno
argument_list|)
condition|)
return|return
operator|(
name|DOIO_SOFT
operator|)
return|;
if|if
condition|(
name|isc_log_wouldlog
argument_list|(
name|isc_lctx
argument_list|,
name|IOEVENT_LEVEL
argument_list|)
condition|)
block|{
name|isc__strerror
argument_list|(
name|recv_errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|socket_log
argument_list|(
name|sock
argument_list|,
name|NULL
argument_list|,
name|IOEVENT
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_DOIORECV
argument_list|,
literal|"doio_recv: recvmsg(%d) %d bytes, err %d/%s"
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|cc
argument_list|,
name|recv_errno
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
block|}
define|#
directive|define
name|SOFT_OR_HARD
parameter_list|(
name|_system
parameter_list|,
name|_isc
parameter_list|)
define|\
value|if (recv_errno == _system) { \ 		if (sock->connected) { \ 			dev->result = _isc; \ 			inc_stats(sock->manager->stats, \ 				  sock->statsindex[STATID_RECVFAIL]); \ 			return (DOIO_HARD); \ 		} \ 		return (DOIO_SOFT); \ 	}
define|#
directive|define
name|ALWAYS_HARD
parameter_list|(
name|_system
parameter_list|,
name|_isc
parameter_list|)
define|\
value|if (recv_errno == _system) { \ 		dev->result = _isc; \ 		inc_stats(sock->manager->stats, \ 			  sock->statsindex[STATID_RECVFAIL]); \ 		return (DOIO_HARD); \ 	}
name|SOFT_OR_HARD
argument_list|(
name|ECONNREFUSED
argument_list|,
name|ISC_R_CONNREFUSED
argument_list|)
expr_stmt|;
name|SOFT_OR_HARD
argument_list|(
name|ENETUNREACH
argument_list|,
name|ISC_R_NETUNREACH
argument_list|)
expr_stmt|;
name|SOFT_OR_HARD
argument_list|(
name|EHOSTUNREACH
argument_list|,
name|ISC_R_HOSTUNREACH
argument_list|)
expr_stmt|;
name|SOFT_OR_HARD
argument_list|(
name|EHOSTDOWN
argument_list|,
name|ISC_R_HOSTDOWN
argument_list|)
expr_stmt|;
comment|/* HPUX 11.11 can return EADDRNOTAVAIL. */
name|SOFT_OR_HARD
argument_list|(
name|EADDRNOTAVAIL
argument_list|,
name|ISC_R_ADDRNOTAVAIL
argument_list|)
expr_stmt|;
name|ALWAYS_HARD
argument_list|(
name|ENOBUFS
argument_list|,
name|ISC_R_NORESOURCES
argument_list|)
expr_stmt|;
comment|/* 		 * HPUX returns EPROTO and EINVAL on receiving some ICMP/ICMPv6 		 * errors. 		 */
ifdef|#
directive|ifdef
name|EPROTO
name|SOFT_OR_HARD
argument_list|(
name|EPROTO
argument_list|,
name|ISC_R_HOSTUNREACH
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SOFT_OR_HARD
argument_list|(
name|EINVAL
argument_list|,
name|ISC_R_HOSTUNREACH
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|SOFT_OR_HARD
undef|#
directive|undef
name|ALWAYS_HARD
name|dev
operator|->
name|result
operator|=
name|isc__errno2result
argument_list|(
name|recv_errno
argument_list|)
expr_stmt|;
name|inc_stats
argument_list|(
name|sock
operator|->
name|manager
operator|->
name|stats
argument_list|,
name|sock
operator|->
name|statsindex
index|[
name|STATID_RECVFAIL
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|DOIO_HARD
operator|)
return|;
block|}
comment|/* 	 * On TCP and UNIX sockets, zero length reads indicate EOF, 	 * while on UDP sockets, zero length reads are perfectly valid, 	 * although strange. 	 */
switch|switch
condition|(
name|sock
operator|->
name|type
condition|)
block|{
case|case
name|isc_sockettype_tcp
case|:
case|case
name|isc_sockettype_unix
case|:
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
return|return
operator|(
name|DOIO_EOF
operator|)
return|;
break|break;
case|case
name|isc_sockettype_udp
case|:
break|break;
case|case
name|isc_sockettype_fdwatch
case|:
default|default:
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_udp
condition|)
block|{
name|dev
operator|->
name|address
operator|.
name|length
operator|=
name|msghdr
operator|.
name|msg_namelen
expr_stmt|;
if|if
condition|(
name|isc_sockaddr_getport
argument_list|(
operator|&
name|dev
operator|->
name|address
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|isc_log_wouldlog
argument_list|(
name|isc_lctx
argument_list|,
name|IOEVENT_LEVEL
argument_list|)
condition|)
block|{
name|socket_log
argument_list|(
name|sock
argument_list|,
operator|&
name|dev
operator|->
name|address
argument_list|,
name|IOEVENT
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_ZEROPORT
argument_list|,
literal|"dropping source port zero packet"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|DOIO_SOFT
operator|)
return|;
block|}
comment|/* 		 * Simulate a firewall blocking UDP responses bigger than 		 * 512 bytes. 		 */
if|if
condition|(
name|sock
operator|->
name|manager
operator|->
name|maxudp
operator|!=
literal|0
operator|&&
name|cc
operator|>
name|sock
operator|->
name|manager
operator|->
name|maxudp
condition|)
return|return
operator|(
name|DOIO_SOFT
operator|)
return|;
block|}
name|socket_log
argument_list|(
name|sock
argument_list|,
operator|&
name|dev
operator|->
name|address
argument_list|,
name|IOEVENT
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_PKTRECV
argument_list|,
literal|"packet received correctly"
argument_list|)
expr_stmt|;
comment|/* 	 * Overflow bit detection.  If we received MORE bytes than we should, 	 * this indicates an overflow situation.  Set the flag in the 	 * dev entry and adjust how much we read by one. 	 */
ifdef|#
directive|ifdef
name|ISC_NET_RECVOVERFLOW
if|if
condition|(
operator|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_udp
operator|)
operator|&&
operator|(
operator|(
name|size_t
operator|)
name|cc
operator|>
name|read_count
operator|)
condition|)
block|{
name|dev
operator|->
name|attributes
operator||=
name|ISC_SOCKEVENTATTR_TRUNC
expr_stmt|;
name|cc
operator|--
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * If there are control messages attached, run through them and pull 	 * out the interesting bits. 	 */
if|if
condition|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_udp
condition|)
name|process_cmsg
argument_list|(
name|sock
argument_list|,
operator|&
name|msghdr
argument_list|,
name|dev
argument_list|)
expr_stmt|;
comment|/* 	 * update the buffers (if any) and the i/o count 	 */
name|dev
operator|->
name|n
operator|+=
name|cc
expr_stmt|;
name|actual_count
operator|=
name|cc
expr_stmt|;
name|buffer
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|dev
operator|->
name|bufferlist
argument_list|)
expr_stmt|;
while|while
condition|(
name|buffer
operator|!=
name|NULL
operator|&&
name|actual_count
operator|>
literal|0U
condition|)
block|{
name|REQUIRE
argument_list|(
name|ISC_BUFFER_VALID
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_buffer_availablelength
argument_list|(
name|buffer
argument_list|)
operator|<=
name|actual_count
condition|)
block|{
name|actual_count
operator|-=
name|isc_buffer_availablelength
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|isc_buffer_add
argument_list|(
name|buffer
argument_list|,
name|isc_buffer_availablelength
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|isc_buffer_add
argument_list|(
name|buffer
argument_list|,
name|actual_count
argument_list|)
expr_stmt|;
name|actual_count
operator|=
literal|0
expr_stmt|;
name|POST
argument_list|(
name|actual_count
argument_list|)
expr_stmt|;
break|break;
block|}
name|buffer
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|buffer
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
name|INSIST
argument_list|(
name|actual_count
operator|==
literal|0U
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If we read less than we expected, update counters, 	 * and let the upper layer poke the descriptor. 	 */
if|if
condition|(
operator|(
operator|(
name|size_t
operator|)
name|cc
operator|!=
name|read_count
operator|)
operator|&&
operator|(
name|dev
operator|->
name|n
operator|<
name|dev
operator|->
name|minimum
operator|)
condition|)
return|return
operator|(
name|DOIO_SOFT
operator|)
return|;
comment|/* 	 * Full reads are posted, or partials if partials are ok. 	 */
name|dev
operator|->
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
return|return
operator|(
name|DOIO_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns:  *	DOIO_SUCCESS	The operation succeeded.  dev->result contains  *			ISC_R_SUCCESS.  *  *	DOIO_HARD	A hard or unexpected I/O error was encountered.  *			dev->result contains the appropriate error.  *  *	DOIO_SOFT	A soft I/O error was encountered.  No senddone  *			event was sent.  The operation should be retried.  *  *	No other return values are possible.  */
end_comment

begin_function
specifier|static
name|int
name|doio_send
parameter_list|(
name|isc__socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socketevent_t
modifier|*
name|dev
parameter_list|)
block|{
name|int
name|cc
decl_stmt|;
name|struct
name|iovec
name|iov
index|[
name|MAXSCATTERGATHER_SEND
index|]
decl_stmt|;
name|size_t
name|write_count
decl_stmt|;
name|struct
name|msghdr
name|msghdr
decl_stmt|;
name|char
name|addrbuf
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
name|int
name|attempts
init|=
literal|0
decl_stmt|;
name|int
name|send_errno
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|build_msghdr_send
argument_list|(
name|sock
argument_list|,
name|dev
argument_list|,
operator|&
name|msghdr
argument_list|,
name|iov
argument_list|,
operator|&
name|write_count
argument_list|)
expr_stmt|;
name|resend
label|:
name|cc
operator|=
name|sendmsg
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
operator|&
name|msghdr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|send_errno
operator|=
name|errno
expr_stmt|;
comment|/* 	 * Check for error or block condition. 	 */
if|if
condition|(
name|cc
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|send_errno
operator|==
name|EINTR
operator|&&
operator|++
name|attempts
operator|<
name|NRETRIES
condition|)
goto|goto
name|resend
goto|;
if|if
condition|(
name|SOFT_ERROR
argument_list|(
name|send_errno
argument_list|)
condition|)
return|return
operator|(
name|DOIO_SOFT
operator|)
return|;
define|#
directive|define
name|SOFT_OR_HARD
parameter_list|(
name|_system
parameter_list|,
name|_isc
parameter_list|)
define|\
value|if (send_errno == _system) { \ 		if (sock->connected) { \ 			dev->result = _isc; \ 			inc_stats(sock->manager->stats, \ 				  sock->statsindex[STATID_SENDFAIL]); \ 			return (DOIO_HARD); \ 		} \ 		return (DOIO_SOFT); \ 	}
define|#
directive|define
name|ALWAYS_HARD
parameter_list|(
name|_system
parameter_list|,
name|_isc
parameter_list|)
define|\
value|if (send_errno == _system) { \ 		dev->result = _isc; \ 		inc_stats(sock->manager->stats, \ 			  sock->statsindex[STATID_SENDFAIL]); \ 		return (DOIO_HARD); \ 	}
name|SOFT_OR_HARD
argument_list|(
name|ECONNREFUSED
argument_list|,
name|ISC_R_CONNREFUSED
argument_list|)
expr_stmt|;
name|ALWAYS_HARD
argument_list|(
name|EACCES
argument_list|,
name|ISC_R_NOPERM
argument_list|)
expr_stmt|;
name|ALWAYS_HARD
argument_list|(
name|EAFNOSUPPORT
argument_list|,
name|ISC_R_ADDRNOTAVAIL
argument_list|)
expr_stmt|;
name|ALWAYS_HARD
argument_list|(
name|EADDRNOTAVAIL
argument_list|,
name|ISC_R_ADDRNOTAVAIL
argument_list|)
expr_stmt|;
name|ALWAYS_HARD
argument_list|(
name|EHOSTUNREACH
argument_list|,
name|ISC_R_HOSTUNREACH
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EHOSTDOWN
name|ALWAYS_HARD
argument_list|(
name|EHOSTDOWN
argument_list|,
name|ISC_R_HOSTUNREACH
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ALWAYS_HARD
argument_list|(
name|ENETUNREACH
argument_list|,
name|ISC_R_NETUNREACH
argument_list|)
expr_stmt|;
name|ALWAYS_HARD
argument_list|(
name|ENOBUFS
argument_list|,
name|ISC_R_NORESOURCES
argument_list|)
expr_stmt|;
name|ALWAYS_HARD
argument_list|(
name|EPERM
argument_list|,
name|ISC_R_HOSTUNREACH
argument_list|)
expr_stmt|;
name|ALWAYS_HARD
argument_list|(
name|EPIPE
argument_list|,
name|ISC_R_NOTCONNECTED
argument_list|)
expr_stmt|;
name|ALWAYS_HARD
argument_list|(
name|ECONNRESET
argument_list|,
name|ISC_R_CONNECTIONRESET
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|SOFT_OR_HARD
undef|#
directive|undef
name|ALWAYS_HARD
comment|/* 		 * The other error types depend on whether or not the 		 * socket is UDP or TCP.  If it is UDP, some errors 		 * that we expect to be fatal under TCP are merely 		 * annoying, and are really soft errors. 		 * 		 * However, these soft errors are still returned as 		 * a status. 		 */
name|isc_sockaddr_format
argument_list|(
operator|&
name|dev
operator|->
name|address
argument_list|,
name|addrbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|addrbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc__strerror
argument_list|(
name|send_errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"internal_send: %s: %s"
argument_list|,
name|addrbuf
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
name|dev
operator|->
name|result
operator|=
name|isc__errno2result
argument_list|(
name|send_errno
argument_list|)
expr_stmt|;
name|inc_stats
argument_list|(
name|sock
operator|->
name|manager
operator|->
name|stats
argument_list|,
name|sock
operator|->
name|statsindex
index|[
name|STATID_SENDFAIL
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|DOIO_HARD
operator|)
return|;
block|}
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
block|{
name|inc_stats
argument_list|(
name|sock
operator|->
name|manager
operator|->
name|stats
argument_list|,
name|sock
operator|->
name|statsindex
index|[
name|STATID_SENDFAIL
index|]
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"doio_send: send() %s 0"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_RETURNED
argument_list|,
literal|"returned"
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we write less than we expected, update counters, poke. 	 */
name|dev
operator|->
name|n
operator|+=
name|cc
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|cc
operator|!=
name|write_count
condition|)
return|return
operator|(
name|DOIO_SOFT
operator|)
return|;
comment|/* 	 * Exactly what we wanted to write.  We're done with this 	 * entry.  Post its completion event. 	 */
name|dev
operator|->
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
return|return
operator|(
name|DOIO_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Kill.  *  * Caller must ensure that the socket is not locked and no external  * references exist.  */
end_comment

begin_function
specifier|static
name|void
name|closesocket
parameter_list|(
name|isc__socketmgr_t
modifier|*
name|manager
parameter_list|,
name|isc__socket_t
modifier|*
name|sock
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|isc_sockettype_t
name|type
init|=
name|sock
operator|->
name|type
decl_stmt|;
name|int
name|lockid
init|=
name|FDLOCK_ID
argument_list|(
name|fd
argument_list|)
decl_stmt|;
comment|/* 	 * No one has this socket open, so the watcher doesn't have to be 	 * poked, and the socket doesn't have to be locked. 	 */
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|fdlock
index|[
name|lockid
index|]
argument_list|)
expr_stmt|;
name|manager
operator|->
name|fds
index|[
name|fd
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|isc_sockettype_fdwatch
condition|)
name|manager
operator|->
name|fdstate
index|[
name|fd
index|]
operator|=
name|CLOSED
expr_stmt|;
else|else
name|manager
operator|->
name|fdstate
index|[
name|fd
index|]
operator|=
name|CLOSE_PENDING
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|fdlock
index|[
name|lockid
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|isc_sockettype_fdwatch
condition|)
block|{
comment|/* 		 * The caller may close the socket once this function returns, 		 * and `fd' may be reassigned for a new socket.  So we do 		 * unwatch_fd() here, rather than defer it via select_poke(). 		 * Note: this may complicate data protection among threads and 		 * may reduce performance due to additional locks.  One way to 		 * solve this would be to dup() the watched descriptor, but we 		 * take a simpler approach at this moment. 		 */
operator|(
name|void
operator|)
name|unwatch_fd
argument_list|(
name|manager
argument_list|,
name|fd
argument_list|,
name|SELECT_POKE_READ
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unwatch_fd
argument_list|(
name|manager
argument_list|,
name|fd
argument_list|,
name|SELECT_POKE_WRITE
argument_list|)
expr_stmt|;
block|}
else|else
name|select_poke
argument_list|(
name|manager
argument_list|,
name|fd
argument_list|,
name|SELECT_POKE_CLOSE
argument_list|)
expr_stmt|;
name|inc_stats
argument_list|(
name|manager
operator|->
name|stats
argument_list|,
name|sock
operator|->
name|statsindex
index|[
name|STATID_CLOSE
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * update manager->maxfd here (XXX: this should be implemented more 	 * efficiently) 	 */
ifdef|#
directive|ifdef
name|USE_SELECT
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|maxfd
operator|==
name|fd
condition|)
block|{
name|int
name|i
decl_stmt|;
name|manager
operator|->
name|maxfd
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|fd
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|lockid
operator|=
name|FDLOCK_ID
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|fdlock
index|[
name|lockid
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|fdstate
index|[
name|i
index|]
operator|==
name|MANAGED
condition|)
block|{
name|manager
operator|->
name|maxfd
operator|=
name|i
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|fdlock
index|[
name|lockid
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|fdlock
index|[
name|lockid
index|]
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ISC_PLATFORM_USETHREADS
if|if
condition|(
name|manager
operator|->
name|maxfd
operator|<
name|manager
operator|->
name|pipe_fds
index|[
literal|0
index|]
condition|)
name|manager
operator|->
name|maxfd
operator|=
name|manager
operator|->
name|pipe_fds
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
block|}
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_SELECT */
block|}
end_function

begin_function
specifier|static
name|void
name|destroy
parameter_list|(
name|isc__socket_t
modifier|*
modifier|*
name|sockp
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|isc__socket_t
modifier|*
name|sock
init|=
operator|*
name|sockp
decl_stmt|;
name|isc__socketmgr_t
modifier|*
name|manager
init|=
name|sock
operator|->
name|manager
decl_stmt|;
name|socket_log
argument_list|(
name|sock
argument_list|,
name|NULL
argument_list|,
name|CREATION
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_DESTROYING
argument_list|,
literal|"destroying"
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|accept_list
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|send_list
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|connect_ev
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sock
operator|->
name|fd
operator|==
operator|-
literal|1
operator|||
name|sock
operator|->
name|fd
operator|<
operator|(
name|int
operator|)
name|manager
operator|->
name|maxsocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|fd
operator|>=
literal|0
condition|)
block|{
name|fd
operator|=
name|sock
operator|->
name|fd
expr_stmt|;
name|sock
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|closesocket
argument_list|(
name|manager
argument_list|,
name|sock
argument_list|,
name|fd
argument_list|)
expr_stmt|;
block|}
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ISC_LIST_UNLINK
argument_list|(
name|manager
operator|->
name|socklist
argument_list|,
name|sock
argument_list|,
name|link
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_WATCHER_THREAD
if|if
condition|(
name|ISC_LIST_EMPTY
argument_list|(
name|manager
operator|->
name|socklist
argument_list|)
condition|)
name|SIGNAL
argument_list|(
operator|&
name|manager
operator|->
name|shutdown_ok
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_WATCHER_THREAD */
comment|/* can't unlock manager as its memory context is still used */
name|free_socket
argument_list|(
name|sockp
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|allocate_socket
parameter_list|(
name|isc__socketmgr_t
modifier|*
name|manager
parameter_list|,
name|isc_sockettype_t
name|type
parameter_list|,
name|isc__socket_t
modifier|*
modifier|*
name|socketp
parameter_list|)
block|{
name|isc__socket_t
modifier|*
name|sock
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|ISC_SOCKADDR_LEN_T
name|cmsgbuflen
decl_stmt|;
name|sock
operator|=
name|isc_mem_get
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
name|sock
operator|->
name|common
operator|.
name|magic
operator|=
literal|0
expr_stmt|;
name|sock
operator|->
name|common
operator|.
name|impmagic
operator|=
literal|0
expr_stmt|;
name|sock
operator|->
name|references
operator|=
literal|0
expr_stmt|;
name|sock
operator|->
name|manager
operator|=
name|manager
expr_stmt|;
name|sock
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|sock
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|sock
operator|->
name|statsindex
operator|=
name|NULL
expr_stmt|;
name|ISC_LINK_INIT
argument_list|(
name|sock
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|sock
operator|->
name|recvcmsgbuf
operator|=
name|NULL
expr_stmt|;
name|sock
operator|->
name|sendcmsgbuf
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * set up cmsg buffers 	 */
name|cmsgbuflen
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_CMSG
argument_list|)
operator|&&
name|defined
argument_list|(
name|ISC_PLATFORM_HAVEIN6PKTINFO
argument_list|)
name|cmsgbuflen
operator|+=
name|cmsg_space
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_pktinfo
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|USE_CMSG
argument_list|)
operator|&&
name|defined
argument_list|(
name|SO_TIMESTAMP
argument_list|)
name|cmsgbuflen
operator|+=
name|cmsg_space
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|timeval
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sock
operator|->
name|recvcmsgbuflen
operator|=
name|cmsgbuflen
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|recvcmsgbuflen
operator|!=
literal|0U
condition|)
block|{
name|sock
operator|->
name|recvcmsgbuf
operator|=
name|isc_mem_get
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|cmsgbuflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|recvcmsgbuf
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
block|}
name|cmsgbuflen
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_CMSG
argument_list|)
operator|&&
name|defined
argument_list|(
name|ISC_PLATFORM_HAVEIN6PKTINFO
argument_list|)
name|cmsgbuflen
operator|+=
name|cmsg_space
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_pktinfo
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|IPV6_USE_MIN_MTU
argument_list|)
comment|/* 	 * Provide space for working around FreeBSD's broken IPV6_USE_MIN_MTU 	 * support. 	 */
name|cmsgbuflen
operator|+=
name|cmsg_space
argument_list|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
name|sock
operator|->
name|sendcmsgbuflen
operator|=
name|cmsgbuflen
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|sendcmsgbuflen
operator|!=
literal|0U
condition|)
block|{
name|sock
operator|->
name|sendcmsgbuf
operator|=
name|isc_mem_get
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|cmsgbuflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|sendcmsgbuf
operator|==
name|NULL
condition|)
goto|goto
name|error
goto|;
block|}
name|memset
argument_list|(
name|sock
operator|->
name|name
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sock
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|sock
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * set up list of readers and writers to be initially empty 	 */
name|ISC_LIST_INIT
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|sock
operator|->
name|send_list
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|sock
operator|->
name|accept_list
argument_list|)
expr_stmt|;
name|sock
operator|->
name|connect_ev
operator|=
name|NULL
expr_stmt|;
name|sock
operator|->
name|pending_recv
operator|=
literal|0
expr_stmt|;
name|sock
operator|->
name|pending_send
operator|=
literal|0
expr_stmt|;
name|sock
operator|->
name|pending_accept
operator|=
literal|0
expr_stmt|;
name|sock
operator|->
name|listener
operator|=
literal|0
expr_stmt|;
name|sock
operator|->
name|connected
operator|=
literal|0
expr_stmt|;
name|sock
operator|->
name|connecting
operator|=
literal|0
expr_stmt|;
name|sock
operator|->
name|bound
operator|=
literal|0
expr_stmt|;
comment|/* 	 * initialize the lock 	 */
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|sock
operator|->
name|common
operator|.
name|magic
operator|=
literal|0
expr_stmt|;
name|sock
operator|->
name|common
operator|.
name|impmagic
operator|=
literal|0
expr_stmt|;
goto|goto
name|error
goto|;
block|}
comment|/* 	 * Initialize readable and writable events 	 */
name|ISC_EVENT_INIT
argument_list|(
operator|&
name|sock
operator|->
name|readable_ev
argument_list|,
sizeof|sizeof
argument_list|(
name|intev_t
argument_list|)
argument_list|,
name|ISC_EVENTATTR_NOPURGE
argument_list|,
name|NULL
argument_list|,
name|ISC_SOCKEVENT_INTR
argument_list|,
name|NULL
argument_list|,
name|sock
argument_list|,
name|sock
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ISC_EVENT_INIT
argument_list|(
operator|&
name|sock
operator|->
name|writable_ev
argument_list|,
sizeof|sizeof
argument_list|(
name|intev_t
argument_list|)
argument_list|,
name|ISC_EVENTATTR_NOPURGE
argument_list|,
name|NULL
argument_list|,
name|ISC_SOCKEVENT_INTW
argument_list|,
name|NULL
argument_list|,
name|sock
argument_list|,
name|sock
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sock
operator|->
name|common
operator|.
name|magic
operator|=
name|ISCAPI_SOCKET_MAGIC
expr_stmt|;
name|sock
operator|->
name|common
operator|.
name|impmagic
operator|=
name|SOCKET_MAGIC
expr_stmt|;
operator|*
name|socketp
operator|=
name|sock
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|error
label|:
if|if
condition|(
name|sock
operator|->
name|recvcmsgbuf
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|sock
operator|->
name|recvcmsgbuf
argument_list|,
name|sock
operator|->
name|recvcmsgbuflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|sendcmsgbuf
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|sock
operator|->
name|sendcmsgbuf
argument_list|,
name|sock
operator|->
name|sendcmsgbuflen
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|sock
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sock
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This event requires that the various lists be empty, that the reference  * count be 1, and that the magic number is valid.  The other socket bits,  * like the lock, must be initialized as well.  The fd associated must be  * marked as closed, by setting it to -1 on close, or this routine will  * also close the socket.  */
end_comment

begin_function
specifier|static
name|void
name|free_socket
parameter_list|(
name|isc__socket_t
modifier|*
modifier|*
name|socketp
parameter_list|)
block|{
name|isc__socket_t
modifier|*
name|sock
init|=
operator|*
name|socketp
decl_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|references
operator|==
literal|0
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|sock
operator|->
name|connecting
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|sock
operator|->
name|pending_recv
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|sock
operator|->
name|pending_send
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|sock
operator|->
name|pending_accept
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|send_list
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|accept_list
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|ISC_LINK_LINKED
argument_list|(
name|sock
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|recvcmsgbuf
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|sock
operator|->
name|manager
operator|->
name|mctx
argument_list|,
name|sock
operator|->
name|recvcmsgbuf
argument_list|,
name|sock
operator|->
name|recvcmsgbuflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|sendcmsgbuf
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|sock
operator|->
name|manager
operator|->
name|mctx
argument_list|,
name|sock
operator|->
name|sendcmsgbuf
argument_list|,
name|sock
operator|->
name|sendcmsgbuflen
argument_list|)
expr_stmt|;
name|sock
operator|->
name|common
operator|.
name|magic
operator|=
literal|0
expr_stmt|;
name|sock
operator|->
name|common
operator|.
name|impmagic
operator|=
literal|0
expr_stmt|;
name|DESTROYLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|sock
operator|->
name|manager
operator|->
name|mctx
argument_list|,
name|sock
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sock
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|socketp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SO_BSDCOMPAT
end_ifdef

begin_comment
comment|/*  * This really should not be necessary to do.  Having to workout  * which kernel version we are on at run time so that we don't cause  * the kernel to issue a warning about us using a deprecated socket option.  * Such warnings should *never* be on by default in production kernels.  *  * We can't do this a build time because executables are moved between  * machines and hence kernels.  *  * We can't just not set SO_BSDCOMAT because some kernels require it.  */
end_comment

begin_decl_stmt
specifier|static
name|isc_once_t
name|bsdcompat_once
init|=
name|ISC_ONCE_INIT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|isc_boolean_t
name|bsdcompat
init|=
name|ISC_TRUE
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|clear_bsdcompat
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|__linux__
name|struct
name|utsname
name|buf
decl_stmt|;
name|char
modifier|*
name|endp
decl_stmt|;
name|long
name|int
name|major
decl_stmt|;
name|long
name|int
name|minor
decl_stmt|;
name|uname
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
comment|/* Can only fail if buf is bad in Linux. */
comment|/* Paranoia in parsing can be increased, but we trust uname(). */
name|major
operator|=
name|strtol
argument_list|(
name|buf
operator|.
name|release
argument_list|,
operator|&
name|endp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endp
operator|==
literal|'.'
condition|)
block|{
name|minor
operator|=
name|strtol
argument_list|(
name|endp
operator|+
literal|1
argument_list|,
operator|&
name|endp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|major
operator|>
literal|2
operator|)
operator|||
operator|(
operator|(
name|major
operator|==
literal|2
operator|)
operator|&&
operator|(
name|minor
operator|>=
literal|4
operator|)
operator|)
condition|)
block|{
name|bsdcompat
operator|=
name|ISC_FALSE
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* __linux __ */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|isc_result_t
name|opensocket
parameter_list|(
name|isc__socketmgr_t
modifier|*
name|manager
parameter_list|,
name|isc__socket_t
modifier|*
name|sock
parameter_list|)
block|{
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|err
init|=
literal|"socket"
decl_stmt|;
name|int
name|tries
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_CMSG
argument_list|)
operator|||
name|defined
argument_list|(
name|SO_BSDCOMPAT
argument_list|)
name|int
name|on
init|=
literal|1
decl_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SO_RCVBUF
argument_list|)
name|ISC_SOCKADDR_LEN_T
name|optlen
decl_stmt|;
name|int
name|size
decl_stmt|;
endif|#
directive|endif
name|again
label|:
switch|switch
condition|(
name|sock
operator|->
name|type
condition|)
block|{
case|case
name|isc_sockettype_udp
case|:
name|sock
operator|->
name|fd
operator|=
name|socket
argument_list|(
name|sock
operator|->
name|pf
argument_list|,
name|SOCK_DGRAM
argument_list|,
name|IPPROTO_UDP
argument_list|)
expr_stmt|;
break|break;
case|case
name|isc_sockettype_tcp
case|:
name|sock
operator|->
name|fd
operator|=
name|socket
argument_list|(
name|sock
operator|->
name|pf
argument_list|,
name|SOCK_STREAM
argument_list|,
name|IPPROTO_TCP
argument_list|)
expr_stmt|;
break|break;
case|case
name|isc_sockettype_unix
case|:
name|sock
operator|->
name|fd
operator|=
name|socket
argument_list|(
name|sock
operator|->
name|pf
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|isc_sockettype_fdwatch
case|:
comment|/* 		 * We should not be called for isc_sockettype_fdwatch sockets. 		 */
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sock
operator|->
name|fd
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
operator|&&
name|tries
operator|++
operator|<
literal|42
condition|)
goto|goto
name|again
goto|;
ifdef|#
directive|ifdef
name|F_DUPFD
comment|/* 	 * Leave a space for stdio and TCP to work in. 	 */
if|if
condition|(
name|manager
operator|->
name|reserved
operator|!=
literal|0
operator|&&
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_udp
operator|&&
name|sock
operator|->
name|fd
operator|>=
literal|0
operator|&&
name|sock
operator|->
name|fd
operator|<
name|manager
operator|->
name|reserved
condition|)
block|{
name|int
name|new
decl_stmt|,
name|tmp
decl_stmt|;
name|new
operator|=
name|fcntl
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|F_DUPFD
argument_list|,
name|manager
operator|->
name|reserved
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sock
operator|->
name|fd
argument_list|)
expr_stmt|;
name|errno
operator|=
name|tmp
expr_stmt|;
name|sock
operator|->
name|fd
operator|=
name|new
expr_stmt|;
name|err
operator|=
literal|"isc_socket_create: fcntl/reserved"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sock
operator|->
name|fd
operator|>=
literal|0
operator|&&
name|sock
operator|->
name|fd
operator|<
literal|20
condition|)
block|{
name|int
name|new
decl_stmt|,
name|tmp
decl_stmt|;
name|new
operator|=
name|fcntl
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|F_DUPFD
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sock
operator|->
name|fd
argument_list|)
expr_stmt|;
name|errno
operator|=
name|tmp
expr_stmt|;
name|sock
operator|->
name|fd
operator|=
name|new
expr_stmt|;
name|err
operator|=
literal|"isc_socket_create: fcntl"
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|sock
operator|->
name|fd
operator|>=
operator|(
name|int
operator|)
name|manager
operator|->
name|maxsocks
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|sock
operator|->
name|fd
argument_list|)
expr_stmt|;
name|isc_log_iwrite
argument_list|(
name|isc_lctx
argument_list|,
name|ISC_LOGCATEGORY_GENERAL
argument_list|,
name|ISC_LOGMODULE_SOCKET
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_TOOMANYFDS
argument_list|,
literal|"socket: file descriptor exceeds limit (%d/%u)"
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|manager
operator|->
name|maxsocks
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NORESOURCES
operator|)
return|;
block|}
if|if
condition|(
name|sock
operator|->
name|fd
operator|<
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EMFILE
case|:
case|case
name|ENFILE
case|:
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_iwrite
argument_list|(
name|isc_lctx
argument_list|,
name|ISC_LOGCATEGORY_GENERAL
argument_list|,
name|ISC_LOGMODULE_SOCKET
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_TOOMANYFDS
argument_list|,
literal|"%s: %s"
argument_list|,
name|err
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
comment|/* fallthrough */
case|case
name|ENOBUFS
case|:
return|return
operator|(
name|ISC_R_NORESOURCES
operator|)
return|;
case|case
name|EPROTONOSUPPORT
case|:
case|case
name|EPFNOSUPPORT
case|:
case|case
name|EAFNOSUPPORT
case|:
comment|/* 		 * Linux 2.2 (and maybe others) return EINVAL instead of 		 * EAFNOSUPPORT. 		 */
case|case
name|EINVAL
case|:
return|return
operator|(
name|ISC_R_FAMILYNOSUPPORT
operator|)
return|;
default|default:
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"%s() %s: %s"
argument_list|,
name|err
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
block|}
if|if
condition|(
name|make_nonblock
argument_list|(
name|sock
operator|->
name|fd
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|sock
operator|->
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|SO_BSDCOMPAT
name|RUNTIME_CHECK
argument_list|(
name|isc_once_do
argument_list|(
operator|&
name|bsdcompat_once
argument_list|,
name|clear_bsdcompat
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|type
operator|!=
name|isc_sockettype_unix
operator|&&
name|bsdcompat
operator|&&
name|setsockopt
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_BSDCOMPAT
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"setsockopt(%d, SO_BSDCOMPAT) %s: %s"
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
comment|/* Press on... */
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SO_NOSIGPIPE
if|if
condition|(
name|setsockopt
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_NOSIGPIPE
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"setsockopt(%d, SO_NOSIGPIPE) %s: %s"
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
comment|/* Press on... */
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|USE_CMSG
argument_list|)
operator|||
name|defined
argument_list|(
name|SO_RCVBUF
argument_list|)
if|if
condition|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_udp
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|USE_CMSG
argument_list|)
if|#
directive|if
name|defined
argument_list|(
name|SO_TIMESTAMP
argument_list|)
if|if
condition|(
name|setsockopt
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_TIMESTAMP
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOPROTOOPT
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"setsockopt(%d, SO_TIMESTAMP) %s: %s"
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
comment|/* Press on... */
block|}
endif|#
directive|endif
comment|/* SO_TIMESTAMP */
if|#
directive|if
name|defined
argument_list|(
name|ISC_PLATFORM_HAVEIPV6
argument_list|)
if|if
condition|(
name|sock
operator|->
name|pf
operator|==
name|AF_INET6
operator|&&
name|sock
operator|->
name|recvcmsgbuflen
operator|==
literal|0U
condition|)
block|{
comment|/* 			 * Warn explicitly because this anomaly can be hidden 			 * in usual operation (and unexpectedly appear later). 			 */
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"No buffer available to receive "
literal|"IPv6 destination"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ISC_PLATFORM_HAVEIN6PKTINFO
ifdef|#
directive|ifdef
name|IPV6_RECVPKTINFO
comment|/* RFC 3542 */
if|if
condition|(
operator|(
name|sock
operator|->
name|pf
operator|==
name|AF_INET6
operator|)
operator|&&
operator|(
name|setsockopt
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_RECVPKTINFO
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"setsockopt(%d, IPV6_RECVPKTINFO) "
literal|"%s: %s"
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* RFC 2292 */
if|if
condition|(
operator|(
name|sock
operator|->
name|pf
operator|==
name|AF_INET6
operator|)
operator|&&
operator|(
name|setsockopt
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_PKTINFO
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"setsockopt(%d, IPV6_PKTINFO) %s: %s"
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* IPV6_RECVPKTINFO */
endif|#
directive|endif
comment|/* ISC_PLATFORM_HAVEIN6PKTINFO */
ifdef|#
directive|ifdef
name|IPV6_USE_MIN_MTU
comment|/* RFC 3542, not too common yet*/
comment|/* use minimum MTU */
if|if
condition|(
name|sock
operator|->
name|pf
operator|==
name|AF_INET6
operator|&&
name|setsockopt
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_USE_MIN_MTU
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"setsockopt(%d, IPV6_USE_MIN_MTU) "
literal|"%s: %s"
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|IPV6_MTU
argument_list|)
comment|/* 		 * Use minimum MTU on IPv6 sockets. 		 */
if|if
condition|(
name|sock
operator|->
name|pf
operator|==
name|AF_INET6
condition|)
block|{
name|int
name|mtu
init|=
literal|1280
decl_stmt|;
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_MTU
argument_list|,
operator|&
name|mtu
argument_list|,
sizeof|sizeof
argument_list|(
name|mtu
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|IPV6_MTU_DISCOVER
argument_list|)
operator|&&
name|defined
argument_list|(
name|IPV6_PMTUDISC_DONT
argument_list|)
comment|/* 		 * Turn off Path MTU discovery on IPv6/UDP sockets. 		 */
if|if
condition|(
name|sock
operator|->
name|pf
operator|==
name|AF_INET6
condition|)
block|{
name|int
name|action
init|=
name|IPV6_PMTUDISC_DONT
decl_stmt|;
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_MTU_DISCOVER
argument_list|,
operator|&
name|action
argument_list|,
sizeof|sizeof
argument_list|(
name|action
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
comment|/* ISC_PLATFORM_HAVEIPV6 */
endif|#
directive|endif
comment|/* defined(USE_CMSG) */
if|#
directive|if
name|defined
argument_list|(
name|IP_MTU_DISCOVER
argument_list|)
operator|&&
name|defined
argument_list|(
name|IP_PMTUDISC_DONT
argument_list|)
comment|/* 		 * Turn off Path MTU discovery on IPv4/UDP sockets. 		 */
if|if
condition|(
name|sock
operator|->
name|pf
operator|==
name|AF_INET
condition|)
block|{
name|int
name|action
init|=
name|IP_PMTUDISC_DONT
decl_stmt|;
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_MTU_DISCOVER
argument_list|,
operator|&
name|action
argument_list|,
sizeof|sizeof
argument_list|(
name|action
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|IP_DONTFRAG
argument_list|)
comment|/* 		 * Turn off Path MTU discovery on IPv4/UDP sockets. 		 */
if|if
condition|(
name|sock
operator|->
name|pf
operator|==
name|AF_INET
condition|)
block|{
name|int
name|off
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_DONTFRAG
argument_list|,
operator|&
name|off
argument_list|,
sizeof|sizeof
argument_list|(
name|off
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|SO_RCVBUF
argument_list|)
name|optlen
operator|=
sizeof|sizeof
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockopt
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_RCVBUF
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|size
argument_list|,
operator|&
name|optlen
argument_list|)
operator|>=
literal|0
operator|&&
name|size
operator|<
name|RCVBUFSIZE
condition|)
block|{
name|size
operator|=
name|RCVBUFSIZE
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_RCVBUF
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|size
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"setsockopt(%d, SO_RCVBUF, %d) %s: %s"
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|size
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* defined(USE_CMSG) || defined(SO_RCVBUF) */
name|inc_stats
argument_list|(
name|manager
operator|->
name|stats
argument_list|,
name|sock
operator|->
name|statsindex
index|[
name|STATID_OPEN
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*%  * Create a new 'type' socket managed by 'manager'.  Events  * will be posted to 'task' and when dispatched 'action' will be  * called with 'arg' as the arg value.  The new socket is returned  * in 'socketp'.  */
end_comment

begin_function
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_create
parameter_list|(
name|isc_socketmgr_t
modifier|*
name|manager0
parameter_list|,
name|int
name|pf
parameter_list|,
name|isc_sockettype_t
name|type
parameter_list|,
name|isc_socket_t
modifier|*
modifier|*
name|socketp
parameter_list|)
block|{
name|isc__socket_t
modifier|*
name|sock
init|=
name|NULL
decl_stmt|;
name|isc__socketmgr_t
modifier|*
name|manager
init|=
operator|(
name|isc__socketmgr_t
operator|*
operator|)
name|manager0
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|int
name|lockid
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|socketp
operator|!=
name|NULL
operator|&&
operator|*
name|socketp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|type
operator|!=
name|isc_sockettype_fdwatch
argument_list|)
expr_stmt|;
name|result
operator|=
name|allocate_socket
argument_list|(
name|manager
argument_list|,
name|type
argument_list|,
operator|&
name|sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
switch|switch
condition|(
name|sock
operator|->
name|type
condition|)
block|{
case|case
name|isc_sockettype_udp
case|:
name|sock
operator|->
name|statsindex
operator|=
operator|(
name|pf
operator|==
name|AF_INET
operator|)
condition|?
name|upd4statsindex
else|:
name|upd6statsindex
expr_stmt|;
break|break;
case|case
name|isc_sockettype_tcp
case|:
name|sock
operator|->
name|statsindex
operator|=
operator|(
name|pf
operator|==
name|AF_INET
operator|)
condition|?
name|tcp4statsindex
else|:
name|tcp6statsindex
expr_stmt|;
break|break;
case|case
name|isc_sockettype_unix
case|:
name|sock
operator|->
name|statsindex
operator|=
name|unixstatsindex
expr_stmt|;
break|break;
default|default:
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|sock
operator|->
name|pf
operator|=
name|pf
expr_stmt|;
name|result
operator|=
name|opensocket
argument_list|(
name|manager
argument_list|,
name|sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|inc_stats
argument_list|(
name|manager
operator|->
name|stats
argument_list|,
name|sock
operator|->
name|statsindex
index|[
name|STATID_OPENFAIL
index|]
argument_list|)
expr_stmt|;
name|free_socket
argument_list|(
operator|&
name|sock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|sock
operator|->
name|common
operator|.
name|methods
operator|=
operator|(
name|isc_socketmethods_t
operator|*
operator|)
operator|&
name|socketmethods
expr_stmt|;
name|sock
operator|->
name|references
operator|=
literal|1
expr_stmt|;
operator|*
name|socketp
operator|=
operator|(
name|isc_socket_t
operator|*
operator|)
name|sock
expr_stmt|;
comment|/* 	 * Note we don't have to lock the socket like we normally would because 	 * there are no external references to it yet. 	 */
name|lockid
operator|=
name|FDLOCK_ID
argument_list|(
name|sock
operator|->
name|fd
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|fdlock
index|[
name|lockid
index|]
argument_list|)
expr_stmt|;
name|manager
operator|->
name|fds
index|[
name|sock
operator|->
name|fd
index|]
operator|=
name|sock
expr_stmt|;
name|manager
operator|->
name|fdstate
index|[
name|sock
operator|->
name|fd
index|]
operator|=
name|MANAGED
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_DEVPOLL
name|INSIST
argument_list|(
name|sock
operator|->
name|manager
operator|->
name|fdpollinfo
index|[
name|sock
operator|->
name|fd
index|]
operator|.
name|want_read
operator|==
literal|0
operator|&&
name|sock
operator|->
name|manager
operator|->
name|fdpollinfo
index|[
name|sock
operator|->
name|fd
index|]
operator|.
name|want_write
operator|==
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|fdlock
index|[
name|lockid
index|]
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|manager
operator|->
name|socklist
argument_list|,
name|sock
argument_list|,
name|link
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_SELECT
if|if
condition|(
name|manager
operator|->
name|maxfd
operator|<
name|sock
operator|->
name|fd
condition|)
name|manager
operator|->
name|maxfd
operator|=
name|sock
operator|->
name|fd
expr_stmt|;
endif|#
directive|endif
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|socket_log
argument_list|(
name|sock
argument_list|,
name|NULL
argument_list|,
name|CREATION
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_CREATED
argument_list|,
literal|"created"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BIND9
end_ifdef

begin_function
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_open
parameter_list|(
name|isc_socket_t
modifier|*
name|sock0
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
name|isc__socket_t
modifier|*
name|sock
init|=
operator|(
name|isc__socket_t
operator|*
operator|)
name|sock0
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sock
operator|->
name|references
operator|==
literal|1
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sock
operator|->
name|type
operator|!=
name|isc_sockettype_fdwatch
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * We don't need to retain the lock hereafter, since no one else has 	 * this socket. 	 */
name|REQUIRE
argument_list|(
name|sock
operator|->
name|fd
operator|==
operator|-
literal|1
argument_list|)
expr_stmt|;
name|result
operator|=
name|opensocket
argument_list|(
name|sock
operator|->
name|manager
argument_list|,
name|sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
name|sock
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ISC_R_SUCCESS
condition|)
block|{
name|int
name|lockid
init|=
name|FDLOCK_ID
argument_list|(
name|sock
operator|->
name|fd
argument_list|)
decl_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|manager
operator|->
name|fdlock
index|[
name|lockid
index|]
argument_list|)
expr_stmt|;
name|sock
operator|->
name|manager
operator|->
name|fds
index|[
name|sock
operator|->
name|fd
index|]
operator|=
name|sock
expr_stmt|;
name|sock
operator|->
name|manager
operator|->
name|fdstate
index|[
name|sock
operator|->
name|fd
index|]
operator|=
name|MANAGED
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_DEVPOLL
name|INSIST
argument_list|(
name|sock
operator|->
name|manager
operator|->
name|fdpollinfo
index|[
name|sock
operator|->
name|fd
index|]
operator|.
name|want_read
operator|==
literal|0
operator|&&
name|sock
operator|->
name|manager
operator|->
name|fdpollinfo
index|[
name|sock
operator|->
name|fd
index|]
operator|.
name|want_write
operator|==
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|manager
operator|->
name|fdlock
index|[
name|lockid
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_SELECT
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|manager
operator|->
name|maxfd
operator|<
name|sock
operator|->
name|fd
condition|)
name|sock
operator|->
name|manager
operator|->
name|maxfd
operator|=
name|sock
operator|->
name|fd
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BIND9 */
end_comment

begin_comment
comment|/*  * Create a new 'type' socket managed by 'manager'.  Events  * will be posted to 'task' and when dispatched 'action' will be  * called with 'arg' as the arg value.  The new socket is returned  * in 'socketp'.  */
end_comment

begin_function
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_fdwatchcreate
parameter_list|(
name|isc_socketmgr_t
modifier|*
name|manager0
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|flags
parameter_list|,
name|isc_sockfdwatch_t
name|callback
parameter_list|,
name|void
modifier|*
name|cbarg
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_socket_t
modifier|*
modifier|*
name|socketp
parameter_list|)
block|{
name|isc__socketmgr_t
modifier|*
name|manager
init|=
operator|(
name|isc__socketmgr_t
operator|*
operator|)
name|manager0
decl_stmt|;
name|isc__socket_t
modifier|*
name|sock
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|int
name|lockid
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|socketp
operator|!=
name|NULL
operator|&&
operator|*
name|socketp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|result
operator|=
name|allocate_socket
argument_list|(
name|manager
argument_list|,
name|isc_sockettype_fdwatch
argument_list|,
operator|&
name|sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
return|return
operator|(
name|result
operator|)
return|;
name|sock
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|sock
operator|->
name|fdwatcharg
operator|=
name|cbarg
expr_stmt|;
name|sock
operator|->
name|fdwatchcb
operator|=
name|callback
expr_stmt|;
name|sock
operator|->
name|fdwatchflags
operator|=
name|flags
expr_stmt|;
name|sock
operator|->
name|fdwatchtask
operator|=
name|task
expr_stmt|;
name|sock
operator|->
name|statsindex
operator|=
name|fdwatchstatsindex
expr_stmt|;
name|sock
operator|->
name|common
operator|.
name|methods
operator|=
operator|(
name|isc_socketmethods_t
operator|*
operator|)
operator|&
name|socketmethods
expr_stmt|;
name|sock
operator|->
name|references
operator|=
literal|1
expr_stmt|;
operator|*
name|socketp
operator|=
operator|(
name|isc_socket_t
operator|*
operator|)
name|sock
expr_stmt|;
comment|/* 	 * Note we don't have to lock the socket like we normally would because 	 * there are no external references to it yet. 	 */
name|lockid
operator|=
name|FDLOCK_ID
argument_list|(
name|sock
operator|->
name|fd
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|fdlock
index|[
name|lockid
index|]
argument_list|)
expr_stmt|;
name|manager
operator|->
name|fds
index|[
name|sock
operator|->
name|fd
index|]
operator|=
name|sock
expr_stmt|;
name|manager
operator|->
name|fdstate
index|[
name|sock
operator|->
name|fd
index|]
operator|=
name|MANAGED
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|fdlock
index|[
name|lockid
index|]
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|manager
operator|->
name|socklist
argument_list|,
name|sock
argument_list|,
name|link
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_SELECT
if|if
condition|(
name|manager
operator|->
name|maxfd
operator|<
name|sock
operator|->
name|fd
condition|)
name|manager
operator|->
name|maxfd
operator|=
name|sock
operator|->
name|fd
expr_stmt|;
endif|#
directive|endif
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ISC_SOCKFDWATCH_READ
condition|)
name|select_poke
argument_list|(
name|sock
operator|->
name|manager
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|SELECT_POKE_READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ISC_SOCKFDWATCH_WRITE
condition|)
name|select_poke
argument_list|(
name|sock
operator|->
name|manager
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|SELECT_POKE_WRITE
argument_list|)
expr_stmt|;
name|socket_log
argument_list|(
name|sock
argument_list|,
name|NULL
argument_list|,
name|CREATION
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_CREATED
argument_list|,
literal|"fdwatch-created"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Indicate to the manager that it should watch the socket again.  * This can be used to restart watching if the previous event handler  * didn't indicate there was more data to be processed.  Primarily  * it is for writing but could be used for reading if desired  */
end_comment

begin_function
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_fdwatchpoke
parameter_list|(
name|isc_socket_t
modifier|*
name|sock0
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|isc__socket_t
modifier|*
name|sock
init|=
operator|(
name|isc__socket_t
operator|*
operator|)
name|sock0
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * We check both flags first to allow us to get the lock 	 * once but only if we need it. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
operator|(
name|ISC_SOCKFDWATCH_READ
operator||
name|ISC_SOCKFDWATCH_WRITE
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|ISC_SOCKFDWATCH_READ
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|!
name|sock
operator|->
name|pending_recv
condition|)
name|select_poke
argument_list|(
name|sock
operator|->
name|manager
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|SELECT_POKE_READ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|flags
operator|&
name|ISC_SOCKFDWATCH_WRITE
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|!
name|sock
operator|->
name|pending_send
condition|)
name|select_poke
argument_list|(
name|sock
operator|->
name|manager
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|SELECT_POKE_WRITE
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|socket_log
argument_list|(
name|sock
argument_list|,
name|NULL
argument_list|,
name|TRACE
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_POKED
argument_list|,
literal|"fdwatch-poked flags: %d"
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach to a socket.  Caller must explicitly detach when it is done.  */
end_comment

begin_function
name|ISC_SOCKETFUNC_SCOPE
name|void
name|isc__socket_attach
parameter_list|(
name|isc_socket_t
modifier|*
name|sock0
parameter_list|,
name|isc_socket_t
modifier|*
modifier|*
name|socketp
parameter_list|)
block|{
name|isc__socket_t
modifier|*
name|sock
init|=
operator|(
name|isc__socket_t
operator|*
operator|)
name|sock0
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|socketp
operator|!=
name|NULL
operator|&&
operator|*
name|socketp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|sock
operator|->
name|references
operator|++
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
operator|*
name|socketp
operator|=
operator|(
name|isc_socket_t
operator|*
operator|)
name|sock
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dereference a socket.  If this is the last reference to it, clean things  * up by destroying the socket.  */
end_comment

begin_function
name|ISC_SOCKETFUNC_SCOPE
name|void
name|isc__socket_detach
parameter_list|(
name|isc_socket_t
modifier|*
modifier|*
name|socketp
parameter_list|)
block|{
name|isc__socket_t
modifier|*
name|sock
decl_stmt|;
name|isc_boolean_t
name|kill_socket
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|socketp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sock
operator|=
operator|(
name|isc__socket_t
operator|*
operator|)
operator|*
name|socketp
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sock
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|sock
operator|->
name|references
operator|--
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|references
operator|==
literal|0
condition|)
name|kill_socket
operator|=
name|ISC_TRUE
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|kill_socket
condition|)
name|destroy
argument_list|(
operator|&
name|sock
argument_list|)
expr_stmt|;
operator|*
name|socketp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BIND9
end_ifdef

begin_function
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_close
parameter_list|(
name|isc_socket_t
modifier|*
name|sock0
parameter_list|)
block|{
name|isc__socket_t
modifier|*
name|sock
init|=
operator|(
name|isc__socket_t
operator|*
operator|)
name|sock0
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|isc__socketmgr_t
modifier|*
name|manager
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sock
operator|->
name|references
operator|==
literal|1
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sock
operator|->
name|type
operator|!=
name|isc_sockettype_fdwatch
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sock
operator|->
name|fd
operator|>=
literal|0
operator|&&
name|sock
operator|->
name|fd
operator|<
operator|(
name|int
operator|)
name|sock
operator|->
name|manager
operator|->
name|maxsocks
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|sock
operator|->
name|connecting
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|sock
operator|->
name|pending_recv
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|sock
operator|->
name|pending_send
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|sock
operator|->
name|pending_accept
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|send_list
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|accept_list
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|connect_ev
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|manager
operator|=
name|sock
operator|->
name|manager
expr_stmt|;
name|fd
operator|=
name|sock
operator|->
name|fd
expr_stmt|;
name|sock
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|memset
argument_list|(
name|sock
operator|->
name|name
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sock
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|sock
operator|->
name|tag
operator|=
name|NULL
expr_stmt|;
name|sock
operator|->
name|listener
operator|=
literal|0
expr_stmt|;
name|sock
operator|->
name|connected
operator|=
literal|0
expr_stmt|;
name|sock
operator|->
name|connecting
operator|=
literal|0
expr_stmt|;
name|sock
operator|->
name|bound
operator|=
literal|0
expr_stmt|;
name|isc_sockaddr_any
argument_list|(
operator|&
name|sock
operator|->
name|peer_address
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|closesocket
argument_list|(
name|manager
argument_list|,
name|sock
argument_list|,
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BIND9 */
end_comment

begin_comment
comment|/*  * I/O is possible on a given socket.  Schedule an event to this task that  * will call an internal function to do the I/O.  This will charge the  * task with the I/O operation and let our select loop handler get back  * to doing something real as fast as possible.  *  * The socket and manager must be locked before calling this function.  */
end_comment

begin_function
specifier|static
name|void
name|dispatch_recv
parameter_list|(
name|isc__socket_t
modifier|*
name|sock
parameter_list|)
block|{
name|intev_t
modifier|*
name|iev
decl_stmt|;
name|isc_socketevent_t
modifier|*
name|ev
decl_stmt|;
name|isc_task_t
modifier|*
name|sender
decl_stmt|;
name|INSIST
argument_list|(
operator|!
name|sock
operator|->
name|pending_recv
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|type
operator|!=
name|isc_sockettype_fdwatch
condition|)
block|{
name|ev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|==
name|NULL
condition|)
return|return;
name|socket_log
argument_list|(
name|sock
argument_list|,
name|NULL
argument_list|,
name|EVENT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"dispatch_recv:  event %p -> task %p"
argument_list|,
name|ev
argument_list|,
name|ev
operator|->
name|ev_sender
argument_list|)
expr_stmt|;
name|sender
operator|=
name|ev
operator|->
name|ev_sender
expr_stmt|;
block|}
else|else
block|{
name|sender
operator|=
name|sock
operator|->
name|fdwatchtask
expr_stmt|;
block|}
name|sock
operator|->
name|pending_recv
operator|=
literal|1
expr_stmt|;
name|iev
operator|=
operator|&
name|sock
operator|->
name|readable_ev
expr_stmt|;
name|sock
operator|->
name|references
operator|++
expr_stmt|;
name|iev
operator|->
name|ev_sender
operator|=
name|sock
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_fdwatch
condition|)
name|iev
operator|->
name|ev_action
operator|=
name|internal_fdwatch_read
expr_stmt|;
else|else
name|iev
operator|->
name|ev_action
operator|=
name|internal_recv
expr_stmt|;
name|iev
operator|->
name|ev_arg
operator|=
name|sock
expr_stmt|;
name|isc_task_send
argument_list|(
name|sender
argument_list|,
operator|(
name|isc_event_t
operator|*
operator|*
operator|)
operator|&
name|iev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dispatch_send
parameter_list|(
name|isc__socket_t
modifier|*
name|sock
parameter_list|)
block|{
name|intev_t
modifier|*
name|iev
decl_stmt|;
name|isc_socketevent_t
modifier|*
name|ev
decl_stmt|;
name|isc_task_t
modifier|*
name|sender
decl_stmt|;
name|INSIST
argument_list|(
operator|!
name|sock
operator|->
name|pending_send
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|type
operator|!=
name|isc_sockettype_fdwatch
condition|)
block|{
name|ev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sock
operator|->
name|send_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|==
name|NULL
condition|)
return|return;
name|socket_log
argument_list|(
name|sock
argument_list|,
name|NULL
argument_list|,
name|EVENT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"dispatch_send:  event %p -> task %p"
argument_list|,
name|ev
argument_list|,
name|ev
operator|->
name|ev_sender
argument_list|)
expr_stmt|;
name|sender
operator|=
name|ev
operator|->
name|ev_sender
expr_stmt|;
block|}
else|else
block|{
name|sender
operator|=
name|sock
operator|->
name|fdwatchtask
expr_stmt|;
block|}
name|sock
operator|->
name|pending_send
operator|=
literal|1
expr_stmt|;
name|iev
operator|=
operator|&
name|sock
operator|->
name|writable_ev
expr_stmt|;
name|sock
operator|->
name|references
operator|++
expr_stmt|;
name|iev
operator|->
name|ev_sender
operator|=
name|sock
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_fdwatch
condition|)
name|iev
operator|->
name|ev_action
operator|=
name|internal_fdwatch_write
expr_stmt|;
else|else
name|iev
operator|->
name|ev_action
operator|=
name|internal_send
expr_stmt|;
name|iev
operator|->
name|ev_arg
operator|=
name|sock
expr_stmt|;
name|isc_task_send
argument_list|(
name|sender
argument_list|,
operator|(
name|isc_event_t
operator|*
operator|*
operator|)
operator|&
name|iev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dispatch an internal accept event.  */
end_comment

begin_function
specifier|static
name|void
name|dispatch_accept
parameter_list|(
name|isc__socket_t
modifier|*
name|sock
parameter_list|)
block|{
name|intev_t
modifier|*
name|iev
decl_stmt|;
name|isc_socket_newconnev_t
modifier|*
name|ev
decl_stmt|;
name|INSIST
argument_list|(
operator|!
name|sock
operator|->
name|pending_accept
argument_list|)
expr_stmt|;
comment|/* 	 * Are there any done events left, or were they all canceled 	 * before the manager got the socket lock? 	 */
name|ev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sock
operator|->
name|accept_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
operator|==
name|NULL
condition|)
return|return;
name|sock
operator|->
name|pending_accept
operator|=
literal|1
expr_stmt|;
name|iev
operator|=
operator|&
name|sock
operator|->
name|readable_ev
expr_stmt|;
name|sock
operator|->
name|references
operator|++
expr_stmt|;
comment|/* keep socket around for this internal event */
name|iev
operator|->
name|ev_sender
operator|=
name|sock
expr_stmt|;
name|iev
operator|->
name|ev_action
operator|=
name|internal_accept
expr_stmt|;
name|iev
operator|->
name|ev_arg
operator|=
name|sock
expr_stmt|;
name|isc_task_send
argument_list|(
name|ev
operator|->
name|ev_sender
argument_list|,
operator|(
name|isc_event_t
operator|*
operator|*
operator|)
operator|&
name|iev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dispatch_connect
parameter_list|(
name|isc__socket_t
modifier|*
name|sock
parameter_list|)
block|{
name|intev_t
modifier|*
name|iev
decl_stmt|;
name|isc_socket_connev_t
modifier|*
name|ev
decl_stmt|;
name|iev
operator|=
operator|&
name|sock
operator|->
name|writable_ev
expr_stmt|;
name|ev
operator|=
name|sock
operator|->
name|connect_ev
expr_stmt|;
name|INSIST
argument_list|(
name|ev
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* XXX */
name|INSIST
argument_list|(
name|sock
operator|->
name|connecting
argument_list|)
expr_stmt|;
name|sock
operator|->
name|references
operator|++
expr_stmt|;
comment|/* keep socket around for this internal event */
name|iev
operator|->
name|ev_sender
operator|=
name|sock
expr_stmt|;
name|iev
operator|->
name|ev_action
operator|=
name|internal_connect
expr_stmt|;
name|iev
operator|->
name|ev_arg
operator|=
name|sock
expr_stmt|;
name|isc_task_send
argument_list|(
name|ev
operator|->
name|ev_sender
argument_list|,
operator|(
name|isc_event_t
operator|*
operator|*
operator|)
operator|&
name|iev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dequeue an item off the given socket's read queue, set the result code  * in the done event to the one provided, and send it to the task it was  * destined for.  *  * If the event to be sent is on a list, remove it before sending.  If  * asked to, send and detach from the socket as well.  *  * Caller must have the socket locked if the event is attached to the socket.  */
end_comment

begin_function
specifier|static
name|void
name|send_recvdone_event
parameter_list|(
name|isc__socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socketevent_t
modifier|*
modifier|*
name|dev
parameter_list|)
block|{
name|isc_task_t
modifier|*
name|task
decl_stmt|;
name|task
operator|=
operator|(
operator|*
name|dev
operator|)
operator|->
name|ev_sender
expr_stmt|;
operator|(
operator|*
name|dev
operator|)
operator|->
name|ev_sender
operator|=
name|sock
expr_stmt|;
if|if
condition|(
name|ISC_LINK_LINKED
argument_list|(
operator|*
name|dev
argument_list|,
name|ev_link
argument_list|)
condition|)
name|ISC_LIST_DEQUEUE
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|,
operator|*
name|dev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|*
name|dev
operator|)
operator|->
name|attributes
operator|&
name|ISC_SOCKEVENTATTR_ATTACHED
operator|)
operator|==
name|ISC_SOCKEVENTATTR_ATTACHED
condition|)
name|isc_task_sendanddetach
argument_list|(
operator|&
name|task
argument_list|,
operator|(
name|isc_event_t
operator|*
operator|*
operator|)
name|dev
argument_list|)
expr_stmt|;
else|else
name|isc_task_send
argument_list|(
name|task
argument_list|,
operator|(
name|isc_event_t
operator|*
operator|*
operator|)
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * See comments for send_recvdone_event() above.  *  * Caller must have the socket locked if the event is attached to the socket.  */
end_comment

begin_function
specifier|static
name|void
name|send_senddone_event
parameter_list|(
name|isc__socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socketevent_t
modifier|*
modifier|*
name|dev
parameter_list|)
block|{
name|isc_task_t
modifier|*
name|task
decl_stmt|;
name|INSIST
argument_list|(
name|dev
operator|!=
name|NULL
operator|&&
operator|*
name|dev
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|task
operator|=
operator|(
operator|*
name|dev
operator|)
operator|->
name|ev_sender
expr_stmt|;
operator|(
operator|*
name|dev
operator|)
operator|->
name|ev_sender
operator|=
name|sock
expr_stmt|;
if|if
condition|(
name|ISC_LINK_LINKED
argument_list|(
operator|*
name|dev
argument_list|,
name|ev_link
argument_list|)
condition|)
name|ISC_LIST_DEQUEUE
argument_list|(
name|sock
operator|->
name|send_list
argument_list|,
operator|*
name|dev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|*
name|dev
operator|)
operator|->
name|attributes
operator|&
name|ISC_SOCKEVENTATTR_ATTACHED
operator|)
operator|==
name|ISC_SOCKEVENTATTR_ATTACHED
condition|)
name|isc_task_sendanddetach
argument_list|(
operator|&
name|task
argument_list|,
operator|(
name|isc_event_t
operator|*
operator|*
operator|)
name|dev
argument_list|)
expr_stmt|;
else|else
name|isc_task_send
argument_list|(
name|task
argument_list|,
operator|(
name|isc_event_t
operator|*
operator|*
operator|)
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Call accept() on a socket, to get the new file descriptor.  The listen  * socket is used as a prototype to create a new isc_socket_t.  The new  * socket has one outstanding reference.  The task receiving the event  * will be detached from just after the event is delivered.  *  * On entry to this function, the event delivered is the internal  * readable event, and the first item on the accept_list should be  * the done event we want to send.  If the list is empty, this is a no-op,  * so just unlock and return.  */
end_comment

begin_function
specifier|static
name|void
name|internal_accept
parameter_list|(
name|isc_task_t
modifier|*
name|me
parameter_list|,
name|isc_event_t
modifier|*
name|ev
parameter_list|)
block|{
name|isc__socket_t
modifier|*
name|sock
decl_stmt|;
name|isc__socketmgr_t
modifier|*
name|manager
decl_stmt|;
name|isc_socket_newconnev_t
modifier|*
name|dev
decl_stmt|;
name|isc_task_t
modifier|*
name|task
decl_stmt|;
name|ISC_SOCKADDR_LEN_T
name|addrlen
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|err
init|=
literal|"accept"
decl_stmt|;
name|UNUSED
argument_list|(
name|me
argument_list|)
expr_stmt|;
name|sock
operator|=
name|ev
operator|->
name|ev_sender
expr_stmt|;
name|INSIST
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|socket_log
argument_list|(
name|sock
argument_list|,
name|NULL
argument_list|,
name|TRACE
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_ACCEPTLOCK
argument_list|,
literal|"internal_accept called, locked socket"
argument_list|)
expr_stmt|;
name|manager
operator|=
name|sock
operator|->
name|manager
expr_stmt|;
name|INSIST
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|listener
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|pending_accept
operator|==
literal|1
argument_list|)
expr_stmt|;
name|sock
operator|->
name|pending_accept
operator|=
literal|0
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|sock
operator|->
name|references
operator|--
expr_stmt|;
comment|/* the internal event is done with this socket */
if|if
condition|(
name|sock
operator|->
name|references
operator|==
literal|0
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|destroy
argument_list|(
operator|&
name|sock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Get the first item off the accept list. 	 * If it is empty, unlock the socket and return. 	 */
name|dev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sock
operator|->
name|accept_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Try to accept the new connection.  If the accept fails with 	 * EAGAIN or EINTR, simply poke the watcher to watch this socket 	 * again.  Also ignore ECONNRESET, which has been reported to 	 * be spuriously returned on Linux 2.2.19 although it is not 	 * a documented error for accept().  ECONNABORTED has been 	 * reported for Solaris 8.  The rest are thrown in not because 	 * we have seen them but because they are ignored by other 	 * daemons such as BIND 8 and Apache. 	 */
name|addrlen
operator|=
sizeof|sizeof
argument_list|(
name|NEWCONNSOCK
argument_list|(
name|dev
argument_list|)
operator|->
name|peer_address
operator|.
name|type
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|NEWCONNSOCK
argument_list|(
name|dev
argument_list|)
operator|->
name|peer_address
operator|.
name|type
argument_list|,
literal|0
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
name|fd
operator|=
name|accept
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
operator|&
name|NEWCONNSOCK
argument_list|(
name|dev
argument_list|)
operator|->
name|peer_address
operator|.
name|type
operator|.
name|sa
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|addrlen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|F_DUPFD
comment|/* 	 * Leave a space for stdio to work in. 	 */
if|if
condition|(
name|fd
operator|>=
literal|0
operator|&&
name|fd
operator|<
literal|20
condition|)
block|{
name|int
name|new
decl_stmt|,
name|tmp
decl_stmt|;
name|new
operator|=
name|fcntl
argument_list|(
name|fd
argument_list|,
name|F_DUPFD
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|errno
operator|=
name|tmp
expr_stmt|;
name|fd
operator|=
name|new
expr_stmt|;
name|err
operator|=
literal|"accept/fcntl"
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|SOFT_ERROR
argument_list|(
name|errno
argument_list|)
condition|)
goto|goto
name|soft_error
goto|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENFILE
case|:
case|case
name|EMFILE
case|:
name|isc_log_iwrite
argument_list|(
name|isc_lctx
argument_list|,
name|ISC_LOGCATEGORY_GENERAL
argument_list|,
name|ISC_LOGMODULE_SOCKET
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_TOOMANYFDS
argument_list|,
literal|"%s: too many open file descriptors"
argument_list|,
name|err
argument_list|)
expr_stmt|;
goto|goto
name|soft_error
goto|;
case|case
name|ENOBUFS
case|:
case|case
name|ENOMEM
case|:
case|case
name|ECONNRESET
case|:
case|case
name|ECONNABORTED
case|:
case|case
name|EHOSTUNREACH
case|:
case|case
name|EHOSTDOWN
case|:
case|case
name|ENETUNREACH
case|:
case|case
name|ENETDOWN
case|:
case|case
name|ECONNREFUSED
case|:
ifdef|#
directive|ifdef
name|EPROTO
case|case
name|EPROTO
case|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ENONET
case|case
name|ENONET
case|:
endif|#
directive|endif
goto|goto
name|soft_error
goto|;
default|default:
break|break;
block|}
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"internal_accept: %s() %s: %s"
argument_list|,
name|err
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|addrlen
operator|==
literal|0U
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"internal_accept(): "
literal|"accept() failed to return "
literal|"remote address"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
goto|goto
name|soft_error
goto|;
block|}
elseif|else
if|if
condition|(
name|NEWCONNSOCK
argument_list|(
name|dev
argument_list|)
operator|->
name|peer_address
operator|.
name|type
operator|.
name|sa
operator|.
name|sa_family
operator|!=
name|sock
operator|->
name|pf
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"internal_accept(): "
literal|"accept() returned peer address "
literal|"family %u (expected %u)"
argument_list|,
name|NEWCONNSOCK
argument_list|(
name|dev
argument_list|)
operator|->
name|peer_address
operator|.
name|type
operator|.
name|sa
operator|.
name|sa_family
argument_list|,
name|sock
operator|->
name|pf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
goto|goto
name|soft_error
goto|;
block|}
elseif|else
if|if
condition|(
name|fd
operator|>=
operator|(
name|int
operator|)
name|manager
operator|->
name|maxsocks
condition|)
block|{
name|isc_log_iwrite
argument_list|(
name|isc_lctx
argument_list|,
name|ISC_LOGCATEGORY_GENERAL
argument_list|,
name|ISC_LOGMODULE_SOCKET
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_TOOMANYFDS
argument_list|,
literal|"accept: "
literal|"file descriptor exceeds limit (%d/%u)"
argument_list|,
name|fd
argument_list|,
name|manager
operator|->
name|maxsocks
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
goto|goto
name|soft_error
goto|;
block|}
block|}
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|NEWCONNSOCK
argument_list|(
name|dev
argument_list|)
operator|->
name|peer_address
operator|.
name|length
operator|=
name|addrlen
expr_stmt|;
name|NEWCONNSOCK
argument_list|(
name|dev
argument_list|)
operator|->
name|pf
operator|=
name|sock
operator|->
name|pf
expr_stmt|;
block|}
comment|/* 	 * Pull off the done event. 	 */
name|ISC_LIST_UNLINK
argument_list|(
name|sock
operator|->
name|accept_list
argument_list|,
name|dev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
comment|/* 	 * Poke watcher if there are more pending accepts. 	 */
if|if
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|accept_list
argument_list|)
condition|)
name|select_poke
argument_list|(
name|sock
operator|->
name|manager
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|SELECT_POKE_ACCEPT
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|make_nonblock
argument_list|(
name|fd
argument_list|)
operator|!=
name|ISC_R_SUCCESS
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
block|}
comment|/* 	 * -1 means the new socket didn't happen. 	 */
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|int
name|lockid
init|=
name|FDLOCK_ID
argument_list|(
name|fd
argument_list|)
decl_stmt|;
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|fdlock
index|[
name|lockid
index|]
argument_list|)
expr_stmt|;
name|manager
operator|->
name|fds
index|[
name|fd
index|]
operator|=
name|NEWCONNSOCK
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|manager
operator|->
name|fdstate
index|[
name|fd
index|]
operator|=
name|MANAGED
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|fdlock
index|[
name|lockid
index|]
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|ISC_LIST_APPEND
argument_list|(
name|manager
operator|->
name|socklist
argument_list|,
name|NEWCONNSOCK
argument_list|(
name|dev
argument_list|)
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|NEWCONNSOCK
argument_list|(
name|dev
argument_list|)
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|NEWCONNSOCK
argument_list|(
name|dev
argument_list|)
operator|->
name|bound
operator|=
literal|1
expr_stmt|;
name|NEWCONNSOCK
argument_list|(
name|dev
argument_list|)
operator|->
name|connected
operator|=
literal|1
expr_stmt|;
comment|/* 		 * Save away the remote address 		 */
name|dev
operator|->
name|address
operator|=
name|NEWCONNSOCK
argument_list|(
name|dev
argument_list|)
operator|->
name|peer_address
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_SELECT
if|if
condition|(
name|manager
operator|->
name|maxfd
operator|<
name|fd
condition|)
name|manager
operator|->
name|maxfd
operator|=
name|fd
expr_stmt|;
endif|#
directive|endif
name|socket_log
argument_list|(
name|sock
argument_list|,
operator|&
name|NEWCONNSOCK
argument_list|(
name|dev
argument_list|)
operator|->
name|peer_address
argument_list|,
name|CREATION
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_ACCEPTEDCXN
argument_list|,
literal|"accepted connection, new socket %p"
argument_list|,
name|dev
operator|->
name|newsocket
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|inc_stats
argument_list|(
name|manager
operator|->
name|stats
argument_list|,
name|sock
operator|->
name|statsindex
index|[
name|STATID_ACCEPT
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inc_stats
argument_list|(
name|manager
operator|->
name|stats
argument_list|,
name|sock
operator|->
name|statsindex
index|[
name|STATID_ACCEPTFAIL
index|]
argument_list|)
expr_stmt|;
name|NEWCONNSOCK
argument_list|(
name|dev
argument_list|)
operator|->
name|references
operator|--
expr_stmt|;
name|free_socket
argument_list|(
operator|(
name|isc__socket_t
operator|*
operator|*
operator|)
operator|&
name|dev
operator|->
name|newsocket
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Fill in the done event details and send it off. 	 */
name|dev
operator|->
name|result
operator|=
name|result
expr_stmt|;
name|task
operator|=
name|dev
operator|->
name|ev_sender
expr_stmt|;
name|dev
operator|->
name|ev_sender
operator|=
name|sock
expr_stmt|;
name|isc_task_sendanddetach
argument_list|(
operator|&
name|task
argument_list|,
name|ISC_EVENT_PTR
argument_list|(
operator|&
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return;
name|soft_error
label|:
name|select_poke
argument_list|(
name|sock
operator|->
name|manager
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|SELECT_POKE_ACCEPT
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|inc_stats
argument_list|(
name|manager
operator|->
name|stats
argument_list|,
name|sock
operator|->
name|statsindex
index|[
name|STATID_ACCEPTFAIL
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|internal_recv
parameter_list|(
name|isc_task_t
modifier|*
name|me
parameter_list|,
name|isc_event_t
modifier|*
name|ev
parameter_list|)
block|{
name|isc_socketevent_t
modifier|*
name|dev
decl_stmt|;
name|isc__socket_t
modifier|*
name|sock
decl_stmt|;
name|INSIST
argument_list|(
name|ev
operator|->
name|ev_type
operator|==
name|ISC_SOCKEVENT_INTR
argument_list|)
expr_stmt|;
name|sock
operator|=
name|ev
operator|->
name|ev_sender
expr_stmt|;
name|INSIST
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|socket_log
argument_list|(
name|sock
argument_list|,
name|NULL
argument_list|,
name|IOEVENT
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_INTERNALRECV
argument_list|,
literal|"internal_recv: task %p got event %p"
argument_list|,
name|me
argument_list|,
name|ev
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|pending_recv
operator|==
literal|1
argument_list|)
expr_stmt|;
name|sock
operator|->
name|pending_recv
operator|=
literal|0
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|sock
operator|->
name|references
operator|--
expr_stmt|;
comment|/* the internal event is done with this socket */
if|if
condition|(
name|sock
operator|->
name|references
operator|==
literal|0
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|destroy
argument_list|(
operator|&
name|sock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Try to do as much I/O as possible on this socket.  There are no 	 * limits here, currently. 	 */
name|dev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|dev
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|doio_recv
argument_list|(
name|sock
argument_list|,
name|dev
argument_list|)
condition|)
block|{
case|case
name|DOIO_SOFT
case|:
goto|goto
name|poke
goto|;
case|case
name|DOIO_EOF
case|:
comment|/* 			 * read of 0 means the remote end was closed. 			 * Run through the event queue and dispatch all 			 * the events with an EOF result code. 			 */
do|do
block|{
name|dev
operator|->
name|result
operator|=
name|ISC_R_EOF
expr_stmt|;
name|send_recvdone_event
argument_list|(
name|sock
argument_list|,
operator|&
name|dev
argument_list|)
expr_stmt|;
name|dev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|dev
operator|!=
name|NULL
condition|)
do|;
goto|goto
name|poke
goto|;
case|case
name|DOIO_SUCCESS
case|:
case|case
name|DOIO_HARD
case|:
name|send_recvdone_event
argument_list|(
name|sock
argument_list|,
operator|&
name|dev
argument_list|)
expr_stmt|;
break|break;
block|}
name|dev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|)
expr_stmt|;
block|}
name|poke
label|:
if|if
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|)
condition|)
name|select_poke
argument_list|(
name|sock
operator|->
name|manager
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|SELECT_POKE_READ
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|internal_send
parameter_list|(
name|isc_task_t
modifier|*
name|me
parameter_list|,
name|isc_event_t
modifier|*
name|ev
parameter_list|)
block|{
name|isc_socketevent_t
modifier|*
name|dev
decl_stmt|;
name|isc__socket_t
modifier|*
name|sock
decl_stmt|;
name|INSIST
argument_list|(
name|ev
operator|->
name|ev_type
operator|==
name|ISC_SOCKEVENT_INTW
argument_list|)
expr_stmt|;
comment|/* 	 * Find out what socket this is and lock it. 	 */
name|sock
operator|=
operator|(
name|isc__socket_t
operator|*
operator|)
name|ev
operator|->
name|ev_sender
expr_stmt|;
name|INSIST
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|socket_log
argument_list|(
name|sock
argument_list|,
name|NULL
argument_list|,
name|IOEVENT
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_INTERNALSEND
argument_list|,
literal|"internal_send: task %p got event %p"
argument_list|,
name|me
argument_list|,
name|ev
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|pending_send
operator|==
literal|1
argument_list|)
expr_stmt|;
name|sock
operator|->
name|pending_send
operator|=
literal|0
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|sock
operator|->
name|references
operator|--
expr_stmt|;
comment|/* the internal event is done with this socket */
if|if
condition|(
name|sock
operator|->
name|references
operator|==
literal|0
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|destroy
argument_list|(
operator|&
name|sock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Try to do as much I/O as possible on this socket.  There are no 	 * limits here, currently. 	 */
name|dev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sock
operator|->
name|send_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|dev
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|doio_send
argument_list|(
name|sock
argument_list|,
name|dev
argument_list|)
condition|)
block|{
case|case
name|DOIO_SOFT
case|:
goto|goto
name|poke
goto|;
case|case
name|DOIO_HARD
case|:
case|case
name|DOIO_SUCCESS
case|:
name|send_senddone_event
argument_list|(
name|sock
argument_list|,
operator|&
name|dev
argument_list|)
expr_stmt|;
break|break;
block|}
name|dev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sock
operator|->
name|send_list
argument_list|)
expr_stmt|;
block|}
name|poke
label|:
if|if
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|send_list
argument_list|)
condition|)
name|select_poke
argument_list|(
name|sock
operator|->
name|manager
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|SELECT_POKE_WRITE
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|internal_fdwatch_write
parameter_list|(
name|isc_task_t
modifier|*
name|me
parameter_list|,
name|isc_event_t
modifier|*
name|ev
parameter_list|)
block|{
name|isc__socket_t
modifier|*
name|sock
decl_stmt|;
name|int
name|more_data
decl_stmt|;
name|INSIST
argument_list|(
name|ev
operator|->
name|ev_type
operator|==
name|ISC_SOCKEVENT_INTW
argument_list|)
expr_stmt|;
comment|/* 	 * Find out what socket this is and lock it. 	 */
name|sock
operator|=
operator|(
name|isc__socket_t
operator|*
operator|)
name|ev
operator|->
name|ev_sender
expr_stmt|;
name|INSIST
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|socket_log
argument_list|(
name|sock
argument_list|,
name|NULL
argument_list|,
name|IOEVENT
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_INTERNALSEND
argument_list|,
literal|"internal_fdwatch_write: task %p got event %p"
argument_list|,
name|me
argument_list|,
name|ev
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|pending_send
operator|==
literal|1
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|more_data
operator|=
call|(
name|sock
operator|->
name|fdwatchcb
call|)
argument_list|(
name|me
argument_list|,
operator|(
name|isc_socket_t
operator|*
operator|)
name|sock
argument_list|,
name|sock
operator|->
name|fdwatcharg
argument_list|,
name|ISC_SOCKFDWATCH_WRITE
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|sock
operator|->
name|pending_send
operator|=
literal|0
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|sock
operator|->
name|references
operator|--
expr_stmt|;
comment|/* the internal event is done with this socket */
if|if
condition|(
name|sock
operator|->
name|references
operator|==
literal|0
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|destroy
argument_list|(
operator|&
name|sock
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|more_data
condition|)
name|select_poke
argument_list|(
name|sock
operator|->
name|manager
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|SELECT_POKE_WRITE
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|internal_fdwatch_read
parameter_list|(
name|isc_task_t
modifier|*
name|me
parameter_list|,
name|isc_event_t
modifier|*
name|ev
parameter_list|)
block|{
name|isc__socket_t
modifier|*
name|sock
decl_stmt|;
name|int
name|more_data
decl_stmt|;
name|INSIST
argument_list|(
name|ev
operator|->
name|ev_type
operator|==
name|ISC_SOCKEVENT_INTR
argument_list|)
expr_stmt|;
comment|/* 	 * Find out what socket this is and lock it. 	 */
name|sock
operator|=
operator|(
name|isc__socket_t
operator|*
operator|)
name|ev
operator|->
name|ev_sender
expr_stmt|;
name|INSIST
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|socket_log
argument_list|(
name|sock
argument_list|,
name|NULL
argument_list|,
name|IOEVENT
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_INTERNALRECV
argument_list|,
literal|"internal_fdwatch_read: task %p got event %p"
argument_list|,
name|me
argument_list|,
name|ev
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|pending_recv
operator|==
literal|1
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|more_data
operator|=
call|(
name|sock
operator|->
name|fdwatchcb
call|)
argument_list|(
name|me
argument_list|,
operator|(
name|isc_socket_t
operator|*
operator|)
name|sock
argument_list|,
name|sock
operator|->
name|fdwatcharg
argument_list|,
name|ISC_SOCKFDWATCH_READ
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|sock
operator|->
name|pending_recv
operator|=
literal|0
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|sock
operator|->
name|references
operator|--
expr_stmt|;
comment|/* the internal event is done with this socket */
if|if
condition|(
name|sock
operator|->
name|references
operator|==
literal|0
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|destroy
argument_list|(
operator|&
name|sock
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|more_data
condition|)
name|select_poke
argument_list|(
name|sock
operator|->
name|manager
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|SELECT_POKE_READ
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Process read/writes on each fd here.  Avoid locking  * and unlocking twice if both reads and writes are possible.  */
end_comment

begin_function
specifier|static
name|void
name|process_fd
parameter_list|(
name|isc__socketmgr_t
modifier|*
name|manager
parameter_list|,
name|int
name|fd
parameter_list|,
name|isc_boolean_t
name|readable
parameter_list|,
name|isc_boolean_t
name|writeable
parameter_list|)
block|{
name|isc__socket_t
modifier|*
name|sock
decl_stmt|;
name|isc_boolean_t
name|unlock_sock
decl_stmt|;
name|isc_boolean_t
name|unwatch_read
init|=
name|ISC_FALSE
decl_stmt|,
name|unwatch_write
init|=
name|ISC_FALSE
decl_stmt|;
name|int
name|lockid
init|=
name|FDLOCK_ID
argument_list|(
name|fd
argument_list|)
decl_stmt|;
comment|/* 	 * If the socket is going to be closed, don't do more I/O. 	 */
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|fdlock
index|[
name|lockid
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|fdstate
index|[
name|fd
index|]
operator|==
name|CLOSE_PENDING
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|fdlock
index|[
name|lockid
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unwatch_fd
argument_list|(
name|manager
argument_list|,
name|fd
argument_list|,
name|SELECT_POKE_READ
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unwatch_fd
argument_list|(
name|manager
argument_list|,
name|fd
argument_list|,
name|SELECT_POKE_WRITE
argument_list|)
expr_stmt|;
return|return;
block|}
name|sock
operator|=
name|manager
operator|->
name|fds
index|[
name|fd
index|]
expr_stmt|;
name|unlock_sock
operator|=
name|ISC_FALSE
expr_stmt|;
if|if
condition|(
name|readable
condition|)
block|{
if|if
condition|(
name|sock
operator|==
name|NULL
condition|)
block|{
name|unwatch_read
operator|=
name|ISC_TRUE
expr_stmt|;
goto|goto
name|check_write
goto|;
block|}
name|unlock_sock
operator|=
name|ISC_TRUE
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SOCK_DEAD
argument_list|(
name|sock
argument_list|)
condition|)
block|{
if|if
condition|(
name|sock
operator|->
name|listener
condition|)
name|dispatch_accept
argument_list|(
name|sock
argument_list|)
expr_stmt|;
else|else
name|dispatch_recv
argument_list|(
name|sock
argument_list|)
expr_stmt|;
block|}
name|unwatch_read
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
name|check_write
label|:
if|if
condition|(
name|writeable
condition|)
block|{
if|if
condition|(
name|sock
operator|==
name|NULL
condition|)
block|{
name|unwatch_write
operator|=
name|ISC_TRUE
expr_stmt|;
goto|goto
name|unlock_fd
goto|;
block|}
if|if
condition|(
operator|!
name|unlock_sock
condition|)
block|{
name|unlock_sock
operator|=
name|ISC_TRUE
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SOCK_DEAD
argument_list|(
name|sock
argument_list|)
condition|)
block|{
if|if
condition|(
name|sock
operator|->
name|connecting
condition|)
name|dispatch_connect
argument_list|(
name|sock
argument_list|)
expr_stmt|;
else|else
name|dispatch_send
argument_list|(
name|sock
argument_list|)
expr_stmt|;
block|}
name|unwatch_write
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|unlock_sock
condition|)
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|unlock_fd
label|:
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|fdlock
index|[
name|lockid
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|unwatch_read
condition|)
operator|(
name|void
operator|)
name|unwatch_fd
argument_list|(
name|manager
argument_list|,
name|fd
argument_list|,
name|SELECT_POKE_READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|unwatch_write
condition|)
operator|(
name|void
operator|)
name|unwatch_fd
argument_list|(
name|manager
argument_list|,
name|fd
argument_list|,
name|SELECT_POKE_WRITE
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|USE_KQUEUE
end_ifdef

begin_function
specifier|static
name|isc_boolean_t
name|process_fds
parameter_list|(
name|isc__socketmgr_t
modifier|*
name|manager
parameter_list|,
name|struct
name|kevent
modifier|*
name|events
parameter_list|,
name|int
name|nevents
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|isc_boolean_t
name|readable
decl_stmt|,
name|writable
decl_stmt|;
name|isc_boolean_t
name|done
init|=
name|ISC_FALSE
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_WATCHER_THREAD
name|isc_boolean_t
name|have_ctlevent
init|=
name|ISC_FALSE
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|nevents
operator|==
name|manager
operator|->
name|nevents
condition|)
block|{
comment|/* 		 * This is not an error, but something unexpected.  If this 		 * happens, it may indicate the need for increasing 		 * ISC_SOCKET_MAXEVENTS. 		 */
name|manager_log
argument_list|(
name|manager
argument_list|,
name|ISC_LOGCATEGORY_GENERAL
argument_list|,
name|ISC_LOGMODULE_SOCKET
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"maximum number of FD events (%d) received"
argument_list|,
name|nevents
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nevents
condition|;
name|i
operator|++
control|)
block|{
name|REQUIRE
argument_list|(
name|events
index|[
name|i
index|]
operator|.
name|ident
operator|<
name|manager
operator|->
name|maxsocks
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_WATCHER_THREAD
if|if
condition|(
name|events
index|[
name|i
index|]
operator|.
name|ident
operator|==
operator|(
name|uintptr_t
operator|)
name|manager
operator|->
name|pipe_fds
index|[
literal|0
index|]
condition|)
block|{
name|have_ctlevent
operator|=
name|ISC_TRUE
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
name|readable
operator|=
name|ISC_TF
argument_list|(
name|events
index|[
name|i
index|]
operator|.
name|filter
operator|==
name|EVFILT_READ
argument_list|)
expr_stmt|;
name|writable
operator|=
name|ISC_TF
argument_list|(
name|events
index|[
name|i
index|]
operator|.
name|filter
operator|==
name|EVFILT_WRITE
argument_list|)
expr_stmt|;
name|process_fd
argument_list|(
name|manager
argument_list|,
name|events
index|[
name|i
index|]
operator|.
name|ident
argument_list|,
name|readable
argument_list|,
name|writable
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USE_WATCHER_THREAD
if|if
condition|(
name|have_ctlevent
condition|)
name|done
operator|=
name|process_ctlfd
argument_list|(
name|manager
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|done
operator|)
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|USE_EPOLL
argument_list|)
end_elif

begin_function
specifier|static
name|isc_boolean_t
name|process_fds
parameter_list|(
name|isc__socketmgr_t
modifier|*
name|manager
parameter_list|,
name|struct
name|epoll_event
modifier|*
name|events
parameter_list|,
name|int
name|nevents
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|isc_boolean_t
name|done
init|=
name|ISC_FALSE
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_WATCHER_THREAD
name|isc_boolean_t
name|have_ctlevent
init|=
name|ISC_FALSE
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|nevents
operator|==
name|manager
operator|->
name|nevents
condition|)
block|{
name|manager_log
argument_list|(
name|manager
argument_list|,
name|ISC_LOGCATEGORY_GENERAL
argument_list|,
name|ISC_LOGMODULE_SOCKET
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"maximum number of FD events (%d) received"
argument_list|,
name|nevents
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nevents
condition|;
name|i
operator|++
control|)
block|{
name|REQUIRE
argument_list|(
name|events
index|[
name|i
index|]
operator|.
name|data
operator|.
name|fd
operator|<
operator|(
name|int
operator|)
name|manager
operator|->
name|maxsocks
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_WATCHER_THREAD
if|if
condition|(
name|events
index|[
name|i
index|]
operator|.
name|data
operator|.
name|fd
operator|==
name|manager
operator|->
name|pipe_fds
index|[
literal|0
index|]
condition|)
block|{
name|have_ctlevent
operator|=
name|ISC_TRUE
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|events
index|[
name|i
index|]
operator|.
name|events
operator|&
name|EPOLLERR
operator|)
operator|!=
literal|0
operator|||
operator|(
name|events
index|[
name|i
index|]
operator|.
name|events
operator|&
name|EPOLLHUP
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * epoll does not set IN/OUT bits on an erroneous 			 * condition, so we need to try both anyway.  This is a 			 * bit inefficient, but should be okay for such rare 			 * events.  Note also that the read or write attempt 			 * won't block because we use non-blocking sockets. 			 */
name|events
index|[
name|i
index|]
operator|.
name|events
operator||=
operator|(
name|EPOLLIN
operator||
name|EPOLLOUT
operator|)
expr_stmt|;
block|}
name|process_fd
argument_list|(
name|manager
argument_list|,
name|events
index|[
name|i
index|]
operator|.
name|data
operator|.
name|fd
argument_list|,
operator|(
name|events
index|[
name|i
index|]
operator|.
name|events
operator|&
name|EPOLLIN
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|events
index|[
name|i
index|]
operator|.
name|events
operator|&
name|EPOLLOUT
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USE_WATCHER_THREAD
if|if
condition|(
name|have_ctlevent
condition|)
name|done
operator|=
name|process_ctlfd
argument_list|(
name|manager
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|done
operator|)
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|USE_DEVPOLL
argument_list|)
end_elif

begin_function
specifier|static
name|isc_boolean_t
name|process_fds
parameter_list|(
name|isc__socketmgr_t
modifier|*
name|manager
parameter_list|,
name|struct
name|pollfd
modifier|*
name|events
parameter_list|,
name|int
name|nevents
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|isc_boolean_t
name|done
init|=
name|ISC_FALSE
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_WATCHER_THREAD
name|isc_boolean_t
name|have_ctlevent
init|=
name|ISC_FALSE
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
name|nevents
operator|==
name|manager
operator|->
name|nevents
condition|)
block|{
name|manager_log
argument_list|(
name|manager
argument_list|,
name|ISC_LOGCATEGORY_GENERAL
argument_list|,
name|ISC_LOGMODULE_SOCKET
argument_list|,
name|ISC_LOG_INFO
argument_list|,
literal|"maximum number of FD events (%d) received"
argument_list|,
name|nevents
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nevents
condition|;
name|i
operator|++
control|)
block|{
name|REQUIRE
argument_list|(
name|events
index|[
name|i
index|]
operator|.
name|fd
operator|<
operator|(
name|int
operator|)
name|manager
operator|->
name|maxsocks
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_WATCHER_THREAD
if|if
condition|(
name|events
index|[
name|i
index|]
operator|.
name|fd
operator|==
name|manager
operator|->
name|pipe_fds
index|[
literal|0
index|]
condition|)
block|{
name|have_ctlevent
operator|=
name|ISC_TRUE
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
name|process_fd
argument_list|(
name|manager
argument_list|,
name|events
index|[
name|i
index|]
operator|.
name|fd
argument_list|,
operator|(
name|events
index|[
name|i
index|]
operator|.
name|events
operator|&
name|POLLIN
operator|)
operator|!=
literal|0
argument_list|,
operator|(
name|events
index|[
name|i
index|]
operator|.
name|events
operator|&
name|POLLOUT
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USE_WATCHER_THREAD
if|if
condition|(
name|have_ctlevent
condition|)
name|done
operator|=
name|process_ctlfd
argument_list|(
name|manager
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|done
operator|)
return|;
block|}
end_function

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|USE_SELECT
argument_list|)
end_elif

begin_function
specifier|static
name|void
name|process_fds
parameter_list|(
name|isc__socketmgr_t
modifier|*
name|manager
parameter_list|,
name|int
name|maxfd
parameter_list|,
name|fd_set
modifier|*
name|readfds
parameter_list|,
name|fd_set
modifier|*
name|writefds
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|REQUIRE
argument_list|(
name|maxfd
operator|<=
operator|(
name|int
operator|)
name|manager
operator|->
name|maxsocks
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|maxfd
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|USE_WATCHER_THREAD
if|if
condition|(
name|i
operator|==
name|manager
operator|->
name|pipe_fds
index|[
literal|0
index|]
operator|||
name|i
operator|==
name|manager
operator|->
name|pipe_fds
index|[
literal|1
index|]
condition|)
continue|continue;
endif|#
directive|endif
comment|/* USE_WATCHER_THREAD */
name|process_fd
argument_list|(
name|manager
argument_list|,
name|i
argument_list|,
name|FD_ISSET
argument_list|(
name|i
argument_list|,
name|readfds
argument_list|)
argument_list|,
name|FD_ISSET
argument_list|(
name|i
argument_list|,
name|writefds
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_WATCHER_THREAD
end_ifdef

begin_function
specifier|static
name|isc_boolean_t
name|process_ctlfd
parameter_list|(
name|isc__socketmgr_t
modifier|*
name|manager
parameter_list|)
block|{
name|int
name|msg
decl_stmt|,
name|fd
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|select_readmsg
argument_list|(
name|manager
argument_list|,
operator|&
name|fd
argument_list|,
operator|&
name|msg
argument_list|)
expr_stmt|;
name|manager_log
argument_list|(
name|manager
argument_list|,
name|IOEVENT
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_WATCHERMSG
argument_list|,
literal|"watcher got message %d "
literal|"for socket %d"
argument_list|)
argument_list|,
name|msg
argument_list|,
name|fd
argument_list|)
expr_stmt|;
comment|/* 		 * Nothing to read? 		 */
if|if
condition|(
name|msg
operator|==
name|SELECT_POKE_NOTHING
condition|)
break|break;
comment|/* 		 * Handle shutdown message.  We really should 		 * jump out of this loop right away, but 		 * it doesn't matter if we have to do a little 		 * more work first. 		 */
if|if
condition|(
name|msg
operator|==
name|SELECT_POKE_SHUTDOWN
condition|)
return|return
operator|(
name|ISC_TRUE
operator|)
return|;
comment|/* 		 * This is a wakeup on a socket.  Look 		 * at the event queue for both read and write, 		 * and decide if we need to watch on it now 		 * or not. 		 */
name|wakeup_socket
argument_list|(
name|manager
argument_list|,
name|fd
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ISC_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is the thread that will loop forever, always in a select or poll  * call.  *  * When select returns something to do, track down what thread gets to do  * this I/O and post the event to it.  */
end_comment

begin_function
specifier|static
name|isc_threadresult_t
name|watcher
parameter_list|(
name|void
modifier|*
name|uap
parameter_list|)
block|{
name|isc__socketmgr_t
modifier|*
name|manager
init|=
name|uap
decl_stmt|;
name|isc_boolean_t
name|done
decl_stmt|;
name|int
name|ctlfd
decl_stmt|;
name|int
name|cc
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_KQUEUE
specifier|const
name|char
modifier|*
name|fnname
init|=
literal|"kevent()"
decl_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|USE_EPOLL
argument_list|)
specifier|const
name|char
modifier|*
name|fnname
init|=
literal|"epoll_wait()"
decl_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|USE_DEVPOLL
argument_list|)
specifier|const
name|char
modifier|*
name|fnname
init|=
literal|"ioctl(DP_POLL)"
decl_stmt|;
name|struct
name|dvpoll
name|dvp
decl_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|USE_SELECT
argument_list|)
specifier|const
name|char
modifier|*
name|fnname
init|=
literal|"select()"
decl_stmt|;
name|int
name|maxfd
decl_stmt|;
endif|#
directive|endif
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|ISC_SOCKET_USE_POLLWATCH
name|pollstate_t
name|pollstate
init|=
name|poll_idle
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Get the control fd here.  This will never change. 	 */
name|ctlfd
operator|=
name|manager
operator|->
name|pipe_fds
index|[
literal|0
index|]
expr_stmt|;
name|done
operator|=
name|ISC_FALSE
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
do|do
block|{
ifdef|#
directive|ifdef
name|USE_KQUEUE
name|cc
operator|=
name|kevent
argument_list|(
name|manager
operator|->
name|kqueue_fd
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|manager
operator|->
name|events
argument_list|,
name|manager
operator|->
name|nevents
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|USE_EPOLL
argument_list|)
name|cc
operator|=
name|epoll_wait
argument_list|(
name|manager
operator|->
name|epoll_fd
argument_list|,
name|manager
operator|->
name|events
argument_list|,
name|manager
operator|->
name|nevents
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|USE_DEVPOLL
argument_list|)
name|dvp
operator|.
name|dp_fds
operator|=
name|manager
operator|->
name|events
expr_stmt|;
name|dvp
operator|.
name|dp_nfds
operator|=
name|manager
operator|->
name|nevents
expr_stmt|;
ifndef|#
directive|ifndef
name|ISC_SOCKET_USE_POLLWATCH
name|dvp
operator|.
name|dp_timeout
operator|=
operator|-
literal|1
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|pollstate
operator|==
name|poll_idle
condition|)
name|dvp
operator|.
name|dp_timeout
operator|=
operator|-
literal|1
expr_stmt|;
else|else
name|dvp
operator|.
name|dp_timeout
operator|=
name|ISC_SOCKET_POLLWATCH_TIMEOUT
expr_stmt|;
endif|#
directive|endif
comment|/* ISC_SOCKET_USE_POLLWATCH */
name|cc
operator|=
name|ioctl
argument_list|(
name|manager
operator|->
name|devpoll_fd
argument_list|,
name|DP_POLL
argument_list|,
operator|&
name|dvp
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|USE_SELECT
argument_list|)
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|manager
operator|->
name|read_fds_copy
argument_list|,
name|manager
operator|->
name|read_fds
argument_list|,
name|manager
operator|->
name|fd_bufsize
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|manager
operator|->
name|write_fds_copy
argument_list|,
name|manager
operator|->
name|write_fds
argument_list|,
name|manager
operator|->
name|fd_bufsize
argument_list|)
expr_stmt|;
name|maxfd
operator|=
name|manager
operator|->
name|maxfd
operator|+
literal|1
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|cc
operator|=
name|select
argument_list|(
name|maxfd
argument_list|,
name|manager
operator|->
name|read_fds_copy
argument_list|,
name|manager
operator|->
name|write_fds_copy
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_KQUEUE */
if|if
condition|(
name|cc
operator|<
literal|0
operator|&&
operator|!
name|SOFT_ERROR
argument_list|(
name|errno
argument_list|)
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|FATAL_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"%s %s: %s"
argument_list|,
name|fnname
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|USE_DEVPOLL
argument_list|)
operator|&&
name|defined
argument_list|(
name|ISC_SOCKET_USE_POLLWATCH
argument_list|)
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pollstate
operator|==
name|poll_active
condition|)
name|pollstate
operator|=
name|poll_checking
expr_stmt|;
elseif|else
if|if
condition|(
name|pollstate
operator|==
name|poll_checking
condition|)
name|pollstate
operator|=
name|poll_idle
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|pollstate
operator|==
name|poll_checking
condition|)
block|{
comment|/* 					 * XXX: We'd like to use a more 					 * verbose log level as it's actually an 					 * unexpected event, but the kernel bug 					 * reportedly happens pretty frequently 					 * (and it can also be a false positive) 					 * so it would be just too noisy. 					 */
name|manager_log
argument_list|(
name|manager
argument_list|,
name|ISC_LOGCATEGORY_GENERAL
argument_list|,
name|ISC_LOGMODULE_SOCKET
argument_list|,
name|ISC_LOG_DEBUG
argument_list|(
literal|1
argument_list|)
argument_list|,
literal|"unexpected POLL timeout"
argument_list|)
expr_stmt|;
block|}
name|pollstate
operator|=
name|poll_active
expr_stmt|;
block|}
endif|#
directive|endif
block|}
do|while
condition|(
name|cc
operator|<
literal|0
condition|)
do|;
if|#
directive|if
name|defined
argument_list|(
name|USE_KQUEUE
argument_list|)
operator|||
name|defined
argument_list|(
name|USE_EPOLL
argument_list|)
operator|||
name|defined
argument_list|(
name|USE_DEVPOLL
argument_list|)
name|done
operator|=
name|process_fds
argument_list|(
name|manager
argument_list|,
name|manager
operator|->
name|events
argument_list|,
name|cc
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|USE_SELECT
argument_list|)
name|process_fds
argument_list|(
name|manager
argument_list|,
name|maxfd
argument_list|,
name|manager
operator|->
name|read_fds_copy
argument_list|,
name|manager
operator|->
name|write_fds_copy
argument_list|)
expr_stmt|;
comment|/* 		 * Process reads on internal, control fd. 		 */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|ctlfd
argument_list|,
name|manager
operator|->
name|read_fds_copy
argument_list|)
condition|)
name|done
operator|=
name|process_ctlfd
argument_list|(
name|manager
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|manager_log
argument_list|(
name|manager
argument_list|,
name|TRACE
argument_list|,
literal|"%s"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_EXITING
argument_list|,
literal|"watcher exiting"
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|isc_threadresult_t
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_WATCHER_THREAD */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BIND9
end_ifdef

begin_function
name|ISC_SOCKETFUNC_SCOPE
name|void
name|isc__socketmgr_setreserved
parameter_list|(
name|isc_socketmgr_t
modifier|*
name|manager0
parameter_list|,
name|isc_uint32_t
name|reserved
parameter_list|)
block|{
name|isc__socketmgr_t
modifier|*
name|manager
init|=
operator|(
name|isc__socketmgr_t
operator|*
operator|)
name|manager0
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|manager
operator|->
name|reserved
operator|=
name|reserved
expr_stmt|;
block|}
end_function

begin_function
name|ISC_SOCKETFUNC_SCOPE
name|void
name|isc___socketmgr_maxudp
parameter_list|(
name|isc_socketmgr_t
modifier|*
name|manager0
parameter_list|,
name|int
name|maxudp
parameter_list|)
block|{
name|isc__socketmgr_t
modifier|*
name|manager
init|=
operator|(
name|isc__socketmgr_t
operator|*
operator|)
name|manager0
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|manager
operator|->
name|maxudp
operator|=
name|maxudp
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BIND9 */
end_comment

begin_comment
comment|/*  * Create a new socket manager.  */
end_comment

begin_function
specifier|static
name|isc_result_t
name|setup_watcher
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|isc__socketmgr_t
modifier|*
name|manager
parameter_list|)
block|{
name|isc_result_t
name|result
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|USE_KQUEUE
argument_list|)
operator|||
name|defined
argument_list|(
name|USE_EPOLL
argument_list|)
operator|||
name|defined
argument_list|(
name|USE_DEVPOLL
argument_list|)
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_KQUEUE
name|manager
operator|->
name|nevents
operator|=
name|ISC_SOCKET_MAXEVENTS
expr_stmt|;
name|manager
operator|->
name|events
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|kevent
argument_list|)
operator|*
name|manager
operator|->
name|nevents
argument_list|)
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|events
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|manager
operator|->
name|kqueue_fd
operator|=
name|kqueue
argument_list|()
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|kqueue_fd
operator|==
operator|-
literal|1
condition|)
block|{
name|result
operator|=
name|isc__errno2result
argument_list|(
name|errno
argument_list|)
expr_stmt|;
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"kqueue %s: %s"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
operator|->
name|events
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|kevent
argument_list|)
operator|*
name|manager
operator|->
name|nevents
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|USE_WATCHER_THREAD
name|result
operator|=
name|watch_fd
argument_list|(
name|manager
argument_list|,
name|manager
operator|->
name|pipe_fds
index|[
literal|0
index|]
argument_list|,
name|SELECT_POKE_READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|close
argument_list|(
name|manager
operator|->
name|kqueue_fd
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
operator|->
name|events
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|kevent
argument_list|)
operator|*
name|manager
operator|->
name|nevents
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* USE_WATCHER_THREAD */
elif|#
directive|elif
name|defined
argument_list|(
name|USE_EPOLL
argument_list|)
name|manager
operator|->
name|nevents
operator|=
name|ISC_SOCKET_MAXEVENTS
expr_stmt|;
name|manager
operator|->
name|events
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|epoll_event
argument_list|)
operator|*
name|manager
operator|->
name|nevents
argument_list|)
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|events
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|manager
operator|->
name|epoll_fd
operator|=
name|epoll_create
argument_list|(
name|manager
operator|->
name|nevents
argument_list|)
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|epoll_fd
operator|==
operator|-
literal|1
condition|)
block|{
name|result
operator|=
name|isc__errno2result
argument_list|(
name|errno
argument_list|)
expr_stmt|;
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"epoll_create %s: %s"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
operator|->
name|events
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|epoll_event
argument_list|)
operator|*
name|manager
operator|->
name|nevents
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|USE_WATCHER_THREAD
name|result
operator|=
name|watch_fd
argument_list|(
name|manager
argument_list|,
name|manager
operator|->
name|pipe_fds
index|[
literal|0
index|]
argument_list|,
name|SELECT_POKE_READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|close
argument_list|(
name|manager
operator|->
name|epoll_fd
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
operator|->
name|events
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|epoll_event
argument_list|)
operator|*
name|manager
operator|->
name|nevents
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* USE_WATCHER_THREAD */
elif|#
directive|elif
name|defined
argument_list|(
name|USE_DEVPOLL
argument_list|)
comment|/* 	 * XXXJT: /dev/poll seems to reject large numbers of events, 	 * so we should be careful about redefining ISC_SOCKET_MAXEVENTS. 	 */
name|manager
operator|->
name|nevents
operator|=
name|ISC_SOCKET_MAXEVENTS
expr_stmt|;
name|manager
operator|->
name|events
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pollfd
argument_list|)
operator|*
name|manager
operator|->
name|nevents
argument_list|)
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|events
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
comment|/* 	 * Note: fdpollinfo should be able to support all possible FDs, so 	 * it must have maxsocks entries (not nevents). 	 */
name|manager
operator|->
name|fdpollinfo
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
name|pollinfo_t
argument_list|)
operator|*
name|manager
operator|->
name|maxsocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|fdpollinfo
operator|==
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
operator|->
name|events
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pollfd
argument_list|)
operator|*
name|manager
operator|->
name|nevents
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|memset
argument_list|(
name|manager
operator|->
name|fdpollinfo
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|pollinfo_t
argument_list|)
operator|*
name|manager
operator|->
name|maxsocks
argument_list|)
expr_stmt|;
name|manager
operator|->
name|devpoll_fd
operator|=
name|open
argument_list|(
literal|"/dev/poll"
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|devpoll_fd
operator|==
operator|-
literal|1
condition|)
block|{
name|result
operator|=
name|isc__errno2result
argument_list|(
name|errno
argument_list|)
expr_stmt|;
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"open(/dev/poll) %s: %s"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
operator|->
name|events
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pollfd
argument_list|)
operator|*
name|manager
operator|->
name|nevents
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
operator|->
name|fdpollinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|pollinfo_t
argument_list|)
operator|*
name|manager
operator|->
name|maxsocks
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|USE_WATCHER_THREAD
name|result
operator|=
name|watch_fd
argument_list|(
name|manager
argument_list|,
name|manager
operator|->
name|pipe_fds
index|[
literal|0
index|]
argument_list|,
name|SELECT_POKE_READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|close
argument_list|(
name|manager
operator|->
name|devpoll_fd
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
operator|->
name|events
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pollfd
argument_list|)
operator|*
name|manager
operator|->
name|nevents
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
operator|->
name|fdpollinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|pollinfo_t
argument_list|)
operator|*
name|manager
operator|->
name|maxsocks
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* USE_WATCHER_THREAD */
elif|#
directive|elif
name|defined
argument_list|(
name|USE_SELECT
argument_list|)
name|UNUSED
argument_list|(
name|result
argument_list|)
expr_stmt|;
if|#
directive|if
name|ISC_SOCKET_MAXSOCKETS
operator|>
name|FD_SETSIZE
comment|/* 	 * Note: this code should also cover the case of MAXSOCKETS<= 	 * FD_SETSIZE, but we separate the cases to avoid possible portability 	 * issues regarding howmany() and the actual representation of fd_set. 	 */
name|manager
operator|->
name|fd_bufsize
operator|=
name|howmany
argument_list|(
name|manager
operator|->
name|maxsocks
argument_list|,
name|NFDBITS
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|fd_mask
argument_list|)
expr_stmt|;
else|#
directive|else
name|manager
operator|->
name|fd_bufsize
operator|=
sizeof|sizeof
argument_list|(
name|fd_set
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|manager
operator|->
name|read_fds
operator|=
name|NULL
expr_stmt|;
name|manager
operator|->
name|read_fds_copy
operator|=
name|NULL
expr_stmt|;
name|manager
operator|->
name|write_fds
operator|=
name|NULL
expr_stmt|;
name|manager
operator|->
name|write_fds_copy
operator|=
name|NULL
expr_stmt|;
name|manager
operator|->
name|read_fds
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|manager
operator|->
name|fd_bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|read_fds
operator|!=
name|NULL
condition|)
name|manager
operator|->
name|read_fds_copy
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|manager
operator|->
name|fd_bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|read_fds_copy
operator|!=
name|NULL
condition|)
name|manager
operator|->
name|write_fds
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|manager
operator|->
name|fd_bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|write_fds
operator|!=
name|NULL
condition|)
block|{
name|manager
operator|->
name|write_fds_copy
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|manager
operator|->
name|fd_bufsize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|manager
operator|->
name|write_fds_copy
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|manager
operator|->
name|write_fds
operator|!=
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
operator|->
name|write_fds
argument_list|,
name|manager
operator|->
name|fd_bufsize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|manager
operator|->
name|read_fds_copy
operator|!=
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
operator|->
name|read_fds_copy
argument_list|,
name|manager
operator|->
name|fd_bufsize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|manager
operator|->
name|read_fds
operator|!=
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
operator|->
name|read_fds
argument_list|,
name|manager
operator|->
name|fd_bufsize
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|memset
argument_list|(
name|manager
operator|->
name|read_fds
argument_list|,
literal|0
argument_list|,
name|manager
operator|->
name|fd_bufsize
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|manager
operator|->
name|write_fds
argument_list|,
literal|0
argument_list|,
name|manager
operator|->
name|fd_bufsize
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_WATCHER_THREAD
operator|(
name|void
operator|)
name|watch_fd
argument_list|(
name|manager
argument_list|,
name|manager
operator|->
name|pipe_fds
index|[
literal|0
index|]
argument_list|,
name|SELECT_POKE_READ
argument_list|)
expr_stmt|;
name|manager
operator|->
name|maxfd
operator|=
name|manager
operator|->
name|pipe_fds
index|[
literal|0
index|]
expr_stmt|;
else|#
directive|else
comment|/* USE_WATCHER_THREAD */
name|manager
operator|->
name|maxfd
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* USE_WATCHER_THREAD */
endif|#
directive|endif
comment|/* USE_KQUEUE */
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|cleanup_watcher
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|isc__socketmgr_t
modifier|*
name|manager
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|USE_WATCHER_THREAD
name|isc_result_t
name|result
decl_stmt|;
name|result
operator|=
name|unwatch_fd
argument_list|(
name|manager
argument_list|,
name|manager
operator|->
name|pipe_fds
index|[
literal|0
index|]
argument_list|,
name|SELECT_POKE_READ
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"epoll_ctl(DEL) %s"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* USE_WATCHER_THREAD */
ifdef|#
directive|ifdef
name|USE_KQUEUE
name|close
argument_list|(
name|manager
operator|->
name|kqueue_fd
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
operator|->
name|events
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|kevent
argument_list|)
operator|*
name|manager
operator|->
name|nevents
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|USE_EPOLL
argument_list|)
name|close
argument_list|(
name|manager
operator|->
name|epoll_fd
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
operator|->
name|events
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|epoll_event
argument_list|)
operator|*
name|manager
operator|->
name|nevents
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|USE_DEVPOLL
argument_list|)
name|close
argument_list|(
name|manager
operator|->
name|devpoll_fd
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
operator|->
name|events
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pollfd
argument_list|)
operator|*
name|manager
operator|->
name|nevents
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
operator|->
name|fdpollinfo
argument_list|,
sizeof|sizeof
argument_list|(
name|pollinfo_t
argument_list|)
operator|*
name|manager
operator|->
name|maxsocks
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|USE_SELECT
argument_list|)
if|if
condition|(
name|manager
operator|->
name|read_fds
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
operator|->
name|read_fds
argument_list|,
name|manager
operator|->
name|fd_bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|read_fds_copy
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
operator|->
name|read_fds_copy
argument_list|,
name|manager
operator|->
name|fd_bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|write_fds
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
operator|->
name|write_fds
argument_list|,
name|manager
operator|->
name|fd_bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|write_fds_copy
operator|!=
name|NULL
condition|)
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
operator|->
name|write_fds_copy
argument_list|,
name|manager
operator|->
name|fd_bufsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_KQUEUE */
block|}
end_function

begin_function
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socketmgr_create
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|isc_socketmgr_t
modifier|*
modifier|*
name|managerp
parameter_list|)
block|{
return|return
operator|(
name|isc__socketmgr_create2
argument_list|(
name|mctx
argument_list|,
name|managerp
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socketmgr_create2
parameter_list|(
name|isc_mem_t
modifier|*
name|mctx
parameter_list|,
name|isc_socketmgr_t
modifier|*
modifier|*
name|managerp
parameter_list|,
name|unsigned
name|int
name|maxsocks
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|isc__socketmgr_t
modifier|*
name|manager
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_WATCHER_THREAD
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
endif|#
directive|endif
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|managerp
operator|!=
name|NULL
operator|&&
operator|*
name|managerp
operator|==
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_SHARED_MANAGER
if|if
condition|(
name|socketmgr
operator|!=
name|NULL
condition|)
block|{
comment|/* Don't allow maxsocks to be updated */
if|if
condition|(
name|maxsocks
operator|>
literal|0
operator|&&
name|socketmgr
operator|->
name|maxsocks
operator|!=
name|maxsocks
condition|)
return|return
operator|(
name|ISC_R_EXISTS
operator|)
return|;
name|socketmgr
operator|->
name|refs
operator|++
expr_stmt|;
operator|*
name|managerp
operator|=
operator|(
name|isc_socketmgr_t
operator|*
operator|)
name|socketmgr
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* USE_SHARED_MANAGER */
if|if
condition|(
name|maxsocks
operator|==
literal|0
condition|)
name|maxsocks
operator|=
name|ISC_SOCKET_MAXSOCKETS
expr_stmt|;
name|manager
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|manager
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|manager
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
comment|/* zero-clear so that necessary cleanup on failure will be easy */
name|memset
argument_list|(
name|manager
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|manager
operator|->
name|maxsocks
operator|=
name|maxsocks
expr_stmt|;
name|manager
operator|->
name|reserved
operator|=
literal|0
expr_stmt|;
name|manager
operator|->
name|maxudp
operator|=
literal|0
expr_stmt|;
name|manager
operator|->
name|fds
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|manager
operator|->
name|maxsocks
operator|*
sizeof|sizeof
argument_list|(
name|isc__socket_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|fds
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|free_manager
goto|;
block|}
name|manager
operator|->
name|fdstate
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|manager
operator|->
name|maxsocks
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|fdstate
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|free_manager
goto|;
block|}
name|manager
operator|->
name|stats
operator|=
name|NULL
expr_stmt|;
name|manager
operator|->
name|common
operator|.
name|methods
operator|=
operator|&
name|socketmgrmethods
expr_stmt|;
name|manager
operator|->
name|common
operator|.
name|magic
operator|=
name|ISCAPI_SOCKETMGR_MAGIC
expr_stmt|;
name|manager
operator|->
name|common
operator|.
name|impmagic
operator|=
name|SOCKET_MANAGER_MAGIC
expr_stmt|;
name|manager
operator|->
name|mctx
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
name|manager
operator|->
name|fds
argument_list|,
literal|0
argument_list|,
name|manager
operator|->
name|maxsocks
operator|*
sizeof|sizeof
argument_list|(
name|isc_socket_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|manager
operator|->
name|socklist
argument_list|)
expr_stmt|;
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|free_manager
goto|;
name|manager
operator|->
name|fdlock
operator|=
name|isc_mem_get
argument_list|(
name|mctx
argument_list|,
name|FDLOCK_COUNT
operator|*
sizeof|sizeof
argument_list|(
name|isc_mutex_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|fdlock
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|ISC_R_NOMEMORY
expr_stmt|;
goto|goto
name|cleanup_lock
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FDLOCK_COUNT
condition|;
name|i
operator|++
control|)
block|{
name|result
operator|=
name|isc_mutex_init
argument_list|(
operator|&
name|manager
operator|->
name|fdlock
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|DESTROYLOCK
argument_list|(
operator|&
name|manager
operator|->
name|fdlock
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
operator|->
name|fdlock
argument_list|,
name|FDLOCK_COUNT
operator|*
sizeof|sizeof
argument_list|(
name|isc_mutex_t
argument_list|)
argument_list|)
expr_stmt|;
name|manager
operator|->
name|fdlock
operator|=
name|NULL
expr_stmt|;
goto|goto
name|cleanup_lock
goto|;
block|}
block|}
ifdef|#
directive|ifdef
name|USE_WATCHER_THREAD
if|if
condition|(
name|isc_condition_init
argument_list|(
operator|&
name|manager
operator|->
name|shutdown_ok
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_condition_init() %s"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
goto|goto
name|cleanup_lock
goto|;
block|}
comment|/* 	 * Create the special fds that will be used to wake up the 	 * select/poll loop when something internal needs to be done. 	 */
if|if
condition|(
name|pipe
argument_list|(
name|manager
operator|->
name|pipe_fds
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"pipe() %s: %s"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
goto|goto
name|cleanup_condition
goto|;
block|}
name|RUNTIME_CHECK
argument_list|(
name|make_nonblock
argument_list|(
name|manager
operator|->
name|pipe_fds
index|[
literal|0
index|]
argument_list|)
operator|==
name|ISC_R_SUCCESS
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|RUNTIME_CHECK(make_nonblock(manager->pipe_fds[1]) == ISC_R_SUCCESS);
endif|#
directive|endif
endif|#
directive|endif
comment|/* USE_WATCHER_THREAD */
ifdef|#
directive|ifdef
name|USE_SHARED_MANAGER
name|manager
operator|->
name|refs
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* USE_SHARED_MANAGER */
comment|/* 	 * Set up initial state for the select loop 	 */
name|result
operator|=
name|setup_watcher
argument_list|(
name|mctx
argument_list|,
name|manager
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
goto|goto
name|cleanup
goto|;
name|memset
argument_list|(
name|manager
operator|->
name|fdstate
argument_list|,
literal|0
argument_list|,
name|manager
operator|->
name|maxsocks
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_WATCHER_THREAD
comment|/* 	 * Start up the select/poll thread. 	 */
if|if
condition|(
name|isc_thread_create
argument_list|(
name|watcher
argument_list|,
name|manager
argument_list|,
operator|&
name|manager
operator|->
name|watcher
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_thread_create() %s"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|)
expr_stmt|;
name|cleanup_watcher
argument_list|(
name|mctx
argument_list|,
name|manager
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
endif|#
directive|endif
comment|/* USE_WATCHER_THREAD */
name|isc_mem_attach
argument_list|(
name|mctx
argument_list|,
operator|&
name|manager
operator|->
name|mctx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_SHARED_MANAGER
name|socketmgr
operator|=
name|manager
expr_stmt|;
endif|#
directive|endif
comment|/* USE_SHARED_MANAGER */
operator|*
name|managerp
operator|=
operator|(
name|isc_socketmgr_t
operator|*
operator|)
name|manager
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
name|cleanup
label|:
ifdef|#
directive|ifdef
name|USE_WATCHER_THREAD
operator|(
name|void
operator|)
name|close
argument_list|(
name|manager
operator|->
name|pipe_fds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|manager
operator|->
name|pipe_fds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_WATCHER_THREAD */
ifdef|#
directive|ifdef
name|USE_WATCHER_THREAD
name|cleanup_condition
label|:
operator|(
name|void
operator|)
name|isc_condition_destroy
argument_list|(
operator|&
name|manager
operator|->
name|shutdown_ok
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_WATCHER_THREAD */
name|cleanup_lock
label|:
if|if
condition|(
name|manager
operator|->
name|fdlock
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FDLOCK_COUNT
condition|;
name|i
operator|++
control|)
name|DESTROYLOCK
argument_list|(
operator|&
name|manager
operator|->
name|fdlock
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|DESTROYLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|free_manager
label|:
if|if
condition|(
name|manager
operator|->
name|fdlock
operator|!=
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
operator|->
name|fdlock
argument_list|,
name|FDLOCK_COUNT
operator|*
sizeof|sizeof
argument_list|(
name|isc_mutex_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|manager
operator|->
name|fdstate
operator|!=
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
operator|->
name|fdstate
argument_list|,
name|manager
operator|->
name|maxsocks
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|manager
operator|->
name|fds
operator|!=
name|NULL
condition|)
block|{
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
operator|->
name|fds
argument_list|,
name|manager
operator|->
name|maxsocks
operator|*
sizeof|sizeof
argument_list|(
name|isc_socket_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|manager
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BIND9
end_ifdef

begin_function
name|isc_result_t
name|isc__socketmgr_getmaxsockets
parameter_list|(
name|isc_socketmgr_t
modifier|*
name|manager0
parameter_list|,
name|unsigned
name|int
modifier|*
name|nsockp
parameter_list|)
block|{
name|isc__socketmgr_t
modifier|*
name|manager
init|=
operator|(
name|isc__socketmgr_t
operator|*
operator|)
name|manager0
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|nsockp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|nsockp
operator|=
name|manager
operator|->
name|maxsocks
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|void
name|isc__socketmgr_setstats
parameter_list|(
name|isc_socketmgr_t
modifier|*
name|manager0
parameter_list|,
name|isc_stats_t
modifier|*
name|stats
parameter_list|)
block|{
name|isc__socketmgr_t
modifier|*
name|manager
init|=
operator|(
name|isc__socketmgr_t
operator|*
operator|)
name|manager0
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|ISC_LIST_EMPTY
argument_list|(
name|manager
operator|->
name|socklist
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|manager
operator|->
name|stats
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|isc_stats_ncounters
argument_list|(
name|stats
argument_list|)
operator|==
name|isc_sockstatscounter_max
argument_list|)
expr_stmt|;
name|isc_stats_attach
argument_list|(
name|stats
argument_list|,
operator|&
name|manager
operator|->
name|stats
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|ISC_SOCKETFUNC_SCOPE
name|void
name|isc__socketmgr_destroy
parameter_list|(
name|isc_socketmgr_t
modifier|*
modifier|*
name|managerp
parameter_list|)
block|{
name|isc__socketmgr_t
modifier|*
name|manager
decl_stmt|;
name|int
name|i
decl_stmt|;
name|isc_mem_t
modifier|*
name|mctx
decl_stmt|;
comment|/* 	 * Destroy a socket manager. 	 */
name|REQUIRE
argument_list|(
name|managerp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|manager
operator|=
operator|(
name|isc__socketmgr_t
operator|*
operator|)
operator|*
name|managerp
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_SHARED_MANAGER
name|manager
operator|->
name|refs
operator|--
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|refs
operator|>
literal|0
condition|)
block|{
operator|*
name|managerp
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|socketmgr
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* USE_SHARED_MANAGER */
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for all sockets to be destroyed. 	 */
while|while
condition|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|manager
operator|->
name|socklist
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_WATCHER_THREAD
name|manager_log
argument_list|(
name|manager
argument_list|,
name|CREATION
argument_list|,
literal|"%s"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_SOCKETSREMAIN
argument_list|,
literal|"sockets exist"
argument_list|)
argument_list|)
expr_stmt|;
name|WAIT
argument_list|(
operator|&
name|manager
operator|->
name|shutdown_ok
argument_list|,
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* USE_WATCHER_THREAD */
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isc__taskmgr_dispatch
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_WATCHER_THREAD */
block|}
name|UNLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * Here, poke our select/poll thread.  Do this by closing the write 	 * half of the pipe, which will send EOF to the read half. 	 * This is currently a no-op in the non-threaded case. 	 */
name|select_poke
argument_list|(
name|manager
argument_list|,
literal|0
argument_list|,
name|SELECT_POKE_SHUTDOWN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_WATCHER_THREAD
comment|/* 	 * Wait for thread to exit. 	 */
if|if
condition|(
name|isc_thread_join
argument_list|(
name|manager
operator|->
name|watcher
argument_list|,
name|NULL
argument_list|)
operator|!=
name|ISC_R_SUCCESS
condition|)
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"isc_thread_join() %s"
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_WATCHER_THREAD */
comment|/* 	 * Clean up. 	 */
name|cleanup_watcher
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|manager
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_WATCHER_THREAD
operator|(
name|void
operator|)
name|close
argument_list|(
name|manager
operator|->
name|pipe_fds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|manager
operator|->
name|pipe_fds
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|isc_condition_destroy
argument_list|(
operator|&
name|manager
operator|->
name|shutdown_ok
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_WATCHER_THREAD */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|manager
operator|->
name|maxsocks
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|manager
operator|->
name|fdstate
index|[
name|i
index|]
operator|==
name|CLOSE_PENDING
condition|)
comment|/* no need to lock */
operator|(
name|void
operator|)
name|close
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|manager
operator|->
name|fds
argument_list|,
name|manager
operator|->
name|maxsocks
operator|*
sizeof|sizeof
argument_list|(
name|isc__socket_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|manager
operator|->
name|fdstate
argument_list|,
name|manager
operator|->
name|maxsocks
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|stats
operator|!=
name|NULL
condition|)
name|isc_stats_detach
argument_list|(
operator|&
name|manager
operator|->
name|stats
argument_list|)
expr_stmt|;
if|if
condition|(
name|manager
operator|->
name|fdlock
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FDLOCK_COUNT
condition|;
name|i
operator|++
control|)
name|DESTROYLOCK
argument_list|(
operator|&
name|manager
operator|->
name|fdlock
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|isc_mem_put
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|manager
operator|->
name|fdlock
argument_list|,
name|FDLOCK_COUNT
operator|*
sizeof|sizeof
argument_list|(
name|isc_mutex_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|DESTROYLOCK
argument_list|(
operator|&
name|manager
operator|->
name|lock
argument_list|)
expr_stmt|;
name|manager
operator|->
name|common
operator|.
name|magic
operator|=
literal|0
expr_stmt|;
name|manager
operator|->
name|common
operator|.
name|impmagic
operator|=
literal|0
expr_stmt|;
name|mctx
operator|=
name|manager
operator|->
name|mctx
expr_stmt|;
name|isc_mem_put
argument_list|(
name|mctx
argument_list|,
name|manager
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|isc_mem_detach
argument_list|(
operator|&
name|mctx
argument_list|)
expr_stmt|;
operator|*
name|managerp
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_SHARED_MANAGER
name|socketmgr
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|socket_recv
parameter_list|(
name|isc__socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socketevent_t
modifier|*
name|dev
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|int
name|io_state
decl_stmt|;
name|isc_boolean_t
name|have_lock
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_task_t
modifier|*
name|ntask
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|dev
operator|->
name|ev_sender
operator|=
name|task
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_udp
condition|)
block|{
name|io_state
operator|=
name|doio_recv
argument_list|(
name|sock
argument_list|,
name|dev
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|have_lock
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|)
condition|)
name|io_state
operator|=
name|doio_recv
argument_list|(
name|sock
argument_list|,
name|dev
argument_list|)
expr_stmt|;
else|else
name|io_state
operator|=
name|DOIO_SOFT
expr_stmt|;
block|}
switch|switch
condition|(
name|io_state
condition|)
block|{
case|case
name|DOIO_SOFT
case|:
comment|/* 		 * We couldn't read all or part of the request right now, so 		 * queue it. 		 * 		 * Attach to socket and to task 		 */
name|isc_task_attach
argument_list|(
name|task
argument_list|,
operator|&
name|ntask
argument_list|)
expr_stmt|;
name|dev
operator|->
name|attributes
operator||=
name|ISC_SOCKEVENTATTR_ATTACHED
expr_stmt|;
if|if
condition|(
operator|!
name|have_lock
condition|)
block|{
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|have_lock
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
comment|/* 		 * Enqueue the request.  If the socket was previously not being 		 * watched, poke the watcher to start paying attention to it. 		 */
if|if
condition|(
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|)
operator|&&
operator|!
name|sock
operator|->
name|pending_recv
condition|)
name|select_poke
argument_list|(
name|sock
operator|->
name|manager
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|SELECT_POKE_READ
argument_list|)
expr_stmt|;
name|ISC_LIST_ENQUEUE
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|,
name|dev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
name|socket_log
argument_list|(
name|sock
argument_list|,
name|NULL
argument_list|,
name|EVENT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"socket_recv: event %p -> task %p"
argument_list|,
name|dev
argument_list|,
name|ntask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|ISC_SOCKFLAG_IMMEDIATE
operator|)
operator|!=
literal|0
condition|)
name|result
operator|=
name|ISC_R_INPROGRESS
expr_stmt|;
break|break;
case|case
name|DOIO_EOF
case|:
name|dev
operator|->
name|result
operator|=
name|ISC_R_EOF
expr_stmt|;
comment|/* fallthrough */
case|case
name|DOIO_HARD
case|:
case|case
name|DOIO_SUCCESS
case|:
if|if
condition|(
operator|(
name|flags
operator|&
name|ISC_SOCKFLAG_IMMEDIATE
operator|)
operator|==
literal|0
condition|)
name|send_recvdone_event
argument_list|(
name|sock
argument_list|,
operator|&
name|dev
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|have_lock
condition|)
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_recvv
parameter_list|(
name|isc_socket_t
modifier|*
name|sock0
parameter_list|,
name|isc_bufferlist_t
modifier|*
name|buflist
parameter_list|,
name|unsigned
name|int
name|minimum
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|isc__socket_t
modifier|*
name|sock
init|=
operator|(
name|isc__socket_t
operator|*
operator|)
name|sock0
decl_stmt|;
name|isc_socketevent_t
modifier|*
name|dev
decl_stmt|;
name|isc__socketmgr_t
modifier|*
name|manager
decl_stmt|;
name|unsigned
name|int
name|iocount
decl_stmt|;
name|isc_buffer_t
modifier|*
name|buffer
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|buflist
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
operator|*
name|buflist
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|task
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|action
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|manager
operator|=
name|sock
operator|->
name|manager
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|iocount
operator|=
name|isc_bufferlist_availablecount
argument_list|(
name|buflist
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|iocount
operator|>
literal|0
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|bound
argument_list|)
expr_stmt|;
name|dev
operator|=
name|allocate_socketevent
argument_list|(
name|sock
argument_list|,
name|ISC_SOCKEVENT_RECVDONE
argument_list|,
name|action
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
comment|/* 	 * UDP sockets are always partial read 	 */
if|if
condition|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_udp
condition|)
name|dev
operator|->
name|minimum
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|minimum
operator|==
literal|0
condition|)
name|dev
operator|->
name|minimum
operator|=
name|iocount
expr_stmt|;
else|else
name|dev
operator|->
name|minimum
operator|=
name|minimum
expr_stmt|;
block|}
comment|/* 	 * Move each buffer from the passed in list to our internal one. 	 */
name|buffer
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|buflist
argument_list|)
expr_stmt|;
while|while
condition|(
name|buffer
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_DEQUEUE
argument_list|(
operator|*
name|buflist
argument_list|,
name|buffer
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_ENQUEUE
argument_list|(
name|dev
operator|->
name|bufferlist
argument_list|,
name|buffer
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|buflist
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|socket_recv
argument_list|(
name|sock
argument_list|,
name|dev
argument_list|,
name|task
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_recv
parameter_list|(
name|isc_socket_t
modifier|*
name|sock0
parameter_list|,
name|isc_region_t
modifier|*
name|region
parameter_list|,
name|unsigned
name|int
name|minimum
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|isc__socket_t
modifier|*
name|sock
init|=
operator|(
name|isc__socket_t
operator|*
operator|)
name|sock0
decl_stmt|;
name|isc_socketevent_t
modifier|*
name|dev
decl_stmt|;
name|isc__socketmgr_t
modifier|*
name|manager
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|action
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|manager
operator|=
name|sock
operator|->
name|manager
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|bound
argument_list|)
expr_stmt|;
name|dev
operator|=
name|allocate_socketevent
argument_list|(
name|sock
argument_list|,
name|ISC_SOCKEVENT_RECVDONE
argument_list|,
name|action
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
return|return
operator|(
name|isc__socket_recv2
argument_list|(
name|sock0
argument_list|,
name|region
argument_list|,
name|minimum
argument_list|,
name|task
argument_list|,
name|dev
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_recv2
parameter_list|(
name|isc_socket_t
modifier|*
name|sock0
parameter_list|,
name|isc_region_t
modifier|*
name|region
parameter_list|,
name|unsigned
name|int
name|minimum
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_socketevent_t
modifier|*
name|event
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|isc__socket_t
modifier|*
name|sock
init|=
operator|(
name|isc__socket_t
operator|*
operator|)
name|sock0
decl_stmt|;
name|event
operator|->
name|ev_sender
operator|=
name|sock
expr_stmt|;
name|event
operator|->
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|event
operator|->
name|bufferlist
argument_list|)
expr_stmt|;
name|event
operator|->
name|region
operator|=
operator|*
name|region
expr_stmt|;
name|event
operator|->
name|n
operator|=
literal|0
expr_stmt|;
name|event
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|event
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
comment|/* 	 * UDP sockets are always partial read. 	 */
if|if
condition|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_udp
condition|)
name|event
operator|->
name|minimum
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|minimum
operator|==
literal|0
condition|)
name|event
operator|->
name|minimum
operator|=
name|region
operator|->
name|length
expr_stmt|;
else|else
name|event
operator|->
name|minimum
operator|=
name|minimum
expr_stmt|;
block|}
return|return
operator|(
name|socket_recv
argument_list|(
name|sock
argument_list|,
name|event
argument_list|,
name|task
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|isc_result_t
name|socket_send
parameter_list|(
name|isc__socket_t
modifier|*
name|sock
parameter_list|,
name|isc_socketevent_t
modifier|*
name|dev
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|address
parameter_list|,
name|struct
name|in6_pktinfo
modifier|*
name|pktinfo
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|int
name|io_state
decl_stmt|;
name|isc_boolean_t
name|have_lock
init|=
name|ISC_FALSE
decl_stmt|;
name|isc_task_t
modifier|*
name|ntask
init|=
name|NULL
decl_stmt|;
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|dev
operator|->
name|ev_sender
operator|=
name|task
expr_stmt|;
name|set_dev_address
argument_list|(
name|address
argument_list|,
name|sock
argument_list|,
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|pktinfo
operator|!=
name|NULL
condition|)
block|{
name|dev
operator|->
name|attributes
operator||=
name|ISC_SOCKEVENTATTR_PKTINFO
expr_stmt|;
name|dev
operator|->
name|pktinfo
operator|=
operator|*
name|pktinfo
expr_stmt|;
if|if
condition|(
operator|!
name|isc_sockaddr_issitelocal
argument_list|(
operator|&
name|dev
operator|->
name|address
argument_list|)
operator|&&
operator|!
name|isc_sockaddr_islinklocal
argument_list|(
operator|&
name|dev
operator|->
name|address
argument_list|)
condition|)
block|{
name|socket_log
argument_list|(
name|sock
argument_list|,
name|NULL
argument_list|,
name|TRACE
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_PKTINFOPROVIDED
argument_list|,
literal|"pktinfo structure provided, ifindex %u "
literal|"(set to 0)"
argument_list|,
name|pktinfo
operator|->
name|ipi6_ifindex
argument_list|)
expr_stmt|;
comment|/* 			 * Set the pktinfo index to 0 here, to let the 			 * kernel decide what interface it should send on. 			 */
name|dev
operator|->
name|pktinfo
operator|.
name|ipi6_ifindex
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_udp
condition|)
name|io_state
operator|=
name|doio_send
argument_list|(
name|sock
argument_list|,
name|dev
argument_list|)
expr_stmt|;
else|else
block|{
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|have_lock
operator|=
name|ISC_TRUE
expr_stmt|;
if|if
condition|(
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|send_list
argument_list|)
condition|)
name|io_state
operator|=
name|doio_send
argument_list|(
name|sock
argument_list|,
name|dev
argument_list|)
expr_stmt|;
else|else
name|io_state
operator|=
name|DOIO_SOFT
expr_stmt|;
block|}
switch|switch
condition|(
name|io_state
condition|)
block|{
case|case
name|DOIO_SOFT
case|:
comment|/* 		 * We couldn't send all or part of the request right now, so 		 * queue it unless ISC_SOCKFLAG_NORETRY is set. 		 */
if|if
condition|(
operator|(
name|flags
operator|&
name|ISC_SOCKFLAG_NORETRY
operator|)
operator|==
literal|0
condition|)
block|{
name|isc_task_attach
argument_list|(
name|task
argument_list|,
operator|&
name|ntask
argument_list|)
expr_stmt|;
name|dev
operator|->
name|attributes
operator||=
name|ISC_SOCKEVENTATTR_ATTACHED
expr_stmt|;
if|if
condition|(
operator|!
name|have_lock
condition|)
block|{
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|have_lock
operator|=
name|ISC_TRUE
expr_stmt|;
block|}
comment|/* 			 * Enqueue the request.  If the socket was previously 			 * not being watched, poke the watcher to start 			 * paying attention to it. 			 */
if|if
condition|(
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|send_list
argument_list|)
operator|&&
operator|!
name|sock
operator|->
name|pending_send
condition|)
name|select_poke
argument_list|(
name|sock
operator|->
name|manager
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|SELECT_POKE_WRITE
argument_list|)
expr_stmt|;
name|ISC_LIST_ENQUEUE
argument_list|(
name|sock
operator|->
name|send_list
argument_list|,
name|dev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
name|socket_log
argument_list|(
name|sock
argument_list|,
name|NULL
argument_list|,
name|EVENT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|"socket_send: event %p -> task %p"
argument_list|,
name|dev
argument_list|,
name|ntask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|ISC_SOCKFLAG_IMMEDIATE
operator|)
operator|!=
literal|0
condition|)
name|result
operator|=
name|ISC_R_INPROGRESS
expr_stmt|;
break|break;
block|}
case|case
name|DOIO_HARD
case|:
case|case
name|DOIO_SUCCESS
case|:
if|if
condition|(
operator|(
name|flags
operator|&
name|ISC_SOCKFLAG_IMMEDIATE
operator|)
operator|==
literal|0
condition|)
name|send_senddone_event
argument_list|(
name|sock
argument_list|,
operator|&
name|dev
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|have_lock
condition|)
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_send
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_region_t
modifier|*
name|region
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|)
block|{
comment|/* 	 * REQUIRE() checking is performed in isc_socket_sendto(). 	 */
return|return
operator|(
name|isc__socket_sendto
argument_list|(
name|sock
argument_list|,
name|region
argument_list|,
name|task
argument_list|,
name|action
argument_list|,
name|arg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_sendto
parameter_list|(
name|isc_socket_t
modifier|*
name|sock0
parameter_list|,
name|isc_region_t
modifier|*
name|region
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|address
parameter_list|,
name|struct
name|in6_pktinfo
modifier|*
name|pktinfo
parameter_list|)
block|{
name|isc__socket_t
modifier|*
name|sock
init|=
operator|(
name|isc__socket_t
operator|*
operator|)
name|sock0
decl_stmt|;
name|isc_socketevent_t
modifier|*
name|dev
decl_stmt|;
name|isc__socketmgr_t
modifier|*
name|manager
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|region
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|task
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|action
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|manager
operator|=
name|sock
operator|->
name|manager
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|bound
argument_list|)
expr_stmt|;
name|dev
operator|=
name|allocate_socketevent
argument_list|(
name|sock
argument_list|,
name|ISC_SOCKEVENT_SENDDONE
argument_list|,
name|action
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
name|dev
operator|->
name|region
operator|=
operator|*
name|region
expr_stmt|;
return|return
operator|(
name|socket_send
argument_list|(
name|sock
argument_list|,
name|dev
argument_list|,
name|task
argument_list|,
name|address
argument_list|,
name|pktinfo
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_sendv
parameter_list|(
name|isc_socket_t
modifier|*
name|sock
parameter_list|,
name|isc_bufferlist_t
modifier|*
name|buflist
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|)
block|{
return|return
operator|(
name|isc__socket_sendtov
argument_list|(
name|sock
argument_list|,
name|buflist
argument_list|,
name|task
argument_list|,
name|action
argument_list|,
name|arg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_sendtov
parameter_list|(
name|isc_socket_t
modifier|*
name|sock0
parameter_list|,
name|isc_bufferlist_t
modifier|*
name|buflist
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|address
parameter_list|,
name|struct
name|in6_pktinfo
modifier|*
name|pktinfo
parameter_list|)
block|{
name|isc__socket_t
modifier|*
name|sock
init|=
operator|(
name|isc__socket_t
operator|*
operator|)
name|sock0
decl_stmt|;
name|isc_socketevent_t
modifier|*
name|dev
decl_stmt|;
name|isc__socketmgr_t
modifier|*
name|manager
decl_stmt|;
name|unsigned
name|int
name|iocount
decl_stmt|;
name|isc_buffer_t
modifier|*
name|buffer
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|buflist
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|ISC_LIST_EMPTY
argument_list|(
operator|*
name|buflist
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|task
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|action
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|manager
operator|=
name|sock
operator|->
name|manager
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|iocount
operator|=
name|isc_bufferlist_usedcount
argument_list|(
name|buflist
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|iocount
operator|>
literal|0
argument_list|)
expr_stmt|;
name|dev
operator|=
name|allocate_socketevent
argument_list|(
name|sock
argument_list|,
name|ISC_SOCKEVENT_SENDDONE
argument_list|,
name|action
argument_list|,
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
comment|/* 	 * Move each buffer from the passed in list to our internal one. 	 */
name|buffer
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|buflist
argument_list|)
expr_stmt|;
while|while
condition|(
name|buffer
operator|!=
name|NULL
condition|)
block|{
name|ISC_LIST_DEQUEUE
argument_list|(
operator|*
name|buflist
argument_list|,
name|buffer
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ISC_LIST_ENQUEUE
argument_list|(
name|dev
operator|->
name|bufferlist
argument_list|,
name|buffer
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|ISC_LIST_HEAD
argument_list|(
operator|*
name|buflist
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|socket_send
argument_list|(
name|sock
argument_list|,
name|dev
argument_list|,
name|task
argument_list|,
name|address
argument_list|,
name|pktinfo
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_sendto2
parameter_list|(
name|isc_socket_t
modifier|*
name|sock0
parameter_list|,
name|isc_region_t
modifier|*
name|region
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|address
parameter_list|,
name|struct
name|in6_pktinfo
modifier|*
name|pktinfo
parameter_list|,
name|isc_socketevent_t
modifier|*
name|event
parameter_list|,
name|unsigned
name|int
name|flags
parameter_list|)
block|{
name|isc__socket_t
modifier|*
name|sock
init|=
operator|(
name|isc__socket_t
operator|*
operator|)
name|sock0
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|(
name|flags
operator|&
operator|~
operator|(
name|ISC_SOCKFLAG_IMMEDIATE
operator||
name|ISC_SOCKFLAG_NORETRY
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|ISC_SOCKFLAG_NORETRY
operator|)
operator|!=
literal|0
condition|)
name|REQUIRE
argument_list|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_udp
argument_list|)
expr_stmt|;
name|event
operator|->
name|ev_sender
operator|=
name|sock
expr_stmt|;
name|event
operator|->
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
name|ISC_LIST_INIT
argument_list|(
name|event
operator|->
name|bufferlist
argument_list|)
expr_stmt|;
name|event
operator|->
name|region
operator|=
operator|*
name|region
expr_stmt|;
name|event
operator|->
name|n
operator|=
literal|0
expr_stmt|;
name|event
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|event
operator|->
name|attributes
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|socket_send
argument_list|(
name|sock
argument_list|,
name|event
argument_list|,
name|task
argument_list|,
name|address
argument_list|,
name|pktinfo
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|ISC_SOCKETFUNC_SCOPE
name|void
name|isc__socket_cleanunix
parameter_list|(
name|isc_sockaddr_t
modifier|*
name|sockaddr
parameter_list|,
name|isc_boolean_t
name|active
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ISC_PLATFORM_HAVESYSUNH
name|int
name|s
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
if|if
condition|(
name|sockaddr
operator|->
name|type
operator|.
name|sa
operator|.
name|sa_family
operator|!=
name|AF_UNIX
condition|)
return|return;
ifndef|#
directive|ifndef
name|S_ISSOCK
if|#
directive|if
name|defined
argument_list|(
name|S_IFMT
argument_list|)
operator|&&
name|defined
argument_list|(
name|S_IFSOCK
argument_list|)
define|#
directive|define
name|S_ISSOCK
parameter_list|(
name|mode
parameter_list|)
value|((mode& S_IFMT)==S_IFSOCK)
elif|#
directive|elif
name|defined
argument_list|(
name|_S_IFMT
argument_list|)
operator|&&
name|defined
argument_list|(
name|S_IFSOCK
argument_list|)
define|#
directive|define
name|S_ISSOCK
parameter_list|(
name|mode
parameter_list|)
value|((mode& _S_IFMT)==S_IFSOCK)
endif|#
directive|endif
endif|#
directive|endif
ifndef|#
directive|ifndef
name|S_ISFIFO
if|#
directive|if
name|defined
argument_list|(
name|S_IFMT
argument_list|)
operator|&&
name|defined
argument_list|(
name|S_IFIFO
argument_list|)
define|#
directive|define
name|S_ISFIFO
parameter_list|(
name|mode
parameter_list|)
value|((mode& S_IFMT)==S_IFIFO)
elif|#
directive|elif
name|defined
argument_list|(
name|_S_IFMT
argument_list|)
operator|&&
name|defined
argument_list|(
name|S_IFIFO
argument_list|)
define|#
directive|define
name|S_ISFIFO
parameter_list|(
name|mode
parameter_list|)
value|((mode& _S_IFMT)==S_IFIFO)
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|S_ISFIFO
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|S_ISSOCK
argument_list|)
error|#
directive|error
error|You need to define S_ISFIFO and S_ISSOCK as appropriate for your platform.  See<sys/stat.h>.
endif|#
directive|endif
ifndef|#
directive|ifndef
name|S_ISFIFO
define|#
directive|define
name|S_ISFIFO
parameter_list|(
name|mode
parameter_list|)
value|0
endif|#
directive|endif
ifndef|#
directive|ifndef
name|S_ISSOCK
define|#
directive|define
name|S_ISSOCK
parameter_list|(
name|mode
parameter_list|)
value|0
endif|#
directive|endif
if|if
condition|(
name|active
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|sockaddr
operator|->
name|type
operator|.
name|sunix
operator|.
name|sun_path
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|isc_lctx
argument_list|,
name|ISC_LOGCATEGORY_GENERAL
argument_list|,
name|ISC_LOGMODULE_SOCKET
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"isc_socket_cleanunix: stat(%s): %s"
argument_list|,
name|sockaddr
operator|->
name|type
operator|.
name|sunix
operator|.
name|sun_path
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|S_ISSOCK
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
operator|||
name|S_ISFIFO
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
block|{
name|isc_log_write
argument_list|(
name|isc_lctx
argument_list|,
name|ISC_LOGCATEGORY_GENERAL
argument_list|,
name|ISC_LOGMODULE_SOCKET
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"isc_socket_cleanunix: %s: not a socket"
argument_list|,
name|sockaddr
operator|->
name|type
operator|.
name|sunix
operator|.
name|sun_path
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|unlink
argument_list|(
name|sockaddr
operator|->
name|type
operator|.
name|sunix
operator|.
name|sun_path
argument_list|)
operator|<
literal|0
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|isc_lctx
argument_list|,
name|ISC_LOGCATEGORY_GENERAL
argument_list|,
name|ISC_LOGMODULE_SOCKET
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"isc_socket_cleanunix: unlink(%s): %s"
argument_list|,
name|sockaddr
operator|->
name|type
operator|.
name|sunix
operator|.
name|sun_path
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|s
operator|=
name|socket
argument_list|(
name|AF_UNIX
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|isc_lctx
argument_list|,
name|ISC_LOGCATEGORY_GENERAL
argument_list|,
name|ISC_LOGMODULE_SOCKET
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"isc_socket_cleanunix: socket(%s): %s"
argument_list|,
name|sockaddr
operator|->
name|type
operator|.
name|sunix
operator|.
name|sun_path
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|stat
argument_list|(
name|sockaddr
operator|->
name|type
operator|.
name|sunix
operator|.
name|sun_path
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOENT
case|:
comment|/* We exited cleanly last time */
break|break;
default|default:
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|isc_lctx
argument_list|,
name|ISC_LOGCATEGORY_GENERAL
argument_list|,
name|ISC_LOGMODULE_SOCKET
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"isc_socket_cleanunix: stat(%s): %s"
argument_list|,
name|sockaddr
operator|->
name|type
operator|.
name|sunix
operator|.
name|sun_path
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|S_ISSOCK
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
operator|||
name|S_ISFIFO
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
block|{
name|isc_log_write
argument_list|(
name|isc_lctx
argument_list|,
name|ISC_LOGCATEGORY_GENERAL
argument_list|,
name|ISC_LOGMODULE_SOCKET
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"isc_socket_cleanunix: %s: not a socket"
argument_list|,
name|sockaddr
operator|->
name|type
operator|.
name|sunix
operator|.
name|sun_path
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|connect
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sockaddr
operator|->
name|type
operator|.
name|sunix
argument_list|,
sizeof|sizeof
argument_list|(
name|sockaddr
operator|->
name|type
operator|.
name|sunix
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ECONNREFUSED
case|:
case|case
name|ECONNRESET
case|:
if|if
condition|(
name|unlink
argument_list|(
name|sockaddr
operator|->
name|type
operator|.
name|sunix
operator|.
name|sun_path
argument_list|)
operator|<
literal|0
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|isc_lctx
argument_list|,
name|ISC_LOGCATEGORY_GENERAL
argument_list|,
name|ISC_LOGMODULE_SOCKET
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"isc_socket_cleanunix: "
literal|"unlink(%s): %s"
argument_list|,
name|sockaddr
operator|->
name|type
operator|.
name|sunix
operator|.
name|sun_path
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|isc_lctx
argument_list|,
name|ISC_LOGCATEGORY_GENERAL
argument_list|,
name|ISC_LOGMODULE_SOCKET
argument_list|,
name|ISC_LOG_WARNING
argument_list|,
literal|"isc_socket_cleanunix: connect(%s): %s"
argument_list|,
name|sockaddr
operator|->
name|type
operator|.
name|sunix
operator|.
name|sun_path
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|cleanup
label|:
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
else|#
directive|else
name|UNUSED
argument_list|(
name|sockaddr
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|active
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_permunix
parameter_list|(
name|isc_sockaddr_t
modifier|*
name|sockaddr
parameter_list|,
name|isc_uint32_t
name|perm
parameter_list|,
name|isc_uint32_t
name|owner
parameter_list|,
name|isc_uint32_t
name|group
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|ISC_PLATFORM_HAVESYSUNH
name|isc_result_t
name|result
init|=
name|ISC_R_SUCCESS
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|char
name|path
index|[
sizeof|sizeof
argument_list|(
name|sockaddr
operator|->
name|type
operator|.
name|sunix
operator|.
name|sun_path
argument_list|)
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|NEED_SECURE_DIRECTORY
name|char
modifier|*
name|slash
decl_stmt|;
endif|#
directive|endif
name|REQUIRE
argument_list|(
name|sockaddr
operator|->
name|type
operator|.
name|sa
operator|.
name|sa_family
operator|==
name|AF_UNIX
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|strlen
argument_list|(
name|sockaddr
operator|->
name|type
operator|.
name|sunix
operator|.
name|sun_path
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|path
argument_list|,
name|sockaddr
operator|->
name|type
operator|.
name|sunix
operator|.
name|sun_path
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NEED_SECURE_DIRECTORY
name|slash
operator|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|slash
operator|!=
name|path
condition|)
operator|*
name|slash
operator|=
literal|'\0'
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|path
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|path
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|chmod
argument_list|(
name|path
argument_list|,
name|perm
argument_list|)
operator|<
literal|0
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|isc_lctx
argument_list|,
name|ISC_LOGCATEGORY_GENERAL
argument_list|,
name|ISC_LOGMODULE_SOCKET
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"isc_socket_permunix: chmod(%s, %d): %s"
argument_list|,
name|path
argument_list|,
name|perm
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
if|if
condition|(
name|chown
argument_list|(
name|path
argument_list|,
name|owner
argument_list|,
name|group
argument_list|)
operator|<
literal|0
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_log_write
argument_list|(
name|isc_lctx
argument_list|,
name|ISC_LOGCATEGORY_GENERAL
argument_list|,
name|ISC_LOGMODULE_SOCKET
argument_list|,
name|ISC_LOG_ERROR
argument_list|,
literal|"isc_socket_permunix: chown(%s, %d, %d): %s"
argument_list|,
name|path
argument_list|,
name|owner
argument_list|,
name|group
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_FAILURE
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
else|#
directive|else
name|UNUSED
argument_list|(
name|sockaddr
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|perm
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|owner
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|group
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_bind
parameter_list|(
name|isc_socket_t
modifier|*
name|sock0
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|sockaddr
parameter_list|,
name|unsigned
name|int
name|options
parameter_list|)
block|{
name|isc__socket_t
modifier|*
name|sock
init|=
operator|(
name|isc__socket_t
operator|*
operator|)
name|sock0
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|int
name|on
init|=
literal|1
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
operator|!
name|sock
operator|->
name|bound
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|pf
operator|!=
name|sockaddr
operator|->
name|type
operator|.
name|sa
operator|.
name|sa_family
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAMILYMISMATCH
operator|)
return|;
block|}
comment|/* 	 * Only set SO_REUSEADDR when we want a specific port. 	 */
ifdef|#
directive|ifdef
name|AF_UNIX
if|if
condition|(
name|sock
operator|->
name|pf
operator|==
name|AF_UNIX
condition|)
goto|goto
name|bind_socket
goto|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|options
operator|&
name|ISC_SOCKET_REUSEADDRESS
operator|)
operator|!=
literal|0
operator|&&
name|isc_sockaddr_getport
argument_list|(
name|sockaddr
argument_list|)
operator|!=
operator|(
name|in_port_t
operator|)
literal|0
operator|&&
name|setsockopt
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"setsockopt(%d) %s"
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Press on... */
block|}
ifdef|#
directive|ifdef
name|AF_UNIX
name|bind_socket
label|:
endif|#
directive|endif
if|if
condition|(
name|bind
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
operator|&
name|sockaddr
operator|->
name|type
operator|.
name|sa
argument_list|,
name|sockaddr
operator|->
name|length
argument_list|)
operator|<
literal|0
condition|)
block|{
name|inc_stats
argument_list|(
name|sock
operator|->
name|manager
operator|->
name|stats
argument_list|,
name|sock
operator|->
name|statsindex
index|[
name|STATID_BINDFAIL
index|]
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|EACCES
case|:
return|return
operator|(
name|ISC_R_NOPERM
operator|)
return|;
case|case
name|EADDRNOTAVAIL
case|:
return|return
operator|(
name|ISC_R_ADDRNOTAVAIL
operator|)
return|;
case|case
name|EADDRINUSE
case|:
return|return
operator|(
name|ISC_R_ADDRINUSE
operator|)
return|;
case|case
name|EINVAL
case|:
return|return
operator|(
name|ISC_R_BOUND
operator|)
return|;
default|default:
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"bind: %s"
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
block|}
name|socket_log
argument_list|(
name|sock
argument_list|,
name|sockaddr
argument_list|,
name|TRACE
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_BOUND
argument_list|,
literal|"bound"
argument_list|)
expr_stmt|;
name|sock
operator|->
name|bound
operator|=
literal|1
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Enable this only for specific OS versions, and only when they have repaired  * their problems with it.  Until then, this is is broken and needs to be  * diabled by default.  See RT22589 for details.  */
end_comment

begin_undef
undef|#
directive|undef
name|ENABLE_ACCEPTFILTER
end_undef

begin_function
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_filter
parameter_list|(
name|isc_socket_t
modifier|*
name|sock0
parameter_list|,
specifier|const
name|char
modifier|*
name|filter
parameter_list|)
block|{
name|isc__socket_t
modifier|*
name|sock
init|=
operator|(
name|isc__socket_t
operator|*
operator|)
name|sock0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SO_ACCEPTFILTER
argument_list|)
operator|&&
name|defined
argument_list|(
name|ENABLE_ACCEPTFILTER
argument_list|)
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|struct
name|accept_filter_arg
name|afa
decl_stmt|;
else|#
directive|else
name|UNUSED
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|filter
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SO_ACCEPTFILTER
argument_list|)
operator|&&
name|defined
argument_list|(
name|ENABLE_ACCEPTFILTER
argument_list|)
name|bzero
argument_list|(
operator|&
name|afa
argument_list|,
sizeof|sizeof
argument_list|(
name|afa
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|afa
operator|.
name|af_name
argument_list|,
name|filter
argument_list|,
sizeof|sizeof
argument_list|(
name|afa
operator|.
name|af_name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_ACCEPTFILTER
argument_list|,
operator|&
name|afa
argument_list|,
sizeof|sizeof
argument_list|(
name|afa
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|socket_log
argument_list|(
name|sock
argument_list|,
name|NULL
argument_list|,
name|CREATION
argument_list|,
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_SOCKET
argument_list|,
name|ISC_MSG_FILTER
argument_list|,
literal|"setsockopt(SO_ACCEPTFILTER): %s"
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_FAILURE
operator|)
return|;
block|}
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|ISC_R_NOTIMPLEMENTED
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Set up to listen on a given socket.  We do this by creating an internal  * event that will be dispatched when the socket has read activity.  The  * watcher will send the internal event to the task when there is a new  * connection.  *  * Unlike in read, we don't preallocate a done event here.  Every time there  * is a new connection we'll have to allocate a new one anyway, so we might  * as well keep things simple rather than having to track them.  */
end_comment

begin_function
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_listen
parameter_list|(
name|isc_socket_t
modifier|*
name|sock0
parameter_list|,
name|unsigned
name|int
name|backlog
parameter_list|)
block|{
name|isc__socket_t
modifier|*
name|sock
init|=
operator|(
name|isc__socket_t
operator|*
operator|)
name|sock0
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|sock
operator|->
name|listener
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sock
operator|->
name|bound
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_tcp
operator|||
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_unix
argument_list|)
expr_stmt|;
if|if
condition|(
name|backlog
operator|==
literal|0
condition|)
name|backlog
operator|=
name|SOMAXCONN
expr_stmt|;
if|if
condition|(
name|listen
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
operator|(
name|int
operator|)
name|backlog
argument_list|)
operator|<
literal|0
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"listen: %s"
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
block|}
name|sock
operator|->
name|listener
operator|=
literal|1
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This should try to do aggressive accept() XXXMLG  */
end_comment

begin_function
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_accept
parameter_list|(
name|isc_socket_t
modifier|*
name|sock0
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|isc__socket_t
modifier|*
name|sock
init|=
operator|(
name|isc__socket_t
operator|*
operator|)
name|sock0
decl_stmt|;
name|isc_socket_newconnev_t
modifier|*
name|dev
decl_stmt|;
name|isc__socketmgr_t
modifier|*
name|manager
decl_stmt|;
name|isc_task_t
modifier|*
name|ntask
init|=
name|NULL
decl_stmt|;
name|isc__socket_t
modifier|*
name|nsock
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|isc_boolean_t
name|do_poke
init|=
name|ISC_FALSE
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|manager
operator|=
name|sock
operator|->
name|manager
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|sock
operator|->
name|listener
argument_list|)
expr_stmt|;
comment|/* 	 * Sender field is overloaded here with the task we will be sending 	 * this event to.  Just before the actual event is delivered the 	 * actual ev_sender will be touched up to be the socket. 	 */
name|dev
operator|=
operator|(
name|isc_socket_newconnev_t
operator|*
operator|)
name|isc_event_allocate
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|task
argument_list|,
name|ISC_SOCKEVENT_NEWCONN
argument_list|,
name|action
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|ISC_LINK_INIT
argument_list|(
name|dev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
name|result
operator|=
name|allocate_socket
argument_list|(
name|manager
argument_list|,
name|sock
operator|->
name|type
argument_list|,
operator|&
name|nsock
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|ISC_R_SUCCESS
condition|)
block|{
name|isc_event_free
argument_list|(
name|ISC_EVENT_PTR
argument_list|(
operator|&
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
comment|/* 	 * Attach to socket and to task. 	 */
name|isc_task_attach
argument_list|(
name|task
argument_list|,
operator|&
name|ntask
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_task_exiting
argument_list|(
name|ntask
argument_list|)
condition|)
block|{
name|free_socket
argument_list|(
operator|&
name|nsock
argument_list|)
expr_stmt|;
name|isc_task_detach
argument_list|(
operator|&
name|ntask
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
name|ISC_EVENT_PTR
argument_list|(
operator|&
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SHUTTINGDOWN
operator|)
return|;
block|}
name|nsock
operator|->
name|references
operator|++
expr_stmt|;
name|nsock
operator|->
name|statsindex
operator|=
name|sock
operator|->
name|statsindex
expr_stmt|;
name|dev
operator|->
name|ev_sender
operator|=
name|ntask
expr_stmt|;
name|dev
operator|->
name|newsocket
operator|=
operator|(
name|isc_socket_t
operator|*
operator|)
name|nsock
expr_stmt|;
comment|/* 	 * Poke watcher here.  We still have the socket locked, so there 	 * is no race condition.  We will keep the lock for such a short 	 * bit of time waking it up now or later won't matter all that much. 	 */
if|if
condition|(
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|accept_list
argument_list|)
condition|)
name|do_poke
operator|=
name|ISC_TRUE
expr_stmt|;
name|ISC_LIST_ENQUEUE
argument_list|(
name|sock
operator|->
name|accept_list
argument_list|,
name|dev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_poke
condition|)
name|select_poke
argument_list|(
name|manager
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|SELECT_POKE_ACCEPT
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_connect
parameter_list|(
name|isc_socket_t
modifier|*
name|sock0
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|addr
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|isc_taskaction_t
name|action
parameter_list|,
specifier|const
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|isc__socket_t
modifier|*
name|sock
init|=
operator|(
name|isc__socket_t
operator|*
operator|)
name|sock0
decl_stmt|;
name|isc_socket_connev_t
modifier|*
name|dev
decl_stmt|;
name|isc_task_t
modifier|*
name|ntask
init|=
name|NULL
decl_stmt|;
name|isc__socketmgr_t
modifier|*
name|manager
decl_stmt|;
name|int
name|cc
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|char
name|addrbuf
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|addr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|task
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|action
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|manager
operator|=
name|sock
operator|->
name|manager
expr_stmt|;
name|REQUIRE
argument_list|(
name|VALID_MANAGER
argument_list|(
name|manager
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|addr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|isc_sockaddr_ismulticast
argument_list|(
name|addr
argument_list|)
condition|)
return|return
operator|(
name|ISC_R_MULTICAST
operator|)
return|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
operator|!
name|sock
operator|->
name|connecting
argument_list|)
expr_stmt|;
name|dev
operator|=
operator|(
name|isc_socket_connev_t
operator|*
operator|)
name|isc_event_allocate
argument_list|(
name|manager
operator|->
name|mctx
argument_list|,
name|sock
argument_list|,
name|ISC_SOCKEVENT_CONNECT
argument_list|,
name|action
argument_list|,
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_NOMEMORY
operator|)
return|;
block|}
name|ISC_LINK_INIT
argument_list|(
name|dev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
comment|/* 	 * Try to do the connect right away, as there can be only one 	 * outstanding, and it might happen to complete. 	 */
name|sock
operator|->
name|peer_address
operator|=
operator|*
name|addr
expr_stmt|;
name|cc
operator|=
name|connect
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
operator|&
name|addr
operator|->
name|type
operator|.
name|sa
argument_list|,
name|addr
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|<
literal|0
condition|)
block|{
comment|/* 		 * HP-UX "fails" to connect a UDP socket and sets errno to 		 * EINPROGRESS if it's non-blocking.  We'd rather regard this as 		 * a success and let the user detect it if it's really an error 		 * at the time of sending a packet on the socket. 		 */
if|if
condition|(
name|sock
operator|->
name|type
operator|==
name|isc_sockettype_udp
operator|&&
name|errno
operator|==
name|EINPROGRESS
condition|)
block|{
name|cc
operator|=
literal|0
expr_stmt|;
goto|goto
name|success
goto|;
block|}
if|if
condition|(
name|SOFT_ERROR
argument_list|(
name|errno
argument_list|)
operator|||
name|errno
operator|==
name|EINPROGRESS
condition|)
goto|goto
name|queue
goto|;
switch|switch
condition|(
name|errno
condition|)
block|{
define|#
directive|define
name|ERROR_MATCH
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|case a: dev->result = b; goto err_exit;
name|ERROR_MATCH
argument_list|(
name|EACCES
argument_list|,
name|ISC_R_NOPERM
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|EADDRNOTAVAIL
argument_list|,
name|ISC_R_ADDRNOTAVAIL
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|EAFNOSUPPORT
argument_list|,
name|ISC_R_ADDRNOTAVAIL
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|ECONNREFUSED
argument_list|,
name|ISC_R_CONNREFUSED
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|EHOSTUNREACH
argument_list|,
name|ISC_R_HOSTUNREACH
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EHOSTDOWN
name|ERROR_MATCH
argument_list|(
name|EHOSTDOWN
argument_list|,
name|ISC_R_HOSTUNREACH
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ERROR_MATCH
argument_list|(
name|ENETUNREACH
argument_list|,
name|ISC_R_NETUNREACH
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|ENOBUFS
argument_list|,
name|ISC_R_NORESOURCES
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|EPERM
argument_list|,
name|ISC_R_HOSTUNREACH
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|EPIPE
argument_list|,
name|ISC_R_NOTCONNECTED
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|ECONNRESET
argument_list|,
name|ISC_R_CONNECTIONRESET
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|ERROR_MATCH
block|}
name|sock
operator|->
name|connected
operator|=
literal|0
expr_stmt|;
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc_sockaddr_format
argument_list|(
name|addr
argument_list|,
name|addrbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|addrbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"connect(%s) %d/%s"
argument_list|,
name|addrbuf
argument_list|,
name|errno
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|inc_stats
argument_list|(
name|sock
operator|->
name|manager
operator|->
name|stats
argument_list|,
name|sock
operator|->
name|statsindex
index|[
name|STATID_CONNECTFAIL
index|]
argument_list|)
expr_stmt|;
name|isc_event_free
argument_list|(
name|ISC_EVENT_PTR
argument_list|(
operator|&
name|dev
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_UNEXPECTED
operator|)
return|;
name|err_exit
label|:
name|sock
operator|->
name|connected
operator|=
literal|0
expr_stmt|;
name|isc_task_send
argument_list|(
name|task
argument_list|,
name|ISC_EVENT_PTR
argument_list|(
operator|&
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|inc_stats
argument_list|(
name|sock
operator|->
name|manager
operator|->
name|stats
argument_list|,
name|sock
operator|->
name|statsindex
index|[
name|STATID_CONNECTFAIL
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
comment|/* 	 * If connect completed, fire off the done event. 	 */
name|success
label|:
if|if
condition|(
name|cc
operator|==
literal|0
condition|)
block|{
name|sock
operator|->
name|connected
operator|=
literal|1
expr_stmt|;
name|sock
operator|->
name|bound
operator|=
literal|1
expr_stmt|;
name|dev
operator|->
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|isc_task_send
argument_list|(
name|task
argument_list|,
name|ISC_EVENT_PTR
argument_list|(
operator|&
name|dev
argument_list|)
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|inc_stats
argument_list|(
name|sock
operator|->
name|manager
operator|->
name|stats
argument_list|,
name|sock
operator|->
name|statsindex
index|[
name|STATID_CONNECT
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
name|queue
label|:
comment|/* 	 * Attach to task. 	 */
name|isc_task_attach
argument_list|(
name|task
argument_list|,
operator|&
name|ntask
argument_list|)
expr_stmt|;
name|sock
operator|->
name|connecting
operator|=
literal|1
expr_stmt|;
name|dev
operator|->
name|ev_sender
operator|=
name|ntask
expr_stmt|;
comment|/* 	 * Poke watcher here.  We still have the socket locked, so there 	 * is no race condition.  We will keep the lock for such a short 	 * bit of time waking it up now or later won't matter all that much. 	 */
if|if
condition|(
name|sock
operator|->
name|connect_ev
operator|==
name|NULL
condition|)
name|select_poke
argument_list|(
name|manager
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|SELECT_POKE_CONNECT
argument_list|)
expr_stmt|;
name|sock
operator|->
name|connect_ev
operator|=
name|dev
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called when a socket with a pending connect() finishes.  */
end_comment

begin_function
specifier|static
name|void
name|internal_connect
parameter_list|(
name|isc_task_t
modifier|*
name|me
parameter_list|,
name|isc_event_t
modifier|*
name|ev
parameter_list|)
block|{
name|isc__socket_t
modifier|*
name|sock
decl_stmt|;
name|isc_socket_connev_t
modifier|*
name|dev
decl_stmt|;
name|isc_task_t
modifier|*
name|task
decl_stmt|;
name|int
name|cc
decl_stmt|;
name|ISC_SOCKADDR_LEN_T
name|optlen
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|char
name|peerbuf
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
name|UNUSED
argument_list|(
name|me
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ev
operator|->
name|ev_type
operator|==
name|ISC_SOCKEVENT_INTW
argument_list|)
expr_stmt|;
name|sock
operator|=
name|ev
operator|->
name|ev_sender
expr_stmt|;
name|INSIST
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * When the internal event was sent the reference count was bumped 	 * to keep the socket around for us.  Decrement the count here. 	 */
name|INSIST
argument_list|(
name|sock
operator|->
name|references
operator|>
literal|0
argument_list|)
expr_stmt|;
name|sock
operator|->
name|references
operator|--
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|references
operator|==
literal|0
condition|)
block|{
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|destroy
argument_list|(
operator|&
name|sock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Has this event been canceled? 	 */
name|dev
operator|=
name|sock
operator|->
name|connect_ev
expr_stmt|;
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
name|INSIST
argument_list|(
operator|!
name|sock
operator|->
name|connecting
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|INSIST
argument_list|(
name|sock
operator|->
name|connecting
argument_list|)
expr_stmt|;
name|sock
operator|->
name|connecting
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Get any possible error status here. 	 */
name|optlen
operator|=
sizeof|sizeof
argument_list|(
name|cc
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockopt
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_ERROR
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|cc
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|optlen
argument_list|)
operator|<
literal|0
condition|)
name|cc
operator|=
name|errno
expr_stmt|;
else|else
name|errno
operator|=
name|cc
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * If the error is EAGAIN, just re-select on this 		 * fd and pretend nothing strange happened. 		 */
if|if
condition|(
name|SOFT_ERROR
argument_list|(
name|errno
argument_list|)
operator|||
name|errno
operator|==
name|EINPROGRESS
condition|)
block|{
name|sock
operator|->
name|connecting
operator|=
literal|1
expr_stmt|;
name|select_poke
argument_list|(
name|sock
operator|->
name|manager
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|SELECT_POKE_CONNECT
argument_list|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|inc_stats
argument_list|(
name|sock
operator|->
name|manager
operator|->
name|stats
argument_list|,
name|sock
operator|->
name|statsindex
index|[
name|STATID_CONNECTFAIL
index|]
argument_list|)
expr_stmt|;
comment|/* 		 * Translate other errors into ISC_R_* flavors. 		 */
switch|switch
condition|(
name|errno
condition|)
block|{
define|#
directive|define
name|ERROR_MATCH
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|case a: dev->result = b; break;
name|ERROR_MATCH
argument_list|(
name|EACCES
argument_list|,
name|ISC_R_NOPERM
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|EADDRNOTAVAIL
argument_list|,
name|ISC_R_ADDRNOTAVAIL
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|EAFNOSUPPORT
argument_list|,
name|ISC_R_ADDRNOTAVAIL
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|ECONNREFUSED
argument_list|,
name|ISC_R_CONNREFUSED
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|EHOSTUNREACH
argument_list|,
name|ISC_R_HOSTUNREACH
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EHOSTDOWN
name|ERROR_MATCH
argument_list|(
name|EHOSTDOWN
argument_list|,
name|ISC_R_HOSTUNREACH
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ERROR_MATCH
argument_list|(
name|ENETUNREACH
argument_list|,
name|ISC_R_NETUNREACH
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|ENOBUFS
argument_list|,
name|ISC_R_NORESOURCES
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|EPERM
argument_list|,
name|ISC_R_HOSTUNREACH
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|EPIPE
argument_list|,
name|ISC_R_NOTCONNECTED
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|ETIMEDOUT
argument_list|,
name|ISC_R_TIMEDOUT
argument_list|)
expr_stmt|;
name|ERROR_MATCH
argument_list|(
name|ECONNRESET
argument_list|,
name|ISC_R_CONNECTIONRESET
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|ERROR_MATCH
default|default:
name|dev
operator|->
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
name|isc_sockaddr_format
argument_list|(
operator|&
name|sock
operator|->
name|peer_address
argument_list|,
name|peerbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|peerbuf
argument_list|)
argument_list|)
expr_stmt|;
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"internal_connect: connect(%s) %s"
argument_list|,
name|peerbuf
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|inc_stats
argument_list|(
name|sock
operator|->
name|manager
operator|->
name|stats
argument_list|,
name|sock
operator|->
name|statsindex
index|[
name|STATID_CONNECT
index|]
argument_list|)
expr_stmt|;
name|dev
operator|->
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|sock
operator|->
name|connected
operator|=
literal|1
expr_stmt|;
name|sock
operator|->
name|bound
operator|=
literal|1
expr_stmt|;
block|}
name|sock
operator|->
name|connect_ev
operator|=
name|NULL
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|task
operator|=
name|dev
operator|->
name|ev_sender
expr_stmt|;
name|dev
operator|->
name|ev_sender
operator|=
name|sock
expr_stmt|;
name|isc_task_sendanddetach
argument_list|(
operator|&
name|task
argument_list|,
name|ISC_EVENT_PTR
argument_list|(
operator|&
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_getpeername
parameter_list|(
name|isc_socket_t
modifier|*
name|sock0
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|addressp
parameter_list|)
block|{
name|isc__socket_t
modifier|*
name|sock
init|=
operator|(
name|isc__socket_t
operator|*
operator|)
name|sock0
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|addressp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|connected
condition|)
block|{
operator|*
name|addressp
operator|=
name|sock
operator|->
name|peer_address
expr_stmt|;
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|ISC_R_NOTCONNECTED
expr_stmt|;
block|}
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|ISC_SOCKETFUNC_SCOPE
name|isc_result_t
name|isc__socket_getsockname
parameter_list|(
name|isc_socket_t
modifier|*
name|sock0
parameter_list|,
name|isc_sockaddr_t
modifier|*
name|addressp
parameter_list|)
block|{
name|isc__socket_t
modifier|*
name|sock
init|=
operator|(
name|isc__socket_t
operator|*
operator|)
name|sock0
decl_stmt|;
name|ISC_SOCKADDR_LEN_T
name|len
decl_stmt|;
name|isc_result_t
name|result
decl_stmt|;
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|addressp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sock
operator|->
name|bound
condition|)
block|{
name|result
operator|=
name|ISC_R_NOTBOUND
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|result
operator|=
name|ISC_R_SUCCESS
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|addressp
operator|->
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
operator|&
name|addressp
operator|->
name|type
operator|.
name|sa
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"getsockname: %s"
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
name|result
operator|=
name|ISC_R_UNEXPECTED
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|addressp
operator|->
name|length
operator|=
operator|(
name|unsigned
name|int
operator|)
name|len
expr_stmt|;
name|out
label|:
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Run through the list of events on this socket, and cancel the ones  * queued for task "task" of type "how".  "how" is a bitmask.  */
end_comment

begin_function
name|ISC_SOCKETFUNC_SCOPE
name|void
name|isc__socket_cancel
parameter_list|(
name|isc_socket_t
modifier|*
name|sock0
parameter_list|,
name|isc_task_t
modifier|*
name|task
parameter_list|,
name|unsigned
name|int
name|how
parameter_list|)
block|{
name|isc__socket_t
modifier|*
name|sock
init|=
operator|(
name|isc__socket_t
operator|*
operator|)
name|sock0
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Quick exit if there is nothing to do.  Don't even bother locking 	 * in this case. 	 */
if|if
condition|(
name|how
operator|==
literal|0
condition|)
return|return;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
comment|/* 	 * All of these do the same thing, more or less. 	 * Each will: 	 *	o If the internal event is marked as "posted" try to 	 *	  remove it from the task's queue.  If this fails, mark it 	 *	  as canceled instead, and let the task clean it up later. 	 *	o For each I/O request for that task of that type, post 	 *	  its done event with status of "ISC_R_CANCELED". 	 *	o Reset any state needed. 	 */
if|if
condition|(
operator|(
operator|(
name|how
operator|&
name|ISC_SOCKCANCEL_RECV
operator|)
operator|==
name|ISC_SOCKCANCEL_RECV
operator|)
operator|&&
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|)
condition|)
block|{
name|isc_socketevent_t
modifier|*
name|dev
decl_stmt|;
name|isc_socketevent_t
modifier|*
name|next
decl_stmt|;
name|isc_task_t
modifier|*
name|current_task
decl_stmt|;
name|dev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sock
operator|->
name|recv_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|dev
operator|!=
name|NULL
condition|)
block|{
name|current_task
operator|=
name|dev
operator|->
name|ev_sender
expr_stmt|;
name|next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|dev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|task
operator|==
name|NULL
operator|)
operator|||
operator|(
name|task
operator|==
name|current_task
operator|)
condition|)
block|{
name|dev
operator|->
name|result
operator|=
name|ISC_R_CANCELED
expr_stmt|;
name|send_recvdone_event
argument_list|(
name|sock
argument_list|,
operator|&
name|dev
argument_list|)
expr_stmt|;
block|}
name|dev
operator|=
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
operator|(
name|how
operator|&
name|ISC_SOCKCANCEL_SEND
operator|)
operator|==
name|ISC_SOCKCANCEL_SEND
operator|)
operator|&&
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|send_list
argument_list|)
condition|)
block|{
name|isc_socketevent_t
modifier|*
name|dev
decl_stmt|;
name|isc_socketevent_t
modifier|*
name|next
decl_stmt|;
name|isc_task_t
modifier|*
name|current_task
decl_stmt|;
name|dev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sock
operator|->
name|send_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|dev
operator|!=
name|NULL
condition|)
block|{
name|current_task
operator|=
name|dev
operator|->
name|ev_sender
expr_stmt|;
name|next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|dev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|task
operator|==
name|NULL
operator|)
operator|||
operator|(
name|task
operator|==
name|current_task
operator|)
condition|)
block|{
name|dev
operator|->
name|result
operator|=
name|ISC_R_CANCELED
expr_stmt|;
name|send_senddone_event
argument_list|(
name|sock
argument_list|,
operator|&
name|dev
argument_list|)
expr_stmt|;
block|}
name|dev
operator|=
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
operator|(
name|how
operator|&
name|ISC_SOCKCANCEL_ACCEPT
operator|)
operator|==
name|ISC_SOCKCANCEL_ACCEPT
operator|)
operator|&&
operator|!
name|ISC_LIST_EMPTY
argument_list|(
name|sock
operator|->
name|accept_list
argument_list|)
condition|)
block|{
name|isc_socket_newconnev_t
modifier|*
name|dev
decl_stmt|;
name|isc_socket_newconnev_t
modifier|*
name|next
decl_stmt|;
name|isc_task_t
modifier|*
name|current_task
decl_stmt|;
name|dev
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|sock
operator|->
name|accept_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|dev
operator|!=
name|NULL
condition|)
block|{
name|current_task
operator|=
name|dev
operator|->
name|ev_sender
expr_stmt|;
name|next
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|dev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|task
operator|==
name|NULL
operator|)
operator|||
operator|(
name|task
operator|==
name|current_task
operator|)
condition|)
block|{
name|ISC_LIST_UNLINK
argument_list|(
name|sock
operator|->
name|accept_list
argument_list|,
name|dev
argument_list|,
name|ev_link
argument_list|)
expr_stmt|;
name|NEWCONNSOCK
argument_list|(
name|dev
argument_list|)
operator|->
name|references
operator|--
expr_stmt|;
name|free_socket
argument_list|(
operator|(
name|isc__socket_t
operator|*
operator|*
operator|)
operator|&
name|dev
operator|->
name|newsocket
argument_list|)
expr_stmt|;
name|dev
operator|->
name|result
operator|=
name|ISC_R_CANCELED
expr_stmt|;
name|dev
operator|->
name|ev_sender
operator|=
name|sock
expr_stmt|;
name|isc_task_sendanddetach
argument_list|(
operator|&
name|current_task
argument_list|,
name|ISC_EVENT_PTR
argument_list|(
operator|&
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dev
operator|=
name|next
expr_stmt|;
block|}
block|}
comment|/* 	 * Connecting is not a list. 	 */
if|if
condition|(
operator|(
operator|(
name|how
operator|&
name|ISC_SOCKCANCEL_CONNECT
operator|)
operator|==
name|ISC_SOCKCANCEL_CONNECT
operator|)
operator|&&
name|sock
operator|->
name|connect_ev
operator|!=
name|NULL
condition|)
block|{
name|isc_socket_connev_t
modifier|*
name|dev
decl_stmt|;
name|isc_task_t
modifier|*
name|current_task
decl_stmt|;
name|INSIST
argument_list|(
name|sock
operator|->
name|connecting
argument_list|)
expr_stmt|;
name|sock
operator|->
name|connecting
operator|=
literal|0
expr_stmt|;
name|dev
operator|=
name|sock
operator|->
name|connect_ev
expr_stmt|;
name|current_task
operator|=
name|dev
operator|->
name|ev_sender
expr_stmt|;
if|if
condition|(
operator|(
name|task
operator|==
name|NULL
operator|)
operator|||
operator|(
name|task
operator|==
name|current_task
operator|)
condition|)
block|{
name|sock
operator|->
name|connect_ev
operator|=
name|NULL
expr_stmt|;
name|dev
operator|->
name|result
operator|=
name|ISC_R_CANCELED
expr_stmt|;
name|dev
operator|->
name|ev_sender
operator|=
name|sock
expr_stmt|;
name|isc_task_sendanddetach
argument_list|(
operator|&
name|current_task
argument_list|,
name|ISC_EVENT_PTR
argument_list|(
operator|&
name|dev
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ISC_SOCKETFUNC_SCOPE
name|isc_sockettype_t
name|isc__socket_gettype
parameter_list|(
name|isc_socket_t
modifier|*
name|sock0
parameter_list|)
block|{
name|isc__socket_t
modifier|*
name|sock
init|=
operator|(
name|isc__socket_t
operator|*
operator|)
name|sock0
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|sock
operator|->
name|type
operator|)
return|;
block|}
end_function

begin_function
name|ISC_SOCKETFUNC_SCOPE
name|isc_boolean_t
name|isc__socket_isbound
parameter_list|(
name|isc_socket_t
modifier|*
name|sock0
parameter_list|)
block|{
name|isc__socket_t
modifier|*
name|sock
init|=
operator|(
name|isc__socket_t
operator|*
operator|)
name|sock0
decl_stmt|;
name|isc_boolean_t
name|val
decl_stmt|;
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
operator|(
name|sock
operator|->
name|bound
operator|)
condition|?
name|ISC_TRUE
else|:
name|ISC_FALSE
operator|)
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|val
operator|)
return|;
block|}
end_function

begin_function
name|ISC_SOCKETFUNC_SCOPE
name|void
name|isc__socket_ipv6only
parameter_list|(
name|isc_socket_t
modifier|*
name|sock0
parameter_list|,
name|isc_boolean_t
name|yes
parameter_list|)
block|{
name|isc__socket_t
modifier|*
name|sock
init|=
operator|(
name|isc__socket_t
operator|*
operator|)
name|sock0
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|IPV6_V6ONLY
argument_list|)
name|int
name|onoff
init|=
name|yes
condition|?
literal|1
else|:
literal|0
decl_stmt|;
else|#
directive|else
name|UNUSED
argument_list|(
name|yes
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|sock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|sock
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPV6_V6ONLY
if|if
condition|(
name|sock
operator|->
name|pf
operator|==
name|AF_INET6
condition|)
block|{
if|if
condition|(
name|setsockopt
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
name|IPPROTO_IPV6
argument_list|,
name|IPV6_V6ONLY
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|onoff
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|char
name|strbuf
index|[
name|ISC_STRERRORSIZE
index|]
decl_stmt|;
name|isc__strerror
argument_list|(
name|errno
argument_list|,
name|strbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|strbuf
argument_list|)
argument_list|)
expr_stmt|;
name|UNEXPECTED_ERROR
argument_list|(
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
literal|"setsockopt(%d, IPV6_V6ONLY) "
literal|"%s: %s"
argument_list|,
name|sock
operator|->
name|fd
argument_list|,
name|isc_msgcat_get
argument_list|(
name|isc_msgcat
argument_list|,
name|ISC_MSGSET_GENERAL
argument_list|,
name|ISC_MSG_FAILED
argument_list|,
literal|"failed"
argument_list|)
argument_list|,
name|strbuf
argument_list|)
expr_stmt|;
block|}
block|}
name|FIX_IPV6_RECVPKTINFO
argument_list|(
name|sock
argument_list|)
expr_stmt|;
comment|/* AIX */
endif|#
directive|endif
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|USE_WATCHER_THREAD
end_ifndef

begin_comment
comment|/*  * In our assumed scenario, we can simply use a single static object.  * XXX: this is not true if the application uses multiple threads with  *      'multi-context' mode.  Fixing this is a future TODO item.  */
end_comment

begin_decl_stmt
specifier|static
name|isc_socketwait_t
name|swait_private
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|isc__socketmgr_waitevents
parameter_list|(
name|isc_socketmgr_t
modifier|*
name|manager0
parameter_list|,
name|struct
name|timeval
modifier|*
name|tvp
parameter_list|,
name|isc_socketwait_t
modifier|*
modifier|*
name|swaitp
parameter_list|)
block|{
name|isc__socketmgr_t
modifier|*
name|manager
init|=
operator|(
name|isc__socketmgr_t
operator|*
operator|)
name|manager0
decl_stmt|;
name|int
name|n
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_KQUEUE
name|struct
name|timespec
name|ts
decl_stmt|,
modifier|*
name|tsp
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_EPOLL
name|int
name|timeout
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_DEVPOLL
name|struct
name|dvpoll
name|dvp
decl_stmt|;
endif|#
directive|endif
name|REQUIRE
argument_list|(
name|swaitp
operator|!=
name|NULL
operator|&&
operator|*
name|swaitp
operator|==
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_SHARED_MANAGER
if|if
condition|(
name|manager
operator|==
name|NULL
condition|)
name|manager
operator|=
name|socketmgr
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|manager
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|USE_KQUEUE
if|if
condition|(
name|tvp
operator|!=
name|NULL
condition|)
block|{
name|ts
operator|.
name|tv_sec
operator|=
name|tvp
operator|->
name|tv_sec
expr_stmt|;
name|ts
operator|.
name|tv_nsec
operator|=
name|tvp
operator|->
name|tv_usec
operator|*
literal|1000
expr_stmt|;
name|tsp
operator|=
operator|&
name|ts
expr_stmt|;
block|}
else|else
name|tsp
operator|=
name|NULL
expr_stmt|;
name|swait_private
operator|.
name|nevents
operator|=
name|kevent
argument_list|(
name|manager
operator|->
name|kqueue_fd
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|manager
operator|->
name|events
argument_list|,
name|manager
operator|->
name|nevents
argument_list|,
name|tsp
argument_list|)
expr_stmt|;
name|n
operator|=
name|swait_private
operator|.
name|nevents
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|USE_EPOLL
argument_list|)
if|if
condition|(
name|tvp
operator|!=
name|NULL
condition|)
name|timeout
operator|=
name|tvp
operator|->
name|tv_sec
operator|*
literal|1000
operator|+
operator|(
name|tvp
operator|->
name|tv_usec
operator|+
literal|999
operator|)
operator|/
literal|1000
expr_stmt|;
else|else
name|timeout
operator|=
operator|-
literal|1
expr_stmt|;
name|swait_private
operator|.
name|nevents
operator|=
name|epoll_wait
argument_list|(
name|manager
operator|->
name|epoll_fd
argument_list|,
name|manager
operator|->
name|events
argument_list|,
name|manager
operator|->
name|nevents
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
name|n
operator|=
name|swait_private
operator|.
name|nevents
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|USE_DEVPOLL
argument_list|)
name|dvp
operator|.
name|dp_fds
operator|=
name|manager
operator|->
name|events
expr_stmt|;
name|dvp
operator|.
name|dp_nfds
operator|=
name|manager
operator|->
name|nevents
expr_stmt|;
if|if
condition|(
name|tvp
operator|!=
name|NULL
condition|)
block|{
name|dvp
operator|.
name|dp_timeout
operator|=
name|tvp
operator|->
name|tv_sec
operator|*
literal|1000
operator|+
operator|(
name|tvp
operator|->
name|tv_usec
operator|+
literal|999
operator|)
operator|/
literal|1000
expr_stmt|;
block|}
else|else
name|dvp
operator|.
name|dp_timeout
operator|=
operator|-
literal|1
expr_stmt|;
name|swait_private
operator|.
name|nevents
operator|=
name|ioctl
argument_list|(
name|manager
operator|->
name|devpoll_fd
argument_list|,
name|DP_POLL
argument_list|,
operator|&
name|dvp
argument_list|)
expr_stmt|;
name|n
operator|=
name|swait_private
operator|.
name|nevents
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|USE_SELECT
argument_list|)
name|memcpy
argument_list|(
name|manager
operator|->
name|read_fds_copy
argument_list|,
name|manager
operator|->
name|read_fds
argument_list|,
name|manager
operator|->
name|fd_bufsize
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|manager
operator|->
name|write_fds_copy
argument_list|,
name|manager
operator|->
name|write_fds
argument_list|,
name|manager
operator|->
name|fd_bufsize
argument_list|)
expr_stmt|;
name|swait_private
operator|.
name|readset
operator|=
name|manager
operator|->
name|read_fds_copy
expr_stmt|;
name|swait_private
operator|.
name|writeset
operator|=
name|manager
operator|->
name|write_fds_copy
expr_stmt|;
name|swait_private
operator|.
name|maxfd
operator|=
name|manager
operator|->
name|maxfd
operator|+
literal|1
expr_stmt|;
name|n
operator|=
name|select
argument_list|(
name|swait_private
operator|.
name|maxfd
argument_list|,
name|swait_private
operator|.
name|readset
argument_list|,
name|swait_private
operator|.
name|writeset
argument_list|,
name|NULL
argument_list|,
name|tvp
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|swaitp
operator|=
operator|&
name|swait_private
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
name|isc_result_t
name|isc__socketmgr_dispatch
parameter_list|(
name|isc_socketmgr_t
modifier|*
name|manager0
parameter_list|,
name|isc_socketwait_t
modifier|*
name|swait
parameter_list|)
block|{
name|isc__socketmgr_t
modifier|*
name|manager
init|=
operator|(
name|isc__socketmgr_t
operator|*
operator|)
name|manager0
decl_stmt|;
name|REQUIRE
argument_list|(
name|swait
operator|==
operator|&
name|swait_private
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_SHARED_MANAGER
if|if
condition|(
name|manager
operator|==
name|NULL
condition|)
name|manager
operator|=
name|socketmgr
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|manager
operator|==
name|NULL
condition|)
return|return
operator|(
name|ISC_R_NOTFOUND
operator|)
return|;
if|#
directive|if
name|defined
argument_list|(
name|USE_KQUEUE
argument_list|)
operator|||
name|defined
argument_list|(
name|USE_EPOLL
argument_list|)
operator|||
name|defined
argument_list|(
name|USE_DEVPOLL
argument_list|)
operator|(
name|void
operator|)
name|process_fds
argument_list|(
name|manager
argument_list|,
name|manager
operator|->
name|events
argument_list|,
name|swait
operator|->
name|nevents
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|USE_SELECT
argument_list|)
name|process_fds
argument_list|(
name|manager
argument_list|,
name|swait
operator|->
name|maxfd
argument_list|,
name|swait
operator|->
name|readset
argument_list|,
name|swait
operator|->
name|writeset
argument_list|)
expr_stmt|;
return|return
operator|(
name|ISC_R_SUCCESS
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USE_WATCHER_THREAD */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BIND9
end_ifdef

begin_function
name|void
name|isc__socket_setname
parameter_list|(
name|isc_socket_t
modifier|*
name|socket0
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|isc__socket_t
modifier|*
name|socket
init|=
operator|(
name|isc__socket_t
operator|*
operator|)
name|socket0
decl_stmt|;
comment|/* 	 * Name 'socket'. 	 */
name|REQUIRE
argument_list|(
name|VALID_SOCKET
argument_list|(
name|socket
argument_list|)
argument_list|)
expr_stmt|;
name|LOCK
argument_list|(
operator|&
name|socket
operator|->
name|lock
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|socket
operator|->
name|name
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|socket
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|socket
operator|->
name|name
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|socket
operator|->
name|name
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|socket
operator|->
name|tag
operator|=
name|tag
expr_stmt|;
name|UNLOCK
argument_list|(
operator|&
name|socket
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ISC_SOCKETFUNC_SCOPE
specifier|const
name|char
modifier|*
name|isc__socket_getname
parameter_list|(
name|isc_socket_t
modifier|*
name|socket0
parameter_list|)
block|{
name|isc__socket_t
modifier|*
name|socket
init|=
operator|(
name|isc__socket_t
operator|*
operator|)
name|socket0
decl_stmt|;
return|return
operator|(
name|socket
operator|->
name|name
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|isc__socket_gettag
parameter_list|(
name|isc_socket_t
modifier|*
name|socket0
parameter_list|)
block|{
name|isc__socket_t
modifier|*
name|socket
init|=
operator|(
name|isc__socket_t
operator|*
operator|)
name|socket0
decl_stmt|;
return|return
operator|(
name|socket
operator|->
name|tag
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BIND9 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|USE_SOCKETIMPREGISTER
end_ifdef

begin_function
name|isc_result_t
name|isc__socket_register
parameter_list|()
block|{
return|return
operator|(
name|isc_socket_register
argument_list|(
name|isc__socketmgr_create
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_LIBXML2
argument_list|)
operator|&&
name|defined
argument_list|(
name|BIND9
argument_list|)
end_if

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|_socktype
parameter_list|(
name|isc_sockettype_t
name|type
parameter_list|)
block|{
if|if
condition|(
name|type
operator|==
name|isc_sockettype_udp
condition|)
return|return
operator|(
literal|"udp"
operator|)
return|;
elseif|else
if|if
condition|(
name|type
operator|==
name|isc_sockettype_tcp
condition|)
return|return
operator|(
literal|"tcp"
operator|)
return|;
elseif|else
if|if
condition|(
name|type
operator|==
name|isc_sockettype_unix
condition|)
return|return
operator|(
literal|"unix"
operator|)
return|;
elseif|else
if|if
condition|(
name|type
operator|==
name|isc_sockettype_fdwatch
condition|)
return|return
operator|(
literal|"fdwatch"
operator|)
return|;
else|else
return|return
operator|(
literal|"not-initialized"
operator|)
return|;
block|}
end_function

begin_function
name|ISC_SOCKETFUNC_SCOPE
name|void
name|isc_socketmgr_renderxml
parameter_list|(
name|isc_socketmgr_t
modifier|*
name|mgr0
parameter_list|,
name|xmlTextWriterPtr
name|writer
parameter_list|)
block|{
name|isc__socketmgr_t
modifier|*
name|mgr
init|=
operator|(
name|isc__socketmgr_t
operator|*
operator|)
name|mgr0
decl_stmt|;
name|isc__socket_t
modifier|*
name|sock
decl_stmt|;
name|char
name|peerbuf
index|[
name|ISC_SOCKADDR_FORMATSIZE
index|]
decl_stmt|;
name|isc_sockaddr_t
name|addr
decl_stmt|;
name|ISC_SOCKADDR_LEN_T
name|len
decl_stmt|;
name|LOCK
argument_list|(
operator|&
name|mgr
operator|->
name|lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_SHARED_MANAGER
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"references"
argument_list|)
expr_stmt|;
name|xmlTextWriterWriteFormatString
argument_list|(
name|writer
argument_list|,
literal|"%d"
argument_list|,
name|mgr
operator|->
name|refs
argument_list|)
expr_stmt|;
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* USE_SHARED_MANAGER */
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"sockets"
argument_list|)
expr_stmt|;
name|sock
operator|=
name|ISC_LIST_HEAD
argument_list|(
name|mgr
operator|->
name|socklist
argument_list|)
expr_stmt|;
while|while
condition|(
name|sock
operator|!=
name|NULL
condition|)
block|{
name|LOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"socket"
argument_list|)
expr_stmt|;
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"id"
argument_list|)
expr_stmt|;
name|xmlTextWriterWriteFormatString
argument_list|(
name|writer
argument_list|,
literal|"%p"
argument_list|,
name|sock
argument_list|)
expr_stmt|;
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"name"
argument_list|)
expr_stmt|;
name|xmlTextWriterWriteFormatString
argument_list|(
name|writer
argument_list|,
literal|"%s"
argument_list|,
name|sock
operator|->
name|name
argument_list|)
expr_stmt|;
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
expr_stmt|;
comment|/* name */
block|}
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"references"
argument_list|)
expr_stmt|;
name|xmlTextWriterWriteFormatString
argument_list|(
name|writer
argument_list|,
literal|"%d"
argument_list|,
name|sock
operator|->
name|references
argument_list|)
expr_stmt|;
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
expr_stmt|;
name|xmlTextWriterWriteElement
argument_list|(
argument|writer
argument_list|,
argument|ISC_XMLCHAR
literal|"type"
argument_list|,
argument|ISC_XMLCHAR _socktype(sock->type)
argument_list|)
empty_stmt|;
if|if
condition|(
name|sock
operator|->
name|connected
condition|)
block|{
name|isc_sockaddr_format
argument_list|(
operator|&
name|sock
operator|->
name|peer_address
argument_list|,
name|peerbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|peerbuf
argument_list|)
argument_list|)
expr_stmt|;
name|xmlTextWriterWriteElement
argument_list|(
argument|writer
argument_list|,
argument|ISC_XMLCHAR
literal|"peer-address"
argument_list|,
argument|ISC_XMLCHAR peerbuf
argument_list|)
empty_stmt|;
block|}
name|len
operator|=
sizeof|sizeof
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|sock
operator|->
name|fd
argument_list|,
operator|&
name|addr
operator|.
name|type
operator|.
name|sa
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|isc_sockaddr_format
argument_list|(
operator|&
name|addr
argument_list|,
name|peerbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|peerbuf
argument_list|)
argument_list|)
expr_stmt|;
name|xmlTextWriterWriteElement
argument_list|(
argument|writer
argument_list|,
argument|ISC_XMLCHAR
literal|"local-address"
argument_list|,
argument|ISC_XMLCHAR peerbuf
argument_list|)
empty_stmt|;
block|}
name|xmlTextWriterStartElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"states"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|pending_recv
condition|)
name|xmlTextWriterWriteElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"state"
argument_list|,
name|ISC_XMLCHAR
literal|"pending-receive"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|pending_send
condition|)
name|xmlTextWriterWriteElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"state"
argument_list|,
name|ISC_XMLCHAR
literal|"pending-send"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|pending_accept
condition|)
name|xmlTextWriterWriteElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"state"
argument_list|,
name|ISC_XMLCHAR
literal|"pending_accept"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|listener
condition|)
name|xmlTextWriterWriteElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"state"
argument_list|,
name|ISC_XMLCHAR
literal|"listener"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|connected
condition|)
name|xmlTextWriterWriteElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"state"
argument_list|,
name|ISC_XMLCHAR
literal|"connected"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|connecting
condition|)
name|xmlTextWriterWriteElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"state"
argument_list|,
name|ISC_XMLCHAR
literal|"connecting"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|->
name|bound
condition|)
name|xmlTextWriterWriteElement
argument_list|(
name|writer
argument_list|,
name|ISC_XMLCHAR
literal|"state"
argument_list|,
name|ISC_XMLCHAR
literal|"bound"
argument_list|)
expr_stmt|;
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
expr_stmt|;
comment|/* states */
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
expr_stmt|;
comment|/* socket */
name|UNLOCK
argument_list|(
operator|&
name|sock
operator|->
name|lock
argument_list|)
expr_stmt|;
name|sock
operator|=
name|ISC_LIST_NEXT
argument_list|(
name|sock
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|xmlTextWriterEndElement
argument_list|(
name|writer
argument_list|)
expr_stmt|;
comment|/* sockets */
name|UNLOCK
argument_list|(
operator|&
name|mgr
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_LIBXML2 */
end_comment

end_unit

