begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009-2013 Steven G. Kargl  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * Optimized by Bruce D. Evans.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/**  * Compute the exponential of x for Intel 80-bit format.  This is based on:  *  *   PTP Tang, "Table-driven implementation of the exponential function  *   in IEEE floating-point arithmetic," ACM Trans. Math. Soft., 15,  *   144-157 (1989).  *  * where the 32 table entries have been expanded to INTERVALS (see below).  */
end_comment

begin_include
include|#
directive|include
file|<float.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__i386__
end_ifdef

begin_include
include|#
directive|include
file|<ieeefp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"fpmath.h"
end_include

begin_include
include|#
directive|include
file|"math.h"
end_include

begin_include
include|#
directive|include
file|"math_private.h"
end_include

begin_include
include|#
directive|include
file|"k_expl.h"
end_include

begin_comment
comment|/* XXX Prevent compilers from erroneously constant folding these: */
end_comment

begin_decl_stmt
specifier|static
specifier|const
specifier|volatile
name|long
name|double
name|huge
init|=
literal|0x1p10000L
decl_stmt|,
name|tiny
init|=
literal|0x1p
operator|-
literal|10000L
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|long
name|double
name|twom10000
init|=
literal|0x1p
operator|-
literal|10000L
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|union
name|IEEEl2bits
comment|/* log(2**16384 - 0.5) rounded towards zero: */
comment|/* log(2**16384 - 0.5 + 1) rounded towards zero for expm1l() is the same: */
name|o_thresholdu
init|=
name|LD80C
argument_list|(
literal|0xb17217f7d1cf79ab
argument_list|,
literal|13
argument_list|,
literal|11356.5234062941439488L
argument_list|)
decl_stmt|,
define|#
directive|define
name|o_threshold
value|(o_thresholdu.e)
comment|/* log(2**(-16381-64-1)) rounded towards zero: */
name|u_thresholdu
init|=
name|LD80C
argument_list|(
literal|0xb21dfe7f09e2baa9
argument_list|,
literal|13
argument_list|,
operator|-
literal|11399.4985314888605581L
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|u_threshold
value|(u_thresholdu.e)
end_define

begin_function
name|long
name|double
name|expl
parameter_list|(
name|long
name|double
name|x
parameter_list|)
block|{
name|union
name|IEEEl2bits
name|u
decl_stmt|;
name|long
name|double
name|hi
decl_stmt|,
name|lo
decl_stmt|,
name|t
decl_stmt|,
name|twopk
decl_stmt|;
name|int
name|k
decl_stmt|;
name|uint16_t
name|hx
decl_stmt|,
name|ix
decl_stmt|;
name|DOPRINT_START
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
comment|/* Filter out exceptional cases. */
name|u
operator|.
name|e
operator|=
name|x
expr_stmt|;
name|hx
operator|=
name|u
operator|.
name|xbits
operator|.
name|expsign
expr_stmt|;
name|ix
operator|=
name|hx
operator|&
literal|0x7fff
expr_stmt|;
if|if
condition|(
name|ix
operator|>=
name|BIAS
operator|+
literal|13
condition|)
block|{
comment|/* |x|>= 8192 or x is NaN */
if|if
condition|(
name|ix
operator|==
name|BIAS
operator|+
name|LDBL_MAX_EXP
condition|)
block|{
if|if
condition|(
name|hx
operator|&
literal|0x8000
condition|)
comment|/* x is -Inf, -NaN or unsupported */
name|RETURNP
argument_list|(
operator|-
literal|1
operator|/
name|x
argument_list|)
expr_stmt|;
name|RETURNP
argument_list|(
name|x
operator|+
name|x
argument_list|)
expr_stmt|;
comment|/* x is +Inf, +NaN or unsupported */
block|}
if|if
condition|(
name|x
operator|>
name|o_threshold
condition|)
name|RETURNP
argument_list|(
name|huge
operator|*
name|huge
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
name|u_threshold
condition|)
name|RETURNP
argument_list|(
name|tiny
operator|*
name|tiny
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ix
operator|<
name|BIAS
operator|-
literal|75
condition|)
block|{
comment|/* |x|< 0x1p-75 (includes pseudos) */
name|RETURN2P
argument_list|(
literal|1
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* 1 with inexact iff x != 0 */
block|}
name|ENTERI
argument_list|()
expr_stmt|;
name|twopk
operator|=
literal|1
expr_stmt|;
name|__k_expl
argument_list|(
name|x
argument_list|,
operator|&
name|hi
argument_list|,
operator|&
name|lo
argument_list|,
operator|&
name|k
argument_list|)
expr_stmt|;
name|t
operator|=
name|SUM2P
argument_list|(
name|hi
argument_list|,
name|lo
argument_list|)
expr_stmt|;
comment|/* Scale by 2**k. */
if|if
condition|(
name|k
operator|>=
name|LDBL_MIN_EXP
condition|)
block|{
if|if
condition|(
name|k
operator|==
name|LDBL_MAX_EXP
condition|)
name|RETURNI
argument_list|(
name|t
operator|*
literal|2
operator|*
literal|0x1p16383L
argument_list|)
expr_stmt|;
name|SET_LDBL_EXPSIGN
argument_list|(
name|twopk
argument_list|,
name|BIAS
operator|+
name|k
argument_list|)
expr_stmt|;
name|RETURNI
argument_list|(
name|t
operator|*
name|twopk
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SET_LDBL_EXPSIGN
argument_list|(
name|twopk
argument_list|,
name|BIAS
operator|+
name|k
operator|+
literal|10000
argument_list|)
expr_stmt|;
name|RETURNI
argument_list|(
name|t
operator|*
name|twopk
operator|*
name|twom10000
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Compute expm1l(x) for Intel 80-bit format.  This is based on:  *  *   PTP Tang, "Table-driven implementation of the Expm1 function  *   in IEEE floating-point arithmetic," ACM Trans. Math. Soft., 18,  *   211-222 (1992).  */
end_comment

begin_comment
comment|/*  * Our T1 and T2 are chosen to be approximately the points where method  * A and method B have the same accuracy.  Tang's T1 and T2 are the  * points where method A's accuracy changes by a full bit.  For Tang,  * this drop in accuracy makes method A immediately less accurate than  * method B, but our larger INTERVALS makes method A 2 bits more  * accurate so it remains the most accurate method significantly  * closer to the origin despite losing the full bit in our extended  * range for it.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|double
name|T1
init|=
operator|-
literal|0.1659
decl_stmt|,
comment|/* ~-30.625/128 * log(2) */
name|T2
init|=
literal|0.1659
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ~30.625/128 * log(2) */
end_comment

begin_comment
comment|/*  * Domain [-0.1659, 0.1659], range ~[-2.6155e-22, 2.5507e-23]:  * |(exp(x)-1-x-x**2/2)/x - p(x)|< 2**-71.6  *  * XXX the coeffs aren't very carefully rounded, and I get 2.8 more bits,  * but unlike for ld128 we can't drop any terms.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|union
name|IEEEl2bits
name|B3
init|=
name|LD80C
argument_list|(
literal|0xaaaaaaaaaaaaaaab
argument_list|,
operator|-
literal|3
argument_list|,
literal|1.66666666666666666671e-1L
argument_list|)
decl_stmt|,
name|B4
init|=
name|LD80C
argument_list|(
literal|0xaaaaaaaaaaaaaaac
argument_list|,
operator|-
literal|5
argument_list|,
literal|4.16666666666666666712e-2L
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|double
name|B5
init|=
literal|8.3333333333333245e-3
decl_stmt|,
comment|/*  0x1.111111111110cp-7 */
name|B6
init|=
literal|1.3888888888888861e-3
decl_stmt|,
comment|/*  0x1.6c16c16c16c0ap-10 */
name|B7
init|=
literal|1.9841269841532042e-4
decl_stmt|,
comment|/*  0x1.a01a01a0319f9p-13 */
name|B8
init|=
literal|2.4801587302069236e-5
decl_stmt|,
comment|/*  0x1.a01a01a03cbbcp-16 */
name|B9
init|=
literal|2.7557316558468562e-6
decl_stmt|,
comment|/*  0x1.71de37fd33d67p-19 */
name|B10
init|=
literal|2.7557315829785151e-7
decl_stmt|,
comment|/*  0x1.27e4f91418144p-22 */
name|B11
init|=
literal|2.5063168199779829e-8
decl_stmt|,
comment|/*  0x1.ae94fabdc6b27p-26 */
name|B12
init|=
literal|2.0887164654459567e-9
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  0x1.1f122d6413fe1p-29 */
end_comment

begin_function
name|long
name|double
name|expm1l
parameter_list|(
name|long
name|double
name|x
parameter_list|)
block|{
name|union
name|IEEEl2bits
name|u
decl_stmt|,
name|v
decl_stmt|;
name|long
name|double
name|fn
decl_stmt|,
name|hx2_hi
decl_stmt|,
name|hx2_lo
decl_stmt|,
name|q
decl_stmt|,
name|r
decl_stmt|,
name|r1
decl_stmt|,
name|r2
decl_stmt|,
name|t
decl_stmt|,
name|twomk
decl_stmt|,
name|twopk
decl_stmt|,
name|x_hi
decl_stmt|;
name|long
name|double
name|x_lo
decl_stmt|,
name|x2
decl_stmt|,
name|z
decl_stmt|;
name|long
name|double
name|x4
decl_stmt|;
name|int
name|k
decl_stmt|,
name|n
decl_stmt|,
name|n2
decl_stmt|;
name|uint16_t
name|hx
decl_stmt|,
name|ix
decl_stmt|;
name|DOPRINT_START
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
comment|/* Filter out exceptional cases. */
name|u
operator|.
name|e
operator|=
name|x
expr_stmt|;
name|hx
operator|=
name|u
operator|.
name|xbits
operator|.
name|expsign
expr_stmt|;
name|ix
operator|=
name|hx
operator|&
literal|0x7fff
expr_stmt|;
if|if
condition|(
name|ix
operator|>=
name|BIAS
operator|+
literal|6
condition|)
block|{
comment|/* |x|>= 64 or x is NaN */
if|if
condition|(
name|ix
operator|==
name|BIAS
operator|+
name|LDBL_MAX_EXP
condition|)
block|{
if|if
condition|(
name|hx
operator|&
literal|0x8000
condition|)
comment|/* x is -Inf, -NaN or unsupported */
name|RETURNP
argument_list|(
operator|-
literal|1
operator|/
name|x
operator|-
literal|1
argument_list|)
expr_stmt|;
name|RETURNP
argument_list|(
name|x
operator|+
name|x
argument_list|)
expr_stmt|;
comment|/* x is +Inf, +NaN or unsupported */
block|}
if|if
condition|(
name|x
operator|>
name|o_threshold
condition|)
name|RETURNP
argument_list|(
name|huge
operator|*
name|huge
argument_list|)
expr_stmt|;
comment|/* 		 * expm1l() never underflows, but it must avoid 		 * unrepresentable large negative exponents.  We used a 		 * much smaller threshold for large |x| above than in 		 * expl() so as to handle not so large negative exponents 		 * in the same way as large ones here. 		 */
if|if
condition|(
name|hx
operator|&
literal|0x8000
condition|)
comment|/* x<= -64 */
name|RETURN2P
argument_list|(
name|tiny
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* good for x< -65ln2 - eps */
block|}
name|ENTERI
argument_list|()
expr_stmt|;
if|if
condition|(
name|T1
operator|<
name|x
operator|&&
name|x
operator|<
name|T2
condition|)
block|{
if|if
condition|(
name|ix
operator|<
name|BIAS
operator|-
literal|74
condition|)
block|{
comment|/* |x|< 0x1p-74 (includes pseudos) */
comment|/* x (rounded) with inexact if x != 0: */
name|RETURNPI
argument_list|(
name|x
operator|==
literal|0
condition|?
name|x
else|:
operator|(
literal|0x1p100
operator|*
name|x
operator|+
name|fabsl
argument_list|(
name|x
argument_list|)
operator|)
operator|*
literal|0x1p
operator|-
literal|100
argument_list|)
expr_stmt|;
block|}
name|x2
operator|=
name|x
operator|*
name|x
expr_stmt|;
name|x4
operator|=
name|x2
operator|*
name|x2
expr_stmt|;
name|q
operator|=
name|x4
operator|*
operator|(
name|x2
operator|*
operator|(
name|x4
operator|*
comment|/* 		     * XXX the number of terms is no longer good for 		     * pairwise grouping of all except B3, and the 		     * grouping is no longer from highest down. 		     */
operator|(
name|x2
operator|*
name|B12
operator|+
operator|(
name|x
operator|*
name|B11
operator|+
name|B10
operator|)
operator|)
operator|+
operator|(
name|x2
operator|*
operator|(
name|x
operator|*
name|B9
operator|+
name|B8
operator|)
operator|+
operator|(
name|x
operator|*
name|B7
operator|+
name|B6
operator|)
operator|)
operator|)
operator|+
operator|(
name|x
operator|*
name|B5
operator|+
name|B4
operator|.
name|e
operator|)
operator|)
operator|+
name|x2
operator|*
name|x
operator|*
name|B3
operator|.
name|e
expr_stmt|;
name|x_hi
operator|=
operator|(
name|float
operator|)
name|x
expr_stmt|;
name|x_lo
operator|=
name|x
operator|-
name|x_hi
expr_stmt|;
name|hx2_hi
operator|=
name|x_hi
operator|*
name|x_hi
operator|/
literal|2
expr_stmt|;
name|hx2_lo
operator|=
name|x_lo
operator|*
operator|(
name|x
operator|+
name|x_hi
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|ix
operator|>=
name|BIAS
operator|-
literal|7
condition|)
name|RETURN2PI
argument_list|(
name|hx2_hi
operator|+
name|x_hi
argument_list|,
name|hx2_lo
operator|+
name|x_lo
operator|+
name|q
argument_list|)
expr_stmt|;
else|else
name|RETURN2PI
argument_list|(
name|x
argument_list|,
name|hx2_lo
operator|+
name|q
operator|+
name|hx2_hi
argument_list|)
expr_stmt|;
block|}
comment|/* Reduce x to (k*ln2 + endpoint[n2] + r1 + r2). */
comment|/* Use a specialized rint() to get fn.  Assume round-to-nearest. */
name|fn
operator|=
name|x
operator|*
name|INV_L
operator|+
literal|0x1
literal|.8p63
operator|-
literal|0x1
literal|.8p63
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_EFFICIENT_IRINTL
argument_list|)
name|n
operator|=
name|irintl
argument_list|(
name|fn
argument_list|)
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_EFFICIENT_IRINT
argument_list|)
name|n
operator|=
name|irint
argument_list|(
name|fn
argument_list|)
expr_stmt|;
else|#
directive|else
name|n
operator|=
operator|(
name|int
operator|)
name|fn
expr_stmt|;
endif|#
directive|endif
name|n2
operator|=
operator|(
name|unsigned
operator|)
name|n
operator|%
name|INTERVALS
expr_stmt|;
name|k
operator|=
name|n
operator|>>
name|LOG2_INTERVALS
expr_stmt|;
name|r1
operator|=
name|x
operator|-
name|fn
operator|*
name|L1
expr_stmt|;
name|r2
operator|=
name|fn
operator|*
operator|-
name|L2
expr_stmt|;
name|r
operator|=
name|r1
operator|+
name|r2
expr_stmt|;
comment|/* Prepare scale factor. */
name|v
operator|.
name|e
operator|=
literal|1
expr_stmt|;
name|v
operator|.
name|xbits
operator|.
name|expsign
operator|=
name|BIAS
operator|+
name|k
expr_stmt|;
name|twopk
operator|=
name|v
operator|.
name|e
expr_stmt|;
comment|/* 	 * Evaluate lower terms of 	 * expl(endpoint[n2] + r1 + r2) = tbl[n2] * expl(r1 + r2). 	 */
name|z
operator|=
name|r
operator|*
name|r
expr_stmt|;
name|q
operator|=
name|r2
operator|+
name|z
operator|*
operator|(
name|A2
operator|+
name|r
operator|*
name|A3
operator|)
operator|+
name|z
operator|*
name|z
operator|*
operator|(
name|A4
operator|+
name|r
operator|*
name|A5
operator|)
operator|+
name|z
operator|*
name|z
operator|*
name|z
operator|*
name|A6
expr_stmt|;
name|t
operator|=
operator|(
name|long
name|double
operator|)
name|tbl
index|[
name|n2
index|]
operator|.
name|lo
operator|+
name|tbl
index|[
name|n2
index|]
operator|.
name|hi
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|0
condition|)
block|{
name|t
operator|=
name|SUM2P
argument_list|(
name|tbl
index|[
name|n2
index|]
operator|.
name|hi
operator|-
literal|1
argument_list|,
name|tbl
index|[
name|n2
index|]
operator|.
name|lo
operator|*
operator|(
name|r1
operator|+
literal|1
operator|)
operator|+
name|t
operator|*
name|q
operator|+
name|tbl
index|[
name|n2
index|]
operator|.
name|hi
operator|*
name|r1
argument_list|)
expr_stmt|;
name|RETURNI
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|==
operator|-
literal|1
condition|)
block|{
name|t
operator|=
name|SUM2P
argument_list|(
name|tbl
index|[
name|n2
index|]
operator|.
name|hi
operator|-
literal|2
argument_list|,
name|tbl
index|[
name|n2
index|]
operator|.
name|lo
operator|*
operator|(
name|r1
operator|+
literal|1
operator|)
operator|+
name|t
operator|*
name|q
operator|+
name|tbl
index|[
name|n2
index|]
operator|.
name|hi
operator|*
name|r1
argument_list|)
expr_stmt|;
name|RETURNI
argument_list|(
name|t
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|<
operator|-
literal|7
condition|)
block|{
name|t
operator|=
name|SUM2P
argument_list|(
name|tbl
index|[
name|n2
index|]
operator|.
name|hi
argument_list|,
name|tbl
index|[
name|n2
index|]
operator|.
name|lo
operator|+
name|t
operator|*
operator|(
name|q
operator|+
name|r1
operator|)
argument_list|)
expr_stmt|;
name|RETURNI
argument_list|(
name|t
operator|*
name|twopk
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|>
literal|2
operator|*
name|LDBL_MANT_DIG
operator|-
literal|1
condition|)
block|{
name|t
operator|=
name|SUM2P
argument_list|(
name|tbl
index|[
name|n2
index|]
operator|.
name|hi
argument_list|,
name|tbl
index|[
name|n2
index|]
operator|.
name|lo
operator|+
name|t
operator|*
operator|(
name|q
operator|+
name|r1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|LDBL_MAX_EXP
condition|)
name|RETURNI
argument_list|(
name|t
operator|*
literal|2
operator|*
literal|0x1p16383L
operator|-
literal|1
argument_list|)
expr_stmt|;
name|RETURNI
argument_list|(
name|t
operator|*
name|twopk
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|v
operator|.
name|xbits
operator|.
name|expsign
operator|=
name|BIAS
operator|-
name|k
expr_stmt|;
name|twomk
operator|=
name|v
operator|.
name|e
expr_stmt|;
if|if
condition|(
name|k
operator|>
name|LDBL_MANT_DIG
operator|-
literal|1
condition|)
name|t
operator|=
name|SUM2P
argument_list|(
name|tbl
index|[
name|n2
index|]
operator|.
name|hi
argument_list|,
name|tbl
index|[
name|n2
index|]
operator|.
name|lo
operator|-
name|twomk
operator|+
name|t
operator|*
operator|(
name|q
operator|+
name|r1
operator|)
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|SUM2P
argument_list|(
name|tbl
index|[
name|n2
index|]
operator|.
name|hi
operator|-
name|twomk
argument_list|,
name|tbl
index|[
name|n2
index|]
operator|.
name|lo
operator|+
name|t
operator|*
operator|(
name|q
operator|+
name|r1
operator|)
argument_list|)
expr_stmt|;
name|RETURNI
argument_list|(
name|t
operator|*
name|twopk
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

