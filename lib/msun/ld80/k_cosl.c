begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* From: @(#)k_cos.c 1.3 95/01/18 */
end_comment

begin_comment
comment|/*  * ====================================================  * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.  * Copyright (c) 2008 Steven G. Kargl, David Schultz, Bruce D. Evans.  *  * Developed at SunSoft, a Sun Microsystems, Inc. business.  * Permission to use, copy, modify, and distribute this  * software is freely granted, provided that this notice   * is preserved.  * ====================================================  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * ld80 version of k_cos.c.  See ../src/k_cos.c for most comments.  */
end_comment

begin_include
include|#
directive|include
file|"math_private.h"
end_include

begin_comment
comment|/*  * Domain [-0.7854, 0.7854], range ~[-2.43e-23, 2.425e-23]:  * |cos(x) - c(x)|< 2**-75.1  *  * The coefficients of c(x) were generated by a pari-gp script using  * a Remez algorithm that searches for the best higher coefficients  * after rounding leading coefficients to a specified precision.  *  * Simpler methods like Chebyshev or basic Remez barely suffice for  * cos() in 64-bit precision, because we want the coefficient of x^2  * to be precisely -0.5 so that multiplying by it is exact, and plain  * rounding of the coefficients of a good polynomial approximation only  * gives this up to about 64-bit precision.  Plain rounding also gives  * a mediocre approximation for the coefficient of x^4, but a rounding  * error of 0.5 ulps for this coefficient would only contribute ~0.01  * ulps to the final error, so this is unimportant.  Rounding errors in  * higher coefficients are even less important.  *  * In fact, coefficients above the x^4 one only need to have 53-bit  * precision, and this is more efficient.  We get this optimization  * almost for free from the complications needed to search for the best  * higher coefficients.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|double
name|one
init|=
literal|1.0
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__amd64__
argument_list|)
operator|||
name|defined
argument_list|(
name|__i386__
argument_list|)
end_if

begin_comment
comment|/* Long double constants are slow on these arches, and broken on i386. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
specifier|volatile
name|double
name|C1hi
init|=
literal|0.041666666666666664
decl_stmt|,
comment|/*  0x15555555555555.0p-57 */
name|C1lo
init|=
literal|2.2598839032744733e-18
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  0x14d80000000000.0p-111 */
end_comment

begin_define
define|#
directive|define
name|C1
value|((long double)C1hi + C1lo)
end_define

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
specifier|const
name|long
name|double
name|C1
init|=
literal|0.0416666666666666666136L
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  0xaaaaaaaaaaaaaa9b.0p-68 */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|double
name|C2
init|=
operator|-
literal|0.0013888888888888874
decl_stmt|,
comment|/* -0x16c16c16c16c10.0p-62 */
name|C3
init|=
literal|0.000024801587301571716
decl_stmt|,
comment|/*  0x1a01a01a018e22.0p-68 */
name|C4
init|=
operator|-
literal|0.00000027557319215507120
decl_stmt|,
comment|/* -0x127e4fb7602f22.0p-74 */
name|C5
init|=
literal|0.0000000020876754400407278
decl_stmt|,
comment|/*  0x11eed8caaeccf1.0p-81 */
name|C6
init|=
operator|-
literal|1.1470297442401303e-11
decl_stmt|,
comment|/* -0x19393412bd1529.0p-89 */
name|C7
init|=
literal|4.7383039476436467e-14
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  0x1aac9d9af5c43e.0p-97 */
end_comment

begin_function
name|long
name|double
name|__kernel_cosl
parameter_list|(
name|long
name|double
name|x
parameter_list|,
name|long
name|double
name|y
parameter_list|)
block|{
name|long
name|double
name|hz
decl_stmt|,
name|z
decl_stmt|,
name|r
decl_stmt|,
name|w
decl_stmt|;
name|z
operator|=
name|x
operator|*
name|x
expr_stmt|;
name|r
operator|=
name|z
operator|*
operator|(
name|C1
operator|+
name|z
operator|*
operator|(
name|C2
operator|+
name|z
operator|*
operator|(
name|C3
operator|+
name|z
operator|*
operator|(
name|C4
operator|+
name|z
operator|*
operator|(
name|C5
operator|+
name|z
operator|*
operator|(
name|C6
operator|+
name|z
operator|*
name|C7
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
name|hz
operator|=
literal|0.5
operator|*
name|z
expr_stmt|;
name|w
operator|=
name|one
operator|-
name|hz
expr_stmt|;
return|return
name|w
operator|+
operator|(
operator|(
operator|(
name|one
operator|-
name|w
operator|)
operator|-
name|hz
operator|)
operator|+
operator|(
name|z
operator|*
name|r
operator|-
name|x
operator|*
name|y
operator|)
operator|)
return|;
block|}
end_function

end_unit

