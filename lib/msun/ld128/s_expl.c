begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009-2013 Steven G. Kargl  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice unmodified, this list of conditions, and the following  *    disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * Optimized by Bruce D. Evans.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * ld128 version of s_expl.c.  See ../ld80/s_expl.c for most comments.  */
end_comment

begin_include
include|#
directive|include
file|<float.h>
end_include

begin_include
include|#
directive|include
file|"fpmath.h"
end_include

begin_include
include|#
directive|include
file|"math.h"
end_include

begin_include
include|#
directive|include
file|"math_private.h"
end_include

begin_include
include|#
directive|include
file|"k_expl.h"
end_include

begin_comment
comment|/* XXX Prevent compilers from erroneously constant folding these: */
end_comment

begin_decl_stmt
specifier|static
specifier|const
specifier|volatile
name|long
name|double
name|huge
init|=
literal|0x1p10000L
decl_stmt|,
name|tiny
init|=
literal|0x1p
operator|-
literal|10000L
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|long
name|double
name|twom10000
init|=
literal|0x1p
operator|-
literal|10000L
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|long
name|double
comment|/* log(2**16384 - 0.5) rounded towards zero: */
comment|/* log(2**16384 - 0.5 + 1) rounded towards zero for expm1l() is the same: */
name|o_threshold
init|=
literal|11356.523406294143949491931077970763428L
decl_stmt|,
comment|/* log(2**(-16381-64-1)) rounded towards zero: */
name|u_threshold
init|=
operator|-
literal|11433.462743336297878837243843452621503L
decl_stmt|;
end_decl_stmt

begin_function
name|long
name|double
name|expl
parameter_list|(
name|long
name|double
name|x
parameter_list|)
block|{
name|union
name|IEEEl2bits
name|u
decl_stmt|;
name|long
name|double
name|hi
decl_stmt|,
name|lo
decl_stmt|,
name|t
decl_stmt|,
name|twopk
decl_stmt|;
name|int
name|k
decl_stmt|;
name|uint16_t
name|hx
decl_stmt|,
name|ix
decl_stmt|;
name|DOPRINT_START
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
comment|/* Filter out exceptional cases. */
name|u
operator|.
name|e
operator|=
name|x
expr_stmt|;
name|hx
operator|=
name|u
operator|.
name|xbits
operator|.
name|expsign
expr_stmt|;
name|ix
operator|=
name|hx
operator|&
literal|0x7fff
expr_stmt|;
if|if
condition|(
name|ix
operator|>=
name|BIAS
operator|+
literal|13
condition|)
block|{
comment|/* |x|>= 8192 or x is NaN */
if|if
condition|(
name|ix
operator|==
name|BIAS
operator|+
name|LDBL_MAX_EXP
condition|)
block|{
if|if
condition|(
name|hx
operator|&
literal|0x8000
condition|)
comment|/* x is -Inf or -NaN */
name|RETURNP
argument_list|(
operator|-
literal|1
operator|/
name|x
argument_list|)
expr_stmt|;
name|RETURNP
argument_list|(
name|x
operator|+
name|x
argument_list|)
expr_stmt|;
comment|/* x is +Inf or +NaN */
block|}
if|if
condition|(
name|x
operator|>
name|o_threshold
condition|)
name|RETURNP
argument_list|(
name|huge
operator|*
name|huge
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
name|u_threshold
condition|)
name|RETURNP
argument_list|(
name|tiny
operator|*
name|tiny
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ix
operator|<
name|BIAS
operator|-
literal|114
condition|)
block|{
comment|/* |x|< 0x1p-114 */
name|RETURN2P
argument_list|(
literal|1
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* 1 with inexact iff x != 0 */
block|}
name|ENTERI
argument_list|()
expr_stmt|;
name|twopk
operator|=
literal|1
expr_stmt|;
name|__k_expl
argument_list|(
name|x
argument_list|,
operator|&
name|hi
argument_list|,
operator|&
name|lo
argument_list|,
operator|&
name|k
argument_list|)
expr_stmt|;
name|t
operator|=
name|SUM2P
argument_list|(
name|hi
argument_list|,
name|lo
argument_list|)
expr_stmt|;
comment|/* Scale by 2**k. */
comment|/* XXX sparc64 multiplication is so slow that scalbnl() is faster. */
if|if
condition|(
name|k
operator|>=
name|LDBL_MIN_EXP
condition|)
block|{
if|if
condition|(
name|k
operator|==
name|LDBL_MAX_EXP
condition|)
name|RETURNI
argument_list|(
name|t
operator|*
literal|2
operator|*
literal|0x1p16383L
argument_list|)
expr_stmt|;
name|SET_LDBL_EXPSIGN
argument_list|(
name|twopk
argument_list|,
name|BIAS
operator|+
name|k
argument_list|)
expr_stmt|;
name|RETURNI
argument_list|(
name|t
operator|*
name|twopk
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SET_LDBL_EXPSIGN
argument_list|(
name|twopk
argument_list|,
name|BIAS
operator|+
name|k
operator|+
literal|10000
argument_list|)
expr_stmt|;
name|RETURNI
argument_list|(
name|t
operator|*
name|twopk
operator|*
name|twom10000
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Our T1 and T2 are chosen to be approximately the points where method  * A and method B have the same accuracy.  Tang's T1 and T2 are the  * points where method A's accuracy changes by a full bit.  For Tang,  * this drop in accuracy makes method A immediately less accurate than  * method B, but our larger INTERVALS makes method A 2 bits more  * accurate so it remains the most accurate method significantly  * closer to the origin despite losing the full bit in our extended  * range for it.  *  * Split the interval [T1, T2] into two intervals [T1, T3] and [T3, T2].  * Setting T3 to 0 would require the |x|< 0x1p-113 condition to appear  * in both subintervals, so set T3 = 2**-5, which places the condition  * into the [T1, T3] interval.  *  * XXX we now do this more to (partially) balance the number of terms  * in the C and D polys than to avoid checking the condition in both  * intervals.  *  * XXX these micro-optimizations are excessive.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|double
name|T1
init|=
operator|-
literal|0.1659
decl_stmt|,
comment|/* ~-30.625/128 * log(2) */
name|T2
init|=
literal|0.1659
decl_stmt|,
comment|/* ~30.625/128 * log(2) */
name|T3
init|=
literal|0.03125
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Domain [-0.1659, 0.03125], range ~[2.9134e-44, 1.8404e-37]:  * |(exp(x)-1-x-x**2/2)/x - p(x)|< 2**-122.03 /*  * XXX none of the long double C or D coeffs except C10 is correctly printed.  * If you re-print their values in %.35Le format, the result is always  * different.  For example, the last 2 digits in C3 should be 59, not 67.  * 67 is apparently from rounding an extra-precision value to 36 decimal  * places.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|long
name|double
name|C3
init|=
literal|1.66666666666666666666666666666666667e-1L
decl_stmt|,
name|C4
init|=
literal|4.16666666666666666666666666666666645e-2L
decl_stmt|,
name|C5
init|=
literal|8.33333333333333333333333333333371638e-3L
decl_stmt|,
name|C6
init|=
literal|1.38888888888888888888888888891188658e-3L
decl_stmt|,
name|C7
init|=
literal|1.98412698412698412698412697235950394e-4L
decl_stmt|,
name|C8
init|=
literal|2.48015873015873015873015112487849040e-5L
decl_stmt|,
name|C9
init|=
literal|2.75573192239858906525606685484412005e-6L
decl_stmt|,
name|C10
init|=
literal|2.75573192239858906612966093057020362e-7L
decl_stmt|,
name|C11
init|=
literal|2.50521083854417203619031960151253944e-8L
decl_stmt|,
name|C12
init|=
literal|2.08767569878679576457272282566520649e-9L
decl_stmt|,
name|C13
init|=
literal|1.60590438367252471783548748824255707e-10L
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * XXX this has 1 more coeff than needed.  * XXX can start the double coeffs but not the double mults at C10.  * With my coeffs (C10-C17 double; s = best_s):  * Domain [-0.1659, 0.03125], range ~[-1.1976e-37, 1.1976e-37]:  * |(exp(x)-1-x-x**2/2)/x - p(x)| ~< 2**-122.65  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|double
name|C14
init|=
literal|1.1470745580491932e-11
decl_stmt|,
comment|/*  0x1.93974a81dae30p-37 */
name|C15
init|=
literal|7.6471620181090468e-13
decl_stmt|,
comment|/*  0x1.ae7f3820adab1p-41 */
name|C16
init|=
literal|4.7793721460260450e-14
decl_stmt|,
comment|/*  0x1.ae7cd18a18eacp-45 */
name|C17
init|=
literal|2.8074757356658877e-15
decl_stmt|,
comment|/*  0x1.949992a1937d9p-49 */
name|C18
init|=
literal|1.4760610323699476e-16
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  0x1.545b43aabfbcdp-53 */
end_comment

begin_comment
comment|/*  * Domain [0.03125, 0.1659], range ~[-2.7676e-37, -1.0367e-38]:  * |(exp(x)-1-x-x**2/2)/x - p(x)|< 2**-121.44  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|long
name|double
name|D3
init|=
literal|1.66666666666666666666666666666682245e-1L
decl_stmt|,
name|D4
init|=
literal|4.16666666666666666666666666634228324e-2L
decl_stmt|,
name|D5
init|=
literal|8.33333333333333333333333364022244481e-3L
decl_stmt|,
name|D6
init|=
literal|1.38888888888888888888887138722762072e-3L
decl_stmt|,
name|D7
init|=
literal|1.98412698412698412699085805424661471e-4L
decl_stmt|,
name|D8
init|=
literal|2.48015873015873015687993712101479612e-5L
decl_stmt|,
name|D9
init|=
literal|2.75573192239858944101036288338208042e-6L
decl_stmt|,
name|D10
init|=
literal|2.75573192239853161148064676533754048e-7L
decl_stmt|,
name|D11
init|=
literal|2.50521083855084570046480450935267433e-8L
decl_stmt|,
name|D12
init|=
literal|2.08767569819738524488686318024854942e-9L
decl_stmt|,
name|D13
init|=
literal|1.60590442297008495301927448122499313e-10L
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * XXX this has 1 more coeff than needed.  * XXX can start the double coeffs but not the double mults at D11.  * With my coeffs (D11-D16 double):  * Domain [0.03125, 0.1659], range ~[-1.1980e-37, 1.1980e-37]:  * |(exp(x)-1-x-x**2/2)/x - p(x)| ~< 2**-122.65  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|double
name|D14
init|=
literal|1.1470726176204336e-11
decl_stmt|,
comment|/*  0x1.93971dc395d9ep-37 */
name|D15
init|=
literal|7.6478532249581686e-13
decl_stmt|,
comment|/*  0x1.ae892e3D16fcep-41 */
name|D16
init|=
literal|4.7628892832607741e-14
decl_stmt|,
comment|/*  0x1.ad00Dfe41feccp-45 */
name|D17
init|=
literal|3.0524857220358650e-15
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  0x1.D7e8d886Df921p-49 */
end_comment

begin_function
name|long
name|double
name|expm1l
parameter_list|(
name|long
name|double
name|x
parameter_list|)
block|{
name|union
name|IEEEl2bits
name|u
decl_stmt|,
name|v
decl_stmt|;
name|long
name|double
name|hx2_hi
decl_stmt|,
name|hx2_lo
decl_stmt|,
name|q
decl_stmt|,
name|r
decl_stmt|,
name|r1
decl_stmt|,
name|t
decl_stmt|,
name|twomk
decl_stmt|,
name|twopk
decl_stmt|,
name|x_hi
decl_stmt|;
name|long
name|double
name|x_lo
decl_stmt|,
name|x2
decl_stmt|;
name|double
name|dr
decl_stmt|,
name|dx
decl_stmt|,
name|fn
decl_stmt|,
name|r2
decl_stmt|;
name|int
name|k
decl_stmt|,
name|n
decl_stmt|,
name|n2
decl_stmt|;
name|uint16_t
name|hx
decl_stmt|,
name|ix
decl_stmt|;
name|DOPRINT_START
argument_list|(
operator|&
name|x
argument_list|)
expr_stmt|;
comment|/* Filter out exceptional cases. */
name|u
operator|.
name|e
operator|=
name|x
expr_stmt|;
name|hx
operator|=
name|u
operator|.
name|xbits
operator|.
name|expsign
expr_stmt|;
name|ix
operator|=
name|hx
operator|&
literal|0x7fff
expr_stmt|;
if|if
condition|(
name|ix
operator|>=
name|BIAS
operator|+
literal|7
condition|)
block|{
comment|/* |x|>= 128 or x is NaN */
if|if
condition|(
name|ix
operator|==
name|BIAS
operator|+
name|LDBL_MAX_EXP
condition|)
block|{
if|if
condition|(
name|hx
operator|&
literal|0x8000
condition|)
comment|/* x is -Inf or -NaN */
name|RETURNP
argument_list|(
operator|-
literal|1
operator|/
name|x
operator|-
literal|1
argument_list|)
expr_stmt|;
name|RETURNP
argument_list|(
name|x
operator|+
name|x
argument_list|)
expr_stmt|;
comment|/* x is +Inf or +NaN */
block|}
if|if
condition|(
name|x
operator|>
name|o_threshold
condition|)
name|RETURNP
argument_list|(
name|huge
operator|*
name|huge
argument_list|)
expr_stmt|;
comment|/* 		 * expm1l() never underflows, but it must avoid 		 * unrepresentable large negative exponents.  We used a 		 * much smaller threshold for large |x| above than in 		 * expl() so as to handle not so large negative exponents 		 * in the same way as large ones here. 		 */
if|if
condition|(
name|hx
operator|&
literal|0x8000
condition|)
comment|/* x<= -128 */
name|RETURN2P
argument_list|(
name|tiny
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* good for x< -114ln2 - eps */
block|}
name|ENTERI
argument_list|()
expr_stmt|;
if|if
condition|(
name|T1
operator|<
name|x
operator|&&
name|x
operator|<
name|T2
condition|)
block|{
name|x2
operator|=
name|x
operator|*
name|x
expr_stmt|;
name|dx
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|x
operator|<
name|T3
condition|)
block|{
if|if
condition|(
name|ix
operator|<
name|BIAS
operator|-
literal|113
condition|)
block|{
comment|/* |x|< 0x1p-113 */
comment|/* x (rounded) with inexact if x != 0: */
name|RETURNPI
argument_list|(
name|x
operator|==
literal|0
condition|?
name|x
else|:
operator|(
literal|0x1p200
operator|*
name|x
operator|+
name|fabsl
argument_list|(
name|x
argument_list|)
operator|)
operator|*
literal|0x1p
operator|-
literal|200
argument_list|)
expr_stmt|;
block|}
name|q
operator|=
name|x
operator|*
name|x2
operator|*
name|C3
operator|+
name|x2
operator|*
name|x2
operator|*
operator|(
name|C4
operator|+
name|x
operator|*
operator|(
name|C5
operator|+
name|x
operator|*
operator|(
name|C6
operator|+
name|x
operator|*
operator|(
name|C7
operator|+
name|x
operator|*
operator|(
name|C8
operator|+
name|x
operator|*
operator|(
name|C9
operator|+
name|x
operator|*
operator|(
name|C10
operator|+
name|x
operator|*
operator|(
name|C11
operator|+
name|x
operator|*
operator|(
name|C12
operator|+
name|x
operator|*
operator|(
name|C13
operator|+
name|dx
operator|*
operator|(
name|C14
operator|+
name|dx
operator|*
operator|(
name|C15
operator|+
name|dx
operator|*
operator|(
name|C16
operator|+
name|dx
operator|*
operator|(
name|C17
operator|+
name|dx
operator|*
name|C18
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|q
operator|=
name|x
operator|*
name|x2
operator|*
name|D3
operator|+
name|x2
operator|*
name|x2
operator|*
operator|(
name|D4
operator|+
name|x
operator|*
operator|(
name|D5
operator|+
name|x
operator|*
operator|(
name|D6
operator|+
name|x
operator|*
operator|(
name|D7
operator|+
name|x
operator|*
operator|(
name|D8
operator|+
name|x
operator|*
operator|(
name|D9
operator|+
name|x
operator|*
operator|(
name|D10
operator|+
name|x
operator|*
operator|(
name|D11
operator|+
name|x
operator|*
operator|(
name|D12
operator|+
name|x
operator|*
operator|(
name|D13
operator|+
name|dx
operator|*
operator|(
name|D14
operator|+
name|dx
operator|*
operator|(
name|D15
operator|+
name|dx
operator|*
operator|(
name|D16
operator|+
name|dx
operator|*
name|D17
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
block|}
name|x_hi
operator|=
operator|(
name|float
operator|)
name|x
expr_stmt|;
name|x_lo
operator|=
name|x
operator|-
name|x_hi
expr_stmt|;
name|hx2_hi
operator|=
name|x_hi
operator|*
name|x_hi
operator|/
literal|2
expr_stmt|;
name|hx2_lo
operator|=
name|x_lo
operator|*
operator|(
name|x
operator|+
name|x_hi
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|ix
operator|>=
name|BIAS
operator|-
literal|7
condition|)
name|RETURN2PI
argument_list|(
name|hx2_hi
operator|+
name|x_hi
argument_list|,
name|hx2_lo
operator|+
name|x_lo
operator|+
name|q
argument_list|)
expr_stmt|;
else|else
name|RETURN2PI
argument_list|(
name|x
argument_list|,
name|hx2_lo
operator|+
name|q
operator|+
name|hx2_hi
argument_list|)
expr_stmt|;
block|}
comment|/* Reduce x to (k*ln2 + endpoint[n2] + r1 + r2). */
comment|/* Use a specialized rint() to get fn.  Assume round-to-nearest. */
name|fn
operator|=
operator|(
name|double
operator|)
name|x
operator|*
name|INV_L
operator|+
literal|0x1
literal|.8p52
operator|-
literal|0x1
literal|.8p52
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|HAVE_EFFICIENT_IRINT
argument_list|)
name|n
operator|=
name|irint
argument_list|(
name|fn
argument_list|)
expr_stmt|;
else|#
directive|else
name|n
operator|=
operator|(
name|int
operator|)
name|fn
expr_stmt|;
endif|#
directive|endif
name|n2
operator|=
operator|(
name|unsigned
operator|)
name|n
operator|%
name|INTERVALS
expr_stmt|;
name|k
operator|=
name|n
operator|>>
name|LOG2_INTERVALS
expr_stmt|;
name|r1
operator|=
name|x
operator|-
name|fn
operator|*
name|L1
expr_stmt|;
name|r2
operator|=
name|fn
operator|*
operator|-
name|L2
expr_stmt|;
name|r
operator|=
name|r1
operator|+
name|r2
expr_stmt|;
comment|/* Prepare scale factor. */
name|v
operator|.
name|e
operator|=
literal|1
expr_stmt|;
name|v
operator|.
name|xbits
operator|.
name|expsign
operator|=
name|BIAS
operator|+
name|k
expr_stmt|;
name|twopk
operator|=
name|v
operator|.
name|e
expr_stmt|;
comment|/* 	 * Evaluate lower terms of 	 * expl(endpoint[n2] + r1 + r2) = tbl[n2] * expl(r1 + r2). 	 */
name|dr
operator|=
name|r
expr_stmt|;
name|q
operator|=
name|r2
operator|+
name|r
operator|*
name|r
operator|*
operator|(
name|A2
operator|+
name|r
operator|*
operator|(
name|A3
operator|+
name|r
operator|*
operator|(
name|A4
operator|+
name|r
operator|*
operator|(
name|A5
operator|+
name|r
operator|*
operator|(
name|A6
operator|+
name|dr
operator|*
operator|(
name|A7
operator|+
name|dr
operator|*
operator|(
name|A8
operator|+
name|dr
operator|*
operator|(
name|A9
operator|+
name|dr
operator|*
name|A10
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
name|t
operator|=
name|tbl
index|[
name|n2
index|]
operator|.
name|lo
operator|+
name|tbl
index|[
name|n2
index|]
operator|.
name|hi
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|0
condition|)
block|{
name|t
operator|=
name|SUM2P
argument_list|(
name|tbl
index|[
name|n2
index|]
operator|.
name|hi
operator|-
literal|1
argument_list|,
name|tbl
index|[
name|n2
index|]
operator|.
name|lo
operator|*
operator|(
name|r1
operator|+
literal|1
operator|)
operator|+
name|t
operator|*
name|q
operator|+
name|tbl
index|[
name|n2
index|]
operator|.
name|hi
operator|*
name|r1
argument_list|)
expr_stmt|;
name|RETURNI
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|==
operator|-
literal|1
condition|)
block|{
name|t
operator|=
name|SUM2P
argument_list|(
name|tbl
index|[
name|n2
index|]
operator|.
name|hi
operator|-
literal|2
argument_list|,
name|tbl
index|[
name|n2
index|]
operator|.
name|lo
operator|*
operator|(
name|r1
operator|+
literal|1
operator|)
operator|+
name|t
operator|*
name|q
operator|+
name|tbl
index|[
name|n2
index|]
operator|.
name|hi
operator|*
name|r1
argument_list|)
expr_stmt|;
name|RETURNI
argument_list|(
name|t
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|<
operator|-
literal|7
condition|)
block|{
name|t
operator|=
name|SUM2P
argument_list|(
name|tbl
index|[
name|n2
index|]
operator|.
name|hi
argument_list|,
name|tbl
index|[
name|n2
index|]
operator|.
name|lo
operator|+
name|t
operator|*
operator|(
name|q
operator|+
name|r1
operator|)
argument_list|)
expr_stmt|;
name|RETURNI
argument_list|(
name|t
operator|*
name|twopk
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|>
literal|2
operator|*
name|LDBL_MANT_DIG
operator|-
literal|1
condition|)
block|{
name|t
operator|=
name|SUM2P
argument_list|(
name|tbl
index|[
name|n2
index|]
operator|.
name|hi
argument_list|,
name|tbl
index|[
name|n2
index|]
operator|.
name|lo
operator|+
name|t
operator|*
operator|(
name|q
operator|+
name|r1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
name|LDBL_MAX_EXP
condition|)
name|RETURNI
argument_list|(
name|t
operator|*
literal|2
operator|*
literal|0x1p16383L
operator|-
literal|1
argument_list|)
expr_stmt|;
name|RETURNI
argument_list|(
name|t
operator|*
name|twopk
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|v
operator|.
name|xbits
operator|.
name|expsign
operator|=
name|BIAS
operator|-
name|k
expr_stmt|;
name|twomk
operator|=
name|v
operator|.
name|e
expr_stmt|;
if|if
condition|(
name|k
operator|>
name|LDBL_MANT_DIG
operator|-
literal|1
condition|)
name|t
operator|=
name|SUM2P
argument_list|(
name|tbl
index|[
name|n2
index|]
operator|.
name|hi
argument_list|,
name|tbl
index|[
name|n2
index|]
operator|.
name|lo
operator|-
name|twomk
operator|+
name|t
operator|*
operator|(
name|q
operator|+
name|r1
operator|)
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
name|SUM2P
argument_list|(
name|tbl
index|[
name|n2
index|]
operator|.
name|hi
operator|-
name|twomk
argument_list|,
name|tbl
index|[
name|n2
index|]
operator|.
name|lo
operator|+
name|t
operator|*
operator|(
name|q
operator|+
name|r1
operator|)
argument_list|)
expr_stmt|;
name|RETURNI
argument_list|(
name|t
operator|*
name|twopk
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

