begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * ====================================================  * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.  * Copyright (c) 2009-2011, Bruce D. Evans, Steven G. Kargl, David Schultz.  *  * Developed at SunPro, a Sun Microsystems, Inc. business.  * Permission to use, copy, modify, and distribute this  * software is freely granted, provided that this notice  * is preserved.  * ====================================================  *  * The argument reduction and testing for exceptional cases was  * written by Steven G. Kargl with input from Bruce D. Evans  * and David A. Schultz.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<float.h>
end_include

begin_include
include|#
directive|include
file|<ieeefp.h>
end_include

begin_include
include|#
directive|include
file|"fpmath.h"
end_include

begin_include
include|#
directive|include
file|"math.h"
end_include

begin_include
include|#
directive|include
file|"math_private.h"
end_include

begin_define
define|#
directive|define
name|BIAS
value|(LDBL_MAX_EXP - 1)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|B1
init|=
literal|709958130
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* B1 = (127-127.0/3-0.03306235651)*2**23 */
end_comment

begin_function
name|long
name|double
name|cbrtl
parameter_list|(
name|long
name|double
name|x
parameter_list|)
block|{
name|union
name|IEEEl2bits
name|u
decl_stmt|,
name|v
decl_stmt|;
name|long
name|double
name|r
decl_stmt|,
name|s
decl_stmt|,
name|t
decl_stmt|,
name|w
decl_stmt|;
name|double
name|dr
decl_stmt|,
name|dt
decl_stmt|,
name|dx
decl_stmt|;
name|float
name|ft
decl_stmt|,
name|fx
decl_stmt|;
name|uint32_t
name|hx
decl_stmt|;
name|uint16_t
name|expsign
decl_stmt|;
name|int
name|k
decl_stmt|;
name|u
operator|.
name|e
operator|=
name|x
expr_stmt|;
name|expsign
operator|=
name|u
operator|.
name|xbits
operator|.
name|expsign
expr_stmt|;
name|k
operator|=
name|expsign
operator|&
literal|0x7fff
expr_stmt|;
comment|/* 	 * If x = +-Inf, then cbrt(x) = +-Inf. 	 * If x = NaN, then cbrt(x) = NaN. 	 */
if|if
condition|(
name|k
operator|==
name|BIAS
operator|+
name|LDBL_MAX_EXP
condition|)
return|return
operator|(
name|x
operator|+
name|x
operator|)
return|;
ifdef|#
directive|ifdef
name|__i386__
name|fp_prec_t
name|oprec
decl_stmt|;
name|oprec
operator|=
name|fpgetprec
argument_list|()
expr_stmt|;
if|if
condition|(
name|oprec
operator|!=
name|FP_PE
condition|)
name|fpsetprec
argument_list|(
name|FP_PE
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|k
operator|==
literal|0
condition|)
block|{
comment|/* If x = +-0, then cbrt(x) = +-0. */
if|if
condition|(
operator|(
name|u
operator|.
name|bits
operator|.
name|manh
operator||
name|u
operator|.
name|bits
operator|.
name|manl
operator|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|__i386__
if|if
condition|(
name|oprec
operator|!=
name|FP_PE
condition|)
name|fpsetprec
argument_list|(
name|oprec
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|x
operator|)
return|;
block|}
comment|/* Adjust subnormal numbers. */
name|u
operator|.
name|e
operator|*=
literal|0x1
literal|.0p514
expr_stmt|;
name|k
operator|=
name|u
operator|.
name|bits
operator|.
name|exp
expr_stmt|;
name|k
operator|-=
name|BIAS
operator|+
literal|514
expr_stmt|;
block|}
else|else
name|k
operator|-=
name|BIAS
expr_stmt|;
name|u
operator|.
name|xbits
operator|.
name|expsign
operator|=
name|BIAS
expr_stmt|;
name|v
operator|.
name|e
operator|=
literal|1
expr_stmt|;
name|x
operator|=
name|u
operator|.
name|e
expr_stmt|;
switch|switch
condition|(
name|k
operator|%
literal|3
condition|)
block|{
case|case
literal|1
case|:
case|case
operator|-
literal|2
case|:
name|x
operator|=
literal|2
operator|*
name|x
expr_stmt|;
name|k
operator|--
expr_stmt|;
break|break;
case|case
literal|2
case|:
case|case
operator|-
literal|1
case|:
name|x
operator|=
literal|4
operator|*
name|x
expr_stmt|;
name|k
operator|-=
literal|2
expr_stmt|;
break|break;
block|}
name|v
operator|.
name|xbits
operator|.
name|expsign
operator|=
operator|(
name|expsign
operator|&
literal|0x8000
operator|)
operator||
operator|(
name|BIAS
operator|+
name|k
operator|/
literal|3
operator|)
expr_stmt|;
comment|/* 	 * The following is the guts of s_cbrtf, with the handling of 	 * special values removed and extra care for accuracy not taken, 	 * but with most of the extra accuracy not discarded. 	 */
comment|/* ~5-bit estimate: */
name|fx
operator|=
name|x
expr_stmt|;
name|GET_FLOAT_WORD
argument_list|(
name|hx
argument_list|,
name|fx
argument_list|)
expr_stmt|;
name|SET_FLOAT_WORD
argument_list|(
name|ft
argument_list|,
operator|(
operator|(
name|hx
operator|&
literal|0x7fffffff
operator|)
operator|/
literal|3
operator|+
name|B1
operator|)
argument_list|)
expr_stmt|;
comment|/* ~16-bit estimate: */
name|dx
operator|=
name|x
expr_stmt|;
name|dt
operator|=
name|ft
expr_stmt|;
name|dr
operator|=
name|dt
operator|*
name|dt
operator|*
name|dt
expr_stmt|;
name|dt
operator|=
name|dt
operator|*
operator|(
name|dx
operator|+
name|dx
operator|+
name|dr
operator|)
operator|/
operator|(
name|dx
operator|+
name|dr
operator|+
name|dr
operator|)
expr_stmt|;
comment|/* ~47-bit estimate: */
name|dr
operator|=
name|dt
operator|*
name|dt
operator|*
name|dt
expr_stmt|;
name|dt
operator|=
name|dt
operator|*
operator|(
name|dx
operator|+
name|dx
operator|+
name|dr
operator|)
operator|/
operator|(
name|dx
operator|+
name|dr
operator|+
name|dr
operator|)
expr_stmt|;
if|#
directive|if
name|LDBL_MANT_DIG
operator|==
literal|64
comment|/* 	 * dt is cbrtl(x) to ~47 bits (after x has been reduced to 1<= x< 8). 	 * Round it away from zero to 32 bits (32 so that t*t is exact, and 	 * away from zero for technical reasons). 	 */
specifier|volatile
name|double
name|vd2
init|=
literal|0x1
literal|.0p32
decl_stmt|;
specifier|volatile
name|double
name|vd1
init|=
literal|0x1
literal|.0p
operator|-
literal|31
decl_stmt|;
define|#
directive|define
name|vd
value|((long double)vd2 + vd1)
name|t
operator|=
name|dt
operator|+
name|vd
operator|-
literal|0x1
literal|.0p32
expr_stmt|;
elif|#
directive|elif
name|LDBL_MANT_DIG
operator|==
literal|113
comment|/* 	 * Round dt away from zero to 47 bits.  Since we don't trust the 47, 	 * add 2 47-bit ulps instead of 1 to round up.  Rounding is slow and 	 * might be avoidable in this case, since on most machines dt will 	 * have been evaluated in 53-bit precision and the technical reasons 	 * for rounding up might not apply to either case in cbrtl() since 	 * dt is much more accurate than needed. 	 */
name|t
operator|=
name|dt
operator|+
literal|0x2
literal|.0p
operator|-
literal|46
operator|+
literal|0x1
literal|.0p60L
operator|-
literal|0x1
literal|.0p60
expr_stmt|;
else|#
directive|else
error|#
directive|error
literal|"Unsupported long double format"
endif|#
directive|endif
comment|/*      	 * Final step Newton iteration to 64 or 113 bits with 	 * error< 0.667 ulps 	 */
name|s
operator|=
name|t
operator|*
name|t
expr_stmt|;
comment|/* t*t is exact */
name|r
operator|=
name|x
operator|/
name|s
expr_stmt|;
comment|/* error<= 0.5 ulps; |r|< |t| */
name|w
operator|=
name|t
operator|+
name|t
expr_stmt|;
comment|/* t+t is exact */
name|r
operator|=
operator|(
name|r
operator|-
name|t
operator|)
operator|/
operator|(
name|w
operator|+
name|r
operator|)
expr_stmt|;
comment|/* r-t is exact; w+r ~= 3*t */
name|t
operator|=
name|t
operator|+
name|t
operator|*
name|r
expr_stmt|;
comment|/* error<= 0.5 + 0.5/3 + epsilon */
name|t
operator|*=
name|v
operator|.
name|e
expr_stmt|;
ifdef|#
directive|ifdef
name|__i386__
if|if
condition|(
name|oprec
operator|!=
name|FP_PE
condition|)
name|fpsetprec
argument_list|(
name|oprec
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

end_unit

