begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2012 Stephen Montgomery-Smith<stephen@FreeBSD.ORG>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<complex.h>
end_include

begin_include
include|#
directive|include
file|<float.h>
end_include

begin_include
include|#
directive|include
file|"math.h"
end_include

begin_include
include|#
directive|include
file|"math_private.h"
end_include

begin_undef
undef|#
directive|undef
name|isinf
end_undef

begin_define
define|#
directive|define
name|isinf
parameter_list|(
name|x
parameter_list|)
value|(fabs(x) == INFINITY)
end_define

begin_undef
undef|#
directive|undef
name|isnan
end_undef

begin_define
define|#
directive|define
name|isnan
parameter_list|(
name|x
parameter_list|)
value|((x) != (x))
end_define

begin_define
define|#
directive|define
name|raise_inexact
parameter_list|()
value|do { volatile float junk __unused = 1 + tiny; } while(0)
end_define

begin_undef
undef|#
directive|undef
name|signbit
end_undef

begin_define
define|#
directive|define
name|signbit
parameter_list|(
name|x
parameter_list|)
value|(__builtin_signbit(x))
end_define

begin_comment
comment|/* We need that DBL_EPSILON^2/128 is larger than FOUR_SQRT_MIN. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|double
name|A_crossover
init|=
literal|10
decl_stmt|,
comment|/* Hull et al suggest 1.5, but 10 works better */
name|B_crossover
init|=
literal|0.6417
decl_stmt|,
comment|/* suggested by Hull et al */
name|FOUR_SQRT_MIN
init|=
literal|0x1p
operator|-
literal|509
decl_stmt|,
comment|/*>= 4 * sqrt(DBL_MIN) */
name|QUARTER_SQRT_MAX
init|=
literal|0x1p509
decl_stmt|,
comment|/*<= sqrt(DBL_MAX) / 4 */
name|m_e
init|=
literal|2.7182818284590452e0
decl_stmt|,
comment|/*  0x15bf0a8b145769.0p-51 */
name|m_ln2
init|=
literal|6.9314718055994531e-1
decl_stmt|,
comment|/*  0x162e42fefa39ef.0p-53 */
name|pio2_hi
init|=
literal|1.5707963267948966e0
decl_stmt|,
comment|/*  0x1921fb54442d18.0p-52 */
name|RECIP_EPSILON
init|=
literal|1
operator|/
name|DBL_EPSILON
decl_stmt|,
name|SQRT_3_EPSILON
init|=
literal|2.5809568279517849e-8
decl_stmt|,
comment|/*  0x1bb67ae8584caa.0p-78 */
name|SQRT_6_EPSILON
init|=
literal|3.6500241499888571e-8
decl_stmt|,
comment|/*  0x13988e1409212e.0p-77 */
name|SQRT_MIN
init|=
literal|0x1p
operator|-
literal|511
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*>= sqrt(DBL_MIN) */
end_comment

begin_decl_stmt
specifier|static
specifier|const
specifier|volatile
name|double
name|pio2_lo
init|=
literal|6.1232339957367659e-17
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  0x11a62633145c07.0p-106 */
end_comment

begin_decl_stmt
specifier|static
specifier|const
specifier|volatile
name|float
name|tiny
init|=
literal|0x1p
operator|-
literal|100
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|double
name|complex
name|clog_for_large_values
parameter_list|(
name|double
name|complex
name|z
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Testing indicates that all these functions are accurate up to 4 ULP.  * The functions casin(h) and cacos(h) are about 2.5 times slower than asinh.  * The functions catan(h) are a little under 2 times slower than atanh.  *  * The code for casinh, casin, cacos, and cacosh comes first.  The code is  * rather complicated, and the four functions are highly interdependent.  *  * The code for catanh and catan comes at the end.  It is much simpler than  * the other functions, and the code for these can be disconnected from the  * rest of the code.  */
end_comment

begin_comment
comment|/*  *			================================  *			| casinh, casin, cacos, cacosh |  *			================================  */
end_comment

begin_comment
comment|/*  * The algorithm is very close to that in "Implementing the complex arcsine  * and arccosine functions using exception handling" by T. E. Hull, Thomas F.  * Fairgrieve, and Ping Tak Peter Tang, published in ACM Transactions on  * Mathematical Software, Volume 23 Issue 3, 1997, Pages 299-335,  * http://dl.acm.org/citation.cfm?id=275324.  *  * Throughout we use the convention z = x + I*y.  *  * casinh(z) = sign(x)*log(A+sqrt(A*A-1)) + I*asin(B)  * where  * A = (|z+I| + |z-I|) / 2  * B = (|z+I| - |z-I|) / 2 = y/A  *  * These formulas become numerically unstable:  *   (a) for Re(casinh(z)) when z is close to the line segment [-I, I] (that  *       is, Re(casinh(z)) is close to 0);  *   (b) for Im(casinh(z)) when z is close to either of the intervals  *       [I, I*infinity) or (-I*infinity, -I] (that is, |Im(casinh(z))| is  *       close to PI/2).  *  * These numerical problems are overcome by defining  * f(a, b) = (hypot(a, b) - b) / 2 = a*a / (hypot(a, b) + b) / 2  * Then if A< A_crossover, we use  *   log(A + sqrt(A*A-1)) = log1p((A-1) + sqrt((A-1)*(A+1)))  *   A-1 = f(x, 1+y) + f(x, 1-y)  * and if B> B_crossover, we use  *   asin(B) = atan2(y, sqrt(A*A - y*y)) = atan2(y, sqrt((A+y)*(A-y)))  *   A-y = f(x, y+1) + f(x, y-1)  * where without loss of generality we have assumed that x and y are  * non-negative.  *  * Much of the difficulty comes because the intermediate computations may  * produce overflows or underflows.  This is dealt with in the paper by Hull  * et al by using exception handling.  We do this by detecting when  * computations risk underflow or overflow.  The hardest part is handling the  * underflows when computing f(a, b).  *  * Note that the function f(a, b) does not appear explicitly in the paper by  * Hull et al, but the idea may be found on pages 308 and 309.  Introducing the  * function f(a, b) allows us to concentrate many of the clever tricks in this  * paper into one function.  */
end_comment

begin_comment
comment|/*  * Function f(a, b, hypot_a_b) = (hypot(a, b) - b) / 2.  * Pass hypot(a, b) as the third argument.  */
end_comment

begin_function
specifier|static
specifier|inline
name|double
name|f
parameter_list|(
name|double
name|a
parameter_list|,
name|double
name|b
parameter_list|,
name|double
name|hypot_a_b
parameter_list|)
block|{
if|if
condition|(
name|b
operator|<
literal|0
condition|)
return|return
operator|(
operator|(
name|hypot_a_b
operator|-
name|b
operator|)
operator|/
literal|2
operator|)
return|;
if|if
condition|(
name|b
operator|==
literal|0
condition|)
return|return
operator|(
name|a
operator|/
literal|2
operator|)
return|;
return|return
operator|(
name|a
operator|*
name|a
operator|/
operator|(
name|hypot_a_b
operator|+
name|b
operator|)
operator|/
literal|2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * All the hard work is contained in this function.  * x and y are assumed positive or zero, and less than RECIP_EPSILON.  * Upon return:  * rx = Re(casinh(z)) = -Im(cacos(y + I*x)).  * B_is_usable is set to 1 if the value of B is usable.  * If B_is_usable is set to 0, sqrt_A2my2 = sqrt(A*A - y*y), and new_y = y.  * If returning sqrt_A2my2 has potential to result in an underflow, it is  * rescaled, and new_y is similarly rescaled.  */
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|do_hard_work
parameter_list|(
name|double
name|x
parameter_list|,
name|double
name|y
parameter_list|,
name|double
modifier|*
name|rx
parameter_list|,
name|int
modifier|*
name|B_is_usable
parameter_list|,
name|double
modifier|*
name|B
parameter_list|,
name|double
modifier|*
name|sqrt_A2my2
parameter_list|,
name|double
modifier|*
name|new_y
parameter_list|)
block|{
name|double
name|R
decl_stmt|,
name|S
decl_stmt|,
name|A
decl_stmt|;
comment|/* A, B, R, and S are as in Hull et al. */
name|double
name|Am1
decl_stmt|,
name|Amy
decl_stmt|;
comment|/* A-1, A-y. */
name|R
operator|=
name|hypot
argument_list|(
name|x
argument_list|,
name|y
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* |z+I| */
name|S
operator|=
name|hypot
argument_list|(
name|x
argument_list|,
name|y
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* |z-I| */
comment|/* A = (|z+I| + |z-I|) / 2 */
name|A
operator|=
operator|(
name|R
operator|+
name|S
operator|)
operator|/
literal|2
expr_stmt|;
comment|/* 	 * Mathematically A>= 1.  There is a small chance that this will not 	 * be so because of rounding errors.  So we will make certain it is 	 * so. 	 */
if|if
condition|(
name|A
operator|<
literal|1
condition|)
name|A
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|A
operator|<
name|A_crossover
condition|)
block|{
comment|/* 		 * Am1 = fp + fm, where fp = f(x, 1+y), and fm = f(x, 1-y). 		 * rx = log1p(Am1 + sqrt(Am1*(A+1))) 		 */
if|if
condition|(
name|y
operator|==
literal|1
operator|&&
name|x
operator|<
name|DBL_EPSILON
operator|*
name|DBL_EPSILON
operator|/
literal|128
condition|)
block|{
comment|/* 			 * fp is of order x^2, and fm = x/2. 			 * A = 1 (inexactly). 			 */
operator|*
name|rx
operator|=
name|sqrt
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|>=
name|DBL_EPSILON
operator|*
name|fabs
argument_list|(
name|y
operator|-
literal|1
argument_list|)
condition|)
block|{
comment|/* 			 * Underflow will not occur because 			 * x>= DBL_EPSILON^2/128>= FOUR_SQRT_MIN 			 */
name|Am1
operator|=
name|f
argument_list|(
name|x
argument_list|,
literal|1
operator|+
name|y
argument_list|,
name|R
argument_list|)
operator|+
name|f
argument_list|(
name|x
argument_list|,
literal|1
operator|-
name|y
argument_list|,
name|S
argument_list|)
expr_stmt|;
operator|*
name|rx
operator|=
name|log1p
argument_list|(
name|Am1
operator|+
name|sqrt
argument_list|(
name|Am1
operator|*
operator|(
name|A
operator|+
literal|1
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|y
operator|<
literal|1
condition|)
block|{
comment|/* 			 * fp = x*x/(1+y)/4, fm = x*x/(1-y)/4, and 			 * A = 1 (inexactly). 			 */
operator|*
name|rx
operator|=
name|x
operator|/
name|sqrt
argument_list|(
operator|(
literal|1
operator|-
name|y
operator|)
operator|*
operator|(
literal|1
operator|+
name|y
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* if (y> 1) */
comment|/* 			 * A-1 = y-1 (inexactly). 			 */
operator|*
name|rx
operator|=
name|log1p
argument_list|(
operator|(
name|y
operator|-
literal|1
operator|)
operator|+
name|sqrt
argument_list|(
operator|(
name|y
operator|-
literal|1
operator|)
operator|*
operator|(
name|y
operator|+
literal|1
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|*
name|rx
operator|=
name|log
argument_list|(
name|A
operator|+
name|sqrt
argument_list|(
name|A
operator|*
name|A
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|new_y
operator|=
name|y
expr_stmt|;
if|if
condition|(
name|y
operator|<
name|FOUR_SQRT_MIN
condition|)
block|{
comment|/* 		 * Avoid a possible underflow caused by y/A.  For casinh this 		 * would be legitimate, but will be picked up by invoking atan2 		 * later on.  For cacos this would not be legitimate. 		 */
operator|*
name|B_is_usable
operator|=
literal|0
expr_stmt|;
operator|*
name|sqrt_A2my2
operator|=
name|A
operator|*
operator|(
literal|2
operator|/
name|DBL_EPSILON
operator|)
expr_stmt|;
operator|*
name|new_y
operator|=
name|y
operator|*
operator|(
literal|2
operator|/
name|DBL_EPSILON
operator|)
expr_stmt|;
return|return;
block|}
comment|/* B = (|z+I| - |z-I|) / 2 = y/A */
operator|*
name|B
operator|=
name|y
operator|/
name|A
expr_stmt|;
operator|*
name|B_is_usable
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|B
operator|>
name|B_crossover
condition|)
block|{
operator|*
name|B_is_usable
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Amy = fp + fm, where fp = f(x, y+1), and fm = f(x, y-1). 		 * sqrt_A2my2 = sqrt(Amy*(A+y)) 		 */
if|if
condition|(
name|y
operator|==
literal|1
operator|&&
name|x
operator|<
name|DBL_EPSILON
operator|/
literal|128
condition|)
block|{
comment|/* 			 * fp is of order x^2, and fm = x/2. 			 * A = 1 (inexactly). 			 */
operator|*
name|sqrt_A2my2
operator|=
name|sqrt
argument_list|(
name|x
argument_list|)
operator|*
name|sqrt
argument_list|(
operator|(
name|A
operator|+
name|y
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|>=
name|DBL_EPSILON
operator|*
name|fabs
argument_list|(
name|y
operator|-
literal|1
argument_list|)
condition|)
block|{
comment|/* 			 * Underflow will not occur because 			 * x>= DBL_EPSILON/128>= FOUR_SQRT_MIN 			 * and 			 * x>= DBL_EPSILON^2>= FOUR_SQRT_MIN 			 */
name|Amy
operator|=
name|f
argument_list|(
name|x
argument_list|,
name|y
operator|+
literal|1
argument_list|,
name|R
argument_list|)
operator|+
name|f
argument_list|(
name|x
argument_list|,
name|y
operator|-
literal|1
argument_list|,
name|S
argument_list|)
expr_stmt|;
operator|*
name|sqrt_A2my2
operator|=
name|sqrt
argument_list|(
name|Amy
operator|*
operator|(
name|A
operator|+
name|y
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|y
operator|>
literal|1
condition|)
block|{
comment|/* 			 * fp = x*x/(y+1)/4, fm = x*x/(y-1)/4, and 			 * A = y (inexactly). 			 * 			 * y< RECIP_EPSILON.  So the following 			 * scaling should avoid any underflow problems. 			 */
operator|*
name|sqrt_A2my2
operator|=
name|x
operator|*
operator|(
literal|4
operator|/
name|DBL_EPSILON
operator|/
name|DBL_EPSILON
operator|)
operator|*
name|y
operator|/
name|sqrt
argument_list|(
operator|(
name|y
operator|+
literal|1
operator|)
operator|*
operator|(
name|y
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
operator|*
name|new_y
operator|=
name|y
operator|*
operator|(
literal|4
operator|/
name|DBL_EPSILON
operator|/
name|DBL_EPSILON
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* if (y< 1) */
comment|/* 			 * fm = 1-y>= DBL_EPSILON, fp is of order x^2, and 			 * A = 1 (inexactly). 			 */
operator|*
name|sqrt_A2my2
operator|=
name|sqrt
argument_list|(
operator|(
literal|1
operator|-
name|y
operator|)
operator|*
operator|(
literal|1
operator|+
name|y
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * casinh(z) = z + O(z^3)   as z -> 0  *  * casinh(z) = sign(x)*clog(sign(x)*z) + O(1/z^2)   as z -> infinity  * The above formula works for the imaginary part as well, because  * Im(casinh(z)) = sign(x)*atan2(sign(x)*y, fabs(x)) + O(y/z^3)  *    as z -> infinity, uniformly in y  */
end_comment

begin_function
name|double
name|complex
name|casinh
parameter_list|(
name|double
name|complex
name|z
parameter_list|)
block|{
name|double
name|x
decl_stmt|,
name|y
decl_stmt|,
name|ax
decl_stmt|,
name|ay
decl_stmt|,
name|rx
decl_stmt|,
name|ry
decl_stmt|,
name|B
decl_stmt|,
name|sqrt_A2my2
decl_stmt|,
name|new_y
decl_stmt|;
name|int
name|B_is_usable
decl_stmt|;
name|double
name|complex
name|w
decl_stmt|;
name|x
operator|=
name|creal
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|y
operator|=
name|cimag
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|ax
operator|=
name|fabs
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|ay
operator|=
name|fabs
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnan
argument_list|(
name|x
argument_list|)
operator|||
name|isnan
argument_list|(
name|y
argument_list|)
condition|)
block|{
comment|/* casinh(+-Inf + I*NaN) = +-Inf + I*NaN */
if|if
condition|(
name|isinf
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
name|CMPLX
argument_list|(
name|x
argument_list|,
name|y
operator|+
name|y
argument_list|)
operator|)
return|;
comment|/* casinh(NaN + I*+-Inf) = opt(+-)Inf + I*NaN */
if|if
condition|(
name|isinf
argument_list|(
name|y
argument_list|)
condition|)
return|return
operator|(
name|CMPLX
argument_list|(
name|y
argument_list|,
name|x
operator|+
name|x
argument_list|)
operator|)
return|;
comment|/* casinh(NaN + I*0) = NaN + I*0 */
if|if
condition|(
name|y
operator|==
literal|0
condition|)
return|return
operator|(
name|CMPLX
argument_list|(
name|x
operator|+
name|x
argument_list|,
name|y
argument_list|)
operator|)
return|;
comment|/* 		 * All other cases involving NaN return NaN + I*NaN. 		 * C99 leaves it optional whether to raise invalid if one of 		 * the arguments is not NaN, so we opt not to raise it. 		 */
return|return
operator|(
name|CMPLX
argument_list|(
name|x
operator|+
literal|0.0L
operator|+
operator|(
name|y
operator|+
literal|0
operator|)
argument_list|,
name|x
operator|+
literal|0.0L
operator|+
operator|(
name|y
operator|+
literal|0
operator|)
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|ax
operator|>
name|RECIP_EPSILON
operator|||
name|ay
operator|>
name|RECIP_EPSILON
condition|)
block|{
comment|/* clog...() will raise inexact unless x or y is infinite. */
if|if
condition|(
name|signbit
argument_list|(
name|x
argument_list|)
operator|==
literal|0
condition|)
name|w
operator|=
name|clog_for_large_values
argument_list|(
name|z
argument_list|)
operator|+
name|m_ln2
expr_stmt|;
else|else
name|w
operator|=
name|clog_for_large_values
argument_list|(
operator|-
name|z
argument_list|)
operator|+
name|m_ln2
expr_stmt|;
return|return
operator|(
name|CMPLX
argument_list|(
name|copysign
argument_list|(
name|creal
argument_list|(
name|w
argument_list|)
argument_list|,
name|x
argument_list|)
argument_list|,
name|copysign
argument_list|(
name|cimag
argument_list|(
name|w
argument_list|)
argument_list|,
name|y
argument_list|)
argument_list|)
operator|)
return|;
block|}
comment|/* Avoid spuriously raising inexact for z = 0. */
if|if
condition|(
name|x
operator|==
literal|0
operator|&&
name|y
operator|==
literal|0
condition|)
return|return
operator|(
name|z
operator|)
return|;
comment|/* All remaining cases are inexact. */
name|raise_inexact
argument_list|()
expr_stmt|;
if|if
condition|(
name|ax
operator|<
name|SQRT_6_EPSILON
operator|/
literal|4
operator|&&
name|ay
operator|<
name|SQRT_6_EPSILON
operator|/
literal|4
condition|)
return|return
operator|(
name|z
operator|)
return|;
name|do_hard_work
argument_list|(
name|ax
argument_list|,
name|ay
argument_list|,
operator|&
name|rx
argument_list|,
operator|&
name|B_is_usable
argument_list|,
operator|&
name|B
argument_list|,
operator|&
name|sqrt_A2my2
argument_list|,
operator|&
name|new_y
argument_list|)
expr_stmt|;
if|if
condition|(
name|B_is_usable
condition|)
name|ry
operator|=
name|asin
argument_list|(
name|B
argument_list|)
expr_stmt|;
else|else
name|ry
operator|=
name|atan2
argument_list|(
name|new_y
argument_list|,
name|sqrt_A2my2
argument_list|)
expr_stmt|;
return|return
operator|(
name|CMPLX
argument_list|(
name|copysign
argument_list|(
name|rx
argument_list|,
name|x
argument_list|)
argument_list|,
name|copysign
argument_list|(
name|ry
argument_list|,
name|y
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * casin(z) = reverse(casinh(reverse(z)))  * where reverse(x + I*y) = y + I*x = I*conj(z).  */
end_comment

begin_function
name|double
name|complex
name|casin
parameter_list|(
name|double
name|complex
name|z
parameter_list|)
block|{
name|double
name|complex
name|w
init|=
name|casinh
argument_list|(
name|CMPLX
argument_list|(
name|cimag
argument_list|(
name|z
argument_list|)
argument_list|,
name|creal
argument_list|(
name|z
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|(
name|CMPLX
argument_list|(
name|cimag
argument_list|(
name|w
argument_list|)
argument_list|,
name|creal
argument_list|(
name|w
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cacos(z) = PI/2 - casin(z)  * but do the computation carefully so cacos(z) is accurate when z is  * close to 1.  *  * cacos(z) = PI/2 - z + O(z^3)   as z -> 0  *  * cacos(z) = -sign(y)*I*clog(z) + O(1/z^2)   as z -> infinity  * The above formula works for the real part as well, because  * Re(cacos(z)) = atan2(fabs(y), x) + O(y/z^3)  *    as z -> infinity, uniformly in y  */
end_comment

begin_function
name|double
name|complex
name|cacos
parameter_list|(
name|double
name|complex
name|z
parameter_list|)
block|{
name|double
name|x
decl_stmt|,
name|y
decl_stmt|,
name|ax
decl_stmt|,
name|ay
decl_stmt|,
name|rx
decl_stmt|,
name|ry
decl_stmt|,
name|B
decl_stmt|,
name|sqrt_A2mx2
decl_stmt|,
name|new_x
decl_stmt|;
name|int
name|sx
decl_stmt|,
name|sy
decl_stmt|;
name|int
name|B_is_usable
decl_stmt|;
name|double
name|complex
name|w
decl_stmt|;
name|x
operator|=
name|creal
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|y
operator|=
name|cimag
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|sx
operator|=
name|signbit
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|sy
operator|=
name|signbit
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|ax
operator|=
name|fabs
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|ay
operator|=
name|fabs
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|isnan
argument_list|(
name|x
argument_list|)
operator|||
name|isnan
argument_list|(
name|y
argument_list|)
condition|)
block|{
comment|/* cacos(+-Inf + I*NaN) = NaN + I*opt(-)Inf */
if|if
condition|(
name|isinf
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
name|CMPLX
argument_list|(
name|y
operator|+
name|y
argument_list|,
operator|-
name|INFINITY
argument_list|)
operator|)
return|;
comment|/* cacos(NaN + I*+-Inf) = NaN + I*-+Inf */
if|if
condition|(
name|isinf
argument_list|(
name|y
argument_list|)
condition|)
return|return
operator|(
name|CMPLX
argument_list|(
name|x
operator|+
name|x
argument_list|,
operator|-
name|y
argument_list|)
operator|)
return|;
comment|/* cacos(0 + I*NaN) = PI/2 + I*NaN with inexact */
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
operator|(
name|CMPLX
argument_list|(
name|pio2_hi
operator|+
name|pio2_lo
argument_list|,
name|y
operator|+
name|y
argument_list|)
operator|)
return|;
comment|/* 		 * All other cases involving NaN return NaN + I*NaN. 		 * C99 leaves it optional whether to raise invalid if one of 		 * the arguments is not NaN, so we opt not to raise it. 		 */
return|return
operator|(
name|CMPLX
argument_list|(
name|x
operator|+
literal|0.0L
operator|+
operator|(
name|y
operator|+
literal|0
operator|)
argument_list|,
name|x
operator|+
literal|0.0L
operator|+
operator|(
name|y
operator|+
literal|0
operator|)
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|ax
operator|>
name|RECIP_EPSILON
operator|||
name|ay
operator|>
name|RECIP_EPSILON
condition|)
block|{
comment|/* clog...() will raise inexact unless x or y is infinite. */
name|w
operator|=
name|clog_for_large_values
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|rx
operator|=
name|fabs
argument_list|(
name|cimag
argument_list|(
name|w
argument_list|)
argument_list|)
expr_stmt|;
name|ry
operator|=
name|creal
argument_list|(
name|w
argument_list|)
operator|+
name|m_ln2
expr_stmt|;
if|if
condition|(
name|sy
operator|==
literal|0
condition|)
name|ry
operator|=
operator|-
name|ry
expr_stmt|;
return|return
operator|(
name|CMPLX
argument_list|(
name|rx
argument_list|,
name|ry
argument_list|)
operator|)
return|;
block|}
comment|/* Avoid spuriously raising inexact for z = 1. */
if|if
condition|(
name|x
operator|==
literal|1
operator|&&
name|y
operator|==
literal|0
condition|)
return|return
operator|(
name|CMPLX
argument_list|(
literal|0
argument_list|,
operator|-
name|y
argument_list|)
operator|)
return|;
comment|/* All remaining cases are inexact. */
name|raise_inexact
argument_list|()
expr_stmt|;
if|if
condition|(
name|ax
operator|<
name|SQRT_6_EPSILON
operator|/
literal|4
operator|&&
name|ay
operator|<
name|SQRT_6_EPSILON
operator|/
literal|4
condition|)
return|return
operator|(
name|CMPLX
argument_list|(
name|pio2_hi
operator|-
operator|(
name|x
operator|-
name|pio2_lo
operator|)
argument_list|,
operator|-
name|y
argument_list|)
operator|)
return|;
name|do_hard_work
argument_list|(
name|ay
argument_list|,
name|ax
argument_list|,
operator|&
name|ry
argument_list|,
operator|&
name|B_is_usable
argument_list|,
operator|&
name|B
argument_list|,
operator|&
name|sqrt_A2mx2
argument_list|,
operator|&
name|new_x
argument_list|)
expr_stmt|;
if|if
condition|(
name|B_is_usable
condition|)
block|{
if|if
condition|(
name|sx
operator|==
literal|0
condition|)
name|rx
operator|=
name|acos
argument_list|(
name|B
argument_list|)
expr_stmt|;
else|else
name|rx
operator|=
name|acos
argument_list|(
operator|-
name|B
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sx
operator|==
literal|0
condition|)
name|rx
operator|=
name|atan2
argument_list|(
name|sqrt_A2mx2
argument_list|,
name|new_x
argument_list|)
expr_stmt|;
else|else
name|rx
operator|=
name|atan2
argument_list|(
name|sqrt_A2mx2
argument_list|,
operator|-
name|new_x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sy
operator|==
literal|0
condition|)
name|ry
operator|=
operator|-
name|ry
expr_stmt|;
return|return
operator|(
name|CMPLX
argument_list|(
name|rx
argument_list|,
name|ry
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * cacosh(z) = I*cacos(z) or -I*cacos(z)  * where the sign is chosen so Re(cacosh(z))>= 0.  */
end_comment

begin_function
name|double
name|complex
name|cacosh
parameter_list|(
name|double
name|complex
name|z
parameter_list|)
block|{
name|double
name|complex
name|w
decl_stmt|;
name|double
name|rx
decl_stmt|,
name|ry
decl_stmt|;
name|w
operator|=
name|cacos
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|rx
operator|=
name|creal
argument_list|(
name|w
argument_list|)
expr_stmt|;
name|ry
operator|=
name|cimag
argument_list|(
name|w
argument_list|)
expr_stmt|;
comment|/* cacosh(NaN + I*NaN) = NaN + I*NaN */
if|if
condition|(
name|isnan
argument_list|(
name|rx
argument_list|)
operator|&&
name|isnan
argument_list|(
name|ry
argument_list|)
condition|)
return|return
operator|(
name|CMPLX
argument_list|(
name|ry
argument_list|,
name|rx
argument_list|)
operator|)
return|;
comment|/* cacosh(NaN + I*+-Inf) = +Inf + I*NaN */
comment|/* cacosh(+-Inf + I*NaN) = +Inf + I*NaN */
if|if
condition|(
name|isnan
argument_list|(
name|rx
argument_list|)
condition|)
return|return
operator|(
name|CMPLX
argument_list|(
name|fabs
argument_list|(
name|ry
argument_list|)
argument_list|,
name|rx
argument_list|)
operator|)
return|;
comment|/* cacosh(0 + I*NaN) = NaN + I*NaN */
if|if
condition|(
name|isnan
argument_list|(
name|ry
argument_list|)
condition|)
return|return
operator|(
name|CMPLX
argument_list|(
name|ry
argument_list|,
name|ry
argument_list|)
operator|)
return|;
return|return
operator|(
name|CMPLX
argument_list|(
name|fabs
argument_list|(
name|ry
argument_list|)
argument_list|,
name|copysign
argument_list|(
name|rx
argument_list|,
name|cimag
argument_list|(
name|z
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Optimized version of clog() for |z| finite and larger than ~RECIP_EPSILON.  */
end_comment

begin_function
specifier|static
name|double
name|complex
name|clog_for_large_values
parameter_list|(
name|double
name|complex
name|z
parameter_list|)
block|{
name|double
name|x
decl_stmt|,
name|y
decl_stmt|;
name|double
name|ax
decl_stmt|,
name|ay
decl_stmt|,
name|t
decl_stmt|;
name|x
operator|=
name|creal
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|y
operator|=
name|cimag
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|ax
operator|=
name|fabs
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|ay
operator|=
name|fabs
argument_list|(
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|ax
operator|<
name|ay
condition|)
block|{
name|t
operator|=
name|ax
expr_stmt|;
name|ax
operator|=
name|ay
expr_stmt|;
name|ay
operator|=
name|t
expr_stmt|;
block|}
comment|/* 	 * Avoid overflow in hypot() when x and y are both very large. 	 * Divide x and y by E, and then add 1 to the logarithm.  This 	 * depends on E being larger than sqrt(2), since the return value of 	 * hypot cannot overflow if neither argument is greater in magnitude 	 * than 1/sqrt(2) of the maximum value of the return type.  Likewise 	 * this determines the necessary threshold for using this method 	 * (however, actually use 1/2 instead as it is simpler). 	 * 	 * Dividing by E causes an insignificant loss of accuracy; however 	 * this method is still poor since it is uneccessarily slow. 	 */
if|if
condition|(
name|ax
operator|>
name|DBL_MAX
operator|/
literal|2
condition|)
return|return
operator|(
name|CMPLX
argument_list|(
name|log
argument_list|(
name|hypot
argument_list|(
name|x
operator|/
name|m_e
argument_list|,
name|y
operator|/
name|m_e
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|,
name|atan2
argument_list|(
name|y
argument_list|,
name|x
argument_list|)
argument_list|)
operator|)
return|;
comment|/* 	 * Avoid overflow when x or y is large.  Avoid underflow when x or 	 * y is small. 	 */
if|if
condition|(
name|ax
operator|>
name|QUARTER_SQRT_MAX
operator|||
name|ay
operator|<
name|SQRT_MIN
condition|)
return|return
operator|(
name|CMPLX
argument_list|(
name|log
argument_list|(
name|hypot
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
argument_list|,
name|atan2
argument_list|(
name|y
argument_list|,
name|x
argument_list|)
argument_list|)
operator|)
return|;
return|return
operator|(
name|CMPLX
argument_list|(
name|log
argument_list|(
name|ax
operator|*
name|ax
operator|+
name|ay
operator|*
name|ay
argument_list|)
operator|/
literal|2
argument_list|,
name|atan2
argument_list|(
name|y
argument_list|,
name|x
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *				=================  *				| catanh, catan |  *				=================  */
end_comment

begin_comment
comment|/*  * sum_squares(x,y) = x*x + y*y (or just x*x if y*y would underflow).  * Assumes x*x and y*y will not overflow.  * Assumes x and y are finite.  * Assumes y is non-negative.  * Assumes fabs(x)>= DBL_EPSILON.  */
end_comment

begin_function
specifier|static
specifier|inline
name|double
name|sum_squares
parameter_list|(
name|double
name|x
parameter_list|,
name|double
name|y
parameter_list|)
block|{
comment|/* Avoid underflow when y is small. */
if|if
condition|(
name|y
operator|<
name|SQRT_MIN
condition|)
return|return
operator|(
name|x
operator|*
name|x
operator|)
return|;
return|return
operator|(
name|x
operator|*
name|x
operator|+
name|y
operator|*
name|y
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * real_part_reciprocal(x, y) = Re(1/(x+I*y)) = x/(x*x + y*y).  * Assumes x and y are not NaN, and one of x and y is larger than  * RECIP_EPSILON.  We avoid unwarranted underflow.  It is important to not use  * the code creal(1/z), because the imaginary part may produce an unwanted  * underflow.  * This is only called in a context where inexact is always raised before  * the call, so no effort is made to avoid or force inexact.  */
end_comment

begin_function
specifier|static
specifier|inline
name|double
name|real_part_reciprocal
parameter_list|(
name|double
name|x
parameter_list|,
name|double
name|y
parameter_list|)
block|{
name|double
name|scale
decl_stmt|;
name|uint32_t
name|hx
decl_stmt|,
name|hy
decl_stmt|;
name|int32_t
name|ix
decl_stmt|,
name|iy
decl_stmt|;
comment|/* 	 * This code is inspired by the C99 document n1124.pdf, Section G.5.1, 	 * example 2. 	 */
name|GET_HIGH_WORD
argument_list|(
name|hx
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|ix
operator|=
name|hx
operator|&
literal|0x7ff00000
expr_stmt|;
name|GET_HIGH_WORD
argument_list|(
name|hy
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|iy
operator|=
name|hy
operator|&
literal|0x7ff00000
expr_stmt|;
define|#
directive|define
name|BIAS
value|(DBL_MAX_EXP - 1)
comment|/* XXX more guard digits are useful iff there is extra precision. */
define|#
directive|define
name|CUTOFF
value|(DBL_MANT_DIG / 2 + 1)
comment|/* just half or 1 guard digit */
if|if
condition|(
name|ix
operator|-
name|iy
operator|>=
name|CUTOFF
operator|<<
literal|20
operator|||
name|isinf
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|/
name|x
operator|)
return|;
comment|/* +-Inf -> +-0 is special */
if|if
condition|(
name|iy
operator|-
name|ix
operator|>=
name|CUTOFF
operator|<<
literal|20
condition|)
return|return
operator|(
name|x
operator|/
name|y
operator|/
name|y
operator|)
return|;
comment|/* should avoid double div, but hard */
if|if
condition|(
name|ix
operator|<=
operator|(
name|BIAS
operator|+
name|DBL_MAX_EXP
operator|/
literal|2
operator|-
name|CUTOFF
operator|)
operator|<<
literal|20
condition|)
return|return
operator|(
name|x
operator|/
operator|(
name|x
operator|*
name|x
operator|+
name|y
operator|*
name|y
operator|)
operator|)
return|;
name|scale
operator|=
literal|1
expr_stmt|;
name|SET_HIGH_WORD
argument_list|(
name|scale
argument_list|,
literal|0x7ff00000
operator|-
name|ix
argument_list|)
expr_stmt|;
comment|/* 2**(1-ilogb(x)) */
name|x
operator|*=
name|scale
expr_stmt|;
name|y
operator|*=
name|scale
expr_stmt|;
return|return
operator|(
name|x
operator|/
operator|(
name|x
operator|*
name|x
operator|+
name|y
operator|*
name|y
operator|)
operator|*
name|scale
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * catanh(z) = log((1+z)/(1-z)) / 2  *           = log1p(4*x / |z-1|^2) / 4  *             + I * atan2(2*y, (1-x)*(1+x)-y*y) / 2  *  * catanh(z) = z + O(z^3)   as z -> 0  *  * catanh(z) = 1/z + sign(y)*I*PI/2 + O(1/z^3)   as z -> infinity  * The above formula works for the real part as well, because  * Re(catanh(z)) = x/|z|^2 + O(x/z^4)  *    as z -> infinity, uniformly in x  */
end_comment

begin_function
name|double
name|complex
name|catanh
parameter_list|(
name|double
name|complex
name|z
parameter_list|)
block|{
name|double
name|x
decl_stmt|,
name|y
decl_stmt|,
name|ax
decl_stmt|,
name|ay
decl_stmt|,
name|rx
decl_stmt|,
name|ry
decl_stmt|;
name|x
operator|=
name|creal
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|y
operator|=
name|cimag
argument_list|(
name|z
argument_list|)
expr_stmt|;
name|ax
operator|=
name|fabs
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|ay
operator|=
name|fabs
argument_list|(
name|y
argument_list|)
expr_stmt|;
comment|/* This helps handle many cases. */
if|if
condition|(
name|y
operator|==
literal|0
operator|&&
name|ax
operator|<=
literal|1
condition|)
return|return
operator|(
name|CMPLX
argument_list|(
name|atanh
argument_list|(
name|x
argument_list|)
argument_list|,
name|y
argument_list|)
operator|)
return|;
comment|/* To ensure the same accuracy as atan(), and to filter out z = 0. */
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
operator|(
name|CMPLX
argument_list|(
name|x
argument_list|,
name|atan
argument_list|(
name|y
argument_list|)
argument_list|)
operator|)
return|;
if|if
condition|(
name|isnan
argument_list|(
name|x
argument_list|)
operator|||
name|isnan
argument_list|(
name|y
argument_list|)
condition|)
block|{
comment|/* catanh(+-Inf + I*NaN) = +-0 + I*NaN */
if|if
condition|(
name|isinf
argument_list|(
name|x
argument_list|)
condition|)
return|return
operator|(
name|CMPLX
argument_list|(
name|copysign
argument_list|(
literal|0
argument_list|,
name|x
argument_list|)
argument_list|,
name|y
operator|+
name|y
argument_list|)
operator|)
return|;
comment|/* catanh(NaN + I*+-Inf) = sign(NaN)0 + I*+-PI/2 */
if|if
condition|(
name|isinf
argument_list|(
name|y
argument_list|)
condition|)
return|return
operator|(
name|CMPLX
argument_list|(
name|copysign
argument_list|(
literal|0
argument_list|,
name|x
argument_list|)
argument_list|,
name|copysign
argument_list|(
name|pio2_hi
operator|+
name|pio2_lo
argument_list|,
name|y
argument_list|)
argument_list|)
operator|)
return|;
comment|/* 		 * All other cases involving NaN return NaN + I*NaN. 		 * C99 leaves it optional whether to raise invalid if one of 		 * the arguments is not NaN, so we opt not to raise it. 		 */
return|return
operator|(
name|CMPLX
argument_list|(
name|x
operator|+
literal|0.0L
operator|+
operator|(
name|y
operator|+
literal|0
operator|)
argument_list|,
name|x
operator|+
literal|0.0L
operator|+
operator|(
name|y
operator|+
literal|0
operator|)
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|ax
operator|>
name|RECIP_EPSILON
operator|||
name|ay
operator|>
name|RECIP_EPSILON
condition|)
return|return
operator|(
name|CMPLX
argument_list|(
name|real_part_reciprocal
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
argument_list|,
name|copysign
argument_list|(
name|pio2_hi
operator|+
name|pio2_lo
argument_list|,
name|y
argument_list|)
argument_list|)
operator|)
return|;
if|if
condition|(
name|ax
operator|<
name|SQRT_3_EPSILON
operator|/
literal|2
operator|&&
name|ay
operator|<
name|SQRT_3_EPSILON
operator|/
literal|2
condition|)
block|{
comment|/* 		 * z = 0 was filtered out above.  All other cases must raise 		 * inexact, but this is the only only that needs to do it 		 * explicitly. 		 */
name|raise_inexact
argument_list|()
expr_stmt|;
return|return
operator|(
name|z
operator|)
return|;
block|}
if|if
condition|(
name|ax
operator|==
literal|1
operator|&&
name|ay
operator|<
name|DBL_EPSILON
condition|)
name|rx
operator|=
operator|(
name|m_ln2
operator|-
name|log
argument_list|(
name|ay
argument_list|)
operator|)
operator|/
literal|2
expr_stmt|;
else|else
name|rx
operator|=
name|log1p
argument_list|(
literal|4
operator|*
name|ax
operator|/
name|sum_squares
argument_list|(
name|ax
operator|-
literal|1
argument_list|,
name|ay
argument_list|)
argument_list|)
operator|/
literal|4
expr_stmt|;
if|if
condition|(
name|ax
operator|==
literal|1
condition|)
name|ry
operator|=
name|atan2
argument_list|(
literal|2
argument_list|,
operator|-
name|ay
argument_list|)
operator|/
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|ay
operator|<
name|DBL_EPSILON
condition|)
name|ry
operator|=
name|atan2
argument_list|(
literal|2
operator|*
name|ay
argument_list|,
operator|(
literal|1
operator|-
name|ax
operator|)
operator|*
operator|(
literal|1
operator|+
name|ax
operator|)
argument_list|)
operator|/
literal|2
expr_stmt|;
else|else
name|ry
operator|=
name|atan2
argument_list|(
literal|2
operator|*
name|ay
argument_list|,
operator|(
literal|1
operator|-
name|ax
operator|)
operator|*
operator|(
literal|1
operator|+
name|ax
operator|)
operator|-
name|ay
operator|*
name|ay
argument_list|)
operator|/
literal|2
expr_stmt|;
return|return
operator|(
name|CMPLX
argument_list|(
name|copysign
argument_list|(
name|rx
argument_list|,
name|x
argument_list|)
argument_list|,
name|copysign
argument_list|(
name|ry
argument_list|,
name|y
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * catan(z) = reverse(catanh(reverse(z)))  * where reverse(x + I*y) = y + I*x = I*conj(z).  */
end_comment

begin_function
name|double
name|complex
name|catan
parameter_list|(
name|double
name|complex
name|z
parameter_list|)
block|{
name|double
name|complex
name|w
init|=
name|catanh
argument_list|(
name|CMPLX
argument_list|(
name|cimag
argument_list|(
name|z
argument_list|)
argument_list|,
name|creal
argument_list|(
name|z
argument_list|)
argument_list|)
argument_list|)
decl_stmt|;
return|return
operator|(
name|CMPLX
argument_list|(
name|cimag
argument_list|(
name|w
argument_list|)
argument_list|,
name|creal
argument_list|(
name|w
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|LDBL_MANT_DIG
operator|==
literal|53
end_if

begin_expr_stmt
name|__weak_reference
argument_list|(
name|cacosh
argument_list|,
name|cacoshl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__weak_reference
argument_list|(
name|cacos
argument_list|,
name|cacosl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__weak_reference
argument_list|(
name|casinh
argument_list|,
name|casinhl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__weak_reference
argument_list|(
name|casin
argument_list|,
name|casinl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__weak_reference
argument_list|(
name|catanh
argument_list|,
name|catanhl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__weak_reference
argument_list|(
name|catan
argument_list|,
name|catanl
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

end_unit

