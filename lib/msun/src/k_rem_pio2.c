begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* @(#)k_rem_pio2.c 1.3 95/01/18 */
end_comment

begin_comment
comment|/*  * ====================================================  * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.  *  * Developed at SunSoft, a Sun Microsystems, Inc. business.  * Permission to use, copy, modify, and distribute this  * software is freely granted, provided that this notice   * is preserved.  * ====================================================  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * __kernel_rem_pio2(x,y,e0,nx,prec,ipio2)  * double x[],y[]; int e0,nx,prec; int ipio2[];  *   * __kernel_rem_pio2 return the last three digits of N with   *		y = x - N*pi/2  * so that |y|< pi/2.  *  * The method is to compute the integer (mod 8) and fraction parts of   * (2/pi)*x without doing the full multiplication. In general we  * skip the part of the product that are known to be a huge integer (  * more accurately, = 0 mod 8 ). Thus the number of operations are  * independent of the exponent of the input.  *  * (2/pi) is represented by an array of 24-bit integers in ipio2[].  *  * Input parameters:  * 	x[]	The input value (must be positive) is broken into nx   *		pieces of 24-bit integers in double precision format.  *		x[i] will be the i-th 24 bit of x. The scaled exponent   *		of x[0] is given in input parameter e0 (i.e., x[0]*2^e0   *		match x's up to 24 bits.  *  *		Example of breaking a double positive z into x[0]+x[1]+x[2]:  *			e0 = ilogb(z)-23  *			z  = scalbn(z,-e0)  *		for i = 0,1,2  *			x[i] = floor(z)  *			z    = (z-x[i])*2**24  *  *  *	y[]	ouput result in an array of double precision numbers.  *		The dimension of y[] is:  *			24-bit  precision	1  *			53-bit  precision	2  *			64-bit  precision	2  *			113-bit precision	3  *		The actual value is the sum of them. Thus for 113-bit  *		precison, one may have to do something like:  *  *		long double t,w,r_head, r_tail;  *		t = (long double)y[2] + (long double)y[1];  *		w = (long double)y[0];  *		r_head = t+w;  *		r_tail = w - (r_head - t);  *  *	e0	The exponent of x[0]  *  *	nx	dimension of x[]  *  *  	prec	an integer indicating the precision:  *			0	24  bits (single)  *			1	53  bits (double)  *			2	64  bits (extended)  *			3	113 bits (quad)  *  *	ipio2[]  *		integer array, contains the (24*i)-th to (24*i+23)-th   *		bit of 2/pi after binary point. The corresponding   *		floating value is  *  *			ipio2[i] * 2^(-24(i+1)).  *  * External function:  *	double scalbn(), floor();  *  *  * Here is the description of some local variables:  *  * 	jk	jk+1 is the initial number of terms of ipio2[] needed  *		in the computation. The recommended value is 2,3,4,  *		6 for single, double, extended,and quad.  *  * 	jz	local integer variable indicating the number of   *		terms of ipio2[] used.   *  *	jx	nx - 1  *  *	jv	index for pointing to the suitable ipio2[] for the  *		computation. In general, we want  *			( 2^e0*x[0] * ipio2[jv-1]*2^(-24jv) )/8  *		is an integer. Thus  *			e0-3-24*jv>= 0 or (e0-3)/24>= jv  *		Hence jv = max(0,(e0-3)/24).  *  *	jp	jp+1 is the number of terms in PIo2[] needed, jp = jk.  *  * 	q[]	double array with integral value, representing the  *		24-bits chunk of the product of x and 2/pi.  *  *	q0	the corresponding exponent of q[0]. Note that the  *		exponent for q[i] would be q0-24*i.  *  *	PIo2[]	double precision array, obtained by cutting pi/2  *		into 24 bits chunks.   *  *	f[]	ipio2[] in floating point   *  *	iq[]	integer array by breaking up q[] in 24-bits chunk.  *  *	fq[]	final product of x*(2/pi) in fq[0],..,fq[jk]  *  *	ih	integer. If>0 it indicates q[] is>= 0.5, hence  *		it also indicates the *sign* of the result.  *  */
end_comment

begin_comment
comment|/*  * Constants:  * The hexadecimal values are the intended ones for the following   * constants. The decimal values may be used, provided that the   * compiler will convert from decimal to binary accurately enough   * to produce the hexadecimal values shown.  */
end_comment

begin_include
include|#
directive|include
file|"math.h"
end_include

begin_include
include|#
directive|include
file|"math_private.h"
end_include

begin_decl_stmt
specifier|static
specifier|const
name|int
name|init_jk
index|[]
init|=
block|{
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|6
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* initial value for jk */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|double
name|PIo2
index|[]
init|=
block|{
literal|1.57079625129699707031e+00
block|,
comment|/* 0x3FF921FB, 0x40000000 */
literal|7.54978941586159635335e-08
block|,
comment|/* 0x3E74442D, 0x00000000 */
literal|5.39030252995776476554e-15
block|,
comment|/* 0x3CF84698, 0x80000000 */
literal|3.28200341580791294123e-22
block|,
comment|/* 0x3B78CC51, 0x60000000 */
literal|1.27065575308067607349e-29
block|,
comment|/* 0x39F01B83, 0x80000000 */
literal|1.22933308981111328932e-36
block|,
comment|/* 0x387A2520, 0x40000000 */
literal|2.73370053816464559624e-44
block|,
comment|/* 0x36E38222, 0x80000000 */
literal|2.16741683877804819444e-51
block|,
comment|/* 0x3569F31D, 0x00000000 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|double
name|zero
init|=
literal|0.0
decl_stmt|,
name|one
init|=
literal|1.0
decl_stmt|,
name|two24
init|=
literal|1.67772160000000000000e+07
decl_stmt|,
comment|/* 0x41700000, 0x00000000 */
name|twon24
init|=
literal|5.96046447753906250000e-08
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0x3E700000, 0x00000000 */
end_comment

begin_function
name|int
name|__kernel_rem_pio2
parameter_list|(
name|double
modifier|*
name|x
parameter_list|,
name|double
modifier|*
name|y
parameter_list|,
name|int
name|e0
parameter_list|,
name|int
name|nx
parameter_list|,
name|int
name|prec
parameter_list|,
specifier|const
name|int32_t
modifier|*
name|ipio2
parameter_list|)
block|{
name|int32_t
name|jz
decl_stmt|,
name|jx
decl_stmt|,
name|jv
decl_stmt|,
name|jp
decl_stmt|,
name|jk
decl_stmt|,
name|carry
decl_stmt|,
name|n
decl_stmt|,
name|iq
index|[
literal|20
index|]
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|m
decl_stmt|,
name|q0
decl_stmt|,
name|ih
decl_stmt|;
name|double
name|z
decl_stmt|,
name|fw
decl_stmt|,
name|f
index|[
literal|20
index|]
decl_stmt|,
name|fq
index|[
literal|20
index|]
decl_stmt|,
name|q
index|[
literal|20
index|]
decl_stmt|;
comment|/* initialize jk*/
name|jk
operator|=
name|init_jk
index|[
name|prec
index|]
expr_stmt|;
name|jp
operator|=
name|jk
expr_stmt|;
comment|/* determine jx,jv,q0, note that 3>q0 */
name|jx
operator|=
name|nx
operator|-
literal|1
expr_stmt|;
name|jv
operator|=
operator|(
name|e0
operator|-
literal|3
operator|)
operator|/
literal|24
expr_stmt|;
if|if
condition|(
name|jv
operator|<
literal|0
condition|)
name|jv
operator|=
literal|0
expr_stmt|;
name|q0
operator|=
name|e0
operator|-
literal|24
operator|*
operator|(
name|jv
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* set up f[0] to f[jx+jk] where f[jx+jk] = ipio2[jv+jk] */
name|j
operator|=
name|jv
operator|-
name|jx
expr_stmt|;
name|m
operator|=
name|jx
operator|+
name|jk
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|m
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
name|f
index|[
name|i
index|]
operator|=
operator|(
name|j
operator|<
literal|0
operator|)
condition|?
name|zero
else|:
operator|(
name|double
operator|)
name|ipio2
index|[
name|j
index|]
expr_stmt|;
comment|/* compute q[0],q[1],...q[jk] */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|jk
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|fw
operator|=
literal|0.0
init|;
name|j
operator|<=
name|jx
condition|;
name|j
operator|++
control|)
name|fw
operator|+=
name|x
index|[
name|j
index|]
operator|*
name|f
index|[
name|jx
operator|+
name|i
operator|-
name|j
index|]
expr_stmt|;
name|q
index|[
name|i
index|]
operator|=
name|fw
expr_stmt|;
block|}
name|jz
operator|=
name|jk
expr_stmt|;
name|recompute
label|:
comment|/* distill q[] into iq[] reversingly */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|jz
operator|,
name|z
operator|=
name|q
index|[
name|jz
index|]
init|;
name|j
operator|>
literal|0
condition|;
name|i
operator|++
operator|,
name|j
operator|--
control|)
block|{
name|fw
operator|=
call|(
name|double
call|)
argument_list|(
call|(
name|int32_t
call|)
argument_list|(
name|twon24
operator|*
name|z
argument_list|)
argument_list|)
expr_stmt|;
name|iq
index|[
name|i
index|]
operator|=
call|(
name|int32_t
call|)
argument_list|(
name|z
operator|-
name|two24
operator|*
name|fw
argument_list|)
expr_stmt|;
name|z
operator|=
name|q
index|[
name|j
operator|-
literal|1
index|]
operator|+
name|fw
expr_stmt|;
block|}
comment|/* compute n */
name|z
operator|=
name|scalbn
argument_list|(
name|z
argument_list|,
name|q0
argument_list|)
expr_stmt|;
comment|/* actual value of z */
name|z
operator|-=
literal|8.0
operator|*
name|floor
argument_list|(
name|z
operator|*
literal|0.125
argument_list|)
expr_stmt|;
comment|/* trim off integer>= 8 */
name|n
operator|=
operator|(
name|int32_t
operator|)
name|z
expr_stmt|;
name|z
operator|-=
operator|(
name|double
operator|)
name|n
expr_stmt|;
name|ih
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|q0
operator|>
literal|0
condition|)
block|{
comment|/* need iq[jz-1] to determine n */
name|i
operator|=
operator|(
name|iq
index|[
name|jz
operator|-
literal|1
index|]
operator|>>
operator|(
literal|24
operator|-
name|q0
operator|)
operator|)
expr_stmt|;
name|n
operator|+=
name|i
expr_stmt|;
name|iq
index|[
name|jz
operator|-
literal|1
index|]
operator|-=
name|i
operator|<<
operator|(
literal|24
operator|-
name|q0
operator|)
expr_stmt|;
name|ih
operator|=
name|iq
index|[
name|jz
operator|-
literal|1
index|]
operator|>>
operator|(
literal|23
operator|-
name|q0
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q0
operator|==
literal|0
condition|)
name|ih
operator|=
name|iq
index|[
name|jz
operator|-
literal|1
index|]
operator|>>
literal|23
expr_stmt|;
elseif|else
if|if
condition|(
name|z
operator|>=
literal|0.5
condition|)
name|ih
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|ih
operator|>
literal|0
condition|)
block|{
comment|/* q> 0.5 */
name|n
operator|+=
literal|1
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|jz
condition|;
name|i
operator|++
control|)
block|{
comment|/* compute 1-q */
name|j
operator|=
name|iq
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|carry
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|j
operator|!=
literal|0
condition|)
block|{
name|carry
operator|=
literal|1
expr_stmt|;
name|iq
index|[
name|i
index|]
operator|=
literal|0x1000000
operator|-
name|j
expr_stmt|;
block|}
block|}
else|else
name|iq
index|[
name|i
index|]
operator|=
literal|0xffffff
operator|-
name|j
expr_stmt|;
block|}
if|if
condition|(
name|q0
operator|>
literal|0
condition|)
block|{
comment|/* rare case: chance is 1 in 12 */
switch|switch
condition|(
name|q0
condition|)
block|{
case|case
literal|1
case|:
name|iq
index|[
name|jz
operator|-
literal|1
index|]
operator|&=
literal|0x7fffff
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|iq
index|[
name|jz
operator|-
literal|1
index|]
operator|&=
literal|0x3fffff
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ih
operator|==
literal|2
condition|)
block|{
name|z
operator|=
name|one
operator|-
name|z
expr_stmt|;
if|if
condition|(
name|carry
operator|!=
literal|0
condition|)
name|z
operator|-=
name|scalbn
argument_list|(
name|one
argument_list|,
name|q0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* check if recomputation is needed */
if|if
condition|(
name|z
operator|==
name|zero
condition|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|jz
operator|-
literal|1
init|;
name|i
operator|>=
name|jk
condition|;
name|i
operator|--
control|)
name|j
operator||=
name|iq
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|0
condition|)
block|{
comment|/* need recomputation */
for|for
control|(
name|k
operator|=
literal|1
init|;
name|iq
index|[
name|jk
operator|-
name|k
index|]
operator|==
literal|0
condition|;
name|k
operator|++
control|)
empty_stmt|;
comment|/* k = no. of terms needed */
for|for
control|(
name|i
operator|=
name|jz
operator|+
literal|1
init|;
name|i
operator|<=
name|jz
operator|+
name|k
condition|;
name|i
operator|++
control|)
block|{
comment|/* add q[jz+1] to q[jz+k] */
name|f
index|[
name|jx
operator|+
name|i
index|]
operator|=
operator|(
name|double
operator|)
name|ipio2
index|[
name|jv
operator|+
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|fw
operator|=
literal|0.0
init|;
name|j
operator|<=
name|jx
condition|;
name|j
operator|++
control|)
name|fw
operator|+=
name|x
index|[
name|j
index|]
operator|*
name|f
index|[
name|jx
operator|+
name|i
operator|-
name|j
index|]
expr_stmt|;
name|q
index|[
name|i
index|]
operator|=
name|fw
expr_stmt|;
block|}
name|jz
operator|+=
name|k
expr_stmt|;
goto|goto
name|recompute
goto|;
block|}
block|}
comment|/* chop off zero terms */
if|if
condition|(
name|z
operator|==
literal|0.0
condition|)
block|{
name|jz
operator|-=
literal|1
expr_stmt|;
name|q0
operator|-=
literal|24
expr_stmt|;
while|while
condition|(
name|iq
index|[
name|jz
index|]
operator|==
literal|0
condition|)
block|{
name|jz
operator|--
expr_stmt|;
name|q0
operator|-=
literal|24
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* break z into 24-bit if necessary */
name|z
operator|=
name|scalbn
argument_list|(
name|z
argument_list|,
operator|-
name|q0
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|>=
name|two24
condition|)
block|{
name|fw
operator|=
call|(
name|double
call|)
argument_list|(
call|(
name|int32_t
call|)
argument_list|(
name|twon24
operator|*
name|z
argument_list|)
argument_list|)
expr_stmt|;
name|iq
index|[
name|jz
index|]
operator|=
call|(
name|int32_t
call|)
argument_list|(
name|z
operator|-
name|two24
operator|*
name|fw
argument_list|)
expr_stmt|;
name|jz
operator|+=
literal|1
expr_stmt|;
name|q0
operator|+=
literal|24
expr_stmt|;
name|iq
index|[
name|jz
index|]
operator|=
operator|(
name|int32_t
operator|)
name|fw
expr_stmt|;
block|}
else|else
name|iq
index|[
name|jz
index|]
operator|=
operator|(
name|int32_t
operator|)
name|z
expr_stmt|;
block|}
comment|/* convert integer "bit" chunk to floating-point value */
name|fw
operator|=
name|scalbn
argument_list|(
name|one
argument_list|,
name|q0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|jz
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|q
index|[
name|i
index|]
operator|=
name|fw
operator|*
operator|(
name|double
operator|)
name|iq
index|[
name|i
index|]
expr_stmt|;
name|fw
operator|*=
name|twon24
expr_stmt|;
block|}
comment|/* compute PIo2[0,...,jp]*q[jz,...,0] */
for|for
control|(
name|i
operator|=
name|jz
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
for|for
control|(
name|fw
operator|=
literal|0.0
operator|,
name|k
operator|=
literal|0
init|;
name|k
operator|<=
name|jp
operator|&&
name|k
operator|<=
name|jz
operator|-
name|i
condition|;
name|k
operator|++
control|)
name|fw
operator|+=
name|PIo2
index|[
name|k
index|]
operator|*
name|q
index|[
name|i
operator|+
name|k
index|]
expr_stmt|;
name|fq
index|[
name|jz
operator|-
name|i
index|]
operator|=
name|fw
expr_stmt|;
block|}
comment|/* compress fq[] into y[] */
switch|switch
condition|(
name|prec
condition|)
block|{
case|case
literal|0
case|:
name|fw
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|jz
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|fw
operator|+=
name|fq
index|[
name|i
index|]
expr_stmt|;
name|y
index|[
literal|0
index|]
operator|=
operator|(
name|ih
operator|==
literal|0
operator|)
condition|?
name|fw
else|:
operator|-
name|fw
expr_stmt|;
break|break;
case|case
literal|1
case|:
case|case
literal|2
case|:
name|fw
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|jz
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|fw
operator|+=
name|fq
index|[
name|i
index|]
expr_stmt|;
name|y
index|[
literal|0
index|]
operator|=
operator|(
name|ih
operator|==
literal|0
operator|)
condition|?
name|fw
else|:
operator|-
name|fw
expr_stmt|;
name|fw
operator|=
name|fq
index|[
literal|0
index|]
operator|-
name|fw
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|jz
condition|;
name|i
operator|++
control|)
name|fw
operator|+=
name|fq
index|[
name|i
index|]
expr_stmt|;
name|y
index|[
literal|1
index|]
operator|=
operator|(
name|ih
operator|==
literal|0
operator|)
condition|?
name|fw
else|:
operator|-
name|fw
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* painful */
for|for
control|(
name|i
operator|=
name|jz
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|fw
operator|=
name|fq
index|[
name|i
operator|-
literal|1
index|]
operator|+
name|fq
index|[
name|i
index|]
expr_stmt|;
name|fq
index|[
name|i
index|]
operator|+=
name|fq
index|[
name|i
operator|-
literal|1
index|]
operator|-
name|fw
expr_stmt|;
name|fq
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|fw
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|jz
init|;
name|i
operator|>
literal|1
condition|;
name|i
operator|--
control|)
block|{
name|fw
operator|=
name|fq
index|[
name|i
operator|-
literal|1
index|]
operator|+
name|fq
index|[
name|i
index|]
expr_stmt|;
name|fq
index|[
name|i
index|]
operator|+=
name|fq
index|[
name|i
operator|-
literal|1
index|]
operator|-
name|fw
expr_stmt|;
name|fq
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|fw
expr_stmt|;
block|}
for|for
control|(
name|fw
operator|=
literal|0.0
operator|,
name|i
operator|=
name|jz
init|;
name|i
operator|>=
literal|2
condition|;
name|i
operator|--
control|)
name|fw
operator|+=
name|fq
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ih
operator|==
literal|0
condition|)
block|{
name|y
index|[
literal|0
index|]
operator|=
name|fq
index|[
literal|0
index|]
expr_stmt|;
name|y
index|[
literal|1
index|]
operator|=
name|fq
index|[
literal|1
index|]
expr_stmt|;
name|y
index|[
literal|2
index|]
operator|=
name|fw
expr_stmt|;
block|}
else|else
block|{
name|y
index|[
literal|0
index|]
operator|=
operator|-
name|fq
index|[
literal|0
index|]
expr_stmt|;
name|y
index|[
literal|1
index|]
operator|=
operator|-
name|fq
index|[
literal|1
index|]
expr_stmt|;
name|y
index|[
literal|2
index|]
operator|=
operator|-
name|fw
expr_stmt|;
block|}
block|}
return|return
name|n
operator|&
literal|7
return|;
block|}
end_function

end_unit

