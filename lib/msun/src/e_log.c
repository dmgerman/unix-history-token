begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* @(#)e_log.c 5.1 93/09/24 */
end_comment

begin_comment
comment|/*  * ====================================================  * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.  *  * Developed at SunPro, a Sun Microsystems, Inc. business.  * Permission to use, copy, modify, and distribute this  * software is freely granted, provided that this notice  * is preserved.  * ====================================================  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __ieee754_log(x)  * Return the logrithm of x  *  * Method :  *   1. Argument Reduction: find k and f such that  *			x = 2^k * (1+f),  *	   where  sqrt(2)/2< 1+f< sqrt(2) .  *  *   2. Approximation of log(1+f).  *	Let s = f/(2+f) ; based on log(1+f) = log(1+s) - log(1-s)  *		 = 2s + 2/3 s**3 + 2/5 s**5 + .....,  *	     	 = 2s + s*R  *      We use a special Reme algorithm on [0,0.1716] to generate  * 	a polynomial of degree 14 to approximate R The maximum error  *	of this polynomial approximation is bounded by 2**-58.45. In  *	other words,  *		        2      4      6      8      10      12      14  *	    R(z) ~ Lg1*s +Lg2*s +Lg3*s +Lg4*s +Lg5*s  +Lg6*s  +Lg7*s  *  	(the values of Lg1 to Lg7 are listed in the program)  *	and  *	    |      2          14          |     -58.45  *	    | Lg1*s +...+Lg7*s    -  R(z) |<= 2  *	    |                             |  *	Note that 2s = f - s*f = f - hfsq + s*hfsq, where hfsq = f*f/2.  *	In order to guarantee error in log below 1ulp, we compute log  *	by  *		log(1+f) = f - s*(f - R)	(if f is not too large)  *		log(1+f) = f - (hfsq - s*(hfsq+R)).	(better accuracy)  *  *	3. Finally,  log(x) = k*ln2 + log(1+f).  *			    = k*ln2_hi+(f-(hfsq-(s*(hfsq+R)+k*ln2_lo)))  *	   Here ln2 is split into two floating point number:  *			ln2_hi + ln2_lo,  *	   where n*ln2_hi is always exact for |n|< 2000.  *  * Special cases:  *	log(x) is NaN with signal if x< 0 (including -INF) ;  *	log(+INF) is +INF; log(0) is -INF with signal;  *	log(NaN) is that NaN with no signal.  *  * Accuracy:  *	according to an error analysis, the error is always less than  *	1 ulp (unit in the last place).  *  * Constants:  * The hexadecimal values are the intended ones for the following  * constants. The decimal values may be used, provided that the  * compiler will convert from decimal to binary accurately enough  * to produce the hexadecimal values shown.  */
end_comment

begin_include
include|#
directive|include
file|"math.h"
end_include

begin_include
include|#
directive|include
file|"math_private.h"
end_include

begin_decl_stmt
specifier|static
specifier|const
name|double
name|ln2_hi
init|=
literal|6.93147180369123816490e-01
decl_stmt|,
comment|/* 3fe62e42 fee00000 */
name|ln2_lo
init|=
literal|1.90821492927058770002e-10
decl_stmt|,
comment|/* 3dea39ef 35793c76 */
name|two54
init|=
literal|1.80143985094819840000e+16
decl_stmt|,
comment|/* 43500000 00000000 */
name|Lg1
init|=
literal|6.666666666666735130e-01
decl_stmt|,
comment|/* 3FE55555 55555593 */
name|Lg2
init|=
literal|3.999999999940941908e-01
decl_stmt|,
comment|/* 3FD99999 9997FA04 */
name|Lg3
init|=
literal|2.857142874366239149e-01
decl_stmt|,
comment|/* 3FD24924 94229359 */
name|Lg4
init|=
literal|2.222219843214978396e-01
decl_stmt|,
comment|/* 3FCC71C5 1D8E78AF */
name|Lg5
init|=
literal|1.818357216161805012e-01
decl_stmt|,
comment|/* 3FC74664 96CB03DE */
name|Lg6
init|=
literal|1.531383769920937332e-01
decl_stmt|,
comment|/* 3FC39A09 D078C69F */
name|Lg7
init|=
literal|1.479819860511658591e-01
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 3FC2F112 DF3E5244 */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|double
name|zero
init|=
literal|0.0
decl_stmt|;
end_decl_stmt

begin_function
name|double
name|__generic___ieee754_log
parameter_list|(
name|double
name|x
parameter_list|)
block|{
name|double
name|hfsq
decl_stmt|,
name|f
decl_stmt|,
name|s
decl_stmt|,
name|z
decl_stmt|,
name|R
decl_stmt|,
name|w
decl_stmt|,
name|t1
decl_stmt|,
name|t2
decl_stmt|,
name|dk
decl_stmt|;
name|int32_t
name|k
decl_stmt|,
name|hx
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|u_int32_t
name|lx
decl_stmt|;
name|EXTRACT_WORDS
argument_list|(
name|hx
argument_list|,
name|lx
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|hx
operator|<
literal|0x00100000
condition|)
block|{
comment|/* x< 2**-1022  */
if|if
condition|(
operator|(
operator|(
name|hx
operator|&
literal|0x7fffffff
operator|)
operator||
name|lx
operator|)
operator|==
literal|0
condition|)
return|return
operator|-
name|two54
operator|/
name|zero
return|;
comment|/* log(+-0)=-inf */
if|if
condition|(
name|hx
operator|<
literal|0
condition|)
return|return
operator|(
name|x
operator|-
name|x
operator|)
operator|/
name|zero
return|;
comment|/* log(-#) = NaN */
name|k
operator|-=
literal|54
expr_stmt|;
name|x
operator|*=
name|two54
expr_stmt|;
comment|/* subnormal number, scale up x */
name|GET_HIGH_WORD
argument_list|(
name|hx
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hx
operator|>=
literal|0x7ff00000
condition|)
return|return
name|x
operator|+
name|x
return|;
name|k
operator|+=
operator|(
name|hx
operator|>>
literal|20
operator|)
operator|-
literal|1023
expr_stmt|;
name|hx
operator|&=
literal|0x000fffff
expr_stmt|;
name|i
operator|=
operator|(
name|hx
operator|+
literal|0x95f64
operator|)
operator|&
literal|0x100000
expr_stmt|;
name|SET_HIGH_WORD
argument_list|(
name|x
argument_list|,
name|hx
operator||
operator|(
name|i
operator|^
literal|0x3ff00000
operator|)
argument_list|)
expr_stmt|;
comment|/* normalize x or x/2 */
name|k
operator|+=
operator|(
name|i
operator|>>
literal|20
operator|)
expr_stmt|;
name|f
operator|=
name|x
operator|-
literal|1.0
expr_stmt|;
if|if
condition|(
operator|(
literal|0x000fffff
operator|&
operator|(
literal|2
operator|+
name|hx
operator|)
operator|)
operator|<
literal|3
condition|)
block|{
comment|/* |f|< 2**-20 */
if|if
condition|(
name|f
operator|==
name|zero
condition|)
if|if
condition|(
name|k
operator|==
literal|0
condition|)
return|return
name|zero
return|;
else|else
block|{
name|dk
operator|=
operator|(
name|double
operator|)
name|k
expr_stmt|;
return|return
name|dk
operator|*
name|ln2_hi
operator|+
name|dk
operator|*
name|ln2_lo
return|;
block|}
name|R
operator|=
name|f
operator|*
name|f
operator|*
operator|(
literal|0.5
operator|-
literal|0.33333333333333333
operator|*
name|f
operator|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|0
condition|)
return|return
name|f
operator|-
name|R
return|;
else|else
block|{
name|dk
operator|=
operator|(
name|double
operator|)
name|k
expr_stmt|;
return|return
name|dk
operator|*
name|ln2_hi
operator|-
operator|(
operator|(
name|R
operator|-
name|dk
operator|*
name|ln2_lo
operator|)
operator|-
name|f
operator|)
return|;
block|}
block|}
name|s
operator|=
name|f
operator|/
operator|(
literal|2.0
operator|+
name|f
operator|)
expr_stmt|;
name|dk
operator|=
operator|(
name|double
operator|)
name|k
expr_stmt|;
name|z
operator|=
name|s
operator|*
name|s
expr_stmt|;
name|i
operator|=
name|hx
operator|-
literal|0x6147a
expr_stmt|;
name|w
operator|=
name|z
operator|*
name|z
expr_stmt|;
name|j
operator|=
literal|0x6b851
operator|-
name|hx
expr_stmt|;
name|t1
operator|=
name|w
operator|*
operator|(
name|Lg2
operator|+
name|w
operator|*
operator|(
name|Lg4
operator|+
name|w
operator|*
name|Lg6
operator|)
operator|)
expr_stmt|;
name|t2
operator|=
name|z
operator|*
operator|(
name|Lg1
operator|+
name|w
operator|*
operator|(
name|Lg3
operator|+
name|w
operator|*
operator|(
name|Lg5
operator|+
name|w
operator|*
name|Lg7
operator|)
operator|)
operator|)
expr_stmt|;
name|i
operator||=
name|j
expr_stmt|;
name|R
operator|=
name|t2
operator|+
name|t1
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|hfsq
operator|=
literal|0.5
operator|*
name|f
operator|*
name|f
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|0
condition|)
return|return
name|f
operator|-
operator|(
name|hfsq
operator|-
name|s
operator|*
operator|(
name|hfsq
operator|+
name|R
operator|)
operator|)
return|;
else|else
return|return
name|dk
operator|*
name|ln2_hi
operator|-
operator|(
operator|(
name|hfsq
operator|-
operator|(
name|s
operator|*
operator|(
name|hfsq
operator|+
name|R
operator|)
operator|+
name|dk
operator|*
name|ln2_lo
operator|)
operator|)
operator|-
name|f
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|k
operator|==
literal|0
condition|)
return|return
name|f
operator|-
name|s
operator|*
operator|(
name|f
operator|-
name|R
operator|)
return|;
else|else
return|return
name|dk
operator|*
name|ln2_hi
operator|-
operator|(
operator|(
name|s
operator|*
operator|(
name|f
operator|-
name|R
operator|)
operator|-
name|dk
operator|*
name|ln2_lo
operator|)
operator|-
name|f
operator|)
return|;
block|}
block|}
end_function

end_unit

