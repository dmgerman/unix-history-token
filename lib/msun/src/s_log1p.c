begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* @(#)s_log1p.c 5.1 93/09/24 */
end_comment

begin_comment
comment|/*  * ====================================================  * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.  *  * Developed at SunPro, a Sun Microsystems, Inc. business.  * Permission to use, copy, modify, and distribute this  * software is freely granted, provided that this notice  * is preserved.  * ====================================================  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* double log1p(double x)  *  * Method :  *   1. Argument Reduction: find k and f such that  *			1+x = 2^k * (1+f),  *	   where  sqrt(2)/2< 1+f< sqrt(2) .  *  *      Note. If k=0, then f=x is exact. However, if k!=0, then f  *	may not be representable exactly. In that case, a correction  *	term is need. Let u=1+x rounded. Let c = (1+x)-u, then  *	log(1+x) - log(u) ~ c/u. Thus, we proceed to compute log(u),  *	and add back the correction term c/u.  *	(Note: when x> 2**53, one can simply return log(x))  *  *   2. Approximation of log1p(f).  *	Let s = f/(2+f) ; based on log(1+f) = log(1+s) - log(1-s)  *		 = 2s + 2/3 s**3 + 2/5 s**5 + .....,  *	     	 = 2s + s*R  *      We use a special Reme algorithm on [0,0.1716] to generate  * 	a polynomial of degree 14 to approximate R The maximum error  *	of this polynomial approximation is bounded by 2**-58.45. In  *	other words,  *		        2      4      6      8      10      12      14  *	    R(z) ~ Lp1*s +Lp2*s +Lp3*s +Lp4*s +Lp5*s  +Lp6*s  +Lp7*s  *  	(the values of Lp1 to Lp7 are listed in the program)  *	and  *	    |      2          14          |     -58.45  *	    | Lp1*s +...+Lp7*s    -  R(z) |<= 2  *	    |                             |  *	Note that 2s = f - s*f = f - hfsq + s*hfsq, where hfsq = f*f/2.  *	In order to guarantee error in log below 1ulp, we compute log  *	by  *		log1p(f) = f - (hfsq - s*(hfsq+R)).  *  *	3. Finally, log1p(x) = k*ln2 + log1p(f).  *		 	     = k*ln2_hi+(f-(hfsq-(s*(hfsq+R)+k*ln2_lo)))  *	   Here ln2 is split into two floating point number:  *			ln2_hi + ln2_lo,  *	   where n*ln2_hi is always exact for |n|< 2000.  *  * Special cases:  *	log1p(x) is NaN with signal if x< -1 (including -INF) ;  *	log1p(+INF) is +INF; log1p(-1) is -INF with signal;  *	log1p(NaN) is that NaN with no signal.  *  * Accuracy:  *	according to an error analysis, the error is always less than  *	1 ulp (unit in the last place).  *  * Constants:  * The hexadecimal values are the intended ones for the following  * constants. The decimal values may be used, provided that the  * compiler will convert from decimal to binary accurately enough  * to produce the hexadecimal values shown.  *  * Note: Assuming log() return accurate answer, the following  * 	 algorithm can be used to compute log1p(x) to within a few ULP:  *  *		u = 1+x;  *		if(u==1.0) return x ; else  *			   return log(u)*(x/(u-1.0));  *  *	 See HP-15C Advanced Functions Handbook, p.193.  */
end_comment

begin_include
include|#
directive|include
file|"math.h"
end_include

begin_include
include|#
directive|include
file|"math_private.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|double
else|#
directive|else
specifier|static
name|double
endif|#
directive|endif
name|ln2_hi
init|=
literal|6.93147180369123816490e-01
decl_stmt|,
comment|/* 3fe62e42 fee00000 */
name|ln2_lo
init|=
literal|1.90821492927058770002e-10
decl_stmt|,
comment|/* 3dea39ef 35793c76 */
name|two54
init|=
literal|1.80143985094819840000e+16
decl_stmt|,
comment|/* 43500000 00000000 */
name|Lp1
init|=
literal|6.666666666666735130e-01
decl_stmt|,
comment|/* 3FE55555 55555593 */
name|Lp2
init|=
literal|3.999999999940941908e-01
decl_stmt|,
comment|/* 3FD99999 9997FA04 */
name|Lp3
init|=
literal|2.857142874366239149e-01
decl_stmt|,
comment|/* 3FD24924 94229359 */
name|Lp4
init|=
literal|2.222219843214978396e-01
decl_stmt|,
comment|/* 3FCC71C5 1D8E78AF */
name|Lp5
init|=
literal|1.818357216161805012e-01
decl_stmt|,
comment|/* 3FC74664 96CB03DE */
name|Lp6
init|=
literal|1.531383769920937332e-01
decl_stmt|,
comment|/* 3FC39A09 D078C69F */
name|Lp7
init|=
literal|1.479819860511658591e-01
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 3FC2F112 DF3E5244 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|double
name|zero
init|=
literal|0.0
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|double
name|zero
init|=
literal|0.0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_function
name|double
name|log1p
parameter_list|(
name|double
name|x
parameter_list|)
else|#
directive|else
function|double log1p
parameter_list|(
name|x
parameter_list|)
name|double
name|x
decl_stmt|;
endif|#
directive|endif
block|{
name|double
name|hfsq
decl_stmt|,
name|f
decl_stmt|,
name|c
decl_stmt|,
name|s
decl_stmt|,
name|z
decl_stmt|,
name|R
decl_stmt|,
name|u
decl_stmt|;
name|int32_t
name|k
decl_stmt|,
name|hx
decl_stmt|,
name|hu
decl_stmt|,
name|ax
decl_stmt|;
name|GET_HIGH_WORD
argument_list|(
name|hx
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|ax
operator|=
name|hx
operator|&
literal|0x7fffffff
expr_stmt|;
name|k
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|hx
operator|<
literal|0x3FDA827A
condition|)
block|{
comment|/* x< 0.41422  */
if|if
condition|(
name|ax
operator|>=
literal|0x3ff00000
condition|)
block|{
comment|/* x<= -1.0 */
if|if
condition|(
name|x
operator|==
operator|-
literal|1.0
condition|)
return|return
operator|-
name|two54
operator|/
name|zero
return|;
comment|/* log1p(-1)=+inf */
else|else
return|return
operator|(
name|x
operator|-
name|x
operator|)
operator|/
operator|(
name|x
operator|-
name|x
operator|)
return|;
comment|/* log1p(x<-1)=NaN */
block|}
if|if
condition|(
name|ax
operator|<
literal|0x3e200000
condition|)
block|{
comment|/* |x|< 2**-29 */
if|if
condition|(
name|two54
operator|+
name|x
operator|>
name|zero
comment|/* raise inexact */
operator|&&
name|ax
operator|<
literal|0x3c900000
condition|)
comment|/* |x|< 2**-54 */
return|return
name|x
return|;
else|else
return|return
name|x
operator|-
name|x
operator|*
name|x
operator|*
literal|0.5
return|;
block|}
if|if
condition|(
name|hx
operator|>
literal|0
operator|||
name|hx
operator|<=
operator|(
operator|(
name|int32_t
operator|)
literal|0xbfd2bec3
operator|)
condition|)
block|{
name|k
operator|=
literal|0
expr_stmt|;
name|f
operator|=
name|x
expr_stmt|;
name|hu
operator|=
literal|1
expr_stmt|;
block|}
comment|/* -0.2929<x<0.41422 */
block|}
if|if
condition|(
name|hx
operator|>=
literal|0x7ff00000
condition|)
return|return
name|x
operator|+
name|x
return|;
if|if
condition|(
name|k
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|hx
operator|<
literal|0x43400000
condition|)
block|{
name|u
operator|=
literal|1.0
operator|+
name|x
expr_stmt|;
name|GET_HIGH_WORD
argument_list|(
name|hu
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|k
operator|=
operator|(
name|hu
operator|>>
literal|20
operator|)
operator|-
literal|1023
expr_stmt|;
name|c
operator|=
operator|(
name|k
operator|>
literal|0
operator|)
condition|?
literal|1.0
operator|-
operator|(
name|u
operator|-
name|x
operator|)
else|:
name|x
operator|-
operator|(
name|u
operator|-
literal|1.0
operator|)
expr_stmt|;
comment|/* correction term */
name|c
operator|/=
name|u
expr_stmt|;
block|}
else|else
block|{
name|u
operator|=
name|x
expr_stmt|;
name|GET_HIGH_WORD
argument_list|(
name|hu
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|k
operator|=
operator|(
name|hu
operator|>>
literal|20
operator|)
operator|-
literal|1023
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
block|}
name|hu
operator|&=
literal|0x000fffff
expr_stmt|;
if|if
condition|(
name|hu
operator|<
literal|0x6a09e
condition|)
block|{
name|SET_HIGH_WORD
argument_list|(
name|u
argument_list|,
name|hu
operator||
literal|0x3ff00000
argument_list|)
expr_stmt|;
comment|/* normalize u */
block|}
else|else
block|{
name|k
operator|+=
literal|1
expr_stmt|;
name|SET_HIGH_WORD
argument_list|(
name|u
argument_list|,
name|hu
operator||
literal|0x3fe00000
argument_list|)
expr_stmt|;
comment|/* normalize u/2 */
name|hu
operator|=
operator|(
literal|0x00100000
operator|-
name|hu
operator|)
operator|>>
literal|2
expr_stmt|;
block|}
name|f
operator|=
name|u
operator|-
literal|1.0
expr_stmt|;
block|}
name|hfsq
operator|=
literal|0.5
operator|*
name|f
operator|*
name|f
expr_stmt|;
if|if
condition|(
name|hu
operator|==
literal|0
condition|)
block|{
comment|/* |f|< 2**-20 */
if|if
condition|(
name|f
operator|==
name|zero
condition|)
if|if
condition|(
name|k
operator|==
literal|0
condition|)
return|return
name|zero
return|;
else|else
block|{
name|c
operator|+=
name|k
operator|*
name|ln2_lo
expr_stmt|;
return|return
name|k
operator|*
name|ln2_hi
operator|+
name|c
return|;
block|}
name|R
operator|=
name|hfsq
operator|*
operator|(
literal|1.0
operator|-
literal|0.66666666666666666
operator|*
name|f
operator|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|0
condition|)
return|return
name|f
operator|-
name|R
return|;
else|else
return|return
name|k
operator|*
name|ln2_hi
operator|-
operator|(
operator|(
name|R
operator|-
operator|(
name|k
operator|*
name|ln2_lo
operator|+
name|c
operator|)
operator|)
operator|-
name|f
operator|)
return|;
block|}
name|s
operator|=
name|f
operator|/
operator|(
literal|2.0
operator|+
name|f
operator|)
expr_stmt|;
name|z
operator|=
name|s
operator|*
name|s
expr_stmt|;
name|R
operator|=
name|z
operator|*
operator|(
name|Lp1
operator|+
name|z
operator|*
operator|(
name|Lp2
operator|+
name|z
operator|*
operator|(
name|Lp3
operator|+
name|z
operator|*
operator|(
name|Lp4
operator|+
name|z
operator|*
operator|(
name|Lp5
operator|+
name|z
operator|*
operator|(
name|Lp6
operator|+
name|z
operator|*
name|Lp7
operator|)
operator|)
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|0
condition|)
return|return
name|f
operator|-
operator|(
name|hfsq
operator|-
name|s
operator|*
operator|(
name|hfsq
operator|+
name|R
operator|)
operator|)
return|;
else|else
return|return
name|k
operator|*
name|ln2_hi
operator|-
operator|(
operator|(
name|hfsq
operator|-
operator|(
name|s
operator|*
operator|(
name|hfsq
operator|+
name|R
operator|)
operator|+
operator|(
name|k
operator|*
name|ln2_lo
operator|+
name|c
operator|)
operator|)
operator|)
operator|-
name|f
operator|)
return|;
block|}
end_function

end_unit

