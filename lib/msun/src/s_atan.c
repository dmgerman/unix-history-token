begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* @(#)s_atan.c 5.1 93/09/24 */
end_comment

begin_comment
comment|/*  * ====================================================  * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.  *  * Developed at SunPro, a Sun Microsystems, Inc. business.  * Permission to use, copy, modify, and distribute this  * software is freely granted, provided that this notice  * is preserved.  * ====================================================  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* atan(x)  * Method  *   1. Reduce x to positive by atan(x) = -atan(-x).  *   2. According to the integer k=4t+0.25 chopped, t=x, the argument  *      is further reduced to one of the following intervals and the  *      arctangent of t is evaluated by the corresponding formula:  *  *      [0,7/16]      atan(x) = t-t^3*(a1+t^2*(a2+...(a10+t^2*a11)...)  *      [7/16,11/16]  atan(x) = atan(1/2) + atan( (t-0.5)/(1+t/2) )  *      [11/16.19/16] atan(x) = atan( 1 ) + atan( (t-1)/(1+t) )  *      [19/16,39/16] atan(x) = atan(3/2) + atan( (t-1.5)/(1+1.5t) )  *      [39/16,INF]   atan(x) = atan(INF) + atan( -1/t )  *  * Constants:  * The hexadecimal values are the intended ones for the following  * constants. The decimal values may be used, provided that the  * compiler will convert from decimal to binary accurately enough  * to produce the hexadecimal values shown.  */
end_comment

begin_include
include|#
directive|include
file|"math.h"
end_include

begin_include
include|#
directive|include
file|"math_private.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|double
name|atanhi
index|[]
init|=
block|{
else|#
directive|else
specifier|static
name|double
name|atanhi
index|[]
operator|=
block|{
endif|#
directive|endif
literal|4.63647609000806093515e-01
block|,
comment|/* atan(0.5)hi 0x3FDDAC67, 0x0561BB4F */
literal|7.85398163397448278999e-01
block|,
comment|/* atan(1.0)hi 0x3FE921FB, 0x54442D18 */
literal|9.82793723247329054082e-01
block|,
comment|/* atan(1.5)hi 0x3FEF730B, 0xD281F69B */
literal|1.57079632679489655800e+00
block|,
comment|/* atan(inf)hi 0x3FF921FB, 0x54442D18 */
block|}
block|;
ifdef|#
directive|ifdef
name|__STDC__
specifier|static
specifier|const
name|double
name|atanlo
index|[]
operator|=
block|{
else|#
directive|else
specifier|static
name|double
name|atanlo
index|[]
operator|=
block|{
endif|#
directive|endif
literal|2.26987774529616870924e-17
block|,
comment|/* atan(0.5)lo 0x3C7A2B7F, 0x222F65E2 */
literal|3.06161699786838301793e-17
block|,
comment|/* atan(1.0)lo 0x3C81A626, 0x33145C07 */
literal|1.39033110312309984516e-17
block|,
comment|/* atan(1.5)lo 0x3C700788, 0x7AF0CBBD */
literal|6.12323399573676603587e-17
block|,
comment|/* atan(inf)lo 0x3C91A626, 0x33145C07 */
block|}
block|;
ifdef|#
directive|ifdef
name|__STDC__
specifier|static
specifier|const
name|double
name|aT
index|[]
operator|=
block|{
else|#
directive|else
specifier|static
name|double
name|aT
index|[]
operator|=
block|{
endif|#
directive|endif
literal|3.33333333333329318027e-01
block|,
comment|/* 0x3FD55555, 0x5555550D */
operator|-
literal|1.99999999998764832476e-01
block|,
comment|/* 0xBFC99999, 0x9998EBC4 */
literal|1.42857142725034663711e-01
block|,
comment|/* 0x3FC24924, 0x920083FF */
operator|-
literal|1.11111104054623557880e-01
block|,
comment|/* 0xBFBC71C6, 0xFE231671 */
literal|9.09088713343650656196e-02
block|,
comment|/* 0x3FB745CD, 0xC54C206E */
operator|-
literal|7.69187620504482999495e-02
block|,
comment|/* 0xBFB3B0F2, 0xAF749A6D */
literal|6.66107313738753120669e-02
block|,
comment|/* 0x3FB10D66, 0xA0D03D51 */
operator|-
literal|5.83357013379057348645e-02
block|,
comment|/* 0xBFADDE2D, 0x52DEFD9A */
literal|4.97687799461593236017e-02
block|,
comment|/* 0x3FA97B4B, 0x24760DEB */
operator|-
literal|3.65315727442169155270e-02
block|,
comment|/* 0xBFA2B444, 0x2C6A6C2F */
literal|1.62858201153657823623e-02
block|,
comment|/* 0x3F90AD3A, 0xE322DA11 */
block|}
block|;
ifdef|#
directive|ifdef
name|__STDC__
specifier|static
specifier|const
name|double
else|#
directive|else
specifier|static
name|double
endif|#
directive|endif
name|one
operator|=
literal|1.0
block|,
name|huge
operator|=
literal|1.0e300
block|;
ifdef|#
directive|ifdef
name|__STDC__
name|double
name|__generic_atan
argument_list|(
argument|double x
argument_list|)
else|#
directive|else
name|double
name|__generic_atan
argument_list|(
argument|x
argument_list|)
name|double
name|x
block|;
endif|#
directive|endif
block|{
name|double
name|w
block|,
name|s1
block|,
name|s2
block|,
name|z
block|;
name|int32_t
name|ix
block|,
name|hx
block|,
name|id
block|;
name|GET_HIGH_WORD
argument_list|(
name|hx
argument_list|,
name|x
argument_list|)
block|;
name|ix
operator|=
name|hx
operator|&
literal|0x7fffffff
block|;
if|if
condition|(
name|ix
operator|>=
literal|0x44100000
condition|)
block|{
comment|/* if |x|>= 2^66 */
name|u_int32_t
name|low
decl_stmt|;
name|GET_LOW_WORD
argument_list|(
name|low
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|ix
operator|>
literal|0x7ff00000
operator|||
operator|(
name|ix
operator|==
literal|0x7ff00000
operator|&&
operator|(
name|low
operator|!=
literal|0
operator|)
operator|)
condition|)
return|return
name|x
operator|+
name|x
return|;
comment|/* NaN */
if|if
condition|(
name|hx
operator|>
literal|0
condition|)
return|return
name|atanhi
index|[
literal|3
index|]
operator|+
name|atanlo
index|[
literal|3
index|]
return|;
else|else
return|return
operator|-
name|atanhi
index|[
literal|3
index|]
operator|-
name|atanlo
index|[
literal|3
index|]
return|;
block|}
if|if
condition|(
name|ix
operator|<
literal|0x3fdc0000
condition|)
block|{
comment|/* |x|< 0.4375 */
if|if
condition|(
name|ix
operator|<
literal|0x3e200000
condition|)
block|{
comment|/* |x|< 2^-29 */
if|if
condition|(
name|huge
operator|+
name|x
operator|>
name|one
condition|)
return|return
name|x
return|;
comment|/* raise inexact */
block|}
name|id
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
name|fabs
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|ix
operator|<
literal|0x3ff30000
condition|)
block|{
comment|/* |x|< 1.1875 */
if|if
condition|(
name|ix
operator|<
literal|0x3fe60000
condition|)
block|{
comment|/* 7/16<=|x|<11/16 */
name|id
operator|=
literal|0
expr_stmt|;
name|x
operator|=
operator|(
literal|2.0
operator|*
name|x
operator|-
name|one
operator|)
operator|/
operator|(
literal|2.0
operator|+
name|x
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 11/16<=|x|< 19/16 */
name|id
operator|=
literal|1
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|-
name|one
operator|)
operator|/
operator|(
name|x
operator|+
name|one
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ix
operator|<
literal|0x40038000
condition|)
block|{
comment|/* |x|< 2.4375 */
name|id
operator|=
literal|2
expr_stmt|;
name|x
operator|=
operator|(
name|x
operator|-
literal|1.5
operator|)
operator|/
operator|(
name|one
operator|+
literal|1.5
operator|*
name|x
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 2.4375<= |x|< 2^66 */
name|id
operator|=
literal|3
expr_stmt|;
name|x
operator|=
operator|-
literal|1.0
operator|/
name|x
expr_stmt|;
block|}
block|}
block|}
comment|/* end of argument reduction */
name|z
operator|=
name|x
operator|*
name|x
expr_stmt|;
name|w
operator|=
name|z
operator|*
name|z
block|;
comment|/* break sum from i=0 to 10 aT[i]z**(i+1) into odd and even poly */
name|s1
operator|=
name|z
operator|*
operator|(
name|aT
index|[
literal|0
index|]
operator|+
name|w
operator|*
operator|(
name|aT
index|[
literal|2
index|]
operator|+
name|w
operator|*
operator|(
name|aT
index|[
literal|4
index|]
operator|+
name|w
operator|*
operator|(
name|aT
index|[
literal|6
index|]
operator|+
name|w
operator|*
operator|(
name|aT
index|[
literal|8
index|]
operator|+
name|w
operator|*
name|aT
index|[
literal|10
index|]
operator|)
operator|)
operator|)
operator|)
operator|)
block|;
name|s2
operator|=
name|w
operator|*
operator|(
name|aT
index|[
literal|1
index|]
operator|+
name|w
operator|*
operator|(
name|aT
index|[
literal|3
index|]
operator|+
name|w
operator|*
operator|(
name|aT
index|[
literal|5
index|]
operator|+
name|w
operator|*
operator|(
name|aT
index|[
literal|7
index|]
operator|+
name|w
operator|*
name|aT
index|[
literal|9
index|]
operator|)
operator|)
operator|)
operator|)
block|;
if|if
condition|(
name|id
operator|<
literal|0
condition|)
return|return
name|x
operator|-
name|x
operator|*
operator|(
name|s1
operator|+
name|s2
operator|)
return|;
else|else
block|{
name|z
operator|=
name|atanhi
index|[
name|id
index|]
operator|-
operator|(
operator|(
name|x
operator|*
operator|(
name|s1
operator|+
name|s2
operator|)
operator|-
name|atanlo
index|[
name|id
index|]
operator|)
operator|-
name|x
operator|)
expr_stmt|;
return|return
operator|(
name|hx
operator|<
literal|0
operator|)
condition|?
operator|-
name|z
else|:
name|z
return|;
block|}
block|}
end_decl_stmt

end_unit

