begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* k_rem_pio2f.c -- float version of k_rem_pio2.c  * Conversion to float by Ian Lance Taylor, Cygnus Support, ian@cygnus.com.  */
end_comment

begin_comment
comment|/*  * ====================================================  * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.  *  * Developed at SunPro, a Sun Microsystems, Inc. business.  * Permission to use, copy, modify, and distribute this  * software is freely granted, provided that this notice  * is preserved.  * ====================================================  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"math.h"
end_include

begin_include
include|#
directive|include
file|"math_private.h"
end_include

begin_comment
comment|/* In the float version, the input parameter x contains 8 bit    integers, not 24 bit integers.  113 bit precision is not supported.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|int
name|init_jk
index|[]
init|=
block|{
literal|4
block|,
literal|7
block|,
literal|9
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* initial value for jk */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|int
name|init_jk
index|[]
init|=
block|{
literal|4
block|,
literal|7
block|,
literal|9
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|float
name|PIo2
index|[]
init|=
block|{
else|#
directive|else
specifier|static
name|float
name|PIo2
index|[]
operator|=
block|{
endif|#
directive|endif
literal|1.5703125000e+00
block|,
comment|/* 0x3fc90000 */
literal|4.5776367188e-04
block|,
comment|/* 0x39f00000 */
literal|2.5987625122e-05
block|,
comment|/* 0x37da0000 */
literal|7.5437128544e-08
block|,
comment|/* 0x33a20000 */
literal|6.0026650317e-11
block|,
comment|/* 0x2e840000 */
literal|7.3896444519e-13
block|,
comment|/* 0x2b500000 */
literal|5.3845816694e-15
block|,
comment|/* 0x27c20000 */
literal|5.6378512969e-18
block|,
comment|/* 0x22d00000 */
literal|8.3009228831e-20
block|,
comment|/* 0x1fc40000 */
literal|3.2756352257e-22
block|,
comment|/* 0x1bc60000 */
literal|6.3331015649e-25
block|,
comment|/* 0x17440000 */
block|}
block|;
ifdef|#
directive|ifdef
name|__STDC__
specifier|static
specifier|const
name|float
else|#
directive|else
specifier|static
name|float
endif|#
directive|endif
name|zero
operator|=
literal|0.0
block|,
name|one
operator|=
literal|1.0
block|,
name|two8
operator|=
literal|2.5600000000e+02
block|,
comment|/* 0x43800000 */
name|twon8
operator|=
literal|3.9062500000e-03
block|;
comment|/* 0x3b800000 */
ifdef|#
directive|ifdef
name|__STDC__
name|int
name|__kernel_rem_pio2f
argument_list|(
argument|float *x
argument_list|,
argument|float *y
argument_list|,
argument|int e0
argument_list|,
argument|int nx
argument_list|,
argument|int prec
argument_list|,
argument|const int32_t *ipio2
argument_list|)
else|#
directive|else
name|int
name|__kernel_rem_pio2f
argument_list|(
argument|x
argument_list|,
argument|y
argument_list|,
argument|e0
argument_list|,
argument|nx
argument_list|,
argument|prec
argument_list|,
argument|ipio2
argument_list|)
name|float
name|x
index|[]
block|,
name|y
index|[]
block|;
name|int
name|e0
block|,
name|nx
block|,
name|prec
block|;
name|int32_t
name|ipio2
index|[]
block|;
endif|#
directive|endif
block|{
name|int32_t
name|jz
block|,
name|jx
block|,
name|jv
block|,
name|jp
block|,
name|jk
block|,
name|carry
block|,
name|n
block|,
name|iq
index|[
literal|20
index|]
block|,
name|i
block|,
name|j
block|,
name|k
block|,
name|m
block|,
name|q0
block|,
name|ih
block|;
name|float
name|z
block|,
name|fw
block|,
name|f
index|[
literal|20
index|]
block|,
name|fq
index|[
literal|20
index|]
block|,
name|q
index|[
literal|20
index|]
block|;
comment|/* initialize jk*/
name|jk
operator|=
name|init_jk
index|[
name|prec
index|]
block|;
name|jp
operator|=
name|jk
block|;
comment|/* determine jx,jv,q0, note that 3>q0 */
name|jx
operator|=
name|nx
operator|-
literal|1
block|;
name|jv
operator|=
operator|(
name|e0
operator|-
literal|3
operator|)
operator|/
literal|8
block|;
if|if
condition|(
name|jv
operator|<
literal|0
condition|)
name|jv
operator|=
literal|0
expr_stmt|;
name|q0
operator|=
name|e0
operator|-
literal|8
operator|*
operator|(
name|jv
operator|+
literal|1
operator|)
block|;
comment|/* set up f[0] to f[jx+jk] where f[jx+jk] = ipio2[jv+jk] */
name|j
operator|=
name|jv
operator|-
name|jx
block|;
name|m
operator|=
name|jx
operator|+
name|jk
block|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|m
condition|;
name|i
operator|++
incr|,
name|j
operator|++
control|)
name|f
index|[
name|i
index|]
operator|=
operator|(
name|j
operator|<
literal|0
operator|)
condition|?
name|zero
else|:
operator|(
name|float
operator|)
name|ipio2
index|[
name|j
index|]
expr_stmt|;
end_decl_stmt

begin_comment
comment|/* compute q[0],q[1],...q[jk] */
end_comment

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|jk
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|fw
operator|=
literal|0.0
init|;
name|j
operator|<=
name|jx
condition|;
name|j
operator|++
control|)
name|fw
operator|+=
name|x
index|[
name|j
index|]
operator|*
name|f
index|[
name|jx
operator|+
name|i
operator|-
name|j
index|]
expr_stmt|;
name|q
index|[
name|i
index|]
operator|=
name|fw
expr_stmt|;
block|}
end_for

begin_expr_stmt
name|jz
operator|=
name|jk
expr_stmt|;
end_expr_stmt

begin_label
name|recompute
label|:
end_label

begin_comment
comment|/* distill q[] into iq[] reversingly */
end_comment

begin_for
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
name|jz
operator|,
name|z
operator|=
name|q
index|[
name|jz
index|]
init|;
name|j
operator|>
literal|0
condition|;
name|i
operator|++
operator|,
name|j
operator|--
control|)
block|{
name|fw
operator|=
call|(
name|float
call|)
argument_list|(
call|(
name|int32_t
call|)
argument_list|(
name|twon8
operator|*
name|z
argument_list|)
argument_list|)
expr_stmt|;
name|iq
index|[
name|i
index|]
operator|=
call|(
name|int32_t
call|)
argument_list|(
name|z
operator|-
name|two8
operator|*
name|fw
argument_list|)
expr_stmt|;
name|z
operator|=
name|q
index|[
name|j
operator|-
literal|1
index|]
operator|+
name|fw
expr_stmt|;
block|}
end_for

begin_comment
comment|/* compute n */
end_comment

begin_expr_stmt
name|z
operator|=
name|scalbnf
argument_list|(
name|z
argument_list|,
name|q0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* actual value of z */
end_comment

begin_expr_stmt
name|z
operator|-=
operator|(
name|float
operator|)
literal|8.0
operator|*
name|floorf
argument_list|(
name|z
operator|*
operator|(
name|float
operator|)
literal|0.125
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* trim off integer>= 8 */
end_comment

begin_expr_stmt
name|n
operator|=
operator|(
name|int32_t
operator|)
name|z
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|z
operator|-=
operator|(
name|float
operator|)
name|n
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ih
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|q0
operator|>
literal|0
condition|)
block|{
comment|/* need iq[jz-1] to determine n */
name|i
operator|=
operator|(
name|iq
index|[
name|jz
operator|-
literal|1
index|]
operator|>>
operator|(
literal|8
operator|-
name|q0
operator|)
operator|)
expr_stmt|;
name|n
operator|+=
name|i
expr_stmt|;
name|iq
index|[
name|jz
operator|-
literal|1
index|]
operator|-=
name|i
operator|<<
operator|(
literal|8
operator|-
name|q0
operator|)
expr_stmt|;
name|ih
operator|=
name|iq
index|[
name|jz
operator|-
literal|1
index|]
operator|>>
operator|(
literal|7
operator|-
name|q0
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|q0
operator|==
literal|0
condition|)
name|ih
operator|=
name|iq
index|[
name|jz
operator|-
literal|1
index|]
operator|>>
literal|8
expr_stmt|;
elseif|else
if|if
condition|(
name|z
operator|>=
operator|(
name|float
operator|)
literal|0.5
condition|)
name|ih
operator|=
literal|2
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|ih
operator|>
literal|0
condition|)
block|{
comment|/* q> 0.5 */
name|n
operator|+=
literal|1
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|jz
condition|;
name|i
operator|++
control|)
block|{
comment|/* compute 1-q */
name|j
operator|=
name|iq
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|carry
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|j
operator|!=
literal|0
condition|)
block|{
name|carry
operator|=
literal|1
expr_stmt|;
name|iq
index|[
name|i
index|]
operator|=
literal|0x100
operator|-
name|j
expr_stmt|;
block|}
block|}
else|else
name|iq
index|[
name|i
index|]
operator|=
literal|0xff
operator|-
name|j
expr_stmt|;
block|}
if|if
condition|(
name|q0
operator|>
literal|0
condition|)
block|{
comment|/* rare case: chance is 1 in 12 */
switch|switch
condition|(
name|q0
condition|)
block|{
case|case
literal|1
case|:
name|iq
index|[
name|jz
operator|-
literal|1
index|]
operator|&=
literal|0x7f
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|iq
index|[
name|jz
operator|-
literal|1
index|]
operator|&=
literal|0x3f
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|ih
operator|==
literal|2
condition|)
block|{
name|z
operator|=
name|one
operator|-
name|z
expr_stmt|;
if|if
condition|(
name|carry
operator|!=
literal|0
condition|)
name|z
operator|-=
name|scalbnf
argument_list|(
name|one
argument_list|,
name|q0
argument_list|)
expr_stmt|;
block|}
block|}
end_if

begin_comment
comment|/* check if recomputation is needed */
end_comment

begin_if
if|if
condition|(
name|z
operator|==
name|zero
condition|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|jz
operator|-
literal|1
init|;
name|i
operator|>=
name|jk
condition|;
name|i
operator|--
control|)
name|j
operator||=
name|iq
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|0
condition|)
block|{
comment|/* need recomputation */
for|for
control|(
name|k
operator|=
literal|1
init|;
name|iq
index|[
name|jk
operator|-
name|k
index|]
operator|==
literal|0
condition|;
name|k
operator|++
control|)
empty_stmt|;
comment|/* k = no. of terms needed */
for|for
control|(
name|i
operator|=
name|jz
operator|+
literal|1
init|;
name|i
operator|<=
name|jz
operator|+
name|k
condition|;
name|i
operator|++
control|)
block|{
comment|/* add q[jz+1] to q[jz+k] */
name|f
index|[
name|jx
operator|+
name|i
index|]
operator|=
operator|(
name|float
operator|)
name|ipio2
index|[
name|jv
operator|+
name|i
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|fw
operator|=
literal|0.0
init|;
name|j
operator|<=
name|jx
condition|;
name|j
operator|++
control|)
name|fw
operator|+=
name|x
index|[
name|j
index|]
operator|*
name|f
index|[
name|jx
operator|+
name|i
operator|-
name|j
index|]
expr_stmt|;
name|q
index|[
name|i
index|]
operator|=
name|fw
expr_stmt|;
block|}
name|jz
operator|+=
name|k
expr_stmt|;
goto|goto
name|recompute
goto|;
block|}
block|}
end_if

begin_comment
comment|/* chop off zero terms */
end_comment

begin_if
if|if
condition|(
name|z
operator|==
operator|(
name|float
operator|)
literal|0.0
condition|)
block|{
name|jz
operator|-=
literal|1
expr_stmt|;
name|q0
operator|-=
literal|8
expr_stmt|;
while|while
condition|(
name|iq
index|[
name|jz
index|]
operator|==
literal|0
condition|)
block|{
name|jz
operator|--
expr_stmt|;
name|q0
operator|-=
literal|8
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* break z into 8-bit if necessary */
name|z
operator|=
name|scalbnf
argument_list|(
name|z
argument_list|,
operator|-
name|q0
argument_list|)
expr_stmt|;
if|if
condition|(
name|z
operator|>=
name|two8
condition|)
block|{
name|fw
operator|=
call|(
name|float
call|)
argument_list|(
call|(
name|int32_t
call|)
argument_list|(
name|twon8
operator|*
name|z
argument_list|)
argument_list|)
expr_stmt|;
name|iq
index|[
name|jz
index|]
operator|=
call|(
name|int32_t
call|)
argument_list|(
name|z
operator|-
name|two8
operator|*
name|fw
argument_list|)
expr_stmt|;
name|jz
operator|+=
literal|1
expr_stmt|;
name|q0
operator|+=
literal|8
expr_stmt|;
name|iq
index|[
name|jz
index|]
operator|=
operator|(
name|int32_t
operator|)
name|fw
expr_stmt|;
block|}
else|else
name|iq
index|[
name|jz
index|]
operator|=
operator|(
name|int32_t
operator|)
name|z
expr_stmt|;
block|}
end_if

begin_comment
comment|/* convert integer "bit" chunk to floating-point value */
end_comment

begin_expr_stmt
name|fw
operator|=
name|scalbnf
argument_list|(
name|one
argument_list|,
name|q0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
name|jz
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|q
index|[
name|i
index|]
operator|=
name|fw
operator|*
operator|(
name|float
operator|)
name|iq
index|[
name|i
index|]
expr_stmt|;
name|fw
operator|*=
name|twon8
expr_stmt|;
block|}
end_for

begin_comment
comment|/* compute PIo2[0,...,jp]*q[jz,...,0] */
end_comment

begin_for
for|for
control|(
name|i
operator|=
name|jz
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
for|for
control|(
name|fw
operator|=
literal|0.0
operator|,
name|k
operator|=
literal|0
init|;
name|k
operator|<=
name|jp
operator|&&
name|k
operator|<=
name|jz
operator|-
name|i
condition|;
name|k
operator|++
control|)
name|fw
operator|+=
name|PIo2
index|[
name|k
index|]
operator|*
name|q
index|[
name|i
operator|+
name|k
index|]
expr_stmt|;
name|fq
index|[
name|jz
operator|-
name|i
index|]
operator|=
name|fw
expr_stmt|;
block|}
end_for

begin_comment
comment|/* compress fq[] into y[] */
end_comment

begin_switch
switch|switch
condition|(
name|prec
condition|)
block|{
case|case
literal|0
case|:
name|fw
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|jz
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|fw
operator|+=
name|fq
index|[
name|i
index|]
expr_stmt|;
name|y
index|[
literal|0
index|]
operator|=
operator|(
name|ih
operator|==
literal|0
operator|)
condition|?
name|fw
else|:
operator|-
name|fw
expr_stmt|;
break|break;
case|case
literal|1
case|:
case|case
literal|2
case|:
name|fw
operator|=
literal|0.0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|jz
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|fw
operator|+=
name|fq
index|[
name|i
index|]
expr_stmt|;
name|y
index|[
literal|0
index|]
operator|=
operator|(
name|ih
operator|==
literal|0
operator|)
condition|?
name|fw
else|:
operator|-
name|fw
expr_stmt|;
name|fw
operator|=
name|fq
index|[
literal|0
index|]
operator|-
name|fw
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|jz
condition|;
name|i
operator|++
control|)
name|fw
operator|+=
name|fq
index|[
name|i
index|]
expr_stmt|;
name|y
index|[
literal|1
index|]
operator|=
operator|(
name|ih
operator|==
literal|0
operator|)
condition|?
name|fw
else|:
operator|-
name|fw
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* painful */
for|for
control|(
name|i
operator|=
name|jz
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|fw
operator|=
name|fq
index|[
name|i
operator|-
literal|1
index|]
operator|+
name|fq
index|[
name|i
index|]
expr_stmt|;
name|fq
index|[
name|i
index|]
operator|+=
name|fq
index|[
name|i
operator|-
literal|1
index|]
operator|-
name|fw
expr_stmt|;
name|fq
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|fw
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|jz
init|;
name|i
operator|>
literal|1
condition|;
name|i
operator|--
control|)
block|{
name|fw
operator|=
name|fq
index|[
name|i
operator|-
literal|1
index|]
operator|+
name|fq
index|[
name|i
index|]
expr_stmt|;
name|fq
index|[
name|i
index|]
operator|+=
name|fq
index|[
name|i
operator|-
literal|1
index|]
operator|-
name|fw
expr_stmt|;
name|fq
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|fw
expr_stmt|;
block|}
for|for
control|(
name|fw
operator|=
literal|0.0
operator|,
name|i
operator|=
name|jz
init|;
name|i
operator|>=
literal|2
condition|;
name|i
operator|--
control|)
name|fw
operator|+=
name|fq
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ih
operator|==
literal|0
condition|)
block|{
name|y
index|[
literal|0
index|]
operator|=
name|fq
index|[
literal|0
index|]
expr_stmt|;
name|y
index|[
literal|1
index|]
operator|=
name|fq
index|[
literal|1
index|]
expr_stmt|;
name|y
index|[
literal|2
index|]
operator|=
name|fw
expr_stmt|;
block|}
else|else
block|{
name|y
index|[
literal|0
index|]
operator|=
operator|-
name|fq
index|[
literal|0
index|]
expr_stmt|;
name|y
index|[
literal|1
index|]
operator|=
operator|-
name|fq
index|[
literal|1
index|]
expr_stmt|;
name|y
index|[
literal|2
index|]
operator|=
operator|-
name|fw
expr_stmt|;
block|}
block|}
end_switch

begin_return
return|return
name|n
operator|&
literal|7
return|;
end_return

unit|}
end_unit

