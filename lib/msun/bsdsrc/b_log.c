begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)log.c	8.2 (Berkeley) 11/30/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"mathimpl.h"
end_include

begin_comment
comment|/* Table-driven natural logarithm.  *  * This code was derived, with minor modifications, from:  *	Peter Tang, "Table-Driven Implementation of the  *	Logarithm in IEEE Floating-Point arithmetic." ACM Trans.  *	Math Software, vol 16. no 4, pp 378-400, Dec 1990).  *  * Calculates log(2^m*F*(1+f/F)), |f/j|<= 1/256,  * where F = j/128 for j an integer in [0, 128].  *  * log(2^m) = log2_hi*m + log2_tail*m  * since m is an integer, the dominant term is exact.  * m has at most 10 digits (for subnormal numbers),  * and log2_hi has 11 trailing zero bits.  *  * log(F) = logF_hi[j] + logF_lo[j] is in tabular form in log_table.h  * logF_hi[] + 512 is exact.  *  * log(1+f/F) = 2*f/(2*F + f) + 1/12 * (2*f/(2*F + f))**3 + ...  * the leading term is calculated to extra precision in two  * parts, the larger of which adds exactly to the dominant  * m and F terms.  * There are two cases:  *	1. when m, j are non-zero (m | j), use absolute  *	   precision for the leading term.  *	2. when m = j = 0, |1-x|< 1/256, and log(x) ~= (x-1).  *	   In this case, use a relative precision of 24 bits.  * (This is done differently in the original paper)  *  * Special cases:  *	0	return signalling -Inf  *	neg	return signalling NaN  *	+Inf	return +Inf */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
operator|||
name|defined
argument_list|(
name|tahoe
argument_list|)
end_if

begin_define
define|#
directive|define
name|_IEEE
value|0
end_define

begin_define
define|#
directive|define
name|TRUNC
parameter_list|(
name|x
parameter_list|)
value|x = (double) (float) (x)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|_IEEE
value|1
end_define

begin_define
define|#
directive|define
name|endian
value|(((*(int *)&one)) ? 1 : 0)
end_define

begin_define
define|#
directive|define
name|TRUNC
parameter_list|(
name|x
parameter_list|)
value|*(((int *)&x) + endian)&= 0xf8000000
end_define

begin_define
define|#
directive|define
name|infnan
parameter_list|(
name|x
parameter_list|)
value|0.0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|N
value|128
end_define

begin_comment
comment|/* Table of log(Fj) = logF_head[j] + logF_tail[j], for Fj = 1+j/128.  * Used for generation of extend precision logarithms.  * The constant 35184372088832 is 2^45, so the divide is exact.  * It ensures correct reading of logF_head, even for inaccurate  * decimal-to-binary conversion routines.  (Everybody gets the  * right answer for integers less than 2^53.)  * Values for log(F) were generated using error< 10^-57 absolute  * with the bc -l package. */
end_comment

begin_decl_stmt
specifier|static
name|double
name|A1
init|=
literal|.08333333333333178827
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|A2
init|=
literal|.01250000000377174923
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|A3
init|=
literal|.002232139987919447809
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|A4
init|=
literal|.0004348877777076145742
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|logF_head
index|[
name|N
operator|+
literal|1
index|]
init|=
block|{
literal|0.
block|,
literal|.007782140442060381246
block|,
literal|.015504186535963526694
block|,
literal|.023167059281547608406
block|,
literal|.030771658666765233647
block|,
literal|.038318864302141264488
block|,
literal|.045809536031242714670
block|,
literal|.053244514518837604555
block|,
literal|.060624621816486978786
block|,
literal|.067950661908525944454
block|,
literal|.075223421237524235039
block|,
literal|.082443669210988446138
block|,
literal|.089612158689760690322
block|,
literal|.096729626458454731618
block|,
literal|.103796793681567578460
block|,
literal|.110814366340264314203
block|,
literal|.117783035656430001836
block|,
literal|.124703478501032805070
block|,
literal|.131576357788617315236
block|,
literal|.138402322859292326029
block|,
literal|.145182009844575077295
block|,
literal|.151916042025732167530
block|,
literal|.158605030176659056451
block|,
literal|.165249572895390883786
block|,
literal|.171850256926518341060
block|,
literal|.178407657472689606947
block|,
literal|.184922338493834104156
block|,
literal|.191394852999565046047
block|,
literal|.197825743329758552135
block|,
literal|.204215541428766300668
block|,
literal|.210564769107350002741
block|,
literal|.216873938300523150246
block|,
literal|.223143551314024080056
block|,
literal|.229374101064877322642
block|,
literal|.235566071312860003672
block|,
literal|.241719936886966024758
block|,
literal|.247836163904594286577
block|,
literal|.253915209980732470285
block|,
literal|.259957524436686071567
block|,
literal|.265963548496984003577
block|,
literal|.271933715484010463114
block|,
literal|.277868451003087102435
block|,
literal|.283768173130738432519
block|,
literal|.289633292582948342896
block|,
literal|.295464212893421063199
block|,
literal|.301261330578199704177
block|,
literal|.307025035294827830512
block|,
literal|.312755710004239517729
block|,
literal|.318453731118097493890
block|,
literal|.324119468654316733591
block|,
literal|.329753286372579168528
block|,
literal|.335355541920762334484
block|,
literal|.340926586970454081892
block|,
literal|.346466767346100823488
block|,
literal|.351976423156884266063
block|,
literal|.357455888922231679316
block|,
literal|.362905493689140712376
block|,
literal|.368325561158599157352
block|,
literal|.373716409793814818840
block|,
literal|.379078352934811846353
block|,
literal|.384411698910298582632
block|,
literal|.389716751140440464951
block|,
literal|.394993808240542421117
block|,
literal|.400243164127459749579
block|,
literal|.405465108107819105498
block|,
literal|.410659924985338875558
block|,
literal|.415827895143593195825
block|,
literal|.420969294644237379543
block|,
literal|.426084395310681429691
block|,
literal|.431173464818130014464
block|,
literal|.436236766774527495726
block|,
literal|.441274560805140936281
block|,
literal|.446287102628048160113
block|,
literal|.451274644139630254358
block|,
literal|.456237433481874177232
block|,
literal|.461175715122408291790
block|,
literal|.466089729924533457960
block|,
literal|.470979715219073113985
block|,
literal|.475845904869856894947
block|,
literal|.480688529345570714212
block|,
literal|.485507815781602403149
block|,
literal|.490303988045525329653
block|,
literal|.495077266798034543171
block|,
literal|.499827869556611403822
block|,
literal|.504556010751912253908
block|,
literal|.509261901790523552335
block|,
literal|.513945751101346104405
block|,
literal|.518607764208354637958
block|,
literal|.523248143765158602036
block|,
literal|.527867089620485785417
block|,
literal|.532464798869114019908
block|,
literal|.537041465897345915436
block|,
literal|.541597282432121573947
block|,
literal|.546132437597407260909
block|,
literal|.550647117952394182793
block|,
literal|.555141507540611200965
block|,
literal|.559615787935399566777
block|,
literal|.564070138285387656651
block|,
literal|.568504735352689749561
block|,
literal|.572919753562018740922
block|,
literal|.577315365035246941260
block|,
literal|.581691739635061821900
block|,
literal|.586049045003164792433
block|,
literal|.590387446602107957005
block|,
literal|.594707107746216934174
block|,
literal|.599008189645246602594
block|,
literal|.603290851438941899687
block|,
literal|.607555250224322662688
block|,
literal|.611801541106615331955
block|,
literal|.616029877215623855590
block|,
literal|.620240409751204424537
block|,
literal|.624433288012369303032
block|,
literal|.628608659422752680256
block|,
literal|.632766669570628437213
block|,
literal|.636907462236194987781
block|,
literal|.641031179420679109171
block|,
literal|.645137961373620782978
block|,
literal|.649227946625615004450
block|,
literal|.653301272011958644725
block|,
literal|.657358072709030238911
block|,
literal|.661398482245203922502
block|,
literal|.665422632544505177065
block|,
literal|.669430653942981734871
block|,
literal|.673422675212350441142
block|,
literal|.677398823590920073911
block|,
literal|.681359224807238206267
block|,
literal|.685304003098281100392
block|,
literal|.689233281238557538017
block|,
literal|.693147180560117703862
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|logF_tail
index|[
name|N
operator|+
literal|1
index|]
init|=
block|{
literal|0.
block|,
operator|-
literal|.00000000000000543229938420049
block|,
literal|.00000000000000172745674997061
block|,
operator|-
literal|.00000000000001323017818229233
block|,
operator|-
literal|.00000000000001154527628289872
block|,
operator|-
literal|.00000000000000466529469958300
block|,
literal|.00000000000005148849572685810
block|,
operator|-
literal|.00000000000002532168943117445
block|,
operator|-
literal|.00000000000005213620639136504
block|,
operator|-
literal|.00000000000001819506003016881
block|,
literal|.00000000000006329065958724544
block|,
literal|.00000000000008614512936087814
block|,
operator|-
literal|.00000000000007355770219435028
block|,
literal|.00000000000009638067658552277
block|,
literal|.00000000000007598636597194141
block|,
literal|.00000000000002579999128306990
block|,
operator|-
literal|.00000000000004654729747598444
block|,
operator|-
literal|.00000000000007556920687451336
block|,
literal|.00000000000010195735223708472
block|,
operator|-
literal|.00000000000017319034406422306
block|,
operator|-
literal|.00000000000007718001336828098
block|,
literal|.00000000000010980754099855238
block|,
operator|-
literal|.00000000000002047235780046195
block|,
operator|-
literal|.00000000000008372091099235912
block|,
literal|.00000000000014088127937111135
block|,
literal|.00000000000012869017157588257
block|,
literal|.00000000000017788850778198106
block|,
literal|.00000000000006440856150696891
block|,
literal|.00000000000016132822667240822
block|,
operator|-
literal|.00000000000007540916511956188
block|,
operator|-
literal|.00000000000000036507188831790
block|,
literal|.00000000000009120937249914984
block|,
literal|.00000000000018567570959796010
block|,
operator|-
literal|.00000000000003149265065191483
block|,
operator|-
literal|.00000000000009309459495196889
block|,
literal|.00000000000017914338601329117
block|,
operator|-
literal|.00000000000001302979717330866
block|,
literal|.00000000000023097385217586939
block|,
literal|.00000000000023999540484211737
block|,
literal|.00000000000015393776174455408
block|,
operator|-
literal|.00000000000036870428315837678
block|,
literal|.00000000000036920375082080089
block|,
operator|-
literal|.00000000000009383417223663699
block|,
literal|.00000000000009433398189512690
block|,
literal|.00000000000041481318704258568
block|,
operator|-
literal|.00000000000003792316480209314
block|,
literal|.00000000000008403156304792424
block|,
operator|-
literal|.00000000000034262934348285429
block|,
literal|.00000000000043712191957429145
block|,
operator|-
literal|.00000000000010475750058776541
block|,
operator|-
literal|.00000000000011118671389559323
block|,
literal|.00000000000037549577257259853
block|,
literal|.00000000000013912841212197565
block|,
literal|.00000000000010775743037572640
block|,
literal|.00000000000029391859187648000
block|,
operator|-
literal|.00000000000042790509060060774
block|,
literal|.00000000000022774076114039555
block|,
literal|.00000000000010849569622967912
block|,
operator|-
literal|.00000000000023073801945705758
block|,
literal|.00000000000015761203773969435
block|,
literal|.00000000000003345710269544082
block|,
operator|-
literal|.00000000000041525158063436123
block|,
literal|.00000000000032655698896907146
block|,
operator|-
literal|.00000000000044704265010452446
block|,
literal|.00000000000034527647952039772
block|,
operator|-
literal|.00000000000007048962392109746
block|,
literal|.00000000000011776978751369214
block|,
operator|-
literal|.00000000000010774341461609578
block|,
literal|.00000000000021863343293215910
block|,
literal|.00000000000024132639491333131
block|,
literal|.00000000000039057462209830700
block|,
operator|-
literal|.00000000000026570679203560751
block|,
literal|.00000000000037135141919592021
block|,
operator|-
literal|.00000000000017166921336082431
block|,
operator|-
literal|.00000000000028658285157914353
block|,
operator|-
literal|.00000000000023812542263446809
block|,
literal|.00000000000006576659768580062
block|,
operator|-
literal|.00000000000028210143846181267
block|,
literal|.00000000000010701931762114254
block|,
literal|.00000000000018119346366441110
block|,
literal|.00000000000009840465278232627
block|,
operator|-
literal|.00000000000033149150282752542
block|,
operator|-
literal|.00000000000018302857356041668
block|,
operator|-
literal|.00000000000016207400156744949
block|,
literal|.00000000000048303314949553201
block|,
operator|-
literal|.00000000000071560553172382115
block|,
literal|.00000000000088821239518571855
block|,
operator|-
literal|.00000000000030900580513238244
block|,
operator|-
literal|.00000000000061076551972851496
block|,
literal|.00000000000035659969663347830
block|,
literal|.00000000000035782396591276383
block|,
operator|-
literal|.00000000000046226087001544578
block|,
literal|.00000000000062279762917225156
block|,
literal|.00000000000072838947272065741
block|,
literal|.00000000000026809646615211673
block|,
operator|-
literal|.00000000000010960825046059278
block|,
literal|.00000000000002311949383800537
block|,
operator|-
literal|.00000000000058469058005299247
block|,
operator|-
literal|.00000000000002103748251144494
block|,
operator|-
literal|.00000000000023323182945587408
block|,
operator|-
literal|.00000000000042333694288141916
block|,
operator|-
literal|.00000000000043933937969737844
block|,
literal|.00000000000041341647073835565
block|,
literal|.00000000000006841763641591466
block|,
literal|.00000000000047585534004430641
block|,
literal|.00000000000083679678674757695
block|,
operator|-
literal|.00000000000085763734646658640
block|,
literal|.00000000000021913281229340092
block|,
operator|-
literal|.00000000000062242842536431148
block|,
operator|-
literal|.00000000000010983594325438430
block|,
literal|.00000000000065310431377633651
block|,
operator|-
literal|.00000000000047580199021710769
block|,
operator|-
literal|.00000000000037854251265457040
block|,
literal|.00000000000040939233218678664
block|,
literal|.00000000000087424383914858291
block|,
literal|.00000000000025218188456842882
block|,
operator|-
literal|.00000000000003608131360422557
block|,
operator|-
literal|.00000000000050518555924280902
block|,
literal|.00000000000078699403323355317
block|,
operator|-
literal|.00000000000067020876961949060
block|,
literal|.00000000000016108575753932458
block|,
literal|.00000000000058527188436251509
block|,
operator|-
literal|.00000000000035246757297904791
block|,
operator|-
literal|.00000000000018372084495629058
block|,
literal|.00000000000088606689813494916
block|,
literal|.00000000000066486268071468700
block|,
literal|.00000000000063831615170646519
block|,
literal|.00000000000025144230728376072
block|,
operator|-
literal|.00000000000017239444525614834
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|double
ifdef|#
directive|ifdef
name|_ANSI_SOURCE
name|log
parameter_list|(
name|double
name|x
parameter_list|)
else|#
directive|else
function|log
parameter_list|(
name|x
parameter_list|)
name|double
name|x
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|m
decl_stmt|,
name|j
decl_stmt|;
name|double
name|F
decl_stmt|,
name|f
decl_stmt|,
name|g
decl_stmt|,
name|q
decl_stmt|,
name|u
decl_stmt|,
name|u2
decl_stmt|,
name|v
decl_stmt|,
name|zero
init|=
literal|0.0
decl_stmt|,
name|one
init|=
literal|1.0
decl_stmt|;
specifier|volatile
name|double
name|u1
decl_stmt|;
comment|/* Catch special cases */
if|if
condition|(
name|x
operator|<=
literal|0
condition|)
if|if
condition|(
name|_IEEE
operator|&&
name|x
operator|==
name|zero
condition|)
comment|/* log(0) = -Inf */
return|return
operator|(
operator|-
name|one
operator|/
name|zero
operator|)
return|;
elseif|else
if|if
condition|(
name|_IEEE
condition|)
comment|/* log(neg) = NaN */
return|return
operator|(
name|zero
operator|/
name|zero
operator|)
return|;
elseif|else
if|if
condition|(
name|x
operator|==
name|zero
condition|)
comment|/* NOT REACHED IF _IEEE */
return|return
operator|(
name|infnan
argument_list|(
operator|-
name|ERANGE
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|infnan
argument_list|(
name|EDOM
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
operator|!
name|finite
argument_list|(
name|x
argument_list|)
condition|)
if|if
condition|(
name|_IEEE
condition|)
comment|/* x = NaN, Inf */
return|return
operator|(
name|x
operator|+
name|x
operator|)
return|;
else|else
return|return
operator|(
name|infnan
argument_list|(
name|ERANGE
argument_list|)
operator|)
return|;
comment|/* Argument reduction: 1<= g< 2; x/2^m = g;	*/
comment|/* y = F*(1 + f/F) for |f|<= 2^-8		*/
name|m
operator|=
name|logb
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|g
operator|=
name|ldexp
argument_list|(
name|x
argument_list|,
operator|-
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|_IEEE
operator|&&
name|m
operator|==
operator|-
literal|1022
condition|)
block|{
name|j
operator|=
name|logb
argument_list|(
name|g
argument_list|)
operator|,
name|m
operator|+=
name|j
expr_stmt|;
name|g
operator|=
name|ldexp
argument_list|(
name|g
argument_list|,
operator|-
name|j
argument_list|)
expr_stmt|;
block|}
name|j
operator|=
name|N
operator|*
operator|(
name|g
operator|-
literal|1
operator|)
operator|+
literal|.5
expr_stmt|;
name|F
operator|=
operator|(
literal|1.0
operator|/
name|N
operator|)
operator|*
name|j
operator|+
literal|1
expr_stmt|;
comment|/* F*128 is an integer in [128, 512] */
name|f
operator|=
name|g
operator|-
name|F
expr_stmt|;
comment|/* Approximate expansion for log(1+f/F) ~= u + q */
name|g
operator|=
literal|1
operator|/
operator|(
literal|2
operator|*
name|F
operator|+
name|f
operator|)
expr_stmt|;
name|u
operator|=
literal|2
operator|*
name|f
operator|*
name|g
expr_stmt|;
name|v
operator|=
name|u
operator|*
name|u
expr_stmt|;
name|q
operator|=
name|u
operator|*
name|v
operator|*
operator|(
name|A1
operator|+
name|v
operator|*
operator|(
name|A2
operator|+
name|v
operator|*
operator|(
name|A3
operator|+
name|v
operator|*
name|A4
operator|)
operator|)
operator|)
expr_stmt|;
comment|/* case 1: u1 = u rounded to 2^-43 absolute.  Since u< 2^-8,      * 	       u1 has at most 35 bits, and F*u1 is exact, as F has< 8 bits.      *         It also adds exactly to |m*log2_hi + log_F_head[j] |< 750     */
if|if
condition|(
name|m
operator||
name|j
condition|)
name|u1
operator|=
name|u
operator|+
literal|513
operator|,
name|u1
operator|-=
literal|513
expr_stmt|;
comment|/* case 2:	|1-x|< 1/256. The m- and j- dependent terms are zero;      * 		u1 = u to 24 bits.     */
else|else
name|u1
operator|=
name|u
operator|,
name|TRUNC
argument_list|(
name|u1
argument_list|)
expr_stmt|;
name|u2
operator|=
operator|(
literal|2.0
operator|*
operator|(
name|f
operator|-
name|F
operator|*
name|u1
operator|)
operator|-
name|u1
operator|*
name|f
operator|)
operator|*
name|g
expr_stmt|;
comment|/* u1 + u2 = 2f/(2F+f) to extra precision.	*/
comment|/* log(x) = log(2^m*F*(1+f/F)) =				*/
comment|/* (m*log2_hi+logF_head[j]+u1) + (m*log2_lo+logF_tail[j]+q);	*/
comment|/* (exact) + (tiny)						*/
name|u1
operator|+=
name|m
operator|*
name|logF_head
index|[
name|N
index|]
operator|+
name|logF_head
index|[
name|j
index|]
expr_stmt|;
comment|/* exact */
name|u2
operator|=
operator|(
name|u2
operator|+
name|logF_tail
index|[
name|j
index|]
operator|)
operator|+
name|q
expr_stmt|;
comment|/* tiny */
name|u2
operator|+=
name|logF_tail
index|[
name|N
index|]
operator|*
name|m
expr_stmt|;
return|return
operator|(
name|u1
operator|+
name|u2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Extra precision variant, returning struct {double a, b;};  * log(x) = a+b to 63 bits, with a is rounded to 26 bits.  */
end_comment

begin_function
name|struct
name|Double
ifdef|#
directive|ifdef
name|_ANSI_SOURCE
name|__log__D
parameter_list|(
name|double
name|x
parameter_list|)
else|#
directive|else
function|__log__D
parameter_list|(
name|x
parameter_list|)
name|double
name|x
decl_stmt|;
endif|#
directive|endif
block|{
name|int
name|m
decl_stmt|,
name|j
decl_stmt|;
name|double
name|F
decl_stmt|,
name|f
decl_stmt|,
name|g
decl_stmt|,
name|q
decl_stmt|,
name|u
decl_stmt|,
name|v
decl_stmt|,
name|u2
decl_stmt|,
name|one
init|=
literal|1.0
decl_stmt|;
specifier|volatile
name|double
name|u1
decl_stmt|;
name|struct
name|Double
name|r
decl_stmt|;
comment|/* Argument reduction: 1<= g< 2; x/2^m = g;	*/
comment|/* y = F*(1 + f/F) for |f|<= 2^-8		*/
name|m
operator|=
name|logb
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|g
operator|=
name|ldexp
argument_list|(
name|x
argument_list|,
operator|-
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|_IEEE
operator|&&
name|m
operator|==
operator|-
literal|1022
condition|)
block|{
name|j
operator|=
name|logb
argument_list|(
name|g
argument_list|)
operator|,
name|m
operator|+=
name|j
expr_stmt|;
name|g
operator|=
name|ldexp
argument_list|(
name|g
argument_list|,
operator|-
name|j
argument_list|)
expr_stmt|;
block|}
name|j
operator|=
name|N
operator|*
operator|(
name|g
operator|-
literal|1
operator|)
operator|+
literal|.5
expr_stmt|;
name|F
operator|=
operator|(
literal|1.0
operator|/
name|N
operator|)
operator|*
name|j
operator|+
literal|1
expr_stmt|;
name|f
operator|=
name|g
operator|-
name|F
expr_stmt|;
name|g
operator|=
literal|1
operator|/
operator|(
literal|2
operator|*
name|F
operator|+
name|f
operator|)
expr_stmt|;
name|u
operator|=
literal|2
operator|*
name|f
operator|*
name|g
expr_stmt|;
name|v
operator|=
name|u
operator|*
name|u
expr_stmt|;
name|q
operator|=
name|u
operator|*
name|v
operator|*
operator|(
name|A1
operator|+
name|v
operator|*
operator|(
name|A2
operator|+
name|v
operator|*
operator|(
name|A3
operator|+
name|v
operator|*
name|A4
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|m
operator||
name|j
condition|)
name|u1
operator|=
name|u
operator|+
literal|513
operator|,
name|u1
operator|-=
literal|513
expr_stmt|;
else|else
name|u1
operator|=
name|u
operator|,
name|TRUNC
argument_list|(
name|u1
argument_list|)
expr_stmt|;
name|u2
operator|=
operator|(
literal|2.0
operator|*
operator|(
name|f
operator|-
name|F
operator|*
name|u1
operator|)
operator|-
name|u1
operator|*
name|f
operator|)
operator|*
name|g
expr_stmt|;
name|u1
operator|+=
name|m
operator|*
name|logF_head
index|[
name|N
index|]
operator|+
name|logF_head
index|[
name|j
index|]
expr_stmt|;
name|u2
operator|+=
name|logF_tail
index|[
name|j
index|]
expr_stmt|;
name|u2
operator|+=
name|q
expr_stmt|;
name|u2
operator|+=
name|logF_tail
index|[
name|N
index|]
operator|*
name|m
expr_stmt|;
name|r
operator|.
name|a
operator|=
name|u1
operator|+
name|u2
expr_stmt|;
comment|/* Only difference is here */
name|TRUNC
argument_list|(
name|r
operator|.
name|a
argument_list|)
expr_stmt|;
name|r
operator|.
name|b
operator|=
operator|(
name|u1
operator|-
name|r
operator|.
name|a
operator|)
operator|+
name|u2
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

end_unit

