begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_expr_stmt
operator|...
name|using
name|script
operator|...
name|CVS
operator|:
name|up
operator|-
name|A
operator|-
name|p
name|calendar
operator|.
name|c
comment|/*-  * Copyright (c) 1997 Wolfgang Helbig  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$Id: calendar.c,v 1.2 1997/12/13 11:51:12 helbig Exp $  */
include|#
directive|include
file|"calendar.h"
ifndef|#
directive|ifndef
name|NULL
define|#
directive|define
name|NULL
value|0
endif|#
directive|endif
comment|/*  * For each month tabulate the number of days elapsed in a year before the  * month. This assumes the internal date representation, where a year  * starts on March 1st. So we don't need a special table for leap years.  * But we do need a special table for the year 1582, since 10 days are  * deleted in October. This is month1s for the switch from Julian to  * Gregorian calendar.  */
specifier|static
name|int
specifier|const
name|month1
index|[]
operator|=
block|{
literal|0
block|,
literal|31
block|,
literal|61
block|,
literal|92
block|,
literal|122
block|,
literal|153
block|,
literal|184
block|,
literal|214
block|,
literal|245
block|,
literal|275
block|,
literal|306
block|,
literal|337
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  M   A   M   J    J    A    S    O    N    D    J */
end_comment

begin_decl_stmt
specifier|static
name|int
specifier|const
name|month1s
index|[]
init|=
block|{
literal|0
block|,
literal|31
block|,
literal|61
block|,
literal|92
block|,
literal|122
block|,
literal|153
block|,
literal|184
block|,
literal|214
block|,
literal|235
block|,
literal|265
block|,
literal|296
block|,
literal|327
block|}
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|struct
name|date
name|date
typedef|;
end_typedef

begin_comment
comment|/* The last day of Julian calendar, in internal and ndays representation */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nswitch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The last day of Julian calendar */
end_comment

begin_decl_stmt
specifier|static
name|date
name|jiswitch
init|=
block|{
literal|1582
block|,
literal|7
block|,
literal|3
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|date
modifier|*
name|date2idt
parameter_list|(
name|date
modifier|*
name|idt
parameter_list|,
name|date
modifier|*
name|dt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|date
modifier|*
name|idt2date
parameter_list|(
name|date
modifier|*
name|dt
parameter_list|,
name|date
modifier|*
name|idt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ndaysji
parameter_list|(
name|date
modifier|*
name|idt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ndaysgi
parameter_list|(
name|date
modifier|*
name|idt
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|firstweek
parameter_list|(
name|int
name|year
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Compute the Julian date from the number of days elapsed since  * March 1st of year zero.  */
end_comment

begin_function
name|date
modifier|*
name|jdate
parameter_list|(
name|int
name|ndays
parameter_list|,
name|date
modifier|*
name|dt
parameter_list|)
block|{
name|date
name|idt
decl_stmt|;
comment|/* Internal date representation */
name|int
name|r
decl_stmt|;
comment|/* hold the rest of days */
comment|/* 	 * Compute the year by starting with an approximation not smaller 	 * than the answer and using linear search for the greatest 	 * year which does not begin after ndays. 	 */
name|idt
operator|.
name|y
operator|=
name|ndays
operator|/
literal|365
expr_stmt|;
name|idt
operator|.
name|m
operator|=
literal|0
expr_stmt|;
name|idt
operator|.
name|d
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|ndaysji
argument_list|(
operator|&
name|idt
argument_list|)
operator|)
operator|>
name|ndays
condition|)
name|idt
operator|.
name|y
operator|--
expr_stmt|;
comment|/* 	 * Set r to the days left in the year and compute the month by 	 * linear search as the largest month that does not begin after r 	 * days. 	 */
name|r
operator|=
name|ndays
operator|-
name|r
expr_stmt|;
for|for
control|(
name|idt
operator|.
name|m
operator|=
literal|11
init|;
name|month1
index|[
name|idt
operator|.
name|m
index|]
operator|>
name|r
condition|;
name|idt
operator|.
name|m
operator|--
control|)
empty_stmt|;
comment|/* Compute the days left in the month */
name|idt
operator|.
name|d
operator|=
name|r
operator|-
name|month1
index|[
name|idt
operator|.
name|m
index|]
expr_stmt|;
comment|/* return external representation of the date */
return|return
operator|(
name|idt2date
argument_list|(
name|dt
argument_list|,
operator|&
name|idt
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the number of days since March 1st of the year zero.  * The date is given according to Julian calendar.  */
end_comment

begin_function
name|int
name|ndaysj
parameter_list|(
name|date
modifier|*
name|dt
parameter_list|)
block|{
name|date
name|idt
decl_stmt|;
comment|/* Internal date representation */
if|if
condition|(
name|date2idt
argument_list|(
operator|&
name|idt
argument_list|,
name|dt
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
else|else
return|return
operator|(
name|ndaysji
argument_list|(
operator|&
name|idt
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Same as above, where the Julian date is given in internal notation.  * This formula shows the beauty of this notation.  */
end_comment

begin_function
specifier|static
name|int
name|ndaysji
parameter_list|(
name|date
modifier|*
name|idt
parameter_list|)
block|{
return|return
operator|(
name|idt
operator|->
name|d
operator|+
name|month1
index|[
name|idt
operator|->
name|m
index|]
operator|+
name|idt
operator|->
name|y
operator|*
literal|365
operator|+
name|idt
operator|->
name|y
operator|/
literal|4
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compute the date according to the Gregorian calendar from the number of  * days since March 1st, year zero. The date computed will be Julian if it  * is older than 1582-10-05. This is the reverse of the function ndaysg().  */
end_comment

begin_function
name|date
modifier|*
name|gdate
parameter_list|(
name|int
name|ndays
parameter_list|,
name|date
modifier|*
name|dt
parameter_list|)
block|{
name|int
specifier|const
modifier|*
name|montht
decl_stmt|;
comment|/* month-table */
name|date
name|idt
decl_stmt|;
comment|/* for internal date representation */
name|int
name|r
decl_stmt|;
comment|/* holds the rest of days */
comment|/* 	 * Compute the year by starting with an approximation not smaller 	 * than the answer and search linearly for the greatest year not 	 * starting after ndays. 	 */
name|idt
operator|.
name|y
operator|=
name|ndays
operator|/
literal|365
expr_stmt|;
name|idt
operator|.
name|m
operator|=
literal|0
expr_stmt|;
name|idt
operator|.
name|d
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|ndaysgi
argument_list|(
operator|&
name|idt
argument_list|)
operator|)
operator|>
name|ndays
condition|)
name|idt
operator|.
name|y
operator|--
expr_stmt|;
comment|/* 	 * Set ndays to the number of days left and compute by linear 	 * search the greatest month which does not start after ndays. We 	 * use the table month1 which provides for each month the number 	 * of days that elapsed in the year before that month. Here the 	 * year 1582 is special, as 10 days are left out in October to 	 * resynchronize the calendar with the earth's orbit. October 4th 	 * 1582 is followed by October 15th 1582. We use the "switch" 	 * table month1s for this year. 	 */
name|ndays
operator|=
name|ndays
operator|-
name|r
expr_stmt|;
if|if
condition|(
name|idt
operator|.
name|y
operator|==
literal|1582
condition|)
name|montht
operator|=
name|month1s
expr_stmt|;
else|else
name|montht
operator|=
name|month1
expr_stmt|;
for|for
control|(
name|idt
operator|.
name|m
operator|=
literal|11
init|;
name|montht
index|[
name|idt
operator|.
name|m
index|]
operator|>
name|ndays
condition|;
name|idt
operator|.
name|m
operator|--
control|)
empty_stmt|;
name|idt
operator|.
name|d
operator|=
name|ndays
operator|-
name|montht
index|[
name|idt
operator|.
name|m
index|]
expr_stmt|;
comment|/* the rest is the day in month */
comment|/* Advance ten days deleted from October if after switch in Oct 1582 */
if|if
condition|(
name|idt
operator|.
name|y
operator|==
name|jiswitch
operator|.
name|y
operator|&&
name|idt
operator|.
name|m
operator|==
name|jiswitch
operator|.
name|m
operator|&&
name|jiswitch
operator|.
name|d
operator|<
name|idt
operator|.
name|d
condition|)
name|idt
operator|.
name|d
operator|+=
literal|10
expr_stmt|;
comment|/* return external representation of found date */
return|return
operator|(
name|idt2date
argument_list|(
name|dt
argument_list|,
operator|&
name|idt
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the number of days since March 1st of the year zero. The date is  * assumed Gregorian if younger than 1582-10-04 and Julian otherwise. This  * is the reverse of gdate.  */
end_comment

begin_function
name|int
name|ndaysg
parameter_list|(
name|date
modifier|*
name|dt
parameter_list|)
block|{
name|date
name|idt
decl_stmt|;
comment|/* Internal date representation */
if|if
condition|(
name|date2idt
argument_list|(
operator|&
name|idt
argument_list|,
name|dt
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|ndaysgi
argument_list|(
operator|&
name|idt
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Same as above, but with the Gregorian date given in internal  * representation.  */
end_comment

begin_function
specifier|static
name|int
name|ndaysgi
parameter_list|(
name|date
modifier|*
name|idt
parameter_list|)
block|{
name|int
name|nd
decl_stmt|;
comment|/* Number of days--return value */
comment|/* Cache nswitch if not already done */
if|if
condition|(
name|nswitch
operator|==
literal|0
condition|)
name|nswitch
operator|=
name|ndaysji
argument_list|(
operator|&
name|jiswitch
argument_list|)
expr_stmt|;
comment|/* 	 * Assume Julian calendar and adapt to Gregorian if necessary, i. e. 	 * younger than nswitch. Gregori deleted 	 * the ten days from Oct 5th to Oct 14th 1582. 	 * Thereafter years which are multiples of 100 and not multiples 	 * of 400 were not leap years anymore. 	 * This makes the average length of a year 	 * 365d +.25d - .01d + .0025d = 365.2425d. But the tropical 	 * year measures 365.2422d. So in 10000/3 years we are 	 * again one day ahead of the earth. Sigh :-) 	 * (d is the average length of a day and tropical year is the 	 * time from one spring point to the next.) 	 */
if|if
condition|(
operator|(
name|nd
operator|=
name|ndaysji
argument_list|(
name|idt
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|idt
operator|->
name|y
operator|>=
literal|1600
condition|)
name|nd
operator|=
operator|(
name|nd
operator|-
literal|10
operator|-
operator|(
name|idt
operator|->
name|y
operator|-
literal|1600
operator|)
operator|/
literal|100
operator|+
operator|(
name|idt
operator|->
name|y
operator|-
literal|1600
operator|)
operator|/
literal|400
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|nd
operator|>
name|nswitch
condition|)
name|nd
operator|-=
literal|10
expr_stmt|;
return|return
operator|(
name|nd
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compute the week number from the number of days since March 1st year 0.  * The weeks are numbered per year starting with 1. If the first  * week of a year includes at least four days of that year it is week 1,  * otherwise it gets the number of the last week of the previous year.  * The variable y will be filled with the year that contains the greater  * part of the week.  */
end_comment

begin_function
name|int
name|week
parameter_list|(
name|int
name|nd
parameter_list|,
name|int
modifier|*
name|y
parameter_list|)
block|{
name|date
name|dt
decl_stmt|;
name|int
name|fw
decl_stmt|;
comment|/* 1st day of week 1 of previous, this and 				 * next year */
name|gdate
argument_list|(
name|nd
argument_list|,
operator|&
name|dt
argument_list|)
expr_stmt|;
for|for
control|(
operator|*
name|y
operator|=
name|dt
operator|.
name|y
operator|+
literal|1
init|;
name|nd
operator|<
operator|(
name|fw
operator|=
name|firstweek
argument_list|(
operator|*
name|y
argument_list|)
operator|)
condition|;
operator|(
operator|*
name|y
operator|)
operator|--
control|)
empty_stmt|;
return|return
operator|(
operator|(
name|nd
operator|-
name|fw
operator|)
operator|/
literal|7
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* return the first day of week 1 of year y */
end_comment

begin_function
specifier|static
name|int
name|firstweek
parameter_list|(
name|int
name|y
parameter_list|)
block|{
name|date
name|idt
decl_stmt|;
name|int
name|nd
decl_stmt|,
name|wd
decl_stmt|;
name|idt
operator|.
name|y
operator|=
name|y
operator|-
literal|1
expr_stmt|;
comment|/* internal representation of y-1-1 */
name|idt
operator|.
name|m
operator|=
literal|10
expr_stmt|;
name|idt
operator|.
name|d
operator|=
literal|0
expr_stmt|;
name|nd
operator|=
name|ndaysgi
argument_list|(
operator|&
name|idt
argument_list|)
expr_stmt|;
comment|/* 	 * If more than 3 days of this week are in the preceding year, the 	 * next week is week 1 (and the next monday is the answer), 	 * otherwise this week is week 1 and the last monday is the 	 * answer. 	 */
if|if
condition|(
operator|(
name|wd
operator|=
name|weekday
argument_list|(
name|nd
argument_list|)
operator|)
operator|>
literal|3
condition|)
return|return
operator|(
name|nd
operator|-
name|wd
operator|+
literal|7
operator|)
return|;
else|else
return|return
operator|(
name|nd
operator|-
name|wd
operator|)
return|;
block|}
end_function

begin_comment
comment|/* return the weekday (Mo = 0 .. Su = 6) */
end_comment

begin_function
name|int
name|weekday
parameter_list|(
name|int
name|nd
parameter_list|)
block|{
name|date
name|dmondaygi
init|=
block|{
literal|1997
block|,
literal|8
block|,
literal|16
block|}
decl_stmt|;
comment|/* Internal repr. of 1997-11-17 */
specifier|static
name|int
name|nmonday
decl_stmt|;
comment|/* ... which is a monday        */
comment|/* Cache the daynumber of one monday */
if|if
condition|(
name|nmonday
operator|==
literal|0
condition|)
name|nmonday
operator|=
name|ndaysgi
argument_list|(
operator|&
name|dmondaygi
argument_list|)
expr_stmt|;
comment|/* return (nd - nmonday) modulo 7 which is the weekday */
name|nd
operator|=
operator|(
name|nd
operator|-
name|nmonday
operator|)
operator|%
literal|7
expr_stmt|;
if|if
condition|(
name|nd
operator|<
literal|0
condition|)
return|return
operator|(
name|nd
operator|+
literal|7
operator|)
return|;
else|else
return|return
operator|(
name|nd
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a date to internal date representation: The year starts on  * March 1st, month and day numbering start at zero. E. g. March 1st of  * year zero is written as y=0, m=0, d=0.  */
end_comment

begin_function
specifier|static
name|date
modifier|*
name|date2idt
parameter_list|(
name|date
modifier|*
name|idt
parameter_list|,
name|date
modifier|*
name|dt
parameter_list|)
block|{
name|idt
operator|->
name|d
operator|=
name|dt
operator|->
name|d
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|dt
operator|->
name|m
operator|>
literal|2
condition|)
block|{
name|idt
operator|->
name|m
operator|=
name|dt
operator|->
name|m
operator|-
literal|3
expr_stmt|;
name|idt
operator|->
name|y
operator|=
name|dt
operator|->
name|y
expr_stmt|;
block|}
else|else
block|{
name|idt
operator|->
name|m
operator|=
name|dt
operator|->
name|m
operator|+
literal|9
expr_stmt|;
name|idt
operator|->
name|y
operator|=
name|dt
operator|->
name|y
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|idt
operator|->
name|m
operator|<
literal|0
operator|||
name|idt
operator|->
name|m
operator|>
literal|11
operator|||
name|idt
operator|->
name|y
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
return|return
name|idt
return|;
block|}
end_function

begin_comment
comment|/* Reverse of date2idt */
end_comment

begin_function
specifier|static
name|date
modifier|*
name|idt2date
parameter_list|(
name|date
modifier|*
name|dt
parameter_list|,
name|date
modifier|*
name|idt
parameter_list|)
block|{
name|dt
operator|->
name|d
operator|=
name|idt
operator|->
name|d
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|idt
operator|->
name|m
operator|<
literal|10
condition|)
block|{
name|dt
operator|->
name|m
operator|=
name|idt
operator|->
name|m
operator|+
literal|3
expr_stmt|;
name|dt
operator|->
name|y
operator|=
name|idt
operator|->
name|y
expr_stmt|;
block|}
else|else
block|{
name|dt
operator|->
name|m
operator|=
name|idt
operator|->
name|m
operator|-
literal|9
expr_stmt|;
name|dt
operator|->
name|y
operator|=
name|idt
operator|->
name|y
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|dt
operator|->
name|m
operator|<
literal|1
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|dt
operator|)
return|;
block|}
end_function

end_unit

