begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2006 - 2007 Kungliga Tekniska HÃ¶gskolan  * (Royal Institute of Technology, Stockholm, Sweden).   * All rights reserved.   *  * Redistribution and use in source and binary forms, with or without   * modification, are permitted provided that the following conditions   * are met:   *  * 1. Redistributions of source code must retain the above copyright   *    notice, this list of conditions and the following disclaimer.   *  * 2. Redistributions in binary form must reproduce the above copyright   *    notice, this list of conditions and the following disclaimer in the   *    documentation and/or other materials provided with the distribution.   *  * 3. Neither the name of the Institute nor the names of its contributors   *    may be used to endorse or promote products derived from this software   *    without specific prior written permission.   *  * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND   * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE   * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL   * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS   * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)   * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT   * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY   * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF   * SUCH DAMAGE.   */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_expr_stmt
name|RCSID
argument_list|(
literal|"$Id: ntlm.c 22370 2007-12-28 16:12:01Z lha $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<krb5.h>
end_include

begin_include
include|#
directive|include
file|<roken.h>
end_include

begin_include
include|#
directive|include
file|"krb5-types.h"
end_include

begin_include
include|#
directive|include
file|"crypto-headers.h"
end_include

begin_include
include|#
directive|include
file|<heimntlm.h>
end_include

begin_comment
comment|/*! \mainpage Heimdal NTLM library  *  * \section intro Introduction  *  * Heimdal libheimntlm library is a implementation of the NTLM  * protocol, both version 1 and 2. The GSS-API mech that uses this  * library adds support for transport encryption and integrity  * checking.  *   * NTLM is a protocol for mutual authentication, its still used in  * many protocol where Kerberos is not support, one example is  * EAP/X802.1x mechanism LEAP from Microsoft and Cisco.  *  * This is a support library for the core protocol, its used in  * Heimdal to implement and GSS-API mechanism. There is also support  * in the KDC to do remote digest authenticiation, this to allow  * services to authenticate users w/o direct access to the users ntlm  * hashes (same as Kerberos arcfour enctype hashes).  *  * More information about the NTLM protocol can found here  * http://davenport.sourceforge.net/ntlm.html .  *   * The Heimdal projects web page: http://www.h5l.org/  */
end_comment

begin_comment
comment|/** @defgroup ntlm_core Heimdal NTLM library   *   * The NTLM core functions implement the string2key generation  * function, message encode and decode function, and the hash function  * functions.  */
end_comment

begin_struct
struct|struct
name|sec_buffer
block|{
name|uint16_t
name|length
decl_stmt|;
name|uint16_t
name|allocated
decl_stmt|;
name|uint32_t
name|offset
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|unsigned
name|char
name|ntlmsigature
index|[
literal|8
index|]
init|=
literal|"NTLMSSP\x00"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  */
end_comment

begin_define
define|#
directive|define
name|CHECK
parameter_list|(
name|f
parameter_list|,
name|e
parameter_list|)
define|\
value|do { ret = f ; if (ret != (e)) { ret = EINVAL; goto out; } } while(0)
end_define

begin_comment
comment|/**  * heim_ntlm_free_buf frees the ntlm buffer  *  * @param p buffer to be freed  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|void
name|heim_ntlm_free_buf
parameter_list|(
name|struct
name|ntlm_buf
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|data
condition|)
name|free
argument_list|(
name|p
operator|->
name|data
argument_list|)
expr_stmt|;
name|p
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|length
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ascii2ucs2le
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|int
name|up
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|buf
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|i
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|/
literal|2
operator|>
name|UINT_MAX
condition|)
return|return
name|ERANGE
return|;
name|buf
operator|->
name|length
operator|=
name|len
operator|*
literal|2
expr_stmt|;
name|buf
operator|->
name|data
operator|=
name|malloc
argument_list|(
name|buf
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|data
operator|==
name|NULL
operator|&&
name|len
operator|!=
literal|0
condition|)
block|{
name|heim_ntlm_free_buf
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|p
operator|=
name|buf
operator|->
name|data
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|char
name|t
init|=
operator|(
name|unsigned
name|char
operator|)
name|string
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|t
operator|&
literal|0x80
condition|)
block|{
name|heim_ntlm_free_buf
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
if|if
condition|(
name|up
condition|)
name|t
operator|=
name|toupper
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|p
index|[
operator|(
name|i
operator|*
literal|2
operator|)
operator|+
literal|0
index|]
operator|=
name|t
expr_stmt|;
name|p
index|[
operator|(
name|i
operator|*
literal|2
operator|)
operator|+
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|krb5_error_code
name|ret_sec_buffer
parameter_list|(
name|krb5_storage
modifier|*
name|sp
parameter_list|,
name|struct
name|sec_buffer
modifier|*
name|buf
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|CHECK
argument_list|(
name|krb5_ret_uint16
argument_list|(
name|sp
argument_list|,
operator|&
name|buf
operator|->
name|length
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_ret_uint16
argument_list|(
name|sp
argument_list|,
operator|&
name|buf
operator|->
name|allocated
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_ret_uint32
argument_list|(
name|sp
argument_list|,
operator|&
name|buf
operator|->
name|offset
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|store_sec_buffer
parameter_list|(
name|krb5_storage
modifier|*
name|sp
parameter_list|,
specifier|const
name|struct
name|sec_buffer
modifier|*
name|buf
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint16
argument_list|(
name|sp
argument_list|,
name|buf
operator|->
name|length
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint16
argument_list|(
name|sp
argument_list|,
name|buf
operator|->
name|allocated
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint32
argument_list|(
name|sp
argument_list|,
name|buf
operator|->
name|offset
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Strings are either OEM or UNICODE. The later is encoded as ucs2 on  * wire, but using utf8 in memory.  */
end_comment

begin_function
specifier|static
name|krb5_error_code
name|len_string
parameter_list|(
name|int
name|ucs2
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|s
argument_list|)
decl_stmt|;
if|if
condition|(
name|ucs2
condition|)
name|len
operator|*=
literal|2
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|ret_string
parameter_list|(
name|krb5_storage
modifier|*
name|sp
parameter_list|,
name|int
name|ucs2
parameter_list|,
name|struct
name|sec_buffer
modifier|*
name|desc
parameter_list|,
name|char
modifier|*
modifier|*
name|s
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
operator|*
name|s
operator|=
name|malloc
argument_list|(
name|desc
operator|->
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_storage_seek
argument_list|(
name|sp
argument_list|,
name|desc
operator|->
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
argument_list|,
name|desc
operator|->
name|offset
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_storage_read
argument_list|(
name|sp
argument_list|,
operator|*
name|s
argument_list|,
name|desc
operator|->
name|length
argument_list|)
argument_list|,
name|desc
operator|->
name|length
argument_list|)
expr_stmt|;
operator|(
operator|*
name|s
operator|)
index|[
name|desc
operator|->
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|ucs2
condition|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|desc
operator|->
name|length
operator|/
literal|2
condition|;
name|i
operator|++
control|)
block|{
operator|(
operator|*
name|s
operator|)
index|[
name|i
index|]
operator|=
operator|(
operator|*
name|s
operator|)
index|[
name|i
operator|*
literal|2
index|]
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|s
operator|)
index|[
name|i
operator|*
literal|2
operator|+
literal|1
index|]
condition|)
block|{
name|free
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
operator|*
name|s
operator|=
name|NULL
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
block|}
operator|(
operator|*
name|s
operator|)
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|ret
operator|=
literal|0
expr_stmt|;
name|out
label|:
return|return
name|ret
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|put_string
parameter_list|(
name|krb5_storage
modifier|*
name|sp
parameter_list|,
name|int
name|ucs2
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|struct
name|ntlm_buf
name|buf
decl_stmt|;
if|if
condition|(
name|ucs2
condition|)
block|{
name|ret
operator|=
name|ascii2ucs2le
argument_list|(
name|s
argument_list|,
literal|0
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
name|ret
return|;
block|}
else|else
block|{
name|buf
operator|.
name|data
operator|=
name|rk_UNCONST
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|buf
operator|.
name|length
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|CHECK
argument_list|(
name|krb5_storage_write
argument_list|(
name|sp
argument_list|,
name|buf
operator|.
name|data
argument_list|,
name|buf
operator|.
name|length
argument_list|)
argument_list|,
name|buf
operator|.
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|ucs2
condition|)
name|heim_ntlm_free_buf
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|out
label|:
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|krb5_error_code
name|ret_buf
parameter_list|(
name|krb5_storage
modifier|*
name|sp
parameter_list|,
name|struct
name|sec_buffer
modifier|*
name|desc
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|buf
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|buf
operator|->
name|data
operator|=
name|malloc
argument_list|(
name|desc
operator|->
name|length
argument_list|)
expr_stmt|;
name|buf
operator|->
name|length
operator|=
name|desc
operator|->
name|length
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_storage_seek
argument_list|(
name|sp
argument_list|,
name|desc
operator|->
name|offset
argument_list|,
name|SEEK_SET
argument_list|)
argument_list|,
name|desc
operator|->
name|offset
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_storage_read
argument_list|(
name|sp
argument_list|,
name|buf
operator|->
name|data
argument_list|,
name|buf
operator|->
name|length
argument_list|)
argument_list|,
name|buf
operator|->
name|length
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|out
label|:
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|krb5_error_code
name|put_buf
parameter_list|(
name|krb5_storage
modifier|*
name|sp
parameter_list|,
specifier|const
name|struct
name|ntlm_buf
modifier|*
name|buf
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|CHECK
argument_list|(
name|krb5_storage_write
argument_list|(
name|sp
argument_list|,
name|buf
operator|->
name|data
argument_list|,
name|buf
operator|->
name|length
argument_list|)
argument_list|,
name|buf
operator|->
name|length
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|out
label|:
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Frees the ntlm_targetinfo message  *  * @param ti targetinfo to be freed  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|void
name|heim_ntlm_free_targetinfo
parameter_list|(
name|struct
name|ntlm_targetinfo
modifier|*
name|ti
parameter_list|)
block|{
name|free
argument_list|(
name|ti
operator|->
name|servername
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ti
operator|->
name|domainname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ti
operator|->
name|dnsdomainname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ti
operator|->
name|dnsservername
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ti
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ti
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|encode_ti_blob
parameter_list|(
name|krb5_storage
modifier|*
name|out
parameter_list|,
name|uint16_t
name|type
parameter_list|,
name|int
name|ucs2
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint16
argument_list|(
name|out
argument_list|,
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint16
argument_list|(
name|out
argument_list|,
name|len_string
argument_list|(
name|ucs2
argument_list|,
name|s
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|put_string
argument_list|(
name|out
argument_list|,
name|ucs2
argument_list|,
name|s
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
label|:
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Encodes a ntlm_targetinfo message.  *  * @param ti the ntlm_targetinfo message to encode.  * @param ucs2 if the strings should be encoded with ucs2 (selected by flag in message).  * @param data is the return buffer with the encoded message, should be  * freed with heim_ntlm_free_buf().  *  * @return In case of success 0 is return, an errors, a errno in what  * went wrong.  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|int
name|heim_ntlm_encode_targetinfo
parameter_list|(
specifier|const
name|struct
name|ntlm_targetinfo
modifier|*
name|ti
parameter_list|,
name|int
name|ucs2
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|data
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|krb5_storage
modifier|*
name|out
decl_stmt|;
name|data
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
name|data
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|out
operator|=
name|krb5_storage_emem
argument_list|()
expr_stmt|;
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
if|if
condition|(
name|ti
operator|->
name|servername
condition|)
name|CHECK
argument_list|(
name|encode_ti_blob
argument_list|(
name|out
argument_list|,
literal|1
argument_list|,
name|ucs2
argument_list|,
name|ti
operator|->
name|servername
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ti
operator|->
name|domainname
condition|)
name|CHECK
argument_list|(
name|encode_ti_blob
argument_list|(
name|out
argument_list|,
literal|2
argument_list|,
name|ucs2
argument_list|,
name|ti
operator|->
name|domainname
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ti
operator|->
name|dnsservername
condition|)
name|CHECK
argument_list|(
name|encode_ti_blob
argument_list|(
name|out
argument_list|,
literal|3
argument_list|,
name|ucs2
argument_list|,
name|ti
operator|->
name|dnsservername
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ti
operator|->
name|dnsdomainname
condition|)
name|CHECK
argument_list|(
name|encode_ti_blob
argument_list|(
name|out
argument_list|,
literal|4
argument_list|,
name|ucs2
argument_list|,
name|ti
operator|->
name|dnsdomainname
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* end tag */
name|CHECK
argument_list|(
name|krb5_store_int16
argument_list|(
name|out
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_store_int16
argument_list|(
name|out
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|krb5_data
name|d
decl_stmt|;
name|ret
operator|=
name|krb5_storage_to_data
argument_list|(
name|out
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
name|data
operator|->
name|data
operator|=
name|d
operator|.
name|data
expr_stmt|;
name|data
operator|->
name|length
operator|=
name|d
operator|.
name|length
expr_stmt|;
block|}
name|out
label|:
name|krb5_storage_free
argument_list|(
name|out
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Decodes an NTLM targetinfo message  *  * @param data input data buffer with the encode NTLM targetinfo message  * @param ucs2 if the strings should be encoded with ucs2 (selected by flag in message).  * @param ti the decoded target info, should be freed with heim_ntlm_free_targetinfo().  *  * @return In case of success 0 is return, an errors, a errno in what  * went wrong.  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|int
name|heim_ntlm_decode_targetinfo
parameter_list|(
specifier|const
name|struct
name|ntlm_buf
modifier|*
name|data
parameter_list|,
name|int
name|ucs2
parameter_list|,
name|struct
name|ntlm_targetinfo
modifier|*
name|ti
parameter_list|)
block|{
name|memset
argument_list|(
name|ti
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ti
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Frees the ntlm_type1 message  *  * @param data message to be freed  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|void
name|heim_ntlm_free_type1
parameter_list|(
name|struct
name|ntlm_type1
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|data
operator|->
name|domain
condition|)
name|free
argument_list|(
name|data
operator|->
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|hostname
condition|)
name|free
argument_list|(
name|data
operator|->
name|hostname
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|heim_ntlm_decode_type1
parameter_list|(
specifier|const
name|struct
name|ntlm_buf
modifier|*
name|buf
parameter_list|,
name|struct
name|ntlm_type1
modifier|*
name|data
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|unsigned
name|char
name|sig
index|[
literal|8
index|]
decl_stmt|;
name|uint32_t
name|type
decl_stmt|;
name|struct
name|sec_buffer
name|domain
decl_stmt|,
name|hostname
decl_stmt|;
name|krb5_storage
modifier|*
name|in
decl_stmt|;
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|in
operator|=
name|krb5_storage_from_readonly_mem
argument_list|(
name|buf
operator|->
name|data
argument_list|,
name|buf
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|krb5_storage_set_byteorder
argument_list|(
name|in
argument_list|,
name|KRB5_STORAGE_BYTEORDER_LE
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_storage_read
argument_list|(
name|in
argument_list|,
name|sig
argument_list|,
sizeof|sizeof
argument_list|(
name|sig
argument_list|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|sig
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|memcmp
argument_list|(
name|ntlmsigature
argument_list|,
name|sig
argument_list|,
sizeof|sizeof
argument_list|(
name|ntlmsigature
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_ret_uint32
argument_list|(
name|in
argument_list|,
operator|&
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_ret_uint32
argument_list|(
name|in
argument_list|,
operator|&
name|data
operator|->
name|flags
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|flags
operator|&
name|NTLM_SUPPLIED_DOMAIN
condition|)
name|CHECK
argument_list|(
name|ret_sec_buffer
argument_list|(
name|in
argument_list|,
operator|&
name|domain
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|flags
operator|&
name|NTLM_SUPPLIED_WORKSTAION
condition|)
name|CHECK
argument_list|(
name|ret_sec_buffer
argument_list|(
name|in
argument_list|,
operator|&
name|hostname
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (domain.offset> 32) { 	CHECK(krb5_ret_uint32(in,&data->os[0]), 0); 	CHECK(krb5_ret_uint32(in,&data->os[1]), 0);     }
endif|#
directive|endif
if|if
condition|(
name|data
operator|->
name|flags
operator|&
name|NTLM_SUPPLIED_DOMAIN
condition|)
name|CHECK
argument_list|(
name|ret_string
argument_list|(
name|in
argument_list|,
literal|0
argument_list|,
operator|&
name|domain
argument_list|,
operator|&
name|data
operator|->
name|domain
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|flags
operator|&
name|NTLM_SUPPLIED_WORKSTAION
condition|)
name|CHECK
argument_list|(
name|ret_string
argument_list|(
name|in
argument_list|,
literal|0
argument_list|,
operator|&
name|hostname
argument_list|,
operator|&
name|data
operator|->
name|hostname
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
label|:
name|krb5_storage_free
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|heim_ntlm_free_type1
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Encodes an ntlm_type1 message.  *  * @param type1 the ntlm_type1 message to encode.  * @param data is the return buffer with the encoded message, should be  * freed with heim_ntlm_free_buf().  *  * @return In case of success 0 is return, an errors, a errno in what  * went wrong.  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|int
name|heim_ntlm_encode_type1
parameter_list|(
specifier|const
name|struct
name|ntlm_type1
modifier|*
name|type1
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|data
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|struct
name|sec_buffer
name|domain
decl_stmt|,
name|hostname
decl_stmt|;
name|krb5_storage
modifier|*
name|out
decl_stmt|;
name|uint32_t
name|base
decl_stmt|,
name|flags
decl_stmt|;
name|flags
operator|=
name|type1
operator|->
name|flags
expr_stmt|;
name|base
operator|=
literal|16
expr_stmt|;
if|if
condition|(
name|type1
operator|->
name|domain
condition|)
block|{
name|base
operator|+=
literal|8
expr_stmt|;
name|flags
operator||=
name|NTLM_SUPPLIED_DOMAIN
expr_stmt|;
block|}
if|if
condition|(
name|type1
operator|->
name|hostname
condition|)
block|{
name|base
operator|+=
literal|8
expr_stmt|;
name|flags
operator||=
name|NTLM_SUPPLIED_WORKSTAION
expr_stmt|;
block|}
if|if
condition|(
name|type1
operator|->
name|os
index|[
literal|0
index|]
condition|)
name|base
operator|+=
literal|8
expr_stmt|;
if|if
condition|(
name|type1
operator|->
name|domain
condition|)
block|{
name|domain
operator|.
name|offset
operator|=
name|base
expr_stmt|;
name|domain
operator|.
name|length
operator|=
name|len_string
argument_list|(
literal|0
argument_list|,
name|type1
operator|->
name|domain
argument_list|)
expr_stmt|;
name|domain
operator|.
name|allocated
operator|=
name|domain
operator|.
name|length
expr_stmt|;
block|}
if|if
condition|(
name|type1
operator|->
name|hostname
condition|)
block|{
name|hostname
operator|.
name|offset
operator|=
name|domain
operator|.
name|allocated
operator|+
name|domain
operator|.
name|offset
expr_stmt|;
name|hostname
operator|.
name|length
operator|=
name|len_string
argument_list|(
literal|0
argument_list|,
name|type1
operator|->
name|hostname
argument_list|)
expr_stmt|;
name|hostname
operator|.
name|allocated
operator|=
name|hostname
operator|.
name|length
expr_stmt|;
block|}
name|out
operator|=
name|krb5_storage_emem
argument_list|()
expr_stmt|;
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|krb5_storage_set_byteorder
argument_list|(
name|out
argument_list|,
name|KRB5_STORAGE_BYTEORDER_LE
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_storage_write
argument_list|(
name|out
argument_list|,
name|ntlmsigature
argument_list|,
sizeof|sizeof
argument_list|(
name|ntlmsigature
argument_list|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ntlmsigature
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint32
argument_list|(
name|out
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint32
argument_list|(
name|out
argument_list|,
name|flags
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|type1
operator|->
name|domain
condition|)
name|CHECK
argument_list|(
name|store_sec_buffer
argument_list|(
name|out
argument_list|,
operator|&
name|domain
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|type1
operator|->
name|hostname
condition|)
name|CHECK
argument_list|(
name|store_sec_buffer
argument_list|(
name|out
argument_list|,
operator|&
name|hostname
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|type1
operator|->
name|os
index|[
literal|0
index|]
condition|)
block|{
name|CHECK
argument_list|(
name|krb5_store_uint32
argument_list|(
name|out
argument_list|,
name|type1
operator|->
name|os
index|[
literal|0
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint32
argument_list|(
name|out
argument_list|,
name|type1
operator|->
name|os
index|[
literal|1
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|type1
operator|->
name|domain
condition|)
name|CHECK
argument_list|(
name|put_string
argument_list|(
name|out
argument_list|,
literal|0
argument_list|,
name|type1
operator|->
name|domain
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|type1
operator|->
name|hostname
condition|)
name|CHECK
argument_list|(
name|put_string
argument_list|(
name|out
argument_list|,
literal|0
argument_list|,
name|type1
operator|->
name|hostname
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|krb5_data
name|d
decl_stmt|;
name|ret
operator|=
name|krb5_storage_to_data
argument_list|(
name|out
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
name|data
operator|->
name|data
operator|=
name|d
operator|.
name|data
expr_stmt|;
name|data
operator|->
name|length
operator|=
name|d
operator|.
name|length
expr_stmt|;
block|}
name|out
label|:
name|krb5_storage_free
argument_list|(
name|out
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Frees the ntlm_type2 message  *  * @param data message to be freed  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|void
name|heim_ntlm_free_type2
parameter_list|(
name|struct
name|ntlm_type2
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|data
operator|->
name|targetname
condition|)
name|free
argument_list|(
name|data
operator|->
name|targetname
argument_list|)
expr_stmt|;
name|heim_ntlm_free_buf
argument_list|(
operator|&
name|data
operator|->
name|targetinfo
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|heim_ntlm_decode_type2
parameter_list|(
specifier|const
name|struct
name|ntlm_buf
modifier|*
name|buf
parameter_list|,
name|struct
name|ntlm_type2
modifier|*
name|type2
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|unsigned
name|char
name|sig
index|[
literal|8
index|]
decl_stmt|;
name|uint32_t
name|type
decl_stmt|,
name|ctx
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|sec_buffer
name|targetname
decl_stmt|,
name|targetinfo
decl_stmt|;
name|krb5_storage
modifier|*
name|in
decl_stmt|;
name|int
name|ucs2
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
name|type2
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|type2
argument_list|)
argument_list|)
expr_stmt|;
name|in
operator|=
name|krb5_storage_from_readonly_mem
argument_list|(
name|buf
operator|->
name|data
argument_list|,
name|buf
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|krb5_storage_set_byteorder
argument_list|(
name|in
argument_list|,
name|KRB5_STORAGE_BYTEORDER_LE
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_storage_read
argument_list|(
name|in
argument_list|,
name|sig
argument_list|,
sizeof|sizeof
argument_list|(
name|sig
argument_list|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|sig
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|memcmp
argument_list|(
name|ntlmsigature
argument_list|,
name|sig
argument_list|,
sizeof|sizeof
argument_list|(
name|ntlmsigature
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_ret_uint32
argument_list|(
name|in
argument_list|,
operator|&
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|type
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|ret_sec_buffer
argument_list|(
name|in
argument_list|,
operator|&
name|targetname
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_ret_uint32
argument_list|(
name|in
argument_list|,
operator|&
name|type2
operator|->
name|flags
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|type2
operator|->
name|flags
operator|&
name|NTLM_NEG_UNICODE
condition|)
name|ucs2
operator|=
literal|1
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_storage_read
argument_list|(
name|in
argument_list|,
name|type2
operator|->
name|challange
argument_list|,
sizeof|sizeof
argument_list|(
name|type2
operator|->
name|challange
argument_list|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|type2
operator|->
name|challange
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_ret_uint32
argument_list|(
name|in
argument_list|,
operator|&
name|ctx
index|[
literal|0
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* context */
name|CHECK
argument_list|(
name|krb5_ret_uint32
argument_list|(
name|in
argument_list|,
operator|&
name|ctx
index|[
literal|1
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|ret_sec_buffer
argument_list|(
name|in
argument_list|,
operator|&
name|targetinfo
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* os version */
if|#
directive|if
literal|0
block|CHECK(krb5_ret_uint32(in,&type2->os[0]), 0);     CHECK(krb5_ret_uint32(in,&type2->os[1]), 0);
endif|#
directive|endif
name|CHECK
argument_list|(
name|ret_string
argument_list|(
name|in
argument_list|,
name|ucs2
argument_list|,
operator|&
name|targetname
argument_list|,
operator|&
name|type2
operator|->
name|targetname
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|ret_buf
argument_list|(
name|in
argument_list|,
operator|&
name|targetinfo
argument_list|,
operator|&
name|type2
operator|->
name|targetinfo
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|krb5_storage_free
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|heim_ntlm_free_type2
argument_list|(
name|type2
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Encodes an ntlm_type2 message.  *  * @param type2 the ntlm_type2 message to encode.  * @param data is the return buffer with the encoded message, should be  * freed with heim_ntlm_free_buf().  *  * @return In case of success 0 is return, an errors, a errno in what  * went wrong.  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|int
name|heim_ntlm_encode_type2
parameter_list|(
specifier|const
name|struct
name|ntlm_type2
modifier|*
name|type2
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|sec_buffer
name|targetname
decl_stmt|,
name|targetinfo
decl_stmt|;
name|krb5_error_code
name|ret
decl_stmt|;
name|krb5_storage
modifier|*
name|out
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|base
decl_stmt|;
name|int
name|ucs2
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|type2
operator|->
name|os
index|[
literal|0
index|]
condition|)
name|base
operator|=
literal|56
expr_stmt|;
else|else
name|base
operator|=
literal|48
expr_stmt|;
if|if
condition|(
name|type2
operator|->
name|flags
operator|&
name|NTLM_NEG_UNICODE
condition|)
name|ucs2
operator|=
literal|1
expr_stmt|;
name|targetname
operator|.
name|offset
operator|=
name|base
expr_stmt|;
name|targetname
operator|.
name|length
operator|=
name|len_string
argument_list|(
name|ucs2
argument_list|,
name|type2
operator|->
name|targetname
argument_list|)
expr_stmt|;
name|targetname
operator|.
name|allocated
operator|=
name|targetname
operator|.
name|length
expr_stmt|;
name|targetinfo
operator|.
name|offset
operator|=
name|targetname
operator|.
name|allocated
operator|+
name|targetname
operator|.
name|offset
expr_stmt|;
name|targetinfo
operator|.
name|length
operator|=
name|type2
operator|->
name|targetinfo
operator|.
name|length
expr_stmt|;
name|targetinfo
operator|.
name|allocated
operator|=
name|type2
operator|->
name|targetinfo
operator|.
name|length
expr_stmt|;
name|out
operator|=
name|krb5_storage_emem
argument_list|()
expr_stmt|;
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|krb5_storage_set_byteorder
argument_list|(
name|out
argument_list|,
name|KRB5_STORAGE_BYTEORDER_LE
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_storage_write
argument_list|(
name|out
argument_list|,
name|ntlmsigature
argument_list|,
sizeof|sizeof
argument_list|(
name|ntlmsigature
argument_list|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ntlmsigature
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint32
argument_list|(
name|out
argument_list|,
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|store_sec_buffer
argument_list|(
name|out
argument_list|,
operator|&
name|targetname
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint32
argument_list|(
name|out
argument_list|,
name|type2
operator|->
name|flags
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_storage_write
argument_list|(
name|out
argument_list|,
name|type2
operator|->
name|challange
argument_list|,
sizeof|sizeof
argument_list|(
name|type2
operator|->
name|challange
argument_list|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|type2
operator|->
name|challange
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint32
argument_list|(
name|out
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* context */
name|CHECK
argument_list|(
name|krb5_store_uint32
argument_list|(
name|out
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|store_sec_buffer
argument_list|(
name|out
argument_list|,
operator|&
name|targetinfo
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* os version */
if|if
condition|(
name|type2
operator|->
name|os
index|[
literal|0
index|]
condition|)
block|{
name|CHECK
argument_list|(
name|krb5_store_uint32
argument_list|(
name|out
argument_list|,
name|type2
operator|->
name|os
index|[
literal|0
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint32
argument_list|(
name|out
argument_list|,
name|type2
operator|->
name|os
index|[
literal|1
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|CHECK
argument_list|(
name|put_string
argument_list|(
name|out
argument_list|,
name|ucs2
argument_list|,
name|type2
operator|->
name|targetname
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_storage_write
argument_list|(
name|out
argument_list|,
name|type2
operator|->
name|targetinfo
operator|.
name|data
argument_list|,
name|type2
operator|->
name|targetinfo
operator|.
name|length
argument_list|)
argument_list|,
name|type2
operator|->
name|targetinfo
operator|.
name|length
argument_list|)
expr_stmt|;
block|{
name|krb5_data
name|d
decl_stmt|;
name|ret
operator|=
name|krb5_storage_to_data
argument_list|(
name|out
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
name|data
operator|->
name|data
operator|=
name|d
operator|.
name|data
expr_stmt|;
name|data
operator|->
name|length
operator|=
name|d
operator|.
name|length
expr_stmt|;
block|}
name|out
label|:
name|krb5_storage_free
argument_list|(
name|out
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Frees the ntlm_type3 message  *  * @param data message to be freed  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|void
name|heim_ntlm_free_type3
parameter_list|(
name|struct
name|ntlm_type3
modifier|*
name|data
parameter_list|)
block|{
name|heim_ntlm_free_buf
argument_list|(
operator|&
name|data
operator|->
name|lm
argument_list|)
expr_stmt|;
name|heim_ntlm_free_buf
argument_list|(
operator|&
name|data
operator|->
name|ntlm
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|targetname
condition|)
name|free
argument_list|(
name|data
operator|->
name|targetname
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|username
condition|)
name|free
argument_list|(
name|data
operator|->
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|->
name|ws
condition|)
name|free
argument_list|(
name|data
operator|->
name|ws
argument_list|)
expr_stmt|;
name|heim_ntlm_free_buf
argument_list|(
operator|&
name|data
operator|->
name|sessionkey
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
name|int
name|heim_ntlm_decode_type3
parameter_list|(
specifier|const
name|struct
name|ntlm_buf
modifier|*
name|buf
parameter_list|,
name|int
name|ucs2
parameter_list|,
name|struct
name|ntlm_type3
modifier|*
name|type3
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|unsigned
name|char
name|sig
index|[
literal|8
index|]
decl_stmt|;
name|uint32_t
name|type
decl_stmt|;
name|krb5_storage
modifier|*
name|in
decl_stmt|;
name|struct
name|sec_buffer
name|lm
decl_stmt|,
name|ntlm
decl_stmt|,
name|target
decl_stmt|,
name|username
decl_stmt|,
name|sessionkey
decl_stmt|,
name|ws
decl_stmt|;
name|memset
argument_list|(
name|type3
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|type3
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sessionkey
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sessionkey
argument_list|)
argument_list|)
expr_stmt|;
name|in
operator|=
name|krb5_storage_from_readonly_mem
argument_list|(
name|buf
operator|->
name|data
argument_list|,
name|buf
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|in
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|krb5_storage_set_byteorder
argument_list|(
name|in
argument_list|,
name|KRB5_STORAGE_BYTEORDER_LE
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_storage_read
argument_list|(
name|in
argument_list|,
name|sig
argument_list|,
sizeof|sizeof
argument_list|(
name|sig
argument_list|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|sig
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|memcmp
argument_list|(
name|ntlmsigature
argument_list|,
name|sig
argument_list|,
sizeof|sizeof
argument_list|(
name|ntlmsigature
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_ret_uint32
argument_list|(
name|in
argument_list|,
operator|&
name|type
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|type
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|ret_sec_buffer
argument_list|(
name|in
argument_list|,
operator|&
name|lm
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|ret_sec_buffer
argument_list|(
name|in
argument_list|,
operator|&
name|ntlm
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|ret_sec_buffer
argument_list|(
name|in
argument_list|,
operator|&
name|target
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|ret_sec_buffer
argument_list|(
name|in
argument_list|,
operator|&
name|username
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|ret_sec_buffer
argument_list|(
name|in
argument_list|,
operator|&
name|ws
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|lm
operator|.
name|offset
operator|>=
literal|60
condition|)
block|{
name|CHECK
argument_list|(
name|ret_sec_buffer
argument_list|(
name|in
argument_list|,
operator|&
name|sessionkey
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lm
operator|.
name|offset
operator|>=
literal|64
condition|)
block|{
name|CHECK
argument_list|(
name|krb5_ret_uint32
argument_list|(
name|in
argument_list|,
operator|&
name|type3
operator|->
name|flags
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lm
operator|.
name|offset
operator|>=
literal|72
condition|)
block|{
name|CHECK
argument_list|(
name|krb5_ret_uint32
argument_list|(
name|in
argument_list|,
operator|&
name|type3
operator|->
name|os
index|[
literal|0
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_ret_uint32
argument_list|(
name|in
argument_list|,
operator|&
name|type3
operator|->
name|os
index|[
literal|1
index|]
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|CHECK
argument_list|(
name|ret_buf
argument_list|(
name|in
argument_list|,
operator|&
name|lm
argument_list|,
operator|&
name|type3
operator|->
name|lm
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|ret_buf
argument_list|(
name|in
argument_list|,
operator|&
name|ntlm
argument_list|,
operator|&
name|type3
operator|->
name|ntlm
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|ret_string
argument_list|(
name|in
argument_list|,
name|ucs2
argument_list|,
operator|&
name|target
argument_list|,
operator|&
name|type3
operator|->
name|targetname
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|ret_string
argument_list|(
name|in
argument_list|,
name|ucs2
argument_list|,
operator|&
name|username
argument_list|,
operator|&
name|type3
operator|->
name|username
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|ret_string
argument_list|(
name|in
argument_list|,
name|ucs2
argument_list|,
operator|&
name|ws
argument_list|,
operator|&
name|type3
operator|->
name|ws
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sessionkey
operator|.
name|offset
condition|)
name|CHECK
argument_list|(
name|ret_buf
argument_list|(
name|in
argument_list|,
operator|&
name|sessionkey
argument_list|,
operator|&
name|type3
operator|->
name|sessionkey
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
label|:
name|krb5_storage_free
argument_list|(
name|in
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|heim_ntlm_free_type3
argument_list|(
name|type3
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Encodes an ntlm_type3 message.  *  * @param type3 the ntlm_type3 message to encode.  * @param data is the return buffer with the encoded message, should be  * freed with heim_ntlm_free_buf().  *  * @return In case of success 0 is return, an errors, a errno in what  * went wrong.  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|int
name|heim_ntlm_encode_type3
parameter_list|(
specifier|const
name|struct
name|ntlm_type3
modifier|*
name|type3
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|sec_buffer
name|lm
decl_stmt|,
name|ntlm
decl_stmt|,
name|target
decl_stmt|,
name|username
decl_stmt|,
name|sessionkey
decl_stmt|,
name|ws
decl_stmt|;
name|krb5_error_code
name|ret
decl_stmt|;
name|krb5_storage
modifier|*
name|out
init|=
name|NULL
decl_stmt|;
name|uint32_t
name|base
decl_stmt|;
name|int
name|ucs2
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
operator|&
name|lm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|lm
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ntlm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ntlm
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|target
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|username
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|username
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ws
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ws
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sessionkey
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sessionkey
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|=
literal|52
expr_stmt|;
if|if
condition|(
name|type3
operator|->
name|sessionkey
operator|.
name|length
condition|)
block|{
name|base
operator|+=
literal|8
expr_stmt|;
comment|/* sessionkey sec buf */
name|base
operator|+=
literal|4
expr_stmt|;
comment|/* flags */
block|}
if|if
condition|(
name|type3
operator|->
name|os
index|[
literal|0
index|]
condition|)
block|{
name|base
operator|+=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|type3
operator|->
name|flags
operator|&
name|NTLM_NEG_UNICODE
condition|)
name|ucs2
operator|=
literal|1
expr_stmt|;
name|lm
operator|.
name|offset
operator|=
name|base
expr_stmt|;
name|lm
operator|.
name|length
operator|=
name|type3
operator|->
name|lm
operator|.
name|length
expr_stmt|;
name|lm
operator|.
name|allocated
operator|=
name|type3
operator|->
name|lm
operator|.
name|length
expr_stmt|;
name|ntlm
operator|.
name|offset
operator|=
name|lm
operator|.
name|offset
operator|+
name|lm
operator|.
name|allocated
expr_stmt|;
name|ntlm
operator|.
name|length
operator|=
name|type3
operator|->
name|ntlm
operator|.
name|length
expr_stmt|;
name|ntlm
operator|.
name|allocated
operator|=
name|ntlm
operator|.
name|length
expr_stmt|;
name|target
operator|.
name|offset
operator|=
name|ntlm
operator|.
name|offset
operator|+
name|ntlm
operator|.
name|allocated
expr_stmt|;
name|target
operator|.
name|length
operator|=
name|len_string
argument_list|(
name|ucs2
argument_list|,
name|type3
operator|->
name|targetname
argument_list|)
expr_stmt|;
name|target
operator|.
name|allocated
operator|=
name|target
operator|.
name|length
expr_stmt|;
name|username
operator|.
name|offset
operator|=
name|target
operator|.
name|offset
operator|+
name|target
operator|.
name|allocated
expr_stmt|;
name|username
operator|.
name|length
operator|=
name|len_string
argument_list|(
name|ucs2
argument_list|,
name|type3
operator|->
name|username
argument_list|)
expr_stmt|;
name|username
operator|.
name|allocated
operator|=
name|username
operator|.
name|length
expr_stmt|;
name|ws
operator|.
name|offset
operator|=
name|username
operator|.
name|offset
operator|+
name|username
operator|.
name|allocated
expr_stmt|;
name|ws
operator|.
name|length
operator|=
name|len_string
argument_list|(
name|ucs2
argument_list|,
name|type3
operator|->
name|ws
argument_list|)
expr_stmt|;
name|ws
operator|.
name|allocated
operator|=
name|ws
operator|.
name|length
expr_stmt|;
name|sessionkey
operator|.
name|offset
operator|=
name|ws
operator|.
name|offset
operator|+
name|ws
operator|.
name|allocated
expr_stmt|;
name|sessionkey
operator|.
name|length
operator|=
name|type3
operator|->
name|sessionkey
operator|.
name|length
expr_stmt|;
name|sessionkey
operator|.
name|allocated
operator|=
name|type3
operator|->
name|sessionkey
operator|.
name|length
expr_stmt|;
name|out
operator|=
name|krb5_storage_emem
argument_list|()
expr_stmt|;
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|krb5_storage_set_byteorder
argument_list|(
name|out
argument_list|,
name|KRB5_STORAGE_BYTEORDER_LE
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_storage_write
argument_list|(
name|out
argument_list|,
name|ntlmsigature
argument_list|,
sizeof|sizeof
argument_list|(
name|ntlmsigature
argument_list|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ntlmsigature
argument_list|)
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint32
argument_list|(
name|out
argument_list|,
literal|3
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|store_sec_buffer
argument_list|(
name|out
argument_list|,
operator|&
name|lm
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|store_sec_buffer
argument_list|(
name|out
argument_list|,
operator|&
name|ntlm
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|store_sec_buffer
argument_list|(
name|out
argument_list|,
operator|&
name|target
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|store_sec_buffer
argument_list|(
name|out
argument_list|,
operator|&
name|username
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|store_sec_buffer
argument_list|(
name|out
argument_list|,
operator|&
name|ws
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* optional */
if|if
condition|(
name|type3
operator|->
name|sessionkey
operator|.
name|length
condition|)
block|{
name|CHECK
argument_list|(
name|store_sec_buffer
argument_list|(
name|out
argument_list|,
operator|&
name|sessionkey
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint32
argument_list|(
name|out
argument_list|,
name|type3
operator|->
name|flags
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|CHECK(krb5_store_uint32(out, 0), 0);
comment|/* os0 */
block|CHECK(krb5_store_uint32(out, 0), 0);
comment|/* os1 */
endif|#
directive|endif
name|CHECK
argument_list|(
name|put_buf
argument_list|(
name|out
argument_list|,
operator|&
name|type3
operator|->
name|lm
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|put_buf
argument_list|(
name|out
argument_list|,
operator|&
name|type3
operator|->
name|ntlm
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|put_string
argument_list|(
name|out
argument_list|,
name|ucs2
argument_list|,
name|type3
operator|->
name|targetname
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|put_string
argument_list|(
name|out
argument_list|,
name|ucs2
argument_list|,
name|type3
operator|->
name|username
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|put_string
argument_list|(
name|out
argument_list|,
name|ucs2
argument_list|,
name|type3
operator|->
name|ws
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|put_buf
argument_list|(
name|out
argument_list|,
operator|&
name|type3
operator|->
name|sessionkey
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|{
name|krb5_data
name|d
decl_stmt|;
name|ret
operator|=
name|krb5_storage_to_data
argument_list|(
name|out
argument_list|,
operator|&
name|d
argument_list|)
expr_stmt|;
name|data
operator|->
name|data
operator|=
name|d
operator|.
name|data
expr_stmt|;
name|data
operator|->
name|length
operator|=
name|d
operator|.
name|length
expr_stmt|;
block|}
name|out
label|:
name|krb5_storage_free
argument_list|(
name|out
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|void
name|splitandenc
parameter_list|(
name|unsigned
name|char
modifier|*
name|hash
parameter_list|,
name|unsigned
name|char
modifier|*
name|challange
parameter_list|,
name|unsigned
name|char
modifier|*
name|answer
parameter_list|)
block|{
name|DES_cblock
name|key
decl_stmt|;
name|DES_key_schedule
name|sched
decl_stmt|;
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|key
operator|)
index|[
literal|0
index|]
operator|=
name|hash
index|[
literal|0
index|]
expr_stmt|;
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|key
operator|)
index|[
literal|1
index|]
operator|=
operator|(
name|hash
index|[
literal|0
index|]
operator|<<
literal|7
operator|)
operator||
operator|(
name|hash
index|[
literal|1
index|]
operator|>>
literal|1
operator|)
expr_stmt|;
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|key
operator|)
index|[
literal|2
index|]
operator|=
operator|(
name|hash
index|[
literal|1
index|]
operator|<<
literal|6
operator|)
operator||
operator|(
name|hash
index|[
literal|2
index|]
operator|>>
literal|2
operator|)
expr_stmt|;
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|key
operator|)
index|[
literal|3
index|]
operator|=
operator|(
name|hash
index|[
literal|2
index|]
operator|<<
literal|5
operator|)
operator||
operator|(
name|hash
index|[
literal|3
index|]
operator|>>
literal|3
operator|)
expr_stmt|;
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|key
operator|)
index|[
literal|4
index|]
operator|=
operator|(
name|hash
index|[
literal|3
index|]
operator|<<
literal|4
operator|)
operator||
operator|(
name|hash
index|[
literal|4
index|]
operator|>>
literal|4
operator|)
expr_stmt|;
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|key
operator|)
index|[
literal|5
index|]
operator|=
operator|(
name|hash
index|[
literal|4
index|]
operator|<<
literal|3
operator|)
operator||
operator|(
name|hash
index|[
literal|5
index|]
operator|>>
literal|5
operator|)
expr_stmt|;
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|key
operator|)
index|[
literal|6
index|]
operator|=
operator|(
name|hash
index|[
literal|5
index|]
operator|<<
literal|2
operator|)
operator||
operator|(
name|hash
index|[
literal|6
index|]
operator|>>
literal|6
operator|)
expr_stmt|;
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|key
operator|)
index|[
literal|7
index|]
operator|=
operator|(
name|hash
index|[
literal|6
index|]
operator|<<
literal|1
operator|)
expr_stmt|;
name|DES_set_odd_parity
argument_list|(
operator|&
name|key
argument_list|)
expr_stmt|;
name|DES_set_key
argument_list|(
operator|&
name|key
argument_list|,
operator|&
name|sched
argument_list|)
expr_stmt|;
name|DES_ecb_encrypt
argument_list|(
operator|(
name|DES_cblock
operator|*
operator|)
name|challange
argument_list|,
operator|(
name|DES_cblock
operator|*
operator|)
name|answer
argument_list|,
operator|&
name|sched
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sched
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sched
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Calculate the NTLM key, the password is assumed to be in UTF8.  *  * @param password password to calcute the key for.  * @param key calcuted key, should be freed with heim_ntlm_free_buf().  *  * @return In case of success 0 is return, an errors, a errno in what  * went wrong.  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|int
name|heim_ntlm_nt_key
parameter_list|(
specifier|const
name|char
modifier|*
name|password
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|key
parameter_list|)
block|{
name|struct
name|ntlm_buf
name|buf
decl_stmt|;
name|MD4_CTX
name|ctx
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|key
operator|->
name|data
operator|=
name|malloc
argument_list|(
name|MD5_DIGEST_LENGTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|data
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|key
operator|->
name|length
operator|=
name|MD5_DIGEST_LENGTH
expr_stmt|;
name|ret
operator|=
name|ascii2ucs2le
argument_list|(
name|password
argument_list|,
literal|0
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
name|heim_ntlm_free_buf
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
name|MD4_Init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|MD4_Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|buf
operator|.
name|data
argument_list|,
name|buf
operator|.
name|length
argument_list|)
expr_stmt|;
name|MD4_Final
argument_list|(
name|key
operator|->
name|data
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|heim_ntlm_free_buf
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Calculate NTLMv1 response hash  *  * @param key the ntlm v1 key  * @param len length of key  * @param challange sent by the server  * @param answer calculated answer, should be freed with heim_ntlm_free_buf().  *  * @return In case of success 0 is return, an errors, a errno in what  * went wrong.  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|int
name|heim_ntlm_calculate_ntlm1
parameter_list|(
name|void
modifier|*
name|key
parameter_list|,
name|size_t
name|len
parameter_list|,
name|unsigned
name|char
name|challange
index|[
literal|8
index|]
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|answer
parameter_list|)
block|{
name|unsigned
name|char
name|res
index|[
literal|21
index|]
decl_stmt|;
if|if
condition|(
name|len
operator|!=
name|MD4_DIGEST_LENGTH
condition|)
return|return
name|EINVAL
return|;
name|memcpy
argument_list|(
name|res
argument_list|,
name|key
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|res
index|[
name|MD4_DIGEST_LENGTH
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|res
argument_list|)
operator|-
name|MD4_DIGEST_LENGTH
argument_list|)
expr_stmt|;
name|answer
operator|->
name|data
operator|=
name|malloc
argument_list|(
literal|24
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|->
name|data
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|answer
operator|->
name|length
operator|=
literal|24
expr_stmt|;
name|splitandenc
argument_list|(
operator|&
name|res
index|[
literal|0
index|]
argument_list|,
name|challange
argument_list|,
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|answer
operator|->
name|data
operator|)
operator|+
literal|0
argument_list|)
expr_stmt|;
name|splitandenc
argument_list|(
operator|&
name|res
index|[
literal|7
index|]
argument_list|,
name|challange
argument_list|,
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|answer
operator|->
name|data
operator|)
operator|+
literal|8
argument_list|)
expr_stmt|;
name|splitandenc
argument_list|(
operator|&
name|res
index|[
literal|14
index|]
argument_list|,
name|challange
argument_list|,
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|answer
operator|->
name|data
operator|)
operator|+
literal|16
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Generates an NTLMv1 session random with assosited session master key.  *  * @param key the ntlm v1 key  * @param len length of key  * @param session generated session nonce, should be freed with heim_ntlm_free_buf().  * @param master calculated session master key, should be freed with heim_ntlm_free_buf().  *  * @return In case of success 0 is return, an errors, a errno in what  * went wrong.  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|int
name|heim_ntlm_build_ntlm1_master
parameter_list|(
name|void
modifier|*
name|key
parameter_list|,
name|size_t
name|len
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|session
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|master
parameter_list|)
block|{
name|RC4_KEY
name|rc4
decl_stmt|;
name|memset
argument_list|(
name|master
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|master
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|session
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|session
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|MD4_DIGEST_LENGTH
condition|)
return|return
name|EINVAL
return|;
name|session
operator|->
name|length
operator|=
name|MD4_DIGEST_LENGTH
expr_stmt|;
name|session
operator|->
name|data
operator|=
name|malloc
argument_list|(
name|session
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|session
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|session
operator|->
name|length
operator|=
literal|0
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|master
operator|->
name|length
operator|=
name|MD4_DIGEST_LENGTH
expr_stmt|;
name|master
operator|->
name|data
operator|=
name|malloc
argument_list|(
name|master
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|master
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|heim_ntlm_free_buf
argument_list|(
name|master
argument_list|)
expr_stmt|;
name|heim_ntlm_free_buf
argument_list|(
name|session
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
block|{
name|unsigned
name|char
name|sessionkey
index|[
name|MD4_DIGEST_LENGTH
index|]
decl_stmt|;
name|MD4_CTX
name|ctx
decl_stmt|;
name|MD4_Init
argument_list|(
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|MD4_Update
argument_list|(
operator|&
name|ctx
argument_list|,
name|key
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|MD4_Final
argument_list|(
name|sessionkey
argument_list|,
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|RC4_set_key
argument_list|(
operator|&
name|rc4
argument_list|,
sizeof|sizeof
argument_list|(
name|sessionkey
argument_list|)
argument_list|,
name|sessionkey
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|RAND_bytes
argument_list|(
name|session
operator|->
name|data
argument_list|,
name|session
operator|->
name|length
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|heim_ntlm_free_buf
argument_list|(
name|master
argument_list|)
expr_stmt|;
name|heim_ntlm_free_buf
argument_list|(
name|session
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
name|RC4
argument_list|(
operator|&
name|rc4
argument_list|,
name|master
operator|->
name|length
argument_list|,
name|session
operator|->
name|data
argument_list|,
name|master
operator|->
name|data
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|rc4
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rc4
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Generates an NTLMv2 session key.  *  * @param key the ntlm key  * @param len length of key  * @param username name of the user, as sent in the message, assumed to be in UTF8.  * @param target the name of the target, assumed to be in UTF8.  * @param ntlmv2 the ntlmv2 session key  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|void
name|heim_ntlm_ntlmv2_key
parameter_list|(
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|username
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
name|unsigned
name|char
name|ntlmv2
index|[
literal|16
index|]
parameter_list|)
block|{
name|unsigned
name|int
name|hmaclen
decl_stmt|;
name|HMAC_CTX
name|c
decl_stmt|;
name|HMAC_CTX_init
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|HMAC_Init_ex
argument_list|(
operator|&
name|c
argument_list|,
name|key
argument_list|,
name|len
argument_list|,
name|EVP_md5
argument_list|()
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|{
name|struct
name|ntlm_buf
name|buf
decl_stmt|;
comment|/* uppercase username and turn it inte ucs2-le */
name|ascii2ucs2le
argument_list|(
name|username
argument_list|,
literal|1
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
name|HMAC_Update
argument_list|(
operator|&
name|c
argument_list|,
name|buf
operator|.
name|data
argument_list|,
name|buf
operator|.
name|length
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
operator|.
name|data
argument_list|)
expr_stmt|;
comment|/* uppercase target and turn into ucs2-le */
name|ascii2ucs2le
argument_list|(
name|target
argument_list|,
literal|1
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
name|HMAC_Update
argument_list|(
operator|&
name|c
argument_list|,
name|buf
operator|.
name|data
argument_list|,
name|buf
operator|.
name|length
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
operator|.
name|data
argument_list|)
expr_stmt|;
block|}
name|HMAC_Final
argument_list|(
operator|&
name|c
argument_list|,
name|ntlmv2
argument_list|,
operator|&
name|hmaclen
argument_list|)
expr_stmt|;
name|HMAC_CTX_cleanup
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_define
define|#
directive|define
name|NTTIME_EPOCH
value|0x019DB1DED53E8000LL
end_define

begin_function
specifier|static
name|uint64_t
name|unix2nttime
parameter_list|(
name|time_t
name|unix_time
parameter_list|)
block|{
name|long
name|long
name|wt
decl_stmt|;
name|wt
operator|=
name|unix_time
operator|*
operator|(
name|uint64_t
operator|)
literal|10000000
operator|+
operator|(
name|uint64_t
operator|)
name|NTTIME_EPOCH
expr_stmt|;
return|return
name|wt
return|;
block|}
end_function

begin_function
specifier|static
name|time_t
name|nt2unixtime
parameter_list|(
name|uint64_t
name|t
parameter_list|)
block|{
name|t
operator|=
operator|(
operator|(
name|t
operator|-
operator|(
name|uint64_t
operator|)
name|NTTIME_EPOCH
operator|)
operator|/
operator|(
name|uint64_t
operator|)
literal|10000000
operator|)
expr_stmt|;
if|if
condition|(
name|t
operator|>
operator|(
operator|(
call|(
name|time_t
call|)
argument_list|(
operator|~
operator|(
name|uint64_t
operator|)
literal|0
argument_list|)
operator|)
operator|>>
literal|1
operator|)
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|time_t
operator|)
name|t
return|;
block|}
end_function

begin_comment
comment|/**  * Calculate NTLMv2 response  *  * @param key the ntlm key  * @param len length of key  * @param username name of the user, as sent in the message, assumed to be in UTF8.  * @param target the name of the target, assumed to be in UTF8.  * @param serverchallange challange as sent by the server in the type2 message.  * @param infotarget infotarget as sent by the server in the type2 message.  * @param ntlmv2 calculated session key  * @param answer ntlm response answer, should be freed with heim_ntlm_free_buf().  *  * @return In case of success 0 is return, an errors, a errno in what  * went wrong.  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|int
name|heim_ntlm_calculate_ntlm2
parameter_list|(
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|username
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
specifier|const
name|unsigned
name|char
name|serverchallange
index|[
literal|8
index|]
parameter_list|,
specifier|const
name|struct
name|ntlm_buf
modifier|*
name|infotarget
parameter_list|,
name|unsigned
name|char
name|ntlmv2
index|[
literal|16
index|]
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|answer
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|krb5_data
name|data
decl_stmt|;
name|unsigned
name|int
name|hmaclen
decl_stmt|;
name|unsigned
name|char
name|ntlmv2answer
index|[
literal|16
index|]
decl_stmt|;
name|krb5_storage
modifier|*
name|sp
decl_stmt|;
name|unsigned
name|char
name|clientchallange
index|[
literal|8
index|]
decl_stmt|;
name|HMAC_CTX
name|c
decl_stmt|;
name|uint64_t
name|t
decl_stmt|;
name|t
operator|=
name|unix2nttime
argument_list|(
name|time
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|RAND_bytes
argument_list|(
name|clientchallange
argument_list|,
sizeof|sizeof
argument_list|(
name|clientchallange
argument_list|)
argument_list|)
operator|!=
literal|1
condition|)
return|return
name|EINVAL
return|;
comment|/* calculate ntlmv2 key */
name|heim_ntlm_ntlmv2_key
argument_list|(
name|key
argument_list|,
name|len
argument_list|,
name|username
argument_list|,
name|target
argument_list|,
name|ntlmv2
argument_list|)
expr_stmt|;
comment|/* calculate and build ntlmv2 answer */
name|sp
operator|=
name|krb5_storage_emem
argument_list|()
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|krb5_storage_set_flags
argument_list|(
name|sp
argument_list|,
name|KRB5_STORAGE_BYTEORDER_LE
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint32
argument_list|(
name|sp
argument_list|,
literal|0x00000101
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint32
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* timestamp le 64 bit ts */
name|CHECK
argument_list|(
name|krb5_store_uint32
argument_list|(
name|sp
argument_list|,
name|t
operator|&
literal|0xffffffff
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint32
argument_list|(
name|sp
argument_list|,
name|t
operator|>>
literal|32
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_storage_write
argument_list|(
name|sp
argument_list|,
name|clientchallange
argument_list|,
literal|8
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint32
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* unknown but zero will work */
name|CHECK
argument_list|(
name|krb5_storage_write
argument_list|(
name|sp
argument_list|,
name|infotarget
operator|->
name|data
argument_list|,
name|infotarget
operator|->
name|length
argument_list|)
argument_list|,
name|infotarget
operator|->
name|length
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_store_uint32
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* unknown but zero will work */
name|CHECK
argument_list|(
name|krb5_storage_to_data
argument_list|(
name|sp
argument_list|,
operator|&
name|data
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|krb5_storage_free
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|=
name|NULL
expr_stmt|;
name|HMAC_CTX_init
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|HMAC_Init_ex
argument_list|(
operator|&
name|c
argument_list|,
name|ntlmv2
argument_list|,
literal|16
argument_list|,
name|EVP_md5
argument_list|()
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|HMAC_Update
argument_list|(
operator|&
name|c
argument_list|,
name|serverchallange
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|HMAC_Update
argument_list|(
operator|&
name|c
argument_list|,
name|data
operator|.
name|data
argument_list|,
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|HMAC_Final
argument_list|(
operator|&
name|c
argument_list|,
name|ntlmv2answer
argument_list|,
operator|&
name|hmaclen
argument_list|)
expr_stmt|;
name|HMAC_CTX_cleanup
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|sp
operator|=
name|krb5_storage_emem
argument_list|()
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
name|krb5_data_free
argument_list|(
operator|&
name|data
argument_list|)
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|CHECK
argument_list|(
name|krb5_storage_write
argument_list|(
name|sp
argument_list|,
name|ntlmv2answer
argument_list|,
literal|16
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_storage_write
argument_list|(
name|sp
argument_list|,
name|data
operator|.
name|data
argument_list|,
name|data
operator|.
name|length
argument_list|)
argument_list|,
name|data
operator|.
name|length
argument_list|)
expr_stmt|;
name|krb5_data_free
argument_list|(
operator|&
name|data
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_storage_to_data
argument_list|(
name|sp
argument_list|,
operator|&
name|data
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|krb5_storage_free
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|=
name|NULL
expr_stmt|;
name|answer
operator|->
name|data
operator|=
name|data
operator|.
name|data
expr_stmt|;
name|answer
operator|->
name|length
operator|=
name|data
operator|.
name|length
expr_stmt|;
return|return
literal|0
return|;
name|out
label|:
if|if
condition|(
name|sp
condition|)
name|krb5_storage_free
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|int
name|authtimediff
init|=
literal|3600
operator|*
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 2 hours */
end_comment

begin_comment
comment|/**  * Verify NTLMv2 response.  *  * @param key the ntlm key  * @param len length of key  * @param username name of the user, as sent in the message, assumed to be in UTF8.  * @param target the name of the target, assumed to be in UTF8.  * @param now the time now (0 if the library should pick it up itself)  * @param serverchallange challange as sent by the server in the type2 message.  * @param answer ntlm response answer, should be freed with heim_ntlm_free_buf().  * @param infotarget infotarget as sent by the server in the type2 message.  * @param ntlmv2 calculated session key  *  * @return In case of success 0 is return, an errors, a errno in what  * went wrong.  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|int
name|heim_ntlm_verify_ntlm2
parameter_list|(
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|size_t
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|username
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
name|time_t
name|now
parameter_list|,
specifier|const
name|unsigned
name|char
name|serverchallange
index|[
literal|8
index|]
parameter_list|,
specifier|const
name|struct
name|ntlm_buf
modifier|*
name|answer
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|infotarget
parameter_list|,
name|unsigned
name|char
name|ntlmv2
index|[
literal|16
index|]
parameter_list|)
block|{
name|krb5_error_code
name|ret
decl_stmt|;
name|unsigned
name|int
name|hmaclen
decl_stmt|;
name|unsigned
name|char
name|clientanswer
index|[
literal|16
index|]
decl_stmt|;
name|unsigned
name|char
name|clientnonce
index|[
literal|8
index|]
decl_stmt|;
name|unsigned
name|char
name|serveranswer
index|[
literal|16
index|]
decl_stmt|;
name|krb5_storage
modifier|*
name|sp
decl_stmt|;
name|HMAC_CTX
name|c
decl_stmt|;
name|uint64_t
name|t
decl_stmt|;
name|time_t
name|authtime
decl_stmt|;
name|uint32_t
name|temp
decl_stmt|;
name|infotarget
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|infotarget
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|answer
operator|->
name|length
operator|<
literal|16
condition|)
return|return
name|EINVAL
return|;
if|if
condition|(
name|now
operator|==
literal|0
condition|)
name|now
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* calculate ntlmv2 key */
name|heim_ntlm_ntlmv2_key
argument_list|(
name|key
argument_list|,
name|len
argument_list|,
name|username
argument_list|,
name|target
argument_list|,
name|ntlmv2
argument_list|)
expr_stmt|;
comment|/* calculate and build ntlmv2 answer */
name|sp
operator|=
name|krb5_storage_from_readonly_mem
argument_list|(
name|answer
operator|->
name|data
argument_list|,
name|answer
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|krb5_storage_set_flags
argument_list|(
name|sp
argument_list|,
name|KRB5_STORAGE_BYTEORDER_LE
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_storage_read
argument_list|(
name|sp
argument_list|,
name|clientanswer
argument_list|,
literal|16
argument_list|)
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_ret_uint32
argument_list|(
name|sp
argument_list|,
operator|&
name|temp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|temp
argument_list|,
literal|0x00000101
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_ret_uint32
argument_list|(
name|sp
argument_list|,
operator|&
name|temp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|temp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* timestamp le 64 bit ts */
name|CHECK
argument_list|(
name|krb5_ret_uint32
argument_list|(
name|sp
argument_list|,
operator|&
name|temp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator|=
name|temp
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_ret_uint32
argument_list|(
name|sp
argument_list|,
operator|&
name|temp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|t
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|temp
operator|)
operator|<<
literal|32
expr_stmt|;
name|authtime
operator|=
name|nt2unixtime
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|abs
argument_list|(
call|(
name|int
call|)
argument_list|(
name|authtime
operator|-
name|now
argument_list|)
argument_list|)
operator|>
name|authtimediff
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* client challange */
name|CHECK
argument_list|(
name|krb5_storage_read
argument_list|(
name|sp
argument_list|,
name|clientnonce
argument_list|,
literal|8
argument_list|)
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|krb5_ret_uint32
argument_list|(
name|sp
argument_list|,
operator|&
name|temp
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* unknown */
comment|/* should really unparse the infotarget, but lets pick up everything */
name|infotarget
operator|->
name|length
operator|=
name|answer
operator|->
name|length
operator|-
name|krb5_storage_seek
argument_list|(
name|sp
argument_list|,
literal|0
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
name|infotarget
operator|->
name|data
operator|=
name|malloc
argument_list|(
name|infotarget
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|infotarget
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|CHECK
argument_list|(
name|krb5_storage_read
argument_list|(
name|sp
argument_list|,
name|infotarget
operator|->
name|data
argument_list|,
name|infotarget
operator|->
name|length
argument_list|)
argument_list|,
name|infotarget
operator|->
name|length
argument_list|)
expr_stmt|;
comment|/* XXX remove the unknown ?? */
name|krb5_storage_free
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
operator|=
name|NULL
expr_stmt|;
name|HMAC_CTX_init
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
name|HMAC_Init_ex
argument_list|(
operator|&
name|c
argument_list|,
name|ntlmv2
argument_list|,
literal|16
argument_list|,
name|EVP_md5
argument_list|()
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|HMAC_Update
argument_list|(
operator|&
name|c
argument_list|,
name|serverchallange
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|HMAC_Update
argument_list|(
operator|&
name|c
argument_list|,
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|answer
operator|->
name|data
operator|)
operator|+
literal|16
argument_list|,
name|answer
operator|->
name|length
operator|-
literal|16
argument_list|)
expr_stmt|;
name|HMAC_Final
argument_list|(
operator|&
name|c
argument_list|,
name|serveranswer
argument_list|,
operator|&
name|hmaclen
argument_list|)
expr_stmt|;
name|HMAC_CTX_cleanup
argument_list|(
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|serveranswer
argument_list|,
name|clientanswer
argument_list|,
literal|16
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|heim_ntlm_free_buf
argument_list|(
name|infotarget
argument_list|)
expr_stmt|;
return|return
name|EINVAL
return|;
block|}
return|return
literal|0
return|;
name|out
label|:
name|heim_ntlm_free_buf
argument_list|(
name|infotarget
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
condition|)
name|krb5_storage_free
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate the NTLM2 Session Response  *  * @param clnt_nonce client nonce  * @param svr_chal server challage  * @param ntlm2_hash ntlm hash  * @param lm The LM response, should be freed with heim_ntlm_free_buf().  * @param ntlm The NTLM response, should be freed with heim_ntlm_free_buf().  *  * @return In case of success 0 is return, an errors, a errno in what  * went wrong.  *  * @ingroup ntlm_core  */
end_comment

begin_function
name|int
name|heim_ntlm_calculate_ntlm2_sess
parameter_list|(
specifier|const
name|unsigned
name|char
name|clnt_nonce
index|[
literal|8
index|]
parameter_list|,
specifier|const
name|unsigned
name|char
name|svr_chal
index|[
literal|8
index|]
parameter_list|,
specifier|const
name|unsigned
name|char
name|ntlm_hash
index|[
literal|16
index|]
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|lm
parameter_list|,
name|struct
name|ntlm_buf
modifier|*
name|ntlm
parameter_list|)
block|{
name|unsigned
name|char
name|ntlm2_sess_hash
index|[
name|MD5_DIGEST_LENGTH
index|]
decl_stmt|;
name|unsigned
name|char
name|res
index|[
literal|21
index|]
decl_stmt|,
modifier|*
name|resp
decl_stmt|;
name|MD5_CTX
name|md5
decl_stmt|;
name|lm
operator|->
name|data
operator|=
name|malloc
argument_list|(
literal|24
argument_list|)
expr_stmt|;
if|if
condition|(
name|lm
operator|->
name|data
operator|==
name|NULL
condition|)
return|return
name|ENOMEM
return|;
name|lm
operator|->
name|length
operator|=
literal|24
expr_stmt|;
name|ntlm
operator|->
name|data
operator|=
name|malloc
argument_list|(
literal|24
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntlm
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|lm
operator|->
name|data
argument_list|)
expr_stmt|;
name|lm
operator|->
name|data
operator|=
name|NULL
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|ntlm
operator|->
name|length
operator|=
literal|24
expr_stmt|;
comment|/* first setup the lm resp */
name|memset
argument_list|(
name|lm
operator|->
name|data
argument_list|,
literal|0
argument_list|,
literal|24
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|lm
operator|->
name|data
argument_list|,
name|clnt_nonce
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|MD5_Init
argument_list|(
operator|&
name|md5
argument_list|)
expr_stmt|;
name|MD5_Update
argument_list|(
operator|&
name|md5
argument_list|,
name|svr_chal
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* session nonce part 1 */
name|MD5_Update
argument_list|(
operator|&
name|md5
argument_list|,
name|clnt_nonce
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* session nonce part 2 */
name|MD5_Final
argument_list|(
name|ntlm2_sess_hash
argument_list|,
operator|&
name|md5
argument_list|)
expr_stmt|;
comment|/* will only use first 8 bytes */
name|memset
argument_list|(
name|res
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|res
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|res
argument_list|,
name|ntlm_hash
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|resp
operator|=
name|ntlm
operator|->
name|data
expr_stmt|;
name|splitandenc
argument_list|(
operator|&
name|res
index|[
literal|0
index|]
argument_list|,
name|ntlm2_sess_hash
argument_list|,
name|resp
operator|+
literal|0
argument_list|)
expr_stmt|;
name|splitandenc
argument_list|(
operator|&
name|res
index|[
literal|7
index|]
argument_list|,
name|ntlm2_sess_hash
argument_list|,
name|resp
operator|+
literal|8
argument_list|)
expr_stmt|;
name|splitandenc
argument_list|(
operator|&
name|res
index|[
literal|14
index|]
argument_list|,
name|ntlm2_sess_hash
argument_list|,
name|resp
operator|+
literal|16
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

end_unit

