begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- LLParser.h - Parser Class -------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file defines the parser class for .ll files.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_ASMPARSER_LLPARSER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_ASMPARSER_LLPARSER_H
end_define

begin_include
include|#
directive|include
file|"LLLexer.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Module.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Type.h"
end_include

begin_include
include|#
directive|include
file|<map>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|Module
decl_stmt|;
name|class
name|OpaqueType
decl_stmt|;
name|class
name|Function
decl_stmt|;
name|class
name|Value
decl_stmt|;
name|class
name|BasicBlock
decl_stmt|;
name|class
name|Instruction
decl_stmt|;
name|class
name|Constant
decl_stmt|;
name|class
name|GlobalValue
decl_stmt|;
name|class
name|MetadataBase
decl_stmt|;
name|class
name|MDString
decl_stmt|;
name|class
name|MDNode
decl_stmt|;
struct_decl|struct
name|ValID
struct_decl|;
name|class
name|LLParser
block|{
name|public
label|:
typedef|typedef
name|LLLexer
operator|::
name|LocTy
name|LocTy
expr_stmt|;
name|private
label|:
name|LLVMContext
modifier|&
name|Context
decl_stmt|;
name|LLLexer
name|Lex
decl_stmt|;
name|Module
modifier|*
name|M
decl_stmt|;
comment|// Type resolution handling data structures.
name|std
operator|::
name|map
operator|<
name|std
operator|::
name|string
operator|,
name|std
operator|::
name|pair
operator|<
name|PATypeHolder
operator|,
name|LocTy
operator|>
expr|>
name|ForwardRefTypes
expr_stmt|;
name|std
operator|::
name|map
operator|<
name|unsigned
operator|,
name|std
operator|::
name|pair
operator|<
name|PATypeHolder
operator|,
name|LocTy
operator|>
expr|>
name|ForwardRefTypeIDs
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|PATypeHolder
operator|>
name|NumberedTypes
expr_stmt|;
comment|/// MetadataCache - This map keeps track of parsed metadata constants.
name|std
operator|::
name|map
operator|<
name|unsigned
operator|,
name|MetadataBase
operator|*
operator|>
name|MetadataCache
expr_stmt|;
name|std
operator|::
name|map
operator|<
name|unsigned
operator|,
name|std
operator|::
name|pair
operator|<
name|MetadataBase
operator|*
operator|,
name|LocTy
operator|>
expr|>
name|ForwardRefMDNodes
expr_stmt|;
name|SmallVector
operator|<
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|MDNode
operator|*
operator|>
operator|,
literal|2
operator|>
name|MDsOnInst
expr_stmt|;
struct|struct
name|UpRefRecord
block|{
comment|/// Loc - This is the location of the upref.
name|LocTy
name|Loc
decl_stmt|;
comment|/// NestingLevel - The number of nesting levels that need to be popped
comment|/// before this type is resolved.
name|unsigned
name|NestingLevel
decl_stmt|;
comment|/// LastContainedTy - This is the type at the current binding level for
comment|/// the type.  Every time we reduce the nesting level, this gets updated.
specifier|const
name|Type
modifier|*
name|LastContainedTy
decl_stmt|;
comment|/// UpRefTy - This is the actual opaque type that the upreference is
comment|/// represented with.
name|OpaqueType
modifier|*
name|UpRefTy
decl_stmt|;
name|UpRefRecord
argument_list|(
argument|LocTy L
argument_list|,
argument|unsigned NL
argument_list|,
argument|OpaqueType *URTy
argument_list|)
block|:
name|Loc
argument_list|(
name|L
argument_list|)
operator|,
name|NestingLevel
argument_list|(
name|NL
argument_list|)
operator|,
name|LastContainedTy
argument_list|(
operator|(
name|Type
operator|*
operator|)
name|URTy
argument_list|)
operator|,
name|UpRefTy
argument_list|(
argument|URTy
argument_list|)
block|{}
block|}
struct|;
name|std
operator|::
name|vector
operator|<
name|UpRefRecord
operator|>
name|UpRefs
expr_stmt|;
comment|// Global Value reference information.
name|std
operator|::
name|map
operator|<
name|std
operator|::
name|string
operator|,
name|std
operator|::
name|pair
operator|<
name|GlobalValue
operator|*
operator|,
name|LocTy
operator|>
expr|>
name|ForwardRefVals
expr_stmt|;
name|std
operator|::
name|map
operator|<
name|unsigned
operator|,
name|std
operator|::
name|pair
operator|<
name|GlobalValue
operator|*
operator|,
name|LocTy
operator|>
expr|>
name|ForwardRefValIDs
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|GlobalValue
operator|*
operator|>
name|NumberedVals
expr_stmt|;
name|Function
modifier|*
name|MallocF
decl_stmt|;
name|public
label|:
name|LLParser
argument_list|(
name|MemoryBuffer
operator|*
name|F
argument_list|,
name|SourceMgr
operator|&
name|SM
argument_list|,
name|SMDiagnostic
operator|&
name|Err
argument_list|,
name|Module
operator|*
name|m
argument_list|)
operator|:
name|Context
argument_list|(
name|m
operator|->
name|getContext
argument_list|()
argument_list|)
operator|,
name|Lex
argument_list|(
name|F
argument_list|,
name|SM
argument_list|,
name|Err
argument_list|,
name|m
operator|->
name|getContext
argument_list|()
argument_list|)
operator|,
name|M
argument_list|(
name|m
argument_list|)
operator|,
name|MallocF
argument_list|(
argument|NULL
argument_list|)
block|{}
name|bool
name|Run
argument_list|()
expr_stmt|;
name|LLVMContext
modifier|&
name|getContext
parameter_list|()
block|{
return|return
name|Context
return|;
block|}
name|private
label|:
name|bool
name|Error
argument_list|(
name|LocTy
name|L
argument_list|,
specifier|const
name|std
operator|::
name|string
operator|&
name|Msg
argument_list|)
decl|const
block|{
return|return
name|Lex
operator|.
name|Error
argument_list|(
name|L
argument_list|,
name|Msg
argument_list|)
return|;
block|}
name|bool
name|TokError
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|Msg
argument_list|)
decl|const
block|{
return|return
name|Error
argument_list|(
name|Lex
operator|.
name|getLoc
argument_list|()
argument_list|,
name|Msg
argument_list|)
return|;
block|}
comment|/// GetGlobalVal - Get a value with the specified name or ID, creating a
comment|/// forward reference record if needed.  This can return null if the value
comment|/// exists but does not have the right type.
name|GlobalValue
modifier|*
name|GetGlobalVal
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|N
argument_list|,
specifier|const
name|Type
operator|*
name|Ty
argument_list|,
name|LocTy
name|Loc
argument_list|)
decl_stmt|;
name|GlobalValue
modifier|*
name|GetGlobalVal
parameter_list|(
name|unsigned
name|ID
parameter_list|,
specifier|const
name|Type
modifier|*
name|Ty
parameter_list|,
name|LocTy
name|Loc
parameter_list|)
function_decl|;
comment|// Helper Routines.
name|bool
name|ParseToken
argument_list|(
name|lltok
operator|::
name|Kind
name|T
argument_list|,
specifier|const
name|char
operator|*
name|ErrMsg
argument_list|)
decl_stmt|;
name|bool
name|EatIfPresent
argument_list|(
name|lltok
operator|::
name|Kind
name|T
argument_list|)
block|{
if|if
condition|(
name|Lex
operator|.
name|getKind
argument_list|()
operator|!=
name|T
condition|)
return|return
name|false
return|;
name|Lex
operator|.
name|Lex
argument_list|()
expr_stmt|;
return|return
name|true
return|;
block|}
name|bool
name|ParseOptionalToken
argument_list|(
name|lltok
operator|::
name|Kind
name|T
argument_list|,
name|bool
operator|&
name|Present
argument_list|)
block|{
if|if
condition|(
name|Lex
operator|.
name|getKind
argument_list|()
operator|!=
name|T
condition|)
block|{
name|Present
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|Lex
operator|.
name|Lex
argument_list|()
expr_stmt|;
name|Present
operator|=
name|true
expr_stmt|;
block|}
return|return
name|false
return|;
block|}
name|bool
name|ParseStringConstant
argument_list|(
name|std
operator|::
name|string
operator|&
name|Result
argument_list|)
decl_stmt|;
name|bool
name|ParseUInt32
parameter_list|(
name|unsigned
modifier|&
name|Val
parameter_list|)
function_decl|;
name|bool
name|ParseUInt32
parameter_list|(
name|unsigned
modifier|&
name|Val
parameter_list|,
name|LocTy
modifier|&
name|Loc
parameter_list|)
block|{
name|Loc
operator|=
name|Lex
operator|.
name|getLoc
argument_list|()
expr_stmt|;
return|return
name|ParseUInt32
argument_list|(
name|Val
argument_list|)
return|;
block|}
name|bool
name|ParseOptionalAddrSpace
parameter_list|(
name|unsigned
modifier|&
name|AddrSpace
parameter_list|)
function_decl|;
name|bool
name|ParseOptionalAttrs
parameter_list|(
name|unsigned
modifier|&
name|Attrs
parameter_list|,
name|unsigned
name|AttrKind
parameter_list|)
function_decl|;
name|bool
name|ParseOptionalLinkage
parameter_list|(
name|unsigned
modifier|&
name|Linkage
parameter_list|,
name|bool
modifier|&
name|HasLinkage
parameter_list|)
function_decl|;
name|bool
name|ParseOptionalLinkage
parameter_list|(
name|unsigned
modifier|&
name|Linkage
parameter_list|)
block|{
name|bool
name|HasLinkage
decl_stmt|;
return|return
name|ParseOptionalLinkage
argument_list|(
name|Linkage
argument_list|,
name|HasLinkage
argument_list|)
return|;
block|}
name|bool
name|ParseOptionalVisibility
parameter_list|(
name|unsigned
modifier|&
name|Visibility
parameter_list|)
function_decl|;
name|bool
name|ParseOptionalCallingConv
argument_list|(
name|CallingConv
operator|::
name|ID
operator|&
name|CC
argument_list|)
decl_stmt|;
name|bool
name|ParseOptionalAlignment
parameter_list|(
name|unsigned
modifier|&
name|Alignment
parameter_list|)
function_decl|;
name|bool
name|ParseOptionalCustomMetadata
parameter_list|()
function_decl|;
name|bool
name|ParseOptionalInfo
parameter_list|(
name|unsigned
modifier|&
name|Alignment
parameter_list|)
function_decl|;
name|bool
name|ParseIndexList
argument_list|(
name|SmallVectorImpl
operator|<
name|unsigned
operator|>
operator|&
name|Indices
argument_list|)
decl_stmt|;
comment|// Top-Level Entities
name|bool
name|ParseTopLevelEntities
parameter_list|()
function_decl|;
name|bool
name|ValidateEndOfModule
parameter_list|()
function_decl|;
name|bool
name|ParseTargetDefinition
parameter_list|()
function_decl|;
name|bool
name|ParseDepLibs
parameter_list|()
function_decl|;
name|bool
name|ParseModuleAsm
parameter_list|()
function_decl|;
name|bool
name|ParseUnnamedType
parameter_list|()
function_decl|;
name|bool
name|ParseNamedType
parameter_list|()
function_decl|;
name|bool
name|ParseDeclare
parameter_list|()
function_decl|;
name|bool
name|ParseDefine
parameter_list|()
function_decl|;
name|bool
name|ParseGlobalType
parameter_list|(
name|bool
modifier|&
name|IsConstant
parameter_list|)
function_decl|;
name|bool
name|ParseUnnamedGlobal
parameter_list|()
function_decl|;
name|bool
name|ParseNamedGlobal
parameter_list|()
function_decl|;
name|bool
name|ParseGlobal
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|Name
argument_list|,
name|LocTy
name|Loc
argument_list|,
name|unsigned
name|Linkage
argument_list|,
name|bool
name|HasLinkage
argument_list|,
name|unsigned
name|Visibility
argument_list|)
decl_stmt|;
name|bool
name|ParseAlias
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|Name
argument_list|,
name|LocTy
name|Loc
argument_list|,
name|unsigned
name|Visibility
argument_list|)
decl_stmt|;
name|bool
name|ParseStandaloneMetadata
parameter_list|()
function_decl|;
name|bool
name|ParseNamedMetadata
parameter_list|()
function_decl|;
name|bool
name|ParseMDString
parameter_list|(
name|MetadataBase
modifier|*
modifier|&
name|S
parameter_list|)
function_decl|;
name|bool
name|ParseMDNode
parameter_list|(
name|MetadataBase
modifier|*
modifier|&
name|N
parameter_list|)
function_decl|;
comment|// Type Parsing.
name|bool
name|ParseType
parameter_list|(
name|PATypeHolder
modifier|&
name|Result
parameter_list|,
name|bool
name|AllowVoid
init|=
name|false
parameter_list|)
function_decl|;
name|bool
name|ParseType
parameter_list|(
name|PATypeHolder
modifier|&
name|Result
parameter_list|,
name|LocTy
modifier|&
name|Loc
parameter_list|,
name|bool
name|AllowVoid
init|=
name|false
parameter_list|)
block|{
name|Loc
operator|=
name|Lex
operator|.
name|getLoc
argument_list|()
expr_stmt|;
return|return
name|ParseType
argument_list|(
name|Result
argument_list|,
name|AllowVoid
argument_list|)
return|;
block|}
name|bool
name|ParseTypeRec
parameter_list|(
name|PATypeHolder
modifier|&
name|H
parameter_list|)
function_decl|;
name|bool
name|ParseStructType
parameter_list|(
name|PATypeHolder
modifier|&
name|H
parameter_list|,
name|bool
name|Packed
parameter_list|)
function_decl|;
name|bool
name|ParseArrayVectorType
parameter_list|(
name|PATypeHolder
modifier|&
name|H
parameter_list|,
name|bool
name|isVector
parameter_list|)
function_decl|;
name|bool
name|ParseFunctionType
parameter_list|(
name|PATypeHolder
modifier|&
name|Result
parameter_list|)
function_decl|;
name|PATypeHolder
name|HandleUpRefs
parameter_list|(
specifier|const
name|Type
modifier|*
name|Ty
parameter_list|)
function_decl|;
comment|// Constants.
name|bool
name|ParseValID
parameter_list|(
name|ValID
modifier|&
name|ID
parameter_list|)
function_decl|;
name|bool
name|ConvertGlobalValIDToValue
parameter_list|(
specifier|const
name|Type
modifier|*
name|Ty
parameter_list|,
name|ValID
modifier|&
name|ID
parameter_list|,
name|Constant
modifier|*
modifier|&
name|V
parameter_list|)
function_decl|;
name|bool
name|ParseGlobalValue
parameter_list|(
specifier|const
name|Type
modifier|*
name|Ty
parameter_list|,
name|Constant
modifier|*
modifier|&
name|V
parameter_list|)
function_decl|;
name|bool
name|ParseGlobalTypeAndValue
parameter_list|(
name|Constant
modifier|*
modifier|&
name|V
parameter_list|)
function_decl|;
name|bool
name|ParseGlobalValueVector
argument_list|(
name|SmallVectorImpl
operator|<
name|Constant
operator|*
operator|>
operator|&
name|Elts
argument_list|)
decl_stmt|;
name|bool
name|ParseMDNodeVector
argument_list|(
name|SmallVectorImpl
operator|<
name|Value
operator|*
operator|>
operator|&
argument_list|)
decl_stmt|;
comment|// Function Semantic Analysis.
name|class
name|PerFunctionState
block|{
name|LLParser
modifier|&
name|P
decl_stmt|;
name|Function
modifier|&
name|F
decl_stmt|;
name|std
operator|::
name|map
operator|<
name|std
operator|::
name|string
operator|,
name|std
operator|::
name|pair
operator|<
name|Value
operator|*
operator|,
name|LocTy
operator|>
expr|>
name|ForwardRefVals
expr_stmt|;
name|std
operator|::
name|map
operator|<
name|unsigned
operator|,
name|std
operator|::
name|pair
operator|<
name|Value
operator|*
operator|,
name|LocTy
operator|>
expr|>
name|ForwardRefValIDs
expr_stmt|;
name|std
operator|::
name|vector
operator|<
name|Value
operator|*
operator|>
name|NumberedVals
expr_stmt|;
name|public
label|:
name|PerFunctionState
argument_list|(
name|LLParser
operator|&
name|p
argument_list|,
name|Function
operator|&
name|f
argument_list|)
expr_stmt|;
operator|~
name|PerFunctionState
argument_list|()
expr_stmt|;
name|Function
operator|&
name|getFunction
argument_list|()
specifier|const
block|{
return|return
name|F
return|;
block|}
name|bool
name|VerifyFunctionComplete
parameter_list|()
function_decl|;
comment|/// GetVal - Get a value with the specified name or ID, creating a
comment|/// forward reference record if needed.  This can return null if the value
comment|/// exists but does not have the right type.
name|Value
modifier|*
name|GetVal
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|Name
argument_list|,
specifier|const
name|Type
operator|*
name|Ty
argument_list|,
name|LocTy
name|Loc
argument_list|)
decl_stmt|;
name|Value
modifier|*
name|GetVal
parameter_list|(
name|unsigned
name|ID
parameter_list|,
specifier|const
name|Type
modifier|*
name|Ty
parameter_list|,
name|LocTy
name|Loc
parameter_list|)
function_decl|;
comment|/// SetInstName - After an instruction is parsed and inserted into its
comment|/// basic block, this installs its name.
name|bool
name|SetInstName
argument_list|(
name|int
name|NameID
argument_list|,
specifier|const
name|std
operator|::
name|string
operator|&
name|NameStr
argument_list|,
name|LocTy
name|NameLoc
argument_list|,
name|Instruction
operator|*
name|Inst
argument_list|)
decl_stmt|;
comment|/// GetBB - Get a basic block with the specified name or ID, creating a
comment|/// forward reference record if needed.  This can return null if the value
comment|/// is not a BasicBlock.
name|BasicBlock
modifier|*
name|GetBB
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|Name
argument_list|,
name|LocTy
name|Loc
argument_list|)
decl_stmt|;
name|BasicBlock
modifier|*
name|GetBB
parameter_list|(
name|unsigned
name|ID
parameter_list|,
name|LocTy
name|Loc
parameter_list|)
function_decl|;
comment|/// DefineBB - Define the specified basic block, which is either named or
comment|/// unnamed.  If there is an error, this returns null otherwise it returns
comment|/// the block being defined.
name|BasicBlock
modifier|*
name|DefineBB
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|Name
argument_list|,
name|LocTy
name|Loc
argument_list|)
decl_stmt|;
block|}
empty_stmt|;
name|bool
name|ConvertValIDToValue
parameter_list|(
specifier|const
name|Type
modifier|*
name|Ty
parameter_list|,
name|ValID
modifier|&
name|ID
parameter_list|,
name|Value
modifier|*
modifier|&
name|V
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|bool
name|ParseValue
parameter_list|(
specifier|const
name|Type
modifier|*
name|Ty
parameter_list|,
name|Value
modifier|*
modifier|&
name|V
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|bool
name|ParseValue
parameter_list|(
specifier|const
name|Type
modifier|*
name|Ty
parameter_list|,
name|Value
modifier|*
modifier|&
name|V
parameter_list|,
name|LocTy
modifier|&
name|Loc
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
block|{
name|Loc
operator|=
name|Lex
operator|.
name|getLoc
argument_list|()
expr_stmt|;
return|return
name|ParseValue
argument_list|(
name|Ty
argument_list|,
name|V
argument_list|,
name|PFS
argument_list|)
return|;
block|}
name|bool
name|ParseTypeAndValue
parameter_list|(
name|Value
modifier|*
modifier|&
name|V
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|bool
name|ParseTypeAndValue
parameter_list|(
name|Value
modifier|*
modifier|&
name|V
parameter_list|,
name|LocTy
modifier|&
name|Loc
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
block|{
name|Loc
operator|=
name|Lex
operator|.
name|getLoc
argument_list|()
expr_stmt|;
return|return
name|ParseTypeAndValue
argument_list|(
name|V
argument_list|,
name|PFS
argument_list|)
return|;
block|}
struct|struct
name|ParamInfo
block|{
name|LocTy
name|Loc
decl_stmt|;
name|Value
modifier|*
name|V
decl_stmt|;
name|unsigned
name|Attrs
decl_stmt|;
name|ParamInfo
argument_list|(
argument|LocTy loc
argument_list|,
argument|Value *v
argument_list|,
argument|unsigned attrs
argument_list|)
block|:
name|Loc
argument_list|(
name|loc
argument_list|)
operator|,
name|V
argument_list|(
name|v
argument_list|)
operator|,
name|Attrs
argument_list|(
argument|attrs
argument_list|)
block|{}
block|}
struct|;
name|bool
name|ParseParameterList
argument_list|(
name|SmallVectorImpl
operator|<
name|ParamInfo
operator|>
operator|&
name|ArgList
argument_list|,
name|PerFunctionState
operator|&
name|PFS
argument_list|)
decl_stmt|;
comment|// Function Parsing.
struct|struct
name|ArgInfo
block|{
name|LocTy
name|Loc
decl_stmt|;
name|PATypeHolder
name|Type
decl_stmt|;
name|unsigned
name|Attrs
decl_stmt|;
name|std
operator|::
name|string
name|Name
expr_stmt|;
name|ArgInfo
argument_list|(
argument|LocTy L
argument_list|,
argument|PATypeHolder Ty
argument_list|,
argument|unsigned Attr
argument_list|,
argument|const std::string&N
argument_list|)
block|:
name|Loc
argument_list|(
name|L
argument_list|)
operator|,
name|Type
argument_list|(
name|Ty
argument_list|)
operator|,
name|Attrs
argument_list|(
name|Attr
argument_list|)
operator|,
name|Name
argument_list|(
argument|N
argument_list|)
block|{}
block|}
struct|;
name|bool
name|ParseArgumentList
argument_list|(
name|std
operator|::
name|vector
operator|<
name|ArgInfo
operator|>
operator|&
name|ArgList
argument_list|,
name|bool
operator|&
name|isVarArg
argument_list|,
name|bool
name|inType
argument_list|)
decl_stmt|;
name|bool
name|ParseFunctionHeader
parameter_list|(
name|Function
modifier|*
modifier|&
name|Fn
parameter_list|,
name|bool
name|isDefine
parameter_list|)
function_decl|;
name|bool
name|ParseFunctionBody
parameter_list|(
name|Function
modifier|&
name|Fn
parameter_list|)
function_decl|;
name|bool
name|ParseBasicBlock
parameter_list|(
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
comment|// Instruction Parsing.
name|bool
name|ParseInstruction
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|Inst
parameter_list|,
name|BasicBlock
modifier|*
name|BB
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|bool
name|ParseCmpPredicate
parameter_list|(
name|unsigned
modifier|&
name|Pred
parameter_list|,
name|unsigned
name|Opc
parameter_list|)
function_decl|;
name|bool
name|ParseRet
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|Inst
parameter_list|,
name|BasicBlock
modifier|*
name|BB
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|bool
name|ParseBr
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|Inst
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|bool
name|ParseSwitch
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|Inst
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|bool
name|ParseInvoke
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|Inst
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|bool
name|ParseArithmetic
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|,
name|unsigned
name|Opc
parameter_list|,
name|unsigned
name|OperandType
parameter_list|)
function_decl|;
name|bool
name|ParseLogical
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|,
name|unsigned
name|Opc
parameter_list|)
function_decl|;
name|bool
name|ParseCompare
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|,
name|unsigned
name|Opc
parameter_list|)
function_decl|;
name|bool
name|ParseCast
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|,
name|unsigned
name|Opc
parameter_list|)
function_decl|;
name|bool
name|ParseSelect
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|bool
name|ParseVA_Arg
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|bool
name|ParseExtractElement
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|bool
name|ParseInsertElement
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|bool
name|ParseShuffleVector
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|bool
name|ParsePHI
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|bool
name|ParseCall
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|,
name|bool
name|isTail
parameter_list|)
function_decl|;
name|bool
name|ParseAlloc
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|,
name|BasicBlock
modifier|*
name|BB
init|=
literal|0
parameter_list|,
name|bool
name|isAlloca
init|=
name|true
parameter_list|)
function_decl|;
name|bool
name|ParseFree
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|bool
name|ParseLoad
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|,
name|bool
name|isVolatile
parameter_list|)
function_decl|;
name|bool
name|ParseStore
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|,
name|bool
name|isVolatile
parameter_list|)
function_decl|;
name|bool
name|ParseGetResult
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|bool
name|ParseGetElementPtr
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|bool
name|ParseExtractValue
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
name|bool
name|ParseInsertValue
parameter_list|(
name|Instruction
modifier|*
modifier|&
name|I
parameter_list|,
name|PerFunctionState
modifier|&
name|PFS
parameter_list|)
function_decl|;
block|}
empty_stmt|;
block|}
end_decl_stmt

begin_comment
comment|// End llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

