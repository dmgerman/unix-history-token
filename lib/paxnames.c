begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* This file is part of GNU paxutils    Copyright (C) 2005 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify it    under the terms of the GNU General Public License as published by the    Free Software Foundation; either version 2, or (at your option) any later    version.     This program is distributed in the hope that it will be useful, but    WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General    Public License for more details.     You should have received a copy of the GNU General Public License along    with this program; if not, write to the Free Software Foundation, Inc.,    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_include
include|#
directive|include
file|<system.h>
end_include

begin_include
include|#
directive|include
file|<hash.h>
end_include

begin_include
include|#
directive|include
file|<paxlib.h>
end_include

begin_escape
end_escape

begin_comment
comment|/* Hash tables of strings.  */
end_comment

begin_comment
comment|/* Calculate the hash of a string.  */
end_comment

begin_function
specifier|static
name|size_t
name|hash_string_hasher
parameter_list|(
name|void
specifier|const
modifier|*
name|name
parameter_list|,
name|size_t
name|n_buckets
parameter_list|)
block|{
return|return
name|hash_string
argument_list|(
name|name
argument_list|,
name|n_buckets
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compare two strings for equality.  */
end_comment

begin_function
specifier|static
name|bool
name|hash_string_compare
parameter_list|(
name|void
specifier|const
modifier|*
name|name1
parameter_list|,
name|void
specifier|const
modifier|*
name|name2
parameter_list|)
block|{
return|return
name|strcmp
argument_list|(
name|name1
argument_list|,
name|name2
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return zero if TABLE contains a copy of STRING; otherwise, insert a    copy of STRING to TABLE and return 1.  */
end_comment

begin_function
name|bool
name|hash_string_insert
parameter_list|(
name|Hash_table
modifier|*
modifier|*
name|table
parameter_list|,
name|char
specifier|const
modifier|*
name|string
parameter_list|)
block|{
name|Hash_table
modifier|*
name|t
init|=
operator|*
name|table
decl_stmt|;
name|char
modifier|*
name|s
init|=
name|xstrdup
argument_list|(
name|string
argument_list|)
decl_stmt|;
name|char
modifier|*
name|e
decl_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|t
operator|||
operator|(
operator|*
name|table
operator|=
name|t
operator|=
name|hash_initialize
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|hash_string_hasher
argument_list|,
name|hash_string_compare
argument_list|,
literal|0
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|e
operator|=
name|hash_insert
argument_list|(
name|t
argument_list|,
name|s
argument_list|)
operator|)
operator|)
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|s
condition|)
return|return
literal|1
return|;
else|else
block|{
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* Return 1 if TABLE contains STRING.  */
end_comment

begin_function
name|bool
name|hash_string_lookup
parameter_list|(
name|Hash_table
specifier|const
modifier|*
name|table
parameter_list|,
name|char
specifier|const
modifier|*
name|string
parameter_list|)
block|{
return|return
name|table
operator|&&
name|hash_lookup
argument_list|(
name|table
argument_list|,
name|string
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|Hash_table
modifier|*
name|prefix_table
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return true if file names of some members in the archive were stripped off    their leading components. We could have used         return prefix_table[0] || prefix_table[1]    but the following seems to be safer: */
end_comment

begin_function
name|bool
name|removed_prefixes_p
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|prefix_table
index|[
literal|0
index|]
operator|&&
name|hash_get_n_entries
argument_list|(
name|prefix_table
index|[
literal|0
index|]
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|prefix_table
index|[
literal|1
index|]
operator|&&
name|hash_get_n_entries
argument_list|(
name|prefix_table
index|[
literal|1
index|]
argument_list|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a safer suffix of FILE_NAME, or "." if it has no safer    suffix.  Check for fully specified file names and other atrocities.    Warn the user if we do not return NAME.  If LINK_TARGET is 1,    FILE_NAME is the target of a hard link, not a member name.    If ABSOLUTE_NAMES is 0, strip filesystem prefix from the file name. */
end_comment

begin_function
name|char
modifier|*
name|safer_name_suffix
parameter_list|(
name|char
specifier|const
modifier|*
name|file_name
parameter_list|,
name|bool
name|link_target
parameter_list|,
name|bool
name|absolute_names
parameter_list|)
block|{
name|char
specifier|const
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|absolute_names
condition|)
name|p
operator|=
name|file_name
expr_stmt|;
else|else
block|{
comment|/* Skip file system prefixes, leading file name components that contain 	 "..", and leading slashes.  */
name|size_t
name|prefix_len
init|=
name|FILE_SYSTEM_PREFIX_LEN
argument_list|(
name|file_name
argument_list|)
decl_stmt|;
for|for
control|(
name|p
operator|=
name|file_name
operator|+
name|prefix_len
init|;
operator|*
name|p
condition|;
control|)
block|{
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|ISSLASH
argument_list|(
name|p
index|[
literal|2
index|]
argument_list|)
operator|||
operator|!
name|p
index|[
literal|2
index|]
operator|)
condition|)
name|prefix_len
operator|=
name|p
operator|+
literal|2
operator|-
name|file_name
expr_stmt|;
do|do
block|{
name|char
name|c
init|=
operator|*
name|p
operator|++
decl_stmt|;
if|if
condition|(
name|ISSLASH
argument_list|(
name|c
argument_list|)
condition|)
break|break;
block|}
do|while
condition|(
operator|*
name|p
condition|)
do|;
block|}
for|for
control|(
name|p
operator|=
name|file_name
operator|+
name|prefix_len
init|;
name|ISSLASH
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
continue|continue;
name|prefix_len
operator|=
name|p
operator|-
name|file_name
expr_stmt|;
if|if
condition|(
name|prefix_len
condition|)
block|{
name|char
modifier|*
name|prefix
init|=
name|alloca
argument_list|(
name|prefix_len
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|prefix
argument_list|,
name|file_name
argument_list|,
name|prefix_len
argument_list|)
expr_stmt|;
name|prefix
index|[
name|prefix_len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|hash_string_insert
argument_list|(
operator|&
name|prefix_table
index|[
name|link_target
index|]
argument_list|,
name|prefix
argument_list|)
condition|)
block|{
specifier|static
name|char
specifier|const
modifier|*
specifier|const
name|diagnostic
index|[]
init|=
block|{
name|N_
argument_list|(
literal|"Removing leading `%s' from member names"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Removing leading `%s' from hard link targets"
argument_list|)
block|}
decl_stmt|;
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
name|_
argument_list|(
name|diagnostic
index|[
name|link_target
index|]
argument_list|)
operator|,
name|prefix
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
operator|*
name|p
condition|)
block|{
if|if
condition|(
name|p
operator|==
name|file_name
condition|)
block|{
specifier|static
name|char
specifier|const
modifier|*
specifier|const
name|diagnostic
index|[]
init|=
block|{
name|N_
argument_list|(
literal|"Substituting `.' for empty member name"
argument_list|)
block|,
name|N_
argument_list|(
literal|"Substituting `.' for empty hard link target"
argument_list|)
block|}
decl_stmt|;
name|WARN
argument_list|(
operator|(
literal|0
operator|,
literal|0
operator|,
literal|"%s"
operator|,
name|_
argument_list|(
name|diagnostic
index|[
name|link_target
index|]
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
literal|"."
expr_stmt|;
block|}
return|return
operator|(
name|char
operator|*
operator|)
name|p
return|;
block|}
end_function

end_unit

