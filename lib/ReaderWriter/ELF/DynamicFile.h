begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- lib/ReaderWriter/ELF/DynamicFile.h ---------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                             The LLVM Linker
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLD_READER_WRITER_ELF_DYNAMIC_FILE_H
end_ifndef

begin_define
define|#
directive|define
name|LLD_READER_WRITER_ELF_DYNAMIC_FILE_H
end_define

begin_include
include|#
directive|include
file|"Atoms.h"
end_include

begin_include
include|#
directive|include
file|"lld/Core/SharedLibraryFile.h"
end_include

begin_include
include|#
directive|include
file|"lld/ReaderWriter/ELFLinkingContext.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Object/ELF.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Path.h"
end_include

begin_include
include|#
directive|include
file|<unordered_map>
end_include

begin_decl_stmt
name|namespace
name|lld
block|{
name|namespace
name|elf
block|{
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|DynamicFile
operator|:
name|public
name|SharedLibraryFile
block|{
name|public
operator|:
specifier|static
name|ErrorOr
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|DynamicFile
operator|>>
name|create
argument_list|(
name|std
operator|::
name|unique_ptr
operator|<
name|llvm
operator|::
name|MemoryBuffer
operator|>
name|mb
argument_list|,
name|ELFLinkingContext
operator|&
name|ctx
argument_list|)
block|;
specifier|const
name|SharedLibraryAtom
operator|*
name|exports
argument_list|(
argument|StringRef name
argument_list|,
argument|bool dataSymbolOnly
argument_list|)
specifier|const
name|override
block|{
name|assert
argument_list|(
operator|!
name|dataSymbolOnly
operator|&&
literal|"Invalid option for ELF exports!"
argument_list|)
block|;
comment|// See if we have the symbol.
name|auto
name|sym
operator|=
name|_nameToSym
operator|.
name|find
argument_list|(
name|name
argument_list|)
block|;
if|if
condition|(
name|sym
operator|==
name|_nameToSym
operator|.
name|end
argument_list|()
condition|)
return|return
name|nullptr
return|;
comment|// Have we already created a SharedLibraryAtom for it?
if|if
condition|(
name|sym
operator|->
name|second
operator|.
name|_atom
condition|)
return|return
name|sym
operator|->
name|second
operator|.
name|_atom
return|;
comment|// Create a SharedLibraryAtom for this symbol.
return|return
name|sym
operator|->
name|second
operator|.
name|_atom
operator|=
name|new
argument_list|(
argument|_alloc
argument_list|)
name|ELFDynamicAtom
operator|<
name|ELFT
operator|>
operator|(
operator|*
name|this
operator|,
name|name
operator|,
name|_soname
operator|,
name|sym
operator|->
name|second
operator|.
name|_symbol
operator|)
return|;
block|}
name|StringRef
name|getDSOName
argument_list|()
specifier|const
name|override
block|{
return|return
name|_soname
return|;
block|}
name|protected
label|:
name|std
operator|::
name|error_code
name|doParse
argument_list|()
name|override
block|{
name|std
operator|::
name|error_code
name|ec
block|;
name|_objFile
operator|.
name|reset
argument_list|(
argument|new llvm::object::ELFFile<ELFT>(_mb->getBuffer(), ec)
argument_list|)
block|;
if|if
condition|(
name|ec
condition|)
return|return
name|ec
return|;
name|llvm
operator|::
name|object
operator|::
name|ELFFile
operator|<
name|ELFT
operator|>
operator|&
name|obj
operator|=
operator|*
name|_objFile
expr_stmt|;
name|_soname
operator|=
name|obj
operator|.
name|getLoadName
argument_list|()
expr_stmt|;
if|if
condition|(
name|_soname
operator|.
name|empty
argument_list|()
condition|)
name|_soname
operator|=
name|llvm
operator|::
name|sys
operator|::
name|path
operator|::
name|filename
argument_list|(
name|path
argument_list|()
argument_list|)
expr_stmt|;
comment|// Create a map from names to dynamic symbol table entries.
comment|// TODO: This should use the object file's build in hash table instead if
comment|// it exists.
for|for
control|(
name|auto
name|i
init|=
name|obj
operator|.
name|begin_dynamic_symbols
argument_list|()
init|,
name|e
init|=
name|obj
operator|.
name|end_dynamic_symbols
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
name|auto
name|name
init|=
name|obj
operator|.
name|getSymbolName
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|ec
operator|=
name|name
operator|.
name|getError
argument_list|()
operator|)
condition|)
return|return
name|ec
return|;
comment|// Dont add local symbols to dynamic entries. The first symbol in the
comment|// dynamic symbol table is a local symbol.
if|if
condition|(
name|i
operator|->
name|getBinding
argument_list|()
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|STB_LOCAL
condition|)
continue|continue;
comment|// TODO: Add absolute symbols
if|if
condition|(
name|i
operator|->
name|st_shndx
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|SHN_ABS
condition|)
continue|continue;
if|if
condition|(
name|i
operator|->
name|st_shndx
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|SHN_UNDEF
condition|)
block|{
if|if
condition|(
operator|!
name|_useShlibUndefines
condition|)
continue|continue;
comment|// Create an undefined atom.
if|if
condition|(
operator|!
name|name
operator|->
name|empty
argument_list|()
condition|)
block|{
name|auto
operator|*
name|newAtom
operator|=
name|new
argument_list|(
argument|_alloc
argument_list|)
name|ELFUndefinedAtom
operator|<
name|ELFT
operator|>
operator|(
operator|*
name|this
operator|,
operator|*
name|name
operator|,
operator|&
operator|*
name|i
operator|)
expr_stmt|;
name|_undefinedAtoms
operator|.
name|_atoms
operator|.
name|push_back
argument_list|(
name|newAtom
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
name|_nameToSym
index|[
operator|*
name|name
index|]
operator|.
name|_symbol
operator|=
operator|&
operator|*
name|i
expr_stmt|;
block|}
return|return
name|std
operator|::
name|error_code
argument_list|()
return|;
block|}
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_expr_stmt
name|DynamicFile
argument_list|(
name|std
operator|::
name|unique_ptr
operator|<
name|MemoryBuffer
operator|>
name|mb
argument_list|,
name|ELFLinkingContext
operator|&
name|ctx
argument_list|)
operator|:
name|SharedLibraryFile
argument_list|(
name|mb
operator|->
name|getBufferIdentifier
argument_list|()
argument_list|)
operator|,
name|_mb
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|mb
argument_list|)
argument_list|)
operator|,
name|_ctx
argument_list|(
name|ctx
argument_list|)
operator|,
name|_useShlibUndefines
argument_list|(
argument|ctx.useShlibUndefines()
argument_list|)
block|{}
name|mutable
name|llvm
operator|::
name|BumpPtrAllocator
name|_alloc
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|unique_ptr
operator|<
name|llvm
operator|::
name|object
operator|::
name|ELFFile
operator|<
name|ELFT
operator|>>
name|_objFile
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// \brief DT_SONAME
end_comment

begin_decl_stmt
name|StringRef
name|_soname
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|SymAtomPair
block|{
name|SymAtomPair
argument_list|()
operator|:
name|_symbol
argument_list|(
name|nullptr
argument_list|)
operator|,
name|_atom
argument_list|(
argument|nullptr
argument_list|)
block|{}
specifier|const
name|typename
name|llvm
operator|::
name|object
operator|::
name|ELFFile
operator|<
name|ELFT
operator|>
operator|::
name|Elf_Sym
operator|*
name|_symbol
expr_stmt|;
specifier|const
name|SharedLibraryAtom
modifier|*
name|_atom
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|std
operator|::
name|unique_ptr
operator|<
name|MemoryBuffer
operator|>
name|_mb
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|ELFLinkingContext
modifier|&
name|_ctx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|_useShlibUndefines
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|mutable
name|std
operator|::
name|unordered_map
operator|<
name|StringRef
operator|,
name|SymAtomPair
operator|>
name|_nameToSym
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|ELFT
operator|>
name|ErrorOr
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|DynamicFile
operator|<
name|ELFT
operator|>>>
name|DynamicFile
operator|<
name|ELFT
operator|>
operator|::
name|create
argument_list|(
argument|std::unique_ptr<llvm::MemoryBuffer> mb
argument_list|,
argument|ELFLinkingContext&ctx
argument_list|)
block|{
return|return
name|std
operator|::
name|unique_ptr
operator|<
name|DynamicFile
operator|>
operator|(
name|new
name|DynamicFile
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|mb
argument_list|)
argument_list|,
name|ctx
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|// end namespace elf
end_comment

begin_comment
unit|}
comment|// end namespace lld
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

