begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- lib/ReaderWriter/ELF/Atoms.h ---------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                             The LLVM Linker
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLD_READER_WRITER_ELF_ATOMS_H
end_ifndef

begin_define
define|#
directive|define
name|LLD_READER_WRITER_ELF_ATOMS_H
end_define

begin_include
include|#
directive|include
file|"TargetHandler.h"
end_include

begin_include
include|#
directive|include
file|"lld/Core/LLVM.h"
end_include

begin_include
include|#
directive|include
file|"lld/Core/Simple.h"
end_include

begin_include
include|#
directive|include
file|"lld/ReaderWriter/ELFLinkingContext.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringSwitch.h"
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|lld
block|{
name|namespace
name|elf
block|{
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|DynamicFile
expr_stmt|;
name|template
operator|<
name|typename
name|ELFT
operator|>
name|class
name|ELFFile
expr_stmt|;
comment|/// \brief Relocation References: Defined Atoms may contain references that will
comment|/// need to be patched before the executable is written.
comment|///
comment|/// Construction of ELFReferences is two pass process. ELFReferences are
comment|/// instantiated while we are iterating over symbol tables to atomize
comment|/// symbols. At that time we only know the index of relocation target symbol
comment|/// (not target atom) about a relocation, so we store the index to
comment|/// ELFREference. In the second pass, ELFReferences are revisited to update
comment|/// target atoms by target symbol indexes.
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|ELFReference
operator|:
name|public
name|Reference
block|{
typedef|typedef
name|llvm
operator|::
name|object
operator|::
name|Elf_Rel_Impl
operator|<
name|ELFT
operator|,
name|false
operator|>
name|Elf_Rel
expr_stmt|;
typedef|typedef
name|llvm
operator|::
name|object
operator|::
name|Elf_Rel_Impl
operator|<
name|ELFT
operator|,
name|true
operator|>
name|Elf_Rela
expr_stmt|;
typedef|typedef
name|llvm
operator|::
name|object
operator|::
name|Elf_Sym_Impl
operator|<
name|ELFT
operator|>
name|Elf_Sym
expr_stmt|;
name|public
label|:
name|ELFReference
argument_list|(
argument|const Elf_Rela *rela
argument_list|,
argument|uint64_t off
argument_list|,
argument|Reference::KindArch arch
argument_list|,
argument|Reference::KindValue relocType
argument_list|,
argument|uint32_t idx
argument_list|)
block|:
name|Reference
argument_list|(
name|Reference
operator|::
name|KindNamespace
operator|::
name|ELF
argument_list|,
name|arch
argument_list|,
name|relocType
argument_list|)
operator|,
name|_targetSymbolIndex
argument_list|(
name|idx
argument_list|)
operator|,
name|_offsetInAtom
argument_list|(
name|off
argument_list|)
operator|,
name|_addend
argument_list|(
argument|rela->r_addend
argument_list|)
block|{}
name|ELFReference
argument_list|(
argument|uint64_t off
argument_list|,
argument|Reference::KindArch arch
argument_list|,
argument|Reference::KindValue relocType
argument_list|,
argument|uint32_t idx
argument_list|)
operator|:
name|Reference
argument_list|(
name|Reference
operator|::
name|KindNamespace
operator|::
name|ELF
argument_list|,
name|arch
argument_list|,
name|relocType
argument_list|)
operator|,
name|_targetSymbolIndex
argument_list|(
name|idx
argument_list|)
operator|,
name|_offsetInAtom
argument_list|(
argument|off
argument_list|)
block|{}
name|ELFReference
argument_list|(
argument|uint32_t edgeKind
argument_list|)
operator|:
name|Reference
argument_list|(
argument|Reference::KindNamespace::all
argument_list|,
argument|Reference::KindArch::all
argument_list|,
argument|edgeKind
argument_list|)
block|{}
name|uint64_t
name|offsetInAtom
argument_list|()
specifier|const
name|override
block|{
return|return
name|_offsetInAtom
return|;
block|}
specifier|const
name|Atom
operator|*
name|target
argument_list|()
specifier|const
name|override
block|{
return|return
name|_target
return|;
block|}
comment|/// \brief The symbol table index that contains the target reference.
name|uint64_t
name|targetSymbolIndex
argument_list|()
specifier|const
block|{
return|return
name|_targetSymbolIndex
return|;
block|}
name|Addend
name|addend
argument_list|()
specifier|const
name|override
block|{
return|return
name|_addend
return|;
block|}
name|virtual
name|void
name|setOffset
parameter_list|(
name|uint64_t
name|off
parameter_list|)
block|{
name|_offsetInAtom
operator|=
name|off
expr_stmt|;
block|}
name|void
name|setAddend
parameter_list|(
name|Addend
name|A
parameter_list|)
function|override
block|{
name|_addend
operator|=
name|A
expr_stmt|;
block|}
name|void
name|setTarget
parameter_list|(
specifier|const
name|Atom
modifier|*
name|newAtom
parameter_list|)
function|override
block|{
name|_target
operator|=
name|newAtom
expr_stmt|;
block|}
name|private
label|:
specifier|const
name|Atom
modifier|*
name|_target
init|=
name|nullptr
decl_stmt|;
name|uint64_t
name|_targetSymbolIndex
init|=
literal|0
decl_stmt|;
name|uint64_t
name|_offsetInAtom
init|=
literal|0
decl_stmt|;
name|Addend
name|_addend
init|=
literal|0
decl_stmt|;
block|}
empty_stmt|;
comment|/// \brief These atoms store symbols that are fixed to a particular address.
comment|/// This atom has no content its address will be used by the writer to fixup
comment|/// references that point to it.
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|ELFAbsoluteAtom
operator|:
name|public
name|AbsoluteAtom
block|{
typedef|typedef
name|llvm
operator|::
name|object
operator|::
name|Elf_Sym_Impl
operator|<
name|ELFT
operator|>
name|Elf_Sym
expr_stmt|;
name|public
operator|:
name|ELFAbsoluteAtom
argument_list|(
argument|const ELFFile<ELFT>&file
argument_list|,
argument|StringRef name
argument_list|,
argument|const Elf_Sym *symbol
argument_list|,
argument|uint64_t value
argument_list|)
operator|:
name|_owningFile
argument_list|(
name|file
argument_list|)
operator|,
name|_name
argument_list|(
name|name
argument_list|)
operator|,
name|_symbol
argument_list|(
name|symbol
argument_list|)
operator|,
name|_value
argument_list|(
argument|value
argument_list|)
block|{}
specifier|const
name|ELFFile
operator|<
name|ELFT
operator|>
operator|&
name|file
argument_list|()
specifier|const
name|override
block|{
return|return
name|_owningFile
return|;
block|}
name|Scope
name|scope
argument_list|()
specifier|const
name|override
expr_stmt|;
name|StringRef
name|name
argument_list|()
specifier|const
name|override
block|{
return|return
name|_name
return|;
block|}
name|uint64_t
name|value
argument_list|()
specifier|const
name|override
block|{
return|return
name|_value
return|;
block|}
name|private
label|:
specifier|const
name|ELFFile
operator|<
name|ELFT
operator|>
operator|&
name|_owningFile
expr_stmt|;
name|StringRef
name|_name
decl_stmt|;
specifier|const
name|Elf_Sym
modifier|*
name|_symbol
decl_stmt|;
name|uint64_t
name|_value
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// \brief ELFUndefinedAtom: These atoms store undefined symbols and are place
end_comment

begin_comment
comment|/// holders that will be replaced by defined atoms later in the linking process.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|ELFUndefinedAtom
operator|:
name|public
name|UndefinedAtom
block|{
typedef|typedef
name|llvm
operator|::
name|object
operator|::
name|Elf_Sym_Impl
operator|<
name|ELFT
operator|>
name|Elf_Sym
expr_stmt|;
name|public
operator|:
name|ELFUndefinedAtom
argument_list|(
argument|const File&file
argument_list|,
argument|StringRef name
argument_list|,
argument|const Elf_Sym *symbol
argument_list|)
operator|:
name|_owningFile
argument_list|(
name|file
argument_list|)
operator|,
name|_name
argument_list|(
name|name
argument_list|)
operator|,
name|_symbol
argument_list|(
argument|symbol
argument_list|)
block|{}
specifier|const
name|File
operator|&
name|file
argument_list|()
specifier|const
name|override
block|{
return|return
name|_owningFile
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|StringRef
name|name
argument_list|()
specifier|const
name|override
block|{
return|return
name|_name
return|;
block|}
end_expr_stmt

begin_comment
comment|// A symbol in ELF can be undefined at build time if the symbol is a undefined
end_comment

begin_comment
comment|// weak symbol.
end_comment

begin_expr_stmt
name|CanBeNull
name|canBeNull
argument_list|()
specifier|const
name|override
expr_stmt|;
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_decl_stmt
specifier|const
name|File
modifier|&
name|_owningFile
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|StringRef
name|_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|Elf_Sym
modifier|*
name|_symbol
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|/// \brief This atom stores defined symbols and will contain either data or
end_comment

begin_comment
comment|/// code.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|ELFDefinedAtom
operator|:
name|public
name|DefinedAtom
block|{
typedef|typedef
name|llvm
operator|::
name|object
operator|::
name|Elf_Sym_Impl
operator|<
name|ELFT
operator|>
name|Elf_Sym
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|llvm
operator|::
name|object
operator|::
name|Elf_Shdr_Impl
operator|<
name|ELFT
operator|>
name|Elf_Shdr
expr_stmt|;
end_typedef

begin_label
name|public
label|:
end_label

begin_macro
name|ELFDefinedAtom
argument_list|(
argument|const ELFFile<ELFT>&file
argument_list|,
argument|StringRef symbolName
argument_list|,
argument|StringRef sectionName
argument_list|,
argument|const Elf_Sym *symbol
argument_list|,
argument|const Elf_Shdr *section
argument_list|,
argument|ArrayRef<uint8_t> contentData
argument_list|,
argument|unsigned int referenceStart
argument_list|,
argument|unsigned int referenceEnd
argument_list|,
argument|std::vector<ELFReference<ELFT> *>&referenceList
argument_list|)
end_macro

begin_expr_stmt
unit|:
name|_owningFile
argument_list|(
name|file
argument_list|)
operator|,
name|_symbolName
argument_list|(
name|symbolName
argument_list|)
operator|,
name|_sectionName
argument_list|(
name|sectionName
argument_list|)
operator|,
name|_symbol
argument_list|(
name|symbol
argument_list|)
operator|,
name|_section
argument_list|(
name|section
argument_list|)
operator|,
name|_contentData
argument_list|(
name|contentData
argument_list|)
operator|,
name|_referenceStartIndex
argument_list|(
name|referenceStart
argument_list|)
operator|,
name|_referenceEndIndex
argument_list|(
name|referenceEnd
argument_list|)
operator|,
name|_referenceList
argument_list|(
name|referenceList
argument_list|)
operator|,
name|_contentType
argument_list|(
name|typeUnknown
argument_list|)
operator|,
name|_permissions
argument_list|(
argument|permUnknown
argument_list|)
block|{}
operator|~
name|ELFDefinedAtom
argument_list|()
name|override
operator|=
expr|default
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|const
name|ELFFile
operator|<
name|ELFT
operator|>
operator|&
name|file
argument_list|()
specifier|const
name|override
block|{
return|return
name|_owningFile
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|StringRef
name|name
argument_list|()
specifier|const
name|override
block|{
return|return
name|_symbolName
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|uint64_t
name|ordinal
argument_list|()
specifier|const
name|override
block|{
return|return
name|_ordinal
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|const
name|Elf_Sym
operator|*
name|symbol
argument_list|()
specifier|const
block|{
return|return
name|_symbol
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|const
name|Elf_Shdr
operator|*
name|section
argument_list|()
specifier|const
block|{
return|return
name|_section
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|uint64_t
name|size
argument_list|()
specifier|const
name|override
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Scope
name|scope
argument_list|()
specifier|const
name|override
expr_stmt|;
end_expr_stmt

begin_comment
comment|// FIXME: Need to revisit this in future.
end_comment

begin_expr_stmt
name|Interposable
name|interposable
argument_list|()
specifier|const
name|override
block|{
return|return
name|interposeNo
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|Merge
name|merge
argument_list|()
specifier|const
name|override
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ContentType
name|contentType
argument_list|()
specifier|const
name|override
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Alignment
name|alignment
argument_list|()
specifier|const
name|override
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|SectionChoice
name|sectionChoice
argument_list|()
specifier|const
name|override
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|StringRef
name|customSectionName
argument_list|()
specifier|const
name|override
expr_stmt|;
end_expr_stmt

begin_comment
comment|// It isn't clear that __attribute__((used)) is transmitted to the ELF object
end_comment

begin_comment
comment|// file.
end_comment

begin_expr_stmt
name|DeadStripKind
name|deadStrip
argument_list|()
specifier|const
name|override
block|{
return|return
name|deadStripNormal
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|ContentPermissions
name|permissions
argument_list|()
specifier|const
name|override
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ArrayRef
operator|<
name|uint8_t
operator|>
name|rawContent
argument_list|()
specifier|const
name|override
block|{
return|return
name|_contentData
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|DefinedAtom
operator|::
name|reference_iterator
name|begin
argument_list|()
specifier|const
name|override
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DefinedAtom
operator|::
name|reference_iterator
name|end
argument_list|()
specifier|const
name|override
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|const
name|Reference
modifier|*
name|derefIterator
argument_list|(
specifier|const
name|void
operator|*
name|It
argument_list|)
decl|const
name|override
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|incrementIterator
argument_list|(
specifier|const
name|void
operator|*
operator|&
name|It
argument_list|)
decl|const
name|override
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|addReference
argument_list|(
name|ELFReference
operator|<
name|ELFT
operator|>
operator|*
name|reference
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|virtual
name|void
name|setOrdinal
parameter_list|(
name|uint64_t
name|ord
parameter_list|)
block|{
name|_ordinal
operator|=
name|ord
expr_stmt|;
block|}
end_function

begin_label
name|protected
label|:
end_label

begin_comment
comment|/// Returns correct st_value for the symbol depending on the architecture.
end_comment

begin_comment
comment|/// For most architectures it's just a regular st_value with no changes.
end_comment

begin_expr_stmt
name|virtual
name|uint64_t
name|getSymbolValue
argument_list|()
specifier|const
block|{
return|return
name|_symbol
operator|->
name|st_value
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|ContentType
name|doContentType
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|const
name|ELFFile
operator|<
name|ELFT
operator|>
operator|&
name|_owningFile
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|StringRef
name|_symbolName
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|StringRef
name|_sectionName
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|Elf_Sym
modifier|*
name|_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|Elf_Shdr
modifier|*
name|_section
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// \brief Holds the bits that make up the atom.
end_comment

begin_expr_stmt
name|ArrayRef
operator|<
name|uint8_t
operator|>
name|_contentData
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|uint64_t
name|_ordinal
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|_referenceStartIndex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|int
name|_referenceEndIndex
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|std
operator|::
name|vector
operator|<
name|ELFReference
operator|<
name|ELFT
operator|>
operator|*
operator|>
operator|&
name|_referenceList
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|mutable
name|ContentType
name|_contentType
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|mutable
name|ContentPermissions
name|_permissions
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|/// \brief This atom stores mergeable Strings
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|ELFMergeAtom
operator|:
name|public
name|DefinedAtom
block|{
typedef|typedef
name|llvm
operator|::
name|object
operator|::
name|Elf_Shdr_Impl
operator|<
name|ELFT
operator|>
name|Elf_Shdr
expr_stmt|;
name|public
operator|:
name|ELFMergeAtom
argument_list|(
argument|const ELFFile<ELFT>&file
argument_list|,
argument|StringRef sectionName
argument_list|,
argument|const Elf_Shdr *section
argument_list|,
argument|ArrayRef<uint8_t> contentData
argument_list|,
argument|uint64_t offset
argument_list|)
operator|:
name|_owningFile
argument_list|(
name|file
argument_list|)
operator|,
name|_sectionName
argument_list|(
name|sectionName
argument_list|)
operator|,
name|_section
argument_list|(
name|section
argument_list|)
operator|,
name|_contentData
argument_list|(
name|contentData
argument_list|)
operator|,
name|_offset
argument_list|(
argument|offset
argument_list|)
block|{   }
specifier|const
name|ELFFile
operator|<
name|ELFT
operator|>
operator|&
name|file
argument_list|()
specifier|const
name|override
block|{
return|return
name|_owningFile
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|StringRef
name|name
argument_list|()
specifier|const
name|override
block|{
return|return
literal|""
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|virtual
name|uint64_t
name|section
argument_list|()
specifier|const
block|{
return|return
name|_section
operator|->
name|sh_name
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|virtual
name|uint64_t
name|offset
argument_list|()
specifier|const
block|{
return|return
name|_offset
return|;
block|}
end_expr_stmt

begin_function
name|virtual
name|void
name|setOrdinal
parameter_list|(
name|uint64_t
name|ord
parameter_list|)
block|{
name|_ordinal
operator|=
name|ord
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|uint64_t
name|ordinal
argument_list|()
specifier|const
name|override
block|{
return|return
name|_ordinal
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|uint64_t
name|size
argument_list|()
specifier|const
name|override
block|{
return|return
name|_contentData
operator|.
name|size
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|Scope
name|scope
argument_list|()
specifier|const
name|override
block|{
return|return
name|scopeTranslationUnit
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|Interposable
name|interposable
argument_list|()
specifier|const
name|override
block|{
return|return
name|interposeNo
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|Merge
name|merge
argument_list|()
specifier|const
name|override
block|{
return|return
name|mergeByContent
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|ContentType
name|contentType
argument_list|()
specifier|const
name|override
block|{
return|return
name|typeConstant
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|Alignment
name|alignment
argument_list|()
specifier|const
name|override
block|{
return|return
name|Alignment
argument_list|(
name|_section
operator|->
name|sh_addralign
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|SectionChoice
name|sectionChoice
argument_list|()
specifier|const
name|override
block|{
return|return
name|sectionCustomRequired
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|StringRef
name|customSectionName
argument_list|()
specifier|const
name|override
block|{
return|return
name|_sectionName
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|DeadStripKind
name|deadStrip
argument_list|()
specifier|const
name|override
block|{
return|return
name|deadStripNormal
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|ContentPermissions
name|permissions
argument_list|()
specifier|const
name|override
block|{
return|return
name|permR__
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|ArrayRef
operator|<
name|uint8_t
operator|>
name|rawContent
argument_list|()
specifier|const
name|override
block|{
return|return
name|_contentData
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|DefinedAtom
operator|::
name|reference_iterator
name|begin
argument_list|()
specifier|const
name|override
block|{
name|uintptr_t
name|index
operator|=
literal|0
block|;
specifier|const
name|void
operator|*
name|it
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|void
operator|*
operator|>
operator|(
name|index
operator|)
block|;
return|return
name|reference_iterator
argument_list|(
operator|*
name|this
argument_list|,
name|it
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|DefinedAtom
operator|::
name|reference_iterator
name|end
argument_list|()
specifier|const
name|override
block|{
name|uintptr_t
name|index
operator|=
literal|0
block|;
specifier|const
name|void
operator|*
name|it
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|void
operator|*
operator|>
operator|(
name|index
operator|)
block|;
return|return
name|reference_iterator
argument_list|(
operator|*
name|this
argument_list|,
name|it
argument_list|)
return|;
block|}
end_expr_stmt

begin_decl_stmt
specifier|const
name|Reference
modifier|*
name|derefIterator
argument_list|(
specifier|const
name|void
operator|*
name|It
argument_list|)
decl|const
name|override
block|{
return|return
name|nullptr
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|incrementIterator
argument_list|(
specifier|const
name|void
operator|*
operator|&
name|It
argument_list|)
decl|const
name|override
block|{}
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_expr_stmt
specifier|const
name|ELFFile
operator|<
name|ELFT
operator|>
operator|&
name|_owningFile
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|StringRef
name|_sectionName
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|Elf_Shdr
modifier|*
name|_section
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// \brief Holds the bits that make up the atom.
end_comment

begin_expr_stmt
name|ArrayRef
operator|<
name|uint8_t
operator|>
name|_contentData
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|uint64_t
name|_ordinal
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint64_t
name|_offset
decl_stmt|;
end_decl_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|ELFCommonAtom
operator|:
name|public
name|DefinedAtom
block|{
typedef|typedef
name|llvm
operator|::
name|object
operator|::
name|Elf_Sym_Impl
operator|<
name|ELFT
operator|>
name|Elf_Sym
expr_stmt|;
name|public
operator|:
name|ELFCommonAtom
argument_list|(
argument|const ELFFile<ELFT>&file
argument_list|,
argument|StringRef symbolName
argument_list|,
argument|const Elf_Sym *symbol
argument_list|)
operator|:
name|_owningFile
argument_list|(
name|file
argument_list|)
operator|,
name|_symbolName
argument_list|(
name|symbolName
argument_list|)
operator|,
name|_symbol
argument_list|(
argument|symbol
argument_list|)
block|{}
specifier|const
name|ELFFile
operator|<
name|ELFT
operator|>
operator|&
name|file
argument_list|()
specifier|const
name|override
block|{
return|return
name|_owningFile
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|StringRef
name|name
argument_list|()
specifier|const
name|override
block|{
return|return
name|_symbolName
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|uint64_t
name|ordinal
argument_list|()
specifier|const
name|override
block|{
return|return
name|_ordinal
return|;
block|}
end_expr_stmt

begin_function
name|virtual
name|void
name|setOrdinal
parameter_list|(
name|uint64_t
name|ord
parameter_list|)
block|{
name|_ordinal
operator|=
name|ord
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|uint64_t
name|size
argument_list|()
specifier|const
name|override
block|{
return|return
name|_symbol
operator|->
name|st_size
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|Scope
name|scope
argument_list|()
specifier|const
name|override
block|{
if|if
condition|(
name|_symbol
operator|->
name|getVisibility
argument_list|()
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|STV_HIDDEN
condition|)
return|return
name|scopeLinkageUnit
return|;
end_expr_stmt

begin_if
if|if
condition|(
name|_symbol
operator|->
name|getBinding
argument_list|()
operator|!=
name|llvm
operator|::
name|ELF
operator|::
name|STB_LOCAL
condition|)
return|return
name|scopeGlobal
return|;
end_if

begin_return
return|return
name|scopeTranslationUnit
return|;
end_return

begin_macro
unit|}    Interposable
name|interposable
argument_list|()
end_macro

begin_expr_stmt
specifier|const
name|override
block|{
return|return
name|interposeNo
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|Merge
name|merge
argument_list|()
specifier|const
name|override
block|{
return|return
name|mergeAsTentative
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|ContentType
name|contentType
argument_list|()
specifier|const
name|override
block|{
return|return
name|typeZeroFill
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|Alignment
name|alignment
argument_list|()
specifier|const
name|override
block|{
return|return
name|Alignment
argument_list|(
name|_symbol
operator|->
name|st_value
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|SectionChoice
name|sectionChoice
argument_list|()
specifier|const
name|override
block|{
return|return
name|sectionBasedOnContent
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|StringRef
name|customSectionName
argument_list|()
specifier|const
name|override
block|{
return|return
literal|".bss"
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|DeadStripKind
name|deadStrip
argument_list|()
specifier|const
name|override
block|{
return|return
name|deadStripNormal
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|ContentPermissions
name|permissions
argument_list|()
specifier|const
name|override
block|{
return|return
name|permRW_
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|ArrayRef
operator|<
name|uint8_t
operator|>
name|rawContent
argument_list|()
specifier|const
name|override
block|{
return|return
name|ArrayRef
operator|<
name|uint8_t
operator|>
operator|(
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|DefinedAtom
operator|::
name|reference_iterator
name|begin
argument_list|()
specifier|const
name|override
block|{
name|uintptr_t
name|index
operator|=
literal|0
block|;
specifier|const
name|void
operator|*
name|it
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|void
operator|*
operator|>
operator|(
name|index
operator|)
block|;
return|return
name|reference_iterator
argument_list|(
operator|*
name|this
argument_list|,
name|it
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|DefinedAtom
operator|::
name|reference_iterator
name|end
argument_list|()
specifier|const
name|override
block|{
name|uintptr_t
name|index
operator|=
literal|0
block|;
specifier|const
name|void
operator|*
name|it
operator|=
name|reinterpret_cast
operator|<
specifier|const
name|void
operator|*
operator|>
operator|(
name|index
operator|)
block|;
return|return
name|reference_iterator
argument_list|(
operator|*
name|this
argument_list|,
name|it
argument_list|)
return|;
block|}
end_expr_stmt

begin_label
name|protected
label|:
end_label

begin_decl_stmt
specifier|const
name|Reference
modifier|*
name|derefIterator
argument_list|(
specifier|const
name|void
operator|*
name|iter
argument_list|)
decl|const
name|override
block|{
return|return
name|nullptr
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|void
name|incrementIterator
argument_list|(
specifier|const
name|void
operator|*
operator|&
name|iter
argument_list|)
decl|const
name|override
block|{}
end_decl_stmt

begin_expr_stmt
specifier|const
name|ELFFile
operator|<
name|ELFT
operator|>
operator|&
name|_owningFile
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|StringRef
name|_symbolName
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|Elf_Sym
modifier|*
name|_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint64_t
name|_ordinal
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|/// \brief An atom from a shared library.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|ELFDynamicAtom
operator|:
name|public
name|SharedLibraryAtom
block|{
typedef|typedef
name|llvm
operator|::
name|object
operator|::
name|Elf_Sym_Impl
operator|<
name|ELFT
operator|>
name|Elf_Sym
expr_stmt|;
name|public
operator|:
name|ELFDynamicAtom
argument_list|(
argument|const DynamicFile<ELFT>&file
argument_list|,
argument|StringRef symbolName
argument_list|,
argument|StringRef loadName
argument_list|,
argument|const Elf_Sym *symbol
argument_list|)
operator|:
name|_owningFile
argument_list|(
name|file
argument_list|)
operator|,
name|_symbolName
argument_list|(
name|symbolName
argument_list|)
operator|,
name|_loadName
argument_list|(
name|loadName
argument_list|)
operator|,
name|_symbol
argument_list|(
argument|symbol
argument_list|)
block|{}
specifier|const
name|DynamicFile
operator|<
name|ELFT
operator|>
operator|&
name|file
argument_list|()
specifier|const
name|override
block|{
return|return
name|_owningFile
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|StringRef
name|name
argument_list|()
specifier|const
name|override
block|{
return|return
name|_symbolName
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|virtual
name|Scope
name|scope
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|StringRef
name|loadName
argument_list|()
specifier|const
name|override
block|{
return|return
name|_loadName
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|canBeNullAtRuntime
argument_list|()
specifier|const
name|override
block|{
return|return
name|_symbol
operator|->
name|getBinding
argument_list|()
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|STB_WEAK
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|Type
name|type
argument_list|()
specifier|const
name|override
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|uint64_t
name|size
argument_list|()
specifier|const
name|override
block|{
return|return
name|_symbol
operator|->
name|st_size
return|;
block|}
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_expr_stmt
specifier|const
name|DynamicFile
operator|<
name|ELFT
operator|>
operator|&
name|_owningFile
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|StringRef
name|_symbolName
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|StringRef
name|_loadName
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|Elf_Sym
modifier|*
name|_symbol
decl_stmt|;
end_decl_stmt

begin_decl_stmt
unit|};
name|class
name|SimpleELFDefinedAtom
range|:
name|public
name|SimpleDefinedAtom
block|{
name|public
operator|:
name|SimpleELFDefinedAtom
argument_list|(
specifier|const
name|File
operator|&
name|f
argument_list|)
operator|:
name|SimpleDefinedAtom
argument_list|(
argument|f
argument_list|)
block|{}
name|void
name|addReferenceELF
argument_list|(
argument|Reference::KindArch arch
argument_list|,
argument|Reference::KindValue kindValue
argument_list|,
argument|uint64_t off
argument_list|,
argument|const Atom *t
argument_list|,
argument|Reference::Addend a
argument_list|)
block|{
name|addReference
argument_list|(
name|Reference
operator|::
name|KindNamespace
operator|::
name|ELF
argument_list|,
name|arch
argument_list|,
name|kindValue
argument_list|,
name|off
argument_list|,
name|t
argument_list|,
name|a
argument_list|)
block|;   }
name|void
name|addReferenceELF_Hexagon
argument_list|(
argument|Reference::KindValue relocType
argument_list|,
argument|uint64_t off
argument_list|,
argument|const Atom *t
argument_list|,
argument|Reference::Addend a
argument_list|)
block|{
name|addReferenceELF
argument_list|(
name|Reference
operator|::
name|KindArch
operator|::
name|Hexagon
argument_list|,
name|relocType
argument_list|,
name|off
argument_list|,
name|t
argument_list|,
name|a
argument_list|)
block|;   }
name|void
name|addReferenceELF_x86_64
argument_list|(
argument|Reference::KindValue relocType
argument_list|,
argument|uint64_t off
argument_list|,
argument|const Atom *t
argument_list|,
argument|Reference::Addend a
argument_list|)
block|{
name|addReferenceELF
argument_list|(
name|Reference
operator|::
name|KindArch
operator|::
name|x86_64
argument_list|,
name|relocType
argument_list|,
name|off
argument_list|,
name|t
argument_list|,
name|a
argument_list|)
block|;   }
name|void
name|addReferenceELF_Mips
argument_list|(
argument|Reference::KindValue relocType
argument_list|,
argument|uint64_t off
argument_list|,
argument|const Atom *t
argument_list|,
argument|Reference::Addend a
argument_list|)
block|{
name|addReferenceELF
argument_list|(
name|Reference
operator|::
name|KindArch
operator|::
name|Mips
argument_list|,
name|relocType
argument_list|,
name|off
argument_list|,
name|t
argument_list|,
name|a
argument_list|)
block|;   }
name|void
name|addReferenceELF_AArch64
argument_list|(
argument|Reference::KindValue relocType
argument_list|,
argument|uint64_t off
argument_list|,
argument|const Atom *t
argument_list|,
argument|Reference::Addend a
argument_list|)
block|{
name|addReferenceELF
argument_list|(
name|Reference
operator|::
name|KindArch
operator|::
name|AArch64
argument_list|,
name|relocType
argument_list|,
name|off
argument_list|,
name|t
argument_list|,
name|a
argument_list|)
block|;   }
name|void
name|addReferenceELF_ARM
argument_list|(
argument|Reference::KindValue relocType
argument_list|,
argument|uint64_t off
argument_list|,
argument|const Atom *t
argument_list|,
argument|Reference::Addend a
argument_list|)
block|{
name|addReferenceELF
argument_list|(
name|Reference
operator|::
name|KindArch
operator|::
name|ARM
argument_list|,
name|relocType
argument_list|,
name|off
argument_list|,
name|t
argument_list|,
name|a
argument_list|)
block|;   }
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// \brief Atom which represents an object for which a COPY relocation will be
end_comment

begin_comment
comment|///   generated.
end_comment

begin_decl_stmt
name|class
name|ObjectAtom
range|:
name|public
name|SimpleELFDefinedAtom
block|{
name|public
operator|:
name|ObjectAtom
argument_list|(
specifier|const
name|File
operator|&
name|f
argument_list|)
operator|:
name|SimpleELFDefinedAtom
argument_list|(
argument|f
argument_list|)
block|{}
name|Scope
name|scope
argument_list|()
specifier|const
name|override
block|{
return|return
name|scopeGlobal
return|;
block|}
name|SectionChoice
name|sectionChoice
argument_list|()
specifier|const
name|override
block|{
return|return
name|sectionBasedOnContent
return|;
block|}
name|ContentType
name|contentType
argument_list|()
specifier|const
name|override
block|{
return|return
name|typeZeroFill
return|;
block|}
name|uint64_t
name|size
argument_list|()
specifier|const
name|override
block|{
return|return
name|_size
return|;
block|}
name|DynamicExport
name|dynamicExport
argument_list|()
specifier|const
name|override
block|{
return|return
name|dynamicExportAlways
return|;
block|}
name|ContentPermissions
name|permissions
argument_list|()
specifier|const
name|override
block|{
return|return
name|permRW_
return|;
block|}
name|ArrayRef
operator|<
name|uint8_t
operator|>
name|rawContent
argument_list|()
specifier|const
name|override
block|{
return|return
name|ArrayRef
operator|<
name|uint8_t
operator|>
operator|(
operator|)
return|;
block|}
name|Alignment
name|alignment
argument_list|()
specifier|const
name|override
block|{
return|return
literal|8
return|;
block|}
name|StringRef
name|name
argument_list|()
specifier|const
name|override
block|{
return|return
name|_name
return|;
block|}
name|std
operator|::
name|string
name|_name
block|;
name|uint64_t
name|_size
block|; }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|class
name|GOTAtom
range|:
name|public
name|SimpleELFDefinedAtom
block|{
name|StringRef
name|_section
block|;
name|public
operator|:
name|GOTAtom
argument_list|(
argument|const File&f
argument_list|,
argument|StringRef secName
argument_list|)
operator|:
name|SimpleELFDefinedAtom
argument_list|(
name|f
argument_list|)
block|,
name|_section
argument_list|(
argument|secName
argument_list|)
block|{}
name|Scope
name|scope
argument_list|()
specifier|const
name|override
block|{
return|return
name|scopeTranslationUnit
return|;
block|}
name|SectionChoice
name|sectionChoice
argument_list|()
specifier|const
name|override
block|{
return|return
name|sectionCustomRequired
return|;
block|}
name|StringRef
name|customSectionName
argument_list|()
specifier|const
name|override
block|{
return|return
name|_section
return|;
block|}
name|ContentType
name|contentType
argument_list|()
specifier|const
name|override
block|{
return|return
name|typeGOT
return|;
block|}
name|uint64_t
name|size
argument_list|()
specifier|const
name|override
block|{
return|return
name|rawContent
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
name|ContentPermissions
name|permissions
argument_list|()
specifier|const
name|override
block|{
return|return
name|permRW_
return|;
block|}
name|Alignment
name|alignment
argument_list|()
specifier|const
name|override
block|{
return|return
literal|8
return|;
block|}
ifndef|#
directive|ifndef
name|NDEBUG
name|StringRef
name|name
argument_list|()
specifier|const
name|override
block|{
return|return
name|_name
return|;
block|}
name|std
operator|::
name|string
name|_name
block|;
else|#
directive|else
name|StringRef
name|name
argument_list|()
specifier|const
name|override
block|{
return|return
literal|""
return|;
block|}
endif|#
directive|endif
expr|}
block|;
name|class
name|PLTAtom
operator|:
name|public
name|SimpleELFDefinedAtom
block|{
name|StringRef
name|_section
block|;
name|public
operator|:
name|PLTAtom
argument_list|(
argument|const File&f
argument_list|,
argument|StringRef secName
argument_list|)
operator|:
name|SimpleELFDefinedAtom
argument_list|(
name|f
argument_list|)
block|,
name|_section
argument_list|(
argument|secName
argument_list|)
block|{}
name|Scope
name|scope
argument_list|()
specifier|const
name|override
block|{
return|return
name|scopeTranslationUnit
return|;
block|}
name|SectionChoice
name|sectionChoice
argument_list|()
specifier|const
name|override
block|{
return|return
name|sectionCustomRequired
return|;
block|}
name|StringRef
name|customSectionName
argument_list|()
specifier|const
name|override
block|{
return|return
name|_section
return|;
block|}
name|ContentType
name|contentType
argument_list|()
specifier|const
name|override
block|{
return|return
name|typeStub
return|;
block|}
name|uint64_t
name|size
argument_list|()
specifier|const
name|override
block|{
return|return
name|rawContent
argument_list|()
operator|.
name|size
argument_list|()
return|;
block|}
name|ContentPermissions
name|permissions
argument_list|()
specifier|const
name|override
block|{
return|return
name|permR_X
return|;
block|}
name|Alignment
name|alignment
argument_list|()
specifier|const
name|override
block|{
return|return
literal|16
return|;
block|}
ifndef|#
directive|ifndef
name|NDEBUG
name|StringRef
name|name
argument_list|()
specifier|const
name|override
block|{
return|return
name|_name
return|;
block|}
name|std
operator|::
name|string
name|_name
block|;
else|#
directive|else
name|StringRef
name|name
argument_list|()
specifier|const
name|override
block|{
return|return
literal|""
return|;
block|}
endif|#
directive|endif
expr|}
block|;
name|class
name|PLT0Atom
operator|:
name|public
name|PLTAtom
block|{
name|public
operator|:
name|PLT0Atom
argument_list|(
specifier|const
name|File
operator|&
name|f
argument_list|)
operator|:
name|PLTAtom
argument_list|(
argument|f
argument_list|,
literal|".plt"
argument_list|)
block|{
ifndef|#
directive|ifndef
name|NDEBUG
name|_name
operator|=
literal|".PLT0"
block|;
endif|#
directive|endif
block|}
block|}
block|;
name|class
name|GlobalOffsetTableAtom
operator|:
name|public
name|SimpleELFDefinedAtom
block|{
name|public
operator|:
name|GlobalOffsetTableAtom
argument_list|(
specifier|const
name|File
operator|&
name|f
argument_list|)
operator|:
name|SimpleELFDefinedAtom
argument_list|(
argument|f
argument_list|)
block|{}
name|StringRef
name|name
argument_list|()
specifier|const
name|override
block|{
return|return
literal|"_GLOBAL_OFFSET_TABLE_"
return|;
block|}
name|Scope
name|scope
argument_list|()
specifier|const
name|override
block|{
return|return
name|scopeLinkageUnit
return|;
block|}
name|SectionChoice
name|sectionChoice
argument_list|()
specifier|const
name|override
block|{
return|return
name|sectionCustomRequired
return|;
block|}
name|StringRef
name|customSectionName
argument_list|()
specifier|const
name|override
block|{
return|return
literal|".got.plt"
return|;
block|}
name|ContentType
name|contentType
argument_list|()
specifier|const
name|override
block|{
return|return
name|typeGOT
return|;
block|}
name|uint64_t
name|size
argument_list|()
specifier|const
name|override
block|{
return|return
literal|0
return|;
block|}
name|ContentPermissions
name|permissions
argument_list|()
specifier|const
name|override
block|{
return|return
name|permRW_
return|;
block|}
name|Alignment
name|alignment
argument_list|()
specifier|const
name|override
block|{
return|return
literal|8
return|;
block|}
name|ArrayRef
operator|<
name|uint8_t
operator|>
name|rawContent
argument_list|()
specifier|const
name|override
block|{
return|return
name|ArrayRef
operator|<
name|uint8_t
operator|>
operator|(
operator|)
return|;
block|}
expr|}
block|;
name|class
name|DynamicAtom
operator|:
name|public
name|SimpleELFDefinedAtom
block|{
name|public
operator|:
name|DynamicAtom
argument_list|(
specifier|const
name|File
operator|&
name|f
argument_list|)
operator|:
name|SimpleELFDefinedAtom
argument_list|(
argument|f
argument_list|)
block|{}
name|StringRef
name|name
argument_list|()
specifier|const
name|override
block|{
return|return
literal|"_DYNAMIC"
return|;
block|}
name|Scope
name|scope
argument_list|()
specifier|const
name|override
block|{
return|return
name|scopeLinkageUnit
return|;
block|}
name|Merge
name|merge
argument_list|()
specifier|const
name|override
block|{
return|return
name|mergeNo
return|;
block|}
name|SectionChoice
name|sectionChoice
argument_list|()
specifier|const
name|override
block|{
return|return
name|sectionCustomRequired
return|;
block|}
name|StringRef
name|customSectionName
argument_list|()
specifier|const
name|override
block|{
return|return
literal|".dynamic"
return|;
block|}
name|ContentType
name|contentType
argument_list|()
specifier|const
name|override
block|{
return|return
name|typeData
return|;
block|}
name|uint64_t
name|size
argument_list|()
specifier|const
name|override
block|{
return|return
literal|0
return|;
block|}
name|ContentPermissions
name|permissions
argument_list|()
specifier|const
name|override
block|{
return|return
name|permRW_
return|;
block|}
name|Alignment
name|alignment
argument_list|()
specifier|const
name|override
block|{
return|return
literal|1
return|;
block|}
name|ArrayRef
operator|<
name|uint8_t
operator|>
name|rawContent
argument_list|()
specifier|const
name|override
block|{
return|return
name|ArrayRef
operator|<
name|uint8_t
operator|>
operator|(
operator|)
return|;
block|}
expr|}
block|;  }
comment|// end namespace elf
block|}
end_decl_stmt

begin_comment
comment|// end namespace lld
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLD_READER_WRITER_ELF_ATOMS_H
end_comment

end_unit

