begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- lib/ReaderWriter/ELF/Hexagon/HexagonSectionChunks.h-----------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                             The LLVM Linker
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|HEXAGON_SECTION_CHUNKS_H
end_ifndef

begin_define
define|#
directive|define
name|HEXAGON_SECTION_CHUNKS_H
end_define

begin_include
include|#
directive|include
file|"HexagonTargetHandler.h"
end_include

begin_decl_stmt
name|namespace
name|lld
block|{
name|namespace
name|elf
block|{
name|template
operator|<
name|typename
name|ELFT
operator|>
name|class
name|HexagonTargetLayout
expr_stmt|;
name|class
name|HexagonLinkingContext
decl_stmt|;
comment|/// \brief Handle Hexagon SData section
name|template
operator|<
name|class
name|HexagonELFType
operator|>
name|class
name|SDataSection
operator|:
name|public
name|AtomSection
operator|<
name|HexagonELFType
operator|>
block|{
name|public
operator|:
name|SDataSection
argument_list|(
specifier|const
name|HexagonLinkingContext
operator|&
name|context
argument_list|)
operator|:
name|AtomSection
operator|<
name|HexagonELFType
operator|>
operator|(
name|context
operator|,
literal|".sdata"
operator|,
name|DefinedAtom
operator|::
name|typeDataFast
operator|,
literal|0
operator|,
name|HexagonTargetLayout
operator|<
name|HexagonELFType
operator|>
operator|::
name|ORDER_SDATA
operator|)
block|{
name|this
operator|->
name|_type
operator|=
name|SHT_PROGBITS
block|;
name|this
operator|->
name|_flags
operator|=
name|SHF_ALLOC
operator||
name|SHF_WRITE
block|;
name|this
operator|->
name|_alignment
operator|=
literal|4096
block|;   }
comment|/// \brief Finalize the section contents before writing
name|virtual
name|void
name|doPreFlight
argument_list|()
block|;
comment|/// \brief Does this section have an output segment.
name|virtual
name|bool
name|hasOutputSegment
argument_list|()
block|{
return|return
name|true
return|;
block|}
specifier|const
name|lld
operator|::
name|AtomLayout
operator|*
name|appendAtom
argument_list|(
argument|const Atom *atom
argument_list|)
block|{
specifier|const
name|DefinedAtom
operator|*
name|definedAtom
operator|=
name|cast
operator|<
name|DefinedAtom
operator|>
operator|(
name|atom
operator|)
block|;
name|DefinedAtom
operator|::
name|Alignment
name|atomAlign
operator|=
name|definedAtom
operator|->
name|alignment
argument_list|()
block|;
name|uint64_t
name|alignment
operator|=
literal|1u
operator|<<
name|atomAlign
operator|.
name|powerOf2
block|;
name|this
operator|->
name|_atoms
operator|.
name|push_back
argument_list|(
name|new
argument_list|(
argument|this->_alloc
argument_list|)
name|lld
operator|::
name|AtomLayout
argument_list|(
name|atom
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
block|;
comment|// Set the section alignment to the largest alignment
comment|// std::max doesn't support uint64_t
if|if
condition|(
name|this
operator|->
name|_alignment
operator|<
name|alignment
condition|)
name|this
operator|->
name|_alignment
operator|=
name|alignment
expr_stmt|;
return|return
operator|(
name|this
operator|->
name|_atoms
operator|.
name|back
argument_list|()
operator|)
return|;
block|}
block|}
empty_stmt|;
comment|// SDataSection
name|template
operator|<
name|class
name|HexagonELFType
operator|>
name|void
name|SDataSection
operator|<
name|HexagonELFType
operator|>
operator|::
name|doPreFlight
argument_list|()
block|{
comment|// sort the atoms on the alignments they have been set
name|std
operator|::
name|stable_sort
argument_list|(
name|this
operator|->
name|_atoms
operator|.
name|begin
argument_list|()
argument_list|,
name|this
operator|->
name|_atoms
operator|.
name|end
argument_list|()
argument_list|,
index|[]
operator|(
specifier|const
name|lld
operator|::
name|AtomLayout
operator|*
name|A
operator|,
specifier|const
name|lld
operator|::
name|AtomLayout
operator|*
name|B
operator|)
block|{
specifier|const
name|DefinedAtom
operator|*
name|definedAtomA
operator|=
name|cast
operator|<
name|DefinedAtom
operator|>
operator|(
name|A
operator|->
name|_atom
operator|)
block|;
specifier|const
name|DefinedAtom
operator|*
name|definedAtomB
operator|=
name|cast
operator|<
name|DefinedAtom
operator|>
operator|(
name|B
operator|->
name|_atom
operator|)
block|;
name|int64_t
name|alignmentA
operator|=
literal|1
operator|<<
name|definedAtomA
operator|->
name|alignment
argument_list|()
operator|.
name|powerOf2
block|;
name|int64_t
name|alignmentB
operator|=
literal|1
operator|<<
name|definedAtomB
operator|->
name|alignment
argument_list|()
operator|.
name|powerOf2
block|;
if|if
condition|(
name|alignmentA
operator|==
name|alignmentB
condition|)
block|{
if|if
condition|(
name|definedAtomA
operator|->
name|merge
argument_list|()
operator|==
name|DefinedAtom
operator|::
name|mergeAsTentative
condition|)
return|return
name|false
return|;
if|if
condition|(
name|definedAtomB
operator|->
name|merge
argument_list|()
operator|==
name|DefinedAtom
operator|::
name|mergeAsTentative
condition|)
return|return
name|true
return|;
block|}
return|return
name|alignmentA
operator|<
name|alignmentB
return|;
block|}
argument_list|)
block|;
comment|// Set the fileOffset, and the appropriate size of the section
for|for
control|(
name|auto
operator|&
name|ai
operator|:
name|this
operator|->
name|_atoms
control|)
block|{
specifier|const
name|DefinedAtom
modifier|*
name|definedAtom
init|=
name|cast
operator|<
name|DefinedAtom
operator|>
operator|(
name|ai
operator|->
name|_atom
operator|)
decl_stmt|;
name|DefinedAtom
operator|::
name|Alignment
name|atomAlign
operator|=
name|definedAtom
operator|->
name|alignment
argument_list|()
expr_stmt|;
name|uint64_t
name|fOffset
init|=
name|this
operator|->
name|alignOffset
argument_list|(
name|this
operator|->
name|fileSize
argument_list|()
argument_list|,
name|atomAlign
argument_list|)
decl_stmt|;
name|uint64_t
name|mOffset
init|=
name|this
operator|->
name|alignOffset
argument_list|(
name|this
operator|->
name|memSize
argument_list|()
argument_list|,
name|atomAlign
argument_list|)
decl_stmt|;
name|ai
operator|->
name|_fileOffset
operator|=
name|fOffset
expr_stmt|;
name|this
operator|->
name|_fsize
operator|=
name|fOffset
operator|+
name|definedAtom
operator|->
name|size
argument_list|()
expr_stmt|;
name|this
operator|->
name|_msize
operator|=
name|mOffset
operator|+
name|definedAtom
operator|->
name|size
argument_list|()
expr_stmt|;
block|}
block|}
comment|// finalize
block|}
end_decl_stmt

begin_comment
comment|// elf
end_comment

begin_comment
unit|}
comment|// lld
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLD_READER_WRITER_ELF_HEXAGON_HEXAGON_SECTION_CHUNKS_H
end_comment

end_unit

