begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- lib/ReaderWriter/ELF/SectionChunks.h -------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                             The LLVM Linker
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLD_READER_WRITER_ELF_SECTION_CHUNKS_H
end_ifndef

begin_define
define|#
directive|define
name|LLD_READER_WRITER_ELF_SECTION_CHUNKS_H
end_define

begin_include
include|#
directive|include
file|"Chunk.h"
end_include

begin_include
include|#
directive|include
file|"Layout.h"
end_include

begin_include
include|#
directive|include
file|"TargetHandler.h"
end_include

begin_include
include|#
directive|include
file|"Writer.h"
end_include

begin_include
include|#
directive|include
file|"lld/Core/DefinedAtom.h"
end_include

begin_include
include|#
directive|include
file|"lld/Core/Parallel.h"
end_include

begin_include
include|#
directive|include
file|"lld/Core/range.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringExtras.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Object/ELF.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Allocator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Debug.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Dwarf.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ELF.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/FileOutputBuffer.h"
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_include
include|#
directive|include
file|<mutex>
end_include

begin_decl_stmt
name|namespace
name|lld
block|{
name|namespace
name|elf
block|{
name|template
operator|<
name|class
operator|>
name|class
name|OutputSection
expr_stmt|;
name|using
name|namespace
name|llvm
operator|::
name|ELF
expr_stmt|;
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|Segment
expr_stmt|;
comment|/// \brief An ELF section.
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|Section
operator|:
name|public
name|Chunk
operator|<
name|ELFT
operator|>
block|{
name|public
operator|:
name|Section
argument_list|(
argument|const ELFLinkingContext&context
argument_list|,
argument|StringRef sectionName
argument_list|,
argument|StringRef chunkName
argument_list|,
argument|typename Chunk<ELFT>::Kind k = Chunk<ELFT>::Kind::ELFSection
argument_list|)
operator|:
name|Chunk
operator|<
name|ELFT
operator|>
operator|(
name|chunkName
operator|,
name|k
operator|,
name|context
operator|)
block|,
name|_outputSection
argument_list|(
name|nullptr
argument_list|)
block|,
name|_flags
argument_list|(
literal|0
argument_list|)
block|,
name|_entSize
argument_list|(
literal|0
argument_list|)
block|,
name|_type
argument_list|(
literal|0
argument_list|)
block|,
name|_link
argument_list|(
literal|0
argument_list|)
block|,
name|_info
argument_list|(
literal|0
argument_list|)
block|,
name|_isFirstSectionInOutputSection
argument_list|(
name|false
argument_list|)
block|,
name|_segmentType
argument_list|(
name|SHT_NULL
argument_list|)
block|,
name|_inputSectionName
argument_list|(
name|sectionName
argument_list|)
block|,
name|_outputSectionName
argument_list|(
argument|sectionName
argument_list|)
block|{}
comment|/// \brief Modify the section contents before assigning virtual addresses
comment|//  or assigning file offsets
name|void
name|doPreFlight
argument_list|()
name|override
block|{}
comment|/// \brief Finalize the section contents before writing
name|void
name|finalize
argument_list|()
name|override
block|{}
comment|/// \brief Does this section have an output segment.
name|virtual
name|bool
name|hasOutputSegment
argument_list|()
block|{
return|return
name|false
return|;
block|}
comment|/// Return if the section is a loadable section that occupies memory
name|virtual
name|bool
name|isLoadableSection
argument_list|()
specifier|const
block|{
return|return
name|false
return|;
block|}
comment|/// \brief Assign file offsets starting at offset.
name|virtual
name|void
name|assignFileOffsets
argument_list|(
argument|uint64_t offset
argument_list|)
block|{}
comment|/// \brief Assign virtual addresses starting at addr.
name|virtual
name|void
name|assignVirtualAddress
argument_list|(
argument|uint64_t addr
argument_list|)
block|{}
name|uint64_t
name|getFlags
argument_list|()
specifier|const
block|{
return|return
name|_flags
return|;
block|}
name|uint64_t
name|getEntSize
argument_list|()
specifier|const
block|{
return|return
name|_entSize
return|;
block|}
name|uint32_t
name|getType
argument_list|()
specifier|const
block|{
return|return
name|_type
return|;
block|}
name|uint32_t
name|getLink
argument_list|()
specifier|const
block|{
return|return
name|_link
return|;
block|}
name|uint32_t
name|getInfo
argument_list|()
specifier|const
block|{
return|return
name|_info
return|;
block|}
name|Layout
operator|::
name|SegmentType
name|getSegmentType
argument_list|()
specifier|const
block|{
return|return
name|_segmentType
return|;
block|}
comment|/// \brief Return the type of content that the section contains
name|virtual
name|int
name|getContentType
argument_list|()
specifier|const
name|override
block|{
if|if
condition|(
name|_flags
operator|&
name|llvm
operator|::
name|ELF
operator|::
name|SHF_EXECINSTR
condition|)
return|return
name|Chunk
operator|<
name|ELFT
operator|>
operator|::
name|ContentType
operator|::
name|Code
return|;
elseif|else
if|if
condition|(
name|_flags
operator|&
name|llvm
operator|::
name|ELF
operator|::
name|SHF_WRITE
condition|)
return|return
name|Chunk
operator|<
name|ELFT
operator|>
operator|::
name|ContentType
operator|::
name|Data
return|;
elseif|else
if|if
condition|(
name|_flags
operator|&
name|llvm
operator|::
name|ELF
operator|::
name|SHF_ALLOC
condition|)
return|return
name|Chunk
operator|<
name|ELFT
operator|>
operator|::
name|ContentType
operator|::
name|Code
return|;
else|else
return|return
name|Chunk
operator|<
name|ELFT
operator|>
operator|::
name|ContentType
operator|::
name|Unknown
return|;
block|}
comment|/// \brief convert the segment type to a String for diagnostics and printing
comment|/// purposes
name|StringRef
name|segmentKindToStr
argument_list|()
specifier|const
block|;
comment|/// \brief Records the segmentType, that this section belongs to
name|void
name|setSegmentType
argument_list|(
argument|const Layout::SegmentType segmentType
argument_list|)
block|{
name|this
operator|->
name|_segmentType
operator|=
name|segmentType
block|;   }
name|virtual
specifier|const
name|AtomLayout
operator|*
name|findAtomLayoutByName
argument_list|(
argument|StringRef
argument_list|)
specifier|const
block|{
return|return
name|nullptr
return|;
block|}
name|void
name|setOutputSection
argument_list|(
argument|OutputSection<ELFT> *os
argument_list|,
argument|bool isFirst = false
argument_list|)
block|{
name|_outputSection
operator|=
name|os
block|;
name|_isFirstSectionInOutputSection
operator|=
name|isFirst
block|;   }
specifier|static
name|bool
name|classof
argument_list|(
argument|const Chunk<ELFT> *c
argument_list|)
block|{
return|return
name|c
operator|->
name|kind
argument_list|()
operator|==
name|Chunk
operator|<
name|ELFT
operator|>
operator|::
name|Kind
operator|::
name|ELFSection
operator|||
name|c
operator|->
name|kind
argument_list|()
operator|==
name|Chunk
operator|<
name|ELFT
operator|>
operator|::
name|Kind
operator|::
name|AtomSection
return|;
block|}
name|uint64_t
name|alignment
argument_list|()
specifier|const
name|override
block|{
return|return
name|_isFirstSectionInOutputSection
operator|?
name|_outputSection
operator|->
name|alignment
argument_list|()
operator|:
name|this
operator|->
name|_alignment
return|;
block|}
name|virtual
name|StringRef
name|inputSectionName
argument_list|()
specifier|const
block|{
return|return
name|_inputSectionName
return|;
block|}
name|virtual
name|StringRef
name|outputSectionName
argument_list|()
specifier|const
block|{
return|return
name|_outputSectionName
return|;
block|}
name|virtual
name|void
name|setOutputSectionName
argument_list|(
argument|StringRef outputSectionName
argument_list|)
block|{
name|_outputSectionName
operator|=
name|outputSectionName
block|;   }
name|void
name|setArchiveNameOrPath
argument_list|(
argument|StringRef name
argument_list|)
block|{
name|_archivePath
operator|=
name|name
block|; }
name|void
name|setMemberNameOrPath
argument_list|(
argument|StringRef name
argument_list|)
block|{
name|_memberPath
operator|=
name|name
block|; }
name|StringRef
name|archivePath
argument_list|()
block|{
return|return
name|_archivePath
return|;
block|}
name|StringRef
name|memberPath
argument_list|()
block|{
return|return
name|_memberPath
return|;
block|}
name|protected
operator|:
comment|/// \brief OutputSection this Section is a member of, or nullptr.
name|OutputSection
operator|<
name|ELFT
operator|>
operator|*
name|_outputSection
block|;
comment|/// \brief ELF SHF_* flags.
name|uint64_t
name|_flags
block|;
comment|/// \brief The size of each entity.
name|uint64_t
name|_entSize
block|;
comment|/// \brief ELF SHT_* type.
name|uint32_t
name|_type
block|;
comment|/// \brief sh_link field.
name|uint32_t
name|_link
block|;
comment|/// \brief the sh_info field.
name|uint32_t
name|_info
block|;
comment|/// \brief Is this the first section in the output section.
name|bool
name|_isFirstSectionInOutputSection
block|;
comment|/// \brief the output ELF segment type of this section.
name|Layout
operator|::
name|SegmentType
name|_segmentType
block|;
comment|/// \brief Input section name.
name|StringRef
name|_inputSectionName
block|;
comment|/// \brief Output section name.
name|StringRef
name|_outputSectionName
block|;
name|StringRef
name|_archivePath
block|;
name|StringRef
name|_memberPath
block|; }
expr_stmt|;
comment|/// \brief A section containing atoms.
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|AtomSection
operator|:
name|public
name|Section
operator|<
name|ELFT
operator|>
block|{
name|public
operator|:
name|AtomSection
argument_list|(
argument|const ELFLinkingContext&context
argument_list|,
argument|StringRef sectionName
argument_list|,
argument|int32_t contentType
argument_list|,
argument|int32_t permissions
argument_list|,
argument|int32_t order
argument_list|)
operator|:
name|Section
operator|<
name|ELFT
operator|>
operator|(
name|context
operator|,
name|sectionName
operator|,
literal|"AtomSection"
operator|,
name|Chunk
operator|<
name|ELFT
operator|>
operator|::
name|Kind
operator|::
name|AtomSection
operator|)
block|,
name|_contentType
argument_list|(
name|contentType
argument_list|)
block|,
name|_contentPermissions
argument_list|(
name|permissions
argument_list|)
block|,
name|_isLoadedInMemory
argument_list|(
argument|true
argument_list|)
block|{
name|this
operator|->
name|setOrder
argument_list|(
name|order
argument_list|)
block|;
switch|switch
condition|(
name|contentType
condition|)
block|{
case|case
name|DefinedAtom
operator|::
name|typeCode
case|:
case|case
name|DefinedAtom
operator|::
name|typeDataFast
case|:
case|case
name|DefinedAtom
operator|::
name|typeData
case|:
case|case
name|DefinedAtom
operator|::
name|typeConstant
case|:
case|case
name|DefinedAtom
operator|::
name|typeGOT
case|:
case|case
name|DefinedAtom
operator|::
name|typeStub
case|:
case|case
name|DefinedAtom
operator|::
name|typeResolver
case|:
case|case
name|DefinedAtom
operator|::
name|typeThreadData
case|:
name|this
operator|->
name|_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
break|break;
case|case
name|DefinedAtom
operator|::
name|typeThreadZeroFill
case|:
case|case
name|DefinedAtom
operator|::
name|typeZeroFillFast
case|:
case|case
name|DefinedAtom
operator|::
name|typeZeroFill
case|:
name|this
operator|->
name|_type
operator|=
name|SHT_NOBITS
expr_stmt|;
break|break;
case|case
name|DefinedAtom
operator|::
name|typeRONote
case|:
case|case
name|DefinedAtom
operator|::
name|typeRWNote
case|:
name|this
operator|->
name|_type
operator|=
name|SHT_NOTE
expr_stmt|;
break|break;
case|case
name|DefinedAtom
operator|::
name|typeNoAlloc
case|:
name|this
operator|->
name|_type
operator|=
name|SHT_PROGBITS
expr_stmt|;
name|this
operator|->
name|_isLoadedInMemory
operator|=
name|false
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|permissions
condition|)
block|{
case|case
name|DefinedAtom
operator|::
name|permR__
case|:
name|this
operator|->
name|_flags
operator|=
name|SHF_ALLOC
expr_stmt|;
break|break;
case|case
name|DefinedAtom
operator|::
name|permR_X
case|:
name|this
operator|->
name|_flags
operator|=
name|SHF_ALLOC
operator||
name|SHF_EXECINSTR
expr_stmt|;
break|break;
case|case
name|DefinedAtom
operator|::
name|permRW_
case|:
case|case
name|DefinedAtom
operator|::
name|permRW_L
case|:
name|this
operator|->
name|_flags
operator|=
name|SHF_ALLOC
operator||
name|SHF_WRITE
expr_stmt|;
if|if
condition|(
name|_contentType
operator|==
name|DefinedAtom
operator|::
name|typeThreadData
operator|||
name|_contentType
operator|==
name|DefinedAtom
operator|::
name|typeThreadZeroFill
condition|)
name|this
operator|->
name|_flags
operator||=
name|SHF_TLS
expr_stmt|;
break|break;
case|case
name|DefinedAtom
operator|::
name|permRWX
case|:
name|this
operator|->
name|_flags
operator|=
name|SHF_ALLOC
operator||
name|SHF_WRITE
operator||
name|SHF_EXECINSTR
expr_stmt|;
break|break;
case|case
name|DefinedAtom
operator|::
name|perm___
case|:
name|this
operator|->
name|_flags
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
comment|/// Align the offset to the required modulus defined by the atom alignment
name|uint64_t
name|alignOffset
argument_list|(
argument|uint64_t offset
argument_list|,
argument|DefinedAtom::Alignment&atomAlign
argument_list|)
block|;
comment|/// Return if the section is a loadable section that occupies memory
name|bool
name|isLoadableSection
argument_list|()
specifier|const
name|override
block|{
return|return
name|_isLoadedInMemory
return|;
block|}
comment|// \brief Append an atom to a Section. The atom gets pushed into a vector
comment|// contains the atom, the atom file offset, the atom virtual address
comment|// the atom file offset is aligned appropriately as set by the Reader
name|virtual
specifier|const
name|lld
operator|::
name|AtomLayout
operator|*
name|appendAtom
argument_list|(
specifier|const
name|Atom
operator|*
name|atom
argument_list|)
block|;
comment|/// \brief Set the virtual address of each Atom in the Section. This
comment|/// routine gets called after the linker fixes up the virtual address
comment|/// of the section
name|virtual
name|void
name|assignVirtualAddress
argument_list|(
argument|uint64_t addr
argument_list|)
name|override
block|{
name|parallel_for_each
argument_list|(
name|_atoms
operator|.
name|begin
argument_list|()
argument_list|,
name|_atoms
operator|.
name|end
argument_list|()
argument_list|,
index|[
operator|&
index|]
operator|(
name|AtomLayout
operator|*
name|ai
operator|)
block|{
name|ai
operator|->
name|_virtualAddr
operator|=
name|addr
operator|+
name|ai
operator|->
name|_fileOffset
block|;     }
argument_list|)
block|;   }
comment|/// \brief Set the file offset of each Atom in the section. This routine
comment|/// gets called after the linker fixes up the section offset
name|void
name|assignFileOffsets
argument_list|(
argument|uint64_t offset
argument_list|)
name|override
block|{
name|parallel_for_each
argument_list|(
name|_atoms
operator|.
name|begin
argument_list|()
argument_list|,
name|_atoms
operator|.
name|end
argument_list|()
argument_list|,
index|[
operator|&
index|]
operator|(
name|AtomLayout
operator|*
name|ai
operator|)
block|{
name|ai
operator|->
name|_fileOffset
operator|=
name|offset
operator|+
name|ai
operator|->
name|_fileOffset
block|;     }
argument_list|)
block|;   }
comment|/// \brief Find the Atom address given a name, this is needed to properly
comment|///  apply relocation. The section class calls this to find the atom address
comment|///  to fix the relocation
specifier|const
name|AtomLayout
operator|*
name|findAtomLayoutByName
argument_list|(
argument|StringRef name
argument_list|)
specifier|const
name|override
block|{
for|for
control|(
name|auto
name|ai
range|:
name|_atoms
control|)
if|if
condition|(
name|ai
operator|->
name|_atom
operator|->
name|name
argument_list|()
operator|==
name|name
condition|)
return|return
name|ai
return|;
return|return
name|nullptr
return|;
block|}
comment|/// \brief Return the raw flags, we need this to sort segments
name|int64_t
name|atomflags
argument_list|()
specifier|const
block|{
return|return
name|_contentPermissions
return|;
block|}
comment|/// Atom Iterators
typedef|typedef
name|typename
name|std
operator|::
name|vector
operator|<
name|lld
operator|::
name|AtomLayout
operator|*
operator|>
operator|::
name|iterator
name|atom_iter
expr_stmt|;
name|range
operator|<
name|atom_iter
operator|>
name|atoms
argument_list|()
block|{
return|return
name|_atoms
return|;
block|}
name|void
name|write
argument_list|(
name|ELFWriter
operator|*
name|writer
argument_list|,
name|TargetLayout
operator|<
name|ELFT
operator|>
operator|&
name|layout
argument_list|,
name|llvm
operator|::
name|FileOutputBuffer
operator|&
name|buffer
argument_list|)
name|override
decl_stmt|;
specifier|static
name|bool
name|classof
argument_list|(
specifier|const
name|Chunk
operator|<
name|ELFT
operator|>
operator|*
name|c
argument_list|)
block|{
return|return
name|c
operator|->
name|kind
argument_list|()
operator|==
name|Chunk
operator|<
name|ELFT
operator|>
operator|::
name|Kind
operator|::
name|AtomSection
return|;
block|}
name|protected
label|:
name|llvm
operator|::
name|BumpPtrAllocator
name|_alloc
expr_stmt|;
name|int32_t
name|_contentType
decl_stmt|;
name|int32_t
name|_contentPermissions
decl_stmt|;
name|bool
name|_isLoadedInMemory
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|lld
operator|::
name|AtomLayout
operator|*
operator|>
name|_atoms
expr_stmt|;
name|mutable
name|std
operator|::
name|mutex
name|_outputMutex
expr_stmt|;
name|void
name|printError
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|errorStr
argument_list|,
specifier|const
name|AtomLayout
operator|&
name|atom
argument_list|,
specifier|const
name|Reference
operator|&
name|ref
argument_list|)
decl|const
block|{
name|StringRef
name|kindValStr
decl_stmt|;
if|if
condition|(
operator|!
name|this
operator|->
name|_context
operator|.
name|registry
argument_list|()
operator|.
name|referenceKindToString
argument_list|(
name|ref
operator|.
name|kindNamespace
argument_list|()
argument_list|,
name|ref
operator|.
name|kindArch
argument_list|()
argument_list|,
name|ref
operator|.
name|kindValue
argument_list|()
argument_list|,
name|kindValStr
argument_list|)
condition|)
block|{
name|kindValStr
operator|=
literal|"unknown"
expr_stmt|;
block|}
name|std
operator|::
name|string
name|errStr
operator|=
operator|(
name|Twine
argument_list|(
name|errorStr
argument_list|)
operator|+
literal|" in file "
operator|+
name|atom
operator|.
name|_atom
operator|->
name|file
argument_list|()
operator|.
name|path
argument_list|()
operator|+
literal|": reference from "
operator|+
name|atom
operator|.
name|_atom
operator|->
name|name
argument_list|()
operator|+
literal|"+"
operator|+
name|Twine
argument_list|(
name|ref
operator|.
name|offsetInAtom
argument_list|()
argument_list|)
operator|+
literal|" to "
operator|+
name|ref
operator|.
name|target
argument_list|()
operator|->
name|name
argument_list|()
operator|+
literal|"+"
operator|+
name|Twine
argument_list|(
name|ref
operator|.
name|addend
argument_list|()
argument_list|)
operator|+
literal|" of type "
operator|+
name|Twine
argument_list|(
name|ref
operator|.
name|kindValue
argument_list|()
argument_list|)
operator|+
literal|" ("
operator|+
name|kindValStr
operator|+
literal|")\n"
operator|)
operator|.
name|str
argument_list|()
expr_stmt|;
comment|// Take the lock to prevent output getting interleaved between threads
name|std
operator|::
name|lock_guard
operator|<
name|std
operator|::
name|mutex
operator|>
name|lock
argument_list|(
name|_outputMutex
argument_list|)
expr_stmt|;
name|llvm
operator|::
name|errs
argument_list|()
operator|<<
name|errStr
expr_stmt|;
block|}
block|}
empty_stmt|;
comment|/// Align the offset to the required modulus defined by the atom alignment
name|template
operator|<
name|class
name|ELFT
operator|>
name|uint64_t
name|AtomSection
operator|<
name|ELFT
operator|>
operator|::
name|alignOffset
argument_list|(
argument|uint64_t offset
argument_list|,
argument|DefinedAtom::Alignment&atomAlign
argument_list|)
block|{
name|uint64_t
name|requiredModulus
operator|=
name|atomAlign
operator|.
name|modulus
block|;
name|uint64_t
name|alignment
operator|=
literal|1u
operator|<<
name|atomAlign
operator|.
name|powerOf2
block|;
name|uint64_t
name|currentModulus
operator|=
operator|(
name|offset
operator|%
name|alignment
operator|)
block|;
name|uint64_t
name|retOffset
operator|=
name|offset
block|;
if|if
condition|(
name|currentModulus
operator|!=
name|requiredModulus
condition|)
block|{
if|if
condition|(
name|requiredModulus
operator|>
name|currentModulus
condition|)
name|retOffset
operator|+=
name|requiredModulus
operator|-
name|currentModulus
expr_stmt|;
else|else
name|retOffset
operator|+=
name|alignment
operator|+
name|requiredModulus
operator|-
name|currentModulus
expr_stmt|;
block|}
return|return
name|retOffset
return|;
block|}
comment|// \brief Append an atom to a Section. The atom gets pushed into a vector
comment|// contains the atom, the atom file offset, the atom virtual address
comment|// the atom file offset is aligned appropriately as set by the Reader
name|template
operator|<
name|class
name|ELFT
operator|>
specifier|const
name|lld
operator|::
name|AtomLayout
operator|*
name|AtomSection
operator|<
name|ELFT
operator|>
operator|::
name|appendAtom
argument_list|(
argument|const Atom *atom
argument_list|)
block|{
specifier|const
name|DefinedAtom
operator|*
name|definedAtom
operator|=
name|cast
operator|<
name|DefinedAtom
operator|>
operator|(
name|atom
operator|)
block|;
name|DefinedAtom
operator|::
name|Alignment
name|atomAlign
operator|=
name|definedAtom
operator|->
name|alignment
argument_list|()
block|;
name|uint64_t
name|alignment
operator|=
literal|1u
operator|<<
name|atomAlign
operator|.
name|powerOf2
block|;
comment|// Align the atom to the required modulus/ align the file offset and the
comment|// memory offset separately this is required so that BSS symbols are handled
comment|// properly as the BSS symbols only occupy memory size and not file size
name|uint64_t
name|fOffset
operator|=
name|alignOffset
argument_list|(
name|this
operator|->
name|fileSize
argument_list|()
argument_list|,
name|atomAlign
argument_list|)
block|;
name|uint64_t
name|mOffset
operator|=
name|alignOffset
argument_list|(
name|this
operator|->
name|memSize
argument_list|()
argument_list|,
name|atomAlign
argument_list|)
block|;
switch|switch
condition|(
name|definedAtom
operator|->
name|contentType
argument_list|()
condition|)
block|{
case|case
name|DefinedAtom
operator|::
name|typeCode
case|:
case|case
name|DefinedAtom
operator|::
name|typeConstant
case|:
case|case
name|DefinedAtom
operator|::
name|typeData
case|:
case|case
name|DefinedAtom
operator|::
name|typeDataFast
case|:
case|case
name|DefinedAtom
operator|::
name|typeZeroFillFast
case|:
case|case
name|DefinedAtom
operator|::
name|typeGOT
case|:
case|case
name|DefinedAtom
operator|::
name|typeStub
case|:
case|case
name|DefinedAtom
operator|::
name|typeResolver
case|:
case|case
name|DefinedAtom
operator|::
name|typeThreadData
case|:
case|case
name|DefinedAtom
operator|::
name|typeRONote
case|:
case|case
name|DefinedAtom
operator|::
name|typeRWNote
case|:
name|_atoms
operator|.
name|push_back
argument_list|(
name|new
argument_list|(
argument|_alloc
argument_list|)
name|lld
operator|::
name|AtomLayout
argument_list|(
name|atom
argument_list|,
name|fOffset
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|->
name|_fsize
operator|=
name|fOffset
operator|+
name|definedAtom
operator|->
name|size
argument_list|()
expr_stmt|;
name|this
operator|->
name|_msize
operator|=
name|mOffset
operator|+
name|definedAtom
operator|->
name|size
argument_list|()
expr_stmt|;
name|DEBUG_WITH_TYPE
argument_list|(
literal|"Section"
argument_list|,
name|llvm
operator|::
name|dbgs
argument_list|()
operator|<<
literal|"["
operator|<<
name|this
operator|->
name|name
argument_list|()
operator|<<
literal|" "
operator|<<
name|this
operator|<<
literal|"] "
operator|<<
literal|"Adding atom: "
operator|<<
name|atom
operator|->
name|name
argument_list|()
operator|<<
literal|"@"
operator|<<
name|fOffset
operator|<<
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DefinedAtom
operator|::
name|typeNoAlloc
case|:
name|_atoms
operator|.
name|push_back
argument_list|(
name|new
argument_list|(
argument|_alloc
argument_list|)
name|lld
operator|::
name|AtomLayout
argument_list|(
name|atom
argument_list|,
name|fOffset
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|->
name|_fsize
operator|=
name|fOffset
operator|+
name|definedAtom
operator|->
name|size
argument_list|()
expr_stmt|;
name|DEBUG_WITH_TYPE
argument_list|(
literal|"Section"
argument_list|,
name|llvm
operator|::
name|dbgs
argument_list|()
operator|<<
literal|"["
operator|<<
name|this
operator|->
name|name
argument_list|()
operator|<<
literal|" "
operator|<<
name|this
operator|<<
literal|"] "
operator|<<
literal|"Adding atom: "
operator|<<
name|atom
operator|->
name|name
argument_list|()
operator|<<
literal|"@"
operator|<<
name|fOffset
operator|<<
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DefinedAtom
operator|::
name|typeThreadZeroFill
case|:
case|case
name|DefinedAtom
operator|::
name|typeZeroFill
case|:
name|_atoms
operator|.
name|push_back
argument_list|(
name|new
argument_list|(
argument|_alloc
argument_list|)
name|lld
operator|::
name|AtomLayout
argument_list|(
name|atom
argument_list|,
name|mOffset
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|this
operator|->
name|_msize
operator|=
name|mOffset
operator|+
name|definedAtom
operator|->
name|size
argument_list|()
expr_stmt|;
break|break;
default|default:
name|llvm
operator|::
name|dbgs
argument_list|()
operator|<<
name|definedAtom
operator|->
name|contentType
argument_list|()
operator|<<
literal|"\n"
expr_stmt|;
name|llvm_unreachable
argument_list|(
literal|"Uexpected content type."
argument_list|)
expr_stmt|;
block|}
comment|// Set the section alignment to the largest alignment
comment|// std::max doesn't support uint64_t
if|if
condition|(
name|this
operator|->
name|_alignment
operator|<
name|alignment
condition|)
name|this
operator|->
name|_alignment
operator|=
name|alignment
expr_stmt|;
if|if
condition|(
name|_atoms
operator|.
name|size
argument_list|()
condition|)
return|return
name|_atoms
operator|.
name|back
argument_list|()
return|;
return|return
name|nullptr
return|;
block|}
end_decl_stmt

begin_comment
comment|/// \brief convert the segment type to a String for diagnostics
end_comment

begin_comment
comment|///        and printing purposes
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|StringRef
name|Section
operator|<
name|ELFT
operator|>
operator|::
name|segmentKindToStr
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|_segmentType
condition|)
block|{
case|case
name|llvm
operator|::
name|ELF
operator|::
name|PT_DYNAMIC
case|:
return|return
literal|"DYNAMIC"
return|;
case|case
name|llvm
operator|::
name|ELF
operator|::
name|PT_INTERP
case|:
return|return
literal|"INTERP"
return|;
case|case
name|llvm
operator|::
name|ELF
operator|::
name|PT_LOAD
case|:
return|return
literal|"LOAD"
return|;
case|case
name|llvm
operator|::
name|ELF
operator|::
name|PT_GNU_EH_FRAME
case|:
return|return
literal|"EH_FRAME"
return|;
case|case
name|llvm
operator|::
name|ELF
operator|::
name|PT_GNU_RELRO
case|:
return|return
literal|"GNU_RELRO"
return|;
case|case
name|llvm
operator|::
name|ELF
operator|::
name|PT_NOTE
case|:
return|return
literal|"NOTE"
return|;
case|case
name|llvm
operator|::
name|ELF
operator|::
name|PT_NULL
case|:
return|return
literal|"NULL"
return|;
case|case
name|llvm
operator|::
name|ELF
operator|::
name|PT_TLS
case|:
return|return
literal|"TLS"
return|;
default|default:
return|return
literal|"UNKNOWN"
return|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|/// \brief Write the section and the atom contents to the buffer
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|ELFT
operator|>
name|void
name|AtomSection
operator|<
name|ELFT
operator|>
operator|::
name|write
argument_list|(
argument|ELFWriter *writer
argument_list|,
argument|TargetLayout<ELFT>&layout
argument_list|,
argument|llvm::FileOutputBuffer&buffer
argument_list|)
block|{
name|uint8_t
operator|*
name|chunkBuffer
operator|=
name|buffer
operator|.
name|getBufferStart
argument_list|()
block|;
name|bool
name|success
operator|=
name|true
block|;
name|parallel_for_each
argument_list|(
name|_atoms
operator|.
name|begin
argument_list|()
argument_list|,
name|_atoms
operator|.
name|end
argument_list|()
argument_list|,
index|[
operator|&
index|]
operator|(
name|lld
operator|::
name|AtomLayout
operator|*
name|ai
operator|)
block|{
name|DEBUG_WITH_TYPE
argument_list|(
literal|"Section"
argument_list|,
name|llvm
operator|::
name|dbgs
argument_list|()
operator|<<
literal|"Writing atom: "
operator|<<
name|ai
operator|->
name|_atom
operator|->
name|name
argument_list|()
operator|<<
literal|" | "
operator|<<
name|ai
operator|->
name|_fileOffset
operator|<<
literal|"\n"
argument_list|)
block|;
specifier|const
name|DefinedAtom
operator|*
name|definedAtom
operator|=
name|cast
operator|<
name|DefinedAtom
operator|>
operator|(
name|ai
operator|->
name|_atom
operator|)
block|;
if|if
condition|(
operator|!
name|definedAtom
operator|->
name|occupiesDiskSpace
argument_list|()
condition|)
return|return;
comment|// Copy raw content of atom to file buffer.
name|ArrayRef
operator|<
name|uint8_t
operator|>
name|content
operator|=
name|definedAtom
operator|->
name|rawContent
argument_list|()
argument_list|;
name|uint64_t
name|contentSize
operator|=
name|content
operator|.
name|size
argument_list|()
argument_list|;     if
operator|(
name|contentSize
operator|==
literal|0
operator|)
return|return;
name|uint8_t
operator|*
name|atomContent
operator|=
name|chunkBuffer
operator|+
name|ai
operator|->
name|_fileOffset
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|memcpy
argument_list|(
name|atomContent
argument_list|,
name|content
operator|.
name|data
argument_list|()
argument_list|,
name|contentSize
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|const
name|TargetRelocationHandler
modifier|&
name|relHandler
init|=
name|this
operator|->
name|_context
operator|.
name|template
name|getTargetHandler
operator|<
name|ELFT
operator|>
operator|(
operator|)
operator|.
name|getRelocationHandler
argument_list|()
decl_stmt|;
end_decl_stmt

begin_for
for|for
control|(
specifier|const
specifier|auto
name|ref
range|:
operator|*
name|definedAtom
control|)
block|{
if|if
condition|(
name|std
operator|::
name|error_code
name|ec
operator|=
name|relHandler
operator|.
name|applyRelocation
argument_list|(
operator|*
name|writer
argument_list|,
name|buffer
argument_list|,
operator|*
name|ai
argument_list|,
operator|*
name|ref
argument_list|)
condition|)
block|{
name|printError
argument_list|(
name|ec
operator|.
name|message
argument_list|()
argument_list|,
operator|*
name|ai
argument_list|,
operator|*
name|ref
argument_list|)
expr_stmt|;
name|success
operator|=
name|false
expr_stmt|;
block|}
block|}
end_for

begin_empty_stmt
unit|})
empty_stmt|;
end_empty_stmt

begin_if
if|if
condition|(
operator|!
name|success
condition|)
name|llvm
operator|::
name|report_fatal_error
argument_list|(
literal|"relocating output"
argument_list|)
expr_stmt|;
end_if

begin_comment
unit|}
comment|/// \brief A OutputSection represents a set of sections grouped by the same
end_comment

begin_comment
comment|/// name. The output file that gets written by the linker has sections grouped
end_comment

begin_comment
comment|/// by similar names
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|OutputSection
block|{
name|public
operator|:
comment|// Iterators
typedef|typedef
name|typename
name|std
operator|::
name|vector
operator|<
name|Chunk
operator|<
name|ELFT
operator|>
operator|*
operator|>
operator|::
name|iterator
name|ChunkIter
expr_stmt|;
name|OutputSection
argument_list|(
argument|StringRef name
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Appends a section into the list of sections that are part of this Output
end_comment

begin_comment
comment|// Section
end_comment

begin_decl_stmt
name|void
name|appendSection
argument_list|(
name|Chunk
operator|<
name|ELFT
operator|>
operator|*
name|c
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Set the OutputSection is associated with a segment
end_comment

begin_function
name|void
name|setHasSegment
parameter_list|()
block|{
name|_hasSegment
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_comment
comment|/// Sets the ordinal
end_comment

begin_function
name|void
name|setOrdinal
parameter_list|(
name|uint64_t
name|ordinal
parameter_list|)
block|{
name|_ordinal
operator|=
name|ordinal
expr_stmt|;
block|}
end_function

begin_comment
comment|/// Sets the Memory size
end_comment

begin_function
name|void
name|setMemSize
parameter_list|(
name|uint64_t
name|memsz
parameter_list|)
block|{
name|_memSize
operator|=
name|memsz
expr_stmt|;
block|}
end_function

begin_comment
comment|/// Sets the size fo the output Section.
end_comment

begin_function
name|void
name|setSize
parameter_list|(
name|uint64_t
name|fsiz
parameter_list|)
block|{
name|_size
operator|=
name|fsiz
expr_stmt|;
block|}
end_function

begin_comment
comment|// The offset of the first section contained in the output section is
end_comment

begin_comment
comment|// contained here.
end_comment

begin_function
name|void
name|setFileOffset
parameter_list|(
name|uint64_t
name|foffset
parameter_list|)
block|{
name|_fileOffset
operator|=
name|foffset
expr_stmt|;
block|}
end_function

begin_comment
comment|// Sets the starting address of the section
end_comment

begin_function
name|void
name|setAddr
parameter_list|(
name|uint64_t
name|addr
parameter_list|)
block|{
name|_virtualAddr
operator|=
name|addr
expr_stmt|;
block|}
end_function

begin_comment
comment|// Is the section loadable?
end_comment

begin_expr_stmt
name|bool
name|isLoadableSection
argument_list|()
specifier|const
block|{
return|return
name|_isLoadableSection
return|;
block|}
end_expr_stmt

begin_comment
comment|// Set section Loadable
end_comment

begin_function
name|void
name|setLoadableSection
parameter_list|(
name|bool
name|isLoadable
parameter_list|)
block|{
name|_isLoadableSection
operator|=
name|isLoadable
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setLink
parameter_list|(
name|uint64_t
name|link
parameter_list|)
block|{
name|_link
operator|=
name|link
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setInfo
parameter_list|(
name|uint64_t
name|info
parameter_list|)
block|{
name|_shInfo
operator|=
name|info
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setFlag
parameter_list|(
name|uint64_t
name|flags
parameter_list|)
block|{
name|_flags
operator|=
name|flags
expr_stmt|;
block|}
end_function

begin_function
name|void
name|setType
parameter_list|(
name|int16_t
name|type
parameter_list|)
block|{
name|_type
operator|=
name|type
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|range
operator|<
name|ChunkIter
operator|>
name|sections
argument_list|()
block|{
return|return
name|_sections
return|;
block|}
end_expr_stmt

begin_comment
comment|// The below functions returns the properties of the OutputSection.
end_comment

begin_expr_stmt
name|bool
name|hasSegment
argument_list|()
specifier|const
block|{
return|return
name|_hasSegment
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|StringRef
name|name
argument_list|()
specifier|const
block|{
return|return
name|_name
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|int64_t
name|shinfo
argument_list|()
specifier|const
block|{
return|return
name|_shInfo
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|uint64_t
name|alignment
argument_list|()
specifier|const
block|{
return|return
name|_alignment
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|int64_t
name|link
argument_list|()
specifier|const
block|{
return|return
name|_link
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|int64_t
name|type
argument_list|()
specifier|const
block|{
return|return
name|_type
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|uint64_t
name|virtualAddr
argument_list|()
specifier|const
block|{
return|return
name|_virtualAddr
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|int64_t
name|ordinal
argument_list|()
specifier|const
block|{
return|return
name|_ordinal
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|int64_t
name|kind
argument_list|()
specifier|const
block|{
return|return
name|_kind
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|uint64_t
name|fileSize
argument_list|()
specifier|const
block|{
return|return
name|_size
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|int64_t
name|entsize
argument_list|()
specifier|const
block|{
return|return
name|_entSize
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|uint64_t
name|fileOffset
argument_list|()
specifier|const
block|{
return|return
name|_fileOffset
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|int64_t
name|flags
argument_list|()
specifier|const
block|{
return|return
name|_flags
return|;
block|}
end_expr_stmt

begin_function
name|uint64_t
name|memSize
parameter_list|()
block|{
return|return
name|_memSize
return|;
block|}
end_function

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|StringRef
name|_name
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|_hasSegment
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint64_t
name|_ordinal
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint64_t
name|_flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint64_t
name|_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint64_t
name|_memSize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint64_t
name|_fileOffset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint64_t
name|_virtualAddr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int64_t
name|_shInfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int64_t
name|_entSize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int64_t
name|_link
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint64_t
name|_alignment
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int64_t
name|_kind
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int64_t
name|_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|_isLoadableSection
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|std
operator|::
name|vector
operator|<
name|Chunk
operator|<
name|ELFT
operator|>
operator|*
operator|>
name|_sections
expr_stmt|;
end_expr_stmt

begin_comment
unit|};
comment|/// OutputSection
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|OutputSection
operator|<
name|ELFT
operator|>
operator|::
name|OutputSection
argument_list|(
argument|StringRef name
argument_list|)
operator|:
name|_name
argument_list|(
name|name
argument_list|)
operator|,
name|_hasSegment
argument_list|(
name|false
argument_list|)
operator|,
name|_ordinal
argument_list|(
literal|0
argument_list|)
operator|,
name|_flags
argument_list|(
literal|0
argument_list|)
operator|,
name|_size
argument_list|(
literal|0
argument_list|)
operator|,
name|_memSize
argument_list|(
literal|0
argument_list|)
operator|,
name|_fileOffset
argument_list|(
literal|0
argument_list|)
operator|,
name|_virtualAddr
argument_list|(
literal|0
argument_list|)
operator|,
name|_shInfo
argument_list|(
literal|0
argument_list|)
operator|,
name|_entSize
argument_list|(
literal|0
argument_list|)
operator|,
name|_link
argument_list|(
literal|0
argument_list|)
operator|,
name|_alignment
argument_list|(
literal|0
argument_list|)
operator|,
name|_kind
argument_list|(
literal|0
argument_list|)
operator|,
name|_type
argument_list|(
literal|0
argument_list|)
operator|,
name|_isLoadableSection
argument_list|(
argument|false
argument_list|)
block|{}
name|template
operator|<
name|class
name|ELFT
operator|>
name|void
name|OutputSection
operator|<
name|ELFT
operator|>
operator|::
name|appendSection
argument_list|(
argument|Chunk<ELFT> *c
argument_list|)
block|{
if|if
condition|(
name|c
operator|->
name|alignment
argument_list|()
operator|>
name|_alignment
condition|)
name|_alignment
operator|=
name|c
operator|->
name|alignment
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
specifier|const
specifier|auto
name|section
init|=
name|dyn_cast
operator|<
name|Section
operator|<
name|ELFT
operator|>>
operator|(
name|c
operator|)
condition|)
block|{
name|assert
argument_list|(
operator|!
name|_link
operator|&&
literal|"Section already has a link!"
argument_list|)
expr_stmt|;
name|_link
operator|=
name|section
operator|->
name|getLink
argument_list|()
expr_stmt|;
name|_shInfo
operator|=
name|section
operator|->
name|getInfo
argument_list|()
expr_stmt|;
name|_entSize
operator|=
name|section
operator|->
name|getEntSize
argument_list|()
expr_stmt|;
name|_type
operator|=
name|section
operator|->
name|getType
argument_list|()
expr_stmt|;
if|if
condition|(
name|_flags
operator|<
name|section
operator|->
name|getFlags
argument_list|()
condition|)
name|_flags
operator|=
name|section
operator|->
name|getFlags
argument_list|()
expr_stmt|;
name|section
operator|->
name|setOutputSection
argument_list|(
name|this
argument_list|,
operator|(
name|_sections
operator|.
name|size
argument_list|()
operator|==
literal|0
operator|)
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|_kind
operator|=
name|c
operator|->
name|kind
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_sections
operator|.
name|push_back
argument_list|(
name|c
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/// \brief The class represents the ELF String Table
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|StringTable
operator|:
name|public
name|Section
operator|<
name|ELFT
operator|>
block|{
name|public
operator|:
name|StringTable
argument_list|(
argument|const ELFLinkingContext&
argument_list|,
argument|const char *str
argument_list|,
argument|int32_t order
argument_list|,
argument|bool dynamic = false
argument_list|)
block|;
name|uint64_t
name|addString
argument_list|(
argument|StringRef symname
argument_list|)
block|;
name|void
name|write
argument_list|(
argument|ELFWriter *writer
argument_list|,
argument|TargetLayout<ELFT>&layout
argument_list|,
argument|llvm::FileOutputBuffer&buffer
argument_list|)
name|override
block|;
name|void
name|setNumEntries
argument_list|(
argument|int64_t numEntries
argument_list|)
block|{
name|_stringMap
operator|.
name|resize
argument_list|(
name|numEntries
argument_list|)
block|; }
name|private
operator|:
name|std
operator|::
name|vector
operator|<
name|StringRef
operator|>
name|_strings
block|;    struct
name|StringRefMappingInfo
block|{
specifier|static
name|StringRef
name|getEmptyKey
argument_list|()
block|{
return|return
name|StringRef
argument_list|()
return|;
block|}
specifier|static
name|StringRef
name|getTombstoneKey
argument_list|()
block|{
return|return
name|StringRef
argument_list|(
literal|" "
argument_list|,
literal|1
argument_list|)
return|;
block|}
specifier|static
name|unsigned
name|getHashValue
argument_list|(
argument|StringRef const val
argument_list|)
block|{
return|return
name|llvm
operator|::
name|HashString
argument_list|(
name|val
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|bool
name|isEqual
parameter_list|(
name|StringRef
specifier|const
name|lhs
parameter_list|,
name|StringRef
specifier|const
name|rhs
parameter_list|)
block|{
return|return
name|lhs
operator|.
name|equals
argument_list|(
name|rhs
argument_list|)
return|;
block|}
end_function

begin_typedef
unit|};
typedef|typedef
name|typename
name|llvm
operator|::
name|DenseMap
operator|<
name|StringRef
operator|,
name|uint64_t
operator|,
name|StringRefMappingInfo
operator|>
name|StringMapT
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|StringMapT
operator|::
name|iterator
name|StringMapTIter
expr_stmt|;
end_typedef

begin_decl_stmt
name|StringMapT
name|_stringMap
decl_stmt|;
end_decl_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|ELFT
operator|>
name|StringTable
operator|<
name|ELFT
operator|>
operator|::
name|StringTable
argument_list|(
argument|const ELFLinkingContext&context
argument_list|,
argument|const char *str
argument_list|,
argument|int32_t order
argument_list|,
argument|bool dynamic
argument_list|)
operator|:
name|Section
operator|<
name|ELFT
operator|>
operator|(
name|context
operator|,
name|str
operator|,
literal|"StringTable"
operator|)
block|{
comment|// the string table has a NULL entry for which
comment|// add an empty string
name|_strings
operator|.
name|push_back
argument_list|(
literal|""
argument_list|)
block|;
name|this
operator|->
name|_fsize
operator|=
literal|1
block|;
name|this
operator|->
name|_alignment
operator|=
literal|1
block|;
name|this
operator|->
name|setOrder
argument_list|(
name|order
argument_list|)
block|;
name|this
operator|->
name|_type
operator|=
name|SHT_STRTAB
block|;
if|if
condition|(
name|dynamic
condition|)
block|{
name|this
operator|->
name|_flags
operator|=
name|SHF_ALLOC
expr_stmt|;
name|this
operator|->
name|_msize
operator|=
name|this
operator|->
name|_fsize
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|uint64_t
name|StringTable
operator|<
name|ELFT
operator|>
operator|::
name|addString
argument_list|(
argument|StringRef symname
argument_list|)
block|{
if|if
condition|(
name|symname
operator|.
name|empty
argument_list|()
condition|)
return|return
literal|0
return|;
name|StringMapTIter
name|stringIter
operator|=
name|_stringMap
operator|.
name|find
argument_list|(
name|symname
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|stringIter
operator|==
name|_stringMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|_strings
operator|.
name|push_back
argument_list|(
name|symname
argument_list|)
expr_stmt|;
name|uint64_t
name|offset
init|=
name|this
operator|->
name|_fsize
decl_stmt|;
name|this
operator|->
name|_fsize
operator|+=
name|symname
operator|.
name|size
argument_list|()
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|this
operator|->
name|_flags
operator|&
name|SHF_ALLOC
condition|)
name|this
operator|->
name|_msize
operator|=
name|this
operator|->
name|_fsize
expr_stmt|;
name|_stringMap
index|[
name|symname
index|]
operator|=
name|offset
expr_stmt|;
return|return
name|offset
return|;
block|}
end_if

begin_return
return|return
name|stringIter
operator|->
name|second
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|void
name|StringTable
operator|<
name|ELFT
operator|>
operator|::
name|write
argument_list|(
argument|ELFWriter *writer
argument_list|,
argument|TargetLayout<ELFT>&
argument_list|,
argument|llvm::FileOutputBuffer&buffer
argument_list|)
block|{
name|uint8_t
operator|*
name|chunkBuffer
operator|=
name|buffer
operator|.
name|getBufferStart
argument_list|()
block|;
name|uint8_t
operator|*
name|dest
operator|=
name|chunkBuffer
operator|+
name|this
operator|->
name|fileOffset
argument_list|()
block|;
for|for
control|(
name|auto
name|si
range|:
name|_strings
control|)
block|{
name|memcpy
argument_list|(
name|dest
argument_list|,
name|si
operator|.
name|data
argument_list|()
argument_list|,
name|si
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|dest
operator|+=
name|si
operator|.
name|size
argument_list|()
expr_stmt|;
name|memcpy
argument_list|(
name|dest
argument_list|,
literal|""
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dest
operator|+=
literal|1
expr_stmt|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|/// \brief The SymbolTable class represents the symbol table in a ELF file
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|SymbolTable
operator|:
name|public
name|Section
operator|<
name|ELFT
operator|>
block|{
typedef|typedef
name|typename
name|llvm
operator|::
name|object
operator|::
name|ELFDataTypeTypedefHelper
operator|<
name|ELFT
operator|>
operator|::
name|Elf_Addr
name|Elf_Addr
expr_stmt|;
name|public
operator|:
end_expr_stmt

begin_typedef
typedef|typedef
name|llvm
operator|::
name|object
operator|::
name|Elf_Sym_Impl
operator|<
name|ELFT
operator|>
name|Elf_Sym
expr_stmt|;
end_typedef

begin_macro
name|SymbolTable
argument_list|(
argument|const ELFLinkingContext&context
argument_list|,
argument|const char *str
argument_list|,
argument|int32_t order
argument_list|)
end_macro

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// \brief set the number of entries that would exist in the symbol
end_comment

begin_comment
comment|/// table for the current link
end_comment

begin_decl_stmt
name|void
name|setNumEntries
argument_list|(
name|int64_t
name|numEntries
argument_list|)
decl|const
block|{
if|if
condition|(
name|_stringSection
condition|)
name|_stringSection
operator|->
name|setNumEntries
argument_list|(
name|numEntries
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/// \brief return number of entries
end_comment

begin_expr_stmt
name|std
operator|::
name|size_t
name|size
argument_list|()
specifier|const
block|{
return|return
name|_symbolTable
operator|.
name|size
argument_list|()
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|void
name|addSymbol
argument_list|(
specifier|const
name|Atom
operator|*
name|atom
argument_list|,
name|int32_t
name|sectionIndex
argument_list|,
name|uint64_t
name|addr
operator|=
literal|0
argument_list|,
specifier|const
name|lld
operator|::
name|AtomLayout
operator|*
name|layout
operator|=
name|nullptr
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// \brief Get the symbol table index for an Atom. If it's not in the symbol
end_comment

begin_comment
comment|/// table, return STN_UNDEF.
end_comment

begin_decl_stmt
name|uint32_t
name|getSymbolTableIndex
argument_list|(
specifier|const
name|Atom
operator|*
name|a
argument_list|)
decl|const
block|{
for|for
control|(
name|size_t
name|i
init|=
literal|0
init|,
name|e
init|=
name|_symbolTable
operator|.
name|size
argument_list|()
init|;
name|i
operator|<
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|_symbolTable
index|[
name|i
index|]
operator|.
name|_atom
operator|==
name|a
condition|)
return|return
name|i
return|;
return|return
name|STN_UNDEF
return|;
block|}
end_decl_stmt

begin_function
name|void
name|finalize
parameter_list|()
function|override
block|{
name|finalize
argument_list|(
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|virtual
name|void
name|sortSymbols
parameter_list|()
block|{
name|std
operator|::
name|stable_sort
argument_list|(
name|_symbolTable
operator|.
name|begin
argument_list|()
argument_list|,
name|_symbolTable
operator|.
name|end
argument_list|()
argument_list|,
index|[]
operator|(
specifier|const
name|SymbolEntry
operator|&
name|A
operator|,
specifier|const
name|SymbolEntry
operator|&
name|B
operator|)
block|{
return|return
name|A
operator|.
name|_symbol
operator|.
name|getBinding
argument_list|()
operator|<
name|B
operator|.
name|_symbol
operator|.
name|getBinding
argument_list|()
return|;
block|}
block|)
function|;
end_function

begin_function_decl
unit|}    virtual
name|void
name|addAbsoluteAtom
parameter_list|(
name|Elf_Sym
modifier|&
name|sym
parameter_list|,
specifier|const
name|AbsoluteAtom
modifier|*
name|aa
parameter_list|,
name|int64_t
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|virtual
name|void
name|addDefinedAtom
parameter_list|(
name|Elf_Sym
modifier|&
name|sym
parameter_list|,
specifier|const
name|DefinedAtom
modifier|*
name|da
parameter_list|,
name|int64_t
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|virtual
name|void
name|addUndefinedAtom
parameter_list|(
name|Elf_Sym
modifier|&
name|sym
parameter_list|,
specifier|const
name|UndefinedAtom
modifier|*
name|ua
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|virtual
name|void
name|addSharedLibAtom
parameter_list|(
name|Elf_Sym
modifier|&
name|sym
parameter_list|,
specifier|const
name|SharedLibraryAtom
modifier|*
name|sla
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|virtual
name|void
name|finalize
parameter_list|(
name|bool
name|sort
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|void
name|write
argument_list|(
name|ELFWriter
operator|*
name|writer
argument_list|,
name|TargetLayout
operator|<
name|ELFT
operator|>
operator|&
name|layout
argument_list|,
name|llvm
operator|::
name|FileOutputBuffer
operator|&
name|buffer
argument_list|)
name|override
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|setStringSection
argument_list|(
name|StringTable
operator|<
name|ELFT
operator|>
operator|*
name|s
argument_list|)
block|{
name|_stringSection
operator|=
name|s
expr_stmt|;
block|}
end_decl_stmt

begin_expr_stmt
name|StringTable
operator|<
name|ELFT
operator|>
operator|*
name|getStringTable
argument_list|()
specifier|const
block|{
return|return
name|_stringSection
return|;
block|}
end_expr_stmt

begin_label
name|protected
label|:
end_label

begin_struct
struct|struct
name|SymbolEntry
block|{
name|SymbolEntry
argument_list|(
specifier|const
name|Atom
operator|*
name|a
argument_list|,
specifier|const
name|Elf_Sym
operator|&
name|sym
argument_list|,
specifier|const
name|lld
operator|::
name|AtomLayout
operator|*
name|layout
argument_list|)
operator|:
name|_atom
argument_list|(
name|a
argument_list|)
operator|,
name|_atomLayout
argument_list|(
name|layout
argument_list|)
operator|,
name|_symbol
argument_list|(
argument|sym
argument_list|)
block|{}
specifier|const
name|Atom
operator|*
name|_atom
expr_stmt|;
specifier|const
name|lld
operator|::
name|AtomLayout
operator|*
name|_atomLayout
expr_stmt|;
name|Elf_Sym
name|_symbol
decl_stmt|;
block|}
struct|;
end_struct

begin_expr_stmt
name|llvm
operator|::
name|BumpPtrAllocator
name|_symbolAllocate
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|StringTable
operator|<
name|ELFT
operator|>
operator|*
name|_stringSection
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|vector
operator|<
name|SymbolEntry
operator|>
name|_symbolTable
expr_stmt|;
end_expr_stmt

begin_comment
unit|};
comment|/// ELF Symbol Table
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|SymbolTable
operator|<
name|ELFT
operator|>
operator|::
name|SymbolTable
argument_list|(
argument|const ELFLinkingContext&context
argument_list|,
argument|const char *str
argument_list|,
argument|int32_t order
argument_list|)
operator|:
name|Section
operator|<
name|ELFT
operator|>
operator|(
name|context
operator|,
name|str
operator|,
literal|"SymbolTable"
operator|)
block|{
name|this
operator|->
name|setOrder
argument_list|(
name|order
argument_list|)
block|;
name|Elf_Sym
name|symbol
block|;
name|std
operator|::
name|memset
argument_list|(
operator|&
name|symbol
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Sym
argument_list|)
argument_list|)
block|;
name|_symbolTable
operator|.
name|push_back
argument_list|(
name|SymbolEntry
argument_list|(
name|nullptr
argument_list|,
name|symbol
argument_list|,
name|nullptr
argument_list|)
argument_list|)
block|;
name|this
operator|->
name|_entSize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Sym
argument_list|)
block|;
name|this
operator|->
name|_fsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Sym
argument_list|)
block|;
name|this
operator|->
name|_alignment
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Addr
argument_list|)
block|;
name|this
operator|->
name|_type
operator|=
name|SHT_SYMTAB
block|; }
name|template
operator|<
name|class
name|ELFT
operator|>
name|void
name|SymbolTable
operator|<
name|ELFT
operator|>
operator|::
name|addDefinedAtom
argument_list|(
argument|Elf_Sym&sym
argument_list|,
argument|const DefinedAtom *da
argument_list|,
argument|int64_t addr
argument_list|)
block|{
name|unsigned
name|char
name|binding
operator|=
literal|0
block|,
name|type
operator|=
literal|0
block|;
name|sym
operator|.
name|st_size
operator|=
name|da
operator|->
name|size
argument_list|()
block|;
name|DefinedAtom
operator|::
name|ContentType
name|ct
block|;
switch|switch
condition|(
name|ct
operator|=
name|da
operator|->
name|contentType
argument_list|()
condition|)
block|{
case|case
name|DefinedAtom
operator|::
name|typeCode
case|:
case|case
name|DefinedAtom
operator|::
name|typeStub
case|:
name|sym
operator|.
name|st_value
operator|=
name|addr
expr_stmt|;
name|type
operator|=
name|llvm
operator|::
name|ELF
operator|::
name|STT_FUNC
expr_stmt|;
break|break;
case|case
name|DefinedAtom
operator|::
name|typeResolver
case|:
name|sym
operator|.
name|st_value
operator|=
name|addr
expr_stmt|;
name|type
operator|=
name|llvm
operator|::
name|ELF
operator|::
name|STT_GNU_IFUNC
expr_stmt|;
break|break;
case|case
name|DefinedAtom
operator|::
name|typeDataFast
case|:
case|case
name|DefinedAtom
operator|::
name|typeData
case|:
case|case
name|DefinedAtom
operator|::
name|typeConstant
case|:
name|sym
operator|.
name|st_value
operator|=
name|addr
expr_stmt|;
name|type
operator|=
name|llvm
operator|::
name|ELF
operator|::
name|STT_OBJECT
expr_stmt|;
break|break;
case|case
name|DefinedAtom
operator|::
name|typeGOT
case|:
name|sym
operator|.
name|st_value
operator|=
name|addr
expr_stmt|;
name|type
operator|=
name|llvm
operator|::
name|ELF
operator|::
name|STT_NOTYPE
expr_stmt|;
break|break;
case|case
name|DefinedAtom
operator|::
name|typeZeroFill
case|:
case|case
name|DefinedAtom
operator|::
name|typeZeroFillFast
case|:
name|type
operator|=
name|llvm
operator|::
name|ELF
operator|::
name|STT_OBJECT
expr_stmt|;
name|sym
operator|.
name|st_value
operator|=
name|addr
expr_stmt|;
break|break;
case|case
name|DefinedAtom
operator|::
name|typeThreadData
case|:
case|case
name|DefinedAtom
operator|::
name|typeThreadZeroFill
case|:
name|type
operator|=
name|llvm
operator|::
name|ELF
operator|::
name|STT_TLS
expr_stmt|;
name|sym
operator|.
name|st_value
operator|=
name|addr
expr_stmt|;
break|break;
default|default:
name|type
operator|=
name|llvm
operator|::
name|ELF
operator|::
name|STT_NOTYPE
expr_stmt|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|da
operator|->
name|customSectionName
argument_list|()
operator|==
name|da
operator|->
name|name
argument_list|()
condition|)
name|type
operator|=
name|llvm
operator|::
name|ELF
operator|::
name|STT_SECTION
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|da
operator|->
name|scope
argument_list|()
operator|==
name|DefinedAtom
operator|::
name|scopeTranslationUnit
condition|)
name|binding
operator|=
name|llvm
operator|::
name|ELF
operator|::
name|STB_LOCAL
expr_stmt|;
else|else
name|binding
operator|=
name|llvm
operator|::
name|ELF
operator|::
name|STB_GLOBAL
expr_stmt|;
end_if

begin_expr_stmt
name|sym
operator|.
name|setBindingAndType
argument_list|(
name|binding
argument_list|,
name|type
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|void
name|SymbolTable
operator|<
name|ELFT
operator|>
operator|::
name|addAbsoluteAtom
argument_list|(
argument|Elf_Sym&sym
argument_list|,
argument|const AbsoluteAtom *aa
argument_list|,
argument|int64_t addr
argument_list|)
block|{
name|unsigned
name|char
name|binding
operator|=
literal|0
block|,
name|type
operator|=
literal|0
block|;
name|type
operator|=
name|llvm
operator|::
name|ELF
operator|::
name|STT_OBJECT
block|;
name|sym
operator|.
name|st_shndx
operator|=
name|llvm
operator|::
name|ELF
operator|::
name|SHN_ABS
block|;
switch|switch
condition|(
name|aa
operator|->
name|scope
argument_list|()
condition|)
block|{
case|case
name|AbsoluteAtom
operator|::
name|scopeLinkageUnit
case|:
name|sym
operator|.
name|setVisibility
argument_list|(
name|llvm
operator|::
name|ELF
operator|::
name|STV_HIDDEN
argument_list|)
expr_stmt|;
name|binding
operator|=
name|llvm
operator|::
name|ELF
operator|::
name|STB_LOCAL
expr_stmt|;
break|break;
case|case
name|AbsoluteAtom
operator|::
name|scopeTranslationUnit
case|:
name|binding
operator|=
name|llvm
operator|::
name|ELF
operator|::
name|STB_LOCAL
expr_stmt|;
break|break;
case|case
name|AbsoluteAtom
operator|::
name|scopeGlobal
case|:
name|binding
operator|=
name|llvm
operator|::
name|ELF
operator|::
name|STB_GLOBAL
expr_stmt|;
break|break;
block|}
name|sym
operator|.
name|st_value
operator|=
name|addr
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|sym
operator|.
name|setBindingAndType
argument_list|(
name|binding
argument_list|,
name|type
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|void
name|SymbolTable
operator|<
name|ELFT
operator|>
operator|::
name|addSharedLibAtom
argument_list|(
argument|Elf_Sym&sym
argument_list|,
argument|const SharedLibraryAtom *aa
argument_list|)
block|{
name|unsigned
name|char
name|binding
operator|=
literal|0
block|,
name|type
operator|=
literal|0
block|;
if|if
condition|(
name|aa
operator|->
name|type
argument_list|()
operator|==
name|SharedLibraryAtom
operator|::
name|Type
operator|::
name|Data
condition|)
block|{
name|type
operator|=
name|llvm
operator|::
name|ELF
operator|::
name|STT_OBJECT
expr_stmt|;
name|sym
operator|.
name|st_size
operator|=
name|aa
operator|->
name|size
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
name|type
operator|=
name|llvm
operator|::
name|ELF
operator|::
name|STT_FUNC
expr_stmt|;
end_else

begin_expr_stmt
name|sym
operator|.
name|st_shndx
operator|=
name|llvm
operator|::
name|ELF
operator|::
name|SHN_UNDEF
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|binding
operator|=
name|llvm
operator|::
name|ELF
operator|::
name|STB_GLOBAL
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|sym
operator|.
name|setBindingAndType
argument_list|(
name|binding
argument_list|,
name|type
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|void
name|SymbolTable
operator|<
name|ELFT
operator|>
operator|::
name|addUndefinedAtom
argument_list|(
argument|Elf_Sym&sym
argument_list|,
argument|const UndefinedAtom *ua
argument_list|)
block|{
name|unsigned
name|char
name|binding
operator|=
literal|0
block|,
name|type
operator|=
literal|0
block|;
name|sym
operator|.
name|st_value
operator|=
literal|0
block|;
name|type
operator|=
name|llvm
operator|::
name|ELF
operator|::
name|STT_NOTYPE
block|;
if|if
condition|(
name|ua
operator|->
name|canBeNull
argument_list|()
condition|)
name|binding
operator|=
name|llvm
operator|::
name|ELF
operator|::
name|STB_WEAK
expr_stmt|;
else|else
name|binding
operator|=
name|llvm
operator|::
name|ELF
operator|::
name|STB_GLOBAL
expr_stmt|;
name|sym
operator|.
name|setBindingAndType
argument_list|(
name|binding
argument_list|,
name|type
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/// Add a symbol to the symbol Table, definedAtoms which get added to the symbol
end_comment

begin_comment
comment|/// section don't have their virtual addresses set at the time of adding the
end_comment

begin_comment
comment|/// symbol to the symbol table(Example: dynamic symbols), the addresses needs
end_comment

begin_comment
comment|/// to be updated in the table before writing the dynamic symbol table
end_comment

begin_comment
comment|/// information
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|ELFT
operator|>
name|void
name|SymbolTable
operator|<
name|ELFT
operator|>
operator|::
name|addSymbol
argument_list|(
argument|const Atom *atom
argument_list|,
argument|int32_t sectionIndex
argument_list|,
argument|uint64_t addr
argument_list|,
argument|const lld::AtomLayout *atomLayout
argument_list|)
block|{
name|Elf_Sym
name|symbol
block|;
if|if
condition|(
name|atom
operator|->
name|name
argument_list|()
operator|.
name|empty
argument_list|()
condition|)
return|return;
name|symbol
operator|.
name|st_name
operator|=
name|_stringSection
operator|->
name|addString
argument_list|(
name|atom
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|symbol
operator|.
name|st_size
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|symbol
operator|.
name|st_shndx
operator|=
name|sectionIndex
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|symbol
operator|.
name|st_value
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|symbol
operator|.
name|st_other
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|symbol
operator|.
name|setVisibility
argument_list|(
name|llvm
operator|::
name|ELF
operator|::
name|STV_DEFAULT
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Add all the atoms
end_comment

begin_if
if|if
condition|(
specifier|const
name|DefinedAtom
modifier|*
name|da
init|=
name|dyn_cast
operator|<
specifier|const
name|DefinedAtom
operator|>
operator|(
name|atom
operator|)
condition|)
name|addDefinedAtom
argument_list|(
name|symbol
argument_list|,
name|da
argument_list|,
name|addr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
specifier|const
name|AbsoluteAtom
modifier|*
name|aa
init|=
name|dyn_cast
operator|<
specifier|const
name|AbsoluteAtom
operator|>
operator|(
name|atom
operator|)
condition|)
name|addAbsoluteAtom
argument_list|(
name|symbol
argument_list|,
name|aa
argument_list|,
name|addr
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isa
operator|<
specifier|const
name|SharedLibraryAtom
operator|>
operator|(
name|atom
operator|)
condition|)
name|addSharedLibAtom
argument_list|(
name|symbol
argument_list|,
name|dyn_cast
operator|<
name|SharedLibraryAtom
operator|>
operator|(
name|atom
operator|)
argument_list|)
expr_stmt|;
else|else
name|addUndefinedAtom
argument_list|(
name|symbol
argument_list|,
name|dyn_cast
operator|<
name|UndefinedAtom
operator|>
operator|(
name|atom
operator|)
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|_symbolTable
operator|.
name|push_back
argument_list|(
name|SymbolEntry
argument_list|(
name|atom
argument_list|,
name|symbol
argument_list|,
name|atomLayout
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|this
operator|->
name|_fsize
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_Sym
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|this
operator|->
name|_flags
operator|&
name|SHF_ALLOC
condition|)
name|this
operator|->
name|_msize
operator|=
name|this
operator|->
name|_fsize
expr_stmt|;
end_if

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|void
name|SymbolTable
operator|<
name|ELFT
operator|>
operator|::
name|finalize
argument_list|(
argument|bool sort
argument_list|)
block|{
comment|// sh_info should be one greater than last symbol with STB_LOCAL binding
comment|// we sort the symbol table to keep all local symbols at the beginning
if|if
condition|(
name|sort
condition|)
name|sortSymbols
argument_list|()
expr_stmt|;
name|uint16_t
name|shInfo
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|i
range|:
name|_symbolTable
control|)
block|{
if|if
condition|(
name|i
operator|.
name|_symbol
operator|.
name|getBinding
argument_list|()
operator|!=
name|llvm
operator|::
name|ELF
operator|::
name|STB_LOCAL
condition|)
break|break;
name|shInfo
operator|++
expr_stmt|;
block|}
end_for

begin_expr_stmt
name|this
operator|->
name|_info
operator|=
name|shInfo
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|this
operator|->
name|_link
operator|=
name|_stringSection
operator|->
name|ordinal
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|this
operator|->
name|_outputSection
condition|)
block|{
name|this
operator|->
name|_outputSection
operator|->
name|setInfo
argument_list|(
name|this
operator|->
name|_info
argument_list|)
expr_stmt|;
name|this
operator|->
name|_outputSection
operator|->
name|setLink
argument_list|(
name|this
operator|->
name|_link
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|void
name|SymbolTable
operator|<
name|ELFT
operator|>
operator|::
name|write
argument_list|(
argument|ELFWriter *writer
argument_list|,
argument|TargetLayout<ELFT>&
argument_list|,
argument|llvm::FileOutputBuffer&buffer
argument_list|)
block|{
name|uint8_t
operator|*
name|chunkBuffer
operator|=
name|buffer
operator|.
name|getBufferStart
argument_list|()
block|;
name|uint8_t
operator|*
name|dest
operator|=
name|chunkBuffer
operator|+
name|this
operator|->
name|fileOffset
argument_list|()
block|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|sti
range|:
name|_symbolTable
control|)
block|{
name|memcpy
argument_list|(
name|dest
argument_list|,
operator|&
name|sti
operator|.
name|_symbol
argument_list|,
sizeof|sizeof
argument_list|(
name|Elf_Sym
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_Sym
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|class
name|HashSection
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|DynamicSymbolTable
operator|:
name|public
name|SymbolTable
operator|<
name|ELFT
operator|>
block|{
name|public
operator|:
name|DynamicSymbolTable
argument_list|(
argument|const ELFLinkingContext&context
argument_list|,
argument|TargetLayout<ELFT>&layout
argument_list|,
argument|const char *str
argument_list|,
argument|int32_t order
argument_list|)
operator|:
name|SymbolTable
operator|<
name|ELFT
operator|>
operator|(
name|context
operator|,
name|str
operator|,
name|order
operator|)
block|,
name|_hashTable
argument_list|(
name|nullptr
argument_list|)
block|,
name|_layout
argument_list|(
argument|layout
argument_list|)
block|{
name|this
operator|->
name|_type
operator|=
name|SHT_DYNSYM
block|;
name|this
operator|->
name|_flags
operator|=
name|SHF_ALLOC
block|;
name|this
operator|->
name|_msize
operator|=
name|this
operator|->
name|_fsize
block|;   }
comment|// Set the dynamic hash table for symbols to be added into
name|void
name|setHashTable
argument_list|(
argument|HashSection<ELFT> *hashTable
argument_list|)
block|{
name|_hashTable
operator|=
name|hashTable
block|; }
comment|// Add all the dynamic symbos to the hash table
name|void
name|addSymbolsToHashTable
argument_list|()
block|{
name|int
name|index
operator|=
literal|0
block|;
for|for
control|(
name|auto
operator|&
name|ste
operator|:
name|this
operator|->
name|_symbolTable
control|)
block|{
if|if
condition|(
operator|!
name|ste
operator|.
name|_atom
condition|)
name|_hashTable
operator|->
name|addSymbol
argument_list|(
literal|""
argument_list|,
name|index
argument_list|)
expr_stmt|;
else|else
name|_hashTable
operator|->
name|addSymbol
argument_list|(
name|ste
operator|.
name|_atom
operator|->
name|name
argument_list|()
argument_list|,
name|index
argument_list|)
expr_stmt|;
operator|++
name|index
expr_stmt|;
block|}
block|}
name|void
name|finalize
argument_list|()
name|override
block|{
comment|// Defined symbols which have been added into the dynamic symbol table
comment|// don't have their addresses known until addresses have been assigned
comment|// so let's update the symbol values after they have got assigned
for|for
control|(
name|auto
operator|&
name|ste
operator|:
name|this
operator|->
name|_symbolTable
control|)
block|{
specifier|const
name|lld
operator|::
name|AtomLayout
operator|*
name|atomLayout
operator|=
name|ste
operator|.
name|_atomLayout
expr_stmt|;
if|if
condition|(
operator|!
name|atomLayout
condition|)
continue|continue;
name|ste
operator|.
name|_symbol
operator|.
name|st_value
operator|=
name|atomLayout
operator|->
name|_virtualAddr
expr_stmt|;
block|}
comment|// Don't sort the symbols
name|SymbolTable
operator|<
name|ELFT
operator|>
operator|::
name|finalize
argument_list|(
name|false
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  protected:
name|HashSection
operator|<
name|ELFT
operator|>
operator|*
name|_hashTable
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TargetLayout
operator|<
name|ELFT
operator|>
operator|&
name|_layout
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|RelocationTable
operator|:
name|public
name|Section
operator|<
name|ELFT
operator|>
block|{
name|public
operator|:
typedef|typedef
name|llvm
operator|::
name|object
operator|::
name|Elf_Rel_Impl
operator|<
name|ELFT
operator|,
name|false
operator|>
name|Elf_Rel
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|llvm
operator|::
name|object
operator|::
name|Elf_Rel_Impl
operator|<
name|ELFT
operator|,
name|true
operator|>
name|Elf_Rela
expr_stmt|;
end_typedef

begin_macro
name|RelocationTable
argument_list|(
argument|const ELFLinkingContext&context
argument_list|,
argument|StringRef str
argument_list|,
argument|int32_t order
argument_list|)
end_macro

begin_expr_stmt
unit|:
name|Section
operator|<
name|ELFT
operator|>
operator|(
name|context
operator|,
name|str
operator|,
literal|"RelocationTable"
operator|)
operator|,
name|_symbolTable
argument_list|(
argument|nullptr
argument_list|)
block|{
name|this
operator|->
name|setOrder
argument_list|(
name|order
argument_list|)
block|;
name|this
operator|->
name|_flags
operator|=
name|SHF_ALLOC
block|;
comment|// Set the alignment properly depending on the target architecture
name|this
operator|->
name|_alignment
operator|=
name|ELFT
operator|::
name|Is64Bits
condition|?
literal|8
else|:
literal|4
block|;
if|if
condition|(
name|context
operator|.
name|isRelaOutputFormat
argument_list|()
condition|)
block|{
name|this
operator|->
name|_entSize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Rela
argument_list|)
expr_stmt|;
name|this
operator|->
name|_type
operator|=
name|SHT_RELA
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|this
operator|->
name|_entSize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Rel
argument_list|)
expr_stmt|;
name|this
operator|->
name|_type
operator|=
name|SHT_REL
expr_stmt|;
block|}
end_else

begin_comment
unit|}
comment|/// \returns the index of the relocation added.
end_comment

begin_macro
unit|uint32_t
name|addRelocation
argument_list|(
argument|const DefinedAtom&da
argument_list|,
argument|const Reference&r
argument_list|)
end_macro

begin_block
block|{
name|_relocs
operator|.
name|emplace_back
argument_list|(
operator|&
name|da
argument_list|,
operator|&
name|r
argument_list|)
expr_stmt|;
name|this
operator|->
name|_fsize
operator|=
name|_relocs
operator|.
name|size
argument_list|()
operator|*
name|this
operator|->
name|_entSize
expr_stmt|;
name|this
operator|->
name|_msize
operator|=
name|this
operator|->
name|_fsize
expr_stmt|;
return|return
name|_relocs
operator|.
name|size
argument_list|()
operator|-
literal|1
return|;
block|}
end_block

begin_function
name|bool
name|getRelocationIndex
parameter_list|(
specifier|const
name|Reference
modifier|&
name|r
parameter_list|,
name|uint32_t
modifier|&
name|res
parameter_list|)
block|{
name|auto
name|rel
init|=
name|std
operator|::
name|find_if
argument_list|(
name|_relocs
operator|.
name|begin
argument_list|()
argument_list|,
name|_relocs
operator|.
name|end
argument_list|()
argument_list|,
index|[
operator|&
index|]
operator|(
specifier|const
name|std
operator|::
name|pair
operator|<
specifier|const
name|DefinedAtom
operator|*
expr|,
specifier|const
name|Reference
operator|*
operator|>
operator|&
name|p
operator|)
block|{
if|if
condition|(
name|p
operator|.
name|second
operator|==
operator|&
name|r
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_function

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_if
if|if
condition|(
name|rel
operator|==
name|_relocs
operator|.
name|end
argument_list|()
condition|)
return|return
name|false
return|;
end_if

begin_expr_stmt
name|res
operator|=
name|std
operator|::
name|distance
argument_list|(
name|_relocs
operator|.
name|begin
argument_list|()
argument_list|,
name|rel
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|true
return|;
end_return

begin_macro
unit|}    void
name|setSymbolTable
argument_list|(
argument|const DynamicSymbolTable<ELFT> *symbolTable
argument_list|)
end_macro

begin_block
block|{
name|_symbolTable
operator|=
name|symbolTable
expr_stmt|;
block|}
end_block

begin_comment
comment|/// \brief Check if any relocation modifies a read-only section.
end_comment

begin_expr_stmt
name|bool
name|canModifyReadonlySection
argument_list|()
specifier|const
block|{
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|rel
range|:
name|_relocs
control|)
block|{
specifier|const
name|DefinedAtom
modifier|*
name|atom
init|=
name|rel
operator|.
name|first
decl_stmt|;
if|if
condition|(
operator|(
name|atom
operator|->
name|permissions
argument_list|()
operator|&
name|DefinedAtom
operator|::
name|permRW_
operator|)
operator|!=
name|DefinedAtom
operator|::
name|permRW_
condition|)
return|return
name|true
return|;
block|}
end_expr_stmt

begin_return
return|return
name|false
return|;
end_return

begin_macro
unit|}    void
name|finalize
argument_list|()
end_macro

begin_macro
name|override
end_macro

begin_block
block|{
name|this
operator|->
name|_link
operator|=
name|_symbolTable
condition|?
name|_symbolTable
operator|->
name|ordinal
argument_list|()
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|this
operator|->
name|_outputSection
condition|)
name|this
operator|->
name|_outputSection
operator|->
name|setLink
argument_list|(
name|this
operator|->
name|_link
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|void
name|write
argument_list|(
name|ELFWriter
operator|*
name|writer
argument_list|,
name|TargetLayout
operator|<
name|ELFT
operator|>
operator|&
name|layout
argument_list|,
name|llvm
operator|::
name|FileOutputBuffer
operator|&
name|buffer
argument_list|)
name|override
block|{
name|uint8_t
modifier|*
name|chunkBuffer
init|=
name|buffer
operator|.
name|getBufferStart
argument_list|()
decl_stmt|;
name|uint8_t
modifier|*
name|dest
init|=
name|chunkBuffer
operator|+
name|this
operator|->
name|fileOffset
argument_list|()
decl_stmt|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|rel
range|:
name|_relocs
control|)
block|{
if|if
condition|(
name|this
operator|->
name|_context
operator|.
name|isRelaOutputFormat
argument_list|()
condition|)
block|{
name|auto
operator|&
name|r
operator|=
operator|*
name|reinterpret_cast
operator|<
name|Elf_Rela
operator|*
operator|>
operator|(
name|dest
operator|)
expr_stmt|;
name|writeRela
argument_list|(
name|writer
argument_list|,
name|r
argument_list|,
operator|*
name|rel
operator|.
name|first
argument_list|,
operator|*
name|rel
operator|.
name|second
argument_list|)
expr_stmt|;
name|DEBUG_WITH_TYPE
argument_list|(
literal|"ELFRelocationTable"
argument_list|,
argument|llvm::dbgs()<< rel.second->kindValue()<<
literal|" relocation at "
argument|<< rel.first->name()<<
literal|"@"
argument|<< r.r_offset<<
literal|" to "
argument|<< rel.second->target()->name()<<
literal|"@"
argument|<< r.r_addend<<
literal|"\n"
argument|;
argument_list|)
empty_stmt|;
block|}
else|else
block|{
name|auto
operator|&
name|r
operator|=
operator|*
name|reinterpret_cast
operator|<
name|Elf_Rel
operator|*
operator|>
operator|(
name|dest
operator|)
expr_stmt|;
name|writeRel
argument_list|(
name|writer
argument_list|,
name|r
argument_list|,
operator|*
name|rel
operator|.
name|first
argument_list|,
operator|*
name|rel
operator|.
name|second
argument_list|)
expr_stmt|;
name|DEBUG_WITH_TYPE
argument_list|(
literal|"ELFRelocationTable"
argument_list|,
argument|llvm::dbgs()<< rel.second->kindValue()<<
literal|" relocation at "
argument|<< rel.first->name()<<
literal|"@"
argument|<< r.r_offset<<
literal|" to "
argument|<< rel.second->target()->name()<<
literal|"\n"
argument|;
argument_list|)
empty_stmt|;
block|}
name|dest
operator|+=
name|this
operator|->
name|_entSize
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_label
name|protected
label|:
end_label

begin_expr_stmt
specifier|const
name|DynamicSymbolTable
operator|<
name|ELFT
operator|>
operator|*
name|_symbolTable
expr_stmt|;
end_expr_stmt

begin_function
name|virtual
name|void
name|writeRela
parameter_list|(
name|ELFWriter
modifier|*
name|writer
parameter_list|,
name|Elf_Rela
modifier|&
name|r
parameter_list|,
specifier|const
name|DefinedAtom
modifier|&
name|atom
parameter_list|,
specifier|const
name|Reference
modifier|&
name|ref
parameter_list|)
block|{
name|r
operator|.
name|setSymbolAndType
argument_list|(
name|getSymbolIndex
argument_list|(
name|ref
operator|.
name|target
argument_list|()
argument_list|)
argument_list|,
name|ref
operator|.
name|kindValue
argument_list|()
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|r
operator|.
name|r_offset
operator|=
name|writer
operator|->
name|addressOfAtom
argument_list|(
operator|&
name|atom
argument_list|)
operator|+
name|ref
operator|.
name|offsetInAtom
argument_list|()
expr_stmt|;
comment|// The addend is used only by relative relocations
if|if
condition|(
name|this
operator|->
name|_context
operator|.
name|isRelativeReloc
argument_list|(
name|ref
argument_list|)
condition|)
name|r
operator|.
name|r_addend
operator|=
name|writer
operator|->
name|addressOfAtom
argument_list|(
name|ref
operator|.
name|target
argument_list|()
argument_list|)
operator|+
name|ref
operator|.
name|addend
argument_list|()
expr_stmt|;
else|else
name|r
operator|.
name|r_addend
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|virtual
name|void
name|writeRel
parameter_list|(
name|ELFWriter
modifier|*
name|writer
parameter_list|,
name|Elf_Rel
modifier|&
name|r
parameter_list|,
specifier|const
name|DefinedAtom
modifier|&
name|atom
parameter_list|,
specifier|const
name|Reference
modifier|&
name|ref
parameter_list|)
block|{
name|r
operator|.
name|setSymbolAndType
argument_list|(
name|getSymbolIndex
argument_list|(
name|ref
operator|.
name|target
argument_list|()
argument_list|)
argument_list|,
name|ref
operator|.
name|kindValue
argument_list|()
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|r
operator|.
name|r_offset
operator|=
name|writer
operator|->
name|addressOfAtom
argument_list|(
operator|&
name|atom
argument_list|)
operator|+
name|ref
operator|.
name|offsetInAtom
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|uint32_t
name|getSymbolIndex
parameter_list|(
specifier|const
name|Atom
modifier|*
name|a
parameter_list|)
block|{
return|return
name|_symbolTable
condition|?
name|_symbolTable
operator|->
name|getSymbolTableIndex
argument_list|(
name|a
argument_list|)
else|:
operator|(
name|uint32_t
operator|)
name|STN_UNDEF
return|;
block|}
end_function

begin_label
name|private
label|:
end_label

begin_expr_stmt
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
specifier|const
name|DefinedAtom
operator|*
operator|,
specifier|const
name|Reference
operator|*
operator|>
expr|>
name|_relocs
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|HashSection
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|DynamicTable
operator|:
name|public
name|Section
operator|<
name|ELFT
operator|>
block|{
name|public
operator|:
typedef|typedef
name|llvm
operator|::
name|object
operator|::
name|Elf_Dyn_Impl
operator|<
name|ELFT
operator|>
name|Elf_Dyn
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|Elf_Dyn
operator|>
name|EntriesT
expr_stmt|;
end_typedef

begin_macro
name|DynamicTable
argument_list|(
argument|const ELFLinkingContext&context
argument_list|,
argument|TargetLayout<ELFT>&layout
argument_list|,
argument|StringRef str
argument_list|,
argument|int32_t order
argument_list|)
end_macro

begin_expr_stmt
unit|:
name|Section
operator|<
name|ELFT
operator|>
operator|(
name|context
operator|,
name|str
operator|,
literal|"DynamicSection"
operator|)
operator|,
name|_layout
argument_list|(
argument|layout
argument_list|)
block|{
name|this
operator|->
name|setOrder
argument_list|(
name|order
argument_list|)
block|;
name|this
operator|->
name|_entSize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Dyn
argument_list|)
block|;
name|this
operator|->
name|_alignment
operator|=
name|ELFT
operator|::
name|Is64Bits
condition|?
literal|8
else|:
literal|4
block|;
comment|// Reserve space for the DT_NULL entry.
name|this
operator|->
name|_fsize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Dyn
argument_list|)
block|;
name|this
operator|->
name|_msize
operator|=
sizeof|sizeof
argument_list|(
name|Elf_Dyn
argument_list|)
block|;
name|this
operator|->
name|_type
operator|=
name|SHT_DYNAMIC
block|;
name|this
operator|->
name|_flags
operator|=
name|SHF_ALLOC
block|;   }
name|range
operator|<
name|typename
name|EntriesT
operator|::
name|iterator
operator|>
name|entries
argument_list|()
block|{
return|return
name|_entries
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \returns the index of the entry.
end_comment

begin_expr_stmt
name|std
operator|::
name|size_t
name|addEntry
argument_list|(
argument|Elf_Dyn e
argument_list|)
block|{
name|_entries
operator|.
name|push_back
argument_list|(
name|e
argument_list|)
block|;
name|this
operator|->
name|_fsize
operator|=
operator|(
name|_entries
operator|.
name|size
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|Elf_Dyn
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|Elf_Dyn
argument_list|)
block|;
name|this
operator|->
name|_msize
operator|=
name|this
operator|->
name|_fsize
block|;
return|return
name|_entries
operator|.
name|size
argument_list|()
operator|-
literal|1
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|void
name|write
argument_list|(
name|ELFWriter
operator|*
name|writer
argument_list|,
name|TargetLayout
operator|<
name|ELFT
operator|>
operator|&
name|layout
argument_list|,
name|llvm
operator|::
name|FileOutputBuffer
operator|&
name|buffer
argument_list|)
name|override
block|{
name|uint8_t
modifier|*
name|chunkBuffer
init|=
name|buffer
operator|.
name|getBufferStart
argument_list|()
decl_stmt|;
name|uint8_t
modifier|*
name|dest
init|=
name|chunkBuffer
operator|+
name|this
operator|->
name|fileOffset
argument_list|()
decl_stmt|;
comment|// Add the null entry.
name|Elf_Dyn
name|d
decl_stmt|;
name|d
operator|.
name|d_tag
operator|=
literal|0
expr_stmt|;
name|d
operator|.
name|d_un
operator|.
name|d_val
operator|=
literal|0
expr_stmt|;
name|_entries
operator|.
name|push_back
argument_list|(
name|d
argument_list|)
expr_stmt|;
name|std
operator|::
name|memcpy
argument_list|(
name|dest
argument_list|,
name|_entries
operator|.
name|data
argument_list|()
argument_list|,
name|this
operator|->
name|_fsize
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|virtual
name|void
name|createDefaultEntries
parameter_list|()
block|{
name|bool
name|isRela
init|=
name|this
operator|->
name|_context
operator|.
name|isRelaOutputFormat
argument_list|()
decl_stmt|;
name|Elf_Dyn
name|dyn
decl_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
literal|0
expr_stmt|;
name|dyn
operator|.
name|d_tag
operator|=
name|DT_HASH
expr_stmt|;
name|_dt_hash
operator|=
name|addEntry
argument_list|(
name|dyn
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_tag
operator|=
name|DT_STRTAB
expr_stmt|;
name|_dt_strtab
operator|=
name|addEntry
argument_list|(
name|dyn
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_tag
operator|=
name|DT_SYMTAB
expr_stmt|;
name|_dt_symtab
operator|=
name|addEntry
argument_list|(
name|dyn
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_tag
operator|=
name|DT_STRSZ
expr_stmt|;
name|_dt_strsz
operator|=
name|addEntry
argument_list|(
name|dyn
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_tag
operator|=
name|DT_SYMENT
expr_stmt|;
name|_dt_syment
operator|=
name|addEntry
argument_list|(
name|dyn
argument_list|)
expr_stmt|;
if|if
condition|(
name|_layout
operator|.
name|hasDynamicRelocationTable
argument_list|()
condition|)
block|{
name|dyn
operator|.
name|d_tag
operator|=
name|isRela
condition|?
name|DT_RELA
else|:
name|DT_REL
expr_stmt|;
name|_dt_rela
operator|=
name|addEntry
argument_list|(
name|dyn
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_tag
operator|=
name|isRela
condition|?
name|DT_RELASZ
else|:
name|DT_RELSZ
expr_stmt|;
name|_dt_relasz
operator|=
name|addEntry
argument_list|(
name|dyn
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_tag
operator|=
name|isRela
condition|?
name|DT_RELAENT
else|:
name|DT_RELENT
expr_stmt|;
name|_dt_relaent
operator|=
name|addEntry
argument_list|(
name|dyn
argument_list|)
expr_stmt|;
if|if
condition|(
name|_layout
operator|.
name|getDynamicRelocationTable
argument_list|()
operator|->
name|canModifyReadonlySection
argument_list|()
condition|)
block|{
name|dyn
operator|.
name|d_tag
operator|=
name|DT_TEXTREL
expr_stmt|;
name|_dt_textrel
operator|=
name|addEntry
argument_list|(
name|dyn
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|_layout
operator|.
name|hasPLTRelocationTable
argument_list|()
condition|)
block|{
name|dyn
operator|.
name|d_tag
operator|=
name|DT_PLTRELSZ
expr_stmt|;
name|_dt_pltrelsz
operator|=
name|addEntry
argument_list|(
name|dyn
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_tag
operator|=
name|getGotPltTag
argument_list|()
expr_stmt|;
name|_dt_pltgot
operator|=
name|addEntry
argument_list|(
name|dyn
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_tag
operator|=
name|DT_PLTREL
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|isRela
condition|?
name|DT_RELA
else|:
name|DT_REL
expr_stmt|;
name|_dt_pltrel
operator|=
name|addEntry
argument_list|(
name|dyn
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
literal|0
expr_stmt|;
name|dyn
operator|.
name|d_tag
operator|=
name|DT_JMPREL
expr_stmt|;
name|_dt_jmprel
operator|=
name|addEntry
argument_list|(
name|dyn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|doPreFlight
parameter_list|()
function|override
block|{
name|Elf_Dyn
name|dyn
decl_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
literal|0
expr_stmt|;
name|auto
name|initArray
init|=
name|_layout
operator|.
name|findOutputSection
argument_list|(
literal|".init_array"
argument_list|)
decl_stmt|;
name|auto
name|finiArray
init|=
name|_layout
operator|.
name|findOutputSection
argument_list|(
literal|".fini_array"
argument_list|)
decl_stmt|;
if|if
condition|(
name|initArray
condition|)
block|{
name|dyn
operator|.
name|d_tag
operator|=
name|DT_INIT_ARRAY
expr_stmt|;
name|_dt_init_array
operator|=
name|addEntry
argument_list|(
name|dyn
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_tag
operator|=
name|DT_INIT_ARRAYSZ
expr_stmt|;
name|_dt_init_arraysz
operator|=
name|addEntry
argument_list|(
name|dyn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|finiArray
condition|)
block|{
name|dyn
operator|.
name|d_tag
operator|=
name|DT_FINI_ARRAY
expr_stmt|;
name|_dt_fini_array
operator|=
name|addEntry
argument_list|(
name|dyn
argument_list|)
expr_stmt|;
name|dyn
operator|.
name|d_tag
operator|=
name|DT_FINI_ARRAYSZ
expr_stmt|;
name|_dt_fini_arraysz
operator|=
name|addEntry
argument_list|(
name|dyn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|getInitAtomLayout
argument_list|()
condition|)
block|{
name|dyn
operator|.
name|d_tag
operator|=
name|DT_INIT
expr_stmt|;
name|_dt_init
operator|=
name|addEntry
argument_list|(
name|dyn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|getFiniAtomLayout
argument_list|()
condition|)
block|{
name|dyn
operator|.
name|d_tag
operator|=
name|DT_FINI
expr_stmt|;
name|_dt_fini
operator|=
name|addEntry
argument_list|(
name|dyn
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/// \brief Dynamic table tag for .got.plt section referencing.
end_comment

begin_comment
comment|/// Usually but not always targets use DT_PLTGOT for that.
end_comment

begin_function
name|virtual
name|int64_t
name|getGotPltTag
parameter_list|()
block|{
return|return
name|DT_PLTGOT
return|;
block|}
end_function

begin_function
name|void
name|finalize
parameter_list|()
function|override
block|{
name|StringTable
operator|<
name|ELFT
operator|>
operator|*
name|dynamicStringTable
operator|=
name|_dynamicSymbolTable
operator|->
name|getStringTable
argument_list|()
expr_stmt|;
name|this
operator|->
name|_link
operator|=
name|dynamicStringTable
operator|->
name|ordinal
argument_list|()
expr_stmt|;
if|if
condition|(
name|this
operator|->
name|_outputSection
condition|)
block|{
name|this
operator|->
name|_outputSection
operator|->
name|setType
argument_list|(
name|this
operator|->
name|_type
argument_list|)
expr_stmt|;
name|this
operator|->
name|_outputSection
operator|->
name|setInfo
argument_list|(
name|this
operator|->
name|_info
argument_list|)
expr_stmt|;
name|this
operator|->
name|_outputSection
operator|->
name|setLink
argument_list|(
name|this
operator|->
name|_link
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
name|void
name|setSymbolTable
argument_list|(
name|DynamicSymbolTable
operator|<
name|ELFT
operator|>
operator|*
name|dynsym
argument_list|)
block|{
name|_dynamicSymbolTable
operator|=
name|dynsym
expr_stmt|;
block|}
end_decl_stmt

begin_expr_stmt
specifier|const
name|DynamicSymbolTable
operator|<
name|ELFT
operator|>
operator|*
name|getSymbolTable
argument_list|()
specifier|const
block|{
return|return
name|_dynamicSymbolTable
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|void
name|setHashTable
argument_list|(
name|HashSection
operator|<
name|ELFT
operator|>
operator|*
name|hsh
argument_list|)
block|{
name|_hashTable
operator|=
name|hsh
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|virtual
name|void
name|updateDynamicTable
parameter_list|()
block|{
name|StringTable
operator|<
name|ELFT
operator|>
operator|*
name|dynamicStringTable
operator|=
name|_dynamicSymbolTable
operator|->
name|getStringTable
argument_list|()
expr_stmt|;
name|_entries
index|[
name|_dt_hash
index|]
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|_hashTable
operator|->
name|virtualAddr
argument_list|()
expr_stmt|;
name|_entries
index|[
name|_dt_strtab
index|]
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|dynamicStringTable
operator|->
name|virtualAddr
argument_list|()
expr_stmt|;
name|_entries
index|[
name|_dt_symtab
index|]
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|_dynamicSymbolTable
operator|->
name|virtualAddr
argument_list|()
expr_stmt|;
name|_entries
index|[
name|_dt_strsz
index|]
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|dynamicStringTable
operator|->
name|memSize
argument_list|()
expr_stmt|;
name|_entries
index|[
name|_dt_syment
index|]
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|_dynamicSymbolTable
operator|->
name|getEntSize
argument_list|()
expr_stmt|;
name|auto
name|initArray
init|=
name|_layout
operator|.
name|findOutputSection
argument_list|(
literal|".init_array"
argument_list|)
decl_stmt|;
if|if
condition|(
name|initArray
condition|)
block|{
name|_entries
index|[
name|_dt_init_array
index|]
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|initArray
operator|->
name|virtualAddr
argument_list|()
expr_stmt|;
name|_entries
index|[
name|_dt_init_arraysz
index|]
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|initArray
operator|->
name|memSize
argument_list|()
expr_stmt|;
block|}
name|auto
name|finiArray
init|=
name|_layout
operator|.
name|findOutputSection
argument_list|(
literal|".fini_array"
argument_list|)
decl_stmt|;
if|if
condition|(
name|finiArray
condition|)
block|{
name|_entries
index|[
name|_dt_fini_array
index|]
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|finiArray
operator|->
name|virtualAddr
argument_list|()
expr_stmt|;
name|_entries
index|[
name|_dt_fini_arraysz
index|]
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|finiArray
operator|->
name|memSize
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
specifier|const
specifier|auto
modifier|*
name|al
init|=
name|getInitAtomLayout
argument_list|()
condition|)
name|_entries
index|[
name|_dt_init
index|]
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|getAtomVirtualAddress
argument_list|(
name|al
argument_list|)
expr_stmt|;
if|if
condition|(
specifier|const
specifier|auto
modifier|*
name|al
init|=
name|getFiniAtomLayout
argument_list|()
condition|)
name|_entries
index|[
name|_dt_fini
index|]
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|getAtomVirtualAddress
argument_list|(
name|al
argument_list|)
expr_stmt|;
if|if
condition|(
name|_layout
operator|.
name|hasDynamicRelocationTable
argument_list|()
condition|)
block|{
name|auto
name|relaTbl
init|=
name|_layout
operator|.
name|getDynamicRelocationTable
argument_list|()
decl_stmt|;
name|_entries
index|[
name|_dt_rela
index|]
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|relaTbl
operator|->
name|virtualAddr
argument_list|()
expr_stmt|;
name|_entries
index|[
name|_dt_relasz
index|]
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|relaTbl
operator|->
name|memSize
argument_list|()
expr_stmt|;
name|_entries
index|[
name|_dt_relaent
index|]
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|relaTbl
operator|->
name|getEntSize
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|_layout
operator|.
name|hasPLTRelocationTable
argument_list|()
condition|)
block|{
name|auto
name|relaTbl
init|=
name|_layout
operator|.
name|getPLTRelocationTable
argument_list|()
decl_stmt|;
name|_entries
index|[
name|_dt_jmprel
index|]
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|relaTbl
operator|->
name|virtualAddr
argument_list|()
expr_stmt|;
name|_entries
index|[
name|_dt_pltrelsz
index|]
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|relaTbl
operator|->
name|memSize
argument_list|()
expr_stmt|;
name|auto
name|gotplt
init|=
name|_layout
operator|.
name|findOutputSection
argument_list|(
literal|".got.plt"
argument_list|)
decl_stmt|;
name|_entries
index|[
name|_dt_pltgot
index|]
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|gotplt
operator|->
name|virtualAddr
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_label
name|protected
label|:
end_label

begin_decl_stmt
name|EntriesT
name|_entries
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// \brief Return a virtual address (maybe adjusted) for the atom layout
end_comment

begin_comment
comment|/// Some targets like microMIPS and ARM Thumb use the last bit
end_comment

begin_comment
comment|/// of a symbol's value to mark 'compressed' code. This function allows
end_comment

begin_comment
comment|/// to adjust a virtal address before using it in the dynamic table tag.
end_comment

begin_decl_stmt
name|virtual
name|uint64_t
name|getAtomVirtualAddress
argument_list|(
specifier|const
name|AtomLayout
operator|*
name|al
argument_list|)
decl|const
block|{
return|return
name|al
operator|->
name|_virtualAddr
return|;
block|}
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_expr_stmt
name|std
operator|::
name|size_t
name|_dt_hash
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|size_t
name|_dt_strtab
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|size_t
name|_dt_symtab
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|size_t
name|_dt_rela
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|size_t
name|_dt_relasz
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|size_t
name|_dt_relaent
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|size_t
name|_dt_strsz
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|size_t
name|_dt_syment
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|size_t
name|_dt_pltrelsz
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|size_t
name|_dt_pltgot
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|size_t
name|_dt_pltrel
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|size_t
name|_dt_jmprel
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|size_t
name|_dt_init_array
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|size_t
name|_dt_init_arraysz
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|size_t
name|_dt_fini_array
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|size_t
name|_dt_fini_arraysz
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|size_t
name|_dt_textrel
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|size_t
name|_dt_init
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|size_t
name|_dt_fini
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TargetLayout
operator|<
name|ELFT
operator|>
operator|&
name|_layout
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DynamicSymbolTable
operator|<
name|ELFT
operator|>
operator|*
name|_dynamicSymbolTable
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|HashSection
operator|<
name|ELFT
operator|>
operator|*
name|_hashTable
expr_stmt|;
end_expr_stmt

begin_function
specifier|const
name|AtomLayout
modifier|*
name|getInitAtomLayout
parameter_list|()
block|{
name|auto
name|al
init|=
name|_layout
operator|.
name|findAtomLayoutByName
argument_list|(
name|this
operator|->
name|_context
operator|.
name|initFunction
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|al
operator|&&
name|isa
operator|<
name|DefinedAtom
operator|>
operator|(
name|al
operator|->
name|_atom
operator|)
condition|)
return|return
name|al
return|;
return|return
name|nullptr
return|;
block|}
end_function

begin_function
specifier|const
name|AtomLayout
modifier|*
name|getFiniAtomLayout
parameter_list|()
block|{
name|auto
name|al
init|=
name|_layout
operator|.
name|findAtomLayoutByName
argument_list|(
name|this
operator|->
name|_context
operator|.
name|finiFunction
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|al
operator|&&
name|isa
operator|<
name|DefinedAtom
operator|>
operator|(
name|al
operator|->
name|_atom
operator|)
condition|)
return|return
name|al
return|;
return|return
name|nullptr
return|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|InterpSection
operator|:
name|public
name|Section
operator|<
name|ELFT
operator|>
block|{
name|public
operator|:
name|InterpSection
argument_list|(
argument|const ELFLinkingContext&context
argument_list|,
argument|StringRef str
argument_list|,
argument|int32_t order
argument_list|,
argument|StringRef interp
argument_list|)
operator|:
name|Section
operator|<
name|ELFT
operator|>
operator|(
name|context
operator|,
name|str
operator|,
literal|"Dynamic:Interp"
operator|)
block|,
name|_interp
argument_list|(
argument|interp
argument_list|)
block|{
name|this
operator|->
name|setOrder
argument_list|(
name|order
argument_list|)
block|;
name|this
operator|->
name|_alignment
operator|=
literal|1
block|;
comment|// + 1 for null term.
name|this
operator|->
name|_fsize
operator|=
name|interp
operator|.
name|size
argument_list|()
operator|+
literal|1
block|;
name|this
operator|->
name|_msize
operator|=
name|this
operator|->
name|_fsize
block|;
name|this
operator|->
name|_type
operator|=
name|SHT_PROGBITS
block|;
name|this
operator|->
name|_flags
operator|=
name|SHF_ALLOC
block|;   }
name|void
name|write
argument_list|(
argument|ELFWriter *writer
argument_list|,
argument|TargetLayout<ELFT>&layout
argument_list|,
argument|llvm::FileOutputBuffer&buffer
argument_list|)
block|{
name|uint8_t
operator|*
name|chunkBuffer
operator|=
name|buffer
operator|.
name|getBufferStart
argument_list|()
block|;
name|uint8_t
operator|*
name|dest
operator|=
name|chunkBuffer
operator|+
name|this
operator|->
name|fileOffset
argument_list|()
block|;
name|std
operator|::
name|memcpy
argument_list|(
name|dest
argument_list|,
name|_interp
operator|.
name|data
argument_list|()
argument_list|,
name|_interp
operator|.
name|size
argument_list|()
argument_list|)
block|;   }
name|private
operator|:
name|StringRef
name|_interp
block|; }
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// The hash table in the dynamic linker is organized into
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|///     [ nbuckets              ]
end_comment

begin_comment
comment|///     [ nchains               ]
end_comment

begin_comment
comment|///     [ buckets[0]            ]
end_comment

begin_comment
comment|///     .........................
end_comment

begin_comment
comment|///     [ buckets[nbuckets-1]   ]
end_comment

begin_comment
comment|///     [ chains[0]             ]
end_comment

begin_comment
comment|///     .........................
end_comment

begin_comment
comment|///     [ chains[nchains - 1]   ]
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// nbuckets - total number of hash buckets
end_comment

begin_comment
comment|/// nchains is equal to the number of dynamic symbols.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// The symbol is searched by the dynamic linker using the below approach.
end_comment

begin_comment
comment|///  * Calculate the hash of the symbol that needs to be searched
end_comment

begin_comment
comment|///  * Take the value from the buckets[hash % nbuckets] as the index of symbol
end_comment

begin_comment
comment|///  * Compare the symbol's name, if true return, if false, look through the
end_comment

begin_comment
comment|///  * array since there was a collision
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|HashSection
operator|:
name|public
name|Section
operator|<
name|ELFT
operator|>
block|{   struct
name|SymbolTableEntry
block|{
name|StringRef
name|_name
block|;
name|uint32_t
name|_index
block|;   }
block|;
name|public
operator|:
name|HashSection
argument_list|(
argument|const ELFLinkingContext&context
argument_list|,
argument|StringRef name
argument_list|,
argument|int32_t order
argument_list|)
operator|:
name|Section
operator|<
name|ELFT
operator|>
operator|(
name|context
operator|,
name|name
operator|,
literal|"Dynamic:Hash"
operator|)
block|,
name|_symbolTable
argument_list|(
argument|nullptr
argument_list|)
block|{
name|this
operator|->
name|setOrder
argument_list|(
name|order
argument_list|)
block|;
name|this
operator|->
name|_entSize
operator|=
literal|4
block|;
name|this
operator|->
name|_type
operator|=
name|SHT_HASH
block|;
name|this
operator|->
name|_flags
operator|=
name|SHF_ALLOC
block|;
name|this
operator|->
name|_alignment
operator|=
name|ELFT
operator|::
name|Is64Bits
condition|?
literal|8
else|:
literal|4
block|;
name|this
operator|->
name|_fsize
operator|=
literal|0
block|;
name|this
operator|->
name|_msize
operator|=
literal|0
block|;   }
comment|/// \brief add the dynamic symbol into the table so that the
comment|/// hash could be calculated
name|void
name|addSymbol
argument_list|(
argument|StringRef name
argument_list|,
argument|uint32_t index
argument_list|)
block|{
name|SymbolTableEntry
name|ste
block|;
name|ste
operator|.
name|_name
operator|=
name|name
block|;
name|ste
operator|.
name|_index
operator|=
name|index
block|;
name|_entries
operator|.
name|push_back
argument_list|(
name|ste
argument_list|)
block|;   }
comment|/// \brief Set the dynamic symbol table
name|void
name|setSymbolTable
argument_list|(
argument|const DynamicSymbolTable<ELFT> *symbolTable
argument_list|)
block|{
name|_symbolTable
operator|=
name|symbolTable
block|;   }
comment|// The size of the section has to be determined so that fileoffsets
comment|// may be properly assigned. Let's calculate the buckets and the chains
comment|// and fill the chains and the buckets hash table used by the dynamic
comment|// linker and update the filesize and memory size accordingly
name|void
name|doPreFlight
argument_list|()
name|override
block|{
comment|// The number of buckets to use for a certain number of symbols.
comment|// If there are less than 3 symbols, 1 bucket will be used. If
comment|// there are less than 17 symbols, 3 buckets will be used, and so
comment|// forth. The bucket numbers are defined by GNU ld. We use the
comment|// same rules here so we generate hash sections with the same
comment|// size as those generated by GNU ld.
name|uint32_t
name|hashBuckets
index|[]
operator|=
block|{
literal|1
block|,
literal|3
block|,
literal|17
block|,
literal|37
block|,
literal|67
block|,
literal|97
block|,
literal|131
block|,
literal|197
block|,
literal|263
block|,
literal|521
block|,
literal|1031
block|,
literal|2053
block|,
literal|4099
block|,
literal|8209
block|,
literal|16411
block|,
literal|32771
block|,
literal|65537
block|,
literal|131101
block|,
literal|262147
block|}
block|;
name|int
name|hashBucketsCount
operator|=
sizeof|sizeof
argument_list|(
name|hashBuckets
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
block|;
name|unsigned
name|int
name|bucketsCount
operator|=
literal|0
block|;
name|unsigned
name|int
name|dynSymCount
operator|=
name|_entries
operator|.
name|size
argument_list|()
block|;
comment|// Get the number of buckes that we want to use
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|hashBucketsCount
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|dynSymCount
operator|<
name|hashBuckets
index|[
name|i
index|]
condition|)
break|break;
name|bucketsCount
operator|=
name|hashBuckets
index|[
name|i
index|]
expr_stmt|;
block|}
name|_buckets
operator|.
name|resize
argument_list|(
name|bucketsCount
argument_list|)
block|;
name|_chains
operator|.
name|resize
argument_list|(
name|_entries
operator|.
name|size
argument_list|()
argument_list|)
block|;
comment|// Create the hash table for the dynamic linker
for|for
control|(
name|auto
name|ai
range|:
name|_entries
control|)
block|{
name|unsigned
name|int
name|dynsymIndex
init|=
name|ai
operator|.
name|_index
decl_stmt|;
name|unsigned
name|int
name|bucketpos
init|=
name|llvm
operator|::
name|object
operator|::
name|elf_hash
argument_list|(
name|ai
operator|.
name|_name
argument_list|)
operator|%
name|bucketsCount
decl_stmt|;
name|_chains
index|[
name|dynsymIndex
index|]
operator|=
name|_buckets
index|[
name|bucketpos
index|]
expr_stmt|;
name|_buckets
index|[
name|bucketpos
index|]
operator|=
name|dynsymIndex
expr_stmt|;
block|}
name|this
operator|->
name|_fsize
operator|=
operator|(
literal|2
operator|+
name|_chains
operator|.
name|size
argument_list|()
operator|+
name|_buckets
operator|.
name|size
argument_list|()
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|this
operator|->
name|_msize
operator|=
name|this
operator|->
name|_fsize
expr_stmt|;
end_expr_stmt

begin_macro
unit|}    void
name|finalize
argument_list|()
end_macro

begin_macro
name|override
end_macro

begin_block
block|{
name|this
operator|->
name|_link
operator|=
name|_symbolTable
condition|?
name|_symbolTable
operator|->
name|ordinal
argument_list|()
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|this
operator|->
name|_outputSection
condition|)
name|this
operator|->
name|_outputSection
operator|->
name|setLink
argument_list|(
name|this
operator|->
name|_link
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|void
name|write
argument_list|(
name|ELFWriter
operator|*
name|writer
argument_list|,
name|TargetLayout
operator|<
name|ELFT
operator|>
operator|&
name|layout
argument_list|,
name|llvm
operator|::
name|FileOutputBuffer
operator|&
name|buffer
argument_list|)
name|override
block|{
name|uint8_t
modifier|*
name|chunkBuffer
init|=
name|buffer
operator|.
name|getBufferStart
argument_list|()
decl_stmt|;
name|uint8_t
modifier|*
name|dest
init|=
name|chunkBuffer
operator|+
name|this
operator|->
name|fileOffset
argument_list|()
decl_stmt|;
name|uint32_t
name|bucketChainCounts
index|[
literal|2
index|]
decl_stmt|;
name|bucketChainCounts
index|[
literal|0
index|]
operator|=
name|_buckets
operator|.
name|size
argument_list|()
expr_stmt|;
name|bucketChainCounts
index|[
literal|1
index|]
operator|=
name|_chains
operator|.
name|size
argument_list|()
expr_stmt|;
name|std
operator|::
name|memcpy
argument_list|(
name|dest
argument_list|,
operator|(
name|char
operator|*
operator|)
name|bucketChainCounts
argument_list|,
sizeof|sizeof
argument_list|(
name|bucketChainCounts
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|+=
sizeof|sizeof
argument_list|(
name|bucketChainCounts
argument_list|)
expr_stmt|;
comment|// write bucket values
for|for
control|(
name|auto
name|bi
range|:
name|_buckets
control|)
block|{
name|uint32_t
name|val
init|=
operator|(
name|bi
operator|)
decl_stmt|;
name|std
operator|::
name|memcpy
argument_list|(
name|dest
argument_list|,
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
block|}
comment|// write chain values
for|for
control|(
name|auto
name|ci
range|:
name|_chains
control|)
block|{
name|uint32_t
name|val
init|=
operator|(
name|ci
operator|)
decl_stmt|;
name|std
operator|::
name|memcpy
argument_list|(
name|dest
argument_list|,
operator|&
name|val
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
name|dest
operator|+=
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_label
name|private
label|:
end_label

begin_expr_stmt
name|std
operator|::
name|vector
operator|<
name|SymbolTableEntry
operator|>
name|_entries
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|vector
operator|<
name|uint32_t
operator|>
name|_buckets
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|vector
operator|<
name|uint32_t
operator|>
name|_chains
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|const
name|DynamicSymbolTable
operator|<
name|ELFT
operator|>
operator|*
name|_symbolTable
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|EHFrameHeader
operator|:
name|public
name|Section
operator|<
name|ELFT
operator|>
block|{
name|public
operator|:
name|EHFrameHeader
argument_list|(
argument|const ELFLinkingContext&context
argument_list|,
argument|StringRef name
argument_list|,
argument|TargetLayout<ELFT>&layout
argument_list|,
argument|int32_t order
argument_list|)
operator|:
name|Section
operator|<
name|ELFT
operator|>
operator|(
name|context
operator|,
name|name
operator|,
literal|"EHFrameHeader"
operator|)
block|,
name|_ehFrameOffset
argument_list|(
literal|0
argument_list|)
block|,
name|_layout
argument_list|(
argument|layout
argument_list|)
block|{
name|this
operator|->
name|setOrder
argument_list|(
name|order
argument_list|)
block|;
name|this
operator|->
name|_entSize
operator|=
literal|0
block|;
name|this
operator|->
name|_type
operator|=
name|SHT_PROGBITS
block|;
name|this
operator|->
name|_flags
operator|=
name|SHF_ALLOC
block|;
name|this
operator|->
name|_alignment
operator|=
name|ELFT
operator|::
name|Is64Bits
condition|?
literal|8
else|:
literal|4
block|;
comment|// Minimum size for empty .eh_frame_hdr.
name|this
operator|->
name|_fsize
operator|=
literal|1
operator|+
literal|1
operator|+
literal|1
operator|+
literal|1
operator|+
literal|4
block|;
name|this
operator|->
name|_msize
operator|=
name|this
operator|->
name|_fsize
block|;   }
name|void
name|doPreFlight
argument_list|()
name|override
block|{
comment|// TODO: Generate a proper binary search table.
block|}
name|void
name|finalize
argument_list|()
name|override
block|{
name|OutputSection
operator|<
name|ELFT
operator|>
operator|*
name|s
operator|=
name|_layout
operator|.
name|findOutputSection
argument_list|(
literal|".eh_frame"
argument_list|)
block|;
name|OutputSection
operator|<
name|ELFT
operator|>
operator|*
name|h
operator|=
name|_layout
operator|.
name|findOutputSection
argument_list|(
literal|".eh_frame_hdr"
argument_list|)
block|;
if|if
condition|(
name|s
operator|&&
name|h
condition|)
name|_ehFrameOffset
operator|=
name|s
operator|->
name|virtualAddr
argument_list|()
operator|-
operator|(
name|h
operator|->
name|virtualAddr
argument_list|()
operator|+
literal|4
operator|)
expr_stmt|;
block|}
name|void
name|write
argument_list|(
argument|ELFWriter *writer
argument_list|,
argument|TargetLayout<ELFT>&layout
argument_list|,
argument|llvm::FileOutputBuffer&buffer
argument_list|)
name|override
block|{
name|uint8_t
operator|*
name|chunkBuffer
operator|=
name|buffer
operator|.
name|getBufferStart
argument_list|()
block|;
name|uint8_t
operator|*
name|dest
operator|=
name|chunkBuffer
operator|+
name|this
operator|->
name|fileOffset
argument_list|()
block|;
name|int
name|pos
operator|=
literal|0
block|;
name|dest
index|[
name|pos
operator|++
index|]
operator|=
literal|1
block|;
comment|// version
name|dest
index|[
name|pos
operator|++
index|]
operator|=
name|llvm
operator|::
name|dwarf
operator|::
name|DW_EH_PE_pcrel
operator||
name|llvm
operator|::
name|dwarf
operator|::
name|DW_EH_PE_sdata4
block|;
comment|// eh_frame_ptr_enc
name|dest
index|[
name|pos
operator|++
index|]
operator|=
name|llvm
operator|::
name|dwarf
operator|::
name|DW_EH_PE_omit
block|;
comment|// fde_count_enc
name|dest
index|[
name|pos
operator|++
index|]
operator|=
name|llvm
operator|::
name|dwarf
operator|::
name|DW_EH_PE_omit
block|;
comment|// table_enc
operator|*
name|reinterpret_cast
operator|<
name|typename
name|llvm
operator|::
name|object
operator|::
name|ELFFile
operator|<
name|ELFT
operator|>
operator|::
name|Elf_Sword
operator|*
operator|>
operator|(
name|dest
operator|+
name|pos
operator|)
operator|=
name|_ehFrameOffset
block|;   }
name|private
operator|:
name|int32_t
name|_ehFrameOffset
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TargetLayout
operator|<
name|ELFT
operator|>
operator|&
name|_layout
expr_stmt|;
end_expr_stmt

begin_comment
unit|}; }
comment|// end namespace elf
end_comment

begin_comment
unit|}
comment|// end namespace lld
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

