begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- lib/ReaderWriter/ELF/Mips/MipsTargetHandler.h ----------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                             The LLVM Linker
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLD_READER_WRITER_ELF_MIPS_MIPS_TARGET_HANDLER_H
end_ifndef

begin_define
define|#
directive|define
name|LLD_READER_WRITER_ELF_MIPS_MIPS_TARGET_HANDLER_H
end_define

begin_include
include|#
directive|include
file|"DefaultTargetHandler.h"
end_include

begin_include
include|#
directive|include
file|"MipsDynamicLibraryWriter.h"
end_include

begin_include
include|#
directive|include
file|"MipsELFReader.h"
end_include

begin_include
include|#
directive|include
file|"MipsExecutableWriter.h"
end_include

begin_include
include|#
directive|include
file|"MipsLinkingContext.h"
end_include

begin_include
include|#
directive|include
file|"MipsRelocationHandler.h"
end_include

begin_include
include|#
directive|include
file|"MipsSectionChunks.h"
end_include

begin_include
include|#
directive|include
file|"TargetLayout.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseSet.h"
end_include

begin_decl_stmt
name|namespace
name|lld
block|{
name|namespace
name|elf
block|{
comment|/// \brief TargetLayout for Mips
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|MipsTargetLayout
name|final
operator|:
name|public
name|TargetLayout
operator|<
name|ELFT
operator|>
block|{
name|public
operator|:
name|MipsTargetLayout
argument_list|(
name|MipsLinkingContext
operator|&
name|ctx
argument_list|)
operator|:
name|TargetLayout
operator|<
name|ELFT
operator|>
operator|(
name|ctx
operator|)
block|,
name|_gotSection
argument_list|(
name|new
argument_list|(
argument|this->_allocator
argument_list|)
name|MipsGOTSection
operator|<
name|ELFT
operator|>
operator|(
name|ctx
operator|)
argument_list|)
block|,
name|_pltSection
argument_list|(
argument|new (this->_allocator) MipsPLTSection<ELFT>(ctx)
argument_list|)
block|{}
specifier|const
name|MipsGOTSection
operator|<
name|ELFT
operator|>
operator|&
name|getGOTSection
argument_list|()
specifier|const
block|{
return|return
operator|*
name|_gotSection
return|;
block|}
specifier|const
name|MipsPLTSection
operator|<
name|ELFT
operator|>
operator|&
name|getPLTSection
argument_list|()
specifier|const
block|{
return|return
operator|*
name|_pltSection
return|;
block|}
name|AtomSection
operator|<
name|ELFT
operator|>
operator|*
name|createSection
argument_list|(
argument|StringRef name
argument_list|,
argument|int32_t type
argument_list|,
argument|DefinedAtom::ContentPermissions permissions
argument_list|,
argument|Layout::SectionOrder order
argument_list|)
name|override
block|{
if|if
condition|(
name|type
operator|==
name|DefinedAtom
operator|::
name|typeGOT
operator|&&
name|name
operator|==
literal|".got"
condition|)
return|return
name|_gotSection
return|;
if|if
condition|(
name|type
operator|==
name|DefinedAtom
operator|::
name|typeStub
operator|&&
name|name
operator|==
literal|".plt"
condition|)
return|return
name|_pltSection
return|;
return|return
name|DefaultLayout
operator|<
name|ELFT
operator|>
operator|::
name|createSection
argument_list|(
name|name
argument_list|,
name|type
argument_list|,
name|permissions
argument_list|,
name|order
argument_list|)
return|;
block|}
comment|/// \brief GP offset relative to .got section.
name|uint64_t
name|getGPOffset
argument_list|()
specifier|const
block|{
return|return
literal|0x7FF0
return|;
block|}
comment|/// \brief Get '_gp' symbol atom layout.
name|AtomLayout
modifier|*
name|getGP
parameter_list|()
block|{
if|if
condition|(
operator|!
name|_gpAtom
operator|.
name|hasValue
argument_list|()
condition|)
block|{
name|auto
name|atom
init|=
name|this
operator|->
name|findAbsoluteAtom
argument_list|(
literal|"_gp"
argument_list|)
decl_stmt|;
name|_gpAtom
operator|=
name|atom
operator|!=
name|this
operator|->
name|absoluteAtoms
argument_list|()
operator|.
name|end
argument_list|()
condition|?
operator|*
name|atom
else|:
name|nullptr
expr_stmt|;
block|}
return|return
operator|*
name|_gpAtom
return|;
block|}
comment|/// \brief Get '_gp_disp' symbol atom layout.
name|AtomLayout
modifier|*
name|getGPDisp
parameter_list|()
block|{
if|if
condition|(
operator|!
name|_gpDispAtom
operator|.
name|hasValue
argument_list|()
condition|)
block|{
name|auto
name|atom
init|=
name|this
operator|->
name|findAbsoluteAtom
argument_list|(
literal|"_gp_disp"
argument_list|)
decl_stmt|;
name|_gpDispAtom
operator|=
name|atom
operator|!=
name|this
operator|->
name|absoluteAtoms
argument_list|()
operator|.
name|end
argument_list|()
condition|?
operator|*
name|atom
else|:
name|nullptr
expr_stmt|;
block|}
return|return
operator|*
name|_gpDispAtom
return|;
block|}
comment|/// \brief Return the section order for a input section
name|Layout
operator|::
name|SectionOrder
name|getSectionOrder
argument_list|(
argument|StringRef name
argument_list|,
argument|int32_t contentType
argument_list|,
argument|int32_t contentPermissions
argument_list|)
name|override
block|{
if|if
condition|(
operator|(
name|contentType
operator|==
name|DefinedAtom
operator|::
name|typeStub
operator|)
operator|&&
operator|(
name|name
operator|.
name|startswith
argument_list|(
literal|".text"
argument_list|)
operator|)
condition|)
return|return
name|DefaultLayout
operator|<
name|ELFT
operator|>
operator|::
name|ORDER_TEXT
return|;
return|return
name|DefaultLayout
operator|<
name|ELFT
operator|>
operator|::
name|getSectionOrder
argument_list|(
name|name
argument_list|,
name|contentType
argument_list|,
name|contentPermissions
argument_list|)
return|;
block|}
end_decl_stmt

begin_label
name|protected
label|:
end_label

begin_expr_stmt
name|unique_bump_ptr
operator|<
name|RelocationTable
operator|<
name|ELFT
operator|>>
name|createRelocationTable
argument_list|(
argument|StringRef name
argument_list|,
argument|int32_t order
argument_list|)
name|override
block|{
return|return
name|unique_bump_ptr
operator|<
name|RelocationTable
operator|<
name|ELFT
operator|>>
operator|(
name|new
argument_list|(
argument|this->_allocator
argument_list|)
name|MipsRelocationTable
operator|<
name|ELFT
operator|>
operator|(
name|this
operator|->
name|_context
operator|,
name|name
operator|,
name|order
operator|)
operator|)
return|;
block|}
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_expr_stmt
name|MipsGOTSection
operator|<
name|ELFT
operator|>
operator|*
name|_gotSection
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|MipsPLTSection
operator|<
name|ELFT
operator|>
operator|*
name|_pltSection
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|llvm
operator|::
name|Optional
operator|<
name|AtomLayout
operator|*
operator|>
name|_gpAtom
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|llvm
operator|::
name|Optional
operator|<
name|AtomLayout
operator|*
operator|>
name|_gpDispAtom
expr_stmt|;
end_expr_stmt

begin_comment
unit|};
comment|/// \brief Mips Runtime file.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|MipsRuntimeFile
name|final
operator|:
name|public
name|RuntimeFile
operator|<
name|ELFT
operator|>
block|{
name|public
operator|:
name|MipsRuntimeFile
argument_list|(
name|MipsLinkingContext
operator|&
name|ctx
argument_list|)
operator|:
name|RuntimeFile
operator|<
name|ELFT
operator|>
operator|(
name|ctx
operator|,
literal|"Mips runtime file"
operator|)
block|{}
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// \brief Auxiliary class holds relocation's names table.
end_comment

begin_decl_stmt
name|class
name|MipsRelocationStringTable
block|{
specifier|static
specifier|const
name|Registry
operator|::
name|KindStrings
name|kindStrings
index|[]
expr_stmt|;
name|public
label|:
specifier|static
name|void
name|registerTable
parameter_list|(
name|Registry
modifier|&
name|registry
parameter_list|)
function_decl|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// \brief TargetHandler for Mips
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|MipsTargetHandler
name|final
operator|:
name|public
name|DefaultTargetHandler
operator|<
name|ELFT
operator|>
block|{
name|public
operator|:
name|MipsTargetHandler
argument_list|(
name|MipsLinkingContext
operator|&
name|ctx
argument_list|)
operator|:
name|_ctx
argument_list|(
name|ctx
argument_list|)
block|,
name|_runtimeFile
argument_list|(
argument|new MipsRuntimeFile<ELFT>(ctx)
argument_list|)
block|,
name|_targetLayout
argument_list|(
argument|new MipsTargetLayout<ELFT>(ctx)
argument_list|)
block|,
name|_relocationHandler
argument_list|(
argument|createMipsRelocationHandler<ELFT>(ctx)
argument_list|)
block|{}
name|MipsTargetLayout
operator|<
name|ELFT
operator|>
operator|&
name|getTargetLayout
argument_list|()
name|override
block|{
return|return
operator|*
name|_targetLayout
return|;
block|}
name|std
operator|::
name|unique_ptr
operator|<
name|Reader
operator|>
name|getObjReader
argument_list|()
name|override
block|{
return|return
name|std
operator|::
name|unique_ptr
operator|<
name|Reader
operator|>
operator|(
name|new
name|MipsELFObjectReader
operator|<
name|ELFT
operator|>
operator|(
name|_ctx
operator|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|unique_ptr
operator|<
name|Reader
operator|>
name|getDSOReader
argument_list|()
name|override
block|{
return|return
name|std
operator|::
name|unique_ptr
operator|<
name|Reader
operator|>
operator|(
name|new
name|MipsELFDSOReader
operator|<
name|ELFT
operator|>
operator|(
name|_ctx
operator|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|const
name|TargetRelocationHandler
operator|&
name|getRelocationHandler
argument_list|()
specifier|const
name|override
block|{
return|return
operator|*
name|_relocationHandler
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|unique_ptr
operator|<
name|Writer
operator|>
name|getWriter
argument_list|()
name|override
block|{
switch|switch
condition|(
name|_ctx
operator|.
name|getOutputELFType
argument_list|()
condition|)
block|{
case|case
name|llvm
operator|::
name|ELF
operator|::
name|ET_EXEC
case|:
return|return
name|std
operator|::
name|unique_ptr
operator|<
name|Writer
operator|>
operator|(
name|new
name|MipsExecutableWriter
operator|<
name|ELFT
operator|>
operator|(
name|_ctx
operator|,
operator|*
name|_targetLayout
operator|)
operator|)
return|;
case|case
name|llvm
operator|::
name|ELF
operator|::
name|ET_DYN
case|:
return|return
name|std
operator|::
name|unique_ptr
operator|<
name|Writer
operator|>
operator|(
name|new
name|MipsDynamicLibraryWriter
operator|<
name|ELFT
operator|>
operator|(
name|_ctx
operator|,
operator|*
name|_targetLayout
operator|)
operator|)
return|;
case|case
name|llvm
operator|::
name|ELF
operator|::
name|ET_REL
case|:
name|llvm_unreachable
argument_list|(
literal|"TODO: support -r mode"
argument_list|)
expr_stmt|;
default|default:
name|llvm_unreachable
argument_list|(
literal|"unsupported output type"
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_macro
unit|}    void
name|registerRelocationNames
argument_list|(
argument|Registry&registry
argument_list|)
end_macro

begin_macro
name|override
end_macro

begin_block
block|{
name|MipsRelocationStringTable
operator|::
name|registerTable
argument_list|(
name|registry
argument_list|)
expr_stmt|;
block|}
end_block

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|MipsLinkingContext
modifier|&
name|_ctx
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|std
operator|::
name|unique_ptr
operator|<
name|MipsRuntimeFile
operator|<
name|ELFT
operator|>>
name|_runtimeFile
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|unique_ptr
operator|<
name|MipsTargetLayout
operator|<
name|ELFT
operator|>>
name|_targetLayout
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|unique_ptr
operator|<
name|TargetRelocationHandler
operator|>
name|_relocationHandler
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|MipsSymbolTable
operator|:
name|public
name|SymbolTable
operator|<
name|ELFT
operator|>
block|{
name|public
operator|:
typedef|typedef
name|llvm
operator|::
name|object
operator|::
name|Elf_Sym_Impl
operator|<
name|ELFT
operator|>
name|Elf_Sym
expr_stmt|;
name|MipsSymbolTable
argument_list|(
specifier|const
name|ELFLinkingContext
operator|&
name|ctx
argument_list|)
operator|:
name|SymbolTable
operator|<
name|ELFT
operator|>
operator|(
name|ctx
operator|,
literal|".symtab"
operator|,
name|DefaultLayout
operator|<
name|ELFT
operator|>
operator|::
name|ORDER_SYMBOL_TABLE
operator|)
block|{}
name|void
name|addDefinedAtom
argument_list|(
argument|Elf_Sym&sym
argument_list|,
argument|const DefinedAtom *da
argument_list|,
argument|int64_t addr
argument_list|)
name|override
block|{
name|SymbolTable
operator|<
name|ELFT
operator|>
operator|::
name|addDefinedAtom
argument_list|(
name|sym
argument_list|,
name|da
argument_list|,
name|addr
argument_list|)
block|;
switch|switch
condition|(
name|da
operator|->
name|codeModel
argument_list|()
condition|)
block|{
case|case
name|DefinedAtom
operator|::
name|codeMipsMicro
case|:
name|sym
operator|.
name|st_other
operator||=
name|llvm
operator|::
name|ELF
operator|::
name|STO_MIPS_MICROMIPS
expr_stmt|;
break|break;
case|case
name|DefinedAtom
operator|::
name|codeMipsMicroPIC
case|:
name|sym
operator|.
name|st_other
operator||=
name|llvm
operator|::
name|ELF
operator|::
name|STO_MIPS_MICROMIPS
operator||
name|llvm
operator|::
name|ELF
operator|::
name|STO_MIPS_PIC
expr_stmt|;
break|break;
default|default:
break|break;
block|}
end_expr_stmt

begin_macro
unit|}    void
name|finalize
argument_list|(
argument|bool sort
argument_list|)
end_macro

begin_macro
name|override
end_macro

begin_block
block|{
name|SymbolTable
operator|<
name|ELFT
operator|>
operator|::
name|finalize
argument_list|(
name|sort
argument_list|)
expr_stmt|;
for|for
control|(
name|auto
operator|&
name|ste
operator|:
name|this
operator|->
name|_symbolTable
control|)
block|{
if|if
condition|(
operator|!
name|ste
operator|.
name|_atom
condition|)
continue|continue;
if|if
condition|(
specifier|const
specifier|auto
modifier|*
name|da
init|=
name|dyn_cast
operator|<
name|DefinedAtom
operator|>
operator|(
name|ste
operator|.
name|_atom
operator|)
condition|)
block|{
if|if
condition|(
name|da
operator|->
name|codeModel
argument_list|()
operator|==
name|DefinedAtom
operator|::
name|codeMipsMicro
operator|||
name|da
operator|->
name|codeModel
argument_list|()
operator|==
name|DefinedAtom
operator|::
name|codeMipsMicroPIC
condition|)
block|{
comment|// Adjust dynamic microMIPS symbol value. That allows a dynamic
comment|// linker to recognize and handle this symbol correctly.
name|ste
operator|.
name|_symbol
operator|.
name|st_value
operator|=
name|ste
operator|.
name|_symbol
operator|.
name|st_value
operator||
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|MipsDynamicSymbolTable
operator|:
name|public
name|DynamicSymbolTable
operator|<
name|ELFT
operator|>
block|{
name|public
operator|:
name|MipsDynamicSymbolTable
argument_list|(
specifier|const
name|ELFLinkingContext
operator|&
name|ctx
argument_list|,
name|MipsTargetLayout
operator|<
name|ELFT
operator|>
operator|&
name|layout
argument_list|)
operator|:
name|DynamicSymbolTable
operator|<
name|ELFT
operator|>
operator|(
name|ctx
operator|,
name|layout
operator|,
literal|".dynsym"
operator|,
name|DefaultLayout
operator|<
name|ELFT
operator|>
operator|::
name|ORDER_DYNAMIC_SYMBOLS
operator|)
block|,
name|_targetLayout
argument_list|(
argument|layout
argument_list|)
block|{}
name|void
name|sortSymbols
argument_list|()
name|override
block|{
typedef|typedef
name|typename
name|DynamicSymbolTable
operator|<
name|ELFT
operator|>
operator|::
name|SymbolEntry
name|SymbolEntry
expr_stmt|;
name|std
operator|::
name|stable_sort
argument_list|(
name|this
operator|->
name|_symbolTable
operator|.
name|begin
argument_list|()
argument_list|,
name|this
operator|->
name|_symbolTable
operator|.
name|end
argument_list|()
argument_list|,
index|[
name|this
index|]
operator|(
specifier|const
name|SymbolEntry
operator|&
name|A
operator|,
specifier|const
name|SymbolEntry
operator|&
name|B
operator|)
block|{
if|if
condition|(
name|A
operator|.
name|_symbol
operator|.
name|getBinding
argument_list|()
operator|!=
name|STB_GLOBAL
operator|&&
name|B
operator|.
name|_symbol
operator|.
name|getBinding
argument_list|()
operator|!=
name|STB_GLOBAL
condition|)
return|return
name|A
operator|.
name|_symbol
operator|.
name|getBinding
argument_list|()
operator|<
name|B
operator|.
name|_symbol
operator|.
name|getBinding
argument_list|()
return|;
return|return
name|_targetLayout
operator|.
name|getGOTSection
argument_list|()
operator|.
name|compare
argument_list|(
name|A
operator|.
name|_atom
argument_list|,
name|B
operator|.
name|_atom
argument_list|)
return|;
block|}
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_macro
unit|}    void
name|finalize
argument_list|()
end_macro

begin_macro
name|override
end_macro

begin_block
block|{
name|DynamicSymbolTable
operator|<
name|ELFT
operator|>
operator|::
name|finalize
argument_list|()
expr_stmt|;
specifier|const
specifier|auto
modifier|&
name|pltSection
init|=
name|_targetLayout
operator|.
name|getPLTSection
argument_list|()
decl_stmt|;
for|for
control|(
name|auto
operator|&
name|ste
operator|:
name|this
operator|->
name|_symbolTable
control|)
block|{
specifier|const
name|Atom
modifier|*
name|a
init|=
name|ste
operator|.
name|_atom
decl_stmt|;
if|if
condition|(
operator|!
name|a
condition|)
continue|continue;
if|if
condition|(
name|auto
operator|*
name|layout
operator|=
name|pltSection
operator|.
name|findPLTLayout
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|a
operator|=
name|layout
operator|->
name|_atom
expr_stmt|;
comment|// Under some conditions a dynamic symbol table record should hold
comment|// a symbol value of the corresponding PLT entry. For details look
comment|// at the PLT entry creation code in the class MipsRelocationPass.
comment|// Let's update atomLayout fields for such symbols.
name|assert
argument_list|(
operator|!
name|ste
operator|.
name|_atomLayout
argument_list|)
expr_stmt|;
name|ste
operator|.
name|_symbol
operator|.
name|st_value
operator|=
name|layout
operator|->
name|_virtualAddr
expr_stmt|;
name|ste
operator|.
name|_symbol
operator|.
name|st_other
operator||=
name|ELF
operator|::
name|STO_MIPS_PLT
expr_stmt|;
block|}
if|if
condition|(
specifier|const
specifier|auto
modifier|*
name|da
init|=
name|dyn_cast
operator|<
name|DefinedAtom
operator|>
operator|(
name|a
operator|)
condition|)
block|{
if|if
condition|(
name|da
operator|->
name|codeModel
argument_list|()
operator|==
name|DefinedAtom
operator|::
name|codeMipsMicro
operator|||
name|da
operator|->
name|codeModel
argument_list|()
operator|==
name|DefinedAtom
operator|::
name|codeMipsMicroPIC
condition|)
block|{
comment|// Adjust dynamic microMIPS symbol value. That allows a dynamic
comment|// linker to recognize and handle this symbol correctly.
name|ste
operator|.
name|_symbol
operator|.
name|st_value
operator|=
name|ste
operator|.
name|_symbol
operator|.
name|st_value
operator||
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
end_block

begin_label
name|private
label|:
end_label

begin_expr_stmt
name|MipsTargetLayout
operator|<
name|ELFT
operator|>
operator|&
name|_targetLayout
expr_stmt|;
end_expr_stmt

begin_comment
unit|};  }
comment|// end namespace elf
end_comment

begin_comment
unit|}
comment|// end namespace lld
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

