begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- lib/ReaderWriter/ELF/ELFFile.h -------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                             The LLVM Linker
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLD_READER_WRITER_ELF_FILE_H
end_ifndef

begin_define
define|#
directive|define
name|LLD_READER_WRITER_ELF_FILE_H
end_define

begin_include
include|#
directive|include
file|"Atoms.h"
end_include

begin_include
include|#
directive|include
file|<llvm/ADT/MapVector.h>
end_include

begin_include
include|#
directive|include
file|<map>
end_include

begin_include
include|#
directive|include
file|<unordered_map>
end_include

begin_decl_stmt
name|namespace
name|lld
block|{
name|namespace
name|elf
block|{
comment|/// \brief Read a binary, find out based on the symbol table contents what kind
comment|/// of symbol it is and create corresponding atoms for it
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|ELFFile
operator|:
name|public
name|File
block|{
typedef|typedef
name|llvm
operator|::
name|object
operator|::
name|Elf_Sym_Impl
operator|<
name|ELFT
operator|>
name|Elf_Sym
expr_stmt|;
typedef|typedef
name|llvm
operator|::
name|object
operator|::
name|Elf_Shdr_Impl
operator|<
name|ELFT
operator|>
name|Elf_Shdr
expr_stmt|;
typedef|typedef
name|llvm
operator|::
name|object
operator|::
name|Elf_Rel_Impl
operator|<
name|ELFT
operator|,
name|false
operator|>
name|Elf_Rel
expr_stmt|;
typedef|typedef
name|llvm
operator|::
name|object
operator|::
name|Elf_Rel_Impl
operator|<
name|ELFT
operator|,
name|true
operator|>
name|Elf_Rela
expr_stmt|;
typedef|typedef
name|typename
name|llvm
operator|::
name|object
operator|::
name|ELFFile
operator|<
name|ELFT
operator|>
operator|::
name|Elf_Sym_Iter
name|Elf_Sym_Iter
expr_stmt|;
typedef|typedef
name|typename
name|llvm
operator|::
name|object
operator|::
name|ELFFile
operator|<
name|ELFT
operator|>
operator|::
name|Elf_Rela_Iter
name|Elf_Rela_Iter
expr_stmt|;
typedef|typedef
name|typename
name|llvm
operator|::
name|object
operator|::
name|ELFFile
operator|<
name|ELFT
operator|>
operator|::
name|Elf_Rel_Iter
name|Elf_Rel_Iter
expr_stmt|;
typedef|typedef
name|typename
name|llvm
operator|::
name|object
operator|::
name|ELFFile
operator|<
name|ELFT
operator|>
operator|::
name|Elf_Word
name|Elf_Word
expr_stmt|;
comment|// A Map is used to hold the atoms that have been divided up
comment|// after reading the section that contains Merge String attributes
struct|struct
name|MergeSectionKey
block|{
name|MergeSectionKey
argument_list|(
argument|const Elf_Shdr *shdr
argument_list|,
argument|int64_t offset
argument_list|)
block|:
name|_shdr
argument_list|(
name|shdr
argument_list|)
operator|,
name|_offset
argument_list|(
argument|offset
argument_list|)
block|{}
comment|// Data members
specifier|const
name|Elf_Shdr
operator|*
name|_shdr
expr_stmt|;
name|int64_t
name|_offset
decl_stmt|;
block|}
struct|;
struct|struct
name|MergeSectionEq
block|{
name|int64_t
name|operator
argument_list|()
operator|(
specifier|const
name|MergeSectionKey
operator|&
name|k
operator|)
specifier|const
block|{
return|return
name|llvm
operator|::
name|hash_combine
argument_list|(
call|(
name|int64_t
call|)
argument_list|(
name|k
operator|.
name|_shdr
operator|->
name|sh_name
argument_list|)
argument_list|,
operator|(
name|int64_t
operator|)
name|k
operator|.
name|_offset
argument_list|)
return|;
block|}
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|MergeSectionKey
operator|&
name|lhs
operator|,
specifier|const
name|MergeSectionKey
operator|&
name|rhs
operator|)
specifier|const
block|{
return|return
operator|(
operator|(
name|lhs
operator|.
name|_shdr
operator|->
name|sh_name
operator|==
name|rhs
operator|.
name|_shdr
operator|->
name|sh_name
operator|)
operator|&&
operator|(
name|lhs
operator|.
name|_offset
operator|==
name|rhs
operator|.
name|_offset
operator|)
operator|)
return|;
block|}
block|}
struct|;
struct|struct
name|MergeString
block|{
name|MergeString
argument_list|(
argument|int64_t offset
argument_list|,
argument|StringRef str
argument_list|,
argument|const Elf_Shdr *shdr
argument_list|,
argument|StringRef sectionName
argument_list|)
block|:
name|_offset
argument_list|(
name|offset
argument_list|)
operator|,
name|_string
argument_list|(
name|str
argument_list|)
operator|,
name|_shdr
argument_list|(
name|shdr
argument_list|)
operator|,
name|_sectionName
argument_list|(
argument|sectionName
argument_list|)
block|{}
comment|// the offset of this atom
name|int64_t
name|_offset
expr_stmt|;
comment|// The content
name|StringRef
name|_string
decl_stmt|;
comment|// Section header
specifier|const
name|Elf_Shdr
modifier|*
name|_shdr
decl_stmt|;
comment|// Section name
name|StringRef
name|_sectionName
decl_stmt|;
block|}
struct|;
comment|// This is used to find the MergeAtom given a relocation
comment|// offset
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|ELFMergeAtom
operator|<
name|ELFT
operator|>
operator|*
operator|>
name|MergeAtomsT
expr_stmt|;
comment|/// \brief find a mergeAtom given a start offset
struct|struct
name|FindByOffset
block|{
specifier|const
name|Elf_Shdr
modifier|*
name|_shdr
decl_stmt|;
name|int64_t
name|_offset
decl_stmt|;
name|FindByOffset
argument_list|(
argument|const Elf_Shdr *shdr
argument_list|,
argument|int64_t offset
argument_list|)
block|:
name|_shdr
argument_list|(
name|shdr
argument_list|)
operator|,
name|_offset
argument_list|(
argument|offset
argument_list|)
block|{}
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|ELFMergeAtom
operator|<
name|ELFT
operator|>
operator|*
name|a
operator|)
block|{
name|int64_t
name|off
operator|=
name|a
operator|->
name|offset
argument_list|()
block|;
return|return
operator|(
name|_shdr
operator|->
name|sh_name
operator|==
name|a
operator|->
name|section
argument_list|()
operator|)
operator|&&
operator|(
operator|(
name|_offset
operator|>=
name|off
operator|)
operator|&&
operator|(
name|_offset
operator|<=
name|off
operator|+
operator|(
name|int64_t
operator|)
name|a
operator|->
name|size
argument_list|()
operator|)
operator|)
return|;
block|}
block|}
struct|;
comment|/// \brief find a merge atom given a offset
name|ELFMergeAtom
operator|<
name|ELFT
operator|>
operator|*
name|findMergeAtom
argument_list|(
argument|const Elf_Shdr *shdr
argument_list|,
argument|uint64_t offset
argument_list|)
block|{
name|auto
name|it
operator|=
name|std
operator|::
name|find_if
argument_list|(
name|_mergeAtoms
operator|.
name|begin
argument_list|()
argument_list|,
name|_mergeAtoms
operator|.
name|end
argument_list|()
argument_list|,
name|FindByOffset
argument_list|(
name|shdr
argument_list|,
name|offset
argument_list|)
argument_list|)
block|;
name|assert
argument_list|(
name|it
operator|!=
name|_mergeAtoms
operator|.
name|end
argument_list|()
argument_list|)
block|;
return|return
operator|*
name|it
return|;
block|}
typedef|typedef
name|std
operator|::
name|unordered_map
operator|<
name|MergeSectionKey
operator|,
name|DefinedAtom
operator|*
operator|,
name|MergeSectionEq
operator|,
name|MergeSectionEq
operator|>
name|MergedSectionMapT
expr_stmt|;
typedef|typedef
name|typename
name|MergedSectionMapT
operator|::
name|iterator
name|MergedSectionMapIterT
expr_stmt|;
name|public
label|:
name|ELFFile
argument_list|(
argument|StringRef name
argument_list|,
argument|ELFLinkingContext&ctx
argument_list|)
block|:
name|File
argument_list|(
name|name
argument_list|,
name|kindObject
argument_list|)
operator|,
name|_ordinal
argument_list|(
literal|0
argument_list|)
operator|,
name|_doStringsMerge
argument_list|(
name|ctx
operator|.
name|mergeCommonStrings
argument_list|()
argument_list|)
operator|,
name|_useWrap
argument_list|(
name|false
argument_list|)
operator|,
name|_ctx
argument_list|(
argument|ctx
argument_list|)
block|{
name|setLastError
argument_list|(
name|std
operator|::
name|error_code
argument_list|()
argument_list|)
block|;   }
name|ELFFile
argument_list|(
name|std
operator|::
name|unique_ptr
operator|<
name|MemoryBuffer
operator|>
name|mb
argument_list|,
name|ELFLinkingContext
operator|&
name|ctx
argument_list|)
operator|:
name|File
argument_list|(
name|mb
operator|->
name|getBufferIdentifier
argument_list|()
argument_list|,
name|kindObject
argument_list|)
operator|,
name|_mb
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|mb
argument_list|)
argument_list|)
operator|,
name|_ordinal
argument_list|(
literal|0
argument_list|)
operator|,
name|_doStringsMerge
argument_list|(
name|ctx
operator|.
name|mergeCommonStrings
argument_list|()
argument_list|)
operator|,
name|_useWrap
argument_list|(
name|ctx
operator|.
name|wrapCalls
argument_list|()
operator|.
name|size
argument_list|()
argument_list|)
operator|,
name|_ctx
argument_list|(
argument|ctx
argument_list|)
block|{}
specifier|static
name|ErrorOr
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|ELFFile
operator|>>
name|create
argument_list|(
name|std
operator|::
name|unique_ptr
operator|<
name|MemoryBuffer
operator|>
name|mb
argument_list|,
name|ELFLinkingContext
operator|&
name|ctx
argument_list|)
expr_stmt|;
name|virtual
name|Reference
operator|::
name|KindArch
name|kindArch
argument_list|()
expr_stmt|;
comment|/// \brief Create symbols from LinkingContext.
name|std
operator|::
name|error_code
name|createAtomsFromContext
argument_list|()
expr_stmt|;
comment|/// \brief Read input sections and populate necessary data structures
comment|/// to read them later and create atoms
name|std
operator|::
name|error_code
name|createAtomizableSections
argument_list|()
expr_stmt|;
comment|/// \brief Create mergeable atoms from sections that have the merge attribute
comment|/// set
name|std
operator|::
name|error_code
name|createMergeableAtoms
argument_list|()
expr_stmt|;
comment|/// \brief Add the symbols that the sections contain. The symbols will be
comment|/// converted to atoms for
comment|/// Undefined symbols, absolute symbols
name|std
operator|::
name|error_code
name|createSymbolsFromAtomizableSections
argument_list|()
expr_stmt|;
comment|/// \brief Create individual atoms
name|std
operator|::
name|error_code
name|createAtoms
argument_list|()
expr_stmt|;
specifier|const
name|atom_collection
operator|<
name|DefinedAtom
operator|>
operator|&
name|defined
argument_list|()
specifier|const
name|override
block|{
return|return
name|_definedAtoms
return|;
block|}
specifier|const
name|atom_collection
operator|<
name|UndefinedAtom
operator|>
operator|&
name|undefined
argument_list|()
specifier|const
name|override
block|{
return|return
name|_undefinedAtoms
return|;
block|}
specifier|const
name|atom_collection
operator|<
name|SharedLibraryAtom
operator|>
operator|&
name|sharedLibrary
argument_list|()
specifier|const
name|override
block|{
return|return
name|_sharedLibraryAtoms
return|;
block|}
specifier|const
name|atom_collection
operator|<
name|AbsoluteAtom
operator|>
operator|&
name|absolute
argument_list|()
specifier|const
name|override
block|{
return|return
name|_absoluteAtoms
return|;
block|}
name|Atom
modifier|*
name|findAtom
parameter_list|(
specifier|const
name|Elf_Sym
modifier|*
name|sourceSymbol
parameter_list|,
specifier|const
name|Elf_Sym
modifier|*
name|targetSymbol
parameter_list|)
block|{
comment|// All references to atoms inside a group are through undefined atoms.
name|Atom
modifier|*
name|targetAtom
init|=
name|_symbolToAtomMapping
operator|.
name|lookup
argument_list|(
name|targetSymbol
argument_list|)
decl_stmt|;
name|StringRef
name|targetSymbolName
init|=
name|targetAtom
operator|->
name|name
argument_list|()
decl_stmt|;
if|if
condition|(
name|targetAtom
operator|->
name|definition
argument_list|()
operator|!=
name|Atom
operator|::
name|definitionRegular
condition|)
return|return
name|targetAtom
return|;
if|if
condition|(
operator|(
name|llvm
operator|::
name|dyn_cast
operator|<
name|DefinedAtom
operator|>
operator|(
name|targetAtom
operator|)
operator|)
operator|->
name|scope
argument_list|()
operator|==
name|DefinedAtom
operator|::
name|scopeTranslationUnit
condition|)
return|return
name|targetAtom
return|;
if|if
condition|(
operator|!
name|redirectReferenceUsingUndefAtom
argument_list|(
name|sourceSymbol
argument_list|,
name|targetSymbol
argument_list|)
condition|)
return|return
name|targetAtom
return|;
name|auto
name|undefForGroupchild
init|=
name|_undefAtomsForGroupChild
operator|.
name|find
argument_list|(
name|targetSymbolName
argument_list|)
decl_stmt|;
if|if
condition|(
name|undefForGroupchild
operator|!=
name|_undefAtomsForGroupChild
operator|.
name|end
argument_list|()
condition|)
return|return
name|undefForGroupchild
operator|->
name|getValue
argument_list|()
return|;
name|auto
name|undefGroupChildAtom
init|=
name|new
argument_list|(
argument|_readerStorage
argument_list|)
name|SimpleUndefinedAtom
argument_list|(
operator|*
name|this
argument_list|,
name|targetSymbolName
argument_list|)
decl_stmt|;
name|_undefinedAtoms
operator|.
name|_atoms
operator|.
name|push_back
argument_list|(
name|undefGroupChildAtom
argument_list|)
expr_stmt|;
return|return
operator|(
name|_undefAtomsForGroupChild
index|[
name|targetSymbolName
index|]
operator|=
name|undefGroupChildAtom
operator|)
return|;
block|}
name|protected
label|:
name|ELFDefinedAtom
operator|<
name|ELFT
operator|>
operator|*
name|createDefinedAtomAndAssignRelocations
argument_list|(
argument|StringRef symbolName
argument_list|,
argument|StringRef sectionName
argument_list|,
argument|const Elf_Sym *symbol
argument_list|,
argument|const Elf_Shdr *section
argument_list|,
argument|ArrayRef<uint8_t> symContent
argument_list|,
argument|ArrayRef<uint8_t> secContent
argument_list|)
expr_stmt|;
name|std
operator|::
name|error_code
name|doParse
argument_list|()
name|override
expr_stmt|;
comment|/// \brief Iterate over Elf_Rela relocations list and create references.
name|virtual
name|void
name|createRelocationReferences
argument_list|(
specifier|const
name|Elf_Sym
operator|*
name|symbol
argument_list|,
name|ArrayRef
operator|<
name|uint8_t
operator|>
name|content
argument_list|,
name|range
operator|<
name|Elf_Rela_Iter
operator|>
name|rels
argument_list|)
decl_stmt|;
comment|/// \brief Iterate over Elf_Rel relocations list and create references.
name|virtual
name|void
name|createRelocationReferences
argument_list|(
specifier|const
name|Elf_Sym
operator|*
name|symbol
argument_list|,
name|ArrayRef
operator|<
name|uint8_t
operator|>
name|symContent
argument_list|,
name|ArrayRef
operator|<
name|uint8_t
operator|>
name|secContent
argument_list|,
name|range
operator|<
name|Elf_Rel_Iter
operator|>
name|rels
argument_list|)
decl_stmt|;
comment|/// \brief After all the Atoms and References are created, update each
comment|/// Reference's target with the Atom pointer it refers to.
name|void
name|updateReferences
parameter_list|()
function_decl|;
comment|/// \brief Update the reference if the access corresponds to a merge string
comment|/// section.
name|void
name|updateReferenceForMergeStringAccess
argument_list|(
name|ELFReference
operator|<
name|ELFT
operator|>
operator|*
name|ref
argument_list|,
specifier|const
name|Elf_Sym
operator|*
name|symbol
argument_list|,
specifier|const
name|Elf_Shdr
operator|*
name|shdr
argument_list|)
decl_stmt|;
comment|/// \brief Do we want to ignore the section. Ignored sections are
comment|/// not processed to create atoms
name|bool
name|isIgnoredSection
parameter_list|(
specifier|const
name|Elf_Shdr
modifier|*
name|section
parameter_list|)
function_decl|;
comment|/// \brief Is the current section be treated as a mergeable string section.
comment|/// The contents of a mergeable string section are null-terminated strings.
comment|/// If the section have mergeable strings, the linker would need to split
comment|/// the section into multiple atoms and mark them mergeByContent.
name|bool
name|isMergeableStringSection
parameter_list|(
specifier|const
name|Elf_Shdr
modifier|*
name|section
parameter_list|)
function_decl|;
comment|/// \brief Returns a new anonymous atom whose size is equal to the
comment|/// section size. That atom will be used to represent the entire
comment|/// section that have no symbols.
name|ELFDefinedAtom
operator|<
name|ELFT
operator|>
operator|*
name|createSectionAtom
argument_list|(
argument|const Elf_Shdr *section
argument_list|,
argument|StringRef sectionName
argument_list|,
argument|ArrayRef<uint8_t> contents
argument_list|)
expr_stmt|;
comment|/// Returns the symbol's content size. The nextSymbol should be null if the
comment|/// symbol is the last one in the section.
name|uint64_t
name|symbolContentSize
parameter_list|(
specifier|const
name|Elf_Shdr
modifier|*
name|section
parameter_list|,
specifier|const
name|Elf_Sym
modifier|*
name|symbol
parameter_list|,
specifier|const
name|Elf_Sym
modifier|*
name|nextSymbol
parameter_list|)
function_decl|;
name|void
name|createEdge
argument_list|(
name|ELFDefinedAtom
operator|<
name|ELFT
operator|>
operator|*
name|from
argument_list|,
name|ELFDefinedAtom
operator|<
name|ELFT
operator|>
operator|*
name|to
argument_list|,
name|uint32_t
name|edgeKind
argument_list|)
decl_stmt|;
comment|/// Get the section name for a section.
name|ErrorOr
operator|<
name|StringRef
operator|>
name|getSectionName
argument_list|(
argument|const Elf_Shdr *shdr
argument_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|shdr
condition|)
return|return
name|StringRef
argument_list|()
return|;
return|return
name|_objFile
operator|->
name|getSectionName
argument_list|(
name|shdr
argument_list|)
return|;
block|}
comment|/// Determines if the section occupy memory space.
name|bool
name|sectionOccupiesMemorySpace
argument_list|(
specifier|const
name|Elf_Shdr
operator|*
name|shdr
argument_list|)
decl|const
block|{
return|return
operator|(
name|shdr
operator|->
name|sh_type
operator|!=
name|llvm
operator|::
name|ELF
operator|::
name|SHT_NOBITS
operator|)
return|;
block|}
comment|/// Return the section contents.
name|ErrorOr
operator|<
name|ArrayRef
operator|<
name|uint8_t
operator|>>
name|getSectionContents
argument_list|(
argument|const Elf_Shdr *shdr
argument_list|)
specifier|const
block|{
if|if
condition|(
operator|!
name|shdr
operator|||
operator|!
name|sectionOccupiesMemorySpace
argument_list|(
name|shdr
argument_list|)
condition|)
return|return
name|ArrayRef
operator|<
name|uint8_t
operator|>
operator|(
operator|)
return|;
return|return
name|_objFile
operator|->
name|getSectionContents
argument_list|(
name|shdr
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/// Returns true if the symbol is a undefined symbol.
end_comment

begin_decl_stmt
name|bool
name|isUndefinedSymbol
argument_list|(
specifier|const
name|Elf_Sym
operator|*
name|sym
argument_list|)
decl|const
block|{
return|return
operator|(
name|sym
operator|->
name|st_shndx
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|SHN_UNDEF
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/// Determines if the target wants to create an atom for a section that has no
end_comment

begin_comment
comment|/// symbol references.
end_comment

begin_decl_stmt
name|bool
name|handleSectionWithNoSymbols
argument_list|(
specifier|const
name|Elf_Shdr
operator|*
name|shdr
argument_list|,
name|std
operator|::
name|vector
operator|<
name|Elf_Sym_Iter
operator|>
operator|&
name|syms
argument_list|)
decl|const
block|{
return|return
name|shdr
operator|&&
operator|(
name|shdr
operator|->
name|sh_type
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|SHT_PROGBITS
operator|)
operator|&&
name|syms
operator|.
name|empty
argument_list|()
return|;
block|}
end_decl_stmt

begin_comment
comment|/// Handle creation of atoms for .gnu.linkonce sections.
end_comment

begin_expr_stmt
name|std
operator|::
name|error_code
name|handleGnuLinkOnceSection
argument_list|(
argument|StringRef sectionName
argument_list|,
argument|llvm::StringMap<std::vector<ELFDefinedAtom<ELFT> *>>&atomsForSection
argument_list|,
argument|const Elf_Shdr *shdr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Handle Section groups/COMDAT scetions.
end_comment

begin_expr_stmt
name|std
operator|::
name|error_code
name|handleSectionGroup
argument_list|(
argument|StringRef signature
argument_list|,
argument|StringRef groupSectionName
argument_list|,
argument|llvm::StringMap<std::vector<ELFDefinedAtom<ELFT> *>>&atomsForSection
argument_list|,
argument|llvm::DenseMap<const Elf_Shdr *
argument_list|,
argument|std::vector<StringRef>>&comdatSections
argument_list|,
argument|const Elf_Shdr *shdr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// Process the Undefined symbol and create an atom for it.
end_comment

begin_expr_stmt
name|ErrorOr
operator|<
name|ELFUndefinedAtom
operator|<
name|ELFT
operator|>
operator|*
operator|>
name|handleUndefinedSymbol
argument_list|(
argument|StringRef symName
argument_list|,
argument|const Elf_Sym *sym
argument_list|)
block|{
return|return
name|new
argument_list|(
argument|_readerStorage
argument_list|)
name|ELFUndefinedAtom
operator|<
name|ELFT
operator|>
operator|(
operator|*
name|this
operator|,
name|symName
operator|,
name|sym
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Returns true if the symbol is a absolute symbol.
end_comment

begin_decl_stmt
name|bool
name|isAbsoluteSymbol
argument_list|(
specifier|const
name|Elf_Sym
operator|*
name|sym
argument_list|)
decl|const
block|{
return|return
operator|(
name|sym
operator|->
name|st_shndx
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|SHN_ABS
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/// Process the Absolute symbol and create an atom for it.
end_comment

begin_expr_stmt
name|ErrorOr
operator|<
name|ELFAbsoluteAtom
operator|<
name|ELFT
operator|>
operator|*
operator|>
name|handleAbsoluteSymbol
argument_list|(
argument|StringRef symName
argument_list|,
argument|const Elf_Sym *sym
argument_list|,
argument|int64_t value
argument_list|)
block|{
return|return
name|new
argument_list|(
argument|_readerStorage
argument_list|)
name|ELFAbsoluteAtom
operator|<
name|ELFT
operator|>
operator|(
operator|*
name|this
operator|,
name|symName
operator|,
name|sym
operator|,
name|value
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Returns true if the symbol is common symbol. A common symbol represents a
end_comment

begin_comment
comment|/// tentive definition in C. It has name, size and alignment constraint, but
end_comment

begin_comment
comment|/// actual storage has not yet been allocated. (The linker will allocate
end_comment

begin_comment
comment|/// storage for them in the later pass after coalescing tentative symbols by
end_comment

begin_comment
comment|/// name.)
end_comment

begin_decl_stmt
name|virtual
name|bool
name|isCommonSymbol
argument_list|(
specifier|const
name|Elf_Sym
operator|*
name|symbol
argument_list|)
decl|const
block|{
return|return
name|symbol
operator|->
name|getType
argument_list|()
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|STT_COMMON
operator|||
name|symbol
operator|->
name|st_shndx
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|SHN_COMMON
return|;
block|}
end_decl_stmt

begin_comment
comment|/// Returns true if the section is a gnulinkonce section.
end_comment

begin_decl_stmt
name|bool
name|isGnuLinkOnceSection
argument_list|(
name|StringRef
name|sectionName
argument_list|)
decl|const
block|{
return|return
name|sectionName
operator|.
name|startswith
argument_list|(
literal|".gnu.linkonce."
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/// Returns true if the section is a COMDAT group section.
end_comment

begin_decl_stmt
name|bool
name|isGroupSection
argument_list|(
specifier|const
name|Elf_Shdr
operator|*
name|shdr
argument_list|)
decl|const
block|{
return|return
operator|(
name|shdr
operator|->
name|sh_type
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|SHT_GROUP
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/// Returns true if the section is a member of some group.
end_comment

begin_decl_stmt
name|bool
name|isSectionMemberOfGroup
argument_list|(
specifier|const
name|Elf_Shdr
operator|*
name|shdr
argument_list|)
decl|const
block|{
return|return
operator|(
name|shdr
operator|->
name|sh_flags
operator|&
name|llvm
operator|::
name|ELF
operator|::
name|SHF_GROUP
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/// Returns correct st_value for the symbol depending on the architecture.
end_comment

begin_comment
comment|/// For most architectures it's just a regular st_value with no changes.
end_comment

begin_decl_stmt
name|virtual
name|uint64_t
name|getSymbolValue
argument_list|(
specifier|const
name|Elf_Sym
operator|*
name|symbol
argument_list|)
decl|const
block|{
return|return
name|symbol
operator|->
name|st_value
return|;
block|}
end_decl_stmt

begin_comment
comment|/// Process the common symbol and create an atom for it.
end_comment

begin_expr_stmt
name|virtual
name|ErrorOr
operator|<
name|ELFCommonAtom
operator|<
name|ELFT
operator|>
operator|*
operator|>
name|handleCommonSymbol
argument_list|(
argument|StringRef symName
argument_list|,
argument|const Elf_Sym *sym
argument_list|)
block|{
return|return
name|new
argument_list|(
argument|_readerStorage
argument_list|)
name|ELFCommonAtom
operator|<
name|ELFT
operator|>
operator|(
operator|*
name|this
operator|,
name|symName
operator|,
name|sym
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Returns true if the symbol is a defined symbol.
end_comment

begin_decl_stmt
name|virtual
name|bool
name|isDefinedSymbol
argument_list|(
specifier|const
name|Elf_Sym
operator|*
name|sym
argument_list|)
decl|const
block|{
return|return
operator|(
name|sym
operator|->
name|getType
argument_list|()
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|STT_NOTYPE
operator|||
name|sym
operator|->
name|getType
argument_list|()
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|STT_OBJECT
operator|||
name|sym
operator|->
name|getType
argument_list|()
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|STT_FUNC
operator|||
name|sym
operator|->
name|getType
argument_list|()
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|STT_GNU_IFUNC
operator|||
name|sym
operator|->
name|getType
argument_list|()
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|STT_SECTION
operator|||
name|sym
operator|->
name|getType
argument_list|()
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|STT_FILE
operator|||
name|sym
operator|->
name|getType
argument_list|()
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|STT_TLS
operator|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/// Process the Defined symbol and create an atom for it.
end_comment

begin_expr_stmt
name|virtual
name|ErrorOr
operator|<
name|ELFDefinedAtom
operator|<
name|ELFT
operator|>
operator|*
operator|>
name|handleDefinedSymbol
argument_list|(
argument|StringRef symName
argument_list|,
argument|StringRef sectionName
argument_list|,
argument|const Elf_Sym *sym
argument_list|,
argument|const Elf_Shdr *sectionHdr
argument_list|,
argument|ArrayRef<uint8_t> contentData
argument_list|,
argument|unsigned int referenceStart
argument_list|,
argument|unsigned int referenceEnd
argument_list|,
argument|std::vector<ELFReference<ELFT> *>&referenceList
argument_list|)
block|{
return|return
name|new
argument_list|(
argument|_readerStorage
argument_list|)
name|ELFDefinedAtom
operator|<
name|ELFT
operator|>
operator|(
operator|*
name|this
operator|,
name|symName
operator|,
name|sectionName
operator|,
name|sym
operator|,
name|sectionHdr
operator|,
name|contentData
operator|,
name|referenceStart
operator|,
name|referenceEnd
operator|,
name|referenceList
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Process the Merge string and create an atom for it.
end_comment

begin_expr_stmt
name|ErrorOr
operator|<
name|ELFMergeAtom
operator|<
name|ELFT
operator|>
operator|*
operator|>
name|handleMergeString
argument_list|(
argument|StringRef sectionName
argument_list|,
argument|const Elf_Shdr *sectionHdr
argument_list|,
argument|ArrayRef<uint8_t> contentData
argument_list|,
argument|unsigned int offset
argument_list|)
block|{
name|ELFMergeAtom
operator|<
name|ELFT
operator|>
operator|*
name|mergeAtom
operator|=
name|new
argument_list|(
argument|_readerStorage
argument_list|)
name|ELFMergeAtom
operator|<
name|ELFT
operator|>
operator|(
operator|*
name|this
operator|,
name|sectionName
operator|,
name|sectionHdr
operator|,
name|contentData
operator|,
name|offset
operator|)
block|;
specifier|const
name|MergeSectionKey
name|mergedSectionKey
argument_list|(
name|sectionHdr
argument_list|,
name|offset
argument_list|)
block|;
if|if
condition|(
name|_mergedSectionMap
operator|.
name|find
argument_list|(
name|mergedSectionKey
argument_list|)
operator|==
name|_mergedSectionMap
operator|.
name|end
argument_list|()
condition|)
name|_mergedSectionMap
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|mergedSectionKey
argument_list|,
name|mergeAtom
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|mergeAtom
return|;
end_return

begin_comment
unit|}
comment|/// References to the sections comprising a group, from sections
end_comment

begin_comment
comment|/// outside the group, must be made via global UNDEF symbols,
end_comment

begin_comment
comment|/// referencing global symbols defined as addresses in the group
end_comment

begin_comment
comment|/// sections. They may not reference local symbols for addresses in
end_comment

begin_comment
comment|/// the group's sections, including section symbols.
end_comment

begin_comment
comment|/// ABI Doc : https://mentorembedded.github.io/cxx-abi/abi/prop-72-comdat.html
end_comment

begin_comment
comment|/// Does the atom need to be redirected using a separate undefined atom?
end_comment

begin_macro
unit|bool
name|redirectReferenceUsingUndefAtom
argument_list|(
argument|const Elf_Sym *sourceSymbol
argument_list|,
argument|const Elf_Sym *targetSymbol
argument_list|)
end_macro

begin_decl_stmt
specifier|const
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|addReferenceToSymbol
argument_list|(
specifier|const
name|ELFReference
operator|<
name|ELFT
operator|>
operator|*
name|r
argument_list|,
specifier|const
name|Elf_Sym
operator|*
name|sym
argument_list|)
block|{
name|_referenceToSymbol
index|[
name|r
index|]
operator|=
name|sym
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
specifier|const
name|Elf_Sym
modifier|*
name|findSymbolForReference
argument_list|(
specifier|const
name|ELFReference
operator|<
name|ELFT
operator|>
operator|*
name|r
argument_list|)
decl|const
block|{
name|auto
name|elfReferenceToSymbol
init|=
name|_referenceToSymbol
operator|.
name|find
argument_list|(
name|r
argument_list|)
decl_stmt|;
if|if
condition|(
name|elfReferenceToSymbol
operator|!=
name|_referenceToSymbol
operator|.
name|end
argument_list|()
condition|)
return|return
name|elfReferenceToSymbol
operator|->
name|second
return|;
return|return
name|nullptr
return|;
block|}
end_decl_stmt

begin_expr_stmt
name|llvm
operator|::
name|BumpPtrAllocator
name|_readerStorage
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|unique_ptr
operator|<
name|llvm
operator|::
name|object
operator|::
name|ELFFile
operator|<
name|ELFT
operator|>
expr|>
name|_objFile
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|atom_collection_vector
operator|<
name|DefinedAtom
operator|>
name|_definedAtoms
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|atom_collection_vector
operator|<
name|UndefinedAtom
operator|>
name|_undefinedAtoms
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|atom_collection_vector
operator|<
name|SharedLibraryAtom
operator|>
name|_sharedLibraryAtoms
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|atom_collection_vector
operator|<
name|AbsoluteAtom
operator|>
name|_absoluteAtoms
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// \brief _relocationAddendReferences and _relocationReferences contain the
end_comment

begin_comment
comment|/// list of relocations references.  In ELF, if a section named, ".text" has
end_comment

begin_comment
comment|/// relocations will also have a section named ".rel.text" or ".rela.text"
end_comment

begin_comment
comment|/// which will hold the entries.
end_comment

begin_expr_stmt
name|std
operator|::
name|unordered_map
operator|<
name|StringRef
operator|,
name|range
operator|<
name|Elf_Rela_Iter
operator|>>
name|_relocationAddendReferences
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|MergedSectionMapT
name|_mergedSectionMap
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|std
operator|::
name|unordered_map
operator|<
name|StringRef
operator|,
name|range
operator|<
name|Elf_Rel_Iter
operator|>>
name|_relocationReferences
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|vector
operator|<
name|ELFReference
operator|<
name|ELFT
operator|>
operator|*
operator|>
name|_references
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|llvm
operator|::
name|DenseMap
operator|<
specifier|const
name|Elf_Sym
operator|*
operator|,
name|Atom
operator|*
operator|>
name|_symbolToAtomMapping
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|llvm
operator|::
name|DenseMap
operator|<
specifier|const
name|ELFReference
operator|<
name|ELFT
operator|>
operator|*
operator|,
specifier|const
name|Elf_Sym
operator|*
operator|>
name|_referenceToSymbol
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Group child atoms have a pair corresponding to the signature and the
end_comment

begin_comment
comment|// section header of the section that was used for generating the signature.
end_comment

begin_expr_stmt
name|llvm
operator|::
name|DenseMap
operator|<
specifier|const
name|Elf_Sym
operator|*
operator|,
name|std
operator|::
name|pair
operator|<
name|StringRef
operator|,
specifier|const
name|Elf_Shdr
operator|*
operator|>>
name|_groupChild
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|llvm
operator|::
name|StringMap
operator|<
name|Atom
operator|*
operator|>
name|_undefAtomsForGroupChild
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// \brief Atoms that are created for a section that has the merge property
end_comment

begin_comment
comment|/// set
end_comment

begin_decl_stmt
name|MergeAtomsT
name|_mergeAtoms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// \brief the section and the symbols that are contained within it to create
end_comment

begin_comment
comment|/// used to create atoms
end_comment

begin_expr_stmt
name|llvm
operator|::
name|MapVector
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|,
name|std
operator|::
name|vector
operator|<
name|Elf_Sym_Iter
operator|>>
name|_sectionSymbols
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// \brief Sections that have merge string property
end_comment

begin_expr_stmt
name|std
operator|::
name|vector
operator|<
specifier|const
name|Elf_Shdr
operator|*
operator|>
name|_mergeStringSections
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|unique_ptr
operator|<
name|MemoryBuffer
operator|>
name|_mb
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int64_t
name|_ordinal
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// \brief the cached options relevant while reading the ELF File
end_comment

begin_decl_stmt
name|bool
name|_doStringsMerge
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// \brief Is --wrap on?
end_comment

begin_decl_stmt
name|bool
name|_useWrap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/// \brief The LinkingContext.
end_comment

begin_decl_stmt
name|ELFLinkingContext
modifier|&
name|_ctx
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Wrap map
end_comment

begin_expr_stmt
name|llvm
operator|::
name|StringMap
operator|<
name|UndefinedAtom
operator|*
operator|>
name|_wrapSymbolMap
expr_stmt|;
end_expr_stmt

begin_comment
unit|};
comment|/// \brief All atoms are owned by a File. To add linker specific atoms
end_comment

begin_comment
comment|/// the atoms need to be inserted to a file called (RuntimeFile) which
end_comment

begin_comment
comment|/// are basically additional symbols required by libc and other runtime
end_comment

begin_comment
comment|/// libraries part of executing a program. This class provides support
end_comment

begin_comment
comment|/// for adding absolute symbols and undefined symbols
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|RuntimeFile
operator|:
name|public
name|ELFFile
operator|<
name|ELFT
operator|>
block|{
name|public
operator|:
typedef|typedef
name|llvm
operator|::
name|object
operator|::
name|Elf_Sym_Impl
operator|<
name|ELFT
operator|>
name|Elf_Sym
expr_stmt|;
name|RuntimeFile
argument_list|(
argument|ELFLinkingContext&context
argument_list|,
argument|StringRef name
argument_list|)
operator|:
name|ELFFile
operator|<
name|ELFT
operator|>
operator|(
name|name
operator|,
name|context
operator|)
block|{}
comment|/// \brief add a global absolute atom
name|virtual
name|Atom
operator|*
name|addAbsoluteAtom
argument_list|(
argument|StringRef symbolName
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|symbolName
operator|.
name|empty
argument_list|()
operator|&&
literal|"AbsoluteAtoms must have a name"
argument_list|)
block|;
name|Elf_Sym
operator|*
name|symbol
operator|=
name|new
argument_list|(
argument|this->_readerStorage
argument_list|)
name|Elf_Sym
block|;
name|symbol
operator|->
name|st_name
operator|=
literal|0
block|;
name|symbol
operator|->
name|st_value
operator|=
literal|0
block|;
name|symbol
operator|->
name|st_shndx
operator|=
name|llvm
operator|::
name|ELF
operator|::
name|SHN_ABS
block|;
name|symbol
operator|->
name|setBindingAndType
argument_list|(
name|llvm
operator|::
name|ELF
operator|::
name|STB_GLOBAL
argument_list|,
name|llvm
operator|::
name|ELF
operator|::
name|STT_OBJECT
argument_list|)
block|;
name|symbol
operator|->
name|setVisibility
argument_list|(
name|llvm
operator|::
name|ELF
operator|::
name|STV_DEFAULT
argument_list|)
block|;
name|symbol
operator|->
name|st_size
operator|=
literal|0
block|;
name|auto
name|newAtom
operator|=
name|this
operator|->
name|handleAbsoluteSymbol
argument_list|(
name|symbolName
argument_list|,
name|symbol
argument_list|,
operator|-
literal|1
argument_list|)
block|;
name|this
operator|->
name|_absoluteAtoms
operator|.
name|_atoms
operator|.
name|push_back
argument_list|(
operator|*
name|newAtom
argument_list|)
block|;
return|return
operator|*
name|newAtom
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief add an undefined atom
end_comment

begin_function
name|virtual
name|Atom
modifier|*
name|addUndefinedAtom
parameter_list|(
name|StringRef
name|symbolName
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|symbolName
operator|.
name|empty
argument_list|()
operator|&&
literal|"UndefinedAtoms must have a name"
argument_list|)
expr_stmt|;
name|Elf_Sym
modifier|*
name|symbol
init|=
name|new
argument_list|(
argument|this->_readerStorage
argument_list|)
name|Elf_Sym
decl_stmt|;
name|symbol
operator|->
name|st_name
operator|=
literal|0
expr_stmt|;
name|symbol
operator|->
name|st_value
operator|=
literal|0
expr_stmt|;
name|symbol
operator|->
name|st_shndx
operator|=
name|llvm
operator|::
name|ELF
operator|::
name|SHN_UNDEF
expr_stmt|;
name|symbol
operator|->
name|setBindingAndType
argument_list|(
name|llvm
operator|::
name|ELF
operator|::
name|STB_GLOBAL
argument_list|,
name|llvm
operator|::
name|ELF
operator|::
name|STT_NOTYPE
argument_list|)
expr_stmt|;
name|symbol
operator|->
name|setVisibility
argument_list|(
name|llvm
operator|::
name|ELF
operator|::
name|STV_DEFAULT
argument_list|)
expr_stmt|;
name|symbol
operator|->
name|st_size
operator|=
literal|0
expr_stmt|;
name|auto
name|newAtom
init|=
name|this
operator|->
name|handleUndefinedSymbol
argument_list|(
name|symbolName
argument_list|,
name|symbol
argument_list|)
decl_stmt|;
name|this
operator|->
name|_undefinedAtoms
operator|.
name|_atoms
operator|.
name|push_back
argument_list|(
operator|*
name|newAtom
argument_list|)
expr_stmt|;
return|return
operator|*
name|newAtom
return|;
block|}
end_function

begin_comment
comment|// cannot add atoms to Runtime file
end_comment

begin_function
name|virtual
name|void
name|addAtom
parameter_list|(
specifier|const
name|Atom
modifier|&
parameter_list|)
block|{
name|llvm_unreachable
argument_list|(
literal|"cannot add atoms to Runtime files"
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|ELFT
operator|>
name|ErrorOr
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|ELFFile
operator|<
name|ELFT
operator|>>>
name|ELFFile
operator|<
name|ELFT
operator|>
operator|::
name|create
argument_list|(
argument|std::unique_ptr<MemoryBuffer> mb
argument_list|,
argument|ELFLinkingContext&ctx
argument_list|)
block|{
name|std
operator|::
name|unique_ptr
operator|<
name|ELFFile
operator|<
name|ELFT
operator|>>
name|file
argument_list|(
argument|new ELFFile<ELFT>(std::move(mb), ctx)
argument_list|)
block|;
return|return
name|std
operator|::
name|move
argument_list|(
name|file
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|std
operator|::
name|error_code
name|ELFFile
operator|<
name|ELFT
operator|>
operator|::
name|doParse
argument_list|()
block|{
name|std
operator|::
name|error_code
name|ec
block|;
name|_objFile
operator|.
name|reset
argument_list|(
argument|new llvm::object::ELFFile<ELFT>(_mb->getBuffer(), ec)
argument_list|)
block|;
if|if
condition|(
name|ec
condition|)
return|return
name|ec
return|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|ec
operator|=
name|createAtomsFromContext
argument_list|()
operator|)
condition|)
return|return
name|ec
return|;
end_if

begin_comment
comment|// Read input sections from the input file that need to be converted to
end_comment

begin_comment
comment|// atoms
end_comment

begin_if
if|if
condition|(
operator|(
name|ec
operator|=
name|createAtomizableSections
argument_list|()
operator|)
condition|)
return|return
name|ec
return|;
end_if

begin_comment
comment|// For mergeable strings, we would need to split the section into various
end_comment

begin_comment
comment|// atoms
end_comment

begin_if
if|if
condition|(
operator|(
name|ec
operator|=
name|createMergeableAtoms
argument_list|()
operator|)
condition|)
return|return
name|ec
return|;
end_if

begin_comment
comment|// Create the necessary symbols that are part of the section that we
end_comment

begin_comment
comment|// created in createAtomizableSections function
end_comment

begin_if
if|if
condition|(
operator|(
name|ec
operator|=
name|createSymbolsFromAtomizableSections
argument_list|()
operator|)
condition|)
return|return
name|ec
return|;
end_if

begin_comment
comment|// Create the appropriate atoms from the file
end_comment

begin_if
if|if
condition|(
operator|(
name|ec
operator|=
name|createAtoms
argument_list|()
operator|)
condition|)
return|return
name|ec
return|;
end_if

begin_return
return|return
name|std
operator|::
name|error_code
argument_list|()
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|Reference
operator|::
name|KindArch
name|ELFFile
operator|<
name|ELFT
operator|>
operator|::
name|kindArch
argument_list|()
block|{
switch|switch
condition|(
name|_objFile
operator|->
name|getHeader
argument_list|()
operator|->
name|e_machine
condition|)
block|{
case|case
name|llvm
operator|::
name|ELF
operator|::
name|EM_X86_64
case|:
return|return
name|Reference
operator|::
name|KindArch
operator|::
name|x86_64
return|;
case|case
name|llvm
operator|::
name|ELF
operator|::
name|EM_386
case|:
return|return
name|Reference
operator|::
name|KindArch
operator|::
name|x86
return|;
case|case
name|llvm
operator|::
name|ELF
operator|::
name|EM_ARM
case|:
return|return
name|Reference
operator|::
name|KindArch
operator|::
name|ARM
return|;
case|case
name|llvm
operator|::
name|ELF
operator|::
name|EM_HEXAGON
case|:
return|return
name|Reference
operator|::
name|KindArch
operator|::
name|Hexagon
return|;
case|case
name|llvm
operator|::
name|ELF
operator|::
name|EM_MIPS
case|:
return|return
name|Reference
operator|::
name|KindArch
operator|::
name|Mips
return|;
case|case
name|llvm
operator|::
name|ELF
operator|::
name|EM_AARCH64
case|:
return|return
name|Reference
operator|::
name|KindArch
operator|::
name|AArch64
return|;
block|}
name|llvm_unreachable
argument_list|(
literal|"unsupported e_machine value"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|std
operator|::
name|error_code
name|ELFFile
operator|<
name|ELFT
operator|>
operator|::
name|createAtomizableSections
argument_list|()
block|{
comment|// Handle: SHT_REL and SHT_RELA sections:
comment|// Increment over the sections, when REL/RELA section types are found add
comment|// the contents to the RelocationReferences map.
comment|// Record the number of relocs to guess at preallocating the buffer.
name|uint64_t
name|totalRelocs
operator|=
literal|0
block|;
for|for
control|(
specifier|const
name|Elf_Shdr
modifier|&
name|section
range|:
name|_objFile
operator|->
name|sections
argument_list|()
control|)
block|{
if|if
condition|(
name|isIgnoredSection
argument_list|(
operator|&
name|section
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|isMergeableStringSection
argument_list|(
operator|&
name|section
argument_list|)
condition|)
block|{
name|_mergeStringSections
operator|.
name|push_back
argument_list|(
operator|&
name|section
argument_list|)
expr_stmt|;
continue|continue;
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|section
operator|.
name|sh_type
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|SHT_RELA
condition|)
block|{
name|auto
name|sHdr
init|=
name|_objFile
operator|->
name|getSection
argument_list|(
name|section
operator|.
name|sh_info
argument_list|)
decl_stmt|;
name|auto
name|sectionName
init|=
name|_objFile
operator|->
name|getSectionName
argument_list|(
name|sHdr
argument_list|)
decl_stmt|;
if|if
condition|(
name|std
operator|::
name|error_code
name|ec
operator|=
name|sectionName
operator|.
name|getError
argument_list|()
condition|)
return|return
name|ec
return|;
name|auto
name|rai
argument_list|(
name|_objFile
operator|->
name|begin_rela
argument_list|(
operator|&
name|section
argument_list|)
argument_list|)
decl_stmt|;
name|auto
name|rae
argument_list|(
name|_objFile
operator|->
name|end_rela
argument_list|(
operator|&
name|section
argument_list|)
argument_list|)
decl_stmt|;
name|_relocationAddendReferences
index|[
operator|*
name|sectionName
index|]
operator|=
name|make_range
argument_list|(
name|rai
argument_list|,
name|rae
argument_list|)
expr_stmt|;
name|totalRelocs
operator|+=
name|std
operator|::
name|distance
argument_list|(
name|rai
argument_list|,
name|rae
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|section
operator|.
name|sh_type
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|SHT_REL
condition|)
block|{
name|auto
name|sHdr
init|=
name|_objFile
operator|->
name|getSection
argument_list|(
name|section
operator|.
name|sh_info
argument_list|)
decl_stmt|;
name|auto
name|sectionName
init|=
name|_objFile
operator|->
name|getSectionName
argument_list|(
name|sHdr
argument_list|)
decl_stmt|;
if|if
condition|(
name|std
operator|::
name|error_code
name|ec
operator|=
name|sectionName
operator|.
name|getError
argument_list|()
condition|)
return|return
name|ec
return|;
name|auto
name|ri
argument_list|(
name|_objFile
operator|->
name|begin_rel
argument_list|(
operator|&
name|section
argument_list|)
argument_list|)
decl_stmt|;
name|auto
name|re
argument_list|(
name|_objFile
operator|->
name|end_rel
argument_list|(
operator|&
name|section
argument_list|)
argument_list|)
decl_stmt|;
name|_relocationReferences
index|[
operator|*
name|sectionName
index|]
operator|=
name|make_range
argument_list|(
name|ri
argument_list|,
name|re
argument_list|)
expr_stmt|;
name|totalRelocs
operator|+=
name|std
operator|::
name|distance
argument_list|(
name|ri
argument_list|,
name|re
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|_sectionSymbols
index|[
operator|&
name|section
index|]
expr_stmt|;
block|}
end_if

begin_expr_stmt
unit|}   _references
operator|.
name|reserve
argument_list|(
name|totalRelocs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|std
operator|::
name|error_code
argument_list|()
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|std
operator|::
name|error_code
name|ELFFile
operator|<
name|ELFT
operator|>
operator|::
name|createMergeableAtoms
argument_list|()
block|{
comment|// Divide the section that contains mergeable strings into tokens
comment|// TODO
comment|// a) add resolver support to recognize multibyte chars
comment|// b) Create a separate section chunk to write mergeable atoms
name|std
operator|::
name|vector
operator|<
name|MergeString
operator|*
operator|>
name|tokens
block|;
for|for
control|(
specifier|const
name|Elf_Shdr
modifier|*
name|msi
range|:
name|_mergeStringSections
control|)
block|{
name|auto
name|sectionName
init|=
name|getSectionName
argument_list|(
name|msi
argument_list|)
decl_stmt|;
if|if
condition|(
name|std
operator|::
name|error_code
name|ec
operator|=
name|sectionName
operator|.
name|getError
argument_list|()
condition|)
return|return
name|ec
return|;
name|auto
name|sectionContents
init|=
name|getSectionContents
argument_list|(
name|msi
argument_list|)
decl_stmt|;
if|if
condition|(
name|std
operator|::
name|error_code
name|ec
operator|=
name|sectionContents
operator|.
name|getError
argument_list|()
condition|)
return|return
name|ec
return|;
name|StringRef
name|secCont
argument_list|(
name|reinterpret_cast
operator|<
specifier|const
name|char
operator|*
operator|>
operator|(
name|sectionContents
operator|->
name|begin
argument_list|()
operator|)
argument_list|,
name|sectionContents
operator|->
name|size
argument_list|()
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|prev
init|=
literal|0
decl_stmt|;
for|for
control|(
name|std
operator|::
name|size_t
name|i
operator|=
literal|0
operator|,
name|e
operator|=
name|sectionContents
operator|->
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|sectionContents
operator|)
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
block|{
name|tokens
operator|.
name|push_back
argument_list|(
name|new
argument_list|(
argument|_readerStorage
argument_list|)
name|MergeString
argument_list|(
name|prev
argument_list|,
name|secCont
operator|.
name|slice
argument_list|(
name|prev
argument_list|,
name|i
operator|+
literal|1
argument_list|)
argument_list|,
name|msi
argument_list|,
operator|*
name|sectionName
argument_list|)
argument_list|)
expr_stmt|;
name|prev
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
end_expr_stmt

begin_comment
unit|}   }
comment|// Create Mergeable atoms
end_comment

begin_for
for|for
control|(
specifier|const
name|MergeString
modifier|*
name|tai
range|:
name|tokens
control|)
block|{
name|ArrayRef
operator|<
name|uint8_t
operator|>
name|content
argument_list|(
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|tai
operator|->
name|_string
operator|.
name|data
argument_list|()
argument_list|,
name|tai
operator|->
name|_string
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
name|ErrorOr
operator|<
name|ELFMergeAtom
operator|<
name|ELFT
operator|>
operator|*
operator|>
name|mergeAtom
operator|=
name|handleMergeString
argument_list|(
name|tai
operator|->
name|_sectionName
argument_list|,
name|tai
operator|->
name|_shdr
argument_list|,
name|content
argument_list|,
name|tai
operator|->
name|_offset
argument_list|)
expr_stmt|;
operator|(
operator|*
name|mergeAtom
operator|)
operator|->
name|setOrdinal
argument_list|(
operator|++
name|_ordinal
argument_list|)
expr_stmt|;
name|_definedAtoms
operator|.
name|_atoms
operator|.
name|push_back
argument_list|(
operator|*
name|mergeAtom
argument_list|)
expr_stmt|;
name|_mergeAtoms
operator|.
name|push_back
argument_list|(
operator|*
name|mergeAtom
argument_list|)
expr_stmt|;
block|}
end_for

begin_return
return|return
name|std
operator|::
name|error_code
argument_list|()
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|std
operator|::
name|error_code
name|ELFFile
operator|<
name|ELFT
operator|>
operator|::
name|createSymbolsFromAtomizableSections
argument_list|()
block|{
comment|// Increment over all the symbols collecting atoms and symbol names for
comment|// later use.
name|auto
name|SymI
operator|=
name|_objFile
operator|->
name|begin_symbols
argument_list|()
block|,
name|SymE
operator|=
name|_objFile
operator|->
name|end_symbols
argument_list|()
block|;
comment|// Skip over dummy sym.
if|if
condition|(
name|SymI
operator|!=
name|SymE
condition|)
operator|++
name|SymI
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
init|;
name|SymI
operator|!=
name|SymE
condition|;
operator|++
name|SymI
control|)
block|{
specifier|const
name|Elf_Shdr
modifier|*
name|section
init|=
name|_objFile
operator|->
name|getSection
argument_list|(
operator|&
operator|*
name|SymI
argument_list|)
decl_stmt|;
name|auto
name|symbolName
init|=
name|_objFile
operator|->
name|getSymbolName
argument_list|(
name|SymI
argument_list|)
decl_stmt|;
if|if
condition|(
name|std
operator|::
name|error_code
name|ec
operator|=
name|symbolName
operator|.
name|getError
argument_list|()
condition|)
return|return
name|ec
return|;
if|if
condition|(
name|isAbsoluteSymbol
argument_list|(
operator|&
operator|*
name|SymI
argument_list|)
condition|)
block|{
name|ErrorOr
operator|<
name|ELFAbsoluteAtom
operator|<
name|ELFT
operator|>
operator|*
operator|>
name|absAtom
operator|=
name|handleAbsoluteSymbol
argument_list|(
operator|*
name|symbolName
argument_list|,
operator|&
operator|*
name|SymI
argument_list|,
operator|(
name|int64_t
operator|)
name|getSymbolValue
argument_list|(
operator|&
operator|*
name|SymI
argument_list|)
argument_list|)
expr_stmt|;
name|_absoluteAtoms
operator|.
name|_atoms
operator|.
name|push_back
argument_list|(
operator|*
name|absAtom
argument_list|)
expr_stmt|;
name|_symbolToAtomMapping
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
operator|&
operator|*
name|SymI
argument_list|,
operator|*
name|absAtom
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isUndefinedSymbol
argument_list|(
operator|&
operator|*
name|SymI
argument_list|)
condition|)
block|{
if|if
condition|(
name|_useWrap
operator|&&
operator|(
name|_wrapSymbolMap
operator|.
name|find
argument_list|(
operator|*
name|symbolName
argument_list|)
operator|!=
name|_wrapSymbolMap
operator|.
name|end
argument_list|()
operator|)
condition|)
block|{
name|auto
name|wrapAtom
init|=
name|_wrapSymbolMap
operator|.
name|find
argument_list|(
operator|*
name|symbolName
argument_list|)
decl_stmt|;
name|_symbolToAtomMapping
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
operator|&
operator|*
name|SymI
argument_list|,
name|wrapAtom
operator|->
name|getValue
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|ErrorOr
operator|<
name|ELFUndefinedAtom
operator|<
name|ELFT
operator|>
operator|*
operator|>
name|undefAtom
operator|=
name|handleUndefinedSymbol
argument_list|(
operator|*
name|symbolName
argument_list|,
operator|&
operator|*
name|SymI
argument_list|)
expr_stmt|;
name|_undefinedAtoms
operator|.
name|_atoms
operator|.
name|push_back
argument_list|(
operator|*
name|undefAtom
argument_list|)
expr_stmt|;
name|_symbolToAtomMapping
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
operator|&
operator|*
name|SymI
argument_list|,
operator|*
name|undefAtom
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isCommonSymbol
argument_list|(
operator|&
operator|*
name|SymI
argument_list|)
condition|)
block|{
name|ErrorOr
operator|<
name|ELFCommonAtom
operator|<
name|ELFT
operator|>
operator|*
operator|>
name|commonAtom
operator|=
name|handleCommonSymbol
argument_list|(
operator|*
name|symbolName
argument_list|,
operator|&
operator|*
name|SymI
argument_list|)
expr_stmt|;
operator|(
operator|*
name|commonAtom
operator|)
operator|->
name|setOrdinal
argument_list|(
operator|++
name|_ordinal
argument_list|)
expr_stmt|;
name|_definedAtoms
operator|.
name|_atoms
operator|.
name|push_back
argument_list|(
operator|*
name|commonAtom
argument_list|)
expr_stmt|;
name|_symbolToAtomMapping
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
operator|&
operator|*
name|SymI
argument_list|,
operator|*
name|commonAtom
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isDefinedSymbol
argument_list|(
operator|&
operator|*
name|SymI
argument_list|)
condition|)
block|{
name|_sectionSymbols
index|[
name|section
index|]
operator|.
name|push_back
argument_list|(
name|SymI
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|llvm
operator|::
name|errs
argument_list|()
operator|<<
literal|"Unable to create atom for: "
operator|<<
operator|*
name|symbolName
operator|<<
literal|"\n"
expr_stmt|;
return|return
name|llvm
operator|::
name|object
operator|::
name|object_error
operator|::
name|parse_failed
return|;
block|}
block|}
end_for

begin_return
return|return
name|std
operator|::
name|error_code
argument_list|()
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|std
operator|::
name|error_code
name|ELFFile
operator|<
name|ELFT
operator|>
operator|::
name|createAtoms
argument_list|()
block|{
comment|// Holds all the atoms that are part of the section. They are the targets of
comment|// the kindGroupChild reference.
name|llvm
operator|::
name|StringMap
operator|<
name|std
operator|::
name|vector
operator|<
name|ELFDefinedAtom
operator|<
name|ELFT
operator|>
operator|*
operator|>>
name|atomsForSection
block|;
comment|// group sections have a mapping of the section header to the
comment|// signature/section.
name|llvm
operator|::
name|DenseMap
operator|<
specifier|const
name|Elf_Shdr
operator|*
block|,
name|std
operator|::
name|pair
operator|<
name|StringRef
block|,
name|StringRef
operator|>>
name|groupSections
block|;
comment|// Contains a list of comdat sections for a group.
name|llvm
operator|::
name|DenseMap
operator|<
specifier|const
name|Elf_Shdr
operator|*
block|,
name|std
operator|::
name|vector
operator|<
name|StringRef
operator|>>
name|comdatSections
block|;
for|for
control|(
name|auto
operator|&
name|i
operator|:
name|_sectionSymbols
control|)
block|{
specifier|const
name|Elf_Shdr
modifier|*
name|section
init|=
name|i
operator|.
name|first
decl_stmt|;
name|std
operator|::
name|vector
operator|<
name|Elf_Sym_Iter
operator|>
operator|&
name|symbols
operator|=
name|i
operator|.
name|second
expr_stmt|;
comment|// Sort symbols by position.
name|std
operator|::
name|stable_sort
argument_list|(
name|symbols
operator|.
name|begin
argument_list|()
argument_list|,
name|symbols
operator|.
name|end
argument_list|()
argument_list|,
index|[
name|this
index|]
operator|(
name|Elf_Sym_Iter
name|a
operator|,
name|Elf_Sym_Iter
name|b
operator|)
block|{
return|return
name|getSymbolValue
argument_list|(
operator|&
operator|*
name|a
argument_list|)
operator|<
name|getSymbolValue
argument_list|(
operator|&
operator|*
name|b
argument_list|)
return|;
block|}
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|ErrorOr
operator|<
name|StringRef
operator|>
name|sectionName
operator|=
name|this
operator|->
name|getSectionName
argument_list|(
name|section
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|std
operator|::
name|error_code
name|ec
operator|=
name|sectionName
operator|.
name|getError
argument_list|()
condition|)
return|return
name|ec
return|;
end_if

begin_decl_stmt
name|auto
name|sectionContents
init|=
name|getSectionContents
argument_list|(
name|section
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|std
operator|::
name|error_code
name|ec
operator|=
name|sectionContents
operator|.
name|getError
argument_list|()
condition|)
return|return
name|ec
return|;
end_if

begin_decl_stmt
name|bool
name|addAtoms
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_comment
comment|// A section of type SHT_GROUP defines a grouping of sections. The name of a
end_comment

begin_comment
comment|// symbol from one of the containing object's symbol tables provides a
end_comment

begin_comment
comment|// signature
end_comment

begin_comment
comment|// for the section group. The section header of the SHT_GROUP section
end_comment

begin_comment
comment|// specifies
end_comment

begin_comment
comment|// the identifying symbol entry, as described : the sh_link member contains
end_comment

begin_comment
comment|// the section header index of the symbol table section that contains the
end_comment

begin_comment
comment|// entry.
end_comment

begin_comment
comment|// The sh_info member contains the symbol table index of the identifying
end_comment

begin_comment
comment|// entry.
end_comment

begin_comment
comment|// The sh_flags member of the section header contains 0. The name of the
end_comment

begin_comment
comment|// section
end_comment

begin_comment
comment|// (sh_name) is not specified.
end_comment

begin_if
if|if
condition|(
name|isGroupSection
argument_list|(
name|section
argument_list|)
condition|)
block|{
specifier|const
name|Elf_Word
modifier|*
name|groupMembers
init|=
name|reinterpret_cast
operator|<
specifier|const
name|Elf_Word
operator|*
operator|>
operator|(
name|sectionContents
operator|->
name|data
argument_list|()
operator|)
decl_stmt|;
specifier|const
name|long
name|count
init|=
operator|(
name|section
operator|->
name|sh_size
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|Elf_Word
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|1
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|Elf_Shdr
modifier|*
name|sHdr
init|=
name|_objFile
operator|->
name|getSection
argument_list|(
name|groupMembers
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|ErrorOr
operator|<
name|StringRef
operator|>
name|sectionName
operator|=
name|_objFile
operator|->
name|getSectionName
argument_list|(
name|sHdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|std
operator|::
name|error_code
name|ec
operator|=
name|sectionName
operator|.
name|getError
argument_list|()
condition|)
return|return
name|ec
return|;
name|comdatSections
index|[
name|section
index|]
operator|.
name|push_back
argument_list|(
operator|*
name|sectionName
argument_list|)
expr_stmt|;
block|}
specifier|const
name|Elf_Sym
modifier|*
name|symbol
init|=
name|_objFile
operator|->
name|getSymbol
argument_list|(
name|section
operator|->
name|sh_info
argument_list|)
decl_stmt|;
specifier|const
name|Elf_Shdr
modifier|*
name|symtab
init|=
name|_objFile
operator|->
name|getSection
argument_list|(
name|section
operator|->
name|sh_link
argument_list|)
decl_stmt|;
name|ErrorOr
operator|<
name|StringRef
operator|>
name|symbolName
operator|=
name|_objFile
operator|->
name|getSymbolName
argument_list|(
name|symtab
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|std
operator|::
name|error_code
name|ec
operator|=
name|symbolName
operator|.
name|getError
argument_list|()
condition|)
return|return
name|ec
return|;
name|groupSections
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|section
argument_list|,
name|std
operator|::
name|make_pair
argument_list|(
operator|*
name|symbolName
argument_list|,
operator|*
name|sectionName
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
end_if

begin_if
if|if
condition|(
name|isGnuLinkOnceSection
argument_list|(
operator|*
name|sectionName
argument_list|)
condition|)
block|{
name|groupSections
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|section
argument_list|,
name|std
operator|::
name|make_pair
argument_list|(
operator|*
name|sectionName
argument_list|,
operator|*
name|sectionName
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|addAtoms
operator|=
name|false
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|isSectionMemberOfGroup
argument_list|(
name|section
argument_list|)
condition|)
name|addAtoms
operator|=
name|false
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|handleSectionWithNoSymbols
argument_list|(
name|section
argument_list|,
name|symbols
argument_list|)
condition|)
block|{
name|ELFDefinedAtom
operator|<
name|ELFT
operator|>
operator|*
name|newAtom
operator|=
name|createSectionAtom
argument_list|(
name|section
argument_list|,
operator|*
name|sectionName
argument_list|,
operator|*
name|sectionContents
argument_list|)
expr_stmt|;
name|newAtom
operator|->
name|setOrdinal
argument_list|(
operator|++
name|_ordinal
argument_list|)
expr_stmt|;
if|if
condition|(
name|addAtoms
condition|)
name|_definedAtoms
operator|.
name|_atoms
operator|.
name|push_back
argument_list|(
name|newAtom
argument_list|)
expr_stmt|;
else|else
name|atomsForSection
index|[
operator|*
name|sectionName
index|]
operator|.
name|push_back
argument_list|(
name|newAtom
argument_list|)
expr_stmt|;
continue|continue;
block|}
end_if

begin_expr_stmt
name|ELFDefinedAtom
operator|<
name|ELFT
operator|>
operator|*
name|previousAtom
operator|=
name|nullptr
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ELFReference
operator|<
name|ELFT
operator|>
operator|*
name|anonFollowedBy
operator|=
name|nullptr
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|auto
name|si
init|=
name|symbols
operator|.
name|begin
argument_list|()
init|,
name|se
init|=
name|symbols
operator|.
name|end
argument_list|()
init|;
name|si
operator|!=
name|se
condition|;
operator|++
name|si
control|)
block|{
name|auto
name|symbol
init|=
operator|*
name|si
decl_stmt|;
name|StringRef
name|symbolName
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|symbol
operator|->
name|getType
argument_list|()
operator|!=
name|llvm
operator|::
name|ELF
operator|::
name|STT_SECTION
condition|)
block|{
name|auto
name|symName
init|=
name|_objFile
operator|->
name|getSymbolName
argument_list|(
name|symbol
argument_list|)
decl_stmt|;
if|if
condition|(
name|std
operator|::
name|error_code
name|ec
operator|=
name|symName
operator|.
name|getError
argument_list|()
condition|)
return|return
name|ec
return|;
name|symbolName
operator|=
operator|*
name|symName
expr_stmt|;
block|}
name|uint64_t
name|contentSize
init|=
name|symbolContentSize
argument_list|(
name|section
argument_list|,
operator|&
operator|*
name|symbol
argument_list|,
operator|(
name|si
operator|+
literal|1
operator|==
name|se
operator|)
condition|?
name|nullptr
else|:
operator|&
operator|*
operator|*
operator|(
name|si
operator|+
literal|1
operator|)
argument_list|)
decl_stmt|;
comment|// Check to see if we need to add the FollowOn Reference
name|ELFReference
operator|<
name|ELFT
operator|>
operator|*
name|followOn
operator|=
name|nullptr
expr_stmt|;
if|if
condition|(
name|previousAtom
condition|)
block|{
comment|// Replace the followon atom with the anonymous atom that we created,
comment|// so that the next symbol that we create is a followon from the
comment|// anonymous atom.
if|if
condition|(
name|anonFollowedBy
condition|)
block|{
name|followOn
operator|=
name|anonFollowedBy
expr_stmt|;
block|}
else|else
block|{
name|followOn
operator|=
name|new
argument_list|(
argument|_readerStorage
argument_list|)
name|ELFReference
operator|<
name|ELFT
operator|>
operator|(
name|lld
operator|::
name|Reference
operator|::
name|kindLayoutAfter
operator|)
expr_stmt|;
name|previousAtom
operator|->
name|addReference
argument_list|(
name|followOn
argument_list|)
expr_stmt|;
block|}
block|}
name|ArrayRef
operator|<
name|uint8_t
operator|>
name|symbolData
argument_list|(
operator|(
specifier|const
name|uint8_t
operator|*
operator|)
name|sectionContents
operator|->
name|data
argument_list|()
operator|+
name|getSymbolValue
argument_list|(
operator|&
operator|*
name|symbol
argument_list|)
argument_list|,
name|contentSize
argument_list|)
expr_stmt|;
comment|// If the linker finds that a section has global atoms that are in a
comment|// mergeable section, treat them as defined atoms as they shouldn't be
comment|// merged away as well as these symbols have to be part of symbol
comment|// resolution
if|if
condition|(
name|isMergeableStringSection
argument_list|(
name|section
argument_list|)
condition|)
block|{
if|if
condition|(
name|symbol
operator|->
name|getBinding
argument_list|()
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|STB_GLOBAL
condition|)
block|{
name|auto
name|definedMergeAtom
init|=
name|handleDefinedSymbol
argument_list|(
name|symbolName
argument_list|,
operator|*
name|sectionName
argument_list|,
operator|&
operator|*
operator|*
name|si
argument_list|,
name|section
argument_list|,
name|symbolData
argument_list|,
name|_references
operator|.
name|size
argument_list|()
argument_list|,
name|_references
operator|.
name|size
argument_list|()
argument_list|,
name|_references
argument_list|)
decl_stmt|;
operator|(
operator|*
name|definedMergeAtom
operator|)
operator|->
name|setOrdinal
argument_list|(
operator|++
name|_ordinal
argument_list|)
expr_stmt|;
if|if
condition|(
name|addAtoms
condition|)
name|_definedAtoms
operator|.
name|_atoms
operator|.
name|push_back
argument_list|(
operator|*
name|definedMergeAtom
argument_list|)
expr_stmt|;
else|else
name|atomsForSection
index|[
operator|*
name|sectionName
index|]
operator|.
name|push_back
argument_list|(
operator|*
name|definedMergeAtom
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
comment|// Don't allocate content to a weak symbol, as they may be merged away.
comment|// Create an anonymous atom to hold the data.
name|ELFDefinedAtom
operator|<
name|ELFT
operator|>
operator|*
name|anonAtom
operator|=
name|nullptr
expr_stmt|;
name|anonFollowedBy
operator|=
name|nullptr
expr_stmt|;
if|if
condition|(
name|symbol
operator|->
name|getBinding
argument_list|()
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|STB_WEAK
condition|)
block|{
comment|// Create anonymous new non-weak ELF symbol that holds the symbol
comment|// data.
name|auto
name|sym
init|=
name|new
argument_list|(
argument|_readerStorage
argument_list|)
name|Elf_Sym
argument_list|(
operator|*
name|symbol
argument_list|)
decl_stmt|;
name|sym
operator|->
name|setBinding
argument_list|(
name|llvm
operator|::
name|ELF
operator|::
name|STB_GLOBAL
argument_list|)
expr_stmt|;
name|anonAtom
operator|=
name|createDefinedAtomAndAssignRelocations
argument_list|(
literal|""
argument_list|,
operator|*
name|sectionName
argument_list|,
name|sym
argument_list|,
name|section
argument_list|,
name|symbolData
argument_list|,
operator|*
name|sectionContents
argument_list|)
expr_stmt|;
name|symbolData
operator|=
name|ArrayRef
operator|<
name|uint8_t
operator|>
operator|(
operator|)
expr_stmt|;
comment|// If this is the last atom, let's not create a followon reference.
if|if
condition|(
name|anonAtom
operator|&&
operator|(
name|si
operator|+
literal|1
operator|)
operator|!=
name|se
condition|)
block|{
name|anonFollowedBy
operator|=
name|new
argument_list|(
argument|_readerStorage
argument_list|)
name|ELFReference
operator|<
name|ELFT
operator|>
operator|(
name|lld
operator|::
name|Reference
operator|::
name|kindLayoutAfter
operator|)
expr_stmt|;
name|anonAtom
operator|->
name|addReference
argument_list|(
name|anonFollowedBy
argument_list|)
expr_stmt|;
block|}
block|}
name|ELFDefinedAtom
operator|<
name|ELFT
operator|>
operator|*
name|newAtom
operator|=
name|createDefinedAtomAndAssignRelocations
argument_list|(
name|symbolName
argument_list|,
operator|*
name|sectionName
argument_list|,
operator|&
operator|*
name|symbol
argument_list|,
name|section
argument_list|,
name|symbolData
argument_list|,
operator|*
name|sectionContents
argument_list|)
expr_stmt|;
name|newAtom
operator|->
name|setOrdinal
argument_list|(
operator|++
name|_ordinal
argument_list|)
expr_stmt|;
comment|// If the atom was a weak symbol, let's create a followon reference to
comment|// the anonymous atom that we created.
if|if
condition|(
name|anonAtom
condition|)
name|createEdge
argument_list|(
name|newAtom
argument_list|,
name|anonAtom
argument_list|,
name|Reference
operator|::
name|kindLayoutAfter
argument_list|)
expr_stmt|;
if|if
condition|(
name|previousAtom
condition|)
block|{
comment|// Set the followon atom to the weak atom that we have created, so
comment|// that they would alias when the file gets written.
name|followOn
operator|->
name|setTarget
argument_list|(
name|anonAtom
condition|?
name|anonAtom
else|:
name|newAtom
argument_list|)
expr_stmt|;
block|}
comment|// The previous atom is always the atom created before unless the atom
comment|// is a weak atom.
name|previousAtom
operator|=
name|anonAtom
condition|?
name|anonAtom
else|:
name|newAtom
expr_stmt|;
if|if
condition|(
name|addAtoms
condition|)
name|_definedAtoms
operator|.
name|_atoms
operator|.
name|push_back
argument_list|(
name|newAtom
argument_list|)
expr_stmt|;
else|else
name|atomsForSection
index|[
operator|*
name|sectionName
index|]
operator|.
name|push_back
argument_list|(
name|newAtom
argument_list|)
expr_stmt|;
name|_symbolToAtomMapping
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
operator|&
operator|*
name|symbol
argument_list|,
name|newAtom
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|anonAtom
condition|)
block|{
name|anonAtom
operator|->
name|setOrdinal
argument_list|(
operator|++
name|_ordinal
argument_list|)
expr_stmt|;
if|if
condition|(
name|addAtoms
condition|)
name|_definedAtoms
operator|.
name|_atoms
operator|.
name|push_back
argument_list|(
name|anonAtom
argument_list|)
expr_stmt|;
else|else
name|atomsForSection
index|[
operator|*
name|sectionName
index|]
operator|.
name|push_back
argument_list|(
name|anonAtom
argument_list|)
expr_stmt|;
block|}
block|}
end_for

begin_comment
unit|}
comment|// Iterate over all the group sections to create parent atoms pointing to
end_comment

begin_comment
comment|// group-child atoms.
end_comment

begin_expr_stmt
unit|for
operator|(
name|auto
operator|&
name|sect
operator|:
name|groupSections
operator|)
block|{
name|StringRef
name|signature
operator|=
name|sect
operator|.
name|second
operator|.
name|first
block|;
name|StringRef
name|groupSectionName
operator|=
name|sect
operator|.
name|second
operator|.
name|second
block|;
if|if
condition|(
name|isGnuLinkOnceSection
argument_list|(
name|signature
argument_list|)
condition|)
name|handleGnuLinkOnceSection
argument_list|(
name|signature
argument_list|,
name|atomsForSection
argument_list|,
name|sect
operator|.
name|first
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isGroupSection
argument_list|(
name|sect
operator|.
name|first
argument_list|)
condition|)
name|handleSectionGroup
argument_list|(
name|signature
argument_list|,
name|groupSectionName
argument_list|,
name|atomsForSection
argument_list|,
name|comdatSections
argument_list|,
name|sect
operator|.
name|first
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
name|updateReferences
argument_list|()
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|std
operator|::
name|error_code
argument_list|()
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|std
operator|::
name|error_code
name|ELFFile
operator|<
name|ELFT
operator|>
operator|::
name|handleGnuLinkOnceSection
argument_list|(
argument|StringRef signature
argument_list|,
argument|llvm::StringMap<std::vector<ELFDefinedAtom<ELFT> *>>&atomsForSection
argument_list|,
argument|const Elf_Shdr *shdr
argument_list|)
block|{
comment|// TODO: Check for errors.
name|unsigned
name|int
name|referenceStart
operator|=
name|_references
operator|.
name|size
argument_list|()
block|;
name|std
operator|::
name|vector
operator|<
name|ELFReference
operator|<
name|ELFT
operator|>
operator|*
operator|>
name|refs
block|;
for|for
control|(
name|auto
name|ha
range|:
name|atomsForSection
index|[
name|signature
index|]
control|)
block|{
name|_groupChild
index|[
name|ha
operator|->
name|symbol
argument_list|()
index|]
operator|=
name|std
operator|::
name|make_pair
argument_list|(
name|signature
argument_list|,
name|shdr
argument_list|)
expr_stmt|;
name|ELFReference
operator|<
name|ELFT
operator|>
operator|*
name|ref
operator|=
name|new
argument_list|(
argument|_readerStorage
argument_list|)
name|ELFReference
operator|<
name|ELFT
operator|>
operator|(
name|lld
operator|::
name|Reference
operator|::
name|kindGroupChild
operator|)
expr_stmt|;
name|ref
operator|->
name|setTarget
argument_list|(
name|ha
argument_list|)
expr_stmt|;
name|refs
operator|.
name|push_back
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
name|atomsForSection
index|[
name|signature
index|]
operator|.
name|clear
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Create a gnu linkonce atom.
end_comment

begin_decl_stmt
name|auto
name|gnuLinkOnceAtom
init|=
name|handleDefinedSymbol
argument_list|(
name|signature
argument_list|,
name|signature
argument_list|,
name|nullptr
argument_list|,
name|shdr
argument_list|,
name|ArrayRef
operator|<
name|uint8_t
operator|>
operator|(
operator|)
argument_list|,
name|referenceStart
argument_list|,
name|_references
operator|.
name|size
argument_list|()
argument_list|,
name|_references
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
operator|(
operator|*
name|gnuLinkOnceAtom
operator|)
operator|->
name|setOrdinal
argument_list|(
operator|++
name|_ordinal
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_definedAtoms
operator|.
name|_atoms
operator|.
name|push_back
argument_list|(
operator|*
name|gnuLinkOnceAtom
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|auto
name|reference
range|:
name|refs
control|)
operator|(
operator|*
name|gnuLinkOnceAtom
operator|)
operator|->
name|addReference
argument_list|(
name|reference
argument_list|)
expr_stmt|;
end_for

begin_return
return|return
name|std
operator|::
name|error_code
argument_list|()
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|std
operator|::
name|error_code
name|ELFFile
operator|<
name|ELFT
operator|>
operator|::
name|handleSectionGroup
argument_list|(
argument|StringRef signature
argument_list|,
argument|StringRef groupSectionName
argument_list|,
argument|llvm::StringMap<std::vector<ELFDefinedAtom<ELFT> *>>&atomsForSection
argument_list|,
argument|llvm::DenseMap<const Elf_Shdr *
argument_list|,
argument|std::vector<StringRef>>&comdatSections
argument_list|,
argument|const Elf_Shdr *shdr
argument_list|)
block|{
comment|// TODO: Check for errors.
name|unsigned
name|int
name|referenceStart
operator|=
name|_references
operator|.
name|size
argument_list|()
block|;
name|std
operator|::
name|vector
operator|<
name|ELFReference
operator|<
name|ELFT
operator|>
operator|*
operator|>
name|refs
block|;
name|auto
name|sectionNamesInGroup
operator|=
name|comdatSections
index|[
name|shdr
index|]
block|;
for|for
control|(
name|auto
name|sectionName
range|:
name|sectionNamesInGroup
control|)
block|{
for|for
control|(
name|auto
name|ha
range|:
name|atomsForSection
index|[
name|sectionName
index|]
control|)
block|{
name|_groupChild
index|[
name|ha
operator|->
name|symbol
argument_list|()
index|]
operator|=
name|std
operator|::
name|make_pair
argument_list|(
name|signature
argument_list|,
name|shdr
argument_list|)
expr_stmt|;
name|ELFReference
operator|<
name|ELFT
operator|>
operator|*
name|ref
operator|=
name|new
argument_list|(
argument|_readerStorage
argument_list|)
name|ELFReference
operator|<
name|ELFT
operator|>
operator|(
name|lld
operator|::
name|Reference
operator|::
name|kindGroupChild
operator|)
expr_stmt|;
name|ref
operator|->
name|setTarget
argument_list|(
name|ha
argument_list|)
expr_stmt|;
name|refs
operator|.
name|push_back
argument_list|(
name|ref
argument_list|)
expr_stmt|;
block|}
name|atomsForSection
index|[
name|sectionName
index|]
operator|.
name|clear
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|// Create a gnu linkonce atom.
end_comment

begin_expr_stmt
unit|auto
name|sectionGroupAtom
operator|=
name|handleDefinedSymbol
argument_list|(
name|signature
argument_list|,
name|groupSectionName
argument_list|,
name|nullptr
argument_list|,
name|shdr
argument_list|,
name|ArrayRef
operator|<
name|uint8_t
operator|>
operator|(
operator|)
argument_list|,
name|referenceStart
argument_list|,
name|_references
operator|.
name|size
argument_list|()
argument_list|,
name|_references
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
operator|*
name|sectionGroupAtom
operator|)
operator|->
name|setOrdinal
argument_list|(
operator|++
name|_ordinal
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_definedAtoms
operator|.
name|_atoms
operator|.
name|push_back
argument_list|(
operator|*
name|sectionGroupAtom
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|auto
name|reference
range|:
name|refs
control|)
operator|(
operator|*
name|sectionGroupAtom
operator|)
operator|->
name|addReference
argument_list|(
name|reference
argument_list|)
expr_stmt|;
end_for

begin_return
return|return
name|std
operator|::
name|error_code
argument_list|()
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|std
operator|::
name|error_code
name|ELFFile
operator|<
name|ELFT
operator|>
operator|::
name|createAtomsFromContext
argument_list|()
block|{
if|if
condition|(
operator|!
name|_useWrap
condition|)
return|return
name|std
operator|::
name|error_code
argument_list|()
return|;
end_expr_stmt

begin_comment
comment|// Steps :-
end_comment

begin_comment
comment|// a) Create an undefined atom for the symbol specified by the --wrap option,
end_comment

begin_comment
comment|// as that
end_comment

begin_comment
comment|// may be needed to be pulled from an archive.
end_comment

begin_comment
comment|// b) Create an undefined atom for __wrap_<symbolname>.
end_comment

begin_comment
comment|// c) All references to the symbol specified by wrap should point to
end_comment

begin_comment
comment|// __wrap_<symbolname>
end_comment

begin_comment
comment|// d) All references to __real_symbol should point to the<symbol>
end_comment

begin_for
for|for
control|(
name|auto
operator|&
name|wrapsym
operator|:
name|_ctx
operator|.
name|wrapCalls
argument_list|()
control|)
block|{
name|StringRef
name|wrapStr
init|=
name|wrapsym
operator|.
name|getKey
argument_list|()
decl_stmt|;
comment|// Create a undefined symbol fror the wrap symbol.
name|UndefinedAtom
modifier|*
name|wrapSymAtom
init|=
name|new
argument_list|(
argument|_readerStorage
argument_list|)
name|SimpleUndefinedAtom
argument_list|(
operator|*
name|this
argument_list|,
name|wrapStr
argument_list|)
decl_stmt|;
name|StringRef
name|wrapCallSym
init|=
name|_ctx
operator|.
name|allocateString
argument_list|(
operator|(
name|llvm
operator|::
name|Twine
argument_list|(
literal|"__wrap_"
argument_list|)
operator|+
name|wrapStr
operator|)
operator|.
name|str
argument_list|()
argument_list|)
decl_stmt|;
name|StringRef
name|realCallSym
init|=
name|_ctx
operator|.
name|allocateString
argument_list|(
operator|(
name|llvm
operator|::
name|Twine
argument_list|(
literal|"__real_"
argument_list|)
operator|+
name|wrapStr
operator|)
operator|.
name|str
argument_list|()
argument_list|)
decl_stmt|;
name|UndefinedAtom
modifier|*
name|wrapCallAtom
init|=
name|new
argument_list|(
argument|_readerStorage
argument_list|)
name|SimpleUndefinedAtom
argument_list|(
operator|*
name|this
argument_list|,
name|wrapCallSym
argument_list|)
decl_stmt|;
comment|// Create maps, when there is call to sym, it should point to wrapCallSym.
name|_wrapSymbolMap
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|wrapStr
argument_list|,
name|wrapCallAtom
argument_list|)
argument_list|)
expr_stmt|;
comment|// Whenever there is a reference to realCall it should point to the symbol
comment|// created for each wrap usage.
name|_wrapSymbolMap
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|realCallSym
argument_list|,
name|wrapSymAtom
argument_list|)
argument_list|)
expr_stmt|;
name|_undefinedAtoms
operator|.
name|_atoms
operator|.
name|push_back
argument_list|(
name|wrapSymAtom
argument_list|)
expr_stmt|;
name|_undefinedAtoms
operator|.
name|_atoms
operator|.
name|push_back
argument_list|(
name|wrapCallAtom
argument_list|)
expr_stmt|;
block|}
end_for

begin_return
return|return
name|std
operator|::
name|error_code
argument_list|()
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|ELFDefinedAtom
operator|<
name|ELFT
operator|>
operator|*
name|ELFFile
operator|<
name|ELFT
operator|>
operator|::
name|createDefinedAtomAndAssignRelocations
argument_list|(
argument|StringRef symbolName
argument_list|,
argument|StringRef sectionName
argument_list|,
argument|const Elf_Sym *symbol
argument_list|,
argument|const Elf_Shdr *section
argument_list|,
argument|ArrayRef<uint8_t> symContent
argument_list|,
argument|ArrayRef<uint8_t> secContent
argument_list|)
block|{
name|unsigned
name|int
name|referenceStart
operator|=
name|_references
operator|.
name|size
argument_list|()
block|;
comment|// Add Rela (those with r_addend) references:
name|auto
name|rari
operator|=
name|_relocationAddendReferences
operator|.
name|find
argument_list|(
name|sectionName
argument_list|)
block|;
if|if
condition|(
name|rari
operator|!=
name|_relocationAddendReferences
operator|.
name|end
argument_list|()
condition|)
name|createRelocationReferences
argument_list|(
name|symbol
argument_list|,
name|symContent
argument_list|,
name|rari
operator|->
name|second
argument_list|)
expr_stmt|;
comment|// Add Rel references.
name|auto
name|rri
operator|=
name|_relocationReferences
operator|.
name|find
argument_list|(
name|sectionName
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|rri
operator|!=
name|_relocationReferences
operator|.
name|end
argument_list|()
condition|)
name|createRelocationReferences
argument_list|(
name|symbol
argument_list|,
name|symContent
argument_list|,
name|secContent
argument_list|,
name|rri
operator|->
name|second
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|// Create the DefinedAtom and add it to the list of DefinedAtoms.
end_comment

begin_return
return|return
operator|*
name|handleDefinedSymbol
argument_list|(
name|symbolName
argument_list|,
name|sectionName
argument_list|,
name|symbol
argument_list|,
name|section
argument_list|,
name|symContent
argument_list|,
name|referenceStart
argument_list|,
name|_references
operator|.
name|size
argument_list|()
argument_list|,
name|_references
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|void
name|ELFFile
operator|<
name|ELFT
operator|>
operator|::
name|createRelocationReferences
argument_list|(
argument|const Elf_Sym *symbol
argument_list|,
argument|ArrayRef<uint8_t> content
argument_list|,
argument|range<Elf_Rela_Iter> rels
argument_list|)
block|{
name|bool
name|isMips64EL
operator|=
name|_objFile
operator|->
name|isMips64EL
argument_list|()
block|;
specifier|const
name|auto
name|symValue
operator|=
name|getSymbolValue
argument_list|(
name|symbol
argument_list|)
block|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|rel
range|:
name|rels
control|)
block|{
if|if
condition|(
name|rel
operator|.
name|r_offset
operator|<
name|symValue
operator|||
name|symValue
operator|+
name|content
operator|.
name|size
argument_list|()
operator|<=
name|rel
operator|.
name|r_offset
condition|)
continue|continue;
name|auto
name|elfRelocation
init|=
name|new
argument_list|(
argument|_readerStorage
argument_list|)
name|ELFReference
operator|<
name|ELFT
operator|>
operator|(
operator|&
name|rel
expr|,
name|rel
operator|.
name|r_offset
operator|-
name|symValue
expr|,
name|kindArch
argument_list|()
expr|,
name|rel
operator|.
name|getType
argument_list|(
name|isMips64EL
argument_list|)
expr|,
name|rel
operator|.
name|getSymbol
argument_list|(
name|isMips64EL
argument_list|)
operator|)
decl_stmt|;
name|addReferenceToSymbol
argument_list|(
name|elfRelocation
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|_references
operator|.
name|push_back
argument_list|(
name|elfRelocation
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|void
name|ELFFile
operator|<
name|ELFT
operator|>
operator|::
name|createRelocationReferences
argument_list|(
argument|const Elf_Sym *symbol
argument_list|,
argument|ArrayRef<uint8_t> symContent
argument_list|,
argument|ArrayRef<uint8_t> secContent
argument_list|,
argument|range<Elf_Rel_Iter> rels
argument_list|)
block|{
name|bool
name|isMips64EL
operator|=
name|_objFile
operator|->
name|isMips64EL
argument_list|()
block|;
specifier|const
name|auto
name|symValue
operator|=
name|getSymbolValue
argument_list|(
name|symbol
argument_list|)
block|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|rel
range|:
name|rels
control|)
block|{
if|if
condition|(
name|rel
operator|.
name|r_offset
operator|<
name|symValue
operator|||
name|symValue
operator|+
name|symContent
operator|.
name|size
argument_list|()
operator|<=
name|rel
operator|.
name|r_offset
condition|)
continue|continue;
name|auto
name|elfRelocation
init|=
name|new
argument_list|(
argument|_readerStorage
argument_list|)
name|ELFReference
operator|<
name|ELFT
operator|>
operator|(
name|rel
operator|.
name|r_offset
operator|-
name|symValue
expr|,
name|kindArch
argument_list|()
expr|,
name|rel
operator|.
name|getType
argument_list|(
name|isMips64EL
argument_list|)
expr|,
name|rel
operator|.
name|getSymbol
argument_list|(
name|isMips64EL
argument_list|)
operator|)
decl_stmt|;
name|int32_t
name|addend
init|=
operator|*
operator|(
name|symContent
operator|.
name|data
argument_list|()
operator|+
name|rel
operator|.
name|r_offset
operator|-
name|symValue
operator|)
decl_stmt|;
name|elfRelocation
operator|->
name|setAddend
argument_list|(
name|addend
argument_list|)
expr_stmt|;
name|addReferenceToSymbol
argument_list|(
name|elfRelocation
argument_list|,
name|symbol
argument_list|)
expr_stmt|;
name|_references
operator|.
name|push_back
argument_list|(
name|elfRelocation
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|void
name|ELFFile
operator|<
name|ELFT
operator|>
operator|::
name|updateReferenceForMergeStringAccess
argument_list|(
argument|ELFReference<ELFT> *ref
argument_list|,
argument|const Elf_Sym *symbol
argument_list|,
argument|const Elf_Shdr *shdr
argument_list|)
block|{
comment|// If the target atom is mergeable strefng atom, the atom might have been
comment|// merged with other atom having the same contents. Try to find the
comment|// merged one if that's the case.
name|int64_t
name|addend
operator|=
name|ref
operator|->
name|addend
argument_list|()
block|;
if|if
condition|(
name|addend
operator|<
literal|0
condition|)
name|addend
operator|=
literal|0
expr_stmt|;
specifier|const
name|MergeSectionKey
name|ms
argument_list|(
name|shdr
argument_list|,
name|addend
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|auto
name|msec
init|=
name|_mergedSectionMap
operator|.
name|find
argument_list|(
name|ms
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|msec
operator|!=
name|_mergedSectionMap
operator|.
name|end
argument_list|()
condition|)
block|{
name|ref
operator|->
name|setTarget
argument_list|(
name|msec
operator|->
name|second
argument_list|)
expr_stmt|;
return|return;
block|}
end_if

begin_comment
comment|// The target atom was not merged. Mergeable atoms are not in
end_comment

begin_comment
comment|// _symbolToAtomMapping, so we cannot find it by calling findAtom(). We
end_comment

begin_comment
comment|// instead call findMergeAtom().
end_comment

begin_if
if|if
condition|(
name|symbol
operator|->
name|getType
argument_list|()
operator|!=
name|llvm
operator|::
name|ELF
operator|::
name|STT_SECTION
condition|)
name|addend
operator|=
name|getSymbolValue
argument_list|(
name|symbol
argument_list|)
operator|+
name|addend
expr_stmt|;
end_if

begin_expr_stmt
name|ELFMergeAtom
operator|<
name|ELFT
operator|>
operator|*
name|mergedAtom
operator|=
name|findMergeAtom
argument_list|(
name|shdr
argument_list|,
name|addend
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ref
operator|->
name|setOffset
argument_list|(
name|addend
operator|-
name|mergedAtom
operator|->
name|offset
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ref
operator|->
name|setAddend
argument_list|(
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ref
operator|->
name|setTarget
argument_list|(
name|mergedAtom
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|void
name|ELFFile
operator|<
name|ELFT
operator|>
operator|::
name|updateReferences
argument_list|()
block|{
for|for
control|(
name|auto
operator|&
name|ri
operator|:
name|_references
control|)
block|{
if|if
condition|(
name|ri
operator|->
name|kindNamespace
argument_list|()
operator|!=
name|lld
operator|::
name|Reference
operator|::
name|KindNamespace
operator|::
name|ELF
condition|)
continue|continue;
specifier|const
name|Elf_Sym
modifier|*
name|symbol
init|=
name|_objFile
operator|->
name|getSymbol
argument_list|(
name|ri
operator|->
name|targetSymbolIndex
argument_list|()
argument_list|)
decl_stmt|;
specifier|const
name|Elf_Shdr
modifier|*
name|shdr
init|=
name|_objFile
operator|->
name|getSection
argument_list|(
name|symbol
argument_list|)
decl_stmt|;
comment|// If the atom is not in mergeable string section, the target atom is
comment|// simply that atom.
if|if
condition|(
name|isMergeableStringSection
argument_list|(
name|shdr
argument_list|)
condition|)
name|updateReferenceForMergeStringAccess
argument_list|(
name|ri
argument_list|,
name|symbol
argument_list|,
name|shdr
argument_list|)
expr_stmt|;
else|else
name|ri
operator|->
name|setTarget
argument_list|(
name|findAtom
argument_list|(
name|findSymbolForReference
argument_list|(
name|ri
argument_list|)
argument_list|,
name|symbol
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|bool
name|ELFFile
operator|<
name|ELFT
operator|>
operator|::
name|isIgnoredSection
argument_list|(
argument|const Elf_Shdr *section
argument_list|)
block|{
switch|switch
condition|(
name|section
operator|->
name|sh_type
condition|)
block|{
case|case
name|llvm
operator|::
name|ELF
operator|::
name|SHT_NULL
case|:
case|case
name|llvm
operator|::
name|ELF
operator|::
name|SHT_STRTAB
case|:
case|case
name|llvm
operator|::
name|ELF
operator|::
name|SHT_SYMTAB
case|:
case|case
name|llvm
operator|::
name|ELF
operator|::
name|SHT_SYMTAB_SHNDX
case|:
return|return
name|true
return|;
default|default:
break|break;
block|}
end_expr_stmt

begin_return
return|return
name|false
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|bool
name|ELFFile
operator|<
name|ELFT
operator|>
operator|::
name|isMergeableStringSection
argument_list|(
argument|const Elf_Shdr *section
argument_list|)
block|{
if|if
condition|(
name|_doStringsMerge
operator|&&
name|section
condition|)
block|{
name|int64_t
name|sectionFlags
init|=
name|section
operator|->
name|sh_flags
decl_stmt|;
name|sectionFlags
operator|&=
operator|~
name|llvm
operator|::
name|ELF
operator|::
name|SHF_ALLOC
expr_stmt|;
comment|// Mergeable string sections have both SHF_MERGE and SHF_STRINGS flags
comment|// set. sh_entsize is the size of each character which is normally 1.
if|if
condition|(
operator|(
name|section
operator|->
name|sh_entsize
operator|<
literal|2
operator|)
operator|&&
operator|(
name|sectionFlags
operator|==
operator|(
name|llvm
operator|::
name|ELF
operator|::
name|SHF_MERGE
operator||
name|llvm
operator|::
name|ELF
operator|::
name|SHF_STRINGS
operator|)
operator|)
condition|)
block|{
return|return
name|true
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}   return
name|false
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|ELFDefinedAtom
operator|<
name|ELFT
operator|>
operator|*
name|ELFFile
operator|<
name|ELFT
operator|>
operator|::
name|createSectionAtom
argument_list|(
argument|const Elf_Shdr *section
argument_list|,
argument|StringRef sectionName
argument_list|,
argument|ArrayRef<uint8_t> content
argument_list|)
block|{
name|Elf_Sym
operator|*
name|sym
operator|=
name|new
argument_list|(
argument|_readerStorage
argument_list|)
name|Elf_Sym
block|;
name|sym
operator|->
name|st_name
operator|=
literal|0
block|;
name|sym
operator|->
name|setBindingAndType
argument_list|(
name|llvm
operator|::
name|ELF
operator|::
name|STB_LOCAL
argument_list|,
name|llvm
operator|::
name|ELF
operator|::
name|STT_SECTION
argument_list|)
block|;
name|sym
operator|->
name|st_other
operator|=
literal|0
block|;
name|sym
operator|->
name|st_shndx
operator|=
literal|0
block|;
name|sym
operator|->
name|st_value
operator|=
literal|0
block|;
name|sym
operator|->
name|st_size
operator|=
literal|0
block|;
name|auto
operator|*
name|newAtom
operator|=
name|createDefinedAtomAndAssignRelocations
argument_list|(
literal|""
argument_list|,
name|sectionName
argument_list|,
name|sym
argument_list|,
name|section
argument_list|,
name|content
argument_list|,
name|content
argument_list|)
block|;
name|newAtom
operator|->
name|setOrdinal
argument_list|(
operator|++
name|_ordinal
argument_list|)
block|;
return|return
name|newAtom
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|uint64_t
name|ELFFile
operator|<
name|ELFT
operator|>
operator|::
name|symbolContentSize
argument_list|(
argument|const Elf_Shdr *section
argument_list|,
argument|const Elf_Sym *symbol
argument_list|,
argument|const Elf_Sym *nextSymbol
argument_list|)
block|{
specifier|const
name|auto
name|symValue
operator|=
name|getSymbolValue
argument_list|(
name|symbol
argument_list|)
block|;
comment|// if this is the last symbol, take up the remaining data.
return|return
name|nextSymbol
condition|?
name|getSymbolValue
argument_list|(
name|nextSymbol
argument_list|)
operator|-
name|symValue
else|:
name|section
operator|->
name|sh_size
operator|-
name|symValue
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|void
name|ELFFile
operator|<
name|ELFT
operator|>
operator|::
name|createEdge
argument_list|(
argument|ELFDefinedAtom<ELFT> *from
argument_list|,
argument|ELFDefinedAtom<ELFT> *to
argument_list|,
argument|uint32_t edgeKind
argument_list|)
block|{
name|auto
name|reference
operator|=
name|new
argument_list|(
argument|_readerStorage
argument_list|)
name|ELFReference
operator|<
name|ELFT
operator|>
operator|(
name|edgeKind
operator|)
block|;
name|reference
operator|->
name|setTarget
argument_list|(
name|to
argument_list|)
block|;
name|from
operator|->
name|addReference
argument_list|(
name|reference
argument_list|)
block|; }
comment|/// Does the atom need to be redirected using a separate undefined atom?
name|template
operator|<
name|class
name|ELFT
operator|>
name|bool
name|ELFFile
operator|<
name|ELFT
operator|>
operator|::
name|redirectReferenceUsingUndefAtom
argument_list|(
argument|const Elf_Sym *sourceSymbol
argument_list|,
argument|const Elf_Sym *targetSymbol
argument_list|)
specifier|const
block|{
name|auto
name|groupChildTarget
operator|=
name|_groupChild
operator|.
name|find
argument_list|(
name|targetSymbol
argument_list|)
block|;
comment|// If the reference is not to a group child atom, there is no need to redirect
comment|// using a undefined atom. Its also not needed if the source and target are
comment|// from the same section.
if|if
condition|(
operator|(
name|groupChildTarget
operator|==
name|_groupChild
operator|.
name|end
argument_list|()
operator|)
operator|||
operator|(
name|sourceSymbol
operator|->
name|st_shndx
operator|==
name|targetSymbol
operator|->
name|st_shndx
operator|)
condition|)
return|return
name|false
return|;
name|auto
name|groupChildSource
operator|=
name|_groupChild
operator|.
name|find
argument_list|(
name|sourceSymbol
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// If the source symbol is not in a group, use a undefined symbol too.
end_comment

begin_if
if|if
condition|(
name|groupChildSource
operator|==
name|_groupChild
operator|.
name|end
argument_list|()
condition|)
return|return
name|true
return|;
end_if

begin_comment
comment|// If the source and child are from the same group, we dont need the
end_comment

begin_comment
comment|// relocation to go through a undefined symbol.
end_comment

begin_if
if|if
condition|(
name|groupChildSource
operator|->
name|second
operator|.
name|second
operator|==
name|groupChildTarget
operator|->
name|second
operator|.
name|second
condition|)
return|return
name|false
return|;
end_if

begin_return
return|return
name|true
return|;
end_return

begin_comment
unit|}  }
comment|// end namespace elf
end_comment

begin_comment
unit|}
comment|// end namespace lld
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLD_READER_WRITER_ELF_FILE_H
end_comment

end_unit

