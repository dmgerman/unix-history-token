begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- lib/ReaderWriter/ELF/SegmentChunks.h -------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                             The LLVM Linker
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLD_READER_WRITER_ELF_SEGMENT_CHUNKS_H
end_ifndef

begin_define
define|#
directive|define
name|LLD_READER_WRITER_ELF_SEGMENT_CHUNKS_H
end_define

begin_include
include|#
directive|include
file|"Chunk.h"
end_include

begin_include
include|#
directive|include
file|"Layout.h"
end_include

begin_include
include|#
directive|include
file|"SectionChunks.h"
end_include

begin_include
include|#
directive|include
file|"Writer.h"
end_include

begin_include
include|#
directive|include
file|"lld/Core/range.h"
end_include

begin_include
include|#
directive|include
file|"lld/Core/Writer.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Object/ELF.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Allocator.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Debug.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ELF.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/FileOutputBuffer.h"
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_decl_stmt
name|namespace
name|lld
block|{
name|namespace
name|elf
block|{
name|template
operator|<
name|typename
name|ELFT
operator|>
name|class
name|DefaultLayout
expr_stmt|;
comment|/// \brief A segment can be divided into segment slices
comment|///        depending on how the segments can be split
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|SegmentSlice
block|{
name|public
operator|:
typedef|typedef
name|typename
name|std
operator|::
name|vector
operator|<
name|Chunk
operator|<
name|ELFT
operator|>
operator|*
operator|>
operator|::
name|iterator
name|SectionIter
expr_stmt|;
name|SegmentSlice
argument_list|()
block|{ }
comment|/// Set the start of the slice.
name|void
name|setStart
argument_list|(
argument|int32_t s
argument_list|)
block|{
name|_startSection
operator|=
name|s
block|; }
comment|// Set the segment slice start and end iterators. This is used to walk through
comment|// the sections that are part of the Segment slice
name|void
name|setSections
argument_list|(
argument|range<SectionIter> sections
argument_list|)
block|{
name|_sections
operator|=
name|sections
block|; }
comment|// Return the fileOffset of the slice
name|uint64_t
name|fileOffset
argument_list|()
specifier|const
block|{
return|return
name|_offset
return|;
block|}
name|void
name|setFileOffset
parameter_list|(
name|uint64_t
name|offset
parameter_list|)
block|{
name|_offset
operator|=
name|offset
expr_stmt|;
block|}
comment|// Return the size of the slice
name|uint64_t
name|fileSize
argument_list|()
specifier|const
block|{
return|return
name|_fsize
return|;
block|}
name|void
name|setFileSize
parameter_list|(
name|uint64_t
name|filesz
parameter_list|)
block|{
name|_fsize
operator|=
name|filesz
expr_stmt|;
block|}
comment|// Return the start of the slice
name|int32_t
name|startSection
argument_list|()
specifier|const
block|{
return|return
name|_startSection
return|;
block|}
comment|// Return the start address of the slice
name|uint64_t
name|virtualAddr
argument_list|()
specifier|const
block|{
return|return
name|_addr
return|;
block|}
comment|// Return the memory size of the slice
name|uint64_t
name|memSize
argument_list|()
specifier|const
block|{
return|return
name|_memSize
return|;
block|}
comment|// Return the alignment of the slice
name|uint64_t
name|alignment
argument_list|()
specifier|const
block|{
return|return
name|_alignment
return|;
block|}
name|void
name|setMemSize
parameter_list|(
name|uint64_t
name|memsz
parameter_list|)
block|{
name|_memSize
operator|=
name|memsz
expr_stmt|;
block|}
name|void
name|setVirtualAddr
parameter_list|(
name|uint64_t
name|addr
parameter_list|)
block|{
name|_addr
operator|=
name|addr
expr_stmt|;
block|}
name|void
name|setAlign
parameter_list|(
name|uint64_t
name|align
parameter_list|)
block|{
name|_alignment
operator|=
name|align
expr_stmt|;
block|}
specifier|static
name|bool
name|compare_slices
argument_list|(
name|SegmentSlice
operator|<
name|ELFT
operator|>
operator|*
name|a
argument_list|,
name|SegmentSlice
operator|<
name|ELFT
operator|>
operator|*
name|b
argument_list|)
block|{
return|return
name|a
operator|->
name|startSection
argument_list|()
operator|<
name|b
operator|->
name|startSection
argument_list|()
return|;
block|}
name|range
operator|<
name|SectionIter
operator|>
name|sections
argument_list|()
block|{
return|return
name|_sections
return|;
block|}
name|private
label|:
name|range
operator|<
name|SectionIter
operator|>
name|_sections
expr_stmt|;
name|int32_t
name|_startSection
decl_stmt|;
name|uint64_t
name|_addr
decl_stmt|;
name|uint64_t
name|_offset
decl_stmt|;
name|uint64_t
name|_alignment
decl_stmt|;
name|uint64_t
name|_fsize
decl_stmt|;
name|uint64_t
name|_memSize
decl_stmt|;
block|}
empty_stmt|;
comment|/// \brief A segment contains a set of sections, that have similar properties
comment|//  the sections are already separated based on different flags and properties
comment|//  the segment is just a way to concatenate sections to segments
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|Segment
operator|:
name|public
name|Chunk
operator|<
name|ELFT
operator|>
block|{
name|public
operator|:
typedef|typedef
name|typename
name|std
operator|::
name|vector
operator|<
name|SegmentSlice
operator|<
name|ELFT
operator|>
operator|*
operator|>
operator|::
name|iterator
name|SliceIter
expr_stmt|;
typedef|typedef
name|typename
name|std
operator|::
name|vector
operator|<
name|Chunk
operator|<
name|ELFT
operator|>
operator|*
operator|>
operator|::
name|iterator
name|SectionIter
expr_stmt|;
name|Segment
argument_list|(
argument|const ELFLinkingContext&context
argument_list|,
argument|StringRef name
argument_list|,
argument|const Layout::SegmentType type
argument_list|)
empty_stmt|;
comment|/// \brief the Order of segments that appear in the output file
enum|enum
name|SegmentOrder
block|{
name|permUnknown
block|,
name|permRWX
block|,
name|permRX
block|,
name|permR
block|,
name|permRWL
block|,
name|permRW
block|,
name|permNonAccess
block|}
enum|;
comment|/// append a section to a segment
name|virtual
name|void
name|append
argument_list|(
name|Chunk
operator|<
name|ELFT
operator|>
operator|*
name|chunk
argument_list|)
decl_stmt|;
comment|/// Sort segments depending on the property
comment|/// If we have a Program Header segment, it should appear first
comment|/// If we have a INTERP segment, that should appear after the Program Header
comment|/// All Loadable segments appear next in this order
comment|/// All Read Write Execute segments follow
comment|/// All Read Execute segments appear next
comment|/// All Read only segments appear first
comment|/// All Write execute segments follow
specifier|static
name|bool
name|compareSegments
argument_list|(
name|Segment
operator|<
name|ELFT
operator|>
operator|*
name|sega
argument_list|,
name|Segment
operator|<
name|ELFT
operator|>
operator|*
name|segb
argument_list|)
decl_stmt|;
comment|/// \brief Start assigning file offset to the segment chunks The fileoffset
comment|/// needs to be page at the start of the segment and in addition the
comment|/// fileoffset needs to be aligned to the max section alignment within the
comment|/// segment. This is required so that the ELF property p_poffset % p_align =
comment|/// p_vaddr mod p_align holds true.
comment|/// The algorithm starts off by assigning the startOffset thats passed in as
comment|/// parameter to the first section in the segment, if the difference between
comment|/// the newly computed offset is greater than a page, then we create a segment
comment|/// slice, as it would be a waste of virtual memory just to be filled with
comment|/// zeroes
name|void
name|assignFileOffsets
parameter_list|(
name|uint64_t
name|startOffset
parameter_list|)
function_decl|;
comment|/// \brief Assign virtual addresses to the slices
name|void
name|assignVirtualAddress
parameter_list|(
name|uint64_t
name|addr
parameter_list|)
function_decl|;
comment|// Write the Segment
name|void
name|write
argument_list|(
name|ELFWriter
operator|*
name|writer
argument_list|,
name|TargetLayout
operator|<
name|ELFT
operator|>
operator|&
name|layout
argument_list|,
name|llvm
operator|::
name|FileOutputBuffer
operator|&
name|buffer
argument_list|)
decl_stmt|;
name|int64_t
name|flags
argument_list|()
specifier|const
expr_stmt|;
comment|/// Prepend a generic chunk to the segment.
name|void
name|prepend
argument_list|(
name|Chunk
operator|<
name|ELFT
operator|>
operator|*
name|c
argument_list|)
block|{
name|_sections
operator|.
name|insert
argument_list|(
name|_sections
operator|.
name|begin
argument_list|()
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
comment|/// Finalize the segment before assigning File Offsets / Virtual addresses
name|void
name|doPreFlight
parameter_list|()
block|{}
comment|/// Finalize the segment, before we want to write the segment header
comment|/// information
name|void
name|finalize
parameter_list|()
block|{
comment|// We want to finalize the segment values for now only for non loadable
comment|// segments, since those values are not set in the Layout
if|if
condition|(
name|_segmentType
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|PT_LOAD
condition|)
return|return;
comment|// The size is the difference of the
comment|// last section to the first section, especially for TLS because
comment|// the TLS segment contains both .tdata/.tbss
name|this
operator|->
name|setFileOffset
argument_list|(
name|_sections
operator|.
name|front
argument_list|()
operator|->
name|fileOffset
argument_list|()
argument_list|)
expr_stmt|;
name|this
operator|->
name|setVirtualAddr
argument_list|(
name|_sections
operator|.
name|front
argument_list|()
operator|->
name|virtualAddr
argument_list|()
argument_list|)
expr_stmt|;
name|size_t
name|startFileOffset
init|=
name|_sections
operator|.
name|front
argument_list|()
operator|->
name|fileOffset
argument_list|()
decl_stmt|;
name|size_t
name|startAddr
init|=
name|_sections
operator|.
name|front
argument_list|()
operator|->
name|virtualAddr
argument_list|()
decl_stmt|;
for|for
control|(
name|auto
name|ai
range|:
name|_sections
control|)
block|{
name|this
operator|->
name|_fsize
operator|=
name|ai
operator|->
name|fileOffset
argument_list|()
operator|+
name|ai
operator|->
name|fileSize
argument_list|()
operator|-
name|startFileOffset
expr_stmt|;
name|this
operator|->
name|_msize
operator|=
name|ai
operator|->
name|virtualAddr
argument_list|()
operator|+
name|ai
operator|->
name|memSize
argument_list|()
operator|-
name|startAddr
expr_stmt|;
block|}
block|}
comment|// For LLVM RTTI
specifier|static
name|bool
name|classof
argument_list|(
specifier|const
name|Chunk
operator|<
name|ELFT
operator|>
operator|*
name|c
argument_list|)
block|{
return|return
name|c
operator|->
name|kind
argument_list|()
operator|==
name|Chunk
operator|<
name|ELFT
operator|>
operator|::
name|Kind
operator|::
name|ELFSegment
return|;
block|}
comment|// Getters
name|int32_t
name|sectionCount
argument_list|()
specifier|const
block|{
return|return
name|_sections
operator|.
name|size
argument_list|()
return|;
block|}
comment|/// \brief, this function returns the type of segment (PT_*)
name|Layout
operator|::
name|SegmentType
name|segmentType
argument_list|()
block|{
return|return
name|_segmentType
return|;
block|}
comment|/// \brief return the segment type depending on the content,
comment|/// If the content corresponds to Code, this will return Segment::Code
comment|/// If the content corresponds to Data, this will return Segment::Data
comment|/// If the content corresponds to TLS, this will return Segment::TLS
name|virtual
name|int
name|getContentType
argument_list|()
specifier|const
block|{
name|int64_t
name|fl
operator|=
name|flags
argument_list|()
block|;
switch|switch
condition|(
name|_segmentType
condition|)
block|{
case|case
name|llvm
operator|::
name|ELF
operator|::
name|PT_LOAD
case|:
block|{
if|if
condition|(
name|fl
operator|&&
name|llvm
operator|::
name|ELF
operator|::
name|PF_X
condition|)
return|return
name|Chunk
operator|<
name|ELFT
operator|>
operator|::
name|ContentType
operator|::
name|Code
return|;
if|if
condition|(
name|fl
operator|&&
name|llvm
operator|::
name|ELF
operator|::
name|PF_W
condition|)
return|return
name|Chunk
operator|<
name|ELFT
operator|>
operator|::
name|ContentType
operator|::
name|Data
return|;
block|}
case|case
name|llvm
operator|::
name|ELF
operator|::
name|PT_TLS
case|:
return|return
name|Chunk
operator|<
name|ELFT
operator|>
operator|::
name|ContentType
operator|::
name|TLS
return|;
case|case
name|llvm
operator|::
name|ELF
operator|::
name|PT_NOTE
case|:
return|return
name|Chunk
operator|<
name|ELFT
operator|>
operator|::
name|ContentType
operator|::
name|Note
return|;
default|default:
return|return
name|Chunk
operator|<
name|ELFT
operator|>
operator|::
name|ContentType
operator|::
name|Unknown
return|;
block|}
end_decl_stmt

begin_macro
unit|}    int
name|pageSize
argument_list|()
end_macro

begin_expr_stmt
specifier|const
block|{
return|return
name|this
operator|->
name|_context
operator|.
name|getPageSize
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|int
name|rawflags
argument_list|()
specifier|const
block|{
return|return
name|_atomflags
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|int64_t
name|atomflags
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|_atomflags
condition|)
block|{
case|case
name|DefinedAtom
operator|::
name|permUnknown
case|:
return|return
name|permUnknown
return|;
case|case
name|DefinedAtom
operator|::
name|permRWX
case|:
return|return
name|permRWX
return|;
case|case
name|DefinedAtom
operator|::
name|permR_X
case|:
return|return
name|permRX
return|;
case|case
name|DefinedAtom
operator|::
name|permR__
case|:
return|return
name|permR
return|;
case|case
name|DefinedAtom
operator|::
name|permRW_L
case|:
return|return
name|permRWL
return|;
case|case
name|DefinedAtom
operator|::
name|permRW_
case|:
return|return
name|permRW
return|;
case|case
name|DefinedAtom
operator|::
name|perm___
case|:
default|default:
return|return
name|permNonAccess
return|;
block|}
end_expr_stmt

begin_macro
unit|}    int64_t
name|numSlices
argument_list|()
end_macro

begin_expr_stmt
specifier|const
block|{
return|return
name|_segmentSlices
operator|.
name|size
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|range
operator|<
name|SliceIter
operator|>
name|slices
argument_list|()
block|{
return|return
name|_segmentSlices
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|Chunk
operator|<
name|ELFT
operator|>
operator|*
name|firstSection
argument_list|()
block|{
return|return
name|_sections
index|[
literal|0
index|]
return|;
block|}
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_comment
comment|/// \brief Check if the chunk needs to be aligned
end_comment

begin_decl_stmt
name|bool
name|needAlign
argument_list|(
name|Chunk
operator|<
name|ELFT
operator|>
operator|*
name|chunk
argument_list|)
decl|const
block|{
if|if
condition|(
name|chunk
operator|->
name|getContentType
argument_list|()
operator|==
name|Chunk
operator|<
name|ELFT
operator|>
operator|::
name|ContentType
operator|::
name|Data
operator|&&
name|_outputMagic
operator|==
name|ELFLinkingContext
operator|::
name|OutputMagic
operator|::
name|NMAGIC
condition|)
return|return
name|true
return|;
return|return
name|false
return|;
block|}
end_decl_stmt

begin_comment
comment|// Cached value of outputMagic
end_comment

begin_expr_stmt
name|ELFLinkingContext
operator|::
name|OutputMagic
name|_outputMagic
expr_stmt|;
end_expr_stmt

begin_label
name|protected
label|:
end_label

begin_comment
comment|/// \brief Section or some other chunk type.
end_comment

begin_expr_stmt
name|std
operator|::
name|vector
operator|<
name|Chunk
operator|<
name|ELFT
operator|>
operator|*
operator|>
name|_sections
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|vector
operator|<
name|SegmentSlice
operator|<
name|ELFT
operator|>
operator|*
operator|>
name|_segmentSlices
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Layout
operator|::
name|SegmentType
name|_segmentType
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|uint64_t
name|_flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int64_t
name|_atomflags
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|llvm
operator|::
name|BumpPtrAllocator
name|_segmentAllocate
expr_stmt|;
end_expr_stmt

begin_comment
unit|};
comment|/// This chunk represents a linker script expression that needs to be calculated
end_comment

begin_comment
comment|/// at the time the virtual addresses for the parent segment are being assigned.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|ExpressionChunk
operator|:
name|public
name|Chunk
operator|<
name|ELFT
operator|>
block|{
name|public
operator|:
name|ExpressionChunk
argument_list|(
name|ELFLinkingContext
operator|&
name|ctx
argument_list|,
specifier|const
name|script
operator|::
name|SymbolAssignment
operator|*
name|expr
argument_list|)
operator|:
name|Chunk
operator|<
name|ELFT
operator|>
operator|(
name|StringRef
argument_list|()
operator|,
name|Chunk
operator|<
name|ELFT
operator|>
operator|::
name|Kind
operator|::
name|Expression
operator|,
name|ctx
operator|)
block|,
name|_expr
argument_list|(
name|expr
argument_list|)
block|,
name|_linkerScriptSema
argument_list|(
argument|ctx.linkerScriptSema()
argument_list|)
block|{
name|this
operator|->
name|_alignment
operator|=
literal|1
block|;   }
specifier|static
name|bool
name|classof
argument_list|(
argument|const Chunk<ELFT> *c
argument_list|)
block|{
return|return
name|c
operator|->
name|kind
argument_list|()
operator|==
name|Chunk
operator|<
name|ELFT
operator|>
operator|::
name|Kind
operator|::
name|Expression
return|;
block|}
name|int
name|getContentType
argument_list|()
specifier|const
name|override
block|{
return|return
name|Chunk
operator|<
name|ELFT
operator|>
operator|::
name|ContentType
operator|::
name|Unknown
return|;
block|}
end_expr_stmt

begin_decl_stmt
name|void
name|write
argument_list|(
name|ELFWriter
operator|*
argument_list|,
name|TargetLayout
operator|<
name|ELFT
operator|>
operator|&
argument_list|,
name|llvm
operator|::
name|FileOutputBuffer
operator|&
argument_list|)
name|override
block|{}
end_decl_stmt

begin_function
name|void
name|doPreFlight
parameter_list|()
function|override
block|{}
end_function

begin_function
name|void
name|finalize
parameter_list|()
function|override
block|{}
end_function

begin_expr_stmt
name|std
operator|::
name|error_code
name|evalExpr
argument_list|(
argument|uint64_t&curPos
argument_list|)
block|{
return|return
name|_linkerScriptSema
operator|.
name|evalExpr
argument_list|(
name|_expr
argument_list|,
name|curPos
argument_list|)
return|;
block|}
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_expr_stmt
specifier|const
name|script
operator|::
name|SymbolAssignment
operator|*
name|_expr
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|script
operator|::
name|Sema
operator|&
name|_linkerScriptSema
expr_stmt|;
end_expr_stmt

begin_comment
unit|};
comment|/// \brief A Program Header segment contains a set of chunks instead of sections
end_comment

begin_comment
comment|/// The segment doesn't contain any slice
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|ProgramHeaderSegment
operator|:
name|public
name|Segment
operator|<
name|ELFT
operator|>
block|{
name|public
operator|:
name|ProgramHeaderSegment
argument_list|(
specifier|const
name|ELFLinkingContext
operator|&
name|context
argument_list|)
operator|:
name|Segment
operator|<
name|ELFT
operator|>
operator|(
name|context
operator|,
literal|"PHDR"
operator|,
name|llvm
operator|::
name|ELF
operator|::
name|PT_PHDR
operator|)
block|{
name|this
operator|->
name|_alignment
operator|=
literal|8
block|;
name|this
operator|->
name|_flags
operator|=
operator|(
name|llvm
operator|::
name|ELF
operator|::
name|SHF_ALLOC
operator||
name|llvm
operator|::
name|ELF
operator|::
name|SHF_EXECINSTR
operator|)
block|;   }
comment|/// Finalize the segment, before we want to write the segment header
comment|/// information
name|void
name|finalize
argument_list|()
block|{
comment|// If the segment is of type Program Header, then the values fileOffset
comment|// and the fileSize need to be picked up from the last section, the first
comment|// section points to the ELF header and the second chunk points to the
comment|// actual program headers
name|this
operator|->
name|setFileOffset
argument_list|(
name|this
operator|->
name|_sections
operator|.
name|back
argument_list|()
operator|->
name|fileOffset
argument_list|()
argument_list|)
block|;
name|this
operator|->
name|setVirtualAddr
argument_list|(
name|this
operator|->
name|_sections
operator|.
name|back
argument_list|()
operator|->
name|virtualAddr
argument_list|()
argument_list|)
block|;
name|this
operator|->
name|_fsize
operator|=
name|this
operator|->
name|_sections
operator|.
name|back
argument_list|()
operator|->
name|fileSize
argument_list|()
block|;
name|this
operator|->
name|_msize
operator|=
name|this
operator|->
name|_sections
operator|.
name|back
argument_list|()
operator|->
name|memSize
argument_list|()
block|;   }
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|Segment
operator|<
name|ELFT
operator|>
operator|::
name|Segment
argument_list|(
argument|const ELFLinkingContext&context
argument_list|,
argument|StringRef name
argument_list|,
argument|const Layout::SegmentType type
argument_list|)
operator|:
name|Chunk
operator|<
name|ELFT
operator|>
operator|(
name|name
operator|,
name|Chunk
operator|<
name|ELFT
operator|>
operator|::
name|Kind
operator|::
name|ELFSegment
operator|,
name|context
operator|)
operator|,
name|_segmentType
argument_list|(
name|type
argument_list|)
operator|,
name|_flags
argument_list|(
literal|0
argument_list|)
operator|,
name|_atomflags
argument_list|(
literal|0
argument_list|)
block|{
name|this
operator|->
name|_alignment
operator|=
literal|0
block|;
name|this
operator|->
name|_fsize
operator|=
literal|0
block|;
name|_outputMagic
operator|=
name|context
operator|.
name|getOutputMagic
argument_list|()
block|; }
comment|// This function actually is used, but not in all instantiations of Segment.
name|LLVM_ATTRIBUTE_UNUSED
specifier|static
name|DefinedAtom
operator|::
name|ContentPermissions
name|toAtomPerms
argument_list|(
argument|uint64_t flags
argument_list|)
block|{
switch|switch
condition|(
name|flags
operator|&
operator|(
name|SHF_ALLOC
operator||
name|SHF_WRITE
operator||
name|SHF_EXECINSTR
operator|)
condition|)
block|{
case|case
name|SHF_ALLOC
operator||
name|SHF_WRITE
operator||
name|SHF_EXECINSTR
case|:
return|return
name|DefinedAtom
operator|::
name|permRWX
return|;
case|case
name|SHF_ALLOC
operator||
name|SHF_EXECINSTR
case|:
return|return
name|DefinedAtom
operator|::
name|permR_X
return|;
case|case
name|SHF_ALLOC
case|:
return|return
name|DefinedAtom
operator|::
name|permR__
return|;
case|case
name|SHF_ALLOC
operator||
name|SHF_WRITE
case|:
return|return
name|DefinedAtom
operator|::
name|permRW_
return|;
default|default:
return|return
name|DefinedAtom
operator|::
name|permUnknown
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|void
name|Segment
operator|<
name|ELFT
operator|>
operator|::
name|append
argument_list|(
argument|Chunk<ELFT> *chunk
argument_list|)
block|{
name|_sections
operator|.
name|push_back
argument_list|(
name|chunk
argument_list|)
block|;
name|Section
operator|<
name|ELFT
operator|>
operator|*
name|section
operator|=
name|dyn_cast
operator|<
name|Section
operator|<
name|ELFT
operator|>>
operator|(
name|chunk
operator|)
block|;
if|if
condition|(
operator|!
name|section
condition|)
return|return;
end_expr_stmt

begin_if
if|if
condition|(
name|_flags
operator|<
name|section
operator|->
name|getFlags
argument_list|()
condition|)
name|_flags
operator||=
name|section
operator|->
name|getFlags
argument_list|()
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|_atomflags
operator|<
name|toAtomPerms
argument_list|(
name|_flags
argument_list|)
condition|)
name|_atomflags
operator|=
name|toAtomPerms
argument_list|(
name|_flags
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|this
operator|->
name|_alignment
operator|<
name|section
operator|->
name|alignment
argument_list|()
condition|)
name|this
operator|->
name|_alignment
operator|=
name|section
operator|->
name|alignment
argument_list|()
expr_stmt|;
end_if

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|bool
name|Segment
operator|<
name|ELFT
operator|>
operator|::
name|compareSegments
argument_list|(
argument|Segment<ELFT> *sega
argument_list|,
argument|Segment<ELFT> *segb
argument_list|)
block|{
name|int64_t
name|type1
operator|=
name|sega
operator|->
name|segmentType
argument_list|()
block|;
name|int64_t
name|type2
operator|=
name|segb
operator|->
name|segmentType
argument_list|()
block|;
if|if
condition|(
name|type1
operator|==
name|type2
condition|)
return|return
name|sega
operator|->
name|atomflags
argument_list|()
operator|<
name|segb
operator|->
name|atomflags
argument_list|()
return|;
end_expr_stmt

begin_comment
comment|// The single PT_PHDR segment is required to precede any loadable
end_comment

begin_comment
comment|// segment.  We simply make it always first.
end_comment

begin_if
if|if
condition|(
name|type1
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|PT_PHDR
condition|)
return|return
name|true
return|;
end_if

begin_if
if|if
condition|(
name|type2
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|PT_PHDR
condition|)
return|return
name|false
return|;
end_if

begin_comment
comment|// The single PT_INTERP segment is required to precede any loadable
end_comment

begin_comment
comment|// segment.  We simply make it always second.
end_comment

begin_if
if|if
condition|(
name|type1
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|PT_INTERP
condition|)
return|return
name|true
return|;
end_if

begin_if
if|if
condition|(
name|type2
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|PT_INTERP
condition|)
return|return
name|false
return|;
end_if

begin_comment
comment|// We then put PT_LOAD segments before any other segments.
end_comment

begin_if
if|if
condition|(
name|type1
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|PT_LOAD
condition|)
return|return
name|true
return|;
end_if

begin_if
if|if
condition|(
name|type2
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|PT_LOAD
condition|)
return|return
name|false
return|;
end_if

begin_comment
comment|// We put the PT_GNU_RELRO segment last, because that is where the
end_comment

begin_comment
comment|// dynamic linker expects to find it
end_comment

begin_if
if|if
condition|(
name|type1
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|PT_GNU_RELRO
condition|)
return|return
name|false
return|;
end_if

begin_if
if|if
condition|(
name|type2
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|PT_GNU_RELRO
condition|)
return|return
name|true
return|;
end_if

begin_comment
comment|// We put the PT_TLS segment last except for the PT_GNU_RELRO
end_comment

begin_comment
comment|// segment, because that is where the dynamic linker expects to find
end_comment

begin_if
if|if
condition|(
name|type1
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|PT_TLS
condition|)
return|return
name|false
return|;
end_if

begin_if
if|if
condition|(
name|type2
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|PT_TLS
condition|)
return|return
name|true
return|;
end_if

begin_comment
comment|// Otherwise compare the types to establish an arbitrary ordering.
end_comment

begin_comment
comment|// FIXME: Should figure out if we should just make all other types compare
end_comment

begin_comment
comment|// equal, but if so, we should probably do the same for atom flags and change
end_comment

begin_comment
comment|// users of this to use stable_sort.
end_comment

begin_return
return|return
name|type1
operator|<
name|type2
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|void
name|Segment
operator|<
name|ELFT
operator|>
operator|::
name|assignFileOffsets
argument_list|(
argument|uint64_t startOffset
argument_list|)
block|{
name|uint64_t
name|fileOffset
operator|=
name|startOffset
block|;
name|uint64_t
name|curSliceFileOffset
operator|=
name|fileOffset
block|;
name|bool
name|isDataPageAlignedForNMagic
operator|=
name|false
block|;
name|bool
name|alignSegments
operator|=
name|this
operator|->
name|_context
operator|.
name|alignSegments
argument_list|()
block|;
name|uint64_t
name|p_align
operator|=
name|this
operator|->
name|_context
operator|.
name|getPageSize
argument_list|()
block|;
name|uint64_t
name|lastVirtualAddress
operator|=
literal|0
block|;
name|this
operator|->
name|setFileOffset
argument_list|(
name|startOffset
argument_list|)
block|;
for|for
control|(
name|auto
operator|&
name|slice
operator|:
name|slices
argument_list|()
control|)
block|{
name|bool
name|isFirstSection
init|=
name|true
decl_stmt|;
for|for
control|(
name|auto
name|section
range|:
name|slice
operator|->
name|sections
argument_list|()
control|)
block|{
comment|// Handle linker script expressions, which may change the offset
if|if
condition|(
operator|!
name|isFirstSection
condition|)
if|if
condition|(
name|auto
name|expr
init|=
name|dyn_cast
operator|<
name|ExpressionChunk
operator|<
name|ELFT
operator|>>
operator|(
name|section
operator|)
condition|)
name|fileOffset
operator|+=
name|expr
operator|->
name|virtualAddr
argument_list|()
operator|-
name|lastVirtualAddress
expr_stmt|;
comment|// Align fileoffset to the alignment of the section.
name|fileOffset
operator|=
name|llvm
operator|::
name|RoundUpToAlignment
argument_list|(
name|fileOffset
argument_list|,
name|section
operator|->
name|alignment
argument_list|()
argument_list|)
expr_stmt|;
comment|// If the linker outputmagic is set to OutputMagic::NMAGIC, align the Data
comment|// to a page boundary
if|if
condition|(
name|isFirstSection
operator|&&
name|_outputMagic
operator|!=
name|ELFLinkingContext
operator|::
name|OutputMagic
operator|::
name|NMAGIC
operator|&&
name|_outputMagic
operator|!=
name|ELFLinkingContext
operator|::
name|OutputMagic
operator|::
name|OMAGIC
condition|)
block|{
comment|// Align to a page only if the output is not
comment|// OutputMagic::NMAGIC/OutputMagic::OMAGIC
if|if
condition|(
name|alignSegments
condition|)
name|fileOffset
operator|=
name|llvm
operator|::
name|RoundUpToAlignment
argument_list|(
name|fileOffset
argument_list|,
name|p_align
argument_list|)
expr_stmt|;
else|else
block|{
comment|// Align according to ELF spec.
comment|// in p75, http://www.sco.com/developers/devspecs/gabi41.pdf
name|uint64_t
name|virtualAddress
init|=
name|slice
operator|->
name|virtualAddr
argument_list|()
decl_stmt|;
name|Section
operator|<
name|ELFT
operator|>
operator|*
name|sect
operator|=
name|dyn_cast
operator|<
name|Section
operator|<
name|ELFT
operator|>>
operator|(
name|section
operator|)
expr_stmt|;
if|if
condition|(
name|sect
operator|&&
name|sect
operator|->
name|isLoadableSection
argument_list|()
operator|&&
operator|(
operator|(
name|virtualAddress
operator|&
operator|(
name|p_align
operator|-
literal|1
operator|)
operator|)
operator|!=
operator|(
name|fileOffset
operator|&
operator|(
name|p_align
operator|-
literal|1
operator|)
operator|)
operator|)
condition|)
name|fileOffset
operator|=
name|llvm
operator|::
name|RoundUpToAlignment
argument_list|(
name|fileOffset
argument_list|,
name|p_align
argument_list|)
operator|+
operator|(
name|virtualAddress
operator|%
name|p_align
operator|)
expr_stmt|;
block|}
end_expr_stmt

begin_if
unit|} else
if|if
condition|(
operator|!
name|isDataPageAlignedForNMagic
operator|&&
name|needAlign
argument_list|(
name|section
argument_list|)
condition|)
block|{
name|fileOffset
operator|=
name|llvm
operator|::
name|RoundUpToAlignment
argument_list|(
name|fileOffset
argument_list|,
name|this
operator|->
name|_context
operator|.
name|getPageSize
argument_list|()
argument_list|)
expr_stmt|;
name|isDataPageAlignedForNMagic
operator|=
name|true
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|isFirstSection
condition|)
block|{
name|slice
operator|->
name|setFileOffset
argument_list|(
name|fileOffset
argument_list|)
expr_stmt|;
name|isFirstSection
operator|=
name|false
expr_stmt|;
name|curSliceFileOffset
operator|=
name|fileOffset
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|section
operator|->
name|setFileOffset
argument_list|(
name|fileOffset
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|fileOffset
operator|+=
name|section
operator|->
name|fileSize
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|lastVirtualAddress
operator|=
name|section
operator|->
name|virtualAddr
argument_list|()
operator|+
name|section
operator|->
name|memSize
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}     slice
operator|->
name|setFileSize
argument_list|(
name|fileOffset
operator|-
name|curSliceFileOffset
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}   this
operator|->
name|setFileSize
argument_list|(
name|fileOffset
operator|-
name|startOffset
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/// \brief Assign virtual addresses to the slices
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|ELFT
operator|>
name|void
name|Segment
operator|<
name|ELFT
operator|>
operator|::
name|assignVirtualAddress
argument_list|(
argument|uint64_t addr
argument_list|)
block|{
name|int
name|startSection
operator|=
literal|0
block|;
name|int
name|currSection
operator|=
literal|0
block|;
name|SectionIter
name|startSectionIter
block|;
comment|// slice align is set to the max alignment of the chunks that are
comment|// contained in the slice
name|uint64_t
name|sliceAlign
operator|=
literal|0
block|;
comment|// Current slice size
name|uint64_t
name|curSliceSize
operator|=
literal|0
block|;
comment|// Current Slice File Offset
name|uint64_t
name|curSliceAddress
operator|=
literal|0
block|;
name|startSectionIter
operator|=
name|_sections
operator|.
name|begin
argument_list|()
block|;
name|startSection
operator|=
literal|0
block|;
name|bool
name|isFirstSection
operator|=
name|true
block|;
name|bool
name|isDataPageAlignedForNMagic
operator|=
name|false
block|;
name|uint64_t
name|startAddr
operator|=
name|addr
block|;
name|SegmentSlice
operator|<
name|ELFT
operator|>
operator|*
name|slice
operator|=
name|nullptr
block|;
name|uint64_t
name|tlsStartAddr
operator|=
literal|0
block|;
name|bool
name|alignSegments
operator|=
name|this
operator|->
name|_context
operator|.
name|alignSegments
argument_list|()
block|;
name|StringRef
name|prevOutputSectionName
operator|=
name|StringRef
argument_list|()
block|;
for|for
control|(
name|auto
name|si
init|=
name|_sections
operator|.
name|begin
argument_list|()
init|;
name|si
operator|!=
name|_sections
operator|.
name|end
argument_list|()
condition|;
operator|++
name|si
control|)
block|{
comment|// If this is first section in the segment, page align the section start
comment|// address. The linker needs to align the data section to a page boundary
comment|// only if NMAGIC is set.
if|if
condition|(
name|isFirstSection
condition|)
block|{
name|isFirstSection
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|alignSegments
operator|&&
name|_outputMagic
operator|!=
name|ELFLinkingContext
operator|::
name|OutputMagic
operator|::
name|NMAGIC
operator|&&
name|_outputMagic
operator|!=
name|ELFLinkingContext
operator|::
name|OutputMagic
operator|::
name|OMAGIC
condition|)
comment|// Align to a page only if the output is not
comment|// OutputMagic::NMAGIC/OutputMagic::OMAGIC
name|startAddr
operator|=
name|llvm
operator|::
name|RoundUpToAlignment
argument_list|(
name|startAddr
argument_list|,
name|this
operator|->
name|_context
operator|.
name|getPageSize
argument_list|()
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|isDataPageAlignedForNMagic
operator|&&
name|needAlign
argument_list|(
operator|*
name|si
argument_list|)
condition|)
block|{
comment|// If the linker outputmagic is set to OutputMagic::NMAGIC, align the
comment|// Data to a page boundary.
name|startAddr
operator|=
name|llvm
operator|::
name|RoundUpToAlignment
argument_list|(
name|startAddr
argument_list|,
name|this
operator|->
name|_context
operator|.
name|getPageSize
argument_list|()
argument_list|)
expr_stmt|;
name|isDataPageAlignedForNMagic
operator|=
name|true
expr_stmt|;
block|}
comment|// align the startOffset to the section alignment
name|uint64_t
name|newAddr
operator|=
name|llvm
operator|::
name|RoundUpToAlignment
argument_list|(
name|startAddr
argument_list|,
operator|(
operator|*
name|si
operator|)
operator|->
name|alignment
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Handle linker script expressions, which *may update newAddr* if the
end_comment

begin_comment
comment|// expression assigns to "."
end_comment

begin_if
if|if
condition|(
name|auto
name|expr
init|=
name|dyn_cast
operator|<
name|ExpressionChunk
operator|<
name|ELFT
operator|>>
operator|(
operator|*
name|si
operator|)
condition|)
name|expr
operator|->
name|evalExpr
argument_list|(
name|newAddr
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|curSliceAddress
operator|=
name|newAddr
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|sliceAlign
operator|=
operator|(
operator|*
name|si
operator|)
operator|->
name|alignment
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
operator|*
name|si
operator|)
operator|->
name|setVirtualAddr
argument_list|(
name|curSliceAddress
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Handle TLS.
end_comment

begin_if
if|if
condition|(
name|auto
name|section
init|=
name|dyn_cast
operator|<
name|Section
operator|<
name|ELFT
operator|>>
operator|(
operator|*
name|si
operator|)
condition|)
block|{
if|if
condition|(
name|section
operator|->
name|getSegmentType
argument_list|()
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|PT_TLS
condition|)
block|{
name|tlsStartAddr
operator|=
name|llvm
operator|::
name|RoundUpToAlignment
argument_list|(
name|tlsStartAddr
argument_list|,
operator|(
operator|*
name|si
operator|)
operator|->
name|alignment
argument_list|()
argument_list|)
expr_stmt|;
name|section
operator|->
name|assignVirtualAddress
argument_list|(
name|tlsStartAddr
argument_list|)
expr_stmt|;
name|tlsStartAddr
operator|+=
operator|(
operator|*
name|si
operator|)
operator|->
name|memSize
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|section
operator|->
name|assignVirtualAddress
argument_list|(
name|newAddr
argument_list|)
expr_stmt|;
block|}
block|}
end_if

begin_comment
comment|// TBSS section is special in that it doesn't contribute to memory of any
end_comment

begin_comment
comment|// segment. If we see a tbss section, don't add memory size to addr The
end_comment

begin_comment
comment|// fileOffset is automatically taken care of since TBSS section does not
end_comment

begin_comment
comment|// end up using file size
end_comment

begin_if
if|if
condition|(
operator|(
operator|*
name|si
operator|)
operator|->
name|order
argument_list|()
operator|!=
name|DefaultLayout
operator|<
name|ELFT
operator|>
operator|::
name|ORDER_TBSS
condition|)
name|curSliceSize
operator|=
operator|(
operator|*
name|si
operator|)
operator|->
name|memSize
argument_list|()
expr_stmt|;
end_if

begin_block
unit|} else
block|{
name|uint64_t
name|curAddr
init|=
name|curSliceAddress
operator|+
name|curSliceSize
decl_stmt|;
if|if
condition|(
operator|!
name|isDataPageAlignedForNMagic
operator|&&
name|needAlign
argument_list|(
operator|*
name|si
argument_list|)
condition|)
block|{
comment|// If the linker outputmagic is set to OutputMagic::NMAGIC, align the
comment|// Data
comment|// to a page boundary
name|curAddr
operator|=
name|llvm
operator|::
name|RoundUpToAlignment
argument_list|(
name|curAddr
argument_list|,
name|this
operator|->
name|_context
operator|.
name|getPageSize
argument_list|()
argument_list|)
expr_stmt|;
name|isDataPageAlignedForNMagic
operator|=
name|true
expr_stmt|;
block|}
name|uint64_t
name|newAddr
init|=
name|llvm
operator|::
name|RoundUpToAlignment
argument_list|(
name|curAddr
argument_list|,
operator|(
operator|*
name|si
operator|)
operator|->
name|alignment
argument_list|()
argument_list|)
decl_stmt|;
comment|// Handle linker script expressions, which *may update newAddr* if the
comment|// expression assigns to "."
if|if
condition|(
name|auto
name|expr
init|=
name|dyn_cast
operator|<
name|ExpressionChunk
operator|<
name|ELFT
operator|>>
operator|(
operator|*
name|si
operator|)
condition|)
name|expr
operator|->
name|evalExpr
argument_list|(
name|newAddr
argument_list|)
expr_stmt|;
name|Section
operator|<
name|ELFT
operator|>
operator|*
name|sec
operator|=
name|dyn_cast
operator|<
name|Section
operator|<
name|ELFT
operator|>>
operator|(
operator|*
name|si
operator|)
expr_stmt|;
name|StringRef
name|curOutputSectionName
decl_stmt|;
if|if
condition|(
name|sec
condition|)
name|curOutputSectionName
operator|=
name|sec
operator|->
name|outputSectionName
argument_list|()
expr_stmt|;
else|else
block|{
comment|// If this is a linker script expression, propagate the name of the
comment|// previous section instead
if|if
condition|(
name|isa
operator|<
name|ExpressionChunk
operator|<
name|ELFT
operator|>>
operator|(
operator|*
name|si
operator|)
condition|)
name|curOutputSectionName
operator|=
name|prevOutputSectionName
expr_stmt|;
else|else
name|curOutputSectionName
operator|=
operator|(
operator|*
name|si
operator|)
operator|->
name|name
argument_list|()
expr_stmt|;
block|}
name|bool
name|autoCreateSlice
init|=
name|true
decl_stmt|;
if|if
condition|(
name|curOutputSectionName
operator|==
name|prevOutputSectionName
condition|)
name|autoCreateSlice
operator|=
name|false
expr_stmt|;
comment|// If the newAddress computed is more than a page away, let's create
comment|// a separate segment, so that memory is not used up while running.
comment|// Dont create a slice, if the new section falls in the same output
comment|// section as the previous section.
if|if
condition|(
name|autoCreateSlice
operator|&&
operator|(
operator|(
name|newAddr
operator|-
name|curAddr
operator|)
operator|>
name|this
operator|->
name|_context
operator|.
name|getPageSize
argument_list|()
operator|)
operator|&&
operator|(
name|_outputMagic
operator|!=
name|ELFLinkingContext
operator|::
name|OutputMagic
operator|::
name|NMAGIC
operator|&&
name|_outputMagic
operator|!=
name|ELFLinkingContext
operator|::
name|OutputMagic
operator|::
name|OMAGIC
operator|)
condition|)
block|{
name|auto
name|sliceIter
init|=
name|std
operator|::
name|find_if
argument_list|(
argument|_segmentSlices.begin()
argument_list|,
argument|_segmentSlices.end()
argument_list|,
argument|[startSection](SegmentSlice<ELFT> *s) -> bool {               return s->startSection() == startSection;             }
argument_list|)
decl_stmt|;
if|if
condition|(
name|sliceIter
operator|==
name|_segmentSlices
operator|.
name|end
argument_list|()
condition|)
block|{
name|slice
operator|=
name|new
argument_list|(
argument|_segmentAllocate.Allocate<SegmentSlice<ELFT>>()
argument_list|)
name|SegmentSlice
operator|<
name|ELFT
operator|>
operator|(
operator|)
expr_stmt|;
name|_segmentSlices
operator|.
name|push_back
argument_list|(
name|slice
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|slice
operator|=
operator|(
operator|*
name|sliceIter
operator|)
expr_stmt|;
block|}
name|slice
operator|->
name|setStart
argument_list|(
name|startSection
argument_list|)
expr_stmt|;
name|slice
operator|->
name|setSections
argument_list|(
name|make_range
argument_list|(
name|startSectionIter
argument_list|,
name|si
argument_list|)
argument_list|)
expr_stmt|;
name|slice
operator|->
name|setMemSize
argument_list|(
name|curSliceSize
argument_list|)
expr_stmt|;
name|slice
operator|->
name|setAlign
argument_list|(
name|sliceAlign
argument_list|)
expr_stmt|;
name|slice
operator|->
name|setVirtualAddr
argument_list|(
name|curSliceAddress
argument_list|)
expr_stmt|;
comment|// Start new slice
name|curSliceAddress
operator|=
name|newAddr
expr_stmt|;
operator|(
operator|*
name|si
operator|)
operator|->
name|setVirtualAddr
argument_list|(
name|curSliceAddress
argument_list|)
expr_stmt|;
name|startSectionIter
operator|=
name|si
expr_stmt|;
name|startSection
operator|=
name|currSection
expr_stmt|;
if|if
condition|(
name|auto
name|section
init|=
name|dyn_cast
operator|<
name|Section
operator|<
name|ELFT
operator|>>
operator|(
operator|*
name|si
operator|)
condition|)
name|section
operator|->
name|assignVirtualAddress
argument_list|(
name|newAddr
argument_list|)
expr_stmt|;
name|curSliceSize
operator|=
name|newAddr
operator|-
name|curSliceAddress
operator|+
operator|(
operator|*
name|si
operator|)
operator|->
name|memSize
argument_list|()
expr_stmt|;
name|sliceAlign
operator|=
operator|(
operator|*
name|si
operator|)
operator|->
name|alignment
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|sliceAlign
operator|<
operator|(
operator|*
name|si
operator|)
operator|->
name|alignment
argument_list|()
condition|)
name|sliceAlign
operator|=
operator|(
operator|*
name|si
operator|)
operator|->
name|alignment
argument_list|()
expr_stmt|;
operator|(
operator|*
name|si
operator|)
operator|->
name|setVirtualAddr
argument_list|(
name|newAddr
argument_list|)
expr_stmt|;
comment|// Handle TLS.
if|if
condition|(
name|auto
name|section
init|=
name|dyn_cast
operator|<
name|Section
operator|<
name|ELFT
operator|>>
operator|(
operator|*
name|si
operator|)
condition|)
block|{
if|if
condition|(
name|section
operator|->
name|getSegmentType
argument_list|()
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|PT_TLS
condition|)
block|{
name|tlsStartAddr
operator|=
name|llvm
operator|::
name|RoundUpToAlignment
argument_list|(
name|tlsStartAddr
argument_list|,
operator|(
operator|*
name|si
operator|)
operator|->
name|alignment
argument_list|()
argument_list|)
expr_stmt|;
name|section
operator|->
name|assignVirtualAddress
argument_list|(
name|tlsStartAddr
argument_list|)
expr_stmt|;
name|tlsStartAddr
operator|+=
operator|(
operator|*
name|si
operator|)
operator|->
name|memSize
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|section
operator|->
name|assignVirtualAddress
argument_list|(
name|newAddr
argument_list|)
expr_stmt|;
block|}
block|}
comment|// TBSS section is special in that it doesn't contribute to memory of
comment|// any segment. If we see a tbss section, don't add memory size to addr
comment|// The fileOffset is automatically taken care of since TBSS section does
comment|// not end up using file size.
if|if
condition|(
operator|(
operator|*
name|si
operator|)
operator|->
name|order
argument_list|()
operator|!=
name|DefaultLayout
operator|<
name|ELFT
operator|>
operator|::
name|ORDER_TBSS
condition|)
name|curSliceSize
operator|=
name|newAddr
operator|-
name|curSliceAddress
operator|+
operator|(
operator|*
name|si
operator|)
operator|->
name|memSize
argument_list|()
expr_stmt|;
else|else
name|curSliceSize
operator|=
name|newAddr
operator|-
name|curSliceAddress
expr_stmt|;
block|}
name|prevOutputSectionName
operator|=
name|curOutputSectionName
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|currSection
operator|++
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}   auto
name|sliceIter
operator|=
name|std
operator|::
name|find_if
argument_list|(
argument|_segmentSlices.begin()
argument_list|,
argument|_segmentSlices.end()
argument_list|,
argument|[startSection](SegmentSlice<ELFT> *s) -> bool {     return s->startSection() == startSection;   }
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|sliceIter
operator|==
name|_segmentSlices
operator|.
name|end
argument_list|()
condition|)
block|{
name|slice
operator|=
name|new
argument_list|(
argument|_segmentAllocate.Allocate<SegmentSlice<ELFT>>()
argument_list|)
name|SegmentSlice
operator|<
name|ELFT
operator|>
operator|(
operator|)
expr_stmt|;
name|_segmentSlices
operator|.
name|push_back
argument_list|(
name|slice
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|slice
operator|=
operator|(
operator|*
name|sliceIter
operator|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|slice
operator|->
name|setStart
argument_list|(
name|startSection
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|slice
operator|->
name|setVirtualAddr
argument_list|(
name|curSliceAddress
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|slice
operator|->
name|setMemSize
argument_list|(
name|curSliceSize
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|slice
operator|->
name|setSections
argument_list|(
name|make_range
argument_list|(
name|startSectionIter
argument_list|,
name|_sections
operator|.
name|end
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|slice
operator|->
name|setAlign
argument_list|(
name|sliceAlign
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Set the segment memory size and the virtual address.
end_comment

begin_expr_stmt
name|this
operator|->
name|setMemSize
argument_list|(
name|curSliceAddress
operator|-
name|startAddr
operator|+
name|curSliceSize
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|this
operator|->
name|setVirtualAddr
argument_list|(
name|curSliceAddress
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|stable_sort
argument_list|(
name|_segmentSlices
operator|.
name|begin
argument_list|()
argument_list|,
name|_segmentSlices
operator|.
name|end
argument_list|()
argument_list|,
name|SegmentSlice
operator|<
name|ELFT
operator|>
operator|::
name|compare_slices
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|// Write the Segment
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|ELFT
operator|>
name|void
name|Segment
operator|<
name|ELFT
operator|>
operator|::
name|write
argument_list|(
argument|ELFWriter *writer
argument_list|,
argument|TargetLayout<ELFT>&layout
argument_list|,
argument|llvm::FileOutputBuffer&buffer
argument_list|)
block|{
for|for
control|(
name|auto
name|slice
range|:
name|slices
argument_list|()
control|)
for|for
control|(
name|auto
name|section
range|:
name|slice
operator|->
name|sections
argument_list|()
control|)
name|section
operator|->
name|write
argument_list|(
name|writer
argument_list|,
name|layout
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|int64_t
name|Segment
operator|<
name|ELFT
operator|>
operator|::
name|flags
argument_list|()
specifier|const
block|{
name|int64_t
name|fl
operator|=
literal|0
block|;
if|if
condition|(
name|_flags
operator|&
name|llvm
operator|::
name|ELF
operator|::
name|SHF_ALLOC
condition|)
name|fl
operator||=
name|llvm
operator|::
name|ELF
operator|::
name|PF_R
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|_flags
operator|&
name|llvm
operator|::
name|ELF
operator|::
name|SHF_WRITE
condition|)
name|fl
operator||=
name|llvm
operator|::
name|ELF
operator|::
name|PF_W
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|_flags
operator|&
name|llvm
operator|::
name|ELF
operator|::
name|SHF_EXECINSTR
condition|)
name|fl
operator||=
name|llvm
operator|::
name|ELF
operator|::
name|PF_X
expr_stmt|;
end_if

begin_return
return|return
name|fl
return|;
end_return

begin_comment
unit|} }
comment|// end namespace elf
end_comment

begin_comment
unit|}
comment|// end namespace lld
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

