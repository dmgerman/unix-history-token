begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- lib/ReaderWriter/ELF/OutputELFWriter.h ----------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                             The LLVM Linker
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLD_READER_WRITER_ELF_OUTPUT_WRITER_H
end_ifndef

begin_define
define|#
directive|define
name|LLD_READER_WRITER_ELF_OUTPUT_WRITER_H
end_define

begin_include
include|#
directive|include
file|"DefaultLayout.h"
end_include

begin_include
include|#
directive|include
file|"ELFFile.h"
end_include

begin_include
include|#
directive|include
file|"TargetLayout.h"
end_include

begin_include
include|#
directive|include
file|"lld/Core/Instrumentation.h"
end_include

begin_include
include|#
directive|include
file|"lld/Core/Parallel.h"
end_include

begin_include
include|#
directive|include
file|"lld/Core/SharedLibraryFile.h"
end_include

begin_include
include|#
directive|include
file|"lld/ReaderWriter/ELFLinkingContext.h"
end_include

begin_include
include|#
directive|include
file|"lld/Core/Simple.h"
end_include

begin_include
include|#
directive|include
file|"lld/Core/Writer.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/Optional.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Path.h"
end_include

begin_decl_stmt
name|namespace
name|lld
block|{
name|namespace
name|elf
block|{
name|using
name|namespace
name|llvm
decl_stmt|;
name|using
name|namespace
name|llvm
operator|::
name|object
expr_stmt|;
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|OutputELFWriter
expr_stmt|;
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|TargetLayout
expr_stmt|;
name|namespace
block|{
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|SymbolFile
operator|:
name|public
name|RuntimeFile
operator|<
name|ELFT
operator|>
block|{
name|public
operator|:
name|SymbolFile
argument_list|(
name|ELFLinkingContext
operator|&
name|context
argument_list|)
operator|:
name|RuntimeFile
operator|<
name|ELFT
operator|>
operator|(
name|context
operator|,
literal|"Dynamic absolute symbols"
operator|)
block|,
name|_atomsAdded
argument_list|(
argument|false
argument_list|)
block|{}
name|Atom
operator|*
name|addAbsoluteAtom
argument_list|(
argument|StringRef symbolName
argument_list|)
name|override
block|{
name|auto
operator|*
name|a
operator|=
name|RuntimeFile
operator|<
name|ELFT
operator|>
operator|::
name|addAbsoluteAtom
argument_list|(
name|symbolName
argument_list|)
block|;
if|if
condition|(
name|a
condition|)
name|_atomsAdded
operator|=
name|true
expr_stmt|;
return|return
name|a
return|;
block|}
name|Atom
modifier|*
name|addUndefinedAtom
parameter_list|(
name|StringRef
parameter_list|)
function|override
block|{
name|llvm_unreachable
argument_list|(
literal|"Cannot add undefined atoms to resolve undefined symbols"
argument_list|)
expr_stmt|;
block|}
name|bool
name|hasAtoms
argument_list|()
specifier|const
block|{
return|return
name|_atomsAdded
return|;
block|}
name|private
label|:
name|bool
name|_atomsAdded
decl_stmt|;
block|}
empty_stmt|;
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|DynamicSymbolFile
operator|:
name|public
name|SimpleArchiveLibraryFile
block|{
typedef|typedef
name|std
operator|::
name|function
operator|<
name|void
argument_list|(
name|StringRef
argument_list|,
name|RuntimeFile
operator|<
name|ELFT
operator|>
operator|&
argument_list|)
operator|>
name|Resolver
expr_stmt|;
name|public
operator|:
name|DynamicSymbolFile
argument_list|(
argument|ELFLinkingContext&context
argument_list|,
argument|Resolver resolver
argument_list|)
operator|:
name|SimpleArchiveLibraryFile
argument_list|(
literal|"Dynamically added runtime symbols"
argument_list|)
operator|,
name|_context
argument_list|(
name|context
argument_list|)
operator|,
name|_resolver
argument_list|(
argument|resolver
argument_list|)
block|{}
name|File
operator|*
name|find
argument_list|(
argument|StringRef sym
argument_list|,
argument|bool dataSymbolOnly
argument_list|)
name|override
block|{
if|if
condition|(
operator|!
name|_file
condition|)
name|_file
operator|.
name|reset
argument_list|(
name|new
argument_list|(
argument|_alloc
argument_list|)
name|SymbolFile
operator|<
name|ELFT
operator|>
operator|(
name|_context
operator|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|!
name|_file
operator|->
name|hasAtoms
argument_list|()
operator|&&
literal|"The file shouldn't have atoms yet"
argument_list|)
expr_stmt|;
name|_resolver
argument_list|(
name|sym
argument_list|,
operator|*
name|_file
argument_list|)
expr_stmt|;
comment|// If atoms were added - release the file to the caller.
return|return
name|_file
operator|->
name|hasAtoms
argument_list|()
condition|?
name|_file
operator|.
name|release
argument_list|()
else|:
name|nullptr
return|;
block|}
name|private
label|:
name|ELFLinkingContext
modifier|&
name|_context
decl_stmt|;
name|Resolver
name|_resolver
decl_stmt|;
comment|// The allocator should go before bump pointers because of
comment|// reversed destruction order.
name|llvm
operator|::
name|BumpPtrAllocator
name|_alloc
expr_stmt|;
name|unique_bump_ptr
operator|<
name|SymbolFile
operator|<
name|ELFT
operator|>>
name|_file
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// end anon namespace
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//  OutputELFWriter Class
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|/// \brief This acts as the base class for all the ELF writers that are output
end_comment

begin_comment
comment|/// for emitting an ELF output file. This class also acts as a common class for
end_comment

begin_comment
comment|/// creating static and dynamic executables. All the function in this class
end_comment

begin_comment
comment|/// can be overridden and an appropriate writer be created
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|OutputELFWriter
operator|:
name|public
name|ELFWriter
block|{
name|public
operator|:
typedef|typedef
name|Elf_Shdr_Impl
operator|<
name|ELFT
operator|>
name|Elf_Shdr
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|Elf_Sym_Impl
operator|<
name|ELFT
operator|>
name|Elf_Sym
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|Elf_Dyn_Impl
operator|<
name|ELFT
operator|>
name|Elf_Dyn
expr_stmt|;
end_typedef

begin_expr_stmt
name|OutputELFWriter
argument_list|(
name|ELFLinkingContext
operator|&
name|context
argument_list|,
name|TargetLayout
operator|<
name|ELFT
operator|>
operator|&
name|layout
argument_list|)
expr_stmt|;
end_expr_stmt

begin_label
name|protected
label|:
end_label

begin_comment
comment|// build the sections that need to be created
end_comment

begin_function_decl
name|virtual
name|void
name|createDefaultSections
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|// Build all the output sections
end_comment

begin_decl_stmt
name|void
name|buildChunks
argument_list|(
specifier|const
name|File
operator|&
name|file
argument_list|)
name|override
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Build the output file
end_comment

begin_expr_stmt
name|virtual
name|std
operator|::
name|error_code
name|buildOutput
argument_list|(
specifier|const
name|File
operator|&
name|file
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Setup the ELF header.
end_comment

begin_expr_stmt
name|virtual
name|std
operator|::
name|error_code
name|setELFHeader
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Write the file to the path specified
end_comment

begin_expr_stmt
name|std
operator|::
name|error_code
name|writeFile
argument_list|(
argument|const File&File
argument_list|,
argument|StringRef path
argument_list|)
name|override
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Write to the output file.
end_comment

begin_expr_stmt
name|virtual
name|std
operator|::
name|error_code
name|writeOutput
argument_list|(
argument|const File&file
argument_list|,
argument|StringRef path
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Get the size of the output file that the linker would emit.
end_comment

begin_expr_stmt
name|virtual
name|uint64_t
name|outputFileSize
argument_list|()
specifier|const
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Build the atom to address map, this has to be called
end_comment

begin_comment
comment|// before applying relocations
end_comment

begin_function_decl
name|virtual
name|void
name|buildAtomToAddressMap
parameter_list|(
specifier|const
name|File
modifier|&
name|file
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Build the symbol table for static linking
end_comment

begin_function_decl
name|virtual
name|void
name|buildStaticSymbolTable
parameter_list|(
specifier|const
name|File
modifier|&
name|file
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Build the dynamic symbol table for dynamic linking
end_comment

begin_function_decl
name|virtual
name|void
name|buildDynamicSymbolTable
parameter_list|(
specifier|const
name|File
modifier|&
name|file
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|// Build the section header table
end_comment

begin_function_decl
name|virtual
name|void
name|buildSectionHeaderTable
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|// Assign sections that have no segments such as the symbol table,
end_comment

begin_comment
comment|// section header table, string table etc
end_comment

begin_function_decl
name|virtual
name|void
name|assignSectionsWithNoSegments
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|// Add default atoms that need to be present in the output file
end_comment

begin_function_decl
name|virtual
name|void
name|addDefaultAtoms
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|// Add any runtime files and their atoms to the output
end_comment

begin_decl_stmt
name|bool
name|createImplicitFiles
argument_list|(
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|unique_ptr
operator|<
name|File
operator|>>
operator|&
argument_list|)
name|override
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Finalize the default atom values
end_comment

begin_function_decl
name|virtual
name|void
name|finalizeDefaultAtomValues
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|// This is called by the write section to apply relocations
end_comment

begin_function
name|uint64_t
name|addressOfAtom
parameter_list|(
specifier|const
name|Atom
modifier|*
name|atom
parameter_list|)
function|override
block|{
name|auto
name|addr
init|=
name|_atomToAddressMap
operator|.
name|find
argument_list|(
name|atom
argument_list|)
decl_stmt|;
return|return
name|addr
operator|==
name|_atomToAddressMap
operator|.
name|end
argument_list|()
condition|?
literal|0
else|:
name|addr
operator|->
name|second
return|;
block|}
end_function

begin_comment
comment|// This is a hook for creating default dynamic entries
end_comment

begin_function
name|virtual
name|void
name|createDefaultDynamicEntries
parameter_list|()
block|{}
end_function

begin_comment
comment|/// \brief Create symbol table.
end_comment

begin_expr_stmt
name|virtual
name|unique_bump_ptr
operator|<
name|SymbolTable
operator|<
name|ELFT
operator|>>
name|createSymbolTable
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// \brief create dynamic table.
end_comment

begin_expr_stmt
name|virtual
name|unique_bump_ptr
operator|<
name|DynamicTable
operator|<
name|ELFT
operator|>>
name|createDynamicTable
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// \brief create dynamic symbol table.
end_comment

begin_expr_stmt
name|virtual
name|unique_bump_ptr
operator|<
name|DynamicSymbolTable
operator|<
name|ELFT
operator|>>
name|createDynamicSymbolTable
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// \brief Create entry in the dynamic symbols table for this atom.
end_comment

begin_decl_stmt
name|virtual
name|bool
name|isDynSymEntryRequired
argument_list|(
specifier|const
name|SharedLibraryAtom
operator|*
name|sla
argument_list|)
decl|const
block|{
return|return
name|_layout
operator|.
name|isReferencedByDefinedAtom
argument_list|(
name|sla
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/// \brief Create DT_NEEDED dynamic tage for the shared library.
end_comment

begin_decl_stmt
name|virtual
name|bool
name|isNeededTagRequired
argument_list|(
specifier|const
name|SharedLibraryAtom
operator|*
name|sla
argument_list|)
decl|const
block|{
return|return
name|false
return|;
block|}
end_decl_stmt

begin_comment
comment|/// \brief Process undefined symbols that left after resolution step.
end_comment

begin_decl_stmt
name|virtual
name|void
name|processUndefinedSymbol
argument_list|(
name|StringRef
name|symName
argument_list|,
name|RuntimeFile
operator|<
name|ELFT
operator|>
operator|&
name|file
argument_list|)
decl|const
block|{}
end_decl_stmt

begin_expr_stmt
name|llvm
operator|::
name|BumpPtrAllocator
name|_alloc
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|ELFLinkingContext
modifier|&
name|_context
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TargetHandler
operator|<
name|ELFT
operator|>
operator|&
name|_targetHandler
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|llvm
operator|::
name|DenseMap
operator|<
specifier|const
name|Atom
operator|*
operator|,
name|uint64_t
operator|>
name|AtomToAddress
expr_stmt|;
end_typedef

begin_decl_stmt
name|AtomToAddress
name|_atomToAddressMap
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TargetLayout
operator|<
name|ELFT
operator|>
operator|&
name|_layout
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|unique_bump_ptr
operator|<
name|ELFHeader
operator|<
name|ELFT
operator|>>
name|_elfHeader
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|unique_bump_ptr
operator|<
name|ProgramHeader
operator|<
name|ELFT
operator|>>
name|_programHeader
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|unique_bump_ptr
operator|<
name|SymbolTable
operator|<
name|ELFT
operator|>>
name|_symtab
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|unique_bump_ptr
operator|<
name|StringTable
operator|<
name|ELFT
operator|>>
name|_strtab
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|unique_bump_ptr
operator|<
name|StringTable
operator|<
name|ELFT
operator|>>
name|_shstrtab
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|unique_bump_ptr
operator|<
name|SectionHeader
operator|<
name|ELFT
operator|>>
name|_shdrtab
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|unique_bump_ptr
operator|<
name|EHFrameHeader
operator|<
name|ELFT
operator|>>
name|_ehFrameHeader
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// \name Dynamic sections.
end_comment

begin_comment
comment|/// @{
end_comment

begin_expr_stmt
name|unique_bump_ptr
operator|<
name|DynamicTable
operator|<
name|ELFT
operator|>>
name|_dynamicTable
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|unique_bump_ptr
operator|<
name|DynamicSymbolTable
operator|<
name|ELFT
operator|>>
name|_dynamicSymbolTable
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|unique_bump_ptr
operator|<
name|StringTable
operator|<
name|ELFT
operator|>>
name|_dynamicStringTable
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|unique_bump_ptr
operator|<
name|HashSection
operator|<
name|ELFT
operator|>>
name|_hashTable
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|llvm
operator|::
name|StringSet
operator|<
operator|>
name|_soNeeded
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// @}
end_comment

begin_expr_stmt
name|std
operator|::
name|unique_ptr
operator|<
name|RuntimeFile
operator|<
name|ELFT
operator|>>
name|_scriptFile
expr_stmt|;
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_function_decl
specifier|static
name|StringRef
name|maybeGetSOName
parameter_list|(
name|Node
modifier|*
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_comment
unit|};
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//  OutputELFWriter
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|OutputELFWriter
operator|<
name|ELFT
operator|>
operator|::
name|OutputELFWriter
argument_list|(
name|ELFLinkingContext
operator|&
name|context
argument_list|,
name|TargetLayout
operator|<
name|ELFT
operator|>
operator|&
name|layout
argument_list|)
operator|:
name|_context
argument_list|(
name|context
argument_list|)
operator|,
name|_targetHandler
argument_list|(
name|context
operator|.
name|getTargetHandler
operator|<
name|ELFT
operator|>
operator|(
operator|)
argument_list|)
operator|,
name|_layout
argument_list|(
name|layout
argument_list|)
operator|,
name|_scriptFile
argument_list|(
argument|new RuntimeFile<ELFT>(context,
literal|"Linker script runtime"
argument|)
argument_list|)
block|{}
name|template
operator|<
name|class
name|ELFT
operator|>
name|void
name|OutputELFWriter
operator|<
name|ELFT
operator|>
operator|::
name|buildChunks
argument_list|(
argument|const File&file
argument_list|)
block|{
name|ScopedTask
name|task
argument_list|(
name|getDefaultDomain
argument_list|()
argument_list|,
literal|"buildChunks"
argument_list|)
block|;
for|for
control|(
specifier|const
name|DefinedAtom
modifier|*
name|definedAtom
range|:
name|file
operator|.
name|defined
argument_list|()
control|)
block|{
name|DefinedAtom
operator|::
name|ContentType
name|contentType
operator|=
name|definedAtom
operator|->
name|contentType
argument_list|()
expr_stmt|;
comment|// Dont add COMDAT group atoms and GNU linkonce atoms, as they are used for
comment|// symbol resolution.
comment|// TODO: handle partial linking.
if|if
condition|(
name|contentType
operator|==
name|DefinedAtom
operator|::
name|typeGroupComdat
operator|||
name|contentType
operator|==
name|DefinedAtom
operator|::
name|typeGnuLinkOnce
condition|)
continue|continue;
name|_layout
operator|.
name|addAtom
argument_list|(
name|definedAtom
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_for
for|for
control|(
specifier|const
name|AbsoluteAtom
modifier|*
name|absoluteAtom
range|:
name|file
operator|.
name|absolute
argument_list|()
control|)
name|_layout
operator|.
name|addAtom
argument_list|(
name|absoluteAtom
argument_list|)
expr_stmt|;
end_for

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|void
name|OutputELFWriter
operator|<
name|ELFT
operator|>
operator|::
name|buildStaticSymbolTable
argument_list|(
argument|const File&file
argument_list|)
block|{
name|ScopedTask
name|task
argument_list|(
name|getDefaultDomain
argument_list|()
argument_list|,
literal|"buildStaticSymbolTable"
argument_list|)
block|;
for|for
control|(
name|auto
name|sec
range|:
name|_layout
operator|.
name|sections
argument_list|()
control|)
if|if
condition|(
name|auto
name|section
init|=
name|dyn_cast
operator|<
name|AtomSection
operator|<
name|ELFT
operator|>>
operator|(
name|sec
operator|)
condition|)
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|atom
range|:
name|section
operator|->
name|atoms
argument_list|()
control|)
name|_symtab
operator|->
name|addSymbol
argument_list|(
name|atom
operator|->
name|_atom
argument_list|,
name|section
operator|->
name|ordinal
argument_list|()
argument_list|,
name|atom
operator|->
name|_virtualAddr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|auto
operator|&
name|atom
operator|:
name|_layout
operator|.
name|absoluteAtoms
argument_list|()
control|)
name|_symtab
operator|->
name|addSymbol
argument_list|(
name|atom
operator|->
name|_atom
argument_list|,
name|ELF
operator|::
name|SHN_ABS
argument_list|,
name|atom
operator|->
name|_virtualAddr
argument_list|)
expr_stmt|;
end_for

begin_for
for|for
control|(
specifier|const
name|UndefinedAtom
modifier|*
name|a
range|:
name|file
operator|.
name|undefined
argument_list|()
control|)
name|_symtab
operator|->
name|addSymbol
argument_list|(
name|a
argument_list|,
name|ELF
operator|::
name|SHN_UNDEF
argument_list|)
expr_stmt|;
end_for

begin_comment
unit|}
comment|// Returns the DSO name for a given input file if it's a shared library
end_comment

begin_comment
comment|// file and not marked as --as-needed.
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|ELFT
operator|>
name|StringRef
name|OutputELFWriter
operator|<
name|ELFT
operator|>
operator|::
name|maybeGetSOName
argument_list|(
argument|Node *node
argument_list|)
block|{
if|if
condition|(
name|auto
operator|*
name|fnode
operator|=
name|dyn_cast
operator|<
name|FileNode
operator|>
operator|(
name|node
operator|)
condition|)
if|if
condition|(
operator|!
name|fnode
operator|->
name|asNeeded
argument_list|()
condition|)
if|if
condition|(
name|auto
operator|*
name|file
operator|=
name|dyn_cast
operator|<
name|SharedLibraryFile
operator|>
operator|(
name|fnode
operator|->
name|getFile
argument_list|()
operator|)
condition|)
return|return
name|file
operator|->
name|getDSOName
argument_list|()
return|;
end_expr_stmt

begin_return
return|return
literal|""
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|void
name|OutputELFWriter
operator|<
name|ELFT
operator|>
operator|::
name|buildDynamicSymbolTable
argument_list|(
argument|const File&file
argument_list|)
block|{
name|ScopedTask
name|task
argument_list|(
name|getDefaultDomain
argument_list|()
argument_list|,
literal|"buildDynamicSymbolTable"
argument_list|)
block|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|sla
range|:
name|file
operator|.
name|sharedLibrary
argument_list|()
control|)
block|{
if|if
condition|(
name|isDynSymEntryRequired
argument_list|(
name|sla
argument_list|)
condition|)
block|{
name|_dynamicSymbolTable
operator|->
name|addSymbol
argument_list|(
name|sla
argument_list|,
name|ELF
operator|::
name|SHN_UNDEF
argument_list|)
expr_stmt|;
name|_soNeeded
operator|.
name|insert
argument_list|(
name|sla
operator|->
name|loadName
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|isNeededTagRequired
argument_list|(
name|sla
argument_list|)
condition|)
name|_soNeeded
operator|.
name|insert
argument_list|(
name|sla
operator|->
name|loadName
argument_list|()
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
unit|}   for
operator|(
specifier|const
name|std
operator|::
name|unique_ptr
operator|<
name|Node
operator|>
operator|&
name|node
operator|:
name|_context
operator|.
name|getNodes
argument_list|()
operator|)
block|{
name|StringRef
name|soname
operator|=
name|maybeGetSOName
argument_list|(
name|node
operator|.
name|get
argument_list|()
argument_list|)
block|;
if|if
condition|(
operator|!
name|soname
operator|.
name|empty
argument_list|()
condition|)
name|_soNeeded
operator|.
name|insert
argument_list|(
name|soname
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_comment
comment|// Never mark the dynamic linker as DT_NEEDED
end_comment

begin_expr_stmt
name|_soNeeded
operator|.
name|erase
argument_list|(
name|sys
operator|::
name|path
operator|::
name|filename
argument_list|(
name|_context
operator|.
name|getInterpreter
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|loadName
range|:
name|_soNeeded
control|)
block|{
name|Elf_Dyn
name|dyn
decl_stmt|;
name|dyn
operator|.
name|d_tag
operator|=
name|DT_NEEDED
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|_dynamicStringTable
operator|->
name|addString
argument_list|(
name|loadName
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
name|_dynamicTable
operator|->
name|addEntry
argument_list|(
name|dyn
argument_list|)
expr_stmt|;
block|}
end_for

begin_decl_stmt
specifier|const
specifier|auto
modifier|&
name|rpathList
init|=
name|_context
operator|.
name|getRpathList
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
operator|!
name|rpathList
operator|.
name|empty
argument_list|()
condition|)
block|{
name|auto
name|rpath
init|=
name|new
argument_list|(
argument|_alloc
argument_list|)
name|std
operator|::
name|string
argument_list|(
name|join
argument_list|(
name|rpathList
operator|.
name|begin
argument_list|()
argument_list|,
name|rpathList
operator|.
name|end
argument_list|()
argument_list|,
literal|":"
argument_list|)
argument_list|)
decl_stmt|;
name|Elf_Dyn
name|dyn
decl_stmt|;
name|dyn
operator|.
name|d_tag
operator|=
name|DT_RPATH
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|_dynamicStringTable
operator|->
name|addString
argument_list|(
operator|*
name|rpath
argument_list|)
expr_stmt|;
name|_dynamicTable
operator|->
name|addEntry
argument_list|(
name|dyn
argument_list|)
expr_stmt|;
block|}
end_if

begin_decl_stmt
name|StringRef
name|soname
init|=
name|_context
operator|.
name|sharedObjectName
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
operator|!
name|soname
operator|.
name|empty
argument_list|()
operator|&&
name|_context
operator|.
name|getOutputELFType
argument_list|()
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|ET_DYN
condition|)
block|{
name|Elf_Dyn
name|dyn
decl_stmt|;
name|dyn
operator|.
name|d_tag
operator|=
name|DT_SONAME
expr_stmt|;
name|dyn
operator|.
name|d_un
operator|.
name|d_val
operator|=
name|_dynamicStringTable
operator|->
name|addString
argument_list|(
name|soname
argument_list|)
expr_stmt|;
name|_dynamicTable
operator|->
name|addEntry
argument_list|(
name|dyn
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|// The dynamic symbol table need to be sorted earlier because the hash
end_comment

begin_comment
comment|// table needs to be built using the dynamic symbol table. It would be
end_comment

begin_comment
comment|// late to sort the symbols due to that in finalize. In the dynamic symbol
end_comment

begin_comment
comment|// table finalize, we call the symbol table finalize and we don't want to
end_comment

begin_comment
comment|// sort again
end_comment

begin_expr_stmt
name|_dynamicSymbolTable
operator|->
name|sortSymbols
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Add the dynamic symbols into the hash table
end_comment

begin_expr_stmt
name|_dynamicSymbolTable
operator|->
name|addSymbolsToHashTable
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|void
name|OutputELFWriter
operator|<
name|ELFT
operator|>
operator|::
name|buildAtomToAddressMap
argument_list|(
argument|const File&file
argument_list|)
block|{
name|ScopedTask
name|task
argument_list|(
name|getDefaultDomain
argument_list|()
argument_list|,
literal|"buildAtomToAddressMap"
argument_list|)
block|;
name|int64_t
name|totalAbsAtoms
operator|=
name|_layout
operator|.
name|absoluteAtoms
argument_list|()
operator|.
name|size
argument_list|()
block|;
name|int64_t
name|totalUndefinedAtoms
operator|=
name|file
operator|.
name|undefined
argument_list|()
operator|.
name|size
argument_list|()
block|;
name|int64_t
name|totalDefinedAtoms
operator|=
literal|0
block|;
for|for
control|(
name|auto
name|sec
range|:
name|_layout
operator|.
name|sections
argument_list|()
control|)
if|if
condition|(
name|auto
name|section
init|=
name|dyn_cast
operator|<
name|AtomSection
operator|<
name|ELFT
operator|>
expr|>
operator|(
name|sec
operator|)
condition|)
block|{
name|totalDefinedAtoms
operator|+=
name|section
operator|->
name|atoms
argument_list|()
operator|.
name|size
argument_list|()
expr_stmt|;
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|atom
range|:
name|section
operator|->
name|atoms
argument_list|()
control|)
name|_atomToAddressMap
index|[
name|atom
operator|->
name|_atom
index|]
operator|=
name|atom
operator|->
name|_virtualAddr
expr_stmt|;
block|}
end_expr_stmt

begin_comment
comment|// build the atomToAddressMap that contains absolute symbols too
end_comment

begin_for
for|for
control|(
name|auto
operator|&
name|atom
operator|:
name|_layout
operator|.
name|absoluteAtoms
argument_list|()
control|)
name|_atomToAddressMap
index|[
name|atom
operator|->
name|_atom
index|]
operator|=
name|atom
operator|->
name|_virtualAddr
expr_stmt|;
end_for

begin_comment
comment|// Set the total number of atoms in the symbol table, so that appropriate
end_comment

begin_comment
comment|// resizing of the string table can be done
end_comment

begin_expr_stmt
name|_symtab
operator|->
name|setNumEntries
argument_list|(
name|totalDefinedAtoms
operator|+
name|totalAbsAtoms
operator|+
name|totalUndefinedAtoms
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|void
name|OutputELFWriter
operator|<
name|ELFT
operator|>
operator|::
name|buildSectionHeaderTable
argument_list|()
block|{
name|ScopedTask
name|task
argument_list|(
name|getDefaultDomain
argument_list|()
argument_list|,
literal|"buildSectionHeaderTable"
argument_list|)
block|;
for|for
control|(
name|auto
name|outputSection
range|:
name|_layout
operator|.
name|outputSections
argument_list|()
control|)
block|{
if|if
condition|(
name|outputSection
operator|->
name|kind
argument_list|()
operator|!=
name|Chunk
operator|<
name|ELFT
operator|>
operator|::
name|Kind
operator|::
name|ELFSection
operator|&&
name|outputSection
operator|->
name|kind
argument_list|()
operator|!=
name|Chunk
operator|<
name|ELFT
operator|>
operator|::
name|Kind
operator|::
name|AtomSection
condition|)
continue|continue;
if|if
condition|(
name|outputSection
operator|->
name|hasSegment
argument_list|()
condition|)
name|_shdrtab
operator|->
name|appendSection
argument_list|(
name|outputSection
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|void
name|OutputELFWriter
operator|<
name|ELFT
operator|>
operator|::
name|assignSectionsWithNoSegments
argument_list|()
block|{
name|ScopedTask
name|task
argument_list|(
name|getDefaultDomain
argument_list|()
argument_list|,
literal|"assignSectionsWithNoSegments"
argument_list|)
block|;
for|for
control|(
name|auto
name|outputSection
range|:
name|_layout
operator|.
name|outputSections
argument_list|()
control|)
block|{
if|if
condition|(
name|outputSection
operator|->
name|kind
argument_list|()
operator|!=
name|Chunk
operator|<
name|ELFT
operator|>
operator|::
name|Kind
operator|::
name|ELFSection
operator|&&
name|outputSection
operator|->
name|kind
argument_list|()
operator|!=
name|Chunk
operator|<
name|ELFT
operator|>
operator|::
name|Kind
operator|::
name|AtomSection
condition|)
continue|continue;
if|if
condition|(
operator|!
name|outputSection
operator|->
name|hasSegment
argument_list|()
condition|)
name|_shdrtab
operator|->
name|appendSection
argument_list|(
name|outputSection
argument_list|)
expr_stmt|;
block|}
name|_layout
operator|.
name|assignFileOffsetsForMiscSections
argument_list|()
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|auto
name|sec
range|:
name|_layout
operator|.
name|sections
argument_list|()
control|)
if|if
condition|(
name|auto
name|section
init|=
name|dyn_cast
operator|<
name|Section
operator|<
name|ELFT
operator|>>
operator|(
name|sec
operator|)
condition|)
if|if
condition|(
operator|!
name|DefaultLayout
operator|<
name|ELFT
operator|>
operator|::
name|hasOutputSegment
argument_list|(
name|section
argument_list|)
condition|)
name|_shdrtab
operator|->
name|updateSection
argument_list|(
name|section
argument_list|)
expr_stmt|;
end_for

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|void
name|OutputELFWriter
operator|<
name|ELFT
operator|>
operator|::
name|addDefaultAtoms
argument_list|()
block|{
specifier|const
name|llvm
operator|::
name|StringSet
operator|<
operator|>
operator|&
name|symbols
operator|=
name|_context
operator|.
name|linkerScriptSema
argument_list|()
operator|.
name|getScriptDefinedSymbols
argument_list|()
block|;
for|for
control|(
name|auto
operator|&
name|sym
operator|:
name|symbols
control|)
name|_scriptFile
operator|->
name|addAbsoluteAtom
argument_list|(
name|sym
operator|.
name|getKey
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|bool
name|OutputELFWriter
operator|<
name|ELFT
operator|>
operator|::
name|createImplicitFiles
argument_list|(
argument|std::vector<std::unique_ptr<File>>&result
argument_list|)
block|{
comment|// Add the virtual archive to resolve undefined symbols.
comment|// The file will be added later in the linking context.
name|auto
name|callback
operator|=
index|[
name|this
index|]
operator|(
name|StringRef
name|sym
operator|,
name|RuntimeFile
operator|<
name|ELFT
operator|>
operator|&
name|file
operator|)
block|{
name|processUndefinedSymbol
argument_list|(
name|sym
argument_list|,
name|file
argument_list|)
block|;   }
block|;
name|auto
operator|&
name|ctx
operator|=
name|const_cast
operator|<
name|ELFLinkingContext
operator|&
operator|>
operator|(
name|_context
operator|)
block|;
name|ctx
operator|.
name|setUndefinesResolver
argument_list|(
name|llvm
operator|::
name|make_unique
operator|<
name|DynamicSymbolFile
operator|<
name|ELFT
operator|>>
operator|(
name|ctx
operator|,
name|std
operator|::
name|move
argument_list|(
name|callback
argument_list|)
operator|)
argument_list|)
block|;
comment|// Add script defined symbols
name|result
operator|.
name|push_back
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|_scriptFile
argument_list|)
argument_list|)
block|;
return|return
name|true
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|void
name|OutputELFWriter
operator|<
name|ELFT
operator|>
operator|::
name|finalizeDefaultAtomValues
argument_list|()
block|{
specifier|const
name|llvm
operator|::
name|StringSet
operator|<
operator|>
operator|&
name|symbols
operator|=
name|_context
operator|.
name|linkerScriptSema
argument_list|()
operator|.
name|getScriptDefinedSymbols
argument_list|()
block|;
for|for
control|(
name|auto
operator|&
name|sym
operator|:
name|symbols
control|)
block|{
name|uint64_t
name|res
init|=
name|_context
operator|.
name|linkerScriptSema
argument_list|()
operator|.
name|getLinkerScriptExprValue
argument_list|(
name|sym
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
name|auto
name|a
init|=
name|_layout
operator|.
name|findAbsoluteAtom
argument_list|(
name|sym
operator|.
name|getKey
argument_list|()
argument_list|)
decl_stmt|;
operator|(
operator|*
name|a
operator|)
operator|->
name|_virtualAddr
operator|=
name|res
expr_stmt|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|void
name|OutputELFWriter
operator|<
name|ELFT
operator|>
operator|::
name|createDefaultSections
argument_list|()
block|{
name|_elfHeader
operator|.
name|reset
argument_list|(
name|new
argument_list|(
argument|_alloc
argument_list|)
name|ELFHeader
operator|<
name|ELFT
operator|>
operator|(
name|_context
operator|)
argument_list|)
block|;
name|_programHeader
operator|.
name|reset
argument_list|(
name|new
argument_list|(
argument|_alloc
argument_list|)
name|ProgramHeader
operator|<
name|ELFT
operator|>
operator|(
name|_context
operator|)
argument_list|)
block|;
name|_layout
operator|.
name|setHeader
argument_list|(
name|_elfHeader
operator|.
name|get
argument_list|()
argument_list|)
block|;
name|_layout
operator|.
name|setProgramHeader
argument_list|(
name|_programHeader
operator|.
name|get
argument_list|()
argument_list|)
block|;
name|_symtab
operator|=
name|std
operator|::
name|move
argument_list|(
name|this
operator|->
name|createSymbolTable
argument_list|()
argument_list|)
block|;
name|_strtab
operator|.
name|reset
argument_list|(
name|new
argument_list|(
argument|_alloc
argument_list|)
name|StringTable
operator|<
name|ELFT
operator|>
operator|(
name|_context
operator|,
literal|".strtab"
operator|,
name|DefaultLayout
operator|<
name|ELFT
operator|>
operator|::
name|ORDER_STRING_TABLE
operator|)
argument_list|)
block|;
name|_shstrtab
operator|.
name|reset
argument_list|(
name|new
argument_list|(
argument|_alloc
argument_list|)
name|StringTable
operator|<
name|ELFT
operator|>
operator|(
name|_context
operator|,
literal|".shstrtab"
operator|,
name|DefaultLayout
operator|<
name|ELFT
operator|>
operator|::
name|ORDER_SECTION_STRINGS
operator|)
argument_list|)
block|;
name|_shdrtab
operator|.
name|reset
argument_list|(
name|new
argument_list|(
argument|_alloc
argument_list|)
name|SectionHeader
operator|<
name|ELFT
operator|>
operator|(
name|_context
operator|,
name|DefaultLayout
operator|<
name|ELFT
operator|>
operator|::
name|ORDER_SECTION_HEADERS
operator|)
argument_list|)
block|;
name|_layout
operator|.
name|addSection
argument_list|(
name|_symtab
operator|.
name|get
argument_list|()
argument_list|)
block|;
name|_layout
operator|.
name|addSection
argument_list|(
name|_strtab
operator|.
name|get
argument_list|()
argument_list|)
block|;
name|_layout
operator|.
name|addSection
argument_list|(
name|_shstrtab
operator|.
name|get
argument_list|()
argument_list|)
block|;
name|_shdrtab
operator|->
name|setStringSection
argument_list|(
name|_shstrtab
operator|.
name|get
argument_list|()
argument_list|)
block|;
name|_symtab
operator|->
name|setStringSection
argument_list|(
name|_strtab
operator|.
name|get
argument_list|()
argument_list|)
block|;
name|_layout
operator|.
name|addSection
argument_list|(
name|_shdrtab
operator|.
name|get
argument_list|()
argument_list|)
block|;
for|for
control|(
name|auto
name|sec
range|:
name|_layout
operator|.
name|sections
argument_list|()
control|)
block|{
comment|// TODO: use findOutputSection
name|auto
name|section
init|=
name|dyn_cast
operator|<
name|Section
operator|<
name|ELFT
operator|>>
operator|(
name|sec
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|section
operator|||
name|section
operator|->
name|outputSectionName
argument_list|()
operator|!=
literal|".eh_frame"
condition|)
continue|continue;
name|_ehFrameHeader
operator|.
name|reset
argument_list|(
name|new
argument_list|(
argument|_alloc
argument_list|)
name|EHFrameHeader
operator|<
name|ELFT
operator|>
operator|(
name|_context
operator|,
literal|".eh_frame_hdr"
operator|,
name|_layout
operator|,
name|DefaultLayout
operator|<
name|ELFT
operator|>
operator|::
name|ORDER_EH_FRAMEHDR
operator|)
argument_list|)
expr_stmt|;
name|_layout
operator|.
name|addSection
argument_list|(
name|_ehFrameHeader
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|_context
operator|.
name|isDynamic
argument_list|()
condition|)
block|{
name|_dynamicTable
operator|=
name|std
operator|::
name|move
argument_list|(
name|createDynamicTable
argument_list|()
argument_list|)
expr_stmt|;
name|_dynamicStringTable
operator|.
name|reset
argument_list|(
name|new
argument_list|(
argument|_alloc
argument_list|)
name|StringTable
operator|<
name|ELFT
operator|>
operator|(
name|_context
operator|,
literal|".dynstr"
operator|,
name|DefaultLayout
operator|<
name|ELFT
operator|>
operator|::
name|ORDER_DYNAMIC_STRINGS
operator|,
name|true
operator|)
argument_list|)
expr_stmt|;
name|_dynamicSymbolTable
operator|=
name|std
operator|::
name|move
argument_list|(
name|createDynamicSymbolTable
argument_list|()
argument_list|)
expr_stmt|;
name|_hashTable
operator|.
name|reset
argument_list|(
name|new
argument_list|(
argument|_alloc
argument_list|)
name|HashSection
operator|<
name|ELFT
operator|>
operator|(
name|_context
operator|,
literal|".hash"
operator|,
name|DefaultLayout
operator|<
name|ELFT
operator|>
operator|::
name|ORDER_HASH
operator|)
argument_list|)
expr_stmt|;
comment|// Set the hash table in the dynamic symbol table so that the entries in the
comment|// hash table can be created
name|_dynamicSymbolTable
operator|->
name|setHashTable
argument_list|(
name|_hashTable
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|_hashTable
operator|->
name|setSymbolTable
argument_list|(
name|_dynamicSymbolTable
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|_layout
operator|.
name|addSection
argument_list|(
name|_dynamicTable
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|_layout
operator|.
name|addSection
argument_list|(
name|_dynamicStringTable
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|_layout
operator|.
name|addSection
argument_list|(
name|_dynamicSymbolTable
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|_layout
operator|.
name|addSection
argument_list|(
name|_hashTable
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|_dynamicSymbolTable
operator|->
name|setStringSection
argument_list|(
name|_dynamicStringTable
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|_dynamicTable
operator|->
name|setSymbolTable
argument_list|(
name|_dynamicSymbolTable
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
name|_dynamicTable
operator|->
name|setHashTable
argument_list|(
name|_hashTable
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|_layout
operator|.
name|hasDynamicRelocationTable
argument_list|()
condition|)
name|_layout
operator|.
name|getDynamicRelocationTable
argument_list|()
operator|->
name|setSymbolTable
argument_list|(
name|_dynamicSymbolTable
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|_layout
operator|.
name|hasPLTRelocationTable
argument_list|()
condition|)
name|_layout
operator|.
name|getPLTRelocationTable
argument_list|()
operator|->
name|setSymbolTable
argument_list|(
name|_dynamicSymbolTable
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|unique_bump_ptr
operator|<
name|SymbolTable
operator|<
name|ELFT
operator|>>
name|OutputELFWriter
operator|<
name|ELFT
operator|>
operator|::
name|createSymbolTable
argument_list|()
block|{
return|return
name|unique_bump_ptr
operator|<
name|SymbolTable
operator|<
name|ELFT
operator|>>
operator|(
name|new
argument_list|(
argument|_alloc
argument_list|)
name|SymbolTable
operator|<
name|ELFT
operator|>
operator|(
name|this
operator|->
name|_context
operator|,
literal|".symtab"
operator|,
name|DefaultLayout
operator|<
name|ELFT
operator|>
operator|::
name|ORDER_SYMBOL_TABLE
operator|)
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief create dynamic table
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|unique_bump_ptr
operator|<
name|DynamicTable
operator|<
name|ELFT
operator|>>
name|OutputELFWriter
operator|<
name|ELFT
operator|>
operator|::
name|createDynamicTable
argument_list|()
block|{
return|return
name|unique_bump_ptr
operator|<
name|DynamicTable
operator|<
name|ELFT
operator|>>
operator|(
name|new
argument_list|(
argument|_alloc
argument_list|)
name|DynamicTable
operator|<
name|ELFT
operator|>
operator|(
name|this
operator|->
name|_context
operator|,
name|_layout
operator|,
literal|".dynamic"
operator|,
name|DefaultLayout
operator|<
name|ELFT
operator|>
operator|::
name|ORDER_DYNAMIC
operator|)
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief create dynamic symbol table
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|unique_bump_ptr
operator|<
name|DynamicSymbolTable
operator|<
name|ELFT
operator|>>
name|OutputELFWriter
operator|<
name|ELFT
operator|>
operator|::
name|createDynamicSymbolTable
argument_list|()
block|{
return|return
name|unique_bump_ptr
operator|<
name|DynamicSymbolTable
operator|<
name|ELFT
operator|>>
operator|(
name|new
argument_list|(
argument|_alloc
argument_list|)
name|DynamicSymbolTable
operator|<
name|ELFT
operator|>
operator|(
name|this
operator|->
name|_context
operator|,
name|_layout
operator|,
literal|".dynsym"
operator|,
name|DefaultLayout
operator|<
name|ELFT
operator|>
operator|::
name|ORDER_DYNAMIC_SYMBOLS
operator|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|std
operator|::
name|error_code
name|OutputELFWriter
operator|<
name|ELFT
operator|>
operator|::
name|buildOutput
argument_list|(
argument|const File&file
argument_list|)
block|{
name|ScopedTask
name|buildTask
argument_list|(
name|getDefaultDomain
argument_list|()
argument_list|,
literal|"ELF Writer buildOutput"
argument_list|)
block|;
name|buildChunks
argument_list|(
name|file
argument_list|)
block|;
comment|// Create the default sections like the symbol table, string table, and the
comment|// section string table
name|createDefaultSections
argument_list|()
block|;
comment|// Set the Layout
name|_layout
operator|.
name|assignSectionsToSegments
argument_list|()
block|;
comment|// Create the dynamic table entries
if|if
condition|(
name|_context
operator|.
name|isDynamic
argument_list|()
condition|)
block|{
name|_dynamicTable
operator|->
name|createDefaultEntries
argument_list|()
expr_stmt|;
name|buildDynamicSymbolTable
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
comment|// Call the preFlight callbacks to modify the sections and the atoms
comment|// contained in them, in anyway the targets may want
name|_layout
operator|.
name|doPreFlight
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_layout
operator|.
name|assignVirtualAddress
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Finalize the default value of symbols that the linker adds
end_comment

begin_expr_stmt
name|finalizeDefaultAtomValues
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Build the Atom To Address map for applying relocations
end_comment

begin_expr_stmt
name|buildAtomToAddressMap
argument_list|(
name|file
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Create symbol table and section string table
end_comment

begin_comment
comment|// Do it only if -s is not specified.
end_comment

begin_if
if|if
condition|(
operator|!
name|_context
operator|.
name|stripSymbols
argument_list|()
condition|)
name|buildStaticSymbolTable
argument_list|(
name|file
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|// Finalize the layout by calling the finalize() functions
end_comment

begin_expr_stmt
name|_layout
operator|.
name|finalize
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|// build Section Header table
end_comment

begin_expr_stmt
name|buildSectionHeaderTable
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|// assign Offsets and virtual addresses
end_comment

begin_comment
comment|// for sections with no segments
end_comment

begin_expr_stmt
name|assignSectionsWithNoSegments
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|_context
operator|.
name|isDynamic
argument_list|()
condition|)
name|_dynamicTable
operator|->
name|updateDynamicTable
argument_list|()
expr_stmt|;
end_if

begin_return
return|return
name|std
operator|::
name|error_code
argument_list|()
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|std
operator|::
name|error_code
name|OutputELFWriter
operator|<
name|ELFT
operator|>
operator|::
name|setELFHeader
argument_list|()
block|{
name|_elfHeader
operator|->
name|e_type
argument_list|(
name|_context
operator|.
name|getOutputELFType
argument_list|()
argument_list|)
block|;
name|_elfHeader
operator|->
name|e_machine
argument_list|(
name|_context
operator|.
name|getOutputMachine
argument_list|()
argument_list|)
block|;
name|_elfHeader
operator|->
name|e_ident
argument_list|(
name|ELF
operator|::
name|EI_VERSION
argument_list|,
literal|1
argument_list|)
block|;
name|_elfHeader
operator|->
name|e_ident
argument_list|(
name|ELF
operator|::
name|EI_OSABI
argument_list|,
literal|0
argument_list|)
block|;
name|_elfHeader
operator|->
name|e_version
argument_list|(
literal|1
argument_list|)
block|;
name|_elfHeader
operator|->
name|e_phoff
argument_list|(
name|_programHeader
operator|->
name|fileOffset
argument_list|()
argument_list|)
block|;
name|_elfHeader
operator|->
name|e_shoff
argument_list|(
name|_shdrtab
operator|->
name|fileOffset
argument_list|()
argument_list|)
block|;
name|_elfHeader
operator|->
name|e_phentsize
argument_list|(
name|_programHeader
operator|->
name|entsize
argument_list|()
argument_list|)
block|;
name|_elfHeader
operator|->
name|e_phnum
argument_list|(
name|_programHeader
operator|->
name|numHeaders
argument_list|()
argument_list|)
block|;
name|_elfHeader
operator|->
name|e_shentsize
argument_list|(
name|_shdrtab
operator|->
name|entsize
argument_list|()
argument_list|)
block|;
name|_elfHeader
operator|->
name|e_shnum
argument_list|(
name|_shdrtab
operator|->
name|numHeaders
argument_list|()
argument_list|)
block|;
name|_elfHeader
operator|->
name|e_shstrndx
argument_list|(
name|_shstrtab
operator|->
name|ordinal
argument_list|()
argument_list|)
block|;
if|if
condition|(
specifier|const
specifier|auto
modifier|*
name|al
init|=
name|_layout
operator|.
name|findAtomLayoutByName
argument_list|(
name|_context
operator|.
name|entrySymbolName
argument_list|()
argument_list|)
condition|)
name|_elfHeader
operator|->
name|e_entry
argument_list|(
name|al
operator|->
name|_virtualAddr
argument_list|)
expr_stmt|;
else|else
name|_elfHeader
operator|->
name|e_entry
argument_list|(
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|std
operator|::
name|error_code
argument_list|()
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|uint64_t
name|OutputELFWriter
operator|<
name|ELFT
operator|>
operator|::
name|outputFileSize
argument_list|()
specifier|const
block|{
return|return
name|_shdrtab
operator|->
name|fileOffset
argument_list|()
operator|+
name|_shdrtab
operator|->
name|fileSize
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|std
operator|::
name|error_code
name|OutputELFWriter
operator|<
name|ELFT
operator|>
operator|::
name|writeOutput
argument_list|(
argument|const File&file
argument_list|,
argument|StringRef path
argument_list|)
block|{
name|std
operator|::
name|unique_ptr
operator|<
name|FileOutputBuffer
operator|>
name|buffer
block|;
name|ScopedTask
name|createOutputTask
argument_list|(
name|getDefaultDomain
argument_list|()
argument_list|,
literal|"ELF Writer Create Output"
argument_list|)
block|;
name|std
operator|::
name|error_code
name|ec
operator|=
name|FileOutputBuffer
operator|::
name|create
argument_list|(
name|path
argument_list|,
name|outputFileSize
argument_list|()
argument_list|,
name|buffer
argument_list|,
name|FileOutputBuffer
operator|::
name|F_executable
argument_list|)
block|;
name|createOutputTask
operator|.
name|end
argument_list|()
block|;
if|if
condition|(
name|ec
condition|)
return|return
name|ec
return|;
name|ScopedTask
name|writeTask
argument_list|(
name|getDefaultDomain
argument_list|()
argument_list|,
literal|"ELF Writer write to memory"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// HACK: We have to write out the header and program header here even though
end_comment

begin_comment
comment|// they are a member of a segment because only sections are written in the
end_comment

begin_comment
comment|// following loop.
end_comment

begin_comment
comment|// Finalize ELF Header / Program Headers.
end_comment

begin_expr_stmt
name|_elfHeader
operator|->
name|finalize
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_programHeader
operator|->
name|finalize
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_elfHeader
operator|->
name|write
argument_list|(
name|this
argument_list|,
name|_layout
argument_list|,
operator|*
name|buffer
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_programHeader
operator|->
name|write
argument_list|(
name|this
argument_list|,
name|_layout
argument_list|,
operator|*
name|buffer
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|auto
name|sections
init|=
name|_layout
operator|.
name|sections
argument_list|()
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|parallel_for_each
argument_list|(
name|sections
operator|.
name|begin
argument_list|()
argument_list|,
name|sections
operator|.
name|end
argument_list|()
argument_list|,
index|[
operator|&
index|]
operator|(
name|Chunk
operator|<
name|ELFT
operator|>
operator|*
name|section
operator|)
block|{
name|section
operator|->
name|write
argument_list|(
name|this
argument_list|,
name|_layout
argument_list|,
operator|*
name|buffer
argument_list|)
block|; }
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|writeTask
operator|.
name|end
argument_list|()
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|ScopedTask
name|commitTask
argument_list|(
name|getDefaultDomain
argument_list|()
argument_list|,
literal|"ELF Writer commit to disk"
argument_list|)
decl_stmt|;
end_decl_stmt

begin_return
return|return
name|buffer
operator|->
name|commit
argument_list|()
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|std
operator|::
name|error_code
name|OutputELFWriter
operator|<
name|ELFT
operator|>
operator|::
name|writeFile
argument_list|(
argument|const File&file
argument_list|,
argument|StringRef path
argument_list|)
block|{
name|std
operator|::
name|error_code
name|ec
operator|=
name|buildOutput
argument_list|(
name|file
argument_list|)
block|;
if|if
condition|(
name|ec
condition|)
return|return
name|ec
return|;
name|ec
operator|=
name|setELFHeader
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|ec
condition|)
return|return
name|ec
return|;
end_if

begin_return
return|return
name|writeOutput
argument_list|(
name|file
argument_list|,
name|path
argument_list|)
return|;
end_return

begin_comment
unit|} }
comment|// namespace elf
end_comment

begin_comment
unit|}
comment|// namespace lld
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLD_READER_WRITER_ELF_OUTPUT_WRITER_H
end_comment

end_unit

