begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- lib/ReaderWriter/ELF/DefaultLayout.h -------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                             The LLVM Linker
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLD_READER_WRITER_ELF_DEFAULT_LAYOUT_H
end_ifndef

begin_define
define|#
directive|define
name|LLD_READER_WRITER_ELF_DEFAULT_LAYOUT_H
end_define

begin_include
include|#
directive|include
file|"Atoms.h"
end_include

begin_include
include|#
directive|include
file|"Chunk.h"
end_include

begin_include
include|#
directive|include
file|"HeaderChunks.h"
end_include

begin_include
include|#
directive|include
file|"Layout.h"
end_include

begin_include
include|#
directive|include
file|"SectionChunks.h"
end_include

begin_include
include|#
directive|include
file|"SegmentChunks.h"
end_include

begin_include
include|#
directive|include
file|"lld/Core/Instrumentation.h"
end_include

begin_include
include|#
directive|include
file|"lld/Core/STDExtras.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/ArrayRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/Hashing.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringExtras.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringRef.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringSwitch.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Errc.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Format.h"
end_include

begin_include
include|#
directive|include
file|<map>
end_include

begin_include
include|#
directive|include
file|<unordered_map>
end_include

begin_decl_stmt
name|namespace
name|lld
block|{
name|namespace
name|elf
block|{
comment|/// \brief The DefaultLayout class is used by the Writer to arrange
comment|///        sections and segments in the order determined by the target ELF
comment|///        format. The writer creates a single instance of the DefaultLayout
comment|///        class
name|template
operator|<
name|class
name|ELFT
operator|>
name|class
name|DefaultLayout
operator|:
name|public
name|Layout
block|{
name|public
operator|:
comment|// The order in which the sections appear in the output file
comment|// If its determined, that the layout needs to change
comment|// just changing the order of enumerations would essentially
comment|// change the layout in the output file
comment|// Change the enumerations so that Target can override and stick
comment|// a section anywhere it wants to
expr|enum
name|DefaultSectionOrder
block|{
name|ORDER_NOT_DEFINED
operator|=
literal|0
block|,
name|ORDER_INTERP
operator|=
literal|10
block|,
name|ORDER_RO_NOTE
operator|=
literal|15
block|,
name|ORDER_HASH
operator|=
literal|30
block|,
name|ORDER_DYNAMIC_SYMBOLS
operator|=
literal|40
block|,
name|ORDER_DYNAMIC_STRINGS
operator|=
literal|50
block|,
name|ORDER_DYNAMIC_RELOCS
operator|=
literal|52
block|,
name|ORDER_DYNAMIC_PLT_RELOCS
operator|=
literal|54
block|,
name|ORDER_INIT
operator|=
literal|60
block|,
name|ORDER_PLT
operator|=
literal|70
block|,
name|ORDER_TEXT
operator|=
literal|80
block|,
name|ORDER_FINI
operator|=
literal|90
block|,
name|ORDER_REL
operator|=
literal|95
block|,
name|ORDER_RODATA
operator|=
literal|100
block|,
name|ORDER_EH_FRAME
operator|=
literal|110
block|,
name|ORDER_EH_FRAMEHDR
operator|=
literal|120
block|,
name|ORDER_TDATA
operator|=
literal|124
block|,
name|ORDER_TBSS
operator|=
literal|128
block|,
name|ORDER_CTORS
operator|=
literal|130
block|,
name|ORDER_DTORS
operator|=
literal|140
block|,
name|ORDER_INIT_ARRAY
operator|=
literal|150
block|,
name|ORDER_FINI_ARRAY
operator|=
literal|160
block|,
name|ORDER_DYNAMIC
operator|=
literal|170
block|,
name|ORDER_GOT
operator|=
literal|180
block|,
name|ORDER_GOT_PLT
operator|=
literal|190
block|,
name|ORDER_DATA
operator|=
literal|200
block|,
name|ORDER_RW_NOTE
operator|=
literal|205
block|,
name|ORDER_BSS
operator|=
literal|210
block|,
name|ORDER_NOALLOC
operator|=
literal|215
block|,
name|ORDER_OTHER
operator|=
literal|220
block|,
name|ORDER_SECTION_STRINGS
operator|=
literal|230
block|,
name|ORDER_SYMBOL_TABLE
operator|=
literal|240
block|,
name|ORDER_STRING_TABLE
operator|=
literal|250
block|,
name|ORDER_SECTION_HEADERS
operator|=
literal|260
block|}
block|;
name|public
operator|:
comment|// The Key used for creating Sections
comment|// The sections are created using
comment|// SectionName, contentPermissions
expr|struct
name|SectionKey
block|{
name|SectionKey
argument_list|(
argument|StringRef name
argument_list|,
argument|DefinedAtom::ContentPermissions perm
argument_list|,
argument|StringRef path
argument_list|)
operator|:
name|_name
argument_list|(
name|name
argument_list|)
block|,
name|_perm
argument_list|(
name|perm
argument_list|)
block|,
name|_path
argument_list|(
argument|path
argument_list|)
block|{}
comment|// Data members
name|StringRef
name|_name
block|;
name|DefinedAtom
operator|::
name|ContentPermissions
name|_perm
block|;
name|StringRef
name|_path
block|;   }
block|;    struct
name|SectionKeyHash
block|{
name|int64_t
name|operator
argument_list|()
operator|(
specifier|const
name|SectionKey
operator|&
name|k
operator|)
specifier|const
block|{
return|return
name|llvm
operator|::
name|hash_combine
argument_list|(
name|k
operator|.
name|_name
argument_list|,
name|k
operator|.
name|_perm
argument_list|,
name|k
operator|.
name|_path
argument_list|)
return|;
block|}
expr|}
block|;    struct
name|SectionKeyEq
block|{
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|SectionKey
operator|&
name|lhs
operator|,
specifier|const
name|SectionKey
operator|&
name|rhs
operator|)
specifier|const
block|{
return|return
operator|(
operator|(
name|lhs
operator|.
name|_name
operator|==
name|rhs
operator|.
name|_name
operator|)
operator|&&
operator|(
name|lhs
operator|.
name|_perm
operator|==
name|rhs
operator|.
name|_perm
operator|)
operator|&&
operator|(
name|lhs
operator|.
name|_path
operator|==
name|rhs
operator|.
name|_path
operator|)
operator|)
return|;
block|}
expr|}
block|;
typedef|typedef
name|typename
name|std
operator|::
name|vector
operator|<
name|Chunk
operator|<
name|ELFT
operator|>
operator|*
operator|>
operator|::
name|iterator
name|ChunkIter
expr_stmt|;
typedef|typedef
name|typename
name|std
operator|::
name|vector
operator|<
name|Segment
operator|<
name|ELFT
operator|>
operator|*
operator|>
operator|::
name|iterator
name|SegmentIter
expr_stmt|;
comment|// The additional segments are used to figure out
comment|// if there is a segment by that type already created
comment|// For example : PT_TLS, we have two sections .tdata/.tbss
comment|// that are part of PT_TLS, we need to create this additional
comment|// segment only once
typedef|typedef
name|std
operator|::
name|pair
operator|<
name|int64_t
operator|,
name|int64_t
operator|>
name|AdditionalSegmentKey
expr_stmt|;
comment|// The segments are created using
comment|// SegmentName, Segment flags
typedef|typedef
name|std
operator|::
name|pair
operator|<
name|StringRef
operator|,
name|int64_t
operator|>
name|SegmentKey
expr_stmt|;
comment|// HashKey for the Segment
name|class
name|SegmentHashKey
block|{
name|public
label|:
name|int64_t
name|operator
argument_list|()
operator|(
specifier|const
name|SegmentKey
operator|&
name|k
operator|)
specifier|const
block|{
comment|// k.first = SegmentName
comment|// k.second = SegmentFlags
return|return
name|llvm
operator|::
name|hash_combine
argument_list|(
name|k
operator|.
name|first
argument_list|,
name|k
operator|.
name|second
argument_list|)
return|;
block|}
block|}
empty_stmt|;
name|class
name|AdditionalSegmentHashKey
block|{
name|public
label|:
name|int64_t
name|operator
argument_list|()
operator|(
specifier|const
name|AdditionalSegmentKey
operator|&
name|k
operator|)
specifier|const
block|{
comment|// k.first = SegmentName
comment|// k.second = SegmentFlags
return|return
name|llvm
operator|::
name|hash_combine
argument_list|(
name|k
operator|.
name|first
argument_list|,
name|k
operator|.
name|second
argument_list|)
return|;
block|}
block|}
empty_stmt|;
comment|// Output Sections contain the map of Sectionnames to a vector of sections,
comment|// that have been merged to form a single section
typedef|typedef
name|llvm
operator|::
name|StringMap
operator|<
name|OutputSection
operator|<
name|ELFT
operator|>
operator|*
operator|>
name|OutputSectionMapT
expr_stmt|;
typedef|typedef
name|typename
name|std
operator|::
name|vector
operator|<
name|OutputSection
operator|<
name|ELFT
operator|>
operator|*
operator|>
operator|::
name|iterator
name|OutputSectionIter
expr_stmt|;
typedef|typedef
name|std
operator|::
name|unordered_map
operator|<
name|SectionKey
operator|,
name|AtomSection
operator|<
name|ELFT
operator|>
operator|*
operator|,
name|SectionKeyHash
operator|,
name|SectionKeyEq
operator|>
name|SectionMapT
expr_stmt|;
typedef|typedef
name|std
operator|::
name|unordered_map
operator|<
name|AdditionalSegmentKey
operator|,
name|Segment
operator|<
name|ELFT
operator|>
operator|*
operator|,
name|AdditionalSegmentHashKey
operator|>
name|AdditionalSegmentMapT
expr_stmt|;
typedef|typedef
name|std
operator|::
name|unordered_map
operator|<
name|SegmentKey
operator|,
name|Segment
operator|<
name|ELFT
operator|>
operator|*
operator|,
name|SegmentHashKey
operator|>
name|SegmentMapT
expr_stmt|;
comment|/// \brief find a absolute atom pair given a absolute atom name
struct|struct
name|FindByName
block|{
specifier|const
name|std
operator|::
name|string
name|_name
expr_stmt|;
name|FindByName
argument_list|(
argument|StringRef name
argument_list|)
block|:
name|_name
argument_list|(
argument|name
argument_list|)
block|{}
name|bool
name|operator
argument_list|()
operator|(
specifier|const
name|lld
operator|::
name|AtomLayout
operator|*
name|j
operator|)
block|{
return|return
name|j
operator|->
name|_atom
operator|->
name|name
argument_list|()
operator|==
name|_name
return|;
block|}
block|}
struct|;
typedef|typedef
name|typename
name|std
operator|::
name|vector
operator|<
name|lld
operator|::
name|AtomLayout
operator|*
operator|>
operator|::
name|iterator
name|AbsoluteAtomIterT
expr_stmt|;
typedef|typedef
name|llvm
operator|::
name|DenseSet
operator|<
specifier|const
name|Atom
operator|*
operator|>
name|AtomSetT
expr_stmt|;
name|DefaultLayout
argument_list|(
name|ELFLinkingContext
operator|&
name|context
argument_list|)
operator|:
name|_context
argument_list|(
name|context
argument_list|)
operator|,
name|_linkerScriptSema
argument_list|(
argument|context.linkerScriptSema()
argument_list|)
block|{}
comment|/// \brief Return the section order for a input section
name|SectionOrder
name|getSectionOrder
argument_list|(
argument|StringRef name
argument_list|,
argument|int32_t contentType
argument_list|,
argument|int32_t contentPermissions
argument_list|)
name|override
expr_stmt|;
comment|/// \brief Return the name of the input section by decoding the input
comment|/// sectionChoice.
name|virtual
name|StringRef
name|getInputSectionName
argument_list|(
specifier|const
name|DefinedAtom
operator|*
name|da
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief Return the name of the output section from the input section.
name|virtual
name|StringRef
name|getOutputSectionName
argument_list|(
name|StringRef
name|archivePath
argument_list|,
name|StringRef
name|memberPath
argument_list|,
name|StringRef
name|inputSectionName
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief Gets or creates a section.
name|AtomSection
operator|<
name|ELFT
operator|>
operator|*
name|getSection
argument_list|(
argument|StringRef name
argument_list|,
argument|int32_t contentType
argument_list|,
argument|DefinedAtom::ContentPermissions contentPermissions
argument_list|,
argument|const DefinedAtom *da
argument_list|)
expr_stmt|;
comment|/// \brief Gets the segment for a output section
name|virtual
name|Layout
operator|::
name|SegmentType
name|getSegmentType
argument_list|(
argument|Section<ELFT> *section
argument_list|)
specifier|const
expr_stmt|;
comment|/// \brief Returns true/false depending on whether the section has a Output
comment|//         segment or not
specifier|static
name|bool
name|hasOutputSegment
argument_list|(
name|Section
operator|<
name|ELFT
operator|>
operator|*
name|section
argument_list|)
decl_stmt|;
comment|// Adds an atom to the section
name|ErrorOr
operator|<
specifier|const
name|lld
operator|::
name|AtomLayout
operator|*
operator|>
name|addAtom
argument_list|(
argument|const Atom *atom
argument_list|)
name|override
expr_stmt|;
comment|/// \brief Find an output Section given a section name.
name|OutputSection
operator|<
name|ELFT
operator|>
operator|*
name|findOutputSection
argument_list|(
argument|StringRef name
argument_list|)
block|{
name|auto
name|iter
operator|=
name|_outputSectionMap
operator|.
name|find
argument_list|(
name|name
argument_list|)
block|;
if|if
condition|(
name|iter
operator|==
name|_outputSectionMap
operator|.
name|end
argument_list|()
condition|)
return|return
name|nullptr
return|;
return|return
name|iter
operator|->
name|second
return|;
block|}
comment|/// \brief find a absolute atom given a name
name|AbsoluteAtomIterT
name|findAbsoluteAtom
parameter_list|(
name|StringRef
name|name
parameter_list|)
block|{
return|return
name|std
operator|::
name|find_if
argument_list|(
name|_absoluteAtoms
operator|.
name|begin
argument_list|()
argument_list|,
name|_absoluteAtoms
operator|.
name|end
argument_list|()
argument_list|,
name|FindByName
argument_list|(
name|name
argument_list|)
argument_list|)
return|;
block|}
comment|// Output sections with the same name into a OutputSection
name|void
name|createOutputSections
parameter_list|()
function_decl|;
comment|/// \brief Sort the sections by their order as defined by the layout,
comment|/// preparing all sections to be assigned to a segment.
name|virtual
name|void
name|sortInputSections
parameter_list|()
function_decl|;
comment|/// \brief Add extra chunks to a segment just before including the input
comment|/// section given by<archivePath, memberPath, sectionName>. This
comment|/// is used to add linker script expressions before each section.
name|virtual
name|void
name|addExtraChunksToSegment
argument_list|(
name|Segment
operator|<
name|ELFT
operator|>
operator|*
name|segment
argument_list|,
name|StringRef
name|archivePath
argument_list|,
name|StringRef
name|memberPath
argument_list|,
name|StringRef
name|sectionName
argument_list|)
decl_stmt|;
name|void
name|assignSectionsToSegments
argument_list|()
name|override
expr_stmt|;
name|void
name|assignVirtualAddress
argument_list|()
name|override
expr_stmt|;
name|void
name|assignFileOffsetsForMiscSections
parameter_list|()
function_decl|;
name|range
operator|<
name|AbsoluteAtomIterT
operator|>
name|absoluteAtoms
argument_list|()
block|{
return|return
name|_absoluteAtoms
return|;
block|}
name|void
name|addSection
argument_list|(
name|Chunk
operator|<
name|ELFT
operator|>
operator|*
name|c
argument_list|)
block|{
name|_sections
operator|.
name|push_back
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|void
name|finalize
parameter_list|()
block|{
name|ScopedTask
name|task
argument_list|(
name|getDefaultDomain
argument_list|()
argument_list|,
literal|"Finalize layout"
argument_list|)
decl_stmt|;
for|for
control|(
name|auto
operator|&
name|si
operator|:
name|_sections
control|)
name|si
operator|->
name|finalize
argument_list|()
expr_stmt|;
block|}
name|void
name|doPreFlight
parameter_list|()
block|{
for|for
control|(
name|auto
operator|&
name|si
operator|:
name|_sections
control|)
name|si
operator|->
name|doPreFlight
argument_list|()
expr_stmt|;
block|}
specifier|const
name|AtomLayout
modifier|*
name|findAtomLayoutByName
argument_list|(
name|StringRef
name|name
argument_list|)
decl|const
name|override
block|{
for|for
control|(
name|auto
name|sec
range|:
name|_sections
control|)
if|if
condition|(
name|auto
name|section
init|=
name|dyn_cast
operator|<
name|Section
operator|<
name|ELFT
operator|>>
operator|(
name|sec
operator|)
condition|)
if|if
condition|(
name|auto
operator|*
name|al
operator|=
name|section
operator|->
name|findAtomLayoutByName
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|al
return|;
return|return
name|nullptr
return|;
block|}
name|void
name|setHeader
argument_list|(
name|ELFHeader
operator|<
name|ELFT
operator|>
operator|*
name|elfHeader
argument_list|)
block|{
name|_elfHeader
operator|=
name|elfHeader
expr_stmt|;
block|}
name|void
name|setProgramHeader
argument_list|(
name|ProgramHeader
operator|<
name|ELFT
operator|>
operator|*
name|p
argument_list|)
block|{
name|_programHeader
operator|=
name|p
expr_stmt|;
block|}
name|range
operator|<
name|OutputSectionIter
operator|>
name|outputSections
argument_list|()
block|{
return|return
name|_outputSections
return|;
block|}
name|range
operator|<
name|ChunkIter
operator|>
name|sections
argument_list|()
block|{
return|return
name|_sections
return|;
block|}
name|range
operator|<
name|SegmentIter
operator|>
name|segments
argument_list|()
block|{
return|return
name|_segments
return|;
block|}
name|ELFHeader
operator|<
name|ELFT
operator|>
operator|*
name|getHeader
argument_list|()
block|{
return|return
name|_elfHeader
return|;
block|}
name|bool
name|hasDynamicRelocationTable
argument_list|()
specifier|const
block|{
return|return
operator|!
operator|!
name|_dynamicRelocationTable
return|;
block|}
name|bool
name|hasPLTRelocationTable
argument_list|()
specifier|const
block|{
return|return
operator|!
operator|!
name|_pltRelocationTable
return|;
block|}
comment|/// \brief Get or create the dynamic relocation table. All relocations in this
comment|/// table are processed at startup.
name|RelocationTable
operator|<
name|ELFT
operator|>
operator|*
name|getDynamicRelocationTable
argument_list|()
block|{
if|if
condition|(
operator|!
name|_dynamicRelocationTable
condition|)
block|{
name|_dynamicRelocationTable
operator|=
name|std
operator|::
name|move
argument_list|(
name|createRelocationTable
argument_list|(
name|_context
operator|.
name|isRelaOutputFormat
argument_list|()
condition|?
literal|".rela.dyn"
else|:
literal|".rel.dyn"
argument_list|,
name|ORDER_DYNAMIC_RELOCS
argument_list|)
argument_list|)
expr_stmt|;
name|addSection
argument_list|(
name|_dynamicRelocationTable
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|_dynamicRelocationTable
operator|.
name|get
argument_list|()
return|;
block|}
comment|/// \brief Get or create the PLT relocation table. Referenced by DT_JMPREL.
name|RelocationTable
operator|<
name|ELFT
operator|>
operator|*
name|getPLTRelocationTable
argument_list|()
block|{
if|if
condition|(
operator|!
name|_pltRelocationTable
condition|)
block|{
name|_pltRelocationTable
operator|=
name|std
operator|::
name|move
argument_list|(
name|createRelocationTable
argument_list|(
name|_context
operator|.
name|isRelaOutputFormat
argument_list|()
condition|?
literal|".rela.plt"
else|:
literal|".rel.plt"
argument_list|,
name|ORDER_DYNAMIC_PLT_RELOCS
argument_list|)
argument_list|)
expr_stmt|;
name|addSection
argument_list|(
name|_pltRelocationTable
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
name|_pltRelocationTable
operator|.
name|get
argument_list|()
return|;
block|}
name|uint64_t
name|getTLSSize
argument_list|()
specifier|const
block|{
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|phdr
range|:
operator|*
name|_programHeader
control|)
if|if
condition|(
name|phdr
operator|->
name|p_type
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|PT_TLS
condition|)
return|return
name|phdr
operator|->
name|p_memsz
return|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|bool
name|isReferencedByDefinedAtom
argument_list|(
specifier|const
name|Atom
operator|*
name|a
argument_list|)
decl|const
block|{
return|return
name|_referencedDynAtoms
operator|.
name|count
argument_list|(
name|a
argument_list|)
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|bool
name|isCopied
argument_list|(
specifier|const
name|SharedLibraryAtom
operator|*
name|sla
argument_list|)
decl|const
block|{
return|return
name|_copiedDynSymNames
operator|.
name|count
argument_list|(
name|sla
operator|->
name|name
argument_list|()
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/// \brief Handle SORT_BY_PRIORITY.
end_comment

begin_function_decl
name|void
name|sortOutputSectionByPriority
parameter_list|(
name|StringRef
name|outputSectionName
parameter_list|,
name|StringRef
name|prefix
parameter_list|)
function_decl|;
end_function_decl

begin_label
name|protected
label|:
end_label

begin_comment
comment|/// \brief TargetLayouts may use these functions to reorder the input sections
end_comment

begin_comment
comment|/// in a order defined by their ABI.
end_comment

begin_function
name|virtual
name|void
name|finalizeOutputSectionLayout
parameter_list|()
block|{}
end_function

begin_comment
comment|/// \brief Allocate a new section.
end_comment

begin_expr_stmt
name|virtual
name|AtomSection
operator|<
name|ELFT
operator|>
operator|*
name|createSection
argument_list|(
argument|StringRef name
argument_list|,
argument|int32_t contentType
argument_list|,
argument|DefinedAtom::ContentPermissions contentPermissions
argument_list|,
argument|SectionOrder sectionOrder
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/// \brief Create a new relocation table.
end_comment

begin_expr_stmt
name|virtual
name|unique_bump_ptr
operator|<
name|RelocationTable
operator|<
name|ELFT
operator|>>
name|createRelocationTable
argument_list|(
argument|StringRef name
argument_list|,
argument|int32_t order
argument_list|)
block|{
return|return
name|unique_bump_ptr
operator|<
name|RelocationTable
operator|<
name|ELFT
operator|>>
operator|(
name|new
argument_list|(
argument|_allocator
argument_list|)
name|RelocationTable
operator|<
name|ELFT
operator|>
operator|(
name|_context
operator|,
name|name
operator|,
name|order
operator|)
operator|)
return|;
block|}
end_expr_stmt

begin_label
name|private
label|:
end_label

begin_comment
comment|/// Helper function that returns the priority value from an input section.
end_comment

begin_decl_stmt
name|uint32_t
name|getPriorityFromSectionName
argument_list|(
name|StringRef
name|sectionName
argument_list|)
decl|const
decl_stmt|;
end_decl_stmt

begin_label
name|protected
label|:
end_label

begin_expr_stmt
name|llvm
operator|::
name|BumpPtrAllocator
name|_allocator
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|SectionMapT
name|_sectionMap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|OutputSectionMapT
name|_outputSectionMap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|AdditionalSegmentMapT
name|_additionalSegmentMap
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SegmentMapT
name|_segmentMap
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|std
operator|::
name|vector
operator|<
name|Chunk
operator|<
name|ELFT
operator|>
operator|*
operator|>
name|_sections
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|vector
operator|<
name|Segment
operator|<
name|ELFT
operator|>
operator|*
operator|>
name|_segments
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|vector
operator|<
name|OutputSection
operator|<
name|ELFT
operator|>
operator|*
operator|>
name|_outputSections
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ELFHeader
operator|<
name|ELFT
operator|>
operator|*
name|_elfHeader
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ProgramHeader
operator|<
name|ELFT
operator|>
operator|*
name|_programHeader
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|unique_bump_ptr
operator|<
name|RelocationTable
operator|<
name|ELFT
operator|>>
name|_dynamicRelocationTable
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|unique_bump_ptr
operator|<
name|RelocationTable
operator|<
name|ELFT
operator|>>
name|_pltRelocationTable
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|vector
operator|<
name|lld
operator|::
name|AtomLayout
operator|*
operator|>
name|_absoluteAtoms
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|AtomSetT
name|_referencedDynAtoms
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|llvm
operator|::
name|StringSet
operator|<
operator|>
name|_copiedDynSymNames
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|ELFLinkingContext
modifier|&
name|_context
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|script
operator|::
name|Sema
operator|&
name|_linkerScriptSema
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|};
name|template
operator|<
name|class
name|ELFT
operator|>
name|Layout
operator|::
name|SectionOrder
name|DefaultLayout
operator|<
name|ELFT
operator|>
operator|::
name|getSectionOrder
argument_list|(
argument|StringRef name
argument_list|,
argument|int32_t contentType
argument_list|,
argument|int32_t contentPermissions
argument_list|)
block|{
switch|switch
condition|(
name|contentType
condition|)
block|{
case|case
name|DefinedAtom
operator|::
name|typeResolver
case|:
case|case
name|DefinedAtom
operator|::
name|typeCode
case|:
return|return
name|llvm
operator|::
name|StringSwitch
operator|<
name|Layout
operator|::
name|SectionOrder
operator|>
operator|(
name|name
operator|)
operator|.
name|StartsWith
argument_list|(
literal|".eh_frame_hdr"
argument_list|,
name|ORDER_EH_FRAMEHDR
argument_list|)
operator|.
name|StartsWith
argument_list|(
literal|".eh_frame"
argument_list|,
name|ORDER_EH_FRAME
argument_list|)
operator|.
name|StartsWith
argument_list|(
literal|".init"
argument_list|,
name|ORDER_INIT
argument_list|)
operator|.
name|StartsWith
argument_list|(
literal|".fini"
argument_list|,
name|ORDER_FINI
argument_list|)
operator|.
name|StartsWith
argument_list|(
literal|".hash"
argument_list|,
name|ORDER_HASH
argument_list|)
operator|.
name|Default
argument_list|(
name|ORDER_TEXT
argument_list|)
return|;
case|case
name|DefinedAtom
operator|::
name|typeConstant
case|:
return|return
name|ORDER_RODATA
return|;
case|case
name|DefinedAtom
operator|::
name|typeData
case|:
case|case
name|DefinedAtom
operator|::
name|typeDataFast
case|:
return|return
name|llvm
operator|::
name|StringSwitch
operator|<
name|Layout
operator|::
name|SectionOrder
operator|>
operator|(
name|name
operator|)
operator|.
name|StartsWith
argument_list|(
literal|".init_array"
argument_list|,
name|ORDER_INIT_ARRAY
argument_list|)
operator|.
name|StartsWith
argument_list|(
literal|".fini_array"
argument_list|,
name|ORDER_FINI_ARRAY
argument_list|)
operator|.
name|StartsWith
argument_list|(
literal|".dynamic"
argument_list|,
name|ORDER_DYNAMIC
argument_list|)
operator|.
name|StartsWith
argument_list|(
literal|".ctors"
argument_list|,
name|ORDER_CTORS
argument_list|)
operator|.
name|StartsWith
argument_list|(
literal|".dtors"
argument_list|,
name|ORDER_DTORS
argument_list|)
operator|.
name|Default
argument_list|(
name|ORDER_DATA
argument_list|)
return|;
case|case
name|DefinedAtom
operator|::
name|typeZeroFill
case|:
case|case
name|DefinedAtom
operator|::
name|typeZeroFillFast
case|:
return|return
name|ORDER_BSS
return|;
case|case
name|DefinedAtom
operator|::
name|typeGOT
case|:
return|return
name|llvm
operator|::
name|StringSwitch
operator|<
name|Layout
operator|::
name|SectionOrder
operator|>
operator|(
name|name
operator|)
operator|.
name|StartsWith
argument_list|(
literal|".got.plt"
argument_list|,
name|ORDER_GOT_PLT
argument_list|)
operator|.
name|Default
argument_list|(
name|ORDER_GOT
argument_list|)
return|;
case|case
name|DefinedAtom
operator|::
name|typeStub
case|:
return|return
name|ORDER_PLT
return|;
case|case
name|DefinedAtom
operator|::
name|typeRONote
case|:
return|return
name|ORDER_RO_NOTE
return|;
case|case
name|DefinedAtom
operator|::
name|typeRWNote
case|:
return|return
name|ORDER_RW_NOTE
return|;
case|case
name|DefinedAtom
operator|::
name|typeNoAlloc
case|:
return|return
name|ORDER_NOALLOC
return|;
case|case
name|DefinedAtom
operator|::
name|typeThreadData
case|:
return|return
name|ORDER_TDATA
return|;
case|case
name|DefinedAtom
operator|::
name|typeThreadZeroFill
case|:
return|return
name|ORDER_TBSS
return|;
default|default:
comment|// If we get passed in a section push it to OTHER
if|if
condition|(
name|contentPermissions
operator|==
name|DefinedAtom
operator|::
name|perm___
condition|)
return|return
name|ORDER_OTHER
return|;
return|return
name|ORDER_NOT_DEFINED
return|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|/// \brief This maps the input sections to the output section names
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|ELFT
operator|>
name|StringRef
name|DefaultLayout
operator|<
name|ELFT
operator|>
operator|::
name|getInputSectionName
argument_list|(
argument|const DefinedAtom *da
argument_list|)
specifier|const
block|{
if|if
condition|(
name|da
operator|->
name|sectionChoice
argument_list|()
operator|==
name|DefinedAtom
operator|::
name|sectionBasedOnContent
condition|)
block|{
switch|switch
condition|(
name|da
operator|->
name|contentType
argument_list|()
condition|)
block|{
case|case
name|DefinedAtom
operator|::
name|typeCode
case|:
return|return
literal|".text"
return|;
case|case
name|DefinedAtom
operator|::
name|typeData
case|:
return|return
literal|".data"
return|;
case|case
name|DefinedAtom
operator|::
name|typeConstant
case|:
return|return
literal|".rodata"
return|;
case|case
name|DefinedAtom
operator|::
name|typeZeroFill
case|:
return|return
literal|".bss"
return|;
case|case
name|DefinedAtom
operator|::
name|typeThreadData
case|:
return|return
literal|".tdata"
return|;
case|case
name|DefinedAtom
operator|::
name|typeThreadZeroFill
case|:
return|return
literal|".tbss"
return|;
default|default:
break|break;
block|}
end_expr_stmt

begin_expr_stmt
unit|}   return
name|da
operator|->
name|customSectionName
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|/// \brief This maps the input sections to the output section names.
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|ELFT
operator|>
name|StringRef
name|DefaultLayout
operator|<
name|ELFT
operator|>
operator|::
name|getOutputSectionName
argument_list|(
argument|StringRef archivePath
argument_list|,
argument|StringRef memberPath
argument_list|,
argument|StringRef inputSectionName
argument_list|)
specifier|const
block|{
name|StringRef
name|outputSectionName
block|;
if|if
condition|(
name|_linkerScriptSema
operator|.
name|hasLayoutCommands
argument_list|()
condition|)
block|{
name|script
operator|::
name|Sema
operator|::
name|SectionKey
name|key
operator|=
block|{
name|archivePath
block|,
name|memberPath
block|,
name|inputSectionName
block|}
expr_stmt|;
name|outputSectionName
operator|=
name|_linkerScriptSema
operator|.
name|getOutputSection
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outputSectionName
operator|.
name|empty
argument_list|()
condition|)
return|return
name|outputSectionName
return|;
block|}
end_expr_stmt

begin_return
return|return
name|llvm
operator|::
name|StringSwitch
operator|<
name|StringRef
operator|>
operator|(
name|inputSectionName
operator|)
operator|.
name|StartsWith
argument_list|(
literal|".text"
argument_list|,
literal|".text"
argument_list|)
operator|.
name|StartsWith
argument_list|(
literal|".ctors"
argument_list|,
literal|".ctors"
argument_list|)
operator|.
name|StartsWith
argument_list|(
literal|".dtors"
argument_list|,
literal|".dtors"
argument_list|)
operator|.
name|StartsWith
argument_list|(
literal|".rodata"
argument_list|,
literal|".rodata"
argument_list|)
operator|.
name|StartsWith
argument_list|(
literal|".gcc_except_table"
argument_list|,
literal|".gcc_except_table"
argument_list|)
operator|.
name|StartsWith
argument_list|(
literal|".data.rel.ro"
argument_list|,
literal|".data.rel.ro"
argument_list|)
operator|.
name|StartsWith
argument_list|(
literal|".data.rel.local"
argument_list|,
literal|".data.rel.local"
argument_list|)
operator|.
name|StartsWith
argument_list|(
literal|".data"
argument_list|,
literal|".data"
argument_list|)
operator|.
name|StartsWith
argument_list|(
literal|".tdata"
argument_list|,
literal|".tdata"
argument_list|)
operator|.
name|StartsWith
argument_list|(
literal|".tbss"
argument_list|,
literal|".tbss"
argument_list|)
operator|.
name|StartsWith
argument_list|(
literal|".init_array"
argument_list|,
literal|".init_array"
argument_list|)
operator|.
name|StartsWith
argument_list|(
literal|".fini_array"
argument_list|,
literal|".fini_array"
argument_list|)
operator|.
name|Default
argument_list|(
name|inputSectionName
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/// \brief Gets the segment for a output section
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|ELFT
operator|>
name|Layout
operator|::
name|SegmentType
name|DefaultLayout
operator|<
name|ELFT
operator|>
operator|::
name|getSegmentType
argument_list|(
argument|Section<ELFT> *section
argument_list|)
specifier|const
block|{
switch|switch
condition|(
name|section
operator|->
name|order
argument_list|()
condition|)
block|{
case|case
name|ORDER_INTERP
case|:
return|return
name|llvm
operator|::
name|ELF
operator|::
name|PT_INTERP
return|;
case|case
name|ORDER_TEXT
case|:
case|case
name|ORDER_HASH
case|:
case|case
name|ORDER_DYNAMIC_SYMBOLS
case|:
case|case
name|ORDER_DYNAMIC_STRINGS
case|:
case|case
name|ORDER_DYNAMIC_RELOCS
case|:
case|case
name|ORDER_DYNAMIC_PLT_RELOCS
case|:
case|case
name|ORDER_REL
case|:
case|case
name|ORDER_INIT
case|:
case|case
name|ORDER_PLT
case|:
case|case
name|ORDER_FINI
case|:
case|case
name|ORDER_RODATA
case|:
case|case
name|ORDER_EH_FRAME
case|:
case|case
name|ORDER_CTORS
case|:
case|case
name|ORDER_DTORS
case|:
return|return
name|llvm
operator|::
name|ELF
operator|::
name|PT_LOAD
return|;
case|case
name|ORDER_RO_NOTE
case|:
case|case
name|ORDER_RW_NOTE
case|:
return|return
name|llvm
operator|::
name|ELF
operator|::
name|PT_NOTE
return|;
case|case
name|ORDER_DYNAMIC
case|:
return|return
name|llvm
operator|::
name|ELF
operator|::
name|PT_DYNAMIC
return|;
case|case
name|ORDER_EH_FRAMEHDR
case|:
return|return
name|llvm
operator|::
name|ELF
operator|::
name|PT_GNU_EH_FRAME
return|;
case|case
name|ORDER_GOT
case|:
case|case
name|ORDER_GOT_PLT
case|:
case|case
name|ORDER_DATA
case|:
case|case
name|ORDER_BSS
case|:
case|case
name|ORDER_INIT_ARRAY
case|:
case|case
name|ORDER_FINI_ARRAY
case|:
return|return
name|llvm
operator|::
name|ELF
operator|::
name|PT_LOAD
return|;
case|case
name|ORDER_TDATA
case|:
case|case
name|ORDER_TBSS
case|:
return|return
name|llvm
operator|::
name|ELF
operator|::
name|PT_TLS
return|;
default|default:
return|return
name|llvm
operator|::
name|ELF
operator|::
name|PT_NULL
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|bool
name|DefaultLayout
operator|<
name|ELFT
operator|>
operator|::
name|hasOutputSegment
argument_list|(
argument|Section<ELFT> *section
argument_list|)
block|{
switch|switch
condition|(
name|section
operator|->
name|order
argument_list|()
condition|)
block|{
case|case
name|ORDER_INTERP
case|:
case|case
name|ORDER_HASH
case|:
case|case
name|ORDER_DYNAMIC_SYMBOLS
case|:
case|case
name|ORDER_DYNAMIC_STRINGS
case|:
case|case
name|ORDER_DYNAMIC_RELOCS
case|:
case|case
name|ORDER_DYNAMIC_PLT_RELOCS
case|:
case|case
name|ORDER_REL
case|:
case|case
name|ORDER_INIT
case|:
case|case
name|ORDER_PLT
case|:
case|case
name|ORDER_TEXT
case|:
case|case
name|ORDER_FINI
case|:
case|case
name|ORDER_RODATA
case|:
case|case
name|ORDER_EH_FRAME
case|:
case|case
name|ORDER_EH_FRAMEHDR
case|:
case|case
name|ORDER_TDATA
case|:
case|case
name|ORDER_TBSS
case|:
case|case
name|ORDER_RO_NOTE
case|:
case|case
name|ORDER_RW_NOTE
case|:
case|case
name|ORDER_DYNAMIC
case|:
case|case
name|ORDER_CTORS
case|:
case|case
name|ORDER_DTORS
case|:
case|case
name|ORDER_GOT
case|:
case|case
name|ORDER_GOT_PLT
case|:
case|case
name|ORDER_DATA
case|:
case|case
name|ORDER_INIT_ARRAY
case|:
case|case
name|ORDER_FINI_ARRAY
case|:
case|case
name|ORDER_BSS
case|:
case|case
name|ORDER_NOALLOC
case|:
return|return
name|true
return|;
default|default:
return|return
name|section
operator|->
name|hasOutputSegment
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|AtomSection
operator|<
name|ELFT
operator|>
operator|*
name|DefaultLayout
operator|<
name|ELFT
operator|>
operator|::
name|createSection
argument_list|(
argument|StringRef sectionName
argument_list|,
argument|int32_t contentType
argument_list|,
argument|DefinedAtom::ContentPermissions permissions
argument_list|,
argument|SectionOrder sectionOrder
argument_list|)
block|{
return|return
name|new
argument_list|(
argument|_allocator
argument_list|)
name|AtomSection
operator|<
name|ELFT
operator|>
operator|(
name|_context
operator|,
name|sectionName
operator|,
name|contentType
operator|,
name|permissions
operator|,
name|sectionOrder
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|ELFT
operator|>
name|AtomSection
operator|<
name|ELFT
operator|>
operator|*
name|DefaultLayout
operator|<
name|ELFT
operator|>
operator|::
name|getSection
argument_list|(
argument|StringRef sectionName
argument_list|,
argument|int32_t contentType
argument_list|,
argument|DefinedAtom::ContentPermissions permissions
argument_list|,
argument|const DefinedAtom *da
argument_list|)
block|{
specifier|const
name|SectionKey
name|sectionKey
argument_list|(
name|sectionName
argument_list|,
name|permissions
argument_list|,
name|da
operator|->
name|file
argument_list|()
operator|.
name|path
argument_list|()
argument_list|)
block|;
name|SectionOrder
name|sectionOrder
operator|=
name|getSectionOrder
argument_list|(
name|sectionName
argument_list|,
name|contentType
argument_list|,
name|permissions
argument_list|)
block|;
name|auto
name|sec
operator|=
name|_sectionMap
operator|.
name|find
argument_list|(
name|sectionKey
argument_list|)
block|;
if|if
condition|(
name|sec
operator|!=
name|_sectionMap
operator|.
name|end
argument_list|()
condition|)
return|return
name|sec
operator|->
name|second
return|;
name|AtomSection
operator|<
name|ELFT
operator|>
operator|*
name|newSec
operator|=
name|createSection
argument_list|(
name|sectionName
argument_list|,
name|contentType
argument_list|,
name|permissions
argument_list|,
name|sectionOrder
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|newSec
operator|->
name|setOutputSectionName
argument_list|(
name|getOutputSectionName
argument_list|(
name|da
operator|->
name|file
argument_list|()
operator|.
name|archivePath
argument_list|()
argument_list|,
name|da
operator|->
name|file
argument_list|()
operator|.
name|memberPath
argument_list|()
argument_list|,
name|sectionName
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|newSec
operator|->
name|setOrder
argument_list|(
name|sectionOrder
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|newSec
operator|->
name|setArchiveNameOrPath
argument_list|(
name|da
operator|->
name|file
argument_list|()
operator|.
name|archivePath
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|newSec
operator|->
name|setMemberNameOrPath
argument_list|(
name|da
operator|->
name|file
argument_list|()
operator|.
name|memberPath
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_sections
operator|.
name|push_back
argument_list|(
name|newSec
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|_sectionMap
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|sectionKey
argument_list|,
name|newSec
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|newSec
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|ErrorOr
operator|<
specifier|const
name|lld
operator|::
name|AtomLayout
operator|*
operator|>
name|DefaultLayout
operator|<
name|ELFT
operator|>
operator|::
name|addAtom
argument_list|(
argument|const Atom *atom
argument_list|)
block|{
if|if
condition|(
specifier|const
name|DefinedAtom
modifier|*
name|definedAtom
init|=
name|dyn_cast
operator|<
name|DefinedAtom
operator|>
operator|(
name|atom
operator|)
condition|)
block|{
comment|// HACK: Ignore undefined atoms. We need to adjust the interface so that
comment|// undefined atoms can still be included in the output symbol table for
comment|// -noinhibit-exec.
if|if
condition|(
name|definedAtom
operator|->
name|contentType
argument_list|()
operator|==
name|DefinedAtom
operator|::
name|typeUnknown
condition|)
return|return
name|make_error_code
argument_list|(
name|llvm
operator|::
name|errc
operator|::
name|invalid_argument
argument_list|)
return|;
specifier|const
name|DefinedAtom
operator|::
name|ContentPermissions
name|permissions
operator|=
name|definedAtom
operator|->
name|permissions
argument_list|()
expr_stmt|;
specifier|const
name|DefinedAtom
operator|::
name|ContentType
name|contentType
operator|=
name|definedAtom
operator|->
name|contentType
argument_list|()
expr_stmt|;
name|StringRef
name|sectionName
init|=
name|getInputSectionName
argument_list|(
name|definedAtom
argument_list|)
decl_stmt|;
name|AtomSection
operator|<
name|ELFT
operator|>
operator|*
name|section
operator|=
name|getSection
argument_list|(
name|sectionName
argument_list|,
name|contentType
argument_list|,
name|permissions
argument_list|,
name|definedAtom
argument_list|)
expr_stmt|;
comment|// Add runtime relocations to the .rela section.
for|for
control|(
specifier|const
specifier|auto
modifier|&
name|reloc
range|:
operator|*
name|definedAtom
control|)
block|{
name|bool
name|isLocalReloc
init|=
name|true
decl_stmt|;
if|if
condition|(
name|_context
operator|.
name|isDynamicRelocation
argument_list|(
operator|*
name|reloc
argument_list|)
condition|)
block|{
name|getDynamicRelocationTable
argument_list|()
operator|->
name|addRelocation
argument_list|(
operator|*
name|definedAtom
argument_list|,
operator|*
name|reloc
argument_list|)
expr_stmt|;
name|isLocalReloc
operator|=
name|false
expr_stmt|;
block|}
end_expr_stmt

begin_elseif
elseif|else
if|if
condition|(
name|_context
operator|.
name|isPLTRelocation
argument_list|(
operator|*
name|reloc
argument_list|)
condition|)
block|{
name|getPLTRelocationTable
argument_list|()
operator|->
name|addRelocation
argument_list|(
operator|*
name|definedAtom
argument_list|,
operator|*
name|reloc
argument_list|)
expr_stmt|;
name|isLocalReloc
operator|=
name|false
expr_stmt|;
block|}
end_elseif

begin_if
if|if
condition|(
operator|!
name|reloc
operator|->
name|target
argument_list|()
condition|)
continue|continue;
end_if

begin_comment
comment|//Ignore undefined atoms that are not target of dynamic relocations
end_comment

begin_if
if|if
condition|(
name|isa
operator|<
name|UndefinedAtom
operator|>
operator|(
name|reloc
operator|->
name|target
argument_list|()
operator|)
operator|&&
name|isLocalReloc
condition|)
continue|continue;
end_if

begin_if
if|if
condition|(
name|_context
operator|.
name|isCopyRelocation
argument_list|(
operator|*
name|reloc
argument_list|)
condition|)
block|{
name|_copiedDynSymNames
operator|.
name|insert
argument_list|(
name|definedAtom
operator|->
name|name
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
end_if

begin_expr_stmt
name|_referencedDynAtoms
operator|.
name|insert
argument_list|(
name|reloc
operator|->
name|target
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}      return
name|section
operator|->
name|appendAtom
argument_list|(
name|atom
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
unit|} else
if|if
condition|(
specifier|const
name|AbsoluteAtom
modifier|*
name|absoluteAtom
init|=
name|dyn_cast
operator|<
name|AbsoluteAtom
operator|>
operator|(
name|atom
operator|)
condition|)
block|{
comment|// Absolute atoms are not part of any section, they are global for the whole
comment|// link
name|_absoluteAtoms
operator|.
name|push_back
argument_list|(
name|new
argument_list|(
argument|_allocator
argument_list|)
name|lld
operator|::
name|AtomLayout
argument_list|(
name|absoluteAtom
argument_list|,
literal|0
argument_list|,
name|absoluteAtom
operator|->
name|value
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|_absoluteAtoms
operator|.
name|back
argument_list|()
return|;
block|}
else|else
block|{
name|llvm_unreachable
argument_list|(
literal|"Only absolute / defined atoms can be added here"
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
unit|}
comment|/// Output sections with the same name into a OutputSection
end_comment

begin_expr_stmt
unit|template
operator|<
name|class
name|ELFT
operator|>
name|void
name|DefaultLayout
operator|<
name|ELFT
operator|>
operator|::
name|createOutputSections
argument_list|()
block|{
name|OutputSection
operator|<
name|ELFT
operator|>
operator|*
name|outputSection
block|;
for|for
control|(
name|auto
operator|&
name|si
operator|:
name|_sections
control|)
block|{
name|Section
operator|<
name|ELFT
operator|>
operator|*
name|section
operator|=
name|dyn_cast
operator|<
name|Section
operator|<
name|ELFT
operator|>>
operator|(
name|si
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|section
condition|)
continue|continue;
specifier|const
name|std
operator|::
name|pair
operator|<
name|StringRef
operator|,
name|OutputSection
operator|<
name|ELFT
operator|>
operator|*
operator|>
name|currentOutputSection
argument_list|(
name|section
operator|->
name|outputSectionName
argument_list|()
argument_list|,
name|nullptr
argument_list|)
expr_stmt|;
name|std
operator|::
name|pair
operator|<
name|typename
name|OutputSectionMapT
operator|::
name|iterator
operator|,
name|bool
operator|>
name|outputSectionInsert
argument_list|(
name|_outputSectionMap
operator|.
name|insert
argument_list|(
name|currentOutputSection
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|outputSectionInsert
operator|.
name|second
condition|)
block|{
name|outputSection
operator|=
name|outputSectionInsert
operator|.
name|first
operator|->
name|second
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|outputSection
operator|=
name|new
argument_list|(
argument|_allocator.Allocate<OutputSection<ELFT>>()
argument_list|)
name|OutputSection
operator|<
name|ELFT
operator|>
operator|(
name|section
operator|->
name|outputSectionName
argument_list|()
operator|)
expr_stmt|;
name|_outputSections
operator|.
name|push_back
argument_list|(
name|outputSection
argument_list|)
expr_stmt|;
name|outputSectionInsert
operator|.
name|first
operator|->
name|second
operator|=
name|outputSection
expr_stmt|;
block|}
end_else

begin_expr_stmt
name|outputSection
operator|->
name|appendSection
argument_list|(
name|si
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|} }
name|template
operator|<
name|class
name|ELFT
operator|>
name|uint32_t
name|DefaultLayout
operator|<
name|ELFT
operator|>
operator|::
name|getPriorityFromSectionName
argument_list|(
argument|StringRef sectionName
argument_list|)
specifier|const
block|{
name|StringRef
name|priority
operator|=
name|sectionName
operator|.
name|drop_front
argument_list|()
operator|.
name|rsplit
argument_list|(
literal|'.'
argument_list|)
operator|.
name|second
block|;
name|uint32_t
name|prio
block|;
if|if
condition|(
name|priority
operator|.
name|getAsInteger
argument_list|(
literal|10
argument_list|,
name|prio
argument_list|)
condition|)
return|return
name|std
operator|::
name|numeric_limits
operator|<
name|uint32_t
operator|>
operator|::
name|max
argument_list|()
return|;
end_expr_stmt

begin_return
return|return
name|prio
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|void
name|DefaultLayout
operator|<
name|ELFT
operator|>
operator|::
name|sortOutputSectionByPriority
argument_list|(
argument|StringRef outputSectionName
argument_list|,
argument|StringRef prefix
argument_list|)
block|{
name|OutputSection
operator|<
name|ELFT
operator|>
operator|*
name|outputSection
operator|=
name|findOutputSection
argument_list|(
name|outputSectionName
argument_list|)
block|;
if|if
condition|(
operator|!
name|outputSection
condition|)
return|return;
name|auto
name|sections
operator|=
name|outputSection
operator|->
name|sections
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|sort
argument_list|(
name|sections
operator|.
name|begin
argument_list|()
argument_list|,
name|sections
operator|.
name|end
argument_list|()
argument_list|,
index|[
operator|&
index|]
operator|(
name|Chunk
operator|<
name|ELFT
operator|>
operator|*
name|lhs
operator|,
name|Chunk
operator|<
name|ELFT
operator|>
operator|*
name|rhs
operator|)
block|{
name|Section
operator|<
name|ELFT
operator|>
operator|*
name|lhsSection
operator|=
name|dyn_cast
operator|<
name|Section
operator|<
name|ELFT
operator|>>
operator|(
name|lhs
operator|)
block|;
name|Section
operator|<
name|ELFT
operator|>
operator|*
name|rhsSection
operator|=
name|dyn_cast
operator|<
name|Section
operator|<
name|ELFT
operator|>>
operator|(
name|rhs
operator|)
block|;
if|if
condition|(
operator|!
name|lhsSection
operator|||
operator|!
name|rhsSection
condition|)
return|return
name|false
return|;
name|StringRef
name|lhsSectionName
operator|=
name|lhsSection
operator|->
name|inputSectionName
argument_list|()
argument_list|;
name|StringRef
name|rhsSectionName
operator|=
name|rhsSection
operator|->
name|inputSectionName
argument_list|()
argument_list|;                if
operator|(
operator|!
name|prefix
operator|.
name|empty
argument_list|()
operator|)
block|{
if|if
condition|(
operator|!
name|lhsSectionName
operator|.
name|startswith
argument_list|(
name|prefix
argument_list|)
operator|||
operator|!
name|rhsSectionName
operator|.
name|startswith
argument_list|(
name|prefix
argument_list|)
condition|)
return|return
name|false
return|;
block|}
end_expr_stmt

begin_return
return|return
name|getPriorityFromSectionName
argument_list|(
name|lhsSectionName
argument_list|)
operator|<
name|getPriorityFromSectionName
argument_list|(
name|rhsSectionName
argument_list|)
return|;
end_return

begin_empty_stmt
unit|})
empty_stmt|;
end_empty_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|void
name|DefaultLayout
operator|<
name|ELFT
operator|>
operator|::
name|assignSectionsToSegments
argument_list|()
block|{
name|ScopedTask
name|task
argument_list|(
name|getDefaultDomain
argument_list|()
argument_list|,
literal|"assignSectionsToSegments"
argument_list|)
block|;
name|ELFLinkingContext
operator|::
name|OutputMagic
name|outputMagic
operator|=
name|_context
operator|.
name|getOutputMagic
argument_list|()
block|;
comment|// sort the sections by their order as defined by the layout
name|sortInputSections
argument_list|()
block|;
comment|// Create output sections.
name|createOutputSections
argument_list|()
block|;
comment|// Finalize output section layout.
name|finalizeOutputSectionLayout
argument_list|()
block|;
comment|// Set the ordinal after sorting the sections
name|int
name|ordinal
operator|=
literal|1
block|;
for|for
control|(
name|auto
name|osi
range|:
name|_outputSections
control|)
block|{
name|osi
operator|->
name|setOrdinal
argument_list|(
name|ordinal
argument_list|)
expr_stmt|;
for|for
control|(
name|auto
name|ai
range|:
name|osi
operator|->
name|sections
argument_list|()
control|)
block|{
name|ai
operator|->
name|setOrdinal
argument_list|(
name|ordinal
argument_list|)
expr_stmt|;
block|}
operator|++
name|ordinal
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}   for
operator|(
name|auto
name|osi
operator|:
name|_outputSections
operator|)
block|{
for|for
control|(
name|auto
name|ai
range|:
name|osi
operator|->
name|sections
argument_list|()
control|)
block|{
if|if
condition|(
name|auto
name|section
init|=
name|dyn_cast
operator|<
name|Section
operator|<
name|ELFT
operator|>
expr|>
operator|(
name|ai
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|hasOutputSegment
argument_list|(
name|section
argument_list|)
condition|)
continue|continue;
name|osi
operator|->
name|setLoadableSection
argument_list|(
name|section
operator|->
name|isLoadableSection
argument_list|()
argument_list|)
expr_stmt|;
comment|// Get the segment type for the section
name|int64_t
name|segmentType
init|=
name|getSegmentType
argument_list|(
name|section
argument_list|)
decl_stmt|;
name|osi
operator|->
name|setHasSegment
argument_list|()
expr_stmt|;
name|section
operator|->
name|setSegmentType
argument_list|(
name|segmentType
argument_list|)
expr_stmt|;
name|StringRef
name|segmentName
init|=
name|section
operator|->
name|segmentKindToStr
argument_list|()
decl_stmt|;
name|int64_t
name|lookupSectionFlag
init|=
name|osi
operator|->
name|flags
argument_list|()
decl_stmt|;
if|if
condition|(
operator|(
operator|!
operator|(
name|lookupSectionFlag
operator|&
name|llvm
operator|::
name|ELF
operator|::
name|SHF_WRITE
operator|)
operator|)
operator|&&
operator|(
name|_context
operator|.
name|mergeRODataToTextSegment
argument_list|()
operator|)
condition|)
name|lookupSectionFlag
operator|&=
operator|~
name|llvm
operator|::
name|ELF
operator|::
name|SHF_EXECINSTR
expr_stmt|;
comment|// Merge string sections into Data segment itself
name|lookupSectionFlag
operator|&=
operator|~
operator|(
name|llvm
operator|::
name|ELF
operator|::
name|SHF_STRINGS
operator||
name|llvm
operator|::
name|ELF
operator|::
name|SHF_MERGE
operator|)
expr_stmt|;
comment|// Merge the TLS section into the DATA segment itself
name|lookupSectionFlag
operator|&=
operator|~
operator|(
name|llvm
operator|::
name|ELF
operator|::
name|SHF_TLS
operator|)
expr_stmt|;
name|Segment
operator|<
name|ELFT
operator|>
operator|*
name|segment
expr_stmt|;
comment|// We need a separate segment for sections that don't have
comment|// the segment type to be PT_LOAD
if|if
condition|(
name|segmentType
operator|!=
name|llvm
operator|::
name|ELF
operator|::
name|PT_LOAD
condition|)
block|{
specifier|const
name|AdditionalSegmentKey
name|key
parameter_list|(
name|segmentType
parameter_list|,
name|lookupSectionFlag
parameter_list|)
function_decl|;
specifier|const
name|std
operator|::
name|pair
operator|<
name|AdditionalSegmentKey
operator|,
name|Segment
operator|<
name|ELFT
operator|>
operator|*
operator|>
name|additionalSegment
argument_list|(
name|key
argument_list|,
name|nullptr
argument_list|)
expr_stmt|;
name|std
operator|::
name|pair
operator|<
name|typename
name|AdditionalSegmentMapT
operator|::
name|iterator
operator|,
name|bool
operator|>
name|additionalSegmentInsert
argument_list|(
name|_additionalSegmentMap
operator|.
name|insert
argument_list|(
name|additionalSegment
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|additionalSegmentInsert
operator|.
name|second
condition|)
block|{
name|segment
operator|=
name|additionalSegmentInsert
operator|.
name|first
operator|->
name|second
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|segment
operator|=
name|new
argument_list|(
argument|_allocator
argument_list|)
name|Segment
operator|<
name|ELFT
operator|>
operator|(
name|_context
operator|,
name|segmentName
operator|,
name|segmentType
operator|)
expr_stmt|;
name|additionalSegmentInsert
operator|.
name|first
operator|->
name|second
operator|=
name|segment
expr_stmt|;
name|_segments
operator|.
name|push_back
argument_list|(
name|segment
argument_list|)
expr_stmt|;
block|}
end_else

begin_expr_stmt
name|segment
operator|->
name|append
argument_list|(
name|section
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}         if
operator|(
name|segmentType
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|PT_NULL
operator|)
end_expr_stmt

begin_continue
continue|continue;
end_continue

begin_comment
comment|// If the output magic is set to OutputMagic::NMAGIC or
end_comment

begin_comment
comment|// OutputMagic::OMAGIC, Place the data alongside text in one single
end_comment

begin_comment
comment|// segment
end_comment

begin_if
if|if
condition|(
name|outputMagic
operator|==
name|ELFLinkingContext
operator|::
name|OutputMagic
operator|::
name|NMAGIC
operator|||
name|outputMagic
operator|==
name|ELFLinkingContext
operator|::
name|OutputMagic
operator|::
name|OMAGIC
condition|)
name|lookupSectionFlag
operator|=
name|llvm
operator|::
name|ELF
operator|::
name|SHF_EXECINSTR
operator||
name|llvm
operator|::
name|ELF
operator|::
name|SHF_ALLOC
operator||
name|llvm
operator|::
name|ELF
operator|::
name|SHF_WRITE
expr_stmt|;
end_if

begin_comment
comment|// Use the flags of the merged Section for the segment
end_comment

begin_decl_stmt
specifier|const
name|SegmentKey
name|key
argument_list|(
literal|"PT_LOAD"
argument_list|,
name|lookupSectionFlag
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|const
name|std
operator|::
name|pair
operator|<
name|SegmentKey
operator|,
name|Segment
operator|<
name|ELFT
operator|>
operator|*
operator|>
name|currentSegment
argument_list|(
name|key
argument_list|,
name|nullptr
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|std
operator|::
name|pair
operator|<
name|typename
name|SegmentMapT
operator|::
name|iterator
operator|,
name|bool
operator|>
name|segmentInsert
argument_list|(
name|_segmentMap
operator|.
name|insert
argument_list|(
name|currentSegment
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|segmentInsert
operator|.
name|second
condition|)
block|{
name|segment
operator|=
name|segmentInsert
operator|.
name|first
operator|->
name|second
expr_stmt|;
block|}
else|else
block|{
name|segment
operator|=
name|new
argument_list|(
argument|_allocator
argument_list|)
name|Segment
operator|<
name|ELFT
operator|>
operator|(
name|_context
operator|,
literal|"PT_LOAD"
operator|,
name|llvm
operator|::
name|ELF
operator|::
name|PT_LOAD
operator|)
expr_stmt|;
name|segmentInsert
operator|.
name|first
operator|->
name|second
operator|=
name|segment
expr_stmt|;
name|_segments
operator|.
name|push_back
argument_list|(
name|segment
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|// Insert chunks with linker script expressions that occur at this
end_comment

begin_comment
comment|// point, just before appending a new input section
end_comment

begin_expr_stmt
name|addExtraChunksToSegment
argument_list|(
name|segment
argument_list|,
name|section
operator|->
name|archivePath
argument_list|()
argument_list|,
name|section
operator|->
name|memberPath
argument_list|()
argument_list|,
name|section
operator|->
name|inputSectionName
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|segment
operator|->
name|append
argument_list|(
name|section
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}     }   }   if
operator|(
name|_context
operator|.
name|isDynamic
argument_list|()
operator|&&
operator|!
name|_context
operator|.
name|isDynamicLibrary
argument_list|()
operator|)
block|{
name|Segment
operator|<
name|ELFT
operator|>
operator|*
name|segment
operator|=
name|new
argument_list|(
argument|_allocator
argument_list|)
name|ProgramHeaderSegment
operator|<
name|ELFT
operator|>
operator|(
name|_context
operator|)
block|;
name|_segments
operator|.
name|push_back
argument_list|(
name|segment
argument_list|)
block|;
name|segment
operator|->
name|append
argument_list|(
name|_elfHeader
argument_list|)
block|;
name|segment
operator|->
name|append
argument_list|(
name|_programHeader
argument_list|)
block|;   }
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|void
name|DefaultLayout
operator|<
name|ELFT
operator|>
operator|::
name|assignVirtualAddress
argument_list|()
block|{
if|if
condition|(
name|_segments
operator|.
name|empty
argument_list|()
condition|)
return|return;
name|std
operator|::
name|sort
argument_list|(
name|_segments
operator|.
name|begin
argument_list|()
argument_list|,
name|_segments
operator|.
name|end
argument_list|()
argument_list|,
name|Segment
operator|<
name|ELFT
operator|>
operator|::
name|compareSegments
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|uint64_t
name|baseAddress
init|=
name|_context
operator|.
name|getBaseAddress
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|// HACK: This is a super dirty hack. The elf header and program header are
end_comment

begin_comment
comment|// not part of a section, but we need them to be loaded at the base address
end_comment

begin_comment
comment|// so that AT_PHDR is set correctly by the loader and so they are accessible
end_comment

begin_comment
comment|// at runtime. To do this we simply prepend them to the first loadable Segment
end_comment

begin_comment
comment|// and let the layout logic take care of it.
end_comment

begin_expr_stmt
name|Segment
operator|<
name|ELFT
operator|>
operator|*
name|firstLoadSegment
operator|=
name|nullptr
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|auto
name|si
range|:
name|_segments
control|)
block|{
if|if
condition|(
name|si
operator|->
name|segmentType
argument_list|()
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|PT_LOAD
condition|)
block|{
name|firstLoadSegment
operator|=
name|si
expr_stmt|;
name|si
operator|->
name|firstSection
argument_list|()
operator|->
name|setAlign
argument_list|(
name|si
operator|->
name|alignment
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_for

begin_expr_stmt
name|assert
argument_list|(
name|firstLoadSegment
operator|!=
name|nullptr
operator|&&
literal|"No loadable segment!"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|firstLoadSegment
operator|->
name|prepend
argument_list|(
name|_programHeader
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|firstLoadSegment
operator|->
name|prepend
argument_list|(
name|_elfHeader
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|bool
name|newSegmentHeaderAdded
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|virtualAddressAssigned
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|fileOffsetAssigned
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_while
while|while
condition|(
name|true
condition|)
block|{
for|for
control|(
name|auto
name|si
range|:
name|_segments
control|)
block|{
name|si
operator|->
name|finalize
argument_list|()
expr_stmt|;
comment|// Don't add PT_NULL segments into the program header
if|if
condition|(
name|si
operator|->
name|segmentType
argument_list|()
operator|!=
name|llvm
operator|::
name|ELF
operator|::
name|PT_NULL
condition|)
name|newSegmentHeaderAdded
operator|=
name|_programHeader
operator|->
name|addSegment
argument_list|(
name|si
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|newSegmentHeaderAdded
operator|&&
name|virtualAddressAssigned
condition|)
break|break;
name|uint64_t
name|address
init|=
name|baseAddress
decl_stmt|;
comment|// start assigning virtual addresses
for|for
control|(
name|auto
operator|&
name|si
operator|:
name|_segments
control|)
block|{
if|if
condition|(
operator|(
name|si
operator|->
name|segmentType
argument_list|()
operator|!=
name|llvm
operator|::
name|ELF
operator|::
name|PT_LOAD
operator|)
operator|&&
operator|(
name|si
operator|->
name|segmentType
argument_list|()
operator|!=
name|llvm
operator|::
name|ELF
operator|::
name|PT_NULL
operator|)
condition|)
continue|continue;
if|if
condition|(
name|si
operator|->
name|segmentType
argument_list|()
operator|==
name|llvm
operator|::
name|ELF
operator|::
name|PT_NULL
condition|)
block|{
name|si
operator|->
name|assignVirtualAddress
argument_list|(
literal|0
comment|/*non loadable*/
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|virtualAddressAssigned
operator|&&
operator|(
name|address
operator|!=
name|baseAddress
operator|)
operator|&&
operator|(
name|address
operator|==
name|si
operator|->
name|virtualAddr
argument_list|()
operator|)
condition|)
break|break;
name|si
operator|->
name|assignVirtualAddress
argument_list|(
name|address
argument_list|)
expr_stmt|;
block|}
name|address
operator|=
name|si
operator|->
name|virtualAddr
argument_list|()
operator|+
name|si
operator|->
name|memSize
argument_list|()
expr_stmt|;
block|}
name|uint64_t
name|baseFileOffset
init|=
literal|0
decl_stmt|;
name|uint64_t
name|fileoffset
init|=
name|baseFileOffset
decl_stmt|;
for|for
control|(
name|auto
operator|&
name|si
operator|:
name|_segments
control|)
block|{
if|if
condition|(
operator|(
name|si
operator|->
name|segmentType
argument_list|()
operator|!=
name|llvm
operator|::
name|ELF
operator|::
name|PT_LOAD
operator|)
operator|&&
operator|(
name|si
operator|->
name|segmentType
argument_list|()
operator|!=
name|llvm
operator|::
name|ELF
operator|::
name|PT_NULL
operator|)
condition|)
continue|continue;
if|if
condition|(
name|fileOffsetAssigned
operator|&&
operator|(
name|fileoffset
operator|!=
name|baseFileOffset
operator|)
operator|&&
operator|(
name|fileoffset
operator|==
name|si
operator|->
name|fileOffset
argument_list|()
operator|)
condition|)
break|break;
name|si
operator|->
name|assignFileOffsets
argument_list|(
name|fileoffset
argument_list|)
expr_stmt|;
name|fileoffset
operator|=
name|si
operator|->
name|fileOffset
argument_list|()
operator|+
name|si
operator|->
name|fileSize
argument_list|()
expr_stmt|;
block|}
name|virtualAddressAssigned
operator|=
name|true
expr_stmt|;
name|fileOffsetAssigned
operator|=
name|true
expr_stmt|;
name|_programHeader
operator|->
name|resetProgramHeaders
argument_list|()
expr_stmt|;
block|}
end_while

begin_expr_stmt
name|Section
operator|<
name|ELFT
operator|>
operator|*
name|section
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Fix the offsets of all the atoms within a section
end_comment

begin_for
for|for
control|(
name|auto
operator|&
name|si
operator|:
name|_sections
control|)
block|{
name|section
operator|=
name|dyn_cast
operator|<
name|Section
operator|<
name|ELFT
operator|>>
operator|(
name|si
operator|)
expr_stmt|;
if|if
condition|(
name|section
operator|&&
name|DefaultLayout
operator|<
name|ELFT
operator|>
operator|::
name|hasOutputSegment
argument_list|(
name|section
argument_list|)
condition|)
name|section
operator|->
name|assignFileOffsets
argument_list|(
name|section
operator|->
name|fileOffset
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_for

begin_comment
comment|// Set the size of the merged Sections
end_comment

begin_for
for|for
control|(
name|auto
name|osi
range|:
name|_outputSections
control|)
block|{
name|uint64_t
name|sectionfileoffset
init|=
literal|0
decl_stmt|;
name|uint64_t
name|startFileOffset
init|=
literal|0
decl_stmt|;
name|uint64_t
name|sectionsize
init|=
literal|0
decl_stmt|;
name|bool
name|isFirstSection
init|=
name|true
decl_stmt|;
for|for
control|(
name|auto
name|si
range|:
name|osi
operator|->
name|sections
argument_list|()
control|)
block|{
if|if
condition|(
name|isFirstSection
condition|)
block|{
name|startFileOffset
operator|=
name|si
operator|->
name|fileOffset
argument_list|()
expr_stmt|;
name|isFirstSection
operator|=
name|false
expr_stmt|;
block|}
name|sectionfileoffset
operator|=
name|si
operator|->
name|fileOffset
argument_list|()
expr_stmt|;
name|sectionsize
operator|=
name|si
operator|->
name|fileSize
argument_list|()
expr_stmt|;
block|}
name|sectionsize
operator|=
operator|(
name|sectionfileoffset
operator|-
name|startFileOffset
operator|)
operator|+
name|sectionsize
expr_stmt|;
name|osi
operator|->
name|setFileOffset
argument_list|(
name|startFileOffset
argument_list|)
expr_stmt|;
name|osi
operator|->
name|setSize
argument_list|(
name|sectionsize
argument_list|)
expr_stmt|;
block|}
end_for

begin_comment
comment|// Set the virtual addr of the merged Sections
end_comment

begin_for
for|for
control|(
name|auto
name|osi
range|:
name|_outputSections
control|)
block|{
name|uint64_t
name|sectionstartaddr
init|=
literal|0
decl_stmt|;
name|uint64_t
name|startaddr
init|=
literal|0
decl_stmt|;
name|uint64_t
name|sectionsize
init|=
literal|0
decl_stmt|;
name|bool
name|isFirstSection
init|=
name|true
decl_stmt|;
for|for
control|(
name|auto
name|si
range|:
name|osi
operator|->
name|sections
argument_list|()
control|)
block|{
if|if
condition|(
name|isFirstSection
condition|)
block|{
name|startaddr
operator|=
name|si
operator|->
name|virtualAddr
argument_list|()
expr_stmt|;
name|isFirstSection
operator|=
name|false
expr_stmt|;
block|}
name|sectionstartaddr
operator|=
name|si
operator|->
name|virtualAddr
argument_list|()
expr_stmt|;
name|sectionsize
operator|=
name|si
operator|->
name|memSize
argument_list|()
expr_stmt|;
block|}
name|sectionsize
operator|=
operator|(
name|sectionstartaddr
operator|-
name|startaddr
operator|)
operator|+
name|sectionsize
expr_stmt|;
name|osi
operator|->
name|setMemSize
argument_list|(
name|sectionsize
argument_list|)
expr_stmt|;
name|osi
operator|->
name|setAddr
argument_list|(
name|startaddr
argument_list|)
expr_stmt|;
block|}
end_for

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|void
name|DefaultLayout
operator|<
name|ELFT
operator|>
operator|::
name|assignFileOffsetsForMiscSections
argument_list|()
block|{
name|uint64_t
name|fileoffset
operator|=
literal|0
block|;
name|uint64_t
name|size
operator|=
literal|0
block|;
for|for
control|(
name|auto
name|si
range|:
name|_segments
control|)
block|{
comment|// Don't calculate offsets from non loadable segments
if|if
condition|(
operator|(
name|si
operator|->
name|segmentType
argument_list|()
operator|!=
name|llvm
operator|::
name|ELF
operator|::
name|PT_LOAD
operator|)
operator|&&
operator|(
name|si
operator|->
name|segmentType
argument_list|()
operator|!=
name|llvm
operator|::
name|ELF
operator|::
name|PT_NULL
operator|)
condition|)
continue|continue;
name|fileoffset
operator|=
name|si
operator|->
name|fileOffset
argument_list|()
expr_stmt|;
name|size
operator|=
name|si
operator|->
name|fileSize
argument_list|()
expr_stmt|;
block|}
name|fileoffset
operator|=
name|fileoffset
operator|+
name|size
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Section
operator|<
name|ELFT
operator|>
operator|*
name|section
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|auto
name|si
range|:
name|_sections
control|)
block|{
name|section
operator|=
name|dyn_cast
operator|<
name|Section
operator|<
name|ELFT
operator|>>
operator|(
name|si
operator|)
expr_stmt|;
if|if
condition|(
name|section
operator|&&
name|DefaultLayout
operator|<
name|ELFT
operator|>
operator|::
name|hasOutputSegment
argument_list|(
name|section
argument_list|)
condition|)
continue|continue;
name|fileoffset
operator|=
name|llvm
operator|::
name|RoundUpToAlignment
argument_list|(
name|fileoffset
argument_list|,
name|si
operator|->
name|alignment
argument_list|()
argument_list|)
expr_stmt|;
name|si
operator|->
name|setFileOffset
argument_list|(
name|fileoffset
argument_list|)
expr_stmt|;
name|si
operator|->
name|setVirtualAddr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|fileoffset
operator|+=
name|si
operator|->
name|fileSize
argument_list|()
expr_stmt|;
block|}
end_for

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|void
name|DefaultLayout
operator|<
name|ELFT
operator|>
operator|::
name|sortInputSections
argument_list|()
block|{
comment|// First, sort according to default layout's order
name|std
operator|::
name|stable_sort
argument_list|(
name|_sections
operator|.
name|begin
argument_list|()
argument_list|,
name|_sections
operator|.
name|end
argument_list|()
argument_list|,
index|[]
operator|(
name|Chunk
operator|<
name|ELFT
operator|>
operator|*
name|A
operator|,
name|Chunk
operator|<
name|ELFT
operator|>
operator|*
name|B
operator|)
block|{
return|return
name|A
operator|->
name|order
argument_list|()
operator|<
name|B
operator|->
name|order
argument_list|()
return|;
block|}
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_if
if|if
condition|(
operator|!
name|_linkerScriptSema
operator|.
name|hasLayoutCommands
argument_list|()
condition|)
return|return;
end_if

begin_comment
comment|// Sort the sections by their order as defined by the linker script
end_comment

begin_expr_stmt
name|std
operator|::
name|stable_sort
argument_list|(
name|this
operator|->
name|_sections
operator|.
name|begin
argument_list|()
argument_list|,
name|this
operator|->
name|_sections
operator|.
name|end
argument_list|()
argument_list|,
index|[
name|this
index|]
operator|(
name|Chunk
operator|<
name|ELFT
operator|>
operator|*
name|A
operator|,
name|Chunk
operator|<
name|ELFT
operator|>
operator|*
name|B
operator|)
block|{
name|auto
operator|*
name|a
operator|=
name|dyn_cast
operator|<
name|Section
operator|<
name|ELFT
operator|>>
operator|(
name|A
operator|)
block|;
name|auto
operator|*
name|b
operator|=
name|dyn_cast
operator|<
name|Section
operator|<
name|ELFT
operator|>>
operator|(
name|B
operator|)
block|;
if|if
condition|(
name|a
operator|==
name|nullptr
condition|)
return|return
name|false
return|;
if|if
condition|(
name|b
operator|==
name|nullptr
condition|)
return|return
name|true
return|;
end_expr_stmt

begin_return
return|return
name|_linkerScriptSema
operator|.
name|less
argument_list|(
block|{
name|a
operator|->
name|archivePath
argument_list|()
block|,
name|a
operator|->
name|memberPath
argument_list|()
block|,
name|a
operator|->
name|inputSectionName
argument_list|()
block|}
argument_list|,
block|{
name|b
operator|->
name|archivePath
argument_list|()
operator|,
name|b
operator|->
name|memberPath
argument_list|()
operator|,
name|b
operator|->
name|inputSectionName
argument_list|()
block|}
end_return

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_empty_stmt
unit|})
empty_stmt|;
end_empty_stmt

begin_comment
comment|// Now try to arrange sections with no mapping rules to sections with
end_comment

begin_comment
comment|// similar content
end_comment

begin_decl_stmt
name|auto
name|p
init|=
name|this
operator|->
name|_sections
operator|.
name|begin
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Find first section that has no assigned rule id
end_comment

begin_while
while|while
condition|(
name|p
operator|!=
name|this
operator|->
name|_sections
operator|.
name|end
argument_list|()
condition|)
block|{
name|auto
operator|*
name|sect
operator|=
name|dyn_cast
operator|<
name|AtomSection
operator|<
name|ELFT
operator|>>
operator|(
operator|*
name|p
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|sect
condition|)
break|break;
if|if
condition|(
operator|!
name|_linkerScriptSema
operator|.
name|hasMapping
argument_list|(
block|{
name|sect
operator|->
name|archivePath
argument_list|()
block|,
name|sect
operator|->
name|memberPath
argument_list|()
block|,
name|sect
operator|->
name|inputSectionName
argument_list|()
block|}
argument_list|)
condition|)
break|break;
operator|++
name|p
expr_stmt|;
block|}
end_while

begin_comment
comment|// For all sections that have no assigned rule id, try to move them near a
end_comment

begin_comment
comment|// section with similar contents
end_comment

begin_if
if|if
condition|(
name|p
operator|!=
name|this
operator|->
name|_sections
operator|.
name|begin
argument_list|()
condition|)
block|{
for|for
control|(
init|;
name|p
operator|!=
name|this
operator|->
name|_sections
operator|.
name|end
argument_list|()
condition|;
operator|++
name|p
control|)
block|{
name|auto
name|q
init|=
name|p
decl_stmt|;
operator|--
name|q
expr_stmt|;
while|while
condition|(
name|q
operator|!=
name|this
operator|->
name|_sections
operator|.
name|begin
argument_list|()
operator|&&
operator|(
operator|*
name|q
operator|)
operator|->
name|getContentType
argument_list|()
operator|!=
operator|(
operator|*
name|p
operator|)
operator|->
name|getContentType
argument_list|()
condition|)
operator|--
name|q
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|q
operator|)
operator|->
name|getContentType
argument_list|()
operator|!=
operator|(
operator|*
name|p
operator|)
operator|->
name|getContentType
argument_list|()
condition|)
continue|continue;
operator|++
name|q
expr_stmt|;
for|for
control|(
name|auto
name|i
init|=
name|p
init|;
name|i
operator|!=
name|q
condition|;
control|)
block|{
name|auto
name|next
init|=
name|i
operator|--
decl_stmt|;
name|std
operator|::
name|iter_swap
argument_list|(
name|i
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_if

begin_expr_stmt
unit|}  template
operator|<
name|class
name|ELFT
operator|>
name|void
name|DefaultLayout
operator|<
name|ELFT
operator|>
operator|::
name|addExtraChunksToSegment
argument_list|(
argument|Segment<ELFT> *segment
argument_list|,
argument|StringRef archivePath
argument_list|,
argument|StringRef memberPath
argument_list|,
argument|StringRef sectionName
argument_list|)
block|{
if|if
condition|(
operator|!
name|_linkerScriptSema
operator|.
name|hasLayoutCommands
argument_list|()
condition|)
return|return;
name|std
operator|::
name|vector
operator|<
specifier|const
name|script
operator|::
name|SymbolAssignment
operator|*
operator|>
name|exprs
operator|=
name|_linkerScriptSema
operator|.
name|getExprs
argument_list|(
block|{
name|archivePath
block|,
name|memberPath
block|,
name|sectionName
block|}
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|auto
name|expr
range|:
name|exprs
control|)
block|{
name|auto
name|expChunk
init|=
name|new
argument_list|(
argument|this->_allocator
argument_list|)
name|ExpressionChunk
operator|<
name|ELFT
operator|>
operator|(
name|this
operator|->
name|_context
expr|,
name|expr
operator|)
decl_stmt|;
name|segment
operator|->
name|append
argument_list|(
name|expChunk
argument_list|)
expr_stmt|;
block|}
end_for

begin_comment
unit|}  }
comment|// end namespace elf
end_comment

begin_comment
unit|}
comment|// end namespace lld
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

