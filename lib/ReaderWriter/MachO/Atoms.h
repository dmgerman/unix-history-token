begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- lib/ReaderWriter/MachO/Atoms.h -------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                             The LLVM Linker
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLD_READER_WRITER_MACHO_ATOMS_H
end_ifndef

begin_define
define|#
directive|define
name|LLD_READER_WRITER_MACHO_ATOMS_H
end_define

begin_include
include|#
directive|include
file|"lld/Core/Simple.h"
end_include

begin_decl_stmt
name|namespace
name|lld
block|{
name|namespace
name|mach_o
block|{
name|class
name|MachODefinedAtom
range|:
name|public
name|SimpleDefinedAtom
block|{
name|public
operator|:
name|MachODefinedAtom
argument_list|(
argument|const File&f
argument_list|,
argument|const StringRef name
argument_list|,
argument|Scope scope
argument_list|,
argument|ContentType type
argument_list|,
argument|Merge merge
argument_list|,
argument|bool thumb
argument_list|,
argument|bool noDeadStrip
argument_list|,
argument|const ArrayRef<uint8_t> content
argument_list|,
argument|Alignment align
argument_list|)
operator|:
name|SimpleDefinedAtom
argument_list|(
name|f
argument_list|)
block|,
name|_name
argument_list|(
name|name
argument_list|)
block|,
name|_content
argument_list|(
name|content
argument_list|)
block|,
name|_align
argument_list|(
name|align
argument_list|)
block|,
name|_contentType
argument_list|(
name|type
argument_list|)
block|,
name|_scope
argument_list|(
name|scope
argument_list|)
block|,
name|_merge
argument_list|(
name|merge
argument_list|)
block|,
name|_thumb
argument_list|(
name|thumb
argument_list|)
block|,
name|_noDeadStrip
argument_list|(
argument|noDeadStrip
argument_list|)
block|{}
comment|// Constructor for zero-fill content
name|MachODefinedAtom
argument_list|(
argument|const File&f
argument_list|,
argument|const StringRef name
argument_list|,
argument|Scope scope
argument_list|,
argument|uint64_t size
argument_list|,
argument|bool noDeadStrip
argument_list|,
argument|Alignment align
argument_list|)
operator|:
name|SimpleDefinedAtom
argument_list|(
name|f
argument_list|)
block|,
name|_name
argument_list|(
name|name
argument_list|)
block|,
name|_content
argument_list|(
name|ArrayRef
operator|<
name|uint8_t
operator|>
operator|(
name|nullptr
expr|,
name|size
operator|)
argument_list|)
block|,
name|_align
argument_list|(
name|align
argument_list|)
block|,
name|_contentType
argument_list|(
name|DefinedAtom
operator|::
name|typeZeroFill
argument_list|)
block|,
name|_scope
argument_list|(
name|scope
argument_list|)
block|,
name|_merge
argument_list|(
name|mergeNo
argument_list|)
block|,
name|_thumb
argument_list|(
name|false
argument_list|)
block|,
name|_noDeadStrip
argument_list|(
argument|noDeadStrip
argument_list|)
block|{}
name|uint64_t
name|size
argument_list|()
specifier|const
name|override
block|{
return|return
name|_content
operator|.
name|size
argument_list|()
return|;
block|}
name|ContentType
name|contentType
argument_list|()
specifier|const
name|override
block|{
return|return
name|_contentType
return|;
block|}
name|Alignment
name|alignment
argument_list|()
specifier|const
name|override
block|{
return|return
name|_align
return|;
block|}
name|StringRef
name|name
argument_list|()
specifier|const
name|override
block|{
return|return
name|_name
return|;
block|}
name|Scope
name|scope
argument_list|()
specifier|const
name|override
block|{
return|return
name|_scope
return|;
block|}
name|Merge
name|merge
argument_list|()
specifier|const
name|override
block|{
return|return
name|_merge
return|;
block|}
name|DeadStripKind
name|deadStrip
argument_list|()
specifier|const
name|override
block|{
if|if
condition|(
name|_contentType
operator|==
name|DefinedAtom
operator|::
name|typeInitializerPtr
condition|)
return|return
name|deadStripNever
return|;
if|if
condition|(
name|_contentType
operator|==
name|DefinedAtom
operator|::
name|typeTerminatorPtr
condition|)
return|return
name|deadStripNever
return|;
if|if
condition|(
name|_noDeadStrip
condition|)
return|return
name|deadStripNever
return|;
return|return
name|deadStripNormal
return|;
block|}
name|ArrayRef
operator|<
name|uint8_t
operator|>
name|rawContent
argument_list|()
specifier|const
name|override
block|{
comment|// Note: Zerofill atoms have a content pointer which is null.
return|return
name|_content
return|;
block|}
name|bool
name|isThumb
argument_list|()
specifier|const
block|{
return|return
name|_thumb
return|;
block|}
name|void
name|addReference
argument_list|(
name|uint32_t
name|offsetInAtom
argument_list|,
name|uint16_t
name|relocType
argument_list|,
specifier|const
name|Atom
operator|*
name|target
argument_list|,
name|Reference
operator|::
name|Addend
name|addend
argument_list|,
name|Reference
operator|::
name|KindArch
name|arch
operator|=
name|Reference
operator|::
name|KindArch
operator|::
name|x86_64
argument_list|,
name|Reference
operator|::
name|KindNamespace
name|ns
operator|=
name|Reference
operator|::
name|KindNamespace
operator|::
name|mach_o
argument_list|)
block|{
name|SimpleDefinedAtom
operator|::
name|addReference
argument_list|(
name|ns
argument_list|,
name|arch
argument_list|,
name|relocType
argument_list|,
name|offsetInAtom
argument_list|,
name|target
argument_list|,
name|addend
argument_list|)
expr_stmt|;
block|}
name|private
label|:
specifier|const
name|StringRef
name|_name
decl_stmt|;
specifier|const
name|ArrayRef
operator|<
name|uint8_t
operator|>
name|_content
expr_stmt|;
specifier|const
name|DefinedAtom
operator|::
name|Alignment
name|_align
expr_stmt|;
specifier|const
name|ContentType
name|_contentType
decl_stmt|;
specifier|const
name|Scope
name|_scope
decl_stmt|;
specifier|const
name|Merge
name|_merge
decl_stmt|;
specifier|const
name|bool
name|_thumb
decl_stmt|;
specifier|const
name|bool
name|_noDeadStrip
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|class
name|MachODefinedCustomSectionAtom
range|:
name|public
name|MachODefinedAtom
block|{
name|public
operator|:
name|MachODefinedCustomSectionAtom
argument_list|(
argument|const File&f
argument_list|,
argument|const StringRef name
argument_list|,
argument|Scope scope
argument_list|,
argument|ContentType type
argument_list|,
argument|Merge merge
argument_list|,
argument|bool thumb
argument_list|,
argument|bool noDeadStrip
argument_list|,
argument|const ArrayRef<uint8_t> content
argument_list|,
argument|StringRef sectionName
argument_list|,
argument|Alignment align
argument_list|)
operator|:
name|MachODefinedAtom
argument_list|(
name|f
argument_list|,
name|name
argument_list|,
name|scope
argument_list|,
name|type
argument_list|,
name|merge
argument_list|,
name|thumb
argument_list|,
name|noDeadStrip
argument_list|,
name|content
argument_list|,
name|align
argument_list|)
block|,
name|_sectionName
argument_list|(
argument|sectionName
argument_list|)
block|{}
name|SectionChoice
name|sectionChoice
argument_list|()
specifier|const
name|override
block|{
return|return
name|DefinedAtom
operator|::
name|sectionCustomRequired
return|;
block|}
name|StringRef
name|customSectionName
argument_list|()
specifier|const
name|override
block|{
return|return
name|_sectionName
return|;
block|}
name|private
operator|:
name|StringRef
name|_sectionName
block|; }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|class
name|MachOTentativeDefAtom
range|:
name|public
name|SimpleDefinedAtom
block|{
name|public
operator|:
name|MachOTentativeDefAtom
argument_list|(
argument|const File&f
argument_list|,
argument|const StringRef name
argument_list|,
argument|Scope scope
argument_list|,
argument|uint64_t size
argument_list|,
argument|DefinedAtom::Alignment align
argument_list|)
operator|:
name|SimpleDefinedAtom
argument_list|(
name|f
argument_list|)
block|,
name|_name
argument_list|(
name|name
argument_list|)
block|,
name|_scope
argument_list|(
name|scope
argument_list|)
block|,
name|_size
argument_list|(
name|size
argument_list|)
block|,
name|_align
argument_list|(
argument|align
argument_list|)
block|{}
name|uint64_t
name|size
argument_list|()
specifier|const
name|override
block|{
return|return
name|_size
return|;
block|}
name|Merge
name|merge
argument_list|()
specifier|const
name|override
block|{
return|return
name|DefinedAtom
operator|::
name|mergeAsTentative
return|;
block|}
name|ContentType
name|contentType
argument_list|()
specifier|const
name|override
block|{
return|return
name|DefinedAtom
operator|::
name|typeZeroFill
return|;
block|}
name|Alignment
name|alignment
argument_list|()
specifier|const
name|override
block|{
return|return
name|_align
return|;
block|}
name|StringRef
name|name
argument_list|()
specifier|const
name|override
block|{
return|return
name|_name
return|;
block|}
name|Scope
name|scope
argument_list|()
specifier|const
name|override
block|{
return|return
name|_scope
return|;
block|}
name|ArrayRef
operator|<
name|uint8_t
operator|>
name|rawContent
argument_list|()
specifier|const
name|override
block|{
return|return
name|ArrayRef
operator|<
name|uint8_t
operator|>
operator|(
operator|)
return|;
block|}
name|private
operator|:
specifier|const
name|StringRef
name|_name
block|;
specifier|const
name|Scope
name|_scope
block|;
specifier|const
name|uint64_t
name|_size
block|;
specifier|const
name|DefinedAtom
operator|::
name|Alignment
name|_align
block|; }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|class
name|MachOSharedLibraryAtom
range|:
name|public
name|SharedLibraryAtom
block|{
name|public
operator|:
name|MachOSharedLibraryAtom
argument_list|(
argument|const File&file
argument_list|,
argument|StringRef name
argument_list|,
argument|StringRef dylibInstallName
argument_list|,
argument|bool weakDef
argument_list|)
operator|:
name|SharedLibraryAtom
argument_list|()
block|,
name|_file
argument_list|(
name|file
argument_list|)
block|,
name|_name
argument_list|(
name|name
argument_list|)
block|,
name|_dylibInstallName
argument_list|(
argument|dylibInstallName
argument_list|)
block|{}
name|virtual
operator|~
name|MachOSharedLibraryAtom
argument_list|()
block|{}
name|virtual
name|StringRef
name|loadName
argument_list|()
specifier|const
name|override
block|{
return|return
name|_dylibInstallName
return|;
block|}
name|virtual
name|bool
name|canBeNullAtRuntime
argument_list|()
specifier|const
name|override
block|{
comment|// FIXME: this may actually be changeable. For now, all symbols are strongly
comment|// defined though.
return|return
name|false
return|;
block|}
name|virtual
specifier|const
name|File
operator|&
name|file
argument_list|()
specifier|const
name|override
block|{
return|return
name|_file
return|;
block|}
name|virtual
name|StringRef
name|name
argument_list|()
specifier|const
name|override
block|{
return|return
name|_name
return|;
block|}
name|virtual
name|Type
name|type
argument_list|()
specifier|const
name|override
block|{
comment|// Unused in MachO (I think).
return|return
name|Type
operator|::
name|Unknown
return|;
block|}
name|virtual
name|uint64_t
name|size
argument_list|()
specifier|const
name|override
block|{
comment|// Unused in MachO (I think)
return|return
literal|0
return|;
block|}
name|private
operator|:
specifier|const
name|File
operator|&
name|_file
block|;
name|StringRef
name|_name
block|;
name|StringRef
name|_dylibInstallName
block|; }
decl_stmt|;
end_decl_stmt

begin_comment
unit|}
comment|// mach_o
end_comment

begin_comment
unit|}
comment|// lld
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

