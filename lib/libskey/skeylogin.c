begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   Login code for S/KEY Authentication.  S/KEY is a trademark  *   of Bellcore.  *  *   Mink is the former name of the S/KEY authentication system.  *   Many references for mink  may still be found in this program.   */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|QUOTA
end_ifdef

begin_include
include|#
directive|include
file|<sys/quota.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"skey.h"
end_include

begin_define
define|#
directive|define
name|KEYFILE
value|"/etc/skeykeys"
end_define

begin_function_decl
name|char
modifier|*
name|skipspace
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|skeylookup
name|__ARGS
argument_list|(
operator|(
expr|struct
name|skey
operator|*
name|mp
operator|,
name|char
operator|*
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|setpriority
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
end_define

begin_comment
comment|/* nothing */
end_comment

begin_comment
comment|/* Issue a skey challenge for user 'name'. If successful,  * fill in the caller's skey structure and return 0. If unsuccessful  * (e.g., if name is unknown) return -1.  *  * The file read/write pointer is left at the start of the  * record.  */
end_comment

begin_function
name|int
name|getskeyprompt
parameter_list|(
name|mp
parameter_list|,
name|name
parameter_list|,
name|prompt
parameter_list|)
name|struct
name|skey
modifier|*
name|mp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|prompt
decl_stmt|;
block|{
name|int
name|rval
decl_stmt|;
name|sevenbit
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|rval
operator|=
name|skeylookup
argument_list|(
name|mp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|prompt
argument_list|,
literal|"s/key 55 latour1\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rval
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* File error */
return|return
operator|-
literal|1
return|;
case|case
literal|0
case|:
comment|/* Lookup succeeded, return challenge */
name|sprintf
argument_list|(
name|prompt
argument_list|,
literal|"s/key %d %s\n"
argument_list|,
name|mp
operator|->
name|n
operator|-
literal|1
argument_list|,
name|mp
operator|->
name|seed
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|1
case|:
comment|/* User not found */
name|fclose
argument_list|(
name|mp
operator|->
name|keyfile
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|-
literal|1
return|;
comment|/* Can't happen */
block|}
end_function

begin_comment
comment|/* Return  a skey challenge string for user 'name'. If successful,  * fill in the caller's skey structure and return 0. If unsuccessful  * (e.g., if name is unknown) return -1.  *  * The file read/write pointer is left at the start of the  * record.  */
end_comment

begin_function
name|int
name|skeychallenge
parameter_list|(
name|mp
parameter_list|,
name|name
parameter_list|,
name|ss
parameter_list|)
name|struct
name|skey
modifier|*
name|mp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|ss
decl_stmt|;
block|{
name|int
name|rval
decl_stmt|;
name|rval
operator|=
name|skeylookup
argument_list|(
name|mp
argument_list|,
name|name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rval
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* File error */
return|return
operator|-
literal|1
return|;
case|case
literal|0
case|:
comment|/* Lookup succeeded, issue challenge */
name|sprintf
argument_list|(
name|ss
argument_list|,
literal|"s/key %d %s"
argument_list|,
name|mp
operator|->
name|n
operator|-
literal|1
argument_list|,
name|mp
operator|->
name|seed
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|1
case|:
comment|/* User not found */
name|fclose
argument_list|(
name|mp
operator|->
name|keyfile
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|-
literal|1
return|;
comment|/* Can't happen */
block|}
end_function

begin_comment
comment|/* Find an entry in the One-time Password database.  * Return codes:  * -1: error in opening database  *  0: entry found, file R/W pointer positioned at beginning of record  *  1: entry not found, file R/W pointer positioned at EOF  */
end_comment

begin_function
name|int
name|skeylookup
parameter_list|(
name|mp
parameter_list|,
name|name
parameter_list|)
name|struct
name|skey
modifier|*
name|mp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|found
decl_stmt|;
name|int
name|len
decl_stmt|;
name|long
name|recstart
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
comment|/* See if the KEYFILE exists, and create it if not */
if|if
condition|(
name|stat
argument_list|(
name|KEYFILE
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|mp
operator|->
name|keyfile
operator|=
name|fopen
argument_list|(
name|KEYFILE
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|KEYFILE
argument_list|,
literal|0644
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise open normally for update */
name|mp
operator|->
name|keyfile
operator|=
name|fopen
argument_list|(
name|KEYFILE
argument_list|,
literal|"r+"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mp
operator|->
name|keyfile
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Look up user name in database */
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|8
condition|)
name|len
operator|=
literal|8
expr_stmt|;
comment|/*  Added 8/2/91  -  nmh */
name|found
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|mp
operator|->
name|keyfile
argument_list|)
condition|)
block|{
name|recstart
operator|=
name|ftell
argument_list|(
name|mp
operator|->
name|keyfile
argument_list|)
expr_stmt|;
name|mp
operator|->
name|recstart
operator|=
name|recstart
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|mp
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|mp
operator|->
name|buf
argument_list|)
argument_list|,
name|mp
operator|->
name|keyfile
argument_list|)
operator|!=
name|mp
operator|->
name|buf
condition|)
block|{
break|break;
block|}
name|rip
argument_list|(
name|mp
operator|->
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|buf
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
continue|continue;
comment|/* Comment */
if|if
condition|(
operator|(
name|mp
operator|->
name|logname
operator|=
name|strtok
argument_list|(
name|mp
operator|->
name|buf
argument_list|,
literal|" \t"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|cp
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" \t"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
name|mp
operator|->
name|n
operator|=
name|atoi
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mp
operator|->
name|seed
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" \t"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
operator|(
name|mp
operator|->
name|val
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" \t"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|strlen
argument_list|(
name|mp
operator|->
name|logname
argument_list|)
operator|==
name|len
operator|&&
name|strncmp
argument_list|(
name|mp
operator|->
name|logname
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found
condition|)
block|{
name|fseek
argument_list|(
name|mp
operator|->
name|keyfile
argument_list|,
name|recstart
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Verify response to a s/key challenge.  *  * Return codes:  * -1: Error of some sort; database unchanged  *  0:  Verify successful, database updated  *  1:  Verify failed, database unchanged  *  * The database file is always closed by this call.  */
end_comment

begin_function
name|int
name|skeyverify
parameter_list|(
name|mp
parameter_list|,
name|response
parameter_list|)
name|struct
name|skey
modifier|*
name|mp
decl_stmt|;
name|char
modifier|*
name|response
decl_stmt|;
block|{
name|struct
name|timeval
name|startval
decl_stmt|;
name|struct
name|timeval
name|endval
decl_stmt|;
name|long
name|microsec
decl_stmt|;
name|char
name|key
index|[
literal|8
index|]
decl_stmt|;
name|char
name|fkey
index|[
literal|8
index|]
decl_stmt|;
name|char
name|filekey
index|[
literal|8
index|]
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
name|char
name|tbuf
index|[
literal|27
index|]
decl_stmt|,
name|buf
index|[
literal|60
index|]
decl_stmt|;
name|char
name|me
index|[
literal|80
index|]
decl_stmt|;
name|int
name|rval
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|tm
operator|=
name|localtime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|strftime
argument_list|(
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|,
literal|" %b %d,%Y %T"
argument_list|,
name|tm
argument_list|)
expr_stmt|;
if|if
condition|(
name|response
operator|==
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|mp
operator|->
name|keyfile
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|rip
argument_list|(
name|response
argument_list|)
expr_stmt|;
comment|/* Convert response to binary */
if|if
condition|(
name|etob
argument_list|(
name|key
argument_list|,
name|response
argument_list|)
operator|!=
literal|1
operator|&&
name|atob8
argument_list|(
name|key
argument_list|,
name|response
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Neither english words or ascii hex */
name|fclose
argument_list|(
name|mp
operator|->
name|keyfile
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Compute fkey = f(key) */
name|memcpy
argument_list|(
name|fkey
argument_list|,
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|f
argument_list|(
name|fkey
argument_list|)
expr_stmt|;
comment|/* in order to make the window of update as short as possible            we must do the comparison here and if OK write it back            other wise the same password can be used twice to get in   	   to the system 	*/
name|setpriority
argument_list|(
name|PRIO_PROCESS
argument_list|,
literal|0
argument_list|,
operator|-
literal|4
argument_list|)
expr_stmt|;
comment|/*   gettimeofday(&startval, (char *)0 ); */
comment|/* reread the file record NOW*/
name|fseek
argument_list|(
name|mp
operator|->
name|keyfile
argument_list|,
name|mp
operator|->
name|recstart
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|mp
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|mp
operator|->
name|buf
argument_list|)
argument_list|,
name|mp
operator|->
name|keyfile
argument_list|)
operator|!=
name|mp
operator|->
name|buf
condition|)
block|{
name|setpriority
argument_list|(
name|PRIO_PROCESS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|mp
operator|->
name|keyfile
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|rip
argument_list|(
name|mp
operator|->
name|buf
argument_list|)
expr_stmt|;
name|mp
operator|->
name|logname
operator|=
name|strtok
argument_list|(
name|mp
operator|->
name|buf
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
name|cp
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
name|mp
operator|->
name|seed
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
name|mp
operator|->
name|val
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
comment|/* And convert file value to hex for comparison */
name|atob8
argument_list|(
name|filekey
argument_list|,
name|mp
operator|->
name|val
argument_list|)
expr_stmt|;
comment|/* Do actual comparison */
if|if
condition|(
name|memcmp
argument_list|(
name|filekey
argument_list|,
name|fkey
argument_list|,
literal|8
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Wrong response */
name|setpriority
argument_list|(
name|PRIO_PROCESS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|mp
operator|->
name|keyfile
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Update key in database by overwriting entire record. Note 	 * that we must write exactly the same number of bytes as in 	 * the original record (note fixed width field for N) 	 */
name|btoa8
argument_list|(
name|mp
operator|->
name|val
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|mp
operator|->
name|n
operator|--
expr_stmt|;
name|fseek
argument_list|(
name|mp
operator|->
name|keyfile
argument_list|,
name|mp
operator|->
name|recstart
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|mp
operator|->
name|keyfile
argument_list|,
literal|"%s %04d %-16s %s %-21s\n"
argument_list|,
name|mp
operator|->
name|logname
argument_list|,
name|mp
operator|->
name|n
argument_list|,
name|mp
operator|->
name|seed
argument_list|,
name|mp
operator|->
name|val
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
comment|/* gettimeofday(&endval, (char *)0 );  microsec = (endval.tv_sec - startval.tv_sec) * 1000000 + (endval.tv_usec - startval.tv_usec); fprintf(stderr, "window= %d micro seconds \n"  , microsec); */
name|fclose
argument_list|(
name|mp
operator|->
name|keyfile
argument_list|)
expr_stmt|;
name|setpriority
argument_list|(
name|PRIO_PROCESS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Convert 8-byte hex-ascii string to binary array  * Returns 0 on success, -1 on error  */
end_comment

begin_expr_stmt
name|atob8
argument_list|(
name|out
argument_list|,
name|in
argument_list|)
specifier|register
name|char
operator|*
name|out
operator|,
operator|*
name|in
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|val
decl_stmt|;
if|if
condition|(
name|in
operator|==
name|NULL
operator|||
name|out
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|in
operator|=
name|skipspace
argument_list|(
name|in
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|val
operator|=
name|htoi
argument_list|(
operator|*
name|in
operator|++
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|out
operator|=
name|val
operator|<<
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|in
operator|=
name|skipspace
argument_list|(
name|in
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|val
operator|=
name|htoi
argument_list|(
operator|*
name|in
operator|++
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|out
operator|++
operator||=
name|val
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|skipspace
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
else|else
return|return
name|cp
return|;
block|}
end_function

begin_comment
comment|/* Convert 8-byte binary array to hex-ascii string */
end_comment

begin_function
name|int
name|btoa8
parameter_list|(
name|out
parameter_list|,
name|in
parameter_list|)
specifier|register
name|char
modifier|*
name|out
decl_stmt|,
decl|*
name|in
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|in
operator|==
name|NULL
operator|||
name|out
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|out
argument_list|,
literal|"%02x"
argument_list|,
operator|*
name|in
operator|++
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|2
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Convert hex digit to binary integer */
end_comment

begin_function
name|int
name|htoi
parameter_list|(
name|c
parameter_list|)
specifier|register
name|char
name|c
decl_stmt|;
block|{
if|if
condition|(
literal|'0'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'9'
condition|)
return|return
name|c
operator|-
literal|'0'
return|;
if|if
condition|(
literal|'a'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'f'
condition|)
return|return
literal|10
operator|+
name|c
operator|-
literal|'a'
return|;
if|if
condition|(
literal|'A'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'F'
condition|)
return|return
literal|10
operator|+
name|c
operator|-
literal|'A'
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

end_unit

