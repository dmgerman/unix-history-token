begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   Login code for S/KEY Authentication.  S/KEY is a trademark  *   of Bellcore.  *  *   Mink is the former name of the S/KEY authentication system.  *   Many references for mink  may still be found in this program.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<utmp.h>
end_include

begin_include
include|#
directive|include
file|"skey.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_decl_stmt
specifier|static
name|char
modifier|*
name|skipspace
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|setpriority
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|z
parameter_list|)
end_define

begin_comment
comment|/* nothing */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|month
index|[
literal|12
index|]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jul"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Look up skey info for user 'name'. If successful, fill in the caller's  * skey structure and return 0. If unsuccessful (e.g., if name is unknown)  * return -1. If an optional challenge string buffer is given, update it.  *  * The file read/write pointer is left at the start of the  * record.  */
end_comment

begin_function
name|int
name|skeyinfo
parameter_list|(
name|mp
parameter_list|,
name|name
parameter_list|,
name|ss
parameter_list|)
name|struct
name|skey
modifier|*
name|mp
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|ss
decl_stmt|;
block|{
name|int
name|rval
decl_stmt|;
name|rval
operator|=
name|skeylookup
argument_list|(
name|mp
argument_list|,
name|name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rval
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* File error */
return|return
operator|-
literal|1
return|;
case|case
literal|0
case|:
comment|/* Lookup succeeded */
if|if
condition|(
name|ss
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|ss
argument_list|,
literal|"s/key %d %s"
argument_list|,
name|mp
operator|->
name|n
operator|-
literal|1
argument_list|,
name|mp
operator|->
name|seed
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|mp
operator|->
name|keyfile
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
case|case
literal|1
case|:
comment|/* User not found */
name|fclose
argument_list|(
name|mp
operator|->
name|keyfile
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|-
literal|1
return|;
comment|/* Can't happen */
block|}
end_function

begin_comment
comment|/* Return  a skey challenge string for user 'name'. If successful,  * fill in the caller's skey structure and return 0. If unsuccessful  * (e.g., if name is unknown) return -1.  *  * The file read/write pointer is left at the start of the  * record.  */
end_comment

begin_function
name|int
name|skeychallenge
parameter_list|(
name|mp
parameter_list|,
name|name
parameter_list|,
name|ss
parameter_list|)
name|struct
name|skey
modifier|*
name|mp
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|ss
decl_stmt|;
block|{
name|int
name|rval
decl_stmt|;
name|rval
operator|=
name|skeylookup
argument_list|(
name|mp
argument_list|,
name|name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rval
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* File error */
return|return
operator|-
literal|1
return|;
case|case
literal|0
case|:
comment|/* Lookup succeeded, issue challenge */
name|sprintf
argument_list|(
name|ss
argument_list|,
literal|"s/key %d %s"
argument_list|,
name|mp
operator|->
name|n
operator|-
literal|1
argument_list|,
name|mp
operator|->
name|seed
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
case|case
literal|1
case|:
comment|/* User not found */
name|fclose
argument_list|(
name|mp
operator|->
name|keyfile
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
operator|-
literal|1
return|;
comment|/* Can't happen */
block|}
end_function

begin_comment
comment|/* Find an entry in the One-time Password database.  * Return codes:  * -1: error in opening database  *  0: entry found, file R/W pointer positioned at beginning of record  *  1: entry not found, file R/W pointer positioned at EOF  */
end_comment

begin_function
name|int
name|skeylookup
parameter_list|(
name|mp
parameter_list|,
name|name
parameter_list|)
name|struct
name|skey
modifier|*
name|mp
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|found
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|long
name|recstart
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|mode_t
name|oldmask
decl_stmt|;
comment|/* See if the _PATH_SKEYFILE exists, and create it if not */
if|if
condition|(
name|stat
argument_list|(
name|_PATH_SKEYFILE
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|oldmask
operator|=
name|umask
argument_list|(
name|S_IRWXG
operator||
name|S_IRWXO
argument_list|)
expr_stmt|;
name|mp
operator|->
name|keyfile
operator|=
name|fopen
argument_list|(
name|_PATH_SKEYFILE
argument_list|,
literal|"w+"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
name|oldmask
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Otherwise open normally for update */
name|mp
operator|->
name|keyfile
operator|=
name|fopen
argument_list|(
name|_PATH_SKEYFILE
argument_list|,
literal|"r+"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mp
operator|->
name|keyfile
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Look up user name in database */
name|len
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|UT_NAMESIZE
condition|)
name|len
operator|=
name|UT_NAMESIZE
expr_stmt|;
name|found
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|mp
operator|->
name|keyfile
argument_list|)
condition|)
block|{
name|recstart
operator|=
name|ftell
argument_list|(
name|mp
operator|->
name|keyfile
argument_list|)
expr_stmt|;
name|mp
operator|->
name|recstart
operator|=
name|recstart
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|mp
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|mp
operator|->
name|buf
argument_list|)
argument_list|,
name|mp
operator|->
name|keyfile
argument_list|)
operator|!=
name|mp
operator|->
name|buf
condition|)
block|{
break|break;
block|}
name|rip
argument_list|(
name|mp
operator|->
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|buf
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
continue|continue;
comment|/* Comment */
name|p
operator|=
name|mp
operator|->
name|buf
expr_stmt|;
while|while
condition|(
operator|(
name|cp
operator|=
name|strsep
argument_list|(
operator|&
name|p
argument_list|,
literal|" \t"
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|*
name|cp
operator|==
literal|'\0'
condition|)
empty_stmt|;
if|if
condition|(
operator|(
name|mp
operator|->
name|logname
operator|=
name|cp
operator|)
operator|==
name|NULL
condition|)
continue|continue;
while|while
condition|(
operator|(
name|cp
operator|=
name|strsep
argument_list|(
operator|&
name|p
argument_list|,
literal|" \t"
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|*
name|cp
operator|==
literal|'\0'
condition|)
empty_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
continue|continue;
name|mp
operator|->
name|n
operator|=
name|atoi
argument_list|(
name|cp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cp
operator|=
name|strsep
argument_list|(
operator|&
name|p
argument_list|,
literal|" \t"
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|*
name|cp
operator|==
literal|'\0'
condition|)
empty_stmt|;
if|if
condition|(
operator|(
name|mp
operator|->
name|seed
operator|=
name|cp
operator|)
operator|==
name|NULL
condition|)
continue|continue;
while|while
condition|(
operator|(
name|cp
operator|=
name|strsep
argument_list|(
operator|&
name|p
argument_list|,
literal|" \t"
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|*
name|cp
operator|==
literal|'\0'
condition|)
empty_stmt|;
if|if
condition|(
operator|(
name|mp
operator|->
name|val
operator|=
name|cp
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|strlen
argument_list|(
name|mp
operator|->
name|logname
argument_list|)
operator|==
name|len
operator|&&
name|strncmp
argument_list|(
name|mp
operator|->
name|logname
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found
condition|)
block|{
name|fseek
argument_list|(
name|mp
operator|->
name|keyfile
argument_list|,
name|recstart
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Verify response to a s/key challenge.  *  * Return codes:  * -1: Error of some sort; database unchanged  *  0:  Verify successful, database updated  *  1:  Verify failed, database unchanged  *  * The database file is always closed by this call.  */
end_comment

begin_function
name|int
name|skeyverify
parameter_list|(
name|mp
parameter_list|,
name|response
parameter_list|)
name|struct
name|skey
modifier|*
name|mp
decl_stmt|;
name|char
modifier|*
name|response
decl_stmt|;
block|{
name|char
name|key
index|[
literal|8
index|]
decl_stmt|;
name|char
name|fkey
index|[
literal|8
index|]
decl_stmt|;
name|char
name|filekey
index|[
literal|8
index|]
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
name|char
name|tbuf
index|[
literal|27
index|]
decl_stmt|,
name|fbuf
index|[
literal|20
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|tm
operator|=
name|localtime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
comment|/* can't use %b here, because it can be in national form */
name|strftime
argument_list|(
name|fbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|fbuf
argument_list|)
argument_list|,
literal|"%d,%Y %T"
argument_list|,
name|tm
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|tbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|tbuf
argument_list|)
argument_list|,
literal|" %s %s"
argument_list|,
name|month
index|[
name|tm
operator|->
name|tm_mon
index|]
argument_list|,
name|fbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|response
operator|==
name|NULL
condition|)
block|{
name|fclose
argument_list|(
name|mp
operator|->
name|keyfile
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|rip
argument_list|(
name|response
argument_list|)
expr_stmt|;
comment|/* Convert response to binary */
if|if
condition|(
name|etob
argument_list|(
name|key
argument_list|,
name|response
argument_list|)
operator|!=
literal|1
operator|&&
name|atob8
argument_list|(
name|key
argument_list|,
name|response
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Neither english words or ascii hex */
name|fclose
argument_list|(
name|mp
operator|->
name|keyfile
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Compute fkey = f(key) */
name|memcpy
argument_list|(
name|fkey
argument_list|,
name|key
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|f
argument_list|(
name|fkey
argument_list|)
expr_stmt|;
comment|/* in order to make the window of update as short as possible            we must do the comparison here and if OK write it back            other wise the same password can be used twice to get in   	   to the system 	*/
name|setpriority
argument_list|(
name|PRIO_PROCESS
argument_list|,
literal|0
argument_list|,
operator|-
literal|4
argument_list|)
expr_stmt|;
comment|/* reread the file record NOW*/
name|fseek
argument_list|(
name|mp
operator|->
name|keyfile
argument_list|,
name|mp
operator|->
name|recstart
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|mp
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|mp
operator|->
name|buf
argument_list|)
argument_list|,
name|mp
operator|->
name|keyfile
argument_list|)
operator|!=
name|mp
operator|->
name|buf
condition|)
block|{
name|setpriority
argument_list|(
name|PRIO_PROCESS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|mp
operator|->
name|keyfile
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|rip
argument_list|(
name|mp
operator|->
name|buf
argument_list|)
expr_stmt|;
name|p
operator|=
name|mp
operator|->
name|buf
expr_stmt|;
while|while
condition|(
operator|(
name|cp
operator|=
name|strsep
argument_list|(
operator|&
name|p
argument_list|,
literal|" \t"
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|*
name|cp
operator|==
literal|'\0'
condition|)
empty_stmt|;
name|mp
operator|->
name|logname
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|(
name|cp
operator|=
name|strsep
argument_list|(
operator|&
name|p
argument_list|,
literal|" \t"
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|*
name|cp
operator|==
literal|'\0'
condition|)
empty_stmt|;
while|while
condition|(
operator|(
name|cp
operator|=
name|strsep
argument_list|(
operator|&
name|p
argument_list|,
literal|" \t"
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|*
name|cp
operator|==
literal|'\0'
condition|)
empty_stmt|;
name|mp
operator|->
name|seed
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|(
name|cp
operator|=
name|strsep
argument_list|(
operator|&
name|p
argument_list|,
literal|" \t"
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|*
name|cp
operator|==
literal|'\0'
condition|)
empty_stmt|;
name|mp
operator|->
name|val
operator|=
name|cp
expr_stmt|;
comment|/* And convert file value to hex for comparison */
name|atob8
argument_list|(
name|filekey
argument_list|,
name|mp
operator|->
name|val
argument_list|)
expr_stmt|;
comment|/* Do actual comparison */
if|if
condition|(
name|memcmp
argument_list|(
name|filekey
argument_list|,
name|fkey
argument_list|,
literal|8
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Wrong response */
name|setpriority
argument_list|(
name|PRIO_PROCESS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|mp
operator|->
name|keyfile
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* Update key in database by overwriting entire record. Note 	 * that we must write exactly the same number of bytes as in 	 * the original record (note fixed width field for N) 	 */
name|btoa8
argument_list|(
name|mp
operator|->
name|val
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|mp
operator|->
name|n
operator|--
expr_stmt|;
name|fseek
argument_list|(
name|mp
operator|->
name|keyfile
argument_list|,
name|mp
operator|->
name|recstart
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|mp
operator|->
name|keyfile
argument_list|,
literal|"%s %04d %-16s %s %-21s\n"
argument_list|,
name|mp
operator|->
name|logname
argument_list|,
name|mp
operator|->
name|n
argument_list|,
name|mp
operator|->
name|seed
argument_list|,
name|mp
operator|->
name|val
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|mp
operator|->
name|keyfile
argument_list|)
expr_stmt|;
name|setpriority
argument_list|(
name|PRIO_PROCESS
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Convert 8-byte hex-ascii string to binary array  * Returns 0 on success, -1 on error  */
end_comment

begin_function
name|int
name|atob8
parameter_list|(
name|out
parameter_list|,
name|in
parameter_list|)
specifier|register
name|char
modifier|*
name|out
decl_stmt|,
decl|*
name|in
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|val
decl_stmt|;
if|if
condition|(
name|in
operator|==
name|NULL
operator|||
name|out
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|in
operator|=
name|skipspace
argument_list|(
name|in
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|val
operator|=
name|htoi
argument_list|(
operator|*
name|in
operator|++
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|out
operator|=
name|val
operator|<<
literal|4
expr_stmt|;
if|if
condition|(
operator|(
name|in
operator|=
name|skipspace
argument_list|(
name|in
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|(
name|val
operator|=
name|htoi
argument_list|(
operator|*
name|in
operator|++
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
operator|*
name|out
operator|++
operator||=
name|val
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_function
specifier|static
name|char
modifier|*
name|skipspace
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
condition|)
name|cp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
else|else
return|return
name|cp
return|;
block|}
end_function

begin_comment
comment|/* Convert 8-byte binary array to hex-ascii string */
end_comment

begin_function
name|int
name|btoa8
parameter_list|(
name|out
parameter_list|,
name|in
parameter_list|)
specifier|register
name|char
modifier|*
name|out
decl_stmt|,
decl|*
name|in
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
if|if
condition|(
name|in
operator|==
name|NULL
operator|||
name|out
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|out
argument_list|,
literal|"%02x"
argument_list|,
operator|*
name|in
operator|++
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|out
operator|+=
literal|2
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Convert hex digit to binary integer */
end_comment

begin_function
name|int
name|htoi
parameter_list|(
name|c
parameter_list|)
specifier|register
name|char
name|c
decl_stmt|;
block|{
if|if
condition|(
literal|'0'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'9'
condition|)
return|return
name|c
operator|-
literal|'0'
return|;
if|if
condition|(
literal|'a'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'f'
condition|)
return|return
literal|10
operator|+
name|c
operator|-
literal|'a'
return|;
if|if
condition|(
literal|'A'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'F'
condition|)
return|return
literal|10
operator|+
name|c
operator|-
literal|'A'
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

end_unit

