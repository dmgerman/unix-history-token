begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*   * md4.c -- Implementation of MD4 Message Digest Algorithm  * Updated: 2/16/90 by Ronald L. Rivest  * (C) 1990 RSA Data Security, Inc.  *  * Portability nits fixed and reformatted - 2/12/91 Phil Karn  */
end_comment

begin_comment
comment|/*   * To use MD4:  *   -- Include md4.h in your program  *   -- Declare an MDstruct MD to hold the state of the digest computation.  *   -- Initialize MD using MDbegin(&MD)  *   -- For each full block (64 bytes) X you wish to process, call  *          MDupdate(&MD,X,512)  *      (512 is the number of bits in a full block.)  *   -- For the last block (less than 64 bytes) you wish to process,  *          MDupdate(&MD,X,n)  *      where n is the number of bits in the partial block. A partial  *      block terminates the computation, so every MD computation should  *      terminate by processing a partial block, even if it has n = 0.  *   -- The message digest is available in MD.buffer[0] ... MD.buffer[3].  *      (Least-significant byte of each word should be output first.)  *   -- You can print out the digest using MDprint(&MD)  */
end_comment

begin_comment
comment|/* Implementation notes:  * This implementation assumes that longs are 32-bit quantities.  * If the machine stores the least-significant byte of an long in the  * least-addressed byte (eg., VAX and 8086), then LOWBYTEFIRST should be  * set to TRUE.  Otherwise (eg., SUNS), LOWBYTEFIRST should be set to  * FALSE.  Note that on machines with LOWBYTEFIRST FALSE the routine  * MDupdate modifies has a side-effect on its input array (the order of bytes  * in each word are reversed).  If this is undesired a call to MDreverse(X) can  * reverse the bytes of X back into order after each call to MDupdate.  */
end_comment

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|__MSDOS__
argument_list|)
operator|||
name|defined
argument_list|(
name|MPU8086
argument_list|)
operator|||
name|defined
argument_list|(
name|MPU8080
argument_list|)
expr|\
operator|||
name|defined
argument_list|(
name|vax
argument_list|)
operator|||
name|defined
argument_list|(
name|MIPSEL
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|LOWBYTEFIRST
value|TRUE
end_define

begin_comment
comment|/* Low order bytes are first in memory */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Almost all other machines are big-endian */
end_comment

begin_define
define|#
directive|define
name|LOWBYTEFIRST
value|FALSE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Compile-time includes */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"md4.h"
end_include

begin_comment
comment|/* Compile-time declarations of MD4 ``magic constants'' */
end_comment

begin_define
define|#
directive|define
name|I0
value|0x67452301
end_define

begin_comment
comment|/* Initial values for MD buffer */
end_comment

begin_define
define|#
directive|define
name|I1
value|0xefcdab89
end_define

begin_define
define|#
directive|define
name|I2
value|0x98badcfe
end_define

begin_define
define|#
directive|define
name|I3
value|0x10325476
end_define

begin_define
define|#
directive|define
name|C2
value|013240474631
end_define

begin_comment
comment|/* round 2 constant = sqrt(2) in octal */
end_comment

begin_define
define|#
directive|define
name|C3
value|015666365641
end_define

begin_comment
comment|/* round 3 constant = sqrt(3) in octal */
end_comment

begin_comment
comment|/* C2 and C3 are from Knuth, The Art of Programming, Volume 2  * (Seminumerical Algorithms), Second Edition (1981), Addison-Wesley.  * Table 2, page 660.  */
end_comment

begin_define
define|#
directive|define
name|fs1
value|3
end_define

begin_comment
comment|/* round 1 shift amounts */
end_comment

begin_define
define|#
directive|define
name|fs2
value|7
end_define

begin_define
define|#
directive|define
name|fs3
value|11
end_define

begin_define
define|#
directive|define
name|fs4
value|19
end_define

begin_define
define|#
directive|define
name|gs1
value|3
end_define

begin_comment
comment|/* round 2 shift amounts */
end_comment

begin_define
define|#
directive|define
name|gs2
value|5
end_define

begin_define
define|#
directive|define
name|gs3
value|9
end_define

begin_define
define|#
directive|define
name|gs4
value|13
end_define

begin_define
define|#
directive|define
name|hs1
value|3
end_define

begin_comment
comment|/* round 3 shift amounts */
end_comment

begin_define
define|#
directive|define
name|hs2
value|9
end_define

begin_define
define|#
directive|define
name|hs3
value|11
end_define

begin_define
define|#
directive|define
name|hs4
value|15
end_define

begin_comment
comment|/* Compile-time macro declarations for MD4.  * Note: The ``rot'' operator uses the variable ``tmp''.  * It assumes tmp is declared as unsigned long, so that the>>  * operator will shift in zeros rather than extending the sign bit.  */
end_comment

begin_define
define|#
directive|define
name|f
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|,
name|Z
parameter_list|)
value|((X&Y) | ((~X)&Z))
end_define

begin_define
define|#
directive|define
name|g
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|,
name|Z
parameter_list|)
value|((X&Y) | (X&Z) | (Y&Z))
end_define

begin_define
define|#
directive|define
name|h
parameter_list|(
name|X
parameter_list|,
name|Y
parameter_list|,
name|Z
parameter_list|)
value|(X^Y^Z)
end_define

begin_define
define|#
directive|define
name|rot
parameter_list|(
name|X
parameter_list|,
name|S
parameter_list|)
value|(tmp=X,(tmp<<S) | (tmp>>(32-S)))
end_define

begin_define
define|#
directive|define
name|ff
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|,
name|C
parameter_list|,
name|D
parameter_list|,
name|i
parameter_list|,
name|s
parameter_list|)
value|A = rot((A + f(B,C,D) + X[i]),s)
end_define

begin_define
define|#
directive|define
name|gg
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|,
name|C
parameter_list|,
name|D
parameter_list|,
name|i
parameter_list|,
name|s
parameter_list|)
value|A = rot((A + g(B,C,D) + X[i] + C2),s)
end_define

begin_define
define|#
directive|define
name|hh
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|,
name|C
parameter_list|,
name|D
parameter_list|,
name|i
parameter_list|,
name|s
parameter_list|)
value|A = rot((A + h(B,C,D) + X[i] + C3),s)
end_define

begin_decl_stmt
name|void
name|MDreverse
name|__ARGS
argument_list|(
operator|(
name|unsigned
name|long
operator|*
name|X
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* MDprint(MDp)  * Print message digest buffer MDp as 32 hexadecimal digits.  * Order is from low-order byte of buffer[0] to high-order byte of buffer[3].  * Each byte is printed with high-order hexadecimal digit first.  * This is a user-callable routine.  */
end_comment

begin_function
name|void
name|MDprint
parameter_list|(
name|MDp
parameter_list|)
name|MDptr
name|MDp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|32
condition|;
name|j
operator|=
name|j
operator|+
literal|8
control|)
name|printf
argument_list|(
literal|"%02lx"
argument_list|,
operator|(
name|MDp
operator|->
name|buffer
index|[
name|i
index|]
operator|>>
name|j
operator|)
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* MDbegin(MDp)  * Initialize message digest buffer MDp.   * This is a user-callable routine.  */
end_comment

begin_function
name|void
name|MDbegin
parameter_list|(
name|MDp
parameter_list|)
name|MDptr
name|MDp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|MDp
operator|->
name|buffer
index|[
literal|0
index|]
operator|=
name|I0
expr_stmt|;
name|MDp
operator|->
name|buffer
index|[
literal|1
index|]
operator|=
name|I1
expr_stmt|;
name|MDp
operator|->
name|buffer
index|[
literal|2
index|]
operator|=
name|I2
expr_stmt|;
name|MDp
operator|->
name|buffer
index|[
literal|3
index|]
operator|=
name|I3
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|MDp
operator|->
name|count
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|MDp
operator|->
name|done
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* MDreverse(X)  * Reverse the byte-ordering of every long in X.  * Assumes X is an array of 16 longs.  * The macro revx reverses the byte-ordering of the next word of X.  */
end_comment

begin_define
define|#
directive|define
name|revx
value|{ t = (*X<< 16) | (*X>> 16); \ 	       *X++ = ((t& 0xFF00FF00)>> 8) | ((t& 0x00FF00FF)<< 8); }
end_define

begin_function
name|void
name|MDreverse
parameter_list|(
name|X
parameter_list|)
name|unsigned
name|long
modifier|*
name|X
decl_stmt|;
block|{
specifier|register
name|unsigned
name|long
name|t
decl_stmt|;
name|revx
expr_stmt|;
name|revx
expr_stmt|;
name|revx
expr_stmt|;
name|revx
expr_stmt|;
name|revx
expr_stmt|;
name|revx
expr_stmt|;
name|revx
expr_stmt|;
name|revx
expr_stmt|;
name|revx
expr_stmt|;
name|revx
expr_stmt|;
name|revx
expr_stmt|;
name|revx
expr_stmt|;
name|revx
expr_stmt|;
name|revx
expr_stmt|;
name|revx
expr_stmt|;
name|revx
expr_stmt|;
block|}
end_function

begin_comment
comment|/* MDblock(MDp,X)  * Update message digest buffer MDp->buffer using 16-word data block X.  * Assumes all 16 words of X are full of data.  * Does not update MDp->count.  * This routine is not user-callable.   */
end_comment

begin_function
specifier|static
name|void
name|MDblock
parameter_list|(
name|MDp
parameter_list|,
name|X
parameter_list|)
name|MDptr
name|MDp
decl_stmt|;
name|unsigned
name|long
modifier|*
name|X
decl_stmt|;
block|{
specifier|register
name|unsigned
name|long
name|tmp
decl_stmt|,
name|A
decl_stmt|,
name|B
decl_stmt|,
name|C
decl_stmt|,
name|D
decl_stmt|;
if|#
directive|if
name|LOWBYTEFIRST
operator|==
name|FALSE
name|MDreverse
argument_list|(
name|X
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|A
operator|=
name|MDp
operator|->
name|buffer
index|[
literal|0
index|]
expr_stmt|;
name|B
operator|=
name|MDp
operator|->
name|buffer
index|[
literal|1
index|]
expr_stmt|;
name|C
operator|=
name|MDp
operator|->
name|buffer
index|[
literal|2
index|]
expr_stmt|;
name|D
operator|=
name|MDp
operator|->
name|buffer
index|[
literal|3
index|]
expr_stmt|;
comment|/* Update the message digest buffer */
name|ff
argument_list|(
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
literal|0
argument_list|,
name|fs1
argument_list|)
expr_stmt|;
comment|/* Round 1 */
name|ff
argument_list|(
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
literal|1
argument_list|,
name|fs2
argument_list|)
expr_stmt|;
name|ff
argument_list|(
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
literal|2
argument_list|,
name|fs3
argument_list|)
expr_stmt|;
name|ff
argument_list|(
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
literal|3
argument_list|,
name|fs4
argument_list|)
expr_stmt|;
name|ff
argument_list|(
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
literal|4
argument_list|,
name|fs1
argument_list|)
expr_stmt|;
name|ff
argument_list|(
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
literal|5
argument_list|,
name|fs2
argument_list|)
expr_stmt|;
name|ff
argument_list|(
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
literal|6
argument_list|,
name|fs3
argument_list|)
expr_stmt|;
name|ff
argument_list|(
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
literal|7
argument_list|,
name|fs4
argument_list|)
expr_stmt|;
name|ff
argument_list|(
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
literal|8
argument_list|,
name|fs1
argument_list|)
expr_stmt|;
name|ff
argument_list|(
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
literal|9
argument_list|,
name|fs2
argument_list|)
expr_stmt|;
name|ff
argument_list|(
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
literal|10
argument_list|,
name|fs3
argument_list|)
expr_stmt|;
name|ff
argument_list|(
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
literal|11
argument_list|,
name|fs4
argument_list|)
expr_stmt|;
name|ff
argument_list|(
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
literal|12
argument_list|,
name|fs1
argument_list|)
expr_stmt|;
name|ff
argument_list|(
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
literal|13
argument_list|,
name|fs2
argument_list|)
expr_stmt|;
name|ff
argument_list|(
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
literal|14
argument_list|,
name|fs3
argument_list|)
expr_stmt|;
name|ff
argument_list|(
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
literal|15
argument_list|,
name|fs4
argument_list|)
expr_stmt|;
name|gg
argument_list|(
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
literal|0
argument_list|,
name|gs1
argument_list|)
expr_stmt|;
comment|/* Round 2 */
name|gg
argument_list|(
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
literal|4
argument_list|,
name|gs2
argument_list|)
expr_stmt|;
name|gg
argument_list|(
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
literal|8
argument_list|,
name|gs3
argument_list|)
expr_stmt|;
name|gg
argument_list|(
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
literal|12
argument_list|,
name|gs4
argument_list|)
expr_stmt|;
name|gg
argument_list|(
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
literal|1
argument_list|,
name|gs1
argument_list|)
expr_stmt|;
name|gg
argument_list|(
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
literal|5
argument_list|,
name|gs2
argument_list|)
expr_stmt|;
name|gg
argument_list|(
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
literal|9
argument_list|,
name|gs3
argument_list|)
expr_stmt|;
name|gg
argument_list|(
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
literal|13
argument_list|,
name|gs4
argument_list|)
expr_stmt|;
name|gg
argument_list|(
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
literal|2
argument_list|,
name|gs1
argument_list|)
expr_stmt|;
name|gg
argument_list|(
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
literal|6
argument_list|,
name|gs2
argument_list|)
expr_stmt|;
name|gg
argument_list|(
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
literal|10
argument_list|,
name|gs3
argument_list|)
expr_stmt|;
name|gg
argument_list|(
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
literal|14
argument_list|,
name|gs4
argument_list|)
expr_stmt|;
name|gg
argument_list|(
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
literal|3
argument_list|,
name|gs1
argument_list|)
expr_stmt|;
name|gg
argument_list|(
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
literal|7
argument_list|,
name|gs2
argument_list|)
expr_stmt|;
name|gg
argument_list|(
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
literal|11
argument_list|,
name|gs3
argument_list|)
expr_stmt|;
name|gg
argument_list|(
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
literal|15
argument_list|,
name|gs4
argument_list|)
expr_stmt|;
name|hh
argument_list|(
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
literal|0
argument_list|,
name|hs1
argument_list|)
expr_stmt|;
comment|/* Round 3 */
name|hh
argument_list|(
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
literal|8
argument_list|,
name|hs2
argument_list|)
expr_stmt|;
name|hh
argument_list|(
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
literal|4
argument_list|,
name|hs3
argument_list|)
expr_stmt|;
name|hh
argument_list|(
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
literal|12
argument_list|,
name|hs4
argument_list|)
expr_stmt|;
name|hh
argument_list|(
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
literal|2
argument_list|,
name|hs1
argument_list|)
expr_stmt|;
name|hh
argument_list|(
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
literal|10
argument_list|,
name|hs2
argument_list|)
expr_stmt|;
name|hh
argument_list|(
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
literal|6
argument_list|,
name|hs3
argument_list|)
expr_stmt|;
name|hh
argument_list|(
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
literal|14
argument_list|,
name|hs4
argument_list|)
expr_stmt|;
name|hh
argument_list|(
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
literal|1
argument_list|,
name|hs1
argument_list|)
expr_stmt|;
name|hh
argument_list|(
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
literal|9
argument_list|,
name|hs2
argument_list|)
expr_stmt|;
name|hh
argument_list|(
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
literal|5
argument_list|,
name|hs3
argument_list|)
expr_stmt|;
name|hh
argument_list|(
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
literal|13
argument_list|,
name|hs4
argument_list|)
expr_stmt|;
name|hh
argument_list|(
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
literal|3
argument_list|,
name|hs1
argument_list|)
expr_stmt|;
name|hh
argument_list|(
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
name|C
argument_list|,
literal|11
argument_list|,
name|hs2
argument_list|)
expr_stmt|;
name|hh
argument_list|(
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
name|B
argument_list|,
literal|7
argument_list|,
name|hs3
argument_list|)
expr_stmt|;
name|hh
argument_list|(
name|B
argument_list|,
name|C
argument_list|,
name|D
argument_list|,
name|A
argument_list|,
literal|15
argument_list|,
name|hs4
argument_list|)
expr_stmt|;
name|MDp
operator|->
name|buffer
index|[
literal|0
index|]
operator|+=
name|A
expr_stmt|;
name|MDp
operator|->
name|buffer
index|[
literal|1
index|]
operator|+=
name|B
expr_stmt|;
name|MDp
operator|->
name|buffer
index|[
literal|2
index|]
operator|+=
name|C
expr_stmt|;
name|MDp
operator|->
name|buffer
index|[
literal|3
index|]
operator|+=
name|D
expr_stmt|;
block|}
end_function

begin_comment
comment|/* MDupdate(MDp,X,count)  * Input: MDp -- an MDptr  *        X -- a pointer to an array of unsigned characters.  *        count -- the number of bits of X to use.  *                 (if not a multiple of 8, uses high bits of last byte.)  * Update MDp using the number of bits of X given by count.  * This is the basic input routine for an MD4 user.  * The routine completes the MD computation when count< 512, so  * every MD computation should end with one call to MDupdate with a  * count less than 512.  A call with count 0 will be ignored if the  * MD has already been terminated (done != 0), so an extra call with count  * 0 can be given as a ``courtesy close'' to force termination if desired.  */
end_comment

begin_function
name|void
name|MDupdate
parameter_list|(
name|MDp
parameter_list|,
name|X
parameter_list|,
name|count
parameter_list|)
name|MDptr
name|MDp
decl_stmt|;
name|unsigned
name|char
modifier|*
name|X
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|bit
decl_stmt|,
name|byte
decl_stmt|,
name|mask
decl_stmt|;
name|unsigned
name|long
name|tmp
decl_stmt|;
name|unsigned
name|char
name|XX
index|[
literal|64
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
comment|/* return with no error if this is a courtesy close with count 	 * zero and MDp->done is true. 	 */
if|if
condition|(
name|count
operator|==
literal|0
operator|&&
name|MDp
operator|->
name|done
condition|)
return|return;
comment|/* check to see if MD is already done and report error */
if|if
condition|(
name|MDp
operator|->
name|done
condition|)
block|{
name|printf
argument_list|(
literal|"\nError: MDupdate MD already done."
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Add count to MDp->count */
name|tmp
operator|=
name|count
expr_stmt|;
name|p
operator|=
name|MDp
operator|->
name|count
expr_stmt|;
while|while
condition|(
name|tmp
condition|)
block|{
name|tmp
operator|+=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|tmp
operator|>>
literal|8
expr_stmt|;
block|}
comment|/* Process data */
if|if
condition|(
name|count
operator|==
literal|512
condition|)
block|{
comment|/* Full block of data to handle */
name|MDblock
argument_list|(
name|MDp
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|X
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|count
operator|>
literal|512
condition|)
block|{
comment|/* Check for count too large */
name|printf
argument_list|(
literal|"\nError: MDupdate called with illegal count value %ld."
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* partial block -- must be last block so finish up 		 * Find out how many bytes and residual bits there are 		 */
name|byte
operator|=
name|count
operator|>>
literal|3
expr_stmt|;
name|bit
operator|=
name|count
operator|&
literal|7
expr_stmt|;
comment|/* Copy X into XX since we need to modify it */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|byte
condition|;
name|i
operator|++
control|)
name|XX
index|[
name|i
index|]
operator|=
name|X
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|byte
operator|+
literal|1
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
name|XX
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Add padding '1' bit and low-order zeros in last byte */
name|mask
operator|=
literal|1
operator|<<
operator|(
literal|7
operator|-
name|bit
operator|)
expr_stmt|;
name|XX
index|[
name|byte
index|]
operator|=
operator|(
name|XX
index|[
name|byte
index|]
operator||
name|mask
operator|)
operator|&
operator|~
operator|(
name|mask
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* If room for bit count, finish up with this block */
if|if
condition|(
name|byte
operator|<=
literal|55
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|XX
index|[
literal|56
operator|+
name|i
index|]
operator|=
name|MDp
operator|->
name|count
index|[
name|i
index|]
expr_stmt|;
name|MDblock
argument_list|(
name|MDp
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|XX
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* need to do two blocks to finish up */
name|MDblock
argument_list|(
name|MDp
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|XX
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|56
condition|;
name|i
operator|++
control|)
name|XX
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
name|XX
index|[
literal|56
operator|+
name|i
index|]
operator|=
name|MDp
operator|->
name|count
index|[
name|i
index|]
expr_stmt|;
name|MDblock
argument_list|(
name|MDp
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
name|XX
argument_list|)
expr_stmt|;
block|}
comment|/* Set flag saying we're done with MD computation */
name|MDp
operator|->
name|done
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* End of md4.c */
end_comment

end_unit

