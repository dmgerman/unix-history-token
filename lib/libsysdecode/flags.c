begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2006 "David Kirchner"<dpk@dpk.net>. All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|L2CAP_SOCKET_CHECKED
end_define

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/acl.h>
end_include

begin_include
include|#
directive|include
file|<sys/capsicum.h>
end_include

begin_include
include|#
directive|include
file|<sys/extattr.h>
end_include

begin_include
include|#
directive|include
file|<sys/linker.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/procctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/reboot.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rtprio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sem.h>
end_include

begin_include
include|#
directive|include
file|<sys/shm.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/thr.h>
end_include

begin_include
include|#
directive|include
file|<sys/umtx.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/sctp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/tcp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udp.h>
end_include

begin_include
include|#
directive|include
file|<netinet/udplite.h>
end_include

begin_include
include|#
directive|include
file|<nfsserver/nfs.h>
end_include

begin_include
include|#
directive|include
file|<ufs/ufs/quota.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/vm_param.h>
end_include

begin_include
include|#
directive|include
file|<aio.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sched.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<sysdecode.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/bitstring.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/bluetooth/include/ng_hci.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/bluetooth/include/ng_l2cap.h>
end_include

begin_include
include|#
directive|include
file|<netgraph/bluetooth/include/ng_btsocket.h>
end_include

begin_comment
comment|/*  * This is taken from the xlat tables originally in truss which were  * in turn taken from strace.  */
end_comment

begin_struct
struct|struct
name|name_table
block|{
name|uintmax_t
name|val
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|X
parameter_list|(
name|a
parameter_list|)
value|{ a, #a },
end_define

begin_define
define|#
directive|define
name|XEND
value|{ 0, NULL }
end_define

begin_define
define|#
directive|define
name|TABLE_START
parameter_list|(
name|n
parameter_list|)
value|static struct name_table n[] = {
end_define

begin_define
define|#
directive|define
name|TABLE_ENTRY
value|X
end_define

begin_define
define|#
directive|define
name|TABLE_END
value|XEND };
end_define

begin_include
include|#
directive|include
file|"tables.h"
end_include

begin_undef
undef|#
directive|undef
name|TABLE_START
end_undef

begin_undef
undef|#
directive|undef
name|TABLE_ENTRY
end_undef

begin_undef
undef|#
directive|undef
name|TABLE_END
end_undef

begin_comment
comment|/*  * These are simple support macros. print_or utilizes a variable  * defined in the calling function to track whether or not it should  * print a logical-OR character ('|') before a string. if_print_or  * simply handles the necessary "if" statement used in many lines  * of this file.  */
end_comment

begin_define
define|#
directive|define
name|print_or
parameter_list|(
name|fp
parameter_list|,
name|str
parameter_list|,
name|orflag
parameter_list|)
value|do {                     \ 	if (orflag) fputc(fp, '|'); else orflag = true;  \ 	fprintf(fp, str); }                              \ 	while (0)
end_define

begin_define
define|#
directive|define
name|if_print_or
parameter_list|(
name|fp
parameter_list|,
name|i
parameter_list|,
name|flag
parameter_list|,
name|orflag
parameter_list|)
value|do {         \ 	if ((i& flag) == flag)                    \ 	print_or(fp,#flag,orflag); }               \ 	while (0)
end_define

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|lookup_value
parameter_list|(
name|struct
name|name_table
modifier|*
name|table
parameter_list|,
name|uintmax_t
name|val
parameter_list|)
block|{
for|for
control|(
init|;
name|table
operator|->
name|str
operator|!=
name|NULL
condition|;
name|table
operator|++
control|)
if|if
condition|(
name|table
operator|->
name|val
operator|==
name|val
condition|)
return|return
operator|(
name|table
operator|->
name|str
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Used when the value maps to a bitmask of #definition values in the  * table.  This is a helper routine which outputs a symbolic mask of  * matched masks.  Multiple masks are separated by a pipe ('|').  * The value is modified on return to only hold unmatched bits.  */
end_comment

begin_function
specifier|static
name|void
name|print_mask_part
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|struct
name|name_table
modifier|*
name|table
parameter_list|,
name|uintmax_t
modifier|*
name|valp
parameter_list|,
name|bool
modifier|*
name|printed
parameter_list|)
block|{
name|uintmax_t
name|rem
decl_stmt|;
name|rem
operator|=
operator|*
name|valp
expr_stmt|;
for|for
control|(
init|;
name|table
operator|->
name|str
operator|!=
name|NULL
condition|;
name|table
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|table
operator|->
name|val
operator|&
name|rem
operator|)
operator|==
name|table
operator|->
name|val
condition|)
block|{
comment|/* 			 * Only print a zero mask if the raw value is 			 * zero. 			 */
if|if
condition|(
name|table
operator|->
name|val
operator|==
literal|0
operator|&&
operator|*
name|valp
operator|!=
literal|0
condition|)
continue|continue;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s%s"
argument_list|,
operator|*
name|printed
condition|?
literal|"|"
else|:
literal|""
argument_list|,
name|table
operator|->
name|str
argument_list|)
expr_stmt|;
operator|*
name|printed
operator|=
name|true
expr_stmt|;
name|rem
operator|&=
operator|~
name|table
operator|->
name|val
expr_stmt|;
block|}
block|}
operator|*
name|valp
operator|=
name|rem
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Used when the value maps to a bitmask of #definition values in the  * table.  The return value is true if something was printed.  If  * rem is not NULL, *rem holds any bits not decoded if something was  * printed.  If nothing was printed and rem is not NULL, *rem holds  * the original value.  */
end_comment

begin_function
specifier|static
name|bool
name|print_mask_int
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|struct
name|name_table
modifier|*
name|table
parameter_list|,
name|int
name|ival
parameter_list|,
name|int
modifier|*
name|rem
parameter_list|)
block|{
name|uintmax_t
name|val
decl_stmt|;
name|bool
name|printed
decl_stmt|;
name|printed
operator|=
name|false
expr_stmt|;
name|val
operator|=
operator|(
name|unsigned
operator|)
name|ival
expr_stmt|;
name|print_mask_part
argument_list|(
name|fp
argument_list|,
name|table
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|printed
argument_list|)
expr_stmt|;
if|if
condition|(
name|rem
operator|!=
name|NULL
condition|)
operator|*
name|rem
operator|=
name|val
expr_stmt|;
return|return
operator|(
name|printed
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Used for a mask of optional flags where a value of 0 is valid.  */
end_comment

begin_function
specifier|static
name|bool
name|print_mask_0
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|struct
name|name_table
modifier|*
name|table
parameter_list|,
name|int
name|val
parameter_list|,
name|int
modifier|*
name|rem
parameter_list|)
block|{
if|if
condition|(
name|val
operator|==
literal|0
condition|)
block|{
name|fputs
argument_list|(
literal|"0"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rem
operator|!=
name|NULL
condition|)
operator|*
name|rem
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
return|return
operator|(
name|print_mask_int
argument_list|(
name|fp
argument_list|,
name|table
argument_list|,
name|val
argument_list|,
name|rem
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Like print_mask_0 but for a unsigned long instead of an int.  */
end_comment

begin_function
specifier|static
name|bool
name|print_mask_0ul
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|struct
name|name_table
modifier|*
name|table
parameter_list|,
name|u_long
name|lval
parameter_list|,
name|u_long
modifier|*
name|rem
parameter_list|)
block|{
name|uintmax_t
name|val
decl_stmt|;
name|bool
name|printed
decl_stmt|;
if|if
condition|(
name|lval
operator|==
literal|0
condition|)
block|{
name|fputs
argument_list|(
literal|"0"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rem
operator|!=
name|NULL
condition|)
operator|*
name|rem
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
name|printed
operator|=
name|false
expr_stmt|;
name|val
operator|=
name|lval
expr_stmt|;
name|print_mask_part
argument_list|(
name|fp
argument_list|,
name|table
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|printed
argument_list|)
expr_stmt|;
if|if
condition|(
name|rem
operator|!=
name|NULL
condition|)
operator|*
name|rem
operator|=
name|val
expr_stmt|;
return|return
operator|(
name|printed
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_integer
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|val
parameter_list|,
name|int
name|base
parameter_list|)
block|{
switch|switch
condition|(
name|base
condition|)
block|{
case|case
literal|8
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"0%o"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"0x%x"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort2
argument_list|(
literal|"bad base"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|bool
name|print_value
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|struct
name|name_table
modifier|*
name|table
parameter_list|,
name|uintmax_t
name|val
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|str
operator|=
name|lookup_value
argument_list|(
name|table
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|!=
name|NULL
condition|)
block|{
name|fputs
argument_list|(
name|str
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_atfd
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
if|if
condition|(
name|fd
operator|==
name|AT_FDCWD
condition|)
return|return
operator|(
literal|"AT_FDCWD"
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|name_table
name|semctlops
index|[]
init|=
block|{
name|X
argument_list|(
argument|GETNCNT
argument_list|)
name|X
argument_list|(
argument|GETPID
argument_list|)
name|X
argument_list|(
argument|GETVAL
argument_list|)
name|X
argument_list|(
argument|GETALL
argument_list|)
name|X
argument_list|(
argument|GETZCNT
argument_list|)
name|X
argument_list|(
argument|SETVAL
argument_list|)
name|X
argument_list|(
argument|SETALL
argument_list|)
name|X
argument_list|(
argument|IPC_RMID
argument_list|)
name|X
argument_list|(
argument|IPC_SET
argument_list|)
name|X
argument_list|(
argument|IPC_STAT
argument_list|)
name|XEND
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_semctl_cmd
parameter_list|(
name|int
name|cmd
parameter_list|)
block|{
return|return
operator|(
name|lookup_value
argument_list|(
name|semctlops
argument_list|,
name|cmd
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|name_table
name|shmctlops
index|[]
init|=
block|{
name|X
argument_list|(
argument|IPC_RMID
argument_list|)
name|X
argument_list|(
argument|IPC_SET
argument_list|)
name|X
argument_list|(
argument|IPC_STAT
argument_list|)
name|XEND
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_shmctl_cmd
parameter_list|(
name|int
name|cmd
parameter_list|)
block|{
return|return
operator|(
name|lookup_value
argument_list|(
name|shmctlops
argument_list|,
name|cmd
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_msgctl_cmd
parameter_list|(
name|int
name|cmd
parameter_list|)
block|{
return|return
operator|(
name|sysdecode_shmctl_cmd
argument_list|(
name|cmd
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|name_table
name|semgetflags
index|[]
init|=
block|{
name|X
argument_list|(
argument|IPC_CREAT
argument_list|)
name|X
argument_list|(
argument|IPC_EXCL
argument_list|)
name|X
argument_list|(
argument|SEM_R
argument_list|)
name|X
argument_list|(
argument|SEM_A
argument_list|)
name|X
argument_list|(
argument|(SEM_R>>
literal|3
argument|)
argument_list|)
name|X
argument_list|(
argument|(SEM_A>>
literal|3
argument|)
argument_list|)
name|X
argument_list|(
argument|(SEM_R>>
literal|6
argument|)
argument_list|)
name|X
argument_list|(
argument|(SEM_A>>
literal|6
argument|)
argument_list|)
name|XEND
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|bool
name|sysdecode_semget_flags
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
modifier|*
name|rem
parameter_list|)
block|{
return|return
operator|(
name|print_mask_int
argument_list|(
name|fp
argument_list|,
name|semgetflags
argument_list|,
name|flag
argument_list|,
name|rem
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|name_table
name|idtypes
index|[]
init|=
block|{
name|X
argument_list|(
argument|P_PID
argument_list|)
name|X
argument_list|(
argument|P_PPID
argument_list|)
name|X
argument_list|(
argument|P_PGID
argument_list|)
name|X
argument_list|(
argument|P_SID
argument_list|)
name|X
argument_list|(
argument|P_CID
argument_list|)
name|X
argument_list|(
argument|P_UID
argument_list|)
name|X
argument_list|(
argument|P_GID
argument_list|)
name|X
argument_list|(
argument|P_ALL
argument_list|)
name|X
argument_list|(
argument|P_LWPID
argument_list|)
name|X
argument_list|(
argument|P_TASKID
argument_list|)
name|X
argument_list|(
argument|P_PROJID
argument_list|)
name|X
argument_list|(
argument|P_POOLID
argument_list|)
name|X
argument_list|(
argument|P_JAILID
argument_list|)
name|X
argument_list|(
argument|P_CTID
argument_list|)
name|X
argument_list|(
argument|P_CPUID
argument_list|)
name|X
argument_list|(
argument|P_PSETID
argument_list|)
name|XEND
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX: idtype is really an idtype_t */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_idtype
parameter_list|(
name|int
name|idtype
parameter_list|)
block|{
return|return
operator|(
name|lookup_value
argument_list|(
name|idtypes
argument_list|,
name|idtype
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * [g|s]etsockopt's level argument can either be SOL_SOCKET or a  * protocol-specific value.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_sockopt_level
parameter_list|(
name|int
name|level
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
if|if
condition|(
name|level
operator|==
name|SOL_SOCKET
condition|)
return|return
operator|(
literal|"SOL_SOCKET"
operator|)
return|;
comment|/* SOL_* constants for Bluetooth sockets. */
name|str
operator|=
name|lookup_value
argument_list|(
name|ngbtsolevel
argument_list|,
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|!=
name|NULL
condition|)
return|return
operator|(
name|str
operator|)
return|;
comment|/* 	 * IP and Infiniband sockets use IP protocols as levels.  Not all 	 * protocols are valid but it is simpler to just allow all of them. 	 * 	 * XXX: IPPROTO_IP == 0, but UNIX domain sockets use a level of 0 	 * for private options. 	 */
name|str
operator|=
name|sysdecode_ipproto
argument_list|(
name|level
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|!=
name|NULL
condition|)
return|return
operator|(
name|str
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|sysdecode_vmprot
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rem
parameter_list|)
block|{
return|return
operator|(
name|print_mask_int
argument_list|(
name|fp
argument_list|,
name|vmprot
argument_list|,
name|type
argument_list|,
name|rem
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|name_table
name|sockflags
index|[]
init|=
block|{
name|X
argument_list|(
argument|SOCK_CLOEXEC
argument_list|)
name|X
argument_list|(
argument|SOCK_NONBLOCK
argument_list|)
name|XEND
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|bool
name|sysdecode_socket_type
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|type
parameter_list|,
name|int
modifier|*
name|rem
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|uintmax_t
name|val
decl_stmt|;
name|bool
name|printed
decl_stmt|;
name|str
operator|=
name|lookup_value
argument_list|(
name|socktype
argument_list|,
name|type
operator|&
operator|~
operator|(
name|SOCK_CLOEXEC
operator||
name|SOCK_NONBLOCK
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|!=
name|NULL
condition|)
block|{
name|fputs
argument_list|(
name|str
argument_list|,
name|fp
argument_list|)
expr_stmt|;
operator|*
name|rem
operator|=
literal|0
expr_stmt|;
name|printed
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
operator|*
name|rem
operator|=
name|type
operator|&
operator|~
operator|(
name|SOCK_CLOEXEC
operator||
name|SOCK_NONBLOCK
operator|)
expr_stmt|;
name|printed
operator|=
name|false
expr_stmt|;
block|}
name|val
operator|=
name|type
operator|&
operator|(
name|SOCK_CLOEXEC
operator||
name|SOCK_NONBLOCK
operator|)
expr_stmt|;
name|print_mask_part
argument_list|(
name|fp
argument_list|,
name|sockflags
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|printed
argument_list|)
expr_stmt|;
return|return
operator|(
name|printed
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|sysdecode_access_mode
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
modifier|*
name|rem
parameter_list|)
block|{
return|return
operator|(
name|print_mask_int
argument_list|(
name|fp
argument_list|,
name|accessmode
argument_list|,
name|mode
argument_list|,
name|rem
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* XXX: 'type' is really an acl_type_t. */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_acltype
parameter_list|(
name|int
name|type
parameter_list|)
block|{
return|return
operator|(
name|lookup_value
argument_list|(
name|acltype
argument_list|,
name|type
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|sysdecode_cap_fcntlrights
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|uint32_t
name|rights
parameter_list|,
name|uint32_t
modifier|*
name|rem
parameter_list|)
block|{
return|return
operator|(
name|print_mask_int
argument_list|(
name|fp
argument_list|,
name|capfcntl
argument_list|,
name|rights
argument_list|,
name|rem
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_extattrnamespace
parameter_list|(
name|int
name|namespace
parameter_list|)
block|{
return|return
operator|(
name|lookup_value
argument_list|(
name|extattrns
argument_list|,
name|namespace
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_fadvice
parameter_list|(
name|int
name|advice
parameter_list|)
block|{
return|return
operator|(
name|lookup_value
argument_list|(
name|fadvisebehav
argument_list|,
name|advice
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|sysdecode_open_flags
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|rem
parameter_list|)
block|{
name|bool
name|printed
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|uintmax_t
name|val
decl_stmt|;
name|mode
operator|=
name|flags
operator|&
name|O_ACCMODE
expr_stmt|;
name|flags
operator|&=
operator|~
name|O_ACCMODE
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|O_RDONLY
case|:
if|if
condition|(
name|flags
operator|&
name|O_EXEC
condition|)
block|{
name|flags
operator|&=
operator|~
name|O_EXEC
expr_stmt|;
name|fputs
argument_list|(
literal|"O_EXEC"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
name|fputs
argument_list|(
literal|"O_RDONLY"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|printed
operator|=
name|true
expr_stmt|;
name|mode
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|O_WRONLY
case|:
name|fputs
argument_list|(
literal|"O_WRONLY"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|printed
operator|=
name|true
expr_stmt|;
name|mode
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|O_RDWR
case|:
name|fputs
argument_list|(
literal|"O_RDWR"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|printed
operator|=
name|true
expr_stmt|;
name|mode
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|printed
operator|=
name|false
expr_stmt|;
block|}
name|val
operator|=
operator|(
name|unsigned
operator|)
name|flags
expr_stmt|;
name|print_mask_part
argument_list|(
name|fp
argument_list|,
name|openflags
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|printed
argument_list|)
expr_stmt|;
if|if
condition|(
name|rem
operator|!=
name|NULL
condition|)
operator|*
name|rem
operator|=
name|val
operator||
name|mode
expr_stmt|;
return|return
operator|(
name|printed
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|sysdecode_fcntl_fileflags
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|rem
parameter_list|)
block|{
name|bool
name|printed
decl_stmt|;
name|int
name|oflags
decl_stmt|;
comment|/* 	 * The file flags used with F_GETFL/F_SETFL mostly match the 	 * flags passed to open(2).  However, a few open-only flag 	 * bits have been repurposed for fcntl-only flags. 	 */
name|oflags
operator|=
name|flags
operator|&
operator|~
operator|(
name|O_NOFOLLOW
operator||
name|FRDAHEAD
operator|)
expr_stmt|;
name|printed
operator|=
name|sysdecode_open_flags
argument_list|(
name|fp
argument_list|,
name|oflags
argument_list|,
name|rem
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|O_NOFOLLOW
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%sFPOIXSHM"
argument_list|,
name|printed
condition|?
literal|"|"
else|:
literal|""
argument_list|)
expr_stmt|;
name|printed
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|FRDAHEAD
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%sFRDAHEAD"
argument_list|,
name|printed
condition|?
literal|"|"
else|:
literal|""
argument_list|)
expr_stmt|;
name|printed
operator|=
name|true
expr_stmt|;
block|}
return|return
operator|(
name|printed
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|sysdecode_flock_operation
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|operation
parameter_list|,
name|int
modifier|*
name|rem
parameter_list|)
block|{
return|return
operator|(
name|print_mask_int
argument_list|(
name|fp
argument_list|,
name|flockops
argument_list|,
name|operation
argument_list|,
name|rem
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|name_table
name|getfsstatmode
index|[]
init|=
block|{
name|X
argument_list|(
argument|MNT_WAIT
argument_list|)
name|X
argument_list|(
argument|MNT_NOWAIT
argument_list|)
name|XEND
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_getfsstat_mode
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
return|return
operator|(
name|lookup_value
argument_list|(
name|getfsstatmode
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_kldsym_cmd
parameter_list|(
name|int
name|cmd
parameter_list|)
block|{
return|return
operator|(
name|lookup_value
argument_list|(
name|kldsymcmd
argument_list|,
name|cmd
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_kldunload_flags
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
return|return
operator|(
name|lookup_value
argument_list|(
name|kldunloadfflags
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_lio_listio_mode
parameter_list|(
name|int
name|mode
parameter_list|)
block|{
return|return
operator|(
name|lookup_value
argument_list|(
name|lio_listiomodes
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_madvice
parameter_list|(
name|int
name|advice
parameter_list|)
block|{
return|return
operator|(
name|lookup_value
argument_list|(
name|madvisebehav
argument_list|,
name|advice
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_minherit_inherit
parameter_list|(
name|int
name|inherit
parameter_list|)
block|{
return|return
operator|(
name|lookup_value
argument_list|(
name|minheritflags
argument_list|,
name|inherit
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|sysdecode_mlockall_flags
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|rem
parameter_list|)
block|{
return|return
operator|(
name|print_mask_int
argument_list|(
name|fp
argument_list|,
name|mlockallflags
argument_list|,
name|flags
argument_list|,
name|rem
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|sysdecode_mmap_prot
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|prot
parameter_list|,
name|int
modifier|*
name|rem
parameter_list|)
block|{
return|return
operator|(
name|print_mask_int
argument_list|(
name|fp
argument_list|,
name|mmapprot
argument_list|,
name|prot
argument_list|,
name|rem
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|sysdecode_fileflags
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|fflags_t
name|flags
parameter_list|,
name|fflags_t
modifier|*
name|rem
parameter_list|)
block|{
return|return
operator|(
name|print_mask_0
argument_list|(
name|fp
argument_list|,
name|fileflags
argument_list|,
name|flags
argument_list|,
name|rem
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|sysdecode_filemode
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
modifier|*
name|rem
parameter_list|)
block|{
return|return
operator|(
name|print_mask_0
argument_list|(
name|fp
argument_list|,
name|filemode
argument_list|,
name|mode
argument_list|,
name|rem
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|sysdecode_mount_flags
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|rem
parameter_list|)
block|{
return|return
operator|(
name|print_mask_int
argument_list|(
name|fp
argument_list|,
name|mountflags
argument_list|,
name|flags
argument_list|,
name|rem
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|sysdecode_msync_flags
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|rem
parameter_list|)
block|{
return|return
operator|(
name|print_mask_int
argument_list|(
name|fp
argument_list|,
name|msyncflags
argument_list|,
name|flags
argument_list|,
name|rem
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_nfssvc_flags
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
return|return
operator|(
name|lookup_value
argument_list|(
name|nfssvcflags
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|name_table
name|pipe2flags
index|[]
init|=
block|{
name|X
argument_list|(
argument|O_CLOEXEC
argument_list|)
name|X
argument_list|(
argument|O_NONBLOCK
argument_list|)
name|XEND
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|bool
name|sysdecode_pipe2_flags
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|rem
parameter_list|)
block|{
return|return
operator|(
name|print_mask_0
argument_list|(
name|fp
argument_list|,
name|pipe2flags
argument_list|,
name|flags
argument_list|,
name|rem
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_prio_which
parameter_list|(
name|int
name|which
parameter_list|)
block|{
return|return
operator|(
name|lookup_value
argument_list|(
name|prio
argument_list|,
name|which
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_procctl_cmd
parameter_list|(
name|int
name|cmd
parameter_list|)
block|{
return|return
operator|(
name|lookup_value
argument_list|(
name|procctlcmd
argument_list|,
name|cmd
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_ptrace_request
parameter_list|(
name|int
name|request
parameter_list|)
block|{
return|return
operator|(
name|lookup_value
argument_list|(
name|ptraceop
argument_list|,
name|request
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|name_table
name|quotatypes
index|[]
init|=
block|{
name|X
argument_list|(
argument|GRPQUOTA
argument_list|)
name|X
argument_list|(
argument|USRQUOTA
argument_list|)
name|XEND
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|bool
name|sysdecode_quotactl_cmd
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|cmd
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|primary
decl_stmt|,
modifier|*
name|type
decl_stmt|;
name|primary
operator|=
name|lookup_value
argument_list|(
name|quotactlcmds
argument_list|,
name|cmd
operator|>>
name|SUBCMDSHIFT
argument_list|)
expr_stmt|;
if|if
condition|(
name|primary
operator|==
name|NULL
condition|)
return|return
operator|(
name|false
operator|)
return|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"QCMD(%s,"
argument_list|,
name|primary
argument_list|)
expr_stmt|;
name|type
operator|=
name|lookup_value
argument_list|(
name|quotatypes
argument_list|,
name|cmd
operator|&
name|SUBCMDMASK
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|type
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%#x"
argument_list|,
name|cmd
operator|&
name|SUBCMDMASK
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|sysdecode_reboot_howto
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|howto
parameter_list|,
name|int
modifier|*
name|rem
parameter_list|)
block|{
return|return
operator|(
name|print_mask_int
argument_list|(
name|fp
argument_list|,
name|rebootopt
argument_list|,
name|howto
argument_list|,
name|rem
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|sysdecode_rfork_flags
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|rem
parameter_list|)
block|{
return|return
operator|(
name|print_mask_int
argument_list|(
name|fp
argument_list|,
name|rforkflags
argument_list|,
name|flags
argument_list|,
name|rem
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_rlimit
parameter_list|(
name|int
name|resource
parameter_list|)
block|{
return|return
operator|(
name|lookup_value
argument_list|(
name|rlimit
argument_list|,
name|resource
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_scheduler_policy
parameter_list|(
name|int
name|policy
parameter_list|)
block|{
return|return
operator|(
name|lookup_value
argument_list|(
name|schedpolicy
argument_list|,
name|policy
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|sysdecode_sendfile_flags
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|rem
parameter_list|)
block|{
return|return
operator|(
name|print_mask_int
argument_list|(
name|fp
argument_list|,
name|sendfileflags
argument_list|,
name|flags
argument_list|,
name|rem
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|sysdecode_shmat_flags
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|rem
parameter_list|)
block|{
return|return
operator|(
name|print_mask_int
argument_list|(
name|fp
argument_list|,
name|shmatflags
argument_list|,
name|flags
argument_list|,
name|rem
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_shutdown_how
parameter_list|(
name|int
name|how
parameter_list|)
block|{
return|return
operator|(
name|lookup_value
argument_list|(
name|shutdownhow
argument_list|,
name|how
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_sigbus_code
parameter_list|(
name|int
name|si_code
parameter_list|)
block|{
return|return
operator|(
name|lookup_value
argument_list|(
name|sigbuscode
argument_list|,
name|si_code
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_sigchld_code
parameter_list|(
name|int
name|si_code
parameter_list|)
block|{
return|return
operator|(
name|lookup_value
argument_list|(
name|sigchldcode
argument_list|,
name|si_code
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_sigfpe_code
parameter_list|(
name|int
name|si_code
parameter_list|)
block|{
return|return
operator|(
name|lookup_value
argument_list|(
name|sigfpecode
argument_list|,
name|si_code
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_sigill_code
parameter_list|(
name|int
name|si_code
parameter_list|)
block|{
return|return
operator|(
name|lookup_value
argument_list|(
name|sigillcode
argument_list|,
name|si_code
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_sigsegv_code
parameter_list|(
name|int
name|si_code
parameter_list|)
block|{
return|return
operator|(
name|lookup_value
argument_list|(
name|sigsegvcode
argument_list|,
name|si_code
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_sigtrap_code
parameter_list|(
name|int
name|si_code
parameter_list|)
block|{
return|return
operator|(
name|lookup_value
argument_list|(
name|sigtrapcode
argument_list|,
name|si_code
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_sigprocmask_how
parameter_list|(
name|int
name|how
parameter_list|)
block|{
return|return
operator|(
name|lookup_value
argument_list|(
name|sigprocmaskhow
argument_list|,
name|how
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_socketdomain
parameter_list|(
name|int
name|domain
parameter_list|)
block|{
return|return
operator|(
name|lookup_value
argument_list|(
name|sockdomain
argument_list|,
name|domain
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_socket_protocol
parameter_list|(
name|int
name|domain
parameter_list|,
name|int
name|protocol
parameter_list|)
block|{
switch|switch
condition|(
name|domain
condition|)
block|{
case|case
name|PF_INET
case|:
case|case
name|PF_INET6
case|:
return|return
operator|(
name|lookup_value
argument_list|(
name|sockipproto
argument_list|,
name|protocol
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_sockaddr_family
parameter_list|(
name|int
name|sa_family
parameter_list|)
block|{
return|return
operator|(
name|lookup_value
argument_list|(
name|sockfamily
argument_list|,
name|sa_family
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_ipproto
parameter_list|(
name|int
name|protocol
parameter_list|)
block|{
return|return
operator|(
name|lookup_value
argument_list|(
name|sockipproto
argument_list|,
name|protocol
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_sockopt_name
parameter_list|(
name|int
name|level
parameter_list|,
name|int
name|optname
parameter_list|)
block|{
if|if
condition|(
name|level
operator|==
name|SOL_SOCKET
condition|)
return|return
operator|(
name|lookup_value
argument_list|(
name|sockopt
argument_list|,
name|optname
argument_list|)
operator|)
return|;
if|if
condition|(
name|level
operator|==
name|IPPROTO_IP
condition|)
comment|/* XXX: UNIX domain socket options use a level of 0 also. */
return|return
operator|(
name|lookup_value
argument_list|(
name|sockoptip
argument_list|,
name|optname
argument_list|)
operator|)
return|;
if|if
condition|(
name|level
operator|==
name|IPPROTO_IPV6
condition|)
return|return
operator|(
name|lookup_value
argument_list|(
name|sockoptipv6
argument_list|,
name|optname
argument_list|)
operator|)
return|;
if|if
condition|(
name|level
operator|==
name|IPPROTO_SCTP
condition|)
return|return
operator|(
name|lookup_value
argument_list|(
name|sockoptsctp
argument_list|,
name|optname
argument_list|)
operator|)
return|;
if|if
condition|(
name|level
operator|==
name|IPPROTO_TCP
condition|)
return|return
operator|(
name|lookup_value
argument_list|(
name|sockopttcp
argument_list|,
name|optname
argument_list|)
operator|)
return|;
if|if
condition|(
name|level
operator|==
name|IPPROTO_UDP
condition|)
return|return
operator|(
name|lookup_value
argument_list|(
name|sockoptudp
argument_list|,
name|optname
argument_list|)
operator|)
return|;
if|if
condition|(
name|level
operator|==
name|IPPROTO_UDPLITE
condition|)
return|return
operator|(
name|lookup_value
argument_list|(
name|sockoptudplite
argument_list|,
name|optname
argument_list|)
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|sysdecode_thr_create_flags
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|rem
parameter_list|)
block|{
return|return
operator|(
name|print_mask_int
argument_list|(
name|fp
argument_list|,
name|thrcreateflags
argument_list|,
name|flags
argument_list|,
name|rem
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_umtx_op
parameter_list|(
name|int
name|op
parameter_list|)
block|{
return|return
operator|(
name|lookup_value
argument_list|(
name|umtxop
argument_list|,
name|op
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_vmresult
parameter_list|(
name|int
name|result
parameter_list|)
block|{
return|return
operator|(
name|lookup_value
argument_list|(
name|vmresult
argument_list|,
name|result
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|sysdecode_wait4_options
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|options
parameter_list|,
name|int
modifier|*
name|rem
parameter_list|)
block|{
name|bool
name|printed
decl_stmt|;
name|int
name|opt6
decl_stmt|;
comment|/* A flags value of 0 is normal. */
if|if
condition|(
name|options
operator|==
literal|0
condition|)
block|{
name|fputs
argument_list|(
literal|"0"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rem
operator|!=
name|NULL
condition|)
operator|*
name|rem
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
comment|/* 	 * These flags are implicit and aren't valid flags for wait4() 	 * directly (though they don't fail with EINVAL). 	 */
name|opt6
operator|=
name|options
operator|&
operator|(
name|WEXITED
operator||
name|WTRAPPED
operator|)
expr_stmt|;
name|options
operator|&=
operator|~
name|opt6
expr_stmt|;
name|printed
operator|=
name|print_mask_int
argument_list|(
name|fp
argument_list|,
name|wait6opt
argument_list|,
name|options
argument_list|,
name|rem
argument_list|)
expr_stmt|;
if|if
condition|(
name|rem
operator|!=
name|NULL
condition|)
operator|*
name|rem
operator||=
name|opt6
expr_stmt|;
return|return
operator|(
name|printed
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|sysdecode_wait6_options
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|options
parameter_list|,
name|int
modifier|*
name|rem
parameter_list|)
block|{
return|return
operator|(
name|print_mask_int
argument_list|(
name|fp
argument_list|,
name|wait6opt
argument_list|,
name|options
argument_list|,
name|rem
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_whence
parameter_list|(
name|int
name|whence
parameter_list|)
block|{
return|return
operator|(
name|lookup_value
argument_list|(
name|seekwhence
argument_list|,
name|whence
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_fcntl_cmd
parameter_list|(
name|int
name|cmd
parameter_list|)
block|{
return|return
operator|(
name|lookup_value
argument_list|(
name|fcntlcmd
argument_list|,
name|cmd
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|name_table
name|fcntl_fd_arg
index|[]
init|=
block|{
name|X
argument_list|(
argument|FD_CLOEXEC
argument_list|)
name|X
argument_list|(
literal|0
argument_list|)
name|XEND
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|bool
name|sysdecode_fcntl_arg_p
parameter_list|(
name|int
name|cmd
parameter_list|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|F_GETFD
case|:
case|case
name|F_GETFL
case|:
case|case
name|F_GETOWN
case|:
return|return
operator|(
name|false
operator|)
return|;
default|default:
return|return
operator|(
name|true
operator|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|sysdecode_fcntl_arg
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|cmd
parameter_list|,
name|uintptr_t
name|arg
parameter_list|,
name|int
name|base
parameter_list|)
block|{
name|int
name|rem
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|F_SETFD
case|:
if|if
condition|(
operator|!
name|print_value
argument_list|(
name|fp
argument_list|,
name|fcntl_fd_arg
argument_list|,
name|arg
argument_list|)
condition|)
name|print_integer
argument_list|(
name|fp
argument_list|,
name|arg
argument_list|,
name|base
argument_list|)
expr_stmt|;
break|break;
case|case
name|F_SETFL
case|:
if|if
condition|(
operator|!
name|sysdecode_fcntl_fileflags
argument_list|(
name|fp
argument_list|,
name|arg
argument_list|,
operator|&
name|rem
argument_list|)
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%#x"
argument_list|,
name|rem
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rem
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"|%#x"
argument_list|,
name|rem
argument_list|)
expr_stmt|;
break|break;
case|case
name|F_GETLK
case|:
case|case
name|F_SETLK
case|:
case|case
name|F_SETLKW
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%p"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|print_integer
argument_list|(
name|fp
argument_list|,
name|arg
argument_list|,
name|base
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
name|bool
name|sysdecode_mmap_flags
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|rem
parameter_list|)
block|{
name|uintmax_t
name|val
decl_stmt|;
name|bool
name|printed
decl_stmt|;
name|int
name|align
decl_stmt|;
comment|/* 	 * MAP_ALIGNED can't be handled directly by print_mask_int(). 	 * MAP_32BIT is also problematic since it isn't defined for 	 * all platforms. 	 */
name|printed
operator|=
name|false
expr_stmt|;
name|align
operator|=
name|flags
operator|&
name|MAP_ALIGNMENT_MASK
expr_stmt|;
name|val
operator|=
operator|(
name|unsigned
operator|)
name|flags
operator|&
operator|~
name|MAP_ALIGNMENT_MASK
expr_stmt|;
name|print_mask_part
argument_list|(
name|fp
argument_list|,
name|mmapflags
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|printed
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAP_32BIT
if|if
condition|(
name|val
operator|&
name|MAP_32BIT
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%sMAP_32BIT"
argument_list|,
name|printed
condition|?
literal|"|"
else|:
literal|""
argument_list|)
expr_stmt|;
name|printed
operator|=
name|true
expr_stmt|;
name|val
operator|&=
operator|~
name|MAP_32BIT
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|align
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|printed
condition|)
name|fputc
argument_list|(
literal|'|'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|==
name|MAP_ALIGNED_SUPER
condition|)
name|fputs
argument_list|(
literal|"MAP_ALIGNED_SUPER"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"MAP_ALIGNED(%d)"
argument_list|,
name|align
operator|>>
name|MAP_ALIGNMENT_SHIFT
argument_list|)
expr_stmt|;
name|printed
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|rem
operator|!=
name|NULL
condition|)
operator|*
name|rem
operator|=
name|val
expr_stmt|;
return|return
operator|(
name|printed
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_rtprio_function
parameter_list|(
name|int
name|function
parameter_list|)
block|{
return|return
operator|(
name|lookup_value
argument_list|(
name|rtpriofuncs
argument_list|,
name|function
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|sysdecode_msg_flags
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|rem
parameter_list|)
block|{
return|return
operator|(
name|print_mask_0
argument_list|(
name|fp
argument_list|,
name|msgflags
argument_list|,
name|flags
argument_list|,
name|rem
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|sysdecode_sigcode
parameter_list|(
name|int
name|sig
parameter_list|,
name|int
name|si_code
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|str
operator|=
name|lookup_value
argument_list|(
name|sigcode
argument_list|,
name|si_code
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|!=
name|NULL
condition|)
return|return
operator|(
name|str
operator|)
return|;
switch|switch
condition|(
name|sig
condition|)
block|{
case|case
name|SIGILL
case|:
return|return
operator|(
name|sysdecode_sigill_code
argument_list|(
name|si_code
argument_list|)
operator|)
return|;
case|case
name|SIGBUS
case|:
return|return
operator|(
name|sysdecode_sigbus_code
argument_list|(
name|si_code
argument_list|)
operator|)
return|;
case|case
name|SIGSEGV
case|:
return|return
operator|(
name|sysdecode_sigsegv_code
argument_list|(
name|si_code
argument_list|)
operator|)
return|;
case|case
name|SIGFPE
case|:
return|return
operator|(
name|sysdecode_sigfpe_code
argument_list|(
name|si_code
argument_list|)
operator|)
return|;
case|case
name|SIGTRAP
case|:
return|return
operator|(
name|sysdecode_sigtrap_code
argument_list|(
name|si_code
argument_list|)
operator|)
return|;
case|case
name|SIGCHLD
case|:
return|return
operator|(
name|sysdecode_sigchld_code
argument_list|(
name|si_code
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
end_function

begin_function
name|bool
name|sysdecode_umtx_cvwait_flags
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|u_long
name|flags
parameter_list|,
name|u_long
modifier|*
name|rem
parameter_list|)
block|{
return|return
operator|(
name|print_mask_0ul
argument_list|(
name|fp
argument_list|,
name|umtxcvwaitflags
argument_list|,
name|flags
argument_list|,
name|rem
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|sysdecode_umtx_rwlock_flags
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|u_long
name|flags
parameter_list|,
name|u_long
modifier|*
name|rem
parameter_list|)
block|{
return|return
operator|(
name|print_mask_0ul
argument_list|(
name|fp
argument_list|,
name|umtxrwlockflags
argument_list|,
name|flags
argument_list|,
name|rem
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|sysdecode_cap_rights
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
name|cap_rights_t
modifier|*
name|rightsp
parameter_list|)
block|{
name|struct
name|name_table
modifier|*
name|t
decl_stmt|;
name|int
name|i
decl_stmt|;
name|bool
name|comma
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CAPARSIZE
argument_list|(
name|rightsp
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|CAPIDXBIT
argument_list|(
name|rightsp
operator|->
name|cr_rights
index|[
name|i
index|]
argument_list|)
operator|!=
literal|1
operator|<<
name|i
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"invalid cap_rights_t"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|comma
operator|=
name|false
expr_stmt|;
for|for
control|(
name|t
operator|=
name|caprights
init|;
name|t
operator|->
name|str
operator|!=
name|NULL
condition|;
name|t
operator|++
control|)
block|{
if|if
condition|(
name|cap_rights_is_set
argument_list|(
name|rightsp
argument_list|,
name|t
operator|->
name|val
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s%s"
argument_list|,
name|comma
condition|?
literal|","
else|:
literal|""
argument_list|,
name|t
operator|->
name|str
argument_list|)
expr_stmt|;
name|comma
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

