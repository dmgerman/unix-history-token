begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* xalloc.h -- malloc with out-of-memory checking     Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,    1999, 2000, 2003, 2004, 2006, 2007 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software Foundation,    Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|XALLOC_H_
end_ifndef

begin_define
define|#
directive|define
name|XALLOC_H_
end_define

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
ifndef|#
directive|ifndef
name|__attribute__
if|#
directive|if
name|__GNUC__
operator|<
literal|2
operator|||
operator|(
name|__GNUC__
operator|==
literal|2
operator|&&
name|__GNUC_MINOR__
operator|<
literal|8
operator|)
operator|||
name|__STRICT_ANSI__
define|#
directive|define
name|__attribute__
parameter_list|(
name|x
parameter_list|)
endif|#
directive|endif
endif|#
directive|endif
ifndef|#
directive|ifndef
name|ATTRIBUTE_NORETURN
define|#
directive|define
name|ATTRIBUTE_NORETURN
value|__attribute__ ((__noreturn__))
endif|#
directive|endif
comment|/* This function is always triggered when memory is exhausted.    It must be defined by the application, either explicitly    or by using gnulib's xalloc-die module.  This is the    function to call when one wants the program to die because of a    memory allocation failure.  */
specifier|extern
name|void
name|xalloc_die
argument_list|(
name|void
argument_list|)
name|ATTRIBUTE_NORETURN
decl_stmt|;
name|void
modifier|*
name|xmalloc
parameter_list|(
name|size_t
name|s
parameter_list|)
function_decl|;
name|void
modifier|*
name|xzalloc
parameter_list|(
name|size_t
name|s
parameter_list|)
function_decl|;
name|void
modifier|*
name|xcalloc
parameter_list|(
name|size_t
name|n
parameter_list|,
name|size_t
name|s
parameter_list|)
function_decl|;
name|void
modifier|*
name|xrealloc
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|size_t
name|s
parameter_list|)
function_decl|;
name|void
modifier|*
name|x2realloc
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|size_t
modifier|*
name|pn
parameter_list|)
function_decl|;
name|void
modifier|*
name|xmemdup
parameter_list|(
name|void
specifier|const
modifier|*
name|p
parameter_list|,
name|size_t
name|s
parameter_list|)
function_decl|;
name|char
modifier|*
name|xstrdup
parameter_list|(
name|char
specifier|const
modifier|*
name|str
parameter_list|)
function_decl|;
comment|/* Return 1 if an array of N objects, each of size S, cannot exist due    to size arithmetic overflow.  S must be positive and N must be    nonnegative.  This is a macro, not an inline function, so that it    works correctly even when SIZE_MAX< N.     By gnulib convention, SIZE_MAX represents overflow in size    calculations, so the conservative dividend to use here is    SIZE_MAX - 1, since SIZE_MAX might represent an overflowed value.    However, malloc (SIZE_MAX) fails on all known hosts where    sizeof (ptrdiff_t)<= sizeof (size_t), so do not bother to test for    exactly-SIZE_MAX allocations on such hosts; this avoids a test and    branch when S is known to be 1.  */
define|#
directive|define
name|xalloc_oversized
parameter_list|(
name|n
parameter_list|,
name|s
parameter_list|)
define|\
value|((size_t) (sizeof (ptrdiff_t)<= sizeof (size_t) ? -1 : -2) / (s)< (n))
comment|/* In the following macros, T must be an elementary or structure/union or    typedef'ed type, or a pointer to such a type.  To apply one of the    following macros to a function pointer or array type, you need to typedef    it first and use the typedef name.  */
comment|/* Allocate an object of type T dynamically, with error checking.  */
comment|/* extern t *XMALLOC (typename t); */
define|#
directive|define
name|XMALLOC
parameter_list|(
name|t
parameter_list|)
value|((t *) xmalloc (sizeof (t)))
comment|/* Allocate memory for N elements of type T, with error checking.  */
comment|/* extern t *XNMALLOC (size_t n, typename t); */
define|#
directive|define
name|XNMALLOC
parameter_list|(
name|n
parameter_list|,
name|t
parameter_list|)
define|\
value|((t *) (sizeof (t) == 1 ? xmalloc (n) : xnmalloc (n, sizeof (t))))
comment|/* Allocate an object of type T dynamically, with error checking,    and zero it.  */
comment|/* extern t *XZALLOC (typename t); */
define|#
directive|define
name|XZALLOC
parameter_list|(
name|t
parameter_list|)
value|((t *) xzalloc (sizeof (t)))
comment|/* Allocate memory for N elements of type T, with error checking,    and zero it.  */
comment|/* extern t *XCALLOC (size_t n, typename t); */
define|#
directive|define
name|XCALLOC
parameter_list|(
name|n
parameter_list|,
name|t
parameter_list|)
define|\
value|((t *) (sizeof (t) == 1 ? xzalloc (n) : xcalloc (n, sizeof (t))))
if|#
directive|if
name|HAVE_INLINE
define|#
directive|define
name|static_inline
value|static inline
else|#
directive|else
name|void
modifier|*
name|xnmalloc
parameter_list|(
name|size_t
name|n
parameter_list|,
name|size_t
name|s
parameter_list|)
function_decl|;
name|void
modifier|*
name|xnrealloc
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|size_t
name|n
parameter_list|,
name|size_t
name|s
parameter_list|)
function_decl|;
name|void
modifier|*
name|x2nrealloc
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|size_t
modifier|*
name|pn
parameter_list|,
name|size_t
name|s
parameter_list|)
function_decl|;
name|char
modifier|*
name|xcharalloc
parameter_list|(
name|size_t
name|n
parameter_list|)
function_decl|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|static_inline
comment|/* Allocate an array of N objects, each with S bytes of memory,    dynamically, with error checking.  S must be nonzero.  */
name|static_inline
name|void
modifier|*
name|xnmalloc
parameter_list|(
name|size_t
name|n
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
if|if
condition|(
name|xalloc_oversized
argument_list|(
name|n
argument_list|,
name|s
argument_list|)
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
return|return
name|xmalloc
argument_list|(
name|n
operator|*
name|s
argument_list|)
return|;
block|}
comment|/* Change the size of an allocated block of memory P to an array of N    objects each of S bytes, with error checking.  S must be nonzero.  */
name|static_inline
name|void
modifier|*
name|xnrealloc
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|size_t
name|n
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
if|if
condition|(
name|xalloc_oversized
argument_list|(
name|n
argument_list|,
name|s
argument_list|)
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
return|return
name|xrealloc
argument_list|(
name|p
argument_list|,
name|n
operator|*
name|s
argument_list|)
return|;
block|}
comment|/* If P is null, allocate a block of at least *PN such objects;    otherwise, reallocate P so that it contains more than *PN objects    each of S bytes.  *PN must be nonzero unless P is null, and S must    be nonzero.  Set *PN to the new number of objects, and return the    pointer to the new block.  *PN is never set to zero, and the    returned pointer is never null.     Repeated reallocations are guaranteed to make progress, either by    allocating an initial block with a nonzero size, or by allocating a    larger block.     In the following implementation, nonzero sizes are increased by a    factor of approximately 1.5 so that repeated reallocations have    O(N) overall cost rather than O(N**2) cost, but the    specification for this function does not guarantee that rate.     Here is an example of use:       int *p = NULL;      size_t used = 0;      size_t allocated = 0;       void      append_int (int value)        { 	 if (used == allocated) 	   p = x2nrealloc (p,&allocated, sizeof *p); 	 p[used++] = value;        }     This causes x2nrealloc to allocate a block of some nonzero size the    first time it is called.     To have finer-grained control over the initial size, set *PN to a    nonzero value before calling this function with P == NULL.  For    example:       int *p = NULL;      size_t used = 0;      size_t allocated = 0;      size_t allocated1 = 1000;       void      append_int (int value)        { 	 if (used == allocated) 	   { 	     p = x2nrealloc (p,&allocated1, sizeof *p); 	     allocated = allocated1; 	   } 	 p[used++] = value;        }     */
name|static_inline
name|void
modifier|*
name|x2nrealloc
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|size_t
modifier|*
name|pn
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
name|size_t
name|n
init|=
operator|*
name|pn
decl_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
if|if
condition|(
operator|!
name|n
condition|)
block|{
comment|/* The approximate size to use for initial small allocation 	     requests, when the invoking code specifies an old size of 	     zero.  64 bytes is the largest "small" request for the 	     GNU C library malloc.  */
enum|enum
block|{
name|DEFAULT_MXFAST
init|=
literal|64
block|}
enum|;
name|n
operator|=
name|DEFAULT_MXFAST
operator|/
name|s
expr_stmt|;
name|n
operator|+=
operator|!
name|n
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Set N = ceil (1.5 * N) so that progress is made if N == 1. 	 Check for overflow, so that N * S stays in size_t range. 	 The check is slightly conservative, but an exact check isn't 	 worth the trouble.  */
if|if
condition|(
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|/
literal|3
operator|*
literal|2
operator|/
name|s
operator|<=
name|n
condition|)
name|xalloc_die
argument_list|()
expr_stmt|;
name|n
operator|+=
operator|(
name|n
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
block|}
operator|*
name|pn
operator|=
name|n
expr_stmt|;
return|return
name|xrealloc
argument_list|(
name|p
argument_list|,
name|n
operator|*
name|s
argument_list|)
return|;
block|}
comment|/* Return a pointer to a new buffer of N bytes.  This is like xmalloc,    except it returns char *.  */
name|static_inline
name|char
modifier|*
name|xcharalloc
parameter_list|(
name|size_t
name|n
parameter_list|)
block|{
return|return
name|XNMALLOC
argument_list|(
name|n
argument_list|,
name|char
argument_list|)
return|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_comment
comment|/* C++ does not allow conversions from void * to other pointer types    without a cast.  Use templates to work around the problem when    possible.  */
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|T
operator|*
name|xrealloc
argument_list|(
argument|T *p
argument_list|,
argument|size_t s
argument_list|)
block|{
return|return
operator|(
name|T
operator|*
operator|)
name|xrealloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|p
argument_list|,
name|s
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|T
operator|*
name|xnrealloc
argument_list|(
argument|T *p
argument_list|,
argument|size_t n
argument_list|,
argument|size_t s
argument_list|)
block|{
return|return
operator|(
name|T
operator|*
operator|)
name|xnrealloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|p
argument_list|,
name|n
argument_list|,
name|s
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|T
operator|*
name|x2realloc
argument_list|(
argument|T *p
argument_list|,
argument|size_t *pn
argument_list|)
block|{
return|return
operator|(
name|T
operator|*
operator|)
name|x2realloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|p
argument_list|,
name|pn
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|T
operator|*
name|x2nrealloc
argument_list|(
argument|T *p
argument_list|,
argument|size_t *pn
argument_list|,
argument|size_t s
argument_list|)
block|{
return|return
operator|(
name|T
operator|*
operator|)
name|x2nrealloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|p
argument_list|,
name|pn
argument_list|,
name|s
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
specifier|inline
name|T
operator|*
name|xmemdup
argument_list|(
argument|T const *p
argument_list|,
argument|size_t s
argument_list|)
block|{
return|return
operator|(
name|T
operator|*
operator|)
name|xmemdup
argument_list|(
operator|(
name|void
specifier|const
operator|*
operator|)
name|p
argument_list|,
name|s
argument_list|)
return|;
block|}
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !XALLOC_H_ */
end_comment

end_unit

