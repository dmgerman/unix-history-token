begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Word-wrapping and line-truncating streams    Copyright (C) 1997,1998,1999,2001,2002,2003 Free Software Foundation, Inc.    This file is part of the GNU C Library.    Written by Miles Bader<miles@gnu.ai.mit.edu>.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License along    with this program; if not, write to the Free Software Foundation,    Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
end_comment

begin_comment
comment|/* This package emulates glibc `line_wrap_stream' semantics for systems that    don't have that.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"argp-fmtstream.h"
end_include

begin_include
include|#
directive|include
file|"argp-namefrob.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|ARGP_FMTSTREAM_USE_LINEWRAP
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|isblank
end_ifndef

begin_define
define|#
directive|define
name|isblank
parameter_list|(
name|ch
parameter_list|)
value|((ch)==' ' || (ch)=='\t')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
name|_LIBC
operator|&&
name|defined
name|USE_IN_LIBIO
end_if

begin_include
include|#
directive|include
file|<wchar.h>
end_include

begin_include
include|#
directive|include
file|<libio/libioP.h>
end_include

begin_define
define|#
directive|define
name|__vsnprintf
parameter_list|(
name|s
parameter_list|,
name|l
parameter_list|,
name|f
parameter_list|,
name|a
parameter_list|)
value|_IO_vsnprintf (s, l, f, a)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|INIT_BUF_SIZE
value|200
end_define

begin_define
define|#
directive|define
name|PRINTF_SIZE_GUESS
value|150
end_define

begin_escape
end_escape

begin_comment
comment|/* Return an argp_fmtstream that outputs to STREAM, and which prefixes lines    written on it with LMARGIN spaces and limits them to RMARGIN columns    total.  If WMARGIN>= 0, words that extend past RMARGIN are wrapped by    replacing the whitespace before them with a newline and WMARGIN spaces.    Otherwise, chars beyond RMARGIN are simply dropped until a newline.    Returns NULL if there was an error.  */
end_comment

begin_function
name|argp_fmtstream_t
name|__argp_make_fmtstream
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|size_t
name|lmargin
parameter_list|,
name|size_t
name|rmargin
parameter_list|,
name|ssize_t
name|wmargin
parameter_list|)
block|{
name|argp_fmtstream_t
name|fs
decl_stmt|;
name|fs
operator|=
operator|(
expr|struct
name|argp_fmtstream
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|argp_fmtstream
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|!=
name|NULL
condition|)
block|{
name|fs
operator|->
name|stream
operator|=
name|stream
expr_stmt|;
name|fs
operator|->
name|lmargin
operator|=
name|lmargin
expr_stmt|;
name|fs
operator|->
name|rmargin
operator|=
name|rmargin
expr_stmt|;
name|fs
operator|->
name|wmargin
operator|=
name|wmargin
expr_stmt|;
name|fs
operator|->
name|point_col
operator|=
literal|0
expr_stmt|;
name|fs
operator|->
name|point_offs
operator|=
literal|0
expr_stmt|;
name|fs
operator|->
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|INIT_BUF_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fs
operator|->
name|buf
condition|)
block|{
name|free
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|fs
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fs
operator|->
name|p
operator|=
name|fs
operator|->
name|buf
expr_stmt|;
name|fs
operator|->
name|end
operator|=
name|fs
operator|->
name|buf
operator|+
name|INIT_BUF_SIZE
expr_stmt|;
block|}
block|}
return|return
name|fs
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Not exported.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|weak_alias
end_ifdef

begin_endif
unit|weak_alias (__argp_make_fmtstream, argp_make_fmtstream)
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Flush FS to its stream, and free it (but don't close the stream).  */
end_comment

begin_function
name|void
name|__argp_fmtstream_free
parameter_list|(
name|argp_fmtstream_t
name|fs
parameter_list|)
block|{
name|__argp_fmtstream_update
argument_list|(
name|fs
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|p
operator|>
name|fs
operator|->
name|buf
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_IN_LIBIO
if|if
condition|(
name|_IO_fwide
argument_list|(
name|fs
operator|->
name|stream
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
name|__fwprintf
argument_list|(
name|fs
operator|->
name|stream
argument_list|,
literal|L"%.*s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|fs
operator|->
name|p
operator|-
name|fs
operator|->
name|buf
argument_list|)
argument_list|,
name|fs
operator|->
name|buf
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|fwrite_unlocked
argument_list|(
name|fs
operator|->
name|buf
argument_list|,
literal|1
argument_list|,
name|fs
operator|->
name|p
operator|-
name|fs
operator|->
name|buf
argument_list|,
name|fs
operator|->
name|stream
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|fs
operator|->
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fs
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Not exported.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|weak_alias
end_ifdef

begin_endif
unit|weak_alias (__argp_fmtstream_free, argp_fmtstream_free)
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Process FS's buffer so that line wrapping is done from POINT_OFFS to the    end of its buffer.  This code is mostly from glibc stdio/linewrap.c.  */
end_comment

begin_function
name|void
name|__argp_fmtstream_update
parameter_list|(
name|argp_fmtstream_t
name|fs
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|nl
decl_stmt|;
name|size_t
name|len
decl_stmt|;
comment|/* Scan the buffer for newlines.  */
name|buf
operator|=
name|fs
operator|->
name|buf
operator|+
name|fs
operator|->
name|point_offs
expr_stmt|;
while|while
condition|(
name|buf
operator|<
name|fs
operator|->
name|p
condition|)
block|{
name|size_t
name|r
decl_stmt|;
if|if
condition|(
name|fs
operator|->
name|point_col
operator|==
literal|0
operator|&&
name|fs
operator|->
name|lmargin
operator|!=
literal|0
condition|)
block|{
comment|/* We are starting a new line.  Print spaces to the left margin.  */
specifier|const
name|size_t
name|pad
init|=
name|fs
operator|->
name|lmargin
decl_stmt|;
if|if
condition|(
name|fs
operator|->
name|p
operator|+
name|pad
operator|<
name|fs
operator|->
name|end
condition|)
block|{
comment|/* We can fit in them in the buffer by moving the 		 buffer text up and filling in the beginning.  */
name|memmove
argument_list|(
name|buf
operator|+
name|pad
argument_list|,
name|buf
argument_list|,
name|fs
operator|->
name|p
operator|-
name|buf
argument_list|)
expr_stmt|;
name|fs
operator|->
name|p
operator|+=
name|pad
expr_stmt|;
comment|/* Compensate for bigger buffer. */
name|memset
argument_list|(
name|buf
argument_list|,
literal|' '
argument_list|,
name|pad
argument_list|)
expr_stmt|;
comment|/* Fill in the spaces.  */
name|buf
operator|+=
name|pad
expr_stmt|;
comment|/* Don't bother searching them.  */
block|}
else|else
block|{
comment|/* No buffer space for spaces.  Must flush.  */
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pad
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|USE_IN_LIBIO
if|if
condition|(
name|_IO_fwide
argument_list|(
name|fs
operator|->
name|stream
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
name|putwc_unlocked
argument_list|(
literal|L'
expr|'
argument_list|,
name|fs
operator|->
name|stream
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|putc_unlocked
argument_list|(
literal|' '
argument_list|,
name|fs
operator|->
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
name|fs
operator|->
name|point_col
operator|=
name|pad
expr_stmt|;
block|}
name|len
operator|=
name|fs
operator|->
name|p
operator|-
name|buf
expr_stmt|;
name|nl
operator|=
name|memchr
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|point_col
operator|<
literal|0
condition|)
name|fs
operator|->
name|point_col
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|nl
condition|)
block|{
comment|/* The buffer ends in a partial line.  */
if|if
condition|(
name|fs
operator|->
name|point_col
operator|+
name|len
operator|<
name|fs
operator|->
name|rmargin
condition|)
block|{
comment|/* The remaining buffer text is a partial line and fits 		 within the maximum line width.  Advance point for the 		 characters to be written and stop scanning.  */
name|fs
operator|->
name|point_col
operator|+=
name|len
expr_stmt|;
break|break;
block|}
else|else
comment|/* Set the end-of-line pointer for the code below to 	       the end of the buffer.  */
name|nl
operator|=
name|fs
operator|->
name|p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fs
operator|->
name|point_col
operator|+
operator|(
name|nl
operator|-
name|buf
operator|)
operator|<
operator|(
name|ssize_t
operator|)
name|fs
operator|->
name|rmargin
condition|)
block|{
comment|/* The buffer contains a full line that fits within the maximum 	     line width.  Reset point and scan the next line.  */
name|fs
operator|->
name|point_col
operator|=
literal|0
expr_stmt|;
name|buf
operator|=
name|nl
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* This line is too long.  */
name|r
operator|=
name|fs
operator|->
name|rmargin
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|wmargin
operator|<
literal|0
condition|)
block|{
comment|/* Truncate the line by overwriting the excess with the 	     newline and anything after it in the buffer.  */
if|if
condition|(
name|nl
operator|<
name|fs
operator|->
name|p
condition|)
block|{
name|memmove
argument_list|(
name|buf
operator|+
operator|(
name|r
operator|-
name|fs
operator|->
name|point_col
operator|)
argument_list|,
name|nl
argument_list|,
name|fs
operator|->
name|p
operator|-
name|nl
argument_list|)
expr_stmt|;
name|fs
operator|->
name|p
operator|-=
name|buf
operator|+
operator|(
name|r
operator|-
name|fs
operator|->
name|point_col
operator|)
operator|-
name|nl
expr_stmt|;
comment|/* Reset point for the next line and start scanning it.  */
name|fs
operator|->
name|point_col
operator|=
literal|0
expr_stmt|;
name|buf
operator|+=
name|r
operator|+
literal|1
expr_stmt|;
comment|/* Skip full line plus \n. */
block|}
else|else
block|{
comment|/* The buffer ends with a partial line that is beyond the 		 maximum line width.  Advance point for the characters 		 written, and discard those past the max from the buffer.  */
name|fs
operator|->
name|point_col
operator|+=
name|len
expr_stmt|;
name|fs
operator|->
name|p
operator|-=
name|fs
operator|->
name|point_col
operator|-
name|r
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* Do word wrap.  Go to the column just past the maximum line 	     width and scan back for the beginning of the word there. 	     Then insert a line break.  */
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|nextline
decl_stmt|;
name|int
name|i
decl_stmt|;
name|p
operator|=
name|buf
operator|+
operator|(
name|r
operator|+
literal|1
operator|-
name|fs
operator|->
name|point_col
operator|)
expr_stmt|;
while|while
condition|(
name|p
operator|>=
name|buf
operator|&&
operator|!
name|isblank
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|--
name|p
expr_stmt|;
name|nextline
operator|=
name|p
operator|+
literal|1
expr_stmt|;
comment|/* This will begin the next line.  */
if|if
condition|(
name|nextline
operator|>
name|buf
condition|)
block|{
comment|/* Swallow separating blanks.  */
if|if
condition|(
name|p
operator|>=
name|buf
condition|)
do|do
operator|--
name|p
expr_stmt|;
do|while
condition|(
name|p
operator|>=
name|buf
operator|&&
name|isblank
argument_list|(
operator|*
name|p
argument_list|)
condition|)
do|;
name|nl
operator|=
name|p
operator|+
literal|1
expr_stmt|;
comment|/* The newline will replace the first blank. */
block|}
else|else
block|{
comment|/* A single word that is greater than the maximum line width. 		 Oh well.  Put it on an overlong line by itself.  */
name|p
operator|=
name|buf
operator|+
operator|(
name|r
operator|+
literal|1
operator|-
name|fs
operator|->
name|point_col
operator|)
expr_stmt|;
comment|/* Find the end of the long word.  */
do|do
operator|++
name|p
expr_stmt|;
do|while
condition|(
name|p
operator|<
name|nl
operator|&&
operator|!
name|isblank
argument_list|(
operator|*
name|p
argument_list|)
condition|)
do|;
if|if
condition|(
name|p
operator|==
name|nl
condition|)
block|{
comment|/* It already ends a line.  No fussing required.  */
name|fs
operator|->
name|point_col
operator|=
literal|0
expr_stmt|;
name|buf
operator|=
name|nl
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* We will move the newline to replace the first blank.  */
name|nl
operator|=
name|p
expr_stmt|;
comment|/* Swallow separating blanks.  */
do|do
operator|++
name|p
expr_stmt|;
do|while
condition|(
name|isblank
argument_list|(
operator|*
name|p
argument_list|)
condition|)
do|;
comment|/* The next line will start here.  */
name|nextline
operator|=
name|p
expr_stmt|;
block|}
comment|/* Note: There are a bunch of tests below for 	     NEXTLINE == BUF + LEN + 1; this case is where NL happens to fall 	     at the end of the buffer, and NEXTLINE is in fact empty (and so 	     we need not be careful to maintain its contents).  */
if|if
condition|(
operator|(
name|nextline
operator|==
name|buf
operator|+
name|len
operator|+
literal|1
condition|?
name|fs
operator|->
name|end
operator|-
name|nl
operator|<
name|fs
operator|->
name|wmargin
operator|+
literal|1
else|:
name|nextline
operator|-
operator|(
name|nl
operator|+
literal|1
operator|)
operator|<
name|fs
operator|->
name|wmargin
operator|)
operator|&&
name|fs
operator|->
name|p
operator|>
name|nextline
condition|)
block|{
comment|/* The margin needs more blanks than we removed.  */
if|if
condition|(
name|fs
operator|->
name|end
operator|-
name|fs
operator|->
name|p
operator|>
name|fs
operator|->
name|wmargin
operator|+
literal|1
condition|)
comment|/* Make some space for them.  */
block|{
name|size_t
name|mv
init|=
name|fs
operator|->
name|p
operator|-
name|nextline
decl_stmt|;
name|memmove
argument_list|(
name|nl
operator|+
literal|1
operator|+
name|fs
operator|->
name|wmargin
argument_list|,
name|nextline
argument_list|,
name|mv
argument_list|)
expr_stmt|;
name|nextline
operator|=
name|nl
operator|+
literal|1
operator|+
name|fs
operator|->
name|wmargin
expr_stmt|;
name|len
operator|=
name|nextline
operator|+
name|mv
operator|-
name|buf
expr_stmt|;
operator|*
name|nl
operator|++
operator|=
literal|'\n'
expr_stmt|;
block|}
else|else
comment|/* Output the first line so we can use the space.  */
block|{
ifdef|#
directive|ifdef
name|USE_IN_LIBIO
if|if
condition|(
name|_IO_fwide
argument_list|(
name|fs
operator|->
name|stream
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
name|__fwprintf
argument_list|(
name|fs
operator|->
name|stream
argument_list|,
literal|L"%.*s\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|nl
operator|-
name|fs
operator|->
name|buf
argument_list|)
argument_list|,
name|fs
operator|->
name|buf
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
if|if
condition|(
name|nl
operator|>
name|fs
operator|->
name|buf
condition|)
name|fwrite_unlocked
argument_list|(
name|fs
operator|->
name|buf
argument_list|,
literal|1
argument_list|,
name|nl
operator|-
name|fs
operator|->
name|buf
argument_list|,
name|fs
operator|->
name|stream
argument_list|)
expr_stmt|;
name|putc_unlocked
argument_list|(
literal|'\n'
argument_list|,
name|fs
operator|->
name|stream
argument_list|)
expr_stmt|;
block|}
name|len
operator|+=
name|buf
operator|-
name|fs
operator|->
name|buf
expr_stmt|;
name|nl
operator|=
name|buf
operator|=
name|fs
operator|->
name|buf
expr_stmt|;
block|}
block|}
else|else
comment|/* We can fit the newline and blanks in before 	       the next word.  */
operator|*
name|nl
operator|++
operator|=
literal|'\n'
expr_stmt|;
if|if
condition|(
name|nextline
operator|-
name|nl
operator|>=
name|fs
operator|->
name|wmargin
operator|||
operator|(
name|nextline
operator|==
name|buf
operator|+
name|len
operator|+
literal|1
operator|&&
name|fs
operator|->
name|end
operator|-
name|nextline
operator|>=
name|fs
operator|->
name|wmargin
operator|)
condition|)
comment|/* Add blanks up to the wrap margin column.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fs
operator|->
name|wmargin
condition|;
operator|++
name|i
control|)
operator|*
name|nl
operator|++
operator|=
literal|' '
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fs
operator|->
name|wmargin
condition|;
operator|++
name|i
control|)
ifdef|#
directive|ifdef
name|USE_IN_LIBIO
if|if
condition|(
name|_IO_fwide
argument_list|(
name|fs
operator|->
name|stream
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
name|putwc_unlocked
argument_list|(
literal|L'
expr|'
argument_list|,
name|fs
operator|->
name|stream
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|putc_unlocked
argument_list|(
literal|' '
argument_list|,
name|fs
operator|->
name|stream
argument_list|)
expr_stmt|;
comment|/* Copy the tail of the original buffer into the current buffer 	     position.  */
if|if
condition|(
name|nl
operator|<
name|nextline
condition|)
name|memmove
argument_list|(
name|nl
argument_list|,
name|nextline
argument_list|,
name|buf
operator|+
name|len
operator|-
name|nextline
argument_list|)
expr_stmt|;
name|len
operator|-=
name|nextline
operator|-
name|buf
expr_stmt|;
comment|/* Continue the scan on the remaining lines in the buffer.  */
name|buf
operator|=
name|nl
expr_stmt|;
comment|/* Restore bufp to include all the remaining text.  */
name|fs
operator|->
name|p
operator|=
name|nl
operator|+
name|len
expr_stmt|;
comment|/* Reset the counter of what has been output this line.  If wmargin 	     is 0, we want to avoid the lmargin getting added, so we set 	     point_col to a magic value of -1 in that case.  */
name|fs
operator|->
name|point_col
operator|=
name|fs
operator|->
name|wmargin
condition|?
name|fs
operator|->
name|wmargin
else|:
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* Remember that we've scanned as far as the end of the buffer.  */
name|fs
operator|->
name|point_offs
operator|=
name|fs
operator|->
name|p
operator|-
name|fs
operator|->
name|buf
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Ensure that FS has space for AMOUNT more bytes in its buffer, either by    growing the buffer, or by flushing it.  True is returned iff we succeed. */
end_comment

begin_function
name|int
name|__argp_fmtstream_ensure
parameter_list|(
name|struct
name|argp_fmtstream
modifier|*
name|fs
parameter_list|,
name|size_t
name|amount
parameter_list|)
block|{
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|fs
operator|->
name|end
operator|-
name|fs
operator|->
name|p
argument_list|)
operator|<
name|amount
condition|)
block|{
name|ssize_t
name|wrote
decl_stmt|;
comment|/* Flush FS's buffer.  */
name|__argp_fmtstream_update
argument_list|(
name|fs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_IN_LIBIO
if|if
condition|(
name|_IO_fwide
argument_list|(
name|fs
operator|->
name|stream
argument_list|,
literal|0
argument_list|)
operator|>
literal|0
condition|)
block|{
name|__fwprintf
argument_list|(
name|fs
operator|->
name|stream
argument_list|,
literal|L"%.*s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|fs
operator|->
name|p
operator|-
name|fs
operator|->
name|buf
argument_list|)
argument_list|,
name|fs
operator|->
name|buf
argument_list|)
expr_stmt|;
name|wrote
operator|=
name|fs
operator|->
name|p
operator|-
name|fs
operator|->
name|buf
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|wrote
operator|=
name|fwrite_unlocked
argument_list|(
name|fs
operator|->
name|buf
argument_list|,
literal|1
argument_list|,
name|fs
operator|->
name|p
operator|-
name|fs
operator|->
name|buf
argument_list|,
name|fs
operator|->
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|wrote
operator|==
name|fs
operator|->
name|p
operator|-
name|fs
operator|->
name|buf
condition|)
block|{
name|fs
operator|->
name|p
operator|=
name|fs
operator|->
name|buf
expr_stmt|;
name|fs
operator|->
name|point_offs
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fs
operator|->
name|p
operator|-=
name|wrote
expr_stmt|;
name|fs
operator|->
name|point_offs
operator|-=
name|wrote
expr_stmt|;
name|memmove
argument_list|(
name|fs
operator|->
name|buf
argument_list|,
name|fs
operator|->
name|buf
operator|+
name|wrote
argument_list|,
name|fs
operator|->
name|p
operator|-
name|fs
operator|->
name|buf
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
call|(
name|size_t
call|)
argument_list|(
name|fs
operator|->
name|end
operator|-
name|fs
operator|->
name|buf
argument_list|)
operator|<
name|amount
condition|)
comment|/* Gotta grow the buffer.  */
block|{
name|size_t
name|old_size
init|=
name|fs
operator|->
name|end
operator|-
name|fs
operator|->
name|buf
decl_stmt|;
name|size_t
name|new_size
init|=
name|old_size
operator|+
name|amount
decl_stmt|;
name|char
modifier|*
name|new_buf
decl_stmt|;
if|if
condition|(
name|new_size
operator|<
name|old_size
operator|||
operator|!
operator|(
name|new_buf
operator|=
name|realloc
argument_list|(
name|fs
operator|->
name|buf
argument_list|,
name|new_size
argument_list|)
operator|)
condition|)
block|{
name|__set_errno
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|fs
operator|->
name|buf
operator|=
name|new_buf
expr_stmt|;
name|fs
operator|->
name|end
operator|=
name|new_buf
operator|+
name|new_size
expr_stmt|;
name|fs
operator|->
name|p
operator|=
name|fs
operator|->
name|buf
expr_stmt|;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|ssize_t
name|__argp_fmtstream_printf
parameter_list|(
name|struct
name|argp_fmtstream
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|out
decl_stmt|;
name|size_t
name|avail
decl_stmt|;
name|size_t
name|size_guess
init|=
name|PRINTF_SIZE_GUESS
decl_stmt|;
comment|/* How much space to reserve. */
do|do
block|{
name|va_list
name|args
decl_stmt|;
if|if
condition|(
operator|!
name|__argp_fmtstream_ensure
argument_list|(
name|fs
argument_list|,
name|size_guess
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
name|va_start
argument_list|(
name|args
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|avail
operator|=
name|fs
operator|->
name|end
operator|-
name|fs
operator|->
name|p
expr_stmt|;
name|out
operator|=
name|__vsnprintf
argument_list|(
name|fs
operator|->
name|p
argument_list|,
name|avail
argument_list|,
name|fmt
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|out
operator|>=
name|avail
condition|)
name|size_guess
operator|=
name|out
operator|+
literal|1
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|size_t
operator|)
name|out
operator|>=
name|avail
condition|)
do|;
name|fs
operator|->
name|p
operator|+=
name|out
expr_stmt|;
return|return
name|out
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Not exported.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|weak_alias
end_ifdef

begin_endif
unit|weak_alias (__argp_fmtstream_printf, argp_fmtstream_printf)
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !ARGP_FMTSTREAM_USE_LINEWRAP */
end_comment

end_unit

