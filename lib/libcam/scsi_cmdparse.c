begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Taken from the original FreeBSD user SCSI library.  */
end_comment

begin_comment
comment|/* Copyright (c) 1994 HD Associates  * (contact: dufault@hda.com)  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  * This product includes software developed by HD Associates  * 4. Neither the name of the HD Associaates nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY HD ASSOCIATES``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL HD ASSOCIATES OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  * From: scsi.c,v 1.8 1997/02/22 15:07:54 peter Exp $  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_message.h>
end_include

begin_include
include|#
directive|include
file|"camlib.h"
end_include

begin_comment
comment|/*  * Decode: Decode the data section of a scsireq.  This decodes  * trivial grammar:  *  * fields : field fields  *        ;  *  * field : field_specifier  *       | control  *       ;  *  * control : 's' seek_value  *       | 's' '+' seek_value  *       ;  *  * seek_value : DECIMAL_NUMBER  *       | 'v'				// For indirect seek, i.e., value from the arg list  *       ;  *  * field_specifier : type_specifier field_width  *       | '{' NAME '}' type_specifier field_width  *       ;  *  * field_width : DECIMAL_NUMBER  *       ;  *  * type_specifier : 'i'	// Integral types (i1, i2, i3, i4)  *       | 'b'				// Bits  *       | 't'				// Bits  *       | 'c'				// Character arrays  *       | 'z'				// Character arrays with zeroed trailing spaces  *       ;  *  * Notes:  * 1. Integral types are swapped into host order.  * 2. Bit fields are allocated MSB to LSB to match the SCSI spec documentation.  * 3. 's' permits "seeking" in the string.  "s+DECIMAL" seeks relative to  *    DECIMAL; "sDECIMAL" seeks absolute to decimal.  * 4. 's' permits an indirect reference.  "sv" or "s+v" will get the  *    next integer value from the arg array.  * 5. Field names can be anything between the braces  *  * BUGS:  * i and b types are promoted to ints.  *  */
end_comment

begin_function
specifier|static
name|int
name|do_buff_decode
parameter_list|(
name|u_int8_t
modifier|*
name|databuf
parameter_list|,
name|size_t
name|len
parameter_list|,
name|void
function_decl|(
modifier|*
name|arg_put
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|puthook
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|int
name|assigned
init|=
literal|0
decl_stmt|;
name|int
name|width
decl_stmt|;
name|int
name|suppress
decl_stmt|;
name|int
name|plus
decl_stmt|;
name|int
name|done
init|=
literal|0
decl_stmt|;
specifier|static
name|u_char
name|mask
index|[]
init|=
block|{
literal|0
block|,
literal|0x01
block|,
literal|0x03
block|,
literal|0x07
block|,
literal|0x0f
block|,
literal|0x1f
block|,
literal|0x3f
block|,
literal|0x7f
block|,
literal|0xff
block|}
decl_stmt|;
name|int
name|value
decl_stmt|;
name|u_char
modifier|*
name|base
init|=
name|databuf
decl_stmt|;
name|char
name|letter
decl_stmt|;
name|char
name|field_name
index|[
literal|80
index|]
decl_stmt|;
define|#
directive|define
name|ARG_PUT
parameter_list|(
name|ARG
parameter_list|)
define|\
value|do \ 	{ \ 		if (!suppress) \ 		{ \ 			if (arg_put) \ 				(*arg_put)(puthook, (letter == 't' ? \ 					'b' : letter), \ 					(void *)((long)(ARG)), width, \ 					field_name); \ 			else \ 				*(va_arg(ap, int *)) = (ARG); \ 			assigned++; \ 		} \ 		field_name[0] = 0; \ 		suppress = 0; \ 	} while (0)
name|u_char
name|bits
init|=
literal|0
decl_stmt|;
comment|/* For bit fields */
name|int
name|shift
init|=
literal|0
decl_stmt|;
comment|/* Bits already shifted out */
name|suppress
operator|=
literal|0
expr_stmt|;
name|field_name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
switch|switch
condition|(
name|letter
operator|=
operator|*
name|fmt
condition|)
block|{
case|case
literal|' '
case|:
comment|/* White space */
case|case
literal|'\t'
case|:
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
case|case
literal|'\f'
case|:
name|fmt
operator|++
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
comment|/* Comment */
while|while
condition|(
operator|*
name|fmt
operator|&&
operator|(
operator|*
name|fmt
operator|!=
literal|'\n'
operator|)
condition|)
name|fmt
operator|++
expr_stmt|;
if|if
condition|(
name|fmt
condition|)
name|fmt
operator|++
expr_stmt|;
comment|/* Skip '\n' */
break|break;
case|case
literal|'*'
case|:
comment|/* Suppress assignment */
name|fmt
operator|++
expr_stmt|;
name|suppress
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
comment|/* Field Name */
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|fmt
operator|++
expr_stmt|;
comment|/* Skip '{' */
while|while
condition|(
operator|*
name|fmt
operator|&&
operator|(
operator|*
name|fmt
operator|!=
literal|'}'
operator|)
condition|)
block|{
if|if
condition|(
name|i
operator|<
sizeof|sizeof
argument_list|(
name|field_name
argument_list|)
condition|)
name|field_name
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|fmt
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|fmt
condition|)
name|fmt
operator|++
expr_stmt|;
comment|/* Skip '}' */
name|field_name
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
break|break;
block|}
case|case
literal|'t'
case|:
comment|/* Bit (field) */
case|case
literal|'b'
case|:
comment|/* Bits */
name|fmt
operator|++
expr_stmt|;
name|width
operator|=
name|strtol
argument_list|(
name|fmt
argument_list|,
operator|&
name|fmt
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|>
literal|8
condition|)
name|done
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|shift
operator|<=
literal|0
condition|)
block|{
name|bits
operator|=
operator|*
name|databuf
operator|++
expr_stmt|;
name|shift
operator|=
literal|8
expr_stmt|;
block|}
name|value
operator|=
operator|(
name|bits
operator|>>
operator|(
name|shift
operator|-
name|width
operator|)
operator|)
operator|&
name|mask
index|[
name|width
index|]
expr_stmt|;
if|#
directive|if
literal|0
block|printf("shift %2d bits %02x value %02x width %2d mask %02x\n", 				shift, bits, value, width, mask[width]);
endif|#
directive|endif
name|ARG_PUT
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|shift
operator|-=
name|width
expr_stmt|;
block|}
break|break;
case|case
literal|'i'
case|:
comment|/* Integral values */
name|shift
operator|=
literal|0
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
name|width
operator|=
name|strtol
argument_list|(
name|fmt
argument_list|,
operator|&
name|fmt
argument_list|,
literal|10
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|width
condition|)
block|{
case|case
literal|1
case|:
name|ARG_PUT
argument_list|(
operator|*
name|databuf
argument_list|)
expr_stmt|;
name|databuf
operator|++
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ARG_PUT
argument_list|(
operator|(
operator|*
name|databuf
operator|)
operator|<<
literal|8
operator||
operator|*
operator|(
name|databuf
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|databuf
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|ARG_PUT
argument_list|(
operator|(
operator|*
name|databuf
operator|)
operator|<<
literal|16
operator||
operator|(
operator|*
operator|(
name|databuf
operator|+
literal|1
operator|)
operator|)
operator|<<
literal|8
operator||
operator|*
operator|(
name|databuf
operator|+
literal|2
operator|)
argument_list|)
expr_stmt|;
name|databuf
operator|+=
literal|3
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|ARG_PUT
argument_list|(
operator|(
operator|*
name|databuf
operator|)
operator|<<
literal|24
operator||
operator|(
operator|*
operator|(
name|databuf
operator|+
literal|1
operator|)
operator|)
operator|<<
literal|16
operator||
operator|(
operator|*
operator|(
name|databuf
operator|+
literal|2
operator|)
operator|)
operator|<<
literal|8
operator||
operator|*
operator|(
name|databuf
operator|+
literal|3
operator|)
argument_list|)
expr_stmt|;
name|databuf
operator|+=
literal|4
expr_stmt|;
break|break;
default|default:
name|done
operator|=
literal|1
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'c'
case|:
comment|/* Characters (i.e., not swapped) */
case|case
literal|'z'
case|:
comment|/* Characters with zeroed trailing 					   spaces  */
name|shift
operator|=
literal|0
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
name|width
operator|=
name|strtol
argument_list|(
name|fmt
argument_list|,
operator|&
name|fmt
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|suppress
condition|)
block|{
if|if
condition|(
name|arg_put
condition|)
call|(
modifier|*
name|arg_put
call|)
argument_list|(
name|puthook
argument_list|,
operator|(
name|letter
operator|==
literal|'t'
condition|?
literal|'b'
else|:
name|letter
operator|)
argument_list|,
name|databuf
argument_list|,
name|width
argument_list|,
name|field_name
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|dest
decl_stmt|;
name|dest
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|databuf
argument_list|,
name|dest
argument_list|,
name|width
argument_list|)
expr_stmt|;
if|if
condition|(
name|letter
operator|==
literal|'z'
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|dest
operator|+
name|width
operator|-
literal|1
init|;
operator|(
name|p
operator|>=
operator|(
name|char
operator|*
operator|)
name|dest
operator|)
operator|&&
operator|(
operator|*
name|p
operator|==
literal|' '
operator|)
condition|;
name|p
operator|--
control|)
operator|*
name|p
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|assigned
operator|++
expr_stmt|;
block|}
name|databuf
operator|+=
name|width
expr_stmt|;
name|field_name
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|suppress
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* Seek */
name|shift
operator|=
literal|0
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'+'
condition|)
block|{
name|plus
operator|=
literal|1
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
block|}
else|else
name|plus
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tolower
argument_list|(
operator|*
name|fmt
argument_list|)
operator|==
literal|'v'
condition|)
block|{
comment|/* 				 * You can't suppress a seek value.  You also 				 * can't have a variable seek when you are using 				 * "arg_put". 				 */
name|width
operator|=
operator|(
name|arg_put
operator|)
condition|?
literal|0
else|:
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
block|}
else|else
name|width
operator|=
name|strtol
argument_list|(
name|fmt
argument_list|,
operator|&
name|fmt
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|plus
condition|)
name|databuf
operator|+=
name|width
expr_stmt|;
comment|/* Relative seek */
else|else
name|databuf
operator|=
name|base
operator|+
name|width
expr_stmt|;
comment|/* Absolute seek */
break|break;
case|case
literal|0
case|:
name|done
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown letter in format: %c\n"
argument_list|,
name|letter
argument_list|)
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|assigned
operator|)
return|;
block|}
end_function

begin_comment
comment|/* next_field: Return the next field in a command specifier.  This  * builds up a SCSI command using this trivial grammar:  *  * fields : field fields  *        ;  *  * field : value  *       | value ':' field_width  *       ;  *  * field_width : digit  *       | 'i' digit		// i2 = 2 byte integer, i3 = 3 byte integer etc.  *       ;  *  * value : HEX_NUMBER  *       | 'v'				// For indirection.  *       ;  *  * Notes:  *  Bit fields are specified MSB first to match the SCSI spec.  *  * Examples:  *  TUR: "0 0 0 0 0 0"  *  WRITE BUFFER: "38 v:3 0:2 0:3 v v:i3 v:i3 0", mode, buffer_id, list_length  *  * The function returns the value:  *  0: For reached end, with error_p set if an error was found  *  1: For valid stuff setup  *  2: For "v" was entered as the value (implies use varargs)  *  */
end_comment

begin_function
specifier|static
name|int
name|next_field
parameter_list|(
name|char
modifier|*
modifier|*
name|pp
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
name|int
modifier|*
name|width_p
parameter_list|,
name|int
modifier|*
name|value_p
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|n_name
parameter_list|,
name|int
modifier|*
name|error_p
parameter_list|,
name|int
modifier|*
name|suppress_p
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
operator|*
name|pp
decl_stmt|;
name|int
name|something
init|=
literal|0
decl_stmt|;
enum|enum
block|{
name|BETWEEN_FIELDS
block|,
name|START_FIELD
block|,
name|GET_FIELD
block|,
name|DONE
block|, 	}
name|state
enum|;
name|int
name|value
init|=
literal|0
decl_stmt|;
name|int
name|field_size
decl_stmt|;
comment|/* Default to byte field type... */
name|int
name|field_width
decl_stmt|;
comment|/* 1 byte wide */
name|int
name|is_error
init|=
literal|0
decl_stmt|;
name|int
name|suppress
init|=
literal|0
decl_stmt|;
name|field_size
operator|=
literal|8
expr_stmt|;
comment|/* Default to byte field type... */
operator|*
name|fmt
operator|=
literal|'i'
expr_stmt|;
name|field_width
operator|=
literal|1
expr_stmt|;
comment|/* 1 byte wide */
if|if
condition|(
name|name
condition|)
operator|*
name|name
operator|=
literal|0
expr_stmt|;
name|state
operator|=
name|BETWEEN_FIELDS
expr_stmt|;
while|while
condition|(
name|state
operator|!=
name|DONE
condition|)
block|{
switch|switch
condition|(
name|state
condition|)
block|{
case|case
name|BETWEEN_FIELDS
case|:
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
name|state
operator|=
name|DONE
expr_stmt|;
elseif|else
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'#'
condition|)
block|{
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'{'
condition|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|p
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'}'
condition|)
block|{
if|if
condition|(
name|name
operator|&&
name|i
operator|<
name|n_name
condition|)
block|{
name|name
index|[
name|i
index|]
operator|=
operator|*
name|p
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|name
operator|&&
name|i
operator|<
name|n_name
condition|)
name|name
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'}'
condition|)
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'*'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|suppress
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isxdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|something
operator|=
literal|1
expr_stmt|;
name|value
operator|=
name|strtol
argument_list|(
name|p
argument_list|,
operator|&
name|p
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|state
operator|=
name|START_FIELD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tolower
argument_list|(
operator|*
name|p
argument_list|)
operator|==
literal|'v'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|something
operator|=
literal|2
expr_stmt|;
name|value
operator|=
operator|*
name|value_p
expr_stmt|;
name|state
operator|=
name|START_FIELD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tolower
argument_list|(
operator|*
name|p
argument_list|)
operator|==
literal|'i'
condition|)
block|{
comment|/* 				 * Try to work without the "v". 				 */
name|something
operator|=
literal|2
expr_stmt|;
name|value
operator|=
operator|*
name|value_p
expr_stmt|;
name|p
operator|++
expr_stmt|;
operator|*
name|fmt
operator|=
literal|'i'
expr_stmt|;
name|field_size
operator|=
literal|8
expr_stmt|;
name|field_width
operator|=
name|strtol
argument_list|(
name|p
argument_list|,
operator|&
name|p
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|state
operator|=
name|DONE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tolower
argument_list|(
operator|*
name|p
argument_list|)
operator|==
literal|'t'
condition|)
block|{
comment|/* 				 * XXX: B can't work: Sees the 'b' as a 				 * hex digit in "isxdigit".  try "t" for 				 * bit field. 				 */
name|something
operator|=
literal|2
expr_stmt|;
name|value
operator|=
operator|*
name|value_p
expr_stmt|;
name|p
operator|++
expr_stmt|;
operator|*
name|fmt
operator|=
literal|'b'
expr_stmt|;
name|field_size
operator|=
literal|1
expr_stmt|;
name|field_width
operator|=
name|strtol
argument_list|(
name|p
argument_list|,
operator|&
name|p
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|state
operator|=
name|DONE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tolower
argument_list|(
operator|*
name|p
argument_list|)
operator|==
literal|'s'
condition|)
block|{
comment|/* Seek */
operator|*
name|fmt
operator|=
literal|'s'
expr_stmt|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|tolower
argument_list|(
operator|*
name|p
argument_list|)
operator|==
literal|'v'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|something
operator|=
literal|2
expr_stmt|;
name|value
operator|=
operator|*
name|value_p
expr_stmt|;
block|}
else|else
block|{
name|something
operator|=
literal|1
expr_stmt|;
name|value
operator|=
name|strtol
argument_list|(
name|p
argument_list|,
operator|&
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|state
operator|=
name|DONE
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid starting "
literal|"character: %c\n"
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|is_error
operator|=
literal|1
expr_stmt|;
name|state
operator|=
name|DONE
expr_stmt|;
block|}
break|break;
case|case
name|START_FIELD
case|:
if|if
condition|(
operator|*
name|p
operator|==
literal|':'
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|field_size
operator|=
literal|1
expr_stmt|;
comment|/* Default to bits 							   when specified */
name|state
operator|=
name|GET_FIELD
expr_stmt|;
block|}
else|else
name|state
operator|=
name|DONE
expr_stmt|;
break|break;
case|case
name|GET_FIELD
case|:
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
operator|*
name|fmt
operator|=
literal|'b'
expr_stmt|;
name|field_size
operator|=
literal|1
expr_stmt|;
name|field_width
operator|=
name|strtol
argument_list|(
name|p
argument_list|,
operator|&
name|p
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|state
operator|=
name|DONE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'i'
condition|)
block|{
comment|/* Integral (bytes) */
name|p
operator|++
expr_stmt|;
operator|*
name|fmt
operator|=
literal|'i'
expr_stmt|;
name|field_size
operator|=
literal|8
expr_stmt|;
name|field_width
operator|=
name|strtol
argument_list|(
name|p
argument_list|,
operator|&
name|p
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|state
operator|=
name|DONE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'b'
condition|)
block|{
comment|/* Bits */
name|p
operator|++
expr_stmt|;
operator|*
name|fmt
operator|=
literal|'b'
expr_stmt|;
name|field_size
operator|=
literal|1
expr_stmt|;
name|field_width
operator|=
name|strtol
argument_list|(
name|p
argument_list|,
operator|&
name|p
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|state
operator|=
name|DONE
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid startfield %c "
literal|"(%02x)\n"
argument_list|,
operator|*
name|p
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|is_error
operator|=
literal|1
expr_stmt|;
name|state
operator|=
name|DONE
expr_stmt|;
block|}
break|break;
case|case
name|DONE
case|:
break|break;
block|}
block|}
if|if
condition|(
name|is_error
condition|)
block|{
operator|*
name|error_p
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|error_p
operator|=
literal|0
expr_stmt|;
operator|*
name|pp
operator|=
name|p
expr_stmt|;
operator|*
name|width_p
operator|=
name|field_width
operator|*
name|field_size
expr_stmt|;
operator|*
name|value_p
operator|=
name|value
expr_stmt|;
operator|*
name|suppress_p
operator|=
name|suppress
expr_stmt|;
return|return
operator|(
name|something
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|do_encode
parameter_list|(
name|u_char
modifier|*
name|buff
parameter_list|,
name|size_t
name|vec_max
parameter_list|,
name|size_t
modifier|*
name|used
parameter_list|,
name|int
function_decl|(
modifier|*
name|arg_get
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|gethook
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|int
name|ind
decl_stmt|;
name|int
name|shift
decl_stmt|;
name|u_char
name|val
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|width
decl_stmt|,
name|value
decl_stmt|,
name|error
decl_stmt|,
name|suppress
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|encoded
init|=
literal|0
decl_stmt|;
name|char
name|field_name
index|[
literal|80
index|]
decl_stmt|;
name|ind
operator|=
literal|0
expr_stmt|;
name|shift
operator|=
literal|0
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ret
operator|=
name|next_field
argument_list|(
operator|&
name|fmt
argument_list|,
operator|&
name|c
argument_list|,
operator|&
name|width
argument_list|,
operator|&
name|value
argument_list|,
name|field_name
argument_list|,
sizeof|sizeof
argument_list|(
name|field_name
argument_list|)
argument_list|,
operator|&
name|error
argument_list|,
operator|&
name|suppress
argument_list|)
operator|)
condition|)
block|{
name|encoded
operator|++
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|suppress
condition|)
name|value
operator|=
literal|0
expr_stmt|;
else|else
name|value
operator|=
name|arg_get
condition|?
call|(
modifier|*
name|arg_get
call|)
argument_list|(
name|gethook
argument_list|,
name|field_name
argument_list|)
else|:
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|printf( "do_encode: ret %d fmt %c width %d value %d name \"%s\" error %d suppress %d\n", 		ret, c, width, value, field_name, error, suppress);
endif|#
directive|endif
comment|/* Absolute seek */
if|if
condition|(
name|c
operator|==
literal|'s'
condition|)
block|{
name|ind
operator|=
name|value
expr_stmt|;
continue|continue;
block|}
comment|/* A width of< 8 is a bit field. */
if|if
condition|(
name|width
operator|<
literal|8
condition|)
block|{
comment|/* This is a bit field.  We start with the high bits 			 * so it reads the same as the SCSI spec. 			 */
name|shift
operator|+=
name|width
expr_stmt|;
name|val
operator||=
operator|(
name|value
operator|<<
operator|(
literal|8
operator|-
name|shift
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|shift
operator|==
literal|8
condition|)
block|{
if|if
condition|(
name|ind
operator|<
name|vec_max
condition|)
block|{
name|buff
index|[
name|ind
operator|++
index|]
operator|=
name|val
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
name|shift
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|shift
condition|)
block|{
if|if
condition|(
name|ind
operator|<
name|vec_max
condition|)
block|{
name|buff
index|[
name|ind
operator|++
index|]
operator|=
name|val
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
name|shift
operator|=
literal|0
expr_stmt|;
block|}
switch|switch
condition|(
name|width
condition|)
block|{
case|case
literal|8
case|:
comment|/* 1 byte integer */
if|if
condition|(
name|ind
operator|<
name|vec_max
condition|)
name|buff
index|[
name|ind
operator|++
index|]
operator|=
name|value
expr_stmt|;
break|break;
case|case
literal|16
case|:
comment|/* 2 byte integer */
if|if
condition|(
name|ind
operator|<
name|vec_max
operator|-
literal|2
operator|+
literal|1
condition|)
block|{
name|buff
index|[
name|ind
operator|++
index|]
operator|=
name|value
operator|>>
literal|8
expr_stmt|;
name|buff
index|[
name|ind
operator|++
index|]
operator|=
name|value
expr_stmt|;
block|}
break|break;
case|case
literal|24
case|:
comment|/* 3 byte integer */
if|if
condition|(
name|ind
operator|<
name|vec_max
operator|-
literal|3
operator|+
literal|1
condition|)
block|{
name|buff
index|[
name|ind
operator|++
index|]
operator|=
name|value
operator|>>
literal|16
expr_stmt|;
name|buff
index|[
name|ind
operator|++
index|]
operator|=
name|value
operator|>>
literal|8
expr_stmt|;
name|buff
index|[
name|ind
operator|++
index|]
operator|=
name|value
expr_stmt|;
block|}
break|break;
case|case
literal|32
case|:
comment|/* 4 byte integer */
if|if
condition|(
name|ind
operator|<
name|vec_max
operator|-
literal|4
operator|+
literal|1
condition|)
block|{
name|buff
index|[
name|ind
operator|++
index|]
operator|=
name|value
operator|>>
literal|24
expr_stmt|;
name|buff
index|[
name|ind
operator|++
index|]
operator|=
name|value
operator|>>
literal|16
expr_stmt|;
name|buff
index|[
name|ind
operator|++
index|]
operator|=
name|value
operator|>>
literal|8
expr_stmt|;
name|buff
index|[
name|ind
operator|++
index|]
operator|=
name|value
expr_stmt|;
block|}
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"do_encode: Illegal width\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Flush out any remaining bits 	 */
if|if
condition|(
name|shift
operator|&&
name|ind
operator|<
name|vec_max
condition|)
block|{
name|buff
index|[
name|ind
operator|++
index|]
operator|=
name|val
expr_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|used
condition|)
operator|*
name|used
operator|=
name|ind
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|encoded
return|;
block|}
end_function

begin_function
name|int
name|csio_decode
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
return|return
operator|(
name|do_buff_decode
argument_list|(
name|csio
operator|->
name|data_ptr
argument_list|,
operator|(
name|size_t
operator|)
name|csio
operator|->
name|dxfer_len
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|csio_decode_visit
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
name|void
function_decl|(
modifier|*
name|arg_put
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|puthook
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
comment|/* 	 * We need some way to output things; we can't do it without 	 * the arg_put function. 	 */
if|if
condition|(
name|arg_put
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bzero
argument_list|(
operator|&
name|ap
argument_list|,
sizeof|sizeof
argument_list|(
name|ap
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|do_buff_decode
argument_list|(
name|csio
operator|->
name|data_ptr
argument_list|,
operator|(
name|size_t
operator|)
name|csio
operator|->
name|dxfer_len
argument_list|,
name|arg_put
argument_list|,
name|puthook
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|buff_decode
parameter_list|(
name|u_int8_t
modifier|*
name|buff
parameter_list|,
name|size_t
name|len
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
return|return
operator|(
name|do_buff_decode
argument_list|(
name|buff
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|buff_decode_visit
parameter_list|(
name|u_int8_t
modifier|*
name|buff
parameter_list|,
name|size_t
name|len
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
name|void
function_decl|(
modifier|*
name|arg_put
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|puthook
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
comment|/* 	 * We need some way to output things; we can't do it without 	 * the arg_put function. 	 */
if|if
condition|(
name|arg_put
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bzero
argument_list|(
operator|&
name|ap
argument_list|,
sizeof|sizeof
argument_list|(
name|ap
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|do_buff_decode
argument_list|(
name|buff
argument_list|,
name|len
argument_list|,
name|arg_put
argument_list|,
name|puthook
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Build a SCSI CCB, given the command and data pointers and a format  * string describing the   */
end_comment

begin_function
name|int
name|csio_build
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int8_t
modifier|*
name|data_ptr
parameter_list|,
name|u_int32_t
name|dxfer_len
parameter_list|,
name|u_int32_t
name|flags
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
name|char
modifier|*
name|cmd_spec
parameter_list|,
modifier|...
parameter_list|)
block|{
name|size_t
name|cmdlen
decl_stmt|;
name|int
name|retval
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
name|csio
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bzero
argument_list|(
name|csio
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_scsiio
argument_list|)
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|cmd_spec
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retval
operator|=
name|do_encode
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|SCSI_MAX_CDBLEN
argument_list|,
operator|&
name|cmdlen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|cmd_spec
argument_list|,
name|ap
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|retval
operator|)
return|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
comment|/* retries */
name|retry_count
argument_list|,
comment|/* cbfcnp */
name|NULL
argument_list|,
comment|/* flags */
name|flags
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* data_ptr */
name|data_ptr
argument_list|,
comment|/* dxfer_len */
name|dxfer_len
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* cdb_len */
name|cmdlen
argument_list|,
comment|/* timeout */
name|timeout
condition|?
name|timeout
else|:
literal|5000
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|csio_build_visit
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|u_int8_t
modifier|*
name|data_ptr
parameter_list|,
name|u_int32_t
name|dxfer_len
parameter_list|,
name|u_int32_t
name|flags
parameter_list|,
name|int
name|retry_count
parameter_list|,
name|int
name|timeout
parameter_list|,
name|char
modifier|*
name|cmd_spec
parameter_list|,
name|int
function_decl|(
modifier|*
name|arg_get
function_decl|)
parameter_list|(
name|void
modifier|*
name|hook
parameter_list|,
name|char
modifier|*
name|field_name
parameter_list|)
parameter_list|,
name|void
modifier|*
name|gethook
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|size_t
name|cmdlen
decl_stmt|;
name|int
name|retval
decl_stmt|;
if|if
condition|(
name|csio
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * We need something to encode, but we can't get it without the 	 * arg_get function. 	 */
if|if
condition|(
name|arg_get
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bzero
argument_list|(
operator|&
name|ap
argument_list|,
sizeof|sizeof
argument_list|(
name|ap
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|csio
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_scsiio
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|retval
operator|=
name|do_encode
argument_list|(
name|csio
operator|->
name|cdb_io
operator|.
name|cdb_bytes
argument_list|,
name|SCSI_MAX_CDBLEN
argument_list|,
operator|&
name|cmdlen
argument_list|,
name|arg_get
argument_list|,
name|gethook
argument_list|,
name|cmd_spec
argument_list|,
name|ap
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|retval
operator|)
return|;
name|cam_fill_csio
argument_list|(
name|csio
argument_list|,
comment|/* retries */
name|retry_count
argument_list|,
comment|/* cbfcnp */
name|NULL
argument_list|,
comment|/* flags */
name|flags
argument_list|,
comment|/* tag_action */
name|MSG_SIMPLE_Q_TAG
argument_list|,
comment|/* data_ptr */
name|data_ptr
argument_list|,
comment|/* dxfer_len */
name|dxfer_len
argument_list|,
comment|/* sense_len */
name|SSD_FULL_SIZE
argument_list|,
comment|/* cdb_len */
name|cmdlen
argument_list|,
comment|/* timeout */
name|timeout
condition|?
name|timeout
else|:
literal|5000
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|csio_encode
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
name|csio
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
return|return
operator|(
name|do_encode
argument_list|(
name|csio
operator|->
name|data_ptr
argument_list|,
name|csio
operator|->
name|dxfer_len
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|buff_encode_visit
parameter_list|(
name|u_int8_t
modifier|*
name|buff
parameter_list|,
name|size_t
name|len
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
name|int
function_decl|(
modifier|*
name|arg_get
function_decl|)
parameter_list|(
name|void
modifier|*
name|hook
parameter_list|,
name|char
modifier|*
name|field_name
parameter_list|)
parameter_list|,
name|void
modifier|*
name|gethook
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
comment|/* 	 * We need something to encode, but we can't get it without the 	 * arg_get function. 	 */
if|if
condition|(
name|arg_get
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bzero
argument_list|(
operator|&
name|ap
argument_list|,
sizeof|sizeof
argument_list|(
name|ap
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|do_encode
argument_list|(
name|buff
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
name|arg_get
argument_list|,
name|gethook
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|csio_encode_visit
parameter_list|(
name|struct
name|ccb_scsiio
modifier|*
name|csio
parameter_list|,
name|char
modifier|*
name|fmt
parameter_list|,
name|int
function_decl|(
modifier|*
name|arg_get
function_decl|)
parameter_list|(
name|void
modifier|*
name|hook
parameter_list|,
name|char
modifier|*
name|field_name
parameter_list|)
parameter_list|,
name|void
modifier|*
name|gethook
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
comment|/* 	 * We need something to encode, but we can't get it without the 	 * arg_get function. 	 */
if|if
condition|(
name|arg_get
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bzero
argument_list|(
operator|&
name|ap
argument_list|,
sizeof|sizeof
argument_list|(
name|ap
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|do_encode
argument_list|(
name|csio
operator|->
name|data_ptr
argument_list|,
name|csio
operator|->
name|dxfer_len
argument_list|,
literal|0
argument_list|,
name|arg_get
argument_list|,
name|gethook
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

