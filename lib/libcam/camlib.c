begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997, 1998, 1999 Kenneth D. Merry.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_all.h>
end_include

begin_include
include|#
directive|include
file|<cam/cam_ccb.h>
end_include

begin_include
include|#
directive|include
file|<cam/scsi/scsi_pass.h>
end_include

begin_include
include|#
directive|include
file|"camlib.h"
end_include

begin_struct
struct|struct
name|cam_devequiv
block|{
name|char
modifier|*
name|given_dev
decl_stmt|;
name|char
modifier|*
name|real_dev
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|cam_devequiv
name|devmatchtable
index|[]
init|=
block|{
block|{
literal|"sd"
block|,
literal|"da"
block|}
block|,
block|{
literal|"st"
block|,
literal|"sa"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|cam_errbuf
index|[
name|CAM_ERRBUF_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|cam_device
modifier|*
name|cam_real_open_device
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
specifier|const
name|char
modifier|*
name|given_path
parameter_list|,
specifier|const
name|char
modifier|*
name|given_dev_name
parameter_list|,
name|int
name|given_unit_number
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|cam_device
modifier|*
name|cam_lookup_pass
parameter_list|(
specifier|const
name|char
modifier|*
name|dev_name
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|given_path
parameter_list|,
name|struct
name|cam_device
modifier|*
name|device
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Send a ccb to a passthrough device.  */
end_comment

begin_function
name|int
name|cam_send_ccb
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
return|return
operator|(
name|ioctl
argument_list|(
name|device
operator|->
name|fd
argument_list|,
name|CAMIOCOMMAND
argument_list|,
name|ccb
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Malloc a CCB, zero out the header and set its path, target and lun ids.  */
end_comment

begin_function
name|union
name|ccb
modifier|*
name|cam_getccb
parameter_list|(
name|struct
name|cam_device
modifier|*
name|dev
parameter_list|)
block|{
name|union
name|ccb
modifier|*
name|ccb
decl_stmt|;
name|ccb
operator|=
operator|(
expr|union
name|ccb
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|!=
name|NULL
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|ccb
operator|->
name|ccb_h
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|path_id
operator|=
name|dev
operator|->
name|path_id
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|target_id
operator|=
name|dev
operator|->
name|target_id
expr_stmt|;
name|ccb
operator|->
name|ccb_h
operator|.
name|target_lun
operator|=
name|dev
operator|->
name|target_lun
expr_stmt|;
block|}
return|return
operator|(
name|ccb
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free a CCB.  */
end_comment

begin_function
name|void
name|cam_freeccb
parameter_list|(
name|union
name|ccb
modifier|*
name|ccb
parameter_list|)
block|{
if|if
condition|(
name|ccb
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|ccb
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Take a device name or path passed in by the user, and attempt to figure  * out the device name and unit number.  Some possible device name formats are:  * /dev/foo0a  * /dev/rfoo0a  * /dev/rfoos2c  * foo0  * foo0a  * rfoo0  * rfoo0a  * nrfoo0  *   * If the caller passes in an old style device name like 'sd' or 'st',  * it will be converted to the new style device name based upon devmatchtable  * above.  *   * Input parameters:  device name/path, length of devname string  * Output:            device name, unit number  * Return values:     returns 0 for success, -1 for failure  */
end_comment

begin_function
name|int
name|cam_get_device
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|char
modifier|*
name|dev_name
parameter_list|,
name|int
name|devnamelen
parameter_list|,
name|int
modifier|*
name|unit
parameter_list|)
block|{
name|char
modifier|*
name|func_name
init|=
literal|"cam_get_device"
decl_stmt|;
name|char
modifier|*
name|tmpstr
decl_stmt|,
modifier|*
name|tmpstr2
decl_stmt|;
name|char
modifier|*
name|newpath
decl_stmt|;
name|int
name|unit_offset
decl_stmt|;
name|int
name|i
decl_stmt|,
name|found
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|cam_errbuf
argument_list|,
literal|"%s: device pathname was NULL"
argument_list|,
name|func_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * We can be rather destructive to the path string.  Make a copy of 	 * it so we don't hose the user's string. 	 */
name|newpath
operator|=
operator|(
name|char
operator|*
operator|)
name|strdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|tmpstr
operator|=
name|newpath
expr_stmt|;
comment|/* Get rid of any leading white space */
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|tmpstr
argument_list|)
operator|&&
operator|(
operator|*
name|tmpstr
operator|!=
literal|'\0'
operator|)
condition|)
name|tmpstr
operator|++
expr_stmt|;
comment|/* 	 * Check to see whether we have an absolute pathname. 	 */
if|if
condition|(
operator|*
name|tmpstr
operator|==
literal|'/'
condition|)
block|{
name|tmpstr2
operator|=
name|tmpstr
expr_stmt|;
name|tmpstr
operator|=
operator|(
name|char
operator|*
operator|)
name|rindex
argument_list|(
name|tmpstr2
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tmpstr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|tmpstr
operator|!=
literal|'\0'
operator|)
condition|)
name|tmpstr
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|tmpstr
operator|==
literal|'\0'
condition|)
block|{
name|sprintf
argument_list|(
name|cam_errbuf
argument_list|,
literal|"%s: no text after slash"
argument_list|,
name|func_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newpath
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Check to see whether the user has given us a nonrewound tape 	 * device. 	 */
if|if
condition|(
operator|*
name|tmpstr
operator|==
literal|'n'
condition|)
name|tmpstr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|tmpstr
operator|==
literal|'\0'
condition|)
block|{
name|sprintf
argument_list|(
name|cam_errbuf
argument_list|,
literal|"%s: no text after leading 'n'"
argument_list|,
name|func_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newpath
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * See if the user has given us a character device. 	 */
if|if
condition|(
operator|*
name|tmpstr
operator|==
literal|'r'
condition|)
name|tmpstr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|tmpstr
operator|==
literal|'\0'
condition|)
block|{
name|sprintf
argument_list|(
name|cam_errbuf
argument_list|,
literal|"%s: no text after leading 'r'"
argument_list|,
name|func_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newpath
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Try to get rid of any trailing white space or partition letters. 	 */
name|tmpstr2
operator|=
operator|&
name|tmpstr
index|[
name|strlen
argument_list|(
name|tmpstr
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|tmpstr2
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
name|tmpstr2
operator|>
name|tmpstr
operator|)
operator|&&
operator|(
operator|!
name|isdigit
argument_list|(
operator|*
name|tmpstr2
argument_list|)
operator|)
condition|)
block|{
operator|*
name|tmpstr2
operator|=
literal|'\0'
expr_stmt|;
name|tmpstr2
operator|--
expr_stmt|;
block|}
comment|/* 	 * Check to see whether we have been given a partition with a slice 	 * name.  If so, get rid of the slice name/number. 	 */
if|if
condition|(
name|strlen
argument_list|(
name|tmpstr
argument_list|)
operator|>
literal|3
condition|)
block|{
comment|/* 		 * Basically, we're looking for a string that ends in the 		 * following general manner:  1s1 -- a number, the letter 		 * s, and then another number.  This indicates that the 		 * user has given us a slice.  We substitute nulls for the 		 * s and the slice number. 		 */
if|if
condition|(
operator|(
name|isdigit
argument_list|(
name|tmpstr
index|[
name|strlen
argument_list|(
name|tmpstr
argument_list|)
operator|-
literal|1
index|]
argument_list|)
operator|)
operator|&&
operator|(
name|tmpstr
index|[
name|strlen
argument_list|(
name|tmpstr
argument_list|)
operator|-
literal|2
index|]
operator|==
literal|'s'
operator|)
operator|&&
operator|(
name|isdigit
argument_list|(
name|tmpstr
index|[
name|strlen
argument_list|(
name|tmpstr
argument_list|)
operator|-
literal|3
index|]
argument_list|)
operator|)
condition|)
block|{
name|tmpstr
index|[
name|strlen
argument_list|(
name|tmpstr
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|tmpstr
index|[
name|strlen
argument_list|(
name|tmpstr
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
comment|/* 	 * After we nuke off the slice, we should have just a device name 	 * and unit number.  That means there must be at least 2 	 * characters.  If we only have 1, we don't have a valid device name. 	 */
if|if
condition|(
name|strlen
argument_list|(
name|tmpstr
argument_list|)
operator|<
literal|2
condition|)
block|{
name|sprintf
argument_list|(
name|cam_errbuf
argument_list|,
literal|"%s: must have both device name and unit number"
argument_list|,
name|func_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newpath
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * If the first character of the string is a digit, then the user 	 * has probably given us all numbers.  Point out the error. 	 */
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|tmpstr
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|cam_errbuf
argument_list|,
literal|"%s: device name cannot begin with a number"
argument_list|,
name|func_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newpath
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * At this point, if the last character of the string isn't a 	 * number, we know the user either didn't give us a device number,  	 * or he gave us a device name/number format we don't recognize. 	 */
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|tmpstr
index|[
name|strlen
argument_list|(
name|tmpstr
argument_list|)
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|cam_errbuf
argument_list|,
literal|"%s: unable to find device unit number"
argument_list|,
name|func_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newpath
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Attempt to figure out where the device name ends and the unit 	 * number begins.  As long as unit_offset is at least 1 less than 	 * the length of the string, we can still potentially have a device 	 * name at the front of the string.  When we get to something that 	 * isn't a digit, we've hit the device name.  Because of the check 	 * above, we know that this cannot happen when unit_offset == 1. 	 * Therefore it is okay to decrement unit_offset -- it won't cause 	 * us to go past the end of the character array. 	 */
for|for
control|(
name|unit_offset
operator|=
literal|1
init|;
operator|(
name|unit_offset
operator|<
operator|(
name|strlen
argument_list|(
name|tmpstr
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|isdigit
argument_list|(
name|tmpstr
index|[
name|strlen
argument_list|(
name|tmpstr
argument_list|)
operator|-
name|unit_offset
index|]
argument_list|)
operator|)
condition|;
name|unit_offset
operator|++
control|)
empty_stmt|;
name|unit_offset
operator|--
expr_stmt|;
comment|/* 	 * Grab the unit number. 	 */
operator|*
name|unit
operator|=
name|atoi
argument_list|(
operator|&
name|tmpstr
index|[
name|strlen
argument_list|(
name|tmpstr
argument_list|)
operator|-
name|unit_offset
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Put a null in place of the first number of the unit number so 	 * that all we have left is the device name. 	 */
name|tmpstr
index|[
name|strlen
argument_list|(
name|tmpstr
argument_list|)
operator|-
name|unit_offset
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * Look through our equivalency table and see if the device name 	 * the user gave us is an old style device name.  If so, translate 	 * it to the new style device name. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|devmatchtable
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|cam_devequiv
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|tmpstr
argument_list|,
name|devmatchtable
index|[
name|i
index|]
operator|.
name|given_dev
argument_list|)
operator|==
literal|0
condition|)
block|{
name|strncpy
argument_list|(
name|dev_name
argument_list|,
name|devmatchtable
index|[
name|i
index|]
operator|.
name|real_dev
argument_list|,
name|devnamelen
argument_list|)
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|found
operator|==
literal|0
condition|)
name|strncpy
argument_list|(
name|dev_name
argument_list|,
name|tmpstr
argument_list|,
name|devnamelen
argument_list|)
expr_stmt|;
comment|/* Make sure we pass back a null-terminated string */
name|dev_name
index|[
name|devnamelen
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Clean up allocated memory */
name|free
argument_list|(
name|newpath
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Backwards compatible wrapper for the real open routine.  This translates  * a pathname into a device name and unit number for use with the real open  * routine.  */
end_comment

begin_function
name|struct
name|cam_device
modifier|*
name|cam_open_device
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|unit
decl_stmt|;
name|char
name|dev_name
index|[
name|DEV_IDLEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/* 	 * cam_get_device() has already put an error message in cam_errbuf, 	 * so we don't need to. 	 */
if|if
condition|(
name|cam_get_device
argument_list|(
name|path
argument_list|,
name|dev_name
argument_list|,
name|DEV_IDLEN
operator|+
literal|1
argument_list|,
operator|&
name|unit
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|cam_lookup_pass
argument_list|(
name|dev_name
argument_list|,
name|unit
argument_list|,
name|flags
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Open the passthrough device for a given bus, target and lun, if the  * passthrough device exists.  */
end_comment

begin_function
name|struct
name|cam_device
modifier|*
name|cam_open_btl
parameter_list|(
name|path_id_t
name|path_id
parameter_list|,
name|target_id_t
name|target_id
parameter_list|,
name|lun_id_t
name|target_lun
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|cam_device
modifier|*
name|device
parameter_list|)
block|{
name|union
name|ccb
name|ccb
decl_stmt|;
name|struct
name|periph_match_pattern
modifier|*
name|match_pat
decl_stmt|;
name|char
modifier|*
name|func_name
init|=
literal|"cam_open_btl"
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|bufsize
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|XPT_DEVICE
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|cam_errbuf
argument_list|,
name|CAM_ERRBUF_SIZE
argument_list|,
literal|"%s: couldn't open %s\n%s: %s"
argument_list|,
name|func_name
argument_list|,
name|XPT_DEVICE
argument_list|,
name|func_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bzero
argument_list|(
operator|&
name|ccb
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
argument_list|)
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_DEV_MATCH
expr_stmt|;
comment|/* Setup the result buffer */
name|bufsize
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dev_match_result
argument_list|)
expr_stmt|;
name|ccb
operator|.
name|cdm
operator|.
name|match_buf_len
operator|=
name|bufsize
expr_stmt|;
name|ccb
operator|.
name|cdm
operator|.
name|matches
operator|=
operator|(
expr|struct
name|dev_match_result
operator|*
operator|)
name|malloc
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|.
name|cdm
operator|.
name|matches
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|cam_errbuf
argument_list|,
name|CAM_ERRBUF_SIZE
argument_list|,
literal|"%s: couldn't malloc match buffer"
argument_list|,
name|func_name
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ccb
operator|.
name|cdm
operator|.
name|num_matches
operator|=
literal|0
expr_stmt|;
comment|/* Setup the pattern buffer */
name|ccb
operator|.
name|cdm
operator|.
name|num_patterns
operator|=
literal|1
expr_stmt|;
name|ccb
operator|.
name|cdm
operator|.
name|pattern_buf_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|dev_match_pattern
argument_list|)
expr_stmt|;
name|ccb
operator|.
name|cdm
operator|.
name|patterns
operator|=
operator|(
expr|struct
name|dev_match_pattern
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dev_match_pattern
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|.
name|cdm
operator|.
name|patterns
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|cam_errbuf
argument_list|,
name|CAM_ERRBUF_SIZE
argument_list|,
literal|"%s: couldn't malloc pattern buffer"
argument_list|,
name|func_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ccb
operator|.
name|cdm
operator|.
name|matches
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ccb
operator|.
name|cdm
operator|.
name|patterns
index|[
literal|0
index|]
operator|.
name|type
operator|=
name|DEV_MATCH_PERIPH
expr_stmt|;
name|match_pat
operator|=
operator|&
name|ccb
operator|.
name|cdm
operator|.
name|patterns
index|[
literal|0
index|]
operator|.
name|pattern
operator|.
name|periph_pattern
expr_stmt|;
comment|/* 	 * We're looking for the passthrough device associated with this 	 * particular bus/target/lun. 	 */
name|sprintf
argument_list|(
name|match_pat
operator|->
name|periph_name
argument_list|,
literal|"pass"
argument_list|)
expr_stmt|;
name|match_pat
operator|->
name|path_id
operator|=
name|path_id
expr_stmt|;
name|match_pat
operator|->
name|target_id
operator|=
name|target_id
expr_stmt|;
name|match_pat
operator|->
name|target_lun
operator|=
name|target_lun
expr_stmt|;
comment|/* Now set the flags to indicate what we're looking for. */
name|match_pat
operator|->
name|flags
operator|=
name|PERIPH_MATCH_PATH
operator||
name|PERIPH_MATCH_TARGET
operator||
name|PERIPH_MATCH_LUN
operator||
name|PERIPH_MATCH_NAME
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|CAMIOCOMMAND
argument_list|,
operator|&
name|ccb
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|cam_errbuf
argument_list|,
literal|"%s: CAMIOCOMMAND ioctl failed\n"
literal|"%s: %s"
argument_list|,
name|func_name
argument_list|,
name|func_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|btl_bailout
goto|;
block|}
comment|/* 	 * Check for an outright error. 	 */
if|if
condition|(
operator|(
name|ccb
operator|.
name|ccb_h
operator|.
name|status
operator|!=
name|CAM_REQ_CMP
operator|)
operator|||
operator|(
operator|(
name|ccb
operator|.
name|cdm
operator|.
name|status
operator|!=
name|CAM_DEV_MATCH_LAST
operator|)
operator|&&
operator|(
name|ccb
operator|.
name|cdm
operator|.
name|status
operator|!=
name|CAM_DEV_MATCH_MORE
operator|)
operator|)
condition|)
block|{
name|sprintf
argument_list|(
name|cam_errbuf
argument_list|,
literal|"%s: CAM error %#x, CDM error %d "
literal|"returned from XPT_DEV_MATCH ccb"
argument_list|,
name|func_name
argument_list|,
name|ccb
operator|.
name|ccb_h
operator|.
name|status
argument_list|,
name|ccb
operator|.
name|cdm
operator|.
name|status
argument_list|)
expr_stmt|;
goto|goto
name|btl_bailout
goto|;
block|}
if|if
condition|(
name|ccb
operator|.
name|cdm
operator|.
name|status
operator|==
name|CAM_DEV_MATCH_MORE
condition|)
block|{
name|sprintf
argument_list|(
name|cam_errbuf
argument_list|,
literal|"%s: CDM reported more than one"
literal|" passthrough device at %d:%d:%d!!\n"
argument_list|,
name|func_name
argument_list|,
name|path_id
argument_list|,
name|target_id
argument_list|,
name|target_lun
argument_list|)
expr_stmt|;
goto|goto
name|btl_bailout
goto|;
block|}
if|if
condition|(
name|ccb
operator|.
name|cdm
operator|.
name|num_matches
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|cam_errbuf
argument_list|,
literal|"%s: no passthrough device found at"
literal|" %d:%d:%d"
argument_list|,
name|func_name
argument_list|,
name|path_id
argument_list|,
name|target_id
argument_list|,
name|target_lun
argument_list|)
expr_stmt|;
goto|goto
name|btl_bailout
goto|;
block|}
switch|switch
condition|(
name|ccb
operator|.
name|cdm
operator|.
name|matches
index|[
literal|0
index|]
operator|.
name|type
condition|)
block|{
case|case
name|DEV_MATCH_PERIPH
case|:
block|{
name|int
name|pass_unit
decl_stmt|;
name|char
name|dev_path
index|[
literal|256
index|]
decl_stmt|;
name|struct
name|periph_match_result
modifier|*
name|periph_result
decl_stmt|;
name|periph_result
operator|=
operator|&
name|ccb
operator|.
name|cdm
operator|.
name|matches
index|[
literal|0
index|]
operator|.
name|result
operator|.
name|periph_result
expr_stmt|;
name|pass_unit
operator|=
name|periph_result
operator|->
name|unit_number
expr_stmt|;
name|free
argument_list|(
name|ccb
operator|.
name|cdm
operator|.
name|matches
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ccb
operator|.
name|cdm
operator|.
name|patterns
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|dev_path
argument_list|,
literal|"/dev/pass%d"
argument_list|,
name|pass_unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|cam_real_open_device
argument_list|(
name|dev_path
argument_list|,
name|flags
argument_list|,
name|device
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
return|;
break|break;
comment|/* NOTREACHED */
block|}
default|default:
name|sprintf
argument_list|(
name|cam_errbuf
argument_list|,
literal|"%s: asked for a peripheral match, but"
literal|" got a bus or device match??!!"
argument_list|,
name|func_name
argument_list|)
expr_stmt|;
goto|goto
name|btl_bailout
goto|;
break|break;
comment|/* NOTREACHED */
block|}
name|btl_bailout
label|:
name|free
argument_list|(
name|ccb
operator|.
name|cdm
operator|.
name|matches
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ccb
operator|.
name|cdm
operator|.
name|patterns
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|cam_device
modifier|*
name|cam_open_spec_device
parameter_list|(
specifier|const
name|char
modifier|*
name|dev_name
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|cam_device
modifier|*
name|device
parameter_list|)
block|{
return|return
operator|(
name|cam_lookup_pass
argument_list|(
name|dev_name
argument_list|,
name|unit
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|,
name|device
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|cam_device
modifier|*
name|cam_open_pass
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|cam_device
modifier|*
name|device
parameter_list|)
block|{
return|return
operator|(
name|cam_real_open_device
argument_list|(
name|path
argument_list|,
name|flags
argument_list|,
name|device
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|cam_device
modifier|*
name|cam_lookup_pass
parameter_list|(
specifier|const
name|char
modifier|*
name|dev_name
parameter_list|,
name|int
name|unit
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|given_path
parameter_list|,
name|struct
name|cam_device
modifier|*
name|device
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|union
name|ccb
name|ccb
decl_stmt|;
name|char
name|dev_path
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|func_name
init|=
literal|"cam_lookup_pass"
decl_stmt|;
comment|/* 	 * The flags argument above only applies to the actual passthrough 	 * device open, not our open of the given device to find the 	 * passthrough device. 	 */
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|XPT_DEVICE
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|cam_errbuf
argument_list|,
name|CAM_ERRBUF_SIZE
argument_list|,
literal|"%s: couldn't open %s\n%s: %s"
argument_list|,
name|func_name
argument_list|,
name|XPT_DEVICE
argument_list|,
name|func_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* This isn't strictly necessary for the GETPASSTHRU ioctl. */
name|ccb
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GDEVLIST
expr_stmt|;
comment|/* These two are necessary for the GETPASSTHRU ioctl to work. */
name|strncpy
argument_list|(
name|ccb
operator|.
name|cgdl
operator|.
name|periph_name
argument_list|,
name|dev_name
argument_list|,
name|DEV_IDLEN
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ccb
operator|.
name|cgdl
operator|.
name|periph_name
index|[
name|DEV_IDLEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ccb
operator|.
name|cgdl
operator|.
name|unit_number
operator|=
name|unit
expr_stmt|;
comment|/* 	 * Attempt to get the passthrough device.  This ioctl will fail if  	 * the device name is null, if the device doesn't exist, or if the 	 * passthrough driver isn't in the kernel. 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|CAMGETPASSTHRU
argument_list|,
operator|&
name|ccb
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|char
name|tmpstr
index|[
literal|256
index|]
decl_stmt|;
comment|/* 		 * If we get ENOENT from the transport layer version of 		 * the CAMGETPASSTHRU ioctl, it means one of two things: 		 * either the device name/unit number passed in doesn't 		 * exist, or the passthrough driver isn't in the kernel. 		 */
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"\n%s: either the pass driver isn't in "
literal|"your kernel\n%s: or %s%d doesn't exist"
argument_list|,
name|func_name
argument_list|,
name|func_name
argument_list|,
name|dev_name
argument_list|,
name|unit
argument_list|)
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|cam_errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|cam_errbuf
argument_list|)
argument_list|,
literal|"%s: CAMGETPASSTHRU ioctl failed\n"
literal|"%s: %s%s"
argument_list|,
name|func_name
argument_list|,
name|func_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
operator|(
name|errno
operator|==
name|ENOENT
operator|)
condition|?
name|tmpstr
else|:
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* 	 * If the ioctl returned the right status, but we got an error back 	 * in the ccb, that means that the kernel found the device the user 	 * passed in, but was unable to find the passthrough device for 	 * the device the user gave us. 	 */
if|if
condition|(
name|ccb
operator|.
name|cgdl
operator|.
name|status
operator|==
name|CAM_GDEVLIST_ERROR
condition|)
block|{
name|sprintf
argument_list|(
name|cam_errbuf
argument_list|,
literal|"%s: device %s%d does not exist"
argument_list|,
name|func_name
argument_list|,
name|dev_name
argument_list|,
name|unit
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|sprintf
argument_list|(
name|dev_path
argument_list|,
literal|"/dev/%s%d"
argument_list|,
name|ccb
operator|.
name|cgdl
operator|.
name|periph_name
argument_list|,
name|ccb
operator|.
name|cgdl
operator|.
name|unit_number
argument_list|)
expr_stmt|;
return|return
operator|(
name|cam_real_open_device
argument_list|(
name|dev_path
argument_list|,
name|flags
argument_list|,
name|device
argument_list|,
name|NULL
argument_list|,
name|dev_name
argument_list|,
name|unit
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Open a given device.  The path argument isn't strictly necessary, but it  * is copied into the cam_device structure as a convenience to the user.  */
end_comment

begin_function
specifier|static
name|struct
name|cam_device
modifier|*
name|cam_real_open_device
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|cam_device
modifier|*
name|device
parameter_list|,
specifier|const
name|char
modifier|*
name|given_path
parameter_list|,
specifier|const
name|char
modifier|*
name|given_dev_name
parameter_list|,
name|int
name|given_unit_number
parameter_list|)
block|{
name|char
name|newpath
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|func_name
init|=
literal|"cam_real_open_device"
decl_stmt|;
name|union
name|ccb
name|ccb
decl_stmt|;
name|int
name|fd
init|=
operator|-
literal|1
decl_stmt|,
name|malloced_device
init|=
literal|0
decl_stmt|;
comment|/* 	 * See if the user wants us to malloc a device for him. 	 */
if|if
condition|(
name|device
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|device
operator|=
operator|(
expr|struct
name|cam_device
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cam_device
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|cam_errbuf
argument_list|,
literal|"%s: device structure malloc"
literal|" failed\n%s: %s"
argument_list|,
name|func_name
argument_list|,
name|func_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|device
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|malloced_device
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * If the user passed in a path, save it for him. 	 */
if|if
condition|(
name|given_path
operator|!=
name|NULL
condition|)
name|strncpy
argument_list|(
name|device
operator|->
name|device_path
argument_list|,
name|given_path
argument_list|,
name|MAXPATHLEN
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|device
operator|->
name|device_path
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * If the user passed in a device name and unit number pair, save 	 * those as well. 	 */
if|if
condition|(
name|given_dev_name
operator|!=
name|NULL
condition|)
name|strncpy
argument_list|(
name|device
operator|->
name|given_dev_name
argument_list|,
name|given_dev_name
argument_list|,
name|DEV_IDLEN
argument_list|)
expr_stmt|;
else|else
name|device
operator|->
name|given_dev_name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|device
operator|->
name|given_unit_number
operator|=
name|given_unit_number
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|path
argument_list|,
name|flags
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|snprintf
argument_list|(
name|cam_errbuf
argument_list|,
name|CAM_ERRBUF_SIZE
argument_list|,
literal|"%s: couldn't open passthrough device %s\n"
literal|"%s: %s"
argument_list|,
name|func_name
argument_list|,
name|path
argument_list|,
name|func_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|crod_bailout
goto|;
block|}
name|device
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|ccb
argument_list|,
sizeof|sizeof
argument_list|(
expr|union
name|ccb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Unlike the transport layer version of the GETPASSTHRU ioctl, 	 * we don't have to set any fields. 	 */
name|ccb
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GDEVLIST
expr_stmt|;
comment|/* 	 * We're only doing this to get some information on the device in 	 * question.  Otherwise, we'd have to pass in yet another 	 * parameter: the passthrough driver unit number. 	 */
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|CAMGETPASSTHRU
argument_list|,
operator|&
name|ccb
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 		 * At this point we know the passthrough device must exist 		 * because we just opened it above.  The only way this 		 * ioctl can fail is if the ccb size is wrong. 		 */
name|sprintf
argument_list|(
name|cam_errbuf
argument_list|,
literal|"%s: CAMGETPASSTHRU ioctl failed\n"
literal|"%s: %s"
argument_list|,
name|func_name
argument_list|,
name|func_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|crod_bailout
goto|;
block|}
comment|/* 	 * If the ioctl returned the right status, but we got an error back 	 * in the ccb, that means that the kernel found the device the user 	 * passed in, but was unable to find the passthrough device for 	 * the device the user gave us. 	 */
if|if
condition|(
name|ccb
operator|.
name|cgdl
operator|.
name|status
operator|==
name|CAM_GDEVLIST_ERROR
condition|)
block|{
name|sprintf
argument_list|(
name|cam_errbuf
argument_list|,
literal|"%s: passthrough device does not exist??!!"
argument_list|,
name|func_name
argument_list|)
expr_stmt|;
goto|goto
name|crod_bailout
goto|;
block|}
name|device
operator|->
name|dev_unit_num
operator|=
name|ccb
operator|.
name|cgdl
operator|.
name|unit_number
expr_stmt|;
name|strcpy
argument_list|(
name|device
operator|->
name|device_name
argument_list|,
name|ccb
operator|.
name|cgdl
operator|.
name|periph_name
argument_list|)
expr_stmt|;
name|device
operator|->
name|path_id
operator|=
name|ccb
operator|.
name|ccb_h
operator|.
name|path_id
expr_stmt|;
name|device
operator|->
name|target_id
operator|=
name|ccb
operator|.
name|ccb_h
operator|.
name|target_id
expr_stmt|;
name|device
operator|->
name|target_lun
operator|=
name|ccb
operator|.
name|ccb_h
operator|.
name|target_lun
expr_stmt|;
name|ccb
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_PATH_INQ
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|CAMIOCOMMAND
argument_list|,
operator|&
name|ccb
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|cam_errbuf
argument_list|,
literal|"%s: Path Inquiry CCB failed\n"
literal|"%s: %s"
argument_list|,
name|func_name
argument_list|,
name|func_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|crod_bailout
goto|;
block|}
name|strncpy
argument_list|(
name|device
operator|->
name|sim_name
argument_list|,
name|ccb
operator|.
name|cpi
operator|.
name|dev_name
argument_list|,
name|SIM_IDLEN
argument_list|)
expr_stmt|;
name|device
operator|->
name|sim_unit_number
operator|=
name|ccb
operator|.
name|cpi
operator|.
name|unit_number
expr_stmt|;
name|device
operator|->
name|bus_id
operator|=
name|ccb
operator|.
name|cpi
operator|.
name|bus_id
expr_stmt|;
comment|/* 	 * It doesn't really matter what is in the payload for a getdev 	 * CCB, the kernel doesn't look at it. 	 */
name|ccb
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GDEV_TYPE
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|CAMIOCOMMAND
argument_list|,
operator|&
name|ccb
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|cam_errbuf
argument_list|,
literal|"%s: Get Device Type CCB failed\n"
literal|"%s: %s"
argument_list|,
name|func_name
argument_list|,
name|func_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|crod_bailout
goto|;
block|}
name|device
operator|->
name|pd_type
operator|=
name|SID_TYPE
argument_list|(
operator|&
name|ccb
operator|.
name|cgd
operator|.
name|inq_data
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ccb
operator|.
name|cgd
operator|.
name|inq_data
argument_list|,
operator|&
name|device
operator|->
name|inq_data
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|scsi_inquiry_data
argument_list|)
argument_list|)
expr_stmt|;
name|device
operator|->
name|serial_num_len
operator|=
name|ccb
operator|.
name|cgd
operator|.
name|serial_num_len
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|ccb
operator|.
name|cgd
operator|.
name|serial_num
argument_list|,
operator|&
name|device
operator|->
name|serial_num
argument_list|,
name|device
operator|->
name|serial_num_len
argument_list|)
expr_stmt|;
comment|/* 	 * Zero the payload, the kernel does look at the flags. 	 */
name|bzero
argument_list|(
operator|&
operator|(
operator|&
name|ccb
operator|.
name|ccb_h
operator|)
index|[
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ccb_trans_settings
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Get transfer settings for this device. 	 */
name|ccb
operator|.
name|ccb_h
operator|.
name|func_code
operator|=
name|XPT_GET_TRAN_SETTINGS
expr_stmt|;
name|ccb
operator|.
name|cts
operator|.
name|flags
operator|=
name|CCB_TRANS_CURRENT_SETTINGS
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|fd
argument_list|,
name|CAMIOCOMMAND
argument_list|,
operator|&
name|ccb
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|cam_errbuf
argument_list|,
literal|"%s: Get Transfer Settings CCB failed\n"
literal|"%s: %s"
argument_list|,
name|func_name
argument_list|,
name|func_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|crod_bailout
goto|;
block|}
name|device
operator|->
name|sync_period
operator|=
name|ccb
operator|.
name|cts
operator|.
name|sync_period
expr_stmt|;
name|device
operator|->
name|sync_offset
operator|=
name|ccb
operator|.
name|cts
operator|.
name|sync_offset
expr_stmt|;
name|device
operator|->
name|bus_width
operator|=
name|ccb
operator|.
name|cts
operator|.
name|bus_width
expr_stmt|;
return|return
operator|(
name|device
operator|)
return|;
name|crod_bailout
label|:
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|malloced_device
condition|)
name|free
argument_list|(
name|device
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cam_close_device
parameter_list|(
name|struct
name|cam_device
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
return|return;
name|cam_close_spec_device
argument_list|(
name|dev
argument_list|)
expr_stmt|;
if|if
condition|(
name|dev
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|dev
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cam_close_spec_device
parameter_list|(
name|struct
name|cam_device
modifier|*
name|dev
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|dev
operator|->
name|fd
operator|>=
literal|0
condition|)
name|close
argument_list|(
name|dev
operator|->
name|fd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|cam_path_string
parameter_list|(
name|struct
name|cam_device
modifier|*
name|dev
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|dev
operator|==
name|NULL
condition|)
block|{
name|snprintf
argument_list|(
name|str
argument_list|,
name|len
argument_list|,
literal|"No path"
argument_list|)
expr_stmt|;
return|return
operator|(
name|str
operator|)
return|;
block|}
name|snprintf
argument_list|(
name|str
argument_list|,
name|len
argument_list|,
literal|"(%s%d:%s%d:%d:%d:%d): "
argument_list|,
operator|(
name|dev
operator|->
name|device_name
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
condition|?
name|dev
operator|->
name|device_name
else|:
literal|"pass"
argument_list|,
name|dev
operator|->
name|dev_unit_num
argument_list|,
operator|(
name|dev
operator|->
name|sim_name
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
condition|?
name|dev
operator|->
name|sim_name
else|:
literal|"unknown"
argument_list|,
name|dev
operator|->
name|sim_unit_number
argument_list|,
name|dev
operator|->
name|bus_id
argument_list|,
name|dev
operator|->
name|target_id
argument_list|,
name|dev
operator|->
name|target_lun
argument_list|)
expr_stmt|;
return|return
operator|(
name|str
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Malloc/duplicate a CAM device structure.  */
end_comment

begin_function
name|struct
name|cam_device
modifier|*
name|cam_device_dup
parameter_list|(
name|struct
name|cam_device
modifier|*
name|device
parameter_list|)
block|{
name|char
modifier|*
name|func_name
init|=
literal|"cam_device_dup"
decl_stmt|;
name|struct
name|cam_device
modifier|*
name|newdev
decl_stmt|;
if|if
condition|(
name|device
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|cam_errbuf
argument_list|,
literal|"%s: device is NULL"
argument_list|,
name|func_name
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|newdev
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cam_device
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|device
argument_list|,
name|newdev
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cam_device
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|newdev
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy a CAM device structure.  */
end_comment

begin_function
name|void
name|cam_device_copy
parameter_list|(
name|struct
name|cam_device
modifier|*
name|src
parameter_list|,
name|struct
name|cam_device
modifier|*
name|dst
parameter_list|)
block|{
name|char
modifier|*
name|func_name
init|=
literal|"cam_device_copy"
decl_stmt|;
if|if
condition|(
name|src
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|cam_errbuf
argument_list|,
literal|"%s: source device struct was NULL"
argument_list|,
name|func_name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|dst
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|cam_errbuf
argument_list|,
literal|"%s: destination device struct was NULL"
argument_list|,
name|func_name
argument_list|)
expr_stmt|;
return|return;
block|}
name|bcopy
argument_list|(
name|src
argument_list|,
name|dst
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|cam_device
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

