begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2016-present, Yann Collet, Facebook, Inc.  * All rights reserved.  *  * This source code is licensed under both the BSD-style license (found in the  * LICENSE file in the root directory of this source tree) and the GPLv2 (found  * in the COPYING file in the root directory of this source tree).  * You may select, at your option, one of the above-listed licenses.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ZSTD_CCOMMON_H_MODULE
end_ifndef

begin_define
define|#
directive|define
name|ZSTD_CCOMMON_H_MODULE
end_define

begin_comment
comment|/*-************************************* *  Dependencies ***************************************/
end_comment

begin_include
include|#
directive|include
file|"compiler.h"
end_include

begin_include
include|#
directive|include
file|"mem.h"
end_include

begin_include
include|#
directive|include
file|"error_private.h"
end_include

begin_define
define|#
directive|define
name|ZSTD_STATIC_LINKING_ONLY
end_define

begin_include
include|#
directive|include
file|"zstd.h"
end_include

begin_define
define|#
directive|define
name|FSE_STATIC_LINKING_ONLY
end_define

begin_include
include|#
directive|include
file|"fse.h"
end_include

begin_define
define|#
directive|define
name|HUF_STATIC_LINKING_ONLY
end_define

begin_include
include|#
directive|include
file|"huf.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|XXH_STATIC_LINKING_ONLY
end_ifndef

begin_define
define|#
directive|define
name|XXH_STATIC_LINKING_ONLY
end_define

begin_comment
comment|/* XXH64_state_t */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"xxhash.h"
end_include

begin_comment
comment|/* XXH_reset, update, digest */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/*-************************************* *  Debug ***************************************/
if|#
directive|if
name|defined
argument_list|(
name|ZSTD_DEBUG
argument_list|)
operator|&&
operator|(
name|ZSTD_DEBUG
operator|>=
literal|1
operator|)
include|#
directive|include
file|<assert.h>
else|#
directive|else
ifndef|#
directive|ifndef
name|assert
define|#
directive|define
name|assert
parameter_list|(
name|condition
parameter_list|)
value|((void)0)
endif|#
directive|endif
endif|#
directive|endif
define|#
directive|define
name|ZSTD_STATIC_ASSERT
parameter_list|(
name|c
parameter_list|)
value|{ enum { ZSTD_static_assert = 1/(int)(!!(c)) }; }
if|#
directive|if
name|defined
argument_list|(
name|ZSTD_DEBUG
argument_list|)
operator|&&
operator|(
name|ZSTD_DEBUG
operator|>=
literal|2
operator|)
include|#
directive|include
file|<stdio.h>
comment|/* recommended values for ZSTD_DEBUG display levels :  * 1 : no display, enables assert() only  * 2 : reserved for currently active debugging path  * 3 : events once per object lifetime (CCtx, CDict)  * 4 : events once per frame  * 5 : events once per block  * 6 : events once per sequence (*very* verbose) */
define|#
directive|define
name|DEBUGLOG
parameter_list|(
name|l
parameter_list|,
modifier|...
parameter_list|)
value|{                         \                 if (l<=ZSTD_DEBUG) {                 \                     fprintf(stderr, __FILE__ ": ");  \                     fprintf(stderr, __VA_ARGS__);    \                     fprintf(stderr, " \n");          \             }   }
else|#
directive|else
define|#
directive|define
name|DEBUGLOG
parameter_list|(
name|l
parameter_list|,
modifier|...
parameter_list|)
value|{}
comment|/* disabled */
endif|#
directive|endif
comment|/*-************************************* *  shared macros ***************************************/
undef|#
directive|undef
name|MIN
undef|#
directive|undef
name|MAX
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)<(b) ? (a) : (b))
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)>(b) ? (a) : (b))
define|#
directive|define
name|CHECK_F
parameter_list|(
name|f
parameter_list|)
value|{ size_t const errcod = f; if (ERR_isError(errcod)) return errcod; }
comment|/* check and Forward error code */
define|#
directive|define
name|CHECK_E
parameter_list|(
name|f
parameter_list|,
name|e
parameter_list|)
value|{ size_t const errcod = f; if (ERR_isError(errcod)) return ERROR(e); }
comment|/* check and send Error code */
comment|/*-************************************* *  Common constants ***************************************/
define|#
directive|define
name|ZSTD_OPT_NUM
value|(1<<12)
define|#
directive|define
name|ZSTD_REP_NUM
value|3
comment|/* number of repcodes */
define|#
directive|define
name|ZSTD_REP_CHECK
value|(ZSTD_REP_NUM)
comment|/* number of repcodes to check by the optimal parser */
define|#
directive|define
name|ZSTD_REP_MOVE
value|(ZSTD_REP_NUM-1)
define|#
directive|define
name|ZSTD_REP_MOVE_OPT
value|(ZSTD_REP_NUM)
specifier|static
specifier|const
name|U32
name|repStartValue
index|[
name|ZSTD_REP_NUM
index|]
init|=
block|{
literal|1
block|,
literal|4
block|,
literal|8
block|}
decl_stmt|;
define|#
directive|define
name|KB
value|*(1<<10)
define|#
directive|define
name|MB
value|*(1<<20)
define|#
directive|define
name|GB
value|*(1U<<30)
define|#
directive|define
name|BIT7
value|128
define|#
directive|define
name|BIT6
value|64
define|#
directive|define
name|BIT5
value|32
define|#
directive|define
name|BIT4
value|16
define|#
directive|define
name|BIT1
value|2
define|#
directive|define
name|BIT0
value|1
define|#
directive|define
name|ZSTD_WINDOWLOG_ABSOLUTEMIN
value|10
define|#
directive|define
name|ZSTD_WINDOWLOG_DEFAULTMAX
value|27
comment|/* Default maximum allowed window log */
specifier|static
specifier|const
name|size_t
name|ZSTD_fcs_fieldSize
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|2
block|,
literal|4
block|,
literal|8
block|}
decl_stmt|;
specifier|static
specifier|const
name|size_t
name|ZSTD_did_fieldSize
index|[
literal|4
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|4
block|}
decl_stmt|;
define|#
directive|define
name|ZSTD_FRAMEIDSIZE
value|4
specifier|static
specifier|const
name|size_t
name|ZSTD_frameIdSize
init|=
name|ZSTD_FRAMEIDSIZE
decl_stmt|;
comment|/* magic number size */
define|#
directive|define
name|ZSTD_BLOCKHEADERSIZE
value|3
comment|/* C standard doesn't allow `static const` variable to be init using another `static const` variable */
specifier|static
specifier|const
name|size_t
name|ZSTD_blockHeaderSize
init|=
name|ZSTD_BLOCKHEADERSIZE
decl_stmt|;
typedef|typedef
enum|enum
block|{
name|bt_raw
block|,
name|bt_rle
block|,
name|bt_compressed
block|,
name|bt_reserved
block|}
name|blockType_e
typedef|;
define|#
directive|define
name|MIN_SEQUENCES_SIZE
value|1
comment|/* nbSeq==0 */
define|#
directive|define
name|MIN_CBLOCK_SIZE
value|(1
comment|/*litCSize*/
value|+ 1
comment|/* RLE or RAW */
value|+ MIN_SEQUENCES_SIZE
comment|/* nbSeq==0 */
value|)
comment|/* for a non-null block */
define|#
directive|define
name|HufLog
value|12
typedef|typedef
enum|enum
block|{
name|set_basic
block|,
name|set_rle
block|,
name|set_compressed
block|,
name|set_repeat
block|}
name|symbolEncodingType_e
typedef|;
define|#
directive|define
name|LONGNBSEQ
value|0x7F00
define|#
directive|define
name|MINMATCH
value|3
define|#
directive|define
name|Litbits
value|8
define|#
directive|define
name|MaxLit
value|((1<<Litbits) - 1)
define|#
directive|define
name|MaxML
value|52
define|#
directive|define
name|MaxLL
value|35
define|#
directive|define
name|DefaultMaxOff
value|28
define|#
directive|define
name|MaxOff
value|31
define|#
directive|define
name|MaxSeq
value|MAX(MaxLL, MaxML)
comment|/* Assumption : MaxOff< MaxLL,MaxML */
define|#
directive|define
name|MLFSELog
value|9
define|#
directive|define
name|LLFSELog
value|9
define|#
directive|define
name|OffFSELog
value|8
specifier|static
specifier|const
name|U32
name|LL_bits
index|[
name|MaxLL
operator|+
literal|1
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|}
decl_stmt|;
specifier|static
specifier|const
name|S16
name|LL_defaultNorm
index|[
name|MaxLL
operator|+
literal|1
index|]
init|=
block|{
literal|4
block|,
literal|3
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
define|#
directive|define
name|LL_DEFAULTNORMLOG
value|6
comment|/* for static allocation */
specifier|static
specifier|const
name|U32
name|LL_defaultNormLog
init|=
name|LL_DEFAULTNORMLOG
decl_stmt|;
specifier|static
specifier|const
name|U32
name|ML_bits
index|[
name|MaxML
operator|+
literal|1
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|}
decl_stmt|;
specifier|static
specifier|const
name|S16
name|ML_defaultNorm
index|[
name|MaxML
operator|+
literal|1
index|]
init|=
block|{
literal|1
block|,
literal|4
block|,
literal|3
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
define|#
directive|define
name|ML_DEFAULTNORMLOG
value|6
comment|/* for static allocation */
specifier|static
specifier|const
name|U32
name|ML_defaultNormLog
init|=
name|ML_DEFAULTNORMLOG
decl_stmt|;
specifier|static
specifier|const
name|S16
name|OF_defaultNorm
index|[
name|DefaultMaxOff
operator|+
literal|1
index|]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|}
decl_stmt|;
define|#
directive|define
name|OF_DEFAULTNORMLOG
value|5
comment|/* for static allocation */
specifier|static
specifier|const
name|U32
name|OF_defaultNormLog
init|=
name|OF_DEFAULTNORMLOG
decl_stmt|;
comment|/*-******************************************* *  Shared functions to include for inlining *********************************************/
specifier|static
name|void
name|ZSTD_copy8
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|)
block|{
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
literal|8
argument_list|)
expr_stmt|;
block|}
define|#
directive|define
name|COPY8
parameter_list|(
name|d
parameter_list|,
name|s
parameter_list|)
value|{ ZSTD_copy8(d,s); d+=8; s+=8; }
comment|/*! ZSTD_wildcopy() : *   custom version of memcpy(), can copy up to 7 bytes too many (8 bytes if length==0) */
define|#
directive|define
name|WILDCOPY_OVERLENGTH
value|8
name|MEM_STATIC
name|void
name|ZSTD_wildcopy
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|ptrdiff_t
name|length
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
decl_stmt|;
name|BYTE
modifier|*
name|op
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oend
init|=
name|op
operator|+
name|length
decl_stmt|;
do|do
name|COPY8
argument_list|(
argument|op
argument_list|,
argument|ip
argument_list|)
while|while
condition|(
name|op
operator|<
name|oend
condition|)
empty_stmt|;
do|}
name|MEM_STATIC
name|void
name|ZSTD_wildcopy_e
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|void
modifier|*
name|dstEnd
parameter_list|)
comment|/* should be faster for decoding, but strangely, not verified on all platform */
block|{
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
decl_stmt|;
name|BYTE
modifier|*
name|op
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dst
decl_stmt|;
name|BYTE
modifier|*
specifier|const
name|oend
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dstEnd
decl_stmt|;
do|do
name|COPY8
argument_list|(
argument|op
argument_list|,
argument|ip
argument_list|)
while|while
condition|(
name|op
operator|<
name|oend
condition|)
empty_stmt|;
do|}
comment|/*-******************************************* *  Private interfaces *********************************************/
typedef|typedef
name|struct
name|ZSTD_stats_s
name|ZSTD_stats_t
typedef|;
typedef|typedef
struct|struct
name|seqDef_s
block|{
name|U32
name|offset
decl_stmt|;
name|U16
name|litLength
decl_stmt|;
name|U16
name|matchLength
decl_stmt|;
block|}
name|seqDef
typedef|;
typedef|typedef
struct|struct
block|{
name|seqDef
modifier|*
name|sequencesStart
decl_stmt|;
name|seqDef
modifier|*
name|sequences
decl_stmt|;
name|BYTE
modifier|*
name|litStart
decl_stmt|;
name|BYTE
modifier|*
name|lit
decl_stmt|;
name|BYTE
modifier|*
name|llCode
decl_stmt|;
name|BYTE
modifier|*
name|mlCode
decl_stmt|;
name|BYTE
modifier|*
name|ofCode
decl_stmt|;
name|U32
name|longLengthID
decl_stmt|;
comment|/* 0 == no longLength; 1 == Lit.longLength; 2 == Match.longLength; */
name|U32
name|longLengthPos
decl_stmt|;
name|U32
name|rep
index|[
name|ZSTD_REP_NUM
index|]
decl_stmt|;
name|U32
name|repToConfirm
index|[
name|ZSTD_REP_NUM
index|]
decl_stmt|;
block|}
name|seqStore_t
typedef|;
typedef|typedef
struct|struct
block|{
name|U32
name|off
decl_stmt|;
name|U32
name|len
decl_stmt|;
block|}
name|ZSTD_match_t
typedef|;
typedef|typedef
struct|struct
block|{
name|U32
name|price
decl_stmt|;
name|U32
name|off
decl_stmt|;
name|U32
name|mlen
decl_stmt|;
name|U32
name|litlen
decl_stmt|;
name|U32
name|rep
index|[
name|ZSTD_REP_NUM
index|]
decl_stmt|;
block|}
name|ZSTD_optimal_t
typedef|;
typedef|typedef
struct|struct
block|{
name|U32
modifier|*
name|litFreq
decl_stmt|;
name|U32
modifier|*
name|litLengthFreq
decl_stmt|;
name|U32
modifier|*
name|matchLengthFreq
decl_stmt|;
name|U32
modifier|*
name|offCodeFreq
decl_stmt|;
name|ZSTD_match_t
modifier|*
name|matchTable
decl_stmt|;
name|ZSTD_optimal_t
modifier|*
name|priceTable
decl_stmt|;
name|U32
name|matchLengthSum
decl_stmt|;
name|U32
name|matchSum
decl_stmt|;
name|U32
name|litLengthSum
decl_stmt|;
name|U32
name|litSum
decl_stmt|;
name|U32
name|offCodeSum
decl_stmt|;
name|U32
name|log2matchLengthSum
decl_stmt|;
name|U32
name|log2matchSum
decl_stmt|;
name|U32
name|log2litLengthSum
decl_stmt|;
name|U32
name|log2litSum
decl_stmt|;
name|U32
name|log2offCodeSum
decl_stmt|;
name|U32
name|factor
decl_stmt|;
name|U32
name|staticPrices
decl_stmt|;
name|U32
name|cachedPrice
decl_stmt|;
name|U32
name|cachedLitLength
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|cachedLiterals
decl_stmt|;
block|}
name|optState_t
typedef|;
typedef|typedef
struct|struct
block|{
name|U32
name|offset
decl_stmt|;
name|U32
name|checksum
decl_stmt|;
block|}
name|ldmEntry_t
typedef|;
typedef|typedef
struct|struct
block|{
name|ldmEntry_t
modifier|*
name|hashTable
decl_stmt|;
name|BYTE
modifier|*
name|bucketOffsets
decl_stmt|;
comment|/* Next position in bucket to insert entry */
name|U64
name|hashPower
decl_stmt|;
comment|/* Used to compute the rolling hash.                              * Depends on ldmParams.minMatchLength */
block|}
name|ldmState_t
typedef|;
typedef|typedef
struct|struct
block|{
name|U32
name|enableLdm
decl_stmt|;
comment|/* 1 if enable long distance matching */
name|U32
name|hashLog
decl_stmt|;
comment|/* Log size of hashTable */
name|U32
name|bucketSizeLog
decl_stmt|;
comment|/* Log bucket size for collision resolution, at most 8 */
name|U32
name|minMatchLength
decl_stmt|;
comment|/* Minimum match length */
name|U32
name|hashEveryLog
decl_stmt|;
comment|/* Log number of entries to skip */
block|}
name|ldmParams_t
typedef|;
typedef|typedef
struct|struct
block|{
name|U32
name|hufCTable
index|[
name|HUF_CTABLE_SIZE_U32
argument_list|(
literal|255
argument_list|)
index|]
decl_stmt|;
name|FSE_CTable
name|offcodeCTable
index|[
name|FSE_CTABLE_SIZE_U32
argument_list|(
name|OffFSELog
argument_list|,
name|MaxOff
argument_list|)
index|]
decl_stmt|;
name|FSE_CTable
name|matchlengthCTable
index|[
name|FSE_CTABLE_SIZE_U32
argument_list|(
name|MLFSELog
argument_list|,
name|MaxML
argument_list|)
index|]
decl_stmt|;
name|FSE_CTable
name|litlengthCTable
index|[
name|FSE_CTABLE_SIZE_U32
argument_list|(
name|LLFSELog
argument_list|,
name|MaxLL
argument_list|)
index|]
decl_stmt|;
name|U32
name|workspace
index|[
name|HUF_WORKSPACE_SIZE_U32
index|]
decl_stmt|;
name|HUF_repeat
name|hufCTable_repeatMode
decl_stmt|;
name|FSE_repeat
name|offcode_repeatMode
decl_stmt|;
name|FSE_repeat
name|matchlength_repeatMode
decl_stmt|;
name|FSE_repeat
name|litlength_repeatMode
decl_stmt|;
block|}
name|ZSTD_entropyCTables_t
typedef|;
struct|struct
name|ZSTD_CCtx_params_s
block|{
name|ZSTD_format_e
name|format
decl_stmt|;
name|ZSTD_compressionParameters
name|cParams
decl_stmt|;
name|ZSTD_frameParameters
name|fParams
decl_stmt|;
name|int
name|compressionLevel
decl_stmt|;
name|U32
name|forceWindow
decl_stmt|;
comment|/* force back-references to respect limit of                                 * 1<<wLog, even for dictionary */
comment|/* Multithreading: used to pass parameters to mtctx */
name|U32
name|nbThreads
decl_stmt|;
name|unsigned
name|jobSize
decl_stmt|;
name|unsigned
name|overlapSizeLog
decl_stmt|;
comment|/* Long distance matching parameters */
name|ldmParams_t
name|ldmParams
decl_stmt|;
comment|/* For use with createCCtxParams() and freeCCtxParams() only */
name|ZSTD_customMem
name|customMem
decl_stmt|;
block|}
struct|;
comment|/* typedef'd to ZSTD_CCtx_params within "zstd.h" */
specifier|const
name|seqStore_t
modifier|*
name|ZSTD_getSeqStore
argument_list|(
specifier|const
name|ZSTD_CCtx
operator|*
name|ctx
argument_list|)
decl_stmt|;
name|void
name|ZSTD_seqToCodes
argument_list|(
specifier|const
name|seqStore_t
operator|*
name|seqStorePtr
argument_list|)
decl_stmt|;
comment|/* custom memory allocation functions */
name|void
modifier|*
name|ZSTD_malloc
argument_list|(
name|size_t
name|size
argument_list|,
name|ZSTD_customMem
name|customMem
argument_list|)
decl_stmt|;
name|void
modifier|*
name|ZSTD_calloc
argument_list|(
name|size_t
name|size
argument_list|,
name|ZSTD_customMem
name|customMem
argument_list|)
decl_stmt|;
name|void
name|ZSTD_free
argument_list|(
name|void
operator|*
name|ptr
argument_list|,
name|ZSTD_customMem
name|customMem
argument_list|)
decl_stmt|;
comment|/*======  common function  ======*/
name|MEM_STATIC
name|U32
name|ZSTD_highbit32
parameter_list|(
name|U32
name|val
parameter_list|)
block|{
name|assert
argument_list|(
name|val
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|{
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
comment|/* Visual */
name|unsigned
name|long
name|r
init|=
literal|0
decl_stmt|;
name|_BitScanReverse
argument_list|(
operator|&
name|r
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|unsigned
operator|)
name|r
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|__GNUC__
operator|>=
literal|3
operator|)
comment|/* GCC Intrinsic */
return|return
literal|31
operator|-
name|__builtin_clz
argument_list|(
name|val
argument_list|)
return|;
else|#
directive|else
comment|/* Software version */
specifier|static
specifier|const
name|int
name|DeBruijnClz
index|[
literal|32
index|]
init|=
block|{
literal|0
block|,
literal|9
block|,
literal|1
block|,
literal|10
block|,
literal|13
block|,
literal|21
block|,
literal|2
block|,
literal|29
block|,
literal|11
block|,
literal|14
block|,
literal|16
block|,
literal|18
block|,
literal|22
block|,
literal|25
block|,
literal|3
block|,
literal|30
block|,
literal|8
block|,
literal|12
block|,
literal|20
block|,
literal|28
block|,
literal|15
block|,
literal|17
block|,
literal|24
block|,
literal|7
block|,
literal|19
block|,
literal|27
block|,
literal|23
block|,
literal|6
block|,
literal|26
block|,
literal|5
block|,
literal|4
block|,
literal|31
block|}
decl_stmt|;
name|U32
name|v
init|=
name|val
decl_stmt|;
name|int
name|r
decl_stmt|;
name|v
operator||=
name|v
operator|>>
literal|1
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|2
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|4
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|8
expr_stmt|;
name|v
operator||=
name|v
operator|>>
literal|16
expr_stmt|;
name|r
operator|=
name|DeBruijnClz
index|[
call|(
name|U32
call|)
argument_list|(
name|v
operator|*
literal|0x07C4ACDDU
argument_list|)
operator|>>
literal|27
index|]
expr_stmt|;
return|return
name|r
return|;
endif|#
directive|endif
block|}
block|}
comment|/* hidden functions */
comment|/* ZSTD_invalidateRepCodes() :  * ensures next compression will not use repcodes from previous block.  * Note : only works with regular variant;  *        do not use with extDict variant ! */
name|void
name|ZSTD_invalidateRepCodes
argument_list|(
name|ZSTD_CCtx
operator|*
name|cctx
argument_list|)
decl_stmt|;
comment|/*! ZSTD_initCStream_internal() :  *  Private use only. Init streaming operation.  *  expects params to be valid.  *  must receive dict, or cdict, or none, but not both.  *  @return : 0, or an error code */
name|size_t
name|ZSTD_initCStream_internal
argument_list|(
name|ZSTD_CStream
operator|*
name|zcs
argument_list|,
specifier|const
name|void
operator|*
name|dict
argument_list|,
name|size_t
name|dictSize
argument_list|,
specifier|const
name|ZSTD_CDict
operator|*
name|cdict
argument_list|,
name|ZSTD_CCtx_params
name|params
argument_list|,
name|unsigned
name|long
name|long
name|pledgedSrcSize
argument_list|)
decl_stmt|;
comment|/*! ZSTD_compressStream_generic() :  *  Private use only. To be called from zstdmt_compress.c in single-thread mode. */
name|size_t
name|ZSTD_compressStream_generic
argument_list|(
name|ZSTD_CStream
operator|*
name|zcs
argument_list|,
name|ZSTD_outBuffer
operator|*
name|output
argument_list|,
name|ZSTD_inBuffer
operator|*
name|input
argument_list|,
name|ZSTD_EndDirective
specifier|const
name|flushMode
argument_list|)
decl_stmt|;
comment|/*! ZSTD_getCParamsFromCDict() :  *  as the name implies */
name|ZSTD_compressionParameters
name|ZSTD_getCParamsFromCDict
argument_list|(
specifier|const
name|ZSTD_CDict
operator|*
name|cdict
argument_list|)
decl_stmt|;
comment|/* ZSTD_compressBegin_advanced_internal() :  * Private use only. To be called from zstdmt_compress.c. */
name|size_t
name|ZSTD_compressBegin_advanced_internal
argument_list|(
name|ZSTD_CCtx
operator|*
name|cctx
argument_list|,
specifier|const
name|void
operator|*
name|dict
argument_list|,
name|size_t
name|dictSize
argument_list|,
name|ZSTD_dictMode_e
name|dictMode
argument_list|,
name|ZSTD_CCtx_params
name|params
argument_list|,
name|unsigned
name|long
name|long
name|pledgedSrcSize
argument_list|)
decl_stmt|;
comment|/* ZSTD_compress_advanced_internal() :  * Private use only. To be called from zstdmt_compress.c. */
name|size_t
name|ZSTD_compress_advanced_internal
argument_list|(
name|ZSTD_CCtx
operator|*
name|cctx
argument_list|,
name|void
operator|*
name|dst
argument_list|,
name|size_t
name|dstCapacity
argument_list|,
specifier|const
name|void
operator|*
name|src
argument_list|,
name|size_t
name|srcSize
argument_list|,
specifier|const
name|void
operator|*
name|dict
argument_list|,
name|size_t
name|dictSize
argument_list|,
name|ZSTD_CCtx_params
name|params
argument_list|)
decl_stmt|;
typedef|typedef
struct|struct
block|{
name|blockType_e
name|blockType
decl_stmt|;
name|U32
name|lastBlock
decl_stmt|;
name|U32
name|origSize
decl_stmt|;
block|}
name|blockProperties_t
typedef|;
comment|/*! ZSTD_getcBlockSize() : *   Provides the size of compressed block from block header `src` */
name|size_t
name|ZSTD_getcBlockSize
argument_list|(
specifier|const
name|void
operator|*
name|src
argument_list|,
name|size_t
name|srcSize
argument_list|,
name|blockProperties_t
operator|*
name|bpPtr
argument_list|)
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__cplusplus
argument_list|)
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ZSTD_CCOMMON_H_MODULE */
end_comment

end_unit

