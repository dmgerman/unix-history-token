begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*    Common functions of New Generation Entropy library    Copyright (C) 2016, Yann Collet.     BSD 2-Clause License (http://www.opensource.org/licenses/bsd-license.php)     Redistribution and use in source and binary forms, with or without    modification, are permitted provided that the following conditions are    met:         * Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer.        * Redistributions in binary form must reproduce the above    copyright notice, this list of conditions and the following disclaimer    in the documentation and/or other materials provided with the    distribution.     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT    OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.      You can contact the author at :     - FSE+HUF source repository : https://github.com/Cyan4973/FiniteStateEntropy     - Public forum : https://groups.google.com/forum/#!forum/lz4c *************************************************************************** */
end_comment

begin_comment
comment|/* ************************************* *  Dependencies ***************************************/
end_comment

begin_include
include|#
directive|include
file|"mem.h"
end_include

begin_include
include|#
directive|include
file|"error_private.h"
end_include

begin_comment
comment|/* ERR_*, ERROR */
end_comment

begin_define
define|#
directive|define
name|FSE_STATIC_LINKING_ONLY
end_define

begin_comment
comment|/* FSE_MIN_TABLELOG */
end_comment

begin_include
include|#
directive|include
file|"fse.h"
end_include

begin_define
define|#
directive|define
name|HUF_STATIC_LINKING_ONLY
end_define

begin_comment
comment|/* HUF_TABLELOG_ABSOLUTEMAX */
end_comment

begin_include
include|#
directive|include
file|"huf.h"
end_include

begin_comment
comment|/*===   Version   ===*/
end_comment

begin_function
name|unsigned
name|FSE_versionNumber
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|FSE_VERSION_NUMBER
return|;
block|}
end_function

begin_comment
comment|/*===   Error Management   ===*/
end_comment

begin_function
name|unsigned
name|FSE_isError
parameter_list|(
name|size_t
name|code
parameter_list|)
block|{
return|return
name|ERR_isError
argument_list|(
name|code
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|FSE_getErrorName
parameter_list|(
name|size_t
name|code
parameter_list|)
block|{
return|return
name|ERR_getErrorName
argument_list|(
name|code
argument_list|)
return|;
block|}
end_function

begin_function
name|unsigned
name|HUF_isError
parameter_list|(
name|size_t
name|code
parameter_list|)
block|{
return|return
name|ERR_isError
argument_list|(
name|code
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|HUF_getErrorName
parameter_list|(
name|size_t
name|code
parameter_list|)
block|{
return|return
name|ERR_getErrorName
argument_list|(
name|code
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*-************************************************************** *  FSE NCount encoding-decoding ****************************************************************/
end_comment

begin_function
name|size_t
name|FSE_readNCount
parameter_list|(
name|short
modifier|*
name|normalizedCounter
parameter_list|,
name|unsigned
modifier|*
name|maxSVPtr
parameter_list|,
name|unsigned
modifier|*
name|tableLogPtr
parameter_list|,
specifier|const
name|void
modifier|*
name|headerBuffer
parameter_list|,
name|size_t
name|hbSize
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|istart
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|headerBuffer
decl_stmt|;
specifier|const
name|BYTE
modifier|*
specifier|const
name|iend
init|=
name|istart
operator|+
name|hbSize
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|ip
init|=
name|istart
decl_stmt|;
name|int
name|nbBits
decl_stmt|;
name|int
name|remaining
decl_stmt|;
name|int
name|threshold
decl_stmt|;
name|U32
name|bitStream
decl_stmt|;
name|int
name|bitCount
decl_stmt|;
name|unsigned
name|charnum
init|=
literal|0
decl_stmt|;
name|int
name|previous0
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|hbSize
operator|<
literal|4
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|bitStream
operator|=
name|MEM_readLE32
argument_list|(
name|ip
argument_list|)
expr_stmt|;
name|nbBits
operator|=
operator|(
name|bitStream
operator|&
literal|0xF
operator|)
operator|+
name|FSE_MIN_TABLELOG
expr_stmt|;
comment|/* extract tableLog */
if|if
condition|(
name|nbBits
operator|>
name|FSE_TABLELOG_ABSOLUTE_MAX
condition|)
return|return
name|ERROR
argument_list|(
name|tableLog_tooLarge
argument_list|)
return|;
name|bitStream
operator|>>=
literal|4
expr_stmt|;
name|bitCount
operator|=
literal|4
expr_stmt|;
operator|*
name|tableLogPtr
operator|=
name|nbBits
expr_stmt|;
name|remaining
operator|=
operator|(
literal|1
operator|<<
name|nbBits
operator|)
operator|+
literal|1
expr_stmt|;
name|threshold
operator|=
literal|1
operator|<<
name|nbBits
expr_stmt|;
name|nbBits
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|remaining
operator|>
literal|1
operator|)
operator|&
operator|(
name|charnum
operator|<=
operator|*
name|maxSVPtr
operator|)
condition|)
block|{
if|if
condition|(
name|previous0
condition|)
block|{
name|unsigned
name|n0
init|=
name|charnum
decl_stmt|;
while|while
condition|(
operator|(
name|bitStream
operator|&
literal|0xFFFF
operator|)
operator|==
literal|0xFFFF
condition|)
block|{
name|n0
operator|+=
literal|24
expr_stmt|;
if|if
condition|(
name|ip
operator|<
name|iend
operator|-
literal|5
condition|)
block|{
name|ip
operator|+=
literal|2
expr_stmt|;
name|bitStream
operator|=
name|MEM_readLE32
argument_list|(
name|ip
argument_list|)
operator|>>
name|bitCount
expr_stmt|;
block|}
else|else
block|{
name|bitStream
operator|>>=
literal|16
expr_stmt|;
name|bitCount
operator|+=
literal|16
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|(
name|bitStream
operator|&
literal|3
operator|)
operator|==
literal|3
condition|)
block|{
name|n0
operator|+=
literal|3
expr_stmt|;
name|bitStream
operator|>>=
literal|2
expr_stmt|;
name|bitCount
operator|+=
literal|2
expr_stmt|;
block|}
name|n0
operator|+=
name|bitStream
operator|&
literal|3
expr_stmt|;
name|bitCount
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|n0
operator|>
operator|*
name|maxSVPtr
condition|)
return|return
name|ERROR
argument_list|(
name|maxSymbolValue_tooSmall
argument_list|)
return|;
while|while
condition|(
name|charnum
operator|<
name|n0
condition|)
name|normalizedCounter
index|[
name|charnum
operator|++
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ip
operator|<=
name|iend
operator|-
literal|7
operator|)
operator|||
operator|(
name|ip
operator|+
operator|(
name|bitCount
operator|>>
literal|3
operator|)
operator|<=
name|iend
operator|-
literal|4
operator|)
condition|)
block|{
name|ip
operator|+=
name|bitCount
operator|>>
literal|3
expr_stmt|;
name|bitCount
operator|&=
literal|7
expr_stmt|;
name|bitStream
operator|=
name|MEM_readLE32
argument_list|(
name|ip
argument_list|)
operator|>>
name|bitCount
expr_stmt|;
block|}
else|else
block|{
name|bitStream
operator|>>=
literal|2
expr_stmt|;
block|}
block|}
block|{
name|int
specifier|const
name|max
init|=
operator|(
literal|2
operator|*
name|threshold
operator|-
literal|1
operator|)
operator|-
name|remaining
decl_stmt|;
name|int
name|count
decl_stmt|;
if|if
condition|(
operator|(
name|bitStream
operator|&
operator|(
name|threshold
operator|-
literal|1
operator|)
operator|)
operator|<
operator|(
name|U32
operator|)
name|max
condition|)
block|{
name|count
operator|=
name|bitStream
operator|&
operator|(
name|threshold
operator|-
literal|1
operator|)
expr_stmt|;
name|bitCount
operator|+=
name|nbBits
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|count
operator|=
name|bitStream
operator|&
operator|(
literal|2
operator|*
name|threshold
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|count
operator|>=
name|threshold
condition|)
name|count
operator|-=
name|max
expr_stmt|;
name|bitCount
operator|+=
name|nbBits
expr_stmt|;
block|}
name|count
operator|--
expr_stmt|;
comment|/* extra accuracy */
name|remaining
operator|-=
name|count
operator|<
literal|0
condition|?
operator|-
name|count
else|:
name|count
expr_stmt|;
comment|/* -1 means +1 */
name|normalizedCounter
index|[
name|charnum
operator|++
index|]
operator|=
operator|(
name|short
operator|)
name|count
expr_stmt|;
name|previous0
operator|=
operator|!
name|count
expr_stmt|;
while|while
condition|(
name|remaining
operator|<
name|threshold
condition|)
block|{
name|nbBits
operator|--
expr_stmt|;
name|threshold
operator|>>=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ip
operator|<=
name|iend
operator|-
literal|7
operator|)
operator|||
operator|(
name|ip
operator|+
operator|(
name|bitCount
operator|>>
literal|3
operator|)
operator|<=
name|iend
operator|-
literal|4
operator|)
condition|)
block|{
name|ip
operator|+=
name|bitCount
operator|>>
literal|3
expr_stmt|;
name|bitCount
operator|&=
literal|7
expr_stmt|;
block|}
else|else
block|{
name|bitCount
operator|-=
call|(
name|int
call|)
argument_list|(
literal|8
operator|*
operator|(
name|iend
operator|-
literal|4
operator|-
name|ip
operator|)
argument_list|)
expr_stmt|;
name|ip
operator|=
name|iend
operator|-
literal|4
expr_stmt|;
block|}
name|bitStream
operator|=
name|MEM_readLE32
argument_list|(
name|ip
argument_list|)
operator|>>
operator|(
name|bitCount
operator|&
literal|31
operator|)
expr_stmt|;
block|}
block|}
comment|/* while ((remaining>1)& (charnum<=*maxSVPtr)) */
if|if
condition|(
name|remaining
operator|!=
literal|1
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
if|if
condition|(
name|bitCount
operator|>
literal|32
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
operator|*
name|maxSVPtr
operator|=
name|charnum
operator|-
literal|1
expr_stmt|;
name|ip
operator|+=
operator|(
name|bitCount
operator|+
literal|7
operator|)
operator|>>
literal|3
expr_stmt|;
return|return
name|ip
operator|-
name|istart
return|;
block|}
end_function

begin_comment
comment|/*! HUF_readStats() :     Read compact Huffman tree, saved by HUF_writeCTable().     `huffWeight` is destination buffer.     `rankStats` is assumed to be a table of at least HUF_TABLELOG_MAX U32.     @return : size read from `src` , or an error Code .     Note : Needed by HUF_readCTable() and HUF_readDTableX?() . */
end_comment

begin_function
name|size_t
name|HUF_readStats
parameter_list|(
name|BYTE
modifier|*
name|huffWeight
parameter_list|,
name|size_t
name|hwSize
parameter_list|,
name|U32
modifier|*
name|rankStats
parameter_list|,
name|U32
modifier|*
name|nbSymbolsPtr
parameter_list|,
name|U32
modifier|*
name|tableLogPtr
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|)
block|{
name|U32
name|weightTotal
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|ip
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|src
decl_stmt|;
name|size_t
name|iSize
decl_stmt|;
name|size_t
name|oSize
decl_stmt|;
if|if
condition|(
operator|!
name|srcSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|iSize
operator|=
name|ip
index|[
literal|0
index|]
expr_stmt|;
comment|/* memset(huffWeight, 0, hwSize);   */
comment|/* is not necessary, even though some analyzer complain ... */
if|if
condition|(
name|iSize
operator|>=
literal|128
condition|)
block|{
comment|/* special header */
name|oSize
operator|=
name|iSize
operator|-
literal|127
expr_stmt|;
name|iSize
operator|=
operator|(
operator|(
name|oSize
operator|+
literal|1
operator|)
operator|/
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|iSize
operator|+
literal|1
operator|>
name|srcSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
if|if
condition|(
name|oSize
operator|>=
name|hwSize
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
name|ip
operator|+=
literal|1
expr_stmt|;
block|{
name|U32
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|oSize
condition|;
name|n
operator|+=
literal|2
control|)
block|{
name|huffWeight
index|[
name|n
index|]
operator|=
name|ip
index|[
name|n
operator|/
literal|2
index|]
operator|>>
literal|4
expr_stmt|;
name|huffWeight
index|[
name|n
operator|+
literal|1
index|]
operator|=
name|ip
index|[
name|n
operator|/
literal|2
index|]
operator|&
literal|15
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* header compressed with FSE (normal case) */
name|FSE_DTable
name|fseWorkspace
index|[
name|FSE_DTABLE_SIZE_U32
argument_list|(
literal|6
argument_list|)
index|]
decl_stmt|;
comment|/* 6 is max possible tableLog for HUF header (maybe even 5, to be tested) */
if|if
condition|(
name|iSize
operator|+
literal|1
operator|>
name|srcSize
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
name|oSize
operator|=
name|FSE_decompress_wksp
argument_list|(
name|huffWeight
argument_list|,
name|hwSize
operator|-
literal|1
argument_list|,
name|ip
operator|+
literal|1
argument_list|,
name|iSize
argument_list|,
name|fseWorkspace
argument_list|,
literal|6
argument_list|)
expr_stmt|;
comment|/* max (hwSize-1) values decoded, as last one is implied */
if|if
condition|(
name|FSE_isError
argument_list|(
name|oSize
argument_list|)
condition|)
return|return
name|oSize
return|;
block|}
comment|/* collect weight stats */
name|memset
argument_list|(
name|rankStats
argument_list|,
literal|0
argument_list|,
operator|(
name|HUF_TABLELOG_MAX
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|U32
argument_list|)
argument_list|)
expr_stmt|;
name|weightTotal
operator|=
literal|0
expr_stmt|;
block|{
name|U32
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|oSize
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|huffWeight
index|[
name|n
index|]
operator|>=
name|HUF_TABLELOG_MAX
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
name|rankStats
index|[
name|huffWeight
index|[
name|n
index|]
index|]
operator|++
expr_stmt|;
name|weightTotal
operator|+=
operator|(
literal|1
operator|<<
name|huffWeight
index|[
name|n
index|]
operator|)
operator|>>
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|weightTotal
operator|==
literal|0
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* get last non-null symbol weight (implied, total must be 2^n) */
block|{
name|U32
specifier|const
name|tableLog
init|=
name|BIT_highbit32
argument_list|(
name|weightTotal
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|tableLog
operator|>
name|HUF_TABLELOG_MAX
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
operator|*
name|tableLogPtr
operator|=
name|tableLog
expr_stmt|;
comment|/* determine last weight */
block|{
name|U32
specifier|const
name|total
init|=
literal|1
operator|<<
name|tableLog
decl_stmt|;
name|U32
specifier|const
name|rest
init|=
name|total
operator|-
name|weightTotal
decl_stmt|;
name|U32
specifier|const
name|verif
init|=
literal|1
operator|<<
name|BIT_highbit32
argument_list|(
name|rest
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|lastWeight
init|=
name|BIT_highbit32
argument_list|(
name|rest
argument_list|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|verif
operator|!=
name|rest
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* last value must be a clean power of 2 */
name|huffWeight
index|[
name|oSize
index|]
operator|=
operator|(
name|BYTE
operator|)
name|lastWeight
expr_stmt|;
name|rankStats
index|[
name|lastWeight
index|]
operator|++
expr_stmt|;
block|}
block|}
comment|/* check tree construction validity */
if|if
condition|(
operator|(
name|rankStats
index|[
literal|1
index|]
operator|<
literal|2
operator|)
operator|||
operator|(
name|rankStats
index|[
literal|1
index|]
operator|&
literal|1
operator|)
condition|)
return|return
name|ERROR
argument_list|(
name|corruption_detected
argument_list|)
return|;
comment|/* by construction : at least 2 elts of rank 1, must be even */
comment|/* results */
operator|*
name|nbSymbolsPtr
operator|=
call|(
name|U32
call|)
argument_list|(
name|oSize
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|iSize
operator|+
literal|1
return|;
block|}
end_function

end_unit

