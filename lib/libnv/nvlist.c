begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009-2013 The FreeBSD Foundation  * All rights reserved.  *  * This software was developed by Pawel Jakub Dawidek under sponsorship from  * the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_define
define|#
directive|define
name|_WITH_DPRINTF
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PJDLOG
end_ifdef

begin_include
include|#
directive|include
file|<pjdlog.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"msgio.h"
end_include

begin_include
include|#
directive|include
file|"nv.h"
end_include

begin_include
include|#
directive|include
file|"nv_impl.h"
end_include

begin_include
include|#
directive|include
file|"nvlist_impl.h"
end_include

begin_include
include|#
directive|include
file|"nvpair_impl.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_PJDLOG
end_ifndef

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_define
define|#
directive|define
name|PJDLOG_ASSERT
parameter_list|(
modifier|...
parameter_list|)
value|assert(__VA_ARGS__)
end_define

begin_define
define|#
directive|define
name|PJDLOG_RASSERT
parameter_list|(
name|expr
parameter_list|,
modifier|...
parameter_list|)
value|assert(expr)
end_define

begin_define
define|#
directive|define
name|PJDLOG_ABORT
parameter_list|(
modifier|...
parameter_list|)
value|do {				\ 	fprintf(stderr, "%s:%u: ", __FILE__, __LINE__);			\ 	fprintf(stderr, __VA_ARGS__);					\ 	fprintf(stderr, "\n");						\ 	abort();							\ } while (0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NV_FLAG_PRIVATE_MASK
value|(NV_FLAG_BIG_ENDIAN)
end_define

begin_define
define|#
directive|define
name|NV_FLAG_PUBLIC_MASK
value|(NV_FLAG_IGNORE_CASE)
end_define

begin_define
define|#
directive|define
name|NV_FLAG_ALL_MASK
value|(NV_FLAG_PRIVATE_MASK | NV_FLAG_PUBLIC_MASK)
end_define

begin_define
define|#
directive|define
name|NVLIST_MAGIC
value|0x6e766c
end_define

begin_comment
comment|/* "nvl" */
end_comment

begin_struct
struct|struct
name|nvlist
block|{
name|int
name|nvl_magic
decl_stmt|;
name|int
name|nvl_error
decl_stmt|;
name|int
name|nvl_flags
decl_stmt|;
name|struct
name|nvl_head
name|nvl_head
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NVLIST_ASSERT
parameter_list|(
name|nvl
parameter_list|)
value|do {					\ 	PJDLOG_ASSERT((nvl) != NULL);					\ 	PJDLOG_ASSERT((nvl)->nvl_magic == NVLIST_MAGIC);		\ } while (0)
end_define

begin_define
define|#
directive|define
name|NVPAIR_ASSERT
parameter_list|(
name|nvp
parameter_list|)
value|nvpair_assert(nvp)
end_define

begin_define
define|#
directive|define
name|NVLIST_HEADER_MAGIC
value|0x6c
end_define

begin_define
define|#
directive|define
name|NVLIST_HEADER_VERSION
value|0x00
end_define

begin_struct
struct|struct
name|nvlist_header
block|{
name|uint8_t
name|nvlh_magic
decl_stmt|;
name|uint8_t
name|nvlh_version
decl_stmt|;
name|uint8_t
name|nvlh_flags
decl_stmt|;
name|uint64_t
name|nvlh_descriptors
decl_stmt|;
name|uint64_t
name|nvlh_size
decl_stmt|;
block|}
name|__packed
struct|;
end_struct

begin_function
name|nvlist_t
modifier|*
name|nvlist_create
parameter_list|(
name|int
name|flags
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nvl
decl_stmt|;
name|PJDLOG_ASSERT
argument_list|(
operator|(
name|flags
operator|&
operator|~
operator|(
name|NV_FLAG_PUBLIC_MASK
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|nvl
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|nvl
argument_list|)
argument_list|)
expr_stmt|;
name|nvl
operator|->
name|nvl_error
operator|=
literal|0
expr_stmt|;
name|nvl
operator|->
name|nvl_flags
operator|=
name|flags
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|nvl
operator|->
name|nvl_head
argument_list|)
expr_stmt|;
name|nvl
operator|->
name|nvl_magic
operator|=
name|NVLIST_MAGIC
expr_stmt|;
return|return
operator|(
name|nvl
operator|)
return|;
block|}
end_function

begin_function
name|void
name|nvlist_destroy
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
name|int
name|serrno
decl_stmt|;
if|if
condition|(
name|nvl
operator|==
name|NULL
condition|)
return|return;
name|serrno
operator|=
name|errno
expr_stmt|;
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|nvp
operator|=
name|nvlist_first_nvpair
argument_list|(
name|nvl
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|nvlist_remove_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
name|nvpair_free
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
block|}
name|nvl
operator|->
name|nvl_magic
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|errno
operator|=
name|serrno
expr_stmt|;
block|}
end_function

begin_function
name|int
name|nvlist_error
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
block|{
if|if
condition|(
name|nvl
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return
operator|(
name|nvl
operator|->
name|nvl_error
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|nvlist_empty
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
block|{
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|nvl
operator|->
name|nvl_error
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|nvlist_first_nvpair
argument_list|(
name|nvl
argument_list|)
operator|==
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|nvlist_report_missing
parameter_list|(
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|namefmt
parameter_list|,
name|va_list
name|nameap
parameter_list|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|vasprintf
argument_list|(
operator|&
name|name
argument_list|,
name|namefmt
argument_list|,
name|nameap
argument_list|)
expr_stmt|;
name|PJDLOG_ABORT
argument_list|(
literal|"Element '%s' of type %s doesn't exist."
argument_list|,
name|name
operator|!=
name|NULL
condition|?
name|name
else|:
literal|"N/A"
argument_list|,
name|nvpair_type_string
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|nvpair_t
modifier|*
name|nvlist_findv
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|namefmt
parameter_list|,
name|va_list
name|nameap
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|nvl
operator|->
name|nvl_error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|type
operator|==
name|NV_TYPE_NONE
operator|||
operator|(
name|type
operator|>=
name|NV_TYPE_FIRST
operator|&&
name|type
operator|<=
name|NV_TYPE_LAST
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vasprintf
argument_list|(
operator|&
name|name
argument_list|,
name|namefmt
argument_list|,
name|nameap
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|nvp
operator|=
name|nvlist_first_nvpair
argument_list|(
name|nvl
argument_list|)
init|;
name|nvp
operator|!=
name|NULL
condition|;
name|nvp
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
control|)
block|{
if|if
condition|(
name|type
operator|!=
name|NV_TYPE_NONE
operator|&&
name|nvpair_type
argument_list|(
name|nvp
argument_list|)
operator|!=
name|type
condition|)
continue|continue;
if|if
condition|(
operator|(
name|nvl
operator|->
name|nvl_flags
operator|&
name|NV_FLAG_IGNORE_CASE
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|nvpair_name
argument_list|(
name|nvp
argument_list|)
argument_list|,
name|name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
block|}
else|else
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|nvpair_name
argument_list|(
name|nvp
argument_list|)
argument_list|,
name|name
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
block|}
break|break;
block|}
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvp
operator|==
name|NULL
condition|)
name|errno
operator|=
name|ENOENT
expr_stmt|;
return|return
operator|(
name|nvp
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|nvlist_exists_type
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|type
parameter_list|)
block|{
return|return
operator|(
name|nvlist_existsf_type
argument_list|(
name|nvl
argument_list|,
name|type
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|nvlist_existsf_type
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|namefmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|nameap
decl_stmt|;
name|bool
name|ret
decl_stmt|;
name|va_start
argument_list|(
name|nameap
argument_list|,
name|namefmt
argument_list|)
expr_stmt|;
name|ret
operator|=
name|nvlist_existsv_type
argument_list|(
name|nvl
argument_list|,
name|type
argument_list|,
name|namefmt
argument_list|,
name|nameap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|nameap
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|nvlist_existsv_type
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|namefmt
parameter_list|,
name|va_list
name|nameap
parameter_list|)
block|{
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|nvl
operator|->
name|nvl_error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|type
operator|==
name|NV_TYPE_NONE
operator|||
operator|(
name|type
operator|>=
name|NV_TYPE_FIRST
operator|&&
name|type
operator|<=
name|NV_TYPE_LAST
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|nvlist_findv
argument_list|(
name|nvl
argument_list|,
name|type
argument_list|,
name|namefmt
argument_list|,
name|nameap
argument_list|)
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|nvlist_free_type
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|nvlist_freef_type
argument_list|(
name|nvl
argument_list|,
name|type
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_freef_type
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|namefmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|nameap
decl_stmt|;
name|va_start
argument_list|(
name|nameap
argument_list|,
name|namefmt
argument_list|)
expr_stmt|;
name|nvlist_freev_type
argument_list|(
name|nvl
argument_list|,
name|type
argument_list|,
name|namefmt
argument_list|,
name|nameap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|nameap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_freev_type
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|namefmt
parameter_list|,
name|va_list
name|nameap
parameter_list|)
block|{
name|va_list
name|cnameap
decl_stmt|;
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|nvl
operator|->
name|nvl_error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|type
operator|==
name|NV_TYPE_NONE
operator|||
operator|(
name|type
operator|>=
name|NV_TYPE_FIRST
operator|&&
name|type
operator|<=
name|NV_TYPE_LAST
operator|)
argument_list|)
expr_stmt|;
name|va_copy
argument_list|(
name|cnameap
argument_list|,
name|nameap
argument_list|)
expr_stmt|;
name|nvp
operator|=
name|nvlist_findv
argument_list|(
name|nvl
argument_list|,
name|type
argument_list|,
name|namefmt
argument_list|,
name|cnameap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|cnameap
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvp
operator|!=
name|NULL
condition|)
name|nvlist_free_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
else|else
name|nvlist_report_missing
argument_list|(
name|type
argument_list|,
name|namefmt
argument_list|,
name|nameap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|nvlist_t
modifier|*
name|nvlist_clone
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|newnvl
decl_stmt|;
name|nvpair_t
modifier|*
name|nvp
decl_stmt|,
modifier|*
name|newnvp
decl_stmt|;
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvl
operator|->
name|nvl_error
operator|!=
literal|0
condition|)
block|{
name|errno
operator|=
name|nvl
operator|->
name|nvl_error
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|newnvl
operator|=
name|nvlist_create
argument_list|(
name|nvl
operator|->
name|nvl_flags
operator|&
name|NV_FLAG_PUBLIC_MASK
argument_list|)
expr_stmt|;
for|for
control|(
name|nvp
operator|=
name|nvlist_first_nvpair
argument_list|(
name|nvl
argument_list|)
init|;
name|nvp
operator|!=
name|NULL
condition|;
name|nvp
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
control|)
block|{
name|newnvp
operator|=
name|nvpair_clone
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|newnvp
operator|==
name|NULL
condition|)
break|break;
name|nvlist_move_nvpair
argument_list|(
name|newnvl
argument_list|,
name|newnvp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nvp
operator|!=
name|NULL
condition|)
block|{
name|nvlist_destroy
argument_list|(
name|newnvl
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|newnvl
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Dump content of nvlist.  */
end_comment

begin_function
specifier|static
name|void
name|nvlist_xdump
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|int
name|fd
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|level
operator|<
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|dprintf
argument_list|(
name|fd
argument_list|,
literal|"%*serror: %d\n"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|nvp
operator|=
name|nvlist_first_nvpair
argument_list|(
name|nvl
argument_list|)
init|;
name|nvp
operator|!=
name|NULL
condition|;
name|nvp
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
control|)
block|{
name|dprintf
argument_list|(
name|fd
argument_list|,
literal|"%*s%s (%s):"
argument_list|,
name|level
operator|*
literal|4
argument_list|,
literal|""
argument_list|,
name|nvpair_name
argument_list|(
name|nvp
argument_list|)
argument_list|,
name|nvpair_type_string
argument_list|(
name|nvpair_type
argument_list|(
name|nvp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|nvpair_type
argument_list|(
name|nvp
argument_list|)
condition|)
block|{
case|case
name|NV_TYPE_NULL
case|:
name|dprintf
argument_list|(
name|fd
argument_list|,
literal|" null\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|NV_TYPE_BOOL
case|:
name|dprintf
argument_list|(
name|fd
argument_list|,
literal|" %s\n"
argument_list|,
name|nvpair_get_bool
argument_list|(
name|nvp
argument_list|)
condition|?
literal|"TRUE"
else|:
literal|"FALSE"
argument_list|)
expr_stmt|;
break|break;
case|case
name|NV_TYPE_NUMBER
case|:
name|dprintf
argument_list|(
name|fd
argument_list|,
literal|" %ju (%jd) (0x%jx)\n"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|nvpair_get_number
argument_list|(
name|nvp
argument_list|)
argument_list|,
operator|(
name|intmax_t
operator|)
name|nvpair_get_number
argument_list|(
name|nvp
argument_list|)
argument_list|,
operator|(
name|uintmax_t
operator|)
name|nvpair_get_number
argument_list|(
name|nvp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NV_TYPE_STRING
case|:
name|dprintf
argument_list|(
name|fd
argument_list|,
literal|" [%s]\n"
argument_list|,
name|nvpair_get_string
argument_list|(
name|nvp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NV_TYPE_NVLIST
case|:
name|dprintf
argument_list|(
name|fd
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|nvlist_xdump
argument_list|(
name|nvpair_get_nvlist
argument_list|(
name|nvp
argument_list|)
argument_list|,
name|fd
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|NV_TYPE_DESCRIPTOR
case|:
name|dprintf
argument_list|(
name|fd
argument_list|,
literal|" %d\n"
argument_list|,
name|nvpair_get_descriptor
argument_list|(
name|nvp
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NV_TYPE_BINARY
case|:
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|binary
decl_stmt|;
name|unsigned
name|int
name|ii
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|binary
operator|=
name|nvpair_get_binary
argument_list|(
name|nvp
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
name|fd
argument_list|,
literal|" %zu "
argument_list|,
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|size
condition|;
name|ii
operator|++
control|)
name|dprintf
argument_list|(
name|fd
argument_list|,
literal|"%02hhx"
argument_list|,
name|binary
index|[
name|ii
index|]
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
name|fd
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|PJDLOG_ABORT
argument_list|(
literal|"Unknown type: %d."
argument_list|,
name|nvpair_type
argument_list|(
name|nvp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|nvlist_dump
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|nvlist_xdump
argument_list|(
name|nvl
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_fdump
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|nvlist_dump
argument_list|(
name|nvl
argument_list|,
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The function obtains size of the nvlist after nvlist_pack().  * Additional argument 'level' allows to track how deep are we as we obtain  * size of the NV_TYPE_NVLIST elements using recursion. We allow at most  * three levels of recursion.  */
end_comment

begin_function
specifier|static
name|size_t
name|nvlist_xsize
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|int
name|level
parameter_list|)
block|{
specifier|const
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|nvl
operator|->
name|nvl_error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|level
operator|<
literal|3
argument_list|)
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|nvlist_header
argument_list|)
expr_stmt|;
for|for
control|(
name|nvp
operator|=
name|nvlist_first_nvpair
argument_list|(
name|nvl
argument_list|)
init|;
name|nvp
operator|!=
name|NULL
condition|;
name|nvp
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
control|)
block|{
name|size
operator|+=
name|nvpair_header_size
argument_list|()
expr_stmt|;
name|size
operator|+=
name|strlen
argument_list|(
name|nvpair_name
argument_list|(
name|nvp
argument_list|)
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|nvpair_type
argument_list|(
name|nvp
argument_list|)
operator|==
name|NV_TYPE_NVLIST
condition|)
name|size
operator|+=
name|nvlist_xsize
argument_list|(
name|nvpair_get_nvlist
argument_list|(
name|nvp
argument_list|)
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|size
operator|+=
name|nvpair_size
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_function
name|size_t
name|nvlist_size
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
block|{
return|return
operator|(
name|nvlist_xsize
argument_list|(
name|nvl
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
modifier|*
name|nvlist_xdescriptors
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|int
modifier|*
name|descs
parameter_list|,
name|int
name|level
parameter_list|)
block|{
specifier|const
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|nvl
operator|->
name|nvl_error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|level
operator|<
literal|3
argument_list|)
expr_stmt|;
for|for
control|(
name|nvp
operator|=
name|nvlist_first_nvpair
argument_list|(
name|nvl
argument_list|)
init|;
name|nvp
operator|!=
name|NULL
condition|;
name|nvp
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
control|)
block|{
switch|switch
condition|(
name|nvpair_type
argument_list|(
name|nvp
argument_list|)
condition|)
block|{
case|case
name|NV_TYPE_DESCRIPTOR
case|:
operator|*
name|descs
operator|=
name|nvpair_get_descriptor
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|descs
operator|++
expr_stmt|;
break|break;
case|case
name|NV_TYPE_NVLIST
case|:
name|descs
operator|=
name|nvlist_xdescriptors
argument_list|(
name|nvpair_get_nvlist
argument_list|(
name|nvp
argument_list|)
argument_list|,
name|descs
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|descs
operator|)
return|;
block|}
end_function

begin_function
name|int
modifier|*
name|nvlist_descriptors
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|size_t
modifier|*
name|nitemsp
parameter_list|)
block|{
name|size_t
name|nitems
decl_stmt|;
name|int
modifier|*
name|fds
decl_stmt|;
name|nitems
operator|=
name|nvlist_ndescriptors
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|fds
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fds
index|[
literal|0
index|]
argument_list|)
operator|*
operator|(
name|nitems
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fds
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|nitems
operator|>
literal|0
condition|)
name|nvlist_xdescriptors
argument_list|(
name|nvl
argument_list|,
name|fds
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fds
index|[
name|nitems
index|]
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|nitemsp
operator|!=
name|NULL
condition|)
operator|*
name|nitemsp
operator|=
name|nitems
expr_stmt|;
return|return
operator|(
name|fds
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|nvlist_xndescriptors
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|int
name|level
parameter_list|)
block|{
specifier|const
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
name|size_t
name|ndescs
decl_stmt|;
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|nvl
operator|->
name|nvl_error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|level
operator|<
literal|3
argument_list|)
expr_stmt|;
name|ndescs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|nvp
operator|=
name|nvlist_first_nvpair
argument_list|(
name|nvl
argument_list|)
init|;
name|nvp
operator|!=
name|NULL
condition|;
name|nvp
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
control|)
block|{
switch|switch
condition|(
name|nvpair_type
argument_list|(
name|nvp
argument_list|)
condition|)
block|{
case|case
name|NV_TYPE_DESCRIPTOR
case|:
name|ndescs
operator|++
expr_stmt|;
break|break;
case|case
name|NV_TYPE_NVLIST
case|:
name|ndescs
operator|+=
name|nvlist_xndescriptors
argument_list|(
name|nvpair_get_nvlist
argument_list|(
name|nvp
argument_list|)
argument_list|,
name|level
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|ndescs
operator|)
return|;
block|}
end_function

begin_function
name|size_t
name|nvlist_ndescriptors
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
block|{
return|return
operator|(
name|nvlist_xndescriptors
argument_list|(
name|nvl
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|char
modifier|*
name|nvlist_pack_header
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|unsigned
name|char
modifier|*
name|ptr
parameter_list|,
name|size_t
modifier|*
name|leftp
parameter_list|)
block|{
name|struct
name|nvlist_header
name|nvlhdr
decl_stmt|;
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|nvlhdr
operator|.
name|nvlh_magic
operator|=
name|NVLIST_HEADER_MAGIC
expr_stmt|;
name|nvlhdr
operator|.
name|nvlh_version
operator|=
name|NVLIST_HEADER_VERSION
expr_stmt|;
name|nvlhdr
operator|.
name|nvlh_flags
operator|=
name|nvl
operator|->
name|nvl_flags
expr_stmt|;
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
name|nvlhdr
operator|.
name|nvlh_flags
operator||=
name|NV_FLAG_BIG_ENDIAN
expr_stmt|;
endif|#
directive|endif
name|nvlhdr
operator|.
name|nvlh_descriptors
operator|=
name|nvlist_ndescriptors
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|nvlhdr
operator|.
name|nvlh_size
operator|=
operator|*
name|leftp
operator|-
sizeof|sizeof
argument_list|(
name|nvlhdr
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
operator|*
name|leftp
operator|>=
sizeof|sizeof
argument_list|(
name|nvlhdr
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ptr
argument_list|,
operator|&
name|nvlhdr
argument_list|,
sizeof|sizeof
argument_list|(
name|nvlhdr
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|+=
sizeof|sizeof
argument_list|(
name|nvlhdr
argument_list|)
expr_stmt|;
operator|*
name|leftp
operator|-=
sizeof|sizeof
argument_list|(
name|nvlhdr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|nvlist_xpack
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|int64_t
modifier|*
name|fdidxp
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
name|size_t
name|left
decl_stmt|,
name|size
decl_stmt|;
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvl
operator|->
name|nvl_error
operator|!=
literal|0
condition|)
block|{
name|errno
operator|=
name|nvl
operator|->
name|nvl_error
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|size
operator|=
name|nvlist_size
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ptr
operator|=
name|buf
expr_stmt|;
name|left
operator|=
name|size
expr_stmt|;
name|ptr
operator|=
name|nvlist_pack_header
argument_list|(
name|nvl
argument_list|,
name|ptr
argument_list|,
operator|&
name|left
argument_list|)
expr_stmt|;
for|for
control|(
name|nvp
operator|=
name|nvlist_first_nvpair
argument_list|(
name|nvl
argument_list|)
init|;
name|nvp
operator|!=
name|NULL
condition|;
name|nvp
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
control|)
block|{
name|ptr
operator|=
name|nvpair_pack
argument_list|(
name|nvp
argument_list|,
name|ptr
argument_list|,
name|fdidxp
argument_list|,
operator|&
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|sizep
operator|!=
name|NULL
condition|)
operator|*
name|sizep
operator|=
name|size
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|nvlist_pack
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvl
operator|->
name|nvl_error
operator|!=
literal|0
condition|)
block|{
name|errno
operator|=
name|nvl
operator|->
name|nvl_error
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|nvlist_ndescriptors
argument_list|(
name|nvl
argument_list|)
operator|>
literal|0
condition|)
block|{
name|errno
operator|=
name|EOPNOTSUPP
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|nvlist_xpack
argument_list|(
name|nvl
argument_list|,
name|NULL
argument_list|,
name|sizep
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|nvlist_check_header
parameter_list|(
name|struct
name|nvlist_header
modifier|*
name|nvlhdrp
parameter_list|)
block|{
if|if
condition|(
name|nvlhdrp
operator|->
name|nvlh_magic
operator|!=
name|NVLIST_HEADER_MAGIC
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|nvlhdrp
operator|->
name|nvlh_flags
operator|&
operator|~
name|NV_FLAG_ALL_MASK
operator|)
operator|!=
literal|0
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
if|if
condition|(
operator|(
name|nvlhdrp
operator|->
name|nvlh_flags
operator|&
name|NV_FLAG_BIG_ENDIAN
operator|)
operator|==
literal|0
condition|)
block|{
name|nvlhdrp
operator|->
name|nvlh_size
operator|=
name|le64toh
argument_list|(
name|nvlhdrp
operator|->
name|nvlh_size
argument_list|)
expr_stmt|;
name|nvlhdrp
operator|->
name|nvlh_descriptors
operator|=
name|le64toh
argument_list|(
name|nvlhdrp
operator|->
name|nvlh_descriptors
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
operator|(
name|nvlhdrp
operator|->
name|nvlh_flags
operator|&
name|NV_FLAG_BIG_ENDIAN
operator|)
operator|!=
literal|0
condition|)
block|{
name|nvlhdrp
operator|->
name|nvlh_size
operator|=
name|be64toh
argument_list|(
name|nvlhdrp
operator|->
name|nvlh_size
argument_list|)
expr_stmt|;
name|nvlhdrp
operator|->
name|nvlh_descriptors
operator|=
name|be64toh
argument_list|(
name|nvlhdrp
operator|->
name|nvlh_descriptors
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
name|nvlist_unpack_header
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|ptr
parameter_list|,
name|size_t
name|nfds
parameter_list|,
name|int
modifier|*
name|flagsp
parameter_list|,
name|size_t
modifier|*
name|leftp
parameter_list|)
block|{
name|struct
name|nvlist_header
name|nvlhdr
decl_stmt|;
if|if
condition|(
operator|*
name|leftp
operator|<
sizeof|sizeof
argument_list|(
name|nvlhdr
argument_list|)
condition|)
goto|goto
name|failed
goto|;
name|memcpy
argument_list|(
operator|&
name|nvlhdr
argument_list|,
name|ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|nvlhdr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nvlist_check_header
argument_list|(
operator|&
name|nvlhdr
argument_list|)
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
name|nvlhdr
operator|.
name|nvlh_size
operator|!=
operator|*
name|leftp
operator|-
sizeof|sizeof
argument_list|(
name|nvlhdr
argument_list|)
condition|)
goto|goto
name|failed
goto|;
comment|/* 	 * nvlh_descriptors might be smaller than nfds in embedded nvlists. 	 */
if|if
condition|(
name|nvlhdr
operator|.
name|nvlh_descriptors
operator|>
name|nfds
condition|)
goto|goto
name|failed
goto|;
if|if
condition|(
operator|(
name|nvlhdr
operator|.
name|nvlh_flags
operator|&
operator|~
name|NV_FLAG_ALL_MASK
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|failed
goto|;
name|nvl
operator|->
name|nvl_flags
operator|=
operator|(
name|nvlhdr
operator|.
name|nvlh_flags
operator|&
name|NV_FLAG_PUBLIC_MASK
operator|)
expr_stmt|;
name|ptr
operator|+=
sizeof|sizeof
argument_list|(
name|nvlhdr
argument_list|)
expr_stmt|;
operator|*
name|flagsp
operator|=
operator|(
name|int
operator|)
name|nvlhdr
operator|.
name|nvlh_flags
expr_stmt|;
operator|*
name|leftp
operator|-=
sizeof|sizeof
argument_list|(
name|nvlhdr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
name|failed
label|:
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|nvlist_t
modifier|*
name|nvlist_xunpack
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|int
modifier|*
name|fds
parameter_list|,
name|size_t
name|nfds
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|ptr
decl_stmt|;
name|nvlist_t
modifier|*
name|nvl
decl_stmt|;
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
name|size_t
name|left
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|left
operator|=
name|size
expr_stmt|;
name|ptr
operator|=
name|buf
expr_stmt|;
name|nvl
operator|=
name|nvlist_create
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvl
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
name|ptr
operator|=
name|nvlist_unpack_header
argument_list|(
name|nvl
argument_list|,
name|ptr
argument_list|,
name|nfds
argument_list|,
operator|&
name|flags
argument_list|,
operator|&
name|left
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
while|while
condition|(
name|left
operator|>
literal|0
condition|)
block|{
name|ptr
operator|=
name|nvpair_unpack
argument_list|(
name|flags
argument_list|,
name|ptr
argument_list|,
operator|&
name|left
argument_list|,
name|fds
argument_list|,
name|nfds
argument_list|,
operator|&
name|nvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|==
name|NULL
condition|)
goto|goto
name|failed
goto|;
name|nvlist_move_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|nvl
operator|)
return|;
name|failed
label|:
name|nvlist_destroy
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|nvlist_t
modifier|*
name|nvlist_unpack
parameter_list|(
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
return|return
operator|(
name|nvlist_xunpack
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|nvlist_send
parameter_list|(
name|int
name|sock
parameter_list|,
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
block|{
name|size_t
name|datasize
decl_stmt|,
name|nfds
decl_stmt|;
name|int
modifier|*
name|fds
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|int64_t
name|fdidx
decl_stmt|;
name|int
name|serrno
decl_stmt|,
name|ret
decl_stmt|;
if|if
condition|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|errno
operator|=
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|fds
operator|=
name|nvlist_descriptors
argument_list|(
name|nvl
argument_list|,
operator|&
name|nfds
argument_list|)
expr_stmt|;
if|if
condition|(
name|fds
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
name|data
operator|=
name|NULL
expr_stmt|;
name|fdidx
operator|=
literal|0
expr_stmt|;
name|data
operator|=
name|nvlist_xpack
argument_list|(
name|nvl
argument_list|,
operator|&
name|fdidx
argument_list|,
operator|&
name|datasize
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|buf_send
argument_list|(
name|sock
argument_list|,
name|data
argument_list|,
name|datasize
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|nfds
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|fd_send
argument_list|(
name|sock
argument_list|,
name|fds
argument_list|,
name|nfds
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|serrno
operator|=
name|errno
expr_stmt|;
name|free
argument_list|(
name|fds
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|errno
operator|=
name|serrno
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|nvlist_t
modifier|*
name|nvlist_recv
parameter_list|(
name|int
name|sock
parameter_list|)
block|{
name|struct
name|nvlist_header
name|nvlhdr
decl_stmt|;
name|nvlist_t
modifier|*
name|nvl
decl_stmt|,
modifier|*
name|ret
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|nfds
decl_stmt|,
name|size
decl_stmt|;
name|int
name|serrno
decl_stmt|,
name|i
decl_stmt|,
modifier|*
name|fds
decl_stmt|;
if|if
condition|(
name|buf_recv
argument_list|(
name|sock
argument_list|,
operator|&
name|nvlhdr
argument_list|,
sizeof|sizeof
argument_list|(
name|nvlhdr
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|!
name|nvlist_check_header
argument_list|(
operator|&
name|nvlhdr
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|nfds
operator|=
operator|(
name|size_t
operator|)
name|nvlhdr
operator|.
name|nvlh_descriptors
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|nvlhdr
argument_list|)
operator|+
operator|(
name|size_t
operator|)
name|nvlhdr
operator|.
name|nvlh_size
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|memcpy
argument_list|(
name|buf
argument_list|,
operator|&
name|nvlhdr
argument_list|,
sizeof|sizeof
argument_list|(
name|nvlhdr
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
name|fds
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|buf_recv
argument_list|(
name|sock
argument_list|,
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|nvlhdr
argument_list|)
argument_list|,
name|size
operator|-
sizeof|sizeof
argument_list|(
name|nvlhdr
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|nfds
operator|>
literal|0
condition|)
block|{
name|fds
operator|=
name|malloc
argument_list|(
name|nfds
operator|*
sizeof|sizeof
argument_list|(
name|fds
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fds
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|fd_recv
argument_list|(
name|sock
argument_list|,
name|fds
argument_list|,
name|nfds
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|out
goto|;
block|}
name|nvl
operator|=
name|nvlist_xunpack
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
name|fds
argument_list|,
name|nfds
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvl
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfds
condition|;
name|i
operator|++
control|)
name|close
argument_list|(
name|fds
index|[
name|i
index|]
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ret
operator|=
name|nvl
expr_stmt|;
name|out
label|:
name|serrno
operator|=
name|errno
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fds
argument_list|)
expr_stmt|;
name|errno
operator|=
name|serrno
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|nvlist_t
modifier|*
name|nvlist_xfer
parameter_list|(
name|int
name|sock
parameter_list|,
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
block|{
if|if
condition|(
name|nvlist_send
argument_list|(
name|sock
argument_list|,
name|nvl
argument_list|)
operator|<
literal|0
condition|)
block|{
name|nvlist_destroy
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|nvlist_destroy
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return
operator|(
name|nvlist_recv
argument_list|(
name|sock
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|nvpair_t
modifier|*
name|nvlist_first_nvpair
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
block|{
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return
operator|(
name|TAILQ_FIRST
argument_list|(
operator|&
name|nvl
operator|->
name|nvl_head
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|nvpair_t
modifier|*
name|nvlist_next_nvpair
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|nvpair_t
modifier|*
name|nvp
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|retnvp
decl_stmt|;
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|NVPAIR_ASSERT
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|nvpair_nvlist
argument_list|(
name|nvp
argument_list|)
operator|==
name|nvl
argument_list|)
expr_stmt|;
name|retnvp
operator|=
name|nvpair_next
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|retnvp
operator|==
name|NULL
operator|||
name|nvpair_nvlist
argument_list|(
name|retnvp
argument_list|)
operator|==
name|nvl
argument_list|)
expr_stmt|;
return|return
operator|(
name|retnvp
operator|)
return|;
block|}
end_function

begin_function
name|nvpair_t
modifier|*
name|nvlist_prev_nvpair
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|nvpair_t
modifier|*
name|nvp
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|retnvp
decl_stmt|;
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|NVPAIR_ASSERT
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|nvpair_nvlist
argument_list|(
name|nvp
argument_list|)
operator|==
name|nvl
argument_list|)
expr_stmt|;
name|retnvp
operator|=
name|nvpair_prev
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|nvpair_nvlist
argument_list|(
name|retnvp
argument_list|)
operator|==
name|nvl
argument_list|)
expr_stmt|;
return|return
operator|(
name|retnvp
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|nvlist_next
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|int
modifier|*
name|typep
parameter_list|,
name|void
modifier|*
modifier|*
name|cookiep
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|cookiep
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cookiep
operator|==
name|NULL
condition|)
name|nvp
operator|=
name|nvlist_first_nvpair
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
else|else
name|nvp
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
operator|*
name|cookiep
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvp
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|typep
operator|!=
name|NULL
condition|)
operator|*
name|typep
operator|=
name|nvpair_type
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
operator|*
name|cookiep
operator|=
name|nvp
expr_stmt|;
return|return
operator|(
name|nvpair_name
argument_list|(
name|nvp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|bool
name|nvlist_exists
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
operator|(
name|nvlist_existsf
argument_list|(
name|nvl
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NVLIST_EXISTS
parameter_list|(
name|type
parameter_list|)
define|\
value|bool									\ nvlist_exists_##type(const nvlist_t *nvl, const char *name)		\ {									\ 									\ 	return (nvlist_existsf_##type(nvl, "%s", name));		\ }
end_define

begin_macro
name|NVLIST_EXISTS
argument_list|(
argument|null
argument_list|)
end_macro

begin_macro
name|NVLIST_EXISTS
argument_list|(
argument|bool
argument_list|)
end_macro

begin_macro
name|NVLIST_EXISTS
argument_list|(
argument|number
argument_list|)
end_macro

begin_macro
name|NVLIST_EXISTS
argument_list|(
argument|string
argument_list|)
end_macro

begin_macro
name|NVLIST_EXISTS
argument_list|(
argument|nvlist
argument_list|)
end_macro

begin_macro
name|NVLIST_EXISTS
argument_list|(
argument|descriptor
argument_list|)
end_macro

begin_macro
name|NVLIST_EXISTS
argument_list|(
argument|binary
argument_list|)
end_macro

begin_undef
undef|#
directive|undef
name|NVLIST_EXISTS
end_undef

begin_function
name|bool
name|nvlist_existsf
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|namefmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|nameap
decl_stmt|;
name|bool
name|ret
decl_stmt|;
name|va_start
argument_list|(
name|nameap
argument_list|,
name|namefmt
argument_list|)
expr_stmt|;
name|ret
operator|=
name|nvlist_existsv
argument_list|(
name|nvl
argument_list|,
name|namefmt
argument_list|,
name|nameap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|nameap
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NVLIST_EXISTSF
parameter_list|(
name|type
parameter_list|)
define|\
value|bool									\ nvlist_existsf_##type(const nvlist_t *nvl, const char *namefmt, ...)	\ {									\ 	va_list nameap;							\ 	bool ret;							\ 									\ 	va_start(nameap, namefmt);					\ 	ret = nvlist_existsv_##type(nvl, namefmt, nameap);		\ 	va_end(nameap);							\ 	return (ret);							\ }
end_define

begin_macro
name|NVLIST_EXISTSF
argument_list|(
argument|null
argument_list|)
end_macro

begin_macro
name|NVLIST_EXISTSF
argument_list|(
argument|bool
argument_list|)
end_macro

begin_macro
name|NVLIST_EXISTSF
argument_list|(
argument|number
argument_list|)
end_macro

begin_macro
name|NVLIST_EXISTSF
argument_list|(
argument|string
argument_list|)
end_macro

begin_macro
name|NVLIST_EXISTSF
argument_list|(
argument|nvlist
argument_list|)
end_macro

begin_macro
name|NVLIST_EXISTSF
argument_list|(
argument|descriptor
argument_list|)
end_macro

begin_macro
name|NVLIST_EXISTSF
argument_list|(
argument|binary
argument_list|)
end_macro

begin_undef
undef|#
directive|undef
name|NVLIST_EXISTSF
end_undef

begin_function
name|bool
name|nvlist_existsv
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|namefmt
parameter_list|,
name|va_list
name|nameap
parameter_list|)
block|{
return|return
operator|(
name|nvlist_findv
argument_list|(
name|nvl
argument_list|,
name|NV_TYPE_NONE
argument_list|,
name|namefmt
argument_list|,
name|nameap
argument_list|)
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NVLIST_EXISTSV
parameter_list|(
name|type
parameter_list|,
name|TYPE
parameter_list|)
define|\
value|bool									\ nvlist_existsv_##type(const nvlist_t *nvl, const char *namefmt,		\     va_list nameap)							\ {									\ 									\ 	return (nvlist_findv(nvl, NV_TYPE_##TYPE, namefmt, nameap) !=	\ 	    NULL);							\ }
end_define

begin_macro
name|NVLIST_EXISTSV
argument_list|(
argument|null
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_macro
name|NVLIST_EXISTSV
argument_list|(
argument|bool
argument_list|,
argument|BOOL
argument_list|)
end_macro

begin_macro
name|NVLIST_EXISTSV
argument_list|(
argument|number
argument_list|,
argument|NUMBER
argument_list|)
end_macro

begin_macro
name|NVLIST_EXISTSV
argument_list|(
argument|string
argument_list|,
argument|STRING
argument_list|)
end_macro

begin_macro
name|NVLIST_EXISTSV
argument_list|(
argument|nvlist
argument_list|,
argument|NVLIST
argument_list|)
end_macro

begin_macro
name|NVLIST_EXISTSV
argument_list|(
argument|descriptor
argument_list|,
argument|DESCRIPTOR
argument_list|)
end_macro

begin_macro
name|NVLIST_EXISTSV
argument_list|(
argument|binary
argument_list|,
argument|BINARY
argument_list|)
end_macro

begin_undef
undef|#
directive|undef
name|NVLIST_EXISTSV
end_undef

begin_function
name|void
name|nvlist_add_nvpair
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|nvpair_t
modifier|*
name|nvp
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|newnvp
decl_stmt|;
name|NVPAIR_ASSERT
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|errno
operator|=
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nvlist_exists
argument_list|(
name|nvl
argument_list|,
name|nvpair_name
argument_list|(
name|nvp
argument_list|)
argument_list|)
condition|)
block|{
name|nvl
operator|->
name|nvl_error
operator|=
name|errno
operator|=
name|EEXIST
expr_stmt|;
return|return;
block|}
name|newnvp
operator|=
name|nvpair_clone
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|newnvp
operator|==
name|NULL
condition|)
block|{
name|nvl
operator|->
name|nvl_error
operator|=
name|errno
operator|=
operator|(
name|errno
operator|!=
literal|0
condition|?
name|errno
else|:
name|ENOMEM
operator|)
expr_stmt|;
return|return;
block|}
name|nvpair_insert
argument_list|(
operator|&
name|nvl
operator|->
name|nvl_head
argument_list|,
name|newnvp
argument_list|,
name|nvl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_add_null
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|nvlist_addf_null
argument_list|(
name|nvl
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_add_bool
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|bool
name|value
parameter_list|)
block|{
name|nvlist_addf_bool
argument_list|(
name|nvl
argument_list|,
name|value
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_add_number
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
name|value
parameter_list|)
block|{
name|nvlist_addf_number
argument_list|(
name|nvl
argument_list|,
name|value
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_add_string
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|nvlist_addf_string
argument_list|(
name|nvl
argument_list|,
name|value
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_add_stringf
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|valuefmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|valueap
decl_stmt|;
name|va_start
argument_list|(
name|valueap
argument_list|,
name|valuefmt
argument_list|)
expr_stmt|;
name|nvlist_add_stringv
argument_list|(
name|nvl
argument_list|,
name|name
argument_list|,
name|valuefmt
argument_list|,
name|valueap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|valueap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_add_stringv
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|valuefmt
parameter_list|,
name|va_list
name|valueap
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
if|if
condition|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|errno
operator|=
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return;
block|}
name|nvp
operator|=
name|nvpair_create_stringv
argument_list|(
name|name
argument_list|,
name|valuefmt
argument_list|,
name|valueap
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvp
operator|==
name|NULL
condition|)
name|nvl
operator|->
name|nvl_error
operator|=
name|errno
operator|=
operator|(
name|errno
operator|!=
literal|0
condition|?
name|errno
else|:
name|ENOMEM
operator|)
expr_stmt|;
else|else
name|nvlist_move_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_add_nvlist
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|nvlist_t
modifier|*
name|value
parameter_list|)
block|{
name|nvlist_addf_nvlist
argument_list|(
name|nvl
argument_list|,
name|value
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_add_descriptor
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|nvlist_addf_descriptor
argument_list|(
name|nvl
argument_list|,
name|value
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_add_binary
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|void
modifier|*
name|value
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|nvlist_addf_binary
argument_list|(
name|nvl
argument_list|,
name|value
argument_list|,
name|size
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_addf_null
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|namefmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|nameap
decl_stmt|;
name|va_start
argument_list|(
name|nameap
argument_list|,
name|namefmt
argument_list|)
expr_stmt|;
name|nvlist_addv_null
argument_list|(
name|nvl
argument_list|,
name|namefmt
argument_list|,
name|nameap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|nameap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_addf_bool
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|bool
name|value
parameter_list|,
specifier|const
name|char
modifier|*
name|namefmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|nameap
decl_stmt|;
name|va_start
argument_list|(
name|nameap
argument_list|,
name|namefmt
argument_list|)
expr_stmt|;
name|nvlist_addv_bool
argument_list|(
name|nvl
argument_list|,
name|value
argument_list|,
name|namefmt
argument_list|,
name|nameap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|nameap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_addf_number
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|uint64_t
name|value
parameter_list|,
specifier|const
name|char
modifier|*
name|namefmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|nameap
decl_stmt|;
name|va_start
argument_list|(
name|nameap
argument_list|,
name|namefmt
argument_list|)
expr_stmt|;
name|nvlist_addv_number
argument_list|(
name|nvl
argument_list|,
name|value
argument_list|,
name|namefmt
argument_list|,
name|nameap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|nameap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_addf_string
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
specifier|const
name|char
modifier|*
name|namefmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|nameap
decl_stmt|;
name|va_start
argument_list|(
name|nameap
argument_list|,
name|namefmt
argument_list|)
expr_stmt|;
name|nvlist_addv_string
argument_list|(
name|nvl
argument_list|,
name|value
argument_list|,
name|namefmt
argument_list|,
name|nameap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|nameap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_addf_nvlist
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|nvlist_t
modifier|*
name|value
parameter_list|,
specifier|const
name|char
modifier|*
name|namefmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|nameap
decl_stmt|;
name|va_start
argument_list|(
name|nameap
argument_list|,
name|namefmt
argument_list|)
expr_stmt|;
name|nvlist_addv_nvlist
argument_list|(
name|nvl
argument_list|,
name|value
argument_list|,
name|namefmt
argument_list|,
name|nameap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|nameap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_addf_descriptor
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|int
name|value
parameter_list|,
specifier|const
name|char
modifier|*
name|namefmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|nameap
decl_stmt|;
name|va_start
argument_list|(
name|nameap
argument_list|,
name|namefmt
argument_list|)
expr_stmt|;
name|nvlist_addv_descriptor
argument_list|(
name|nvl
argument_list|,
name|value
argument_list|,
name|namefmt
argument_list|,
name|nameap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|nameap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_addf_binary
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|void
modifier|*
name|value
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|namefmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|nameap
decl_stmt|;
name|va_start
argument_list|(
name|nameap
argument_list|,
name|namefmt
argument_list|)
expr_stmt|;
name|nvlist_addv_binary
argument_list|(
name|nvl
argument_list|,
name|value
argument_list|,
name|size
argument_list|,
name|namefmt
argument_list|,
name|nameap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|nameap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_addv_null
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|namefmt
parameter_list|,
name|va_list
name|nameap
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
if|if
condition|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|errno
operator|=
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return;
block|}
name|nvp
operator|=
name|nvpair_createv_null
argument_list|(
name|namefmt
argument_list|,
name|nameap
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvp
operator|==
name|NULL
condition|)
name|nvl
operator|->
name|nvl_error
operator|=
name|errno
operator|=
operator|(
name|errno
operator|!=
literal|0
condition|?
name|errno
else|:
name|ENOMEM
operator|)
expr_stmt|;
else|else
name|nvlist_move_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_addv_bool
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|bool
name|value
parameter_list|,
specifier|const
name|char
modifier|*
name|namefmt
parameter_list|,
name|va_list
name|nameap
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
if|if
condition|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|errno
operator|=
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return;
block|}
name|nvp
operator|=
name|nvpair_createv_bool
argument_list|(
name|value
argument_list|,
name|namefmt
argument_list|,
name|nameap
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvp
operator|==
name|NULL
condition|)
name|nvl
operator|->
name|nvl_error
operator|=
name|errno
operator|=
operator|(
name|errno
operator|!=
literal|0
condition|?
name|errno
else|:
name|ENOMEM
operator|)
expr_stmt|;
else|else
name|nvlist_move_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_addv_number
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|uint64_t
name|value
parameter_list|,
specifier|const
name|char
modifier|*
name|namefmt
parameter_list|,
name|va_list
name|nameap
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
if|if
condition|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|errno
operator|=
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return;
block|}
name|nvp
operator|=
name|nvpair_createv_number
argument_list|(
name|value
argument_list|,
name|namefmt
argument_list|,
name|nameap
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvp
operator|==
name|NULL
condition|)
name|nvl
operator|->
name|nvl_error
operator|=
name|errno
operator|=
operator|(
name|errno
operator|!=
literal|0
condition|?
name|errno
else|:
name|ENOMEM
operator|)
expr_stmt|;
else|else
name|nvlist_move_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_addv_string
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
specifier|const
name|char
modifier|*
name|namefmt
parameter_list|,
name|va_list
name|nameap
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
if|if
condition|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|errno
operator|=
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return;
block|}
name|nvp
operator|=
name|nvpair_createv_string
argument_list|(
name|value
argument_list|,
name|namefmt
argument_list|,
name|nameap
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvp
operator|==
name|NULL
condition|)
name|nvl
operator|->
name|nvl_error
operator|=
name|errno
operator|=
operator|(
name|errno
operator|!=
literal|0
condition|?
name|errno
else|:
name|ENOMEM
operator|)
expr_stmt|;
else|else
name|nvlist_move_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_addv_nvlist
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|nvlist_t
modifier|*
name|value
parameter_list|,
specifier|const
name|char
modifier|*
name|namefmt
parameter_list|,
name|va_list
name|nameap
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
if|if
condition|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|errno
operator|=
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return;
block|}
name|nvp
operator|=
name|nvpair_createv_nvlist
argument_list|(
name|value
argument_list|,
name|namefmt
argument_list|,
name|nameap
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvp
operator|==
name|NULL
condition|)
name|nvl
operator|->
name|nvl_error
operator|=
name|errno
operator|=
operator|(
name|errno
operator|!=
literal|0
condition|?
name|errno
else|:
name|ENOMEM
operator|)
expr_stmt|;
else|else
name|nvlist_move_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_addv_descriptor
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|int
name|value
parameter_list|,
specifier|const
name|char
modifier|*
name|namefmt
parameter_list|,
name|va_list
name|nameap
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
if|if
condition|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|errno
operator|=
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return;
block|}
name|nvp
operator|=
name|nvpair_createv_descriptor
argument_list|(
name|value
argument_list|,
name|namefmt
argument_list|,
name|nameap
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvp
operator|==
name|NULL
condition|)
name|nvl
operator|->
name|nvl_error
operator|=
name|errno
operator|=
operator|(
name|errno
operator|!=
literal|0
condition|?
name|errno
else|:
name|ENOMEM
operator|)
expr_stmt|;
else|else
name|nvlist_move_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_addv_binary
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|void
modifier|*
name|value
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|namefmt
parameter_list|,
name|va_list
name|nameap
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
if|if
condition|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|errno
operator|=
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return;
block|}
name|nvp
operator|=
name|nvpair_createv_binary
argument_list|(
name|value
argument_list|,
name|size
argument_list|,
name|namefmt
argument_list|,
name|nameap
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvp
operator|==
name|NULL
condition|)
name|nvl
operator|->
name|nvl_error
operator|=
name|errno
operator|=
operator|(
name|errno
operator|!=
literal|0
condition|?
name|errno
else|:
name|ENOMEM
operator|)
expr_stmt|;
else|else
name|nvlist_move_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_move_nvpair
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|nvpair_t
modifier|*
name|nvp
parameter_list|)
block|{
name|NVPAIR_ASSERT
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|nvpair_nvlist
argument_list|(
name|nvp
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvpair_free
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|errno
operator|=
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nvlist_exists
argument_list|(
name|nvl
argument_list|,
name|nvpair_name
argument_list|(
name|nvp
argument_list|)
argument_list|)
condition|)
block|{
name|nvpair_free
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|nvl
operator|->
name|nvl_error
operator|=
name|errno
operator|=
name|EEXIST
expr_stmt|;
return|return;
block|}
name|nvpair_insert
argument_list|(
operator|&
name|nvl
operator|->
name|nvl_head
argument_list|,
name|nvp
argument_list|,
name|nvl
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|NVLIST_MOVE
parameter_list|(
name|vtype
parameter_list|,
name|type
parameter_list|)
define|\
value|void									\ nvlist_move_##type(nvlist_t *nvl, const char *name, vtype value)	\ {									\ 									\ 	nvlist_movef_##type(nvl, value, "%s", name);			\ }
end_define

begin_macro
name|NVLIST_MOVE
argument_list|(
argument|char *
argument_list|,
argument|string
argument_list|)
end_macro

begin_macro
name|NVLIST_MOVE
argument_list|(
argument|nvlist_t *
argument_list|,
argument|nvlist
argument_list|)
end_macro

begin_macro
name|NVLIST_MOVE
argument_list|(
argument|int
argument_list|,
argument|descriptor
argument_list|)
end_macro

begin_undef
undef|#
directive|undef
name|NVLIST_MOVE
end_undef

begin_function
name|void
name|nvlist_move_binary
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|value
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|nvlist_movef_binary
argument_list|(
name|nvl
argument_list|,
name|value
argument_list|,
name|size
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|NVLIST_MOVEF
parameter_list|(
name|vtype
parameter_list|,
name|type
parameter_list|)
define|\
value|void									\ nvlist_movef_##type(nvlist_t *nvl, vtype value, const char *namefmt,	\     ...)								\ {									\ 	va_list nameap;							\ 									\ 	va_start(nameap, namefmt);					\ 	nvlist_movev_##type(nvl, value, namefmt, nameap);		\ 	va_end(nameap);							\ }
end_define

begin_macro
name|NVLIST_MOVEF
argument_list|(
argument|char *
argument_list|,
argument|string
argument_list|)
end_macro

begin_macro
name|NVLIST_MOVEF
argument_list|(
argument|nvlist_t *
argument_list|,
argument|nvlist
argument_list|)
end_macro

begin_macro
name|NVLIST_MOVEF
argument_list|(
argument|int
argument_list|,
argument|descriptor
argument_list|)
end_macro

begin_undef
undef|#
directive|undef
name|NVLIST_MOVEF
end_undef

begin_function
name|void
name|nvlist_movef_binary
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|void
modifier|*
name|value
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|namefmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|nameap
decl_stmt|;
name|va_start
argument_list|(
name|nameap
argument_list|,
name|namefmt
argument_list|)
expr_stmt|;
name|nvlist_movev_binary
argument_list|(
name|nvl
argument_list|,
name|value
argument_list|,
name|size
argument_list|,
name|namefmt
argument_list|,
name|nameap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|nameap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_movev_string
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|char
modifier|*
name|value
parameter_list|,
specifier|const
name|char
modifier|*
name|namefmt
parameter_list|,
name|va_list
name|nameap
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
if|if
condition|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|errno
operator|=
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return;
block|}
name|nvp
operator|=
name|nvpair_movev_string
argument_list|(
name|value
argument_list|,
name|namefmt
argument_list|,
name|nameap
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvp
operator|==
name|NULL
condition|)
name|nvl
operator|->
name|nvl_error
operator|=
name|errno
operator|=
operator|(
name|errno
operator|!=
literal|0
condition|?
name|errno
else|:
name|ENOMEM
operator|)
expr_stmt|;
else|else
name|nvlist_move_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_movev_nvlist
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|nvlist_t
modifier|*
name|value
parameter_list|,
specifier|const
name|char
modifier|*
name|namefmt
parameter_list|,
name|va_list
name|nameap
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
if|if
condition|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_destroy
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|errno
operator|=
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return;
block|}
name|nvp
operator|=
name|nvpair_movev_nvlist
argument_list|(
name|value
argument_list|,
name|namefmt
argument_list|,
name|nameap
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvp
operator|==
name|NULL
condition|)
name|nvl
operator|->
name|nvl_error
operator|=
name|errno
operator|=
operator|(
name|errno
operator|!=
literal|0
condition|?
name|errno
else|:
name|ENOMEM
operator|)
expr_stmt|;
else|else
name|nvlist_move_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_movev_descriptor
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|int
name|value
parameter_list|,
specifier|const
name|char
modifier|*
name|namefmt
parameter_list|,
name|va_list
name|nameap
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
if|if
condition|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|close
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|errno
operator|=
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return;
block|}
name|nvp
operator|=
name|nvpair_movev_descriptor
argument_list|(
name|value
argument_list|,
name|namefmt
argument_list|,
name|nameap
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvp
operator|==
name|NULL
condition|)
name|nvl
operator|->
name|nvl_error
operator|=
name|errno
operator|=
operator|(
name|errno
operator|!=
literal|0
condition|?
name|errno
else|:
name|ENOMEM
operator|)
expr_stmt|;
else|else
name|nvlist_move_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_movev_binary
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|void
modifier|*
name|value
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|namefmt
parameter_list|,
name|va_list
name|nameap
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
if|if
condition|(
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|errno
operator|=
name|nvlist_error
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
return|return;
block|}
name|nvp
operator|=
name|nvpair_movev_binary
argument_list|(
name|value
argument_list|,
name|size
argument_list|,
name|namefmt
argument_list|,
name|nameap
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvp
operator|==
name|NULL
condition|)
name|nvl
operator|->
name|nvl_error
operator|=
name|errno
operator|=
operator|(
name|errno
operator|!=
literal|0
condition|?
name|errno
else|:
name|ENOMEM
operator|)
expr_stmt|;
else|else
name|nvlist_move_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|NVLIST_GET
parameter_list|(
name|ftype
parameter_list|,
name|type
parameter_list|)
define|\
value|ftype									\ nvlist_get_##type(const nvlist_t *nvl, const char *name)		\ {									\ 									\ 	return (nvlist_getf_##type(nvl, "%s", name));			\ }
end_define

begin_macro
name|NVLIST_GET
argument_list|(
argument|const nvpair_t *
argument_list|,
argument|nvpair
argument_list|)
end_macro

begin_macro
name|NVLIST_GET
argument_list|(
argument|bool
argument_list|,
argument|bool
argument_list|)
end_macro

begin_macro
name|NVLIST_GET
argument_list|(
argument|uint64_t
argument_list|,
argument|number
argument_list|)
end_macro

begin_macro
name|NVLIST_GET
argument_list|(
argument|const char *
argument_list|,
argument|string
argument_list|)
end_macro

begin_macro
name|NVLIST_GET
argument_list|(
argument|const nvlist_t *
argument_list|,
argument|nvlist
argument_list|)
end_macro

begin_macro
name|NVLIST_GET
argument_list|(
argument|int
argument_list|,
argument|descriptor
argument_list|)
end_macro

begin_undef
undef|#
directive|undef
name|NVLIST_GET
end_undef

begin_function
specifier|const
name|void
modifier|*
name|nvlist_get_binary
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
return|return
operator|(
name|nvlist_getf_binary
argument_list|(
name|nvl
argument_list|,
name|sizep
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NVLIST_GETF
parameter_list|(
name|ftype
parameter_list|,
name|type
parameter_list|)
define|\
value|ftype									\ nvlist_getf_##type(const nvlist_t *nvl, const char *namefmt, ...)	\ {									\ 	va_list nameap;							\ 	ftype value;							\ 									\ 	va_start(nameap, namefmt);					\ 	value = nvlist_getv_##type(nvl, namefmt, nameap);		\ 	va_end(nameap);							\ 									\ 	return (value);							\ }
end_define

begin_macro
name|NVLIST_GETF
argument_list|(
argument|const nvpair_t *
argument_list|,
argument|nvpair
argument_list|)
end_macro

begin_macro
name|NVLIST_GETF
argument_list|(
argument|bool
argument_list|,
argument|bool
argument_list|)
end_macro

begin_macro
name|NVLIST_GETF
argument_list|(
argument|uint64_t
argument_list|,
argument|number
argument_list|)
end_macro

begin_macro
name|NVLIST_GETF
argument_list|(
argument|const char *
argument_list|,
argument|string
argument_list|)
end_macro

begin_macro
name|NVLIST_GETF
argument_list|(
argument|const nvlist_t *
argument_list|,
argument|nvlist
argument_list|)
end_macro

begin_macro
name|NVLIST_GETF
argument_list|(
argument|int
argument_list|,
argument|descriptor
argument_list|)
end_macro

begin_undef
undef|#
directive|undef
name|NVLIST_GETF
end_undef

begin_function
specifier|const
name|void
modifier|*
name|nvlist_getf_binary
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|,
specifier|const
name|char
modifier|*
name|namefmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|nameap
decl_stmt|;
specifier|const
name|void
modifier|*
name|value
decl_stmt|;
name|va_start
argument_list|(
name|nameap
argument_list|,
name|namefmt
argument_list|)
expr_stmt|;
name|value
operator|=
name|nvlist_getv_binary
argument_list|(
name|nvl
argument_list|,
name|sizep
argument_list|,
name|namefmt
argument_list|,
name|nameap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|nameap
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_function
specifier|const
name|nvpair_t
modifier|*
name|nvlist_getv_nvpair
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|namefmt
parameter_list|,
name|va_list
name|nameap
parameter_list|)
block|{
return|return
operator|(
name|nvlist_findv
argument_list|(
name|nvl
argument_list|,
name|NV_TYPE_NONE
argument_list|,
name|namefmt
argument_list|,
name|nameap
argument_list|)
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NVLIST_GETV
parameter_list|(
name|ftype
parameter_list|,
name|type
parameter_list|,
name|TYPE
parameter_list|)
define|\
value|ftype									\ nvlist_getv_##type(const nvlist_t *nvl, const char *namefmt,		\     va_list nameap)							\ {									\ 	va_list cnameap;						\ 	const nvpair_t *nvp;						\ 									\ 	va_copy(cnameap, nameap);					\ 	nvp = nvlist_findv(nvl, NV_TYPE_##TYPE, namefmt, cnameap);	\ 	va_end(cnameap);						\ 	if (nvp == NULL)						\ 		nvlist_report_missing(NV_TYPE_##TYPE, namefmt, nameap);	\ 	return (nvpair_get_##type(nvp));				\ }
end_define

begin_macro
name|NVLIST_GETV
argument_list|(
argument|bool
argument_list|,
argument|bool
argument_list|,
argument|BOOL
argument_list|)
end_macro

begin_macro
name|NVLIST_GETV
argument_list|(
argument|uint64_t
argument_list|,
argument|number
argument_list|,
argument|NUMBER
argument_list|)
end_macro

begin_macro
name|NVLIST_GETV
argument_list|(
argument|const char *
argument_list|,
argument|string
argument_list|,
argument|STRING
argument_list|)
end_macro

begin_macro
name|NVLIST_GETV
argument_list|(
argument|const nvlist_t *
argument_list|,
argument|nvlist
argument_list|,
argument|NVLIST
argument_list|)
end_macro

begin_macro
name|NVLIST_GETV
argument_list|(
argument|int
argument_list|,
argument|descriptor
argument_list|,
argument|DESCRIPTOR
argument_list|)
end_macro

begin_undef
undef|#
directive|undef
name|NVLIST_GETV
end_undef

begin_function
specifier|const
name|void
modifier|*
name|nvlist_getv_binary
parameter_list|(
specifier|const
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|,
specifier|const
name|char
modifier|*
name|namefmt
parameter_list|,
name|va_list
name|nameap
parameter_list|)
block|{
name|va_list
name|cnameap
decl_stmt|;
specifier|const
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
name|va_copy
argument_list|(
name|cnameap
argument_list|,
name|nameap
argument_list|)
expr_stmt|;
name|nvp
operator|=
name|nvlist_findv
argument_list|(
name|nvl
argument_list|,
name|NV_TYPE_BINARY
argument_list|,
name|namefmt
argument_list|,
name|cnameap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|cnameap
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvp
operator|==
name|NULL
condition|)
name|nvlist_report_missing
argument_list|(
name|NV_TYPE_BINARY
argument_list|,
name|namefmt
argument_list|,
name|nameap
argument_list|)
expr_stmt|;
return|return
operator|(
name|nvpair_get_binary
argument_list|(
name|nvp
argument_list|,
name|sizep
argument_list|)
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NVLIST_TAKE
parameter_list|(
name|ftype
parameter_list|,
name|type
parameter_list|)
define|\
value|ftype									\ nvlist_take_##type(nvlist_t *nvl, const char *name)			\ {									\ 									\ 	return (nvlist_takef_##type(nvl, "%s", name));			\ }
end_define

begin_macro
name|NVLIST_TAKE
argument_list|(
argument|nvpair_t *
argument_list|,
argument|nvpair
argument_list|)
end_macro

begin_macro
name|NVLIST_TAKE
argument_list|(
argument|bool
argument_list|,
argument|bool
argument_list|)
end_macro

begin_macro
name|NVLIST_TAKE
argument_list|(
argument|uint64_t
argument_list|,
argument|number
argument_list|)
end_macro

begin_macro
name|NVLIST_TAKE
argument_list|(
argument|char *
argument_list|,
argument|string
argument_list|)
end_macro

begin_macro
name|NVLIST_TAKE
argument_list|(
argument|nvlist_t *
argument_list|,
argument|nvlist
argument_list|)
end_macro

begin_macro
name|NVLIST_TAKE
argument_list|(
argument|int
argument_list|,
argument|descriptor
argument_list|)
end_macro

begin_undef
undef|#
directive|undef
name|NVLIST_TAKE
end_undef

begin_function
name|void
modifier|*
name|nvlist_take_binary
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|)
block|{
return|return
operator|(
name|nvlist_takef_binary
argument_list|(
name|nvl
argument_list|,
name|sizep
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NVLIST_TAKEF
parameter_list|(
name|ftype
parameter_list|,
name|type
parameter_list|)
define|\
value|ftype									\ nvlist_takef_##type(nvlist_t *nvl, const char *namefmt, ...)		\ {									\ 	va_list nameap;							\ 	ftype value;							\ 									\ 	va_start(nameap, namefmt);					\ 	value = nvlist_takev_##type(nvl, namefmt, nameap);		\ 	va_end(nameap);							\ 									\ 	return (value);							\ }
end_define

begin_macro
name|NVLIST_TAKEF
argument_list|(
argument|nvpair_t *
argument_list|,
argument|nvpair
argument_list|)
end_macro

begin_macro
name|NVLIST_TAKEF
argument_list|(
argument|bool
argument_list|,
argument|bool
argument_list|)
end_macro

begin_macro
name|NVLIST_TAKEF
argument_list|(
argument|uint64_t
argument_list|,
argument|number
argument_list|)
end_macro

begin_macro
name|NVLIST_TAKEF
argument_list|(
argument|char *
argument_list|,
argument|string
argument_list|)
end_macro

begin_macro
name|NVLIST_TAKEF
argument_list|(
argument|nvlist_t *
argument_list|,
argument|nvlist
argument_list|)
end_macro

begin_macro
name|NVLIST_TAKEF
argument_list|(
argument|int
argument_list|,
argument|descriptor
argument_list|)
end_macro

begin_undef
undef|#
directive|undef
name|NVLIST_TAKEF
end_undef

begin_function
name|void
modifier|*
name|nvlist_takef_binary
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|,
specifier|const
name|char
modifier|*
name|namefmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|nameap
decl_stmt|;
name|void
modifier|*
name|value
decl_stmt|;
name|va_start
argument_list|(
name|nameap
argument_list|,
name|namefmt
argument_list|)
expr_stmt|;
name|value
operator|=
name|nvlist_takev_binary
argument_list|(
name|nvl
argument_list|,
name|sizep
argument_list|,
name|namefmt
argument_list|,
name|nameap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|nameap
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_function
name|nvpair_t
modifier|*
name|nvlist_takev_nvpair
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|namefmt
parameter_list|,
name|va_list
name|nameap
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
name|nvp
operator|=
name|nvlist_findv
argument_list|(
name|nvl
argument_list|,
name|NV_TYPE_NONE
argument_list|,
name|namefmt
argument_list|,
name|nameap
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvp
operator|!=
name|NULL
condition|)
name|nvlist_remove_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|nvp
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|NVLIST_TAKEV
parameter_list|(
name|ftype
parameter_list|,
name|type
parameter_list|,
name|TYPE
parameter_list|)
define|\
value|ftype									\ nvlist_takev_##type(nvlist_t *nvl, const char *namefmt, va_list nameap)	\ {									\ 	va_list cnameap;						\ 	nvpair_t *nvp;							\ 	ftype value;							\ 									\ 	va_copy(cnameap, nameap);					\ 	nvp = nvlist_findv(nvl, NV_TYPE_##TYPE, namefmt, cnameap);	\ 	va_end(cnameap);						\ 	if (nvp == NULL)						\ 		nvlist_report_missing(NV_TYPE_##TYPE, namefmt, nameap);	\ 	value = (ftype)(intptr_t)nvpair_get_##type(nvp);		\ 	nvlist_remove_nvpair(nvl, nvp);					\ 	nvpair_free_structure(nvp);					\ 	return (value);							\ }
end_define

begin_macro
name|NVLIST_TAKEV
argument_list|(
argument|bool
argument_list|,
argument|bool
argument_list|,
argument|BOOL
argument_list|)
end_macro

begin_macro
name|NVLIST_TAKEV
argument_list|(
argument|uint64_t
argument_list|,
argument|number
argument_list|,
argument|NUMBER
argument_list|)
end_macro

begin_macro
name|NVLIST_TAKEV
argument_list|(
argument|char *
argument_list|,
argument|string
argument_list|,
argument|STRING
argument_list|)
end_macro

begin_macro
name|NVLIST_TAKEV
argument_list|(
argument|nvlist_t *
argument_list|,
argument|nvlist
argument_list|,
argument|NVLIST
argument_list|)
end_macro

begin_macro
name|NVLIST_TAKEV
argument_list|(
argument|int
argument_list|,
argument|descriptor
argument_list|,
argument|DESCRIPTOR
argument_list|)
end_macro

begin_undef
undef|#
directive|undef
name|NVLIST_TAKEV
end_undef

begin_function
name|void
modifier|*
name|nvlist_takev_binary
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|size_t
modifier|*
name|sizep
parameter_list|,
specifier|const
name|char
modifier|*
name|namefmt
parameter_list|,
name|va_list
name|nameap
parameter_list|)
block|{
name|va_list
name|cnameap
decl_stmt|;
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
name|void
modifier|*
name|value
decl_stmt|;
name|va_copy
argument_list|(
name|cnameap
argument_list|,
name|nameap
argument_list|)
expr_stmt|;
name|nvp
operator|=
name|nvlist_findv
argument_list|(
name|nvl
argument_list|,
name|NV_TYPE_BINARY
argument_list|,
name|namefmt
argument_list|,
name|cnameap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|cnameap
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvp
operator|==
name|NULL
condition|)
name|nvlist_report_missing
argument_list|(
name|NV_TYPE_BINARY
argument_list|,
name|namefmt
argument_list|,
name|nameap
argument_list|)
expr_stmt|;
name|value
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
name|intptr_t
operator|)
name|nvpair_get_binary
argument_list|(
name|nvp
argument_list|,
name|sizep
argument_list|)
expr_stmt|;
name|nvlist_remove_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
name|nvpair_free_structure
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_function
name|void
name|nvlist_remove_nvpair
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|nvpair_t
modifier|*
name|nvp
parameter_list|)
block|{
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|NVPAIR_ASSERT
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|nvpair_nvlist
argument_list|(
name|nvp
argument_list|)
operator|==
name|nvl
argument_list|)
expr_stmt|;
name|nvpair_remove
argument_list|(
operator|&
name|nvl
operator|->
name|nvl_head
argument_list|,
name|nvp
argument_list|,
name|nvl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nvlist_free
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|nvlist_freef
argument_list|(
name|nvl
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|NVLIST_FREE
parameter_list|(
name|type
parameter_list|)
define|\
value|void									\ nvlist_free_##type(nvlist_t *nvl, const char *name)			\ {									\ 									\ 	nvlist_freef_##type(nvl, "%s", name);				\ }
end_define

begin_macro
name|NVLIST_FREE
argument_list|(
argument|null
argument_list|)
end_macro

begin_macro
name|NVLIST_FREE
argument_list|(
argument|bool
argument_list|)
end_macro

begin_macro
name|NVLIST_FREE
argument_list|(
argument|number
argument_list|)
end_macro

begin_macro
name|NVLIST_FREE
argument_list|(
argument|string
argument_list|)
end_macro

begin_macro
name|NVLIST_FREE
argument_list|(
argument|nvlist
argument_list|)
end_macro

begin_macro
name|NVLIST_FREE
argument_list|(
argument|descriptor
argument_list|)
end_macro

begin_macro
name|NVLIST_FREE
argument_list|(
argument|binary
argument_list|)
end_macro

begin_undef
undef|#
directive|undef
name|NVLIST_FREE
end_undef

begin_function
name|void
name|nvlist_freef
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|namefmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|nameap
decl_stmt|;
name|va_start
argument_list|(
name|nameap
argument_list|,
name|namefmt
argument_list|)
expr_stmt|;
name|nvlist_freev
argument_list|(
name|nvl
argument_list|,
name|namefmt
argument_list|,
name|nameap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|nameap
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|NVLIST_FREEF
parameter_list|(
name|type
parameter_list|)
define|\
value|void									\ nvlist_freef_##type(nvlist_t *nvl, const char *namefmt, ...)		\ {									\ 	va_list nameap;							\ 									\ 	va_start(nameap, namefmt);					\ 	nvlist_freev_##type(nvl, namefmt, nameap);			\ 	va_end(nameap);							\ }
end_define

begin_macro
name|NVLIST_FREEF
argument_list|(
argument|null
argument_list|)
end_macro

begin_macro
name|NVLIST_FREEF
argument_list|(
argument|bool
argument_list|)
end_macro

begin_macro
name|NVLIST_FREEF
argument_list|(
argument|number
argument_list|)
end_macro

begin_macro
name|NVLIST_FREEF
argument_list|(
argument|string
argument_list|)
end_macro

begin_macro
name|NVLIST_FREEF
argument_list|(
argument|nvlist
argument_list|)
end_macro

begin_macro
name|NVLIST_FREEF
argument_list|(
argument|descriptor
argument_list|)
end_macro

begin_macro
name|NVLIST_FREEF
argument_list|(
argument|binary
argument_list|)
end_macro

begin_undef
undef|#
directive|undef
name|NVLIST_FREEF
end_undef

begin_function
name|void
name|nvlist_freev
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|namefmt
parameter_list|,
name|va_list
name|nameap
parameter_list|)
block|{
name|nvlist_freev_type
argument_list|(
name|nvl
argument_list|,
name|NV_TYPE_NONE
argument_list|,
name|namefmt
argument_list|,
name|nameap
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|NVLIST_FREEV
parameter_list|(
name|type
parameter_list|,
name|TYPE
parameter_list|)
define|\
value|void									\ nvlist_freev_##type(nvlist_t *nvl, const char *namefmt, va_list nameap)	\ {									\ 									\ 	nvlist_freev_type(nvl, NV_TYPE_##TYPE, namefmt, nameap);	\ }
end_define

begin_macro
name|NVLIST_FREEV
argument_list|(
argument|null
argument_list|,
argument|NULL
argument_list|)
end_macro

begin_macro
name|NVLIST_FREEV
argument_list|(
argument|bool
argument_list|,
argument|BOOL
argument_list|)
end_macro

begin_macro
name|NVLIST_FREEV
argument_list|(
argument|number
argument_list|,
argument|NUMBER
argument_list|)
end_macro

begin_macro
name|NVLIST_FREEV
argument_list|(
argument|string
argument_list|,
argument|STRING
argument_list|)
end_macro

begin_macro
name|NVLIST_FREEV
argument_list|(
argument|nvlist
argument_list|,
argument|NVLIST
argument_list|)
end_macro

begin_macro
name|NVLIST_FREEV
argument_list|(
argument|descriptor
argument_list|,
argument|DESCRIPTOR
argument_list|)
end_macro

begin_macro
name|NVLIST_FREEV
argument_list|(
argument|binary
argument_list|,
argument|BINARY
argument_list|)
end_macro

begin_undef
undef|#
directive|undef
name|NVLIST_FREEV
end_undef

begin_function
name|void
name|nvlist_free_nvpair
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|nvpair_t
modifier|*
name|nvp
parameter_list|)
block|{
name|NVLIST_ASSERT
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
name|NVPAIR_ASSERT
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
name|PJDLOG_ASSERT
argument_list|(
name|nvpair_nvlist
argument_list|(
name|nvp
argument_list|)
operator|==
name|nvl
argument_list|)
expr_stmt|;
name|nvlist_remove_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
name|nvpair_free
argument_list|(
name|nvp
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

