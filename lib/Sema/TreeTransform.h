begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===------- TreeTransform.h - Semantic Tree Transformation -----*- C++ -*-===/
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===/
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file implements a semantic tree transformation that takes a given
end_comment

begin_comment
comment|//  AST and rebuilds it, possibly transforming some nodes in the process.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_SEMA_TREETRANSFORM_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_SEMA_TREETRANSFORM_H
end_define

begin_include
include|#
directive|include
file|"Sema.h"
end_include

begin_include
include|#
directive|include
file|"Lookup.h"
end_include

begin_include
include|#
directive|include
file|"clang/Sema/SemaDiagnostic.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/Decl.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/Expr.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/ExprCXX.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/ExprObjC.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/Stmt.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/StmtCXX.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/StmtObjC.h"
end_include

begin_include
include|#
directive|include
file|"clang/AST/TypeLocBuilder.h"
end_include

begin_include
include|#
directive|include
file|"clang/Parse/Ownership.h"
end_include

begin_include
include|#
directive|include
file|"clang/Parse/Designator.h"
end_include

begin_include
include|#
directive|include
file|"clang/Lex/Preprocessor.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ErrorHandling.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
comment|/// \brief A semantic tree transformation that allows one to transform one
comment|/// abstract syntax tree into another.
comment|///
comment|/// A new tree transformation is defined by creating a new subclass \c X of
comment|/// \c TreeTransform<X> and then overriding certain operations to provide
comment|/// behavior specific to that transformation. For example, template
comment|/// instantiation is implemented as a tree transformation where the
comment|/// transformation of TemplateTypeParmType nodes involves substituting the
comment|/// template arguments for their corresponding template parameters; a similar
comment|/// transformation is performed for non-type template parameters and
comment|/// template template parameters.
comment|///
comment|/// This tree-transformation template uses static polymorphism to allow
comment|/// subclasses to customize any of its operations. Thus, a subclass can
comment|/// override any of the transformation or rebuild operators by providing an
comment|/// operation with the same signature as the default implementation. The
comment|/// overridding function should not be virtual.
comment|///
comment|/// Semantic tree transformations are split into two stages, either of which
comment|/// can be replaced by a subclass. The "transform" step transforms an AST node
comment|/// or the parts of an AST node using the various transformation functions,
comment|/// then passes the pieces on to the "rebuild" step, which constructs a new AST
comment|/// node of the appropriate kind from the pieces. The default transformation
comment|/// routines recursively transform the operands to composite AST nodes (e.g.,
comment|/// the pointee type of a PointerType node) and, if any of those operand nodes
comment|/// were changed by the transformation, invokes the rebuild operation to create
comment|/// a new AST node.
comment|///
comment|/// Subclasses can customize the transformation at various levels. The
comment|/// most coarse-grained transformations involve replacing TransformType(),
comment|/// TransformExpr(), TransformDecl(), TransformNestedNameSpecifier(),
comment|/// TransformTemplateName(), or TransformTemplateArgument() with entirely
comment|/// new implementations.
comment|///
comment|/// For more fine-grained transformations, subclasses can replace any of the
comment|/// \c TransformXXX functions (where XXX is the name of an AST node, e.g.,
comment|/// PointerType, StmtExpr) to alter the transformation. As mentioned previously,
comment|/// replacing TransformTemplateTypeParmType() allows template instantiation
comment|/// to substitute template arguments for their corresponding template
comment|/// parameters. Additionally, subclasses can override the \c RebuildXXX
comment|/// functions to control how AST nodes are rebuilt when their operands change.
comment|/// By default, \c TreeTransform will invoke semantic analysis to rebuild
comment|/// AST nodes. However, certain other tree transformations (e.g, cloning) may
comment|/// be able to use more efficient rebuild steps.
comment|///
comment|/// There are a handful of other functions that can be overridden, allowing one
comment|/// to avoid traversing nodes that don't need any transformation
comment|/// (\c AlreadyTransformed()), force rebuilding AST nodes even when their
comment|/// operands have not changed (\c AlwaysRebuild()), and customize the
comment|/// default locations and entity names used for type-checking
comment|/// (\c getBaseLocation(), \c getBaseEntity()).
name|template
operator|<
name|typename
name|Derived
operator|>
name|class
name|TreeTransform
block|{
name|protected
operator|:
name|Sema
operator|&
name|SemaRef
block|;
name|public
operator|:
typedef|typedef
name|Sema
operator|::
name|OwningStmtResult
name|OwningStmtResult
expr_stmt|;
typedef|typedef
name|Sema
operator|::
name|OwningExprResult
name|OwningExprResult
expr_stmt|;
typedef|typedef
name|Sema
operator|::
name|StmtArg
name|StmtArg
expr_stmt|;
typedef|typedef
name|Sema
operator|::
name|ExprArg
name|ExprArg
expr_stmt|;
typedef|typedef
name|Sema
operator|::
name|MultiExprArg
name|MultiExprArg
expr_stmt|;
typedef|typedef
name|Sema
operator|::
name|MultiStmtArg
name|MultiStmtArg
expr_stmt|;
typedef|typedef
name|Sema
operator|::
name|DeclPtrTy
name|DeclPtrTy
expr_stmt|;
comment|/// \brief Initializes a new tree transformer.
name|TreeTransform
argument_list|(
name|Sema
operator|&
name|SemaRef
argument_list|)
operator|:
name|SemaRef
argument_list|(
argument|SemaRef
argument_list|)
block|{ }
comment|/// \brief Retrieves a reference to the derived class.
name|Derived
operator|&
name|getDerived
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|Derived
operator|&
operator|>
operator|(
operator|*
name|this
operator|)
return|;
block|}
comment|/// \brief Retrieves a reference to the derived class.
specifier|const
name|Derived
operator|&
name|getDerived
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
specifier|const
name|Derived
operator|&
operator|>
operator|(
operator|*
name|this
operator|)
return|;
block|}
comment|/// \brief Retrieves a reference to the semantic analysis object used for
comment|/// this tree transform.
name|Sema
operator|&
name|getSema
argument_list|()
specifier|const
block|{
return|return
name|SemaRef
return|;
block|}
comment|/// \brief Whether the transformation should always rebuild AST nodes, even
comment|/// if none of the children have changed.
comment|///
comment|/// Subclasses may override this function to specify when the transformation
comment|/// should rebuild all AST nodes.
name|bool
name|AlwaysRebuild
parameter_list|()
block|{
return|return
name|false
return|;
block|}
comment|/// \brief Returns the location of the entity being transformed, if that
comment|/// information was not available elsewhere in the AST.
comment|///
comment|/// By default, returns no source-location information. Subclasses can
comment|/// provide an alternative implementation that provides better location
comment|/// information.
name|SourceLocation
name|getBaseLocation
parameter_list|()
block|{
return|return
name|SourceLocation
argument_list|()
return|;
block|}
comment|/// \brief Returns the name of the entity being transformed, if that
comment|/// information was not available elsewhere in the AST.
comment|///
comment|/// By default, returns an empty name. Subclasses can provide an alternative
comment|/// implementation with a more precise name.
name|DeclarationName
name|getBaseEntity
parameter_list|()
block|{
return|return
name|DeclarationName
argument_list|()
return|;
block|}
comment|/// \brief Sets the "base" location and entity when that
comment|/// information is known based on another transformation.
comment|///
comment|/// By default, the source location and entity are ignored. Subclasses can
comment|/// override this function to provide a customized implementation.
name|void
name|setBase
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
name|DeclarationName
name|Entity
parameter_list|)
block|{ }
comment|/// \brief RAII object that temporarily sets the base location and entity
comment|/// used for reporting diagnostics in types.
name|class
name|TemporaryBase
block|{
name|TreeTransform
modifier|&
name|Self
decl_stmt|;
name|SourceLocation
name|OldLocation
decl_stmt|;
name|DeclarationName
name|OldEntity
decl_stmt|;
name|public
label|:
name|TemporaryBase
argument_list|(
argument|TreeTransform&Self
argument_list|,
argument|SourceLocation Location
argument_list|,
argument|DeclarationName Entity
argument_list|)
block|:
name|Self
argument_list|(
argument|Self
argument_list|)
block|{
name|OldLocation
operator|=
name|Self
operator|.
name|getDerived
argument_list|()
operator|.
name|getBaseLocation
argument_list|()
expr_stmt|;
name|OldEntity
operator|=
name|Self
operator|.
name|getDerived
argument_list|()
operator|.
name|getBaseEntity
argument_list|()
expr_stmt|;
name|Self
operator|.
name|getDerived
argument_list|()
operator|.
name|setBase
argument_list|(
name|Location
argument_list|,
name|Entity
argument_list|)
expr_stmt|;
block|}
operator|~
name|TemporaryBase
argument_list|()
block|{
name|Self
operator|.
name|getDerived
argument_list|()
operator|.
name|setBase
argument_list|(
name|OldLocation
argument_list|,
name|OldEntity
argument_list|)
block|;     }
block|}
empty_stmt|;
comment|/// \brief Determine whether the given type \p T has already been
comment|/// transformed.
comment|///
comment|/// Subclasses can provide an alternative implementation of this routine
comment|/// to short-circuit evaluation when it is known that a given type will
comment|/// not change. For example, template instantiation need not traverse
comment|/// non-dependent types.
name|bool
name|AlreadyTransformed
parameter_list|(
name|QualType
name|T
parameter_list|)
block|{
return|return
name|T
operator|.
name|isNull
argument_list|()
return|;
block|}
comment|/// \brief Determine whether the given call argument should be dropped, e.g.,
comment|/// because it is a default argument.
comment|///
comment|/// Subclasses can provide an alternative implementation of this routine to
comment|/// determine which kinds of call arguments get dropped. By default,
comment|/// CXXDefaultArgument nodes are dropped (prior to transformation).
name|bool
name|DropCallArgument
parameter_list|(
name|Expr
modifier|*
name|E
parameter_list|)
block|{
return|return
name|E
operator|->
name|isDefaultArgument
argument_list|()
return|;
block|}
comment|/// \brief Transforms the given type into another type.
comment|///
comment|/// By default, this routine transforms a type by creating a
comment|/// TypeSourceInfo for it and delegating to the appropriate
comment|/// function.  This is expensive, but we don't mind, because
comment|/// this method is deprecated anyway;  all users should be
comment|/// switched to storing TypeSourceInfos.
comment|///
comment|/// \returns the transformed type.
name|QualType
name|TransformType
parameter_list|(
name|QualType
name|T
parameter_list|,
name|QualType
name|ObjectType
init|=
name|QualType
argument_list|()
parameter_list|)
function_decl|;
comment|/// \brief Transforms the given type-with-location into a new
comment|/// type-with-location.
comment|///
comment|/// By default, this routine transforms a type by delegating to the
comment|/// appropriate TransformXXXType to build a new type.  Subclasses
comment|/// may override this function (to take over all type
comment|/// transformations) or some set of the TransformXXXType functions
comment|/// to alter the transformation.
name|TypeSourceInfo
modifier|*
name|TransformType
parameter_list|(
name|TypeSourceInfo
modifier|*
name|DI
parameter_list|,
name|QualType
name|ObjectType
init|=
name|QualType
argument_list|()
parameter_list|)
function_decl|;
comment|/// \brief Transform the given type-with-location into a new
comment|/// type, collecting location information in the given builder
comment|/// as necessary.
comment|///
name|QualType
name|TransformType
parameter_list|(
name|TypeLocBuilder
modifier|&
name|TLB
parameter_list|,
name|TypeLoc
name|TL
parameter_list|,
name|QualType
name|ObjectType
init|=
name|QualType
argument_list|()
parameter_list|)
function_decl|;
comment|/// \brief Transform the given statement.
comment|///
comment|/// By default, this routine transforms a statement by delegating to the
comment|/// appropriate TransformXXXStmt function to transform a specific kind of
comment|/// statement or the TransformExpr() function to transform an expression.
comment|/// Subclasses may override this function to transform statements using some
comment|/// other mechanism.
comment|///
comment|/// \returns the transformed statement.
name|OwningStmtResult
name|TransformStmt
parameter_list|(
name|Stmt
modifier|*
name|S
parameter_list|)
function_decl|;
comment|/// \brief Transform the given expression.
comment|///
comment|/// By default, this routine transforms an expression by delegating to the
comment|/// appropriate TransformXXXExpr function to build a new expression.
comment|/// Subclasses may override this function to transform expressions using some
comment|/// other mechanism.
comment|///
comment|/// \returns the transformed expression.
name|OwningExprResult
name|TransformExpr
parameter_list|(
name|Expr
modifier|*
name|E
parameter_list|)
function_decl|;
comment|/// \brief Transform the given declaration, which is referenced from a type
comment|/// or expression.
comment|///
comment|/// By default, acts as the identity function on declarations. Subclasses
comment|/// may override this function to provide alternate behavior.
name|Decl
modifier|*
name|TransformDecl
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
name|Decl
modifier|*
name|D
parameter_list|)
block|{
return|return
name|D
return|;
block|}
comment|/// \brief Transform the definition of the given declaration.
comment|///
comment|/// By default, invokes TransformDecl() to transform the declaration.
comment|/// Subclasses may override this function to provide alternate behavior.
name|Decl
modifier|*
name|TransformDefinition
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
name|Decl
modifier|*
name|D
parameter_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|Loc
argument_list|,
name|D
argument_list|)
return|;
block|}
comment|/// \brief Transform the given declaration, which was the first part of a
comment|/// nested-name-specifier in a member access expression.
comment|///
comment|/// This specific declaration transformation only applies to the first
comment|/// identifier in a nested-name-specifier of a member access expression, e.g.,
comment|/// the \c T in \c x->T::member
comment|///
comment|/// By default, invokes TransformDecl() to transform the declaration.
comment|/// Subclasses may override this function to provide alternate behavior.
name|NamedDecl
modifier|*
name|TransformFirstQualifierInScope
parameter_list|(
name|NamedDecl
modifier|*
name|D
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|)
block|{
return|return
name|cast_or_null
operator|<
name|NamedDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|Loc
argument_list|,
name|D
argument_list|)
operator|)
return|;
block|}
comment|/// \brief Transform the given nested-name-specifier.
comment|///
comment|/// By default, transforms all of the types and declarations within the
comment|/// nested-name-specifier. Subclasses may override this function to provide
comment|/// alternate behavior.
name|NestedNameSpecifier
modifier|*
name|TransformNestedNameSpecifier
parameter_list|(
name|NestedNameSpecifier
modifier|*
name|NNS
parameter_list|,
name|SourceRange
name|Range
parameter_list|,
name|QualType
name|ObjectType
init|=
name|QualType
argument_list|()
parameter_list|,
name|NamedDecl
modifier|*
name|FirstQualifierInScope
init|=
literal|0
parameter_list|)
function_decl|;
comment|/// \brief Transform the given declaration name.
comment|///
comment|/// By default, transforms the types of conversion function, constructor,
comment|/// and destructor names and then (if needed) rebuilds the declaration name.
comment|/// Identifiers and selectors are returned unmodified. Sublcasses may
comment|/// override this function to provide alternate behavior.
name|DeclarationName
name|TransformDeclarationName
parameter_list|(
name|DeclarationName
name|Name
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
name|QualType
name|ObjectType
init|=
name|QualType
argument_list|()
parameter_list|)
function_decl|;
comment|/// \brief Transform the given template name.
comment|///
comment|/// By default, transforms the template name by transforming the declarations
comment|/// and nested-name-specifiers that occur within the template name.
comment|/// Subclasses may override this function to provide alternate behavior.
name|TemplateName
name|TransformTemplateName
parameter_list|(
name|TemplateName
name|Name
parameter_list|,
name|QualType
name|ObjectType
init|=
name|QualType
argument_list|()
parameter_list|)
function_decl|;
comment|/// \brief Transform the given template argument.
comment|///
comment|/// By default, this operation transforms the type, expression, or
comment|/// declaration stored within the template argument and constructs a
comment|/// new template argument from the transformed result. Subclasses may
comment|/// override this function to provide alternate behavior.
comment|///
comment|/// Returns true if there was an error.
name|bool
name|TransformTemplateArgument
parameter_list|(
specifier|const
name|TemplateArgumentLoc
modifier|&
name|Input
parameter_list|,
name|TemplateArgumentLoc
modifier|&
name|Output
parameter_list|)
function_decl|;
comment|/// \brief Fakes up a TemplateArgumentLoc for a given TemplateArgument.
name|void
name|InventTemplateArgumentLoc
parameter_list|(
specifier|const
name|TemplateArgument
modifier|&
name|Arg
parameter_list|,
name|TemplateArgumentLoc
modifier|&
name|ArgLoc
parameter_list|)
function_decl|;
comment|/// \brief Fakes up a TypeSourceInfo for a type.
name|TypeSourceInfo
modifier|*
name|InventTypeSourceInfo
parameter_list|(
name|QualType
name|T
parameter_list|)
block|{
return|return
name|SemaRef
operator|.
name|Context
operator|.
name|getTrivialTypeSourceInfo
argument_list|(
name|T
argument_list|,
name|getDerived
argument_list|()
operator|.
name|getBaseLocation
argument_list|()
argument_list|)
return|;
block|}
define|#
directive|define
name|ABSTRACT_TYPELOC
parameter_list|(
name|CLASS
parameter_list|,
name|PARENT
parameter_list|)
define|#
directive|define
name|TYPELOC
parameter_list|(
name|CLASS
parameter_list|,
name|PARENT
parameter_list|)
define|\
value|QualType Transform##CLASS##Type(TypeLocBuilder&TLB, CLASS##TypeLoc T, \                                   QualType ObjectType = QualType());
include|#
directive|include
file|"clang/AST/TypeLocNodes.def"
comment|/// \brief Transforms the parameters of a function type into the
comment|/// given vectors.
comment|///
comment|/// The result vectors should be kept in sync; null entries in the
comment|/// variables vector are acceptable.
comment|///
comment|/// Return true on error.
name|bool
name|TransformFunctionTypeParams
argument_list|(
name|FunctionProtoTypeLoc
name|TL
argument_list|,
name|llvm
operator|::
name|SmallVectorImpl
operator|<
name|QualType
operator|>
operator|&
name|PTypes
argument_list|,
name|llvm
operator|::
name|SmallVectorImpl
operator|<
name|ParmVarDecl
operator|*
operator|>
operator|&
name|PVars
argument_list|)
decl_stmt|;
comment|/// \brief Transforms a single function-type parameter.  Return null
comment|/// on error.
name|ParmVarDecl
modifier|*
name|TransformFunctionTypeParam
parameter_list|(
name|ParmVarDecl
modifier|*
name|OldParm
parameter_list|)
function_decl|;
name|QualType
name|TransformReferenceType
parameter_list|(
name|TypeLocBuilder
modifier|&
name|TLB
parameter_list|,
name|ReferenceTypeLoc
name|TL
parameter_list|,
name|QualType
name|ObjectType
parameter_list|)
function_decl|;
name|QualType
name|TransformTemplateSpecializationType
parameter_list|(
specifier|const
name|TemplateSpecializationType
modifier|*
name|T
parameter_list|,
name|QualType
name|ObjectType
parameter_list|)
function_decl|;
name|OwningStmtResult
name|TransformCompoundStmt
parameter_list|(
name|CompoundStmt
modifier|*
name|S
parameter_list|,
name|bool
name|IsStmtExpr
parameter_list|)
function_decl|;
define|#
directive|define
name|STMT
parameter_list|(
name|Node
parameter_list|,
name|Parent
parameter_list|)
define|\
value|OwningStmtResult Transform##Node(Node *S);
define|#
directive|define
name|EXPR
parameter_list|(
name|Node
parameter_list|,
name|Parent
parameter_list|)
define|\
value|OwningExprResult Transform##Node(Node *E);
define|#
directive|define
name|ABSTRACT_EXPR
parameter_list|(
name|Node
parameter_list|,
name|Parent
parameter_list|)
include|#
directive|include
file|"clang/AST/StmtNodes.def"
comment|/// \brief Build a new pointer type given its pointee type.
comment|///
comment|/// By default, performs semantic analysis when building the pointer type.
comment|/// Subclasses may override this routine to provide different behavior.
name|QualType
name|RebuildPointerType
parameter_list|(
name|QualType
name|PointeeType
parameter_list|,
name|SourceLocation
name|Sigil
parameter_list|)
function_decl|;
comment|/// \brief Build a new block pointer type given its pointee type.
comment|///
comment|/// By default, performs semantic analysis when building the block pointer
comment|/// type. Subclasses may override this routine to provide different behavior.
name|QualType
name|RebuildBlockPointerType
parameter_list|(
name|QualType
name|PointeeType
parameter_list|,
name|SourceLocation
name|Sigil
parameter_list|)
function_decl|;
comment|/// \brief Build a new reference type given the type it references.
comment|///
comment|/// By default, performs semantic analysis when building the
comment|/// reference type. Subclasses may override this routine to provide
comment|/// different behavior.
comment|///
comment|/// \param LValue whether the type was written with an lvalue sigil
comment|/// or an rvalue sigil.
name|QualType
name|RebuildReferenceType
parameter_list|(
name|QualType
name|ReferentType
parameter_list|,
name|bool
name|LValue
parameter_list|,
name|SourceLocation
name|Sigil
parameter_list|)
function_decl|;
comment|/// \brief Build a new member pointer type given the pointee type and the
comment|/// class type it refers into.
comment|///
comment|/// By default, performs semantic analysis when building the member pointer
comment|/// type. Subclasses may override this routine to provide different behavior.
name|QualType
name|RebuildMemberPointerType
parameter_list|(
name|QualType
name|PointeeType
parameter_list|,
name|QualType
name|ClassType
parameter_list|,
name|SourceLocation
name|Sigil
parameter_list|)
function_decl|;
comment|/// \brief Build a new Objective C object pointer type.
name|QualType
name|RebuildObjCObjectPointerType
parameter_list|(
name|QualType
name|PointeeType
parameter_list|,
name|SourceLocation
name|Sigil
parameter_list|)
function_decl|;
comment|/// \brief Build a new array type given the element type, size
comment|/// modifier, size of the array (if known), size expression, and index type
comment|/// qualifiers.
comment|///
comment|/// By default, performs semantic analysis when building the array type.
comment|/// Subclasses may override this routine to provide different behavior.
comment|/// Also by default, all of the other Rebuild*Array
name|QualType
name|RebuildArrayType
argument_list|(
name|QualType
name|ElementType
argument_list|,
name|ArrayType
operator|::
name|ArraySizeModifier
name|SizeMod
argument_list|,
specifier|const
name|llvm
operator|::
name|APInt
operator|*
name|Size
argument_list|,
name|Expr
operator|*
name|SizeExpr
argument_list|,
name|unsigned
name|IndexTypeQuals
argument_list|,
name|SourceRange
name|BracketsRange
argument_list|)
decl_stmt|;
comment|/// \brief Build a new constant array type given the element type, size
comment|/// modifier, (known) size of the array, and index type qualifiers.
comment|///
comment|/// By default, performs semantic analysis when building the array type.
comment|/// Subclasses may override this routine to provide different behavior.
name|QualType
name|RebuildConstantArrayType
argument_list|(
name|QualType
name|ElementType
argument_list|,
name|ArrayType
operator|::
name|ArraySizeModifier
name|SizeMod
argument_list|,
specifier|const
name|llvm
operator|::
name|APInt
operator|&
name|Size
argument_list|,
name|unsigned
name|IndexTypeQuals
argument_list|,
name|SourceRange
name|BracketsRange
argument_list|)
decl_stmt|;
comment|/// \brief Build a new incomplete array type given the element type, size
comment|/// modifier, and index type qualifiers.
comment|///
comment|/// By default, performs semantic analysis when building the array type.
comment|/// Subclasses may override this routine to provide different behavior.
name|QualType
name|RebuildIncompleteArrayType
argument_list|(
name|QualType
name|ElementType
argument_list|,
name|ArrayType
operator|::
name|ArraySizeModifier
name|SizeMod
argument_list|,
name|unsigned
name|IndexTypeQuals
argument_list|,
name|SourceRange
name|BracketsRange
argument_list|)
decl_stmt|;
comment|/// \brief Build a new variable-length array type given the element type,
comment|/// size modifier, size expression, and index type qualifiers.
comment|///
comment|/// By default, performs semantic analysis when building the array type.
comment|/// Subclasses may override this routine to provide different behavior.
name|QualType
name|RebuildVariableArrayType
argument_list|(
name|QualType
name|ElementType
argument_list|,
name|ArrayType
operator|::
name|ArraySizeModifier
name|SizeMod
argument_list|,
name|ExprArg
name|SizeExpr
argument_list|,
name|unsigned
name|IndexTypeQuals
argument_list|,
name|SourceRange
name|BracketsRange
argument_list|)
decl_stmt|;
comment|/// \brief Build a new dependent-sized array type given the element type,
comment|/// size modifier, size expression, and index type qualifiers.
comment|///
comment|/// By default, performs semantic analysis when building the array type.
comment|/// Subclasses may override this routine to provide different behavior.
name|QualType
name|RebuildDependentSizedArrayType
argument_list|(
name|QualType
name|ElementType
argument_list|,
name|ArrayType
operator|::
name|ArraySizeModifier
name|SizeMod
argument_list|,
name|ExprArg
name|SizeExpr
argument_list|,
name|unsigned
name|IndexTypeQuals
argument_list|,
name|SourceRange
name|BracketsRange
argument_list|)
decl_stmt|;
comment|/// \brief Build a new vector type given the element type and
comment|/// number of elements.
comment|///
comment|/// By default, performs semantic analysis when building the vector type.
comment|/// Subclasses may override this routine to provide different behavior.
name|QualType
name|RebuildVectorType
parameter_list|(
name|QualType
name|ElementType
parameter_list|,
name|unsigned
name|NumElements
parameter_list|,
name|bool
name|IsAltiVec
parameter_list|,
name|bool
name|IsPixel
parameter_list|)
function_decl|;
comment|/// \brief Build a new extended vector type given the element type and
comment|/// number of elements.
comment|///
comment|/// By default, performs semantic analysis when building the vector type.
comment|/// Subclasses may override this routine to provide different behavior.
name|QualType
name|RebuildExtVectorType
parameter_list|(
name|QualType
name|ElementType
parameter_list|,
name|unsigned
name|NumElements
parameter_list|,
name|SourceLocation
name|AttributeLoc
parameter_list|)
function_decl|;
comment|/// \brief Build a new potentially dependently-sized extended vector type
comment|/// given the element type and number of elements.
comment|///
comment|/// By default, performs semantic analysis when building the vector type.
comment|/// Subclasses may override this routine to provide different behavior.
name|QualType
name|RebuildDependentSizedExtVectorType
parameter_list|(
name|QualType
name|ElementType
parameter_list|,
name|ExprArg
name|SizeExpr
parameter_list|,
name|SourceLocation
name|AttributeLoc
parameter_list|)
function_decl|;
comment|/// \brief Build a new function type.
comment|///
comment|/// By default, performs semantic analysis when building the function type.
comment|/// Subclasses may override this routine to provide different behavior.
name|QualType
name|RebuildFunctionProtoType
parameter_list|(
name|QualType
name|T
parameter_list|,
name|QualType
modifier|*
name|ParamTypes
parameter_list|,
name|unsigned
name|NumParamTypes
parameter_list|,
name|bool
name|Variadic
parameter_list|,
name|unsigned
name|Quals
parameter_list|)
function_decl|;
comment|/// \brief Build a new unprototyped function type.
name|QualType
name|RebuildFunctionNoProtoType
parameter_list|(
name|QualType
name|ResultType
parameter_list|)
function_decl|;
comment|/// \brief Rebuild an unresolved typename type, given the decl that
comment|/// the UnresolvedUsingTypenameDecl was transformed to.
name|QualType
name|RebuildUnresolvedUsingType
parameter_list|(
name|Decl
modifier|*
name|D
parameter_list|)
function_decl|;
comment|/// \brief Build a new typedef type.
name|QualType
name|RebuildTypedefType
parameter_list|(
name|TypedefDecl
modifier|*
name|Typedef
parameter_list|)
block|{
return|return
name|SemaRef
operator|.
name|Context
operator|.
name|getTypeDeclType
argument_list|(
name|Typedef
argument_list|)
return|;
block|}
comment|/// \brief Build a new class/struct/union type.
name|QualType
name|RebuildRecordType
parameter_list|(
name|RecordDecl
modifier|*
name|Record
parameter_list|)
block|{
return|return
name|SemaRef
operator|.
name|Context
operator|.
name|getTypeDeclType
argument_list|(
name|Record
argument_list|)
return|;
block|}
comment|/// \brief Build a new Enum type.
name|QualType
name|RebuildEnumType
parameter_list|(
name|EnumDecl
modifier|*
name|Enum
parameter_list|)
block|{
return|return
name|SemaRef
operator|.
name|Context
operator|.
name|getTypeDeclType
argument_list|(
name|Enum
argument_list|)
return|;
block|}
comment|/// \brief Build a new elaborated type.
name|QualType
name|RebuildElaboratedType
argument_list|(
name|QualType
name|T
argument_list|,
name|ElaboratedType
operator|::
name|TagKind
name|Tag
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|Context
operator|.
name|getElaboratedType
argument_list|(
name|T
argument_list|,
name|Tag
argument_list|)
return|;
block|}
comment|/// \brief Build a new typeof(expr) type.
comment|///
comment|/// By default, performs semantic analysis when building the typeof type.
comment|/// Subclasses may override this routine to provide different behavior.
name|QualType
name|RebuildTypeOfExprType
parameter_list|(
name|ExprArg
name|Underlying
parameter_list|)
function_decl|;
comment|/// \brief Build a new typeof(type) type.
comment|///
comment|/// By default, builds a new TypeOfType with the given underlying type.
name|QualType
name|RebuildTypeOfType
parameter_list|(
name|QualType
name|Underlying
parameter_list|)
function_decl|;
comment|/// \brief Build a new C++0x decltype type.
comment|///
comment|/// By default, performs semantic analysis when building the decltype type.
comment|/// Subclasses may override this routine to provide different behavior.
name|QualType
name|RebuildDecltypeType
parameter_list|(
name|ExprArg
name|Underlying
parameter_list|)
function_decl|;
comment|/// \brief Build a new template specialization type.
comment|///
comment|/// By default, performs semantic analysis when building the template
comment|/// specialization type. Subclasses may override this routine to provide
comment|/// different behavior.
name|QualType
name|RebuildTemplateSpecializationType
parameter_list|(
name|TemplateName
name|Template
parameter_list|,
name|SourceLocation
name|TemplateLoc
parameter_list|,
specifier|const
name|TemplateArgumentListInfo
modifier|&
name|Args
parameter_list|)
function_decl|;
comment|/// \brief Build a new qualified name type.
comment|///
comment|/// By default, builds a new QualifiedNameType type from the
comment|/// nested-name-specifier and the named type. Subclasses may override
comment|/// this routine to provide different behavior.
name|QualType
name|RebuildQualifiedNameType
parameter_list|(
name|NestedNameSpecifier
modifier|*
name|NNS
parameter_list|,
name|QualType
name|Named
parameter_list|)
block|{
return|return
name|SemaRef
operator|.
name|Context
operator|.
name|getQualifiedNameType
argument_list|(
name|NNS
argument_list|,
name|Named
argument_list|)
return|;
block|}
comment|/// \brief Build a new typename type that refers to a template-id.
comment|///
comment|/// By default, builds a new TypenameType type from the nested-name-specifier
comment|/// and the given type. Subclasses may override this routine to provide
comment|/// different behavior.
name|QualType
name|RebuildTypenameType
parameter_list|(
name|NestedNameSpecifier
modifier|*
name|NNS
parameter_list|,
name|QualType
name|T
parameter_list|)
block|{
if|if
condition|(
name|NNS
operator|->
name|isDependent
argument_list|()
condition|)
block|{
name|CXXScopeSpec
name|SS
decl_stmt|;
name|SS
operator|.
name|setScopeRep
argument_list|(
name|NNS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SemaRef
operator|.
name|computeDeclContext
argument_list|(
name|SS
argument_list|)
condition|)
return|return
name|SemaRef
operator|.
name|Context
operator|.
name|getTypenameType
argument_list|(
name|NNS
argument_list|,
name|cast
operator|<
name|TemplateSpecializationType
operator|>
operator|(
name|T
operator|)
argument_list|)
return|;
block|}
return|return
name|SemaRef
operator|.
name|Context
operator|.
name|getQualifiedNameType
argument_list|(
name|NNS
argument_list|,
name|T
argument_list|)
return|;
block|}
comment|/// \brief Build a new typename type that refers to an identifier.
comment|///
comment|/// By default, performs semantic analysis when building the typename type
comment|/// (or qualified name type). Subclasses may override this routine to provide
comment|/// different behavior.
name|QualType
name|RebuildTypenameType
parameter_list|(
name|NestedNameSpecifier
modifier|*
name|NNS
parameter_list|,
specifier|const
name|IdentifierInfo
modifier|*
name|Id
parameter_list|,
name|SourceRange
name|SR
parameter_list|)
block|{
return|return
name|SemaRef
operator|.
name|CheckTypenameType
argument_list|(
name|NNS
argument_list|,
operator|*
name|Id
argument_list|,
name|SR
argument_list|)
return|;
block|}
comment|/// \brief Build a new nested-name-specifier given the prefix and an
comment|/// identifier that names the next step in the nested-name-specifier.
comment|///
comment|/// By default, performs semantic analysis when building the new
comment|/// nested-name-specifier. Subclasses may override this routine to provide
comment|/// different behavior.
name|NestedNameSpecifier
modifier|*
name|RebuildNestedNameSpecifier
parameter_list|(
name|NestedNameSpecifier
modifier|*
name|Prefix
parameter_list|,
name|SourceRange
name|Range
parameter_list|,
name|IdentifierInfo
modifier|&
name|II
parameter_list|,
name|QualType
name|ObjectType
parameter_list|,
name|NamedDecl
modifier|*
name|FirstQualifierInScope
parameter_list|)
function_decl|;
comment|/// \brief Build a new nested-name-specifier given the prefix and the
comment|/// namespace named in the next step in the nested-name-specifier.
comment|///
comment|/// By default, performs semantic analysis when building the new
comment|/// nested-name-specifier. Subclasses may override this routine to provide
comment|/// different behavior.
name|NestedNameSpecifier
modifier|*
name|RebuildNestedNameSpecifier
parameter_list|(
name|NestedNameSpecifier
modifier|*
name|Prefix
parameter_list|,
name|SourceRange
name|Range
parameter_list|,
name|NamespaceDecl
modifier|*
name|NS
parameter_list|)
function_decl|;
comment|/// \brief Build a new nested-name-specifier given the prefix and the
comment|/// type named in the next step in the nested-name-specifier.
comment|///
comment|/// By default, performs semantic analysis when building the new
comment|/// nested-name-specifier. Subclasses may override this routine to provide
comment|/// different behavior.
name|NestedNameSpecifier
modifier|*
name|RebuildNestedNameSpecifier
parameter_list|(
name|NestedNameSpecifier
modifier|*
name|Prefix
parameter_list|,
name|SourceRange
name|Range
parameter_list|,
name|bool
name|TemplateKW
parameter_list|,
name|QualType
name|T
parameter_list|)
function_decl|;
comment|/// \brief Build a new template name given a nested name specifier, a flag
comment|/// indicating whether the "template" keyword was provided, and the template
comment|/// that the template name refers to.
comment|///
comment|/// By default, builds the new template name directly. Subclasses may override
comment|/// this routine to provide different behavior.
name|TemplateName
name|RebuildTemplateName
parameter_list|(
name|NestedNameSpecifier
modifier|*
name|Qualifier
parameter_list|,
name|bool
name|TemplateKW
parameter_list|,
name|TemplateDecl
modifier|*
name|Template
parameter_list|)
function_decl|;
comment|/// \brief Build a new template name given a nested name specifier and the
comment|/// name that is referred to as a template.
comment|///
comment|/// By default, performs semantic analysis to determine whether the name can
comment|/// be resolved to a specific template, then builds the appropriate kind of
comment|/// template name. Subclasses may override this routine to provide different
comment|/// behavior.
name|TemplateName
name|RebuildTemplateName
parameter_list|(
name|NestedNameSpecifier
modifier|*
name|Qualifier
parameter_list|,
specifier|const
name|IdentifierInfo
modifier|&
name|II
parameter_list|,
name|QualType
name|ObjectType
parameter_list|)
function_decl|;
comment|/// \brief Build a new template name given a nested name specifier and the
comment|/// overloaded operator name that is referred to as a template.
comment|///
comment|/// By default, performs semantic analysis to determine whether the name can
comment|/// be resolved to a specific template, then builds the appropriate kind of
comment|/// template name. Subclasses may override this routine to provide different
comment|/// behavior.
name|TemplateName
name|RebuildTemplateName
parameter_list|(
name|NestedNameSpecifier
modifier|*
name|Qualifier
parameter_list|,
name|OverloadedOperatorKind
name|Operator
parameter_list|,
name|QualType
name|ObjectType
parameter_list|)
function_decl|;
comment|/// \brief Build a new compound statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningStmtResult
name|RebuildCompoundStmt
parameter_list|(
name|SourceLocation
name|LBraceLoc
parameter_list|,
name|MultiStmtArg
name|Statements
parameter_list|,
name|SourceLocation
name|RBraceLoc
parameter_list|,
name|bool
name|IsStmtExpr
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnCompoundStmt
argument_list|(
name|LBraceLoc
argument_list|,
name|RBraceLoc
argument_list|,
name|move
argument_list|(
name|Statements
argument_list|)
argument_list|,
name|IsStmtExpr
argument_list|)
return|;
block|}
comment|/// \brief Build a new case statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningStmtResult
name|RebuildCaseStmt
parameter_list|(
name|SourceLocation
name|CaseLoc
parameter_list|,
name|ExprArg
name|LHS
parameter_list|,
name|SourceLocation
name|EllipsisLoc
parameter_list|,
name|ExprArg
name|RHS
parameter_list|,
name|SourceLocation
name|ColonLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnCaseStmt
argument_list|(
name|CaseLoc
argument_list|,
name|move
argument_list|(
name|LHS
argument_list|)
argument_list|,
name|EllipsisLoc
argument_list|,
name|move
argument_list|(
name|RHS
argument_list|)
argument_list|,
name|ColonLoc
argument_list|)
return|;
block|}
comment|/// \brief Attach the body to a new case statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningStmtResult
name|RebuildCaseStmtBody
parameter_list|(
name|StmtArg
name|S
parameter_list|,
name|StmtArg
name|Body
parameter_list|)
block|{
name|getSema
argument_list|()
operator|.
name|ActOnCaseStmtBody
argument_list|(
name|S
operator|.
name|get
argument_list|()
argument_list|,
name|move
argument_list|(
name|Body
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|move
argument_list|(
name|S
argument_list|)
return|;
block|}
comment|/// \brief Build a new default statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningStmtResult
name|RebuildDefaultStmt
parameter_list|(
name|SourceLocation
name|DefaultLoc
parameter_list|,
name|SourceLocation
name|ColonLoc
parameter_list|,
name|StmtArg
name|SubStmt
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnDefaultStmt
argument_list|(
name|DefaultLoc
argument_list|,
name|ColonLoc
argument_list|,
name|move
argument_list|(
name|SubStmt
argument_list|)
argument_list|,
comment|/*CurScope=*/
literal|0
argument_list|)
return|;
block|}
comment|/// \brief Build a new label statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningStmtResult
name|RebuildLabelStmt
parameter_list|(
name|SourceLocation
name|IdentLoc
parameter_list|,
name|IdentifierInfo
modifier|*
name|Id
parameter_list|,
name|SourceLocation
name|ColonLoc
parameter_list|,
name|StmtArg
name|SubStmt
parameter_list|)
block|{
return|return
name|SemaRef
operator|.
name|ActOnLabelStmt
argument_list|(
name|IdentLoc
argument_list|,
name|Id
argument_list|,
name|ColonLoc
argument_list|,
name|move
argument_list|(
name|SubStmt
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new "if" statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningStmtResult
name|RebuildIfStmt
argument_list|(
name|SourceLocation
name|IfLoc
argument_list|,
name|Sema
operator|::
name|FullExprArg
name|Cond
argument_list|,
name|VarDecl
operator|*
name|CondVar
argument_list|,
name|StmtArg
name|Then
argument_list|,
name|SourceLocation
name|ElseLoc
argument_list|,
name|StmtArg
name|Else
argument_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnIfStmt
argument_list|(
name|IfLoc
argument_list|,
name|Cond
argument_list|,
name|DeclPtrTy
operator|::
name|make
argument_list|(
name|CondVar
argument_list|)
argument_list|,
name|move
argument_list|(
name|Then
argument_list|)
argument_list|,
name|ElseLoc
argument_list|,
name|move
argument_list|(
name|Else
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Start building a new switch statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningStmtResult
name|RebuildSwitchStmtStart
argument_list|(
name|Sema
operator|::
name|FullExprArg
name|Cond
argument_list|,
name|VarDecl
operator|*
name|CondVar
argument_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnStartOfSwitchStmt
argument_list|(
name|Cond
argument_list|,
name|DeclPtrTy
operator|::
name|make
argument_list|(
name|CondVar
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Attach the body to the switch statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningStmtResult
name|RebuildSwitchStmtBody
parameter_list|(
name|SourceLocation
name|SwitchLoc
parameter_list|,
name|StmtArg
name|Switch
parameter_list|,
name|StmtArg
name|Body
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnFinishSwitchStmt
argument_list|(
name|SwitchLoc
argument_list|,
name|move
argument_list|(
name|Switch
argument_list|)
argument_list|,
name|move
argument_list|(
name|Body
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new while statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningStmtResult
name|RebuildWhileStmt
argument_list|(
name|SourceLocation
name|WhileLoc
argument_list|,
name|Sema
operator|::
name|FullExprArg
name|Cond
argument_list|,
name|VarDecl
operator|*
name|CondVar
argument_list|,
name|StmtArg
name|Body
argument_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnWhileStmt
argument_list|(
name|WhileLoc
argument_list|,
name|Cond
argument_list|,
name|DeclPtrTy
operator|::
name|make
argument_list|(
name|CondVar
argument_list|)
argument_list|,
name|move
argument_list|(
name|Body
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new do-while statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningStmtResult
name|RebuildDoStmt
parameter_list|(
name|SourceLocation
name|DoLoc
parameter_list|,
name|StmtArg
name|Body
parameter_list|,
name|SourceLocation
name|WhileLoc
parameter_list|,
name|SourceLocation
name|LParenLoc
parameter_list|,
name|ExprArg
name|Cond
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnDoStmt
argument_list|(
name|DoLoc
argument_list|,
name|move
argument_list|(
name|Body
argument_list|)
argument_list|,
name|WhileLoc
argument_list|,
name|LParenLoc
argument_list|,
name|move
argument_list|(
name|Cond
argument_list|)
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new for statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningStmtResult
name|RebuildForStmt
argument_list|(
name|SourceLocation
name|ForLoc
argument_list|,
name|SourceLocation
name|LParenLoc
argument_list|,
name|StmtArg
name|Init
argument_list|,
name|Sema
operator|::
name|FullExprArg
name|Cond
argument_list|,
name|VarDecl
operator|*
name|CondVar
argument_list|,
name|Sema
operator|::
name|FullExprArg
name|Inc
argument_list|,
name|SourceLocation
name|RParenLoc
argument_list|,
name|StmtArg
name|Body
argument_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnForStmt
argument_list|(
name|ForLoc
argument_list|,
name|LParenLoc
argument_list|,
name|move
argument_list|(
name|Init
argument_list|)
argument_list|,
name|Cond
argument_list|,
name|DeclPtrTy
operator|::
name|make
argument_list|(
name|CondVar
argument_list|)
argument_list|,
name|Inc
argument_list|,
name|RParenLoc
argument_list|,
name|move
argument_list|(
name|Body
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new goto statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningStmtResult
name|RebuildGotoStmt
parameter_list|(
name|SourceLocation
name|GotoLoc
parameter_list|,
name|SourceLocation
name|LabelLoc
parameter_list|,
name|LabelStmt
modifier|*
name|Label
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnGotoStmt
argument_list|(
name|GotoLoc
argument_list|,
name|LabelLoc
argument_list|,
name|Label
operator|->
name|getID
argument_list|()
argument_list|)
return|;
block|}
comment|/// \brief Build a new indirect goto statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningStmtResult
name|RebuildIndirectGotoStmt
parameter_list|(
name|SourceLocation
name|GotoLoc
parameter_list|,
name|SourceLocation
name|StarLoc
parameter_list|,
name|ExprArg
name|Target
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnIndirectGotoStmt
argument_list|(
name|GotoLoc
argument_list|,
name|StarLoc
argument_list|,
name|move
argument_list|(
name|Target
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new return statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningStmtResult
name|RebuildReturnStmt
parameter_list|(
name|SourceLocation
name|ReturnLoc
parameter_list|,
name|ExprArg
name|Result
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnReturnStmt
argument_list|(
name|ReturnLoc
argument_list|,
name|move
argument_list|(
name|Result
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new declaration statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningStmtResult
name|RebuildDeclStmt
parameter_list|(
name|Decl
modifier|*
modifier|*
name|Decls
parameter_list|,
name|unsigned
name|NumDecls
parameter_list|,
name|SourceLocation
name|StartLoc
parameter_list|,
name|SourceLocation
name|EndLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|Owned
argument_list|(
name|new
argument_list|(
argument|getSema().Context
argument_list|)
name|DeclStmt
argument_list|(
name|DeclGroupRef
operator|::
name|Create
argument_list|(
name|getSema
argument_list|()
operator|.
name|Context
argument_list|,
name|Decls
argument_list|,
name|NumDecls
argument_list|)
argument_list|,
name|StartLoc
argument_list|,
name|EndLoc
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new inline asm statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningStmtResult
name|RebuildAsmStmt
parameter_list|(
name|SourceLocation
name|AsmLoc
parameter_list|,
name|bool
name|IsSimple
parameter_list|,
name|bool
name|IsVolatile
parameter_list|,
name|unsigned
name|NumOutputs
parameter_list|,
name|unsigned
name|NumInputs
parameter_list|,
name|IdentifierInfo
modifier|*
modifier|*
name|Names
parameter_list|,
name|MultiExprArg
name|Constraints
parameter_list|,
name|MultiExprArg
name|Exprs
parameter_list|,
name|ExprArg
name|AsmString
parameter_list|,
name|MultiExprArg
name|Clobbers
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|,
name|bool
name|MSAsm
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnAsmStmt
argument_list|(
name|AsmLoc
argument_list|,
name|IsSimple
argument_list|,
name|IsVolatile
argument_list|,
name|NumOutputs
argument_list|,
name|NumInputs
argument_list|,
name|Names
argument_list|,
name|move
argument_list|(
name|Constraints
argument_list|)
argument_list|,
name|move
argument_list|(
name|Exprs
argument_list|)
argument_list|,
name|move
argument_list|(
name|AsmString
argument_list|)
argument_list|,
name|move
argument_list|(
name|Clobbers
argument_list|)
argument_list|,
name|RParenLoc
argument_list|,
name|MSAsm
argument_list|)
return|;
block|}
comment|/// \brief Build a new C++ exception declaration.
comment|///
comment|/// By default, performs semantic analysis to build the new decaration.
comment|/// Subclasses may override this routine to provide different behavior.
name|VarDecl
modifier|*
name|RebuildExceptionDecl
parameter_list|(
name|VarDecl
modifier|*
name|ExceptionDecl
parameter_list|,
name|QualType
name|T
parameter_list|,
name|TypeSourceInfo
modifier|*
name|Declarator
parameter_list|,
name|IdentifierInfo
modifier|*
name|Name
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
name|SourceRange
name|TypeRange
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildExceptionDeclaration
argument_list|(
literal|0
argument_list|,
name|T
argument_list|,
name|Declarator
argument_list|,
name|Name
argument_list|,
name|Loc
argument_list|,
name|TypeRange
argument_list|)
return|;
block|}
comment|/// \brief Build a new C++ catch statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningStmtResult
name|RebuildCXXCatchStmt
parameter_list|(
name|SourceLocation
name|CatchLoc
parameter_list|,
name|VarDecl
modifier|*
name|ExceptionDecl
parameter_list|,
name|StmtArg
name|Handler
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|Owned
argument_list|(
name|new
argument_list|(
argument|getSema().Context
argument_list|)
name|CXXCatchStmt
argument_list|(
name|CatchLoc
argument_list|,
name|ExceptionDecl
argument_list|,
name|Handler
operator|.
name|takeAs
operator|<
name|Stmt
operator|>
operator|(
operator|)
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new C++ try statement.
comment|///
comment|/// By default, performs semantic analysis to build the new statement.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningStmtResult
name|RebuildCXXTryStmt
parameter_list|(
name|SourceLocation
name|TryLoc
parameter_list|,
name|StmtArg
name|TryBlock
parameter_list|,
name|MultiStmtArg
name|Handlers
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnCXXTryBlock
argument_list|(
name|TryLoc
argument_list|,
name|move
argument_list|(
name|TryBlock
argument_list|)
argument_list|,
name|move
argument_list|(
name|Handlers
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new expression that references a declaration.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildDeclarationNameExpr
parameter_list|(
specifier|const
name|CXXScopeSpec
modifier|&
name|SS
parameter_list|,
name|LookupResult
modifier|&
name|R
parameter_list|,
name|bool
name|RequiresADL
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildDeclarationNameExpr
argument_list|(
name|SS
argument_list|,
name|R
argument_list|,
name|RequiresADL
argument_list|)
return|;
block|}
comment|/// \brief Build a new expression that references a declaration.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildDeclRefExpr
parameter_list|(
name|NestedNameSpecifier
modifier|*
name|Qualifier
parameter_list|,
name|SourceRange
name|QualifierRange
parameter_list|,
name|ValueDecl
modifier|*
name|VD
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
name|TemplateArgumentListInfo
modifier|*
name|TemplateArgs
parameter_list|)
block|{
name|CXXScopeSpec
name|SS
decl_stmt|;
name|SS
operator|.
name|setScopeRep
argument_list|(
name|Qualifier
argument_list|)
expr_stmt|;
name|SS
operator|.
name|setRange
argument_list|(
name|QualifierRange
argument_list|)
expr_stmt|;
comment|// FIXME: loses template args.
return|return
name|getSema
argument_list|()
operator|.
name|BuildDeclarationNameExpr
argument_list|(
name|SS
argument_list|,
name|Loc
argument_list|,
name|VD
argument_list|)
return|;
block|}
comment|/// \brief Build a new expression in parentheses.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildParenExpr
parameter_list|(
name|ExprArg
name|SubExpr
parameter_list|,
name|SourceLocation
name|LParen
parameter_list|,
name|SourceLocation
name|RParen
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnParenExpr
argument_list|(
name|LParen
argument_list|,
name|RParen
argument_list|,
name|move
argument_list|(
name|SubExpr
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new pseudo-destructor expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildCXXPseudoDestructorExpr
parameter_list|(
name|ExprArg
name|Base
parameter_list|,
name|SourceLocation
name|OperatorLoc
parameter_list|,
name|bool
name|isArrow
parameter_list|,
name|NestedNameSpecifier
modifier|*
name|Qualifier
parameter_list|,
name|SourceRange
name|QualifierRange
parameter_list|,
name|TypeSourceInfo
modifier|*
name|ScopeType
parameter_list|,
name|SourceLocation
name|CCLoc
parameter_list|,
name|SourceLocation
name|TildeLoc
parameter_list|,
name|PseudoDestructorTypeStorage
name|Destroyed
parameter_list|)
function_decl|;
comment|/// \brief Build a new unary operator expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildUnaryOperator
argument_list|(
name|SourceLocation
name|OpLoc
argument_list|,
name|UnaryOperator
operator|::
name|Opcode
name|Opc
argument_list|,
name|ExprArg
name|SubExpr
argument_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildUnaryOp
argument_list|(
comment|/*Scope=*/
literal|0
argument_list|,
name|OpLoc
argument_list|,
name|Opc
argument_list|,
name|move
argument_list|(
name|SubExpr
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new sizeof or alignof expression with a type argument.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildSizeOfAlignOf
parameter_list|(
name|TypeSourceInfo
modifier|*
name|TInfo
parameter_list|,
name|SourceLocation
name|OpLoc
parameter_list|,
name|bool
name|isSizeOf
parameter_list|,
name|SourceRange
name|R
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|CreateSizeOfAlignOfExpr
argument_list|(
name|TInfo
argument_list|,
name|OpLoc
argument_list|,
name|isSizeOf
argument_list|,
name|R
argument_list|)
return|;
block|}
comment|/// \brief Build a new sizeof or alignof expression with an expression
comment|/// argument.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildSizeOfAlignOf
parameter_list|(
name|ExprArg
name|SubExpr
parameter_list|,
name|SourceLocation
name|OpLoc
parameter_list|,
name|bool
name|isSizeOf
parameter_list|,
name|SourceRange
name|R
parameter_list|)
block|{
name|OwningExprResult
name|Result
init|=
name|getSema
argument_list|()
operator|.
name|CreateSizeOfAlignOfExpr
argument_list|(
operator|(
name|Expr
operator|*
operator|)
name|SubExpr
operator|.
name|get
argument_list|()
argument_list|,
name|OpLoc
argument_list|,
name|isSizeOf
argument_list|,
name|R
argument_list|)
decl_stmt|;
if|if
condition|(
name|Result
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|getSema
argument_list|()
operator|.
name|ExprError
argument_list|()
return|;
name|SubExpr
operator|.
name|release
argument_list|()
expr_stmt|;
return|return
name|move
argument_list|(
name|Result
argument_list|)
return|;
block|}
comment|/// \brief Build a new array subscript expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildArraySubscriptExpr
parameter_list|(
name|ExprArg
name|LHS
parameter_list|,
name|SourceLocation
name|LBracketLoc
parameter_list|,
name|ExprArg
name|RHS
parameter_list|,
name|SourceLocation
name|RBracketLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnArraySubscriptExpr
argument_list|(
comment|/*Scope=*/
literal|0
argument_list|,
name|move
argument_list|(
name|LHS
argument_list|)
argument_list|,
name|LBracketLoc
argument_list|,
name|move
argument_list|(
name|RHS
argument_list|)
argument_list|,
name|RBracketLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new call expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildCallExpr
parameter_list|(
name|ExprArg
name|Callee
parameter_list|,
name|SourceLocation
name|LParenLoc
parameter_list|,
name|MultiExprArg
name|Args
parameter_list|,
name|SourceLocation
modifier|*
name|CommaLocs
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnCallExpr
argument_list|(
comment|/*Scope=*/
literal|0
argument_list|,
name|move
argument_list|(
name|Callee
argument_list|)
argument_list|,
name|LParenLoc
argument_list|,
name|move
argument_list|(
name|Args
argument_list|)
argument_list|,
name|CommaLocs
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new member access expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildMemberExpr
parameter_list|(
name|ExprArg
name|Base
parameter_list|,
name|SourceLocation
name|OpLoc
parameter_list|,
name|bool
name|isArrow
parameter_list|,
name|NestedNameSpecifier
modifier|*
name|Qualifier
parameter_list|,
name|SourceRange
name|QualifierRange
parameter_list|,
name|SourceLocation
name|MemberLoc
parameter_list|,
name|ValueDecl
modifier|*
name|Member
parameter_list|,
specifier|const
name|TemplateArgumentListInfo
modifier|*
name|ExplicitTemplateArgs
parameter_list|,
name|NamedDecl
modifier|*
name|FirstQualifierInScope
parameter_list|)
block|{
if|if
condition|(
operator|!
name|Member
operator|->
name|getDeclName
argument_list|()
condition|)
block|{
comment|// We have a reference to an unnamed field.
name|assert
argument_list|(
operator|!
name|Qualifier
operator|&&
literal|"Can't have an unnamed field with a qualifier!"
argument_list|)
expr_stmt|;
name|Expr
modifier|*
name|BaseExpr
init|=
name|Base
operator|.
name|takeAs
operator|<
name|Expr
operator|>
operator|(
operator|)
decl_stmt|;
if|if
condition|(
name|getSema
argument_list|()
operator|.
name|PerformObjectMemberConversion
argument_list|(
name|BaseExpr
argument_list|,
name|Qualifier
argument_list|,
name|Member
argument_list|)
condition|)
return|return
name|getSema
argument_list|()
operator|.
name|ExprError
argument_list|()
return|;
name|MemberExpr
modifier|*
name|ME
init|=
name|new
argument_list|(
argument|getSema().Context
argument_list|)
name|MemberExpr
argument_list|(
name|BaseExpr
argument_list|,
name|isArrow
argument_list|,
name|Member
argument_list|,
name|MemberLoc
argument_list|,
name|cast
operator|<
name|FieldDecl
operator|>
operator|(
name|Member
operator|)
operator|->
name|getType
argument_list|()
argument_list|)
decl_stmt|;
return|return
name|getSema
argument_list|()
operator|.
name|Owned
argument_list|(
name|ME
argument_list|)
return|;
block|}
name|CXXScopeSpec
name|SS
decl_stmt|;
if|if
condition|(
name|Qualifier
condition|)
block|{
name|SS
operator|.
name|setRange
argument_list|(
name|QualifierRange
argument_list|)
expr_stmt|;
name|SS
operator|.
name|setScopeRep
argument_list|(
name|Qualifier
argument_list|)
expr_stmt|;
block|}
name|QualType
name|BaseType
init|=
operator|(
operator|(
name|Expr
operator|*
operator|)
name|Base
operator|.
name|get
argument_list|()
operator|)
operator|->
name|getType
argument_list|()
decl_stmt|;
name|LookupResult
name|R
argument_list|(
name|getSema
argument_list|()
argument_list|,
name|Member
operator|->
name|getDeclName
argument_list|()
argument_list|,
name|MemberLoc
argument_list|,
name|Sema
operator|::
name|LookupMemberName
argument_list|)
decl_stmt|;
name|R
operator|.
name|addDecl
argument_list|(
name|Member
argument_list|)
expr_stmt|;
name|R
operator|.
name|resolveKind
argument_list|()
expr_stmt|;
return|return
name|getSema
argument_list|()
operator|.
name|BuildMemberReferenceExpr
argument_list|(
name|move
argument_list|(
name|Base
argument_list|)
argument_list|,
name|BaseType
argument_list|,
name|OpLoc
argument_list|,
name|isArrow
argument_list|,
name|SS
argument_list|,
name|FirstQualifierInScope
argument_list|,
name|R
argument_list|,
name|ExplicitTemplateArgs
argument_list|)
return|;
block|}
comment|/// \brief Build a new binary operator expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildBinaryOperator
argument_list|(
name|SourceLocation
name|OpLoc
argument_list|,
name|BinaryOperator
operator|::
name|Opcode
name|Opc
argument_list|,
name|ExprArg
name|LHS
argument_list|,
name|ExprArg
name|RHS
argument_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildBinOp
argument_list|(
comment|/*Scope=*/
literal|0
argument_list|,
name|OpLoc
argument_list|,
name|Opc
argument_list|,
name|LHS
operator|.
name|takeAs
operator|<
name|Expr
operator|>
operator|(
operator|)
argument_list|,
name|RHS
operator|.
name|takeAs
operator|<
name|Expr
operator|>
operator|(
operator|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new conditional operator expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildConditionalOperator
parameter_list|(
name|ExprArg
name|Cond
parameter_list|,
name|SourceLocation
name|QuestionLoc
parameter_list|,
name|ExprArg
name|LHS
parameter_list|,
name|SourceLocation
name|ColonLoc
parameter_list|,
name|ExprArg
name|RHS
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnConditionalOp
argument_list|(
name|QuestionLoc
argument_list|,
name|ColonLoc
argument_list|,
name|move
argument_list|(
name|Cond
argument_list|)
argument_list|,
name|move
argument_list|(
name|LHS
argument_list|)
argument_list|,
name|move
argument_list|(
name|RHS
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new C-style cast expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildCStyleCastExpr
parameter_list|(
name|SourceLocation
name|LParenLoc
parameter_list|,
name|TypeSourceInfo
modifier|*
name|TInfo
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|,
name|ExprArg
name|SubExpr
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildCStyleCastExpr
argument_list|(
name|LParenLoc
argument_list|,
name|TInfo
argument_list|,
name|RParenLoc
argument_list|,
name|move
argument_list|(
name|SubExpr
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new compound literal expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildCompoundLiteralExpr
parameter_list|(
name|SourceLocation
name|LParenLoc
parameter_list|,
name|TypeSourceInfo
modifier|*
name|TInfo
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|,
name|ExprArg
name|Init
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildCompoundLiteralExpr
argument_list|(
name|LParenLoc
argument_list|,
name|TInfo
argument_list|,
name|RParenLoc
argument_list|,
name|move
argument_list|(
name|Init
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new extended vector element access expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildExtVectorElementExpr
parameter_list|(
name|ExprArg
name|Base
parameter_list|,
name|SourceLocation
name|OpLoc
parameter_list|,
name|SourceLocation
name|AccessorLoc
parameter_list|,
name|IdentifierInfo
modifier|&
name|Accessor
parameter_list|)
block|{
name|CXXScopeSpec
name|SS
decl_stmt|;
name|QualType
name|BaseType
init|=
operator|(
operator|(
name|Expr
operator|*
operator|)
name|Base
operator|.
name|get
argument_list|()
operator|)
operator|->
name|getType
argument_list|()
decl_stmt|;
return|return
name|getSema
argument_list|()
operator|.
name|BuildMemberReferenceExpr
argument_list|(
name|move
argument_list|(
name|Base
argument_list|)
argument_list|,
name|BaseType
argument_list|,
name|OpLoc
argument_list|,
comment|/*IsArrow*/
name|false
argument_list|,
name|SS
argument_list|,
comment|/*FirstQualifierInScope*/
literal|0
argument_list|,
name|DeclarationName
argument_list|(
operator|&
name|Accessor
argument_list|)
argument_list|,
name|AccessorLoc
argument_list|,
comment|/* TemplateArgs */
literal|0
argument_list|)
return|;
block|}
comment|/// \brief Build a new initializer list expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildInitList
parameter_list|(
name|SourceLocation
name|LBraceLoc
parameter_list|,
name|MultiExprArg
name|Inits
parameter_list|,
name|SourceLocation
name|RBraceLoc
parameter_list|,
name|QualType
name|ResultTy
parameter_list|)
block|{
name|OwningExprResult
name|Result
init|=
name|SemaRef
operator|.
name|ActOnInitList
argument_list|(
name|LBraceLoc
argument_list|,
name|move
argument_list|(
name|Inits
argument_list|)
argument_list|,
name|RBraceLoc
argument_list|)
decl_stmt|;
if|if
condition|(
name|Result
operator|.
name|isInvalid
argument_list|()
operator|||
name|ResultTy
operator|->
name|isDependentType
argument_list|()
condition|)
return|return
name|move
argument_list|(
name|Result
argument_list|)
return|;
comment|// Patch in the result type we were given, which may have been computed
comment|// when the initial InitListExpr was built.
name|InitListExpr
modifier|*
name|ILE
init|=
name|cast
operator|<
name|InitListExpr
operator|>
operator|(
operator|(
name|Expr
operator|*
operator|)
name|Result
operator|.
name|get
argument_list|()
operator|)
decl_stmt|;
name|ILE
operator|->
name|setType
argument_list|(
name|ResultTy
argument_list|)
expr_stmt|;
return|return
name|move
argument_list|(
name|Result
argument_list|)
return|;
block|}
comment|/// \brief Build a new designated initializer expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildDesignatedInitExpr
parameter_list|(
name|Designation
modifier|&
name|Desig
parameter_list|,
name|MultiExprArg
name|ArrayExprs
parameter_list|,
name|SourceLocation
name|EqualOrColonLoc
parameter_list|,
name|bool
name|GNUSyntax
parameter_list|,
name|ExprArg
name|Init
parameter_list|)
block|{
name|OwningExprResult
name|Result
init|=
name|SemaRef
operator|.
name|ActOnDesignatedInitializer
argument_list|(
name|Desig
argument_list|,
name|EqualOrColonLoc
argument_list|,
name|GNUSyntax
argument_list|,
name|move
argument_list|(
name|Init
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|Result
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
name|ArrayExprs
operator|.
name|release
argument_list|()
expr_stmt|;
return|return
name|move
argument_list|(
name|Result
argument_list|)
return|;
block|}
comment|/// \brief Build a new value-initialized expression.
comment|///
comment|/// By default, builds the implicit value initialization without performing
comment|/// any semantic analysis. Subclasses may override this routine to provide
comment|/// different behavior.
name|OwningExprResult
name|RebuildImplicitValueInitExpr
parameter_list|(
name|QualType
name|T
parameter_list|)
block|{
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|new
argument_list|(
argument|SemaRef.Context
argument_list|)
name|ImplicitValueInitExpr
argument_list|(
name|T
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new \c va_arg expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildVAArgExpr
parameter_list|(
name|SourceLocation
name|BuiltinLoc
parameter_list|,
name|ExprArg
name|SubExpr
parameter_list|,
name|QualType
name|T
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnVAArg
argument_list|(
name|BuiltinLoc
argument_list|,
name|move
argument_list|(
name|SubExpr
argument_list|)
argument_list|,
name|T
operator|.
name|getAsOpaquePtr
argument_list|()
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new expression list in parentheses.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildParenListExpr
parameter_list|(
name|SourceLocation
name|LParenLoc
parameter_list|,
name|MultiExprArg
name|SubExprs
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnParenOrParenListExpr
argument_list|(
name|LParenLoc
argument_list|,
name|RParenLoc
argument_list|,
name|move
argument_list|(
name|SubExprs
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new address-of-label expression.
comment|///
comment|/// By default, performs semantic analysis, using the name of the label
comment|/// rather than attempting to map the label statement itself.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildAddrLabelExpr
parameter_list|(
name|SourceLocation
name|AmpAmpLoc
parameter_list|,
name|SourceLocation
name|LabelLoc
parameter_list|,
name|LabelStmt
modifier|*
name|Label
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnAddrLabel
argument_list|(
name|AmpAmpLoc
argument_list|,
name|LabelLoc
argument_list|,
name|Label
operator|->
name|getID
argument_list|()
argument_list|)
return|;
block|}
comment|/// \brief Build a new GNU statement expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildStmtExpr
parameter_list|(
name|SourceLocation
name|LParenLoc
parameter_list|,
name|StmtArg
name|SubStmt
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnStmtExpr
argument_list|(
name|LParenLoc
argument_list|,
name|move
argument_list|(
name|SubStmt
argument_list|)
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new __builtin_types_compatible_p expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildTypesCompatibleExpr
parameter_list|(
name|SourceLocation
name|BuiltinLoc
parameter_list|,
name|QualType
name|T1
parameter_list|,
name|QualType
name|T2
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnTypesCompatibleExpr
argument_list|(
name|BuiltinLoc
argument_list|,
name|T1
operator|.
name|getAsOpaquePtr
argument_list|()
argument_list|,
name|T2
operator|.
name|getAsOpaquePtr
argument_list|()
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new __builtin_choose_expr expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildChooseExpr
parameter_list|(
name|SourceLocation
name|BuiltinLoc
parameter_list|,
name|ExprArg
name|Cond
parameter_list|,
name|ExprArg
name|LHS
parameter_list|,
name|ExprArg
name|RHS
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|SemaRef
operator|.
name|ActOnChooseExpr
argument_list|(
name|BuiltinLoc
argument_list|,
name|move
argument_list|(
name|Cond
argument_list|)
argument_list|,
name|move
argument_list|(
name|LHS
argument_list|)
argument_list|,
name|move
argument_list|(
name|RHS
argument_list|)
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new overloaded operator call expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// The semantic analysis provides the behavior of template instantiation,
comment|/// copying with transformations that turn what looks like an overloaded
comment|/// operator call into a use of a builtin operator, performing
comment|/// argument-dependent lookup, etc. Subclasses may override this routine to
comment|/// provide different behavior.
name|OwningExprResult
name|RebuildCXXOperatorCallExpr
parameter_list|(
name|OverloadedOperatorKind
name|Op
parameter_list|,
name|SourceLocation
name|OpLoc
parameter_list|,
name|ExprArg
name|Callee
parameter_list|,
name|ExprArg
name|First
parameter_list|,
name|ExprArg
name|Second
parameter_list|)
function_decl|;
comment|/// \brief Build a new C++ "named" cast expression, such as static_cast or
comment|/// reinterpret_cast.
comment|///
comment|/// By default, this routine dispatches to one of the more-specific routines
comment|/// for a particular named case, e.g., RebuildCXXStaticCastExpr().
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildCXXNamedCastExpr
argument_list|(
name|SourceLocation
name|OpLoc
argument_list|,
name|Stmt
operator|::
name|StmtClass
name|Class
argument_list|,
name|SourceLocation
name|LAngleLoc
argument_list|,
name|TypeSourceInfo
operator|*
name|TInfo
argument_list|,
name|SourceLocation
name|RAngleLoc
argument_list|,
name|SourceLocation
name|LParenLoc
argument_list|,
name|ExprArg
name|SubExpr
argument_list|,
name|SourceLocation
name|RParenLoc
argument_list|)
block|{
switch|switch
condition|(
name|Class
condition|)
block|{
case|case
name|Stmt
operator|::
name|CXXStaticCastExprClass
case|:
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXStaticCastExpr
argument_list|(
name|OpLoc
argument_list|,
name|LAngleLoc
argument_list|,
name|TInfo
argument_list|,
name|RAngleLoc
argument_list|,
name|LParenLoc
argument_list|,
name|move
argument_list|(
name|SubExpr
argument_list|)
argument_list|,
name|RParenLoc
argument_list|)
return|;
case|case
name|Stmt
operator|::
name|CXXDynamicCastExprClass
case|:
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXDynamicCastExpr
argument_list|(
name|OpLoc
argument_list|,
name|LAngleLoc
argument_list|,
name|TInfo
argument_list|,
name|RAngleLoc
argument_list|,
name|LParenLoc
argument_list|,
name|move
argument_list|(
name|SubExpr
argument_list|)
argument_list|,
name|RParenLoc
argument_list|)
return|;
case|case
name|Stmt
operator|::
name|CXXReinterpretCastExprClass
case|:
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXReinterpretCastExpr
argument_list|(
name|OpLoc
argument_list|,
name|LAngleLoc
argument_list|,
name|TInfo
argument_list|,
name|RAngleLoc
argument_list|,
name|LParenLoc
argument_list|,
name|move
argument_list|(
name|SubExpr
argument_list|)
argument_list|,
name|RParenLoc
argument_list|)
return|;
case|case
name|Stmt
operator|::
name|CXXConstCastExprClass
case|:
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXConstCastExpr
argument_list|(
name|OpLoc
argument_list|,
name|LAngleLoc
argument_list|,
name|TInfo
argument_list|,
name|RAngleLoc
argument_list|,
name|LParenLoc
argument_list|,
name|move
argument_list|(
name|SubExpr
argument_list|)
argument_list|,
name|RParenLoc
argument_list|)
return|;
default|default:
name|assert
argument_list|(
name|false
operator|&&
literal|"Invalid C++ named cast"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|getSema
argument_list|()
operator|.
name|ExprError
argument_list|()
return|;
block|}
comment|/// \brief Build a new C++ static_cast expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildCXXStaticCastExpr
parameter_list|(
name|SourceLocation
name|OpLoc
parameter_list|,
name|SourceLocation
name|LAngleLoc
parameter_list|,
name|TypeSourceInfo
modifier|*
name|TInfo
parameter_list|,
name|SourceLocation
name|RAngleLoc
parameter_list|,
name|SourceLocation
name|LParenLoc
parameter_list|,
name|ExprArg
name|SubExpr
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildCXXNamedCast
argument_list|(
name|OpLoc
argument_list|,
name|tok
operator|::
name|kw_static_cast
argument_list|,
name|TInfo
argument_list|,
name|move
argument_list|(
name|SubExpr
argument_list|)
argument_list|,
name|SourceRange
argument_list|(
name|LAngleLoc
argument_list|,
name|RAngleLoc
argument_list|)
argument_list|,
name|SourceRange
argument_list|(
name|LParenLoc
argument_list|,
name|RParenLoc
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new C++ dynamic_cast expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildCXXDynamicCastExpr
parameter_list|(
name|SourceLocation
name|OpLoc
parameter_list|,
name|SourceLocation
name|LAngleLoc
parameter_list|,
name|TypeSourceInfo
modifier|*
name|TInfo
parameter_list|,
name|SourceLocation
name|RAngleLoc
parameter_list|,
name|SourceLocation
name|LParenLoc
parameter_list|,
name|ExprArg
name|SubExpr
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildCXXNamedCast
argument_list|(
name|OpLoc
argument_list|,
name|tok
operator|::
name|kw_dynamic_cast
argument_list|,
name|TInfo
argument_list|,
name|move
argument_list|(
name|SubExpr
argument_list|)
argument_list|,
name|SourceRange
argument_list|(
name|LAngleLoc
argument_list|,
name|RAngleLoc
argument_list|)
argument_list|,
name|SourceRange
argument_list|(
name|LParenLoc
argument_list|,
name|RParenLoc
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new C++ reinterpret_cast expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildCXXReinterpretCastExpr
parameter_list|(
name|SourceLocation
name|OpLoc
parameter_list|,
name|SourceLocation
name|LAngleLoc
parameter_list|,
name|TypeSourceInfo
modifier|*
name|TInfo
parameter_list|,
name|SourceLocation
name|RAngleLoc
parameter_list|,
name|SourceLocation
name|LParenLoc
parameter_list|,
name|ExprArg
name|SubExpr
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildCXXNamedCast
argument_list|(
name|OpLoc
argument_list|,
name|tok
operator|::
name|kw_reinterpret_cast
argument_list|,
name|TInfo
argument_list|,
name|move
argument_list|(
name|SubExpr
argument_list|)
argument_list|,
name|SourceRange
argument_list|(
name|LAngleLoc
argument_list|,
name|RAngleLoc
argument_list|)
argument_list|,
name|SourceRange
argument_list|(
name|LParenLoc
argument_list|,
name|RParenLoc
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new C++ const_cast expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildCXXConstCastExpr
parameter_list|(
name|SourceLocation
name|OpLoc
parameter_list|,
name|SourceLocation
name|LAngleLoc
parameter_list|,
name|TypeSourceInfo
modifier|*
name|TInfo
parameter_list|,
name|SourceLocation
name|RAngleLoc
parameter_list|,
name|SourceLocation
name|LParenLoc
parameter_list|,
name|ExprArg
name|SubExpr
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildCXXNamedCast
argument_list|(
name|OpLoc
argument_list|,
name|tok
operator|::
name|kw_const_cast
argument_list|,
name|TInfo
argument_list|,
name|move
argument_list|(
name|SubExpr
argument_list|)
argument_list|,
name|SourceRange
argument_list|(
name|LAngleLoc
argument_list|,
name|RAngleLoc
argument_list|)
argument_list|,
name|SourceRange
argument_list|(
name|LParenLoc
argument_list|,
name|RParenLoc
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new C++ functional-style cast expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildCXXFunctionalCastExpr
parameter_list|(
name|SourceRange
name|TypeRange
parameter_list|,
name|TypeSourceInfo
modifier|*
name|TInfo
parameter_list|,
name|SourceLocation
name|LParenLoc
parameter_list|,
name|ExprArg
name|SubExpr
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
name|void
modifier|*
name|Sub
init|=
name|SubExpr
operator|.
name|takeAs
operator|<
name|Expr
operator|>
operator|(
operator|)
decl_stmt|;
return|return
name|getSema
argument_list|()
operator|.
name|ActOnCXXTypeConstructExpr
argument_list|(
name|TypeRange
argument_list|,
name|TInfo
operator|->
name|getType
argument_list|()
operator|.
name|getAsOpaquePtr
argument_list|()
argument_list|,
name|LParenLoc
argument_list|,
name|Sema
operator|::
name|MultiExprArg
argument_list|(
name|getSema
argument_list|()
argument_list|,
operator|&
name|Sub
argument_list|,
literal|1
argument_list|)
argument_list|,
comment|/*CommaLocs=*/
literal|0
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new C++ typeid(type) expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildCXXTypeidExpr
parameter_list|(
name|SourceLocation
name|TypeidLoc
parameter_list|,
name|SourceLocation
name|LParenLoc
parameter_list|,
name|QualType
name|T
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnCXXTypeid
argument_list|(
name|TypeidLoc
argument_list|,
name|LParenLoc
argument_list|,
name|true
argument_list|,
name|T
operator|.
name|getAsOpaquePtr
argument_list|()
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new C++ typeid(expr) expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildCXXTypeidExpr
parameter_list|(
name|SourceLocation
name|TypeidLoc
parameter_list|,
name|SourceLocation
name|LParenLoc
parameter_list|,
name|ExprArg
name|Operand
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
name|OwningExprResult
name|Result
init|=
name|getSema
argument_list|()
operator|.
name|ActOnCXXTypeid
argument_list|(
name|TypeidLoc
argument_list|,
name|LParenLoc
argument_list|,
name|false
argument_list|,
name|Operand
operator|.
name|get
argument_list|()
argument_list|,
name|RParenLoc
argument_list|)
decl_stmt|;
if|if
condition|(
name|Result
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|getSema
argument_list|()
operator|.
name|ExprError
argument_list|()
return|;
name|Operand
operator|.
name|release
argument_list|()
expr_stmt|;
comment|// FIXME: since ActOnCXXTypeid silently took ownership
return|return
name|move
argument_list|(
name|Result
argument_list|)
return|;
block|}
comment|/// \brief Build a new C++ "this" expression.
comment|///
comment|/// By default, builds a new "this" expression without performing any
comment|/// semantic analysis. Subclasses may override this routine to provide
comment|/// different behavior.
name|OwningExprResult
name|RebuildCXXThisExpr
parameter_list|(
name|SourceLocation
name|ThisLoc
parameter_list|,
name|QualType
name|ThisType
parameter_list|,
name|bool
name|isImplicit
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|Owned
argument_list|(
name|new
argument_list|(
argument|getSema().Context
argument_list|)
name|CXXThisExpr
argument_list|(
name|ThisLoc
argument_list|,
name|ThisType
argument_list|,
name|isImplicit
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new C++ throw expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildCXXThrowExpr
parameter_list|(
name|SourceLocation
name|ThrowLoc
parameter_list|,
name|ExprArg
name|Sub
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnCXXThrow
argument_list|(
name|ThrowLoc
argument_list|,
name|move
argument_list|(
name|Sub
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new C++ default-argument expression.
comment|///
comment|/// By default, builds a new default-argument expression, which does not
comment|/// require any semantic analysis. Subclasses may override this routine to
comment|/// provide different behavior.
name|OwningExprResult
name|RebuildCXXDefaultArgExpr
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
name|ParmVarDecl
modifier|*
name|Param
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|Owned
argument_list|(
name|CXXDefaultArgExpr
operator|::
name|Create
argument_list|(
name|getSema
argument_list|()
operator|.
name|Context
argument_list|,
name|Loc
argument_list|,
name|Param
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new C++ zero-initialization expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildCXXZeroInitValueExpr
parameter_list|(
name|SourceLocation
name|TypeStartLoc
parameter_list|,
name|SourceLocation
name|LParenLoc
parameter_list|,
name|QualType
name|T
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnCXXTypeConstructExpr
argument_list|(
name|SourceRange
argument_list|(
name|TypeStartLoc
argument_list|)
argument_list|,
name|T
operator|.
name|getAsOpaquePtr
argument_list|()
argument_list|,
name|LParenLoc
argument_list|,
name|MultiExprArg
argument_list|(
name|getSema
argument_list|()
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new C++ "new" expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildCXXNewExpr
parameter_list|(
name|SourceLocation
name|StartLoc
parameter_list|,
name|bool
name|UseGlobal
parameter_list|,
name|SourceLocation
name|PlacementLParen
parameter_list|,
name|MultiExprArg
name|PlacementArgs
parameter_list|,
name|SourceLocation
name|PlacementRParen
parameter_list|,
name|bool
name|ParenTypeId
parameter_list|,
name|QualType
name|AllocType
parameter_list|,
name|SourceLocation
name|TypeLoc
parameter_list|,
name|SourceRange
name|TypeRange
parameter_list|,
name|ExprArg
name|ArraySize
parameter_list|,
name|SourceLocation
name|ConstructorLParen
parameter_list|,
name|MultiExprArg
name|ConstructorArgs
parameter_list|,
name|SourceLocation
name|ConstructorRParen
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildCXXNew
argument_list|(
name|StartLoc
argument_list|,
name|UseGlobal
argument_list|,
name|PlacementLParen
argument_list|,
name|move
argument_list|(
name|PlacementArgs
argument_list|)
argument_list|,
name|PlacementRParen
argument_list|,
name|ParenTypeId
argument_list|,
name|AllocType
argument_list|,
name|TypeLoc
argument_list|,
name|TypeRange
argument_list|,
name|move
argument_list|(
name|ArraySize
argument_list|)
argument_list|,
name|ConstructorLParen
argument_list|,
name|move
argument_list|(
name|ConstructorArgs
argument_list|)
argument_list|,
name|ConstructorRParen
argument_list|)
return|;
block|}
comment|/// \brief Build a new C++ "delete" expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildCXXDeleteExpr
parameter_list|(
name|SourceLocation
name|StartLoc
parameter_list|,
name|bool
name|IsGlobalDelete
parameter_list|,
name|bool
name|IsArrayForm
parameter_list|,
name|ExprArg
name|Operand
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnCXXDelete
argument_list|(
name|StartLoc
argument_list|,
name|IsGlobalDelete
argument_list|,
name|IsArrayForm
argument_list|,
name|move
argument_list|(
name|Operand
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new unary type trait expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildUnaryTypeTrait
parameter_list|(
name|UnaryTypeTrait
name|Trait
parameter_list|,
name|SourceLocation
name|StartLoc
parameter_list|,
name|SourceLocation
name|LParenLoc
parameter_list|,
name|QualType
name|T
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnUnaryTypeTrait
argument_list|(
name|Trait
argument_list|,
name|StartLoc
argument_list|,
name|LParenLoc
argument_list|,
name|T
operator|.
name|getAsOpaquePtr
argument_list|()
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new (previously unresolved) declaration reference
comment|/// expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildDependentScopeDeclRefExpr
parameter_list|(
name|NestedNameSpecifier
modifier|*
name|NNS
parameter_list|,
name|SourceRange
name|QualifierRange
parameter_list|,
name|DeclarationName
name|Name
parameter_list|,
name|SourceLocation
name|Location
parameter_list|,
specifier|const
name|TemplateArgumentListInfo
modifier|*
name|TemplateArgs
parameter_list|)
block|{
name|CXXScopeSpec
name|SS
decl_stmt|;
name|SS
operator|.
name|setRange
argument_list|(
name|QualifierRange
argument_list|)
expr_stmt|;
name|SS
operator|.
name|setScopeRep
argument_list|(
name|NNS
argument_list|)
expr_stmt|;
if|if
condition|(
name|TemplateArgs
condition|)
return|return
name|getSema
argument_list|()
operator|.
name|BuildQualifiedTemplateIdExpr
argument_list|(
name|SS
argument_list|,
name|Name
argument_list|,
name|Location
argument_list|,
operator|*
name|TemplateArgs
argument_list|)
return|;
return|return
name|getSema
argument_list|()
operator|.
name|BuildQualifiedDeclarationNameExpr
argument_list|(
name|SS
argument_list|,
name|Name
argument_list|,
name|Location
argument_list|)
return|;
block|}
comment|/// \brief Build a new template-id expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildTemplateIdExpr
parameter_list|(
specifier|const
name|CXXScopeSpec
modifier|&
name|SS
parameter_list|,
name|LookupResult
modifier|&
name|R
parameter_list|,
name|bool
name|RequiresADL
parameter_list|,
specifier|const
name|TemplateArgumentListInfo
modifier|&
name|TemplateArgs
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|BuildTemplateIdExpr
argument_list|(
name|SS
argument_list|,
name|R
argument_list|,
name|RequiresADL
argument_list|,
name|TemplateArgs
argument_list|)
return|;
block|}
comment|/// \brief Build a new object-construction expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildCXXConstructExpr
parameter_list|(
name|QualType
name|T
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
name|CXXConstructorDecl
modifier|*
name|Constructor
parameter_list|,
name|bool
name|IsElidable
parameter_list|,
name|MultiExprArg
name|Args
parameter_list|)
block|{
name|ASTOwningVector
operator|<
operator|&
name|ActionBase
operator|::
name|DeleteExpr
operator|>
name|ConvertedArgs
argument_list|(
name|SemaRef
argument_list|)
expr_stmt|;
if|if
condition|(
name|getSema
argument_list|()
operator|.
name|CompleteConstructorCall
argument_list|(
name|Constructor
argument_list|,
name|move
argument_list|(
name|Args
argument_list|)
argument_list|,
name|Loc
argument_list|,
name|ConvertedArgs
argument_list|)
condition|)
return|return
name|getSema
argument_list|()
operator|.
name|ExprError
argument_list|()
return|;
return|return
name|getSema
argument_list|()
operator|.
name|BuildCXXConstructExpr
argument_list|(
name|Loc
argument_list|,
name|T
argument_list|,
name|Constructor
argument_list|,
name|IsElidable
argument_list|,
name|move_arg
argument_list|(
name|ConvertedArgs
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new object-construction expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildCXXTemporaryObjectExpr
parameter_list|(
name|SourceLocation
name|TypeBeginLoc
parameter_list|,
name|QualType
name|T
parameter_list|,
name|SourceLocation
name|LParenLoc
parameter_list|,
name|MultiExprArg
name|Args
parameter_list|,
name|SourceLocation
modifier|*
name|Commas
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnCXXTypeConstructExpr
argument_list|(
name|SourceRange
argument_list|(
name|TypeBeginLoc
argument_list|)
argument_list|,
name|T
operator|.
name|getAsOpaquePtr
argument_list|()
argument_list|,
name|LParenLoc
argument_list|,
name|move
argument_list|(
name|Args
argument_list|)
argument_list|,
name|Commas
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new object-construction expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildCXXUnresolvedConstructExpr
parameter_list|(
name|SourceLocation
name|TypeBeginLoc
parameter_list|,
name|QualType
name|T
parameter_list|,
name|SourceLocation
name|LParenLoc
parameter_list|,
name|MultiExprArg
name|Args
parameter_list|,
name|SourceLocation
modifier|*
name|Commas
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|getSema
argument_list|()
operator|.
name|ActOnCXXTypeConstructExpr
argument_list|(
name|SourceRange
argument_list|(
name|TypeBeginLoc
argument_list|,
comment|/*FIXME*/
name|LParenLoc
argument_list|)
argument_list|,
name|T
operator|.
name|getAsOpaquePtr
argument_list|()
argument_list|,
name|LParenLoc
argument_list|,
name|move
argument_list|(
name|Args
argument_list|)
argument_list|,
name|Commas
argument_list|,
name|RParenLoc
argument_list|)
return|;
block|}
comment|/// \brief Build a new member reference expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildCXXDependentScopeMemberExpr
parameter_list|(
name|ExprArg
name|BaseE
parameter_list|,
name|QualType
name|BaseType
parameter_list|,
name|bool
name|IsArrow
parameter_list|,
name|SourceLocation
name|OperatorLoc
parameter_list|,
name|NestedNameSpecifier
modifier|*
name|Qualifier
parameter_list|,
name|SourceRange
name|QualifierRange
parameter_list|,
name|NamedDecl
modifier|*
name|FirstQualifierInScope
parameter_list|,
name|DeclarationName
name|Name
parameter_list|,
name|SourceLocation
name|MemberLoc
parameter_list|,
specifier|const
name|TemplateArgumentListInfo
modifier|*
name|TemplateArgs
parameter_list|)
block|{
name|CXXScopeSpec
name|SS
decl_stmt|;
name|SS
operator|.
name|setRange
argument_list|(
name|QualifierRange
argument_list|)
expr_stmt|;
name|SS
operator|.
name|setScopeRep
argument_list|(
name|Qualifier
argument_list|)
expr_stmt|;
return|return
name|SemaRef
operator|.
name|BuildMemberReferenceExpr
argument_list|(
name|move
argument_list|(
name|BaseE
argument_list|)
argument_list|,
name|BaseType
argument_list|,
name|OperatorLoc
argument_list|,
name|IsArrow
argument_list|,
name|SS
argument_list|,
name|FirstQualifierInScope
argument_list|,
name|Name
argument_list|,
name|MemberLoc
argument_list|,
name|TemplateArgs
argument_list|)
return|;
block|}
comment|/// \brief Build a new member reference expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildUnresolvedMemberExpr
parameter_list|(
name|ExprArg
name|BaseE
parameter_list|,
name|QualType
name|BaseType
parameter_list|,
name|SourceLocation
name|OperatorLoc
parameter_list|,
name|bool
name|IsArrow
parameter_list|,
name|NestedNameSpecifier
modifier|*
name|Qualifier
parameter_list|,
name|SourceRange
name|QualifierRange
parameter_list|,
name|NamedDecl
modifier|*
name|FirstQualifierInScope
parameter_list|,
name|LookupResult
modifier|&
name|R
parameter_list|,
specifier|const
name|TemplateArgumentListInfo
modifier|*
name|TemplateArgs
parameter_list|)
block|{
name|CXXScopeSpec
name|SS
decl_stmt|;
name|SS
operator|.
name|setRange
argument_list|(
name|QualifierRange
argument_list|)
expr_stmt|;
name|SS
operator|.
name|setScopeRep
argument_list|(
name|Qualifier
argument_list|)
expr_stmt|;
return|return
name|SemaRef
operator|.
name|BuildMemberReferenceExpr
argument_list|(
name|move
argument_list|(
name|BaseE
argument_list|)
argument_list|,
name|BaseType
argument_list|,
name|OperatorLoc
argument_list|,
name|IsArrow
argument_list|,
name|SS
argument_list|,
name|FirstQualifierInScope
argument_list|,
name|R
argument_list|,
name|TemplateArgs
argument_list|)
return|;
block|}
comment|/// \brief Build a new Objective-C @encode expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildObjCEncodeExpr
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|,
name|QualType
name|T
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|SemaRef
operator|.
name|BuildObjCEncodeExpression
argument_list|(
name|AtLoc
argument_list|,
name|T
argument_list|,
name|RParenLoc
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new Objective-C protocol expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildObjCProtocolExpr
parameter_list|(
name|ObjCProtocolDecl
modifier|*
name|Protocol
parameter_list|,
name|SourceLocation
name|AtLoc
parameter_list|,
name|SourceLocation
name|ProtoLoc
parameter_list|,
name|SourceLocation
name|LParenLoc
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|SemaRef
operator|.
name|ParseObjCProtocolExpression
argument_list|(
name|Protocol
operator|->
name|getIdentifier
argument_list|()
argument_list|,
name|AtLoc
argument_list|,
name|ProtoLoc
argument_list|,
name|LParenLoc
argument_list|,
name|RParenLoc
argument_list|)
argument_list|)
return|;
block|}
comment|/// \brief Build a new shuffle vector expression.
comment|///
comment|/// By default, performs semantic analysis to build the new expression.
comment|/// Subclasses may override this routine to provide different behavior.
name|OwningExprResult
name|RebuildShuffleVectorExpr
parameter_list|(
name|SourceLocation
name|BuiltinLoc
parameter_list|,
name|MultiExprArg
name|SubExprs
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
block|{
comment|// Find the declaration for __builtin_shufflevector
specifier|const
name|IdentifierInfo
modifier|&
name|Name
init|=
name|SemaRef
operator|.
name|Context
operator|.
name|Idents
operator|.
name|get
argument_list|(
literal|"__builtin_shufflevector"
argument_list|)
decl_stmt|;
name|TranslationUnitDecl
modifier|*
name|TUDecl
init|=
name|SemaRef
operator|.
name|Context
operator|.
name|getTranslationUnitDecl
argument_list|()
decl_stmt|;
name|DeclContext
operator|::
name|lookup_result
name|Lookup
operator|=
name|TUDecl
operator|->
name|lookup
argument_list|(
name|DeclarationName
argument_list|(
operator|&
name|Name
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|Lookup
operator|.
name|first
operator|!=
name|Lookup
operator|.
name|second
operator|&&
literal|"No __builtin_shufflevector?"
argument_list|)
expr_stmt|;
comment|// Build a reference to the __builtin_shufflevector builtin
name|FunctionDecl
modifier|*
name|Builtin
init|=
name|cast
operator|<
name|FunctionDecl
operator|>
operator|(
operator|*
name|Lookup
operator|.
name|first
operator|)
decl_stmt|;
name|Expr
modifier|*
name|Callee
init|=
name|new
argument_list|(
argument|SemaRef.Context
argument_list|)
name|DeclRefExpr
argument_list|(
name|Builtin
argument_list|,
name|Builtin
operator|->
name|getType
argument_list|()
argument_list|,
name|BuiltinLoc
argument_list|)
decl_stmt|;
name|SemaRef
operator|.
name|UsualUnaryConversions
argument_list|(
name|Callee
argument_list|)
expr_stmt|;
comment|// Build the CallExpr
name|unsigned
name|NumSubExprs
init|=
name|SubExprs
operator|.
name|size
argument_list|()
decl_stmt|;
name|Expr
modifier|*
modifier|*
name|Subs
init|=
operator|(
name|Expr
operator|*
operator|*
operator|)
name|SubExprs
operator|.
name|release
argument_list|()
decl_stmt|;
name|CallExpr
modifier|*
name|TheCall
init|=
name|new
argument_list|(
argument|SemaRef.Context
argument_list|)
name|CallExpr
argument_list|(
name|SemaRef
operator|.
name|Context
argument_list|,
name|Callee
argument_list|,
name|Subs
argument_list|,
name|NumSubExprs
argument_list|,
name|Builtin
operator|->
name|getResultType
argument_list|()
argument_list|,
name|RParenLoc
argument_list|)
decl_stmt|;
name|OwningExprResult
name|OwnedCall
argument_list|(
name|SemaRef
operator|.
name|Owned
argument_list|(
name|TheCall
argument_list|)
argument_list|)
decl_stmt|;
comment|// Type-check the __builtin_shufflevector expression.
name|OwningExprResult
name|Result
init|=
name|SemaRef
operator|.
name|SemaBuiltinShuffleVector
argument_list|(
name|TheCall
argument_list|)
decl_stmt|;
if|if
condition|(
name|Result
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
name|OwnedCall
operator|.
name|release
argument_list|()
expr_stmt|;
return|return
name|move
argument_list|(
name|Result
argument_list|)
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningStmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformStmt
argument_list|(
argument|Stmt *S
argument_list|)
block|{
if|if
condition|(
operator|!
name|S
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
argument_list|)
return|;
end_expr_stmt

begin_switch
switch|switch
condition|(
name|S
operator|->
name|getStmtClass
argument_list|()
condition|)
block|{
case|case
name|Stmt
operator|::
name|NoStmtClass
case|:
break|break;
comment|// Transform individual statement nodes
define|#
directive|define
name|STMT
parameter_list|(
name|Node
parameter_list|,
name|Parent
parameter_list|)
define|\
value|case Stmt::Node##Class: return getDerived().Transform##Node(cast<Node>(S));
define|#
directive|define
name|EXPR
parameter_list|(
name|Node
parameter_list|,
name|Parent
parameter_list|)
include|#
directive|include
file|"clang/AST/StmtNodes.def"
comment|// Transform expressions by calling TransformExpr.
define|#
directive|define
name|STMT
parameter_list|(
name|Node
parameter_list|,
name|Parent
parameter_list|)
define|#
directive|define
name|ABSTRACT_EXPR
parameter_list|(
name|Node
parameter_list|,
name|Parent
parameter_list|)
define|#
directive|define
name|EXPR
parameter_list|(
name|Node
parameter_list|,
name|Parent
parameter_list|)
value|case Stmt::Node##Class:
include|#
directive|include
file|"clang/AST/StmtNodes.def"
block|{
name|Sema
operator|::
name|OwningExprResult
name|E
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|cast
operator|<
name|Expr
operator|>
operator|(
name|S
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|E
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|getSema
argument_list|()
operator|.
name|StmtError
argument_list|()
return|;
return|return
name|getSema
argument_list|()
operator|.
name|ActOnExprStmt
argument_list|(
name|getSema
argument_list|()
operator|.
name|MakeFullExpr
argument_list|(
name|E
argument_list|)
argument_list|)
return|;
block|}
block|}
end_switch

begin_return
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}   template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformExpr
argument_list|(
argument|Expr *E
argument_list|)
block|{
if|if
condition|(
operator|!
name|E
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
argument_list|)
return|;
end_expr_stmt

begin_switch
switch|switch
condition|(
name|E
operator|->
name|getStmtClass
argument_list|()
condition|)
block|{
case|case
name|Stmt
operator|::
name|NoStmtClass
case|:
break|break;
define|#
directive|define
name|STMT
parameter_list|(
name|Node
parameter_list|,
name|Parent
parameter_list|)
value|case Stmt::Node##Class: break;
define|#
directive|define
name|ABSTRACT_EXPR
parameter_list|(
name|Node
parameter_list|,
name|Parent
parameter_list|)
define|#
directive|define
name|EXPR
parameter_list|(
name|Node
parameter_list|,
name|Parent
parameter_list|)
define|\
value|case Stmt::Node##Class: return getDerived().Transform##Node(cast<Node>(E));
include|#
directive|include
file|"clang/AST/StmtNodes.def"
block|}
end_switch

begin_return
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|NestedNameSpecifier
operator|*
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformNestedNameSpecifier
argument_list|(
argument|NestedNameSpecifier *NNS
argument_list|,
argument|SourceRange Range
argument_list|,
argument|QualType ObjectType
argument_list|,
argument|NamedDecl *FirstQualifierInScope
argument_list|)
block|{
if|if
condition|(
operator|!
name|NNS
condition|)
return|return
literal|0
return|;
comment|// Transform the prefix of this nested name specifier.
name|NestedNameSpecifier
operator|*
name|Prefix
operator|=
name|NNS
operator|->
name|getPrefix
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Prefix
condition|)
block|{
name|Prefix
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformNestedNameSpecifier
argument_list|(
name|Prefix
argument_list|,
name|Range
argument_list|,
name|ObjectType
argument_list|,
name|FirstQualifierInScope
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Prefix
condition|)
return|return
literal|0
return|;
comment|// Clear out the object type and the first qualifier in scope; they only
comment|// apply to the first element in the nested-name-specifier.
name|ObjectType
operator|=
name|QualType
argument_list|()
expr_stmt|;
name|FirstQualifierInScope
operator|=
literal|0
expr_stmt|;
block|}
end_if

begin_switch
switch|switch
condition|(
name|NNS
operator|->
name|getKind
argument_list|()
condition|)
block|{
case|case
name|NestedNameSpecifier
operator|::
name|Identifier
case|:
name|assert
argument_list|(
operator|(
name|Prefix
operator|||
operator|!
name|ObjectType
operator|.
name|isNull
argument_list|()
operator|)
operator|&&
literal|"Identifier nested-name-specifier with no prefix or object type"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Prefix
operator|==
name|NNS
operator|->
name|getPrefix
argument_list|()
operator|&&
name|ObjectType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|NNS
return|;
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildNestedNameSpecifier
argument_list|(
name|Prefix
argument_list|,
name|Range
argument_list|,
operator|*
name|NNS
operator|->
name|getAsIdentifier
argument_list|()
argument_list|,
name|ObjectType
argument_list|,
name|FirstQualifierInScope
argument_list|)
return|;
case|case
name|NestedNameSpecifier
operator|::
name|Namespace
case|:
block|{
name|NamespaceDecl
modifier|*
name|NS
init|=
name|cast_or_null
operator|<
name|NamespaceDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|Range
operator|.
name|getBegin
argument_list|()
argument_list|,
name|NNS
operator|->
name|getAsNamespace
argument_list|()
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Prefix
operator|==
name|NNS
operator|->
name|getPrefix
argument_list|()
operator|&&
name|NS
operator|==
name|NNS
operator|->
name|getAsNamespace
argument_list|()
condition|)
return|return
name|NNS
return|;
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildNestedNameSpecifier
argument_list|(
name|Prefix
argument_list|,
name|Range
argument_list|,
name|NS
argument_list|)
return|;
block|}
case|case
name|NestedNameSpecifier
operator|::
name|Global
case|:
comment|// There is no meaningful transformation that one could perform on the
comment|// global scope.
return|return
name|NNS
return|;
case|case
name|NestedNameSpecifier
operator|::
name|TypeSpecWithTemplate
case|:
case|case
name|NestedNameSpecifier
operator|::
name|TypeSpec
case|:
block|{
name|TemporaryBase
name|Rebase
argument_list|(
operator|*
name|this
argument_list|,
name|Range
operator|.
name|getBegin
argument_list|()
argument_list|,
name|DeclarationName
argument_list|()
argument_list|)
decl_stmt|;
name|QualType
name|T
init|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|QualType
argument_list|(
name|NNS
operator|->
name|getAsType
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|,
name|ObjectType
argument_list|)
decl_stmt|;
if|if
condition|(
name|T
operator|.
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Prefix
operator|==
name|NNS
operator|->
name|getPrefix
argument_list|()
operator|&&
name|T
operator|==
name|QualType
argument_list|(
name|NNS
operator|->
name|getAsType
argument_list|()
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|NNS
return|;
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildNestedNameSpecifier
argument_list|(
name|Prefix
argument_list|,
name|Range
argument_list|,
name|NNS
operator|->
name|getKind
argument_list|()
operator|==
name|NestedNameSpecifier
operator|::
name|TypeSpecWithTemplate
argument_list|,
name|T
argument_list|)
return|;
block|}
block|}
end_switch

begin_comment
comment|// Required to silence a GCC warning
end_comment

begin_return
return|return
literal|0
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|DeclarationName
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformDeclarationName
argument_list|(
argument|DeclarationName Name
argument_list|,
argument|SourceLocation Loc
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
if|if
condition|(
operator|!
name|Name
condition|)
return|return
name|Name
return|;
end_expr_stmt

begin_switch
switch|switch
condition|(
name|Name
operator|.
name|getNameKind
argument_list|()
condition|)
block|{
case|case
name|DeclarationName
operator|::
name|Identifier
case|:
case|case
name|DeclarationName
operator|::
name|ObjCZeroArgSelector
case|:
case|case
name|DeclarationName
operator|::
name|ObjCOneArgSelector
case|:
case|case
name|DeclarationName
operator|::
name|ObjCMultiArgSelector
case|:
case|case
name|DeclarationName
operator|::
name|CXXOperatorName
case|:
case|case
name|DeclarationName
operator|::
name|CXXLiteralOperatorName
case|:
case|case
name|DeclarationName
operator|::
name|CXXUsingDirective
case|:
return|return
name|Name
return|;
case|case
name|DeclarationName
operator|::
name|CXXConstructorName
case|:
case|case
name|DeclarationName
operator|::
name|CXXDestructorName
case|:
case|case
name|DeclarationName
operator|::
name|CXXConversionFunctionName
case|:
block|{
name|TemporaryBase
name|Rebase
argument_list|(
operator|*
name|this
argument_list|,
name|Loc
argument_list|,
name|Name
argument_list|)
decl_stmt|;
name|QualType
name|T
init|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|Name
operator|.
name|getCXXNameType
argument_list|()
argument_list|,
name|ObjectType
argument_list|)
decl_stmt|;
if|if
condition|(
name|T
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|DeclarationName
argument_list|()
return|;
return|return
name|SemaRef
operator|.
name|Context
operator|.
name|DeclarationNames
operator|.
name|getCXXSpecialName
argument_list|(
name|Name
operator|.
name|getNameKind
argument_list|()
argument_list|,
name|SemaRef
operator|.
name|Context
operator|.
name|getCanonicalType
argument_list|(
name|T
argument_list|)
argument_list|)
return|;
block|}
block|}
end_switch

begin_return
return|return
name|DeclarationName
argument_list|()
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|TemplateName
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformTemplateName
argument_list|(
argument|TemplateName Name
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
name|SourceLocation
name|Loc
operator|=
name|getDerived
argument_list|()
operator|.
name|getBaseLocation
argument_list|()
block|;
if|if
condition|(
name|QualifiedTemplateName
modifier|*
name|QTN
init|=
name|Name
operator|.
name|getAsQualifiedTemplateName
argument_list|()
condition|)
block|{
name|NestedNameSpecifier
modifier|*
name|NNS
init|=
name|getDerived
argument_list|()
operator|.
name|TransformNestedNameSpecifier
argument_list|(
name|QTN
operator|->
name|getQualifier
argument_list|()
argument_list|,
comment|/*FIXME:*/
name|SourceRange
argument_list|(
name|getDerived
argument_list|()
operator|.
name|getBaseLocation
argument_list|()
argument_list|)
argument_list|,
name|ObjectType
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|NNS
condition|)
return|return
name|TemplateName
argument_list|()
return|;
if|if
condition|(
name|TemplateDecl
modifier|*
name|Template
init|=
name|QTN
operator|->
name|getTemplateDecl
argument_list|()
condition|)
block|{
name|TemplateDecl
modifier|*
name|TransTemplate
init|=
name|cast_or_null
operator|<
name|TemplateDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|Loc
argument_list|,
name|Template
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|TransTemplate
condition|)
return|return
name|TemplateName
argument_list|()
return|;
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|NNS
operator|==
name|QTN
operator|->
name|getQualifier
argument_list|()
operator|&&
name|TransTemplate
operator|==
name|Template
condition|)
return|return
name|Name
return|;
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildTemplateName
argument_list|(
name|NNS
argument_list|,
name|QTN
operator|->
name|hasTemplateKeyword
argument_list|()
argument_list|,
name|TransTemplate
argument_list|)
return|;
block|}
comment|// These should be getting filtered out before they make it into the AST.
name|assert
argument_list|(
name|false
operator|&&
literal|"overloaded template name survived to here"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}    if
operator|(
name|DependentTemplateName
operator|*
name|DTN
operator|=
name|Name
operator|.
name|getAsDependentTemplateName
argument_list|()
operator|)
block|{
name|NestedNameSpecifier
operator|*
name|NNS
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformNestedNameSpecifier
argument_list|(
name|DTN
operator|->
name|getQualifier
argument_list|()
argument_list|,
comment|/*FIXME:*/
name|SourceRange
argument_list|(
name|getDerived
argument_list|()
operator|.
name|getBaseLocation
argument_list|()
argument_list|)
argument_list|,
name|ObjectType
argument_list|)
block|;
if|if
condition|(
operator|!
name|NNS
operator|&&
name|DTN
operator|->
name|getQualifier
argument_list|()
condition|)
return|return
name|TemplateName
argument_list|()
return|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|NNS
operator|==
name|DTN
operator|->
name|getQualifier
argument_list|()
operator|&&
name|ObjectType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|Name
return|;
end_if

begin_if
if|if
condition|(
name|DTN
operator|->
name|isIdentifier
argument_list|()
condition|)
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildTemplateName
argument_list|(
name|NNS
argument_list|,
operator|*
name|DTN
operator|->
name|getIdentifier
argument_list|()
argument_list|,
name|ObjectType
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildTemplateName
argument_list|(
name|NNS
argument_list|,
name|DTN
operator|->
name|getOperator
argument_list|()
argument_list|,
name|ObjectType
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}    if
operator|(
name|TemplateDecl
operator|*
name|Template
operator|=
name|Name
operator|.
name|getAsTemplateDecl
argument_list|()
operator|)
block|{
name|TemplateDecl
operator|*
name|TransTemplate
operator|=
name|cast_or_null
operator|<
name|TemplateDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|Loc
argument_list|,
name|Template
argument_list|)
operator|)
block|;
if|if
condition|(
operator|!
name|TransTemplate
condition|)
return|return
name|TemplateName
argument_list|()
return|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|TransTemplate
operator|==
name|Template
condition|)
return|return
name|Name
return|;
end_if

begin_return
return|return
name|TemplateName
argument_list|(
name|TransTemplate
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|// These should be getting filtered out before they reach the AST.
end_comment

begin_expr_stmt
unit|assert
operator|(
name|false
operator|&&
literal|"overloaded function decl survived to here"
operator|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|TemplateName
argument_list|()
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|void
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|InventTemplateArgumentLoc
argument_list|(
argument|const TemplateArgument&Arg
argument_list|,
argument|TemplateArgumentLoc&Output
argument_list|)
block|{
name|SourceLocation
name|Loc
operator|=
name|getDerived
argument_list|()
operator|.
name|getBaseLocation
argument_list|()
block|;
switch|switch
condition|(
name|Arg
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|TemplateArgument
operator|::
name|Null
case|:
name|llvm_unreachable
argument_list|(
literal|"null template argument in TreeTransform"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TemplateArgument
operator|::
name|Type
case|:
name|Output
operator|=
name|TemplateArgumentLoc
argument_list|(
name|Arg
argument_list|,
name|SemaRef
operator|.
name|Context
operator|.
name|getTrivialTypeSourceInfo
argument_list|(
name|Arg
operator|.
name|getAsType
argument_list|()
argument_list|,
name|Loc
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|TemplateArgument
operator|::
name|Template
case|:
name|Output
operator|=
name|TemplateArgumentLoc
argument_list|(
name|Arg
argument_list|,
name|SourceRange
argument_list|()
argument_list|,
name|Loc
argument_list|)
expr_stmt|;
break|break;
case|case
name|TemplateArgument
operator|::
name|Expression
case|:
name|Output
operator|=
name|TemplateArgumentLoc
argument_list|(
name|Arg
argument_list|,
name|Arg
operator|.
name|getAsExpr
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|TemplateArgument
operator|::
name|Declaration
case|:
case|case
name|TemplateArgument
operator|::
name|Integral
case|:
case|case
name|TemplateArgument
operator|::
name|Pack
case|:
name|Output
operator|=
name|TemplateArgumentLoc
argument_list|(
name|Arg
argument_list|,
name|TemplateArgumentLocInfo
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformTemplateArgument
argument_list|(
argument|const TemplateArgumentLoc&Input
argument_list|,
argument|TemplateArgumentLoc&Output
argument_list|)
block|{
specifier|const
name|TemplateArgument
operator|&
name|Arg
operator|=
name|Input
operator|.
name|getArgument
argument_list|()
block|;
switch|switch
condition|(
name|Arg
operator|.
name|getKind
argument_list|()
condition|)
block|{
case|case
name|TemplateArgument
operator|::
name|Null
case|:
case|case
name|TemplateArgument
operator|::
name|Integral
case|:
name|Output
operator|=
name|Input
expr_stmt|;
return|return
name|false
return|;
case|case
name|TemplateArgument
operator|::
name|Type
case|:
block|{
name|TypeSourceInfo
modifier|*
name|DI
init|=
name|Input
operator|.
name|getTypeSourceInfo
argument_list|()
decl_stmt|;
if|if
condition|(
name|DI
operator|==
name|NULL
condition|)
name|DI
operator|=
name|InventTypeSourceInfo
argument_list|(
name|Input
operator|.
name|getArgument
argument_list|()
operator|.
name|getAsType
argument_list|()
argument_list|)
expr_stmt|;
name|DI
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|DI
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DI
condition|)
return|return
name|true
return|;
name|Output
operator|=
name|TemplateArgumentLoc
argument_list|(
name|TemplateArgument
argument_list|(
name|DI
operator|->
name|getType
argument_list|()
argument_list|)
argument_list|,
name|DI
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_expr_stmt

begin_case
case|case
name|TemplateArgument
operator|::
name|Declaration
case|:
end_case

begin_block
block|{
comment|// FIXME: we should never have to transform one of these.
name|DeclarationName
name|Name
decl_stmt|;
if|if
condition|(
name|NamedDecl
modifier|*
name|ND
init|=
name|dyn_cast
operator|<
name|NamedDecl
operator|>
operator|(
name|Arg
operator|.
name|getAsDecl
argument_list|()
operator|)
condition|)
name|Name
operator|=
name|ND
operator|->
name|getDeclName
argument_list|()
expr_stmt|;
name|TemporaryBase
name|Rebase
argument_list|(
operator|*
name|this
argument_list|,
name|Input
operator|.
name|getLocation
argument_list|()
argument_list|,
name|Name
argument_list|)
decl_stmt|;
name|Decl
modifier|*
name|D
init|=
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|Input
operator|.
name|getLocation
argument_list|()
argument_list|,
name|Arg
operator|.
name|getAsDecl
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|D
condition|)
return|return
name|true
return|;
name|Expr
modifier|*
name|SourceExpr
init|=
name|Input
operator|.
name|getSourceDeclExpression
argument_list|()
decl_stmt|;
if|if
condition|(
name|SourceExpr
condition|)
block|{
name|EnterExpressionEvaluationContext
name|Unevaluated
argument_list|(
name|getSema
argument_list|()
argument_list|,
name|Action
operator|::
name|Unevaluated
argument_list|)
decl_stmt|;
name|Sema
operator|::
name|OwningExprResult
name|E
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|SourceExpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|E
operator|.
name|isInvalid
argument_list|()
condition|)
name|SourceExpr
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|SourceExpr
operator|=
name|E
operator|.
name|takeAs
operator|<
name|Expr
operator|>
operator|(
operator|)
expr_stmt|;
name|SourceExpr
operator|->
name|Retain
argument_list|()
expr_stmt|;
block|}
block|}
name|Output
operator|=
name|TemplateArgumentLoc
argument_list|(
name|TemplateArgument
argument_list|(
name|D
argument_list|)
argument_list|,
name|SourceExpr
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_block

begin_case
case|case
name|TemplateArgument
operator|::
name|Template
case|:
end_case

begin_block
block|{
name|TemporaryBase
name|Rebase
argument_list|(
operator|*
name|this
argument_list|,
name|Input
operator|.
name|getLocation
argument_list|()
argument_list|,
name|DeclarationName
argument_list|()
argument_list|)
decl_stmt|;
name|TemplateName
name|Template
init|=
name|getDerived
argument_list|()
operator|.
name|TransformTemplateName
argument_list|(
name|Arg
operator|.
name|getAsTemplate
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|Template
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|true
return|;
name|Output
operator|=
name|TemplateArgumentLoc
argument_list|(
name|TemplateArgument
argument_list|(
name|Template
argument_list|)
argument_list|,
name|Input
operator|.
name|getTemplateQualifierRange
argument_list|()
argument_list|,
name|Input
operator|.
name|getTemplateNameLoc
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_block

begin_case
case|case
name|TemplateArgument
operator|::
name|Expression
case|:
end_case

begin_block
block|{
comment|// Template argument expressions are not potentially evaluated.
name|EnterExpressionEvaluationContext
name|Unevaluated
argument_list|(
name|getSema
argument_list|()
argument_list|,
name|Action
operator|::
name|Unevaluated
argument_list|)
decl_stmt|;
name|Expr
modifier|*
name|InputExpr
init|=
name|Input
operator|.
name|getSourceExpression
argument_list|()
decl_stmt|;
if|if
condition|(
operator|!
name|InputExpr
condition|)
name|InputExpr
operator|=
name|Input
operator|.
name|getArgument
argument_list|()
operator|.
name|getAsExpr
argument_list|()
expr_stmt|;
name|Sema
operator|::
name|OwningExprResult
name|E
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|InputExpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|E
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|true
return|;
name|Expr
modifier|*
name|ETaken
init|=
name|E
operator|.
name|takeAs
operator|<
name|Expr
operator|>
operator|(
operator|)
decl_stmt|;
name|ETaken
operator|->
name|Retain
argument_list|()
expr_stmt|;
name|Output
operator|=
name|TemplateArgumentLoc
argument_list|(
name|TemplateArgument
argument_list|(
name|ETaken
argument_list|)
argument_list|,
name|ETaken
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_block

begin_case
case|case
name|TemplateArgument
operator|::
name|Pack
case|:
end_case

begin_block
block|{
name|llvm
operator|::
name|SmallVector
operator|<
name|TemplateArgument
operator|,
literal|4
operator|>
name|TransformedArgs
expr_stmt|;
name|TransformedArgs
operator|.
name|reserve
argument_list|(
name|Arg
operator|.
name|pack_size
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|TemplateArgument
operator|::
name|pack_iterator
name|A
operator|=
name|Arg
operator|.
name|pack_begin
argument_list|()
operator|,
name|AEnd
operator|=
name|Arg
operator|.
name|pack_end
argument_list|()
init|;
name|A
operator|!=
name|AEnd
condition|;
operator|++
name|A
control|)
block|{
comment|// FIXME: preserve source information here when we start
comment|// caring about parameter packs.
name|TemplateArgumentLoc
name|InputArg
decl_stmt|;
name|TemplateArgumentLoc
name|OutputArg
decl_stmt|;
name|getDerived
argument_list|()
operator|.
name|InventTemplateArgumentLoc
argument_list|(
operator|*
name|A
argument_list|,
name|InputArg
argument_list|)
expr_stmt|;
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TransformTemplateArgument
argument_list|(
name|InputArg
argument_list|,
name|OutputArg
argument_list|)
condition|)
return|return
name|true
return|;
name|TransformedArgs
operator|.
name|push_back
argument_list|(
name|OutputArg
operator|.
name|getArgument
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|TemplateArgument
name|Result
decl_stmt|;
name|Result
operator|.
name|setArgumentPack
argument_list|(
name|TransformedArgs
operator|.
name|data
argument_list|()
argument_list|,
name|TransformedArgs
operator|.
name|size
argument_list|()
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|Output
operator|=
name|TemplateArgumentLoc
argument_list|(
name|Result
argument_list|,
name|Input
operator|.
name|getLocInfo
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_block

begin_comment
unit|}
comment|// Work around bogus GCC warning
end_comment

begin_expr_stmt
unit|return
name|true
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// Type transformation
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformType
argument_list|(
argument|QualType T
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlreadyTransformed
argument_list|(
name|T
argument_list|)
condition|)
return|return
name|T
return|;
comment|// Temporary workaround.  All of these transformations should
comment|// eventually turn into transformations on TypeLocs.
name|TypeSourceInfo
operator|*
name|DI
operator|=
name|getSema
argument_list|()
operator|.
name|Context
operator|.
name|CreateTypeSourceInfo
argument_list|(
name|T
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|DI
operator|->
name|getTypeLoc
argument_list|()
operator|.
name|initialize
argument_list|(
name|getDerived
argument_list|()
operator|.
name|getBaseLocation
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|TypeSourceInfo
modifier|*
name|NewDI
init|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|DI
argument_list|,
name|ObjectType
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
operator|!
name|NewDI
condition|)
return|return
name|QualType
argument_list|()
return|;
end_if

begin_return
return|return
name|NewDI
operator|->
name|getType
argument_list|()
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|TypeSourceInfo
operator|*
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformType
argument_list|(
argument|TypeSourceInfo *DI
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlreadyTransformed
argument_list|(
name|DI
operator|->
name|getType
argument_list|()
argument_list|)
condition|)
return|return
name|DI
return|;
name|TypeLocBuilder
name|TLB
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|TypeLoc
name|TL
init|=
name|DI
operator|->
name|getTypeLoc
argument_list|()
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|TLB
operator|.
name|reserve
argument_list|(
name|TL
operator|.
name|getFullDataSize
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|QualType
name|Result
init|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|TLB
argument_list|,
name|TL
argument_list|,
name|ObjectType
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
literal|0
return|;
end_if

begin_return
return|return
name|TLB
operator|.
name|getTypeSourceInfo
argument_list|(
name|SemaRef
operator|.
name|Context
argument_list|,
name|Result
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|TypeLoc T
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
switch|switch
condition|(
name|T
operator|.
name|getTypeLocClass
argument_list|()
condition|)
block|{
define|#
directive|define
name|ABSTRACT_TYPELOC
parameter_list|(
name|CLASS
parameter_list|,
name|PARENT
parameter_list|)
define|#
directive|define
name|TYPELOC
parameter_list|(
name|CLASS
parameter_list|,
name|PARENT
parameter_list|)
define|\
value|case TypeLoc::CLASS: \     return getDerived().Transform##CLASS##Type(TLB, cast<CLASS##TypeLoc>(T), \                                                ObjectType);
include|#
directive|include
file|"clang/AST/TypeLocNodes.def"
block|}
name|llvm_unreachable
argument_list|(
literal|"unhandled type loc!"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|QualType
argument_list|()
return|;
end_return

begin_comment
unit|}
comment|/// FIXME: By default, this routine adds type qualifiers only to types
end_comment

begin_comment
comment|/// that can have qualifiers, and silently suppresses those qualifiers
end_comment

begin_comment
comment|/// that are not permitted (e.g., qualifiers on reference or function
end_comment

begin_comment
comment|/// types). This is the right thing for template instantiation, but
end_comment

begin_comment
comment|/// probably not for other clients.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformQualifiedType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|QualifiedTypeLoc T
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
name|Qualifiers
name|Quals
operator|=
name|T
operator|.
name|getType
argument_list|()
operator|.
name|getLocalQualifiers
argument_list|()
block|;
name|QualType
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|TLB
argument_list|,
name|T
operator|.
name|getUnqualifiedLoc
argument_list|()
argument_list|,
name|ObjectType
argument_list|)
block|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
end_expr_stmt

begin_comment
comment|// Silently suppress qualifiers if the result type can't be qualified.
end_comment

begin_comment
comment|// FIXME: this is the right thing for template instantiation, but
end_comment

begin_comment
comment|// probably not for other clients.
end_comment

begin_if
if|if
condition|(
name|Result
operator|->
name|isFunctionType
argument_list|()
operator|||
name|Result
operator|->
name|isReferenceType
argument_list|()
condition|)
return|return
name|Result
return|;
end_if

begin_expr_stmt
name|Result
operator|=
name|SemaRef
operator|.
name|Context
operator|.
name|getQualifiedType
argument_list|(
name|Result
argument_list|,
name|Quals
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TLB
operator|.
name|push
operator|<
name|QualifiedTypeLoc
operator|>
operator|(
name|Result
operator|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// No location information to preserve.
end_comment

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|class
name|TyLoc
operator|>
specifier|static
specifier|inline
name|QualType
name|TransformTypeSpecType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|TyLoc T
argument_list|)
block|{
name|TyLoc
name|NewT
operator|=
name|TLB
operator|.
name|push
operator|<
name|TyLoc
operator|>
operator|(
name|T
operator|.
name|getType
argument_list|()
operator|)
block|;
name|NewT
operator|.
name|setNameLoc
argument_list|(
name|T
operator|.
name|getNameLoc
argument_list|()
argument_list|)
block|;
return|return
name|T
operator|.
name|getType
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|// Ugly metaprogramming macros because I couldn't be bothered to make
end_comment

begin_comment
comment|// the equivalent template version work.
end_comment

begin_define
define|#
directive|define
name|TransformPointerLikeType
parameter_list|(
name|TypeClass
parameter_list|)
value|do { \   QualType PointeeType                                       \     = getDerived().TransformType(TLB, TL.getPointeeLoc());   \   if (PointeeType.isNull())                                  \     return QualType();                                       \                                                              \   QualType Result = TL.getType();                            \   if (getDerived().AlwaysRebuild() ||                        \       PointeeType != TL.getPointeeLoc().getType()) {         \     Result = getDerived().Rebuild##TypeClass(PointeeType,    \                                           TL.getSigilLoc()); \     if (Result.isNull())                                     \       return QualType();                                     \   }                                                          \                                                              \   TypeClass##Loc NewT = TLB.push<TypeClass##Loc>(Result);    \   NewT.setSigilLoc(TL.getSigilLoc());                        \                                                              \   return Result;                                             \ } while(0)
end_define

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformBuiltinType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|BuiltinTypeLoc T
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
name|BuiltinTypeLoc
name|NewT
operator|=
name|TLB
operator|.
name|push
operator|<
name|BuiltinTypeLoc
operator|>
operator|(
name|T
operator|.
name|getType
argument_list|()
operator|)
block|;
name|NewT
operator|.
name|setBuiltinLoc
argument_list|(
name|T
operator|.
name|getBuiltinLoc
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|T
operator|.
name|needsExtraLocalData
argument_list|()
condition|)
name|NewT
operator|.
name|getWrittenBuiltinSpecs
argument_list|()
operator|=
name|T
operator|.
name|getWrittenBuiltinSpecs
argument_list|()
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|T
operator|.
name|getType
argument_list|()
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformComplexType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|ComplexTypeLoc T
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
comment|// FIXME: recurse?
return|return
name|TransformTypeSpecType
argument_list|(
name|TLB
argument_list|,
name|T
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformPointerType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|PointerTypeLoc TL
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
name|TransformPointerLikeType
argument_list|(
name|PointerType
argument_list|)
block|; }
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformBlockPointerType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|BlockPointerTypeLoc TL
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
name|TransformPointerLikeType
argument_list|(
name|BlockPointerType
argument_list|)
block|; }
comment|/// Transforms a reference type.  Note that somewhat paradoxically we
comment|/// don't care whether the type itself is an l-value type or an r-value
comment|/// type;  we only care if the type was *written* as an l-value type
comment|/// or an r-value type.
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformReferenceType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|ReferenceTypeLoc TL
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
specifier|const
name|ReferenceType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
comment|// Note that this works with the pointee-as-written.
name|QualType
name|PointeeType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|TLB
argument_list|,
name|TL
operator|.
name|getPointeeLoc
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|PointeeType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
name|QualType
name|Result
operator|=
name|TL
operator|.
name|getType
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|PointeeType
operator|!=
name|T
operator|->
name|getPointeeTypeAsWritten
argument_list|()
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildReferenceType
argument_list|(
name|PointeeType
argument_list|,
name|T
operator|->
name|isSpelledAsLValue
argument_list|()
argument_list|,
name|TL
operator|.
name|getSigilLoc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_if

begin_comment
comment|// r-value references can be rebuilt as l-value references.
end_comment

begin_decl_stmt
name|ReferenceTypeLoc
name|NewTL
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|isa
operator|<
name|LValueReferenceType
operator|>
operator|(
name|Result
operator|)
condition|)
name|NewTL
operator|=
name|TLB
operator|.
name|push
operator|<
name|LValueReferenceTypeLoc
operator|>
operator|(
name|Result
operator|)
expr_stmt|;
else|else
name|NewTL
operator|=
name|TLB
operator|.
name|push
operator|<
name|RValueReferenceTypeLoc
operator|>
operator|(
name|Result
operator|)
expr_stmt|;
end_if

begin_expr_stmt
name|NewTL
operator|.
name|setSigilLoc
argument_list|(
name|TL
operator|.
name|getSigilLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformLValueReferenceType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|LValueReferenceTypeLoc TL
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
return|return
name|TransformReferenceType
argument_list|(
name|TLB
argument_list|,
name|TL
argument_list|,
name|ObjectType
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformRValueReferenceType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|RValueReferenceTypeLoc TL
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
return|return
name|TransformReferenceType
argument_list|(
name|TLB
argument_list|,
name|TL
argument_list|,
name|ObjectType
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformMemberPointerType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|MemberPointerTypeLoc TL
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
name|MemberPointerType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
name|QualType
name|PointeeType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|TLB
argument_list|,
name|TL
operator|.
name|getPointeeLoc
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|PointeeType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
comment|// TODO: preserve source information for this.
name|QualType
name|ClassType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|QualType
argument_list|(
name|T
operator|->
name|getClass
argument_list|()
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|ClassType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
end_if

begin_decl_stmt
name|QualType
name|Result
init|=
name|TL
operator|.
name|getType
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|PointeeType
operator|!=
name|T
operator|->
name|getPointeeType
argument_list|()
operator|||
name|ClassType
operator|!=
name|QualType
argument_list|(
name|T
operator|->
name|getClass
argument_list|()
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildMemberPointerType
argument_list|(
name|PointeeType
argument_list|,
name|ClassType
argument_list|,
name|TL
operator|.
name|getStarLoc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|MemberPointerTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|MemberPointerTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setSigilLoc
argument_list|(
name|TL
operator|.
name|getSigilLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformConstantArrayType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|ConstantArrayTypeLoc TL
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
name|ConstantArrayType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
name|QualType
name|ElementType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|TLB
argument_list|,
name|TL
operator|.
name|getElementLoc
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|ElementType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
name|QualType
name|Result
operator|=
name|TL
operator|.
name|getType
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|ElementType
operator|!=
name|T
operator|->
name|getElementType
argument_list|()
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildConstantArrayType
argument_list|(
name|ElementType
argument_list|,
name|T
operator|->
name|getSizeModifier
argument_list|()
argument_list|,
name|T
operator|->
name|getSize
argument_list|()
argument_list|,
name|T
operator|->
name|getIndexTypeCVRQualifiers
argument_list|()
argument_list|,
name|TL
operator|.
name|getBracketsRange
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|ConstantArrayTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|ConstantArrayTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setLBracketLoc
argument_list|(
name|TL
operator|.
name|getLBracketLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setRBracketLoc
argument_list|(
name|TL
operator|.
name|getRBracketLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Expr
modifier|*
name|Size
init|=
name|TL
operator|.
name|getSizeExpr
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Size
condition|)
block|{
name|EnterExpressionEvaluationContext
name|Unevaluated
argument_list|(
name|SemaRef
argument_list|,
name|Action
operator|::
name|Unevaluated
argument_list|)
decl_stmt|;
name|Size
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|Size
argument_list|)
operator|.
name|template
name|takeAs
operator|<
name|Expr
operator|>
operator|(
operator|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|NewTL
operator|.
name|setSizeExpr
argument_list|(
name|Size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformIncompleteArrayType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|IncompleteArrayTypeLoc TL
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
name|IncompleteArrayType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
name|QualType
name|ElementType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|TLB
argument_list|,
name|TL
operator|.
name|getElementLoc
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|ElementType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
name|QualType
name|Result
operator|=
name|TL
operator|.
name|getType
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|ElementType
operator|!=
name|T
operator|->
name|getElementType
argument_list|()
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildIncompleteArrayType
argument_list|(
name|ElementType
argument_list|,
name|T
operator|->
name|getSizeModifier
argument_list|()
argument_list|,
name|T
operator|->
name|getIndexTypeCVRQualifiers
argument_list|()
argument_list|,
name|TL
operator|.
name|getBracketsRange
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|IncompleteArrayTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|IncompleteArrayTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setLBracketLoc
argument_list|(
name|TL
operator|.
name|getLBracketLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setRBracketLoc
argument_list|(
name|TL
operator|.
name|getRBracketLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setSizeExpr
argument_list|(
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformVariableArrayType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|VariableArrayTypeLoc TL
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
name|VariableArrayType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
name|QualType
name|ElementType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|TLB
argument_list|,
name|TL
operator|.
name|getElementLoc
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|ElementType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
comment|// Array bounds are not potentially evaluated contexts
name|EnterExpressionEvaluationContext
name|Unevaluated
argument_list|(
name|SemaRef
argument_list|,
name|Action
operator|::
name|Unevaluated
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Sema
operator|::
name|OwningExprResult
name|SizeResult
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|T
operator|->
name|getSizeExpr
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|SizeResult
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
end_if

begin_decl_stmt
name|Expr
modifier|*
name|Size
init|=
name|static_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SizeResult
operator|.
name|get
argument_list|()
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|QualType
name|Result
init|=
name|TL
operator|.
name|getType
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|ElementType
operator|!=
name|T
operator|->
name|getElementType
argument_list|()
operator|||
name|Size
operator|!=
name|T
operator|->
name|getSizeExpr
argument_list|()
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildVariableArrayType
argument_list|(
name|ElementType
argument_list|,
name|T
operator|->
name|getSizeModifier
argument_list|()
argument_list|,
name|move
argument_list|(
name|SizeResult
argument_list|)
argument_list|,
name|T
operator|->
name|getIndexTypeCVRQualifiers
argument_list|()
argument_list|,
name|TL
operator|.
name|getBracketsRange
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
else|else
name|SizeResult
operator|.
name|take
argument_list|()
expr_stmt|;
end_if

begin_decl_stmt
name|VariableArrayTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|VariableArrayTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setLBracketLoc
argument_list|(
name|TL
operator|.
name|getLBracketLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setRBracketLoc
argument_list|(
name|TL
operator|.
name|getRBracketLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setSizeExpr
argument_list|(
name|Size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformDependentSizedArrayType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|DependentSizedArrayTypeLoc TL
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
name|DependentSizedArrayType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
name|QualType
name|ElementType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|TLB
argument_list|,
name|TL
operator|.
name|getElementLoc
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|ElementType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
comment|// Array bounds are not potentially evaluated contexts
name|EnterExpressionEvaluationContext
name|Unevaluated
argument_list|(
name|SemaRef
argument_list|,
name|Action
operator|::
name|Unevaluated
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Sema
operator|::
name|OwningExprResult
name|SizeResult
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|T
operator|->
name|getSizeExpr
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|SizeResult
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
end_if

begin_decl_stmt
name|Expr
modifier|*
name|Size
init|=
name|static_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|SizeResult
operator|.
name|get
argument_list|()
operator|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|QualType
name|Result
init|=
name|TL
operator|.
name|getType
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|ElementType
operator|!=
name|T
operator|->
name|getElementType
argument_list|()
operator|||
name|Size
operator|!=
name|T
operator|->
name|getSizeExpr
argument_list|()
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildDependentSizedArrayType
argument_list|(
name|ElementType
argument_list|,
name|T
operator|->
name|getSizeModifier
argument_list|()
argument_list|,
name|move
argument_list|(
name|SizeResult
argument_list|)
argument_list|,
name|T
operator|->
name|getIndexTypeCVRQualifiers
argument_list|()
argument_list|,
name|TL
operator|.
name|getBracketsRange
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
else|else
name|SizeResult
operator|.
name|take
argument_list|()
expr_stmt|;
end_if

begin_comment
comment|// We might have any sort of array type now, but fortunately they
end_comment

begin_comment
comment|// all have the same location layout.
end_comment

begin_decl_stmt
name|ArrayTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|ArrayTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setLBracketLoc
argument_list|(
name|TL
operator|.
name|getLBracketLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setRBracketLoc
argument_list|(
name|TL
operator|.
name|getRBracketLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setSizeExpr
argument_list|(
name|Size
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformDependentSizedExtVectorType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|DependentSizedExtVectorTypeLoc TL
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
name|DependentSizedExtVectorType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
comment|// FIXME: ext vector locs should be nested
name|QualType
name|ElementType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|T
operator|->
name|getElementType
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|ElementType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
comment|// Vector sizes are not potentially evaluated contexts
name|EnterExpressionEvaluationContext
name|Unevaluated
argument_list|(
name|SemaRef
argument_list|,
name|Action
operator|::
name|Unevaluated
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Sema
operator|::
name|OwningExprResult
name|Size
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|T
operator|->
name|getSizeExpr
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Size
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
end_if

begin_decl_stmt
name|QualType
name|Result
init|=
name|TL
operator|.
name|getType
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|ElementType
operator|!=
name|T
operator|->
name|getElementType
argument_list|()
operator|||
name|Size
operator|.
name|get
argument_list|()
operator|!=
name|T
operator|->
name|getSizeExpr
argument_list|()
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildDependentSizedExtVectorType
argument_list|(
name|ElementType
argument_list|,
name|move
argument_list|(
name|Size
argument_list|)
argument_list|,
name|T
operator|->
name|getAttributeLoc
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
else|else
name|Size
operator|.
name|take
argument_list|()
expr_stmt|;
end_if

begin_comment
comment|// Result might be dependent or not.
end_comment

begin_if
if|if
condition|(
name|isa
operator|<
name|DependentSizedExtVectorType
operator|>
operator|(
name|Result
operator|)
condition|)
block|{
name|DependentSizedExtVectorTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|DependentSizedExtVectorTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
name|NewTL
operator|.
name|setNameLoc
argument_list|(
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ExtVectorTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|ExtVectorTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
name|NewTL
operator|.
name|setNameLoc
argument_list|(
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_if

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformVectorType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|VectorTypeLoc TL
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
name|VectorType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
name|QualType
name|ElementType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|T
operator|->
name|getElementType
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|ElementType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
name|QualType
name|Result
operator|=
name|TL
operator|.
name|getType
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|ElementType
operator|!=
name|T
operator|->
name|getElementType
argument_list|()
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildVectorType
argument_list|(
name|ElementType
argument_list|,
name|T
operator|->
name|getNumElements
argument_list|()
argument_list|,
name|T
operator|->
name|isAltiVec
argument_list|()
argument_list|,
name|T
operator|->
name|isPixel
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|VectorTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|VectorTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setNameLoc
argument_list|(
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformExtVectorType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|ExtVectorTypeLoc TL
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
name|VectorType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
name|QualType
name|ElementType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|T
operator|->
name|getElementType
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|ElementType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
name|QualType
name|Result
operator|=
name|TL
operator|.
name|getType
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|ElementType
operator|!=
name|T
operator|->
name|getElementType
argument_list|()
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildExtVectorType
argument_list|(
name|ElementType
argument_list|,
name|T
operator|->
name|getNumElements
argument_list|()
argument_list|,
comment|/*FIXME*/
name|SourceLocation
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|ExtVectorTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|ExtVectorTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setNameLoc
argument_list|(
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|ParmVarDecl
operator|*
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformFunctionTypeParam
argument_list|(
argument|ParmVarDecl *OldParm
argument_list|)
block|{
name|TypeSourceInfo
operator|*
name|OldDI
operator|=
name|OldParm
operator|->
name|getTypeSourceInfo
argument_list|()
block|;
name|TypeSourceInfo
operator|*
name|NewDI
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|OldDI
argument_list|)
block|;
if|if
condition|(
operator|!
name|NewDI
condition|)
return|return
literal|0
return|;
end_expr_stmt

begin_if
if|if
condition|(
name|NewDI
operator|==
name|OldDI
condition|)
return|return
name|OldParm
return|;
else|else
return|return
name|ParmVarDecl
operator|::
name|Create
argument_list|(
name|SemaRef
operator|.
name|Context
argument_list|,
name|OldParm
operator|->
name|getDeclContext
argument_list|()
argument_list|,
name|OldParm
operator|->
name|getLocation
argument_list|()
argument_list|,
name|OldParm
operator|->
name|getIdentifier
argument_list|()
argument_list|,
name|NewDI
operator|->
name|getType
argument_list|()
argument_list|,
name|NewDI
argument_list|,
name|OldParm
operator|->
name|getStorageClass
argument_list|()
argument_list|,
comment|/* DefArg */
name|NULL
argument_list|)
return|;
end_if

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|bool
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformFunctionTypeParams
argument_list|(
argument|FunctionProtoTypeLoc TL
argument_list|,
argument|llvm::SmallVectorImpl<QualType>&PTypes
argument_list|,
argument|llvm::SmallVectorImpl<ParmVarDecl*>&PVars
argument_list|)
block|{
name|FunctionProtoType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|TL
operator|.
name|getNumArgs
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
name|ParmVarDecl
modifier|*
name|OldParm
init|=
name|TL
operator|.
name|getArg
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|QualType
name|NewType
decl_stmt|;
name|ParmVarDecl
modifier|*
name|NewParm
decl_stmt|;
if|if
condition|(
name|OldParm
condition|)
block|{
name|NewParm
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformFunctionTypeParam
argument_list|(
name|OldParm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|NewParm
condition|)
return|return
name|true
return|;
name|NewType
operator|=
name|NewParm
operator|->
name|getType
argument_list|()
expr_stmt|;
comment|// Deal with the possibility that we don't have a parameter
comment|// declaration for this parameter.
block|}
end_expr_stmt

begin_else
else|else
block|{
name|NewParm
operator|=
literal|0
expr_stmt|;
name|QualType
name|OldType
init|=
name|T
operator|->
name|getArgType
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|NewType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|OldType
argument_list|)
expr_stmt|;
if|if
condition|(
name|NewType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|true
return|;
block|}
end_else

begin_expr_stmt
name|PTypes
operator|.
name|push_back
argument_list|(
name|NewType
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|PVars
operator|.
name|push_back
argument_list|(
name|NewParm
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}    return
name|false
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformFunctionProtoType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|FunctionProtoTypeLoc TL
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
name|FunctionProtoType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
name|QualType
name|ResultType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|TLB
argument_list|,
name|TL
operator|.
name|getResultLoc
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|ResultType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
comment|// Transform the parameters.
name|llvm
operator|::
name|SmallVector
operator|<
name|QualType
operator|,
literal|4
operator|>
name|ParamTypes
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|llvm
operator|::
name|SmallVector
operator|<
name|ParmVarDecl
operator|*
operator|,
literal|4
operator|>
name|ParamDecls
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TransformFunctionTypeParams
argument_list|(
name|TL
argument_list|,
name|ParamTypes
argument_list|,
name|ParamDecls
argument_list|)
condition|)
return|return
name|QualType
argument_list|()
return|;
end_if

begin_decl_stmt
name|QualType
name|Result
init|=
name|TL
operator|.
name|getType
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|ResultType
operator|!=
name|T
operator|->
name|getResultType
argument_list|()
operator|||
operator|!
name|std
operator|::
name|equal
argument_list|(
name|T
operator|->
name|arg_type_begin
argument_list|()
argument_list|,
name|T
operator|->
name|arg_type_end
argument_list|()
argument_list|,
name|ParamTypes
operator|.
name|begin
argument_list|()
argument_list|)
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildFunctionProtoType
argument_list|(
name|ResultType
argument_list|,
name|ParamTypes
operator|.
name|data
argument_list|()
argument_list|,
name|ParamTypes
operator|.
name|size
argument_list|()
argument_list|,
name|T
operator|->
name|isVariadic
argument_list|()
argument_list|,
name|T
operator|->
name|getTypeQuals
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|FunctionProtoTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|FunctionProtoTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setLParenLoc
argument_list|(
name|TL
operator|.
name|getLParenLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setRParenLoc
argument_list|(
name|TL
operator|.
name|getRParenLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|NewTL
operator|.
name|getNumArgs
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|NewTL
operator|.
name|setArg
argument_list|(
name|i
argument_list|,
name|ParamDecls
index|[
name|i
index|]
argument_list|)
expr_stmt|;
end_for

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformFunctionNoProtoType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|FunctionNoProtoTypeLoc TL
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
name|FunctionNoProtoType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
name|QualType
name|ResultType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|TLB
argument_list|,
name|TL
operator|.
name|getResultLoc
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|ResultType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
name|QualType
name|Result
operator|=
name|TL
operator|.
name|getType
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|ResultType
operator|!=
name|T
operator|->
name|getResultType
argument_list|()
condition|)
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildFunctionNoProtoType
argument_list|(
name|ResultType
argument_list|)
expr_stmt|;
end_if

begin_decl_stmt
name|FunctionNoProtoTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|FunctionNoProtoTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setLParenLoc
argument_list|(
name|TL
operator|.
name|getLParenLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setRParenLoc
argument_list|(
name|TL
operator|.
name|getRParenLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformUnresolvedUsingType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|UnresolvedUsingTypeLoc TL
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
name|UnresolvedUsingType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
name|Decl
operator|*
name|D
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|,
name|T
operator|->
name|getDecl
argument_list|()
argument_list|)
block|;
if|if
condition|(
operator|!
name|D
condition|)
return|return
name|QualType
argument_list|()
return|;
name|QualType
name|Result
operator|=
name|TL
operator|.
name|getType
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|D
operator|!=
name|T
operator|->
name|getDecl
argument_list|()
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildUnresolvedUsingType
argument_list|(
name|D
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_if

begin_comment
comment|// We might get an arbitrary type spec type back.  We should at
end_comment

begin_comment
comment|// least always get a type spec type, though.
end_comment

begin_decl_stmt
name|TypeSpecTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|pushTypeSpec
argument_list|(
name|Result
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setNameLoc
argument_list|(
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformTypedefType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|TypedefTypeLoc TL
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
name|TypedefType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
name|TypedefDecl
operator|*
name|Typedef
operator|=
name|cast_or_null
operator|<
name|TypedefDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|,
name|T
operator|->
name|getDecl
argument_list|()
argument_list|)
operator|)
block|;
if|if
condition|(
operator|!
name|Typedef
condition|)
return|return
name|QualType
argument_list|()
return|;
name|QualType
name|Result
operator|=
name|TL
operator|.
name|getType
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|Typedef
operator|!=
name|T
operator|->
name|getDecl
argument_list|()
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildTypedefType
argument_list|(
name|Typedef
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|TypedefTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|TypedefTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setNameLoc
argument_list|(
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformTypeOfExprType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|TypeOfExprTypeLoc TL
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
comment|// typeof expressions are not potentially evaluated contexts
name|EnterExpressionEvaluationContext
name|Unevaluated
argument_list|(
name|SemaRef
argument_list|,
name|Action
operator|::
name|Unevaluated
argument_list|)
block|;
name|Sema
operator|::
name|OwningExprResult
name|E
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|TL
operator|.
name|getUnderlyingExpr
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|E
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
name|QualType
name|Result
operator|=
name|TL
operator|.
name|getType
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|E
operator|.
name|get
argument_list|()
operator|!=
name|TL
operator|.
name|getUnderlyingExpr
argument_list|()
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildTypeOfExprType
argument_list|(
name|move
argument_list|(
name|E
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
else|else
name|E
operator|.
name|take
argument_list|()
expr_stmt|;
end_if

begin_decl_stmt
name|TypeOfExprTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|TypeOfExprTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setTypeofLoc
argument_list|(
name|TL
operator|.
name|getTypeofLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setLParenLoc
argument_list|(
name|TL
operator|.
name|getLParenLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setRParenLoc
argument_list|(
name|TL
operator|.
name|getRParenLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformTypeOfType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|TypeOfTypeLoc TL
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
name|TypeSourceInfo
operator|*
name|Old_Under_TI
operator|=
name|TL
operator|.
name|getUnderlyingTInfo
argument_list|()
block|;
name|TypeSourceInfo
operator|*
name|New_Under_TI
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|Old_Under_TI
argument_list|)
block|;
if|if
condition|(
operator|!
name|New_Under_TI
condition|)
return|return
name|QualType
argument_list|()
return|;
name|QualType
name|Result
operator|=
name|TL
operator|.
name|getType
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|New_Under_TI
operator|!=
name|Old_Under_TI
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildTypeOfType
argument_list|(
name|New_Under_TI
operator|->
name|getType
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|TypeOfTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|TypeOfTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setTypeofLoc
argument_list|(
name|TL
operator|.
name|getTypeofLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setLParenLoc
argument_list|(
name|TL
operator|.
name|getLParenLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setRParenLoc
argument_list|(
name|TL
operator|.
name|getRParenLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setUnderlyingTInfo
argument_list|(
name|New_Under_TI
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformDecltypeType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|DecltypeTypeLoc TL
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
name|DecltypeType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
comment|// decltype expressions are not potentially evaluated contexts
name|EnterExpressionEvaluationContext
name|Unevaluated
argument_list|(
name|SemaRef
argument_list|,
name|Action
operator|::
name|Unevaluated
argument_list|)
block|;
name|Sema
operator|::
name|OwningExprResult
name|E
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|T
operator|->
name|getUnderlyingExpr
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|E
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
name|QualType
name|Result
operator|=
name|TL
operator|.
name|getType
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|E
operator|.
name|get
argument_list|()
operator|!=
name|T
operator|->
name|getUnderlyingExpr
argument_list|()
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildDecltypeType
argument_list|(
name|move
argument_list|(
name|E
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
else|else
name|E
operator|.
name|take
argument_list|()
expr_stmt|;
end_if

begin_decl_stmt
name|DecltypeTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|DecltypeTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setNameLoc
argument_list|(
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformRecordType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|RecordTypeLoc TL
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
name|RecordType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
name|RecordDecl
operator|*
name|Record
operator|=
name|cast_or_null
operator|<
name|RecordDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|,
name|T
operator|->
name|getDecl
argument_list|()
argument_list|)
operator|)
block|;
if|if
condition|(
operator|!
name|Record
condition|)
return|return
name|QualType
argument_list|()
return|;
name|QualType
name|Result
operator|=
name|TL
operator|.
name|getType
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|Record
operator|!=
name|T
operator|->
name|getDecl
argument_list|()
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildRecordType
argument_list|(
name|Record
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|RecordTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|RecordTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setNameLoc
argument_list|(
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformEnumType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|EnumTypeLoc TL
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
name|EnumType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
name|EnumDecl
operator|*
name|Enum
operator|=
name|cast_or_null
operator|<
name|EnumDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|,
name|T
operator|->
name|getDecl
argument_list|()
argument_list|)
operator|)
block|;
if|if
condition|(
operator|!
name|Enum
condition|)
return|return
name|QualType
argument_list|()
return|;
name|QualType
name|Result
operator|=
name|TL
operator|.
name|getType
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|Enum
operator|!=
name|T
operator|->
name|getDecl
argument_list|()
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildEnumType
argument_list|(
name|Enum
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|EnumTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|EnumTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setNameLoc
argument_list|(
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformElaboratedType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|ElaboratedTypeLoc TL
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
name|ElaboratedType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
comment|// FIXME: this should be a nested type.
name|QualType
name|Underlying
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|T
operator|->
name|getUnderlyingType
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Underlying
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
name|QualType
name|Result
operator|=
name|TL
operator|.
name|getType
argument_list|()
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|Underlying
operator|!=
name|T
operator|->
name|getUnderlyingType
argument_list|()
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildElaboratedType
argument_list|(
name|Underlying
argument_list|,
name|T
operator|->
name|getTagKind
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|ElaboratedTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|ElaboratedTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setNameLoc
argument_list|(
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformInjectedClassNameType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|InjectedClassNameTypeLoc TL
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
name|Decl
operator|*
name|D
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|,
name|TL
operator|.
name|getTypePtr
argument_list|()
operator|->
name|getDecl
argument_list|()
argument_list|)
block|;
if|if
condition|(
operator|!
name|D
condition|)
return|return
name|QualType
argument_list|()
return|;
name|QualType
name|T
operator|=
name|SemaRef
operator|.
name|Context
operator|.
name|getTypeDeclType
argument_list|(
name|cast
operator|<
name|TypeDecl
operator|>
operator|(
name|D
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|TLB
operator|.
name|pushTypeSpec
argument_list|(
name|T
argument_list|)
operator|.
name|setNameLoc
argument_list|(
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|T
return|;
end_return

begin_expr_stmt
unit|}   template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformTemplateTypeParmType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|TemplateTypeParmTypeLoc TL
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
return|return
name|TransformTypeSpecType
argument_list|(
name|TLB
argument_list|,
name|TL
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformSubstTemplateTypeParmType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|SubstTemplateTypeParmTypeLoc TL
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
return|return
name|TransformTypeSpecType
argument_list|(
name|TLB
argument_list|,
name|TL
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformTemplateSpecializationType
argument_list|(
argument|const TemplateSpecializationType *TST
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
comment|// FIXME: this entire method is a temporary workaround; callers
comment|// should be rewritten to provide real type locs.
comment|// Fake up a TemplateSpecializationTypeLoc.
name|TypeLocBuilder
name|TLB
block|;
name|TemplateSpecializationTypeLoc
name|TL
operator|=
name|TLB
operator|.
name|push
operator|<
name|TemplateSpecializationTypeLoc
operator|>
operator|(
name|QualType
argument_list|(
name|TST
argument_list|,
literal|0
argument_list|)
operator|)
block|;
name|SourceLocation
name|BaseLoc
operator|=
name|getDerived
argument_list|()
operator|.
name|getBaseLocation
argument_list|()
block|;
name|TL
operator|.
name|setTemplateNameLoc
argument_list|(
name|BaseLoc
argument_list|)
block|;
name|TL
operator|.
name|setLAngleLoc
argument_list|(
name|BaseLoc
argument_list|)
block|;
name|TL
operator|.
name|setRAngleLoc
argument_list|(
name|BaseLoc
argument_list|)
block|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|TL
operator|.
name|getNumArgs
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|TemplateArgument
modifier|&
name|TA
init|=
name|TST
operator|->
name|getArg
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|TemplateArgumentLoc
name|TAL
decl_stmt|;
name|getDerived
argument_list|()
operator|.
name|InventTemplateArgumentLoc
argument_list|(
name|TA
argument_list|,
name|TAL
argument_list|)
expr_stmt|;
name|TL
operator|.
name|setArgLocInfo
argument_list|(
name|i
argument_list|,
name|TAL
operator|.
name|getLocInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|TypeLocBuilder
name|IgnoredTLB
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|TransformTemplateSpecializationType
argument_list|(
name|IgnoredTLB
argument_list|,
name|TL
argument_list|,
name|ObjectType
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}    template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformTemplateSpecializationType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|TemplateSpecializationTypeLoc TL
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
specifier|const
name|TemplateSpecializationType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
name|TemplateName
name|Template
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformTemplateName
argument_list|(
name|T
operator|->
name|getTemplateName
argument_list|()
argument_list|,
name|ObjectType
argument_list|)
block|;
if|if
condition|(
name|Template
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
name|TemplateArgumentListInfo
name|NewTemplateArgs
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTemplateArgs
operator|.
name|setLAngleLoc
argument_list|(
name|TL
operator|.
name|getLAngleLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|NewTemplateArgs
operator|.
name|setRAngleLoc
argument_list|(
name|TL
operator|.
name|getRAngleLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|T
operator|->
name|getNumArgs
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
block|{
name|TemplateArgumentLoc
name|Loc
decl_stmt|;
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TransformTemplateArgument
argument_list|(
name|TL
operator|.
name|getArgLoc
argument_list|(
name|i
argument_list|)
argument_list|,
name|Loc
argument_list|)
condition|)
return|return
name|QualType
argument_list|()
return|;
name|NewTemplateArgs
operator|.
name|addArgument
argument_list|(
name|Loc
argument_list|)
expr_stmt|;
block|}
end_for

begin_comment
comment|// FIXME: maybe don't rebuild if all the template arguments are the same.
end_comment

begin_decl_stmt
name|QualType
name|Result
init|=
name|getDerived
argument_list|()
operator|.
name|RebuildTemplateSpecializationType
argument_list|(
name|Template
argument_list|,
name|TL
operator|.
name|getTemplateNameLoc
argument_list|()
argument_list|,
name|NewTemplateArgs
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
operator|!
name|Result
operator|.
name|isNull
argument_list|()
condition|)
block|{
name|TemplateSpecializationTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|TemplateSpecializationTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
name|NewTL
operator|.
name|setTemplateNameLoc
argument_list|(
name|TL
operator|.
name|getTemplateNameLoc
argument_list|()
argument_list|)
expr_stmt|;
name|NewTL
operator|.
name|setLAngleLoc
argument_list|(
name|TL
operator|.
name|getLAngleLoc
argument_list|()
argument_list|)
expr_stmt|;
name|NewTL
operator|.
name|setRAngleLoc
argument_list|(
name|TL
operator|.
name|getRAngleLoc
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|NewTemplateArgs
operator|.
name|size
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|NewTL
operator|.
name|setArgLocInfo
argument_list|(
name|i
argument_list|,
name|NewTemplateArgs
index|[
name|i
index|]
operator|.
name|getLocInfo
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_if

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformQualifiedNameType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|QualifiedNameTypeLoc TL
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
name|QualifiedNameType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
name|NestedNameSpecifier
operator|*
name|NNS
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformNestedNameSpecifier
argument_list|(
name|T
operator|->
name|getQualifier
argument_list|()
argument_list|,
name|SourceRange
argument_list|()
argument_list|,
name|ObjectType
argument_list|)
block|;
if|if
condition|(
operator|!
name|NNS
condition|)
return|return
name|QualType
argument_list|()
return|;
name|QualType
name|Named
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|T
operator|->
name|getNamedType
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Named
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
end_if

begin_decl_stmt
name|QualType
name|Result
init|=
name|TL
operator|.
name|getType
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|||
name|NNS
operator|!=
name|T
operator|->
name|getQualifier
argument_list|()
operator|||
name|Named
operator|!=
name|T
operator|->
name|getNamedType
argument_list|()
condition|)
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildQualifiedNameType
argument_list|(
name|NNS
argument_list|,
name|Named
argument_list|)
expr_stmt|;
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|QualifiedNameTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|QualifiedNameTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setNameLoc
argument_list|(
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformTypenameType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|TypenameTypeLoc TL
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
name|TypenameType
operator|*
name|T
operator|=
name|TL
operator|.
name|getTypePtr
argument_list|()
block|;
comment|/* FIXME: preserve source information better than this */
name|SourceRange
name|SR
argument_list|(
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|)
block|;
name|NestedNameSpecifier
operator|*
name|NNS
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformNestedNameSpecifier
argument_list|(
name|T
operator|->
name|getQualifier
argument_list|()
argument_list|,
name|SR
argument_list|,
name|ObjectType
argument_list|)
block|;
if|if
condition|(
operator|!
name|NNS
condition|)
return|return
name|QualType
argument_list|()
return|;
name|QualType
name|Result
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
specifier|const
name|TemplateSpecializationType
modifier|*
name|TemplateId
init|=
name|T
operator|->
name|getTemplateId
argument_list|()
condition|)
block|{
name|QualType
name|NewTemplateId
init|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|QualType
argument_list|(
name|TemplateId
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|NewTemplateId
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|NNS
operator|==
name|T
operator|->
name|getQualifier
argument_list|()
operator|&&
name|NewTemplateId
operator|==
name|QualType
argument_list|(
name|TemplateId
argument_list|,
literal|0
argument_list|)
condition|)
return|return
name|QualType
argument_list|(
name|T
argument_list|,
literal|0
argument_list|)
return|;
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildTypenameType
argument_list|(
name|NNS
argument_list|,
name|NewTemplateId
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildTypenameType
argument_list|(
name|NNS
argument_list|,
name|T
operator|->
name|getIdentifier
argument_list|()
argument_list|,
name|SR
argument_list|)
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|Result
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
end_if

begin_decl_stmt
name|TypenameTypeLoc
name|NewTL
init|=
name|TLB
operator|.
name|push
operator|<
name|TypenameTypeLoc
operator|>
operator|(
name|Result
operator|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|NewTL
operator|.
name|setNameLoc
argument_list|(
name|TL
operator|.
name|getNameLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|Result
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCInterfaceType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|ObjCInterfaceTypeLoc TL
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
name|assert
argument_list|(
name|false
operator|&&
literal|"TransformObjCInterfaceType unimplemented"
argument_list|)
block|;
return|return
name|QualType
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCObjectPointerType
argument_list|(
argument|TypeLocBuilder&TLB
argument_list|,
argument|ObjCObjectPointerTypeLoc TL
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
name|assert
argument_list|(
name|false
operator|&&
literal|"TransformObjCObjectPointerType unimplemented"
argument_list|)
block|;
return|return
name|QualType
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// Statement transformation
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningStmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformNullStmt
argument_list|(
argument|NullStmt *S
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningStmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCompoundStmt
argument_list|(
argument|CompoundStmt *S
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|TransformCompoundStmt
argument_list|(
name|S
argument_list|,
name|false
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningStmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCompoundStmt
argument_list|(
argument|CompoundStmt *S
argument_list|,
argument|bool IsStmtExpr
argument_list|)
block|{
name|bool
name|SubStmtChanged
operator|=
name|false
block|;
name|ASTOwningVector
operator|<
operator|&
name|ActionBase
operator|::
name|DeleteStmt
operator|>
name|Statements
argument_list|(
name|getSema
argument_list|()
argument_list|)
block|;
for|for
control|(
name|CompoundStmt
operator|::
name|body_iterator
name|B
operator|=
name|S
operator|->
name|body_begin
argument_list|()
operator|,
name|BEnd
operator|=
name|S
operator|->
name|body_end
argument_list|()
init|;
name|B
operator|!=
name|BEnd
condition|;
operator|++
name|B
control|)
block|{
name|OwningStmtResult
name|Result
init|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
operator|*
name|B
argument_list|)
decl_stmt|;
if|if
condition|(
name|Result
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|getSema
argument_list|()
operator|.
name|StmtError
argument_list|()
return|;
name|SubStmtChanged
operator|=
name|SubStmtChanged
operator|||
name|Result
operator|.
name|get
argument_list|()
operator|!=
operator|*
name|B
expr_stmt|;
name|Statements
operator|.
name|push_back
argument_list|(
name|Result
operator|.
name|takeAs
operator|<
name|Stmt
operator|>
operator|(
operator|)
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
operator|!
name|SubStmtChanged
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCompoundStmt
argument_list|(
name|S
operator|->
name|getLBracLoc
argument_list|()
argument_list|,
name|move_arg
argument_list|(
name|Statements
argument_list|)
argument_list|,
name|S
operator|->
name|getRBracLoc
argument_list|()
argument_list|,
name|IsStmtExpr
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningStmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCaseStmt
argument_list|(
argument|CaseStmt *S
argument_list|)
block|{
name|OwningExprResult
name|LHS
argument_list|(
name|SemaRef
argument_list|)
block|,
name|RHS
argument_list|(
name|SemaRef
argument_list|)
block|;
block|{
comment|// The case value expressions are not potentially evaluated.
name|EnterExpressionEvaluationContext
name|Unevaluated
argument_list|(
name|SemaRef
argument_list|,
name|Action
operator|::
name|Unevaluated
argument_list|)
block|;
comment|// Transform the left-hand case value.
name|LHS
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|S
operator|->
name|getLHS
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|LHS
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|StmtError
argument_list|()
return|;
comment|// Transform the right-hand case value (for the GNU case-range extension).
name|RHS
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|S
operator|->
name|getRHS
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|RHS
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|StmtError
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|// Build the case statement.
end_comment

begin_comment
comment|// Case statements are always rebuilt so that they will attached to their
end_comment

begin_comment
comment|// transformed switch statement.
end_comment

begin_decl_stmt
name|OwningStmtResult
name|Case
init|=
name|getDerived
argument_list|()
operator|.
name|RebuildCaseStmt
argument_list|(
name|S
operator|->
name|getCaseLoc
argument_list|()
argument_list|,
name|move
argument_list|(
name|LHS
argument_list|)
argument_list|,
name|S
operator|->
name|getEllipsisLoc
argument_list|()
argument_list|,
name|move
argument_list|(
name|RHS
argument_list|)
argument_list|,
name|S
operator|->
name|getColonLoc
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Case
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|StmtError
argument_list|()
return|;
end_if

begin_comment
comment|// Transform the statement following the case
end_comment

begin_decl_stmt
name|OwningStmtResult
name|SubStmt
init|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|S
operator|->
name|getSubStmt
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|SubStmt
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|StmtError
argument_list|()
return|;
end_if

begin_comment
comment|// Attach the body to the case statement
end_comment

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCaseStmtBody
argument_list|(
name|move
argument_list|(
name|Case
argument_list|)
argument_list|,
name|move
argument_list|(
name|SubStmt
argument_list|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningStmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformDefaultStmt
argument_list|(
argument|DefaultStmt *S
argument_list|)
block|{
comment|// Transform the statement following the default case
name|OwningStmtResult
name|SubStmt
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|S
operator|->
name|getSubStmt
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|SubStmt
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|StmtError
argument_list|()
return|;
end_expr_stmt

begin_comment
comment|// Default statements are always rebuilt
end_comment

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildDefaultStmt
argument_list|(
name|S
operator|->
name|getDefaultLoc
argument_list|()
argument_list|,
name|S
operator|->
name|getColonLoc
argument_list|()
argument_list|,
name|move
argument_list|(
name|SubStmt
argument_list|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningStmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformLabelStmt
argument_list|(
argument|LabelStmt *S
argument_list|)
block|{
name|OwningStmtResult
name|SubStmt
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|S
operator|->
name|getSubStmt
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|SubStmt
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|StmtError
argument_list|()
return|;
comment|// FIXME: Pass the real colon location in.
name|SourceLocation
name|ColonLoc
operator|=
name|SemaRef
operator|.
name|PP
operator|.
name|getLocForEndOfToken
argument_list|(
name|S
operator|->
name|getIdentLoc
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildLabelStmt
argument_list|(
name|S
operator|->
name|getIdentLoc
argument_list|()
argument_list|,
name|S
operator|->
name|getID
argument_list|()
argument_list|,
name|ColonLoc
argument_list|,
name|move
argument_list|(
name|SubStmt
argument_list|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningStmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformIfStmt
argument_list|(
argument|IfStmt *S
argument_list|)
block|{
comment|// Transform the condition
name|OwningExprResult
name|Cond
argument_list|(
name|SemaRef
argument_list|)
block|;
name|VarDecl
operator|*
name|ConditionVar
operator|=
literal|0
block|;
if|if
condition|(
name|S
operator|->
name|getConditionVariable
argument_list|()
condition|)
block|{
name|ConditionVar
operator|=
name|cast_or_null
operator|<
name|VarDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDefinition
argument_list|(
name|S
operator|->
name|getConditionVariable
argument_list|()
operator|->
name|getLocation
argument_list|()
argument_list|,
name|S
operator|->
name|getConditionVariable
argument_list|()
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ConditionVar
condition|)
return|return
name|SemaRef
operator|.
name|StmtError
argument_list|()
return|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|Cond
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|S
operator|->
name|getCond
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Cond
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|StmtError
argument_list|()
return|;
block|}
end_else

begin_expr_stmt
name|Sema
operator|::
name|FullExprArg
name|FullCond
argument_list|(
name|getSema
argument_list|()
operator|.
name|MakeFullExpr
argument_list|(
name|Cond
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Transform the "then" branch.
end_comment

begin_decl_stmt
name|OwningStmtResult
name|Then
init|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|S
operator|->
name|getThen
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Then
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|StmtError
argument_list|()
return|;
end_if

begin_comment
comment|// Transform the "else" branch.
end_comment

begin_decl_stmt
name|OwningStmtResult
name|Else
init|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|S
operator|->
name|getElse
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Else
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|StmtError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|FullCond
operator|->
name|get
argument_list|()
operator|==
name|S
operator|->
name|getCond
argument_list|()
operator|&&
name|ConditionVar
operator|==
name|S
operator|->
name|getConditionVariable
argument_list|()
operator|&&
name|Then
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getThen
argument_list|()
operator|&&
name|Else
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getElse
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildIfStmt
argument_list|(
name|S
operator|->
name|getIfLoc
argument_list|()
argument_list|,
name|FullCond
argument_list|,
name|ConditionVar
argument_list|,
name|move
argument_list|(
name|Then
argument_list|)
argument_list|,
name|S
operator|->
name|getElseLoc
argument_list|()
argument_list|,
name|move
argument_list|(
name|Else
argument_list|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningStmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformSwitchStmt
argument_list|(
argument|SwitchStmt *S
argument_list|)
block|{
comment|// Transform the condition.
name|OwningExprResult
name|Cond
argument_list|(
name|SemaRef
argument_list|)
block|;
name|VarDecl
operator|*
name|ConditionVar
operator|=
literal|0
block|;
if|if
condition|(
name|S
operator|->
name|getConditionVariable
argument_list|()
condition|)
block|{
name|ConditionVar
operator|=
name|cast_or_null
operator|<
name|VarDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDefinition
argument_list|(
name|S
operator|->
name|getConditionVariable
argument_list|()
operator|->
name|getLocation
argument_list|()
argument_list|,
name|S
operator|->
name|getConditionVariable
argument_list|()
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ConditionVar
condition|)
return|return
name|SemaRef
operator|.
name|StmtError
argument_list|()
return|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|Cond
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|S
operator|->
name|getCond
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Cond
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|StmtError
argument_list|()
return|;
block|}
end_else

begin_expr_stmt
name|Sema
operator|::
name|FullExprArg
name|FullCond
argument_list|(
name|getSema
argument_list|()
operator|.
name|MakeFullExpr
argument_list|(
name|Cond
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Rebuild the switch statement.
end_comment

begin_decl_stmt
name|OwningStmtResult
name|Switch
init|=
name|getDerived
argument_list|()
operator|.
name|RebuildSwitchStmtStart
argument_list|(
name|FullCond
argument_list|,
name|ConditionVar
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Switch
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|StmtError
argument_list|()
return|;
end_if

begin_comment
comment|// Transform the body of the switch statement.
end_comment

begin_decl_stmt
name|OwningStmtResult
name|Body
init|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|S
operator|->
name|getBody
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Body
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|StmtError
argument_list|()
return|;
end_if

begin_comment
comment|// Complete the switch statement.
end_comment

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildSwitchStmtBody
argument_list|(
name|S
operator|->
name|getSwitchLoc
argument_list|()
argument_list|,
name|move
argument_list|(
name|Switch
argument_list|)
argument_list|,
name|move
argument_list|(
name|Body
argument_list|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningStmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformWhileStmt
argument_list|(
argument|WhileStmt *S
argument_list|)
block|{
comment|// Transform the condition
name|OwningExprResult
name|Cond
argument_list|(
name|SemaRef
argument_list|)
block|;
name|VarDecl
operator|*
name|ConditionVar
operator|=
literal|0
block|;
if|if
condition|(
name|S
operator|->
name|getConditionVariable
argument_list|()
condition|)
block|{
name|ConditionVar
operator|=
name|cast_or_null
operator|<
name|VarDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDefinition
argument_list|(
name|S
operator|->
name|getConditionVariable
argument_list|()
operator|->
name|getLocation
argument_list|()
argument_list|,
name|S
operator|->
name|getConditionVariable
argument_list|()
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ConditionVar
condition|)
return|return
name|SemaRef
operator|.
name|StmtError
argument_list|()
return|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|Cond
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|S
operator|->
name|getCond
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Cond
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|StmtError
argument_list|()
return|;
block|}
end_else

begin_expr_stmt
name|Sema
operator|::
name|FullExprArg
name|FullCond
argument_list|(
name|getSema
argument_list|()
operator|.
name|MakeFullExpr
argument_list|(
name|Cond
argument_list|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Transform the body
end_comment

begin_decl_stmt
name|OwningStmtResult
name|Body
init|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|S
operator|->
name|getBody
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Body
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|StmtError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|FullCond
operator|->
name|get
argument_list|()
operator|==
name|S
operator|->
name|getCond
argument_list|()
operator|&&
name|ConditionVar
operator|==
name|S
operator|->
name|getConditionVariable
argument_list|()
operator|&&
name|Body
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getBody
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildWhileStmt
argument_list|(
name|S
operator|->
name|getWhileLoc
argument_list|()
argument_list|,
name|FullCond
argument_list|,
name|ConditionVar
argument_list|,
name|move
argument_list|(
name|Body
argument_list|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningStmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformDoStmt
argument_list|(
argument|DoStmt *S
argument_list|)
block|{
comment|// Transform the condition
name|OwningExprResult
name|Cond
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|S
operator|->
name|getCond
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cond
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|StmtError
argument_list|()
return|;
comment|// Transform the body
name|OwningStmtResult
name|Body
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|S
operator|->
name|getBody
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Body
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|StmtError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Cond
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getCond
argument_list|()
operator|&&
name|Body
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getBody
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildDoStmt
argument_list|(
name|S
operator|->
name|getDoLoc
argument_list|()
argument_list|,
name|move
argument_list|(
name|Body
argument_list|)
argument_list|,
name|S
operator|->
name|getWhileLoc
argument_list|()
argument_list|,
comment|/*FIXME:*/
name|S
operator|->
name|getWhileLoc
argument_list|()
argument_list|,
name|move
argument_list|(
name|Cond
argument_list|)
argument_list|,
name|S
operator|->
name|getRParenLoc
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningStmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformForStmt
argument_list|(
argument|ForStmt *S
argument_list|)
block|{
comment|// Transform the initialization statement
name|OwningStmtResult
name|Init
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|S
operator|->
name|getInit
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Init
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|StmtError
argument_list|()
return|;
comment|// Transform the condition
name|OwningExprResult
name|Cond
argument_list|(
name|SemaRef
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|VarDecl
modifier|*
name|ConditionVar
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|S
operator|->
name|getConditionVariable
argument_list|()
condition|)
block|{
name|ConditionVar
operator|=
name|cast_or_null
operator|<
name|VarDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDefinition
argument_list|(
name|S
operator|->
name|getConditionVariable
argument_list|()
operator|->
name|getLocation
argument_list|()
argument_list|,
name|S
operator|->
name|getConditionVariable
argument_list|()
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ConditionVar
condition|)
return|return
name|SemaRef
operator|.
name|StmtError
argument_list|()
return|;
block|}
else|else
block|{
name|Cond
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|S
operator|->
name|getCond
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Cond
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|StmtError
argument_list|()
return|;
block|}
end_if

begin_comment
comment|// Transform the increment
end_comment

begin_decl_stmt
name|OwningExprResult
name|Inc
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|S
operator|->
name|getInc
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Inc
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|StmtError
argument_list|()
return|;
end_if

begin_comment
comment|// Transform the body
end_comment

begin_decl_stmt
name|OwningStmtResult
name|Body
init|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|S
operator|->
name|getBody
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Body
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|StmtError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Init
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getInit
argument_list|()
operator|&&
name|Cond
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getCond
argument_list|()
operator|&&
name|Inc
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getInc
argument_list|()
operator|&&
name|Body
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getBody
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildForStmt
argument_list|(
name|S
operator|->
name|getForLoc
argument_list|()
argument_list|,
name|S
operator|->
name|getLParenLoc
argument_list|()
argument_list|,
name|move
argument_list|(
name|Init
argument_list|)
argument_list|,
name|getSema
argument_list|()
operator|.
name|MakeFullExpr
argument_list|(
name|Cond
argument_list|)
argument_list|,
name|ConditionVar
argument_list|,
name|getSema
argument_list|()
operator|.
name|MakeFullExpr
argument_list|(
name|Inc
argument_list|)
argument_list|,
name|S
operator|->
name|getRParenLoc
argument_list|()
argument_list|,
name|move
argument_list|(
name|Body
argument_list|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningStmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformGotoStmt
argument_list|(
argument|GotoStmt *S
argument_list|)
block|{
comment|// Goto statements must always be rebuilt, to resolve the label.
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildGotoStmt
argument_list|(
name|S
operator|->
name|getGotoLoc
argument_list|()
argument_list|,
name|S
operator|->
name|getLabelLoc
argument_list|()
argument_list|,
name|S
operator|->
name|getLabel
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningStmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformIndirectGotoStmt
argument_list|(
argument|IndirectGotoStmt *S
argument_list|)
block|{
name|OwningExprResult
name|Target
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|S
operator|->
name|getTarget
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Target
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|StmtError
argument_list|()
return|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Target
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getTarget
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildIndirectGotoStmt
argument_list|(
name|S
operator|->
name|getGotoLoc
argument_list|()
argument_list|,
name|S
operator|->
name|getStarLoc
argument_list|()
argument_list|,
name|move
argument_list|(
name|Target
argument_list|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningStmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformContinueStmt
argument_list|(
argument|ContinueStmt *S
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningStmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformBreakStmt
argument_list|(
argument|BreakStmt *S
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningStmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformReturnStmt
argument_list|(
argument|ReturnStmt *S
argument_list|)
block|{
name|Sema
operator|::
name|OwningExprResult
name|Result
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|S
operator|->
name|getRetValue
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Result
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|StmtError
argument_list|()
return|;
end_expr_stmt

begin_comment
comment|// FIXME: We always rebuild the return statement because there is no way
end_comment

begin_comment
comment|// to tell whether the return type of the function has changed.
end_comment

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildReturnStmt
argument_list|(
name|S
operator|->
name|getReturnLoc
argument_list|()
argument_list|,
name|move
argument_list|(
name|Result
argument_list|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningStmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformDeclStmt
argument_list|(
argument|DeclStmt *S
argument_list|)
block|{
name|bool
name|DeclChanged
operator|=
name|false
block|;
name|llvm
operator|::
name|SmallVector
operator|<
name|Decl
operator|*
block|,
literal|4
operator|>
name|Decls
block|;
for|for
control|(
name|DeclStmt
operator|::
name|decl_iterator
name|D
operator|=
name|S
operator|->
name|decl_begin
argument_list|()
operator|,
name|DEnd
operator|=
name|S
operator|->
name|decl_end
argument_list|()
init|;
name|D
operator|!=
name|DEnd
condition|;
operator|++
name|D
control|)
block|{
name|Decl
modifier|*
name|Transformed
init|=
name|getDerived
argument_list|()
operator|.
name|TransformDefinition
argument_list|(
operator|(
operator|*
name|D
operator|)
operator|->
name|getLocation
argument_list|()
argument_list|,
operator|*
name|D
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|Transformed
condition|)
return|return
name|SemaRef
operator|.
name|StmtError
argument_list|()
return|;
if|if
condition|(
name|Transformed
operator|!=
operator|*
name|D
condition|)
name|DeclChanged
operator|=
name|true
expr_stmt|;
name|Decls
operator|.
name|push_back
argument_list|(
name|Transformed
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
operator|!
name|DeclChanged
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildDeclStmt
argument_list|(
name|Decls
operator|.
name|data
argument_list|()
argument_list|,
name|Decls
operator|.
name|size
argument_list|()
argument_list|,
name|S
operator|->
name|getStartLoc
argument_list|()
argument_list|,
name|S
operator|->
name|getEndLoc
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningStmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformSwitchCase
argument_list|(
argument|SwitchCase *S
argument_list|)
block|{
name|assert
argument_list|(
name|false
operator|&&
literal|"SwitchCase is abstract and cannot be transformed"
argument_list|)
block|;
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningStmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformAsmStmt
argument_list|(
argument|AsmStmt *S
argument_list|)
block|{
name|ASTOwningVector
operator|<
operator|&
name|ActionBase
operator|::
name|DeleteExpr
operator|>
name|Constraints
argument_list|(
name|getSema
argument_list|()
argument_list|)
block|;
name|ASTOwningVector
operator|<
operator|&
name|ActionBase
operator|::
name|DeleteExpr
operator|>
name|Exprs
argument_list|(
name|getSema
argument_list|()
argument_list|)
block|;
name|llvm
operator|::
name|SmallVector
operator|<
name|IdentifierInfo
operator|*
block|,
literal|4
operator|>
name|Names
block|;
name|OwningExprResult
name|AsmString
argument_list|(
name|SemaRef
argument_list|)
block|;
name|ASTOwningVector
operator|<
operator|&
name|ActionBase
operator|::
name|DeleteExpr
operator|>
name|Clobbers
argument_list|(
name|getSema
argument_list|()
argument_list|)
block|;
name|bool
name|ExprsChanged
operator|=
name|false
block|;
comment|// Go through the outputs.
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|,
name|E
init|=
name|S
operator|->
name|getNumOutputs
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|Names
operator|.
name|push_back
argument_list|(
name|S
operator|->
name|getOutputIdentifier
argument_list|(
name|I
argument_list|)
argument_list|)
expr_stmt|;
comment|// No need to transform the constraint literal.
name|Constraints
operator|.
name|push_back
argument_list|(
name|S
operator|->
name|getOutputConstraintLiteral
argument_list|(
name|I
argument_list|)
operator|->
name|Retain
argument_list|()
argument_list|)
expr_stmt|;
comment|// Transform the output expr.
name|Expr
modifier|*
name|OutputExpr
init|=
name|S
operator|->
name|getOutputExpr
argument_list|(
name|I
argument_list|)
decl_stmt|;
name|OwningExprResult
name|Result
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|OutputExpr
argument_list|)
decl_stmt|;
if|if
condition|(
name|Result
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|StmtError
argument_list|()
return|;
name|ExprsChanged
operator||=
name|Result
operator|.
name|get
argument_list|()
operator|!=
name|OutputExpr
expr_stmt|;
name|Exprs
operator|.
name|push_back
argument_list|(
name|Result
operator|.
name|takeAs
operator|<
name|Expr
operator|>
operator|(
operator|)
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_comment
comment|// Go through the inputs.
end_comment

begin_for
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|,
name|E
init|=
name|S
operator|->
name|getNumInputs
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|Names
operator|.
name|push_back
argument_list|(
name|S
operator|->
name|getInputIdentifier
argument_list|(
name|I
argument_list|)
argument_list|)
expr_stmt|;
comment|// No need to transform the constraint literal.
name|Constraints
operator|.
name|push_back
argument_list|(
name|S
operator|->
name|getInputConstraintLiteral
argument_list|(
name|I
argument_list|)
operator|->
name|Retain
argument_list|()
argument_list|)
expr_stmt|;
comment|// Transform the input expr.
name|Expr
modifier|*
name|InputExpr
init|=
name|S
operator|->
name|getInputExpr
argument_list|(
name|I
argument_list|)
decl_stmt|;
name|OwningExprResult
name|Result
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|InputExpr
argument_list|)
decl_stmt|;
if|if
condition|(
name|Result
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|StmtError
argument_list|()
return|;
name|ExprsChanged
operator||=
name|Result
operator|.
name|get
argument_list|()
operator|!=
name|InputExpr
expr_stmt|;
name|Exprs
operator|.
name|push_back
argument_list|(
name|Result
operator|.
name|takeAs
operator|<
name|Expr
operator|>
operator|(
operator|)
argument_list|)
expr_stmt|;
block|}
end_for

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
operator|!
name|ExprsChanged
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_comment
comment|// Go through the clobbers.
end_comment

begin_for
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|,
name|E
init|=
name|S
operator|->
name|getNumClobbers
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
name|Clobbers
operator|.
name|push_back
argument_list|(
name|S
operator|->
name|getClobber
argument_list|(
name|I
argument_list|)
operator|->
name|Retain
argument_list|()
argument_list|)
expr_stmt|;
end_for

begin_comment
comment|// No need to transform the asm string literal.
end_comment

begin_expr_stmt
name|AsmString
operator|=
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
operator|->
name|getAsmString
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildAsmStmt
argument_list|(
name|S
operator|->
name|getAsmLoc
argument_list|()
argument_list|,
name|S
operator|->
name|isSimple
argument_list|()
argument_list|,
name|S
operator|->
name|isVolatile
argument_list|()
argument_list|,
name|S
operator|->
name|getNumOutputs
argument_list|()
argument_list|,
name|S
operator|->
name|getNumInputs
argument_list|()
argument_list|,
name|Names
operator|.
name|data
argument_list|()
argument_list|,
name|move_arg
argument_list|(
name|Constraints
argument_list|)
argument_list|,
name|move_arg
argument_list|(
name|Exprs
argument_list|)
argument_list|,
name|move
argument_list|(
name|AsmString
argument_list|)
argument_list|,
name|move_arg
argument_list|(
name|Clobbers
argument_list|)
argument_list|,
name|S
operator|->
name|getRParenLoc
argument_list|()
argument_list|,
name|S
operator|->
name|isMSAsm
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}   template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningStmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCAtTryStmt
argument_list|(
argument|ObjCAtTryStmt *S
argument_list|)
block|{
comment|// FIXME: Implement this
name|assert
argument_list|(
name|false
operator|&&
literal|"Cannot transform an Objective-C @try statement"
argument_list|)
block|;
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningStmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCAtCatchStmt
argument_list|(
argument|ObjCAtCatchStmt *S
argument_list|)
block|{
comment|// FIXME: Implement this
name|assert
argument_list|(
name|false
operator|&&
literal|"Cannot transform an Objective-C @catch statement"
argument_list|)
block|;
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningStmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCAtFinallyStmt
argument_list|(
argument|ObjCAtFinallyStmt *S
argument_list|)
block|{
comment|// FIXME: Implement this
name|assert
argument_list|(
name|false
operator|&&
literal|"Cannot transform an Objective-C @finally statement"
argument_list|)
block|;
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningStmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCAtThrowStmt
argument_list|(
argument|ObjCAtThrowStmt *S
argument_list|)
block|{
comment|// FIXME: Implement this
name|assert
argument_list|(
name|false
operator|&&
literal|"Cannot transform an Objective-C @throw statement"
argument_list|)
block|;
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningStmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCAtSynchronizedStmt
argument_list|(
argument|ObjCAtSynchronizedStmt *S
argument_list|)
block|{
comment|// FIXME: Implement this
name|assert
argument_list|(
name|false
operator|&&
literal|"Cannot transform an Objective-C @synchronized statement"
argument_list|)
block|;
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningStmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCForCollectionStmt
argument_list|(
argument|ObjCForCollectionStmt *S
argument_list|)
block|{
comment|// FIXME: Implement this
name|assert
argument_list|(
name|false
operator|&&
literal|"Cannot transform an Objective-C for-each statement"
argument_list|)
block|;
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningStmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXCatchStmt
argument_list|(
argument|CXXCatchStmt *S
argument_list|)
block|{
comment|// Transform the exception declaration, if any.
name|VarDecl
operator|*
name|Var
operator|=
literal|0
block|;
if|if
condition|(
name|S
operator|->
name|getExceptionDecl
argument_list|()
condition|)
block|{
name|VarDecl
modifier|*
name|ExceptionDecl
init|=
name|S
operator|->
name|getExceptionDecl
argument_list|()
decl_stmt|;
name|TemporaryBase
name|Rebase
argument_list|(
operator|*
name|this
argument_list|,
name|ExceptionDecl
operator|->
name|getLocation
argument_list|()
argument_list|,
name|ExceptionDecl
operator|->
name|getDeclName
argument_list|()
argument_list|)
decl_stmt|;
name|QualType
name|T
init|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|ExceptionDecl
operator|->
name|getType
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|T
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|StmtError
argument_list|()
return|;
name|Var
operator|=
name|getDerived
argument_list|()
operator|.
name|RebuildExceptionDecl
argument_list|(
name|ExceptionDecl
argument_list|,
name|T
argument_list|,
name|ExceptionDecl
operator|->
name|getTypeSourceInfo
argument_list|()
argument_list|,
name|ExceptionDecl
operator|->
name|getIdentifier
argument_list|()
argument_list|,
name|ExceptionDecl
operator|->
name|getLocation
argument_list|()
argument_list|,
comment|/*FIXME: Inaccurate*/
name|SourceRange
argument_list|(
name|ExceptionDecl
operator|->
name|getLocation
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Var
operator|||
name|Var
operator|->
name|isInvalidDecl
argument_list|()
condition|)
block|{
if|if
condition|(
name|Var
condition|)
name|Var
operator|->
name|Destroy
argument_list|(
name|SemaRef
operator|.
name|Context
argument_list|)
expr_stmt|;
return|return
name|SemaRef
operator|.
name|StmtError
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|// Transform the actual exception handler.
end_comment

begin_expr_stmt
unit|OwningStmtResult
name|Handler
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformStmt
argument_list|(
name|S
operator|->
name|getHandlerBlock
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Handler
operator|.
name|isInvalid
argument_list|()
condition|)
block|{
if|if
condition|(
name|Var
condition|)
name|Var
operator|->
name|Destroy
argument_list|(
name|SemaRef
operator|.
name|Context
argument_list|)
expr_stmt|;
return|return
name|SemaRef
operator|.
name|StmtError
argument_list|()
return|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
operator|!
name|Var
operator|&&
name|Handler
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getHandlerBlock
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXCatchStmt
argument_list|(
name|S
operator|->
name|getCatchLoc
argument_list|()
argument_list|,
name|Var
argument_list|,
name|move
argument_list|(
name|Handler
argument_list|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningStmtResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXTryStmt
argument_list|(
argument|CXXTryStmt *S
argument_list|)
block|{
comment|// Transform the try block itself.
name|OwningStmtResult
name|TryBlock
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformCompoundStmt
argument_list|(
name|S
operator|->
name|getTryBlock
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|TryBlock
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|StmtError
argument_list|()
return|;
comment|// Transform the handlers.
name|bool
name|HandlerChanged
operator|=
name|false
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ASTOwningVector
operator|<
operator|&
name|ActionBase
operator|::
name|DeleteStmt
operator|>
name|Handlers
argument_list|(
name|SemaRef
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|,
name|N
init|=
name|S
operator|->
name|getNumHandlers
argument_list|()
init|;
name|I
operator|!=
name|N
condition|;
operator|++
name|I
control|)
block|{
name|OwningStmtResult
name|Handler
init|=
name|getDerived
argument_list|()
operator|.
name|TransformCXXCatchStmt
argument_list|(
name|S
operator|->
name|getHandler
argument_list|(
name|I
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|Handler
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|StmtError
argument_list|()
return|;
name|HandlerChanged
operator|=
name|HandlerChanged
operator|||
name|Handler
operator|.
name|get
argument_list|()
operator|!=
name|S
operator|->
name|getHandler
argument_list|(
name|I
argument_list|)
expr_stmt|;
name|Handlers
operator|.
name|push_back
argument_list|(
name|Handler
operator|.
name|takeAs
operator|<
name|Stmt
operator|>
operator|(
operator|)
argument_list|)
expr_stmt|;
block|}
end_for

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|TryBlock
operator|.
name|get
argument_list|()
operator|==
name|S
operator|->
name|getTryBlock
argument_list|()
operator|&&
operator|!
name|HandlerChanged
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|S
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXTryStmt
argument_list|(
name|S
operator|->
name|getTryLoc
argument_list|()
argument_list|,
name|move
argument_list|(
name|TryBlock
argument_list|)
argument_list|,
name|move_arg
argument_list|(
name|Handlers
argument_list|)
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// Expression transformation
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformPredefinedExpr
argument_list|(
argument|PredefinedExpr *E
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformDeclRefExpr
argument_list|(
argument|DeclRefExpr *E
argument_list|)
block|{
name|NestedNameSpecifier
operator|*
name|Qualifier
operator|=
literal|0
block|;
if|if
condition|(
name|E
operator|->
name|getQualifier
argument_list|()
condition|)
block|{
name|Qualifier
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformNestedNameSpecifier
argument_list|(
name|E
operator|->
name|getQualifier
argument_list|()
argument_list|,
name|E
operator|->
name|getQualifierRange
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Qualifier
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
block|}
name|ValueDecl
operator|*
name|ND
operator|=
name|cast_or_null
operator|<
name|ValueDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|E
operator|->
name|getLocation
argument_list|()
argument_list|,
name|E
operator|->
name|getDecl
argument_list|()
argument_list|)
operator|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|ND
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Qualifier
operator|==
name|E
operator|->
name|getQualifier
argument_list|()
operator|&&
name|ND
operator|==
name|E
operator|->
name|getDecl
argument_list|()
operator|&&
operator|!
name|E
operator|->
name|hasExplicitTemplateArgumentList
argument_list|()
condition|)
block|{
comment|// Mark it referenced in the new context regardless.
comment|// FIXME: this is a bit instantiation-specific.
name|SemaRef
operator|.
name|MarkDeclarationReferenced
argument_list|(
name|E
operator|->
name|getLocation
argument_list|()
argument_list|,
name|ND
argument_list|)
expr_stmt|;
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
block|}
end_if

begin_decl_stmt
name|TemplateArgumentListInfo
name|TransArgs
decl_stmt|,
modifier|*
name|TemplateArgs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|E
operator|->
name|hasExplicitTemplateArgumentList
argument_list|()
condition|)
block|{
name|TemplateArgs
operator|=
operator|&
name|TransArgs
expr_stmt|;
name|TransArgs
operator|.
name|setLAngleLoc
argument_list|(
name|E
operator|->
name|getLAngleLoc
argument_list|()
argument_list|)
expr_stmt|;
name|TransArgs
operator|.
name|setRAngleLoc
argument_list|(
name|E
operator|->
name|getRAngleLoc
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|,
name|N
init|=
name|E
operator|->
name|getNumTemplateArgs
argument_list|()
init|;
name|I
operator|!=
name|N
condition|;
operator|++
name|I
control|)
block|{
name|TemplateArgumentLoc
name|Loc
decl_stmt|;
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TransformTemplateArgument
argument_list|(
name|E
operator|->
name|getTemplateArgs
argument_list|()
index|[
name|I
index|]
argument_list|,
name|Loc
argument_list|)
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
name|TransArgs
operator|.
name|addArgument
argument_list|(
name|Loc
argument_list|)
expr_stmt|;
block|}
block|}
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildDeclRefExpr
argument_list|(
name|Qualifier
argument_list|,
name|E
operator|->
name|getQualifierRange
argument_list|()
argument_list|,
name|ND
argument_list|,
name|E
operator|->
name|getLocation
argument_list|()
argument_list|,
name|TemplateArgs
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformIntegerLiteral
argument_list|(
argument|IntegerLiteral *E
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformFloatingLiteral
argument_list|(
argument|FloatingLiteral *E
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformImaginaryLiteral
argument_list|(
argument|ImaginaryLiteral *E
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformStringLiteral
argument_list|(
argument|StringLiteral *E
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCharacterLiteral
argument_list|(
argument|CharacterLiteral *E
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformParenExpr
argument_list|(
argument|ParenExpr *E
argument_list|)
block|{
name|OwningExprResult
name|SubExpr
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getSubExpr
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|SubExpr
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|SubExpr
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getSubExpr
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildParenExpr
argument_list|(
name|move
argument_list|(
name|SubExpr
argument_list|)
argument_list|,
name|E
operator|->
name|getLParen
argument_list|()
argument_list|,
name|E
operator|->
name|getRParen
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformUnaryOperator
argument_list|(
argument|UnaryOperator *E
argument_list|)
block|{
name|OwningExprResult
name|SubExpr
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getSubExpr
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|SubExpr
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|SubExpr
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getSubExpr
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildUnaryOperator
argument_list|(
name|E
operator|->
name|getOperatorLoc
argument_list|()
argument_list|,
name|E
operator|->
name|getOpcode
argument_list|()
argument_list|,
name|move
argument_list|(
name|SubExpr
argument_list|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformSizeOfAlignOfExpr
argument_list|(
argument|SizeOfAlignOfExpr *E
argument_list|)
block|{
if|if
condition|(
name|E
operator|->
name|isArgumentType
argument_list|()
condition|)
block|{
name|TypeSourceInfo
modifier|*
name|OldT
init|=
name|E
operator|->
name|getArgumentTypeInfo
argument_list|()
decl_stmt|;
name|TypeSourceInfo
modifier|*
name|NewT
init|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|OldT
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|NewT
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|OldT
operator|==
name|NewT
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildSizeOfAlignOf
argument_list|(
name|NewT
argument_list|,
name|E
operator|->
name|getOperatorLoc
argument_list|()
argument_list|,
name|E
operator|->
name|isSizeOf
argument_list|()
argument_list|,
name|E
operator|->
name|getSourceRange
argument_list|()
argument_list|)
return|;
block|}
name|Sema
operator|::
name|OwningExprResult
name|SubExpr
argument_list|(
name|SemaRef
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|// C++0x [expr.sizeof]p1:
comment|//   The operand is either an expression, which is an unevaluated operand
comment|//   [...]
name|EnterExpressionEvaluationContext
name|Unevaluated
argument_list|(
name|SemaRef
argument_list|,
name|Action
operator|::
name|Unevaluated
argument_list|)
decl_stmt|;
name|SubExpr
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getArgumentExpr
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|SubExpr
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|SubExpr
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getArgumentExpr
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
block|}
end_block

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildSizeOfAlignOf
argument_list|(
name|move
argument_list|(
name|SubExpr
argument_list|)
argument_list|,
name|E
operator|->
name|getOperatorLoc
argument_list|()
argument_list|,
name|E
operator|->
name|isSizeOf
argument_list|()
argument_list|,
name|E
operator|->
name|getSourceRange
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformArraySubscriptExpr
argument_list|(
argument|ArraySubscriptExpr *E
argument_list|)
block|{
name|OwningExprResult
name|LHS
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getLHS
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|LHS
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
name|OwningExprResult
name|RHS
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getRHS
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|RHS
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|LHS
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getLHS
argument_list|()
operator|&&
name|RHS
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getRHS
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildArraySubscriptExpr
argument_list|(
name|move
argument_list|(
name|LHS
argument_list|)
argument_list|,
comment|/*FIXME:*/
name|E
operator|->
name|getLHS
argument_list|()
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|move
argument_list|(
name|RHS
argument_list|)
argument_list|,
name|E
operator|->
name|getRBracketLoc
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCallExpr
argument_list|(
argument|CallExpr *E
argument_list|)
block|{
comment|// Transform the callee.
name|OwningExprResult
name|Callee
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getCallee
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Callee
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
comment|// Transform arguments.
name|bool
name|ArgChanged
operator|=
name|false
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ASTOwningVector
operator|<
operator|&
name|ActionBase
operator|::
name|DeleteExpr
operator|>
name|Args
argument_list|(
name|SemaRef
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|llvm
operator|::
name|SmallVector
operator|<
name|SourceLocation
operator|,
literal|4
operator|>
name|FakeCommaLocs
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|,
name|N
init|=
name|E
operator|->
name|getNumArgs
argument_list|()
init|;
name|I
operator|!=
name|N
condition|;
operator|++
name|I
control|)
block|{
name|OwningExprResult
name|Arg
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getArg
argument_list|(
name|I
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|Arg
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
comment|// FIXME: Wrong source location information for the ','.
name|FakeCommaLocs
operator|.
name|push_back
argument_list|(
name|SemaRef
operator|.
name|PP
operator|.
name|getLocForEndOfToken
argument_list|(
name|E
operator|->
name|getArg
argument_list|(
name|I
argument_list|)
operator|->
name|getSourceRange
argument_list|()
operator|.
name|getEnd
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ArgChanged
operator|=
name|ArgChanged
operator|||
name|Arg
operator|.
name|get
argument_list|()
operator|!=
name|E
operator|->
name|getArg
argument_list|(
name|I
argument_list|)
expr_stmt|;
name|Args
operator|.
name|push_back
argument_list|(
name|Arg
operator|.
name|takeAs
operator|<
name|Expr
operator|>
operator|(
operator|)
argument_list|)
expr_stmt|;
block|}
end_for

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Callee
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getCallee
argument_list|()
operator|&&
operator|!
name|ArgChanged
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_comment
comment|// FIXME: Wrong source location information for the '('.
end_comment

begin_decl_stmt
name|SourceLocation
name|FakeLParenLoc
init|=
operator|(
operator|(
name|Expr
operator|*
operator|)
name|Callee
operator|.
name|get
argument_list|()
operator|)
operator|->
name|getSourceRange
argument_list|()
operator|.
name|getBegin
argument_list|()
decl_stmt|;
end_decl_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCallExpr
argument_list|(
name|move
argument_list|(
name|Callee
argument_list|)
argument_list|,
name|FakeLParenLoc
argument_list|,
name|move_arg
argument_list|(
name|Args
argument_list|)
argument_list|,
name|FakeCommaLocs
operator|.
name|data
argument_list|()
argument_list|,
name|E
operator|->
name|getRParenLoc
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformMemberExpr
argument_list|(
argument|MemberExpr *E
argument_list|)
block|{
name|OwningExprResult
name|Base
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getBase
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Base
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
name|NestedNameSpecifier
operator|*
name|Qualifier
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|E
operator|->
name|hasQualifier
argument_list|()
condition|)
block|{
name|Qualifier
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformNestedNameSpecifier
argument_list|(
name|E
operator|->
name|getQualifier
argument_list|()
argument_list|,
name|E
operator|->
name|getQualifierRange
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Qualifier
operator|==
literal|0
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|ValueDecl
modifier|*
name|Member
init|=
name|cast_or_null
operator|<
name|ValueDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|E
operator|->
name|getMemberLoc
argument_list|()
argument_list|,
name|E
operator|->
name|getMemberDecl
argument_list|()
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
operator|!
name|Member
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Base
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getBase
argument_list|()
operator|&&
name|Qualifier
operator|==
name|E
operator|->
name|getQualifier
argument_list|()
operator|&&
name|Member
operator|==
name|E
operator|->
name|getMemberDecl
argument_list|()
operator|&&
operator|!
name|E
operator|->
name|hasExplicitTemplateArgumentList
argument_list|()
condition|)
block|{
comment|// Mark it referenced in the new context regardless.
comment|// FIXME: this is a bit instantiation-specific.
name|SemaRef
operator|.
name|MarkDeclarationReferenced
argument_list|(
name|E
operator|->
name|getMemberLoc
argument_list|()
argument_list|,
name|Member
argument_list|)
expr_stmt|;
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
block|}
end_if

begin_decl_stmt
name|TemplateArgumentListInfo
name|TransArgs
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|E
operator|->
name|hasExplicitTemplateArgumentList
argument_list|()
condition|)
block|{
name|TransArgs
operator|.
name|setLAngleLoc
argument_list|(
name|E
operator|->
name|getLAngleLoc
argument_list|()
argument_list|)
expr_stmt|;
name|TransArgs
operator|.
name|setRAngleLoc
argument_list|(
name|E
operator|->
name|getRAngleLoc
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|,
name|N
init|=
name|E
operator|->
name|getNumTemplateArgs
argument_list|()
init|;
name|I
operator|!=
name|N
condition|;
operator|++
name|I
control|)
block|{
name|TemplateArgumentLoc
name|Loc
decl_stmt|;
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TransformTemplateArgument
argument_list|(
name|E
operator|->
name|getTemplateArgs
argument_list|()
index|[
name|I
index|]
argument_list|,
name|Loc
argument_list|)
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
name|TransArgs
operator|.
name|addArgument
argument_list|(
name|Loc
argument_list|)
expr_stmt|;
block|}
block|}
end_if

begin_comment
comment|// FIXME: Bogus source location for the operator
end_comment

begin_decl_stmt
name|SourceLocation
name|FakeOperatorLoc
init|=
name|SemaRef
operator|.
name|PP
operator|.
name|getLocForEndOfToken
argument_list|(
name|E
operator|->
name|getBase
argument_list|()
operator|->
name|getSourceRange
argument_list|()
operator|.
name|getEnd
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|// FIXME: to do this check properly, we will need to preserve the
end_comment

begin_comment
comment|// first-qualifier-in-scope here, just in case we had a dependent
end_comment

begin_comment
comment|// base (and therefore couldn't do the check) and a
end_comment

begin_comment
comment|// nested-name-qualifier (and therefore could do the lookup).
end_comment

begin_decl_stmt
name|NamedDecl
modifier|*
name|FirstQualifierInScope
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildMemberExpr
argument_list|(
name|move
argument_list|(
name|Base
argument_list|)
argument_list|,
name|FakeOperatorLoc
argument_list|,
name|E
operator|->
name|isArrow
argument_list|()
argument_list|,
name|Qualifier
argument_list|,
name|E
operator|->
name|getQualifierRange
argument_list|()
argument_list|,
name|E
operator|->
name|getMemberLoc
argument_list|()
argument_list|,
name|Member
argument_list|,
operator|(
name|E
operator|->
name|hasExplicitTemplateArgumentList
argument_list|()
condition|?
operator|&
name|TransArgs
else|:
literal|0
operator|)
argument_list|,
name|FirstQualifierInScope
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformBinaryOperator
argument_list|(
argument|BinaryOperator *E
argument_list|)
block|{
name|OwningExprResult
name|LHS
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getLHS
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|LHS
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
name|OwningExprResult
name|RHS
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getRHS
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|RHS
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|LHS
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getLHS
argument_list|()
operator|&&
name|RHS
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getRHS
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildBinaryOperator
argument_list|(
name|E
operator|->
name|getOperatorLoc
argument_list|()
argument_list|,
name|E
operator|->
name|getOpcode
argument_list|()
argument_list|,
name|move
argument_list|(
name|LHS
argument_list|)
argument_list|,
name|move
argument_list|(
name|RHS
argument_list|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCompoundAssignOperator
argument_list|(
argument|CompoundAssignOperator *E
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|TransformBinaryOperator
argument_list|(
name|E
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformConditionalOperator
argument_list|(
argument|ConditionalOperator *E
argument_list|)
block|{
name|OwningExprResult
name|Cond
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getCond
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cond
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
name|OwningExprResult
name|LHS
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getLHS
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|LHS
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_if

begin_decl_stmt
name|OwningExprResult
name|RHS
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getRHS
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|RHS
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Cond
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getCond
argument_list|()
operator|&&
name|LHS
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getLHS
argument_list|()
operator|&&
name|RHS
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getRHS
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildConditionalOperator
argument_list|(
name|move
argument_list|(
name|Cond
argument_list|)
argument_list|,
name|E
operator|->
name|getQuestionLoc
argument_list|()
argument_list|,
name|move
argument_list|(
name|LHS
argument_list|)
argument_list|,
name|E
operator|->
name|getColonLoc
argument_list|()
argument_list|,
name|move
argument_list|(
name|RHS
argument_list|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformImplicitCastExpr
argument_list|(
argument|ImplicitCastExpr *E
argument_list|)
block|{
comment|// Implicit casts are eliminated during transformation, since they
comment|// will be recomputed by semantic analysis after transformation.
return|return
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getSubExprAsWritten
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCStyleCastExpr
argument_list|(
argument|CStyleCastExpr *E
argument_list|)
block|{
name|TypeSourceInfo
operator|*
name|OldT
block|;
name|TypeSourceInfo
operator|*
name|NewT
block|;
block|{
comment|// FIXME: Source location isn't quite accurate.
name|SourceLocation
name|TypeStartLoc
operator|=
name|SemaRef
operator|.
name|PP
operator|.
name|getLocForEndOfToken
argument_list|(
name|E
operator|->
name|getLParenLoc
argument_list|()
argument_list|)
block|;
name|TemporaryBase
name|Rebase
argument_list|(
operator|*
name|this
argument_list|,
name|TypeStartLoc
argument_list|,
name|DeclarationName
argument_list|()
argument_list|)
block|;
name|OldT
operator|=
name|E
operator|->
name|getTypeInfoAsWritten
argument_list|()
block|;
name|NewT
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|OldT
argument_list|)
block|;
if|if
condition|(
operator|!
name|NewT
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
block|}
name|OwningExprResult
name|SubExpr
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getSubExprAsWritten
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|SubExpr
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|OldT
operator|==
name|NewT
operator|&&
name|SubExpr
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getSubExpr
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCStyleCastExpr
argument_list|(
name|E
operator|->
name|getLParenLoc
argument_list|()
argument_list|,
name|NewT
argument_list|,
name|E
operator|->
name|getRParenLoc
argument_list|()
argument_list|,
name|move
argument_list|(
name|SubExpr
argument_list|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCompoundLiteralExpr
argument_list|(
argument|CompoundLiteralExpr *E
argument_list|)
block|{
name|TypeSourceInfo
operator|*
name|OldT
operator|=
name|E
operator|->
name|getTypeSourceInfo
argument_list|()
block|;
name|TypeSourceInfo
operator|*
name|NewT
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|OldT
argument_list|)
block|;
if|if
condition|(
operator|!
name|NewT
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
name|OwningExprResult
name|Init
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getInitializer
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Init
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|OldT
operator|==
name|NewT
operator|&&
name|Init
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getInitializer
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_comment
comment|// Note: the expression type doesn't necessarily match the
end_comment

begin_comment
comment|// type-as-written, but that's okay, because it should always be
end_comment

begin_comment
comment|// derivable from the initializer.
end_comment

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCompoundLiteralExpr
argument_list|(
name|E
operator|->
name|getLParenLoc
argument_list|()
argument_list|,
name|NewT
argument_list|,
comment|/*FIXME:*/
name|E
operator|->
name|getInitializer
argument_list|()
operator|->
name|getLocEnd
argument_list|()
argument_list|,
name|move
argument_list|(
name|Init
argument_list|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformExtVectorElementExpr
argument_list|(
argument|ExtVectorElementExpr *E
argument_list|)
block|{
name|OwningExprResult
name|Base
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getBase
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Base
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Base
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getBase
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_comment
comment|// FIXME: Bad source location
end_comment

begin_decl_stmt
name|SourceLocation
name|FakeOperatorLoc
init|=
name|SemaRef
operator|.
name|PP
operator|.
name|getLocForEndOfToken
argument_list|(
name|E
operator|->
name|getBase
argument_list|()
operator|->
name|getLocEnd
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildExtVectorElementExpr
argument_list|(
name|move
argument_list|(
name|Base
argument_list|)
argument_list|,
name|FakeOperatorLoc
argument_list|,
name|E
operator|->
name|getAccessorLoc
argument_list|()
argument_list|,
name|E
operator|->
name|getAccessor
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformInitListExpr
argument_list|(
argument|InitListExpr *E
argument_list|)
block|{
name|bool
name|InitChanged
operator|=
name|false
block|;
name|ASTOwningVector
operator|<
operator|&
name|ActionBase
operator|::
name|DeleteExpr
block|,
literal|4
operator|>
name|Inits
argument_list|(
name|SemaRef
argument_list|)
block|;
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|,
name|N
init|=
name|E
operator|->
name|getNumInits
argument_list|()
init|;
name|I
operator|!=
name|N
condition|;
operator|++
name|I
control|)
block|{
name|OwningExprResult
name|Init
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getInit
argument_list|(
name|I
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|Init
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
name|InitChanged
operator|=
name|InitChanged
operator|||
name|Init
operator|.
name|get
argument_list|()
operator|!=
name|E
operator|->
name|getInit
argument_list|(
name|I
argument_list|)
expr_stmt|;
name|Inits
operator|.
name|push_back
argument_list|(
name|Init
operator|.
name|takeAs
operator|<
name|Expr
operator|>
operator|(
operator|)
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
operator|!
name|InitChanged
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildInitList
argument_list|(
name|E
operator|->
name|getLBraceLoc
argument_list|()
argument_list|,
name|move_arg
argument_list|(
name|Inits
argument_list|)
argument_list|,
name|E
operator|->
name|getRBraceLoc
argument_list|()
argument_list|,
name|E
operator|->
name|getType
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformDesignatedInitExpr
argument_list|(
argument|DesignatedInitExpr *E
argument_list|)
block|{
name|Designation
name|Desig
block|;
comment|// transform the initializer value
name|OwningExprResult
name|Init
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getInit
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Init
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
comment|// transform the designators.
name|ASTOwningVector
operator|<
operator|&
name|ActionBase
operator|::
name|DeleteExpr
operator|,
literal|4
operator|>
name|ArrayExprs
argument_list|(
name|SemaRef
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|bool
name|ExprChanged
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_for
for|for
control|(
name|DesignatedInitExpr
operator|::
name|designators_iterator
name|D
operator|=
name|E
operator|->
name|designators_begin
argument_list|()
operator|,
name|DEnd
operator|=
name|E
operator|->
name|designators_end
argument_list|()
init|;
name|D
operator|!=
name|DEnd
condition|;
operator|++
name|D
control|)
block|{
if|if
condition|(
name|D
operator|->
name|isFieldDesignator
argument_list|()
condition|)
block|{
name|Desig
operator|.
name|AddDesignator
argument_list|(
name|Designator
operator|::
name|getField
argument_list|(
name|D
operator|->
name|getFieldName
argument_list|()
argument_list|,
name|D
operator|->
name|getDotLoc
argument_list|()
argument_list|,
name|D
operator|->
name|getFieldLoc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|D
operator|->
name|isArrayDesignator
argument_list|()
condition|)
block|{
name|OwningExprResult
name|Index
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getArrayIndex
argument_list|(
operator|*
name|D
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|Index
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
name|Desig
operator|.
name|AddDesignator
argument_list|(
name|Designator
operator|::
name|getArray
argument_list|(
name|Index
operator|.
name|get
argument_list|()
argument_list|,
name|D
operator|->
name|getLBracketLoc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ExprChanged
operator|=
name|ExprChanged
operator|||
name|Init
operator|.
name|get
argument_list|()
operator|!=
name|E
operator|->
name|getArrayIndex
argument_list|(
operator|*
name|D
argument_list|)
expr_stmt|;
name|ArrayExprs
operator|.
name|push_back
argument_list|(
name|Index
operator|.
name|release
argument_list|()
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|assert
argument_list|(
name|D
operator|->
name|isArrayRangeDesignator
argument_list|()
operator|&&
literal|"New kind of designator?"
argument_list|)
expr_stmt|;
name|OwningExprResult
name|Start
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getArrayRangeStart
argument_list|(
operator|*
name|D
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|Start
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
name|OwningExprResult
name|End
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getArrayRangeEnd
argument_list|(
operator|*
name|D
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|End
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
name|Desig
operator|.
name|AddDesignator
argument_list|(
name|Designator
operator|::
name|getArrayRange
argument_list|(
name|Start
operator|.
name|get
argument_list|()
argument_list|,
name|End
operator|.
name|get
argument_list|()
argument_list|,
name|D
operator|->
name|getLBracketLoc
argument_list|()
argument_list|,
name|D
operator|->
name|getEllipsisLoc
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|ExprChanged
operator|=
name|ExprChanged
operator|||
name|Start
operator|.
name|get
argument_list|()
operator|!=
name|E
operator|->
name|getArrayRangeStart
argument_list|(
operator|*
name|D
argument_list|)
operator|||
name|End
operator|.
name|get
argument_list|()
operator|!=
name|E
operator|->
name|getArrayRangeEnd
argument_list|(
operator|*
name|D
argument_list|)
expr_stmt|;
name|ArrayExprs
operator|.
name|push_back
argument_list|(
name|Start
operator|.
name|release
argument_list|()
argument_list|)
expr_stmt|;
name|ArrayExprs
operator|.
name|push_back
argument_list|(
name|End
operator|.
name|release
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_for

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Init
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getInit
argument_list|()
operator|&&
operator|!
name|ExprChanged
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildDesignatedInitExpr
argument_list|(
name|Desig
argument_list|,
name|move_arg
argument_list|(
name|ArrayExprs
argument_list|)
argument_list|,
name|E
operator|->
name|getEqualOrColonLoc
argument_list|()
argument_list|,
name|E
operator|->
name|usesGNUSyntax
argument_list|()
argument_list|,
name|move
argument_list|(
name|Init
argument_list|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformImplicitValueInitExpr
argument_list|(
argument|ImplicitValueInitExpr *E
argument_list|)
block|{
name|TemporaryBase
name|Rebase
argument_list|(
operator|*
name|this
argument_list|,
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|DeclarationName
argument_list|()
argument_list|)
block|;
comment|// FIXME: Will we ever have proper type location here? Will we actually
comment|// need to transform the type?
name|QualType
name|T
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getType
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|T
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|T
operator|==
name|E
operator|->
name|getType
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildImplicitValueInitExpr
argument_list|(
name|T
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformVAArgExpr
argument_list|(
argument|VAArgExpr *E
argument_list|)
block|{
comment|// FIXME: Do we want the type as written?
name|QualType
name|T
block|;
block|{
comment|// FIXME: Source location isn't quite accurate.
name|TemporaryBase
name|Rebase
argument_list|(
operator|*
name|this
argument_list|,
name|E
operator|->
name|getBuiltinLoc
argument_list|()
argument_list|,
name|DeclarationName
argument_list|()
argument_list|)
block|;
name|T
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getType
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|T
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
block|}
name|OwningExprResult
name|SubExpr
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getSubExpr
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|SubExpr
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|T
operator|==
name|E
operator|->
name|getType
argument_list|()
operator|&&
name|SubExpr
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getSubExpr
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildVAArgExpr
argument_list|(
name|E
operator|->
name|getBuiltinLoc
argument_list|()
argument_list|,
name|move
argument_list|(
name|SubExpr
argument_list|)
argument_list|,
name|T
argument_list|,
name|E
operator|->
name|getRParenLoc
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformParenListExpr
argument_list|(
argument|ParenListExpr *E
argument_list|)
block|{
name|bool
name|ArgumentChanged
operator|=
name|false
block|;
name|ASTOwningVector
operator|<
operator|&
name|ActionBase
operator|::
name|DeleteExpr
block|,
literal|4
operator|>
name|Inits
argument_list|(
name|SemaRef
argument_list|)
block|;
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|,
name|N
init|=
name|E
operator|->
name|getNumExprs
argument_list|()
init|;
name|I
operator|!=
name|N
condition|;
operator|++
name|I
control|)
block|{
name|OwningExprResult
name|Init
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getExpr
argument_list|(
name|I
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|Init
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
name|ArgumentChanged
operator|=
name|ArgumentChanged
operator|||
name|Init
operator|.
name|get
argument_list|()
operator|!=
name|E
operator|->
name|getExpr
argument_list|(
name|I
argument_list|)
expr_stmt|;
name|Inits
operator|.
name|push_back
argument_list|(
name|Init
operator|.
name|takeAs
operator|<
name|Expr
operator|>
operator|(
operator|)
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildParenListExpr
argument_list|(
name|E
operator|->
name|getLParenLoc
argument_list|()
argument_list|,
name|move_arg
argument_list|(
name|Inits
argument_list|)
argument_list|,
name|E
operator|->
name|getRParenLoc
argument_list|()
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/// \brief Transform an address-of-label expression.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// By default, the transformation of an address-of-label expression always
end_comment

begin_comment
comment|/// rebuilds the expression, so that the label identifier can be resolved to
end_comment

begin_comment
comment|/// the corresponding label statement by semantic analysis.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformAddrLabelExpr
argument_list|(
argument|AddrLabelExpr *E
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildAddrLabelExpr
argument_list|(
name|E
operator|->
name|getAmpAmpLoc
argument_list|()
argument_list|,
name|E
operator|->
name|getLabelLoc
argument_list|()
argument_list|,
name|E
operator|->
name|getLabel
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformStmtExpr
argument_list|(
argument|StmtExpr *E
argument_list|)
block|{
name|OwningStmtResult
name|SubStmt
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformCompoundStmt
argument_list|(
name|E
operator|->
name|getSubStmt
argument_list|()
argument_list|,
name|true
argument_list|)
block|;
if|if
condition|(
name|SubStmt
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|SubStmt
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getSubStmt
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildStmtExpr
argument_list|(
name|E
operator|->
name|getLParenLoc
argument_list|()
argument_list|,
name|move
argument_list|(
name|SubStmt
argument_list|)
argument_list|,
name|E
operator|->
name|getRParenLoc
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformTypesCompatibleExpr
argument_list|(
argument|TypesCompatibleExpr *E
argument_list|)
block|{
name|QualType
name|T1
block|,
name|T2
block|;
block|{
comment|// FIXME: Source location isn't quite accurate.
name|TemporaryBase
name|Rebase
argument_list|(
operator|*
name|this
argument_list|,
name|E
operator|->
name|getBuiltinLoc
argument_list|()
argument_list|,
name|DeclarationName
argument_list|()
argument_list|)
block|;
name|T1
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getArgType1
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|T1
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
name|T2
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getArgType2
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|T2
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|T1
operator|==
name|E
operator|->
name|getArgType1
argument_list|()
operator|&&
name|T2
operator|==
name|E
operator|->
name|getArgType2
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildTypesCompatibleExpr
argument_list|(
name|E
operator|->
name|getBuiltinLoc
argument_list|()
argument_list|,
name|T1
argument_list|,
name|T2
argument_list|,
name|E
operator|->
name|getRParenLoc
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformChooseExpr
argument_list|(
argument|ChooseExpr *E
argument_list|)
block|{
name|OwningExprResult
name|Cond
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getCond
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Cond
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
name|OwningExprResult
name|LHS
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getLHS
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|LHS
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_if

begin_decl_stmt
name|OwningExprResult
name|RHS
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getRHS
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|RHS
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Cond
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getCond
argument_list|()
operator|&&
name|LHS
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getLHS
argument_list|()
operator|&&
name|RHS
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getRHS
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildChooseExpr
argument_list|(
name|E
operator|->
name|getBuiltinLoc
argument_list|()
argument_list|,
name|move
argument_list|(
name|Cond
argument_list|)
argument_list|,
name|move
argument_list|(
name|LHS
argument_list|)
argument_list|,
name|move
argument_list|(
name|RHS
argument_list|)
argument_list|,
name|E
operator|->
name|getRParenLoc
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformGNUNullExpr
argument_list|(
argument|GNUNullExpr *E
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXOperatorCallExpr
argument_list|(
argument|CXXOperatorCallExpr *E
argument_list|)
block|{
switch|switch
condition|(
name|E
operator|->
name|getOperator
argument_list|()
condition|)
block|{
case|case
name|OO_New
case|:
case|case
name|OO_Delete
case|:
case|case
name|OO_Array_New
case|:
case|case
name|OO_Array_Delete
case|:
name|llvm_unreachable
argument_list|(
literal|"new and delete operators cannot use CXXOperatorCallExpr"
argument_list|)
expr_stmt|;
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
case|case
name|OO_Call
case|:
block|{
comment|// This is a call to an object's operator().
name|assert
argument_list|(
name|E
operator|->
name|getNumArgs
argument_list|()
operator|>=
literal|1
operator|&&
literal|"Object call is missing arguments"
argument_list|)
expr_stmt|;
comment|// Transform the object itself.
name|OwningExprResult
name|Object
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getArg
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|Object
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
comment|// FIXME: Poor location information
name|SourceLocation
name|FakeLParenLoc
init|=
name|SemaRef
operator|.
name|PP
operator|.
name|getLocForEndOfToken
argument_list|(
name|static_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|Object
operator|.
name|get
argument_list|()
operator|)
operator|->
name|getLocEnd
argument_list|()
argument_list|)
decl_stmt|;
comment|// Transform the call arguments.
name|ASTOwningVector
operator|<
operator|&
name|ActionBase
operator|::
name|DeleteExpr
operator|>
name|Args
argument_list|(
name|SemaRef
argument_list|)
expr_stmt|;
name|llvm
operator|::
name|SmallVector
operator|<
name|SourceLocation
operator|,
literal|4
operator|>
name|FakeCommaLocs
expr_stmt|;
for|for
control|(
name|unsigned
name|I
init|=
literal|1
init|,
name|N
init|=
name|E
operator|->
name|getNumArgs
argument_list|()
init|;
name|I
operator|!=
name|N
condition|;
operator|++
name|I
control|)
block|{
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|DropCallArgument
argument_list|(
name|E
operator|->
name|getArg
argument_list|(
name|I
argument_list|)
argument_list|)
condition|)
break|break;
name|OwningExprResult
name|Arg
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getArg
argument_list|(
name|I
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|Arg
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
comment|// FIXME: Poor source location information.
name|SourceLocation
name|FakeCommaLoc
init|=
name|SemaRef
operator|.
name|PP
operator|.
name|getLocForEndOfToken
argument_list|(
name|static_cast
operator|<
name|Expr
operator|*
operator|>
operator|(
name|Arg
operator|.
name|get
argument_list|()
operator|)
operator|->
name|getLocEnd
argument_list|()
argument_list|)
decl_stmt|;
name|FakeCommaLocs
operator|.
name|push_back
argument_list|(
name|FakeCommaLoc
argument_list|)
expr_stmt|;
name|Args
operator|.
name|push_back
argument_list|(
name|Arg
operator|.
name|release
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCallExpr
argument_list|(
name|move
argument_list|(
name|Object
argument_list|)
argument_list|,
name|FakeLParenLoc
argument_list|,
name|move_arg
argument_list|(
name|Args
argument_list|)
argument_list|,
name|FakeCommaLocs
operator|.
name|data
argument_list|()
argument_list|,
name|E
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
end_return

begin_define
unit|}
define|#
directive|define
name|OVERLOADED_OPERATOR
parameter_list|(
name|Name
parameter_list|,
name|Spelling
parameter_list|,
name|Token
parameter_list|,
name|Unary
parameter_list|,
name|Binary
parameter_list|,
name|MemberOnly
parameter_list|)
define|\
value|case OO_##Name:
end_define

begin_define
define|#
directive|define
name|OVERLOADED_OPERATOR_MULTI
parameter_list|(
name|Name
parameter_list|,
name|Spelling
parameter_list|,
name|Unary
parameter_list|,
name|Binary
parameter_list|,
name|MemberOnly
parameter_list|)
end_define

begin_include
include|#
directive|include
file|"clang/Basic/OperatorKinds.def"
end_include

begin_label
unit|case
name|OO_Subscript
label|:
end_label

begin_comment
comment|// Handled below.
end_comment

begin_break
break|break;
end_break

begin_case
case|case
name|OO_Conditional
case|:
end_case

begin_expr_stmt
name|llvm_unreachable
argument_list|(
literal|"conditional operator is not actually overloadable"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_return

begin_case
case|case
name|OO_None
case|:
end_case

begin_case
case|case
name|NUM_OVERLOADED_OPERATORS
case|:
end_case

begin_expr_stmt
name|llvm_unreachable
argument_list|(
literal|"not an overloaded operator?"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_return

begin_expr_stmt
unit|}    OwningExprResult
name|Callee
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getCallee
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Callee
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_if

begin_decl_stmt
name|OwningExprResult
name|First
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getArg
argument_list|(
literal|0
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|First
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_if

begin_function_decl
name|OwningExprResult
name|Second
parameter_list|(
name|SemaRef
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|if
condition|(
name|E
operator|->
name|getNumArgs
argument_list|()
operator|==
literal|2
condition|)
block|{
name|Second
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getArg
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|Second
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Callee
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getCallee
argument_list|()
operator|&&
name|First
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getArg
argument_list|(
literal|0
argument_list|)
operator|&&
operator|(
name|E
operator|->
name|getNumArgs
argument_list|()
operator|!=
literal|2
operator|||
name|Second
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getArg
argument_list|(
literal|1
argument_list|)
operator|)
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXOperatorCallExpr
argument_list|(
name|E
operator|->
name|getOperator
argument_list|()
argument_list|,
name|E
operator|->
name|getOperatorLoc
argument_list|()
argument_list|,
name|move
argument_list|(
name|Callee
argument_list|)
argument_list|,
name|move
argument_list|(
name|First
argument_list|)
argument_list|,
name|move
argument_list|(
name|Second
argument_list|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXMemberCallExpr
argument_list|(
argument|CXXMemberCallExpr *E
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|TransformCallExpr
argument_list|(
name|E
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXNamedCastExpr
argument_list|(
argument|CXXNamedCastExpr *E
argument_list|)
block|{
name|TypeSourceInfo
operator|*
name|OldT
block|;
name|TypeSourceInfo
operator|*
name|NewT
block|;
block|{
comment|// FIXME: Source location isn't quite accurate.
name|SourceLocation
name|TypeStartLoc
operator|=
name|SemaRef
operator|.
name|PP
operator|.
name|getLocForEndOfToken
argument_list|(
name|E
operator|->
name|getOperatorLoc
argument_list|()
argument_list|)
block|;
name|TemporaryBase
name|Rebase
argument_list|(
operator|*
name|this
argument_list|,
name|TypeStartLoc
argument_list|,
name|DeclarationName
argument_list|()
argument_list|)
block|;
name|OldT
operator|=
name|E
operator|->
name|getTypeInfoAsWritten
argument_list|()
block|;
name|NewT
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|OldT
argument_list|)
block|;
if|if
condition|(
operator|!
name|NewT
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
block|}
name|OwningExprResult
name|SubExpr
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getSubExprAsWritten
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|SubExpr
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|OldT
operator|==
name|NewT
operator|&&
name|SubExpr
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getSubExpr
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_comment
comment|// FIXME: Poor source location information here.
end_comment

begin_decl_stmt
name|SourceLocation
name|FakeLAngleLoc
init|=
name|SemaRef
operator|.
name|PP
operator|.
name|getLocForEndOfToken
argument_list|(
name|E
operator|->
name|getOperatorLoc
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SourceLocation
name|FakeRAngleLoc
init|=
name|E
operator|->
name|getSubExpr
argument_list|()
operator|->
name|getSourceRange
argument_list|()
operator|.
name|getBegin
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SourceLocation
name|FakeRParenLoc
init|=
name|SemaRef
operator|.
name|PP
operator|.
name|getLocForEndOfToken
argument_list|(
name|E
operator|->
name|getSubExpr
argument_list|()
operator|->
name|getSourceRange
argument_list|()
operator|.
name|getEnd
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXNamedCastExpr
argument_list|(
name|E
operator|->
name|getOperatorLoc
argument_list|()
argument_list|,
name|E
operator|->
name|getStmtClass
argument_list|()
argument_list|,
name|FakeLAngleLoc
argument_list|,
name|NewT
argument_list|,
name|FakeRAngleLoc
argument_list|,
name|FakeRAngleLoc
argument_list|,
name|move
argument_list|(
name|SubExpr
argument_list|)
argument_list|,
name|FakeRParenLoc
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXStaticCastExpr
argument_list|(
argument|CXXStaticCastExpr *E
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|TransformCXXNamedCastExpr
argument_list|(
name|E
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXDynamicCastExpr
argument_list|(
argument|CXXDynamicCastExpr *E
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|TransformCXXNamedCastExpr
argument_list|(
name|E
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXReinterpretCastExpr
argument_list|(
argument|CXXReinterpretCastExpr *E
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|TransformCXXNamedCastExpr
argument_list|(
name|E
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXConstCastExpr
argument_list|(
argument|CXXConstCastExpr *E
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|TransformCXXNamedCastExpr
argument_list|(
name|E
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXFunctionalCastExpr
argument_list|(
argument|CXXFunctionalCastExpr *E
argument_list|)
block|{
name|TypeSourceInfo
operator|*
name|OldT
block|;
name|TypeSourceInfo
operator|*
name|NewT
block|;
block|{
name|TemporaryBase
name|Rebase
argument_list|(
operator|*
name|this
argument_list|,
name|E
operator|->
name|getTypeBeginLoc
argument_list|()
argument_list|,
name|DeclarationName
argument_list|()
argument_list|)
block|;
name|OldT
operator|=
name|E
operator|->
name|getTypeInfoAsWritten
argument_list|()
block|;
name|NewT
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|OldT
argument_list|)
block|;
if|if
condition|(
operator|!
name|NewT
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
block|}
name|OwningExprResult
name|SubExpr
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getSubExprAsWritten
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|SubExpr
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|OldT
operator|==
name|NewT
operator|&&
name|SubExpr
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getSubExpr
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_comment
comment|// FIXME: The end of the type's source range is wrong
end_comment

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXFunctionalCastExpr
argument_list|(
comment|/*FIXME:*/
name|SourceRange
argument_list|(
name|E
operator|->
name|getTypeBeginLoc
argument_list|()
argument_list|)
argument_list|,
name|NewT
argument_list|,
comment|/*FIXME:*/
name|E
operator|->
name|getSubExpr
argument_list|()
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|move
argument_list|(
name|SubExpr
argument_list|)
argument_list|,
name|E
operator|->
name|getRParenLoc
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXTypeidExpr
argument_list|(
argument|CXXTypeidExpr *E
argument_list|)
block|{
if|if
condition|(
name|E
operator|->
name|isTypeOperand
argument_list|()
condition|)
block|{
name|TemporaryBase
name|Rebase
argument_list|(
operator|*
name|this
argument_list|,
comment|/*FIXME*/
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|DeclarationName
argument_list|()
argument_list|)
decl_stmt|;
name|QualType
name|T
init|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getTypeOperand
argument_list|()
argument_list|)
decl_stmt|;
if|if
condition|(
name|T
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|T
operator|==
name|E
operator|->
name|getTypeOperand
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXTypeidExpr
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
comment|/*FIXME:*/
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|T
argument_list|,
name|E
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
block|}
comment|// We don't know whether the expression is potentially evaluated until
comment|// after we perform semantic analysis, so the expression is potentially
comment|// potentially evaluated.
name|EnterExpressionEvaluationContext
name|Unevaluated
argument_list|(
name|SemaRef
argument_list|,
name|Action
operator|::
name|PotentiallyPotentiallyEvaluated
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|OwningExprResult
name|SubExpr
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getExprOperand
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|SubExpr
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|SubExpr
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getExprOperand
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXTypeidExpr
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
comment|/*FIXME:*/
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|move
argument_list|(
name|SubExpr
argument_list|)
argument_list|,
name|E
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXBoolLiteralExpr
argument_list|(
argument|CXXBoolLiteralExpr *E
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXNullPtrLiteralExpr
argument_list|(
argument|CXXNullPtrLiteralExpr *E
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXThisExpr
argument_list|(
argument|CXXThisExpr *E
argument_list|)
block|{
name|TemporaryBase
name|Rebase
argument_list|(
operator|*
name|this
argument_list|,
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|DeclarationName
argument_list|()
argument_list|)
block|;
name|QualType
name|T
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getType
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|T
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|T
operator|==
name|E
operator|->
name|getType
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXThisExpr
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|T
argument_list|,
name|E
operator|->
name|isImplicit
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXThrowExpr
argument_list|(
argument|CXXThrowExpr *E
argument_list|)
block|{
name|OwningExprResult
name|SubExpr
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getSubExpr
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|SubExpr
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|SubExpr
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getSubExpr
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXThrowExpr
argument_list|(
name|E
operator|->
name|getThrowLoc
argument_list|()
argument_list|,
name|move
argument_list|(
name|SubExpr
argument_list|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXDefaultArgExpr
argument_list|(
argument|CXXDefaultArgExpr *E
argument_list|)
block|{
name|ParmVarDecl
operator|*
name|Param
operator|=
name|cast_or_null
operator|<
name|ParmVarDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|E
operator|->
name|getParam
argument_list|()
argument_list|)
operator|)
block|;
if|if
condition|(
operator|!
name|Param
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Param
operator|==
name|E
operator|->
name|getParam
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXDefaultArgExpr
argument_list|(
name|E
operator|->
name|getUsedLocation
argument_list|()
argument_list|,
name|Param
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXZeroInitValueExpr
argument_list|(
argument|CXXZeroInitValueExpr *E
argument_list|)
block|{
name|TemporaryBase
name|Rebase
argument_list|(
operator|*
name|this
argument_list|,
name|E
operator|->
name|getTypeBeginLoc
argument_list|()
argument_list|,
name|DeclarationName
argument_list|()
argument_list|)
block|;
name|QualType
name|T
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getType
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|T
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|T
operator|==
name|E
operator|->
name|getType
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXZeroInitValueExpr
argument_list|(
name|E
operator|->
name|getTypeBeginLoc
argument_list|()
argument_list|,
comment|/*FIXME:*/
name|E
operator|->
name|getTypeBeginLoc
argument_list|()
argument_list|,
name|T
argument_list|,
name|E
operator|->
name|getRParenLoc
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXNewExpr
argument_list|(
argument|CXXNewExpr *E
argument_list|)
block|{
comment|// Transform the type that we're allocating
name|TemporaryBase
name|Rebase
argument_list|(
operator|*
name|this
argument_list|,
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|DeclarationName
argument_list|()
argument_list|)
block|;
name|QualType
name|AllocType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getAllocatedType
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|AllocType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
comment|// Transform the size of the array we're allocating (if any).
name|OwningExprResult
name|ArraySize
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getArraySize
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|ArraySize
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_if

begin_comment
comment|// Transform the placement arguments (if any).
end_comment

begin_decl_stmt
name|bool
name|ArgumentChanged
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|ASTOwningVector
operator|<
operator|&
name|ActionBase
operator|::
name|DeleteExpr
operator|>
name|PlacementArgs
argument_list|(
name|SemaRef
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|,
name|N
init|=
name|E
operator|->
name|getNumPlacementArgs
argument_list|()
init|;
name|I
operator|!=
name|N
condition|;
operator|++
name|I
control|)
block|{
name|OwningExprResult
name|Arg
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getPlacementArg
argument_list|(
name|I
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|Arg
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
name|ArgumentChanged
operator|=
name|ArgumentChanged
operator|||
name|Arg
operator|.
name|get
argument_list|()
operator|!=
name|E
operator|->
name|getPlacementArg
argument_list|(
name|I
argument_list|)
expr_stmt|;
name|PlacementArgs
operator|.
name|push_back
argument_list|(
name|Arg
operator|.
name|take
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_for

begin_comment
comment|// transform the constructor arguments (if any).
end_comment

begin_expr_stmt
name|ASTOwningVector
operator|<
operator|&
name|ActionBase
operator|::
name|DeleteExpr
operator|>
name|ConstructorArgs
argument_list|(
name|SemaRef
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|,
name|N
init|=
name|E
operator|->
name|getNumConstructorArgs
argument_list|()
init|;
name|I
operator|!=
name|N
condition|;
operator|++
name|I
control|)
block|{
name|OwningExprResult
name|Arg
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getConstructorArg
argument_list|(
name|I
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|Arg
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
name|ArgumentChanged
operator|=
name|ArgumentChanged
operator|||
name|Arg
operator|.
name|get
argument_list|()
operator|!=
name|E
operator|->
name|getConstructorArg
argument_list|(
name|I
argument_list|)
expr_stmt|;
name|ConstructorArgs
operator|.
name|push_back
argument_list|(
name|Arg
operator|.
name|take
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_for

begin_comment
comment|// Transform constructor, new operator, and delete operator.
end_comment

begin_decl_stmt
name|CXXConstructorDecl
modifier|*
name|Constructor
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|E
operator|->
name|getConstructor
argument_list|()
condition|)
block|{
name|Constructor
operator|=
name|cast_or_null
operator|<
name|CXXConstructorDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|E
operator|->
name|getConstructor
argument_list|()
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|Constructor
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|FunctionDecl
modifier|*
name|OperatorNew
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|E
operator|->
name|getOperatorNew
argument_list|()
condition|)
block|{
name|OperatorNew
operator|=
name|cast_or_null
operator|<
name|FunctionDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|E
operator|->
name|getOperatorNew
argument_list|()
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|OperatorNew
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|FunctionDecl
modifier|*
name|OperatorDelete
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|E
operator|->
name|getOperatorDelete
argument_list|()
condition|)
block|{
name|OperatorDelete
operator|=
name|cast_or_null
operator|<
name|FunctionDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|E
operator|->
name|getOperatorDelete
argument_list|()
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|OperatorDelete
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|AllocType
operator|==
name|E
operator|->
name|getAllocatedType
argument_list|()
operator|&&
name|ArraySize
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getArraySize
argument_list|()
operator|&&
name|Constructor
operator|==
name|E
operator|->
name|getConstructor
argument_list|()
operator|&&
name|OperatorNew
operator|==
name|E
operator|->
name|getOperatorNew
argument_list|()
operator|&&
name|OperatorDelete
operator|==
name|E
operator|->
name|getOperatorDelete
argument_list|()
operator|&&
operator|!
name|ArgumentChanged
condition|)
block|{
comment|// Mark any declarations we need as referenced.
comment|// FIXME: instantiation-specific.
if|if
condition|(
name|Constructor
condition|)
name|SemaRef
operator|.
name|MarkDeclarationReferenced
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|Constructor
argument_list|)
expr_stmt|;
if|if
condition|(
name|OperatorNew
condition|)
name|SemaRef
operator|.
name|MarkDeclarationReferenced
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|OperatorNew
argument_list|)
expr_stmt|;
if|if
condition|(
name|OperatorDelete
condition|)
name|SemaRef
operator|.
name|MarkDeclarationReferenced
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|OperatorDelete
argument_list|)
expr_stmt|;
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
name|ArraySize
operator|.
name|get
argument_list|()
condition|)
block|{
comment|// If no array size was specified, but the new expression was
comment|// instantiated with an array type (e.g., "new T" where T is
comment|// instantiated with "int[4]"), extract the outer bound from the
comment|// array type as our array size. We do this with constant and
comment|// dependently-sized array types.
specifier|const
name|ArrayType
modifier|*
name|ArrayT
init|=
name|SemaRef
operator|.
name|Context
operator|.
name|getAsArrayType
argument_list|(
name|AllocType
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ArrayT
condition|)
block|{
comment|// Do nothing
block|}
elseif|else
if|if
condition|(
specifier|const
name|ConstantArrayType
modifier|*
name|ConsArrayT
init|=
name|dyn_cast
operator|<
name|ConstantArrayType
operator|>
operator|(
name|ArrayT
operator|)
condition|)
block|{
name|ArraySize
operator|=
name|SemaRef
operator|.
name|Owned
argument_list|(
name|new
argument_list|(
argument|SemaRef.Context
argument_list|)
name|IntegerLiteral
argument_list|(
name|ConsArrayT
operator|->
name|getSize
argument_list|()
argument_list|,
name|SemaRef
operator|.
name|Context
operator|.
name|getSizeType
argument_list|()
argument_list|,
comment|/*FIXME:*/
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|AllocType
operator|=
name|ConsArrayT
operator|->
name|getElementType
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
specifier|const
name|DependentSizedArrayType
modifier|*
name|DepArrayT
init|=
name|dyn_cast
operator|<
name|DependentSizedArrayType
operator|>
operator|(
name|ArrayT
operator|)
condition|)
block|{
if|if
condition|(
name|DepArrayT
operator|->
name|getSizeExpr
argument_list|()
condition|)
block|{
name|ArraySize
operator|=
name|SemaRef
operator|.
name|Owned
argument_list|(
name|DepArrayT
operator|->
name|getSizeExpr
argument_list|()
operator|->
name|Retain
argument_list|()
argument_list|)
expr_stmt|;
name|AllocType
operator|=
name|DepArrayT
operator|->
name|getElementType
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXNewExpr
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|E
operator|->
name|isGlobalNew
argument_list|()
argument_list|,
comment|/*FIXME:*/
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|move_arg
argument_list|(
name|PlacementArgs
argument_list|)
argument_list|,
comment|/*FIXME:*/
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|E
operator|->
name|isParenTypeId
argument_list|()
argument_list|,
name|AllocType
argument_list|,
comment|/*FIXME:*/
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
comment|/*FIXME:*/
name|SourceRange
argument_list|()
argument_list|,
name|move
argument_list|(
name|ArraySize
argument_list|)
argument_list|,
comment|/*FIXME:*/
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|move_arg
argument_list|(
name|ConstructorArgs
argument_list|)
argument_list|,
name|E
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXDeleteExpr
argument_list|(
argument|CXXDeleteExpr *E
argument_list|)
block|{
name|OwningExprResult
name|Operand
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getArgument
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Operand
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
comment|// Transform the delete operator, if known.
name|FunctionDecl
operator|*
name|OperatorDelete
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|E
operator|->
name|getOperatorDelete
argument_list|()
condition|)
block|{
name|OperatorDelete
operator|=
name|cast_or_null
operator|<
name|FunctionDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|E
operator|->
name|getOperatorDelete
argument_list|()
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|OperatorDelete
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Operand
operator|.
name|get
argument_list|()
operator|==
name|E
operator|->
name|getArgument
argument_list|()
operator|&&
name|OperatorDelete
operator|==
name|E
operator|->
name|getOperatorDelete
argument_list|()
condition|)
block|{
comment|// Mark any declarations we need as referenced.
comment|// FIXME: instantiation-specific.
if|if
condition|(
name|OperatorDelete
condition|)
name|SemaRef
operator|.
name|MarkDeclarationReferenced
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|OperatorDelete
argument_list|)
expr_stmt|;
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
block|}
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXDeleteExpr
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|E
operator|->
name|isGlobalDelete
argument_list|()
argument_list|,
name|E
operator|->
name|isArrayForm
argument_list|()
argument_list|,
name|move
argument_list|(
name|Operand
argument_list|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXPseudoDestructorExpr
argument_list|(
argument|CXXPseudoDestructorExpr *E
argument_list|)
block|{
name|OwningExprResult
name|Base
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getBase
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|Base
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
name|Sema
operator|::
name|TypeTy
operator|*
name|ObjectTypePtr
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|bool
name|MayBePseudoDestructor
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|Base
operator|=
name|SemaRef
operator|.
name|ActOnStartCXXMemberReference
argument_list|(
literal|0
argument_list|,
name|move
argument_list|(
name|Base
argument_list|)
argument_list|,
name|E
operator|->
name|getOperatorLoc
argument_list|()
argument_list|,
name|E
operator|->
name|isArrow
argument_list|()
condition|?
name|tok
operator|::
name|arrow
else|:
name|tok
operator|::
name|period
argument_list|,
name|ObjectTypePtr
argument_list|,
name|MayBePseudoDestructor
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|Base
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_if

begin_decl_stmt
name|QualType
name|ObjectType
init|=
name|QualType
operator|::
name|getFromOpaquePtr
argument_list|(
name|ObjectTypePtr
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|NestedNameSpecifier
modifier|*
name|Qualifier
init|=
name|getDerived
argument_list|()
operator|.
name|TransformNestedNameSpecifier
argument_list|(
name|E
operator|->
name|getQualifier
argument_list|()
argument_list|,
name|E
operator|->
name|getQualifierRange
argument_list|()
argument_list|,
name|ObjectType
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|E
operator|->
name|getQualifier
argument_list|()
operator|&&
operator|!
name|Qualifier
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_if

begin_decl_stmt
name|PseudoDestructorTypeStorage
name|Destroyed
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|E
operator|->
name|getDestroyedTypeInfo
argument_list|()
condition|)
block|{
name|TypeSourceInfo
modifier|*
name|DestroyedTypeInfo
init|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getDestroyedTypeInfo
argument_list|()
argument_list|,
name|ObjectType
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|DestroyedTypeInfo
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
name|Destroyed
operator|=
name|DestroyedTypeInfo
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ObjectType
operator|->
name|isDependentType
argument_list|()
condition|)
block|{
comment|// We aren't likely to be able to resolve the identifier down to a type
comment|// now anyway, so just retain the identifier.
name|Destroyed
operator|=
name|PseudoDestructorTypeStorage
argument_list|(
name|E
operator|->
name|getDestroyedTypeIdentifier
argument_list|()
argument_list|,
name|E
operator|->
name|getDestroyedTypeLoc
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// Look for a destructor known with the given name.
name|CXXScopeSpec
name|SS
decl_stmt|;
if|if
condition|(
name|Qualifier
condition|)
block|{
name|SS
operator|.
name|setScopeRep
argument_list|(
name|Qualifier
argument_list|)
expr_stmt|;
name|SS
operator|.
name|setRange
argument_list|(
name|E
operator|->
name|getQualifierRange
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|Sema
operator|::
name|TypeTy
operator|*
name|T
operator|=
name|SemaRef
operator|.
name|getDestructorName
argument_list|(
name|E
operator|->
name|getTildeLoc
argument_list|()
argument_list|,
operator|*
name|E
operator|->
name|getDestroyedTypeIdentifier
argument_list|()
argument_list|,
name|E
operator|->
name|getDestroyedTypeLoc
argument_list|()
argument_list|,
comment|/*Scope=*/
literal|0
argument_list|,
name|SS
argument_list|,
name|ObjectTypePtr
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|T
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
name|Destroyed
operator|=
name|SemaRef
operator|.
name|Context
operator|.
name|getTrivialTypeSourceInfo
argument_list|(
name|SemaRef
operator|.
name|GetTypeFromParser
argument_list|(
name|T
argument_list|)
argument_list|,
name|E
operator|->
name|getDestroyedTypeLoc
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_if

begin_decl_stmt
name|TypeSourceInfo
modifier|*
name|ScopeTypeInfo
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|E
operator|->
name|getScopeTypeInfo
argument_list|()
condition|)
block|{
name|ScopeTypeInfo
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getScopeTypeInfo
argument_list|()
argument_list|,
name|ObjectType
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ScopeTypeInfo
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
block|}
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXPseudoDestructorExpr
argument_list|(
name|move
argument_list|(
name|Base
argument_list|)
argument_list|,
name|E
operator|->
name|getOperatorLoc
argument_list|()
argument_list|,
name|E
operator|->
name|isArrow
argument_list|()
argument_list|,
name|Qualifier
argument_list|,
name|E
operator|->
name|getQualifierRange
argument_list|()
argument_list|,
name|ScopeTypeInfo
argument_list|,
name|E
operator|->
name|getColonColonLoc
argument_list|()
argument_list|,
name|E
operator|->
name|getTildeLoc
argument_list|()
argument_list|,
name|Destroyed
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformUnresolvedLookupExpr
argument_list|(
argument|UnresolvedLookupExpr *Old
argument_list|)
block|{
name|TemporaryBase
name|Rebase
argument_list|(
operator|*
name|this
argument_list|,
name|Old
operator|->
name|getNameLoc
argument_list|()
argument_list|,
name|DeclarationName
argument_list|()
argument_list|)
block|;
name|LookupResult
name|R
argument_list|(
name|SemaRef
argument_list|,
name|Old
operator|->
name|getName
argument_list|()
argument_list|,
name|Old
operator|->
name|getNameLoc
argument_list|()
argument_list|,
name|Sema
operator|::
name|LookupOrdinaryName
argument_list|)
block|;
comment|// Transform all the decls.
for|for
control|(
name|UnresolvedLookupExpr
operator|::
name|decls_iterator
name|I
operator|=
name|Old
operator|->
name|decls_begin
argument_list|()
operator|,
name|E
operator|=
name|Old
operator|->
name|decls_end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|NamedDecl
modifier|*
name|InstD
init|=
name|static_cast
operator|<
name|NamedDecl
operator|*
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|Old
operator|->
name|getNameLoc
argument_list|()
argument_list|,
operator|*
name|I
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|InstD
condition|)
block|{
comment|// Silently ignore these if a UsingShadowDecl instantiated to nothing.
comment|// This can happen because of dependent hiding.
if|if
condition|(
name|isa
operator|<
name|UsingShadowDecl
operator|>
operator|(
operator|*
name|I
operator|)
condition|)
continue|continue;
else|else
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|// Expand using declarations.
end_comment

begin_if
if|if
condition|(
name|isa
operator|<
name|UsingDecl
operator|>
operator|(
name|InstD
operator|)
condition|)
block|{
name|UsingDecl
modifier|*
name|UD
init|=
name|cast
operator|<
name|UsingDecl
operator|>
operator|(
name|InstD
operator|)
decl_stmt|;
for|for
control|(
name|UsingDecl
operator|::
name|shadow_iterator
name|I
operator|=
name|UD
operator|->
name|shadow_begin
argument_list|()
operator|,
name|E
operator|=
name|UD
operator|->
name|shadow_end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
name|R
operator|.
name|addDecl
argument_list|(
operator|*
name|I
argument_list|)
expr_stmt|;
continue|continue;
block|}
end_if

begin_expr_stmt
name|R
operator|.
name|addDecl
argument_list|(
name|InstD
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
unit|}
comment|// Resolve a kind, but don't do any further analysis.  If it's
end_comment

begin_comment
comment|// ambiguous, the callee needs to deal with it.
end_comment

begin_expr_stmt
unit|R
operator|.
name|resolveKind
argument_list|()
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Rebuild the nested-name qualifier, if present.
end_comment

begin_decl_stmt
name|CXXScopeSpec
name|SS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|NestedNameSpecifier
modifier|*
name|Qualifier
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Old
operator|->
name|getQualifier
argument_list|()
condition|)
block|{
name|Qualifier
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformNestedNameSpecifier
argument_list|(
name|Old
operator|->
name|getQualifier
argument_list|()
argument_list|,
name|Old
operator|->
name|getQualifierRange
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Qualifier
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
name|SS
operator|.
name|setScopeRep
argument_list|(
name|Qualifier
argument_list|)
expr_stmt|;
name|SS
operator|.
name|setRange
argument_list|(
name|Old
operator|->
name|getQualifierRange
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|// If we have no template arguments, it's a normal declaration name.
end_comment

begin_if
if|if
condition|(
operator|!
name|Old
operator|->
name|hasExplicitTemplateArgs
argument_list|()
condition|)
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildDeclarationNameExpr
argument_list|(
name|SS
argument_list|,
name|R
argument_list|,
name|Old
operator|->
name|requiresADL
argument_list|()
argument_list|)
return|;
end_if

begin_comment
comment|// If we have template arguments, rebuild them, then rebuild the
end_comment

begin_comment
comment|// templateid expression.
end_comment

begin_decl_stmt
name|TemplateArgumentListInfo
name|TransArgs
argument_list|(
name|Old
operator|->
name|getLAngleLoc
argument_list|()
argument_list|,
name|Old
operator|->
name|getRAngleLoc
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_for
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|,
name|N
init|=
name|Old
operator|->
name|getNumTemplateArgs
argument_list|()
init|;
name|I
operator|!=
name|N
condition|;
operator|++
name|I
control|)
block|{
name|TemplateArgumentLoc
name|Loc
decl_stmt|;
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TransformTemplateArgument
argument_list|(
name|Old
operator|->
name|getTemplateArgs
argument_list|()
index|[
name|I
index|]
argument_list|,
name|Loc
argument_list|)
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
name|TransArgs
operator|.
name|addArgument
argument_list|(
name|Loc
argument_list|)
expr_stmt|;
block|}
end_for

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildTemplateIdExpr
argument_list|(
name|SS
argument_list|,
name|R
argument_list|,
name|Old
operator|->
name|requiresADL
argument_list|()
argument_list|,
name|TransArgs
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformUnaryTypeTraitExpr
argument_list|(
argument|UnaryTypeTraitExpr *E
argument_list|)
block|{
name|TemporaryBase
name|Rebase
argument_list|(
operator|*
name|this
argument_list|,
comment|/*FIXME*/
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|DeclarationName
argument_list|()
argument_list|)
block|;
name|QualType
name|T
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getQueriedType
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|T
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|T
operator|==
name|E
operator|->
name|getQueriedType
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_comment
comment|// FIXME: Bad location information
end_comment

begin_decl_stmt
name|SourceLocation
name|FakeLParenLoc
init|=
name|SemaRef
operator|.
name|PP
operator|.
name|getLocForEndOfToken
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildUnaryTypeTrait
argument_list|(
name|E
operator|->
name|getTrait
argument_list|()
argument_list|,
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
comment|/*FIXME:*/
name|FakeLParenLoc
argument_list|,
name|T
argument_list|,
name|E
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformDependentScopeDeclRefExpr
argument_list|(
argument|DependentScopeDeclRefExpr *E
argument_list|)
block|{
name|NestedNameSpecifier
operator|*
name|NNS
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformNestedNameSpecifier
argument_list|(
name|E
operator|->
name|getQualifier
argument_list|()
argument_list|,
name|E
operator|->
name|getQualifierRange
argument_list|()
argument_list|)
block|;
if|if
condition|(
operator|!
name|NNS
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
name|DeclarationName
name|Name
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformDeclarationName
argument_list|(
name|E
operator|->
name|getDeclName
argument_list|()
argument_list|,
name|E
operator|->
name|getLocation
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|Name
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|E
operator|->
name|hasExplicitTemplateArgs
argument_list|()
condition|)
block|{
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|NNS
operator|==
name|E
operator|->
name|getQualifier
argument_list|()
operator|&&
name|Name
operator|==
name|E
operator|->
name|getDeclName
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildDependentScopeDeclRefExpr
argument_list|(
name|NNS
argument_list|,
name|E
operator|->
name|getQualifierRange
argument_list|()
argument_list|,
name|Name
argument_list|,
name|E
operator|->
name|getLocation
argument_list|()
argument_list|,
comment|/*TemplateArgs*/
literal|0
argument_list|)
return|;
block|}
end_if

begin_decl_stmt
name|TemplateArgumentListInfo
name|TransArgs
argument_list|(
name|E
operator|->
name|getLAngleLoc
argument_list|()
argument_list|,
name|E
operator|->
name|getRAngleLoc
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_for
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|,
name|N
init|=
name|E
operator|->
name|getNumTemplateArgs
argument_list|()
init|;
name|I
operator|!=
name|N
condition|;
operator|++
name|I
control|)
block|{
name|TemplateArgumentLoc
name|Loc
decl_stmt|;
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TransformTemplateArgument
argument_list|(
name|E
operator|->
name|getTemplateArgs
argument_list|()
index|[
name|I
index|]
argument_list|,
name|Loc
argument_list|)
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
name|TransArgs
operator|.
name|addArgument
argument_list|(
name|Loc
argument_list|)
expr_stmt|;
block|}
end_for

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildDependentScopeDeclRefExpr
argument_list|(
name|NNS
argument_list|,
name|E
operator|->
name|getQualifierRange
argument_list|()
argument_list|,
name|Name
argument_list|,
name|E
operator|->
name|getLocation
argument_list|()
argument_list|,
operator|&
name|TransArgs
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXConstructExpr
argument_list|(
argument|CXXConstructExpr *E
argument_list|)
block|{
comment|// CXXConstructExprs are always implicit, so when we have a
comment|// 1-argument construction we just transform that argument.
if|if
condition|(
name|E
operator|->
name|getNumArgs
argument_list|()
operator|==
literal|1
operator|||
operator|(
name|E
operator|->
name|getNumArgs
argument_list|()
operator|>
literal|1
operator|&&
name|getDerived
argument_list|()
operator|.
name|DropCallArgument
argument_list|(
name|E
operator|->
name|getArg
argument_list|(
literal|1
argument_list|)
argument_list|)
operator|)
condition|)
return|return
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getArg
argument_list|(
literal|0
argument_list|)
argument_list|)
return|;
name|TemporaryBase
name|Rebase
argument_list|(
operator|*
name|this
argument_list|,
comment|/*FIXME*/
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|DeclarationName
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|QualType
name|T
init|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getType
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|T
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_if

begin_decl_stmt
name|CXXConstructorDecl
modifier|*
name|Constructor
init|=
name|cast_or_null
operator|<
name|CXXConstructorDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|E
operator|->
name|getConstructor
argument_list|()
argument_list|)
operator|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
operator|!
name|Constructor
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_if

begin_decl_stmt
name|bool
name|ArgumentChanged
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|ASTOwningVector
operator|<
operator|&
name|ActionBase
operator|::
name|DeleteExpr
operator|>
name|Args
argument_list|(
name|SemaRef
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|CXXConstructExpr
operator|::
name|arg_iterator
name|Arg
operator|=
name|E
operator|->
name|arg_begin
argument_list|()
operator|,
name|ArgEnd
operator|=
name|E
operator|->
name|arg_end
argument_list|()
init|;
name|Arg
operator|!=
name|ArgEnd
condition|;
operator|++
name|Arg
control|)
block|{
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|DropCallArgument
argument_list|(
operator|*
name|Arg
argument_list|)
condition|)
block|{
name|ArgumentChanged
operator|=
name|true
expr_stmt|;
break|break;
block|}
name|OwningExprResult
name|TransArg
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
operator|*
name|Arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|TransArg
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
name|ArgumentChanged
operator|=
name|ArgumentChanged
operator|||
name|TransArg
operator|.
name|get
argument_list|()
operator|!=
operator|*
name|Arg
expr_stmt|;
name|Args
operator|.
name|push_back
argument_list|(
name|TransArg
operator|.
name|takeAs
operator|<
name|Expr
operator|>
operator|(
operator|)
argument_list|)
expr_stmt|;
block|}
end_for

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|T
operator|==
name|E
operator|->
name|getType
argument_list|()
operator|&&
name|Constructor
operator|==
name|E
operator|->
name|getConstructor
argument_list|()
operator|&&
operator|!
name|ArgumentChanged
condition|)
block|{
comment|// Mark the constructor as referenced.
comment|// FIXME: Instantiation-specific
name|SemaRef
operator|.
name|MarkDeclarationReferenced
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|Constructor
argument_list|)
expr_stmt|;
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
block|}
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXConstructExpr
argument_list|(
name|T
argument_list|,
comment|/*FIXME:*/
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|Constructor
argument_list|,
name|E
operator|->
name|isElidable
argument_list|()
argument_list|,
name|move_arg
argument_list|(
name|Args
argument_list|)
argument_list|)
return|;
end_return

begin_comment
unit|}
comment|/// \brief Transform a C++ temporary-binding expression.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Since CXXBindTemporaryExpr nodes are implicitly generated, we just
end_comment

begin_comment
comment|/// transform the subexpression and return that.
end_comment

begin_expr_stmt
unit|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXBindTemporaryExpr
argument_list|(
argument|CXXBindTemporaryExpr *E
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getSubExpr
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief Transform a C++ reference-binding expression.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Since CXXBindReferenceExpr nodes are implicitly generated, we just
end_comment

begin_comment
comment|/// transform the subexpression and return that.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXBindReferenceExpr
argument_list|(
argument|CXXBindReferenceExpr *E
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getSubExpr
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// \brief Transform a C++ expression that contains temporaries that should
end_comment

begin_comment
comment|/// be destroyed after the expression is evaluated.
end_comment

begin_comment
comment|///
end_comment

begin_comment
comment|/// Since CXXExprWithTemporaries nodes are implicitly generated, we
end_comment

begin_comment
comment|/// just transform the subexpression and return that.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXExprWithTemporaries
argument_list|(
argument|CXXExprWithTemporaries *E
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getSubExpr
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXTemporaryObjectExpr
argument_list|(
argument|CXXTemporaryObjectExpr *E
argument_list|)
block|{
name|TemporaryBase
name|Rebase
argument_list|(
operator|*
name|this
argument_list|,
name|E
operator|->
name|getTypeBeginLoc
argument_list|()
argument_list|,
name|DeclarationName
argument_list|()
argument_list|)
block|;
name|QualType
name|T
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getType
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|T
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
name|CXXConstructorDecl
operator|*
name|Constructor
operator|=
name|cast_or_null
operator|<
name|CXXConstructorDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|E
operator|->
name|getConstructor
argument_list|()
argument_list|)
operator|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|Constructor
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_if

begin_decl_stmt
name|bool
name|ArgumentChanged
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|ASTOwningVector
operator|<
operator|&
name|ActionBase
operator|::
name|DeleteExpr
operator|>
name|Args
argument_list|(
name|SemaRef
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Args
operator|.
name|reserve
argument_list|(
name|E
operator|->
name|getNumArgs
argument_list|()
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|CXXTemporaryObjectExpr
operator|::
name|arg_iterator
name|Arg
operator|=
name|E
operator|->
name|arg_begin
argument_list|()
operator|,
name|ArgEnd
operator|=
name|E
operator|->
name|arg_end
argument_list|()
init|;
name|Arg
operator|!=
name|ArgEnd
condition|;
operator|++
name|Arg
control|)
block|{
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|DropCallArgument
argument_list|(
operator|*
name|Arg
argument_list|)
condition|)
block|{
name|ArgumentChanged
operator|=
name|true
expr_stmt|;
break|break;
block|}
name|OwningExprResult
name|TransArg
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
operator|*
name|Arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|TransArg
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
name|ArgumentChanged
operator|=
name|ArgumentChanged
operator|||
name|TransArg
operator|.
name|get
argument_list|()
operator|!=
operator|*
name|Arg
expr_stmt|;
name|Args
operator|.
name|push_back
argument_list|(
operator|(
name|Expr
operator|*
operator|)
name|TransArg
operator|.
name|release
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_for

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|T
operator|==
name|E
operator|->
name|getType
argument_list|()
operator|&&
name|Constructor
operator|==
name|E
operator|->
name|getConstructor
argument_list|()
operator|&&
operator|!
name|ArgumentChanged
condition|)
block|{
comment|// FIXME: Instantiation-specific
name|SemaRef
operator|.
name|MarkDeclarationReferenced
argument_list|(
name|E
operator|->
name|getTypeBeginLoc
argument_list|()
argument_list|,
name|Constructor
argument_list|)
expr_stmt|;
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
block|}
end_if

begin_comment
comment|// FIXME: Bogus location information
end_comment

begin_decl_stmt
name|SourceLocation
name|CommaLoc
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Args
operator|.
name|size
argument_list|()
operator|>
literal|1
condition|)
block|{
name|Expr
modifier|*
name|First
init|=
operator|(
name|Expr
operator|*
operator|)
name|Args
index|[
literal|0
index|]
decl_stmt|;
name|CommaLoc
operator|=
name|SemaRef
operator|.
name|PP
operator|.
name|getLocForEndOfToken
argument_list|(
name|First
operator|->
name|getSourceRange
argument_list|()
operator|.
name|getEnd
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXTemporaryObjectExpr
argument_list|(
name|E
operator|->
name|getTypeBeginLoc
argument_list|()
argument_list|,
name|T
argument_list|,
comment|/*FIXME:*/
name|E
operator|->
name|getTypeBeginLoc
argument_list|()
argument_list|,
name|move_arg
argument_list|(
name|Args
argument_list|)
argument_list|,
operator|&
name|CommaLoc
argument_list|,
name|E
operator|->
name|getLocEnd
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXUnresolvedConstructExpr
argument_list|(
argument|CXXUnresolvedConstructExpr *E
argument_list|)
block|{
name|TemporaryBase
name|Rebase
argument_list|(
operator|*
name|this
argument_list|,
name|E
operator|->
name|getTypeBeginLoc
argument_list|()
argument_list|,
name|DeclarationName
argument_list|()
argument_list|)
block|;
name|QualType
name|T
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getTypeAsWritten
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|T
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
name|bool
name|ArgumentChanged
operator|=
name|false
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ASTOwningVector
operator|<
operator|&
name|ActionBase
operator|::
name|DeleteExpr
operator|>
name|Args
argument_list|(
name|SemaRef
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|llvm
operator|::
name|SmallVector
operator|<
name|SourceLocation
operator|,
literal|8
operator|>
name|FakeCommaLocs
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|CXXUnresolvedConstructExpr
operator|::
name|arg_iterator
name|Arg
operator|=
name|E
operator|->
name|arg_begin
argument_list|()
operator|,
name|ArgEnd
operator|=
name|E
operator|->
name|arg_end
argument_list|()
init|;
name|Arg
operator|!=
name|ArgEnd
condition|;
operator|++
name|Arg
control|)
block|{
name|OwningExprResult
name|TransArg
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
operator|*
name|Arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|TransArg
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
name|ArgumentChanged
operator|=
name|ArgumentChanged
operator|||
name|TransArg
operator|.
name|get
argument_list|()
operator|!=
operator|*
name|Arg
expr_stmt|;
name|FakeCommaLocs
operator|.
name|push_back
argument_list|(
name|SemaRef
operator|.
name|PP
operator|.
name|getLocForEndOfToken
argument_list|(
operator|(
operator|*
name|Arg
operator|)
operator|->
name|getLocEnd
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
name|Args
operator|.
name|push_back
argument_list|(
name|TransArg
operator|.
name|takeAs
operator|<
name|Expr
operator|>
operator|(
operator|)
argument_list|)
expr_stmt|;
block|}
end_for

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|T
operator|==
name|E
operator|->
name|getTypeAsWritten
argument_list|()
operator|&&
operator|!
name|ArgumentChanged
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_comment
comment|// FIXME: we're faking the locations of the commas
end_comment

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXUnresolvedConstructExpr
argument_list|(
name|E
operator|->
name|getTypeBeginLoc
argument_list|()
argument_list|,
name|T
argument_list|,
name|E
operator|->
name|getLParenLoc
argument_list|()
argument_list|,
name|move_arg
argument_list|(
name|Args
argument_list|)
argument_list|,
name|FakeCommaLocs
operator|.
name|data
argument_list|()
argument_list|,
name|E
operator|->
name|getRParenLoc
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformCXXDependentScopeMemberExpr
argument_list|(
argument|CXXDependentScopeMemberExpr *E
argument_list|)
block|{
comment|// Transform the base of the expression.
name|OwningExprResult
name|Base
argument_list|(
name|SemaRef
argument_list|,
operator|(
name|Expr
operator|*
operator|)
literal|0
argument_list|)
block|;
name|Expr
operator|*
name|OldBase
block|;
name|QualType
name|BaseType
block|;
name|QualType
name|ObjectType
block|;
if|if
condition|(
operator|!
name|E
operator|->
name|isImplicitAccess
argument_list|()
condition|)
block|{
name|OldBase
operator|=
name|E
operator|->
name|getBase
argument_list|()
expr_stmt|;
name|Base
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|OldBase
argument_list|)
expr_stmt|;
if|if
condition|(
name|Base
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
comment|// Start the member reference and compute the object's type.
name|Sema
operator|::
name|TypeTy
operator|*
name|ObjectTy
operator|=
literal|0
expr_stmt|;
name|bool
name|MayBePseudoDestructor
init|=
name|false
decl_stmt|;
name|Base
operator|=
name|SemaRef
operator|.
name|ActOnStartCXXMemberReference
argument_list|(
literal|0
argument_list|,
name|move
argument_list|(
name|Base
argument_list|)
argument_list|,
name|E
operator|->
name|getOperatorLoc
argument_list|()
argument_list|,
name|E
operator|->
name|isArrow
argument_list|()
condition|?
name|tok
operator|::
name|arrow
else|:
name|tok
operator|::
name|period
argument_list|,
name|ObjectTy
argument_list|,
name|MayBePseudoDestructor
argument_list|)
expr_stmt|;
if|if
condition|(
name|Base
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
name|ObjectType
operator|=
name|QualType
operator|::
name|getFromOpaquePtr
argument_list|(
name|ObjectTy
argument_list|)
expr_stmt|;
name|BaseType
operator|=
operator|(
operator|(
name|Expr
operator|*
operator|)
name|Base
operator|.
name|get
argument_list|()
operator|)
operator|->
name|getType
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|OldBase
operator|=
literal|0
expr_stmt|;
name|BaseType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getBaseType
argument_list|()
argument_list|)
expr_stmt|;
name|ObjectType
operator|=
name|BaseType
operator|->
name|getAs
operator|<
name|PointerType
operator|>
operator|(
operator|)
operator|->
name|getPointeeType
argument_list|()
expr_stmt|;
block|}
end_else

begin_comment
comment|// Transform the first part of the nested-name-specifier that qualifies
end_comment

begin_comment
comment|// the member name.
end_comment

begin_decl_stmt
name|NamedDecl
modifier|*
name|FirstQualifierInScope
init|=
name|getDerived
argument_list|()
operator|.
name|TransformFirstQualifierInScope
argument_list|(
name|E
operator|->
name|getFirstQualifierFoundInScope
argument_list|()
argument_list|,
name|E
operator|->
name|getQualifierRange
argument_list|()
operator|.
name|getBegin
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|NestedNameSpecifier
modifier|*
name|Qualifier
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|E
operator|->
name|getQualifier
argument_list|()
condition|)
block|{
name|Qualifier
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformNestedNameSpecifier
argument_list|(
name|E
operator|->
name|getQualifier
argument_list|()
argument_list|,
name|E
operator|->
name|getQualifierRange
argument_list|()
argument_list|,
name|ObjectType
argument_list|,
name|FirstQualifierInScope
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Qualifier
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|DeclarationName
name|Name
init|=
name|getDerived
argument_list|()
operator|.
name|TransformDeclarationName
argument_list|(
name|E
operator|->
name|getMember
argument_list|()
argument_list|,
name|E
operator|->
name|getMemberLoc
argument_list|()
argument_list|,
name|ObjectType
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
operator|!
name|Name
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_if

begin_if
if|if
condition|(
operator|!
name|E
operator|->
name|hasExplicitTemplateArgs
argument_list|()
condition|)
block|{
comment|// This is a reference to a member without an explicitly-specified
comment|// template argument list. Optimize for this common case.
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Base
operator|.
name|get
argument_list|()
operator|==
name|OldBase
operator|&&
name|BaseType
operator|==
name|E
operator|->
name|getBaseType
argument_list|()
operator|&&
name|Qualifier
operator|==
name|E
operator|->
name|getQualifier
argument_list|()
operator|&&
name|Name
operator|==
name|E
operator|->
name|getMember
argument_list|()
operator|&&
name|FirstQualifierInScope
operator|==
name|E
operator|->
name|getFirstQualifierFoundInScope
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXDependentScopeMemberExpr
argument_list|(
name|move
argument_list|(
name|Base
argument_list|)
argument_list|,
name|BaseType
argument_list|,
name|E
operator|->
name|isArrow
argument_list|()
argument_list|,
name|E
operator|->
name|getOperatorLoc
argument_list|()
argument_list|,
name|Qualifier
argument_list|,
name|E
operator|->
name|getQualifierRange
argument_list|()
argument_list|,
name|FirstQualifierInScope
argument_list|,
name|Name
argument_list|,
name|E
operator|->
name|getMemberLoc
argument_list|()
argument_list|,
comment|/*TemplateArgs*/
literal|0
argument_list|)
return|;
block|}
end_if

begin_decl_stmt
name|TemplateArgumentListInfo
name|TransArgs
argument_list|(
name|E
operator|->
name|getLAngleLoc
argument_list|()
argument_list|,
name|E
operator|->
name|getRAngleLoc
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_for
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|,
name|N
init|=
name|E
operator|->
name|getNumTemplateArgs
argument_list|()
init|;
name|I
operator|!=
name|N
condition|;
operator|++
name|I
control|)
block|{
name|TemplateArgumentLoc
name|Loc
decl_stmt|;
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TransformTemplateArgument
argument_list|(
name|E
operator|->
name|getTemplateArgs
argument_list|()
index|[
name|I
index|]
argument_list|,
name|Loc
argument_list|)
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
name|TransArgs
operator|.
name|addArgument
argument_list|(
name|Loc
argument_list|)
expr_stmt|;
block|}
end_for

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildCXXDependentScopeMemberExpr
argument_list|(
name|move
argument_list|(
name|Base
argument_list|)
argument_list|,
name|BaseType
argument_list|,
name|E
operator|->
name|isArrow
argument_list|()
argument_list|,
name|E
operator|->
name|getOperatorLoc
argument_list|()
argument_list|,
name|Qualifier
argument_list|,
name|E
operator|->
name|getQualifierRange
argument_list|()
argument_list|,
name|FirstQualifierInScope
argument_list|,
name|Name
argument_list|,
name|E
operator|->
name|getMemberLoc
argument_list|()
argument_list|,
operator|&
name|TransArgs
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformUnresolvedMemberExpr
argument_list|(
argument|UnresolvedMemberExpr *Old
argument_list|)
block|{
comment|// Transform the base of the expression.
name|OwningExprResult
name|Base
argument_list|(
name|SemaRef
argument_list|,
operator|(
name|Expr
operator|*
operator|)
literal|0
argument_list|)
block|;
name|QualType
name|BaseType
block|;
if|if
condition|(
operator|!
name|Old
operator|->
name|isImplicitAccess
argument_list|()
condition|)
block|{
name|Base
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|Old
operator|->
name|getBase
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Base
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
name|BaseType
operator|=
operator|(
operator|(
name|Expr
operator|*
operator|)
name|Base
operator|.
name|get
argument_list|()
operator|)
operator|->
name|getType
argument_list|()
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|BaseType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|Old
operator|->
name|getBaseType
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_else

begin_decl_stmt
name|NestedNameSpecifier
modifier|*
name|Qualifier
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Old
operator|->
name|getQualifier
argument_list|()
condition|)
block|{
name|Qualifier
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformNestedNameSpecifier
argument_list|(
name|Old
operator|->
name|getQualifier
argument_list|()
argument_list|,
name|Old
operator|->
name|getQualifierRange
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|Qualifier
operator|==
literal|0
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
block|}
end_if

begin_decl_stmt
name|LookupResult
name|R
argument_list|(
name|SemaRef
argument_list|,
name|Old
operator|->
name|getMemberName
argument_list|()
argument_list|,
name|Old
operator|->
name|getMemberLoc
argument_list|()
argument_list|,
name|Sema
operator|::
name|LookupOrdinaryName
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Transform all the decls.
end_comment

begin_for
for|for
control|(
name|UnresolvedMemberExpr
operator|::
name|decls_iterator
name|I
operator|=
name|Old
operator|->
name|decls_begin
argument_list|()
operator|,
name|E
operator|=
name|Old
operator|->
name|decls_end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|NamedDecl
modifier|*
name|InstD
init|=
name|static_cast
operator|<
name|NamedDecl
operator|*
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|Old
operator|->
name|getMemberLoc
argument_list|()
argument_list|,
operator|*
name|I
argument_list|)
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|InstD
condition|)
block|{
comment|// Silently ignore these if a UsingShadowDecl instantiated to nothing.
comment|// This can happen because of dependent hiding.
if|if
condition|(
name|isa
operator|<
name|UsingShadowDecl
operator|>
operator|(
operator|*
name|I
operator|)
condition|)
continue|continue;
else|else
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
block|}
comment|// Expand using declarations.
if|if
condition|(
name|isa
operator|<
name|UsingDecl
operator|>
operator|(
name|InstD
operator|)
condition|)
block|{
name|UsingDecl
modifier|*
name|UD
init|=
name|cast
operator|<
name|UsingDecl
operator|>
operator|(
name|InstD
operator|)
decl_stmt|;
for|for
control|(
name|UsingDecl
operator|::
name|shadow_iterator
name|I
operator|=
name|UD
operator|->
name|shadow_begin
argument_list|()
operator|,
name|E
operator|=
name|UD
operator|->
name|shadow_end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
name|R
operator|.
name|addDecl
argument_list|(
operator|*
name|I
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|R
operator|.
name|addDecl
argument_list|(
name|InstD
argument_list|)
expr_stmt|;
block|}
end_for

begin_expr_stmt
name|R
operator|.
name|resolveKind
argument_list|()
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|TemplateArgumentListInfo
name|TransArgs
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Old
operator|->
name|hasExplicitTemplateArgs
argument_list|()
condition|)
block|{
name|TransArgs
operator|.
name|setLAngleLoc
argument_list|(
name|Old
operator|->
name|getLAngleLoc
argument_list|()
argument_list|)
expr_stmt|;
name|TransArgs
operator|.
name|setRAngleLoc
argument_list|(
name|Old
operator|->
name|getRAngleLoc
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|,
name|N
init|=
name|Old
operator|->
name|getNumTemplateArgs
argument_list|()
init|;
name|I
operator|!=
name|N
condition|;
operator|++
name|I
control|)
block|{
name|TemplateArgumentLoc
name|Loc
decl_stmt|;
if|if
condition|(
name|getDerived
argument_list|()
operator|.
name|TransformTemplateArgument
argument_list|(
name|Old
operator|->
name|getTemplateArgs
argument_list|()
index|[
name|I
index|]
argument_list|,
name|Loc
argument_list|)
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
name|TransArgs
operator|.
name|addArgument
argument_list|(
name|Loc
argument_list|)
expr_stmt|;
block|}
block|}
end_if

begin_comment
comment|// FIXME: to do this check properly, we will need to preserve the
end_comment

begin_comment
comment|// first-qualifier-in-scope here, just in case we had a dependent
end_comment

begin_comment
comment|// base (and therefore couldn't do the check) and a
end_comment

begin_comment
comment|// nested-name-qualifier (and therefore could do the lookup).
end_comment

begin_decl_stmt
name|NamedDecl
modifier|*
name|FirstQualifierInScope
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildUnresolvedMemberExpr
argument_list|(
name|move
argument_list|(
name|Base
argument_list|)
argument_list|,
name|BaseType
argument_list|,
name|Old
operator|->
name|getOperatorLoc
argument_list|()
argument_list|,
name|Old
operator|->
name|isArrow
argument_list|()
argument_list|,
name|Qualifier
argument_list|,
name|Old
operator|->
name|getQualifierRange
argument_list|()
argument_list|,
name|FirstQualifierInScope
argument_list|,
name|R
argument_list|,
operator|(
name|Old
operator|->
name|hasExplicitTemplateArgs
argument_list|()
condition|?
operator|&
name|TransArgs
else|:
literal|0
operator|)
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCStringLiteral
argument_list|(
argument|ObjCStringLiteral *E
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCEncodeExpr
argument_list|(
argument|ObjCEncodeExpr *E
argument_list|)
block|{
comment|// FIXME: poor source location
name|TemporaryBase
name|Rebase
argument_list|(
operator|*
name|this
argument_list|,
name|E
operator|->
name|getAtLoc
argument_list|()
argument_list|,
name|DeclarationName
argument_list|()
argument_list|)
block|;
name|QualType
name|EncodedType
operator|=
name|getDerived
argument_list|()
operator|.
name|TransformType
argument_list|(
name|E
operator|->
name|getEncodedType
argument_list|()
argument_list|)
block|;
if|if
condition|(
name|EncodedType
operator|.
name|isNull
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|EncodedType
operator|==
name|E
operator|->
name|getEncodedType
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildObjCEncodeExpr
argument_list|(
name|E
operator|->
name|getAtLoc
argument_list|()
argument_list|,
name|EncodedType
argument_list|,
name|E
operator|->
name|getRParenLoc
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCMessageExpr
argument_list|(
argument|ObjCMessageExpr *E
argument_list|)
block|{
comment|// FIXME: Implement this!
name|assert
argument_list|(
name|false
operator|&&
literal|"Cannot transform Objective-C expressions yet"
argument_list|)
block|;
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCSelectorExpr
argument_list|(
argument|ObjCSelectorExpr *E
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCProtocolExpr
argument_list|(
argument|ObjCProtocolExpr *E
argument_list|)
block|{
name|ObjCProtocolDecl
operator|*
name|Protocol
operator|=
name|cast_or_null
operator|<
name|ObjCProtocolDecl
operator|>
operator|(
name|getDerived
argument_list|()
operator|.
name|TransformDecl
argument_list|(
name|E
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|E
operator|->
name|getProtocol
argument_list|()
argument_list|)
operator|)
block|;
if|if
condition|(
operator|!
name|Protocol
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
name|Protocol
operator|==
name|E
operator|->
name|getProtocol
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildObjCProtocolExpr
argument_list|(
name|Protocol
argument_list|,
name|E
operator|->
name|getAtLoc
argument_list|()
argument_list|,
comment|/*FIXME:*/
name|E
operator|->
name|getAtLoc
argument_list|()
argument_list|,
comment|/*FIXME:*/
name|E
operator|->
name|getAtLoc
argument_list|()
argument_list|,
name|E
operator|->
name|getRParenLoc
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCIvarRefExpr
argument_list|(
argument|ObjCIvarRefExpr *E
argument_list|)
block|{
comment|// FIXME: Implement this!
name|assert
argument_list|(
name|false
operator|&&
literal|"Cannot transform Objective-C expressions yet"
argument_list|)
block|;
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCPropertyRefExpr
argument_list|(
argument|ObjCPropertyRefExpr *E
argument_list|)
block|{
comment|// FIXME: Implement this!
name|assert
argument_list|(
name|false
operator|&&
literal|"Cannot transform Objective-C expressions yet"
argument_list|)
block|;
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCImplicitSetterGetterRefExpr
argument_list|(
argument|ObjCImplicitSetterGetterRefExpr *E
argument_list|)
block|{
comment|// FIXME: Implement this!
name|assert
argument_list|(
name|false
operator|&&
literal|"Cannot transform Objective-C expressions yet"
argument_list|)
block|;
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCSuperExpr
argument_list|(
argument|ObjCSuperExpr *E
argument_list|)
block|{
comment|// FIXME: Implement this!
name|assert
argument_list|(
name|false
operator|&&
literal|"Cannot transform Objective-C expressions yet"
argument_list|)
block|;
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformObjCIsaExpr
argument_list|(
argument|ObjCIsaExpr *E
argument_list|)
block|{
comment|// FIXME: Implement this!
name|assert
argument_list|(
name|false
operator|&&
literal|"Cannot transform Objective-C expressions yet"
argument_list|)
block|;
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformShuffleVectorExpr
argument_list|(
argument|ShuffleVectorExpr *E
argument_list|)
block|{
name|bool
name|ArgumentChanged
operator|=
name|false
block|;
name|ASTOwningVector
operator|<
operator|&
name|ActionBase
operator|::
name|DeleteExpr
operator|>
name|SubExprs
argument_list|(
name|SemaRef
argument_list|)
block|;
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|,
name|N
init|=
name|E
operator|->
name|getNumSubExprs
argument_list|()
init|;
name|I
operator|!=
name|N
condition|;
operator|++
name|I
control|)
block|{
name|OwningExprResult
name|SubExpr
init|=
name|getDerived
argument_list|()
operator|.
name|TransformExpr
argument_list|(
name|E
operator|->
name|getExpr
argument_list|(
name|I
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|SubExpr
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
name|ArgumentChanged
operator|=
name|ArgumentChanged
operator|||
name|SubExpr
operator|.
name|get
argument_list|()
operator|!=
name|E
operator|->
name|getExpr
argument_list|(
name|I
argument_list|)
expr_stmt|;
name|SubExprs
operator|.
name|push_back
argument_list|(
name|SubExpr
operator|.
name|takeAs
operator|<
name|Expr
operator|>
operator|(
operator|)
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|getDerived
argument_list|()
operator|.
name|AlwaysRebuild
argument_list|()
operator|&&
operator|!
name|ArgumentChanged
condition|)
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
end_if

begin_return
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildShuffleVectorExpr
argument_list|(
name|E
operator|->
name|getBuiltinLoc
argument_list|()
argument_list|,
name|move_arg
argument_list|(
name|SubExprs
argument_list|)
argument_list|,
name|E
operator|->
name|getRParenLoc
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformBlockExpr
argument_list|(
argument|BlockExpr *E
argument_list|)
block|{
comment|// FIXME: Implement this!
name|assert
argument_list|(
name|false
operator|&&
literal|"Cannot transform block expressions yet"
argument_list|)
block|;
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|TransformBlockDeclRefExpr
argument_list|(
argument|BlockDeclRefExpr *E
argument_list|)
block|{
comment|// FIXME: Implement this!
name|assert
argument_list|(
name|false
operator|&&
literal|"Cannot transform block-related expressions yet"
argument_list|)
block|;
return|return
name|SemaRef
operator|.
name|Owned
argument_list|(
name|E
operator|->
name|Retain
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// Type reconstruction
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildPointerType
argument_list|(
argument|QualType PointeeType
argument_list|,
argument|SourceLocation Star
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|BuildPointerType
argument_list|(
name|PointeeType
argument_list|,
name|Qualifiers
argument_list|()
argument_list|,
name|Star
argument_list|,
name|getDerived
argument_list|()
operator|.
name|getBaseEntity
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildBlockPointerType
argument_list|(
argument|QualType PointeeType
argument_list|,
argument|SourceLocation Star
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|BuildBlockPointerType
argument_list|(
name|PointeeType
argument_list|,
name|Qualifiers
argument_list|()
argument_list|,
name|Star
argument_list|,
name|getDerived
argument_list|()
operator|.
name|getBaseEntity
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildReferenceType
argument_list|(
argument|QualType ReferentType
argument_list|,
argument|bool WrittenAsLValue
argument_list|,
argument|SourceLocation Sigil
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|BuildReferenceType
argument_list|(
name|ReferentType
argument_list|,
name|WrittenAsLValue
argument_list|,
name|Qualifiers
argument_list|()
argument_list|,
name|Sigil
argument_list|,
name|getDerived
argument_list|()
operator|.
name|getBaseEntity
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildMemberPointerType
argument_list|(
argument|QualType PointeeType
argument_list|,
argument|QualType ClassType
argument_list|,
argument|SourceLocation Sigil
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|BuildMemberPointerType
argument_list|(
name|PointeeType
argument_list|,
name|ClassType
argument_list|,
name|Qualifiers
argument_list|()
argument_list|,
name|Sigil
argument_list|,
name|getDerived
argument_list|()
operator|.
name|getBaseEntity
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildObjCObjectPointerType
argument_list|(
argument|QualType PointeeType
argument_list|,
argument|SourceLocation Sigil
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|BuildPointerType
argument_list|(
name|PointeeType
argument_list|,
name|Qualifiers
argument_list|()
argument_list|,
name|Sigil
argument_list|,
name|getDerived
argument_list|()
operator|.
name|getBaseEntity
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildArrayType
argument_list|(
argument|QualType ElementType
argument_list|,
argument|ArrayType::ArraySizeModifier SizeMod
argument_list|,
argument|const llvm::APInt *Size
argument_list|,
argument|Expr *SizeExpr
argument_list|,
argument|unsigned IndexTypeQuals
argument_list|,
argument|SourceRange BracketsRange
argument_list|)
block|{
if|if
condition|(
name|SizeExpr
operator|||
operator|!
name|Size
condition|)
return|return
name|SemaRef
operator|.
name|BuildArrayType
argument_list|(
name|ElementType
argument_list|,
name|SizeMod
argument_list|,
name|SizeExpr
argument_list|,
name|IndexTypeQuals
argument_list|,
name|BracketsRange
argument_list|,
name|getDerived
argument_list|()
operator|.
name|getBaseEntity
argument_list|()
argument_list|)
return|;
name|QualType
name|Types
index|[]
operator|=
block|{
name|SemaRef
operator|.
name|Context
operator|.
name|UnsignedCharTy
block|,
name|SemaRef
operator|.
name|Context
operator|.
name|UnsignedShortTy
block|,
name|SemaRef
operator|.
name|Context
operator|.
name|UnsignedIntTy
block|,
name|SemaRef
operator|.
name|Context
operator|.
name|UnsignedLongTy
block|,
name|SemaRef
operator|.
name|Context
operator|.
name|UnsignedLongLongTy
block|,
name|SemaRef
operator|.
name|Context
operator|.
name|UnsignedInt128Ty
block|}
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|const
name|unsigned
name|NumTypes
init|=
sizeof|sizeof
argument_list|(
name|Types
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|QualType
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|QualType
name|SizeType
decl_stmt|;
end_decl_stmt

begin_for
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|;
name|I
operator|!=
name|NumTypes
condition|;
operator|++
name|I
control|)
if|if
condition|(
name|Size
operator|->
name|getBitWidth
argument_list|()
operator|==
name|SemaRef
operator|.
name|Context
operator|.
name|getIntWidth
argument_list|(
name|Types
index|[
name|I
index|]
argument_list|)
condition|)
block|{
name|SizeType
operator|=
name|Types
index|[
name|I
index|]
expr_stmt|;
break|break;
block|}
end_for

begin_decl_stmt
name|IntegerLiteral
name|ArraySize
argument_list|(
operator|*
name|Size
argument_list|,
name|SizeType
argument_list|,
comment|/*FIXME*/
name|BracketsRange
operator|.
name|getBegin
argument_list|()
argument_list|)
decl_stmt|;
end_decl_stmt

begin_return
return|return
name|SemaRef
operator|.
name|BuildArrayType
argument_list|(
name|ElementType
argument_list|,
name|SizeMod
argument_list|,
operator|&
name|ArraySize
argument_list|,
name|IndexTypeQuals
argument_list|,
name|BracketsRange
argument_list|,
name|getDerived
argument_list|()
operator|.
name|getBaseEntity
argument_list|()
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildConstantArrayType
argument_list|(
argument|QualType ElementType
argument_list|,
argument|ArrayType::ArraySizeModifier SizeMod
argument_list|,
argument|const llvm::APInt&Size
argument_list|,
argument|unsigned IndexTypeQuals
argument_list|,
argument|SourceRange BracketsRange
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildArrayType
argument_list|(
name|ElementType
argument_list|,
name|SizeMod
argument_list|,
operator|&
name|Size
argument_list|,
literal|0
argument_list|,
name|IndexTypeQuals
argument_list|,
name|BracketsRange
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildIncompleteArrayType
argument_list|(
argument|QualType ElementType
argument_list|,
argument|ArrayType::ArraySizeModifier SizeMod
argument_list|,
argument|unsigned IndexTypeQuals
argument_list|,
argument|SourceRange BracketsRange
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildArrayType
argument_list|(
name|ElementType
argument_list|,
name|SizeMod
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|IndexTypeQuals
argument_list|,
name|BracketsRange
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildVariableArrayType
argument_list|(
argument|QualType ElementType
argument_list|,
argument|ArrayType::ArraySizeModifier SizeMod
argument_list|,
argument|ExprArg SizeExpr
argument_list|,
argument|unsigned IndexTypeQuals
argument_list|,
argument|SourceRange BracketsRange
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildArrayType
argument_list|(
name|ElementType
argument_list|,
name|SizeMod
argument_list|,
literal|0
argument_list|,
name|SizeExpr
operator|.
name|takeAs
operator|<
name|Expr
operator|>
operator|(
operator|)
argument_list|,
name|IndexTypeQuals
argument_list|,
name|BracketsRange
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildDependentSizedArrayType
argument_list|(
argument|QualType ElementType
argument_list|,
argument|ArrayType::ArraySizeModifier SizeMod
argument_list|,
argument|ExprArg SizeExpr
argument_list|,
argument|unsigned IndexTypeQuals
argument_list|,
argument|SourceRange BracketsRange
argument_list|)
block|{
return|return
name|getDerived
argument_list|()
operator|.
name|RebuildArrayType
argument_list|(
name|ElementType
argument_list|,
name|SizeMod
argument_list|,
literal|0
argument_list|,
name|SizeExpr
operator|.
name|takeAs
operator|<
name|Expr
operator|>
operator|(
operator|)
argument_list|,
name|IndexTypeQuals
argument_list|,
name|BracketsRange
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildVectorType
argument_list|(
argument|QualType ElementType
argument_list|,
argument|unsigned NumElements
argument_list|,
argument|bool IsAltiVec
argument_list|,
argument|bool IsPixel
argument_list|)
block|{
comment|// FIXME: semantic checking!
return|return
name|SemaRef
operator|.
name|Context
operator|.
name|getVectorType
argument_list|(
name|ElementType
argument_list|,
name|NumElements
argument_list|,
name|IsAltiVec
argument_list|,
name|IsPixel
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildExtVectorType
argument_list|(
argument|QualType ElementType
argument_list|,
argument|unsigned NumElements
argument_list|,
argument|SourceLocation AttributeLoc
argument_list|)
block|{
name|llvm
operator|::
name|APInt
name|numElements
argument_list|(
name|SemaRef
operator|.
name|Context
operator|.
name|getIntWidth
argument_list|(
name|SemaRef
operator|.
name|Context
operator|.
name|IntTy
argument_list|)
argument_list|,
name|NumElements
argument_list|,
name|true
argument_list|)
block|;
name|IntegerLiteral
operator|*
name|VectorSize
operator|=
name|new
argument_list|(
argument|SemaRef.Context
argument_list|)
name|IntegerLiteral
argument_list|(
name|numElements
argument_list|,
name|SemaRef
operator|.
name|Context
operator|.
name|IntTy
argument_list|,
name|AttributeLoc
argument_list|)
block|;
return|return
name|SemaRef
operator|.
name|BuildExtVectorType
argument_list|(
name|ElementType
argument_list|,
name|SemaRef
operator|.
name|Owned
argument_list|(
name|VectorSize
argument_list|)
argument_list|,
name|AttributeLoc
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildDependentSizedExtVectorType
argument_list|(
argument|QualType ElementType
argument_list|,
argument|ExprArg SizeExpr
argument_list|,
argument|SourceLocation AttributeLoc
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|BuildExtVectorType
argument_list|(
name|ElementType
argument_list|,
name|move
argument_list|(
name|SizeExpr
argument_list|)
argument_list|,
name|AttributeLoc
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildFunctionProtoType
argument_list|(
argument|QualType T
argument_list|,
argument|QualType *ParamTypes
argument_list|,
argument|unsigned NumParamTypes
argument_list|,
argument|bool Variadic
argument_list|,
argument|unsigned Quals
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|BuildFunctionType
argument_list|(
name|T
argument_list|,
name|ParamTypes
argument_list|,
name|NumParamTypes
argument_list|,
name|Variadic
argument_list|,
name|Quals
argument_list|,
name|getDerived
argument_list|()
operator|.
name|getBaseLocation
argument_list|()
argument_list|,
name|getDerived
argument_list|()
operator|.
name|getBaseEntity
argument_list|()
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildFunctionNoProtoType
argument_list|(
argument|QualType T
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|Context
operator|.
name|getFunctionNoProtoType
argument_list|(
name|T
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildUnresolvedUsingType
argument_list|(
argument|Decl *D
argument_list|)
block|{
name|assert
argument_list|(
name|D
operator|&&
literal|"no decl found"
argument_list|)
block|;
if|if
condition|(
name|D
operator|->
name|isInvalidDecl
argument_list|()
condition|)
return|return
name|QualType
argument_list|()
return|;
name|TypeDecl
operator|*
name|Ty
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|isa
operator|<
name|UsingDecl
operator|>
operator|(
name|D
operator|)
condition|)
block|{
name|UsingDecl
modifier|*
name|Using
init|=
name|cast
operator|<
name|UsingDecl
operator|>
operator|(
name|D
operator|)
decl_stmt|;
name|assert
argument_list|(
name|Using
operator|->
name|isTypeName
argument_list|()
operator|&&
literal|"UnresolvedUsingTypenameDecl transformed to non-typename using"
argument_list|)
expr_stmt|;
comment|// A valid resolved using typename decl points to exactly one type decl.
name|assert
argument_list|(
operator|++
name|Using
operator|->
name|shadow_begin
argument_list|()
operator|==
name|Using
operator|->
name|shadow_end
argument_list|()
argument_list|)
expr_stmt|;
name|Ty
operator|=
name|cast
operator|<
name|TypeDecl
operator|>
operator|(
operator|(
operator|*
name|Using
operator|->
name|shadow_begin
argument_list|()
operator|)
operator|->
name|getTargetDecl
argument_list|()
operator|)
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|isa
operator|<
name|UnresolvedUsingTypenameDecl
operator|>
operator|(
name|D
operator|)
operator|&&
literal|"UnresolvedUsingTypenameDecl transformed to non-using decl"
argument_list|)
expr_stmt|;
name|Ty
operator|=
name|cast
operator|<
name|UnresolvedUsingTypenameDecl
operator|>
operator|(
name|D
operator|)
expr_stmt|;
block|}
end_if

begin_return
return|return
name|SemaRef
operator|.
name|Context
operator|.
name|getTypeDeclType
argument_list|(
name|Ty
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildTypeOfExprType
argument_list|(
argument|ExprArg E
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|BuildTypeofExprType
argument_list|(
name|E
operator|.
name|takeAs
operator|<
name|Expr
operator|>
operator|(
operator|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildTypeOfType
argument_list|(
argument|QualType Underlying
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|Context
operator|.
name|getTypeOfType
argument_list|(
name|Underlying
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildDecltypeType
argument_list|(
argument|ExprArg E
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|BuildDecltypeType
argument_list|(
name|E
operator|.
name|takeAs
operator|<
name|Expr
operator|>
operator|(
operator|)
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|QualType
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildTemplateSpecializationType
argument_list|(
argument|TemplateName Template
argument_list|,
argument|SourceLocation TemplateNameLoc
argument_list|,
argument|const TemplateArgumentListInfo&TemplateArgs
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|CheckTemplateIdType
argument_list|(
name|Template
argument_list|,
name|TemplateNameLoc
argument_list|,
name|TemplateArgs
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|NestedNameSpecifier
operator|*
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildNestedNameSpecifier
argument_list|(
argument|NestedNameSpecifier *Prefix
argument_list|,
argument|SourceRange Range
argument_list|,
argument|IdentifierInfo&II
argument_list|,
argument|QualType ObjectType
argument_list|,
argument|NamedDecl *FirstQualifierInScope
argument_list|)
block|{
name|CXXScopeSpec
name|SS
block|;
comment|// FIXME: The source location information is all wrong.
name|SS
operator|.
name|setRange
argument_list|(
name|Range
argument_list|)
block|;
name|SS
operator|.
name|setScopeRep
argument_list|(
name|Prefix
argument_list|)
block|;
return|return
name|static_cast
operator|<
name|NestedNameSpecifier
operator|*
operator|>
operator|(
name|SemaRef
operator|.
name|BuildCXXNestedNameSpecifier
argument_list|(
literal|0
argument_list|,
name|SS
argument_list|,
name|Range
operator|.
name|getEnd
argument_list|()
argument_list|,
name|Range
operator|.
name|getEnd
argument_list|()
argument_list|,
name|II
argument_list|,
name|ObjectType
argument_list|,
name|FirstQualifierInScope
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|NestedNameSpecifier
operator|*
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildNestedNameSpecifier
argument_list|(
argument|NestedNameSpecifier *Prefix
argument_list|,
argument|SourceRange Range
argument_list|,
argument|NamespaceDecl *NS
argument_list|)
block|{
return|return
name|NestedNameSpecifier
operator|::
name|Create
argument_list|(
name|SemaRef
operator|.
name|Context
argument_list|,
name|Prefix
argument_list|,
name|NS
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|NestedNameSpecifier
operator|*
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildNestedNameSpecifier
argument_list|(
argument|NestedNameSpecifier *Prefix
argument_list|,
argument|SourceRange Range
argument_list|,
argument|bool TemplateKW
argument_list|,
argument|QualType T
argument_list|)
block|{
if|if
condition|(
name|T
operator|->
name|isDependentType
argument_list|()
operator|||
name|T
operator|->
name|isRecordType
argument_list|()
operator|||
operator|(
name|SemaRef
operator|.
name|getLangOptions
argument_list|()
operator|.
name|CPlusPlus0x
operator|&&
name|T
operator|->
name|isEnumeralType
argument_list|()
operator|)
condition|)
block|{
name|assert
argument_list|(
operator|!
name|T
operator|.
name|hasLocalQualifiers
argument_list|()
operator|&&
literal|"Can't get cv-qualifiers here"
argument_list|)
expr_stmt|;
return|return
name|NestedNameSpecifier
operator|::
name|Create
argument_list|(
name|SemaRef
operator|.
name|Context
argument_list|,
name|Prefix
argument_list|,
name|TemplateKW
argument_list|,
name|T
operator|.
name|getTypePtr
argument_list|()
argument_list|)
return|;
block|}
name|SemaRef
operator|.
name|Diag
argument_list|(
name|Range
operator|.
name|getBegin
argument_list|()
argument_list|,
name|diag
operator|::
name|err_nested_name_spec_non_tag
argument_list|)
operator|<<
name|T
expr_stmt|;
end_expr_stmt

begin_return
return|return
literal|0
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|TemplateName
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildTemplateName
argument_list|(
argument|NestedNameSpecifier *Qualifier
argument_list|,
argument|bool TemplateKW
argument_list|,
argument|TemplateDecl *Template
argument_list|)
block|{
return|return
name|SemaRef
operator|.
name|Context
operator|.
name|getQualifiedTemplateName
argument_list|(
name|Qualifier
argument_list|,
name|TemplateKW
argument_list|,
name|Template
argument_list|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|TemplateName
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildTemplateName
argument_list|(
argument|NestedNameSpecifier *Qualifier
argument_list|,
argument|const IdentifierInfo&II
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
name|CXXScopeSpec
name|SS
block|;
name|SS
operator|.
name|setRange
argument_list|(
name|SourceRange
argument_list|(
name|getDerived
argument_list|()
operator|.
name|getBaseLocation
argument_list|()
argument_list|)
argument_list|)
block|;
name|SS
operator|.
name|setScopeRep
argument_list|(
name|Qualifier
argument_list|)
block|;
name|UnqualifiedId
name|Name
block|;
name|Name
operator|.
name|setIdentifier
argument_list|(
operator|&
name|II
argument_list|,
comment|/*FIXME:*/
name|getDerived
argument_list|()
operator|.
name|getBaseLocation
argument_list|()
argument_list|)
block|;
return|return
name|getSema
argument_list|()
operator|.
name|ActOnDependentTemplateName
argument_list|(
comment|/*FIXME:*/
name|getDerived
argument_list|()
operator|.
name|getBaseLocation
argument_list|()
argument_list|,
name|SS
argument_list|,
name|Name
argument_list|,
name|ObjectType
operator|.
name|getAsOpaquePtr
argument_list|()
argument_list|,
comment|/*EnteringContext=*/
name|false
argument_list|)
operator|.
name|template
name|getAsVal
operator|<
name|TemplateName
operator|>
operator|(
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|TemplateName
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildTemplateName
argument_list|(
argument|NestedNameSpecifier *Qualifier
argument_list|,
argument|OverloadedOperatorKind Operator
argument_list|,
argument|QualType ObjectType
argument_list|)
block|{
name|CXXScopeSpec
name|SS
block|;
name|SS
operator|.
name|setRange
argument_list|(
name|SourceRange
argument_list|(
name|getDerived
argument_list|()
operator|.
name|getBaseLocation
argument_list|()
argument_list|)
argument_list|)
block|;
name|SS
operator|.
name|setScopeRep
argument_list|(
name|Qualifier
argument_list|)
block|;
name|UnqualifiedId
name|Name
block|;
name|SourceLocation
name|SymbolLocations
index|[
literal|3
index|]
block|;
comment|// FIXME: Bogus location information.
name|Name
operator|.
name|setOperatorFunctionId
argument_list|(
comment|/*FIXME:*/
name|getDerived
argument_list|()
operator|.
name|getBaseLocation
argument_list|()
argument_list|,
name|Operator
argument_list|,
name|SymbolLocations
argument_list|)
block|;
return|return
name|getSema
argument_list|()
operator|.
name|ActOnDependentTemplateName
argument_list|(
comment|/*FIXME:*/
name|getDerived
argument_list|()
operator|.
name|getBaseLocation
argument_list|()
argument_list|,
name|SS
argument_list|,
name|Name
argument_list|,
name|ObjectType
operator|.
name|getAsOpaquePtr
argument_list|()
argument_list|,
comment|/*EnteringContext=*/
name|false
argument_list|)
operator|.
name|template
name|getAsVal
operator|<
name|TemplateName
operator|>
operator|(
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildCXXOperatorCallExpr
argument_list|(
argument|OverloadedOperatorKind Op
argument_list|,
argument|SourceLocation OpLoc
argument_list|,
argument|ExprArg Callee
argument_list|,
argument|ExprArg First
argument_list|,
argument|ExprArg Second
argument_list|)
block|{
name|Expr
operator|*
name|FirstExpr
operator|=
operator|(
name|Expr
operator|*
operator|)
name|First
operator|.
name|get
argument_list|()
block|;
name|Expr
operator|*
name|SecondExpr
operator|=
operator|(
name|Expr
operator|*
operator|)
name|Second
operator|.
name|get
argument_list|()
block|;
name|Expr
operator|*
name|CalleeExpr
operator|=
operator|(
operator|(
name|Expr
operator|*
operator|)
name|Callee
operator|.
name|get
argument_list|()
operator|)
operator|->
name|IgnoreParenCasts
argument_list|()
block|;
name|bool
name|isPostIncDec
operator|=
name|SecondExpr
operator|&&
operator|(
name|Op
operator|==
name|OO_PlusPlus
operator|||
name|Op
operator|==
name|OO_MinusMinus
operator|)
block|;
comment|// Determine whether this should be a builtin operation.
if|if
condition|(
name|Op
operator|==
name|OO_Subscript
condition|)
block|{
if|if
condition|(
operator|!
name|FirstExpr
operator|->
name|getType
argument_list|()
operator|->
name|isOverloadableType
argument_list|()
operator|&&
operator|!
name|SecondExpr
operator|->
name|getType
argument_list|()
operator|->
name|isOverloadableType
argument_list|()
condition|)
return|return
name|getSema
argument_list|()
operator|.
name|CreateBuiltinArraySubscriptExpr
argument_list|(
name|move
argument_list|(
name|First
argument_list|)
argument_list|,
name|CalleeExpr
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|move
argument_list|(
name|Second
argument_list|)
argument_list|,
name|OpLoc
argument_list|)
return|;
block|}
end_expr_stmt

begin_elseif
elseif|else
if|if
condition|(
name|Op
operator|==
name|OO_Arrow
condition|)
block|{
comment|// -> is never a builtin operation.
return|return
name|SemaRef
operator|.
name|BuildOverloadedArrowExpr
argument_list|(
literal|0
argument_list|,
name|move
argument_list|(
name|First
argument_list|)
argument_list|,
name|OpLoc
argument_list|)
return|;
block|}
end_elseif

begin_elseif
elseif|else
if|if
condition|(
name|SecondExpr
operator|==
literal|0
operator|||
name|isPostIncDec
condition|)
block|{
if|if
condition|(
operator|!
name|FirstExpr
operator|->
name|getType
argument_list|()
operator|->
name|isOverloadableType
argument_list|()
condition|)
block|{
comment|// The argument is not of overloadable type, so try to create a
comment|// built-in unary operation.
name|UnaryOperator
operator|::
name|Opcode
name|Opc
operator|=
name|UnaryOperator
operator|::
name|getOverloadedOpcode
argument_list|(
name|Op
argument_list|,
name|isPostIncDec
argument_list|)
expr_stmt|;
return|return
name|getSema
argument_list|()
operator|.
name|CreateBuiltinUnaryOp
argument_list|(
name|OpLoc
argument_list|,
name|Opc
argument_list|,
name|move
argument_list|(
name|First
argument_list|)
argument_list|)
return|;
block|}
block|}
end_elseif

begin_else
else|else
block|{
if|if
condition|(
operator|!
name|FirstExpr
operator|->
name|getType
argument_list|()
operator|->
name|isOverloadableType
argument_list|()
operator|&&
operator|!
name|SecondExpr
operator|->
name|getType
argument_list|()
operator|->
name|isOverloadableType
argument_list|()
condition|)
block|{
comment|// Neither of the arguments is an overloadable type, so try to
comment|// create a built-in binary operation.
name|BinaryOperator
operator|::
name|Opcode
name|Opc
operator|=
name|BinaryOperator
operator|::
name|getOverloadedOpcode
argument_list|(
name|Op
argument_list|)
expr_stmt|;
name|OwningExprResult
name|Result
init|=
name|SemaRef
operator|.
name|CreateBuiltinBinOp
argument_list|(
name|OpLoc
argument_list|,
name|Opc
argument_list|,
name|FirstExpr
argument_list|,
name|SecondExpr
argument_list|)
decl_stmt|;
if|if
condition|(
name|Result
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
name|First
operator|.
name|release
argument_list|()
expr_stmt|;
name|Second
operator|.
name|release
argument_list|()
expr_stmt|;
return|return
name|move
argument_list|(
name|Result
argument_list|)
return|;
block|}
block|}
end_else

begin_comment
comment|// Compute the transformed set of functions (and function templates) to be
end_comment

begin_comment
comment|// used during overload resolution.
end_comment

begin_expr_stmt
name|UnresolvedSet
operator|<
literal|16
operator|>
name|Functions
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|UnresolvedLookupExpr
modifier|*
name|ULE
init|=
name|dyn_cast
operator|<
name|UnresolvedLookupExpr
operator|>
operator|(
name|CalleeExpr
operator|)
condition|)
block|{
name|assert
argument_list|(
name|ULE
operator|->
name|requiresADL
argument_list|()
argument_list|)
expr_stmt|;
comment|// FIXME: Do we have to check
comment|// IsAcceptableNonMemberOperatorCandidate for each of these?
name|Functions
operator|.
name|append
argument_list|(
name|ULE
operator|->
name|decls_begin
argument_list|()
argument_list|,
name|ULE
operator|->
name|decls_end
argument_list|()
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Functions
operator|.
name|addDecl
argument_list|(
name|cast
operator|<
name|DeclRefExpr
operator|>
operator|(
name|CalleeExpr
operator|)
operator|->
name|getDecl
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|// Add any functions found via argument-dependent lookup.
end_comment

begin_decl_stmt
name|Expr
modifier|*
name|Args
index|[
literal|2
index|]
init|=
block|{
name|FirstExpr
block|,
name|SecondExpr
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|NumArgs
init|=
literal|1
operator|+
operator|(
name|SecondExpr
operator|!=
literal|0
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Create the overloaded operator invocation for unary operators.
end_comment

begin_if
if|if
condition|(
name|NumArgs
operator|==
literal|1
operator|||
name|isPostIncDec
condition|)
block|{
name|UnaryOperator
operator|::
name|Opcode
name|Opc
operator|=
name|UnaryOperator
operator|::
name|getOverloadedOpcode
argument_list|(
name|Op
argument_list|,
name|isPostIncDec
argument_list|)
expr_stmt|;
return|return
name|SemaRef
operator|.
name|CreateOverloadedUnaryOp
argument_list|(
name|OpLoc
argument_list|,
name|Opc
argument_list|,
name|Functions
argument_list|,
name|move
argument_list|(
name|First
argument_list|)
argument_list|)
return|;
block|}
end_if

begin_if
if|if
condition|(
name|Op
operator|==
name|OO_Subscript
condition|)
return|return
name|SemaRef
operator|.
name|CreateOverloadedArraySubscriptExpr
argument_list|(
name|CalleeExpr
operator|->
name|getLocStart
argument_list|()
argument_list|,
name|OpLoc
argument_list|,
name|move
argument_list|(
name|First
argument_list|)
argument_list|,
name|move
argument_list|(
name|Second
argument_list|)
argument_list|)
return|;
end_if

begin_comment
comment|// Create the overloaded operator invocation for binary operators.
end_comment

begin_expr_stmt
name|BinaryOperator
operator|::
name|Opcode
name|Opc
operator|=
name|BinaryOperator
operator|::
name|getOverloadedOpcode
argument_list|(
name|Op
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|OwningExprResult
name|Result
init|=
name|SemaRef
operator|.
name|CreateOverloadedBinOp
argument_list|(
name|OpLoc
argument_list|,
name|Opc
argument_list|,
name|Functions
argument_list|,
name|Args
index|[
literal|0
index|]
argument_list|,
name|Args
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|Result
operator|.
name|isInvalid
argument_list|()
condition|)
return|return
name|SemaRef
operator|.
name|ExprError
argument_list|()
return|;
end_if

begin_expr_stmt
name|First
operator|.
name|release
argument_list|()
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Second
operator|.
name|release
argument_list|()
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|move
argument_list|(
name|Result
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|Derived
operator|>
name|Sema
operator|::
name|OwningExprResult
name|TreeTransform
operator|<
name|Derived
operator|>
operator|::
name|RebuildCXXPseudoDestructorExpr
argument_list|(
argument|ExprArg Base
argument_list|,
argument|SourceLocation OperatorLoc
argument_list|,
argument|bool isArrow
argument_list|,
argument|NestedNameSpecifier *Qualifier
argument_list|,
argument|SourceRange QualifierRange
argument_list|,
argument|TypeSourceInfo *ScopeType
argument_list|,
argument|SourceLocation CCLoc
argument_list|,
argument|SourceLocation TildeLoc
argument_list|,
argument|PseudoDestructorTypeStorage Destroyed
argument_list|)
block|{
name|CXXScopeSpec
name|SS
block|;
if|if
condition|(
name|Qualifier
condition|)
block|{
name|SS
operator|.
name|setRange
argument_list|(
name|QualifierRange
argument_list|)
expr_stmt|;
name|SS
operator|.
name|setScopeRep
argument_list|(
name|Qualifier
argument_list|)
expr_stmt|;
block|}
name|Expr
operator|*
name|BaseE
operator|=
operator|(
name|Expr
operator|*
operator|)
name|Base
operator|.
name|get
argument_list|()
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|QualType
name|BaseType
init|=
name|BaseE
operator|->
name|getType
argument_list|()
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|BaseE
operator|->
name|isTypeDependent
argument_list|()
operator|||
name|Destroyed
operator|.
name|getIdentifier
argument_list|()
operator|||
operator|(
operator|!
name|isArrow
operator|&&
operator|!
name|BaseType
operator|->
name|getAs
operator|<
name|RecordType
operator|>
operator|(
operator|)
operator|)
operator|||
operator|(
name|isArrow
operator|&&
name|BaseType
operator|->
name|getAs
operator|<
name|PointerType
operator|>
operator|(
operator|)
operator|&&
operator|!
name|BaseType
operator|->
name|getAs
operator|<
name|PointerType
operator|>
operator|(
operator|)
operator|->
name|getPointeeType
argument_list|()
operator|->
name|template
name|getAs
operator|<
name|RecordType
operator|>
operator|(
operator|)
operator|)
condition|)
block|{
comment|// This pseudo-destructor expression is still a pseudo-destructor.
return|return
name|SemaRef
operator|.
name|BuildPseudoDestructorExpr
argument_list|(
name|move
argument_list|(
name|Base
argument_list|)
argument_list|,
name|OperatorLoc
argument_list|,
name|isArrow
condition|?
name|tok
operator|::
name|arrow
else|:
name|tok
operator|::
name|period
argument_list|,
name|SS
argument_list|,
name|ScopeType
argument_list|,
name|CCLoc
argument_list|,
name|TildeLoc
argument_list|,
name|Destroyed
argument_list|,
comment|/*FIXME?*/
name|true
argument_list|)
return|;
block|}
end_if

begin_decl_stmt
name|TypeSourceInfo
modifier|*
name|DestroyedType
init|=
name|Destroyed
operator|.
name|getTypeSourceInfo
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|DeclarationName
name|Name
init|=
name|SemaRef
operator|.
name|Context
operator|.
name|DeclarationNames
operator|.
name|getCXXDestructorName
argument_list|(
name|SemaRef
operator|.
name|Context
operator|.
name|getCanonicalType
argument_list|(
name|DestroyedType
operator|->
name|getType
argument_list|()
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|// FIXME: the ScopeType should be tacked onto SS.
end_comment

begin_return
return|return
name|getSema
argument_list|()
operator|.
name|BuildMemberReferenceExpr
argument_list|(
name|move
argument_list|(
name|Base
argument_list|)
argument_list|,
name|BaseType
argument_list|,
name|OperatorLoc
argument_list|,
name|isArrow
argument_list|,
name|SS
argument_list|,
comment|/*FIXME: FirstQualifier*/
literal|0
argument_list|,
name|Name
argument_list|,
name|Destroyed
operator|.
name|getLocation
argument_list|()
argument_list|,
comment|/*TemplateArgs*/
literal|0
argument_list|)
return|;
end_return

begin_comment
unit|}  }
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLVM_CLANG_SEMA_TREETRANSFORM_H
end_comment

end_unit

