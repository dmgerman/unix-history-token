begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * tparm.c  *  * By Ross Ridge  * Public Domain  * 92/02/01 07:30:36  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|<term.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_SCCS_IDS
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|SCCSid
index|[]
init|=
literal|"@(#) mytinfo tparm.c 3.2 92/02/01 public domain, By Ross Ridge"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAX_PUSHED
end_ifndef

begin_define
define|#
directive|define
name|MAX_PUSHED
value|32
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ARG
value|1
end_define

begin_define
define|#
directive|define
name|NUM
value|2
end_define

begin_define
define|#
directive|define
name|INTEGER
value|1
end_define

begin_define
define|#
directive|define
name|STRING
value|2
end_define

begin_typedef
typedef|typedef
struct|struct
name|stack_str
block|{
name|int
name|type
decl_stmt|;
name|int
name|argnum
decl_stmt|;
name|int
name|value
decl_stmt|;
block|}
name|stack
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|stack
name|S
index|[
name|MAX_PUSHED
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|stack
name|vars
index|[
literal|'z'
operator|-
literal|'a'
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pos
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
struct|struct
name|arg_str
block|{
name|int
name|type
decl_stmt|;
name|int
name|integer
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|}
name|arg_list
index|[
literal|10
index|]
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|argcnt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|va_list
name|tparm_args
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|pusharg
parameter_list|(
name|arg
parameter_list|)
name|int
name|arg
decl_stmt|;
block|{
if|if
condition|(
name|pos
operator|==
name|MAX_PUSHED
condition|)
return|return
literal|1
return|;
name|S
index|[
name|pos
index|]
operator|.
name|type
operator|=
name|ARG
expr_stmt|;
name|S
index|[
name|pos
operator|++
index|]
operator|.
name|argnum
operator|=
name|arg
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pushnum
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
block|{
if|if
condition|(
name|pos
operator|==
name|MAX_PUSHED
condition|)
return|return
literal|1
return|;
name|S
index|[
name|pos
index|]
operator|.
name|type
operator|=
name|NUM
expr_stmt|;
name|S
index|[
name|pos
operator|++
index|]
operator|.
name|value
operator|=
name|num
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* VARARGS2 */
end_comment

begin_function
specifier|static
name|int
name|getarg
parameter_list|(
name|argnum
parameter_list|,
name|type
parameter_list|,
name|p
parameter_list|)
name|int
name|argnum
decl_stmt|,
name|type
decl_stmt|;
name|anyptr
name|p
decl_stmt|;
block|{
while|while
condition|(
name|argcnt
operator|<
name|argnum
condition|)
block|{
name|arg_list
index|[
name|argcnt
index|]
operator|.
name|type
operator|=
name|INTEGER
expr_stmt|;
name|arg_list
index|[
name|argcnt
operator|++
index|]
operator|.
name|integer
operator|=
operator|(
name|int
operator|)
name|va_arg
argument_list|(
name|tparm_args
argument_list|,
name|int
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argcnt
operator|>
name|argnum
condition|)
block|{
if|if
condition|(
name|arg_list
index|[
name|argnum
index|]
operator|.
name|type
operator|!=
name|type
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|type
operator|==
name|STRING
condition|)
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
name|p
operator|=
name|arg_list
index|[
name|argnum
index|]
operator|.
name|string
expr_stmt|;
else|else
operator|*
operator|(
name|int
operator|*
operator|)
name|p
operator|=
name|arg_list
index|[
name|argnum
index|]
operator|.
name|integer
expr_stmt|;
block|}
else|else
block|{
name|arg_list
index|[
name|argcnt
index|]
operator|.
name|type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|STRING
condition|)
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
name|p
operator|=
name|arg_list
index|[
name|argcnt
operator|++
index|]
operator|.
name|string
operator|=
operator|(
name|char
operator|*
operator|)
name|va_arg
argument_list|(
name|tparm_args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
else|else
operator|*
operator|(
name|int
operator|*
operator|)
name|p
operator|=
name|arg_list
index|[
name|argcnt
operator|++
index|]
operator|.
name|integer
operator|=
operator|(
name|int
operator|)
name|va_arg
argument_list|(
name|tparm_args
argument_list|,
name|int
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|popstring
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
modifier|*
name|str
decl_stmt|;
block|{
if|if
condition|(
name|pos
operator|--
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|S
index|[
name|pos
index|]
operator|.
name|type
operator|!=
name|ARG
condition|)
return|return
literal|1
return|;
return|return
operator|(
name|getarg
argument_list|(
name|S
index|[
name|pos
index|]
operator|.
name|argnum
argument_list|,
name|STRING
argument_list|,
operator|(
name|anyptr
operator|)
name|str
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|popnum
parameter_list|(
name|num
parameter_list|)
name|int
modifier|*
name|num
decl_stmt|;
block|{
if|if
condition|(
name|pos
operator|--
operator|==
literal|0
condition|)
return|return
literal|1
return|;
switch|switch
condition|(
name|S
index|[
name|pos
index|]
operator|.
name|type
condition|)
block|{
case|case
name|ARG
case|:
return|return
operator|(
name|getarg
argument_list|(
name|S
index|[
name|pos
index|]
operator|.
name|argnum
argument_list|,
name|INTEGER
argument_list|,
operator|(
name|anyptr
operator|)
name|num
argument_list|)
operator|)
return|;
case|case
name|NUM
case|:
operator|*
name|num
operator|=
name|S
index|[
name|pos
index|]
operator|.
name|value
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cvtchar
parameter_list|(
name|sp
parameter_list|,
name|c
parameter_list|)
specifier|register
name|char
modifier|*
name|sp
decl_stmt|,
decl|*
name|c
decl_stmt|;
end_function

begin_block
block|{
switch|switch
condition|(
operator|*
name|sp
condition|)
block|{
case|case
literal|'\\'
case|:
switch|switch
condition|(
operator|*
operator|++
name|sp
condition|)
block|{
case|case
literal|'\''
case|:
case|case
literal|'$'
case|:
case|case
literal|'\\'
case|:
case|case
literal|'%'
case|:
operator|*
name|c
operator|=
operator|*
name|sp
expr_stmt|;
return|return
literal|2
return|;
case|case
literal|'\0'
case|:
operator|*
name|c
operator|=
literal|'\\'
expr_stmt|;
return|return
literal|1
return|;
case|case
literal|'0'
case|:
if|if
condition|(
name|sp
index|[
literal|1
index|]
operator|==
literal|'0'
operator|&&
name|sp
index|[
literal|2
index|]
operator|==
literal|'0'
condition|)
block|{
operator|*
name|c
operator|=
literal|'\0'
expr_stmt|;
return|return
literal|4
return|;
block|}
operator|*
name|c
operator|=
literal|'\200'
expr_stmt|;
comment|/* '\0' ???? */
return|return
literal|2
return|;
default|default:
operator|*
name|c
operator|=
operator|*
name|sp
expr_stmt|;
return|return
literal|2
return|;
block|}
default|default:
operator|*
name|c
operator|=
operator|*
name|sp
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_block

begin_decl_stmt
specifier|static
name|int
name|termcap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sigh... this has got to be the ugliest code I've ever written.    Trying to handle everything has its cost, I guess.     It actually isn't to hard to figure out if a given % code is supposed    to be interpeted with its termcap or terminfo meaning since almost    all terminfo codes are invalid unless something has been pushed on    the stack and termcap strings will never push things on the stack    (%p isn't used by termcap). So where we have a choice we make the    decision by wether or not somthing has been pushed on the stack.    The static variable termcap keeps track of this; it starts out set    to 1 and is incremented as each argument processed by a termcap % code,    however if something is pushed on the stack it's set to 0 and the    rest of the % codes are interpeted as terminfo % codes. Another way    of putting it is that if termcap equals one we haven't decided either    way yet, if it equals zero we're looking for terminfo codes, and if    its greater than 1 we're looking for termcap codes.     Terminfo % codes:  	%%	output a '%' 	%[[:][-+# ][width][.precision]][doxXs] 		output pop according to the printf format 	%c	output pop as a char 	%'c'	push character constant c. 	%{n}	push decimal constant n. 	%p[1-9] push paramter [1-9] 	%g[a-z] push variable [a-z] 	%P[a-z] put pop in variable [a-z] 	%l	push the length of pop (a string) 	%+	add pop to pop and push the result 	%-	subtract pop from pop and push the result 	%*	multiply pop and pop and push the result 	%&	bitwise and pop and pop and push the result 	%|	bitwise or pop and pop and push the result 	%^	bitwise xor pop and pop and push the result 	%~	push the bitwise not of pop 	%=	compare if pop and pop are equal and push the result 	%>	compare if pop is less than pop and push the result 	%<	compare if pop is greater than pop and push the result 	%A	logical and pop and pop and push the result 	%O	logical or pop and pop and push the result 	%!	push the logical not of pop 	%? condition %t if_true [%e if_false] %; 		if condtion evaulates as true then evaluate if_true, 		else evaluate if_false. elseif's can be done: %? cond %t true [%e cond2 %t true2] ... [%e condN %t trueN] [%e false] %; 	%i	add one to parameters 1 and 2. (ANSI)    Termcap Codes:  	%%	output a % 	%.	output parameter as a character 	%d	output parameter as a decimal number 	%2	output parameter in printf format %02d 	%3	output parameter in printf format %03d 	%+x	add the character x to parameter and output it as a character (UW)	%-x	subtract parameter FROM the character x and output it as a char (UW)	%ax	add the character x to parameter (GNU)	%a[+*-/=][cp]x 		GNU arithmetic. (UW)	%sx	subtract parameter FROM the character x 	%>xy	if parameter> character x then add character y to parameter 	%B	convert to BCD (parameter = (parameter/10)*16 + parameter%16) 	%D	Delta Data encode (parameter = parameter - 2*(paramter%16)) 	%i	increment the first two parameters by one 	%n	xor the first two parameters by 0140 (GNU)	%m	xor the first two parameters by 0177 	%r	swap the first two parameters (GNU)	%b	backup to previous parameter (GNU)	%f	skip this parameter    Note the two definitions of %a, the GNU defintion is used if the characters   after the 'a' are valid, otherwise the UW definition is used.    (GNU) used by GNU Emacs termcap libraries   (UW) used by the University of Waterloo (MFCF) termcap libraries  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|lint
end_ifdef

begin_comment
comment|/* VARARGS1 */
end_comment

begin_function
name|char
modifier|*
name|tparm
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
else|#
directive|else
comment|/* lint */
ifdef|#
directive|ifdef
name|USE_STDARG
ifdef|#
directive|ifdef
name|USE_PROTOTYPES
name|char
modifier|*
name|tparm
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
modifier|...
parameter_list|)
block|{
else|#
directive|else
comment|/* USE_PROTOTYPES */
name|char
modifier|*
name|tparm
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
endif|#
directive|endif
comment|/* USE_PROTOTYPES */
else|#
directive|else
comment|/* USE_STDARG */
name|char
modifier|*
name|tparm
parameter_list|(
name|va_alist
parameter_list|)
function|va_dcl
block|{
name|char
modifier|*
name|str
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
specifier|static
name|char
name|OOPS
index|[]
init|=
literal|"OOPS"
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|MAX_LINE
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|dp
decl_stmt|;
specifier|register
name|char
modifier|*
name|fmt
decl_stmt|;
specifier|const
name|char
modifier|*
name|sp
decl_stmt|;
name|char
name|conv_char
decl_stmt|;
name|char
name|scan_for
decl_stmt|;
name|int
name|scan_depth
init|=
literal|0
decl_stmt|,
name|if_depth
decl_stmt|;
specifier|static
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|static
name|char
modifier|*
name|s
decl_stmt|,
name|c
decl_stmt|;
name|char
name|fmt_buf
index|[
name|MAX_LINE
index|]
decl_stmt|;
name|char
name|sbuf
index|[
name|MAX_LINE
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_STDARG
name|va_start
argument_list|(
name|tparm_args
argument_list|,
name|str
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|tparm_args
argument_list|)
expr_stmt|;
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|va_arg
argument_list|(
name|tparm_args
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sp
operator|=
name|str
expr_stmt|;
name|dp
operator|=
name|buf
expr_stmt|;
name|scan_for
operator|=
literal|0
expr_stmt|;
name|if_depth
operator|=
literal|0
expr_stmt|;
name|argcnt
operator|=
literal|0
expr_stmt|;
name|pos
operator|=
literal|0
expr_stmt|;
name|termcap
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|sp
operator|!=
literal|'\0'
condition|)
block|{
switch|switch
condition|(
operator|*
name|sp
condition|)
block|{
case|case
literal|'\\'
case|:
if|if
condition|(
name|scan_for
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|sp
operator|!=
literal|'\0'
condition|)
name|sp
operator|++
expr_stmt|;
break|break;
block|}
operator|*
name|dp
operator|++
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|sp
operator|!=
literal|'\0'
condition|)
operator|*
name|dp
operator|++
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
name|sp
operator|++
expr_stmt|;
if|if
condition|(
name|scan_for
condition|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
name|scan_for
operator|&&
name|if_depth
operator|==
name|scan_depth
condition|)
block|{
if|if
condition|(
name|scan_for
operator|==
literal|';'
condition|)
name|if_depth
operator|--
expr_stmt|;
name|scan_for
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|sp
operator|==
literal|'?'
condition|)
name|if_depth
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|sp
operator|==
literal|';'
condition|)
block|{
if|if
condition|(
name|if_depth
operator|==
literal|0
condition|)
return|return
name|OOPS
return|;
else|else
name|if_depth
operator|--
expr_stmt|;
block|}
name|sp
operator|++
expr_stmt|;
break|break;
block|}
name|fmt
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
operator|*
name|sp
condition|)
block|{
case|case
literal|'%'
case|:
operator|*
name|dp
operator|++
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
if|if
condition|(
operator|!
name|termcap
condition|)
block|{
if|if
condition|(
name|popnum
argument_list|(
operator|&
name|j
argument_list|)
operator|||
name|popnum
argument_list|(
operator|&
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|i
operator|+=
name|j
expr_stmt|;
if|if
condition|(
name|pushnum
argument_list|(
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|sp
operator|++
expr_stmt|;
break|break;
block|}
empty_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|'C'
case|:
if|if
condition|(
operator|*
name|sp
operator|==
literal|'C'
condition|)
block|{
if|if
condition|(
name|getarg
argument_list|(
name|termcap
operator|-
literal|1
argument_list|,
name|INTEGER
argument_list|,
operator|&
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
if|if
condition|(
name|i
operator|>=
literal|96
condition|)
block|{
name|i
operator|/=
literal|96
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|'$'
condition|)
operator|*
name|dp
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
name|i
expr_stmt|;
block|}
block|}
name|fmt
operator|=
literal|"%c"
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|'a'
case|:
if|if
condition|(
operator|!
name|termcap
condition|)
return|return
name|OOPS
return|;
if|if
condition|(
name|getarg
argument_list|(
name|termcap
operator|-
literal|1
argument_list|,
name|INTEGER
argument_list|,
operator|(
name|anyptr
operator|)
operator|&
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
if|if
condition|(
operator|*
operator|++
name|sp
operator|==
literal|'\0'
condition|)
return|return
name|OOPS
return|;
if|if
condition|(
operator|(
name|sp
index|[
literal|1
index|]
operator|==
literal|'p'
operator|||
name|sp
index|[
literal|1
index|]
operator|==
literal|'c'
operator|)
operator|&&
name|sp
index|[
literal|2
index|]
operator|!=
literal|'\0'
operator|&&
name|fmt
operator|==
name|NULL
condition|)
block|{
comment|/* GNU arithmetic parameter, what they 					   really need is terminfo.	      */
name|int
name|val
decl_stmt|,
name|lc
decl_stmt|;
if|if
condition|(
name|sp
index|[
literal|1
index|]
operator|==
literal|'p'
operator|&&
name|getarg
argument_list|(
name|termcap
operator|-
literal|1
operator|+
name|sp
index|[
literal|2
index|]
operator|-
literal|'@'
argument_list|,
name|INTEGER
argument_list|,
operator|(
name|anyptr
operator|)
operator|&
name|val
argument_list|)
condition|)
return|return
name|OOPS
return|;
if|if
condition|(
name|sp
index|[
literal|1
index|]
operator|==
literal|'c'
condition|)
block|{
name|lc
operator|=
name|cvtchar
argument_list|(
name|sp
operator|+
literal|2
argument_list|,
operator|&
name|c
argument_list|)
operator|+
literal|2
expr_stmt|;
comment|/* Mask out 8th bit so \200 can be 					   used for \0 as per GNU doc's    */
name|val
operator|=
name|c
operator|&
literal|0177
expr_stmt|;
block|}
else|else
name|lc
operator|=
literal|2
expr_stmt|;
switch|switch
condition|(
name|sp
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'='
case|:
break|break;
case|case
literal|'+'
case|:
name|val
operator|=
name|i
operator|+
name|val
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|val
operator|=
name|i
operator|-
name|val
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|val
operator|=
name|i
operator|*
name|val
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
name|val
operator|=
name|i
operator|/
name|val
expr_stmt|;
break|break;
default|default:
comment|/* Not really GNU's %a after all... */
name|lc
operator|=
name|cvtchar
argument_list|(
name|sp
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
name|val
operator|=
name|c
operator|+
name|i
expr_stmt|;
break|break;
block|}
name|arg_list
index|[
name|termcap
operator|-
literal|1
index|]
operator|.
name|integer
operator|=
name|val
expr_stmt|;
name|sp
operator|+=
name|lc
expr_stmt|;
break|break;
block|}
name|sp
operator|+=
name|cvtchar
argument_list|(
name|sp
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
name|arg_list
index|[
name|termcap
operator|-
literal|1
index|]
operator|.
name|integer
operator|=
name|c
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|NULL
condition|)
break|break;
name|sp
operator|--
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|'-'
case|:
if|if
condition|(
operator|!
name|termcap
condition|)
block|{
if|if
condition|(
name|popnum
argument_list|(
operator|&
name|j
argument_list|)
operator|||
name|popnum
argument_list|(
operator|&
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|i
operator|-=
name|j
expr_stmt|;
if|if
condition|(
name|pushnum
argument_list|(
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|sp
operator|++
expr_stmt|;
break|break;
block|}
name|fmt
operator|=
literal|"%c"
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|'s'
case|:
if|if
condition|(
name|termcap
operator|&&
operator|(
name|fmt
operator|==
name|NULL
operator|||
operator|*
name|sp
operator|==
literal|'-'
operator|)
condition|)
block|{
if|if
condition|(
name|getarg
argument_list|(
name|termcap
operator|-
literal|1
argument_list|,
name|INTEGER
argument_list|,
operator|&
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
if|if
condition|(
operator|*
operator|++
name|sp
operator|==
literal|'\0'
condition|)
return|return
name|OOPS
return|;
name|sp
operator|+=
name|cvtchar
argument_list|(
name|sp
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
name|arg_list
index|[
name|termcap
operator|-
literal|1
index|]
operator|.
name|integer
operator|=
name|c
operator|-
name|i
expr_stmt|;
if|if
condition|(
name|fmt
operator|==
name|NULL
condition|)
break|break;
name|sp
operator|--
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|termcap
condition|)
return|return
name|OOPS
return|;
empty_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|'.'
case|:
if|if
condition|(
name|termcap
operator|&&
name|fmt
operator|==
name|NULL
condition|)
name|fmt
operator|=
literal|"%c"
expr_stmt|;
empty_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|'d'
case|:
if|if
condition|(
name|termcap
operator|&&
name|fmt
operator|==
name|NULL
condition|)
name|fmt
operator|=
literal|"%d"
expr_stmt|;
empty_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|'2'
case|:
if|if
condition|(
name|termcap
operator|&&
name|fmt
operator|==
name|NULL
condition|)
name|fmt
operator|=
literal|"%02d"
expr_stmt|;
empty_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|'3'
case|:
if|if
condition|(
name|termcap
operator|&&
name|fmt
operator|==
name|NULL
condition|)
name|fmt
operator|=
literal|"%03d"
expr_stmt|;
empty_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|':'
case|:
case|case
literal|' '
case|:
case|case
literal|'#'
case|:
case|case
literal|'u'
case|:
case|case
literal|'x'
case|:
case|case
literal|'X'
case|:
case|case
literal|'o'
case|:
case|case
literal|'c'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|fmt
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|termcap
condition|)
return|return
name|OOPS
return|;
if|if
condition|(
operator|*
name|sp
operator|==
literal|':'
condition|)
name|sp
operator|++
expr_stmt|;
name|fmt
operator|=
name|fmt_buf
expr_stmt|;
operator|*
name|fmt
operator|++
operator|=
literal|'%'
expr_stmt|;
while|while
condition|(
operator|*
name|sp
operator|!=
literal|'s'
operator|&&
operator|*
name|sp
operator|!=
literal|'x'
operator|&&
operator|*
name|sp
operator|!=
literal|'X'
operator|&&
operator|*
name|sp
operator|!=
literal|'d'
operator|&&
operator|*
name|sp
operator|!=
literal|'o'
operator|&&
operator|*
name|sp
operator|!=
literal|'c'
operator|&&
operator|*
name|sp
operator|!=
literal|'u'
condition|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
literal|'\0'
condition|)
return|return
name|OOPS
return|;
operator|*
name|fmt
operator|++
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
block|}
operator|*
name|fmt
operator|++
operator|=
operator|*
name|sp
expr_stmt|;
operator|*
name|fmt
operator|=
literal|'\0'
expr_stmt|;
name|fmt
operator|=
name|fmt_buf
expr_stmt|;
block|}
name|conv_char
operator|=
name|fmt
index|[
name|strlen
argument_list|(
name|fmt
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|conv_char
operator|==
literal|'s'
condition|)
block|{
if|if
condition|(
name|popstring
argument_list|(
operator|&
name|s
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|sprintf
argument_list|(
name|sbuf
argument_list|,
name|fmt
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|termcap
condition|)
block|{
if|if
condition|(
name|getarg
argument_list|(
name|termcap
operator|++
operator|-
literal|1
argument_list|,
name|INTEGER
argument_list|,
operator|&
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
block|}
elseif|else
if|if
condition|(
name|popnum
argument_list|(
operator|&
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|conv_char
operator|==
literal|'c'
condition|)
name|strcpy
argument_list|(
name|sbuf
argument_list|,
literal|"\000"
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|sbuf
argument_list|,
name|fmt
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|sp
operator|++
expr_stmt|;
name|fmt
operator|=
name|sbuf
expr_stmt|;
while|while
condition|(
operator|*
name|fmt
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'$'
operator|||
operator|*
name|fmt
operator|==
literal|'^'
operator|||
operator|*
name|fmt
operator|==
literal|'\\'
condition|)
operator|*
name|dp
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|dp
operator|++
operator|=
operator|*
name|fmt
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
operator|!
name|termcap
operator|||
name|getarg
argument_list|(
literal|1
argument_list|,
name|INTEGER
argument_list|,
operator|&
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|arg_list
index|[
literal|1
index|]
operator|.
name|integer
operator|=
name|arg_list
index|[
literal|0
index|]
operator|.
name|integer
expr_stmt|;
name|arg_list
index|[
literal|0
index|]
operator|.
name|integer
operator|=
name|i
expr_stmt|;
name|sp
operator|++
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|getarg
argument_list|(
literal|1
argument_list|,
name|INTEGER
argument_list|,
operator|&
name|i
argument_list|)
operator|||
name|arg_list
index|[
literal|0
index|]
operator|.
name|type
operator|!=
name|INTEGER
condition|)
return|return
name|OOPS
return|;
name|arg_list
index|[
literal|1
index|]
operator|.
name|integer
operator|++
expr_stmt|;
name|arg_list
index|[
literal|0
index|]
operator|.
name|integer
operator|++
expr_stmt|;
name|sp
operator|++
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
operator|!
name|termcap
operator|||
name|getarg
argument_list|(
literal|1
argument_list|,
name|INTEGER
argument_list|,
operator|&
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|arg_list
index|[
literal|0
index|]
operator|.
name|integer
operator|^=
literal|0140
expr_stmt|;
name|arg_list
index|[
literal|1
index|]
operator|.
name|integer
operator|^=
literal|0140
expr_stmt|;
name|sp
operator|++
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
operator|!
name|termcap
condition|)
block|{
if|if
condition|(
name|popnum
argument_list|(
operator|&
name|j
argument_list|)
operator|||
name|popnum
argument_list|(
operator|&
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|i
operator|=
operator|(
name|i
operator|>
name|j
operator|)
expr_stmt|;
if|if
condition|(
name|pushnum
argument_list|(
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|sp
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|getarg
argument_list|(
name|termcap
operator|-
literal|1
argument_list|,
name|INTEGER
argument_list|,
operator|&
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|sp
operator|+=
name|cvtchar
argument_list|(
name|sp
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|c
condition|)
block|{
name|sp
operator|+=
name|cvtchar
argument_list|(
name|sp
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
name|arg_list
index|[
name|termcap
operator|-
literal|1
index|]
operator|.
name|integer
operator|+=
name|c
expr_stmt|;
block|}
else|else
name|sp
operator|+=
name|cvtchar
argument_list|(
name|sp
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
name|sp
operator|++
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
if|if
condition|(
operator|!
name|termcap
operator|||
name|getarg
argument_list|(
name|termcap
operator|-
literal|1
argument_list|,
name|INTEGER
argument_list|,
operator|&
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|arg_list
index|[
name|termcap
operator|-
literal|1
index|]
operator|.
name|integer
operator|=
literal|16
operator|*
operator|(
name|i
operator|/
literal|10
operator|)
operator|+
name|i
operator|%
literal|10
expr_stmt|;
name|sp
operator|++
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
operator|!
name|termcap
operator|||
name|getarg
argument_list|(
name|termcap
operator|-
literal|1
argument_list|,
name|INTEGER
argument_list|,
operator|&
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|arg_list
index|[
name|termcap
operator|-
literal|1
index|]
operator|.
name|integer
operator|=
name|i
operator|-
literal|2
operator|*
operator|(
name|i
operator|%
literal|16
operator|)
expr_stmt|;
name|sp
operator|++
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
name|termcap
operator|>
literal|1
condition|)
return|return
name|OOPS
return|;
if|if
condition|(
operator|*
operator|++
name|sp
operator|==
literal|'\0'
condition|)
return|return
name|OOPS
return|;
if|if
condition|(
operator|*
name|sp
operator|==
literal|'0'
condition|)
name|i
operator|=
literal|9
expr_stmt|;
else|else
name|i
operator|=
operator|*
name|sp
operator|-
literal|'1'
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
literal|9
condition|)
return|return
name|OOPS
return|;
if|if
condition|(
name|pusharg
argument_list|(
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|termcap
operator|=
literal|0
expr_stmt|;
name|sp
operator|++
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
if|if
condition|(
name|termcap
operator|||
operator|*
operator|++
name|sp
operator|==
literal|'\0'
condition|)
return|return
name|OOPS
return|;
name|i
operator|=
operator|*
name|sp
operator|++
operator|-
literal|'a'
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
literal|25
condition|)
return|return
name|OOPS
return|;
if|if
condition|(
name|pos
operator|--
operator|==
literal|0
condition|)
return|return
name|OOPS
return|;
switch|switch
condition|(
name|vars
index|[
name|i
index|]
operator|.
name|type
operator|=
name|S
index|[
name|pos
index|]
operator|.
name|type
condition|)
block|{
case|case
name|ARG
case|:
name|vars
index|[
name|i
index|]
operator|.
name|argnum
operator|=
name|S
index|[
name|pos
index|]
operator|.
name|argnum
expr_stmt|;
break|break;
case|case
name|NUM
case|:
name|vars
index|[
name|i
index|]
operator|.
name|value
operator|=
name|S
index|[
name|pos
index|]
operator|.
name|value
expr_stmt|;
break|break;
block|}
break|break;
case|case
literal|'g'
case|:
if|if
condition|(
name|termcap
operator|||
operator|*
operator|++
name|sp
operator|==
literal|'\0'
condition|)
return|return
name|OOPS
return|;
name|i
operator|=
operator|*
name|sp
operator|++
operator|-
literal|'a'
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
operator|||
name|i
operator|>
literal|25
condition|)
return|return
name|OOPS
return|;
switch|switch
condition|(
name|vars
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
case|case
name|ARG
case|:
if|if
condition|(
name|pusharg
argument_list|(
name|vars
index|[
name|i
index|]
operator|.
name|argnum
argument_list|)
condition|)
return|return
name|OOPS
return|;
break|break;
case|case
name|NUM
case|:
if|if
condition|(
name|pushnum
argument_list|(
name|vars
index|[
name|i
index|]
operator|.
name|value
argument_list|)
condition|)
return|return
name|OOPS
return|;
break|break;
block|}
break|break;
case|case
literal|'\''
case|:
if|if
condition|(
name|termcap
operator|>
literal|1
condition|)
return|return
name|OOPS
return|;
if|if
condition|(
operator|*
operator|++
name|sp
operator|==
literal|'\0'
condition|)
return|return
name|OOPS
return|;
name|sp
operator|+=
name|cvtchar
argument_list|(
name|sp
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|pushnum
argument_list|(
name|c
argument_list|)
operator|||
operator|*
name|sp
operator|++
operator|!=
literal|'\''
condition|)
return|return
name|OOPS
return|;
name|termcap
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
if|if
condition|(
name|termcap
operator|>
literal|1
condition|)
return|return
name|OOPS
return|;
name|i
operator|=
literal|0
expr_stmt|;
name|sp
operator|++
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|sp
argument_list|)
condition|)
name|i
operator|=
literal|10
operator|*
name|i
operator|+
operator|*
name|sp
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|*
name|sp
operator|++
operator|!=
literal|'}'
operator|||
name|pushnum
argument_list|(
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|termcap
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|termcap
operator|||
name|popstring
argument_list|(
operator|&
name|s
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|i
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|pushnum
argument_list|(
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|sp
operator|++
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
if|if
condition|(
name|termcap
operator|||
name|popnum
argument_list|(
operator|&
name|j
argument_list|)
operator|||
name|popnum
argument_list|(
operator|&
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|i
operator|*=
name|j
expr_stmt|;
if|if
condition|(
name|pushnum
argument_list|(
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|sp
operator|++
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
name|termcap
operator|||
name|popnum
argument_list|(
operator|&
name|j
argument_list|)
operator|||
name|popnum
argument_list|(
operator|&
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|i
operator|/=
name|j
expr_stmt|;
if|if
condition|(
name|pushnum
argument_list|(
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|sp
operator|++
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
name|termcap
condition|)
block|{
if|if
condition|(
name|getarg
argument_list|(
literal|1
argument_list|,
name|INTEGER
argument_list|,
operator|&
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|arg_list
index|[
literal|0
index|]
operator|.
name|integer
operator|^=
literal|0177
expr_stmt|;
name|arg_list
index|[
literal|1
index|]
operator|.
name|integer
operator|^=
literal|0177
expr_stmt|;
name|sp
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|popnum
argument_list|(
operator|&
name|j
argument_list|)
operator|||
name|popnum
argument_list|(
operator|&
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|i
operator|%=
name|j
expr_stmt|;
if|if
condition|(
name|pushnum
argument_list|(
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|sp
operator|++
expr_stmt|;
break|break;
case|case
literal|'&'
case|:
if|if
condition|(
name|popnum
argument_list|(
operator|&
name|j
argument_list|)
operator|||
name|popnum
argument_list|(
operator|&
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|i
operator|&=
name|j
expr_stmt|;
if|if
condition|(
name|pushnum
argument_list|(
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|sp
operator|++
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
if|if
condition|(
name|popnum
argument_list|(
operator|&
name|j
argument_list|)
operator|||
name|popnum
argument_list|(
operator|&
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|i
operator||=
name|j
expr_stmt|;
if|if
condition|(
name|pushnum
argument_list|(
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|sp
operator|++
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
if|if
condition|(
name|popnum
argument_list|(
operator|&
name|j
argument_list|)
operator|||
name|popnum
argument_list|(
operator|&
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|i
operator|^=
name|j
expr_stmt|;
if|if
condition|(
name|pushnum
argument_list|(
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|sp
operator|++
expr_stmt|;
break|break;
case|case
literal|'='
case|:
if|if
condition|(
name|popnum
argument_list|(
operator|&
name|j
argument_list|)
operator|||
name|popnum
argument_list|(
operator|&
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|i
operator|=
operator|(
name|i
operator|==
name|j
operator|)
expr_stmt|;
if|if
condition|(
name|pushnum
argument_list|(
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|sp
operator|++
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
if|if
condition|(
name|popnum
argument_list|(
operator|&
name|j
argument_list|)
operator|||
name|popnum
argument_list|(
operator|&
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|i
operator|=
operator|(
name|i
operator|<
name|j
operator|)
expr_stmt|;
if|if
condition|(
name|pushnum
argument_list|(
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|sp
operator|++
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
if|if
condition|(
name|popnum
argument_list|(
operator|&
name|j
argument_list|)
operator|||
name|popnum
argument_list|(
operator|&
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|i
operator|=
operator|(
name|i
operator|&&
name|j
operator|)
expr_stmt|;
if|if
condition|(
name|pushnum
argument_list|(
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|sp
operator|++
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
if|if
condition|(
name|popnum
argument_list|(
operator|&
name|j
argument_list|)
operator|||
name|popnum
argument_list|(
operator|&
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|i
operator|=
operator|(
name|i
operator|||
name|j
operator|)
expr_stmt|;
if|if
condition|(
name|pushnum
argument_list|(
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|sp
operator|++
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
if|if
condition|(
name|popnum
argument_list|(
operator|&
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|i
operator|=
operator|!
name|i
expr_stmt|;
if|if
condition|(
name|pushnum
argument_list|(
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|sp
operator|++
expr_stmt|;
break|break;
case|case
literal|'~'
case|:
if|if
condition|(
name|popnum
argument_list|(
operator|&
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|i
operator|=
operator|~
name|i
expr_stmt|;
if|if
condition|(
name|pushnum
argument_list|(
name|i
argument_list|)
condition|)
return|return
name|OOPS
return|;
name|sp
operator|++
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
if|if
condition|(
name|termcap
operator|>
literal|1
condition|)
return|return
name|OOPS
return|;
name|termcap
operator|=
literal|0
expr_stmt|;
name|if_depth
operator|++
expr_stmt|;
name|sp
operator|++
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|popnum
argument_list|(
operator|&
name|i
argument_list|)
operator|||
name|if_depth
operator|==
literal|0
condition|)
return|return
name|OOPS
return|;
if|if
condition|(
operator|!
name|i
condition|)
block|{
name|scan_for
operator|=
literal|'e'
expr_stmt|;
name|scan_depth
operator|=
name|if_depth
expr_stmt|;
block|}
name|sp
operator|++
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|if_depth
operator|==
literal|0
condition|)
return|return
name|OOPS
return|;
name|scan_for
operator|=
literal|';'
expr_stmt|;
name|scan_depth
operator|=
name|if_depth
expr_stmt|;
name|sp
operator|++
expr_stmt|;
break|break;
case|case
literal|';'
case|:
if|if
condition|(
name|if_depth
operator|--
operator|==
literal|0
condition|)
return|return
name|OOPS
return|;
name|sp
operator|++
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
if|if
condition|(
operator|--
name|termcap
operator|<
literal|1
condition|)
return|return
name|OOPS
return|;
name|sp
operator|++
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
operator|!
name|termcap
operator|++
condition|)
return|return
name|OOPS
return|;
name|sp
operator|++
expr_stmt|;
break|break;
block|}
break|break;
default|default:
if|if
condition|(
name|scan_for
condition|)
name|sp
operator|++
expr_stmt|;
else|else
operator|*
name|dp
operator|++
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|va_end
argument_list|(
name|tparm_args
argument_list|)
expr_stmt|;
operator|*
name|dp
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buf
return|;
block|}
ifdef|#
directive|ifdef
name|TEST
name|void
name|putch
parameter_list|(
name|c
parameter_list|)
name|char
name|c
decl_stmt|;
block|{
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\\%03o"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|<
literal|32
condition|)
block|{
name|printf
argument_list|(
literal|"^%c"
argument_list|,
name|c
operator|+
literal|'@'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|127
condition|)
block|{
name|printf
argument_list|(
literal|"^?"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
name|char
name|line
index|[
name|MAX_LINE
index|]
decl_stmt|;
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|stdin
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|line
index|[
name|strlen
argument_list|(
name|line
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sp
operator|=
name|tparm
argument_list|(
name|line
argument_list|,
literal|1
argument_list|,
operator|-
literal|2
argument_list|,
literal|30
argument_list|,
literal|0
argument_list|,
literal|"bob was here"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|sp
condition|)
name|putch
argument_list|(
operator|*
name|sp
operator|++
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

