begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * tcapconv.c  *  * By Ross Ridge  * Public Domain  * 92/02/01 07:30:20  *  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_define
define|#
directive|define
name|SINGLE
end_define

begin_include
include|#
directive|include
file|<term.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USE_SCCS_IDS
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|SCCSid
index|[]
init|=
literal|"@(#) mytinfo tcapconv.c 3.2 92/02/01 public domain, By Ross Ridge"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|_sstrcodes
index|[]
decl_stmt|,
modifier|*
modifier|*
name|_sstrnames
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|C_CR
init|=
literal|"\r"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|C_LF
init|=
literal|"\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|C_BS
init|=
literal|"\b"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* static char *C_FF = "\f"; */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|C_HT
init|=
literal|"\t"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* static char *C_VT = "\013"; */
end_comment

begin_comment
comment|/* static char *C_NL = "\r\n"; */
end_comment

begin_define
define|#
directive|define
name|DEF
parameter_list|(
name|s
parameter_list|)
value|((s) != (char *) -1&& (s) != NULL)
end_define

begin_define
define|#
directive|define
name|NOTSET
parameter_list|(
name|s
parameter_list|)
value|((s) == (char *) -1)
end_define

begin_comment
comment|/*  * This routine fills in caps that either had defaults under termcap or  * can be manufactured from obsolete termcap capabilities.   */
end_comment

begin_function
name|void
name|_tcapdefault
parameter_list|()
block|{
name|char
name|buf
index|[
name|MAX_LINE
operator|*
literal|2
operator|+
literal|2
index|]
decl_stmt|;
name|int
name|set_scroll_forward_to_lf
decl_stmt|;
if|if
condition|(
name|NOTSET
argument_list|(
name|carriage_return
argument_list|)
condition|)
block|{
if|if
condition|(
name|carriage_return_delay
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s$<%d>"
argument_list|,
name|C_CR
argument_list|,
name|carriage_return_delay
argument_list|)
expr_stmt|;
name|carriage_return
operator|=
name|_addstr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
name|carriage_return
operator|=
name|_addstr
argument_list|(
name|C_CR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NOTSET
argument_list|(
name|cursor_left
argument_list|)
condition|)
block|{
if|if
condition|(
name|backspace_delay
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s$<%d>"
argument_list|,
name|C_BS
argument_list|,
name|backspace_delay
argument_list|)
expr_stmt|;
name|cursor_left
operator|=
name|_addstr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|backspaces_with_bs
operator|==
literal|1
condition|)
name|cursor_left
operator|=
name|_addstr
argument_list|(
name|C_BS
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|DEF
argument_list|(
name|backspace_if_not_bs
argument_list|)
condition|)
name|cursor_left
operator|=
name|_addstr
argument_list|(
name|backspace_if_not_bs
argument_list|)
expr_stmt|;
block|}
comment|/* vi doesn't use "do", but it does seems to use nl (or '\n') instead */
if|if
condition|(
name|NOTSET
argument_list|(
name|cursor_down
argument_list|)
condition|)
block|{
if|if
condition|(
name|DEF
argument_list|(
name|linefeed_if_not_lf
argument_list|)
condition|)
name|cursor_down
operator|=
name|_addstr
argument_list|(
name|linefeed_if_not_lf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|linefeed_is_newline
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|new_line_delay
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s$<%d>"
argument_list|,
name|C_LF
argument_list|,
name|new_line_delay
argument_list|)
expr_stmt|;
name|cursor_down
operator|=
name|_addstr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
name|cursor_down
operator|=
name|_addstr
argument_list|(
name|C_LF
argument_list|)
expr_stmt|;
block|}
block|}
name|set_scroll_forward_to_lf
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|NOTSET
argument_list|(
name|scroll_forward
argument_list|)
operator|&&
name|crt_without_scrolling
operator|!=
literal|1
condition|)
block|{
name|set_scroll_forward_to_lf
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|DEF
argument_list|(
name|linefeed_if_not_lf
argument_list|)
condition|)
name|scroll_forward
operator|=
name|_addstr
argument_list|(
name|linefeed_if_not_lf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|linefeed_is_newline
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|new_line_delay
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s$<%d>"
argument_list|,
name|C_LF
argument_list|,
name|new_line_delay
argument_list|)
expr_stmt|;
name|scroll_forward
operator|=
name|_addstr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
name|scroll_forward
operator|=
name|_addstr
argument_list|(
name|C_LF
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|NOTSET
argument_list|(
name|newline
argument_list|)
condition|)
block|{
if|if
condition|(
name|linefeed_is_newline
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|new_line_delay
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s$<%d>"
argument_list|,
name|C_LF
argument_list|,
name|new_line_delay
argument_list|)
expr_stmt|;
name|newline
operator|=
name|_addstr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
name|newline
operator|=
name|_addstr
argument_list|(
name|C_LF
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DEF
argument_list|(
name|carriage_return
argument_list|)
operator|&&
name|carriage_return_delay
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|set_scroll_forward_to_lf
condition|)
block|{
name|strncpy
argument_list|(
name|buf
argument_list|,
name|carriage_return
argument_list|,
name|MAX_LINE
operator|-
literal|2
argument_list|)
expr_stmt|;
name|buf
index|[
name|MAX_LINE
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strncat
argument_list|(
name|buf
argument_list|,
name|scroll_forward
argument_list|,
name|MAX_LINE
operator|-
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|DEF
argument_list|(
name|linefeed_if_not_lf
argument_list|)
condition|)
block|{
name|strncpy
argument_list|(
name|buf
argument_list|,
name|carriage_return
argument_list|,
name|MAX_LINE
operator|-
literal|2
argument_list|)
expr_stmt|;
name|buf
index|[
name|MAX_LINE
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strncat
argument_list|(
name|buf
argument_list|,
name|linefeed_if_not_lf
argument_list|,
name|MAX_LINE
operator|-
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|new_line_delay
operator|>
literal|0
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s%s$<%d>"
argument_list|,
name|carriage_return
argument_list|,
name|C_LF
argument_list|,
name|new_line_delay
argument_list|)
expr_stmt|;
else|else
block|{
name|strncpy
argument_list|(
name|buf
argument_list|,
name|carriage_return
argument_list|,
name|MAX_LINE
operator|-
literal|2
argument_list|)
expr_stmt|;
name|buf
index|[
name|MAX_LINE
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strncat
argument_list|(
name|buf
argument_list|,
name|C_LF
argument_list|,
name|MAX_LINE
operator|-
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|buf
index|[
name|MAX_LINE
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|newline
operator|=
name|_addstr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*  * We wait until know to decide if we've got a working cr because even  * one that doesn't work can be used for newline. Unfortunately the  * space allocated for it is wasted.  */
if|if
condition|(
name|return_does_clr_eol
operator|==
literal|1
operator|||
name|no_correctly_working_cr
operator|==
literal|1
condition|)
name|carriage_return
operator|=
name|NULL
expr_stmt|;
comment|/*  * supposedly most termcap entries have ta now and '\t' is no longer a  * default, but it doesn't seem to be true...  */
if|if
condition|(
name|NOTSET
argument_list|(
name|tab
argument_list|)
condition|)
block|{
if|if
condition|(
name|horizontal_tab_delay
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s$<%d>"
argument_list|,
name|C_HT
argument_list|,
name|horizontal_tab_delay
argument_list|)
expr_stmt|;
name|tab
operator|=
name|_addstr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
name|tab
operator|=
name|_addstr
argument_list|(
name|C_HT
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* probably not needed and might confuse some programmes */
block|if (NOTSET(form_feed)) { 		if (form_feed_delay> 0) { 			sprintf(buf, "%s$<%d>", C_FF, form_feed_delay); 			form_feed = _addstr(buf); 		} else 			form_feed = _addstr(C_FF); 	}
endif|#
directive|endif
if|if
condition|(
name|init_tabs
operator|==
operator|-
literal|1
operator|&&
name|has_hardware_tabs
operator|==
literal|1
condition|)
name|init_tabs
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|NOTSET
argument_list|(
name|key_backspace
argument_list|)
condition|)
name|key_backspace
operator|=
name|_addstr
argument_list|(
name|C_BS
argument_list|)
expr_stmt|;
if|if
condition|(
name|NOTSET
argument_list|(
name|key_left
argument_list|)
condition|)
name|key_left
operator|=
name|_addstr
argument_list|(
name|C_BS
argument_list|)
expr_stmt|;
if|if
condition|(
name|NOTSET
argument_list|(
name|key_down
argument_list|)
condition|)
name|key_down
operator|=
name|_addstr
argument_list|(
name|C_LF
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_tcapconv
parameter_list|()
block|{
name|char
name|buf
index|[
name|MAX_LINE
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|GNU_tab_width
operator|>
literal|0
operator|&&
name|init_tabs
operator|==
operator|-
literal|1
condition|)
name|init_tabs
operator|=
name|GNU_tab_width
expr_stmt|;
if|if
condition|(
name|GNU_has_meta_key
operator|==
literal|1
operator|&&
name|has_meta_key
operator|==
operator|-
literal|1
condition|)
name|has_meta_key
operator|=
literal|1
expr_stmt|;
comment|/*  * this is some what a kludge, but should work unless someone breaks  * conventions.  */
if|if
condition|(
name|DEF
argument_list|(
name|other_non_function_keys
argument_list|)
condition|)
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|static
name|char
modifier|*
name|o
decl_stmt|;
specifier|static
name|char
name|name
index|[
name|MAX_NAME
index|]
init|=
literal|"k"
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|ind
decl_stmt|;
name|s
operator|=
name|strcpy
argument_list|(
name|buf
argument_list|,
name|other_non_function_keys
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
name|o
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|!=
literal|','
operator|&&
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|ind
operator|=
name|_findstrcode
argument_list|(
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|ind
operator|==
operator|-
literal|1
condition|)
continue|continue;
name|str
operator|=
name|_term_buf
operator|.
name|strs
index|[
name|ind
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|DEF
argument_list|(
name|str
argument_list|)
condition|)
continue|continue;
name|strncpy
argument_list|(
name|name
operator|+
literal|1
argument_list|,
name|strnames
index|[
name|ind
index|]
argument_list|,
name|MAX_NAME
operator|-
literal|2
argument_list|)
expr_stmt|;
name|ind
operator|=
name|_findstrname
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ind
operator|==
operator|-
literal|1
condition|)
continue|continue;
if|if
condition|(
operator|!
name|NOTSET
argument_list|(
name|_term_buf
operator|.
name|strs
index|[
name|ind
index|]
argument_list|)
condition|)
continue|continue;
name|_term_buf
operator|.
name|strs
index|[
name|ind
index|]
operator|=
name|_addstr
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

