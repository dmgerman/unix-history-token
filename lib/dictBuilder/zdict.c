begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/**  * Copyright (c) 2016-present, Yann Collet, Facebook, Inc.  * All rights reserved.  *  * This source code is licensed under the BSD-style license found in the  * LICENSE file in the root directory of this source tree. An additional grant  * of patent rights can be found in the PATENTS file in the same directory.  */
end_comment

begin_comment
comment|/*-************************************** *  Tuning parameters ****************************************/
end_comment

begin_define
define|#
directive|define
name|ZDICT_MAX_SAMPLES_SIZE
value|(2000U<< 20)
end_define

begin_define
define|#
directive|define
name|ZDICT_MIN_SAMPLES_SIZE
value|512
end_define

begin_comment
comment|/*-************************************** *  Compiler Options ****************************************/
end_comment

begin_comment
comment|/* Unix Large Files support (>4GB) */
end_comment

begin_define
define|#
directive|define
name|_FILE_OFFSET_BITS
value|64
end_define

begin_if
if|#
directive|if
operator|(
name|defined
argument_list|(
name|__sun__
argument_list|)
operator|&&
operator|(
operator|!
name|defined
argument_list|(
name|__LP64__
argument_list|)
operator|)
operator|)
end_if

begin_comment
comment|/* Sun Solaris 32-bits requires specific definitions */
end_comment

begin_define
define|#
directive|define
name|_LARGEFILE_SOURCE
end_define

begin_elif
elif|#
directive|elif
operator|!
name|defined
argument_list|(
name|__LP64__
argument_list|)
end_elif

begin_comment
comment|/* No point defining Large file for 64 bit */
end_comment

begin_define
define|#
directive|define
name|_LARGEFILE64_SOURCE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*-************************************* *  Dependencies ***************************************/
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* malloc, free */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* memset */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* fprintf, fopen, ftello64 */
end_comment

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_comment
comment|/* clock */
end_comment

begin_include
include|#
directive|include
file|"mem.h"
end_include

begin_comment
comment|/* read */
end_comment

begin_include
include|#
directive|include
file|"fse.h"
end_include

begin_comment
comment|/* FSE_normalizeCount, FSE_writeNCount */
end_comment

begin_define
define|#
directive|define
name|HUF_STATIC_LINKING_ONLY
end_define

begin_include
include|#
directive|include
file|"huf.h"
end_include

begin_comment
comment|/* HUF_buildCTable, HUF_writeCTable */
end_comment

begin_include
include|#
directive|include
file|"zstd_internal.h"
end_include

begin_comment
comment|/* includes zstd.h */
end_comment

begin_include
include|#
directive|include
file|"xxhash.h"
end_include

begin_comment
comment|/* XXH64 */
end_comment

begin_include
include|#
directive|include
file|"divsufsort.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|ZDICT_STATIC_LINKING_ONLY
end_ifndef

begin_define
define|#
directive|define
name|ZDICT_STATIC_LINKING_ONLY
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"zdict.h"
end_include

begin_comment
comment|/*-************************************* *  Constants ***************************************/
end_comment

begin_define
define|#
directive|define
name|KB
value|*(1<<10)
end_define

begin_define
define|#
directive|define
name|MB
value|*(1<<20)
end_define

begin_define
define|#
directive|define
name|GB
value|*(1U<<30)
end_define

begin_define
define|#
directive|define
name|DICTLISTSIZE_DEFAULT
value|10000
end_define

begin_define
define|#
directive|define
name|NOISELENGTH
value|32
end_define

begin_define
define|#
directive|define
name|MINRATIO
value|4
end_define

begin_decl_stmt
specifier|static
specifier|const
name|int
name|g_compressionLevel_default
init|=
literal|6
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|U32
name|g_selectivity_default
init|=
literal|9
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|size_t
name|g_provision_entropySize
init|=
literal|200
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|size_t
name|g_min_fast_dictContent
init|=
literal|192
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*-************************************* *  Console display ***************************************/
end_comment

begin_define
define|#
directive|define
name|DISPLAY
parameter_list|(
modifier|...
parameter_list|)
value|{ fprintf(stderr, __VA_ARGS__); fflush( stderr ); }
end_define

begin_define
define|#
directive|define
name|DISPLAYLEVEL
parameter_list|(
name|l
parameter_list|,
modifier|...
parameter_list|)
value|if (notificationLevel>=l) { DISPLAY(__VA_ARGS__); }
end_define

begin_comment
comment|/* 0 : no display;   1: errors;   2: default;  3: details;  4: debug */
end_comment

begin_function
specifier|static
name|clock_t
name|ZDICT_clockSpan
parameter_list|(
name|clock_t
name|nPrevious
parameter_list|)
block|{
return|return
name|clock
argument_list|()
operator|-
name|nPrevious
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ZDICT_printHex
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
specifier|const
name|BYTE
modifier|*
specifier|const
name|b
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|ptr
decl_stmt|;
name|size_t
name|u
decl_stmt|;
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|length
condition|;
name|u
operator|++
control|)
block|{
name|BYTE
name|c
init|=
name|b
index|[
name|u
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|<
literal|32
operator|||
name|c
operator|>
literal|126
condition|)
name|c
operator|=
literal|'.'
expr_stmt|;
comment|/* non-printable char */
name|DISPLAY
argument_list|(
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*-******************************************************** *  Helper functions **********************************************************/
end_comment

begin_function
name|unsigned
name|ZDICT_isError
parameter_list|(
name|size_t
name|errorCode
parameter_list|)
block|{
return|return
name|ERR_isError
argument_list|(
name|errorCode
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|ZDICT_getErrorName
parameter_list|(
name|size_t
name|errorCode
parameter_list|)
block|{
return|return
name|ERR_getErrorName
argument_list|(
name|errorCode
argument_list|)
return|;
block|}
end_function

begin_function
name|unsigned
name|ZDICT_getDictID
parameter_list|(
specifier|const
name|void
modifier|*
name|dictBuffer
parameter_list|,
name|size_t
name|dictSize
parameter_list|)
block|{
if|if
condition|(
name|dictSize
operator|<
literal|8
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|MEM_readLE32
argument_list|(
name|dictBuffer
argument_list|)
operator|!=
name|ZSTD_DICT_MAGIC
condition|)
return|return
literal|0
return|;
return|return
name|MEM_readLE32
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|dictBuffer
operator|+
literal|4
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*-******************************************************** *  Dictionary training functions **********************************************************/
end_comment

begin_function
specifier|static
name|unsigned
name|ZDICT_NbCommonBytes
parameter_list|(
specifier|register
name|size_t
name|val
parameter_list|)
block|{
if|if
condition|(
name|MEM_isLittleEndian
argument_list|()
condition|)
block|{
if|if
condition|(
name|MEM_64bits
argument_list|()
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|defined
argument_list|(
name|_WIN64
argument_list|)
name|unsigned
name|long
name|r
init|=
literal|0
decl_stmt|;
name|_BitScanForward64
argument_list|(
operator|&
name|r
argument_list|,
operator|(
name|U64
operator|)
name|val
argument_list|)
expr_stmt|;
return|return
call|(
name|unsigned
call|)
argument_list|(
name|r
operator|>>
literal|3
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|__GNUC__
operator|>=
literal|3
operator|)
return|return
operator|(
name|__builtin_ctzll
argument_list|(
operator|(
name|U64
operator|)
name|val
argument_list|)
operator|>>
literal|3
operator|)
return|;
else|#
directive|else
specifier|static
specifier|const
name|int
name|DeBruijnBytePos
index|[
literal|64
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
literal|3
block|,
literal|1
block|,
literal|3
block|,
literal|1
block|,
literal|4
block|,
literal|2
block|,
literal|7
block|,
literal|0
block|,
literal|2
block|,
literal|3
block|,
literal|6
block|,
literal|1
block|,
literal|5
block|,
literal|3
block|,
literal|5
block|,
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|7
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|4
block|,
literal|6
block|,
literal|2
block|,
literal|6
block|,
literal|5
block|,
literal|5
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|6
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|7
block|,
literal|2
block|,
literal|6
block|,
literal|5
block|,
literal|7
block|,
literal|6
block|,
literal|7
block|,
literal|7
block|}
decl_stmt|;
return|return
name|DeBruijnBytePos
index|[
operator|(
call|(
name|U64
call|)
argument_list|(
operator|(
name|val
operator|&
operator|-
operator|(
name|long
name|long
operator|)
name|val
operator|)
operator|*
literal|0x0218A392CDABBD3FULL
argument_list|)
operator|)
operator|>>
literal|58
index|]
return|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* 32 bits */
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
name|unsigned
name|long
name|r
init|=
literal|0
decl_stmt|;
name|_BitScanForward
argument_list|(
operator|&
name|r
argument_list|,
operator|(
name|U32
operator|)
name|val
argument_list|)
expr_stmt|;
return|return
call|(
name|unsigned
call|)
argument_list|(
name|r
operator|>>
literal|3
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|__GNUC__
operator|>=
literal|3
operator|)
return|return
operator|(
name|__builtin_ctz
argument_list|(
operator|(
name|U32
operator|)
name|val
argument_list|)
operator|>>
literal|3
operator|)
return|;
else|#
directive|else
specifier|static
specifier|const
name|int
name|DeBruijnBytePos
index|[
literal|32
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|3
block|,
literal|1
block|,
literal|3
block|,
literal|0
block|,
literal|3
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|3
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|3
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
literal|3
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
return|return
name|DeBruijnBytePos
index|[
operator|(
call|(
name|U32
call|)
argument_list|(
operator|(
name|val
operator|&
operator|-
operator|(
name|S32
operator|)
name|val
operator|)
operator|*
literal|0x077CB531U
argument_list|)
operator|)
operator|>>
literal|27
index|]
return|;
endif|#
directive|endif
block|}
block|}
else|else
block|{
comment|/* Big Endian CPU */
if|if
condition|(
name|MEM_64bits
argument_list|()
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|defined
argument_list|(
name|_WIN64
argument_list|)
name|unsigned
name|long
name|r
init|=
literal|0
decl_stmt|;
name|_BitScanReverse64
argument_list|(
operator|&
name|r
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
call|(
name|unsigned
call|)
argument_list|(
name|r
operator|>>
literal|3
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|__GNUC__
operator|>=
literal|3
operator|)
return|return
operator|(
name|__builtin_clzll
argument_list|(
name|val
argument_list|)
operator|>>
literal|3
operator|)
return|;
else|#
directive|else
name|unsigned
name|r
decl_stmt|;
specifier|const
name|unsigned
name|n32
init|=
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|*
literal|4
decl_stmt|;
comment|/* calculate this way due to compiler complaining in 32-bits mode */
if|if
condition|(
operator|!
operator|(
name|val
operator|>>
name|n32
operator|)
condition|)
block|{
name|r
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
literal|0
expr_stmt|;
name|val
operator|>>=
name|n32
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|val
operator|>>
literal|16
operator|)
condition|)
block|{
name|r
operator|+=
literal|2
expr_stmt|;
name|val
operator|>>=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|val
operator|>>=
literal|24
expr_stmt|;
block|}
name|r
operator|+=
operator|(
operator|!
name|val
operator|)
expr_stmt|;
return|return
name|r
return|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* 32 bits */
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
name|unsigned
name|long
name|r
init|=
literal|0
decl_stmt|;
name|_BitScanReverse
argument_list|(
operator|&
name|r
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|val
argument_list|)
expr_stmt|;
return|return
call|(
name|unsigned
call|)
argument_list|(
name|r
operator|>>
literal|3
argument_list|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|__GNUC__
argument_list|)
operator|&&
operator|(
name|__GNUC__
operator|>=
literal|3
operator|)
return|return
operator|(
name|__builtin_clz
argument_list|(
operator|(
name|U32
operator|)
name|val
argument_list|)
operator|>>
literal|3
operator|)
return|;
else|#
directive|else
name|unsigned
name|r
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|val
operator|>>
literal|16
operator|)
condition|)
block|{
name|r
operator|=
literal|2
expr_stmt|;
name|val
operator|>>=
literal|8
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
literal|0
expr_stmt|;
name|val
operator|>>=
literal|24
expr_stmt|;
block|}
name|r
operator|+=
operator|(
operator|!
name|val
operator|)
expr_stmt|;
return|return
name|r
return|;
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_comment
comment|/*! ZDICT_count() :     Count the nb of common bytes between 2 pointers.     Note : this function presumes end of buffer followed by noisy guard band. */
end_comment

begin_function
specifier|static
name|size_t
name|ZDICT_count
parameter_list|(
specifier|const
name|void
modifier|*
name|pIn
parameter_list|,
specifier|const
name|void
modifier|*
name|pMatch
parameter_list|)
block|{
specifier|const
name|char
modifier|*
specifier|const
name|pStart
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|pIn
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|size_t
specifier|const
name|diff
init|=
name|MEM_readST
argument_list|(
name|pMatch
argument_list|)
operator|^
name|MEM_readST
argument_list|(
name|pIn
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|diff
condition|)
block|{
name|pIn
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|pIn
operator|+
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
expr_stmt|;
name|pMatch
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|pMatch
operator|+
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|pIn
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|pIn
operator|+
name|ZDICT_NbCommonBytes
argument_list|(
name|diff
argument_list|)
expr_stmt|;
return|return
call|(
name|size_t
call|)
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|pIn
operator|-
name|pStart
argument_list|)
return|;
block|}
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
block|{
name|U32
name|pos
decl_stmt|;
name|U32
name|length
decl_stmt|;
name|U32
name|savings
decl_stmt|;
block|}
name|dictItem
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|ZDICT_initDictItem
parameter_list|(
name|dictItem
modifier|*
name|d
parameter_list|)
block|{
name|d
operator|->
name|pos
operator|=
literal|1
expr_stmt|;
name|d
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|savings
operator|=
call|(
name|U32
call|)
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|LLIMIT
value|64
end_define

begin_comment
comment|/* heuristic determined experimentally */
end_comment

begin_define
define|#
directive|define
name|MINMATCHLENGTH
value|7
end_define

begin_comment
comment|/* heuristic determined experimentally */
end_comment

begin_function
specifier|static
name|dictItem
name|ZDICT_analyzePos
parameter_list|(
name|BYTE
modifier|*
name|doneMarks
parameter_list|,
specifier|const
name|int
modifier|*
name|suffix
parameter_list|,
name|U32
name|start
parameter_list|,
specifier|const
name|void
modifier|*
name|buffer
parameter_list|,
name|U32
name|minRatio
parameter_list|,
name|U32
name|notificationLevel
parameter_list|)
block|{
name|U32
name|lengthList
index|[
name|LLIMIT
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|U32
name|cumulLength
index|[
name|LLIMIT
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|U32
name|savings
index|[
name|LLIMIT
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
specifier|const
name|BYTE
modifier|*
name|b
init|=
operator|(
specifier|const
name|BYTE
operator|*
operator|)
name|buffer
decl_stmt|;
name|size_t
name|length
decl_stmt|;
name|size_t
name|maxLength
init|=
name|LLIMIT
decl_stmt|;
name|size_t
name|pos
init|=
name|suffix
index|[
name|start
index|]
decl_stmt|;
name|U32
name|end
init|=
name|start
decl_stmt|;
name|dictItem
name|solution
decl_stmt|;
comment|/* init */
name|memset
argument_list|(
operator|&
name|solution
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|solution
argument_list|)
argument_list|)
expr_stmt|;
name|doneMarks
index|[
name|pos
index|]
operator|=
literal|1
expr_stmt|;
comment|/* trivial repetition cases */
if|if
condition|(
operator|(
name|MEM_read16
argument_list|(
name|b
operator|+
name|pos
operator|+
literal|0
argument_list|)
operator|==
name|MEM_read16
argument_list|(
name|b
operator|+
name|pos
operator|+
literal|2
argument_list|)
operator|)
operator|||
operator|(
name|MEM_read16
argument_list|(
name|b
operator|+
name|pos
operator|+
literal|1
argument_list|)
operator|==
name|MEM_read16
argument_list|(
name|b
operator|+
name|pos
operator|+
literal|3
argument_list|)
operator|)
operator|||
operator|(
name|MEM_read16
argument_list|(
name|b
operator|+
name|pos
operator|+
literal|2
argument_list|)
operator|==
name|MEM_read16
argument_list|(
name|b
operator|+
name|pos
operator|+
literal|4
argument_list|)
operator|)
condition|)
block|{
comment|/* skip and mark segment */
name|U16
name|u16
init|=
name|MEM_read16
argument_list|(
name|b
operator|+
name|pos
operator|+
literal|4
argument_list|)
decl_stmt|;
name|U32
name|u
decl_stmt|,
name|e
init|=
literal|6
decl_stmt|;
while|while
condition|(
name|MEM_read16
argument_list|(
name|b
operator|+
name|pos
operator|+
name|e
argument_list|)
operator|==
name|u16
condition|)
name|e
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|b
index|[
name|pos
operator|+
name|e
index|]
operator|==
name|b
index|[
name|pos
operator|+
name|e
operator|-
literal|1
index|]
condition|)
name|e
operator|++
expr_stmt|;
for|for
control|(
name|u
operator|=
literal|1
init|;
name|u
operator|<
name|e
condition|;
name|u
operator|++
control|)
name|doneMarks
index|[
name|pos
operator|+
name|u
index|]
operator|=
literal|1
expr_stmt|;
return|return
name|solution
return|;
block|}
comment|/* look forward */
do|do
block|{
name|end
operator|++
expr_stmt|;
name|length
operator|=
name|ZDICT_count
argument_list|(
name|b
operator|+
name|pos
argument_list|,
name|b
operator|+
name|suffix
index|[
name|end
index|]
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|length
operator|>=
name|MINMATCHLENGTH
condition|)
do|;
comment|/* look backward */
do|do
block|{
name|length
operator|=
name|ZDICT_count
argument_list|(
name|b
operator|+
name|pos
argument_list|,
name|b
operator|+
operator|*
operator|(
name|suffix
operator|+
name|start
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>=
name|MINMATCHLENGTH
condition|)
name|start
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|length
operator|>=
name|MINMATCHLENGTH
condition|)
do|;
comment|/* exit if not found a minimum nb of repetitions */
if|if
condition|(
name|end
operator|-
name|start
operator|<
name|minRatio
condition|)
block|{
name|U32
name|idx
decl_stmt|;
for|for
control|(
name|idx
operator|=
name|start
init|;
name|idx
operator|<
name|end
condition|;
name|idx
operator|++
control|)
name|doneMarks
index|[
name|suffix
index|[
name|idx
index|]
index|]
operator|=
literal|1
expr_stmt|;
return|return
name|solution
return|;
block|}
block|{
name|int
name|i
decl_stmt|;
name|U32
name|searchLength
decl_stmt|;
name|U32
name|refinedStart
init|=
name|start
decl_stmt|;
name|U32
name|refinedEnd
init|=
name|end
decl_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|4
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|4
argument_list|,
literal|"found %3u matches of length>= %i at pos %7u  "
argument_list|,
call|(
name|U32
call|)
argument_list|(
name|end
operator|-
name|start
argument_list|)
argument_list|,
name|MINMATCHLENGTH
argument_list|,
operator|(
name|U32
operator|)
name|pos
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|4
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|searchLength
operator|=
name|MINMATCHLENGTH
init|;
condition|;
name|searchLength
operator|++
control|)
block|{
name|BYTE
name|currentChar
init|=
literal|0
decl_stmt|;
name|U32
name|currentCount
init|=
literal|0
decl_stmt|;
name|U32
name|currentID
init|=
name|refinedStart
decl_stmt|;
name|U32
name|id
decl_stmt|;
name|U32
name|selectedCount
init|=
literal|0
decl_stmt|;
name|U32
name|selectedID
init|=
name|currentID
decl_stmt|;
for|for
control|(
name|id
operator|=
name|refinedStart
init|;
name|id
operator|<
name|refinedEnd
condition|;
name|id
operator|++
control|)
block|{
if|if
condition|(
name|b
index|[
name|suffix
index|[
name|id
index|]
operator|+
name|searchLength
index|]
operator|!=
name|currentChar
condition|)
block|{
if|if
condition|(
name|currentCount
operator|>
name|selectedCount
condition|)
block|{
name|selectedCount
operator|=
name|currentCount
expr_stmt|;
name|selectedID
operator|=
name|currentID
expr_stmt|;
block|}
name|currentID
operator|=
name|id
expr_stmt|;
name|currentChar
operator|=
name|b
index|[
name|suffix
index|[
name|id
index|]
operator|+
name|searchLength
index|]
expr_stmt|;
name|currentCount
operator|=
literal|0
expr_stmt|;
block|}
name|currentCount
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|currentCount
operator|>
name|selectedCount
condition|)
block|{
comment|/* for last */
name|selectedCount
operator|=
name|currentCount
expr_stmt|;
name|selectedID
operator|=
name|currentID
expr_stmt|;
block|}
if|if
condition|(
name|selectedCount
operator|<
name|minRatio
condition|)
break|break;
name|refinedStart
operator|=
name|selectedID
expr_stmt|;
name|refinedEnd
operator|=
name|refinedStart
operator|+
name|selectedCount
expr_stmt|;
block|}
comment|/* evaluate gain based on new ref */
name|start
operator|=
name|refinedStart
expr_stmt|;
name|pos
operator|=
name|suffix
index|[
name|refinedStart
index|]
expr_stmt|;
name|end
operator|=
name|start
expr_stmt|;
name|memset
argument_list|(
name|lengthList
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|lengthList
argument_list|)
argument_list|)
expr_stmt|;
comment|/* look forward */
do|do
block|{
name|end
operator|++
expr_stmt|;
name|length
operator|=
name|ZDICT_count
argument_list|(
name|b
operator|+
name|pos
argument_list|,
name|b
operator|+
name|suffix
index|[
name|end
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>=
name|LLIMIT
condition|)
name|length
operator|=
name|LLIMIT
operator|-
literal|1
expr_stmt|;
name|lengthList
index|[
name|length
index|]
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|length
operator|>=
name|MINMATCHLENGTH
condition|)
do|;
comment|/* look backward */
name|length
operator|=
name|MINMATCHLENGTH
expr_stmt|;
while|while
condition|(
operator|(
name|length
operator|>=
name|MINMATCHLENGTH
operator|)
operator|&
operator|(
name|start
operator|>
literal|0
operator|)
condition|)
block|{
name|length
operator|=
name|ZDICT_count
argument_list|(
name|b
operator|+
name|pos
argument_list|,
name|b
operator|+
name|suffix
index|[
name|start
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>=
name|LLIMIT
condition|)
name|length
operator|=
name|LLIMIT
operator|-
literal|1
expr_stmt|;
name|lengthList
index|[
name|length
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|length
operator|>=
name|MINMATCHLENGTH
condition|)
name|start
operator|--
expr_stmt|;
block|}
comment|/* largest useful length */
name|memset
argument_list|(
name|cumulLength
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cumulLength
argument_list|)
argument_list|)
expr_stmt|;
name|cumulLength
index|[
name|maxLength
operator|-
literal|1
index|]
operator|=
name|lengthList
index|[
name|maxLength
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
call|(
name|int
call|)
argument_list|(
name|maxLength
operator|-
literal|2
argument_list|)
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
name|cumulLength
index|[
name|i
index|]
operator|=
name|cumulLength
index|[
name|i
operator|+
literal|1
index|]
operator|+
name|lengthList
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|LLIMIT
operator|-
literal|1
init|;
name|i
operator|>=
name|MINMATCHLENGTH
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|cumulLength
index|[
name|i
index|]
operator|>=
name|minRatio
condition|)
break|break;
name|maxLength
operator|=
name|i
expr_stmt|;
comment|/* reduce maxLength in case of final into repetitive data */
block|{
name|U32
name|l
init|=
operator|(
name|U32
operator|)
name|maxLength
decl_stmt|;
name|BYTE
specifier|const
name|c
init|=
name|b
index|[
name|pos
operator|+
name|maxLength
operator|-
literal|1
index|]
decl_stmt|;
while|while
condition|(
name|b
index|[
name|pos
operator|+
name|l
operator|-
literal|2
index|]
operator|==
name|c
condition|)
name|l
operator|--
expr_stmt|;
name|maxLength
operator|=
name|l
expr_stmt|;
block|}
if|if
condition|(
name|maxLength
operator|<
name|MINMATCHLENGTH
condition|)
return|return
name|solution
return|;
comment|/* skip : no long-enough solution */
comment|/* calculate savings */
name|savings
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|MINMATCHLENGTH
init|;
name|i
operator|<=
operator|(
name|int
operator|)
name|maxLength
condition|;
name|i
operator|++
control|)
name|savings
index|[
name|i
index|]
operator|=
name|savings
index|[
name|i
operator|-
literal|1
index|]
operator|+
operator|(
name|lengthList
index|[
name|i
index|]
operator|*
operator|(
name|i
operator|-
literal|3
operator|)
operator|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|4
argument_list|,
literal|"Selected ref at position %u, of length %u : saves %u (ratio: %.2f)  \n"
argument_list|,
operator|(
name|U32
operator|)
name|pos
argument_list|,
operator|(
name|U32
operator|)
name|maxLength
argument_list|,
name|savings
index|[
name|maxLength
index|]
argument_list|,
operator|(
name|double
operator|)
name|savings
index|[
name|maxLength
index|]
operator|/
name|maxLength
argument_list|)
expr_stmt|;
name|solution
operator|.
name|pos
operator|=
operator|(
name|U32
operator|)
name|pos
expr_stmt|;
name|solution
operator|.
name|length
operator|=
operator|(
name|U32
operator|)
name|maxLength
expr_stmt|;
name|solution
operator|.
name|savings
operator|=
name|savings
index|[
name|maxLength
index|]
expr_stmt|;
comment|/* mark positions done */
block|{
name|U32
name|id
decl_stmt|;
for|for
control|(
name|id
operator|=
name|start
init|;
name|id
operator|<
name|end
condition|;
name|id
operator|++
control|)
block|{
name|U32
name|p
decl_stmt|,
name|pEnd
decl_stmt|;
name|U32
specifier|const
name|testedPos
init|=
name|suffix
index|[
name|id
index|]
decl_stmt|;
if|if
condition|(
name|testedPos
operator|==
name|pos
condition|)
name|length
operator|=
name|solution
operator|.
name|length
expr_stmt|;
else|else
block|{
name|length
operator|=
name|ZDICT_count
argument_list|(
name|b
operator|+
name|pos
argument_list|,
name|b
operator|+
name|testedPos
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
operator|>
name|solution
operator|.
name|length
condition|)
name|length
operator|=
name|solution
operator|.
name|length
expr_stmt|;
block|}
name|pEnd
operator|=
call|(
name|U32
call|)
argument_list|(
name|testedPos
operator|+
name|length
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|testedPos
init|;
name|p
operator|<
name|pEnd
condition|;
name|p
operator|++
control|)
name|doneMarks
index|[
name|p
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
return|return
name|solution
return|;
block|}
end_function

begin_comment
comment|/*! ZDICT_checkMerge     check if dictItem can be merged, do it if possible     @return : id of destination elt, 0 if not merged */
end_comment

begin_function
specifier|static
name|U32
name|ZDICT_checkMerge
parameter_list|(
name|dictItem
modifier|*
name|table
parameter_list|,
name|dictItem
name|elt
parameter_list|,
name|U32
name|eltNbToSkip
parameter_list|)
block|{
specifier|const
name|U32
name|tableSize
init|=
name|table
operator|->
name|pos
decl_stmt|;
specifier|const
name|U32
name|eltEnd
init|=
name|elt
operator|.
name|pos
operator|+
name|elt
operator|.
name|length
decl_stmt|;
comment|/* tail overlap */
name|U32
name|u
decl_stmt|;
for|for
control|(
name|u
operator|=
literal|1
init|;
name|u
operator|<
name|tableSize
condition|;
name|u
operator|++
control|)
block|{
if|if
condition|(
name|u
operator|==
name|eltNbToSkip
condition|)
continue|continue;
if|if
condition|(
operator|(
name|table
index|[
name|u
index|]
operator|.
name|pos
operator|>
name|elt
operator|.
name|pos
operator|)
operator|&&
operator|(
name|table
index|[
name|u
index|]
operator|.
name|pos
operator|<=
name|eltEnd
operator|)
condition|)
block|{
comment|/* overlap, existing> new */
comment|/* append */
name|U32
name|addedLength
init|=
name|table
index|[
name|u
index|]
operator|.
name|pos
operator|-
name|elt
operator|.
name|pos
decl_stmt|;
name|table
index|[
name|u
index|]
operator|.
name|length
operator|+=
name|addedLength
expr_stmt|;
name|table
index|[
name|u
index|]
operator|.
name|pos
operator|=
name|elt
operator|.
name|pos
expr_stmt|;
name|table
index|[
name|u
index|]
operator|.
name|savings
operator|+=
name|elt
operator|.
name|savings
operator|*
name|addedLength
operator|/
name|elt
operator|.
name|length
expr_stmt|;
comment|/* rough approx */
name|table
index|[
name|u
index|]
operator|.
name|savings
operator|+=
name|elt
operator|.
name|length
operator|/
literal|8
expr_stmt|;
comment|/* rough approx bonus */
name|elt
operator|=
name|table
index|[
name|u
index|]
expr_stmt|;
comment|/* sort : improve rank */
while|while
condition|(
operator|(
name|u
operator|>
literal|1
operator|)
operator|&&
operator|(
name|table
index|[
name|u
operator|-
literal|1
index|]
operator|.
name|savings
operator|<
name|elt
operator|.
name|savings
operator|)
condition|)
name|table
index|[
name|u
index|]
operator|=
name|table
index|[
name|u
operator|-
literal|1
index|]
operator|,
name|u
operator|--
expr_stmt|;
name|table
index|[
name|u
index|]
operator|=
name|elt
expr_stmt|;
return|return
name|u
return|;
block|}
block|}
comment|/* front overlap */
for|for
control|(
name|u
operator|=
literal|1
init|;
name|u
operator|<
name|tableSize
condition|;
name|u
operator|++
control|)
block|{
if|if
condition|(
name|u
operator|==
name|eltNbToSkip
condition|)
continue|continue;
if|if
condition|(
operator|(
name|table
index|[
name|u
index|]
operator|.
name|pos
operator|+
name|table
index|[
name|u
index|]
operator|.
name|length
operator|>=
name|elt
operator|.
name|pos
operator|)
operator|&&
operator|(
name|table
index|[
name|u
index|]
operator|.
name|pos
operator|<
name|elt
operator|.
name|pos
operator|)
condition|)
block|{
comment|/* overlap, existing< new */
comment|/* append */
name|int
name|addedLength
init|=
operator|(
name|int
operator|)
name|eltEnd
operator|-
operator|(
name|table
index|[
name|u
index|]
operator|.
name|pos
operator|+
name|table
index|[
name|u
index|]
operator|.
name|length
operator|)
decl_stmt|;
name|table
index|[
name|u
index|]
operator|.
name|savings
operator|+=
name|elt
operator|.
name|length
operator|/
literal|8
expr_stmt|;
comment|/* rough approx bonus */
if|if
condition|(
name|addedLength
operator|>
literal|0
condition|)
block|{
comment|/* otherwise, elt fully included into existing */
name|table
index|[
name|u
index|]
operator|.
name|length
operator|+=
name|addedLength
expr_stmt|;
name|table
index|[
name|u
index|]
operator|.
name|savings
operator|+=
name|elt
operator|.
name|savings
operator|*
name|addedLength
operator|/
name|elt
operator|.
name|length
expr_stmt|;
comment|/* rough approx */
block|}
comment|/* sort : improve rank */
name|elt
operator|=
name|table
index|[
name|u
index|]
expr_stmt|;
while|while
condition|(
operator|(
name|u
operator|>
literal|1
operator|)
operator|&&
operator|(
name|table
index|[
name|u
operator|-
literal|1
index|]
operator|.
name|savings
operator|<
name|elt
operator|.
name|savings
operator|)
condition|)
name|table
index|[
name|u
index|]
operator|=
name|table
index|[
name|u
operator|-
literal|1
index|]
operator|,
name|u
operator|--
expr_stmt|;
name|table
index|[
name|u
index|]
operator|=
name|elt
expr_stmt|;
return|return
name|u
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ZDICT_removeDictItem
parameter_list|(
name|dictItem
modifier|*
name|table
parameter_list|,
name|U32
name|id
parameter_list|)
block|{
comment|/* convention : first element is nb of elts */
name|U32
specifier|const
name|max
init|=
name|table
operator|->
name|pos
decl_stmt|;
name|U32
name|u
decl_stmt|;
if|if
condition|(
operator|!
name|id
condition|)
return|return;
comment|/* protection, should never happen */
for|for
control|(
name|u
operator|=
name|id
init|;
name|u
operator|<
name|max
operator|-
literal|1
condition|;
name|u
operator|++
control|)
name|table
index|[
name|u
index|]
operator|=
name|table
index|[
name|u
operator|+
literal|1
index|]
expr_stmt|;
name|table
operator|->
name|pos
operator|--
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ZDICT_insertDictItem
parameter_list|(
name|dictItem
modifier|*
name|table
parameter_list|,
name|U32
name|maxSize
parameter_list|,
name|dictItem
name|elt
parameter_list|)
block|{
comment|/* merge if possible */
name|U32
name|mergeId
init|=
name|ZDICT_checkMerge
argument_list|(
name|table
argument_list|,
name|elt
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|mergeId
condition|)
block|{
name|U32
name|newMerge
init|=
literal|1
decl_stmt|;
while|while
condition|(
name|newMerge
condition|)
block|{
name|newMerge
operator|=
name|ZDICT_checkMerge
argument_list|(
name|table
argument_list|,
name|table
index|[
name|mergeId
index|]
argument_list|,
name|mergeId
argument_list|)
expr_stmt|;
if|if
condition|(
name|newMerge
condition|)
name|ZDICT_removeDictItem
argument_list|(
name|table
argument_list|,
name|mergeId
argument_list|)
expr_stmt|;
name|mergeId
operator|=
name|newMerge
expr_stmt|;
block|}
return|return;
block|}
comment|/* insert */
block|{
name|U32
name|current
decl_stmt|;
name|U32
name|nextElt
init|=
name|table
operator|->
name|pos
decl_stmt|;
if|if
condition|(
name|nextElt
operator|>=
name|maxSize
condition|)
name|nextElt
operator|=
name|maxSize
operator|-
literal|1
expr_stmt|;
name|current
operator|=
name|nextElt
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|table
index|[
name|current
index|]
operator|.
name|savings
operator|<
name|elt
operator|.
name|savings
condition|)
block|{
name|table
index|[
name|current
operator|+
literal|1
index|]
operator|=
name|table
index|[
name|current
index|]
expr_stmt|;
name|current
operator|--
expr_stmt|;
block|}
name|table
index|[
name|current
operator|+
literal|1
index|]
operator|=
name|elt
expr_stmt|;
name|table
operator|->
name|pos
operator|=
name|nextElt
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|U32
name|ZDICT_dictSize
parameter_list|(
specifier|const
name|dictItem
modifier|*
name|dictList
parameter_list|)
block|{
name|U32
name|u
decl_stmt|,
name|dictSize
init|=
literal|0
decl_stmt|;
for|for
control|(
name|u
operator|=
literal|1
init|;
name|u
operator|<
name|dictList
index|[
literal|0
index|]
operator|.
name|pos
condition|;
name|u
operator|++
control|)
name|dictSize
operator|+=
name|dictList
index|[
name|u
index|]
operator|.
name|length
expr_stmt|;
return|return
name|dictSize
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|ZDICT_trainBuffer
parameter_list|(
name|dictItem
modifier|*
name|dictList
parameter_list|,
name|U32
name|dictListSize
parameter_list|,
specifier|const
name|void
modifier|*
specifier|const
name|buffer
parameter_list|,
name|size_t
name|bufferSize
parameter_list|,
comment|/* buffer must end with noisy guard band */
specifier|const
name|size_t
modifier|*
name|fileSizes
parameter_list|,
name|unsigned
name|nbFiles
parameter_list|,
name|U32
name|minRatio
parameter_list|,
name|U32
name|notificationLevel
parameter_list|)
block|{
name|int
modifier|*
specifier|const
name|suffix0
init|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|bufferSize
operator|+
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|suffix0
argument_list|)
argument_list|)
decl_stmt|;
name|int
modifier|*
specifier|const
name|suffix
init|=
name|suffix0
operator|+
literal|1
decl_stmt|;
name|U32
modifier|*
name|reverseSuffix
init|=
operator|(
name|U32
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|bufferSize
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|reverseSuffix
argument_list|)
argument_list|)
decl_stmt|;
name|BYTE
modifier|*
name|doneMarks
init|=
operator|(
name|BYTE
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|bufferSize
operator|+
literal|16
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|doneMarks
argument_list|)
argument_list|)
decl_stmt|;
comment|/* +16 for overflow security */
name|U32
modifier|*
name|filePos
init|=
operator|(
name|U32
operator|*
operator|)
name|malloc
argument_list|(
name|nbFiles
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|filePos
argument_list|)
argument_list|)
decl_stmt|;
name|size_t
name|result
init|=
literal|0
decl_stmt|;
name|clock_t
name|displayClock
init|=
literal|0
decl_stmt|;
name|clock_t
specifier|const
name|refreshRate
init|=
name|CLOCKS_PER_SEC
operator|*
literal|3
operator|/
literal|10
decl_stmt|;
define|#
directive|define
name|DISPLAYUPDATE
parameter_list|(
name|l
parameter_list|,
modifier|...
parameter_list|)
value|if (notificationLevel>=l) { \             if (ZDICT_clockSpan(displayClock)> refreshRate)  \             { displayClock = clock(); DISPLAY(__VA_ARGS__); \             if (notificationLevel>=4) fflush(stdout); } }
comment|/* init */
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"\r%70s\r"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* clean display line */
if|if
condition|(
operator|!
name|suffix0
operator|||
operator|!
name|reverseSuffix
operator|||
operator|!
name|doneMarks
operator|||
operator|!
name|filePos
condition|)
block|{
name|result
operator|=
name|ERROR
argument_list|(
name|memory_allocation
argument_list|)
expr_stmt|;
goto|goto
name|_cleanup
goto|;
block|}
if|if
condition|(
name|minRatio
operator|<
name|MINRATIO
condition|)
name|minRatio
operator|=
name|MINRATIO
expr_stmt|;
name|memset
argument_list|(
name|doneMarks
argument_list|,
literal|0
argument_list|,
name|bufferSize
operator|+
literal|16
argument_list|)
expr_stmt|;
comment|/* limit sample set size (divsufsort limitation)*/
if|if
condition|(
name|bufferSize
operator|>
name|ZDICT_MAX_SAMPLES_SIZE
condition|)
name|DISPLAYLEVEL
argument_list|(
literal|3
argument_list|,
literal|"sample set too large : reduced to %u MB ...\n"
argument_list|,
call|(
name|U32
call|)
argument_list|(
name|ZDICT_MAX_SAMPLES_SIZE
operator|>>
literal|20
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|bufferSize
operator|>
name|ZDICT_MAX_SAMPLES_SIZE
condition|)
name|bufferSize
operator|-=
name|fileSizes
index|[
operator|--
name|nbFiles
index|]
expr_stmt|;
comment|/* sort */
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"sorting %u files of total size %u MB ...\n"
argument_list|,
name|nbFiles
argument_list|,
call|(
name|U32
call|)
argument_list|(
name|bufferSize
operator|>>
literal|20
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|int
specifier|const
name|divSuftSortResult
init|=
name|divsufsort
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|buffer
argument_list|,
name|suffix
argument_list|,
operator|(
name|int
operator|)
name|bufferSize
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|divSuftSortResult
operator|!=
literal|0
condition|)
block|{
name|result
operator|=
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
expr_stmt|;
goto|goto
name|_cleanup
goto|;
block|}
block|}
name|suffix
index|[
name|bufferSize
index|]
operator|=
operator|(
name|int
operator|)
name|bufferSize
expr_stmt|;
comment|/* leads into noise */
name|suffix0
index|[
literal|0
index|]
operator|=
operator|(
name|int
operator|)
name|bufferSize
expr_stmt|;
comment|/* leads into noise */
comment|/* build reverse suffix sort */
block|{
name|size_t
name|pos
decl_stmt|;
for|for
control|(
name|pos
operator|=
literal|0
init|;
name|pos
operator|<
name|bufferSize
condition|;
name|pos
operator|++
control|)
name|reverseSuffix
index|[
name|suffix
index|[
name|pos
index|]
index|]
operator|=
operator|(
name|U32
operator|)
name|pos
expr_stmt|;
comment|/* note filePos tracks borders between samples.            It's not used at this stage, but planned to become useful in a later update */
name|filePos
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|pos
operator|=
literal|1
init|;
name|pos
operator|<
name|nbFiles
condition|;
name|pos
operator|++
control|)
name|filePos
index|[
name|pos
index|]
operator|=
call|(
name|U32
call|)
argument_list|(
name|filePos
index|[
name|pos
operator|-
literal|1
index|]
operator|+
name|fileSizes
index|[
name|pos
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"finding patterns ... \n"
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|3
argument_list|,
literal|"minimum ratio : %u \n"
argument_list|,
name|minRatio
argument_list|)
expr_stmt|;
block|{
name|U32
name|cursor
decl_stmt|;
for|for
control|(
name|cursor
operator|=
literal|0
init|;
name|cursor
operator|<
name|bufferSize
condition|;
control|)
block|{
name|dictItem
name|solution
decl_stmt|;
if|if
condition|(
name|doneMarks
index|[
name|cursor
index|]
condition|)
block|{
name|cursor
operator|++
expr_stmt|;
continue|continue;
block|}
name|solution
operator|=
name|ZDICT_analyzePos
argument_list|(
name|doneMarks
argument_list|,
name|suffix
argument_list|,
name|reverseSuffix
index|[
name|cursor
index|]
argument_list|,
name|buffer
argument_list|,
name|minRatio
argument_list|,
name|notificationLevel
argument_list|)
expr_stmt|;
if|if
condition|(
name|solution
operator|.
name|length
operator|==
literal|0
condition|)
block|{
name|cursor
operator|++
expr_stmt|;
continue|continue;
block|}
name|ZDICT_insertDictItem
argument_list|(
name|dictList
argument_list|,
name|dictListSize
argument_list|,
name|solution
argument_list|)
expr_stmt|;
name|cursor
operator|+=
name|solution
operator|.
name|length
expr_stmt|;
name|DISPLAYUPDATE
argument_list|(
literal|2
argument_list|,
literal|"\r%4.2f %% \r"
argument_list|,
operator|(
name|double
operator|)
name|cursor
operator|/
name|bufferSize
operator|*
literal|100
argument_list|)
expr_stmt|;
block|}
block|}
name|_cleanup
label|:
name|free
argument_list|(
name|suffix0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|reverseSuffix
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|doneMarks
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filePos
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|ZDICT_fillNoise
parameter_list|(
name|void
modifier|*
name|buffer
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
name|unsigned
specifier|const
name|prime1
init|=
literal|2654435761U
decl_stmt|;
name|unsigned
specifier|const
name|prime2
init|=
literal|2246822519U
decl_stmt|;
name|unsigned
name|acc
init|=
name|prime1
decl_stmt|;
name|size_t
name|p
init|=
literal|0
decl_stmt|;
empty_stmt|;
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
name|length
condition|;
name|p
operator|++
control|)
block|{
name|acc
operator|*=
name|prime2
expr_stmt|;
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
name|buffer
operator|)
index|[
name|p
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|acc
operator|>>
literal|21
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
block|{
name|ZSTD_CCtx
modifier|*
name|ref
decl_stmt|;
name|ZSTD_CCtx
modifier|*
name|zc
decl_stmt|;
name|void
modifier|*
name|workPlace
decl_stmt|;
comment|/* must be ZSTD_BLOCKSIZE_ABSOLUTEMAX allocated */
block|}
name|EStats_ress_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|MAXREPOFFSET
value|1024
end_define

begin_function
specifier|static
name|void
name|ZDICT_countEStats
parameter_list|(
name|EStats_ress_t
name|esr
parameter_list|,
name|ZSTD_parameters
name|params
parameter_list|,
name|U32
modifier|*
name|countLit
parameter_list|,
name|U32
modifier|*
name|offsetcodeCount
parameter_list|,
name|U32
modifier|*
name|matchlengthCount
parameter_list|,
name|U32
modifier|*
name|litlengthCount
parameter_list|,
name|U32
modifier|*
name|repOffsets
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|srcSize
parameter_list|,
name|U32
name|notificationLevel
parameter_list|)
block|{
name|size_t
specifier|const
name|blockSizeMax
init|=
name|MIN
argument_list|(
name|ZSTD_BLOCKSIZE_ABSOLUTEMAX
argument_list|,
literal|1
operator|<<
name|params
operator|.
name|cParams
operator|.
name|windowLog
argument_list|)
decl_stmt|;
name|size_t
name|cSize
decl_stmt|;
if|if
condition|(
name|srcSize
operator|>
name|blockSizeMax
condition|)
name|srcSize
operator|=
name|blockSizeMax
expr_stmt|;
comment|/* protection vs large samples */
block|{
name|size_t
specifier|const
name|errorCode
init|=
name|ZSTD_copyCCtx
argument_list|(
name|esr
operator|.
name|zc
argument_list|,
name|esr
operator|.
name|ref
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"warning : ZSTD_copyCCtx failed \n"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|cSize
operator|=
name|ZSTD_compressBlock
argument_list|(
name|esr
operator|.
name|zc
argument_list|,
name|esr
operator|.
name|workPlace
argument_list|,
name|ZSTD_BLOCKSIZE_ABSOLUTEMAX
argument_list|,
name|src
argument_list|,
name|srcSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|cSize
argument_list|)
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|3
argument_list|,
literal|"warning : could not compress sample size %u \n"
argument_list|,
operator|(
name|U32
operator|)
name|srcSize
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|cSize
condition|)
block|{
comment|/* if == 0; block is not compressible */
specifier|const
name|seqStore_t
modifier|*
name|seqStorePtr
init|=
name|ZSTD_getSeqStore
argument_list|(
name|esr
operator|.
name|zc
argument_list|)
decl_stmt|;
comment|/* literals stats */
block|{
specifier|const
name|BYTE
modifier|*
name|bytePtr
decl_stmt|;
for|for
control|(
name|bytePtr
operator|=
name|seqStorePtr
operator|->
name|litStart
init|;
name|bytePtr
operator|<
name|seqStorePtr
operator|->
name|lit
condition|;
name|bytePtr
operator|++
control|)
name|countLit
index|[
operator|*
name|bytePtr
index|]
operator|++
expr_stmt|;
block|}
comment|/* seqStats */
block|{
name|U32
specifier|const
name|nbSeq
init|=
call|(
name|U32
call|)
argument_list|(
name|seqStorePtr
operator|->
name|sequences
operator|-
name|seqStorePtr
operator|->
name|sequencesStart
argument_list|)
decl_stmt|;
name|ZSTD_seqToCodes
argument_list|(
name|seqStorePtr
argument_list|)
expr_stmt|;
block|{
specifier|const
name|BYTE
modifier|*
name|codePtr
init|=
name|seqStorePtr
operator|->
name|ofCode
decl_stmt|;
name|U32
name|u
decl_stmt|;
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|nbSeq
condition|;
name|u
operator|++
control|)
name|offsetcodeCount
index|[
name|codePtr
index|[
name|u
index|]
index|]
operator|++
expr_stmt|;
block|}
block|{
specifier|const
name|BYTE
modifier|*
name|codePtr
init|=
name|seqStorePtr
operator|->
name|mlCode
decl_stmt|;
name|U32
name|u
decl_stmt|;
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|nbSeq
condition|;
name|u
operator|++
control|)
name|matchlengthCount
index|[
name|codePtr
index|[
name|u
index|]
index|]
operator|++
expr_stmt|;
block|}
block|{
specifier|const
name|BYTE
modifier|*
name|codePtr
init|=
name|seqStorePtr
operator|->
name|llCode
decl_stmt|;
name|U32
name|u
decl_stmt|;
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|nbSeq
condition|;
name|u
operator|++
control|)
name|litlengthCount
index|[
name|codePtr
index|[
name|u
index|]
index|]
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|nbSeq
operator|>=
literal|2
condition|)
block|{
comment|/* rep offsets */
specifier|const
name|seqDef
modifier|*
specifier|const
name|seq
init|=
name|seqStorePtr
operator|->
name|sequencesStart
decl_stmt|;
name|U32
name|offset1
init|=
name|seq
index|[
literal|0
index|]
operator|.
name|offset
operator|-
literal|3
decl_stmt|;
name|U32
name|offset2
init|=
name|seq
index|[
literal|1
index|]
operator|.
name|offset
operator|-
literal|3
decl_stmt|;
if|if
condition|(
name|offset1
operator|>=
name|MAXREPOFFSET
condition|)
name|offset1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|offset2
operator|>=
name|MAXREPOFFSET
condition|)
name|offset2
operator|=
literal|0
expr_stmt|;
name|repOffsets
index|[
name|offset1
index|]
operator|+=
literal|3
expr_stmt|;
name|repOffsets
index|[
name|offset2
index|]
operator|+=
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* static size_t ZDICT_maxSampleSize(const size_t* fileSizes, unsigned nbFiles) {     unsigned u;     size_t max=0;     for (u=0; u<nbFiles; u++)         if (max< fileSizes[u]) max = fileSizes[u];     return max; } */
end_comment

begin_function
specifier|static
name|size_t
name|ZDICT_totalSampleSize
parameter_list|(
specifier|const
name|size_t
modifier|*
name|fileSizes
parameter_list|,
name|unsigned
name|nbFiles
parameter_list|)
block|{
name|size_t
name|total
init|=
literal|0
decl_stmt|;
name|unsigned
name|u
decl_stmt|;
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|nbFiles
condition|;
name|u
operator|++
control|)
name|total
operator|+=
name|fileSizes
index|[
name|u
index|]
expr_stmt|;
return|return
name|total
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
block|{
name|U32
name|offset
decl_stmt|;
name|U32
name|count
decl_stmt|;
block|}
name|offsetCount_t
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|ZDICT_insertSortCount
parameter_list|(
name|offsetCount_t
name|table
index|[
name|ZSTD_REP_NUM
operator|+
literal|1
index|]
parameter_list|,
name|U32
name|val
parameter_list|,
name|U32
name|count
parameter_list|)
block|{
name|U32
name|u
decl_stmt|;
name|table
index|[
name|ZSTD_REP_NUM
index|]
operator|.
name|offset
operator|=
name|val
expr_stmt|;
name|table
index|[
name|ZSTD_REP_NUM
index|]
operator|.
name|count
operator|=
name|count
expr_stmt|;
for|for
control|(
name|u
operator|=
name|ZSTD_REP_NUM
init|;
name|u
operator|>
literal|0
condition|;
name|u
operator|--
control|)
block|{
name|offsetCount_t
name|tmp
decl_stmt|;
if|if
condition|(
name|table
index|[
name|u
operator|-
literal|1
index|]
operator|.
name|count
operator|>=
name|table
index|[
name|u
index|]
operator|.
name|count
condition|)
break|break;
name|tmp
operator|=
name|table
index|[
name|u
operator|-
literal|1
index|]
expr_stmt|;
name|table
index|[
name|u
operator|-
literal|1
index|]
operator|=
name|table
index|[
name|u
index|]
expr_stmt|;
name|table
index|[
name|u
index|]
operator|=
name|tmp
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|OFFCODE_MAX
value|30
end_define

begin_comment
comment|/* only applicable to first block */
end_comment

begin_function
specifier|static
name|size_t
name|ZDICT_analyzeEntropy
parameter_list|(
name|void
modifier|*
name|dstBuffer
parameter_list|,
name|size_t
name|maxDstSize
parameter_list|,
name|unsigned
name|compressionLevel
parameter_list|,
specifier|const
name|void
modifier|*
name|srcBuffer
parameter_list|,
specifier|const
name|size_t
modifier|*
name|fileSizes
parameter_list|,
name|unsigned
name|nbFiles
parameter_list|,
specifier|const
name|void
modifier|*
name|dictBuffer
parameter_list|,
name|size_t
name|dictBufferSize
parameter_list|,
name|unsigned
name|notificationLevel
parameter_list|)
block|{
name|U32
name|countLit
index|[
literal|256
index|]
decl_stmt|;
name|HUF_CREATE_STATIC_CTABLE
argument_list|(
name|hufTable
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|U32
name|offcodeCount
index|[
name|OFFCODE_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|short
name|offcodeNCount
index|[
name|OFFCODE_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|U32
name|offcodeMax
init|=
name|ZSTD_highbit32
argument_list|(
call|(
name|U32
call|)
argument_list|(
name|dictBufferSize
operator|+
literal|128
name|KB
argument_list|)
argument_list|)
decl_stmt|;
name|U32
name|matchLengthCount
index|[
name|MaxML
operator|+
literal|1
index|]
decl_stmt|;
name|short
name|matchLengthNCount
index|[
name|MaxML
operator|+
literal|1
index|]
decl_stmt|;
name|U32
name|litLengthCount
index|[
name|MaxLL
operator|+
literal|1
index|]
decl_stmt|;
name|short
name|litLengthNCount
index|[
name|MaxLL
operator|+
literal|1
index|]
decl_stmt|;
name|U32
name|repOffset
index|[
name|MAXREPOFFSET
index|]
decl_stmt|;
name|offsetCount_t
name|bestRepOffset
index|[
name|ZSTD_REP_NUM
operator|+
literal|1
index|]
decl_stmt|;
name|EStats_ress_t
name|esr
decl_stmt|;
name|ZSTD_parameters
name|params
decl_stmt|;
name|U32
name|u
decl_stmt|,
name|huffLog
init|=
literal|11
decl_stmt|,
name|Offlog
init|=
name|OffFSELog
decl_stmt|,
name|mlLog
init|=
name|MLFSELog
decl_stmt|,
name|llLog
init|=
name|LLFSELog
decl_stmt|,
name|total
decl_stmt|;
name|size_t
name|pos
init|=
literal|0
decl_stmt|,
name|errorCode
decl_stmt|;
name|size_t
name|eSize
init|=
literal|0
decl_stmt|;
name|size_t
specifier|const
name|totalSrcSize
init|=
name|ZDICT_totalSampleSize
argument_list|(
name|fileSizes
argument_list|,
name|nbFiles
argument_list|)
decl_stmt|;
name|size_t
specifier|const
name|averageSampleSize
init|=
name|totalSrcSize
operator|/
operator|(
name|nbFiles
operator|+
operator|!
name|nbFiles
operator|)
decl_stmt|;
name|BYTE
modifier|*
name|dstPtr
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dstBuffer
decl_stmt|;
comment|/* init */
name|esr
operator|.
name|ref
operator|=
name|ZSTD_createCCtx
argument_list|()
expr_stmt|;
name|esr
operator|.
name|zc
operator|=
name|ZSTD_createCCtx
argument_list|()
expr_stmt|;
name|esr
operator|.
name|workPlace
operator|=
name|malloc
argument_list|(
name|ZSTD_BLOCKSIZE_ABSOLUTEMAX
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|esr
operator|.
name|ref
operator|||
operator|!
name|esr
operator|.
name|zc
operator|||
operator|!
name|esr
operator|.
name|workPlace
condition|)
block|{
name|eSize
operator|=
name|ERROR
argument_list|(
name|memory_allocation
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"Not enough memory \n"
argument_list|)
expr_stmt|;
goto|goto
name|_cleanup
goto|;
block|}
if|if
condition|(
name|offcodeMax
operator|>
name|OFFCODE_MAX
condition|)
block|{
name|eSize
operator|=
name|ERROR
argument_list|(
name|dictionary_wrong
argument_list|)
expr_stmt|;
goto|goto
name|_cleanup
goto|;
block|}
comment|/* too large dictionary */
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
literal|256
condition|;
name|u
operator|++
control|)
name|countLit
index|[
name|u
index|]
operator|=
literal|1
expr_stmt|;
comment|/* any character must be described */
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<=
name|offcodeMax
condition|;
name|u
operator|++
control|)
name|offcodeCount
index|[
name|u
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<=
name|MaxML
condition|;
name|u
operator|++
control|)
name|matchLengthCount
index|[
name|u
index|]
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<=
name|MaxLL
condition|;
name|u
operator|++
control|)
name|litLengthCount
index|[
name|u
index|]
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
name|repOffset
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|repOffset
argument_list|)
argument_list|)
expr_stmt|;
name|repOffset
index|[
literal|1
index|]
operator|=
name|repOffset
index|[
literal|4
index|]
operator|=
name|repOffset
index|[
literal|8
index|]
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
name|bestRepOffset
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|bestRepOffset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|compressionLevel
operator|==
literal|0
condition|)
name|compressionLevel
operator|=
name|g_compressionLevel_default
expr_stmt|;
name|params
operator|=
name|ZSTD_getParams
argument_list|(
name|compressionLevel
argument_list|,
name|averageSampleSize
argument_list|,
name|dictBufferSize
argument_list|)
expr_stmt|;
block|{
name|size_t
specifier|const
name|beginResult
init|=
name|ZSTD_compressBegin_advanced
argument_list|(
name|esr
operator|.
name|ref
argument_list|,
name|dictBuffer
argument_list|,
name|dictBufferSize
argument_list|,
name|params
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZSTD_isError
argument_list|(
name|beginResult
argument_list|)
condition|)
block|{
name|eSize
operator|=
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"error : ZSTD_compressBegin_advanced failed \n"
argument_list|)
expr_stmt|;
goto|goto
name|_cleanup
goto|;
block|}
block|}
comment|/* collect stats on all files */
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<
name|nbFiles
condition|;
name|u
operator|++
control|)
block|{
name|ZDICT_countEStats
argument_list|(
name|esr
argument_list|,
name|params
argument_list|,
name|countLit
argument_list|,
name|offcodeCount
argument_list|,
name|matchLengthCount
argument_list|,
name|litLengthCount
argument_list|,
name|repOffset
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|srcBuffer
operator|+
name|pos
argument_list|,
name|fileSizes
index|[
name|u
index|]
argument_list|,
name|notificationLevel
argument_list|)
expr_stmt|;
name|pos
operator|+=
name|fileSizes
index|[
name|u
index|]
expr_stmt|;
block|}
comment|/* analyze */
name|errorCode
operator|=
name|HUF_buildCTable
argument_list|(
name|hufTable
argument_list|,
name|countLit
argument_list|,
literal|255
argument_list|,
name|huffLog
argument_list|)
expr_stmt|;
if|if
condition|(
name|HUF_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
block|{
name|eSize
operator|=
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"HUF_buildCTable error \n"
argument_list|)
expr_stmt|;
goto|goto
name|_cleanup
goto|;
block|}
name|huffLog
operator|=
operator|(
name|U32
operator|)
name|errorCode
expr_stmt|;
comment|/* looking for most common first offsets */
block|{
name|U32
name|offset
decl_stmt|;
for|for
control|(
name|offset
operator|=
literal|1
init|;
name|offset
operator|<
name|MAXREPOFFSET
condition|;
name|offset
operator|++
control|)
name|ZDICT_insertSortCount
argument_list|(
name|bestRepOffset
argument_list|,
name|offset
argument_list|,
name|repOffset
index|[
name|offset
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* note : the result of this phase should be used to better appreciate the impact on statistics */
name|total
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<=
name|offcodeMax
condition|;
name|u
operator|++
control|)
name|total
operator|+=
name|offcodeCount
index|[
name|u
index|]
expr_stmt|;
name|errorCode
operator|=
name|FSE_normalizeCount
argument_list|(
name|offcodeNCount
argument_list|,
name|Offlog
argument_list|,
name|offcodeCount
argument_list|,
name|total
argument_list|,
name|offcodeMax
argument_list|)
expr_stmt|;
if|if
condition|(
name|FSE_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
block|{
name|eSize
operator|=
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"FSE_normalizeCount error with offcodeCount \n"
argument_list|)
expr_stmt|;
goto|goto
name|_cleanup
goto|;
block|}
name|Offlog
operator|=
operator|(
name|U32
operator|)
name|errorCode
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<=
name|MaxML
condition|;
name|u
operator|++
control|)
name|total
operator|+=
name|matchLengthCount
index|[
name|u
index|]
expr_stmt|;
name|errorCode
operator|=
name|FSE_normalizeCount
argument_list|(
name|matchLengthNCount
argument_list|,
name|mlLog
argument_list|,
name|matchLengthCount
argument_list|,
name|total
argument_list|,
name|MaxML
argument_list|)
expr_stmt|;
if|if
condition|(
name|FSE_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
block|{
name|eSize
operator|=
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"FSE_normalizeCount error with matchLengthCount \n"
argument_list|)
expr_stmt|;
goto|goto
name|_cleanup
goto|;
block|}
name|mlLog
operator|=
operator|(
name|U32
operator|)
name|errorCode
expr_stmt|;
name|total
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|u
operator|=
literal|0
init|;
name|u
operator|<=
name|MaxLL
condition|;
name|u
operator|++
control|)
name|total
operator|+=
name|litLengthCount
index|[
name|u
index|]
expr_stmt|;
name|errorCode
operator|=
name|FSE_normalizeCount
argument_list|(
name|litLengthNCount
argument_list|,
name|llLog
argument_list|,
name|litLengthCount
argument_list|,
name|total
argument_list|,
name|MaxLL
argument_list|)
expr_stmt|;
if|if
condition|(
name|FSE_isError
argument_list|(
name|errorCode
argument_list|)
condition|)
block|{
name|eSize
operator|=
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"FSE_normalizeCount error with litLengthCount \n"
argument_list|)
expr_stmt|;
goto|goto
name|_cleanup
goto|;
block|}
name|llLog
operator|=
operator|(
name|U32
operator|)
name|errorCode
expr_stmt|;
comment|/* write result to buffer */
block|{
name|size_t
specifier|const
name|hhSize
init|=
name|HUF_writeCTable
argument_list|(
name|dstPtr
argument_list|,
name|maxDstSize
argument_list|,
name|hufTable
argument_list|,
literal|255
argument_list|,
name|huffLog
argument_list|)
decl_stmt|;
if|if
condition|(
name|HUF_isError
argument_list|(
name|hhSize
argument_list|)
condition|)
block|{
name|eSize
operator|=
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"HUF_writeCTable error \n"
argument_list|)
expr_stmt|;
goto|goto
name|_cleanup
goto|;
block|}
name|dstPtr
operator|+=
name|hhSize
expr_stmt|;
name|maxDstSize
operator|-=
name|hhSize
expr_stmt|;
name|eSize
operator|+=
name|hhSize
expr_stmt|;
block|}
block|{
name|size_t
specifier|const
name|ohSize
init|=
name|FSE_writeNCount
argument_list|(
name|dstPtr
argument_list|,
name|maxDstSize
argument_list|,
name|offcodeNCount
argument_list|,
name|OFFCODE_MAX
argument_list|,
name|Offlog
argument_list|)
decl_stmt|;
if|if
condition|(
name|FSE_isError
argument_list|(
name|ohSize
argument_list|)
condition|)
block|{
name|eSize
operator|=
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"FSE_writeNCount error with offcodeNCount \n"
argument_list|)
expr_stmt|;
goto|goto
name|_cleanup
goto|;
block|}
name|dstPtr
operator|+=
name|ohSize
expr_stmt|;
name|maxDstSize
operator|-=
name|ohSize
expr_stmt|;
name|eSize
operator|+=
name|ohSize
expr_stmt|;
block|}
block|{
name|size_t
specifier|const
name|mhSize
init|=
name|FSE_writeNCount
argument_list|(
name|dstPtr
argument_list|,
name|maxDstSize
argument_list|,
name|matchLengthNCount
argument_list|,
name|MaxML
argument_list|,
name|mlLog
argument_list|)
decl_stmt|;
if|if
condition|(
name|FSE_isError
argument_list|(
name|mhSize
argument_list|)
condition|)
block|{
name|eSize
operator|=
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"FSE_writeNCount error with matchLengthNCount \n"
argument_list|)
expr_stmt|;
goto|goto
name|_cleanup
goto|;
block|}
name|dstPtr
operator|+=
name|mhSize
expr_stmt|;
name|maxDstSize
operator|-=
name|mhSize
expr_stmt|;
name|eSize
operator|+=
name|mhSize
expr_stmt|;
block|}
block|{
name|size_t
specifier|const
name|lhSize
init|=
name|FSE_writeNCount
argument_list|(
name|dstPtr
argument_list|,
name|maxDstSize
argument_list|,
name|litLengthNCount
argument_list|,
name|MaxLL
argument_list|,
name|llLog
argument_list|)
decl_stmt|;
if|if
condition|(
name|FSE_isError
argument_list|(
name|lhSize
argument_list|)
condition|)
block|{
name|eSize
operator|=
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"FSE_writeNCount error with litlengthNCount \n"
argument_list|)
expr_stmt|;
goto|goto
name|_cleanup
goto|;
block|}
name|dstPtr
operator|+=
name|lhSize
expr_stmt|;
name|maxDstSize
operator|-=
name|lhSize
expr_stmt|;
name|eSize
operator|+=
name|lhSize
expr_stmt|;
block|}
if|if
condition|(
name|maxDstSize
operator|<
literal|12
condition|)
block|{
name|eSize
operator|=
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|1
argument_list|,
literal|"not enough space to write RepOffsets \n"
argument_list|)
expr_stmt|;
goto|goto
name|_cleanup
goto|;
block|}
if|#
directive|if
literal|0
block|MEM_writeLE32(dstPtr+0, bestRepOffset[0].offset);     MEM_writeLE32(dstPtr+4, bestRepOffset[1].offset);     MEM_writeLE32(dstPtr+8, bestRepOffset[2].offset);
else|#
directive|else
comment|/* at this stage, we don't use the result of "most common first offset",        as the impact of statistics is not properly evaluated */
name|MEM_writeLE32
argument_list|(
name|dstPtr
operator|+
literal|0
argument_list|,
name|repStartValue
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|MEM_writeLE32
argument_list|(
name|dstPtr
operator|+
literal|4
argument_list|,
name|repStartValue
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|MEM_writeLE32
argument_list|(
name|dstPtr
operator|+
literal|8
argument_list|,
name|repStartValue
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|//dstPtr += 12;
name|eSize
operator|+=
literal|12
expr_stmt|;
name|_cleanup
label|:
name|ZSTD_freeCCtx
argument_list|(
name|esr
operator|.
name|ref
argument_list|)
expr_stmt|;
name|ZSTD_freeCCtx
argument_list|(
name|esr
operator|.
name|zc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|esr
operator|.
name|workPlace
argument_list|)
expr_stmt|;
return|return
name|eSize
return|;
block|}
end_function

begin_function
name|size_t
name|ZDICT_finalizeDictionary
parameter_list|(
name|void
modifier|*
name|dictBuffer
parameter_list|,
name|size_t
name|dictBufferCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|customDictContent
parameter_list|,
name|size_t
name|dictContentSize
parameter_list|,
specifier|const
name|void
modifier|*
name|samplesBuffer
parameter_list|,
specifier|const
name|size_t
modifier|*
name|samplesSizes
parameter_list|,
name|unsigned
name|nbSamples
parameter_list|,
name|ZDICT_params_t
name|params
parameter_list|)
block|{
name|size_t
name|hSize
decl_stmt|;
define|#
directive|define
name|HBUFFSIZE
value|256
name|BYTE
name|header
index|[
name|HBUFFSIZE
index|]
decl_stmt|;
name|int
specifier|const
name|compressionLevel
init|=
operator|(
name|params
operator|.
name|compressionLevel
operator|<=
literal|0
operator|)
condition|?
name|g_compressionLevel_default
else|:
name|params
operator|.
name|compressionLevel
decl_stmt|;
name|U32
specifier|const
name|notificationLevel
init|=
name|params
operator|.
name|notificationLevel
decl_stmt|;
comment|/* check conditions */
if|if
condition|(
name|dictBufferCapacity
operator|<
name|dictContentSize
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
if|if
condition|(
name|dictContentSize
operator|<
name|ZDICT_CONTENTSIZE_MIN
condition|)
return|return
name|ERROR
argument_list|(
name|srcSize_wrong
argument_list|)
return|;
if|if
condition|(
name|dictBufferCapacity
operator|<
name|ZDICT_DICTSIZE_MIN
condition|)
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
comment|/* dictionary header */
name|MEM_writeLE32
argument_list|(
name|header
argument_list|,
name|ZSTD_DICT_MAGIC
argument_list|)
expr_stmt|;
block|{
name|U64
specifier|const
name|randomID
init|=
name|XXH64
argument_list|(
name|customDictContent
argument_list|,
name|dictContentSize
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|compliantID
init|=
operator|(
name|randomID
operator|%
operator|(
operator|(
literal|1U
operator|<<
literal|31
operator|)
operator|-
literal|32768
operator|)
operator|)
operator|+
literal|32768
decl_stmt|;
name|U32
specifier|const
name|dictID
init|=
name|params
operator|.
name|dictID
condition|?
name|params
operator|.
name|dictID
else|:
name|compliantID
decl_stmt|;
name|MEM_writeLE32
argument_list|(
name|header
operator|+
literal|4
argument_list|,
name|dictID
argument_list|)
expr_stmt|;
block|}
name|hSize
operator|=
literal|8
expr_stmt|;
comment|/* entropy tables */
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"\r%70s\r"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* clean display line */
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"statistics ... \n"
argument_list|)
expr_stmt|;
block|{
name|size_t
specifier|const
name|eSize
init|=
name|ZDICT_analyzeEntropy
argument_list|(
name|header
operator|+
name|hSize
argument_list|,
name|HBUFFSIZE
operator|-
name|hSize
argument_list|,
name|compressionLevel
argument_list|,
name|samplesBuffer
argument_list|,
name|samplesSizes
argument_list|,
name|nbSamples
argument_list|,
name|customDictContent
argument_list|,
name|dictContentSize
argument_list|,
name|notificationLevel
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZDICT_isError
argument_list|(
name|eSize
argument_list|)
condition|)
return|return
name|eSize
return|;
name|hSize
operator|+=
name|eSize
expr_stmt|;
block|}
comment|/* copy elements in final buffer ; note : src and dst buffer can overlap */
if|if
condition|(
name|hSize
operator|+
name|dictContentSize
operator|>
name|dictBufferCapacity
condition|)
name|dictContentSize
operator|=
name|dictBufferCapacity
operator|-
name|hSize
expr_stmt|;
block|{
name|size_t
specifier|const
name|dictSize
init|=
name|hSize
operator|+
name|dictContentSize
decl_stmt|;
name|char
modifier|*
name|dictEnd
init|=
operator|(
name|char
operator|*
operator|)
name|dictBuffer
operator|+
name|dictSize
decl_stmt|;
name|memmove
argument_list|(
name|dictEnd
operator|-
name|dictContentSize
argument_list|,
name|customDictContent
argument_list|,
name|dictContentSize
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|dictBuffer
argument_list|,
name|header
argument_list|,
name|hSize
argument_list|)
expr_stmt|;
return|return
name|dictSize
return|;
block|}
block|}
end_function

begin_function
name|size_t
name|ZDICT_addEntropyTablesFromBuffer_advanced
parameter_list|(
name|void
modifier|*
name|dictBuffer
parameter_list|,
name|size_t
name|dictContentSize
parameter_list|,
name|size_t
name|dictBufferCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|samplesBuffer
parameter_list|,
specifier|const
name|size_t
modifier|*
name|samplesSizes
parameter_list|,
name|unsigned
name|nbSamples
parameter_list|,
name|ZDICT_params_t
name|params
parameter_list|)
block|{
name|size_t
name|hSize
decl_stmt|;
name|int
specifier|const
name|compressionLevel
init|=
operator|(
name|params
operator|.
name|compressionLevel
operator|<=
literal|0
operator|)
condition|?
name|g_compressionLevel_default
else|:
name|params
operator|.
name|compressionLevel
decl_stmt|;
name|U32
specifier|const
name|notificationLevel
init|=
name|params
operator|.
name|notificationLevel
decl_stmt|;
comment|/* dictionary header */
name|MEM_writeLE32
argument_list|(
name|dictBuffer
argument_list|,
name|ZSTD_DICT_MAGIC
argument_list|)
expr_stmt|;
block|{
name|U64
specifier|const
name|randomID
init|=
name|XXH64
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dictBuffer
operator|+
name|dictBufferCapacity
operator|-
name|dictContentSize
argument_list|,
name|dictContentSize
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|compliantID
init|=
operator|(
name|randomID
operator|%
operator|(
operator|(
literal|1U
operator|<<
literal|31
operator|)
operator|-
literal|32768
operator|)
operator|)
operator|+
literal|32768
decl_stmt|;
name|U32
specifier|const
name|dictID
init|=
name|params
operator|.
name|dictID
condition|?
name|params
operator|.
name|dictID
else|:
name|compliantID
decl_stmt|;
name|MEM_writeLE32
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dictBuffer
operator|+
literal|4
argument_list|,
name|dictID
argument_list|)
expr_stmt|;
block|}
name|hSize
operator|=
literal|8
expr_stmt|;
comment|/* entropy tables */
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"\r%70s\r"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* clean display line */
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"statistics ... \n"
argument_list|)
expr_stmt|;
block|{
name|size_t
specifier|const
name|eSize
init|=
name|ZDICT_analyzeEntropy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dictBuffer
operator|+
name|hSize
argument_list|,
name|dictBufferCapacity
operator|-
name|hSize
argument_list|,
name|compressionLevel
argument_list|,
name|samplesBuffer
argument_list|,
name|samplesSizes
argument_list|,
name|nbSamples
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dictBuffer
operator|+
name|dictBufferCapacity
operator|-
name|dictContentSize
argument_list|,
name|dictContentSize
argument_list|,
name|notificationLevel
argument_list|)
decl_stmt|;
if|if
condition|(
name|ZDICT_isError
argument_list|(
name|eSize
argument_list|)
condition|)
return|return
name|eSize
return|;
name|hSize
operator|+=
name|eSize
expr_stmt|;
block|}
if|if
condition|(
name|hSize
operator|+
name|dictContentSize
operator|<
name|dictBufferCapacity
condition|)
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dictBuffer
operator|+
name|hSize
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dictBuffer
operator|+
name|dictBufferCapacity
operator|-
name|dictContentSize
argument_list|,
name|dictContentSize
argument_list|)
expr_stmt|;
return|return
name|MIN
argument_list|(
name|dictBufferCapacity
argument_list|,
name|hSize
operator|+
name|dictContentSize
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*! ZDICT_trainFromBuffer_unsafe() : *   Warning : `samplesBuffer` must be followed by noisy guard band. *   @return : size of dictionary, or an error code which can be tested with ZDICT_isError() */
end_comment

begin_function
name|size_t
name|ZDICT_trainFromBuffer_unsafe
parameter_list|(
name|void
modifier|*
name|dictBuffer
parameter_list|,
name|size_t
name|maxDictSize
parameter_list|,
specifier|const
name|void
modifier|*
name|samplesBuffer
parameter_list|,
specifier|const
name|size_t
modifier|*
name|samplesSizes
parameter_list|,
name|unsigned
name|nbSamples
parameter_list|,
name|ZDICT_params_t
name|params
parameter_list|)
block|{
name|U32
specifier|const
name|dictListSize
init|=
name|MAX
argument_list|(
name|MAX
argument_list|(
name|DICTLISTSIZE_DEFAULT
argument_list|,
name|nbSamples
argument_list|)
argument_list|,
call|(
name|U32
call|)
argument_list|(
name|maxDictSize
operator|/
literal|16
argument_list|)
argument_list|)
decl_stmt|;
name|dictItem
modifier|*
specifier|const
name|dictList
init|=
operator|(
name|dictItem
operator|*
operator|)
name|malloc
argument_list|(
name|dictListSize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|dictList
argument_list|)
argument_list|)
decl_stmt|;
name|unsigned
specifier|const
name|selectivity
init|=
name|params
operator|.
name|selectivityLevel
operator|==
literal|0
condition|?
name|g_selectivity_default
else|:
name|params
operator|.
name|selectivityLevel
decl_stmt|;
name|unsigned
specifier|const
name|minRep
init|=
operator|(
name|selectivity
operator|>
literal|30
operator|)
condition|?
name|MINRATIO
else|:
name|nbSamples
operator|>>
name|selectivity
decl_stmt|;
name|size_t
specifier|const
name|targetDictSize
init|=
name|maxDictSize
decl_stmt|;
name|size_t
specifier|const
name|samplesBuffSize
init|=
name|ZDICT_totalSampleSize
argument_list|(
name|samplesSizes
argument_list|,
name|nbSamples
argument_list|)
decl_stmt|;
name|size_t
name|dictSize
init|=
literal|0
decl_stmt|;
name|U32
specifier|const
name|notificationLevel
init|=
name|params
operator|.
name|notificationLevel
decl_stmt|;
comment|/* checks */
if|if
condition|(
operator|!
name|dictList
condition|)
return|return
name|ERROR
argument_list|(
name|memory_allocation
argument_list|)
return|;
if|if
condition|(
name|maxDictSize
operator|<=
name|g_provision_entropySize
operator|+
name|g_min_fast_dictContent
condition|)
block|{
name|free
argument_list|(
name|dictList
argument_list|)
expr_stmt|;
return|return
name|ERROR
argument_list|(
name|dstSize_tooSmall
argument_list|)
return|;
block|}
if|if
condition|(
name|samplesBuffSize
operator|<
name|ZDICT_MIN_SAMPLES_SIZE
condition|)
block|{
name|free
argument_list|(
name|dictList
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* not enough source to create dictionary */
comment|/* init */
name|ZDICT_initDictItem
argument_list|(
name|dictList
argument_list|)
expr_stmt|;
comment|/* build dictionary */
name|ZDICT_trainBuffer
argument_list|(
name|dictList
argument_list|,
name|dictListSize
argument_list|,
name|samplesBuffer
argument_list|,
name|samplesBuffSize
argument_list|,
name|samplesSizes
argument_list|,
name|nbSamples
argument_list|,
name|minRep
argument_list|,
name|notificationLevel
argument_list|)
expr_stmt|;
comment|/* display best matches */
if|if
condition|(
name|params
operator|.
name|notificationLevel
operator|>=
literal|3
condition|)
block|{
name|U32
specifier|const
name|nb
init|=
name|MIN
argument_list|(
literal|25
argument_list|,
name|dictList
index|[
literal|0
index|]
operator|.
name|pos
argument_list|)
decl_stmt|;
name|U32
specifier|const
name|dictContentSize
init|=
name|ZDICT_dictSize
argument_list|(
name|dictList
argument_list|)
decl_stmt|;
name|U32
name|u
decl_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|3
argument_list|,
literal|"\n %u segments found, of total size %u \n"
argument_list|,
name|dictList
index|[
literal|0
index|]
operator|.
name|pos
operator|-
literal|1
argument_list|,
name|dictContentSize
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|3
argument_list|,
literal|"list %u best segments \n"
argument_list|,
name|nb
operator|-
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|u
operator|=
literal|1
init|;
name|u
operator|<
name|nb
condition|;
name|u
operator|++
control|)
block|{
name|U32
specifier|const
name|pos
init|=
name|dictList
index|[
name|u
index|]
operator|.
name|pos
decl_stmt|;
name|U32
specifier|const
name|length
init|=
name|dictList
index|[
name|u
index|]
operator|.
name|length
decl_stmt|;
name|U32
specifier|const
name|printedLength
init|=
name|MIN
argument_list|(
literal|40
argument_list|,
name|length
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|pos
operator|>
name|samplesBuffSize
operator|)
operator|||
operator|(
operator|(
name|pos
operator|+
name|length
operator|)
operator|>
name|samplesBuffSize
operator|)
condition|)
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
comment|/* should never happen */
name|DISPLAYLEVEL
argument_list|(
literal|3
argument_list|,
literal|"%3u:%3u bytes at pos %8u, savings %7u bytes |"
argument_list|,
name|u
argument_list|,
name|length
argument_list|,
name|pos
argument_list|,
name|dictList
index|[
name|u
index|]
operator|.
name|savings
argument_list|)
expr_stmt|;
name|ZDICT_printHex
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|samplesBuffer
operator|+
name|pos
argument_list|,
name|printedLength
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|3
argument_list|,
literal|"| \n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* create dictionary */
block|{
name|U32
name|dictContentSize
init|=
name|ZDICT_dictSize
argument_list|(
name|dictList
argument_list|)
decl_stmt|;
if|if
condition|(
name|dictContentSize
operator|<
name|targetDictSize
operator|/
literal|3
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"!  warning : selected content significantly smaller than requested (%u< %u) \n"
argument_list|,
name|dictContentSize
argument_list|,
operator|(
name|U32
operator|)
name|maxDictSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|minRep
operator|>
name|MINRATIO
condition|)
block|{
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"!  consider increasing selectivity to produce larger dictionary (-s%u) \n"
argument_list|,
name|selectivity
operator|+
literal|1
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"!  note : larger dictionaries are not necessarily better, test its efficiency on samples \n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|samplesBuffSize
operator|<
literal|10
operator|*
name|targetDictSize
condition|)
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"!  consider increasing the number of samples (total size : %u MB)\n"
argument_list|,
call|(
name|U32
call|)
argument_list|(
name|samplesBuffSize
operator|>>
literal|20
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dictContentSize
operator|>
name|targetDictSize
operator|*
literal|3
operator|)
operator|&&
operator|(
name|nbSamples
operator|>
literal|2
operator|*
name|MINRATIO
operator|)
operator|&&
operator|(
name|selectivity
operator|>
literal|1
operator|)
condition|)
block|{
name|U32
name|proposedSelectivity
init|=
name|selectivity
operator|-
literal|1
decl_stmt|;
while|while
condition|(
operator|(
name|nbSamples
operator|>>
name|proposedSelectivity
operator|)
operator|<=
name|MINRATIO
condition|)
block|{
name|proposedSelectivity
operator|--
expr_stmt|;
block|}
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"!  note : calculated dictionary significantly larger than requested (%u> %u) \n"
argument_list|,
name|dictContentSize
argument_list|,
operator|(
name|U32
operator|)
name|maxDictSize
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"!  consider increasing dictionary size, or produce denser dictionary (-s%u) \n"
argument_list|,
name|proposedSelectivity
argument_list|)
expr_stmt|;
name|DISPLAYLEVEL
argument_list|(
literal|2
argument_list|,
literal|"!  always test dictionary efficiency on samples \n"
argument_list|)
expr_stmt|;
block|}
comment|/* limit dictionary size */
block|{
name|U32
specifier|const
name|max
init|=
name|dictList
operator|->
name|pos
decl_stmt|;
comment|/* convention : nb of useful elts within dictList */
name|U32
name|currentSize
init|=
literal|0
decl_stmt|;
name|U32
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|<
name|max
condition|;
name|n
operator|++
control|)
block|{
name|currentSize
operator|+=
name|dictList
index|[
name|n
index|]
operator|.
name|length
expr_stmt|;
if|if
condition|(
name|currentSize
operator|>
name|targetDictSize
condition|)
block|{
name|currentSize
operator|-=
name|dictList
index|[
name|n
index|]
operator|.
name|length
expr_stmt|;
break|break;
block|}
block|}
name|dictList
operator|->
name|pos
operator|=
name|n
expr_stmt|;
name|dictContentSize
operator|=
name|currentSize
expr_stmt|;
block|}
comment|/* build dict content */
block|{
name|U32
name|u
decl_stmt|;
name|BYTE
modifier|*
name|ptr
init|=
operator|(
name|BYTE
operator|*
operator|)
name|dictBuffer
operator|+
name|maxDictSize
decl_stmt|;
for|for
control|(
name|u
operator|=
literal|1
init|;
name|u
operator|<
name|dictList
operator|->
name|pos
condition|;
name|u
operator|++
control|)
block|{
name|U32
name|l
init|=
name|dictList
index|[
name|u
index|]
operator|.
name|length
decl_stmt|;
name|ptr
operator|-=
name|l
expr_stmt|;
if|if
condition|(
name|ptr
operator|<
operator|(
name|BYTE
operator|*
operator|)
name|dictBuffer
condition|)
block|{
name|free
argument_list|(
name|dictList
argument_list|)
expr_stmt|;
return|return
name|ERROR
argument_list|(
name|GENERIC
argument_list|)
return|;
block|}
comment|/* should not happen */
name|memcpy
argument_list|(
name|ptr
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|samplesBuffer
operator|+
name|dictList
index|[
name|u
index|]
operator|.
name|pos
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
block|}
name|dictSize
operator|=
name|ZDICT_addEntropyTablesFromBuffer_advanced
argument_list|(
name|dictBuffer
argument_list|,
name|dictContentSize
argument_list|,
name|maxDictSize
argument_list|,
name|samplesBuffer
argument_list|,
name|samplesSizes
argument_list|,
name|nbSamples
argument_list|,
name|params
argument_list|)
expr_stmt|;
block|}
comment|/* clean up */
name|free
argument_list|(
name|dictList
argument_list|)
expr_stmt|;
return|return
name|dictSize
return|;
block|}
end_function

begin_comment
comment|/* issue : samplesBuffer need to be followed by a noisy guard band. *  work around : duplicate the buffer, and add the noise */
end_comment

begin_function
name|size_t
name|ZDICT_trainFromBuffer_advanced
parameter_list|(
name|void
modifier|*
name|dictBuffer
parameter_list|,
name|size_t
name|dictBufferCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|samplesBuffer
parameter_list|,
specifier|const
name|size_t
modifier|*
name|samplesSizes
parameter_list|,
name|unsigned
name|nbSamples
parameter_list|,
name|ZDICT_params_t
name|params
parameter_list|)
block|{
name|size_t
name|result
decl_stmt|;
name|void
modifier|*
name|newBuff
decl_stmt|;
name|size_t
specifier|const
name|sBuffSize
init|=
name|ZDICT_totalSampleSize
argument_list|(
name|samplesSizes
argument_list|,
name|nbSamples
argument_list|)
decl_stmt|;
if|if
condition|(
name|sBuffSize
operator|<
name|ZDICT_MIN_SAMPLES_SIZE
condition|)
return|return
literal|0
return|;
comment|/* not enough content => no dictionary */
name|newBuff
operator|=
name|malloc
argument_list|(
name|sBuffSize
operator|+
name|NOISELENGTH
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newBuff
condition|)
return|return
name|ERROR
argument_list|(
name|memory_allocation
argument_list|)
return|;
name|memcpy
argument_list|(
name|newBuff
argument_list|,
name|samplesBuffer
argument_list|,
name|sBuffSize
argument_list|)
expr_stmt|;
name|ZDICT_fillNoise
argument_list|(
operator|(
name|char
operator|*
operator|)
name|newBuff
operator|+
name|sBuffSize
argument_list|,
name|NOISELENGTH
argument_list|)
expr_stmt|;
comment|/* guard band, for end of buffer condition */
name|result
operator|=
name|ZDICT_trainFromBuffer_unsafe
argument_list|(
name|dictBuffer
argument_list|,
name|dictBufferCapacity
argument_list|,
name|newBuff
argument_list|,
name|samplesSizes
argument_list|,
name|nbSamples
argument_list|,
name|params
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|newBuff
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|size_t
name|ZDICT_trainFromBuffer
parameter_list|(
name|void
modifier|*
name|dictBuffer
parameter_list|,
name|size_t
name|dictBufferCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|samplesBuffer
parameter_list|,
specifier|const
name|size_t
modifier|*
name|samplesSizes
parameter_list|,
name|unsigned
name|nbSamples
parameter_list|)
block|{
name|ZDICT_params_t
name|params
decl_stmt|;
name|memset
argument_list|(
operator|&
name|params
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|params
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ZDICT_trainFromBuffer_advanced
argument_list|(
name|dictBuffer
argument_list|,
name|dictBufferCapacity
argument_list|,
name|samplesBuffer
argument_list|,
name|samplesSizes
argument_list|,
name|nbSamples
argument_list|,
name|params
argument_list|)
return|;
block|}
end_function

begin_function
name|size_t
name|ZDICT_addEntropyTablesFromBuffer
parameter_list|(
name|void
modifier|*
name|dictBuffer
parameter_list|,
name|size_t
name|dictContentSize
parameter_list|,
name|size_t
name|dictBufferCapacity
parameter_list|,
specifier|const
name|void
modifier|*
name|samplesBuffer
parameter_list|,
specifier|const
name|size_t
modifier|*
name|samplesSizes
parameter_list|,
name|unsigned
name|nbSamples
parameter_list|)
block|{
name|ZDICT_params_t
name|params
decl_stmt|;
name|memset
argument_list|(
operator|&
name|params
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|params
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ZDICT_addEntropyTablesFromBuffer_advanced
argument_list|(
name|dictBuffer
argument_list|,
name|dictContentSize
argument_list|,
name|dictBufferCapacity
argument_list|,
name|samplesBuffer
argument_list|,
name|samplesSizes
argument_list|,
name|nbSamples
argument_list|,
name|params
argument_list|)
return|;
block|}
end_function

end_unit

