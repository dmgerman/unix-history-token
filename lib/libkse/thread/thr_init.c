begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2003 Daniel M. Eischen<deischen@freebsd.org>  * Copyright (c) 1995-1998 John Birrell<jb@cimlogic.com.au>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by John Birrell.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY JOHN BIRRELL AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/* Allocate space for global thread variables here: */
end_comment

begin_define
define|#
directive|define
name|GLOBAL_PTHREAD_PRIVATE
end_define

begin_include
include|#
directive|include
file|"namespace.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/event.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/ttycom.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|<pthread_np.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"un-namespace.h"
end_include

begin_include
include|#
directive|include
file|"libc_private.h"
end_include

begin_include
include|#
directive|include
file|"thr_private.h"
end_include

begin_include
include|#
directive|include
file|"ksd.h"
end_include

begin_function_decl
name|int
name|__pthread_cond_wait
parameter_list|(
name|pthread_cond_t
modifier|*
parameter_list|,
name|pthread_mutex_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|__pthread_mutex_lock
parameter_list|(
name|pthread_mutex_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|__pthread_mutex_trylock
parameter_list|(
name|pthread_mutex_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|_thread_init_hack
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_private
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_main_thread
parameter_list|(
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * All weak references used within libc should be in this table.  * This is so that static libraries will work.  */
end_comment

begin_decl_stmt
specifier|static
name|void
modifier|*
name|references
index|[]
init|=
block|{
operator|&
name|_accept
block|,
operator|&
name|_bind
block|,
operator|&
name|_close
block|,
operator|&
name|_connect
block|,
operator|&
name|_dup
block|,
operator|&
name|_dup2
block|,
operator|&
name|_execve
block|,
operator|&
name|_fcntl
block|,
operator|&
name|_flock
block|,
operator|&
name|_flockfile
block|,
operator|&
name|_fstat
block|,
operator|&
name|_fstatfs
block|,
operator|&
name|_fsync
block|,
operator|&
name|_funlockfile
block|,
operator|&
name|_getdirentries
block|,
operator|&
name|_getlogin
block|,
operator|&
name|_getpeername
block|,
operator|&
name|_getsockname
block|,
operator|&
name|_getsockopt
block|,
operator|&
name|_ioctl
block|,
operator|&
name|_kevent
block|,
operator|&
name|_listen
block|,
operator|&
name|_nanosleep
block|,
operator|&
name|_open
block|,
operator|&
name|_pthread_getspecific
block|,
operator|&
name|_pthread_key_create
block|,
operator|&
name|_pthread_key_delete
block|,
operator|&
name|_pthread_mutex_destroy
block|,
operator|&
name|_pthread_mutex_init
block|,
operator|&
name|_pthread_mutex_lock
block|,
operator|&
name|_pthread_mutex_trylock
block|,
operator|&
name|_pthread_mutex_unlock
block|,
operator|&
name|_pthread_mutexattr_init
block|,
operator|&
name|_pthread_mutexattr_destroy
block|,
operator|&
name|_pthread_mutexattr_settype
block|,
operator|&
name|_pthread_once
block|,
operator|&
name|_pthread_setspecific
block|,
operator|&
name|_read
block|,
operator|&
name|_readv
block|,
operator|&
name|_recvfrom
block|,
operator|&
name|_recvmsg
block|,
operator|&
name|_select
block|,
operator|&
name|_sendmsg
block|,
operator|&
name|_sendto
block|,
operator|&
name|_setsockopt
block|,
operator|&
name|_sigaction
block|,
operator|&
name|_sigprocmask
block|,
operator|&
name|_sigsuspend
block|,
operator|&
name|_socket
block|,
operator|&
name|_socketpair
block|,
operator|&
name|_thread_init_hack
block|,
operator|&
name|_wait4
block|,
operator|&
name|_write
block|,
operator|&
name|_writev
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * These are needed when linking statically.  All references within  * libgcc (and in the future libc) to these routines are weak, but  * if they are not (strongly) referenced by the application or other  * libraries, then the actual functions will not be loaded.  */
end_comment

begin_decl_stmt
specifier|static
name|void
modifier|*
name|libgcc_references
index|[]
init|=
block|{
operator|&
name|_pthread_once
block|,
operator|&
name|_pthread_key_create
block|,
operator|&
name|_pthread_key_delete
block|,
operator|&
name|_pthread_getspecific
block|,
operator|&
name|_pthread_setspecific
block|,
operator|&
name|_pthread_mutex_init
block|,
operator|&
name|_pthread_mutex_destroy
block|,
operator|&
name|_pthread_mutex_lock
block|,
operator|&
name|_pthread_mutex_trylock
block|,
operator|&
name|_pthread_mutex_unlock
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|DUAL_ENTRY
parameter_list|(
name|entry
parameter_list|)
define|\
value|(pthread_func_t)entry, (pthread_func_t)entry
end_define

begin_decl_stmt
specifier|static
name|pthread_func_t
name|jmp_table
index|[]
index|[
literal|2
index|]
init|=
block|{
block|{
name|DUAL_ENTRY
argument_list|(
argument|_pthread_cond_broadcast
argument_list|)
block|}
block|,
comment|/* PJT_COND_BROADCAST */
block|{
name|DUAL_ENTRY
argument_list|(
argument|_pthread_cond_destroy
argument_list|)
block|}
block|,
comment|/* PJT_COND_DESTROY */
block|{
name|DUAL_ENTRY
argument_list|(
argument|_pthread_cond_init
argument_list|)
block|}
block|,
comment|/* PJT_COND_INIT */
block|{
name|DUAL_ENTRY
argument_list|(
argument|_pthread_cond_signal
argument_list|)
block|}
block|,
comment|/* PJT_COND_SIGNAL */
block|{
operator|(
name|pthread_func_t
operator|)
name|__pthread_cond_wait
block|,
operator|(
name|pthread_func_t
operator|)
name|_pthread_cond_wait
block|}
block|,
comment|/* PJT_COND_WAIT */
block|{
name|DUAL_ENTRY
argument_list|(
argument|_pthread_getspecific
argument_list|)
block|}
block|,
comment|/* PJT_GETSPECIFIC */
block|{
name|DUAL_ENTRY
argument_list|(
argument|_pthread_key_create
argument_list|)
block|}
block|,
comment|/* PJT_KEY_CREATE */
block|{
name|DUAL_ENTRY
argument_list|(
argument|_pthread_key_delete
argument_list|)
block|}
block|,
comment|/* PJT_KEY_DELETE*/
block|{
name|DUAL_ENTRY
argument_list|(
argument|_pthread_main_np
argument_list|)
block|}
block|,
comment|/* PJT_MAIN_NP */
block|{
name|DUAL_ENTRY
argument_list|(
argument|_pthread_mutex_destroy
argument_list|)
block|}
block|,
comment|/* PJT_MUTEX_DESTROY */
block|{
name|DUAL_ENTRY
argument_list|(
argument|_pthread_mutex_init
argument_list|)
block|}
block|,
comment|/* PJT_MUTEX_INIT */
block|{
operator|(
name|pthread_func_t
operator|)
name|__pthread_mutex_lock
block|,
operator|(
name|pthread_func_t
operator|)
name|_pthread_mutex_lock
block|}
block|,
comment|/* PJT_MUTEX_LOCK */
block|{
operator|(
name|pthread_func_t
operator|)
name|__pthread_mutex_trylock
block|,
operator|(
name|pthread_func_t
operator|)
name|_pthread_mutex_trylock
block|}
block|,
comment|/* PJT_MUTEX_TRYLOCK */
block|{
name|DUAL_ENTRY
argument_list|(
argument|_pthread_mutex_unlock
argument_list|)
block|}
block|,
comment|/* PJT_MUTEX_UNLOCK */
block|{
name|DUAL_ENTRY
argument_list|(
argument|_pthread_mutexattr_destroy
argument_list|)
block|}
block|,
comment|/* PJT_MUTEXATTR_DESTROY */
block|{
name|DUAL_ENTRY
argument_list|(
argument|_pthread_mutexattr_init
argument_list|)
block|}
block|,
comment|/* PJT_MUTEXATTR_INIT */
block|{
name|DUAL_ENTRY
argument_list|(
argument|_pthread_mutexattr_settype
argument_list|)
block|}
block|,
comment|/* PJT_MUTEXATTR_SETTYPE */
block|{
name|DUAL_ENTRY
argument_list|(
argument|_pthread_once
argument_list|)
block|}
block|,
comment|/* PJT_ONCE */
block|{
name|DUAL_ENTRY
argument_list|(
argument|_pthread_rwlock_destroy
argument_list|)
block|}
block|,
comment|/* PJT_RWLOCK_DESTROY */
block|{
name|DUAL_ENTRY
argument_list|(
argument|_pthread_rwlock_init
argument_list|)
block|}
block|,
comment|/* PJT_RWLOCK_INIT */
block|{
name|DUAL_ENTRY
argument_list|(
argument|_pthread_rwlock_rdlock
argument_list|)
block|}
block|,
comment|/* PJT_RWLOCK_RDLOCK */
block|{
name|DUAL_ENTRY
argument_list|(
argument|_pthread_rwlock_tryrdlock
argument_list|)
block|}
block|,
comment|/* PJT_RWLOCK_TRYRDLOCK */
block|{
name|DUAL_ENTRY
argument_list|(
argument|_pthread_rwlock_trywrlock
argument_list|)
block|}
block|,
comment|/* PJT_RWLOCK_TRYWRLOCK */
block|{
name|DUAL_ENTRY
argument_list|(
argument|_pthread_rwlock_unlock
argument_list|)
block|}
block|,
comment|/* PJT_RWLOCK_UNLOCK */
block|{
name|DUAL_ENTRY
argument_list|(
argument|_pthread_rwlock_wrlock
argument_list|)
block|}
block|,
comment|/* PJT_RWLOCK_WRLOCK */
block|{
name|DUAL_ENTRY
argument_list|(
argument|_pthread_self
argument_list|)
block|}
block|,
comment|/* PJT_SELF */
block|{
name|DUAL_ENTRY
argument_list|(
argument|_pthread_setspecific
argument_list|)
block|}
block|,
comment|/* PJT_SETSPECIFIC */
block|{
name|DUAL_ENTRY
argument_list|(
argument|_pthread_sigmask
argument_list|)
block|}
comment|/* PJT_SIGMASK */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|init_once
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Threaded process initialization.  *  * This is only called under two conditions:  *  *   1) Some thread routines have detected that the library hasn't yet  *      been initialized (_thr_initial == NULL&& curthread == NULL), or  *  *   2) An explicit call to reinitialize after a fork (indicated  *      by curthread != NULL)  */
end_comment

begin_function
name|void
name|_libpthread_init
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
comment|/* Check if this function has already been called: */
if|if
condition|(
operator|(
name|_thr_initial
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|curthread
operator|==
name|NULL
operator|)
condition|)
comment|/* Only initialize the threaded application once. */
return|return;
comment|/* 	 * Make gcc quiescent about {,libgcc_}references not being 	 * referenced: 	 */
if|if
condition|(
operator|(
name|references
index|[
literal|0
index|]
operator|==
name|NULL
operator|)
operator|||
operator|(
name|libgcc_references
index|[
literal|0
index|]
operator|==
name|NULL
operator|)
condition|)
name|PANIC
argument_list|(
literal|"Failed loading mandatory references in _thread_init"
argument_list|)
expr_stmt|;
comment|/* 	 * Check the size of the jump table to make sure it is preset 	 * with the correct number of entries. 	 */
if|if
condition|(
sizeof|sizeof
argument_list|(
name|jmp_table
argument_list|)
operator|!=
operator|(
sizeof|sizeof
argument_list|(
name|pthread_func_t
argument_list|)
operator|*
name|PJT_MAX
operator|*
literal|2
operator|)
condition|)
name|PANIC
argument_list|(
literal|"Thread jump table not properly initialized"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|__thr_jtable
argument_list|,
name|jmp_table
argument_list|,
sizeof|sizeof
argument_list|(
name|jmp_table
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Check for the special case of this process running as 	 * or in place of init as pid = 1: 	 */
if|if
condition|(
operator|(
name|_thr_pid
operator|=
name|getpid
argument_list|()
operator|)
operator|==
literal|1
condition|)
block|{
comment|/* 		 * Setup a new session for this process which is 		 * assumed to be running as root. 		 */
if|if
condition|(
name|setsid
argument_list|()
operator|==
operator|-
literal|1
condition|)
name|PANIC
argument_list|(
literal|"Can't set session ID"
argument_list|)
expr_stmt|;
if|if
condition|(
name|revoke
argument_list|(
name|_PATH_CONSOLE
argument_list|)
operator|!=
literal|0
condition|)
name|PANIC
argument_list|(
literal|"Can't revoke console"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|__sys_open
argument_list|(
name|_PATH_CONSOLE
argument_list|,
name|O_RDWR
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|PANIC
argument_list|(
literal|"Can't open console"
argument_list|)
expr_stmt|;
if|if
condition|(
name|setlogin
argument_list|(
literal|"root"
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|PANIC
argument_list|(
literal|"Can't set login to root"
argument_list|)
expr_stmt|;
if|if
condition|(
name|__sys_ioctl
argument_list|(
name|fd
argument_list|,
name|TIOCSCTTY
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|PANIC
argument_list|(
literal|"Can't set controlling terminal"
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize pthread private data. */
name|init_private
argument_list|()
expr_stmt|;
name|_kse_init
argument_list|()
expr_stmt|;
comment|/* Initialize the initial kse and kseg. */
name|_kse_initial
operator|=
name|_kse_alloc
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|_kse_initial
operator|==
name|NULL
condition|)
name|PANIC
argument_list|(
literal|"Can't allocate initial kse."
argument_list|)
expr_stmt|;
name|_kse_initial
operator|->
name|k_kseg
operator|=
name|_kseg_alloc
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|_kse_initial
operator|->
name|k_kseg
operator|==
name|NULL
condition|)
name|PANIC
argument_list|(
literal|"Can't allocate initial kseg."
argument_list|)
expr_stmt|;
name|_kse_initial
operator|->
name|k_schedq
operator|=
operator|&
name|_kse_initial
operator|->
name|k_kseg
operator|->
name|kg_schedq
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|_kse_initial
operator|->
name|k_kseg
operator|->
name|kg_kseq
argument_list|,
name|_kse_initial
argument_list|,
name|k_kgqe
argument_list|)
expr_stmt|;
name|_kse_initial
operator|->
name|k_kseg
operator|->
name|kg_ksecount
operator|=
literal|1
expr_stmt|;
comment|/* Set the initial thread. */
if|if
condition|(
name|curthread
operator|==
name|NULL
condition|)
block|{
comment|/* Create and initialize the initial thread. */
name|curthread
operator|=
name|_thr_alloc
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|curthread
operator|==
name|NULL
condition|)
name|PANIC
argument_list|(
literal|"Can't allocate initial thread"
argument_list|)
expr_stmt|;
name|_thr_initial
operator|=
name|curthread
expr_stmt|;
name|init_main_thread
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The initial thread is the current thread.  It is 		 * assumed that the current thread is already initialized 		 * because it is left over from a fork(). 		 */
name|_thr_initial
operator|=
name|curthread
expr_stmt|;
block|}
name|_kse_initial
operator|->
name|k_kseg
operator|->
name|kg_threadcount
operator|=
literal|0
expr_stmt|;
name|_thr_initial
operator|->
name|kse
operator|=
name|_kse_initial
expr_stmt|;
name|_thr_initial
operator|->
name|kseg
operator|=
name|_kse_initial
operator|->
name|k_kseg
expr_stmt|;
name|_thr_initial
operator|->
name|active
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Add the thread to the thread list and to the KSEG's thread          * queue. 	 */
name|THR_LIST_ADD
argument_list|(
name|_thr_initial
argument_list|)
expr_stmt|;
name|KSEG_THRQ_ADD
argument_list|(
name|_kse_initial
operator|->
name|k_kseg
argument_list|,
name|_thr_initial
argument_list|)
expr_stmt|;
comment|/* Setup the KSE/thread specific data for the current KSE/thread. */
if|if
condition|(
name|_ksd_setprivate
argument_list|(
operator|&
name|_thr_initial
operator|->
name|kse
operator|->
name|k_ksd
argument_list|)
operator|!=
literal|0
condition|)
name|PANIC
argument_list|(
literal|"Can't set initial KSE specific data"
argument_list|)
expr_stmt|;
name|_set_curkse
argument_list|(
name|_thr_initial
operator|->
name|kse
argument_list|)
expr_stmt|;
name|_thr_initial
operator|->
name|kse
operator|->
name|k_curthread
operator|=
name|_thr_initial
expr_stmt|;
name|_thr_initial
operator|->
name|kse
operator|->
name|k_flags
operator||=
name|KF_INITIALIZED
expr_stmt|;
name|_kse_initial
operator|->
name|k_curthread
operator|=
name|_thr_initial
expr_stmt|;
name|_thr_rtld_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function and pthread_create() do a lot of the same things.  * It'd be nice to consolidate the common stuff in one place.  */
end_comment

begin_function
specifier|static
name|void
name|init_main_thread
parameter_list|(
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Zero the initial thread structure. */
name|p
operator|=
name|thread
operator|->
name|alloc_addr
expr_stmt|;
name|memset
argument_list|(
name|thread
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pthread
argument_list|)
argument_list|)
expr_stmt|;
name|thread
operator|->
name|alloc_addr
operator|=
name|p
expr_stmt|;
comment|/* Setup the thread attributes. */
name|thread
operator|->
name|attr
operator|=
name|_pthread_attr_default
expr_stmt|;
comment|/* 	 * Set up the thread stack. 	 * 	 * Create a red zone below the main stack.  All other stacks 	 * are constrained to a maximum size by the parameters 	 * passed to mmap(), but this stack is only limited by 	 * resource limits, so this stack needs an explicitly mapped 	 * red zone to protect the thread stack that is just beyond. 	 */
if|if
condition|(
name|mmap
argument_list|(
operator|(
name|void
operator|*
operator|)
name|_usrstack
operator|-
name|THR_STACK_INITIAL
operator|-
name|_thr_guard_default
argument_list|,
name|_thr_guard_default
argument_list|,
literal|0
argument_list|,
name|MAP_ANON
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
operator|==
name|MAP_FAILED
condition|)
name|PANIC
argument_list|(
literal|"Cannot allocate red zone for initial thread"
argument_list|)
expr_stmt|;
comment|/* 	 * Mark the stack as an application supplied stack so that it 	 * isn't deallocated. 	 * 	 * XXX - I'm not sure it would hurt anything to deallocate 	 *       the main thread stack because deallocation doesn't 	 *       actually free() it; it just puts it in the free 	 *       stack queue for later reuse. 	 */
name|thread
operator|->
name|attr
operator|.
name|stackaddr_attr
operator|=
operator|(
name|void
operator|*
operator|)
name|_usrstack
operator|-
name|THR_STACK_INITIAL
expr_stmt|;
name|thread
operator|->
name|attr
operator|.
name|stacksize_attr
operator|=
name|THR_STACK_INITIAL
expr_stmt|;
name|thread
operator|->
name|attr
operator|.
name|guardsize_attr
operator|=
name|_thr_guard_default
expr_stmt|;
name|thread
operator|->
name|attr
operator|.
name|flags
operator||=
name|THR_STACK_USER
expr_stmt|;
comment|/* 	 * Write a magic value to the thread structure 	 * to help identify valid ones: 	 */
name|thread
operator|->
name|magic
operator|=
name|THR_MAGIC
expr_stmt|;
name|thread
operator|->
name|slice_usec
operator|=
operator|-
literal|1
expr_stmt|;
name|thread
operator|->
name|cancelflags
operator|=
name|PTHREAD_CANCEL_ENABLE
operator||
name|PTHREAD_CANCEL_DEFERRED
expr_stmt|;
name|thread
operator|->
name|name
operator|=
name|strdup
argument_list|(
literal|"initial thread"
argument_list|)
expr_stmt|;
comment|/* Initialize the thread for signals: */
name|sigemptyset
argument_list|(
operator|&
name|thread
operator|->
name|sigmask
argument_list|)
expr_stmt|;
comment|/* 	 * Set up the thread mailbox.  The threads saved context 	 * is also in the mailbox. 	 */
name|thread
operator|->
name|tmbx
operator|.
name|tm_udata
operator|=
name|thread
expr_stmt|;
name|thread
operator|->
name|tmbx
operator|.
name|tm_context
operator|.
name|uc_sigmask
operator|=
name|thread
operator|->
name|sigmask
expr_stmt|;
name|thread
operator|->
name|tmbx
operator|.
name|tm_context
operator|.
name|uc_stack
operator|.
name|ss_size
operator|=
name|thread
operator|->
name|attr
operator|.
name|stacksize_attr
expr_stmt|;
name|thread
operator|->
name|tmbx
operator|.
name|tm_context
operator|.
name|uc_stack
operator|.
name|ss_sp
operator|=
name|thread
operator|->
name|attr
operator|.
name|stackaddr_attr
expr_stmt|;
comment|/* Default the priority of the initial thread: */
name|thread
operator|->
name|base_priority
operator|=
name|THR_DEFAULT_PRIORITY
expr_stmt|;
name|thread
operator|->
name|active_priority
operator|=
name|THR_DEFAULT_PRIORITY
expr_stmt|;
name|thread
operator|->
name|inherited_priority
operator|=
literal|0
expr_stmt|;
comment|/* Initialize the mutex queue: */
name|TAILQ_INIT
argument_list|(
operator|&
name|thread
operator|->
name|mutexq
argument_list|)
expr_stmt|;
comment|/* Initialize thread locking. */
if|if
condition|(
name|_lock_init
argument_list|(
operator|&
name|thread
operator|->
name|lock
argument_list|,
name|LCK_ADAPTIVE
argument_list|,
name|_thr_lock_wait
argument_list|,
name|_thr_lock_wakeup
argument_list|)
operator|!=
literal|0
condition|)
name|PANIC
argument_list|(
literal|"Cannot initialize initial thread lock"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_THR_LOCKLEVEL
condition|;
name|i
operator|++
control|)
block|{
name|_lockuser_init
argument_list|(
operator|&
name|thread
operator|->
name|lockusers
index|[
name|i
index|]
argument_list|,
operator|(
name|void
operator|*
operator|)
name|thread
argument_list|)
expr_stmt|;
name|_LCK_SET_PRIVATE2
argument_list|(
operator|&
name|thread
operator|->
name|lockusers
index|[
name|i
index|]
argument_list|,
operator|(
name|void
operator|*
operator|)
name|thread
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize hooks in the thread structure: */
name|thread
operator|->
name|specific
operator|=
name|NULL
expr_stmt|;
name|thread
operator|->
name|cleanup
operator|=
name|NULL
expr_stmt|;
name|thread
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|thread
operator|->
name|continuation
operator|=
name|NULL
expr_stmt|;
name|thread
operator|->
name|state
operator|=
name|PS_RUNNING
expr_stmt|;
name|thread
operator|->
name|uniqueid
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_private
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|clockinfo
name|clockinfo
decl_stmt|;
name|struct
name|sigaction
name|act
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|mib
index|[
literal|2
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * Avoid reinitializing some things if they don't need to be, 	 * e.g. after a fork(). 	 */
if|if
condition|(
name|init_once
operator|==
literal|0
condition|)
block|{
comment|/* Find the stack top */
name|mib
index|[
literal|0
index|]
operator|=
name|CTL_KERN
expr_stmt|;
name|mib
index|[
literal|1
index|]
operator|=
name|KERN_USRSTACK
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|_usrstack
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|2
argument_list|,
operator|&
name|_usrstack
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|PANIC
argument_list|(
literal|"Cannot get kern.usrstack from sysctl"
argument_list|)
expr_stmt|;
comment|/* 		 * Create a red zone below the main stack.  All other 		 * stacks are constrained to a maximum size by the 		 * parameters passed to mmap(), but this stack is only 		 * limited by resource limits, so this stack needs an 		 * explicitly mapped red zone to protect the thread stack 		 * that is just beyond. 		 */
if|if
condition|(
name|mmap
argument_list|(
operator|(
name|void
operator|*
operator|)
name|_usrstack
operator|-
name|THR_STACK_INITIAL
operator|-
name|_thr_guard_default
argument_list|,
name|_thr_guard_default
argument_list|,
literal|0
argument_list|,
name|MAP_ANON
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
operator|==
name|MAP_FAILED
condition|)
name|PANIC
argument_list|(
literal|"Cannot allocate red zone for initial thread"
argument_list|)
expr_stmt|;
comment|/* Get the kernel clockrate: */
name|mib
index|[
literal|0
index|]
operator|=
name|CTL_KERN
expr_stmt|;
name|mib
index|[
literal|1
index|]
operator|=
name|KERN_CLOCKRATE
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|clockinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|2
argument_list|,
operator|&
name|clockinfo
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
name|_clock_res_usec
operator|=
name|clockinfo
operator|.
name|tick
expr_stmt|;
else|else
name|_clock_res_usec
operator|=
name|CLOCK_RES_USEC
expr_stmt|;
name|_thr_page_size
operator|=
name|getpagesize
argument_list|()
expr_stmt|;
name|_thr_guard_default
operator|=
name|_thr_page_size
expr_stmt|;
comment|/* Enter a loop to get the existing signal status: */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NSIG
condition|;
name|i
operator|++
control|)
block|{
comment|/* Check for signals which cannot be trapped: */
if|if
condition|(
name|i
operator|==
name|SIGKILL
operator|||
name|i
operator|==
name|SIGSTOP
condition|)
block|{ 			}
comment|/* Get the signal handler details: */
elseif|else
if|if
condition|(
name|__sys_sigaction
argument_list|(
name|i
argument_list|,
name|NULL
argument_list|,
operator|&
name|_thread_sigact
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * Abort this process if signal 				 * initialisation fails: 				 */
name|PANIC
argument_list|(
literal|"Cannot read signal handler info"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Install the signal handler for SIGINFO.  It isn't 		 * really needed, but it is nice to have for debugging 		 * purposes. 		 */
if|if
condition|(
name|__sys_sigaction
argument_list|(
name|SIGINFO
argument_list|,
operator|&
name|act
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Abort this process if signal initialisation fails: 			 */
name|PANIC
argument_list|(
literal|"Cannot initialize signal handler"
argument_list|)
expr_stmt|;
block|}
name|_thread_sigact
index|[
name|SIGINFO
operator|-
literal|1
index|]
operator|.
name|sa_flags
operator|=
name|SA_SIGINFO
operator||
name|SA_RESTART
expr_stmt|;
name|init_once
operator|=
literal|1
expr_stmt|;
comment|/* Don't do this again. */
block|}
else|else
block|{
comment|/* 		 * Destroy the locks before creating them.  We don't 		 * know what state they are in so it is better to just 		 * recreate them. 		 */
name|_lock_destroy
argument_list|(
operator|&
name|_thread_signal_lock
argument_list|)
expr_stmt|;
name|_lock_destroy
argument_list|(
operator|&
name|_mutex_static_lock
argument_list|)
expr_stmt|;
name|_lock_destroy
argument_list|(
operator|&
name|_rwlock_static_lock
argument_list|)
expr_stmt|;
name|_lock_destroy
argument_list|(
operator|&
name|_keytable_lock
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize everything else. */
name|TAILQ_INIT
argument_list|(
operator|&
name|_thread_list
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|_thread_gc_list
argument_list|)
expr_stmt|;
comment|/* Enter a loop to get the existing signal status: */
comment|/* Initialize the SIG_DFL dummy handler count. */
name|bzero
argument_list|(
name|_thread_dfl_count
argument_list|,
sizeof|sizeof
argument_list|(
name|_thread_dfl_count
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the lock for temporary installation of signal 	 * handlers (to support sigwait() semantics) and for the 	 * process signal mask and pending signal sets. 	 */
if|if
condition|(
name|_lock_init
argument_list|(
operator|&
name|_thread_signal_lock
argument_list|,
name|LCK_ADAPTIVE
argument_list|,
name|_kse_lock_wait
argument_list|,
name|_kse_lock_wakeup
argument_list|)
operator|!=
literal|0
condition|)
name|PANIC
argument_list|(
literal|"Cannot initialize _thread_signal_lock"
argument_list|)
expr_stmt|;
if|if
condition|(
name|_lock_init
argument_list|(
operator|&
name|_mutex_static_lock
argument_list|,
name|LCK_ADAPTIVE
argument_list|,
name|_thr_lock_wait
argument_list|,
name|_thr_lock_wakeup
argument_list|)
operator|!=
literal|0
condition|)
name|PANIC
argument_list|(
literal|"Cannot initialize mutex static init lock"
argument_list|)
expr_stmt|;
if|if
condition|(
name|_lock_init
argument_list|(
operator|&
name|_rwlock_static_lock
argument_list|,
name|LCK_ADAPTIVE
argument_list|,
name|_thr_lock_wait
argument_list|,
name|_thr_lock_wakeup
argument_list|)
operator|!=
literal|0
condition|)
name|PANIC
argument_list|(
literal|"Cannot initialize rwlock static init lock"
argument_list|)
expr_stmt|;
if|if
condition|(
name|_lock_init
argument_list|(
operator|&
name|_keytable_lock
argument_list|,
name|LCK_ADAPTIVE
argument_list|,
name|_thr_lock_wait
argument_list|,
name|_thr_lock_wakeup
argument_list|)
operator|!=
literal|0
condition|)
name|PANIC
argument_list|(
literal|"Cannot initialize thread specific keytable lock"
argument_list|)
expr_stmt|;
name|_thr_spinlock_init
argument_list|()
expr_stmt|;
comment|/* Clear pending signals and get the process signal mask. */
name|sigemptyset
argument_list|(
operator|&
name|_thr_proc_sigpending
argument_list|)
expr_stmt|;
name|__sys_sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
name|NULL
argument_list|,
operator|&
name|_thr_proc_sigmask
argument_list|)
expr_stmt|;
comment|/* 	 * _thread_list_lock and _kse_count are initialized 	 * by _kse_init() 	 */
block|}
end_function

end_unit

