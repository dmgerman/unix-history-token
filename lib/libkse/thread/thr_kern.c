begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (C) 2003 Daniel M. Eischen<deischen@freebsd.org>  * Copyright (C) 2002 Jonathon Mini<mini@freebsd.org>  * Copyright (c) 1995-1998 John Birrell<jb@cimlogic.com.au>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by John Birrell.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY JOHN BIRRELL AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/kse.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/signalvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<machine/sigframe.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<ucontext.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"atomic_ops.h"
end_include

begin_include
include|#
directive|include
file|"thr_private.h"
end_include

begin_include
include|#
directive|include
file|"libc_private.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NOTYET
end_ifdef

begin_include
include|#
directive|include
file|"spinlock.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* #define DEBUG_THREAD_KERN */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_THREAD_KERN
end_ifdef

begin_define
define|#
directive|define
name|DBG_MSG
value|stdout_debug
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DBG_MSG
parameter_list|(
name|x
modifier|...
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Define a high water mark for the maximum number of threads that  * will be cached.  Once this level is reached, any extra threads  * will be free()'d.  */
end_comment

begin_define
define|#
directive|define
name|MAX_CACHED_THREADS
value|100
end_define

begin_comment
comment|/*  * Define high water marks for the maximum number of KSEs and KSE groups  * that will be cached. Because we support 1:1 threading, there could have  * same number of KSEs and KSE groups as threads. Once these levels are  * reached, any extra KSE and KSE groups will be free()'d.  */
end_comment

begin_define
define|#
directive|define
name|MAX_CACHED_KSES
value|((_thread_scope_system<= 0) ? 50 : 100)
end_define

begin_define
define|#
directive|define
name|MAX_CACHED_KSEGS
value|((_thread_scope_system<= 0) ? 50 : 100)
end_define

begin_define
define|#
directive|define
name|KSE_SET_MBOX
parameter_list|(
name|kse
parameter_list|,
name|thrd
parameter_list|)
define|\
value|(kse)->k_kcb->kcb_kmbx.km_curthread =&(thrd)->tcb->tcb_tmbx
end_define

begin_define
define|#
directive|define
name|KSE_SET_EXITED
parameter_list|(
name|kse
parameter_list|)
value|(kse)->k_flags |= KF_EXITED
end_define

begin_comment
comment|/*  * Macros for manipulating the run queues.  The priority queue  * routines use the thread's pqe link and also handle the setting  * and clearing of the thread's THR_FLAGS_IN_RUNQ flag.  */
end_comment

begin_define
define|#
directive|define
name|KSE_RUNQ_INSERT_HEAD
parameter_list|(
name|kse
parameter_list|,
name|thrd
parameter_list|)
define|\
value|_pq_insert_head(&(kse)->k_schedq->sq_runq, thrd)
end_define

begin_define
define|#
directive|define
name|KSE_RUNQ_INSERT_TAIL
parameter_list|(
name|kse
parameter_list|,
name|thrd
parameter_list|)
define|\
value|_pq_insert_tail(&(kse)->k_schedq->sq_runq, thrd)
end_define

begin_define
define|#
directive|define
name|KSE_RUNQ_REMOVE
parameter_list|(
name|kse
parameter_list|,
name|thrd
parameter_list|)
define|\
value|_pq_remove(&(kse)->k_schedq->sq_runq, thrd)
end_define

begin_define
define|#
directive|define
name|KSE_RUNQ_FIRST
parameter_list|(
name|kse
parameter_list|)
define|\
value|((_libkse_debug == 0) ?				\ 	 _pq_first(&(kse)->k_schedq->sq_runq) :		\ 	 _pq_first_debug(&(kse)->k_schedq->sq_runq))
end_define

begin_define
define|#
directive|define
name|KSE_RUNQ_THREADS
parameter_list|(
name|kse
parameter_list|)
value|((kse)->k_schedq->sq_runq.pq_threads)
end_define

begin_define
define|#
directive|define
name|THR_NEED_CANCEL
parameter_list|(
name|thrd
parameter_list|)
define|\
value|(((thrd)->cancelflags& THR_CANCELLING) != 0&&		\ 	  ((thrd)->cancelflags& PTHREAD_CANCEL_DISABLE) == 0&&	\ 	  (((thrd)->cancelflags& THR_AT_CANCEL_POINT) != 0 ||		\ 	   ((thrd)->cancelflags& PTHREAD_CANCEL_ASYNCHRONOUS) != 0))
end_define

begin_define
define|#
directive|define
name|THR_NEED_ASYNC_CANCEL
parameter_list|(
name|thrd
parameter_list|)
define|\
value|(((thrd)->cancelflags& THR_CANCELLING) != 0&&		\ 	  ((thrd)->cancelflags& PTHREAD_CANCEL_DISABLE) == 0&&	\ 	  (((thrd)->cancelflags& THR_AT_CANCEL_POINT) == 0&&		\ 	   ((thrd)->cancelflags& PTHREAD_CANCEL_ASYNCHRONOUS) != 0))
end_define

begin_comment
comment|/*  * We've got to keep track of everything that is allocated, not only  * to have a speedy free list, but also so they can be deallocated  * after a fork().  */
end_comment

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|kse
argument_list|)
name|active_kseq
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|kse
argument_list|)
name|free_kseq
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|kse_group
argument_list|)
name|free_kse_groupq
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|kse_group
argument_list|)
name|active_kse_groupq
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|kse_group
argument_list|)
name|gc_ksegq
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|lock
name|kse_lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* also used for kseg queue */
end_comment

begin_decl_stmt
specifier|static
name|int
name|free_kse_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|free_kseg_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|pthread
argument_list|)
name|free_threadq
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|lock
name|thread_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|free_thread_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|inited
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|active_kse_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|active_kseg_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int64_t
name|next_uniqueid
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|LIST_HEAD
argument_list|(
name|thread_hash_head
argument_list|,
name|pthread
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|THREAD_HASH_QUEUES
value|127
end_define

begin_decl_stmt
specifier|static
name|struct
name|thread_hash_head
name|thr_hashtable
index|[
name|THREAD_HASH_QUEUES
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|THREAD_HASH
parameter_list|(
name|thrd
parameter_list|)
value|((unsigned long)thrd % THREAD_HASH_QUEUES)
end_define

begin_comment
comment|/* Lock for thread tcb constructor/destructor */
end_comment

begin_decl_stmt
specifier|static
name|pthread_mutex_t
name|_tcb_mutex
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_THREAD_KERN
end_ifdef

begin_function_decl
specifier|static
name|void
name|dump_queues
parameter_list|(
name|struct
name|kse
modifier|*
name|curkse
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|kse_check_completed
parameter_list|(
name|struct
name|kse
modifier|*
name|kse
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kse_check_waitq
parameter_list|(
name|struct
name|kse
modifier|*
name|kse
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kse_fini
parameter_list|(
name|struct
name|kse
modifier|*
name|curkse
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kse_reinit
parameter_list|(
name|struct
name|kse
modifier|*
name|kse
parameter_list|,
name|int
name|sys_scope
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kse_sched_multi
parameter_list|(
name|struct
name|kse_mailbox
modifier|*
name|kmbx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kse_sched_single
parameter_list|(
name|struct
name|kse_mailbox
modifier|*
name|kmbx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kse_switchout_thread
parameter_list|(
name|struct
name|kse
modifier|*
name|kse
parameter_list|,
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kse_wait
parameter_list|(
name|struct
name|kse
modifier|*
name|kse
parameter_list|,
name|struct
name|pthread
modifier|*
name|td_wait
parameter_list|,
name|int
name|sigseq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kse_free_unlocked
parameter_list|(
name|struct
name|kse
modifier|*
name|kse
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kse_destroy
parameter_list|(
name|struct
name|kse
modifier|*
name|kse
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kseg_free_unlocked
parameter_list|(
name|struct
name|kse_group
modifier|*
name|kseg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kseg_init
parameter_list|(
name|struct
name|kse_group
modifier|*
name|kseg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kseg_reinit
parameter_list|(
name|struct
name|kse_group
modifier|*
name|kseg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kseg_destroy
parameter_list|(
name|struct
name|kse_group
modifier|*
name|kseg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kse_waitq_insert
parameter_list|(
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kse_wakeup_multi
parameter_list|(
name|struct
name|kse
modifier|*
name|curkse
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|kse_mailbox
modifier|*
name|kse_wakeup_one
parameter_list|(
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|thr_cleanup
parameter_list|(
name|struct
name|kse
modifier|*
name|kse
parameter_list|,
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|thr_link
parameter_list|(
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|thr_resume_wrapper
parameter_list|(
name|int
name|sig
parameter_list|,
name|siginfo_t
modifier|*
parameter_list|,
name|ucontext_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|thr_resume_check
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|,
name|ucontext_t
modifier|*
name|ucp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|thr_timedout
parameter_list|(
name|struct
name|pthread
modifier|*
name|thread
parameter_list|,
name|struct
name|timespec
modifier|*
name|curtime
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|thr_unlink
parameter_list|(
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|thr_destroy
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|,
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|thread_gc
parameter_list|(
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kse_gc
parameter_list|(
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|kseg_gc
parameter_list|(
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|__inline
name|thr_accounting
parameter_list|(
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
block|{
if|if
condition|(
operator|(
name|thread
operator|->
name|slice_usec
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
name|thread
operator|->
name|slice_usec
operator|<=
name|TIMESLICE_USEC
operator|)
operator|&&
operator|(
name|thread
operator|->
name|attr
operator|.
name|sched_policy
operator|!=
name|SCHED_FIFO
operator|)
condition|)
block|{
name|thread
operator|->
name|slice_usec
operator|+=
operator|(
name|thread
operator|->
name|tcb
operator|->
name|tcb_tmbx
operator|.
name|tm_uticks
operator|+
name|thread
operator|->
name|tcb
operator|->
name|tcb_tmbx
operator|.
name|tm_sticks
operator|)
operator|*
name|_clock_res_usec
expr_stmt|;
comment|/* Check for time quantum exceeded: */
if|if
condition|(
name|thread
operator|->
name|slice_usec
operator|>
name|TIMESLICE_USEC
condition|)
name|thread
operator|->
name|slice_usec
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|thread
operator|->
name|tcb
operator|->
name|tcb_tmbx
operator|.
name|tm_uticks
operator|=
literal|0
expr_stmt|;
name|thread
operator|->
name|tcb
operator|->
name|tcb_tmbx
operator|.
name|tm_sticks
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is called after a fork().  * No locks need to be taken here since we are guaranteed to be  * single threaded.  *   * XXX  * POSIX says for threaded process, fork() function is used  * only to run new programs, and the effects of calling functions  * that require certain resources between the call to fork() and  * the call to an exec function are undefined.  *  * It is not safe to free memory after fork(), because these data  * structures may be in inconsistent state.  */
end_comment

begin_function
name|void
name|_kse_single_thread
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|NOTYET
name|struct
name|kse
modifier|*
name|kse
decl_stmt|;
name|struct
name|kse_group
modifier|*
name|kseg
decl_stmt|;
name|struct
name|pthread
modifier|*
name|thread
decl_stmt|;
name|_thr_spinlock_init
argument_list|()
expr_stmt|;
operator|*
name|__malloc_lock
operator|=
operator|(
name|spinlock_t
operator|)
name|_SPINLOCK_INITIALIZER
expr_stmt|;
if|if
condition|(
name|__isthreaded
condition|)
block|{
name|_thr_rtld_fini
argument_list|()
expr_stmt|;
name|_thr_signal_deinit
argument_list|()
expr_stmt|;
block|}
name|__isthreaded
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Restore signal mask early, so any memory problems could 	 * dump core. 	 */
name|__sys_sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|curthread
operator|->
name|sigmask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_thread_active_threads
operator|=
literal|1
expr_stmt|;
name|curthread
operator|->
name|kse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_curthread
operator|=
name|NULL
expr_stmt|;
name|curthread
operator|->
name|attr
operator|.
name|flags
operator|&=
operator|~
name|PTHREAD_SCOPE_SYSTEM
expr_stmt|;
name|curthread
operator|->
name|attr
operator|.
name|flags
operator||=
name|PTHREAD_SCOPE_SYSTEM
expr_stmt|;
comment|/* 	 * Enter a loop to remove and free all threads other than 	 * the running thread from the active thread list: 	 */
while|while
condition|(
operator|(
name|thread
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|_thread_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|THR_GCLIST_REMOVE
argument_list|(
name|thread
argument_list|)
expr_stmt|;
comment|/* 		 * Remove this thread from the list (the current 		 * thread will be removed but re-added by libpthread 		 * initialization. 		 */
name|TAILQ_REMOVE
argument_list|(
operator|&
name|_thread_list
argument_list|,
name|thread
argument_list|,
name|tle
argument_list|)
expr_stmt|;
comment|/* Make sure this isn't the running thread: */
if|if
condition|(
name|thread
operator|!=
name|curthread
condition|)
block|{
name|_thr_stack_free
argument_list|(
operator|&
name|thread
operator|->
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
name|thread
operator|->
name|specific
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|thread
operator|->
name|specific
argument_list|)
expr_stmt|;
name|thr_destroy
argument_list|(
name|curthread
argument_list|,
name|thread
argument_list|)
expr_stmt|;
block|}
block|}
name|TAILQ_INIT
argument_list|(
operator|&
name|curthread
operator|->
name|mutexq
argument_list|)
expr_stmt|;
comment|/* initialize mutex queue */
name|curthread
operator|->
name|joiner
operator|=
name|NULL
expr_stmt|;
comment|/* no joining threads yet */
name|curthread
operator|->
name|refcount
operator|=
literal|0
expr_stmt|;
name|SIGEMPTYSET
argument_list|(
name|curthread
operator|->
name|sigpend
argument_list|)
expr_stmt|;
comment|/* clear pending signals */
comment|/* Don't free thread-specific data as the caller may require it */
comment|/* Free the free KSEs: */
while|while
condition|(
operator|(
name|kse
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|free_kseq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|free_kseq
argument_list|,
name|kse
argument_list|,
name|k_qe
argument_list|)
expr_stmt|;
name|kse_destroy
argument_list|(
name|kse
argument_list|)
expr_stmt|;
block|}
name|free_kse_count
operator|=
literal|0
expr_stmt|;
comment|/* Free the active KSEs: */
while|while
condition|(
operator|(
name|kse
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|active_kseq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|active_kseq
argument_list|,
name|kse
argument_list|,
name|k_qe
argument_list|)
expr_stmt|;
name|kse_destroy
argument_list|(
name|kse
argument_list|)
expr_stmt|;
block|}
name|active_kse_count
operator|=
literal|0
expr_stmt|;
comment|/* Free the free KSEGs: */
while|while
condition|(
operator|(
name|kseg
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|free_kse_groupq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|free_kse_groupq
argument_list|,
name|kseg
argument_list|,
name|kg_qe
argument_list|)
expr_stmt|;
name|kseg_destroy
argument_list|(
name|kseg
argument_list|)
expr_stmt|;
block|}
name|free_kseg_count
operator|=
literal|0
expr_stmt|;
comment|/* Free the active KSEGs: */
while|while
condition|(
operator|(
name|kseg
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|active_kse_groupq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|active_kse_groupq
argument_list|,
name|kseg
argument_list|,
name|kg_qe
argument_list|)
expr_stmt|;
name|kseg_destroy
argument_list|(
name|kseg
argument_list|)
expr_stmt|;
block|}
name|active_kseg_count
operator|=
literal|0
expr_stmt|;
comment|/* Free the free threads. */
while|while
condition|(
operator|(
name|thread
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|free_threadq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|free_threadq
argument_list|,
name|thread
argument_list|,
name|tle
argument_list|)
expr_stmt|;
name|thr_destroy
argument_list|(
name|curthread
argument_list|,
name|thread
argument_list|)
expr_stmt|;
block|}
name|free_thread_count
operator|=
literal|0
expr_stmt|;
comment|/* Free the to-be-gc'd threads. */
while|while
condition|(
operator|(
name|thread
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|_thread_gc_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|_thread_gc_list
argument_list|,
name|thread
argument_list|,
name|gcle
argument_list|)
expr_stmt|;
name|thr_destroy
argument_list|(
name|curthread
argument_list|,
name|thread
argument_list|)
expr_stmt|;
block|}
name|TAILQ_INIT
argument_list|(
operator|&
name|gc_ksegq
argument_list|)
expr_stmt|;
name|_gc_count
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|inited
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Destroy these locks; they'll be recreated to assure they 		 * are in the unlocked state. 		 */
name|_lock_destroy
argument_list|(
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
name|_lock_destroy
argument_list|(
operator|&
name|thread_lock
argument_list|)
expr_stmt|;
name|_lock_destroy
argument_list|(
operator|&
name|_thread_list_lock
argument_list|)
expr_stmt|;
name|inited
operator|=
literal|0
expr_stmt|;
block|}
comment|/* We're no longer part of any lists */
name|curthread
operator|->
name|tlflags
operator|=
literal|0
expr_stmt|;
comment|/* 	 * After a fork, we are still operating on the thread's original 	 * stack.  Don't clear the THR_FLAGS_USER from the thread's 	 * attribute flags. 	 */
comment|/* Initialize the threads library. */
name|curthread
operator|->
name|kse
operator|=
name|NULL
expr_stmt|;
name|curthread
operator|->
name|kseg
operator|=
name|NULL
expr_stmt|;
name|_kse_initial
operator|=
name|NULL
expr_stmt|;
name|_libpthread_init
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
else|#
directive|else
name|int
name|i
decl_stmt|;
comment|/* Reset the current thread and KSE lock data. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|curthread
operator|->
name|locklevel
condition|;
name|i
operator|++
control|)
block|{
name|_lockuser_reinit
argument_list|(
operator|&
name|curthread
operator|->
name|lockusers
index|[
name|i
index|]
argument_list|,
operator|(
name|void
operator|*
operator|)
name|curthread
argument_list|)
expr_stmt|;
block|}
name|curthread
operator|->
name|locklevel
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|curthread
operator|->
name|kse
operator|->
name|k_locklevel
condition|;
name|i
operator|++
control|)
block|{
name|_lockuser_reinit
argument_list|(
operator|&
name|curthread
operator|->
name|kse
operator|->
name|k_lockusers
index|[
name|i
index|]
argument_list|,
operator|(
name|void
operator|*
operator|)
name|curthread
operator|->
name|kse
argument_list|)
expr_stmt|;
name|_LCK_SET_PRIVATE2
argument_list|(
operator|&
name|curthread
operator|->
name|kse
operator|->
name|k_lockusers
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|curthread
operator|->
name|kse
operator|->
name|k_locklevel
operator|=
literal|0
expr_stmt|;
name|_thr_spinlock_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|__isthreaded
condition|)
block|{
name|_thr_rtld_fini
argument_list|()
expr_stmt|;
name|_thr_signal_deinit
argument_list|()
expr_stmt|;
block|}
name|__isthreaded
operator|=
literal|0
expr_stmt|;
name|curthread
operator|->
name|kse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_curthread
operator|=
name|NULL
expr_stmt|;
name|curthread
operator|->
name|attr
operator|.
name|flags
operator||=
name|PTHREAD_SCOPE_SYSTEM
expr_stmt|;
comment|/* After a fork(), there child should have no pending signals. */
name|sigemptyset
argument_list|(
operator|&
name|curthread
operator|->
name|sigpend
argument_list|)
expr_stmt|;
comment|/* 	 * Restore signal mask early, so any memory problems could 	 * dump core. 	 */
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|curthread
operator|->
name|sigmask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|_thread_active_threads
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * This is used to initialize housekeeping and to initialize the  * KSD for the KSE.  */
end_comment

begin_function
name|void
name|_kse_init
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|inited
operator|==
literal|0
condition|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|active_kseq
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|active_kse_groupq
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|free_kseq
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|free_kse_groupq
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|free_threadq
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|gc_ksegq
argument_list|)
expr_stmt|;
if|if
condition|(
name|_lock_init
argument_list|(
operator|&
name|kse_lock
argument_list|,
name|LCK_ADAPTIVE
argument_list|,
name|_kse_lock_wait
argument_list|,
name|_kse_lock_wakeup
argument_list|)
operator|!=
literal|0
condition|)
name|PANIC
argument_list|(
literal|"Unable to initialize free KSE queue lock"
argument_list|)
expr_stmt|;
if|if
condition|(
name|_lock_init
argument_list|(
operator|&
name|thread_lock
argument_list|,
name|LCK_ADAPTIVE
argument_list|,
name|_kse_lock_wait
argument_list|,
name|_kse_lock_wakeup
argument_list|)
operator|!=
literal|0
condition|)
name|PANIC
argument_list|(
literal|"Unable to initialize free thread queue lock"
argument_list|)
expr_stmt|;
if|if
condition|(
name|_lock_init
argument_list|(
operator|&
name|_thread_list_lock
argument_list|,
name|LCK_ADAPTIVE
argument_list|,
name|_kse_lock_wait
argument_list|,
name|_kse_lock_wakeup
argument_list|)
operator|!=
literal|0
condition|)
name|PANIC
argument_list|(
literal|"Unable to initialize thread list lock"
argument_list|)
expr_stmt|;
name|_pthread_mutex_init
argument_list|(
operator|&
name|_tcb_mutex
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|active_kse_count
operator|=
literal|0
expr_stmt|;
name|active_kseg_count
operator|=
literal|0
expr_stmt|;
name|_gc_count
operator|=
literal|0
expr_stmt|;
name|inited
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This is called when the first thread (other than the initial  * thread) is created.  */
end_comment

begin_function
name|int
name|_kse_setthreaded
parameter_list|(
name|int
name|threaded
parameter_list|)
block|{
name|sigset_t
name|sigset
decl_stmt|;
if|if
condition|(
operator|(
name|threaded
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|__isthreaded
operator|==
literal|0
operator|)
condition|)
block|{
name|SIGFILLSET
argument_list|(
name|sigset
argument_list|)
expr_stmt|;
name|__sys_sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|sigset
argument_list|,
operator|&
name|_thr_initial
operator|->
name|sigmask
argument_list|)
expr_stmt|;
comment|/* 		 * Tell the kernel to create a KSE for the initial thread 		 * and enable upcalls in it. 		 */
name|_kse_initial
operator|->
name|k_flags
operator||=
name|KF_STARTED
expr_stmt|;
if|if
condition|(
name|_thread_scope_system
operator|<=
literal|0
condition|)
block|{
name|_thr_initial
operator|->
name|attr
operator|.
name|flags
operator|&=
operator|~
name|PTHREAD_SCOPE_SYSTEM
expr_stmt|;
name|_kse_initial
operator|->
name|k_kseg
operator|->
name|kg_flags
operator|&=
operator|~
name|KGF_SINGLE_THREAD
expr_stmt|;
name|_kse_initial
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_curthread
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * For bound thread, kernel reads mailbox pointer 			 * once, we'd set it here before calling kse_create. 			 */
name|_tcb_set
argument_list|(
name|_kse_initial
operator|->
name|k_kcb
argument_list|,
name|_thr_initial
operator|->
name|tcb
argument_list|)
expr_stmt|;
name|KSE_SET_MBOX
argument_list|(
name|_kse_initial
argument_list|,
name|_thr_initial
argument_list|)
expr_stmt|;
name|_kse_initial
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_flags
operator||=
name|KMF_BOUND
expr_stmt|;
block|}
comment|/* 		 * Locking functions in libc are required when there are 		 * threads other than the initial thread. 		 */
name|_thr_rtld_init
argument_list|()
expr_stmt|;
name|__isthreaded
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|kse_create
argument_list|(
operator|&
name|_kse_initial
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|_kse_initial
operator|->
name|k_flags
operator|&=
operator|~
name|KF_STARTED
expr_stmt|;
name|__isthreaded
operator|=
literal|0
expr_stmt|;
name|PANIC
argument_list|(
literal|"kse_create() failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|_thr_initial
operator|->
name|tcb
operator|->
name|tcb_tmbx
operator|.
name|tm_lwp
operator|=
name|_kse_initial
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_lwp
expr_stmt|;
name|_thread_activated
operator|=
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|SYSTEM_SCOPE_ONLY
if|if
condition|(
name|_thread_scope_system
operator|<=
literal|0
condition|)
block|{
comment|/* Set current thread to initial thread */
name|_tcb_set
argument_list|(
name|_kse_initial
operator|->
name|k_kcb
argument_list|,
name|_thr_initial
operator|->
name|tcb
argument_list|)
expr_stmt|;
name|KSE_SET_MBOX
argument_list|(
name|_kse_initial
argument_list|,
name|_thr_initial
argument_list|)
expr_stmt|;
name|_thr_start_sig_daemon
argument_list|()
expr_stmt|;
name|_thr_setmaxconcurrency
argument_list|()
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|__sys_sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|_thr_initial
operator|->
name|sigmask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lock wait and wakeup handlers for KSE locks.  These are only used by  * KSEs, and should never be used by threads.  KSE locks include the  * KSE group lock (used for locking the scheduling queue) and the  * kse_lock defined above.  *  * When a KSE lock attempt blocks, the entire KSE blocks allowing another  * KSE to run.  For the most part, it doesn't make much sense to try and  * schedule another thread because you need to lock the scheduling queue  * in order to do that.  And since the KSE lock is used to lock the scheduling  * queue, you would just end up blocking again.  */
end_comment

begin_function
name|void
name|_kse_lock_wait
parameter_list|(
name|struct
name|lock
modifier|*
name|lock
parameter_list|,
name|struct
name|lockuser
modifier|*
name|lu
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|curkse
init|=
operator|(
expr|struct
name|kse
operator|*
operator|)
name|_LCK_GET_PRIVATE
argument_list|(
name|lu
argument_list|)
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
name|int
name|saved_flags
decl_stmt|;
if|if
condition|(
name|curkse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_curthread
operator|!=
name|NULL
condition|)
name|PANIC
argument_list|(
literal|"kse_lock_wait does not disable upcall.\n"
argument_list|)
expr_stmt|;
comment|/* 	 * Enter a loop to wait until we get the lock. 	 */
name|ts
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|ts
operator|.
name|tv_nsec
operator|=
literal|1000000
expr_stmt|;
comment|/* 1 sec */
while|while
condition|(
operator|!
name|_LCK_GRANTED
argument_list|(
name|lu
argument_list|)
condition|)
block|{
comment|/* 		 * Yield the kse and wait to be notified when the lock 		 * is granted. 		 */
name|saved_flags
operator|=
name|curkse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_flags
expr_stmt|;
name|curkse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_flags
operator||=
name|KMF_NOUPCALL
operator||
name|KMF_NOCOMPLETED
expr_stmt|;
name|kse_release
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
name|curkse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_flags
operator|=
name|saved_flags
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|_kse_lock_wakeup
parameter_list|(
name|struct
name|lock
modifier|*
name|lock
parameter_list|,
name|struct
name|lockuser
modifier|*
name|lu
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|curkse
decl_stmt|;
name|struct
name|kse
modifier|*
name|kse
decl_stmt|;
name|struct
name|kse_mailbox
modifier|*
name|mbx
decl_stmt|;
name|curkse
operator|=
name|_get_curkse
argument_list|()
expr_stmt|;
name|kse
operator|=
operator|(
expr|struct
name|kse
operator|*
operator|)
name|_LCK_GET_PRIVATE
argument_list|(
name|lu
argument_list|)
expr_stmt|;
if|if
condition|(
name|kse
operator|==
name|curkse
condition|)
name|PANIC
argument_list|(
literal|"KSE trying to wake itself up in lock"
argument_list|)
expr_stmt|;
else|else
block|{
name|mbx
operator|=
operator|&
name|kse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
expr_stmt|;
name|_lock_grant
argument_list|(
name|lock
argument_list|,
name|lu
argument_list|)
expr_stmt|;
comment|/* 		 * Notify the owning kse that it has the lock. 		 * It is safe to pass invalid address to kse_wakeup 		 * even if the mailbox is not in kernel at all, 		 * and waking up a wrong kse is also harmless. 		 */
name|kse_wakeup
argument_list|(
name|mbx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Thread wait and wakeup handlers for thread locks.  These are only used  * by threads, never by KSEs.  Thread locks include the per-thread lock  * (defined in its structure), and condition variable and mutex locks.  */
end_comment

begin_function
name|void
name|_thr_lock_wait
parameter_list|(
name|struct
name|lock
modifier|*
name|lock
parameter_list|,
name|struct
name|lockuser
modifier|*
name|lu
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|curthread
init|=
operator|(
expr|struct
name|pthread
operator|*
operator|)
name|lu
operator|->
name|lu_private
decl_stmt|;
do|do
block|{
name|THR_LOCK_SWITCH
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|THR_SET_STATE
argument_list|(
name|curthread
argument_list|,
name|PS_LOCKWAIT
argument_list|)
expr_stmt|;
name|_thr_sched_switch_unlocked
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|_LCK_GRANTED
argument_list|(
name|lu
argument_list|)
condition|)
do|;
block|}
end_function

begin_function
name|void
name|_thr_lock_wakeup
parameter_list|(
name|struct
name|lock
modifier|*
name|lock
parameter_list|,
name|struct
name|lockuser
modifier|*
name|lu
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|thread
decl_stmt|;
name|struct
name|pthread
modifier|*
name|curthread
decl_stmt|;
name|struct
name|kse_mailbox
modifier|*
name|kmbx
decl_stmt|;
name|curthread
operator|=
name|_get_curthread
argument_list|()
expr_stmt|;
name|thread
operator|=
operator|(
expr|struct
name|pthread
operator|*
operator|)
name|_LCK_GET_PRIVATE
argument_list|(
name|lu
argument_list|)
expr_stmt|;
name|THR_SCHED_LOCK
argument_list|(
name|curthread
argument_list|,
name|thread
argument_list|)
expr_stmt|;
name|_lock_grant
argument_list|(
name|lock
argument_list|,
name|lu
argument_list|)
expr_stmt|;
name|kmbx
operator|=
name|_thr_setrunnable_unlocked
argument_list|(
name|thread
argument_list|)
expr_stmt|;
name|THR_SCHED_UNLOCK
argument_list|(
name|curthread
argument_list|,
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|kmbx
operator|!=
name|NULL
condition|)
name|kse_wakeup
argument_list|(
name|kmbx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|kse_critical_t
name|_kse_critical_enter
parameter_list|(
name|void
parameter_list|)
block|{
name|kse_critical_t
name|crit
decl_stmt|;
name|crit
operator|=
operator|(
name|kse_critical_t
operator|)
name|_kcb_critical_enter
argument_list|()
expr_stmt|;
return|return
operator|(
name|crit
operator|)
return|;
block|}
end_function

begin_function
name|void
name|_kse_critical_leave
parameter_list|(
name|kse_critical_t
name|crit
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|curthread
decl_stmt|;
name|_kcb_critical_leave
argument_list|(
operator|(
expr|struct
name|kse_thr_mailbox
operator|*
operator|)
name|crit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|crit
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|curthread
operator|=
name|_get_curthread
argument_list|()
operator|)
operator|!=
name|NULL
operator|)
condition|)
name|THR_YIELD_CHECK
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|_kse_in_critical
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|_kcb_in_critical
argument_list|()
operator|)
return|;
block|}
end_function

begin_function
name|void
name|_thr_critical_enter
parameter_list|(
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
block|{
name|thread
operator|->
name|critical_count
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_thr_critical_leave
parameter_list|(
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
block|{
name|thread
operator|->
name|critical_count
operator|--
expr_stmt|;
name|THR_YIELD_CHECK
argument_list|(
name|thread
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_thr_sched_switch
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|curkse
decl_stmt|;
operator|(
name|void
operator|)
name|_kse_critical_enter
argument_list|()
expr_stmt|;
name|curkse
operator|=
name|_get_curkse
argument_list|()
expr_stmt|;
name|KSE_SCHED_LOCK
argument_list|(
name|curkse
argument_list|,
name|curkse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
name|_thr_sched_switch_unlocked
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * XXX - We may need to take the scheduling lock before calling  *       this, or perhaps take the lock within here before  *       doing anything else.  */
end_comment

begin_function
name|void
name|_thr_sched_switch_unlocked
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|curkse
decl_stmt|;
specifier|volatile
name|int
name|resume_once
init|=
literal|0
decl_stmt|;
name|ucontext_t
modifier|*
name|uc
decl_stmt|;
comment|/* We're in the scheduler, 5 by 5: */
name|curkse
operator|=
name|curthread
operator|->
name|kse
expr_stmt|;
name|curthread
operator|->
name|need_switchout
operator|=
literal|1
expr_stmt|;
comment|/* The thread yielded on its own. */
name|curthread
operator|->
name|critical_yield
operator|=
literal|0
expr_stmt|;
comment|/* No need to yield anymore. */
comment|/* Thread can unlock the scheduler lock. */
name|curthread
operator|->
name|lock_switch
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|curthread
operator|->
name|attr
operator|.
name|flags
operator|&
name|PTHREAD_SCOPE_SYSTEM
condition|)
name|kse_sched_single
argument_list|(
operator|&
name|curkse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|__predict_false
argument_list|(
name|_libkse_debug
operator|!=
literal|0
argument_list|)
condition|)
block|{
comment|/* 			 * Because debugger saves single step status in thread 			 * mailbox's tm_dflags, we can safely clear single  			 * step status here. the single step status will be 			 * restored by kse_switchin when the thread is 			 * switched in again. This also lets uts run in full 			 * speed. 			 */
name|ptrace
argument_list|(
name|PT_CLEARSTEP
argument_list|,
name|curkse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_lwp
argument_list|,
operator|(
name|caddr_t
operator|)
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|KSE_SET_SWITCH
argument_list|(
name|curkse
argument_list|)
expr_stmt|;
name|_thread_enter_uts
argument_list|(
name|curthread
operator|->
name|tcb
argument_list|,
name|curkse
operator|->
name|k_kcb
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Unlock the scheduling queue and leave the 	 * critical region. 	 */
comment|/* Don't trust this after a switch! */
name|curkse
operator|=
name|curthread
operator|->
name|kse
expr_stmt|;
name|curthread
operator|->
name|lock_switch
operator|=
literal|0
expr_stmt|;
name|KSE_SCHED_UNLOCK
argument_list|(
name|curkse
argument_list|,
name|curkse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
name|_kse_critical_leave
argument_list|(
operator|&
name|curthread
operator|->
name|tcb
operator|->
name|tcb_tmbx
argument_list|)
expr_stmt|;
comment|/* 	 * This thread is being resumed; check for cancellations. 	 */
if|if
condition|(
name|THR_NEED_ASYNC_CANCEL
argument_list|(
name|curthread
argument_list|)
operator|&&
operator|!
name|THR_IN_CRITICAL
argument_list|(
name|curthread
argument_list|)
condition|)
block|{
name|uc
operator|=
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
name|ucontext_t
argument_list|)
argument_list|)
expr_stmt|;
name|resume_once
operator|=
literal|0
expr_stmt|;
name|THR_GETCONTEXT
argument_list|(
name|uc
argument_list|)
expr_stmt|;
if|if
condition|(
name|resume_once
operator|==
literal|0
condition|)
block|{
name|resume_once
operator|=
literal|1
expr_stmt|;
name|curthread
operator|->
name|check_pending
operator|=
literal|0
expr_stmt|;
name|thr_resume_check
argument_list|(
name|curthread
argument_list|,
name|uc
argument_list|)
expr_stmt|;
block|}
block|}
name|THR_ACTIVATE_LAST_LOCK
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is the scheduler for a KSE which runs a scope system thread.  * The multi-thread KSE scheduler should also work for a single threaded  * KSE, but we use a separate scheduler so that it can be fine-tuned  * to be more efficient (and perhaps not need a separate stack for  * the KSE, allowing it to use the thread's stack).  */
end_comment

begin_function
specifier|static
name|void
name|kse_sched_single
parameter_list|(
name|struct
name|kse_mailbox
modifier|*
name|kmbx
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|curkse
decl_stmt|;
name|struct
name|pthread
modifier|*
name|curthread
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
name|sigset_t
name|sigmask
decl_stmt|;
name|int
name|i
decl_stmt|,
name|sigseqno
decl_stmt|,
name|level
decl_stmt|,
name|first
init|=
literal|0
decl_stmt|;
name|curkse
operator|=
operator|(
expr|struct
name|kse
operator|*
operator|)
name|kmbx
operator|->
name|km_udata
expr_stmt|;
name|curthread
operator|=
name|curkse
operator|->
name|k_curthread
expr_stmt|;
if|if
condition|(
name|__predict_false
argument_list|(
operator|(
name|curkse
operator|->
name|k_flags
operator|&
name|KF_INITIALIZED
operator|)
operator|==
literal|0
argument_list|)
condition|)
block|{
comment|/* Setup this KSEs specific data. */
name|_kcb_set
argument_list|(
name|curkse
operator|->
name|k_kcb
argument_list|)
expr_stmt|;
name|_tcb_set
argument_list|(
name|curkse
operator|->
name|k_kcb
argument_list|,
name|curthread
operator|->
name|tcb
argument_list|)
expr_stmt|;
name|curkse
operator|->
name|k_flags
operator||=
name|KF_INITIALIZED
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
name|curthread
operator|->
name|active
operator|=
literal|1
expr_stmt|;
comment|/* Setup kernel signal masks for new thread. */
name|__sys_sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|curthread
operator|->
name|sigmask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * Enter critical region, this is meanless for bound thread, 		 * It is used to let other code work, those code want mailbox 		 * to be cleared. 		 */
operator|(
name|void
operator|)
name|_kse_critical_enter
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Bound thread always has tcb set, this prevent some 		 * code from blindly setting bound thread tcb to NULL, 		 * buggy code ? 		 */
name|_tcb_set
argument_list|(
name|curkse
operator|->
name|k_kcb
argument_list|,
name|curthread
operator|->
name|tcb
argument_list|)
expr_stmt|;
block|}
name|curthread
operator|->
name|critical_yield
operator|=
literal|0
expr_stmt|;
name|curthread
operator|->
name|need_switchout
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Lock the scheduling queue. 	 * 	 * There is no scheduling queue for single threaded KSEs, 	 * but we need a lock for protection regardless. 	 */
if|if
condition|(
name|curthread
operator|->
name|lock_switch
operator|==
literal|0
condition|)
name|KSE_SCHED_LOCK
argument_list|(
name|curkse
argument_list|,
name|curkse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
comment|/* 	 * This has to do the job of kse_switchout_thread(), only 	 * for a single threaded KSE/KSEG. 	 */
switch|switch
condition|(
name|curthread
operator|->
name|state
condition|)
block|{
case|case
name|PS_MUTEX_WAIT
case|:
case|case
name|PS_COND_WAIT
case|:
if|if
condition|(
name|THR_NEED_CANCEL
argument_list|(
name|curthread
argument_list|)
condition|)
block|{
name|curthread
operator|->
name|interrupted
operator|=
literal|1
expr_stmt|;
name|curthread
operator|->
name|continuation
operator|=
name|_thr_finish_cancellation
expr_stmt|;
name|THR_SET_STATE
argument_list|(
name|curthread
argument_list|,
name|PS_RUNNING
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PS_LOCKWAIT
case|:
comment|/* 		 * This state doesn't timeout. 		 */
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|=
operator|-
literal|1
expr_stmt|;
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|=
operator|-
literal|1
expr_stmt|;
name|level
operator|=
name|curthread
operator|->
name|locklevel
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|_LCK_GRANTED
argument_list|(
operator|&
name|curthread
operator|->
name|lockusers
index|[
name|level
index|]
argument_list|)
condition|)
name|THR_SET_STATE
argument_list|(
name|curthread
argument_list|,
name|PS_RUNNING
argument_list|)
expr_stmt|;
break|break;
case|case
name|PS_DEAD
case|:
comment|/* Unlock the scheduling queue and exit the KSE and thread. */
name|thr_cleanup
argument_list|(
name|curkse
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|KSE_SCHED_UNLOCK
argument_list|(
name|curkse
argument_list|,
name|curkse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
name|PANIC
argument_list|(
literal|"bound thread shouldn't get here\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PS_JOIN
case|:
if|if
condition|(
name|THR_NEED_CANCEL
argument_list|(
name|curthread
argument_list|)
condition|)
block|{
name|curthread
operator|->
name|join_status
operator|.
name|thread
operator|=
name|NULL
expr_stmt|;
name|THR_SET_STATE
argument_list|(
name|curthread
argument_list|,
name|PS_RUNNING
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * This state doesn't timeout. 			 */
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|=
operator|-
literal|1
expr_stmt|;
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|=
operator|-
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|PS_SUSPENDED
case|:
if|if
condition|(
name|THR_NEED_CANCEL
argument_list|(
name|curthread
argument_list|)
condition|)
block|{
name|curthread
operator|->
name|interrupted
operator|=
literal|1
expr_stmt|;
name|THR_SET_STATE
argument_list|(
name|curthread
argument_list|,
name|PS_RUNNING
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * These states don't timeout. 			 */
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|=
operator|-
literal|1
expr_stmt|;
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|=
operator|-
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|PS_RUNNING
case|:
if|if
condition|(
operator|(
name|curthread
operator|->
name|flags
operator|&
name|THR_FLAGS_SUSPENDED
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|THR_NEED_CANCEL
argument_list|(
name|curthread
argument_list|)
condition|)
block|{
name|THR_SET_STATE
argument_list|(
name|curthread
argument_list|,
name|PS_SUSPENDED
argument_list|)
expr_stmt|;
comment|/* 			 * These states don't timeout. 			 */
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|=
operator|-
literal|1
expr_stmt|;
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|=
operator|-
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|PS_SIGWAIT
case|:
name|PANIC
argument_list|(
literal|"bound thread does not have SIGWAIT state\n"
argument_list|)
expr_stmt|;
case|case
name|PS_SLEEP_WAIT
case|:
name|PANIC
argument_list|(
literal|"bound thread does not have SLEEP_WAIT state\n"
argument_list|)
expr_stmt|;
case|case
name|PS_SIGSUSPEND
case|:
name|PANIC
argument_list|(
literal|"bound thread does not have SIGSUSPEND state\n"
argument_list|)
expr_stmt|;
case|case
name|PS_DEADLOCK
case|:
comment|/* 		 * These states don't timeout and don't need 		 * to be in the waiting queue. 		 */
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|=
operator|-
literal|1
expr_stmt|;
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
name|PANIC
argument_list|(
literal|"Unknown state\n"
argument_list|)
expr_stmt|;
break|break;
block|}
while|while
condition|(
name|curthread
operator|->
name|state
operator|!=
name|PS_RUNNING
condition|)
block|{
name|sigseqno
operator|=
name|curkse
operator|->
name|k_sigseqno
expr_stmt|;
if|if
condition|(
name|curthread
operator|->
name|check_pending
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Install pending signals into the frame, possible 			 * cause mutex or condvar backout. 			 */
name|curthread
operator|->
name|check_pending
operator|=
literal|0
expr_stmt|;
name|SIGFILLSET
argument_list|(
name|sigmask
argument_list|)
expr_stmt|;
comment|/* 			 * Lock out kernel signal code when we are processing 			 * signals, and get a fresh copy of signal mask. 			 */
name|__sys_sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|sigmask
argument_list|,
operator|&
name|curthread
operator|->
name|sigmask
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|_SIG_MAXSIG
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|SIGISMEMBER
argument_list|(
name|curthread
operator|->
name|sigmask
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|SIGISMEMBER
argument_list|(
name|curthread
operator|->
name|sigpend
argument_list|,
name|i
argument_list|)
condition|)
operator|(
name|void
operator|)
name|_thr_sig_add
argument_list|(
name|curthread
argument_list|,
name|i
argument_list|,
operator|&
name|curthread
operator|->
name|siginfo
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|__sys_sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|curthread
operator|->
name|sigmask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* The above code might make thread runnable */
if|if
condition|(
name|curthread
operator|->
name|state
operator|==
name|PS_RUNNING
condition|)
break|break;
block|}
name|THR_DEACTIVATE_LAST_LOCK
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|kse_wait
argument_list|(
name|curkse
argument_list|,
name|curthread
argument_list|,
name|sigseqno
argument_list|)
expr_stmt|;
name|THR_ACTIVATE_LAST_LOCK
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|>=
literal|0
condition|)
block|{
name|KSE_GET_TOD
argument_list|(
name|curkse
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|thr_timedout
argument_list|(
name|curthread
argument_list|,
operator|&
name|ts
argument_list|)
condition|)
block|{
comment|/* Indicate the thread timedout: */
name|curthread
operator|->
name|timeout
operator|=
literal|1
expr_stmt|;
comment|/* Make the thread runnable. */
name|THR_SET_STATE
argument_list|(
name|curthread
argument_list|,
name|PS_RUNNING
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|curthread
operator|->
name|lock_switch
operator|==
literal|0
condition|)
block|{
comment|/* Unlock the scheduling queue. */
name|KSE_SCHED_UNLOCK
argument_list|(
name|curkse
argument_list|,
name|curkse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
block|}
name|DBG_MSG
argument_list|(
literal|"Continuing bound thread %p\n"
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|_kse_critical_leave
argument_list|(
operator|&
name|curthread
operator|->
name|tcb
operator|->
name|tcb_tmbx
argument_list|)
expr_stmt|;
name|pthread_exit
argument_list|(
name|curthread
operator|->
name|start_routine
argument_list|(
name|curthread
operator|->
name|arg
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_THREAD_KERN
end_ifdef

begin_function
specifier|static
name|void
name|dump_queues
parameter_list|(
name|struct
name|kse
modifier|*
name|curkse
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|thread
decl_stmt|;
name|DBG_MSG
argument_list|(
literal|"Threads in waiting queue:\n"
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|thread
argument_list|,
argument|&curkse->k_kseg->kg_schedq.sq_waitq
argument_list|,
argument|pqe
argument_list|)
block|{
name|DBG_MSG
argument_list|(
literal|"  thread %p, state %d, blocked %d\n"
argument_list|,
name|thread
argument_list|,
name|thread
operator|->
name|state
argument_list|,
name|thread
operator|->
name|blocked
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * This is the scheduler for a KSE which runs multiple threads.  */
end_comment

begin_function
specifier|static
name|void
name|kse_sched_multi
parameter_list|(
name|struct
name|kse_mailbox
modifier|*
name|kmbx
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|curkse
decl_stmt|;
name|struct
name|pthread
modifier|*
name|curthread
decl_stmt|,
modifier|*
name|td_wait
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|curkse
operator|=
operator|(
expr|struct
name|kse
operator|*
operator|)
name|kmbx
operator|->
name|km_udata
expr_stmt|;
name|THR_ASSERT
argument_list|(
name|curkse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_curthread
operator|==
name|NULL
argument_list|,
literal|"Mailbox not null in kse_sched_multi"
argument_list|)
expr_stmt|;
comment|/* Check for first time initialization: */
if|if
condition|(
name|__predict_false
argument_list|(
operator|(
name|curkse
operator|->
name|k_flags
operator|&
name|KF_INITIALIZED
operator|)
operator|==
literal|0
argument_list|)
condition|)
block|{
comment|/* Setup this KSEs specific data. */
name|_kcb_set
argument_list|(
name|curkse
operator|->
name|k_kcb
argument_list|)
expr_stmt|;
comment|/* Set this before grabbing the context. */
name|curkse
operator|->
name|k_flags
operator||=
name|KF_INITIALIZED
expr_stmt|;
block|}
comment|/* 	 * No current thread anymore, calling _get_curthread in UTS 	 * should dump core 	 */
name|_tcb_set
argument_list|(
name|curkse
operator|->
name|k_kcb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If this is an upcall; take the scheduler lock. */
if|if
condition|(
operator|!
name|KSE_IS_SWITCH
argument_list|(
name|curkse
argument_list|)
condition|)
name|KSE_SCHED_LOCK
argument_list|(
name|curkse
argument_list|,
name|curkse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
else|else
name|KSE_CLEAR_SWITCH
argument_list|(
name|curkse
argument_list|)
expr_stmt|;
if|if
condition|(
name|KSE_IS_IDLE
argument_list|(
name|curkse
argument_list|)
condition|)
block|{
name|KSE_CLEAR_IDLE
argument_list|(
name|curkse
argument_list|)
expr_stmt|;
name|curkse
operator|->
name|k_kseg
operator|->
name|kg_idle_kses
operator|--
expr_stmt|;
block|}
comment|/* 	 * Now that the scheduler lock is held, get the current 	 * thread.  The KSE's current thread cannot be safely 	 * examined without the lock because it could have returned 	 * as completed on another KSE.  See kse_check_completed(). 	 */
name|curthread
operator|=
name|curkse
operator|->
name|k_curthread
expr_stmt|;
comment|/* 	 * If the current thread was completed in another KSE, then 	 * it will be in the run queue.  Don't mark it as being blocked. 	 */
if|if
condition|(
operator|(
name|curthread
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|curthread
operator|->
name|flags
operator|&
name|THR_FLAGS_IN_RUNQ
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|curthread
operator|->
name|need_switchout
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * Assume the current thread is blocked; when the 		 * completed threads are checked and if the current 		 * thread is among the completed, the blocked flag 		 * will be cleared. 		 */
name|curthread
operator|->
name|blocked
operator|=
literal|1
expr_stmt|;
name|DBG_MSG
argument_list|(
literal|"Running thread %p is now blocked in kernel.\n"
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
block|}
comment|/* Check for any unblocked threads in the kernel. */
name|kse_check_completed
argument_list|(
name|curkse
argument_list|)
expr_stmt|;
comment|/* 	 * Check for threads that have timed-out. 	 */
name|kse_check_waitq
argument_list|(
name|curkse
argument_list|)
expr_stmt|;
comment|/* 	 * Switchout the current thread, if necessary, as the last step 	 * so that it is inserted into the run queue (if it's runnable) 	 * _after_ any other threads that were added to it above. 	 */
if|if
condition|(
name|curthread
operator|==
name|NULL
condition|)
empty_stmt|;
comment|/* Nothing to do here. */
elseif|else
if|if
condition|(
operator|(
name|curthread
operator|->
name|need_switchout
operator|==
literal|0
operator|)
operator|&&
name|DBG_CAN_RUN
argument_list|(
name|curthread
argument_list|)
operator|&&
operator|(
name|curthread
operator|->
name|blocked
operator|==
literal|0
operator|)
operator|&&
operator|(
name|THR_IN_CRITICAL
argument_list|(
name|curthread
argument_list|)
operator|)
condition|)
block|{
comment|/* 		 * Resume the thread and tell it to yield when 		 * it leaves the critical region. 		 */
name|curthread
operator|->
name|critical_yield
operator|=
literal|1
expr_stmt|;
name|curthread
operator|->
name|active
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|curthread
operator|->
name|flags
operator|&
name|THR_FLAGS_IN_RUNQ
operator|)
operator|!=
literal|0
condition|)
name|KSE_RUNQ_REMOVE
argument_list|(
name|curkse
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|curkse
operator|->
name|k_curthread
operator|=
name|curthread
expr_stmt|;
name|curthread
operator|->
name|kse
operator|=
name|curkse
expr_stmt|;
name|DBG_MSG
argument_list|(
literal|"Continuing thread %p in critical region\n"
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
name|kse_wakeup_multi
argument_list|(
name|curkse
argument_list|)
expr_stmt|;
name|KSE_SCHED_UNLOCK
argument_list|(
name|curkse
argument_list|,
name|curkse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
name|ret
operator|=
name|_thread_switch
argument_list|(
name|curkse
operator|->
name|k_kcb
argument_list|,
name|curthread
operator|->
name|tcb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|PANIC
argument_list|(
literal|"Can't resume thread in critical region\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|curthread
operator|->
name|flags
operator|&
name|THR_FLAGS_IN_RUNQ
operator|)
operator|==
literal|0
condition|)
block|{
name|curthread
operator|->
name|tcb
operator|->
name|tcb_tmbx
operator|.
name|tm_lwp
operator|=
literal|0
expr_stmt|;
name|kse_switchout_thread
argument_list|(
name|curkse
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
block|}
name|curkse
operator|->
name|k_curthread
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_THREAD_KERN
name|dump_queues
argument_list|(
name|curkse
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Check if there are no threads ready to run: */
while|while
condition|(
operator|(
operator|(
name|curthread
operator|=
name|KSE_RUNQ_FIRST
argument_list|(
name|curkse
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|curkse
operator|->
name|k_kseg
operator|->
name|kg_threadcount
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|curkse
operator|->
name|k_flags
operator|&
name|KF_TERMINATED
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 		 * Wait for a thread to become active or until there are 		 * no more threads. 		 */
name|td_wait
operator|=
name|KSE_WAITQ_FIRST
argument_list|(
name|curkse
argument_list|)
expr_stmt|;
name|kse_wait
argument_list|(
name|curkse
argument_list|,
name|td_wait
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kse_check_completed
argument_list|(
name|curkse
argument_list|)
expr_stmt|;
name|kse_check_waitq
argument_list|(
name|curkse
argument_list|)
expr_stmt|;
block|}
comment|/* Check for no more threads: */
if|if
condition|(
operator|(
name|curkse
operator|->
name|k_kseg
operator|->
name|kg_threadcount
operator|==
literal|0
operator|)
operator|||
operator|(
operator|(
name|curkse
operator|->
name|k_flags
operator|&
name|KF_TERMINATED
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* 		 * Normally this shouldn't return, but it will if there 		 * are other KSEs running that create new threads that 		 * are assigned to this KSE[G].  For instance, if a scope 		 * system thread were to create a scope process thread 		 * and this kse[g] is the initial kse[g], then that newly 		 * created thread would be assigned to us (the initial 		 * kse[g]). 		 */
name|kse_wakeup_multi
argument_list|(
name|curkse
argument_list|)
expr_stmt|;
name|KSE_SCHED_UNLOCK
argument_list|(
name|curkse
argument_list|,
name|curkse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
name|kse_fini
argument_list|(
name|curkse
argument_list|)
expr_stmt|;
comment|/* never returns */
block|}
name|THR_ASSERT
argument_list|(
name|curthread
operator|!=
name|NULL
argument_list|,
literal|"Return from kse_wait/fini without thread."
argument_list|)
expr_stmt|;
name|THR_ASSERT
argument_list|(
name|curthread
operator|->
name|state
operator|!=
name|PS_DEAD
argument_list|,
literal|"Trying to resume dead thread!"
argument_list|)
expr_stmt|;
name|KSE_RUNQ_REMOVE
argument_list|(
name|curkse
argument_list|,
name|curthread
argument_list|)
expr_stmt|;
comment|/* 	 * Make the selected thread the current thread. 	 */
name|curkse
operator|->
name|k_curthread
operator|=
name|curthread
expr_stmt|;
comment|/* 	 * Make sure the current thread's kse points to this kse. 	 */
name|curthread
operator|->
name|kse
operator|=
name|curkse
expr_stmt|;
comment|/* 	 * Reset the time slice if this thread is running for the first 	 * time or running again after using its full time slice allocation. 	 */
if|if
condition|(
name|curthread
operator|->
name|slice_usec
operator|==
operator|-
literal|1
condition|)
name|curthread
operator|->
name|slice_usec
operator|=
literal|0
expr_stmt|;
comment|/* Mark the thread active. */
name|curthread
operator|->
name|active
operator|=
literal|1
expr_stmt|;
comment|/* 	 * The thread's current signal frame will only be NULL if it 	 * is being resumed after being blocked in the kernel.  In 	 * this case, and if the thread needs to run down pending 	 * signals or needs a cancellation check, we need to add a 	 * signal frame to the thread's context. 	 */
if|if
condition|(
name|curthread
operator|->
name|lock_switch
operator|==
literal|0
operator|&&
name|curthread
operator|->
name|state
operator|==
name|PS_RUNNING
operator|&&
operator|(
name|curthread
operator|->
name|check_pending
operator|!=
literal|0
operator|||
name|THR_NEED_ASYNC_CANCEL
argument_list|(
name|curthread
argument_list|)
operator|)
operator|&&
operator|!
name|THR_IN_CRITICAL
argument_list|(
name|curthread
argument_list|)
condition|)
block|{
name|curthread
operator|->
name|check_pending
operator|=
literal|0
expr_stmt|;
name|signalcontext
argument_list|(
operator|&
name|curthread
operator|->
name|tcb
operator|->
name|tcb_tmbx
operator|.
name|tm_context
argument_list|,
literal|0
argument_list|,
operator|(
name|__sighandler_t
operator|*
operator|)
name|thr_resume_wrapper
argument_list|)
expr_stmt|;
block|}
name|kse_wakeup_multi
argument_list|(
name|curkse
argument_list|)
expr_stmt|;
comment|/* 	 * Continue the thread at its current frame: 	 */
if|if
condition|(
name|curthread
operator|->
name|lock_switch
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * This thread came from a scheduler switch; it will 		 * unlock the scheduler lock and set the mailbox. 		 */
name|ret
operator|=
name|_thread_switch
argument_list|(
name|curkse
operator|->
name|k_kcb
argument_list|,
name|curthread
operator|->
name|tcb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This thread won't unlock the scheduler lock. */
name|KSE_SCHED_UNLOCK
argument_list|(
name|curkse
argument_list|,
name|curkse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
name|ret
operator|=
name|_thread_switch
argument_list|(
name|curkse
operator|->
name|k_kcb
argument_list|,
name|curthread
operator|->
name|tcb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|PANIC
argument_list|(
literal|"Thread has returned from _thread_switch"
argument_list|)
expr_stmt|;
comment|/* This point should not be reached. */
name|PANIC
argument_list|(
literal|"Thread has returned from _thread_switch"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|thr_resume_wrapper
parameter_list|(
name|int
name|sig
parameter_list|,
name|siginfo_t
modifier|*
name|siginfo
parameter_list|,
name|ucontext_t
modifier|*
name|ucp
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|curthread
init|=
name|_get_curthread
argument_list|()
decl_stmt|;
name|struct
name|kse
modifier|*
name|curkse
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|err_save
init|=
name|errno
decl_stmt|;
name|DBG_MSG
argument_list|(
literal|">>> sig wrapper\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|curthread
operator|->
name|lock_switch
condition|)
name|PANIC
argument_list|(
literal|"thr_resume_wrapper, lock_switch != 0\n"
argument_list|)
expr_stmt|;
name|thr_resume_check
argument_list|(
name|curthread
argument_list|,
name|ucp
argument_list|)
expr_stmt|;
name|errno
operator|=
name|err_save
expr_stmt|;
name|_kse_critical_enter
argument_list|()
expr_stmt|;
name|curkse
operator|=
name|curthread
operator|->
name|kse
expr_stmt|;
name|curthread
operator|->
name|tcb
operator|->
name|tcb_tmbx
operator|.
name|tm_context
operator|=
operator|*
name|ucp
expr_stmt|;
name|ret
operator|=
name|_thread_switch
argument_list|(
name|curkse
operator|->
name|k_kcb
argument_list|,
name|curthread
operator|->
name|tcb
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|PANIC
argument_list|(
literal|"thr_resume_wrapper: thread has returned "
literal|"from _thread_switch"
argument_list|)
expr_stmt|;
comment|/* THR_SETCONTEXT(ucp); */
comment|/* not work, why ? */
block|}
end_function

begin_function
specifier|static
name|void
name|thr_resume_check
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|,
name|ucontext_t
modifier|*
name|ucp
parameter_list|)
block|{
name|_thr_sig_rundown
argument_list|(
name|curthread
argument_list|,
name|ucp
argument_list|)
expr_stmt|;
if|if
condition|(
name|THR_NEED_ASYNC_CANCEL
argument_list|(
name|curthread
argument_list|)
condition|)
name|pthread_testcancel
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Clean up a thread.  This must be called with the thread's KSE  * scheduling lock held.  The thread must be a thread from the  * KSE's group.  */
end_comment

begin_function
specifier|static
name|void
name|thr_cleanup
parameter_list|(
name|struct
name|kse
modifier|*
name|curkse
parameter_list|,
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|joiner
decl_stmt|;
name|struct
name|kse_mailbox
modifier|*
name|kmbx
init|=
name|NULL
decl_stmt|;
name|int
name|sys_scope
decl_stmt|;
name|thread
operator|->
name|active
operator|=
literal|0
expr_stmt|;
name|thread
operator|->
name|need_switchout
operator|=
literal|0
expr_stmt|;
name|thread
operator|->
name|lock_switch
operator|=
literal|0
expr_stmt|;
name|thread
operator|->
name|check_pending
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|joiner
operator|=
name|thread
operator|->
name|joiner
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Joinee scheduler lock held; joiner won't leave. */
if|if
condition|(
name|joiner
operator|->
name|kseg
operator|==
name|curkse
operator|->
name|k_kseg
condition|)
block|{
if|if
condition|(
name|joiner
operator|->
name|join_status
operator|.
name|thread
operator|==
name|thread
condition|)
block|{
name|joiner
operator|->
name|join_status
operator|.
name|thread
operator|=
name|NULL
expr_stmt|;
name|joiner
operator|->
name|join_status
operator|.
name|ret
operator|=
name|thread
operator|->
name|ret
expr_stmt|;
operator|(
name|void
operator|)
name|_thr_setrunnable_unlocked
argument_list|(
name|joiner
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|KSE_SCHED_UNLOCK
argument_list|(
name|curkse
argument_list|,
name|curkse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
comment|/* The joiner may have removed itself and exited. */
if|if
condition|(
name|_thr_ref_add
argument_list|(
name|thread
argument_list|,
name|joiner
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|KSE_SCHED_LOCK
argument_list|(
name|curkse
argument_list|,
name|joiner
operator|->
name|kseg
argument_list|)
expr_stmt|;
if|if
condition|(
name|joiner
operator|->
name|join_status
operator|.
name|thread
operator|==
name|thread
condition|)
block|{
name|joiner
operator|->
name|join_status
operator|.
name|thread
operator|=
name|NULL
expr_stmt|;
name|joiner
operator|->
name|join_status
operator|.
name|ret
operator|=
name|thread
operator|->
name|ret
expr_stmt|;
name|kmbx
operator|=
name|_thr_setrunnable_unlocked
argument_list|(
name|joiner
argument_list|)
expr_stmt|;
block|}
name|KSE_SCHED_UNLOCK
argument_list|(
name|curkse
argument_list|,
name|joiner
operator|->
name|kseg
argument_list|)
expr_stmt|;
name|_thr_ref_delete
argument_list|(
name|thread
argument_list|,
name|joiner
argument_list|)
expr_stmt|;
if|if
condition|(
name|kmbx
operator|!=
name|NULL
condition|)
name|kse_wakeup
argument_list|(
name|kmbx
argument_list|)
expr_stmt|;
block|}
name|KSE_SCHED_LOCK
argument_list|(
name|curkse
argument_list|,
name|curkse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
block|}
name|thread
operator|->
name|attr
operator|.
name|flags
operator||=
name|PTHREAD_DETACHED
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|sys_scope
operator|=
operator|(
name|thread
operator|->
name|attr
operator|.
name|flags
operator|&
name|PTHREAD_SCOPE_SYSTEM
operator|)
operator|)
condition|)
block|{
comment|/* 		 * Remove the thread from the KSEG's list of threads. 	 	 */
name|KSEG_THRQ_REMOVE
argument_list|(
name|thread
operator|->
name|kseg
argument_list|,
name|thread
argument_list|)
expr_stmt|;
comment|/* 		 * Migrate the thread to the main KSE so that this 		 * KSE and KSEG can be cleaned when their last thread 		 * exits. 		 */
name|thread
operator|->
name|kseg
operator|=
name|_kse_initial
operator|->
name|k_kseg
expr_stmt|;
name|thread
operator|->
name|kse
operator|=
name|_kse_initial
expr_stmt|;
block|}
comment|/* 	 * We can't hold the thread list lock while holding the 	 * scheduler lock. 	 */
name|KSE_SCHED_UNLOCK
argument_list|(
name|curkse
argument_list|,
name|curkse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
name|DBG_MSG
argument_list|(
literal|"Adding thread %p to GC list\n"
argument_list|,
name|thread
argument_list|)
expr_stmt|;
name|KSE_LOCK_ACQUIRE
argument_list|(
name|curkse
argument_list|,
operator|&
name|_thread_list_lock
argument_list|)
expr_stmt|;
name|thread
operator|->
name|tlflags
operator||=
name|TLFLAGS_GC_SAFE
expr_stmt|;
name|THR_GCLIST_ADD
argument_list|(
name|thread
argument_list|)
expr_stmt|;
name|KSE_LOCK_RELEASE
argument_list|(
name|curkse
argument_list|,
operator|&
name|_thread_list_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|sys_scope
condition|)
block|{
comment|/* 		 * System scope thread is single thread group,  		 * when thread is exited, its kse and ksegrp should 		 * be recycled as well. 		 * kse upcall stack belongs to thread, clear it here. 		 */
name|curkse
operator|->
name|k_stack
operator|.
name|ss_sp
operator|=
literal|0
expr_stmt|;
name|curkse
operator|->
name|k_stack
operator|.
name|ss_size
operator|=
literal|0
expr_stmt|;
name|kse_exit
argument_list|()
expr_stmt|;
name|PANIC
argument_list|(
literal|"kse_exit() failed for system scope thread"
argument_list|)
expr_stmt|;
block|}
name|KSE_SCHED_LOCK
argument_list|(
name|curkse
argument_list|,
name|curkse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_thr_gc
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|)
block|{
name|thread_gc
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|kse_gc
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
name|kseg_gc
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|thread_gc
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|td
decl_stmt|,
modifier|*
name|td_next
decl_stmt|;
name|kse_critical_t
name|crit
decl_stmt|;
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|pthread
argument_list|)
name|worklist
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|worklist
argument_list|)
expr_stmt|;
name|crit
operator|=
name|_kse_critical_enter
argument_list|()
expr_stmt|;
name|KSE_LOCK_ACQUIRE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|_thread_list_lock
argument_list|)
expr_stmt|;
comment|/* Check the threads waiting for GC. */
for|for
control|(
name|td
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|_thread_gc_list
argument_list|)
init|;
name|td
operator|!=
name|NULL
condition|;
name|td
operator|=
name|td_next
control|)
block|{
name|td_next
operator|=
name|TAILQ_NEXT
argument_list|(
name|td
argument_list|,
name|gcle
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|td
operator|->
name|tlflags
operator|&
name|TLFLAGS_GC_SAFE
operator|)
operator|==
literal|0
condition|)
continue|continue;
elseif|else
if|if
condition|(
operator|(
operator|(
name|td
operator|->
name|attr
operator|.
name|flags
operator|&
name|PTHREAD_SCOPE_SYSTEM
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|td
operator|->
name|kse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_flags
operator|&
name|KMF_DONE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 			 * The thread and KSE are operating on the same 			 * stack.  Wait for the KSE to exit before freeing 			 * the thread's stack as well as everything else. 			 */
continue|continue;
block|}
comment|/* 		 * Remove the thread from the GC list.  If the thread 		 * isn't yet detached, it will get added back to the 		 * GC list at a later time. 		 */
name|THR_GCLIST_REMOVE
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|DBG_MSG
argument_list|(
literal|"Freeing thread %p stack\n"
argument_list|,
name|td
argument_list|)
expr_stmt|;
comment|/* 		 * We can free the thread stack since it's no longer 		 * in use. 		 */
name|_thr_stack_free
argument_list|(
operator|&
name|td
operator|->
name|attr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|td
operator|->
name|attr
operator|.
name|flags
operator|&
name|PTHREAD_DETACHED
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|td
operator|->
name|refcount
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* 			 * The thread has detached and is no longer 			 * referenced.  It is safe to remove all 			 * remnants of the thread. 			 */
name|THR_LIST_REMOVE
argument_list|(
name|td
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|worklist
argument_list|,
name|td
argument_list|,
name|gcle
argument_list|)
expr_stmt|;
block|}
block|}
name|KSE_LOCK_RELEASE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|_thread_list_lock
argument_list|)
expr_stmt|;
name|_kse_critical_leave
argument_list|(
name|crit
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|td
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|worklist
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|worklist
argument_list|,
name|td
argument_list|,
name|gcle
argument_list|)
expr_stmt|;
comment|/* 		 * XXX we don't free initial thread and its kse 		 * (if thread is a bound thread), because there might 		 * have some code referencing initial thread and kse. 		 */
if|if
condition|(
name|td
operator|==
name|_thr_initial
condition|)
block|{
name|DBG_MSG
argument_list|(
literal|"Initial thread won't be freed\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|td
operator|->
name|attr
operator|.
name|flags
operator|&
name|PTHREAD_SCOPE_SYSTEM
operator|)
operator|!=
literal|0
condition|)
block|{
name|crit
operator|=
name|_kse_critical_enter
argument_list|()
expr_stmt|;
name|KSE_LOCK_ACQUIRE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
name|kse_free_unlocked
argument_list|(
name|td
operator|->
name|kse
argument_list|)
expr_stmt|;
name|kseg_free_unlocked
argument_list|(
name|td
operator|->
name|kseg
argument_list|)
expr_stmt|;
name|KSE_LOCK_RELEASE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
name|_kse_critical_leave
argument_list|(
name|crit
argument_list|)
expr_stmt|;
block|}
name|DBG_MSG
argument_list|(
literal|"Freeing thread %p\n"
argument_list|,
name|td
argument_list|)
expr_stmt|;
name|_thr_free
argument_list|(
name|curthread
argument_list|,
name|td
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|kse_gc
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|)
block|{
name|kse_critical_t
name|crit
decl_stmt|;
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|kse
argument_list|)
name|worklist
expr_stmt|;
name|struct
name|kse
modifier|*
name|kse
decl_stmt|;
if|if
condition|(
name|free_kse_count
operator|<=
name|MAX_CACHED_KSES
condition|)
return|return;
name|TAILQ_INIT
argument_list|(
operator|&
name|worklist
argument_list|)
expr_stmt|;
name|crit
operator|=
name|_kse_critical_enter
argument_list|()
expr_stmt|;
name|KSE_LOCK_ACQUIRE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|free_kse_count
operator|>
name|MAX_CACHED_KSES
condition|)
block|{
name|kse
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|free_kseq
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|free_kseq
argument_list|,
name|kse
argument_list|,
name|k_qe
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|worklist
argument_list|,
name|kse
argument_list|,
name|k_qe
argument_list|)
expr_stmt|;
name|free_kse_count
operator|--
expr_stmt|;
block|}
name|KSE_LOCK_RELEASE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
name|_kse_critical_leave
argument_list|(
name|crit
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|kse
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|worklist
argument_list|)
operator|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|worklist
argument_list|,
name|kse
argument_list|,
name|k_qe
argument_list|)
expr_stmt|;
name|kse_destroy
argument_list|(
name|kse
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|kseg_gc
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|)
block|{
name|kse_critical_t
name|crit
decl_stmt|;
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|kse_group
argument_list|)
name|worklist
expr_stmt|;
name|struct
name|kse_group
modifier|*
name|kseg
decl_stmt|;
if|if
condition|(
name|free_kseg_count
operator|<=
name|MAX_CACHED_KSEGS
condition|)
return|return;
name|TAILQ_INIT
argument_list|(
operator|&
name|worklist
argument_list|)
expr_stmt|;
name|crit
operator|=
name|_kse_critical_enter
argument_list|()
expr_stmt|;
name|KSE_LOCK_ACQUIRE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|free_kseg_count
operator|>
name|MAX_CACHED_KSEGS
condition|)
block|{
name|kseg
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|free_kse_groupq
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|free_kse_groupq
argument_list|,
name|kseg
argument_list|,
name|kg_qe
argument_list|)
expr_stmt|;
name|free_kseg_count
operator|--
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|worklist
argument_list|,
name|kseg
argument_list|,
name|kg_qe
argument_list|)
expr_stmt|;
block|}
name|KSE_LOCK_RELEASE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
name|_kse_critical_leave
argument_list|(
name|crit
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|kseg
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|worklist
argument_list|)
operator|)
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|worklist
argument_list|,
name|kseg
argument_list|,
name|kg_qe
argument_list|)
expr_stmt|;
name|kseg_destroy
argument_list|(
name|kseg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Only new threads that are running or suspended may be scheduled.  */
end_comment

begin_function
name|int
name|_thr_schedule_add
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|,
name|struct
name|pthread
modifier|*
name|newthread
parameter_list|)
block|{
name|kse_critical_t
name|crit
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* Add the new thread. */
name|thr_link
argument_list|(
name|newthread
argument_list|)
expr_stmt|;
comment|/* 	 * If this is the first time creating a thread, make sure 	 * the mailbox is set for the current thread. 	 */
if|if
condition|(
operator|(
name|newthread
operator|->
name|attr
operator|.
name|flags
operator|&
name|PTHREAD_SCOPE_SYSTEM
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* We use the thread's stack as the KSE's stack. */
name|newthread
operator|->
name|kse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_stack
operator|.
name|ss_sp
operator|=
name|newthread
operator|->
name|attr
operator|.
name|stackaddr_attr
expr_stmt|;
name|newthread
operator|->
name|kse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_stack
operator|.
name|ss_size
operator|=
name|newthread
operator|->
name|attr
operator|.
name|stacksize_attr
expr_stmt|;
comment|/* 		 * No need to lock the scheduling queue since the 		 * KSE/KSEG pair have not yet been started. 		 */
name|KSEG_THRQ_ADD
argument_list|(
name|newthread
operator|->
name|kseg
argument_list|,
name|newthread
argument_list|)
expr_stmt|;
comment|/* this thread never gives up kse */
name|newthread
operator|->
name|active
operator|=
literal|1
expr_stmt|;
name|newthread
operator|->
name|kse
operator|->
name|k_curthread
operator|=
name|newthread
expr_stmt|;
name|newthread
operator|->
name|kse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_flags
operator|=
name|KMF_BOUND
expr_stmt|;
name|newthread
operator|->
name|kse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_func
operator|=
operator|(
name|kse_func_t
operator|*
operator|)
name|kse_sched_single
expr_stmt|;
name|newthread
operator|->
name|kse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_quantum
operator|=
literal|0
expr_stmt|;
name|KSE_SET_MBOX
argument_list|(
name|newthread
operator|->
name|kse
argument_list|,
name|newthread
argument_list|)
expr_stmt|;
comment|/* 		 * This thread needs a new KSE and KSEG. 		 */
name|newthread
operator|->
name|kse
operator|->
name|k_flags
operator|&=
operator|~
name|KF_INITIALIZED
expr_stmt|;
name|newthread
operator|->
name|kse
operator|->
name|k_flags
operator||=
name|KF_STARTED
expr_stmt|;
comment|/* Fire up! */
name|ret
operator|=
name|kse_create
argument_list|(
operator|&
name|newthread
operator|->
name|kse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|ret
operator|=
name|errno
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Lock the KSE and add the new thread to its list of 		 * assigned threads.  If the new thread is runnable, also 		 * add it to the KSE's run queue. 		 */
name|crit
operator|=
name|_kse_critical_enter
argument_list|()
expr_stmt|;
name|KSE_SCHED_LOCK
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
name|newthread
operator|->
name|kseg
argument_list|)
expr_stmt|;
name|KSEG_THRQ_ADD
argument_list|(
name|newthread
operator|->
name|kseg
argument_list|,
name|newthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|newthread
operator|->
name|state
operator|==
name|PS_RUNNING
condition|)
name|THR_RUNQ_INSERT_TAIL
argument_list|(
name|newthread
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|newthread
operator|->
name|kse
operator|->
name|k_flags
operator|&
name|KF_STARTED
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * This KSE hasn't been started yet.  Start it 			 * outside of holding the lock. 			 */
name|newthread
operator|->
name|kse
operator|->
name|k_flags
operator||=
name|KF_STARTED
expr_stmt|;
name|newthread
operator|->
name|kse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_func
operator|=
operator|(
name|kse_func_t
operator|*
operator|)
name|kse_sched_multi
expr_stmt|;
name|newthread
operator|->
name|kse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_flags
operator|=
literal|0
expr_stmt|;
name|kse_create
argument_list|(
operator|&
name|newthread
operator|->
name|kse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|newthread
operator|->
name|state
operator|==
name|PS_RUNNING
operator|)
operator|&&
name|KSE_IS_IDLE
argument_list|(
name|newthread
operator|->
name|kse
argument_list|)
condition|)
block|{
comment|/* 			 * The thread is being scheduled on another KSEG. 			 */
name|kse_wakeup_one
argument_list|(
name|newthread
argument_list|)
expr_stmt|;
block|}
name|KSE_SCHED_UNLOCK
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
name|newthread
operator|->
name|kseg
argument_list|)
expr_stmt|;
name|_kse_critical_leave
argument_list|(
name|crit
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
name|thr_unlink
argument_list|(
name|newthread
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|kse_waitq_insert
parameter_list|(
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|td
decl_stmt|;
if|if
condition|(
name|thread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|==
operator|-
literal|1
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|thread
operator|->
name|kse
operator|->
name|k_schedq
operator|->
name|sq_waitq
argument_list|,
name|thread
argument_list|,
name|pqe
argument_list|)
expr_stmt|;
else|else
block|{
name|td
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|thread
operator|->
name|kse
operator|->
name|k_schedq
operator|->
name|sq_waitq
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|td
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|td
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|!=
operator|-
literal|1
operator|)
operator|&&
operator|(
operator|(
name|td
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|<
name|thread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|)
operator|||
operator|(
operator|(
name|td
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|==
name|thread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|)
operator|&&
operator|(
name|td
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|<=
name|thread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|)
operator|)
operator|)
condition|)
name|td
operator|=
name|TAILQ_NEXT
argument_list|(
name|td
argument_list|,
name|pqe
argument_list|)
expr_stmt|;
if|if
condition|(
name|td
operator|==
name|NULL
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|thread
operator|->
name|kse
operator|->
name|k_schedq
operator|->
name|sq_waitq
argument_list|,
name|thread
argument_list|,
name|pqe
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_BEFORE
argument_list|(
name|td
argument_list|,
name|thread
argument_list|,
name|pqe
argument_list|)
expr_stmt|;
block|}
name|thread
operator|->
name|flags
operator||=
name|THR_FLAGS_IN_WAITQ
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This must be called with the scheduling lock held.  */
end_comment

begin_function
specifier|static
name|void
name|kse_check_completed
parameter_list|(
name|struct
name|kse
modifier|*
name|kse
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|thread
decl_stmt|;
name|struct
name|kse_thr_mailbox
modifier|*
name|completed
decl_stmt|;
name|int
name|sig
decl_stmt|;
if|if
condition|(
operator|(
name|completed
operator|=
name|kse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_completed
operator|)
operator|!=
name|NULL
condition|)
block|{
name|kse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_completed
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|completed
operator|!=
name|NULL
condition|)
block|{
name|thread
operator|=
name|completed
operator|->
name|tm_udata
expr_stmt|;
name|DBG_MSG
argument_list|(
literal|"Found completed thread %p, name %s\n"
argument_list|,
name|thread
argument_list|,
operator|(
name|thread
operator|->
name|name
operator|==
name|NULL
operator|)
condition|?
literal|"none"
else|:
name|thread
operator|->
name|name
argument_list|)
expr_stmt|;
name|thread
operator|->
name|blocked
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|thread
operator|!=
name|kse
operator|->
name|k_curthread
condition|)
block|{
name|thr_accounting
argument_list|(
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|thread
operator|->
name|flags
operator|&
name|THR_FLAGS_SUSPENDED
operator|)
operator|!=
literal|0
condition|)
name|THR_SET_STATE
argument_list|(
name|thread
argument_list|,
name|PS_SUSPENDED
argument_list|)
expr_stmt|;
else|else
name|KSE_RUNQ_INSERT_TAIL
argument_list|(
name|kse
argument_list|,
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|thread
operator|->
name|kse
operator|!=
name|kse
operator|)
operator|&&
operator|(
name|thread
operator|->
name|kse
operator|->
name|k_curthread
operator|==
name|thread
operator|)
condition|)
block|{
comment|/* 					 * Remove this thread from its 					 * previous KSE so that it (the KSE) 					 * doesn't think it is still active. 					 */
name|thread
operator|->
name|kse
operator|->
name|k_curthread
operator|=
name|NULL
expr_stmt|;
name|thread
operator|->
name|active
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|sig
operator|=
name|thread
operator|->
name|tcb
operator|->
name|tcb_tmbx
operator|.
name|tm_syncsig
operator|.
name|si_signo
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|SIGISMEMBER
argument_list|(
name|thread
operator|->
name|sigmask
argument_list|,
name|sig
argument_list|)
condition|)
name|SIGADDSET
argument_list|(
name|thread
operator|->
name|sigpend
argument_list|,
name|sig
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|THR_IN_CRITICAL
argument_list|(
name|thread
argument_list|)
condition|)
name|kse_thr_interrupt
argument_list|(
name|NULL
argument_list|,
name|KSE_INTR_SIGEXIT
argument_list|,
name|sig
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|_thr_sig_add
argument_list|(
name|thread
argument_list|,
name|sig
argument_list|,
operator|&
name|thread
operator|->
name|tcb
operator|->
name|tcb_tmbx
operator|.
name|tm_syncsig
argument_list|)
expr_stmt|;
name|thread
operator|->
name|tcb
operator|->
name|tcb_tmbx
operator|.
name|tm_syncsig
operator|.
name|si_signo
operator|=
literal|0
expr_stmt|;
block|}
name|completed
operator|=
name|completed
operator|->
name|tm_next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * This must be called with the scheduling lock held.  */
end_comment

begin_function
specifier|static
name|void
name|kse_check_waitq
parameter_list|(
name|struct
name|kse
modifier|*
name|kse
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|pthread
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
name|KSE_GET_TOD
argument_list|(
name|kse
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
comment|/* 	 * Wake up threads that have timedout.  This has to be 	 * done before adding the current thread to the run queue 	 * so that a CPU intensive thread doesn't get preference 	 * over waiting threads. 	 */
while|while
condition|(
operator|(
operator|(
name|pthread
operator|=
name|KSE_WAITQ_FIRST
argument_list|(
name|kse
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|&&
name|thr_timedout
argument_list|(
name|pthread
argument_list|,
operator|&
name|ts
argument_list|)
condition|)
block|{
comment|/* Remove the thread from the wait queue: */
name|KSE_WAITQ_REMOVE
argument_list|(
name|kse
argument_list|,
name|pthread
argument_list|)
expr_stmt|;
name|DBG_MSG
argument_list|(
literal|"Found timedout thread %p in waitq\n"
argument_list|,
name|pthread
argument_list|)
expr_stmt|;
comment|/* Indicate the thread timedout: */
name|pthread
operator|->
name|timeout
operator|=
literal|1
expr_stmt|;
comment|/* Add the thread to the priority queue: */
if|if
condition|(
operator|(
name|pthread
operator|->
name|flags
operator|&
name|THR_FLAGS_SUSPENDED
operator|)
operator|!=
literal|0
condition|)
name|THR_SET_STATE
argument_list|(
name|pthread
argument_list|,
name|PS_SUSPENDED
argument_list|)
expr_stmt|;
else|else
block|{
name|THR_SET_STATE
argument_list|(
name|pthread
argument_list|,
name|PS_RUNNING
argument_list|)
expr_stmt|;
name|KSE_RUNQ_INSERT_TAIL
argument_list|(
name|kse
argument_list|,
name|pthread
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|thr_timedout
parameter_list|(
name|struct
name|pthread
modifier|*
name|thread
parameter_list|,
name|struct
name|timespec
modifier|*
name|curtime
parameter_list|)
block|{
if|if
condition|(
name|thread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
elseif|else
if|if
condition|(
name|thread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|>
name|curtime
operator|->
name|tv_sec
condition|)
return|return
operator|(
literal|0
operator|)
return|;
elseif|else
if|if
condition|(
operator|(
name|thread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|==
name|curtime
operator|->
name|tv_sec
operator|)
operator|&&
operator|(
name|thread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|>
name|curtime
operator|->
name|tv_nsec
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This must be called with the scheduling lock held.  *  * Each thread has a time slice, a wakeup time (used when it wants  * to wait for a specified amount of time), a run state, and an  * active flag.  *  * When a thread gets run by the scheduler, the active flag is  * set to non-zero (1).  When a thread performs an explicit yield  * or schedules a state change, it enters the scheduler and the  * active flag is cleared.  When the active flag is still seen  * set in the scheduler, that means that the thread is blocked in  * the kernel (because it is cleared before entering the scheduler  * in all other instances).  *  * The wakeup time is only set for those states that can timeout.  * It is set to (-1, -1) for all other instances.  *  * The thread's run state, aside from being useful when debugging,  * is used to place the thread in an appropriate queue.  There  * are 2 basic queues:  *  *   o run queue - queue ordered by priority for all threads  *                 that are runnable  *   o waiting queue - queue sorted by wakeup time for all threads  *                     that are not otherwise runnable (not blocked  *                     in kernel, not waiting for locks)  *  * The thread's time slice is used for round-robin scheduling  * (the default scheduling policy).  While a SCHED_RR thread  * is runnable it's time slice accumulates.  When it reaches  * the time slice interval, it gets reset and added to the end  * of the queue of threads at its priority.  When a thread no  * longer becomes runnable (blocks in kernel, waits, etc), its  * time slice is reset.  *  * The job of kse_switchout_thread() is to handle all of the above.  */
end_comment

begin_function
specifier|static
name|void
name|kse_switchout_thread
parameter_list|(
name|struct
name|kse
modifier|*
name|kse
parameter_list|,
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
block|{
name|int
name|level
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|restart
decl_stmt|;
name|siginfo_t
name|siginfo
decl_stmt|;
comment|/* 	 * Place the currently running thread into the 	 * appropriate queue(s). 	 */
name|DBG_MSG
argument_list|(
literal|"Switching out thread %p, state %d\n"
argument_list|,
name|thread
argument_list|,
name|thread
operator|->
name|state
argument_list|)
expr_stmt|;
name|THR_DEACTIVATE_LAST_LOCK
argument_list|(
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|thread
operator|->
name|blocked
operator|!=
literal|0
condition|)
block|{
name|thread
operator|->
name|active
operator|=
literal|0
expr_stmt|;
name|thread
operator|->
name|need_switchout
operator|=
literal|0
expr_stmt|;
comment|/* This thread must have blocked in the kernel. */
comment|/* 		 * Check for pending signals and cancellation for 		 * this thread to see if we need to interrupt it 		 * in the kernel. 		 */
if|if
condition|(
name|THR_NEED_CANCEL
argument_list|(
name|thread
argument_list|)
condition|)
block|{
name|kse_thr_interrupt
argument_list|(
operator|&
name|thread
operator|->
name|tcb
operator|->
name|tcb_tmbx
argument_list|,
name|KSE_INTR_INTERRUPT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|thread
operator|->
name|check_pending
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|_SIG_MAXSIG
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|SIGISMEMBER
argument_list|(
name|thread
operator|->
name|sigpend
argument_list|,
name|i
argument_list|)
operator|&&
operator|!
name|SIGISMEMBER
argument_list|(
name|thread
operator|->
name|sigmask
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|restart
operator|=
name|_thread_sigact
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|sa_flags
operator|&
name|SA_RESTART
expr_stmt|;
name|kse_thr_interrupt
argument_list|(
operator|&
name|thread
operator|->
name|tcb
operator|->
name|tcb_tmbx
argument_list|,
name|restart
condition|?
name|KSE_INTR_RESTART
else|:
name|KSE_INTR_INTERRUPT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
else|else
block|{
switch|switch
condition|(
name|thread
operator|->
name|state
condition|)
block|{
case|case
name|PS_MUTEX_WAIT
case|:
case|case
name|PS_COND_WAIT
case|:
if|if
condition|(
name|THR_NEED_CANCEL
argument_list|(
name|thread
argument_list|)
condition|)
block|{
name|thread
operator|->
name|interrupted
operator|=
literal|1
expr_stmt|;
name|thread
operator|->
name|continuation
operator|=
name|_thr_finish_cancellation
expr_stmt|;
name|THR_SET_STATE
argument_list|(
name|thread
argument_list|,
name|PS_RUNNING
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Insert into the waiting queue: */
name|KSE_WAITQ_INSERT
argument_list|(
name|kse
argument_list|,
name|thread
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PS_LOCKWAIT
case|:
comment|/* 			 * This state doesn't timeout. 			 */
name|thread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|=
operator|-
literal|1
expr_stmt|;
name|thread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|=
operator|-
literal|1
expr_stmt|;
name|level
operator|=
name|thread
operator|->
name|locklevel
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|_LCK_GRANTED
argument_list|(
operator|&
name|thread
operator|->
name|lockusers
index|[
name|level
index|]
argument_list|)
condition|)
name|KSE_WAITQ_INSERT
argument_list|(
name|kse
argument_list|,
name|thread
argument_list|)
expr_stmt|;
else|else
name|THR_SET_STATE
argument_list|(
name|thread
argument_list|,
name|PS_RUNNING
argument_list|)
expr_stmt|;
break|break;
case|case
name|PS_SLEEP_WAIT
case|:
case|case
name|PS_SIGWAIT
case|:
if|if
condition|(
name|THR_NEED_CANCEL
argument_list|(
name|thread
argument_list|)
condition|)
block|{
name|thread
operator|->
name|interrupted
operator|=
literal|1
expr_stmt|;
name|THR_SET_STATE
argument_list|(
name|thread
argument_list|,
name|PS_RUNNING
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|KSE_WAITQ_INSERT
argument_list|(
name|kse
argument_list|,
name|thread
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PS_JOIN
case|:
if|if
condition|(
name|THR_NEED_CANCEL
argument_list|(
name|thread
argument_list|)
condition|)
block|{
name|thread
operator|->
name|join_status
operator|.
name|thread
operator|=
name|NULL
expr_stmt|;
name|THR_SET_STATE
argument_list|(
name|thread
argument_list|,
name|PS_RUNNING
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * This state doesn't timeout. 				 */
name|thread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|=
operator|-
literal|1
expr_stmt|;
name|thread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Insert into the waiting queue: */
name|KSE_WAITQ_INSERT
argument_list|(
name|kse
argument_list|,
name|thread
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PS_SIGSUSPEND
case|:
case|case
name|PS_SUSPENDED
case|:
if|if
condition|(
name|THR_NEED_CANCEL
argument_list|(
name|thread
argument_list|)
condition|)
block|{
name|thread
operator|->
name|interrupted
operator|=
literal|1
expr_stmt|;
name|THR_SET_STATE
argument_list|(
name|thread
argument_list|,
name|PS_RUNNING
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * These states don't timeout. 				 */
name|thread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|=
operator|-
literal|1
expr_stmt|;
name|thread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Insert into the waiting queue: */
name|KSE_WAITQ_INSERT
argument_list|(
name|kse
argument_list|,
name|thread
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PS_DEAD
case|:
comment|/* 			 * The scheduler is operating on a different 			 * stack.  It is safe to do garbage collecting 			 * here. 			 */
name|thr_cleanup
argument_list|(
name|kse
argument_list|,
name|thread
argument_list|)
expr_stmt|;
return|return;
break|break;
case|case
name|PS_RUNNING
case|:
if|if
condition|(
operator|(
name|thread
operator|->
name|flags
operator|&
name|THR_FLAGS_SUSPENDED
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|THR_NEED_CANCEL
argument_list|(
name|thread
argument_list|)
condition|)
name|THR_SET_STATE
argument_list|(
name|thread
argument_list|,
name|PS_SUSPENDED
argument_list|)
expr_stmt|;
break|break;
case|case
name|PS_DEADLOCK
case|:
comment|/* 			 * These states don't timeout. 			 */
name|thread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|=
operator|-
literal|1
expr_stmt|;
name|thread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Insert into the waiting queue: */
name|KSE_WAITQ_INSERT
argument_list|(
name|kse
argument_list|,
name|thread
argument_list|)
expr_stmt|;
break|break;
default|default:
name|PANIC
argument_list|(
literal|"Unknown state\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|thr_accounting
argument_list|(
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|thread
operator|->
name|state
operator|==
name|PS_RUNNING
condition|)
block|{
if|if
condition|(
name|thread
operator|->
name|slice_usec
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 				 * The thread exceeded its time quantum or 				 * it yielded the CPU; place it at the tail 				 * of the queue for its priority. 				 */
name|KSE_RUNQ_INSERT_TAIL
argument_list|(
name|kse
argument_list|,
name|thread
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * The thread hasn't exceeded its interval 				 * Place it at the head of the queue for its 				 * priority. 				 */
name|KSE_RUNQ_INSERT_HEAD
argument_list|(
name|kse
argument_list|,
name|thread
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|thread
operator|->
name|active
operator|=
literal|0
expr_stmt|;
name|thread
operator|->
name|need_switchout
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|thread
operator|->
name|check_pending
operator|!=
literal|0
condition|)
block|{
comment|/* Install pending signals into the frame. */
name|thread
operator|->
name|check_pending
operator|=
literal|0
expr_stmt|;
name|KSE_LOCK_ACQUIRE
argument_list|(
name|kse
argument_list|,
operator|&
name|_thread_signal_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|_SIG_MAXSIG
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|SIGISMEMBER
argument_list|(
name|thread
operator|->
name|sigmask
argument_list|,
name|i
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|SIGISMEMBER
argument_list|(
name|thread
operator|->
name|sigpend
argument_list|,
name|i
argument_list|)
condition|)
operator|(
name|void
operator|)
name|_thr_sig_add
argument_list|(
name|thread
argument_list|,
name|i
argument_list|,
operator|&
name|thread
operator|->
name|siginfo
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|SIGISMEMBER
argument_list|(
name|_thr_proc_sigpending
argument_list|,
name|i
argument_list|)
operator|&&
name|_thr_getprocsig_unlocked
argument_list|(
name|i
argument_list|,
operator|&
name|siginfo
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|_thr_sig_add
argument_list|(
name|thread
argument_list|,
name|i
argument_list|,
operator|&
name|siginfo
argument_list|)
expr_stmt|;
block|}
block|}
name|KSE_LOCK_RELEASE
argument_list|(
name|kse
argument_list|,
operator|&
name|_thread_signal_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This function waits for the smallest timeout value of any waiting  * thread, or until it receives a message from another KSE.  *  * This must be called with the scheduling lock held.  */
end_comment

begin_function
specifier|static
name|void
name|kse_wait
parameter_list|(
name|struct
name|kse
modifier|*
name|kse
parameter_list|,
name|struct
name|pthread
modifier|*
name|td_wait
parameter_list|,
name|int
name|sigseqno
parameter_list|)
block|{
name|struct
name|timespec
name|ts
decl_stmt|,
name|ts_sleep
decl_stmt|;
name|int
name|saved_flags
decl_stmt|;
if|if
condition|(
operator|(
name|td_wait
operator|==
name|NULL
operator|)
operator|||
operator|(
name|td_wait
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|<
literal|0
operator|)
condition|)
block|{
comment|/* Limit sleep to no more than 1 minute. */
name|ts_sleep
operator|.
name|tv_sec
operator|=
literal|60
expr_stmt|;
name|ts_sleep
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|KSE_GET_TOD
argument_list|(
name|kse
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|TIMESPEC_SUB
argument_list|(
operator|&
name|ts_sleep
argument_list|,
operator|&
name|td_wait
operator|->
name|wakeup_time
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
if|if
condition|(
name|ts_sleep
operator|.
name|tv_sec
operator|>
literal|60
condition|)
block|{
name|ts_sleep
operator|.
name|tv_sec
operator|=
literal|60
expr_stmt|;
name|ts_sleep
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Don't sleep for negative times. */
if|if
condition|(
operator|(
name|ts_sleep
operator|.
name|tv_sec
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|ts_sleep
operator|.
name|tv_nsec
operator|>=
literal|0
operator|)
condition|)
block|{
name|KSE_SET_IDLE
argument_list|(
name|kse
argument_list|)
expr_stmt|;
name|kse
operator|->
name|k_kseg
operator|->
name|kg_idle_kses
operator|++
expr_stmt|;
name|KSE_SCHED_UNLOCK
argument_list|(
name|kse
argument_list|,
name|kse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|kse
operator|->
name|k_kseg
operator|->
name|kg_flags
operator|&
name|KGF_SINGLE_THREAD
operator|)
operator|&&
operator|(
name|kse
operator|->
name|k_sigseqno
operator|!=
name|sigseqno
operator|)
condition|)
empty_stmt|;
comment|/* don't sleep */
else|else
block|{
name|saved_flags
operator|=
name|kse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_flags
expr_stmt|;
name|kse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_flags
operator||=
name|KMF_NOUPCALL
expr_stmt|;
name|kse_release
argument_list|(
operator|&
name|ts_sleep
argument_list|)
expr_stmt|;
name|kse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_flags
operator|=
name|saved_flags
expr_stmt|;
block|}
name|KSE_SCHED_LOCK
argument_list|(
name|kse
argument_list|,
name|kse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
if|if
condition|(
name|KSE_IS_IDLE
argument_list|(
name|kse
argument_list|)
condition|)
block|{
name|KSE_CLEAR_IDLE
argument_list|(
name|kse
argument_list|)
expr_stmt|;
name|kse
operator|->
name|k_kseg
operator|->
name|kg_idle_kses
operator|--
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Avoid calling this kse_exit() so as not to confuse it with the  * system call of the same name.  */
end_comment

begin_function
specifier|static
name|void
name|kse_fini
parameter_list|(
name|struct
name|kse
modifier|*
name|kse
parameter_list|)
block|{
comment|/* struct kse_group *free_kseg = NULL; */
name|struct
name|timespec
name|ts
decl_stmt|;
name|struct
name|pthread
modifier|*
name|td
decl_stmt|;
comment|/* 	 * Check to see if this is one of the main kses. 	 */
if|if
condition|(
name|kse
operator|->
name|k_kseg
operator|!=
name|_kse_initial
operator|->
name|k_kseg
condition|)
block|{
name|PANIC
argument_list|(
literal|"shouldn't get here"
argument_list|)
expr_stmt|;
comment|/* This is for supporting thread groups. */
ifdef|#
directive|ifdef
name|NOT_YET
comment|/* Remove this KSE from the KSEG's list of KSEs. */
name|KSE_SCHED_LOCK
argument_list|(
name|kse
argument_list|,
name|kse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|kse
operator|->
name|k_kseg
operator|->
name|kg_kseq
argument_list|,
name|kse
argument_list|,
name|k_kgqe
argument_list|)
expr_stmt|;
name|kse
operator|->
name|k_kseg
operator|->
name|kg_ksecount
operator|--
expr_stmt|;
if|if
condition|(
name|TAILQ_EMPTY
argument_list|(
operator|&
name|kse
operator|->
name|k_kseg
operator|->
name|kg_kseq
argument_list|)
condition|)
name|free_kseg
operator|=
name|kse
operator|->
name|k_kseg
expr_stmt|;
name|KSE_SCHED_UNLOCK
argument_list|(
name|kse
argument_list|,
name|kse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
comment|/* 		 * Add this KSE to the list of free KSEs along with 		 * the KSEG if is now orphaned. 		 */
name|KSE_LOCK_ACQUIRE
argument_list|(
name|kse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_kseg
operator|!=
name|NULL
condition|)
name|kseg_free_unlocked
argument_list|(
name|free_kseg
argument_list|)
expr_stmt|;
name|kse_free_unlocked
argument_list|(
name|kse
argument_list|)
expr_stmt|;
name|KSE_LOCK_RELEASE
argument_list|(
name|kse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
name|kse_exit
argument_list|()
expr_stmt|;
comment|/* Never returns. */
name|PANIC
argument_list|(
literal|"kse_exit()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* 		 * We allow program to kill kse in initial group (by 		 * lowering the concurrency). 		 */
if|if
condition|(
operator|(
name|kse
operator|!=
name|_kse_initial
operator|)
operator|&&
operator|(
operator|(
name|kse
operator|->
name|k_flags
operator|&
name|KF_TERMINATED
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|KSE_SCHED_LOCK
argument_list|(
name|kse
argument_list|,
name|kse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|kse
operator|->
name|k_kseg
operator|->
name|kg_kseq
argument_list|,
name|kse
argument_list|,
name|k_kgqe
argument_list|)
expr_stmt|;
name|kse
operator|->
name|k_kseg
operator|->
name|kg_ksecount
operator|--
expr_stmt|;
comment|/* 			 * Migrate thread to  _kse_initial if its lastest 			 * kse it ran on is the kse. 			 */
name|td
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|kse
operator|->
name|k_kseg
operator|->
name|kg_threadq
argument_list|)
expr_stmt|;
while|while
condition|(
name|td
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|td
operator|->
name|kse
operator|==
name|kse
condition|)
name|td
operator|->
name|kse
operator|=
name|_kse_initial
expr_stmt|;
name|td
operator|=
name|TAILQ_NEXT
argument_list|(
name|td
argument_list|,
name|kle
argument_list|)
expr_stmt|;
block|}
name|KSE_SCHED_UNLOCK
argument_list|(
name|kse
argument_list|,
name|kse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
name|KSE_LOCK_ACQUIRE
argument_list|(
name|kse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
name|kse_free_unlocked
argument_list|(
name|kse
argument_list|)
expr_stmt|;
name|KSE_LOCK_RELEASE
argument_list|(
name|kse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
comment|/* Make sure there is always at least one is awake */
name|KSE_WAKEUP
argument_list|(
name|_kse_initial
argument_list|)
expr_stmt|;
name|kse_exit
argument_list|()
expr_stmt|;
comment|/* Never returns. */
name|PANIC
argument_list|(
literal|"kse_exit() failed for initial kseg"
argument_list|)
expr_stmt|;
block|}
name|KSE_SCHED_LOCK
argument_list|(
name|kse
argument_list|,
name|kse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
name|KSE_SET_IDLE
argument_list|(
name|kse
argument_list|)
expr_stmt|;
name|kse
operator|->
name|k_kseg
operator|->
name|kg_idle_kses
operator|++
expr_stmt|;
name|KSE_SCHED_UNLOCK
argument_list|(
name|kse
argument_list|,
name|kse
operator|->
name|k_kseg
argument_list|)
expr_stmt|;
name|ts
operator|.
name|tv_sec
operator|=
literal|120
expr_stmt|;
name|ts
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
name|kse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_flags
operator|=
literal|0
expr_stmt|;
name|kse_release
argument_list|(
operator|&
name|ts
argument_list|)
expr_stmt|;
comment|/* Never reach */
block|}
block|}
end_function

begin_function
name|void
name|_thr_set_timeout
parameter_list|(
specifier|const
name|struct
name|timespec
modifier|*
name|timeout
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|curthread
init|=
name|_get_curthread
argument_list|()
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
comment|/* Reset the timeout flag for the running thread: */
name|curthread
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
comment|/* Check if the thread is to wait forever: */
if|if
condition|(
name|timeout
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Set the wakeup time to something that can be recognised as 		 * different to an actual time of day: 		 */
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|=
operator|-
literal|1
expr_stmt|;
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Check if no waiting is required: */
elseif|else
if|if
condition|(
operator|(
name|timeout
operator|->
name|tv_sec
operator|==
literal|0
operator|)
operator|&&
operator|(
name|timeout
operator|->
name|tv_nsec
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Set the wake up time to 'immediately': */
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|curthread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Calculate the time for the current thread to wakeup: */
name|KSE_GET_TOD
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
name|TIMESPEC_ADD
argument_list|(
operator|&
name|curthread
operator|->
name|wakeup_time
argument_list|,
operator|&
name|ts
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|_thr_panic_exit
parameter_list|(
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"(%s:%d) %s\n"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|__sys_write
argument_list|(
literal|2
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_thr_setrunnable
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|,
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
block|{
name|kse_critical_t
name|crit
decl_stmt|;
name|struct
name|kse_mailbox
modifier|*
name|kmbx
decl_stmt|;
name|crit
operator|=
name|_kse_critical_enter
argument_list|()
expr_stmt|;
name|KSE_SCHED_LOCK
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
name|thread
operator|->
name|kseg
argument_list|)
expr_stmt|;
name|kmbx
operator|=
name|_thr_setrunnable_unlocked
argument_list|(
name|thread
argument_list|)
expr_stmt|;
name|KSE_SCHED_UNLOCK
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
name|thread
operator|->
name|kseg
argument_list|)
expr_stmt|;
name|_kse_critical_leave
argument_list|(
name|crit
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|kmbx
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|__isthreaded
operator|!=
literal|0
operator|)
condition|)
name|kse_wakeup
argument_list|(
name|kmbx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|kse_mailbox
modifier|*
name|_thr_setrunnable_unlocked
parameter_list|(
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
block|{
name|struct
name|kse_mailbox
modifier|*
name|kmbx
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|(
name|thread
operator|->
name|kseg
operator|->
name|kg_flags
operator|&
name|KGF_SINGLE_THREAD
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* No silly queues for these threads. */
if|if
condition|(
operator|(
name|thread
operator|->
name|flags
operator|&
name|THR_FLAGS_SUSPENDED
operator|)
operator|!=
literal|0
condition|)
name|THR_SET_STATE
argument_list|(
name|thread
argument_list|,
name|PS_SUSPENDED
argument_list|)
expr_stmt|;
else|else
block|{
name|THR_SET_STATE
argument_list|(
name|thread
argument_list|,
name|PS_RUNNING
argument_list|)
expr_stmt|;
name|kmbx
operator|=
name|kse_wakeup_one
argument_list|(
name|thread
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|thread
operator|->
name|state
operator|!=
name|PS_RUNNING
condition|)
block|{
if|if
condition|(
operator|(
name|thread
operator|->
name|flags
operator|&
name|THR_FLAGS_IN_WAITQ
operator|)
operator|!=
literal|0
condition|)
name|KSE_WAITQ_REMOVE
argument_list|(
name|thread
operator|->
name|kse
argument_list|,
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|thread
operator|->
name|flags
operator|&
name|THR_FLAGS_SUSPENDED
operator|)
operator|!=
literal|0
condition|)
name|THR_SET_STATE
argument_list|(
name|thread
argument_list|,
name|PS_SUSPENDED
argument_list|)
expr_stmt|;
else|else
block|{
name|THR_SET_STATE
argument_list|(
name|thread
argument_list|,
name|PS_RUNNING
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|thread
operator|->
name|blocked
operator|==
literal|0
operator|)
operator|&&
operator|(
name|thread
operator|->
name|active
operator|==
literal|0
operator|)
operator|&&
operator|(
name|thread
operator|->
name|flags
operator|&
name|THR_FLAGS_IN_RUNQ
operator|)
operator|==
literal|0
condition|)
name|THR_RUNQ_INSERT_TAIL
argument_list|(
name|thread
argument_list|)
expr_stmt|;
comment|/* 			 * XXX - Threads are not yet assigned to specific 			 *       KSEs; they are assigned to the KSEG.  So 			 *       the fact that a thread's KSE is waiting 			 *       doesn't necessarily mean that it will be 			 *       the KSE that runs the thread after the 			 *       lock is granted.  But we don't know if the 			 *       other KSEs within the same KSEG are also 			 *       in a waiting state or not so we err on the 			 *       side of caution and wakeup the thread's 			 *       last known KSE.  We ensure that the 			 *       threads KSE doesn't change while it's 			 *       scheduling lock is held so it is safe to 			 *       reference it (the KSE).  If the KSE wakes 			 *       up and doesn't find any more work it will 			 *       again go back to waiting so no harm is 			 *       done. 			 */
name|kmbx
operator|=
name|kse_wakeup_one
argument_list|(
name|thread
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|kmbx
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|kse_mailbox
modifier|*
name|kse_wakeup_one
parameter_list|(
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
if|if
condition|(
name|KSE_IS_IDLE
argument_list|(
name|thread
operator|->
name|kse
argument_list|)
condition|)
block|{
name|KSE_CLEAR_IDLE
argument_list|(
name|thread
operator|->
name|kse
argument_list|)
expr_stmt|;
name|thread
operator|->
name|kseg
operator|->
name|kg_idle_kses
operator|--
expr_stmt|;
return|return
operator|(
operator|&
name|thread
operator|->
name|kse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|)
return|;
block|}
else|else
block|{
name|TAILQ_FOREACH
argument_list|(
argument|ke
argument_list|,
argument|&thread->kseg->kg_kseq
argument_list|,
argument|k_kgqe
argument_list|)
block|{
if|if
condition|(
name|KSE_IS_IDLE
argument_list|(
name|ke
argument_list|)
condition|)
block|{
name|KSE_CLEAR_IDLE
argument_list|(
name|ke
argument_list|)
expr_stmt|;
name|ke
operator|->
name|k_kseg
operator|->
name|kg_idle_kses
operator|--
expr_stmt|;
return|return
operator|(
operator|&
name|ke
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|kse_wakeup_multi
parameter_list|(
name|struct
name|kse
modifier|*
name|curkse
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|ke
decl_stmt|;
name|int
name|tmp
decl_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|=
name|KSE_RUNQ_THREADS
argument_list|(
name|curkse
argument_list|)
operator|)
operator|&&
name|curkse
operator|->
name|k_kseg
operator|->
name|kg_idle_kses
condition|)
block|{
name|TAILQ_FOREACH
argument_list|(
argument|ke
argument_list|,
argument|&curkse->k_kseg->kg_kseq
argument_list|,
argument|k_kgqe
argument_list|)
block|{
if|if
condition|(
name|KSE_IS_IDLE
argument_list|(
name|ke
argument_list|)
condition|)
block|{
name|KSE_CLEAR_IDLE
argument_list|(
name|ke
argument_list|)
expr_stmt|;
name|ke
operator|->
name|k_kseg
operator|->
name|kg_idle_kses
operator|--
expr_stmt|;
name|KSE_WAKEUP
argument_list|(
name|ke
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|tmp
operator|==
literal|0
condition|)
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Allocate a new KSEG.  *  * We allow the current thread to be NULL in the case that this  * is the first time a KSEG is being created (library initialization).  * In this case, we don't need to (and can't) take any locks.  */
end_comment

begin_function
name|struct
name|kse_group
modifier|*
name|_kseg_alloc
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|)
block|{
name|struct
name|kse_group
modifier|*
name|kseg
init|=
name|NULL
decl_stmt|;
name|kse_critical_t
name|crit
decl_stmt|;
if|if
condition|(
operator|(
name|curthread
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|free_kseg_count
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* Use the kse lock for the kseg queue. */
name|crit
operator|=
name|_kse_critical_enter
argument_list|()
expr_stmt|;
name|KSE_LOCK_ACQUIRE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|kseg
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|free_kse_groupq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|free_kse_groupq
argument_list|,
name|kseg
argument_list|,
name|kg_qe
argument_list|)
expr_stmt|;
name|free_kseg_count
operator|--
expr_stmt|;
name|active_kseg_count
operator|++
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|active_kse_groupq
argument_list|,
name|kseg
argument_list|,
name|kg_qe
argument_list|)
expr_stmt|;
block|}
name|KSE_LOCK_RELEASE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
name|_kse_critical_leave
argument_list|(
name|crit
argument_list|)
expr_stmt|;
if|if
condition|(
name|kseg
condition|)
name|kseg_reinit
argument_list|(
name|kseg
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If requested, attempt to allocate a new KSE group only if the 	 * KSE allocation was successful and a KSE group wasn't found in 	 * the free list. 	 */
if|if
condition|(
operator|(
name|kseg
operator|==
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|kseg
operator|=
operator|(
expr|struct
name|kse_group
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|kseg
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|_pq_alloc
argument_list|(
operator|&
name|kseg
operator|->
name|kg_schedq
operator|.
name|sq_runq
argument_list|,
name|THR_MIN_PRIORITY
argument_list|,
name|THR_LAST_PRIORITY
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|kseg
argument_list|)
expr_stmt|;
name|kseg
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|kseg_init
argument_list|(
name|kseg
argument_list|)
expr_stmt|;
comment|/* Add the KSEG to the list of active KSEGs. */
if|if
condition|(
name|curthread
operator|!=
name|NULL
condition|)
block|{
name|crit
operator|=
name|_kse_critical_enter
argument_list|()
expr_stmt|;
name|KSE_LOCK_ACQUIRE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
name|active_kseg_count
operator|++
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|active_kse_groupq
argument_list|,
name|kseg
argument_list|,
name|kg_qe
argument_list|)
expr_stmt|;
name|KSE_LOCK_RELEASE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
name|_kse_critical_leave
argument_list|(
name|crit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|active_kseg_count
operator|++
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|active_kse_groupq
argument_list|,
name|kseg
argument_list|,
name|kg_qe
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|kseg
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|kseg_init
parameter_list|(
name|struct
name|kse_group
modifier|*
name|kseg
parameter_list|)
block|{
name|kseg_reinit
argument_list|(
name|kseg
argument_list|)
expr_stmt|;
name|_lock_init
argument_list|(
operator|&
name|kseg
operator|->
name|kg_lock
argument_list|,
name|LCK_ADAPTIVE
argument_list|,
name|_kse_lock_wait
argument_list|,
name|_kse_lock_wakeup
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|kseg_reinit
parameter_list|(
name|struct
name|kse_group
modifier|*
name|kseg
parameter_list|)
block|{
name|TAILQ_INIT
argument_list|(
operator|&
name|kseg
operator|->
name|kg_kseq
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|kseg
operator|->
name|kg_threadq
argument_list|)
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|kseg
operator|->
name|kg_schedq
operator|.
name|sq_waitq
argument_list|)
expr_stmt|;
name|kseg
operator|->
name|kg_threadcount
operator|=
literal|0
expr_stmt|;
name|kseg
operator|->
name|kg_ksecount
operator|=
literal|0
expr_stmt|;
name|kseg
operator|->
name|kg_idle_kses
operator|=
literal|0
expr_stmt|;
name|kseg
operator|->
name|kg_flags
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This must be called with the kse lock held and when there are  * no more threads that reference it.  */
end_comment

begin_function
specifier|static
name|void
name|kseg_free_unlocked
parameter_list|(
name|struct
name|kse_group
modifier|*
name|kseg
parameter_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|active_kse_groupq
argument_list|,
name|kseg
argument_list|,
name|kg_qe
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|free_kse_groupq
argument_list|,
name|kseg
argument_list|,
name|kg_qe
argument_list|)
expr_stmt|;
name|free_kseg_count
operator|++
expr_stmt|;
name|active_kseg_count
operator|--
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_kseg_free
parameter_list|(
name|struct
name|kse_group
modifier|*
name|kseg
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|curkse
decl_stmt|;
name|kse_critical_t
name|crit
decl_stmt|;
name|crit
operator|=
name|_kse_critical_enter
argument_list|()
expr_stmt|;
name|curkse
operator|=
name|_get_curkse
argument_list|()
expr_stmt|;
name|KSE_LOCK_ACQUIRE
argument_list|(
name|curkse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
name|kseg_free_unlocked
argument_list|(
name|kseg
argument_list|)
expr_stmt|;
name|KSE_LOCK_RELEASE
argument_list|(
name|curkse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
name|_kse_critical_leave
argument_list|(
name|crit
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|kseg_destroy
parameter_list|(
name|struct
name|kse_group
modifier|*
name|kseg
parameter_list|)
block|{
name|_lock_destroy
argument_list|(
operator|&
name|kseg
operator|->
name|kg_lock
argument_list|)
expr_stmt|;
name|_pq_free
argument_list|(
operator|&
name|kseg
operator|->
name|kg_schedq
operator|.
name|sq_runq
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|kseg
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a new KSE.  *  * We allow the current thread to be NULL in the case that this  * is the first time a KSE is being created (library initialization).  * In this case, we don't need to (and can't) take any locks.  */
end_comment

begin_function
name|struct
name|kse
modifier|*
name|_kse_alloc
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|,
name|int
name|sys_scope
parameter_list|)
block|{
name|struct
name|kse
modifier|*
name|kse
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|stack
decl_stmt|;
name|kse_critical_t
name|crit
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|curthread
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|free_kse_count
operator|>
literal|0
operator|)
condition|)
block|{
name|crit
operator|=
name|_kse_critical_enter
argument_list|()
expr_stmt|;
name|KSE_LOCK_ACQUIRE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
comment|/* Search for a finished KSE. */
name|kse
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|free_kseq
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|kse
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|kse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_flags
operator|&
name|KMF_DONE
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|kse
operator|=
name|TAILQ_NEXT
argument_list|(
name|kse
argument_list|,
name|k_qe
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kse
operator|!=
name|NULL
condition|)
block|{
name|DBG_MSG
argument_list|(
literal|"found an unused kse.\n"
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|free_kseq
argument_list|,
name|kse
argument_list|,
name|k_qe
argument_list|)
expr_stmt|;
name|free_kse_count
operator|--
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|active_kseq
argument_list|,
name|kse
argument_list|,
name|k_qe
argument_list|)
expr_stmt|;
name|active_kse_count
operator|++
expr_stmt|;
block|}
name|KSE_LOCK_RELEASE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
name|_kse_critical_leave
argument_list|(
name|crit
argument_list|)
expr_stmt|;
if|if
condition|(
name|kse
operator|!=
name|NULL
condition|)
name|kse_reinit
argument_list|(
name|kse
argument_list|,
name|sys_scope
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|kse
operator|==
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|kse
operator|=
operator|(
expr|struct
name|kse
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|kse
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|sys_scope
operator|!=
literal|0
condition|)
name|stack
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|stack
operator|=
name|malloc
argument_list|(
name|KSE_STACKSIZE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|kse
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bzero
argument_list|(
name|kse
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|kse
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize KCB without the lock. */
if|if
condition|(
operator|(
name|kse
operator|->
name|k_kcb
operator|=
name|_kcb_ctor
argument_list|(
name|kse
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|stack
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|stack
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|kse
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Initialize the lockusers. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_KSE_LOCKLEVEL
condition|;
name|i
operator|++
control|)
block|{
name|_lockuser_init
argument_list|(
operator|&
name|kse
operator|->
name|k_lockusers
index|[
name|i
index|]
argument_list|,
operator|(
name|void
operator|*
operator|)
name|kse
argument_list|)
expr_stmt|;
name|_LCK_SET_PRIVATE2
argument_list|(
operator|&
name|kse
operator|->
name|k_lockusers
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* _lock_init(kse->k_lock, ...) */
if|if
condition|(
name|curthread
operator|!=
name|NULL
condition|)
block|{
name|crit
operator|=
name|_kse_critical_enter
argument_list|()
expr_stmt|;
name|KSE_LOCK_ACQUIRE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
block|}
name|kse
operator|->
name|k_flags
operator|=
literal|0
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|active_kseq
argument_list|,
name|kse
argument_list|,
name|k_qe
argument_list|)
expr_stmt|;
name|active_kse_count
operator|++
expr_stmt|;
if|if
condition|(
name|curthread
operator|!=
name|NULL
condition|)
block|{
name|KSE_LOCK_RELEASE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
name|_kse_critical_leave
argument_list|(
name|crit
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Create the KSE context. 		 * Scope system threads (one thread per KSE) are not required 		 * to have a stack for an unneeded kse upcall. 		 */
if|if
condition|(
operator|!
name|sys_scope
condition|)
block|{
name|kse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_func
operator|=
operator|(
name|kse_func_t
operator|*
operator|)
name|kse_sched_multi
expr_stmt|;
name|kse
operator|->
name|k_stack
operator|.
name|ss_sp
operator|=
name|stack
expr_stmt|;
name|kse
operator|->
name|k_stack
operator|.
name|ss_size
operator|=
name|KSE_STACKSIZE
expr_stmt|;
block|}
else|else
block|{
name|kse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_func
operator|=
operator|(
name|kse_func_t
operator|*
operator|)
name|kse_sched_single
expr_stmt|;
name|kse
operator|->
name|k_stack
operator|.
name|ss_sp
operator|=
name|NULL
expr_stmt|;
name|kse
operator|->
name|k_stack
operator|.
name|ss_size
operator|=
literal|0
expr_stmt|;
block|}
name|kse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_udata
operator|=
operator|(
name|void
operator|*
operator|)
name|kse
expr_stmt|;
name|kse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_quantum
operator|=
literal|20000
expr_stmt|;
comment|/* 		 * We need to keep a copy of the stack in case it 		 * doesn't get used; a KSE running a scope system 		 * thread will use that thread's stack. 		 */
name|kse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_stack
operator|=
name|kse
operator|->
name|k_stack
expr_stmt|;
block|}
return|return
operator|(
name|kse
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|kse_reinit
parameter_list|(
name|struct
name|kse
modifier|*
name|kse
parameter_list|,
name|int
name|sys_scope
parameter_list|)
block|{
if|if
condition|(
operator|!
name|sys_scope
condition|)
block|{
name|kse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_func
operator|=
operator|(
name|kse_func_t
operator|*
operator|)
name|kse_sched_multi
expr_stmt|;
if|if
condition|(
name|kse
operator|->
name|k_stack
operator|.
name|ss_sp
operator|==
name|NULL
condition|)
block|{
comment|/* XXX check allocation failure */
name|kse
operator|->
name|k_stack
operator|.
name|ss_sp
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|KSE_STACKSIZE
argument_list|)
expr_stmt|;
name|kse
operator|->
name|k_stack
operator|.
name|ss_size
operator|=
name|KSE_STACKSIZE
expr_stmt|;
block|}
name|kse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_quantum
operator|=
literal|20000
expr_stmt|;
block|}
else|else
block|{
name|kse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_func
operator|=
operator|(
name|kse_func_t
operator|*
operator|)
name|kse_sched_single
expr_stmt|;
if|if
condition|(
name|kse
operator|->
name|k_stack
operator|.
name|ss_sp
condition|)
name|free
argument_list|(
name|kse
operator|->
name|k_stack
operator|.
name|ss_sp
argument_list|)
expr_stmt|;
name|kse
operator|->
name|k_stack
operator|.
name|ss_sp
operator|=
name|NULL
expr_stmt|;
name|kse
operator|->
name|k_stack
operator|.
name|ss_size
operator|=
literal|0
expr_stmt|;
name|kse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_quantum
operator|=
literal|0
expr_stmt|;
block|}
name|kse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_stack
operator|=
name|kse
operator|->
name|k_stack
expr_stmt|;
name|kse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_udata
operator|=
operator|(
name|void
operator|*
operator|)
name|kse
expr_stmt|;
name|kse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_curthread
operator|=
name|NULL
expr_stmt|;
name|kse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_flags
operator|=
literal|0
expr_stmt|;
name|kse
operator|->
name|k_curthread
operator|=
name|NULL
expr_stmt|;
name|kse
operator|->
name|k_kseg
operator|=
literal|0
expr_stmt|;
name|kse
operator|->
name|k_schedq
operator|=
literal|0
expr_stmt|;
name|kse
operator|->
name|k_locklevel
operator|=
literal|0
expr_stmt|;
name|kse
operator|->
name|k_flags
operator|=
literal|0
expr_stmt|;
name|kse
operator|->
name|k_error
operator|=
literal|0
expr_stmt|;
name|kse
operator|->
name|k_cpu
operator|=
literal|0
expr_stmt|;
name|kse
operator|->
name|k_sigseqno
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|kse_free_unlocked
parameter_list|(
name|struct
name|kse
modifier|*
name|kse
parameter_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|active_kseq
argument_list|,
name|kse
argument_list|,
name|k_qe
argument_list|)
expr_stmt|;
name|active_kse_count
operator|--
expr_stmt|;
name|kse
operator|->
name|k_kseg
operator|=
name|NULL
expr_stmt|;
name|kse
operator|->
name|k_kcb
operator|->
name|kcb_kmbx
operator|.
name|km_quantum
operator|=
literal|20000
expr_stmt|;
name|kse
operator|->
name|k_flags
operator|=
literal|0
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
operator|&
name|free_kseq
argument_list|,
name|kse
argument_list|,
name|k_qe
argument_list|)
expr_stmt|;
name|free_kse_count
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_kse_free
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|,
name|struct
name|kse
modifier|*
name|kse
parameter_list|)
block|{
name|kse_critical_t
name|crit
decl_stmt|;
if|if
condition|(
name|curthread
operator|==
name|NULL
condition|)
name|kse_free_unlocked
argument_list|(
name|kse
argument_list|)
expr_stmt|;
else|else
block|{
name|crit
operator|=
name|_kse_critical_enter
argument_list|()
expr_stmt|;
name|KSE_LOCK_ACQUIRE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
name|kse_free_unlocked
argument_list|(
name|kse
argument_list|)
expr_stmt|;
name|KSE_LOCK_RELEASE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|kse_lock
argument_list|)
expr_stmt|;
name|_kse_critical_leave
argument_list|(
name|crit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|kse_destroy
parameter_list|(
name|struct
name|kse
modifier|*
name|kse
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|kse
operator|->
name|k_stack
operator|.
name|ss_sp
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|kse
operator|->
name|k_stack
operator|.
name|ss_sp
argument_list|)
expr_stmt|;
name|_kcb_dtor
argument_list|(
name|kse
operator|->
name|k_kcb
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_KSE_LOCKLEVEL
condition|;
operator|++
name|i
control|)
name|_lockuser_destroy
argument_list|(
operator|&
name|kse
operator|->
name|k_lockusers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|_lock_destroy
argument_list|(
operator|&
name|kse
operator|->
name|k_lock
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|kse
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|pthread
modifier|*
name|_thr_alloc
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|)
block|{
name|kse_critical_t
name|crit
decl_stmt|;
name|struct
name|pthread
modifier|*
name|thread
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|curthread
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|GC_NEEDED
argument_list|()
condition|)
name|_thr_gc
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
if|if
condition|(
name|free_thread_count
operator|>
literal|0
condition|)
block|{
name|crit
operator|=
name|_kse_critical_enter
argument_list|()
expr_stmt|;
name|KSE_LOCK_ACQUIRE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|thread_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|thread
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|free_threadq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|free_threadq
argument_list|,
name|thread
argument_list|,
name|tle
argument_list|)
expr_stmt|;
name|free_thread_count
operator|--
expr_stmt|;
block|}
name|KSE_LOCK_RELEASE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|thread_lock
argument_list|)
expr_stmt|;
name|_kse_critical_leave
argument_list|(
name|crit
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|thread
operator|==
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|thread
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pthread
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|bzero
argument_list|(
name|thread
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pthread
argument_list|)
argument_list|)
expr_stmt|;
name|thread
operator|->
name|siginfo
operator|=
name|calloc
argument_list|(
name|_SIG_MAXSIG
argument_list|,
sizeof|sizeof
argument_list|(
name|siginfo_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|thread
operator|->
name|siginfo
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|thread
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|curthread
condition|)
block|{
name|_pthread_mutex_lock
argument_list|(
operator|&
name|_tcb_mutex
argument_list|)
expr_stmt|;
name|thread
operator|->
name|tcb
operator|=
name|_tcb_ctor
argument_list|(
name|thread
argument_list|,
literal|0
comment|/* not initial tls */
argument_list|)
expr_stmt|;
name|_pthread_mutex_unlock
argument_list|(
operator|&
name|_tcb_mutex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|thread
operator|->
name|tcb
operator|=
name|_tcb_ctor
argument_list|(
name|thread
argument_list|,
literal|1
comment|/* initial tls */
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|thread
operator|->
name|tcb
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|thread
operator|->
name|siginfo
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|thread
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 		 * Initialize thread locking. 		 * Lock initializing needs malloc, so don't 		 * enter critical region before doing this! 		 */
if|if
condition|(
name|_lock_init
argument_list|(
operator|&
name|thread
operator|->
name|lock
argument_list|,
name|LCK_ADAPTIVE
argument_list|,
name|_thr_lock_wait
argument_list|,
name|_thr_lock_wakeup
argument_list|)
operator|!=
literal|0
condition|)
name|PANIC
argument_list|(
literal|"Cannot initialize thread lock"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_THR_LOCKLEVEL
condition|;
name|i
operator|++
control|)
block|{
name|_lockuser_init
argument_list|(
operator|&
name|thread
operator|->
name|lockusers
index|[
name|i
index|]
argument_list|,
operator|(
name|void
operator|*
operator|)
name|thread
argument_list|)
expr_stmt|;
name|_LCK_SET_PRIVATE2
argument_list|(
operator|&
name|thread
operator|->
name|lockusers
index|[
name|i
index|]
argument_list|,
operator|(
name|void
operator|*
operator|)
name|thread
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|thread
operator|)
return|;
block|}
end_function

begin_function
name|void
name|_thr_free
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|,
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
block|{
name|kse_critical_t
name|crit
decl_stmt|;
name|DBG_MSG
argument_list|(
literal|"Freeing thread %p\n"
argument_list|,
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|thread
operator|->
name|name
condition|)
block|{
name|free
argument_list|(
name|thread
operator|->
name|name
argument_list|)
expr_stmt|;
name|thread
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|curthread
operator|==
name|NULL
operator|)
operator|||
operator|(
name|free_thread_count
operator|>=
name|MAX_CACHED_THREADS
operator|)
condition|)
block|{
name|thr_destroy
argument_list|(
name|curthread
argument_list|,
name|thread
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Add the thread to the free thread list. */
name|crit
operator|=
name|_kse_critical_enter
argument_list|()
expr_stmt|;
name|KSE_LOCK_ACQUIRE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|thread_lock
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|free_threadq
argument_list|,
name|thread
argument_list|,
name|tle
argument_list|)
expr_stmt|;
name|free_thread_count
operator|++
expr_stmt|;
name|KSE_LOCK_RELEASE
argument_list|(
name|curthread
operator|->
name|kse
argument_list|,
operator|&
name|thread_lock
argument_list|)
expr_stmt|;
name|_kse_critical_leave
argument_list|(
name|crit
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|thr_destroy
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|,
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_THR_LOCKLEVEL
condition|;
name|i
operator|++
control|)
name|_lockuser_destroy
argument_list|(
operator|&
name|thread
operator|->
name|lockusers
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|_lock_destroy
argument_list|(
operator|&
name|thread
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|curthread
condition|)
block|{
name|_pthread_mutex_lock
argument_list|(
operator|&
name|_tcb_mutex
argument_list|)
expr_stmt|;
name|_tcb_dtor
argument_list|(
name|thread
operator|->
name|tcb
argument_list|)
expr_stmt|;
name|_pthread_mutex_unlock
argument_list|(
operator|&
name|_tcb_mutex
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|_tcb_dtor
argument_list|(
name|thread
operator|->
name|tcb
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|thread
operator|->
name|siginfo
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|thread
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add an active thread:  *  *   o Assign the thread a unique id (which GDB uses to track  *     threads.  *   o Add the thread to the list of all threads and increment  *     number of active threads.  */
end_comment

begin_function
specifier|static
name|void
name|thr_link
parameter_list|(
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
block|{
name|kse_critical_t
name|crit
decl_stmt|;
name|struct
name|kse
modifier|*
name|curkse
decl_stmt|;
name|crit
operator|=
name|_kse_critical_enter
argument_list|()
expr_stmt|;
name|curkse
operator|=
name|_get_curkse
argument_list|()
expr_stmt|;
name|KSE_LOCK_ACQUIRE
argument_list|(
name|curkse
argument_list|,
operator|&
name|_thread_list_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the unique id (which GDB uses to track 	 * threads), add the thread to the list of all threads, 	 * and 	 */
name|thread
operator|->
name|uniqueid
operator|=
name|next_uniqueid
operator|++
expr_stmt|;
name|THR_LIST_ADD
argument_list|(
name|thread
argument_list|)
expr_stmt|;
name|_thread_active_threads
operator|++
expr_stmt|;
name|KSE_LOCK_RELEASE
argument_list|(
name|curkse
argument_list|,
operator|&
name|_thread_list_lock
argument_list|)
expr_stmt|;
name|_kse_critical_leave
argument_list|(
name|crit
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove an active thread.  */
end_comment

begin_function
specifier|static
name|void
name|thr_unlink
parameter_list|(
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
block|{
name|kse_critical_t
name|crit
decl_stmt|;
name|struct
name|kse
modifier|*
name|curkse
decl_stmt|;
name|crit
operator|=
name|_kse_critical_enter
argument_list|()
expr_stmt|;
name|curkse
operator|=
name|_get_curkse
argument_list|()
expr_stmt|;
name|KSE_LOCK_ACQUIRE
argument_list|(
name|curkse
argument_list|,
operator|&
name|_thread_list_lock
argument_list|)
expr_stmt|;
name|THR_LIST_REMOVE
argument_list|(
name|thread
argument_list|)
expr_stmt|;
name|_thread_active_threads
operator|--
expr_stmt|;
name|KSE_LOCK_RELEASE
argument_list|(
name|curkse
argument_list|,
operator|&
name|_thread_list_lock
argument_list|)
expr_stmt|;
name|_kse_critical_leave
argument_list|(
name|crit
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_thr_hash_add
parameter_list|(
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
block|{
name|struct
name|thread_hash_head
modifier|*
name|head
decl_stmt|;
name|head
operator|=
operator|&
name|thr_hashtable
index|[
name|THREAD_HASH
argument_list|(
name|thread
argument_list|)
index|]
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
name|head
argument_list|,
name|thread
argument_list|,
name|hle
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_thr_hash_remove
parameter_list|(
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
block|{
name|LIST_REMOVE
argument_list|(
name|thread
argument_list|,
name|hle
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|pthread
modifier|*
name|_thr_hash_find
parameter_list|(
name|struct
name|pthread
modifier|*
name|thread
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|td
decl_stmt|;
name|struct
name|thread_hash_head
modifier|*
name|head
decl_stmt|;
name|head
operator|=
operator|&
name|thr_hashtable
index|[
name|THREAD_HASH
argument_list|(
name|thread
argument_list|)
index|]
expr_stmt|;
name|LIST_FOREACH
argument_list|(
argument|td
argument_list|,
argument|head
argument_list|,
argument|hle
argument_list|)
block|{
if|if
condition|(
name|td
operator|==
name|thread
condition|)
return|return
operator|(
name|thread
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|_thr_debug_check_yield
parameter_list|(
name|struct
name|pthread
modifier|*
name|curthread
parameter_list|)
block|{
comment|/* 	 * Note that TMDF_SUSPEND is set after process is suspended. 	 * When we are being debugged, every suspension in process 	 * will cause all KSEs to schedule an upcall in kernel, unless the 	 * KSE is in critical region. 	 * If the function is being called, it means the KSE is no longer 	 * in critical region, if the TMDF_SUSPEND is set by debugger 	 * before KSE leaves critical region, we will catch it here, else 	 * if the flag is changed during testing, it also not a problem, 	 * because the change only occurs after a process suspension event 	 * occurs. A suspension event will always cause KSE to schedule an 	 * upcall, in the case, because we are not in critical region, 	 * upcall will be scheduled sucessfully, the flag will be checked 	 * again in kse_sched_multi, we won't back until the flag 	 * is cleared by debugger, the flag will be cleared in next 	 * suspension event.  	 */
if|if
condition|(
operator|!
name|DBG_CAN_RUN
argument_list|(
name|curthread
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|curthread
operator|->
name|attr
operator|.
name|flags
operator|&
name|PTHREAD_SCOPE_SYSTEM
operator|)
operator|==
literal|0
condition|)
name|_thr_sched_switch
argument_list|(
name|curthread
argument_list|)
expr_stmt|;
else|else
name|kse_thr_interrupt
argument_list|(
operator|&
name|curthread
operator|->
name|tcb
operator|->
name|tcb_tmbx
argument_list|,
name|KSE_INTR_DBSUSPEND
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

