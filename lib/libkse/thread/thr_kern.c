begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1995 John Birrell<jb@cimlogic.com.au>.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by John Birrell.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY JOHN BIRRELL AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $Id: uthread_kern.c,v 1.6 1998/02/13 01:27:33 julian Exp $  *  */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/syscall.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_THREAD_SAFE
end_ifdef

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|"pthread_private.h"
end_include

begin_comment
comment|/* Static variables: */
end_comment

begin_decl_stmt
specifier|static
name|sigset_t
name|sig_to_block
init|=
literal|0xffffffff
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|sigset_t
name|sig_to_unblock
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Static function prototype definitions: */
end_comment

begin_function_decl
specifier|static
name|void
name|_thread_kern_select
parameter_list|(
name|int
name|wait_reqd
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_thread_signal
parameter_list|(
name|pthread_t
name|pthread
parameter_list|,
name|int
name|sig
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|_thread_kern_sched
parameter_list|(
name|struct
name|sigcontext
modifier|*
name|scp
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|__alpha__
name|char
modifier|*
name|fdata
decl_stmt|;
endif|#
directive|endif
name|int
name|i
decl_stmt|;
name|int
name|prio
init|=
operator|-
literal|1
decl_stmt|;
name|pthread_t
name|pthread
decl_stmt|;
name|pthread_t
name|pthread_h
init|=
name|NULL
decl_stmt|;
name|pthread_t
name|pthread_nxt
init|=
name|NULL
decl_stmt|;
name|pthread_t
name|pthread_prv
init|=
name|NULL
decl_stmt|;
name|pthread_t
name|pthread_s
init|=
name|NULL
decl_stmt|;
name|struct
name|itimerval
name|itimer
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
name|struct
name|timespec
name|ts1
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|timeval
name|tv1
decl_stmt|;
comment|/* Block signals: */
name|_thread_kern_sig_block
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* Check if this function was called from the signal handler: */
if|if
condition|(
name|scp
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Copy the signal context to the current thread's jump 		 * buffer:  		 */
name|memcpy
argument_list|(
operator|&
name|_thread_run
operator|->
name|saved_sigcontext
argument_list|,
name|scp
argument_list|,
sizeof|sizeof
argument_list|(
name|_thread_run
operator|->
name|saved_sigcontext
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|__alpha__
comment|/* Point to the floating point data in the running thread: */
name|fdata
operator|=
name|_thread_run
operator|->
name|saved_fp
expr_stmt|;
comment|/* Save the floating point data: */
asm|__asm__("fnsave %0": :"m"(*fdata));
endif|#
directive|endif
comment|/* Flag the signal context as the last state saved: */
name|_thread_run
operator|->
name|sig_saved
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Save the state of the current thread: */
elseif|else
if|if
condition|(
name|_thread_sys_setjmp
argument_list|(
name|_thread_run
operator|->
name|saved_jmp_buf
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Unblock signals (just in case): */
name|_thread_kern_sig_unblock
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * This point is reached when a longjmp() is called to 		 * restore the state of a thread.  		 */
return|return;
block|}
else|else
block|{
comment|/* Flag the jump buffer was the last state saved: */
name|_thread_run
operator|->
name|sig_saved
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Point to the first dead thread (if there are any): */
name|pthread
operator|=
name|_thread_dead
expr_stmt|;
comment|/* There is no previous dead thread: */
name|pthread_prv
operator|=
name|NULL
expr_stmt|;
comment|/* Enter a loop to cleanup after dead threads: */
while|while
condition|(
name|pthread
operator|!=
name|NULL
condition|)
block|{
comment|/* Save a pointer to the next thread: */
name|pthread_nxt
operator|=
name|pthread
operator|->
name|nxt
expr_stmt|;
comment|/* Check if this thread is one which is running: */
if|if
condition|(
name|pthread
operator|==
name|_thread_run
operator|||
name|pthread
operator|==
name|_thread_initial
condition|)
block|{
comment|/* 			 * Don't destroy the running thread or the initial 			 * thread.  			 */
name|pthread_prv
operator|=
name|pthread
expr_stmt|;
block|}
comment|/* 		 * Check if this thread has detached or if it is a signal 		 * handler thread:  		 */
elseif|else
if|if
condition|(
operator|(
operator|(
name|pthread
operator|->
name|attr
operator|.
name|flags
operator|&
name|PTHREAD_DETACHED
operator|)
operator|!=
literal|0
operator|)
operator|||
name|pthread
operator|->
name|parent_thread
operator|!=
name|NULL
condition|)
block|{
comment|/* Check if there is no previous dead thread: */
if|if
condition|(
name|pthread_prv
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * The dead thread is at the head of the 				 * list:  				 */
name|_thread_dead
operator|=
name|pthread_nxt
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * The dead thread is not at the head of the 				 * list:  				 */
name|pthread_prv
operator|->
name|nxt
operator|=
name|pthread
operator|->
name|nxt
expr_stmt|;
block|}
comment|/* 			 * Check if the stack was not specified by the caller 			 * to pthread_create and has not been destroyed yet:  			 */
if|if
condition|(
name|pthread
operator|->
name|attr
operator|.
name|stackaddr_attr
operator|==
name|NULL
operator|&&
name|pthread
operator|->
name|stack
operator|!=
name|NULL
condition|)
block|{
comment|/* Free the stack of the dead thread: */
name|free
argument_list|(
name|pthread
operator|->
name|stack
argument_list|)
expr_stmt|;
block|}
comment|/* Free the memory allocated to the thread structure: */
name|free
argument_list|(
name|pthread
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * This thread has not detached, so do not destroy 			 * it:  			 */
name|pthread_prv
operator|=
name|pthread
expr_stmt|;
comment|/* 			 * Check if the stack was not specified by the caller 			 * to pthread_create and has not been destroyed yet:  			 */
if|if
condition|(
name|pthread
operator|->
name|attr
operator|.
name|stackaddr_attr
operator|==
name|NULL
operator|&&
name|pthread
operator|->
name|stack
operator|!=
name|NULL
condition|)
block|{
comment|/* Free the stack of the dead thread: */
name|free
argument_list|(
name|pthread
operator|->
name|stack
argument_list|)
expr_stmt|;
comment|/* 				 * NULL the stack pointer now that the memory 				 * has been freed:  				 */
name|pthread
operator|->
name|stack
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Point to the next thread: */
name|pthread
operator|=
name|pthread_nxt
expr_stmt|;
block|}
comment|/* 	 * Enter a the scheduling loop that finds the next thread that is 	 * ready to run. This loop completes when there are no more threads 	 * in the global list or when a thread has its state restored by 	 * either a sigreturn (if the state was saved as a sigcontext) or a 	 * longjmp (if the state was saved by a setjmp).  	 */
while|while
condition|(
name|_thread_link_list
operator|!=
name|NULL
condition|)
block|{
comment|/* Get the current time of day: */
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TIMEVAL_TO_TIMESPEC
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
comment|/* 		 * Poll file descriptors to update the state of threads 		 * waiting on file I/O where data may be available:  		 */
name|_thread_kern_select
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Enter a loop to look for sleeping threads that are ready 		 * or threads with pending signals that are no longer 		 * blocked:  		 */
for|for
control|(
name|pthread
operator|=
name|_thread_link_list
init|;
name|pthread
operator|!=
name|NULL
condition|;
name|pthread
operator|=
name|pthread
operator|->
name|nxt
control|)
block|{
comment|/* Enter a loop to process the sending signals: */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NSIG
condition|;
name|i
operator|++
control|)
block|{
comment|/* 				 * Check if there are no pending signals of 				 * this type:  				 */
if|if
condition|(
name|pthread
operator|->
name|sigpend
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{ 				}
comment|/* Check if this signal type is not masked: */
elseif|else
if|if
condition|(
name|sigismember
argument_list|(
operator|&
name|pthread
operator|->
name|sigmask
argument_list|,
name|i
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 					 * Delete the signal from the set of 					 * pending signals for this thread:  					 */
name|pthread
operator|->
name|sigpend
index|[
name|i
index|]
operator|-=
literal|1
expr_stmt|;
comment|/* 					 * Act on the signal for the current 					 * thread:  					 */
name|_thread_signal
argument_list|(
name|pthread
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * This signal is masked, so make 					 * sure the count does not exceed 1:  					 */
name|pthread
operator|->
name|sigpend
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Check if this thread is to timeout: */
if|if
condition|(
name|pthread
operator|->
name|state
operator|==
name|PS_COND_WAIT
operator|||
name|pthread
operator|->
name|state
operator|==
name|PS_SLEEP_WAIT
operator|||
name|pthread
operator|->
name|state
operator|==
name|PS_FDR_WAIT
operator|||
name|pthread
operator|->
name|state
operator|==
name|PS_FDW_WAIT
operator|||
name|pthread
operator|->
name|state
operator|==
name|PS_SELECT_WAIT
condition|)
block|{
comment|/* Check if this thread is to wait forever: */
if|if
condition|(
name|pthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|==
operator|-
literal|1
condition|)
block|{ 				}
comment|/* 				 * Check if this thread is to wakeup 				 * immediately or if it is past its wakeup 				 * time:  				 */
elseif|else
if|if
condition|(
operator|(
name|pthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|==
literal|0
operator|&&
name|pthread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|==
literal|0
operator|)
operator|||
operator|(
name|ts
operator|.
name|tv_sec
operator|>
name|pthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|)
operator|||
operator|(
operator|(
name|ts
operator|.
name|tv_sec
operator|==
name|pthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|)
operator|&&
operator|(
name|ts
operator|.
name|tv_nsec
operator|>=
name|pthread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|)
operator|)
condition|)
block|{
comment|/* 					 * Check if this thread is waiting on 					 * select:  					 */
if|if
condition|(
name|pthread
operator|->
name|state
operator|==
name|PS_SELECT_WAIT
condition|)
block|{
comment|/* 						 * The select has timed out, 						 * so zero the file 						 * descriptor sets:  						 */
name|FD_ZERO
argument_list|(
operator|&
name|pthread
operator|->
name|data
operator|.
name|select_data
operator|->
name|readfds
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|pthread
operator|->
name|data
operator|.
name|select_data
operator|->
name|writefds
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|pthread
operator|->
name|data
operator|.
name|select_data
operator|->
name|exceptfds
argument_list|)
expr_stmt|;
name|pthread
operator|->
name|data
operator|.
name|select_data
operator|->
name|nfds
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 					 * Return an error as an interrupted 					 * wait:  					 */
name|_thread_seterrno
argument_list|(
name|pthread
argument_list|,
name|EINTR
argument_list|)
expr_stmt|;
comment|/* 					 * Flag the timeout in the thread 					 * structure:  					 */
name|pthread
operator|->
name|timeout
operator|=
literal|1
expr_stmt|;
comment|/* 					 * Change the threads state to allow 					 * it to be restarted:  					 */
name|PTHREAD_NEW_STATE
argument_list|(
name|pthread
argument_list|,
name|PS_RUNNING
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Check if there is a current thread: */
if|if
condition|(
name|_thread_run
operator|!=
operator|&
name|_thread_kern_thread
condition|)
block|{
comment|/* 			 * Save the current time as the time that the thread 			 * became inactive:  			 */
name|_thread_run
operator|->
name|last_inactive
operator|.
name|tv_sec
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|_thread_run
operator|->
name|last_inactive
operator|.
name|tv_usec
operator|=
name|tv
operator|.
name|tv_usec
expr_stmt|;
comment|/* 			 * Accumulate the number of microseconds that this 			 * thread has run for:  			 */
name|_thread_run
operator|->
name|slice_usec
operator|+=
operator|(
name|_thread_run
operator|->
name|last_inactive
operator|.
name|tv_sec
operator|-
name|_thread_run
operator|->
name|last_active
operator|.
name|tv_sec
operator|)
operator|*
literal|1000000
operator|+
name|_thread_run
operator|->
name|last_inactive
operator|.
name|tv_usec
operator|-
name|_thread_run
operator|->
name|last_active
operator|.
name|tv_usec
expr_stmt|;
comment|/* 			 * Check if this thread has reached its allocated 			 * time slice period:  			 */
if|if
condition|(
name|_thread_run
operator|->
name|slice_usec
operator|>
name|TIMESLICE_USEC
condition|)
block|{
comment|/* 				 * Flag the allocated time slice period as 				 * up:  				 */
name|_thread_run
operator|->
name|slice_usec
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* Check if an incremental priority update is required: */
if|if
condition|(
operator|(
operator|(
name|tv
operator|.
name|tv_sec
operator|-
name|kern_inc_prio_time
operator|.
name|tv_sec
operator|)
operator|*
literal|1000000
operator|+
name|tv
operator|.
name|tv_usec
operator|-
name|kern_inc_prio_time
operator|.
name|tv_usec
operator|)
operator|>
name|INC_PRIO_USEC
condition|)
block|{
comment|/* 			 * Enter a loop to look for run-enabled threads that 			 * have not run since the last time that an 			 * incremental priority update was performed:  			 */
for|for
control|(
name|pthread
operator|=
name|_thread_link_list
init|;
name|pthread
operator|!=
name|NULL
condition|;
name|pthread
operator|=
name|pthread
operator|->
name|nxt
control|)
block|{
comment|/* Check if this thread is unable to run: */
if|if
condition|(
name|pthread
operator|->
name|state
operator|!=
name|PS_RUNNING
condition|)
block|{ 				}
comment|/* 				 * Check if the last time that this thread 				 * was run (as indicated by the last time it 				 * became inactive) is before the time that 				 * the last incremental priority check was 				 * made:  				 */
elseif|else
if|if
condition|(
name|timercmp
argument_list|(
operator|&
name|_thread_run
operator|->
name|last_inactive
argument_list|,
operator|&
name|kern_inc_prio_time
argument_list|,
operator|>
argument_list|)
condition|)
block|{
comment|/* 					 * Increment the incremental priority 					 * for this thread in the hope that 					 * it will eventually get a chance to 					 * run:  					 */
operator|(
name|pthread
operator|->
name|inc_prio
operator|)
operator|++
expr_stmt|;
block|}
block|}
comment|/* Save the new incremental priority update time: */
name|kern_inc_prio_time
operator|.
name|tv_sec
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|kern_inc_prio_time
operator|.
name|tv_usec
operator|=
name|tv
operator|.
name|tv_usec
expr_stmt|;
block|}
comment|/* 		 * Enter a loop to look for the first thread of the highest 		 * priority that is ready to run:  		 */
for|for
control|(
name|pthread
operator|=
name|_thread_link_list
init|;
name|pthread
operator|!=
name|NULL
condition|;
name|pthread
operator|=
name|pthread
operator|->
name|nxt
control|)
block|{
comment|/* Check if in single-threaded mode: */
if|if
condition|(
name|_thread_single
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * Check if the current thread is 				 * the thread for which single-threaded 				 * mode is enabled: 				 */
if|if
condition|(
name|pthread
operator|==
name|_thread_single
condition|)
block|{
comment|/* 					 * This thread is allowed 					 * to run. 					 */
block|}
else|else
block|{
comment|/* 					 * Walk up the signal handler                                          * parent thread tree to see 					 * if the current thread is 					 * descended from the thread 					 * for which single-threaded 					 * mode is enabled. 					 */
name|pthread_nxt
operator|=
name|pthread
expr_stmt|;
while|while
condition|(
name|pthread_nxt
operator|!=
name|NULL
operator|&&
name|pthread_nxt
operator|!=
name|_thread_single
condition|)
block|{
name|pthread_nxt
operator|=
name|pthread
operator|->
name|parent_thread
expr_stmt|;
block|}
comment|/* 					 * Check if the current 					 * thread is not descended 					 * from the thread for which 					 * single-threaded mode is 					 * enabled. 					 */
if|if
condition|(
name|pthread_nxt
operator|==
name|NULL
condition|)
comment|/* Ignore this thread. */
continue|continue;
block|}
block|}
comment|/* Check if the current thread is unable to run: */
if|if
condition|(
name|pthread
operator|->
name|state
operator|!=
name|PS_RUNNING
condition|)
block|{ 			}
comment|/* 			 * Check if no run-enabled thread has been seen or if 			 * the current thread has a priority higher than the 			 * highest seen so far:  			 */
elseif|else
if|if
condition|(
name|pthread_h
operator|==
name|NULL
operator|||
operator|(
name|pthread
operator|->
name|pthread_priority
operator|+
name|pthread
operator|->
name|inc_prio
operator|)
operator|>
name|prio
condition|)
block|{
comment|/* 				 * Save this thread as the highest priority 				 * thread seen so far:  				 */
name|pthread_h
operator|=
name|pthread
expr_stmt|;
name|prio
operator|=
name|pthread
operator|->
name|pthread_priority
operator|+
name|pthread
operator|->
name|inc_prio
expr_stmt|;
block|}
block|}
comment|/* 		 * Enter a loop to look for a thread that: 1. Is run-enabled. 		 * 2. Has the required agregate priority. 3. Has not been 		 * allocated its allocated time slice. 4. Became inactive 		 * least recently.  		 */
for|for
control|(
name|pthread
operator|=
name|_thread_link_list
init|;
name|pthread
operator|!=
name|NULL
condition|;
name|pthread
operator|=
name|pthread
operator|->
name|nxt
control|)
block|{
comment|/* Check if in single-threaded mode: */
if|if
condition|(
name|_thread_single
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * Check if the current thread is 				 * the thread for which single-threaded 				 * mode is enabled: 				 */
if|if
condition|(
name|pthread
operator|==
name|_thread_single
condition|)
block|{
comment|/* 					 * This thread is allowed 					 * to run. 					 */
block|}
else|else
block|{
comment|/* 					 * Walk up the signal handler                                          * parent thread tree to see 					 * if the current thread is 					 * descended from the thread 					 * for which single-threaded 					 * mode is enabled. 					 */
name|pthread_nxt
operator|=
name|pthread
expr_stmt|;
while|while
condition|(
name|pthread_nxt
operator|!=
name|NULL
operator|&&
name|pthread_nxt
operator|!=
name|_thread_single
condition|)
block|{
name|pthread_nxt
operator|=
name|pthread
operator|->
name|parent_thread
expr_stmt|;
block|}
comment|/* 					 * Check if the current 					 * thread is not descended 					 * from the thread for which 					 * single-threaded mode is 					 * enabled. 					 */
if|if
condition|(
name|pthread_nxt
operator|==
name|NULL
condition|)
comment|/* Ignore this thread. */
continue|continue;
block|}
block|}
comment|/* Check if the current thread is unable to run: */
if|if
condition|(
name|pthread
operator|->
name|state
operator|!=
name|PS_RUNNING
condition|)
block|{
comment|/* Ignore threads that are not ready to run. */
block|}
comment|/* 			 * Check if the current thread as an agregate 			 * priority not equal to the highest priority found 			 * above:  			 */
elseif|else
if|if
condition|(
operator|(
name|pthread
operator|->
name|pthread_priority
operator|+
name|pthread
operator|->
name|inc_prio
operator|)
operator|!=
name|prio
condition|)
block|{
comment|/* 				 * Ignore threads which have lower agregate 				 * priority.  				 */
block|}
comment|/* 			 * Check if the current thread reached its time slice 			 * allocation last time it ran (or if it has not run 			 * yet):  			 */
elseif|else
if|if
condition|(
name|pthread
operator|->
name|slice_usec
operator|==
operator|-
literal|1
condition|)
block|{ 			}
comment|/* 			 * Check if an eligible thread has not been found 			 * yet, or if the current thread has an inactive time 			 * earlier than the last one seen:  			 */
elseif|else
if|if
condition|(
name|pthread_s
operator|==
name|NULL
operator|||
name|timercmp
argument_list|(
operator|&
name|pthread
operator|->
name|last_inactive
argument_list|,
operator|&
name|tv1
argument_list|,
operator|<
argument_list|)
condition|)
block|{
comment|/* 				 * Save the pointer to the current thread as 				 * the most eligible thread seen so far:  				 */
name|pthread_s
operator|=
name|pthread
expr_stmt|;
comment|/* 				 * Save the time that the selected thread 				 * became inactive:  				 */
name|tv1
operator|.
name|tv_sec
operator|=
name|pthread
operator|->
name|last_inactive
operator|.
name|tv_sec
expr_stmt|;
name|tv1
operator|.
name|tv_usec
operator|=
name|pthread
operator|->
name|last_inactive
operator|.
name|tv_usec
expr_stmt|;
block|}
block|}
comment|/* 		 * Check if no thread was selected according to incomplete 		 * time slice allocation:  		 */
if|if
condition|(
name|pthread_s
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Enter a loop to look for any other thread that: 1. 			 * Is run-enabled. 2. Has the required agregate 			 * priority. 3. Became inactive least recently.  			 */
for|for
control|(
name|pthread
operator|=
name|_thread_link_list
init|;
name|pthread
operator|!=
name|NULL
condition|;
name|pthread
operator|=
name|pthread
operator|->
name|nxt
control|)
block|{
comment|/* Check if in single-threaded mode: */
if|if
condition|(
name|_thread_single
operator|!=
name|NULL
condition|)
block|{
comment|/* 					 * Check if the current thread is 					 * the thread for which single-threaded 					 * mode is enabled: 					 */
if|if
condition|(
name|pthread
operator|==
name|_thread_single
condition|)
block|{
comment|/* 						 * This thread is allowed 						 * to run. 						 */
block|}
else|else
block|{
comment|/* 						 * Walk up the signal handler 						 * parent thread tree to see 						 * if the current thread is 						 * descended from the thread 						 * for which single-threaded 						 * mode is enabled. 						 */
name|pthread_nxt
operator|=
name|pthread
expr_stmt|;
while|while
condition|(
name|pthread_nxt
operator|!=
name|NULL
operator|&&
name|pthread_nxt
operator|!=
name|_thread_single
condition|)
block|{
name|pthread_nxt
operator|=
name|pthread
operator|->
name|parent_thread
expr_stmt|;
block|}
comment|/* 						 * Check if the current 						 * thread is not descended 						 * from the thread for which 						 * single-threaded mode is 						 * enabled. 						 */
if|if
condition|(
name|pthread_nxt
operator|==
name|NULL
condition|)
comment|/* Ignore this thread. */
continue|continue;
block|}
block|}
comment|/* 				 * Check if the current thread is unable to 				 * run:  				 */
if|if
condition|(
name|pthread
operator|->
name|state
operator|!=
name|PS_RUNNING
condition|)
block|{
comment|/* 					 * Ignore threads that are not ready 					 * to run.  					 */
block|}
comment|/* 				 * Check if the current thread as an agregate 				 * priority not equal to the highest priority 				 * found above:  				 */
elseif|else
if|if
condition|(
operator|(
name|pthread
operator|->
name|pthread_priority
operator|+
name|pthread
operator|->
name|inc_prio
operator|)
operator|!=
name|prio
condition|)
block|{
comment|/* 					 * Ignore threads which have lower 					 * agregate priority.    					 */
block|}
comment|/* 				 * Check if an eligible thread has not been 				 * found yet, or if the current thread has an 				 * inactive time earlier than the last one 				 * seen:  				 */
elseif|else
if|if
condition|(
name|pthread_s
operator|==
name|NULL
operator|||
name|timercmp
argument_list|(
operator|&
name|pthread
operator|->
name|last_inactive
argument_list|,
operator|&
name|tv1
argument_list|,
operator|<
argument_list|)
condition|)
block|{
comment|/* 					 * Save the pointer to the current 					 * thread as the most eligible thread 					 * seen so far:  					 */
name|pthread_s
operator|=
name|pthread
expr_stmt|;
comment|/* 					 * Save the time that the selected 					 * thread became inactive:  					 */
name|tv1
operator|.
name|tv_sec
operator|=
name|pthread
operator|->
name|last_inactive
operator|.
name|tv_sec
expr_stmt|;
name|tv1
operator|.
name|tv_usec
operator|=
name|pthread
operator|->
name|last_inactive
operator|.
name|tv_usec
expr_stmt|;
block|}
block|}
block|}
comment|/* Check if there are no threads ready to run: */
if|if
condition|(
name|pthread_s
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Lock the pthread kernel by changing the pointer to 			 * the running thread to point to the global kernel 			 * thread structure:  			 */
name|_thread_run
operator|=
operator|&
name|_thread_kern_thread
expr_stmt|;
comment|/* 			 * There are no threads ready to run, so wait until 			 * something happens that changes this condition:  			 */
name|_thread_kern_select
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Make the selected thread the current thread: */
name|_thread_run
operator|=
name|pthread_s
expr_stmt|;
comment|/* 			 * Save the current time as the time that the thread 			 * became active:  			 */
name|_thread_run
operator|->
name|last_active
operator|.
name|tv_sec
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|_thread_run
operator|->
name|last_active
operator|.
name|tv_usec
operator|=
name|tv
operator|.
name|tv_usec
expr_stmt|;
comment|/* 			 * Check if this thread is running for the first time 			 * or running again after using its full time slice 			 * allocation:  			 */
if|if
condition|(
name|_thread_run
operator|->
name|slice_usec
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Reset the accumulated time slice period: */
name|_thread_run
operator|->
name|slice_usec
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 			 * Reset the incremental priority now that this 			 * thread has been given the chance to run:  			 */
name|_thread_run
operator|->
name|inc_prio
operator|=
literal|0
expr_stmt|;
comment|/* Check if there is more than one thread: */
if|if
condition|(
name|_thread_run
operator|!=
name|_thread_link_list
operator|||
name|_thread_run
operator|->
name|nxt
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * Define the maximum time before a SIGVTALRM 				 * is required:  				 */
name|itimer
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|itimer
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
name|TIMESLICE_USEC
expr_stmt|;
comment|/* 				 * The interval timer is not reloaded when it 				 * times out. The interval time needs to be 				 * calculated every time.  				 */
name|itimer
operator|.
name|it_interval
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|itimer
operator|.
name|it_interval
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
comment|/* 				 * Enter a loop to look for threads waiting 				 * for a time:  				 */
for|for
control|(
name|pthread
operator|=
name|_thread_link_list
init|;
name|pthread
operator|!=
name|NULL
condition|;
name|pthread
operator|=
name|pthread
operator|->
name|nxt
control|)
block|{
comment|/* 					 * Check if this thread is to 					 * timeout:  					 */
if|if
condition|(
name|pthread
operator|->
name|state
operator|==
name|PS_COND_WAIT
operator|||
name|pthread
operator|->
name|state
operator|==
name|PS_SLEEP_WAIT
operator|||
name|pthread
operator|->
name|state
operator|==
name|PS_FDR_WAIT
operator|||
name|pthread
operator|->
name|state
operator|==
name|PS_FDW_WAIT
operator|||
name|pthread
operator|->
name|state
operator|==
name|PS_SELECT_WAIT
condition|)
block|{
comment|/* 						 * Check if this thread is to 						 * wait forever:  						 */
if|if
condition|(
name|pthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|==
operator|-
literal|1
condition|)
block|{ 						}
comment|/* 						 * Check if this thread is to 						 * wakeup immediately:  						 */
elseif|else
if|if
condition|(
name|pthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|==
literal|0
operator|&&
name|pthread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|==
literal|0
condition|)
block|{ 						}
comment|/* 						 * Check if the current time 						 * is after the wakeup time:  						 */
elseif|else
if|if
condition|(
operator|(
name|ts
operator|.
name|tv_sec
operator|>
name|pthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|)
operator|||
operator|(
operator|(
name|ts
operator|.
name|tv_sec
operator|==
name|pthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|)
operator|&&
operator|(
name|ts
operator|.
name|tv_nsec
operator|>
name|pthread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|)
operator|)
condition|)
block|{ 						}
else|else
block|{
comment|/* 							 * Calculate the time 							 * until this thread 							 * is ready, allowing 							 * for the clock 							 * resolution:  							 */
name|ts1
operator|.
name|tv_sec
operator|=
name|pthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|-
name|ts
operator|.
name|tv_sec
expr_stmt|;
name|ts1
operator|.
name|tv_nsec
operator|=
name|pthread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|-
name|ts
operator|.
name|tv_nsec
operator|+
name|CLOCK_RES_NSEC
expr_stmt|;
comment|/* 							 * Check for 							 * underflow of the 							 * nanosecond field:  							 */
if|if
condition|(
name|ts1
operator|.
name|tv_nsec
operator|<
literal|0
condition|)
block|{
comment|/* 								 * Allow for 								 * the 								 * underflow 								 * of the 								 * nanosecond 								 * field:  								 */
name|ts1
operator|.
name|tv_sec
operator|--
expr_stmt|;
name|ts1
operator|.
name|tv_nsec
operator|+=
literal|1000000000
expr_stmt|;
block|}
comment|/* 							 * Check for overflow 							 * of the nanosecond 							 * field:  							 */
if|if
condition|(
name|ts1
operator|.
name|tv_nsec
operator|>=
literal|1000000000
condition|)
block|{
comment|/* 								 * Allow for 								 * the 								 * overflow 								 * of the 								 * nanosecond 								 * field:  								 */
name|ts1
operator|.
name|tv_sec
operator|++
expr_stmt|;
name|ts1
operator|.
name|tv_nsec
operator|-=
literal|1000000000
expr_stmt|;
block|}
comment|/* 							 * Convert the 							 * timespec structure 							 * to a timeval 							 * structure:  							 */
name|TIMESPEC_TO_TIMEVAL
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|ts1
argument_list|)
expr_stmt|;
comment|/* 							 * Check if the 							 * thread will be 							 * ready sooner than 							 * the earliest one 							 * found so far:  							 */
if|if
condition|(
name|timercmp
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|itimer
operator|.
name|it_value
argument_list|,
operator|<
argument_list|)
condition|)
block|{
comment|/* 								 * Update the 								 * time 								 * value:  								 */
name|itimer
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
name|tv
operator|.
name|tv_sec
expr_stmt|;
name|itimer
operator|.
name|it_value
operator|.
name|tv_usec
operator|=
name|tv
operator|.
name|tv_usec
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 				 * Start the interval timer for the 				 * calculated time interval:  				 */
if|if
condition|(
name|setitimer
argument_list|(
name|ITIMER_VIRTUAL
argument_list|,
operator|&
name|itimer
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 					 * Cannot initialise the timer, so 					 * abort this process:  					 */
name|PANIC
argument_list|(
literal|"Cannot set virtual timer"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Check if a signal context was saved: */
if|if
condition|(
name|_thread_run
operator|->
name|sig_saved
operator|==
literal|1
condition|)
block|{
ifndef|#
directive|ifndef
name|__alpha__
comment|/* 				 * Point to the floating point data in the 				 * running thread:  				 */
name|fdata
operator|=
name|_thread_run
operator|->
name|saved_fp
expr_stmt|;
comment|/* Restore the floating point state: */
asm|__asm__("frstor %0": :"m"(*fdata));
endif|#
directive|endif
comment|/* 				 * Do a sigreturn to restart the thread that 				 * was interrupted by a signal:  				 */
name|_thread_sys_sigreturn
argument_list|(
operator|&
name|_thread_run
operator|->
name|saved_sigcontext
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Do a longjmp to restart the thread that 				 * was context switched out (by a longjmp to 				 * a different thread):  				 */
name|_thread_sys_longjmp
argument_list|(
name|_thread_run
operator|->
name|saved_jmp_buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* This point should not be reached. */
name|PANIC
argument_list|(
literal|"Thread has returned from sigreturn or longjmp"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* There are no more threads, so exit this process: */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_thread_signal
parameter_list|(
name|pthread_t
name|pthread
parameter_list|,
name|int
name|sig
parameter_list|)
block|{
name|int
name|done
decl_stmt|;
name|long
name|l
decl_stmt|;
name|pthread_t
name|new_pthread
decl_stmt|;
name|struct
name|sigaction
name|act
decl_stmt|;
name|void
modifier|*
name|arg
decl_stmt|;
comment|/* 	 * Assume that the signal will not be dealt with according 	 * to the thread state: 	 */
name|done
operator|=
literal|0
expr_stmt|;
comment|/* Process according to thread state: */
switch|switch
condition|(
name|pthread
operator|->
name|state
condition|)
block|{
comment|/* States which do not change when a signal is trapped: */
case|case
name|PS_COND_WAIT
case|:
case|case
name|PS_DEAD
case|:
case|case
name|PS_FDLR_WAIT
case|:
case|case
name|PS_FDLW_WAIT
case|:
case|case
name|PS_JOIN
case|:
case|case
name|PS_MUTEX_WAIT
case|:
case|case
name|PS_RUNNING
case|:
case|case
name|PS_STATE_MAX
case|:
case|case
name|PS_SIGTHREAD
case|:
case|case
name|PS_SUSPENDED
case|:
comment|/* Nothing to do here. */
break|break;
comment|/* Wait for child: */
case|case
name|PS_WAIT_WAIT
case|:
comment|/* Check if the signal is from a child exiting: */
if|if
condition|(
name|sig
operator|==
name|SIGCHLD
condition|)
block|{
comment|/* Reset the error: */
name|_thread_seterrno
argument_list|(
name|pthread
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Change the state of the thread to run: */
name|PTHREAD_NEW_STATE
argument_list|(
name|pthread
argument_list|,
name|PS_RUNNING
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Return the 'interrupted' error: */
name|_thread_seterrno
argument_list|(
name|pthread
argument_list|,
name|EINTR
argument_list|)
expr_stmt|;
comment|/* Change the state of the thread to run: */
name|PTHREAD_NEW_STATE
argument_list|(
name|pthread
argument_list|,
name|PS_RUNNING
argument_list|)
expr_stmt|;
block|}
name|pthread
operator|->
name|interrupted
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* Waiting on I/O for zero or more file descriptors: */
case|case
name|PS_SELECT_WAIT
case|:
name|pthread
operator|->
name|data
operator|.
name|select_data
operator|->
name|nfds
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Return the 'interrupted' error: */
name|_thread_seterrno
argument_list|(
name|pthread
argument_list|,
name|EINTR
argument_list|)
expr_stmt|;
name|pthread
operator|->
name|interrupted
operator|=
literal|1
expr_stmt|;
comment|/* Change the state of the thread to run: */
name|PTHREAD_NEW_STATE
argument_list|(
name|pthread
argument_list|,
name|PS_RUNNING
argument_list|)
expr_stmt|;
break|break;
comment|/* 	 * States that are interrupted by the occurrence of a signal 	 * other than the scheduling alarm:  	 */
case|case
name|PS_FDR_WAIT
case|:
case|case
name|PS_FDW_WAIT
case|:
case|case
name|PS_SLEEP_WAIT
case|:
comment|/* Return the 'interrupted' error: */
name|_thread_seterrno
argument_list|(
name|pthread
argument_list|,
name|EINTR
argument_list|)
expr_stmt|;
name|pthread
operator|->
name|interrupted
operator|=
literal|1
expr_stmt|;
comment|/* Change the state of the thread to run: */
name|PTHREAD_NEW_STATE
argument_list|(
name|pthread
argument_list|,
name|PS_RUNNING
argument_list|)
expr_stmt|;
comment|/* Return the signal number: */
name|pthread
operator|->
name|signo
operator|=
name|sig
expr_stmt|;
break|break;
comment|/* Waiting on a signal: */
case|case
name|PS_SIGWAIT
case|:
comment|/* Change the state of the thread to run: */
name|PTHREAD_NEW_STATE
argument_list|(
name|pthread
argument_list|,
name|PS_RUNNING
argument_list|)
expr_stmt|;
comment|/* Return the signal number: */
name|pthread
operator|->
name|signo
operator|=
name|sig
expr_stmt|;
comment|/* Flag the signal as dealt with: */
name|done
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* 	 * Check if this signal has been dealt with, or is being 	 * ignored: 	 */
if|if
condition|(
name|done
operator|||
name|pthread
operator|->
name|act
index|[
name|sig
operator|-
literal|1
index|]
operator|.
name|sa_handler
operator|==
name|SIG_IGN
condition|)
block|{
comment|/* Ignore the signal for this thread. */
block|}
comment|/* Check if this signal is to use the default handler: */
elseif|else
if|if
condition|(
name|pthread
operator|->
name|act
index|[
name|sig
operator|-
literal|1
index|]
operator|.
name|sa_handler
operator|==
name|SIG_DFL
condition|)
block|{
comment|/* Process according to signal type: */
switch|switch
condition|(
name|sig
condition|)
block|{
comment|/* Signals which cause core dumps: */
case|case
name|SIGQUIT
case|:
case|case
name|SIGILL
case|:
case|case
name|SIGTRAP
case|:
case|case
name|SIGABRT
case|:
case|case
name|SIGEMT
case|:
case|case
name|SIGFPE
case|:
case|case
name|SIGBUS
case|:
case|case
name|SIGSEGV
case|:
case|case
name|SIGSYS
case|:
comment|/* Clear the signal action: */
name|sigfillset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_handler
operator|=
name|SIG_DFL
expr_stmt|;
name|act
operator|.
name|sa_flags
operator|=
name|SA_RESTART
expr_stmt|;
name|_thread_sys_sigaction
argument_list|(
name|sig
argument_list|,
operator|&
name|act
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 			 * Do a sigreturn back to where the signal was 			 * detected and a core dump should occur:  			 */
name|_thread_sys_sigreturn
argument_list|(
operator|&
name|pthread
operator|->
name|saved_sigcontext
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * The following signals should terminate the 		 * process. Do this by clearing the signal action 		 * and then re-throwing the signal. 		 */
case|case
name|SIGHUP
case|:
case|case
name|SIGINT
case|:
case|case
name|SIGPIPE
case|:
case|case
name|SIGALRM
case|:
case|case
name|SIGTERM
case|:
case|case
name|SIGXCPU
case|:
case|case
name|SIGXFSZ
case|:
case|case
name|SIGVTALRM
case|:
case|case
name|SIGUSR1
case|:
case|case
name|SIGUSR2
case|:
comment|/* These signals stop the process. Also re-throw them. */
case|case
name|SIGTSTP
case|:
case|case
name|SIGTTIN
case|:
case|case
name|SIGTTOU
case|:
comment|/* Clear the signal action: */
name|sigfillset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_handler
operator|=
name|SIG_DFL
expr_stmt|;
name|act
operator|.
name|sa_flags
operator|=
name|SA_RESTART
expr_stmt|;
name|_thread_sys_sigaction
argument_list|(
name|sig
argument_list|,
operator|&
name|act
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Re-throw to ourselves. */
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|sig
argument_list|)
expr_stmt|;
break|break;
case|case
name|SIGCONT
case|:
comment|/* 			 * If we get this it means that we were 			 * probably stopped and then continued. 			 * Reset the handler for the SIGTSTP, SIGTTIN 			 * and SIGTTOU signals. 			 */
name|sigfillset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_handler
operator|=
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|_thread_sig_handler
expr_stmt|;
name|act
operator|.
name|sa_flags
operator|=
name|SA_RESTART
expr_stmt|;
comment|/* Initialise the signals for default handling: */
if|if
condition|(
name|_thread_sys_sigaction
argument_list|(
name|SIGTSTP
argument_list|,
operator|&
name|act
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|PANIC
argument_list|(
literal|"Cannot initialise SIGTSTP signal handler"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|_thread_sys_sigaction
argument_list|(
name|SIGTTIN
argument_list|,
operator|&
name|act
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|PANIC
argument_list|(
literal|"Cannot initialise SIGTTIN signal handler"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|_thread_sys_sigaction
argument_list|(
name|SIGTTOU
argument_list|,
operator|&
name|act
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|PANIC
argument_list|(
literal|"Cannot initialise SIGTTOU signal handler"
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* Default processing for other signals: */
default|default:
comment|/* 			 * ### Default processing is a problem to resolve!      			 * ###  			 */
break|break;
block|}
block|}
else|else
block|{
comment|/* 		 * Cast the signal number as a long and then to a void 		 * pointer. Sigh. This is POSIX.  		 */
name|l
operator|=
operator|(
name|long
operator|)
name|sig
expr_stmt|;
name|arg
operator|=
operator|(
name|void
operator|*
operator|)
name|l
expr_stmt|;
comment|/* Create a signal handler thread, but don't run it yet: */
if|if
condition|(
name|_thread_create
argument_list|(
operator|&
name|new_pthread
argument_list|,
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
name|pthread
operator|->
name|act
index|[
name|sig
operator|-
literal|1
index|]
operator|.
name|sa_handler
argument_list|,
name|arg
argument_list|,
name|pthread
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Error creating signal handler thread, so abort 			 * this process:  			 */
name|PANIC
argument_list|(
literal|"Cannot create signal handler thread"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Nothing to return. */
return|return;
block|}
end_function

begin_function
name|void
name|_thread_kern_sig_block
parameter_list|(
name|int
modifier|*
name|status
parameter_list|)
block|{
name|sigset_t
name|oset
decl_stmt|;
comment|/* 	 * Block all signals so that the process will not be interrupted by 	 * signals:  	 */
name|_thread_sys_sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|sig_to_block
argument_list|,
operator|&
name|oset
argument_list|)
expr_stmt|;
comment|/* Check if the caller wants the current block status returned: */
if|if
condition|(
name|status
operator|!=
name|NULL
condition|)
block|{
comment|/* Return the previous signal block status: */
operator|*
name|status
operator|=
operator|(
name|oset
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|_thread_kern_sig_unblock
parameter_list|(
name|int
name|status
parameter_list|)
block|{
name|sigset_t
name|oset
decl_stmt|;
comment|/* 	 * Check if the caller thinks that signals weren't blocked when it 	 * called _thread_kern_sig_block:  	 */
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Unblock all signals so that the process will be 		 * interrupted when a signal occurs:  		 */
name|_thread_sys_sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|sig_to_unblock
argument_list|,
operator|&
name|oset
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|_thread_kern_sched_state
parameter_list|(
name|enum
name|pthread_state
name|state
parameter_list|,
name|char
modifier|*
name|fname
parameter_list|,
name|int
name|lineno
parameter_list|)
block|{
comment|/* Change the state of the current thread: */
name|_thread_run
operator|->
name|state
operator|=
name|state
expr_stmt|;
name|_thread_run
operator|->
name|fname
operator|=
name|fname
expr_stmt|;
name|_thread_run
operator|->
name|lineno
operator|=
name|lineno
expr_stmt|;
comment|/* Schedule the next thread that is ready: */
name|_thread_kern_sched
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|_thread_kern_select
parameter_list|(
name|int
name|wait_reqd
parameter_list|)
block|{
name|char
name|bufr
index|[
literal|128
index|]
decl_stmt|;
name|fd_set
name|fd_set_except
decl_stmt|;
name|fd_set
name|fd_set_read
decl_stmt|;
name|fd_set
name|fd_set_write
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|count_dec
decl_stmt|;
name|int
name|found_one
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|nfds
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|settimeout
decl_stmt|;
name|pthread_t
name|pthread
decl_stmt|;
name|ssize_t
name|num
decl_stmt|;
name|struct
name|timespec
name|ts
decl_stmt|;
name|struct
name|timespec
name|ts1
decl_stmt|;
name|struct
name|timeval
modifier|*
name|p_tv
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|timeval
name|tv1
decl_stmt|;
comment|/* Zero the file descriptor sets: */
name|FD_ZERO
argument_list|(
operator|&
name|fd_set_read
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fd_set_write
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fd_set_except
argument_list|)
expr_stmt|;
comment|/* Check if the caller wants to wait: */
if|if
condition|(
name|wait_reqd
condition|)
block|{
comment|/* 		 * Add the pthread kernel pipe file descriptor to the read 		 * set:  		 */
name|FD_SET
argument_list|(
name|_thread_kern_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fd_set_read
argument_list|)
expr_stmt|;
name|nfds
operator|=
name|_thread_kern_pipe
index|[
literal|0
index|]
expr_stmt|;
comment|/* Get the current time of day: */
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TIMEVAL_TO_TIMESPEC
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|ts
argument_list|)
expr_stmt|;
block|}
comment|/* Initialise the time value structure: */
name|tv
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Enter a loop to process threads waiting on either file descriptors 	 * or times:  	 */
for|for
control|(
name|pthread
operator|=
name|_thread_link_list
init|;
name|pthread
operator|!=
name|NULL
condition|;
name|pthread
operator|=
name|pthread
operator|->
name|nxt
control|)
block|{
comment|/* Assume that this state does not time out: */
name|settimeout
operator|=
literal|0
expr_stmt|;
comment|/* Process according to thread state: */
switch|switch
condition|(
name|pthread
operator|->
name|state
condition|)
block|{
comment|/* 		 * States which do not depend on file descriptor I/O 		 * operations or timeouts:  		 */
case|case
name|PS_DEAD
case|:
case|case
name|PS_FDLR_WAIT
case|:
case|case
name|PS_FDLW_WAIT
case|:
case|case
name|PS_JOIN
case|:
case|case
name|PS_MUTEX_WAIT
case|:
case|case
name|PS_RUNNING
case|:
case|case
name|PS_SIGTHREAD
case|:
case|case
name|PS_SIGWAIT
case|:
case|case
name|PS_STATE_MAX
case|:
case|case
name|PS_WAIT_WAIT
case|:
case|case
name|PS_SUSPENDED
case|:
comment|/* Nothing to do here. */
break|break;
comment|/* File descriptor read wait: */
case|case
name|PS_FDR_WAIT
case|:
comment|/* Add the file descriptor to the read set: */
name|FD_SET
argument_list|(
name|pthread
operator|->
name|data
operator|.
name|fd
operator|.
name|fd
argument_list|,
operator|&
name|fd_set_read
argument_list|)
expr_stmt|;
comment|/* 			 * Check if this file descriptor is greater than any 			 * of those seen so far:  			 */
if|if
condition|(
name|pthread
operator|->
name|data
operator|.
name|fd
operator|.
name|fd
operator|>
name|nfds
condition|)
block|{
comment|/* Remember this file descriptor: */
name|nfds
operator|=
name|pthread
operator|->
name|data
operator|.
name|fd
operator|.
name|fd
expr_stmt|;
block|}
comment|/* Increment the file descriptor count: */
name|count
operator|++
expr_stmt|;
comment|/* This state can time out: */
name|settimeout
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* File descriptor write wait: */
case|case
name|PS_FDW_WAIT
case|:
comment|/* Add the file descriptor to the write set: */
name|FD_SET
argument_list|(
name|pthread
operator|->
name|data
operator|.
name|fd
operator|.
name|fd
argument_list|,
operator|&
name|fd_set_write
argument_list|)
expr_stmt|;
comment|/* 			 * Check if this file descriptor is greater than any 			 * of those seen so far:  			 */
if|if
condition|(
name|pthread
operator|->
name|data
operator|.
name|fd
operator|.
name|fd
operator|>
name|nfds
condition|)
block|{
comment|/* Remember this file descriptor: */
name|nfds
operator|=
name|pthread
operator|->
name|data
operator|.
name|fd
operator|.
name|fd
expr_stmt|;
block|}
comment|/* Increment the file descriptor count: */
name|count
operator|++
expr_stmt|;
comment|/* This state can time out: */
name|settimeout
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* States that time out: */
case|case
name|PS_SLEEP_WAIT
case|:
case|case
name|PS_COND_WAIT
case|:
comment|/* Flag a timeout as required: */
name|settimeout
operator|=
literal|1
expr_stmt|;
break|break;
comment|/* Select wait: */
case|case
name|PS_SELECT_WAIT
case|:
comment|/* 			 * Enter a loop to process each file descriptor in 			 * the thread-specific file descriptor sets:  			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pthread
operator|->
name|data
operator|.
name|select_data
operator|->
name|nfds
condition|;
name|i
operator|++
control|)
block|{
comment|/* 				 * Check if this file descriptor is set for 				 * exceptions:  				 */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|pthread
operator|->
name|data
operator|.
name|select_data
operator|->
name|exceptfds
argument_list|)
condition|)
block|{
comment|/* 					 * Add the file descriptor to the 					 * exception set:  					 */
name|FD_SET
argument_list|(
name|i
argument_list|,
operator|&
name|fd_set_except
argument_list|)
expr_stmt|;
comment|/* 					 * Increment the file descriptor 					 * count:  					 */
name|count
operator|++
expr_stmt|;
comment|/* 					 * Check if this file descriptor is 					 * greater than any of those seen so 					 * far:  					 */
if|if
condition|(
name|i
operator|>
name|nfds
condition|)
block|{
comment|/* 						 * Remember this file 						 * descriptor:  						 */
name|nfds
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* 				 * Check if this file descriptor is set for 				 * write:  				 */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|pthread
operator|->
name|data
operator|.
name|select_data
operator|->
name|writefds
argument_list|)
condition|)
block|{
comment|/* 					 * Add the file descriptor to the 					 * write set:  					 */
name|FD_SET
argument_list|(
name|i
argument_list|,
operator|&
name|fd_set_write
argument_list|)
expr_stmt|;
comment|/* 					 * Increment the file descriptor 					 * count:  					 */
name|count
operator|++
expr_stmt|;
comment|/* 					 * Check if this file descriptor is 					 * greater than any of those seen so 					 * far:  					 */
if|if
condition|(
name|i
operator|>
name|nfds
condition|)
block|{
comment|/* 						 * Remember this file 						 * descriptor:  						 */
name|nfds
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* 				 * Check if this file descriptor is set for 				 * read:  				 */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|pthread
operator|->
name|data
operator|.
name|select_data
operator|->
name|readfds
argument_list|)
condition|)
block|{
comment|/* 					 * Add the file descriptor to the 					 * read set:  					 */
name|FD_SET
argument_list|(
name|i
argument_list|,
operator|&
name|fd_set_read
argument_list|)
expr_stmt|;
comment|/* 					 * Increment the file descriptor 					 * count:  					 */
name|count
operator|++
expr_stmt|;
comment|/* 					 * Check if this file descriptor is 					 * greater than any of those seen so 					 * far:  					 */
if|if
condition|(
name|i
operator|>
name|nfds
condition|)
block|{
comment|/* 						 * Remember this file 						 * descriptor:  						 */
name|nfds
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
comment|/* This state can time out: */
name|settimeout
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* 		 * Check if the caller wants to wait and if the thread state 		 * is one that times out:  		 */
if|if
condition|(
name|wait_reqd
operator|&&
name|settimeout
condition|)
block|{
comment|/* Check if this thread wants to wait forever: */
if|if
condition|(
name|pthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|==
operator|-
literal|1
condition|)
block|{ 			}
comment|/* Check if this thread doesn't want to wait at all: */
elseif|else
if|if
condition|(
name|pthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|==
literal|0
operator|&&
name|pthread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|==
literal|0
condition|)
block|{
comment|/* Override the caller's request to wait: */
name|wait_reqd
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Calculate the time until this thread is 				 * ready, allowing for the clock resolution:  				 */
name|ts1
operator|.
name|tv_sec
operator|=
name|pthread
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|-
name|ts
operator|.
name|tv_sec
expr_stmt|;
name|ts1
operator|.
name|tv_nsec
operator|=
name|pthread
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|-
name|ts
operator|.
name|tv_nsec
operator|+
name|CLOCK_RES_NSEC
expr_stmt|;
comment|/* 				 * Check for underflow of the nanosecond 				 * field:  				 */
if|if
condition|(
name|ts1
operator|.
name|tv_nsec
operator|<
literal|0
condition|)
block|{
comment|/* 					 * Allow for the underflow of the 					 * nanosecond field:  					 */
name|ts1
operator|.
name|tv_sec
operator|--
expr_stmt|;
name|ts1
operator|.
name|tv_nsec
operator|+=
literal|1000000000
expr_stmt|;
block|}
comment|/* 				 * Check for overflow of the nanosecond 				 * field:  				 */
if|if
condition|(
name|ts1
operator|.
name|tv_nsec
operator|>=
literal|1000000000
condition|)
block|{
comment|/* 					 * Allow for the overflow of the 					 * nanosecond field:  					 */
name|ts1
operator|.
name|tv_sec
operator|++
expr_stmt|;
name|ts1
operator|.
name|tv_nsec
operator|-=
literal|1000000000
expr_stmt|;
block|}
comment|/* 				 * Convert the timespec structure to a 				 * timeval structure:  				 */
name|TIMESPEC_TO_TIMEVAL
argument_list|(
operator|&
name|tv1
argument_list|,
operator|&
name|ts1
argument_list|)
expr_stmt|;
comment|/* 				 * Check if no time value has been found yet, 				 * or if the thread will be ready sooner that 				 * the earliest one found so far:  				 */
if|if
condition|(
operator|(
name|tv
operator|.
name|tv_sec
operator|==
literal|0
operator|&&
name|tv
operator|.
name|tv_usec
operator|==
literal|0
operator|)
operator|||
name|timercmp
argument_list|(
operator|&
name|tv1
argument_list|,
operator|&
name|tv
argument_list|,
operator|<
argument_list|)
condition|)
block|{
comment|/* Update the time value: */
name|tv
operator|.
name|tv_sec
operator|=
name|tv1
operator|.
name|tv_sec
expr_stmt|;
name|tv
operator|.
name|tv_usec
operator|=
name|tv1
operator|.
name|tv_usec
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Check if the caller wants to wait: */
if|if
condition|(
name|wait_reqd
condition|)
block|{
comment|/* Check if no threads were found with timeouts: */
if|if
condition|(
name|tv
operator|.
name|tv_sec
operator|==
literal|0
operator|&&
name|tv
operator|.
name|tv_usec
operator|==
literal|0
condition|)
block|{
comment|/* Wait forever: */
name|p_tv
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Point to the time value structure which contains 			 * the earliest time that a thread will be ready:  			 */
name|p_tv
operator|=
operator|&
name|tv
expr_stmt|;
block|}
comment|/* 		 * Flag the pthread kernel as in a select. This is to avoid 		 * the window between the next statement that unblocks 		 * signals and the select statement which follows.  		 */
name|_thread_kern_in_select
operator|=
literal|1
expr_stmt|;
comment|/* Unblock all signals: */
name|_thread_kern_sig_unblock
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Wait for a file descriptor to be ready for read, write, or 		 * an exception, or a timeout to occur:  		 */
name|count
operator|=
name|_thread_sys_select
argument_list|(
name|nfds
operator|+
literal|1
argument_list|,
operator|&
name|fd_set_read
argument_list|,
operator|&
name|fd_set_write
argument_list|,
operator|&
name|fd_set_except
argument_list|,
name|p_tv
argument_list|)
expr_stmt|;
comment|/* Block all signals again: */
name|_thread_kern_sig_block
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* Reset the kernel in select flag: */
name|_thread_kern_in_select
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Check if it is possible that there are bytes in the kernel 		 * read pipe waiting to be read:  		 */
if|if
condition|(
name|count
operator|<
literal|0
operator|||
name|FD_ISSET
argument_list|(
name|_thread_kern_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fd_set_read
argument_list|)
condition|)
block|{
comment|/* 			 * Check if the kernel read pipe was included in the 			 * count:  			 */
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
comment|/* 				 * Remove the kernel read pipe from the 				 * count:  				 */
name|FD_CLR
argument_list|(
name|_thread_kern_pipe
index|[
literal|0
index|]
argument_list|,
operator|&
name|fd_set_read
argument_list|)
expr_stmt|;
comment|/* Decrement the count of file descriptors: */
name|count
operator|--
expr_stmt|;
block|}
comment|/* 			 * Enter a loop to read (and trash) bytes from the 			 * pthread kernel pipe:  			 */
while|while
condition|(
operator|(
name|num
operator|=
name|_thread_sys_read
argument_list|(
name|_thread_kern_pipe
index|[
literal|0
index|]
argument_list|,
name|bufr
argument_list|,
sizeof|sizeof
argument_list|(
name|bufr
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
comment|/* 				 * The buffer read contains one byte per 				 * signal and each byte is the signal number. 				 * This data is not used, but the fact that 				 * the signal handler wrote to the pipe *is* 				 * used to cause the _thread_sys_select call 				 * to complete if the signal occurred between 				 * the time when signals were unblocked and 				 * the _thread_sys_select select call being 				 * made.  				 */
block|}
block|}
block|}
comment|/* Check if there are file descriptors to poll: */
elseif|else
if|if
condition|(
name|count
operator|>
literal|0
condition|)
block|{
comment|/* 		 * Point to the time value structure which has been zeroed so 		 * that the call to _thread_sys_select will not wait:  		 */
name|p_tv
operator|=
operator|&
name|tv
expr_stmt|;
comment|/* Poll file descrptors without wait: */
name|count
operator|=
name|_thread_sys_select
argument_list|(
name|nfds
operator|+
literal|1
argument_list|,
operator|&
name|fd_set_read
argument_list|,
operator|&
name|fd_set_write
argument_list|,
operator|&
name|fd_set_except
argument_list|,
name|p_tv
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Check if the select call was interrupted, or some other error 	 * occurred:  	 */
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
comment|/* Check if the select call was interrupted: */
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
block|{
comment|/* 			 * Interrupted calls are expected. The interrupting 			 * signal will be in the sigpend array.  			 */
block|}
else|else
block|{
comment|/* This should not occur: */
block|}
block|}
comment|/* Check if no file descriptors are ready: */
elseif|else
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
comment|/* Nothing to do here.                                              */
block|}
else|else
block|{
comment|/* 		 * Enter a loop to look for threads waiting on file 		 * descriptors that are flagged as available by the 		 * _thread_sys_select syscall:  		 */
for|for
control|(
name|pthread
operator|=
name|_thread_link_list
init|;
name|pthread
operator|!=
name|NULL
condition|;
name|pthread
operator|=
name|pthread
operator|->
name|nxt
control|)
block|{
comment|/* Process according to thread state: */
switch|switch
condition|(
name|pthread
operator|->
name|state
condition|)
block|{
comment|/* 			 * States which do not depend on file 			 * descriptor I/O operations:  			 */
case|case
name|PS_RUNNING
case|:
case|case
name|PS_COND_WAIT
case|:
case|case
name|PS_DEAD
case|:
case|case
name|PS_FDLR_WAIT
case|:
case|case
name|PS_FDLW_WAIT
case|:
case|case
name|PS_JOIN
case|:
case|case
name|PS_MUTEX_WAIT
case|:
case|case
name|PS_SIGWAIT
case|:
case|case
name|PS_SLEEP_WAIT
case|:
case|case
name|PS_WAIT_WAIT
case|:
case|case
name|PS_SIGTHREAD
case|:
case|case
name|PS_STATE_MAX
case|:
case|case
name|PS_SUSPENDED
case|:
comment|/* Nothing to do here. */
break|break;
comment|/* File descriptor read wait: */
case|case
name|PS_FDR_WAIT
case|:
comment|/* 				 * Check if the file descriptor is available 				 * for read:  				 */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|pthread
operator|->
name|data
operator|.
name|fd
operator|.
name|fd
argument_list|,
operator|&
name|fd_set_read
argument_list|)
condition|)
block|{
comment|/* 					 * Change the thread state to allow 					 * it to read from the file when it 					 * is scheduled next:  					 */
name|pthread
operator|->
name|state
operator|=
name|PS_RUNNING
expr_stmt|;
block|}
break|break;
comment|/* File descriptor write wait: */
case|case
name|PS_FDW_WAIT
case|:
comment|/* 				 * Check if the file descriptor is available 				 * for write:  				 */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|pthread
operator|->
name|data
operator|.
name|fd
operator|.
name|fd
argument_list|,
operator|&
name|fd_set_write
argument_list|)
condition|)
block|{
comment|/* 					 * Change the thread state to allow 					 * it to write to the file when it is 					 * scheduled next:  					 */
name|pthread
operator|->
name|state
operator|=
name|PS_RUNNING
expr_stmt|;
block|}
break|break;
comment|/* Select wait: */
case|case
name|PS_SELECT_WAIT
case|:
comment|/* 				 * Reset the flag that indicates if a file 				 * descriptor is ready for some type of 				 * operation:  				 */
name|count_dec
operator|=
literal|0
expr_stmt|;
comment|/* 				 * Enter a loop to search though the 				 * thread-specific select file descriptors 				 * for the first descriptor that is ready:  				 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pthread
operator|->
name|data
operator|.
name|select_data
operator|->
name|nfds
operator|&&
name|count_dec
operator|==
literal|0
condition|;
name|i
operator|++
control|)
block|{
comment|/* 					 * Check if this file descriptor does 					 * not have an exception:  					 */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|pthread
operator|->
name|data
operator|.
name|select_data
operator|->
name|exceptfds
argument_list|)
operator|&&
name|FD_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|fd_set_except
argument_list|)
condition|)
block|{
comment|/* 						 * Flag this file descriptor 						 * as ready:  						 */
name|count_dec
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 					 * Check if this file descriptor is 					 * not ready for write:  					 */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|pthread
operator|->
name|data
operator|.
name|select_data
operator|->
name|writefds
argument_list|)
operator|&&
name|FD_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|fd_set_write
argument_list|)
condition|)
block|{
comment|/* 						 * Flag this file descriptor 						 * as ready:  						 */
name|count_dec
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 					 * Check if this file descriptor is 					 * not ready for read:  					 */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|pthread
operator|->
name|data
operator|.
name|select_data
operator|->
name|readfds
argument_list|)
operator|&&
name|FD_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|fd_set_read
argument_list|)
condition|)
block|{
comment|/* 						 * Flag this file descriptor 						 * as ready:  						 */
name|count_dec
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* 				 * Check if any file descriptors are ready 				 * for the current thread:  				 */
if|if
condition|(
name|count_dec
condition|)
block|{
comment|/* 					 * Reset the count of file 					 * descriptors that are ready for 					 * this thread:  					 */
name|found_one
operator|=
literal|0
expr_stmt|;
comment|/* 					 * Enter a loop to search though the 					 * thread-specific select file 					 * descriptors:  					 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pthread
operator|->
name|data
operator|.
name|select_data
operator|->
name|nfds
condition|;
name|i
operator|++
control|)
block|{
comment|/* 						 * Reset the count of 						 * operations for which the 						 * current file descriptor is 						 * ready:  						 */
name|count_dec
operator|=
literal|0
expr_stmt|;
comment|/* 						 * Check if this file 						 * descriptor is selected for 						 * exceptions:  						 */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|pthread
operator|->
name|data
operator|.
name|select_data
operator|->
name|exceptfds
argument_list|)
condition|)
block|{
comment|/* 							 * Check if this file 							 * descriptor has an 							 * exception:  							 */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|fd_set_except
argument_list|)
condition|)
block|{
comment|/* 								 * Increment 								 * the count 								 * for this 								 * file:  								 */
name|count_dec
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 								 * Clear the 								 * file 								 * descriptor 								 * in the 								 * thread-spec 								 * ific file 								 * descriptor 								 * set:  								 */
name|FD_CLR
argument_list|(
name|i
argument_list|,
operator|&
name|pthread
operator|->
name|data
operator|.
name|select_data
operator|->
name|exceptfds
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 						 * Check if this file 						 * descriptor is selected for 						 * write:  						 */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|pthread
operator|->
name|data
operator|.
name|select_data
operator|->
name|writefds
argument_list|)
condition|)
block|{
comment|/* 							 * Check if this file 							 * descriptor is 							 * ready for write:  							 */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|fd_set_write
argument_list|)
condition|)
block|{
comment|/* 								 * Increment 								 * the count 								 * for this 								 * file:  								 */
name|count_dec
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 								 * Clear the 								 * file 								 * descriptor 								 * in the 								 * thread-spec 								 * ific file 								 * descriptor 								 * set:  								 */
name|FD_CLR
argument_list|(
name|i
argument_list|,
operator|&
name|pthread
operator|->
name|data
operator|.
name|select_data
operator|->
name|writefds
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 						 * Check if this file 						 * descriptor is selected for 						 * read:  						 */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|pthread
operator|->
name|data
operator|.
name|select_data
operator|->
name|readfds
argument_list|)
condition|)
block|{
comment|/* 							 * Check if this file 							 * descriptor is 							 * ready for read:  							 */
if|if
condition|(
name|FD_ISSET
argument_list|(
name|i
argument_list|,
operator|&
name|fd_set_read
argument_list|)
condition|)
block|{
comment|/* 								 * Increment 								 * the count 								 * for this 								 * file:  								 */
name|count_dec
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* 								 * Clear the 								 * file 								 * descriptor 								 * in the 								 * thread-spec 								 * ific file 								 * descriptor 								 * set:  								 */
name|FD_CLR
argument_list|(
name|i
argument_list|,
operator|&
name|pthread
operator|->
name|data
operator|.
name|select_data
operator|->
name|readfds
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 						 * Check if the current file 						 * descriptor is ready for 						 * any one of the operations:  						 */
if|if
condition|(
name|count_dec
operator|>
literal|0
condition|)
block|{
comment|/* 							 * Increment the 							 * count of file 							 * descriptors that 							 * are ready for the 							 * current thread:  							 */
name|found_one
operator|++
expr_stmt|;
block|}
block|}
comment|/* 					 * Return the number of file 					 * descriptors that are ready:  					 */
name|pthread
operator|->
name|data
operator|.
name|select_data
operator|->
name|nfds
operator|=
name|found_one
expr_stmt|;
comment|/* 					 * Change the state of the current 					 * thread to run:  					 */
name|pthread
operator|->
name|state
operator|=
name|PS_RUNNING
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
comment|/* Nothing to return. */
return|return;
block|}
end_function

begin_function
name|void
name|_thread_kern_set_timeout
parameter_list|(
name|struct
name|timespec
modifier|*
name|timeout
parameter_list|)
block|{
name|struct
name|timespec
name|current_time
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
comment|/* Reset the timeout flag for the running thread: */
name|_thread_run
operator|->
name|timeout
operator|=
literal|0
expr_stmt|;
comment|/* Check if the thread is to wait forever: */
if|if
condition|(
name|timeout
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Set the wakeup time to something that can be recognised as 		 * different to an actual time of day:  		 */
name|_thread_run
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|=
operator|-
literal|1
expr_stmt|;
name|_thread_run
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Check if no waiting is required: */
elseif|else
if|if
condition|(
name|timeout
operator|->
name|tv_sec
operator|==
literal|0
operator|&&
name|timeout
operator|->
name|tv_nsec
operator|==
literal|0
condition|)
block|{
comment|/* Set the wake up time to 'immediately': */
name|_thread_run
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|_thread_run
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Get the current time: */
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TIMEVAL_TO_TIMESPEC
argument_list|(
operator|&
name|tv
argument_list|,
operator|&
name|current_time
argument_list|)
expr_stmt|;
comment|/* Calculate the time for the current thread to wake up: */
name|_thread_run
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|=
name|current_time
operator|.
name|tv_sec
operator|+
name|timeout
operator|->
name|tv_sec
expr_stmt|;
name|_thread_run
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|=
name|current_time
operator|.
name|tv_nsec
operator|+
name|timeout
operator|->
name|tv_nsec
expr_stmt|;
comment|/* Check if the nanosecond field needs to wrap: */
if|if
condition|(
name|_thread_run
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|>=
literal|1000000000
condition|)
block|{
comment|/* Wrap the nanosecond field: */
name|_thread_run
operator|->
name|wakeup_time
operator|.
name|tv_sec
operator|+=
literal|1
expr_stmt|;
name|_thread_run
operator|->
name|wakeup_time
operator|.
name|tv_nsec
operator|-=
literal|1000000000
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

