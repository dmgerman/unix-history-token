begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1997, 1998 Kenneth D. Merry.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkstat.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"devstat.h"
end_include

begin_decl_stmt
name|char
name|devstat_errbuf
index|[
name|DEVSTAT_ERRBUF_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Table to match descriptive strings with device types.  These are in  * order from most common to least common to speed search time.  */
end_comment

begin_decl_stmt
name|struct
name|devstat_match_table
name|match_table
index|[]
init|=
block|{
block|{
literal|"da"
block|,
name|DEVSTAT_TYPE_DIRECT
block|,
name|DEVSTAT_MATCH_TYPE
block|}
block|,
block|{
literal|"cd"
block|,
name|DEVSTAT_TYPE_CDROM
block|,
name|DEVSTAT_MATCH_TYPE
block|}
block|,
block|{
literal|"scsi"
block|,
name|DEVSTAT_TYPE_IF_SCSI
block|,
name|DEVSTAT_MATCH_IF
block|}
block|,
block|{
literal|"ide"
block|,
name|DEVSTAT_TYPE_IF_IDE
block|,
name|DEVSTAT_MATCH_IF
block|}
block|,
block|{
literal|"other"
block|,
name|DEVSTAT_TYPE_IF_OTHER
block|,
name|DEVSTAT_MATCH_IF
block|}
block|,
block|{
literal|"worm"
block|,
name|DEVSTAT_TYPE_WORM
block|,
name|DEVSTAT_MATCH_TYPE
block|}
block|,
block|{
literal|"sa"
block|,
name|DEVSTAT_TYPE_SEQUENTIAL
block|,
name|DEVSTAT_MATCH_TYPE
block|}
block|,
block|{
literal|"pass"
block|,
name|DEVSTAT_TYPE_PASS
block|,
name|DEVSTAT_MATCH_PASS
block|}
block|,
block|{
literal|"optical"
block|,
name|DEVSTAT_TYPE_OPTICAL
block|,
name|DEVSTAT_MATCH_TYPE
block|}
block|,
block|{
literal|"array"
block|,
name|DEVSTAT_TYPE_STORARRAY
block|,
name|DEVSTAT_MATCH_TYPE
block|}
block|,
block|{
literal|"changer"
block|,
name|DEVSTAT_TYPE_CHANGER
block|,
name|DEVSTAT_MATCH_TYPE
block|}
block|,
block|{
literal|"scanner"
block|,
name|DEVSTAT_TYPE_SCANNER
block|,
name|DEVSTAT_MATCH_TYPE
block|}
block|,
block|{
literal|"printer"
block|,
name|DEVSTAT_TYPE_PRINTER
block|,
name|DEVSTAT_MATCH_TYPE
block|}
block|,
block|{
literal|"floppy"
block|,
name|DEVSTAT_TYPE_FLOPPY
block|,
name|DEVSTAT_MATCH_TYPE
block|}
block|,
block|{
literal|"proc"
block|,
name|DEVSTAT_TYPE_PROCESSOR
block|,
name|DEVSTAT_MATCH_TYPE
block|}
block|,
block|{
literal|"comm"
block|,
name|DEVSTAT_TYPE_COMM
block|,
name|DEVSTAT_MATCH_TYPE
block|}
block|,
block|{
literal|"enclosure"
block|,
name|DEVSTAT_TYPE_ENCLOSURE
block|,
name|DEVSTAT_MATCH_TYPE
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Local function declarations.  */
end_comment

begin_function_decl
specifier|static
name|int
name|compare_select
parameter_list|(
specifier|const
name|void
modifier|*
name|arg1
parameter_list|,
specifier|const
name|void
modifier|*
name|arg2
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|getnumdevs
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|numdevsize
decl_stmt|;
name|int
name|numdevs
decl_stmt|;
name|char
modifier|*
name|func_name
init|=
literal|"getnumdevs"
decl_stmt|;
name|numdevsize
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
comment|/* 	 * Find out how many devices we have in the system. 	 */
if|if
condition|(
name|sysctlbyname
argument_list|(
literal|"kern.devstat.numdevs"
argument_list|,
operator|&
name|numdevs
argument_list|,
operator|&
name|numdevsize
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|devstat_errbuf
argument_list|,
literal|"%s: error getting number of devices\n"
literal|"%s: %s"
argument_list|,
name|func_name
argument_list|,
name|func_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
name|numdevs
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is an easy way to get the generation number, but the generation is  * supplied in a more atmoic manner by the kern.devstat.all sysctl.  * Because this generation sysctl is separate from the statistics sysctl,  * the device list and the generation could change between the time that  * this function is called and the device list is retreived.  */
end_comment

begin_function
name|long
name|getgeneration
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|gensize
decl_stmt|;
name|long
name|generation
decl_stmt|;
name|char
modifier|*
name|func_name
init|=
literal|"getgeneration"
decl_stmt|;
name|gensize
operator|=
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
comment|/* 	 * Get the current generation number. 	 */
if|if
condition|(
name|sysctlbyname
argument_list|(
literal|"kern.devstat.generation"
argument_list|,
operator|&
name|generation
argument_list|,
operator|&
name|gensize
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|devstat_errbuf
argument_list|,
literal|"%s: error getting devstat generation\n"
literal|"%s: %s"
argument_list|,
name|func_name
argument_list|,
name|func_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
name|generation
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the current devstat version.  The return value of this function  * should be compared with DEVSTAT_VERSION, which is defined in  * sys/devicestat.h.  This will enable userland programs to determine  * whether they are out of sync with the kernel.  */
end_comment

begin_function
name|int
name|getversion
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|versize
decl_stmt|;
name|int
name|version
decl_stmt|;
name|char
modifier|*
name|func_name
init|=
literal|"getversion"
decl_stmt|;
name|versize
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
comment|/* 	 * Get the current devstat version. 	 */
if|if
condition|(
name|sysctlbyname
argument_list|(
literal|"kern.devstat.version"
argument_list|,
operator|&
name|version
argument_list|,
operator|&
name|versize
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|devstat_errbuf
argument_list|,
literal|"%s: error getting devstat version\n"
literal|"%s: %s"
argument_list|,
name|func_name
argument_list|,
name|func_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
name|version
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check the devstat version we know about against the devstat version the  * kernel knows about.  If they don't match, print an error into the  * devstat error buffer, and return -1.  If they match, return 0.  */
end_comment

begin_function
name|int
name|checkversion
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|int
name|errlen
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|func_name
init|=
literal|"checkversion"
decl_stmt|;
name|int
name|version
decl_stmt|;
name|version
operator|=
name|getversion
argument_list|()
expr_stmt|;
if|if
condition|(
name|version
operator|!=
name|DEVSTAT_VERSION
condition|)
block|{
name|int
name|buflen
init|=
literal|0
decl_stmt|;
name|char
name|tmpstr
index|[
literal|256
index|]
decl_stmt|;
comment|/* 		 * This is really pretty silly, but basically the idea is 		 * that if getversion() returns an error (i.e. -1), then it 		 * has printed an error message in the buffer.  Therefore, 		 * we need to add a \n to the end of that message before we 		 * print our own message in the buffer. 		 */
if|if
condition|(
name|version
operator|==
operator|-
literal|1
condition|)
block|{
name|buflen
operator|=
name|strlen
argument_list|(
name|devstat_errbuf
argument_list|)
expr_stmt|;
name|errlen
operator|=
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|devstat_errbuf
argument_list|,
name|tmpstr
argument_list|,
name|DEVSTAT_ERRBUF_SIZE
operator|-
name|buflen
operator|-
literal|1
argument_list|)
expr_stmt|;
name|buflen
operator|+=
name|errlen
expr_stmt|;
block|}
name|errlen
operator|=
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"%s: userland devstat version %d is not "
literal|"the same as the kernel\n%s: devstat "
literal|"version %d\n"
argument_list|,
name|func_name
argument_list|,
name|DEVSTAT_VERSION
argument_list|,
name|func_name
argument_list|,
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|==
operator|-
literal|1
condition|)
block|{
name|strncat
argument_list|(
name|devstat_errbuf
argument_list|,
name|tmpstr
argument_list|,
name|DEVSTAT_ERRBUF_SIZE
operator|-
name|buflen
operator|-
literal|1
argument_list|)
expr_stmt|;
name|buflen
operator|+=
name|errlen
expr_stmt|;
block|}
else|else
block|{
name|strncpy
argument_list|(
name|devstat_errbuf
argument_list|,
name|tmpstr
argument_list|,
name|DEVSTAT_ERRBUF_SIZE
argument_list|)
expr_stmt|;
name|devstat_errbuf
index|[
name|DEVSTAT_ERRBUF_SIZE
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|version
operator|<
name|DEVSTAT_VERSION
condition|)
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"%s: libdevstat newer than kernel\n"
argument_list|,
name|func_name
argument_list|)
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"%s: kernel newer than libdevstat\n"
argument_list|,
name|func_name
argument_list|)
expr_stmt|;
name|strncat
argument_list|(
name|devstat_errbuf
argument_list|,
name|tmpstr
argument_list|,
name|DEVSTAT_ERRBUF_SIZE
operator|-
name|buflen
operator|-
literal|1
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the current list of devices and statistics, and the current  * generation number.  *   * Return values:  * -1  -- error  *  0  -- device list is unchanged  *  1  -- device list has changed  */
end_comment

begin_function
name|int
name|getdevs
parameter_list|(
name|struct
name|statinfo
modifier|*
name|stats
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|size_t
name|dssize
decl_stmt|;
name|int
name|oldnumdevs
decl_stmt|;
name|long
name|oldgeneration
decl_stmt|;
name|int
name|retval
init|=
literal|0
decl_stmt|;
name|struct
name|devinfo
modifier|*
name|dinfo
decl_stmt|;
name|char
modifier|*
name|func_name
init|=
literal|"getdevs"
decl_stmt|;
name|dinfo
operator|=
name|stats
operator|->
name|dinfo
expr_stmt|;
if|if
condition|(
name|dinfo
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|devstat_errbuf
argument_list|,
literal|"%s: stats->dinfo was NULL"
argument_list|,
name|func_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|oldnumdevs
operator|=
name|dinfo
operator|->
name|numdevs
expr_stmt|;
name|oldgeneration
operator|=
name|dinfo
operator|->
name|generation
expr_stmt|;
comment|/* 	 * If this is our first time through, mem_ptr will be null.   	 */
if|if
condition|(
name|dinfo
operator|->
name|mem_ptr
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Get the number of devices.  If it's negative, it's an 		 * error.  Don't bother setting the error string, since 		 * getnumdevs() has already done that for us. 		 */
if|if
condition|(
operator|(
name|dinfo
operator|->
name|numdevs
operator|=
name|getnumdevs
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 		 * The kern.devstat.all sysctl returns the current generation 		 * number, as well as all the devices.  So we need four 		 * bytes more. 		 */
name|dssize
operator|=
operator|(
name|dinfo
operator|->
name|numdevs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|devstat
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|mem_ptr
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|malloc
argument_list|(
name|dssize
argument_list|)
expr_stmt|;
block|}
else|else
name|dssize
operator|=
operator|(
name|dinfo
operator|->
name|numdevs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|devstat
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
comment|/* Get the current time when we get the stats */
name|gettimeofday
argument_list|(
operator|&
name|stats
operator|->
name|busy_time
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Request all of the devices.  We only really allow for one 	 * ENOMEM failure.  It would, of course, be possible to just go in 	 * a loop and keep reallocing the device structure until we don't 	 * get ENOMEM back.  I'm not sure it's worth it, though.  If 	 * devices are being added to the system that quickly, maybe the 	 * user can just wait until all devices are added. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|sysctlbyname
argument_list|(
literal|"kern.devstat.all"
argument_list|,
name|dinfo
operator|->
name|mem_ptr
argument_list|,
operator|&
name|dssize
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* 		 * If we get ENOMEM back, that means that there are  		 * more devices now, so we need to allocate more  		 * space for the device array. 		 */
if|if
condition|(
name|errno
operator|==
name|ENOMEM
condition|)
block|{
comment|/* 			 * No need to set the error string here, getnumdevs() 			 * will do that if it fails. 			 */
if|if
condition|(
operator|(
name|dinfo
operator|->
name|numdevs
operator|=
name|getnumdevs
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|dssize
operator|=
operator|(
name|dinfo
operator|->
name|numdevs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|devstat
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|mem_ptr
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|realloc
argument_list|(
name|dinfo
operator|->
name|mem_ptr
argument_list|,
name|dssize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|sysctlbyname
argument_list|(
literal|"kern.devstat.all"
argument_list|,
name|dinfo
operator|->
name|mem_ptr
argument_list|,
operator|&
name|dssize
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|sprintf
argument_list|(
name|devstat_errbuf
argument_list|,
literal|"%s: error getting device stats\n"
literal|"%s: %s"
argument_list|,
name|func_name
argument_list|,
name|func_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
block|{
name|sprintf
argument_list|(
name|devstat_errbuf
argument_list|,
literal|"%s: error getting device stats\n"
literal|"%s: %s"
argument_list|,
name|func_name
argument_list|,
name|func_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* 	 * The sysctl spits out the generation as the first four bytes, 	 * then all of the device statistics structures. 	 */
name|dinfo
operator|->
name|generation
operator|=
operator|*
operator|(
name|long
operator|*
operator|)
name|dinfo
operator|->
name|mem_ptr
expr_stmt|;
comment|/* 	 * If the generation has changed, and if the current number of 	 * devices is not the same as the number of devices recorded in the 	 * devinfo structure, it is likely that the device list has shrunk. 	 * The reason that it is likely that the device list has shrunk in 	 * this case is that if the device list has grown, the sysctl above 	 * will return an ENOMEM error, and we will reset the number of 	 * devices and reallocate the device array.  If the second sysctl 	 * fails, we will return an error and therefore never get to this 	 * point.  If the device list has shrunk, the sysctl will not 	 * return an error since we have more space allocated than is 	 * necessary.  So, in the shrinkage case, we catch it here and 	 * reallocate the array so that we don't use any more space than is 	 * necessary. 	 */
if|if
condition|(
name|oldgeneration
operator|!=
name|dinfo
operator|->
name|generation
condition|)
block|{
if|if
condition|(
name|getnumdevs
argument_list|()
operator|!=
name|dinfo
operator|->
name|numdevs
condition|)
block|{
if|if
condition|(
operator|(
name|dinfo
operator|->
name|numdevs
operator|=
name|getnumdevs
argument_list|()
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|dssize
operator|=
operator|(
name|dinfo
operator|->
name|numdevs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|devstat
argument_list|)
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|long
argument_list|)
expr_stmt|;
name|dinfo
operator|->
name|mem_ptr
operator|=
operator|(
name|u_int8_t
operator|*
operator|)
name|realloc
argument_list|(
name|dinfo
operator|->
name|mem_ptr
argument_list|,
name|dssize
argument_list|)
expr_stmt|;
block|}
name|retval
operator|=
literal|1
expr_stmt|;
block|}
name|dinfo
operator|->
name|devices
operator|=
operator|(
expr|struct
name|devstat
operator|*
operator|)
operator|(
name|dinfo
operator|->
name|mem_ptr
operator|+
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * selectdevs():  *  * Devices are selected/deselected based upon the following criteria:  * - devices specified by the user on the command line  * - devices matching any device type expressions given on the command line  * - devices with the highest I/O, if 'top' mode is enabled  * - the first n unselected devices in the device list, if maxshowdevs  *   devices haven't already been selected and if the user has not  *   specified any devices on the command line and if we're in "add" mode.  *  * Input parameters:  * - device selection list (dev_select)  * - current number of devices selected (num_selected)  * - total number of devices in the selection list (num_selections)  * - devstat generation as of the last time selectdevs() was called  *   (select_generation)  * - current devstat generation (current_generation)  * - current list of devices and statistics (devices)  * - number of devices in the current device list (numdevs)  * - compiled version of the command line device type arguments (matches)  *   - This is optional.  If the number of devices is 0, this will be ignored.  *   - The matching code pays attention to the current selection mode.  So  *     if you pass in a matching expression, it will be evaluated based  *     upon the selection mode that is passed in.  See below for details.  * - number of device type matching expressions (num_matches)  *   - Set to 0 to disable the matching code.  * - list of devices specified on the command line by the user (dev_selections)  * - number of devices selected on the command line by the user  *   (num_dev_selections)  * - Our selection mode.  There are four different selection modes:  *      - add mode.  (DS_SELECT_ADD) Any devices matching devices explicitly  *        selected by the user or devices matching a pattern given by the  *        user will be selected in addition to devices that are already  *        selected.  Additional devices will be selected, up to maxshowdevs  *        number of devices.   *      - only mode. (DS_SELECT_ONLY)  Only devices matching devices  *        explicitly given by the user or devices matching a pattern  *        given by the user will be selected.  No other devices will be  *        selected.  *      - addonly mode.  (DS_SELECT_ADDONLY)  This is similar to add and  *        only.  Basically, this will not de-select any devices that are  *        current selected, as only mode would, but it will also not  *        gratuitously select up to maxshowdevs devices as add mode would.  *      - remove mode.  (DS_SELECT_REMOVE)  Any devices matching devices  *        explicitly selected by the user or devices matching a pattern  *        given by the user will be de-selected.  * - maximum number of devices we can select (maxshowdevs)  * - flag indicating whether or not we're in 'top' mode (perf_select)  *  * Output data:  * - the device selection list may be modified and passed back out  * - the number of devices selected and the total number of items in the  *   device selection list may be changed  * - the selection generation may be changed to match the current generation  *   * Return values:  * -1  -- error  *  0  -- selected devices are unchanged  *  1  -- selected devices changed  */
end_comment

begin_function
name|int
name|selectdevs
parameter_list|(
name|struct
name|device_selection
modifier|*
modifier|*
name|dev_select
parameter_list|,
name|int
modifier|*
name|num_selected
parameter_list|,
name|int
modifier|*
name|num_selections
parameter_list|,
name|long
modifier|*
name|select_generation
parameter_list|,
name|long
name|current_generation
parameter_list|,
name|struct
name|devstat
modifier|*
name|devices
parameter_list|,
name|int
name|numdevs
parameter_list|,
name|struct
name|devstat_match
modifier|*
name|matches
parameter_list|,
name|int
name|num_matches
parameter_list|,
name|char
modifier|*
modifier|*
name|dev_selections
parameter_list|,
name|int
name|num_dev_selections
parameter_list|,
name|devstat_select_mode
name|select_mode
parameter_list|,
name|int
name|maxshowdevs
parameter_list|,
name|int
name|perf_select
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
name|init_selections
init|=
literal|0
decl_stmt|,
name|init_selected_var
init|=
literal|0
decl_stmt|;
name|struct
name|device_selection
modifier|*
name|old_dev_select
init|=
name|NULL
decl_stmt|;
name|int
name|old_num_selections
init|=
literal|0
decl_stmt|,
name|old_num_selected
decl_stmt|;
name|int
name|selection_number
init|=
literal|0
decl_stmt|;
name|int
name|changed
init|=
literal|0
decl_stmt|,
name|found
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|dev_select
operator|==
name|NULL
operator|)
operator|||
operator|(
name|devices
operator|==
name|NULL
operator|)
operator|||
operator|(
name|numdevs
operator|<=
literal|0
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * We always want to make sure that we have as many dev_select 	 * entries as there are devices.  	 */
comment|/* 	 * In this case, we haven't selected devices before. 	 */
if|if
condition|(
operator|*
name|dev_select
operator|==
name|NULL
condition|)
block|{
operator|*
name|dev_select
operator|=
operator|(
expr|struct
name|device_selection
operator|*
operator|)
name|malloc
argument_list|(
name|numdevs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|device_selection
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|select_generation
operator|=
name|current_generation
expr_stmt|;
name|init_selections
operator|=
literal|1
expr_stmt|;
name|changed
operator|=
literal|1
expr_stmt|;
comment|/* 	 * In this case, we have selected devices before, but the device 	 * list has changed since we last selected devices, so we need to 	 * either enlarge or reduce the size of the device selection list. 	 */
block|}
elseif|else
if|if
condition|(
operator|*
name|num_selections
operator|!=
name|numdevs
condition|)
block|{
operator|*
name|dev_select
operator|=
operator|(
expr|struct
name|device_selection
operator|*
operator|)
name|realloc
argument_list|(
operator|*
name|dev_select
argument_list|,
name|numdevs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|device_selection
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|select_generation
operator|=
name|current_generation
expr_stmt|;
name|init_selections
operator|=
literal|1
expr_stmt|;
comment|/* 	 * In this case, we've selected devices before, and the selection 	 * list is the same size as it was the last time, but the device 	 * list has changed. 	 */
block|}
elseif|else
if|if
condition|(
operator|*
name|select_generation
operator|<
name|current_generation
condition|)
block|{
operator|*
name|select_generation
operator|=
name|current_generation
expr_stmt|;
name|init_selections
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * If we're in "only" mode, we want to clear out the selected 	 * variable since we're going to select exactly what the user wants 	 * this time through. 	 */
if|if
condition|(
name|select_mode
operator|==
name|DS_SELECT_ONLY
condition|)
name|init_selected_var
operator|=
literal|1
expr_stmt|;
comment|/* 	 * In all cases, we want to back up the number of selected devices. 	 * It is a quick and accurate way to determine whether the selected 	 * devices have changed. 	 */
name|old_num_selected
operator|=
operator|*
name|num_selected
expr_stmt|;
comment|/* 	 * We want to make a backup of the current selection list if  	 * the list of devices has changed, or if we're in performance  	 * selection mode.  In both cases, we don't want to make a backup 	 * if we already know for sure that the list will be different. 	 * This is certainly the case if this is our first time through the 	 * selection code. 	 */
if|if
condition|(
operator|(
operator|(
name|init_selected_var
operator|!=
literal|0
operator|)
operator|||
operator|(
name|init_selections
operator|!=
literal|0
operator|)
operator|||
operator|(
name|perf_select
operator|!=
literal|0
operator|)
operator|)
operator|&&
operator|(
name|changed
operator|==
literal|0
operator|)
condition|)
block|{
name|old_dev_select
operator|=
operator|(
expr|struct
name|device_selection
operator|*
operator|)
name|malloc
argument_list|(
operator|*
name|num_selections
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|device_selection
argument_list|)
argument_list|)
expr_stmt|;
name|old_num_selections
operator|=
operator|*
name|num_selections
expr_stmt|;
name|bcopy
argument_list|(
operator|*
name|dev_select
argument_list|,
name|old_dev_select
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|device_selection
argument_list|)
operator|*
operator|*
name|num_selections
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|init_selections
operator|!=
literal|0
condition|)
block|{
name|bzero
argument_list|(
operator|*
name|dev_select
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|device_selection
argument_list|)
operator|*
name|numdevs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numdevs
condition|;
name|i
operator|++
control|)
block|{
operator|(
operator|*
name|dev_select
operator|)
index|[
name|i
index|]
operator|.
name|device_number
operator|=
name|devices
index|[
name|i
index|]
operator|.
name|device_number
expr_stmt|;
name|strncpy
argument_list|(
operator|(
operator|*
name|dev_select
operator|)
index|[
name|i
index|]
operator|.
name|device_name
argument_list|,
name|devices
index|[
name|i
index|]
operator|.
name|device_name
argument_list|,
name|DEVSTAT_NAME_LEN
argument_list|)
expr_stmt|;
operator|(
operator|*
name|dev_select
operator|)
index|[
name|i
index|]
operator|.
name|device_name
index|[
name|DEVSTAT_NAME_LEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
operator|*
name|dev_select
operator|)
index|[
name|i
index|]
operator|.
name|unit_number
operator|=
name|devices
index|[
name|i
index|]
operator|.
name|unit_number
expr_stmt|;
operator|(
operator|*
name|dev_select
operator|)
index|[
name|i
index|]
operator|.
name|position
operator|=
name|i
expr_stmt|;
block|}
operator|*
name|num_selections
operator|=
name|numdevs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|init_selected_var
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numdevs
condition|;
name|i
operator|++
control|)
operator|(
operator|*
name|dev_select
operator|)
index|[
name|i
index|]
operator|.
name|selected
operator|=
literal|0
expr_stmt|;
block|}
comment|/* we haven't gotten around to selecting anything yet.. */
if|if
condition|(
operator|(
name|select_mode
operator|==
name|DS_SELECT_ONLY
operator|)
operator|||
operator|(
name|init_selections
operator|!=
literal|0
operator|)
operator|||
operator|(
name|init_selected_var
operator|!=
literal|0
operator|)
condition|)
operator|*
name|num_selected
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Look through any devices the user specified on the command line 	 * and see if they match known devices.  If so, select them. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
operator|*
name|num_selections
operator|)
operator|&&
operator|(
name|num_dev_selections
operator|>
literal|0
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|char
name|tmpstr
index|[
literal|80
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|tmpstr
argument_list|,
sizeof|sizeof
argument_list|(
name|tmpstr
argument_list|)
argument_list|,
literal|"%s%d"
argument_list|,
operator|(
operator|*
name|dev_select
operator|)
index|[
name|i
index|]
operator|.
name|device_name
argument_list|,
operator|(
operator|*
name|dev_select
operator|)
index|[
name|i
index|]
operator|.
name|unit_number
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_dev_selections
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|tmpstr
argument_list|,
name|dev_selections
index|[
name|j
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Here we do different things based on the 				 * mode we're in.  If we're in add or 				 * addonly mode, we only select this device 				 * if it hasn't already been selected. 				 * Otherwise, we would be unnecessarily 				 * changing the selection order and 				 * incrementing the selection count.  If 				 * we're in only mode, we unconditionally 				 * select this device, since in only mode 				 * any previous selections are erased and 				 * manually specified devices are the first 				 * ones to be selected.  If we're in remove 				 * mode, we de-select the specified device and 				 * decrement the selection count. 				 */
switch|switch
condition|(
name|select_mode
condition|)
block|{
case|case
name|DS_SELECT_ADD
case|:
case|case
name|DS_SELECT_ADDONLY
case|:
if|if
condition|(
operator|(
operator|*
name|dev_select
operator|)
index|[
name|i
index|]
operator|.
name|selected
condition|)
break|break;
comment|/* FALLTHROUGH */
case|case
name|DS_SELECT_ONLY
case|:
operator|(
operator|*
name|dev_select
operator|)
index|[
name|i
index|]
operator|.
name|selected
operator|=
operator|++
name|selection_number
expr_stmt|;
operator|(
operator|*
name|num_selected
operator|)
operator|++
expr_stmt|;
break|break;
case|case
name|DS_SELECT_REMOVE
case|:
operator|(
operator|*
name|dev_select
operator|)
index|[
name|i
index|]
operator|.
name|selected
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|num_selected
operator|)
operator|--
expr_stmt|;
comment|/* 					 * This isn't passed back out, we 					 * just use it to keep track of 					 * how many devices we've removed. 					 */
name|num_dev_selections
operator|--
expr_stmt|;
break|break;
block|}
break|break;
block|}
block|}
block|}
comment|/* 	 * Go through the user's device type expressions and select devices 	 * accordingly.  We only do this if the number of devices already 	 * selected is less than the maximum number we can show. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|num_matches
operator|)
operator|&&
operator|(
operator|*
name|num_selected
operator|<
name|maxshowdevs
operator|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* We should probably indicate some error here */
if|if
condition|(
operator|(
name|matches
index|[
name|i
index|]
operator|.
name|match_fields
operator|==
name|DEVSTAT_MATCH_NONE
operator|)
operator|||
operator|(
name|matches
index|[
name|i
index|]
operator|.
name|num_match_categories
operator|<=
literal|0
operator|)
condition|)
continue|continue;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numdevs
condition|;
name|j
operator|++
control|)
block|{
name|int
name|num_match_categories
decl_stmt|;
name|num_match_categories
operator|=
name|matches
index|[
name|i
index|]
operator|.
name|num_match_categories
expr_stmt|;
comment|/* 			 * Determine whether or not the current device 			 * matches the given matching expression.  This if 			 * statement consists of three components: 			 *   - the device type check 			 *   - the device interface check 			 *   - the passthrough check 			 * If a the matching test is successful, it  			 * decrements the number of matching categories, 			 * and if we've reached the last element that 			 * needed to be matched, the if statement succeeds. 			 *  			 */
if|if
condition|(
operator|(
operator|(
operator|(
name|matches
index|[
name|i
index|]
operator|.
name|match_fields
operator|&
name|DEVSTAT_MATCH_TYPE
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|devices
index|[
name|j
index|]
operator|.
name|device_type
operator|&
name|DEVSTAT_TYPE_MASK
operator|)
operator|==
operator|(
name|matches
index|[
name|i
index|]
operator|.
name|device_type
operator|&
name|DEVSTAT_TYPE_MASK
operator|)
operator|)
operator|&&
operator|(
operator|(
operator|(
name|matches
index|[
name|i
index|]
operator|.
name|match_fields
operator|&
name|DEVSTAT_MATCH_PASS
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
operator|(
name|matches
index|[
name|i
index|]
operator|.
name|match_fields
operator|&
name|DEVSTAT_MATCH_PASS
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|devices
index|[
name|j
index|]
operator|.
name|device_type
operator|&
name|DEVSTAT_TYPE_PASS
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|--
name|num_match_categories
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
operator|(
name|matches
index|[
name|i
index|]
operator|.
name|match_fields
operator|&
name|DEVSTAT_MATCH_IF
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|devices
index|[
name|j
index|]
operator|.
name|device_type
operator|&
name|DEVSTAT_TYPE_IF_MASK
operator|)
operator|==
operator|(
name|matches
index|[
name|i
index|]
operator|.
name|device_type
operator|&
name|DEVSTAT_TYPE_IF_MASK
operator|)
operator|)
operator|&&
operator|(
operator|(
operator|(
name|matches
index|[
name|i
index|]
operator|.
name|match_fields
operator|&
name|DEVSTAT_MATCH_PASS
operator|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|(
operator|(
name|matches
index|[
name|i
index|]
operator|.
name|match_fields
operator|&
name|DEVSTAT_MATCH_PASS
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|devices
index|[
name|j
index|]
operator|.
name|device_type
operator|&
name|DEVSTAT_TYPE_PASS
operator|)
operator|==
literal|0
operator|)
operator|)
operator|)
operator|&&
operator|(
operator|--
name|num_match_categories
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
operator|(
name|matches
index|[
name|i
index|]
operator|.
name|match_fields
operator|&
name|DEVSTAT_MATCH_PASS
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|devices
index|[
name|j
index|]
operator|.
name|device_type
operator|&
name|DEVSTAT_TYPE_PASS
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|--
name|num_match_categories
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
comment|/* 				 * This is probably a non-optimal solution 				 * to the problem that the devices in the 				 * device list will not be in the same 				 * order as the devices in the selection 				 * array. 				 */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|numdevs
condition|;
name|k
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|dev_select
operator|)
index|[
name|k
index|]
operator|.
name|position
operator|==
name|j
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* 				 * There shouldn't be a case where a device 				 * in the device list is not in the 				 * selection list...but it could happen. 				 */
if|if
condition|(
name|found
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"selectdevs: couldn't"
literal|" find %s%d in selection "
literal|"list\n"
argument_list|,
name|devices
index|[
name|j
index|]
operator|.
name|device_name
argument_list|,
name|devices
index|[
name|j
index|]
operator|.
name|unit_number
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 				 * We do different things based upon the 				 * mode we're in.  If we're in add or only 				 * mode, we go ahead and select this device 				 * if it hasn't already been selected.  If 				 * it has already been selected, we leave 				 * it alone so we don't mess up the 				 * selection ordering.  Manually specified 				 * devices have already been selected, and 				 * they have higher priority than pattern 				 * matched devices.  If we're in remove 				 * mode, we de-select the given device and 				 * decrement the selected count. 				 */
switch|switch
condition|(
name|select_mode
condition|)
block|{
case|case
name|DS_SELECT_ADD
case|:
case|case
name|DS_SELECT_ADDONLY
case|:
case|case
name|DS_SELECT_ONLY
case|:
if|if
condition|(
operator|(
operator|*
name|dev_select
operator|)
index|[
name|k
index|]
operator|.
name|selected
operator|!=
literal|0
condition|)
break|break;
operator|(
operator|*
name|dev_select
operator|)
index|[
name|k
index|]
operator|.
name|selected
operator|=
operator|++
name|selection_number
expr_stmt|;
operator|(
operator|*
name|num_selected
operator|)
operator|++
expr_stmt|;
break|break;
case|case
name|DS_SELECT_REMOVE
case|:
operator|(
operator|*
name|dev_select
operator|)
index|[
name|k
index|]
operator|.
name|selected
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|num_selected
operator|)
operator|--
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
comment|/* 	 * Here we implement "top" mode.  Devices are sorted in the 	 * selection array based on two criteria:  whether or not they are 	 * selected (not selection number, just the fact that they are 	 * selected!) and the number of bytes in the "bytes" field of the 	 * selection structure.  The bytes field generally must be kept up 	 * by the user.  In the future, it may be maintained by library 	 * functions, but for now the user has to do the work. 	 * 	 * At first glance, it may seem wrong that we don't go through and 	 * select every device in the case where the user hasn't specified 	 * any devices or patterns.  In fact, though, it won't make any 	 * difference in the device sorting.  In that particular case (i.e. 	 * when we're in "add" or "only" mode, and the user hasn't 	 * specified anything) the first time through no devices will be 	 * selected, so the only criterion used to sort them will be their 	 * performance.  The second time through, and every time thereafter, 	 * all devices will be selected, so again selection won't matter. 	 */
if|if
condition|(
name|perf_select
operator|!=
literal|0
condition|)
block|{
comment|/* Sort the device array by throughput  */
name|qsort
argument_list|(
operator|*
name|dev_select
argument_list|,
operator|*
name|num_selections
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|device_selection
argument_list|)
argument_list|,
name|compare_select
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|num_selected
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Here we select every device in the array, if it 			 * isn't already selected.  Because the 'selected' 			 * variable in the selection array entries contains 			 * the selection order, the devstats routine can show 			 * the devices that were selected first. 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|num_selections
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|dev_select
operator|)
index|[
name|i
index|]
operator|.
name|selected
operator|==
literal|0
condition|)
block|{
operator|(
operator|*
name|dev_select
operator|)
index|[
name|i
index|]
operator|.
name|selected
operator|=
operator|++
name|selection_number
expr_stmt|;
operator|(
operator|*
name|num_selected
operator|)
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|selection_number
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|num_selections
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|*
name|dev_select
operator|)
index|[
name|i
index|]
operator|.
name|selected
operator|!=
literal|0
condition|)
block|{
operator|(
operator|*
name|dev_select
operator|)
index|[
name|i
index|]
operator|.
name|selected
operator|=
operator|++
name|selection_number
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 	 * If we're in the "add" selection mode and if we haven't already 	 * selected maxshowdevs number of devices, go through the array and 	 * select any unselected devices.  If we're in "only" mode, we 	 * obviously don't want to select anything other than what the user 	 * specifies.  If we're in "remove" mode, it probably isn't a good 	 * idea to go through and select any more devices, since we might 	 * end up selecting something that the user wants removed.  Through 	 * more complicated logic, we could actually figure this out, but 	 * that would probably require combining this loop with the various 	 * selections loops above. 	 */
if|if
condition|(
operator|(
name|select_mode
operator|==
name|DS_SELECT_ADD
operator|)
operator|&&
operator|(
operator|*
name|num_selected
operator|<
name|maxshowdevs
operator|)
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|*
name|num_selections
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|*
name|dev_select
operator|)
index|[
name|i
index|]
operator|.
name|selected
operator|==
literal|0
condition|)
block|{
operator|(
operator|*
name|dev_select
operator|)
index|[
name|i
index|]
operator|.
name|selected
operator|=
operator|++
name|selection_number
expr_stmt|;
operator|(
operator|*
name|num_selected
operator|)
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * Look at the number of devices that have been selected.  If it 	 * has changed, set the changed variable.  Otherwise, if we've 	 * made a backup of the selection list, compare it to the current 	 * selection list to see if the selected devices have changed. 	 */
if|if
condition|(
operator|(
name|changed
operator|==
literal|0
operator|)
operator|&&
operator|(
name|old_num_selected
operator|!=
operator|*
name|num_selected
operator|)
condition|)
name|changed
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|changed
operator|==
literal|0
operator|)
operator|&&
operator|(
name|old_dev_select
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|/* 		 * Now we go through the selection list and we look at 		 * it three different ways. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
operator|*
name|num_selections
operator|)
operator|&&
operator|(
name|changed
operator|==
literal|0
operator|)
operator|&&
operator|(
name|i
operator|<
name|old_num_selections
operator|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* 			 * If the device at index i in both the new and old 			 * selection arrays has the same device number and 			 * selection status, it hasn't changed.  We 			 * continue on to the next index. 			 */
if|if
condition|(
operator|(
operator|(
operator|*
name|dev_select
operator|)
index|[
name|i
index|]
operator|.
name|device_number
operator|==
name|old_dev_select
index|[
name|i
index|]
operator|.
name|device_number
operator|)
operator|&&
operator|(
operator|(
operator|*
name|dev_select
operator|)
index|[
name|i
index|]
operator|.
name|selected
operator|==
name|old_dev_select
index|[
name|i
index|]
operator|.
name|selected
operator|)
condition|)
continue|continue;
comment|/* 			 * Now, if we're still going through the if 			 * statement, the above test wasn't true.  So we 			 * check here to see if the device at index i in 			 * the current array is the same as the device at 			 * index i in the old array.  If it is, that means 			 * that its selection number has changed.  Set 			 * changed to 1 and exit the loop. 			 */
elseif|else
if|if
condition|(
operator|(
operator|*
name|dev_select
operator|)
index|[
name|i
index|]
operator|.
name|device_number
operator|==
name|old_dev_select
index|[
name|i
index|]
operator|.
name|device_number
condition|)
block|{
name|changed
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* 			 * If we get here, then the device at index i in 			 * the current array isn't the same device as the 			 * device at index i in the old array. 			 */
else|else
block|{
name|int
name|found
init|=
literal|0
decl_stmt|;
comment|/* 				 * Search through the old selection array 				 * looking for a device with the same 				 * device number as the device at index i 				 * in the current array.  If the selection 				 * status is the same, then we mark it as 				 * found.  If the selection status isn't 				 * the same, we break out of the loop. 				 * Since found isn't set, changed will be 				 * set to 1 below. 				 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|old_num_selections
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
operator|(
operator|(
operator|*
name|dev_select
operator|)
index|[
name|i
index|]
operator|.
name|device_number
operator|==
name|old_dev_select
index|[
name|j
index|]
operator|.
name|device_number
operator|)
operator|&&
operator|(
operator|(
operator|*
name|dev_select
operator|)
index|[
name|i
index|]
operator|.
name|selected
operator|==
name|old_dev_select
index|[
name|j
index|]
operator|.
name|selected
operator|)
condition|)
block|{
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
operator|*
name|dev_select
operator|)
index|[
name|i
index|]
operator|.
name|device_number
operator|==
name|old_dev_select
index|[
name|j
index|]
operator|.
name|device_number
condition|)
break|break;
block|}
if|if
condition|(
name|found
operator|==
literal|0
condition|)
name|changed
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|old_dev_select
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|old_dev_select
argument_list|)
expr_stmt|;
return|return
operator|(
name|changed
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Comparison routine for qsort() above.  Note that the comparison here is  * backwards -- generally, it should return a value to indicate whether  * arg1 is<, =, or> arg2.  Instead, it returns the opposite.  The reason  * it returns the opposite is so that the selection array will be sorted in  * order of decreasing performance.  We sort on two parameters.  The first  * sort key is whether or not one or the other of the devices in question  * has been selected.  If one of them has, and the other one has not, the  * selected device is automatically more important than the unselected  * device.  If neither device is selected, we judge the devices based upon  * performance.  */
end_comment

begin_function
specifier|static
name|int
name|compare_select
parameter_list|(
specifier|const
name|void
modifier|*
name|arg1
parameter_list|,
specifier|const
name|void
modifier|*
name|arg2
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|(
operator|(
expr|struct
name|device_selection
operator|*
operator|)
name|arg1
operator|)
operator|->
name|selected
operator|)
operator|&&
operator|(
operator|(
operator|(
expr|struct
name|device_selection
operator|*
operator|)
name|arg2
operator|)
operator|->
name|selected
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
operator|(
operator|(
operator|(
expr|struct
name|device_selection
operator|*
operator|)
name|arg1
operator|)
operator|->
name|selected
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|(
expr|struct
name|device_selection
operator|*
operator|)
name|arg2
operator|)
operator|->
name|selected
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
operator|(
operator|(
expr|struct
name|device_selection
operator|*
operator|)
name|arg2
operator|)
operator|->
name|bytes
operator|<
operator|(
operator|(
expr|struct
name|device_selection
operator|*
operator|)
name|arg1
operator|)
operator|->
name|bytes
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
operator|(
operator|(
expr|struct
name|device_selection
operator|*
operator|)
name|arg2
operator|)
operator|->
name|bytes
operator|>
operator|(
operator|(
expr|struct
name|device_selection
operator|*
operator|)
name|arg1
operator|)
operator|->
name|bytes
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Take a string with the general format "arg1,arg2,arg3", and build a  * device matching expression from it.  */
end_comment

begin_function
name|int
name|buildmatch
parameter_list|(
name|char
modifier|*
name|match_str
parameter_list|,
name|struct
name|devstat_match
modifier|*
modifier|*
name|matches
parameter_list|,
name|int
modifier|*
name|num_matches
parameter_list|)
block|{
name|char
modifier|*
name|tstr
index|[
literal|5
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|tempstr
decl_stmt|;
name|int
name|num_args
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|func_name
init|=
literal|"buildmatch"
decl_stmt|;
comment|/* We can't do much without a string to parse */
if|if
condition|(
name|match_str
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|devstat_errbuf
argument_list|,
literal|"%s: no match expression"
argument_list|,
name|func_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Break the (comma delimited) input string out into separate strings. 	 */
for|for
control|(
name|tempstr
operator|=
name|tstr
operator|,
name|num_args
operator|=
literal|0
init|;
operator|(
operator|*
name|tempstr
operator|=
name|strsep
argument_list|(
operator|&
name|match_str
argument_list|,
literal|","
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|num_args
operator|<
literal|5
operator|)
condition|;
name|num_args
operator|++
control|)
if|if
condition|(
operator|*
operator|*
name|tempstr
operator|!=
literal|'\0'
condition|)
if|if
condition|(
operator|++
name|tempstr
operator|>=
operator|&
name|tstr
index|[
literal|5
index|]
condition|)
break|break;
comment|/* The user gave us too many type arguments */
if|if
condition|(
name|num_args
operator|>
literal|3
condition|)
block|{
name|sprintf
argument_list|(
name|devstat_errbuf
argument_list|,
literal|"%s: too many type arguments"
argument_list|,
name|func_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * Since you can't realloc a pointer that hasn't been malloced 	 * first, we malloc first and then realloc. 	 */
if|if
condition|(
operator|*
name|num_matches
operator|==
literal|0
condition|)
operator|*
name|matches
operator|=
operator|(
expr|struct
name|devstat_match
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|devstat_match
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|*
name|matches
operator|=
operator|(
expr|struct
name|devstat_match
operator|*
operator|)
name|realloc
argument_list|(
operator|*
name|matches
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|devstat_match
argument_list|)
operator|*
operator|(
operator|*
name|num_matches
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* Make sure the current entry is clear */
name|bzero
argument_list|(
operator|&
name|matches
index|[
literal|0
index|]
index|[
operator|*
name|num_matches
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|devstat_match
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Step through the arguments the user gave us and build a device 	 * matching expression from them. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_args
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|tempstr2
decl_stmt|,
modifier|*
name|tempstr3
decl_stmt|;
comment|/* 		 * Get rid of leading white space. 		 */
name|tempstr2
operator|=
name|tstr
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|tempstr2
argument_list|)
operator|&&
operator|(
operator|*
name|tempstr2
operator|!=
literal|'\0'
operator|)
condition|)
name|tempstr2
operator|++
expr_stmt|;
comment|/* 		 * Get rid of trailing white space. 		 */
name|tempstr3
operator|=
operator|&
name|tempstr2
index|[
name|strlen
argument_list|(
name|tempstr2
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|tempstr3
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
name|tempstr3
operator|>
name|tempstr2
operator|)
operator|&&
operator|(
name|isspace
argument_list|(
operator|*
name|tempstr3
argument_list|)
operator|)
condition|)
block|{
operator|*
name|tempstr3
operator|=
literal|'\0'
expr_stmt|;
name|tempstr3
operator|--
expr_stmt|;
block|}
comment|/* 		 * Go through the match table comparing the user's 		 * arguments to known device types, interfaces, etc.   		 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|match_table
index|[
name|j
index|]
operator|.
name|match_str
operator|!=
name|NULL
condition|;
name|j
operator|++
control|)
block|{
comment|/* 			 * We do case-insensitive matching, in case someone 			 * wants to enter "SCSI" instead of "scsi" or 			 * something like that.  Only compare as many  			 * characters as are in the string in the match  			 * table.  This should help if someone tries to use  			 * a super-long match expression.   			 */
if|if
condition|(
name|strncasecmp
argument_list|(
name|tempstr2
argument_list|,
name|match_table
index|[
name|j
index|]
operator|.
name|match_str
argument_list|,
name|strlen
argument_list|(
name|match_table
index|[
name|j
index|]
operator|.
name|match_str
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Make sure the user hasn't specified two 				 * items of the same type, like "da" and 				 * "cd".  One device cannot be both. 				 */
if|if
condition|(
operator|(
operator|(
operator|*
name|matches
operator|)
index|[
operator|*
name|num_matches
index|]
operator|.
name|match_fields
operator|&
name|match_table
index|[
name|j
index|]
operator|.
name|match_field
operator|)
operator|!=
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|devstat_errbuf
argument_list|,
literal|"%s: cannot have more than "
literal|"one match item in a single "
literal|"category"
argument_list|,
name|func_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 				 * If we've gotten this far, we have a 				 * winner.  Set the appropriate fields in 				 * the match entry. 				 */
operator|(
operator|*
name|matches
operator|)
index|[
operator|*
name|num_matches
index|]
operator|.
name|match_fields
operator||=
name|match_table
index|[
name|j
index|]
operator|.
name|match_field
expr_stmt|;
operator|(
operator|*
name|matches
operator|)
index|[
operator|*
name|num_matches
index|]
operator|.
name|device_type
operator||=
name|match_table
index|[
name|j
index|]
operator|.
name|type
expr_stmt|;
operator|(
operator|*
name|matches
operator|)
index|[
operator|*
name|num_matches
index|]
operator|.
name|num_match_categories
operator|++
expr_stmt|;
break|break;
block|}
block|}
comment|/* 		 * We should have found a match in the above for loop.  If 		 * not, that means the user entered an invalid device type 		 * or interface. 		 */
if|if
condition|(
operator|(
operator|*
name|matches
operator|)
index|[
operator|*
name|num_matches
index|]
operator|.
name|num_match_categories
operator|!=
operator|(
name|i
operator|+
literal|1
operator|)
condition|)
block|{
name|snprintf
argument_list|(
name|devstat_errbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|devstat_errbuf
argument_list|)
argument_list|,
literal|"%s: unknown match item \"%s\""
argument_list|,
name|func_name
argument_list|,
name|tstr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
operator|(
operator|*
name|num_matches
operator|)
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compute a number of device statistics.  Only one field is mandatory, and  * that is "current".  Everything else is optional.  The caller passes in  * pointers to variables to hold the various statistics he desires.  If he  * doesn't want a particular staistic, he should pass in a NULL pointer.  * Return values:  * 0   -- success  * -1  -- failure  */
end_comment

begin_function
name|int
name|compute_stats
parameter_list|(
name|struct
name|devstat
modifier|*
name|current
parameter_list|,
name|struct
name|devstat
modifier|*
name|previous
parameter_list|,
name|long
name|double
name|etime
parameter_list|,
name|u_int64_t
modifier|*
name|total_bytes
parameter_list|,
name|u_int64_t
modifier|*
name|total_transfers
parameter_list|,
name|u_int64_t
modifier|*
name|total_blocks
parameter_list|,
name|long
name|double
modifier|*
name|kb_per_transfer
parameter_list|,
name|long
name|double
modifier|*
name|transfers_per_second
parameter_list|,
name|long
name|double
modifier|*
name|mb_per_second
parameter_list|,
name|long
name|double
modifier|*
name|blocks_per_second
parameter_list|,
name|long
name|double
modifier|*
name|ms_per_transaction
parameter_list|)
block|{
name|u_int64_t
name|totalbytes
decl_stmt|,
name|totaltransfers
decl_stmt|,
name|totalblocks
decl_stmt|;
name|char
modifier|*
name|func_name
init|=
literal|"compute_stats"
decl_stmt|;
comment|/* 	 * current is the only mandatory field. 	 */
if|if
condition|(
name|current
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|devstat_errbuf
argument_list|,
literal|"%s: current stats structure was NULL"
argument_list|,
name|func_name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|totalbytes
operator|=
operator|(
name|current
operator|->
name|bytes_written
operator|+
name|current
operator|->
name|bytes_read
operator|)
operator|-
operator|(
operator|(
name|previous
operator|)
condition|?
operator|(
name|previous
operator|->
name|bytes_written
operator|+
name|previous
operator|->
name|bytes_read
operator|)
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|total_bytes
condition|)
operator|*
name|total_bytes
operator|=
name|totalbytes
expr_stmt|;
name|totaltransfers
operator|=
operator|(
name|current
operator|->
name|num_reads
operator|+
name|current
operator|->
name|num_writes
operator|+
name|current
operator|->
name|num_other
operator|)
operator|-
operator|(
operator|(
name|previous
operator|)
condition|?
operator|(
name|previous
operator|->
name|num_reads
operator|+
name|previous
operator|->
name|num_writes
operator|+
name|previous
operator|->
name|num_other
operator|)
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|total_transfers
condition|)
operator|*
name|total_transfers
operator|=
name|totaltransfers
expr_stmt|;
if|if
condition|(
name|transfers_per_second
condition|)
block|{
if|if
condition|(
name|etime
operator|>
literal|0.0
condition|)
block|{
operator|*
name|transfers_per_second
operator|=
name|totaltransfers
expr_stmt|;
operator|*
name|transfers_per_second
operator|/=
name|etime
expr_stmt|;
block|}
else|else
operator|*
name|transfers_per_second
operator|=
literal|0.0
expr_stmt|;
block|}
if|if
condition|(
name|kb_per_transfer
condition|)
block|{
operator|*
name|kb_per_transfer
operator|=
name|totalbytes
expr_stmt|;
operator|*
name|kb_per_transfer
operator|/=
literal|1024
expr_stmt|;
if|if
condition|(
name|totaltransfers
operator|>
literal|0
condition|)
operator|*
name|kb_per_transfer
operator|/=
name|totaltransfers
expr_stmt|;
else|else
operator|*
name|kb_per_transfer
operator|=
literal|0.0
expr_stmt|;
block|}
if|if
condition|(
name|mb_per_second
condition|)
block|{
operator|*
name|mb_per_second
operator|=
name|totalbytes
expr_stmt|;
operator|*
name|mb_per_second
operator|/=
literal|1024
operator|*
literal|1024
expr_stmt|;
if|if
condition|(
name|etime
operator|>
literal|0.0
condition|)
operator|*
name|mb_per_second
operator|/=
name|etime
expr_stmt|;
else|else
operator|*
name|mb_per_second
operator|=
literal|0.0
expr_stmt|;
block|}
name|totalblocks
operator|=
name|totalbytes
expr_stmt|;
if|if
condition|(
name|current
operator|->
name|block_size
operator|>
literal|0
condition|)
name|totalblocks
operator|/=
name|current
operator|->
name|block_size
expr_stmt|;
else|else
name|totalblocks
operator|/=
literal|512
expr_stmt|;
if|if
condition|(
name|total_blocks
condition|)
operator|*
name|total_blocks
operator|=
name|totalblocks
expr_stmt|;
if|if
condition|(
name|blocks_per_second
condition|)
block|{
operator|*
name|blocks_per_second
operator|=
name|totalblocks
expr_stmt|;
if|if
condition|(
name|etime
operator|>
literal|0.0
condition|)
operator|*
name|blocks_per_second
operator|/=
name|etime
expr_stmt|;
else|else
operator|*
name|blocks_per_second
operator|=
literal|0.0
expr_stmt|;
block|}
if|if
condition|(
name|ms_per_transaction
condition|)
block|{
if|if
condition|(
name|totaltransfers
operator|>
literal|0
condition|)
block|{
operator|*
name|ms_per_transaction
operator|=
name|etime
expr_stmt|;
operator|*
name|ms_per_transaction
operator|/=
name|totaltransfers
expr_stmt|;
operator|*
name|ms_per_transaction
operator|*=
literal|1000
expr_stmt|;
block|}
else|else
operator|*
name|ms_per_transaction
operator|=
literal|0.0
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|long
name|double
name|compute_etime
parameter_list|(
name|struct
name|timeval
name|cur_time
parameter_list|,
name|struct
name|timeval
name|prev_time
parameter_list|)
block|{
name|struct
name|timeval
name|busy_time
decl_stmt|;
name|u_int64_t
name|busy_usec
decl_stmt|;
name|long
name|double
name|etime
decl_stmt|;
name|timersub
argument_list|(
operator|&
name|cur_time
argument_list|,
operator|&
name|prev_time
argument_list|,
operator|&
name|busy_time
argument_list|)
expr_stmt|;
name|busy_usec
operator|=
name|busy_time
operator|.
name|tv_sec
expr_stmt|;
name|busy_usec
operator|*=
literal|1000000
expr_stmt|;
name|busy_usec
operator|+=
name|busy_time
operator|.
name|tv_usec
expr_stmt|;
name|etime
operator|=
name|busy_usec
expr_stmt|;
name|etime
operator|/=
literal|1000000
expr_stmt|;
return|return
operator|(
name|etime
operator|)
return|;
block|}
end_function

end_unit

