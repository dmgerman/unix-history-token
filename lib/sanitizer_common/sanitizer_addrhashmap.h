begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- sanitizer_addrhashmap.h ---------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Concurrent uptr->T hashmap.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SANITIZER_ADDRHASHMAP_H
end_ifndef

begin_define
define|#
directive|define
name|SANITIZER_ADDRHASHMAP_H
end_define

begin_include
include|#
directive|include
file|"sanitizer_common.h"
end_include

begin_include
include|#
directive|include
file|"sanitizer_mutex.h"
end_include

begin_include
include|#
directive|include
file|"sanitizer_atomic.h"
end_include

begin_include
include|#
directive|include
file|"sanitizer_allocator_internal.h"
end_include

begin_decl_stmt
name|namespace
name|__sanitizer
block|{
comment|// Concurrent uptr->T hashmap.
comment|// T must be a POD type, kSize is preferably a prime but can be any number.
comment|// Usage example:
comment|//
comment|// typedef AddrHashMap<uptr, 11> Map;
comment|// Map m;
comment|// {
comment|//   Map::Handle h(&m, addr);
comment|//   use h.operator->() to access the data
comment|//   if h.created() then the element was just created, and the current thread
comment|//     has exclusive access to it
comment|//   otherwise the current thread has only read access to the data
comment|// }
comment|// {
comment|//   Map::Handle h(&m, addr, true);
comment|//   this will remove the data from the map in Handle dtor
comment|//   the current thread has exclusive access to the data
comment|//   if !h.exists() then the element never existed
comment|// }
name|template
operator|<
name|typename
name|T
operator|,
name|uptr
name|kSize
operator|>
name|class
name|AddrHashMap
block|{
name|private
operator|:
expr|struct
name|Cell
block|{
name|atomic_uintptr_t
name|addr
block|;
name|T
name|val
block|;   }
block|;    struct
name|AddBucket
block|{
name|uptr
name|cap
block|;
name|uptr
name|size
block|;
name|Cell
name|cells
index|[
literal|1
index|]
block|;
comment|// variable len
block|}
block|;
specifier|static
specifier|const
name|uptr
name|kBucketSize
operator|=
literal|3
block|;    struct
name|Bucket
block|{
name|RWMutex
name|mtx
block|;
name|atomic_uintptr_t
name|add
block|;
name|Cell
name|cells
index|[
name|kBucketSize
index|]
block|;   }
block|;
name|public
operator|:
name|AddrHashMap
argument_list|()
block|;
name|class
name|Handle
block|{
name|public
operator|:
name|Handle
argument_list|(
argument|AddrHashMap<T
argument_list|,
argument|kSize> *map
argument_list|,
argument|uptr addr
argument_list|)
block|;
name|Handle
argument_list|(
argument|AddrHashMap<T
argument_list|,
argument|kSize> *map
argument_list|,
argument|uptr addr
argument_list|,
argument|bool remove
argument_list|)
block|;
name|Handle
argument_list|(
argument|AddrHashMap<T
argument_list|,
argument|kSize> *map
argument_list|,
argument|uptr addr
argument_list|,
argument|bool remove
argument_list|,
argument|bool create
argument_list|)
block|;
operator|~
name|Handle
argument_list|()
block|;
name|T
operator|*
name|operator
operator|->
expr|(
block|)
block|;
name|bool
name|created
argument_list|()
specifier|const
block|;
name|bool
name|exists
argument_list|()
specifier|const
block|;
name|private
operator|:
name|friend
name|AddrHashMap
operator|<
name|T
block|,
name|kSize
operator|>
block|;
name|AddrHashMap
operator|<
name|T
block|,
name|kSize
operator|>
operator|*
name|map_
block|;
name|Bucket
operator|*
name|bucket_
block|;
name|Cell
operator|*
name|cell_
block|;
name|uptr
name|addr_
block|;
name|uptr
name|addidx_
block|;
name|bool
name|created_
block|;
name|bool
name|remove_
block|;
name|bool
name|create_
block|;   }
expr_stmt|;
name|private
label|:
name|friend
name|class
name|Handle
decl_stmt|;
name|Bucket
modifier|*
name|table_
decl_stmt|;
name|void
name|acquire
parameter_list|(
name|Handle
modifier|*
name|h
parameter_list|)
function_decl|;
name|void
name|release
parameter_list|(
name|Handle
modifier|*
name|h
parameter_list|)
function_decl|;
name|uptr
name|calcHash
parameter_list|(
name|uptr
name|addr
parameter_list|)
function_decl|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|,
name|uptr
name|kSize
operator|>
name|AddrHashMap
operator|<
name|T
operator|,
name|kSize
operator|>
operator|::
name|Handle
operator|::
name|Handle
argument_list|(
argument|AddrHashMap<T
argument_list|,
argument|kSize> *map
argument_list|,
argument|uptr addr
argument_list|)
block|{
name|map_
operator|=
name|map
block|;
name|addr_
operator|=
name|addr
block|;
name|remove_
operator|=
name|false
block|;
name|create_
operator|=
name|true
block|;
name|map_
operator|->
name|acquire
argument_list|(
name|this
argument_list|)
block|; }
name|template
operator|<
name|typename
name|T
operator|,
name|uptr
name|kSize
operator|>
name|AddrHashMap
operator|<
name|T
operator|,
name|kSize
operator|>
operator|::
name|Handle
operator|::
name|Handle
argument_list|(
argument|AddrHashMap<T
argument_list|,
argument|kSize> *map
argument_list|,
argument|uptr addr
argument_list|,
argument|bool remove
argument_list|)
block|{
name|map_
operator|=
name|map
block|;
name|addr_
operator|=
name|addr
block|;
name|remove_
operator|=
name|remove
block|;
name|create_
operator|=
name|true
block|;
name|map_
operator|->
name|acquire
argument_list|(
name|this
argument_list|)
block|; }
name|template
operator|<
name|typename
name|T
operator|,
name|uptr
name|kSize
operator|>
name|AddrHashMap
operator|<
name|T
operator|,
name|kSize
operator|>
operator|::
name|Handle
operator|::
name|Handle
argument_list|(
argument|AddrHashMap<T
argument_list|,
argument|kSize> *map
argument_list|,
argument|uptr addr
argument_list|,
argument|bool remove
argument_list|,
argument|bool create
argument_list|)
block|{
name|map_
operator|=
name|map
block|;
name|addr_
operator|=
name|addr
block|;
name|remove_
operator|=
name|remove
block|;
name|create_
operator|=
name|create
block|;
name|map_
operator|->
name|acquire
argument_list|(
name|this
argument_list|)
block|; }
name|template
operator|<
name|typename
name|T
operator|,
name|uptr
name|kSize
operator|>
name|AddrHashMap
operator|<
name|T
operator|,
name|kSize
operator|>
operator|::
name|Handle
operator|::
operator|~
name|Handle
argument_list|()
block|{
name|map_
operator|->
name|release
argument_list|(
name|this
argument_list|)
block|; }
name|template
operator|<
name|typename
name|T
operator|,
name|uptr
name|kSize
operator|>
name|T
operator|*
name|AddrHashMap
operator|<
name|T
operator|,
name|kSize
operator|>
operator|::
name|Handle
operator|::
name|operator
operator|->
expr|(
end_expr_stmt

begin_block
unit|)
block|{
return|return
operator|&
name|cell_
operator|->
name|val
return|;
block|}
end_block

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|,
name|uptr
name|kSize
operator|>
name|bool
name|AddrHashMap
operator|<
name|T
operator|,
name|kSize
operator|>
operator|::
name|Handle
operator|::
name|created
argument_list|()
specifier|const
block|{
return|return
name|created_
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|,
name|uptr
name|kSize
operator|>
name|bool
name|AddrHashMap
operator|<
name|T
operator|,
name|kSize
operator|>
operator|::
name|Handle
operator|::
name|exists
argument_list|()
specifier|const
block|{
return|return
name|cell_
operator|!=
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|,
name|uptr
name|kSize
operator|>
name|AddrHashMap
operator|<
name|T
operator|,
name|kSize
operator|>
operator|::
name|AddrHashMap
argument_list|()
block|{
name|table_
operator|=
operator|(
name|Bucket
operator|*
operator|)
name|MmapOrDie
argument_list|(
name|kSize
operator|*
sizeof|sizeof
argument_list|(
name|table_
index|[
literal|0
index|]
argument_list|)
argument_list|,
literal|"AddrHashMap"
argument_list|)
block|; }
name|template
operator|<
name|typename
name|T
operator|,
name|uptr
name|kSize
operator|>
name|void
name|AddrHashMap
operator|<
name|T
operator|,
name|kSize
operator|>
operator|::
name|acquire
argument_list|(
argument|Handle *h
argument_list|)
block|{
name|uptr
name|addr
operator|=
name|h
operator|->
name|addr_
block|;
name|uptr
name|hash
operator|=
name|calcHash
argument_list|(
name|addr
argument_list|)
block|;
name|Bucket
operator|*
name|b
operator|=
operator|&
name|table_
index|[
name|hash
index|]
block|;
name|h
operator|->
name|created_
operator|=
name|false
block|;
name|h
operator|->
name|addidx_
operator|=
operator|-
literal|1U
block|;
name|h
operator|->
name|bucket_
operator|=
name|b
block|;
name|h
operator|->
name|cell_
operator|=
literal|0
block|;
comment|// If we want to remove the element, we need exclusive access to the bucket,
comment|// so skip the lock-free phase.
if|if
condition|(
name|h
operator|->
name|remove_
condition|)
goto|goto
name|locked
goto|;
name|retry
operator|:
comment|// First try to find an existing element w/o read mutex.
name|CHECK
argument_list|(
operator|!
name|h
operator|->
name|remove_
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Check the embed cells.
end_comment

begin_for
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|kBucketSize
condition|;
name|i
operator|++
control|)
block|{
name|Cell
modifier|*
name|c
init|=
operator|&
name|b
operator|->
name|cells
index|[
name|i
index|]
decl_stmt|;
name|uptr
name|addr1
init|=
name|atomic_load
argument_list|(
operator|&
name|c
operator|->
name|addr
argument_list|,
name|memory_order_acquire
argument_list|)
decl_stmt|;
if|if
condition|(
name|addr1
operator|==
name|addr
condition|)
block|{
name|h
operator|->
name|cell_
operator|=
name|c
expr_stmt|;
return|return;
block|}
block|}
end_for

begin_comment
comment|// Check the add cells with read lock.
end_comment

begin_if
if|if
condition|(
name|atomic_load
argument_list|(
operator|&
name|b
operator|->
name|add
argument_list|,
name|memory_order_relaxed
argument_list|)
condition|)
block|{
name|b
operator|->
name|mtx
operator|.
name|ReadLock
argument_list|()
expr_stmt|;
name|AddBucket
modifier|*
name|add
init|=
operator|(
name|AddBucket
operator|*
operator|)
name|atomic_load
argument_list|(
operator|&
name|b
operator|->
name|add
argument_list|,
name|memory_order_relaxed
argument_list|)
decl_stmt|;
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|add
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|Cell
modifier|*
name|c
init|=
operator|&
name|add
operator|->
name|cells
index|[
name|i
index|]
decl_stmt|;
name|uptr
name|addr1
init|=
name|atomic_load
argument_list|(
operator|&
name|c
operator|->
name|addr
argument_list|,
name|memory_order_relaxed
argument_list|)
decl_stmt|;
if|if
condition|(
name|addr1
operator|==
name|addr
condition|)
block|{
name|h
operator|->
name|addidx_
operator|=
name|i
expr_stmt|;
name|h
operator|->
name|cell_
operator|=
name|c
expr_stmt|;
return|return;
block|}
block|}
name|b
operator|->
name|mtx
operator|.
name|ReadUnlock
argument_list|()
expr_stmt|;
block|}
end_if

begin_label
name|locked
label|:
end_label

begin_comment
comment|// Re-check existence under write lock.
end_comment

begin_comment
comment|// Embed cells.
end_comment

begin_expr_stmt
name|b
operator|->
name|mtx
operator|.
name|Lock
argument_list|()
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|kBucketSize
condition|;
name|i
operator|++
control|)
block|{
name|Cell
modifier|*
name|c
init|=
operator|&
name|b
operator|->
name|cells
index|[
name|i
index|]
decl_stmt|;
name|uptr
name|addr1
init|=
name|atomic_load
argument_list|(
operator|&
name|c
operator|->
name|addr
argument_list|,
name|memory_order_relaxed
argument_list|)
decl_stmt|;
if|if
condition|(
name|addr1
operator|==
name|addr
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|remove_
condition|)
block|{
name|h
operator|->
name|cell_
operator|=
name|c
expr_stmt|;
return|return;
block|}
name|b
operator|->
name|mtx
operator|.
name|Unlock
argument_list|()
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
end_for

begin_comment
comment|// Add cells.
end_comment

begin_decl_stmt
name|AddBucket
modifier|*
name|add
init|=
operator|(
name|AddBucket
operator|*
operator|)
name|atomic_load
argument_list|(
operator|&
name|b
operator|->
name|add
argument_list|,
name|memory_order_relaxed
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|add
condition|)
block|{
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|add
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|Cell
modifier|*
name|c
init|=
operator|&
name|add
operator|->
name|cells
index|[
name|i
index|]
decl_stmt|;
name|uptr
name|addr1
init|=
name|atomic_load
argument_list|(
operator|&
name|c
operator|->
name|addr
argument_list|,
name|memory_order_relaxed
argument_list|)
decl_stmt|;
if|if
condition|(
name|addr1
operator|==
name|addr
condition|)
block|{
if|if
condition|(
name|h
operator|->
name|remove_
condition|)
block|{
name|h
operator|->
name|addidx_
operator|=
name|i
expr_stmt|;
name|h
operator|->
name|cell_
operator|=
name|c
expr_stmt|;
return|return;
block|}
name|b
operator|->
name|mtx
operator|.
name|Unlock
argument_list|()
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
block|}
end_if

begin_comment
comment|// The element does not exist, no need to create it if we want to remove.
end_comment

begin_if
if|if
condition|(
name|h
operator|->
name|remove_
operator|||
operator|!
name|h
operator|->
name|create_
condition|)
block|{
name|b
operator|->
name|mtx
operator|.
name|Unlock
argument_list|()
expr_stmt|;
return|return;
block|}
end_if

begin_comment
comment|// Now try to create it under the mutex.
end_comment

begin_expr_stmt
name|h
operator|->
name|created_
operator|=
name|true
expr_stmt|;
end_expr_stmt

begin_comment
comment|// See if we have a free embed cell.
end_comment

begin_for
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|kBucketSize
condition|;
name|i
operator|++
control|)
block|{
name|Cell
modifier|*
name|c
init|=
operator|&
name|b
operator|->
name|cells
index|[
name|i
index|]
decl_stmt|;
name|uptr
name|addr1
init|=
name|atomic_load
argument_list|(
operator|&
name|c
operator|->
name|addr
argument_list|,
name|memory_order_relaxed
argument_list|)
decl_stmt|;
if|if
condition|(
name|addr1
operator|==
literal|0
condition|)
block|{
name|h
operator|->
name|cell_
operator|=
name|c
expr_stmt|;
return|return;
block|}
block|}
end_for

begin_comment
comment|// Store in the add cells.
end_comment

begin_if
if|if
condition|(
name|add
operator|==
literal|0
condition|)
block|{
comment|// Allocate a new add array.
specifier|const
name|uptr
name|kInitSize
init|=
literal|64
decl_stmt|;
name|add
operator|=
operator|(
name|AddBucket
operator|*
operator|)
name|InternalAlloc
argument_list|(
name|kInitSize
argument_list|)
expr_stmt|;
name|internal_memset
argument_list|(
name|add
argument_list|,
literal|0
argument_list|,
name|kInitSize
argument_list|)
expr_stmt|;
name|add
operator|->
name|cap
operator|=
operator|(
name|kInitSize
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|add
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|add
operator|->
name|cells
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
name|add
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|atomic_store
argument_list|(
operator|&
name|b
operator|->
name|add
argument_list|,
operator|(
name|uptr
operator|)
name|add
argument_list|,
name|memory_order_relaxed
argument_list|)
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|add
operator|->
name|size
operator|==
name|add
operator|->
name|cap
condition|)
block|{
comment|// Grow existing add array.
name|uptr
name|oldsize
init|=
sizeof|sizeof
argument_list|(
operator|*
name|add
argument_list|)
operator|+
operator|(
name|add
operator|->
name|cap
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|add
operator|->
name|cells
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|uptr
name|newsize
init|=
name|oldsize
operator|*
literal|2
decl_stmt|;
name|AddBucket
modifier|*
name|add1
init|=
operator|(
name|AddBucket
operator|*
operator|)
name|InternalAlloc
argument_list|(
name|newsize
argument_list|)
decl_stmt|;
name|internal_memset
argument_list|(
name|add1
argument_list|,
literal|0
argument_list|,
name|newsize
argument_list|)
expr_stmt|;
name|add1
operator|->
name|cap
operator|=
operator|(
name|newsize
operator|-
sizeof|sizeof
argument_list|(
operator|*
name|add
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|add
operator|->
name|cells
index|[
literal|0
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
name|add1
operator|->
name|size
operator|=
name|add
operator|->
name|size
expr_stmt|;
name|internal_memcpy
argument_list|(
name|add1
operator|->
name|cells
argument_list|,
name|add
operator|->
name|cells
argument_list|,
name|add
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
name|add
operator|->
name|cells
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|InternalFree
argument_list|(
name|add
argument_list|)
expr_stmt|;
name|atomic_store
argument_list|(
operator|&
name|b
operator|->
name|add
argument_list|,
operator|(
name|uptr
operator|)
name|add1
argument_list|,
name|memory_order_relaxed
argument_list|)
expr_stmt|;
name|add
operator|=
name|add1
expr_stmt|;
block|}
end_if

begin_comment
comment|// Store.
end_comment

begin_decl_stmt
name|uptr
name|i
init|=
name|add
operator|->
name|size
operator|++
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Cell
modifier|*
name|c
init|=
operator|&
name|add
operator|->
name|cells
index|[
name|i
index|]
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|CHECK_EQ
argument_list|(
name|atomic_load
argument_list|(
operator|&
name|c
operator|->
name|addr
argument_list|,
name|memory_order_relaxed
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|h
operator|->
name|addidx_
operator|=
name|i
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|h
operator|->
name|cell_
operator|=
name|c
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|T
operator|,
name|uptr
name|kSize
operator|>
name|void
name|AddrHashMap
operator|<
name|T
operator|,
name|kSize
operator|>
operator|::
name|release
argument_list|(
argument|Handle *h
argument_list|)
block|{
if|if
condition|(
name|h
operator|->
name|cell_
operator|==
literal|0
condition|)
return|return;
name|Bucket
operator|*
name|b
operator|=
name|h
operator|->
name|bucket_
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|Cell
modifier|*
name|c
init|=
name|h
operator|->
name|cell_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uptr
name|addr1
init|=
name|atomic_load
argument_list|(
operator|&
name|c
operator|->
name|addr
argument_list|,
name|memory_order_relaxed
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
name|h
operator|->
name|created_
condition|)
block|{
comment|// Denote completion of insertion.
name|CHECK_EQ
argument_list|(
name|addr1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|// After the following store, the element becomes available
comment|// for lock-free reads.
name|atomic_store
argument_list|(
operator|&
name|c
operator|->
name|addr
argument_list|,
name|h
operator|->
name|addr_
argument_list|,
name|memory_order_release
argument_list|)
expr_stmt|;
name|b
operator|->
name|mtx
operator|.
name|Unlock
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|h
operator|->
name|remove_
condition|)
block|{
comment|// Denote that the cell is empty now.
name|CHECK_EQ
argument_list|(
name|addr1
argument_list|,
name|h
operator|->
name|addr_
argument_list|)
expr_stmt|;
name|atomic_store
argument_list|(
operator|&
name|c
operator|->
name|addr
argument_list|,
literal|0
argument_list|,
name|memory_order_release
argument_list|)
expr_stmt|;
comment|// See if we need to compact the bucket.
name|AddBucket
modifier|*
name|add
init|=
operator|(
name|AddBucket
operator|*
operator|)
name|atomic_load
argument_list|(
operator|&
name|b
operator|->
name|add
argument_list|,
name|memory_order_relaxed
argument_list|)
decl_stmt|;
if|if
condition|(
name|h
operator|->
name|addidx_
operator|==
operator|-
literal|1U
condition|)
block|{
comment|// Removed from embed array, move an add element into the freed cell.
if|if
condition|(
name|add
operator|&&
name|add
operator|->
name|size
operator|!=
literal|0
condition|)
block|{
name|uptr
name|last
init|=
operator|--
name|add
operator|->
name|size
decl_stmt|;
name|Cell
modifier|*
name|c1
init|=
operator|&
name|add
operator|->
name|cells
index|[
name|last
index|]
decl_stmt|;
name|c
operator|->
name|val
operator|=
name|c1
operator|->
name|val
expr_stmt|;
name|uptr
name|addr1
init|=
name|atomic_load
argument_list|(
operator|&
name|c1
operator|->
name|addr
argument_list|,
name|memory_order_relaxed
argument_list|)
decl_stmt|;
name|atomic_store
argument_list|(
operator|&
name|c
operator|->
name|addr
argument_list|,
name|addr1
argument_list|,
name|memory_order_release
argument_list|)
expr_stmt|;
name|atomic_store
argument_list|(
operator|&
name|c1
operator|->
name|addr
argument_list|,
literal|0
argument_list|,
name|memory_order_release
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|// Removed from add array, compact it.
name|uptr
name|last
init|=
operator|--
name|add
operator|->
name|size
decl_stmt|;
name|Cell
modifier|*
name|c1
init|=
operator|&
name|add
operator|->
name|cells
index|[
name|last
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|!=
name|c1
condition|)
block|{
operator|*
name|c
operator|=
operator|*
name|c1
expr_stmt|;
name|atomic_store
argument_list|(
operator|&
name|c1
operator|->
name|addr
argument_list|,
literal|0
argument_list|,
name|memory_order_relaxed
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|add
operator|&&
name|add
operator|->
name|size
operator|==
literal|0
condition|)
block|{
comment|// FIXME(dvyukov): free add?
block|}
name|b
operator|->
name|mtx
operator|.
name|Unlock
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|CHECK_EQ
argument_list|(
name|addr1
argument_list|,
name|h
operator|->
name|addr_
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|addidx_
operator|!=
operator|-
literal|1U
condition|)
name|b
operator|->
name|mtx
operator|.
name|ReadUnlock
argument_list|()
expr_stmt|;
block|}
end_if

begin_expr_stmt
unit|}  template
operator|<
name|typename
name|T
operator|,
name|uptr
name|kSize
operator|>
name|uptr
name|AddrHashMap
operator|<
name|T
operator|,
name|kSize
operator|>
operator|::
name|calcHash
argument_list|(
argument|uptr addr
argument_list|)
block|{
name|addr
operator|+=
name|addr
operator|<<
literal|10
block|;
name|addr
operator|^=
name|addr
operator|>>
literal|6
block|;
return|return
name|addr
operator|%
name|kSize
return|;
block|}
end_expr_stmt

begin_comment
unit|}
comment|// namespace __sanitizer
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// SANITIZER_ADDRHASHMAP_H
end_comment

end_unit

