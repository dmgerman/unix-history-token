begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- sanitizer_quarantine.h ----------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Memory quarantine for AddressSanitizer and potentially other tools.
end_comment

begin_comment
comment|// Quarantine caches some specified amount of memory in per-thread caches,
end_comment

begin_comment
comment|// then evicts to global FIFO queue. When the queue reaches specified threshold,
end_comment

begin_comment
comment|// oldest memory is recycled.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SANITIZER_QUARANTINE_H
end_ifndef

begin_define
define|#
directive|define
name|SANITIZER_QUARANTINE_H
end_define

begin_include
include|#
directive|include
file|"sanitizer_internal_defs.h"
end_include

begin_include
include|#
directive|include
file|"sanitizer_mutex.h"
end_include

begin_include
include|#
directive|include
file|"sanitizer_list.h"
end_include

begin_decl_stmt
name|namespace
name|__sanitizer
block|{
name|template
operator|<
name|typename
name|Node
operator|>
name|class
name|QuarantineCache
expr_stmt|;
struct|struct
name|QuarantineBatch
block|{
specifier|static
specifier|const
name|uptr
name|kSize
init|=
literal|1021
decl_stmt|;
name|QuarantineBatch
modifier|*
name|next
decl_stmt|;
name|uptr
name|size
decl_stmt|;
name|uptr
name|count
decl_stmt|;
name|void
modifier|*
name|batch
index|[
name|kSize
index|]
decl_stmt|;
name|void
name|init
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|uptr
name|size
parameter_list|)
block|{
name|count
operator|=
literal|1
expr_stmt|;
name|batch
index|[
literal|0
index|]
operator|=
name|ptr
expr_stmt|;
name|this
operator|->
name|size
operator|=
name|size
operator|+
sizeof|sizeof
argument_list|(
name|QuarantineBatch
argument_list|)
expr_stmt|;
comment|// Account for the batch size.
block|}
comment|// The total size of quarantined nodes recorded in this batch.
name|uptr
name|quarantined_size
argument_list|()
specifier|const
block|{
return|return
name|size
operator|-
sizeof|sizeof
argument_list|(
name|QuarantineBatch
argument_list|)
return|;
block|}
name|void
name|push_back
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|uptr
name|size
parameter_list|)
block|{
name|CHECK_LT
argument_list|(
name|count
argument_list|,
name|kSize
argument_list|)
expr_stmt|;
name|batch
index|[
name|count
operator|++
index|]
operator|=
name|ptr
expr_stmt|;
name|this
operator|->
name|size
operator|+=
name|size
expr_stmt|;
block|}
name|bool
name|can_merge
argument_list|(
specifier|const
name|QuarantineBatch
operator|*
specifier|const
name|from
argument_list|)
decl|const
block|{
return|return
name|count
operator|+
name|from
operator|->
name|count
operator|<=
name|kSize
return|;
block|}
name|void
name|merge
parameter_list|(
name|QuarantineBatch
modifier|*
specifier|const
name|from
parameter_list|)
block|{
name|CHECK_LE
argument_list|(
name|count
operator|+
name|from
operator|->
name|count
argument_list|,
name|kSize
argument_list|)
expr_stmt|;
name|CHECK_GE
argument_list|(
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|QuarantineBatch
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|from
operator|->
name|count
condition|;
operator|++
name|i
control|)
name|batch
index|[
name|count
operator|+
name|i
index|]
operator|=
name|from
operator|->
name|batch
index|[
name|i
index|]
expr_stmt|;
name|count
operator|+=
name|from
operator|->
name|count
expr_stmt|;
name|size
operator|+=
name|from
operator|->
name|quarantined_size
argument_list|()
expr_stmt|;
name|from
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|from
operator|->
name|size
operator|=
sizeof|sizeof
argument_list|(
name|QuarantineBatch
argument_list|)
expr_stmt|;
block|}
block|}
struct|;
name|COMPILER_CHECK
argument_list|(
sizeof|sizeof
argument_list|(
name|QuarantineBatch
argument_list|)
operator|<=
operator|(
literal|1
operator|<<
literal|13
operator|)
argument_list|)
expr_stmt|;
comment|// 8Kb.
comment|// The callback interface is:
comment|// void Callback::Recycle(Node *ptr);
comment|// void *cb.Allocate(uptr size);
comment|// void cb.Deallocate(void *ptr);
name|template
operator|<
name|typename
name|Callback
operator|,
name|typename
name|Node
operator|>
name|class
name|Quarantine
block|{
name|public
operator|:
typedef|typedef
name|QuarantineCache
operator|<
name|Callback
operator|>
name|Cache
expr_stmt|;
name|explicit
name|Quarantine
argument_list|(
name|LinkerInitialized
argument_list|)
operator|:
name|cache_
argument_list|(
argument|LINKER_INITIALIZED
argument_list|)
block|{   }
name|void
name|Init
argument_list|(
argument|uptr size
argument_list|,
argument|uptr cache_size
argument_list|)
block|{
comment|// Thread local quarantine size can be zero only when global quarantine size
comment|// is zero (it allows us to perform just one atomic read per Put() call).
name|CHECK
argument_list|(
operator|(
name|size
operator|==
literal|0
operator|&&
name|cache_size
operator|==
literal|0
operator|)
operator|||
name|cache_size
operator|!=
literal|0
argument_list|)
block|;
name|atomic_store
argument_list|(
operator|&
name|max_size_
argument_list|,
name|size
argument_list|,
name|memory_order_relaxed
argument_list|)
block|;
name|atomic_store
argument_list|(
operator|&
name|min_size_
argument_list|,
name|size
operator|/
literal|10
operator|*
literal|9
argument_list|,
name|memory_order_relaxed
argument_list|)
block|;
comment|// 90% of max size.
name|atomic_store
argument_list|(
operator|&
name|max_cache_size_
argument_list|,
name|cache_size
argument_list|,
name|memory_order_relaxed
argument_list|)
block|;   }
name|uptr
name|GetSize
argument_list|()
specifier|const
block|{
return|return
name|atomic_load
argument_list|(
operator|&
name|max_size_
argument_list|,
name|memory_order_relaxed
argument_list|)
return|;
block|}
name|uptr
name|GetCacheSize
argument_list|()
specifier|const
block|{
return|return
name|atomic_load
argument_list|(
operator|&
name|max_cache_size_
argument_list|,
name|memory_order_relaxed
argument_list|)
return|;
block|}
name|void
name|Put
parameter_list|(
name|Cache
modifier|*
name|c
parameter_list|,
name|Callback
name|cb
parameter_list|,
name|Node
modifier|*
name|ptr
parameter_list|,
name|uptr
name|size
parameter_list|)
block|{
name|uptr
name|cache_size
init|=
name|GetCacheSize
argument_list|()
decl_stmt|;
if|if
condition|(
name|cache_size
condition|)
block|{
name|c
operator|->
name|Enqueue
argument_list|(
name|cb
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|// GetCacheSize() == 0 only when GetSize() == 0 (see Init).
name|cb
operator|.
name|Recycle
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
comment|// Check cache size anyway to accommodate for runtime cache_size change.
if|if
condition|(
name|c
operator|->
name|Size
argument_list|()
operator|>
name|cache_size
condition|)
name|Drain
argument_list|(
name|c
argument_list|,
name|cb
argument_list|)
expr_stmt|;
block|}
name|void
name|NOINLINE
name|Drain
parameter_list|(
name|Cache
modifier|*
name|c
parameter_list|,
name|Callback
name|cb
parameter_list|)
block|{
block|{
name|SpinMutexLock
name|l
argument_list|(
operator|&
name|cache_mutex_
argument_list|)
decl_stmt|;
name|cache_
operator|.
name|Transfer
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cache_
operator|.
name|Size
argument_list|()
operator|>
name|GetSize
argument_list|()
operator|&&
name|recycle_mutex_
operator|.
name|TryLock
argument_list|()
condition|)
name|Recycle
argument_list|(
name|cb
argument_list|)
expr_stmt|;
block|}
name|void
name|PrintStats
argument_list|()
specifier|const
block|{
comment|// It assumes that the world is stopped, just as the allocator's PrintStats.
name|Printf
argument_list|(
literal|"Quarantine limits: global: %zdMb; thread local: %zdKb\n"
argument_list|,
name|GetSize
argument_list|()
operator|>>
literal|20
argument_list|,
name|GetCacheSize
argument_list|()
operator|>>
literal|10
argument_list|)
block|;
name|cache_
operator|.
name|PrintStats
argument_list|()
block|;   }
name|private
operator|:
comment|// Read-only data.
name|char
name|pad0_
index|[
name|kCacheLineSize
index|]
expr_stmt|;
name|atomic_uintptr_t
name|max_size_
decl_stmt|;
name|atomic_uintptr_t
name|min_size_
decl_stmt|;
name|atomic_uintptr_t
name|max_cache_size_
decl_stmt|;
name|char
name|pad1_
index|[
name|kCacheLineSize
index|]
decl_stmt|;
name|SpinMutex
name|cache_mutex_
decl_stmt|;
name|SpinMutex
name|recycle_mutex_
decl_stmt|;
name|Cache
name|cache_
decl_stmt|;
name|char
name|pad2_
index|[
name|kCacheLineSize
index|]
decl_stmt|;
name|void
name|NOINLINE
name|Recycle
parameter_list|(
name|Callback
name|cb
parameter_list|)
block|{
name|Cache
name|tmp
decl_stmt|;
name|uptr
name|min_size
init|=
name|atomic_load
argument_list|(
operator|&
name|min_size_
argument_list|,
name|memory_order_relaxed
argument_list|)
decl_stmt|;
block|{
name|SpinMutexLock
name|l
argument_list|(
operator|&
name|cache_mutex_
argument_list|)
decl_stmt|;
comment|// Go over the batches and merge partially filled ones to
comment|// save some memory, otherwise batches themselves (since the memory used
comment|// by them is counted against quarantine limit) can overcome the actual
comment|// user's quarantined chunks, which diminishes the purpose of the
comment|// quarantine.
name|uptr
name|cache_size
init|=
name|cache_
operator|.
name|Size
argument_list|()
decl_stmt|;
name|uptr
name|overhead_size
init|=
name|cache_
operator|.
name|OverheadSize
argument_list|()
decl_stmt|;
name|CHECK_GE
argument_list|(
name|cache_size
argument_list|,
name|overhead_size
argument_list|)
expr_stmt|;
comment|// Do the merge only when overhead exceeds this predefined limit (might
comment|// require some tuning). It saves us merge attempt when the batch list
comment|// quarantine is unlikely to contain batches suitable for merge.
specifier|const
name|uptr
name|kOverheadThresholdPercents
init|=
literal|100
decl_stmt|;
if|if
condition|(
name|cache_size
operator|>
name|overhead_size
operator|&&
name|overhead_size
operator|*
operator|(
literal|100
operator|+
name|kOverheadThresholdPercents
operator|)
operator|>
name|cache_size
operator|*
name|kOverheadThresholdPercents
condition|)
block|{
name|cache_
operator|.
name|MergeBatches
argument_list|(
operator|&
name|tmp
argument_list|)
expr_stmt|;
block|}
comment|// Extract enough chunks from the quarantine to get below the max
comment|// quarantine size and leave some leeway for the newly quarantined chunks.
while|while
condition|(
name|cache_
operator|.
name|Size
argument_list|()
operator|>
name|min_size
condition|)
block|{
name|tmp
operator|.
name|EnqueueBatch
argument_list|(
name|cache_
operator|.
name|DequeueBatch
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
name|recycle_mutex_
operator|.
name|Unlock
argument_list|()
expr_stmt|;
name|DoRecycle
argument_list|(
operator|&
name|tmp
argument_list|,
name|cb
argument_list|)
expr_stmt|;
block|}
name|void
name|NOINLINE
name|DoRecycle
parameter_list|(
name|Cache
modifier|*
name|c
parameter_list|,
name|Callback
name|cb
parameter_list|)
block|{
while|while
condition|(
name|QuarantineBatch
modifier|*
name|b
init|=
name|c
operator|->
name|DequeueBatch
argument_list|()
condition|)
block|{
specifier|const
name|uptr
name|kPrefetch
init|=
literal|16
decl_stmt|;
name|CHECK
argument_list|(
name|kPrefetch
operator|<=
name|ARRAY_SIZE
argument_list|(
name|b
operator|->
name|batch
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|kPrefetch
condition|;
name|i
operator|++
control|)
name|PREFETCH
argument_list|(
name|b
operator|->
name|batch
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|,
name|count
init|=
name|b
operator|->
name|count
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|+
name|kPrefetch
operator|<
name|count
condition|)
name|PREFETCH
argument_list|(
name|b
operator|->
name|batch
index|[
name|i
operator|+
name|kPrefetch
index|]
argument_list|)
expr_stmt|;
name|cb
operator|.
name|Recycle
argument_list|(
operator|(
name|Node
operator|*
operator|)
name|b
operator|->
name|batch
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|cb
operator|.
name|Deallocate
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// Per-thread cache of memory blocks.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|Callback
operator|>
name|class
name|QuarantineCache
block|{
name|public
operator|:
name|explicit
name|QuarantineCache
argument_list|(
argument|LinkerInitialized
argument_list|)
block|{   }
name|QuarantineCache
argument_list|()
operator|:
name|size_
argument_list|()
block|{
name|list_
operator|.
name|clear
argument_list|()
block|;   }
comment|// Total memory used, including internal accounting.
name|uptr
name|Size
argument_list|()
specifier|const
block|{
return|return
name|atomic_load
argument_list|(
operator|&
name|size_
argument_list|,
name|memory_order_relaxed
argument_list|)
return|;
block|}
comment|// Memory used for internal accounting.
name|uptr
name|OverheadSize
argument_list|()
specifier|const
block|{
return|return
name|list_
operator|.
name|size
argument_list|()
operator|*
sizeof|sizeof
argument_list|(
name|QuarantineBatch
argument_list|)
return|;
block|}
end_expr_stmt

begin_function
name|void
name|Enqueue
parameter_list|(
name|Callback
name|cb
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|uptr
name|size
parameter_list|)
block|{
if|if
condition|(
name|list_
operator|.
name|empty
argument_list|()
operator|||
name|list_
operator|.
name|back
argument_list|()
operator|->
name|count
operator|==
name|QuarantineBatch
operator|::
name|kSize
condition|)
block|{
name|QuarantineBatch
modifier|*
name|b
init|=
operator|(
name|QuarantineBatch
operator|*
operator|)
name|cb
operator|.
name|Allocate
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|b
argument_list|)
argument_list|)
decl_stmt|;
name|CHECK
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|->
name|init
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|EnqueueBatch
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|list_
operator|.
name|back
argument_list|()
operator|->
name|push_back
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|SizeAdd
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|Transfer
parameter_list|(
name|QuarantineCache
modifier|*
name|from_cache
parameter_list|)
block|{
name|list_
operator|.
name|append_back
argument_list|(
operator|&
name|from_cache
operator|->
name|list_
argument_list|)
expr_stmt|;
name|SizeAdd
argument_list|(
name|from_cache
operator|->
name|Size
argument_list|()
argument_list|)
expr_stmt|;
name|atomic_store
argument_list|(
operator|&
name|from_cache
operator|->
name|size_
argument_list|,
literal|0
argument_list|,
name|memory_order_relaxed
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|EnqueueBatch
parameter_list|(
name|QuarantineBatch
modifier|*
name|b
parameter_list|)
block|{
name|list_
operator|.
name|push_back
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|SizeAdd
argument_list|(
name|b
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|QuarantineBatch
modifier|*
name|DequeueBatch
parameter_list|()
block|{
if|if
condition|(
name|list_
operator|.
name|empty
argument_list|()
condition|)
return|return
name|nullptr
return|;
name|QuarantineBatch
modifier|*
name|b
init|=
name|list_
operator|.
name|front
argument_list|()
decl_stmt|;
name|list_
operator|.
name|pop_front
argument_list|()
expr_stmt|;
name|SizeSub
argument_list|(
name|b
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_function
name|void
name|MergeBatches
parameter_list|(
name|QuarantineCache
modifier|*
name|to_deallocate
parameter_list|)
block|{
name|uptr
name|extracted_size
init|=
literal|0
decl_stmt|;
name|QuarantineBatch
modifier|*
name|current
init|=
name|list_
operator|.
name|front
argument_list|()
decl_stmt|;
while|while
condition|(
name|current
operator|&&
name|current
operator|->
name|next
condition|)
block|{
if|if
condition|(
name|current
operator|->
name|can_merge
argument_list|(
name|current
operator|->
name|next
argument_list|)
condition|)
block|{
name|QuarantineBatch
modifier|*
name|extracted
init|=
name|current
operator|->
name|next
decl_stmt|;
comment|// Move all the chunks into the current batch.
name|current
operator|->
name|merge
argument_list|(
name|extracted
argument_list|)
expr_stmt|;
name|CHECK_EQ
argument_list|(
name|extracted
operator|->
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CHECK_EQ
argument_list|(
name|extracted
operator|->
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|QuarantineBatch
argument_list|)
argument_list|)
expr_stmt|;
comment|// Remove the next batch from the list and account for its size.
name|list_
operator|.
name|extract
argument_list|(
name|current
argument_list|,
name|extracted
argument_list|)
expr_stmt|;
name|extracted_size
operator|+=
name|extracted
operator|->
name|size
expr_stmt|;
comment|// Add it to deallocation list.
name|to_deallocate
operator|->
name|EnqueueBatch
argument_list|(
name|extracted
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|current
operator|=
name|current
operator|->
name|next
expr_stmt|;
block|}
block|}
name|SizeSub
argument_list|(
name|extracted_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
name|void
name|PrintStats
argument_list|()
specifier|const
block|{
name|uptr
name|batch_count
operator|=
literal|0
block|;
name|uptr
name|total_overhead_bytes
operator|=
literal|0
block|;
name|uptr
name|total_bytes
operator|=
literal|0
block|;
name|uptr
name|total_quarantine_chunks
operator|=
literal|0
block|;
for|for
control|(
name|List
operator|::
name|ConstIterator
name|it
operator|=
name|list_
operator|.
name|begin
argument_list|()
init|;
name|it
operator|!=
name|list_
operator|.
name|end
argument_list|()
condition|;
operator|++
name|it
control|)
block|{
name|batch_count
operator|++
expr_stmt|;
name|total_bytes
operator|+=
operator|(
operator|*
name|it
operator|)
operator|.
name|size
expr_stmt|;
name|total_overhead_bytes
operator|+=
operator|(
operator|*
name|it
operator|)
operator|.
name|size
operator|-
operator|(
operator|*
name|it
operator|)
operator|.
name|quarantined_size
argument_list|()
expr_stmt|;
name|total_quarantine_chunks
operator|+=
operator|(
operator|*
name|it
operator|)
operator|.
name|count
expr_stmt|;
block|}
name|uptr
name|quarantine_chunks_capacity
operator|=
name|batch_count
operator|*
name|QuarantineBatch
operator|::
name|kSize
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|chunks_usage_percent
init|=
name|quarantine_chunks_capacity
operator|==
literal|0
condition|?
literal|0
else|:
name|total_quarantine_chunks
operator|*
literal|100
operator|/
name|quarantine_chunks_capacity
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uptr
name|total_quarantined_bytes
init|=
name|total_bytes
operator|-
name|total_overhead_bytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|memory_overhead_percent
init|=
name|total_quarantined_bytes
operator|==
literal|0
condition|?
literal|0
else|:
name|total_overhead_bytes
operator|*
literal|100
operator|/
name|total_quarantined_bytes
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|Printf
argument_list|(
literal|"Global quarantine stats: batches: %zd; bytes: %zd (user: %zd); "
literal|"chunks: %zd (capacity: %zd); %d%% chunks used; %d%% memory overhead"
literal|"\n"
argument_list|,
name|batch_count
argument_list|,
name|total_bytes
argument_list|,
name|total_quarantined_bytes
argument_list|,
name|total_quarantine_chunks
argument_list|,
name|quarantine_chunks_capacity
argument_list|,
name|chunks_usage_percent
argument_list|,
name|memory_overhead_percent
argument_list|)
expr_stmt|;
end_expr_stmt

begin_typedef
unit|}   private:
typedef|typedef
name|IntrusiveList
operator|<
name|QuarantineBatch
operator|>
name|List
expr_stmt|;
end_typedef

begin_decl_stmt
name|List
name|list_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|atomic_uintptr_t
name|size_
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|SizeAdd
parameter_list|(
name|uptr
name|add
parameter_list|)
block|{
name|atomic_store
argument_list|(
operator|&
name|size_
argument_list|,
name|Size
argument_list|()
operator|+
name|add
argument_list|,
name|memory_order_relaxed
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|SizeSub
parameter_list|(
name|uptr
name|sub
parameter_list|)
block|{
name|atomic_store
argument_list|(
operator|&
name|size_
argument_list|,
name|Size
argument_list|()
operator|-
name|sub
argument_list|,
name|memory_order_relaxed
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
unit|};  }
comment|// namespace __sanitizer
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// SANITIZER_QUARANTINE_H
end_comment

end_unit

