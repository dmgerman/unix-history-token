begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- sanitizer_allocator64.h ---------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// Specialized allocator which works only in 64-bit address space.
end_comment

begin_comment
comment|// To be used by ThreadSanitizer, MemorySanitizer and possibly other tools.
end_comment

begin_comment
comment|// The main feature of this allocator is that the header is located far away
end_comment

begin_comment
comment|// from the user memory region, so that the tool does not use extra shadow
end_comment

begin_comment
comment|// for the header.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Status: not yet ready.
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SANITIZER_ALLOCATOR_H
end_ifndef

begin_define
define|#
directive|define
name|SANITIZER_ALLOCATOR_H
end_define

begin_include
include|#
directive|include
file|"sanitizer_common.h"
end_include

begin_include
include|#
directive|include
file|"sanitizer_internal_defs.h"
end_include

begin_include
include|#
directive|include
file|"sanitizer_libc.h"
end_include

begin_include
include|#
directive|include
file|"sanitizer_list.h"
end_include

begin_include
include|#
directive|include
file|"sanitizer_mutex.h"
end_include

begin_decl_stmt
name|namespace
name|__sanitizer
block|{
comment|// Maps size class id to size and back.
name|class
name|DefaultSizeClassMap
block|{
name|private
label|:
comment|// Here we use a spline composed of 5 polynomials of oder 1.
comment|// The first size class is l0, then the classes go with step s0
comment|// untill they reach l1, after which they go with step s1 and so on.
comment|// Steps should be powers of two for cheap division.
comment|// The size of the last size class should be a power of two.
comment|// There should be at most 256 size classes.
specifier|static
specifier|const
name|uptr
name|l0
init|=
literal|1
operator|<<
literal|4
decl_stmt|;
specifier|static
specifier|const
name|uptr
name|l1
init|=
literal|1
operator|<<
literal|9
decl_stmt|;
specifier|static
specifier|const
name|uptr
name|l2
init|=
literal|1
operator|<<
literal|12
decl_stmt|;
specifier|static
specifier|const
name|uptr
name|l3
init|=
literal|1
operator|<<
literal|15
decl_stmt|;
specifier|static
specifier|const
name|uptr
name|l4
init|=
literal|1
operator|<<
literal|18
decl_stmt|;
specifier|static
specifier|const
name|uptr
name|l5
init|=
literal|1
operator|<<
literal|21
decl_stmt|;
specifier|static
specifier|const
name|uptr
name|s0
init|=
literal|1
operator|<<
literal|4
decl_stmt|;
specifier|static
specifier|const
name|uptr
name|s1
init|=
literal|1
operator|<<
literal|6
decl_stmt|;
specifier|static
specifier|const
name|uptr
name|s2
init|=
literal|1
operator|<<
literal|9
decl_stmt|;
specifier|static
specifier|const
name|uptr
name|s3
init|=
literal|1
operator|<<
literal|12
decl_stmt|;
specifier|static
specifier|const
name|uptr
name|s4
init|=
literal|1
operator|<<
literal|15
decl_stmt|;
specifier|static
specifier|const
name|uptr
name|u0
init|=
literal|0
operator|+
operator|(
name|l1
operator|-
name|l0
operator|)
operator|/
name|s0
decl_stmt|;
specifier|static
specifier|const
name|uptr
name|u1
init|=
name|u0
operator|+
operator|(
name|l2
operator|-
name|l1
operator|)
operator|/
name|s1
decl_stmt|;
specifier|static
specifier|const
name|uptr
name|u2
init|=
name|u1
operator|+
operator|(
name|l3
operator|-
name|l2
operator|)
operator|/
name|s2
decl_stmt|;
specifier|static
specifier|const
name|uptr
name|u3
init|=
name|u2
operator|+
operator|(
name|l4
operator|-
name|l3
operator|)
operator|/
name|s3
decl_stmt|;
specifier|static
specifier|const
name|uptr
name|u4
init|=
name|u3
operator|+
operator|(
name|l5
operator|-
name|l4
operator|)
operator|/
name|s4
decl_stmt|;
name|public
label|:
specifier|static
specifier|const
name|uptr
name|kNumClasses
init|=
name|u4
operator|+
literal|1
decl_stmt|;
specifier|static
specifier|const
name|uptr
name|kMaxSize
init|=
name|l5
decl_stmt|;
specifier|static
specifier|const
name|uptr
name|kMinSize
init|=
name|l0
decl_stmt|;
name|COMPILER_CHECK
argument_list|(
name|kNumClasses
operator|<=
literal|256
argument_list|)
expr_stmt|;
name|COMPILER_CHECK
argument_list|(
operator|(
name|kMaxSize
operator|&
operator|(
name|kMaxSize
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
specifier|static
name|uptr
name|Size
parameter_list|(
name|uptr
name|class_id
parameter_list|)
block|{
if|if
condition|(
name|class_id
operator|<=
name|u0
condition|)
return|return
name|l0
operator|+
name|s0
operator|*
operator|(
name|class_id
operator|-
literal|0
operator|)
return|;
if|if
condition|(
name|class_id
operator|<=
name|u1
condition|)
return|return
name|l1
operator|+
name|s1
operator|*
operator|(
name|class_id
operator|-
name|u0
operator|)
return|;
if|if
condition|(
name|class_id
operator|<=
name|u2
condition|)
return|return
name|l2
operator|+
name|s2
operator|*
operator|(
name|class_id
operator|-
name|u1
operator|)
return|;
if|if
condition|(
name|class_id
operator|<=
name|u3
condition|)
return|return
name|l3
operator|+
name|s3
operator|*
operator|(
name|class_id
operator|-
name|u2
operator|)
return|;
if|if
condition|(
name|class_id
operator|<=
name|u4
condition|)
return|return
name|l4
operator|+
name|s4
operator|*
operator|(
name|class_id
operator|-
name|u3
operator|)
return|;
return|return
literal|0
return|;
block|}
specifier|static
name|uptr
name|ClassID
parameter_list|(
name|uptr
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|<=
name|l1
condition|)
return|return
literal|0
operator|+
operator|(
name|size
operator|-
name|l0
operator|+
name|s0
operator|-
literal|1
operator|)
operator|/
name|s0
return|;
if|if
condition|(
name|size
operator|<=
name|l2
condition|)
return|return
name|u0
operator|+
operator|(
name|size
operator|-
name|l1
operator|+
name|s1
operator|-
literal|1
operator|)
operator|/
name|s1
return|;
if|if
condition|(
name|size
operator|<=
name|l3
condition|)
return|return
name|u1
operator|+
operator|(
name|size
operator|-
name|l2
operator|+
name|s2
operator|-
literal|1
operator|)
operator|/
name|s2
return|;
if|if
condition|(
name|size
operator|<=
name|l4
condition|)
return|return
name|u2
operator|+
operator|(
name|size
operator|-
name|l3
operator|+
name|s3
operator|-
literal|1
operator|)
operator|/
name|s3
return|;
if|if
condition|(
name|size
operator|<=
name|l5
condition|)
return|return
name|u3
operator|+
operator|(
name|size
operator|-
name|l4
operator|+
name|s4
operator|-
literal|1
operator|)
operator|/
name|s4
return|;
return|return
literal|0
return|;
block|}
block|}
empty_stmt|;
struct|struct
name|AllocatorListNode
block|{
name|AllocatorListNode
modifier|*
name|next
decl_stmt|;
block|}
struct|;
typedef|typedef
name|IntrusiveList
operator|<
name|AllocatorListNode
operator|>
name|AllocatorFreeList
expr_stmt|;
comment|// Space: a portion of address space of kSpaceSize bytes starting at
comment|// a fixed address (kSpaceBeg). Both constants are powers of two and
comment|// kSpaceBeg is kSpaceSize-aligned.
comment|//
comment|// Region: a part of Space dedicated to a single size class.
comment|// There are kNumClasses Regions of equal size.
comment|//
comment|// UserChunk: a piece of memory returned to user.
comment|// MetaChunk: kMetadataSize bytes of metadata associated with a UserChunk.
comment|//
comment|// A Region looks like this:
comment|// UserChunk1 ... UserChunkN<gap> MetaChunkN ... MetaChunk1
name|template
operator|<
specifier|const
name|uptr
name|kSpaceBeg
operator|,
specifier|const
name|uptr
name|kSpaceSize
operator|,
specifier|const
name|uptr
name|kMetadataSize
operator|,
name|class
name|SizeClassMap
operator|>
name|class
name|SizeClassAllocator64
block|{
name|public
operator|:
name|void
name|Init
argument_list|()
block|{
name|CHECK_EQ
argument_list|(
name|AllocBeg
argument_list|()
argument_list|,
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|MmapFixedNoReserve
argument_list|(
name|AllocBeg
argument_list|()
argument_list|,
name|AllocSize
argument_list|()
argument_list|)
operator|)
argument_list|)
block|;   }
name|bool
name|CanAllocate
argument_list|(
argument|uptr size
argument_list|,
argument|uptr alignment
argument_list|)
block|{
return|return
name|size
operator|<=
name|SizeClassMap
operator|::
name|kMaxSize
operator|&&
name|alignment
operator|<=
name|SizeClassMap
operator|::
name|kMaxSize
return|;
block|}
name|void
operator|*
name|Allocate
argument_list|(
argument|uptr size
argument_list|,
argument|uptr alignment
argument_list|)
block|{
name|CHECK
argument_list|(
name|CanAllocate
argument_list|(
name|size
argument_list|,
name|alignment
argument_list|)
argument_list|)
block|;
return|return
name|AllocateBySizeClass
argument_list|(
name|SizeClassMap
operator|::
name|ClassID
argument_list|(
name|size
argument_list|)
argument_list|)
return|;
block|}
name|void
name|Deallocate
argument_list|(
argument|void *p
argument_list|)
block|{
name|CHECK
argument_list|(
name|PointerIsMine
argument_list|(
name|p
argument_list|)
argument_list|)
block|;
name|DeallocateBySizeClass
argument_list|(
name|p
argument_list|,
name|GetSizeClass
argument_list|(
name|p
argument_list|)
argument_list|)
block|;   }
comment|// Allocate several chunks of the given class_id.
name|void
name|BulkAllocate
argument_list|(
argument|uptr class_id
argument_list|,
argument|AllocatorFreeList *free_list
argument_list|)
block|{
name|CHECK_LT
argument_list|(
name|class_id
argument_list|,
name|kNumClasses
argument_list|)
block|;
name|RegionInfo
operator|*
name|region
operator|=
name|GetRegionInfo
argument_list|(
name|class_id
argument_list|)
block|;
name|SpinMutexLock
name|l
argument_list|(
operator|&
name|region
operator|->
name|mutex
argument_list|)
block|;
if|if
condition|(
name|region
operator|->
name|free_list
operator|.
name|empty
argument_list|()
condition|)
block|{
name|PopulateFreeList
argument_list|(
name|class_id
argument_list|,
name|region
argument_list|)
expr_stmt|;
block|}
name|CHECK
argument_list|(
operator|!
name|region
operator|->
name|free_list
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
comment|// Just take as many chunks as we have in the free list now.
comment|// FIXME: this might be too much.
name|free_list
operator|->
name|append_front
argument_list|(
operator|&
name|region
operator|->
name|free_list
argument_list|)
block|;
name|CHECK
argument_list|(
name|region
operator|->
name|free_list
operator|.
name|empty
argument_list|()
argument_list|)
block|;   }
comment|// Swallow the entire free_list for the given class_id.
name|void
name|BulkDeallocate
argument_list|(
argument|uptr class_id
argument_list|,
argument|AllocatorFreeList *free_list
argument_list|)
block|{
name|CHECK_LT
argument_list|(
name|class_id
argument_list|,
name|kNumClasses
argument_list|)
block|;
name|RegionInfo
operator|*
name|region
operator|=
name|GetRegionInfo
argument_list|(
name|class_id
argument_list|)
block|;
name|SpinMutexLock
name|l
argument_list|(
operator|&
name|region
operator|->
name|mutex
argument_list|)
block|;
name|region
operator|->
name|free_list
operator|.
name|append_front
argument_list|(
name|free_list
argument_list|)
block|;   }
name|bool
name|PointerIsMine
argument_list|(
argument|void *p
argument_list|)
block|{
return|return
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|p
operator|)
operator|/
name|kSpaceSize
operator|==
name|kSpaceBeg
operator|/
name|kSpaceSize
return|;
block|}
name|uptr
name|GetSizeClass
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|p
operator|)
operator|/
name|kRegionSize
operator|)
operator|%
name|kNumClasses
return|;
block|}
name|uptr
name|GetActuallyAllocatedSize
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|CHECK
argument_list|(
name|PointerIsMine
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SizeClassMap
operator|::
name|Size
argument_list|(
name|GetSizeClass
argument_list|(
name|p
argument_list|)
argument_list|)
return|;
block|}
name|uptr
name|ClassID
parameter_list|(
name|uptr
name|size
parameter_list|)
block|{
return|return
name|SizeClassMap
operator|::
name|ClassID
argument_list|(
name|size
argument_list|)
return|;
block|}
name|void
modifier|*
name|GetMetaData
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|uptr
name|class_id
init|=
name|GetSizeClass
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|uptr
name|chunk_idx
init|=
name|GetChunkIdx
argument_list|(
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|p
operator|)
argument_list|,
name|class_id
argument_list|)
decl_stmt|;
return|return
name|reinterpret_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|kSpaceBeg
operator|+
operator|(
name|kRegionSize
operator|*
operator|(
name|class_id
operator|+
literal|1
operator|)
operator|)
operator|-
operator|(
literal|1
operator|+
name|chunk_idx
operator|)
operator|*
name|kMetadataSize
operator|)
return|;
block|}
name|uptr
name|TotalMemoryUsed
parameter_list|()
block|{
name|uptr
name|res
init|=
literal|0
decl_stmt|;
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|kNumClasses
condition|;
name|i
operator|++
control|)
name|res
operator|+=
name|GetRegionInfo
argument_list|(
name|i
argument_list|)
operator|->
name|allocated_user
expr_stmt|;
return|return
name|res
return|;
block|}
comment|// Test-only.
name|void
name|TestOnlyUnmap
parameter_list|()
block|{
name|UnmapOrDie
argument_list|(
name|reinterpret_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|AllocBeg
argument_list|()
operator|)
argument_list|,
name|AllocSize
argument_list|()
argument_list|)
expr_stmt|;
block|}
specifier|static
specifier|const
name|uptr
name|kNumClasses
init|=
literal|256
decl_stmt|;
comment|// Power of two<= 256
name|private
label|:
name|COMPILER_CHECK
argument_list|(
name|kNumClasses
operator|<=
name|SizeClassMap
operator|::
name|kNumClasses
argument_list|)
expr_stmt|;
specifier|static
specifier|const
name|uptr
name|kRegionSize
init|=
name|kSpaceSize
operator|/
name|kNumClasses
decl_stmt|;
name|COMPILER_CHECK
argument_list|(
operator|(
name|kRegionSize
operator|>>
literal|32
operator|)
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|// kRegionSize must be>= 2^32.
comment|// Populate the free list with at most this number of bytes at once
comment|// or with one element if its size is greater.
specifier|static
specifier|const
name|uptr
name|kPopulateSize
init|=
literal|1
operator|<<
literal|18
decl_stmt|;
struct|struct
name|RegionInfo
block|{
name|SpinMutex
name|mutex
decl_stmt|;
name|AllocatorFreeList
name|free_list
decl_stmt|;
name|uptr
name|allocated_user
decl_stmt|;
comment|// Bytes allocated for user memory.
name|uptr
name|allocated_meta
decl_stmt|;
comment|// Bytes allocated for metadata.
name|char
name|padding
index|[
name|kCacheLineSize
operator|-
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|uptr
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|AllocatorFreeList
argument_list|)
index|]
decl_stmt|;
block|}
struct|;
name|COMPILER_CHECK
argument_list|(
sizeof|sizeof
argument_list|(
name|RegionInfo
argument_list|)
operator|==
name|kCacheLineSize
argument_list|)
expr_stmt|;
name|uptr
name|AdditionalSize
parameter_list|()
block|{
name|uptr
name|res
init|=
sizeof|sizeof
argument_list|(
name|RegionInfo
argument_list|)
operator|*
name|kNumClasses
decl_stmt|;
name|CHECK_EQ
argument_list|(
name|res
operator|%
name|kPageSize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
name|uptr
name|AllocBeg
parameter_list|()
block|{
return|return
name|kSpaceBeg
operator|-
name|AdditionalSize
argument_list|()
return|;
block|}
name|uptr
name|AllocSize
parameter_list|()
block|{
return|return
name|kSpaceSize
operator|+
name|AdditionalSize
argument_list|()
return|;
block|}
name|RegionInfo
modifier|*
name|GetRegionInfo
parameter_list|(
name|uptr
name|class_id
parameter_list|)
block|{
name|CHECK_LT
argument_list|(
name|class_id
argument_list|,
name|kNumClasses
argument_list|)
expr_stmt|;
name|RegionInfo
modifier|*
name|regions
init|=
name|reinterpret_cast
operator|<
name|RegionInfo
operator|*
operator|>
operator|(
name|kSpaceBeg
operator|)
decl_stmt|;
return|return
operator|&
name|regions
index|[
operator|-
literal|1
operator|-
name|class_id
index|]
return|;
block|}
name|uptr
name|GetChunkIdx
parameter_list|(
name|uptr
name|chunk
parameter_list|,
name|uptr
name|class_id
parameter_list|)
block|{
name|u32
name|offset
init|=
name|chunk
operator|%
name|kRegionSize
decl_stmt|;
comment|// Here we divide by a non-constant. This is costly.
comment|// We require that kRegionSize is at least 2^32 so that offset is 32-bit.
comment|// We save 2x by using 32-bit div, but may need to use a 256-way switch.
return|return
name|offset
operator|/
operator|(
name|u32
operator|)
name|SizeClassMap
operator|::
name|Size
argument_list|(
name|class_id
argument_list|)
return|;
block|}
name|void
name|PopulateFreeList
parameter_list|(
name|uptr
name|class_id
parameter_list|,
name|RegionInfo
modifier|*
name|region
parameter_list|)
block|{
name|uptr
name|size
init|=
name|SizeClassMap
operator|::
name|Size
argument_list|(
name|class_id
argument_list|)
decl_stmt|;
name|uptr
name|beg_idx
init|=
name|region
operator|->
name|allocated_user
decl_stmt|;
name|uptr
name|end_idx
init|=
name|beg_idx
operator|+
name|kPopulateSize
decl_stmt|;
name|region
operator|->
name|free_list
operator|.
name|clear
argument_list|()
expr_stmt|;
name|uptr
name|region_beg
init|=
name|kSpaceBeg
operator|+
name|kRegionSize
operator|*
name|class_id
decl_stmt|;
name|uptr
name|idx
init|=
name|beg_idx
decl_stmt|;
name|uptr
name|i
init|=
literal|0
decl_stmt|;
do|do
block|{
comment|// do-while loop because we need to put at least one item.
name|uptr
name|p
init|=
name|region_beg
operator|+
name|idx
decl_stmt|;
name|region
operator|->
name|free_list
operator|.
name|push_front
argument_list|(
name|reinterpret_cast
operator|<
name|AllocatorListNode
operator|*
operator|>
operator|(
name|p
operator|)
argument_list|)
expr_stmt|;
name|idx
operator|+=
name|size
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|idx
operator|<
name|end_idx
condition|)
do|;
name|region
operator|->
name|allocated_user
operator|+=
name|idx
operator|-
name|beg_idx
expr_stmt|;
name|region
operator|->
name|allocated_meta
operator|+=
name|i
operator|*
name|kMetadataSize
expr_stmt|;
name|CHECK_LT
argument_list|(
name|region
operator|->
name|allocated_user
operator|+
name|region
operator|->
name|allocated_meta
argument_list|,
name|kRegionSize
argument_list|)
expr_stmt|;
block|}
name|void
modifier|*
name|AllocateBySizeClass
parameter_list|(
name|uptr
name|class_id
parameter_list|)
block|{
name|CHECK_LT
argument_list|(
name|class_id
argument_list|,
name|kNumClasses
argument_list|)
expr_stmt|;
name|RegionInfo
modifier|*
name|region
init|=
name|GetRegionInfo
argument_list|(
name|class_id
argument_list|)
decl_stmt|;
name|SpinMutexLock
name|l
argument_list|(
operator|&
name|region
operator|->
name|mutex
argument_list|)
decl_stmt|;
if|if
condition|(
name|region
operator|->
name|free_list
operator|.
name|empty
argument_list|()
condition|)
block|{
name|PopulateFreeList
argument_list|(
name|class_id
argument_list|,
name|region
argument_list|)
expr_stmt|;
block|}
name|CHECK
argument_list|(
operator|!
name|region
operator|->
name|free_list
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
name|AllocatorListNode
modifier|*
name|node
init|=
name|region
operator|->
name|free_list
operator|.
name|front
argument_list|()
decl_stmt|;
name|region
operator|->
name|free_list
operator|.
name|pop_front
argument_list|()
expr_stmt|;
return|return
name|reinterpret_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|node
operator|)
return|;
block|}
name|void
name|DeallocateBySizeClass
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|uptr
name|class_id
parameter_list|)
block|{
name|RegionInfo
modifier|*
name|region
init|=
name|GetRegionInfo
argument_list|(
name|class_id
argument_list|)
decl_stmt|;
name|SpinMutexLock
name|l
argument_list|(
operator|&
name|region
operator|->
name|mutex
argument_list|)
decl_stmt|;
name|region
operator|->
name|free_list
operator|.
name|push_front
argument_list|(
name|reinterpret_cast
operator|<
name|AllocatorListNode
operator|*
operator|>
operator|(
name|p
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// Objects of this type should be used as local caches for SizeClassAllocator64.
end_comment

begin_comment
comment|// Since the typical use of this class is to have one object per thread in TLS,
end_comment

begin_comment
comment|// is has to be POD.
end_comment

begin_expr_stmt
name|template
operator|<
specifier|const
name|uptr
name|kNumClasses
operator|,
name|class
name|SizeClassAllocator
operator|>
expr|struct
name|SizeClassAllocatorLocalCache
block|{
comment|// Don't need to call Init if the object is a global (i.e. zero-initialized).
name|void
name|Init
argument_list|()
block|{
name|internal_memset
argument_list|(
name|this
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|this
argument_list|)
argument_list|)
block|;   }
name|void
operator|*
name|Allocate
argument_list|(
argument|SizeClassAllocator *allocator
argument_list|,
argument|uptr class_id
argument_list|)
block|{
name|CHECK_LT
argument_list|(
name|class_id
argument_list|,
name|kNumClasses
argument_list|)
block|;
name|AllocatorFreeList
operator|*
name|free_list
operator|=
operator|&
name|free_lists_
index|[
name|class_id
index|]
block|;
if|if
condition|(
name|free_list
operator|->
name|empty
argument_list|()
condition|)
name|allocator
operator|->
name|BulkAllocate
argument_list|(
name|class_id
argument_list|,
name|free_list
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
operator|!
name|free_list
operator|->
name|empty
argument_list|()
argument_list|)
block|;
name|void
operator|*
name|res
operator|=
name|free_list
operator|->
name|front
argument_list|()
block|;
name|free_list
operator|->
name|pop_front
argument_list|()
block|;
return|return
name|res
return|;
block|}
end_expr_stmt

begin_function
name|void
name|Deallocate
parameter_list|(
name|SizeClassAllocator
modifier|*
name|allocator
parameter_list|,
name|uptr
name|class_id
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|CHECK_LT
argument_list|(
name|class_id
argument_list|,
name|kNumClasses
argument_list|)
expr_stmt|;
name|free_lists_
index|[
name|class_id
index|]
operator|.
name|push_front
argument_list|(
name|reinterpret_cast
operator|<
name|AllocatorListNode
operator|*
operator|>
operator|(
name|p
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Drain
parameter_list|(
name|SizeClassAllocator
modifier|*
name|allocator
parameter_list|)
block|{
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|kNumClasses
condition|;
name|i
operator|++
control|)
block|{
name|allocator
operator|->
name|BulkDeallocate
argument_list|(
name|i
argument_list|,
operator|&
name|free_lists_
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
name|free_lists_
index|[
name|i
index|]
operator|.
name|empty
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|// private:
end_comment

begin_decl_stmt
name|AllocatorFreeList
name|free_lists_
index|[
name|kNumClasses
index|]
decl_stmt|;
end_decl_stmt

begin_comment
unit|};
comment|// This class can (de)allocate only large chunks of memory using mmap/unmap.
end_comment

begin_comment
comment|// The main purpose of this allocator is to cover large and rare allocation
end_comment

begin_comment
comment|// sizes not covered by more efficient allocators (e.g. SizeClassAllocator64).
end_comment

begin_comment
comment|// The result is always page-aligned.
end_comment

begin_decl_stmt
name|class
name|LargeMmapAllocator
block|{
name|public
label|:
name|void
name|Init
parameter_list|()
block|{
name|internal_memset
argument_list|(
name|this
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|this
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|void
modifier|*
name|Allocate
parameter_list|(
name|uptr
name|size
parameter_list|,
name|uptr
name|alignment
parameter_list|)
block|{
name|CHECK_LE
argument_list|(
name|alignment
argument_list|,
name|kPageSize
argument_list|)
expr_stmt|;
comment|// Not implemented. Do we need it?
name|uptr
name|map_size
init|=
name|RoundUpMapSize
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|void
modifier|*
name|map
init|=
name|MmapOrDie
argument_list|(
name|map_size
argument_list|,
literal|"LargeMmapAllocator"
argument_list|)
decl_stmt|;
name|void
modifier|*
name|res
init|=
name|reinterpret_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|map
operator|)
operator|+
name|kPageSize
operator|)
decl_stmt|;
name|Header
modifier|*
name|h
init|=
name|GetHeader
argument_list|(
name|res
argument_list|)
decl_stmt|;
name|h
operator|->
name|size
operator|=
name|size
expr_stmt|;
block|{
name|SpinMutexLock
name|l
argument_list|(
operator|&
name|mutex_
argument_list|)
decl_stmt|;
name|h
operator|->
name|next
operator|=
name|list_
expr_stmt|;
name|h
operator|->
name|prev
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|list_
condition|)
name|list_
operator|->
name|prev
operator|=
name|h
expr_stmt|;
name|list_
operator|=
name|h
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
name|void
name|Deallocate
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
name|Header
modifier|*
name|h
init|=
name|GetHeader
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|uptr
name|map_size
init|=
name|RoundUpMapSize
argument_list|(
name|h
operator|->
name|size
argument_list|)
decl_stmt|;
block|{
name|SpinMutexLock
name|l
argument_list|(
operator|&
name|mutex_
argument_list|)
decl_stmt|;
name|Header
modifier|*
name|prev
init|=
name|h
operator|->
name|prev
decl_stmt|;
name|Header
modifier|*
name|next
init|=
name|h
operator|->
name|next
decl_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|next
operator|->
name|prev
operator|=
name|prev
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|list_
condition|)
name|list_
operator|=
name|next
expr_stmt|;
block|}
name|UnmapOrDie
argument_list|(
name|h
argument_list|,
name|map_size
argument_list|)
expr_stmt|;
block|}
name|uptr
name|TotalMemoryUsed
parameter_list|()
block|{
name|SpinMutexLock
name|l
argument_list|(
operator|&
name|mutex_
argument_list|)
decl_stmt|;
name|uptr
name|res
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Header
modifier|*
name|l
init|=
name|list_
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|res
operator|+=
name|RoundUpMapSize
argument_list|(
name|l
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
return|return
name|res
return|;
block|}
name|bool
name|PointerIsMine
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
comment|// Fast check.
if|if
condition|(
operator|(
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|p
operator|)
operator|%
name|kPageSize
operator|)
operator|!=
literal|0
condition|)
return|return
name|false
return|;
name|SpinMutexLock
name|l
argument_list|(
operator|&
name|mutex_
argument_list|)
decl_stmt|;
for|for
control|(
name|Header
modifier|*
name|l
init|=
name|list_
init|;
name|l
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
if|if
condition|(
name|GetUser
argument_list|(
name|l
argument_list|)
operator|==
name|p
condition|)
return|return
name|true
return|;
block|}
return|return
name|false
return|;
block|}
name|uptr
name|GetActuallyAllocatedSize
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
return|return
name|RoundUpMapSize
argument_list|(
name|GetHeader
argument_list|(
name|p
argument_list|)
operator|->
name|size
argument_list|)
operator|-
name|kPageSize
return|;
block|}
comment|// At least kPageSize/2 metadata bytes is available.
name|void
modifier|*
name|GetMetaData
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
return|return
name|GetHeader
argument_list|(
name|p
argument_list|)
operator|+
literal|1
return|;
block|}
name|private
label|:
struct|struct
name|Header
block|{
name|uptr
name|size
decl_stmt|;
name|Header
modifier|*
name|next
decl_stmt|;
name|Header
modifier|*
name|prev
decl_stmt|;
block|}
struct|;
name|Header
modifier|*
name|GetHeader
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
return|return
name|reinterpret_cast
operator|<
name|Header
operator|*
operator|>
operator|(
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|p
operator|)
operator|-
name|kPageSize
operator|)
return|;
block|}
name|void
modifier|*
name|GetUser
parameter_list|(
name|Header
modifier|*
name|h
parameter_list|)
block|{
return|return
name|reinterpret_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|h
operator|)
operator|+
name|kPageSize
operator|)
return|;
block|}
name|uptr
name|RoundUpMapSize
parameter_list|(
name|uptr
name|size
parameter_list|)
block|{
return|return
name|RoundUpTo
argument_list|(
name|size
argument_list|,
name|kPageSize
argument_list|)
operator|+
name|kPageSize
return|;
block|}
name|Header
modifier|*
name|list_
decl_stmt|;
name|SpinMutex
name|mutex_
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// This class implements a complete memory allocator by using two
end_comment

begin_comment
comment|// internal allocators:
end_comment

begin_comment
comment|// PrimaryAllocator is efficient, but may not allocate some sizes (alignments).
end_comment

begin_comment
comment|//  When allocating 2^x bytes it should return 2^x aligned chunk.
end_comment

begin_comment
comment|// PrimaryAllocator is used via a local AllocatorCache.
end_comment

begin_comment
comment|// SecondaryAllocator can allocate anything, but is not efficient.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|PrimaryAllocator
operator|,
name|class
name|AllocatorCache
operator|,
name|class
name|SecondaryAllocator
operator|>
comment|// NOLINT
name|class
name|CombinedAllocator
block|{
name|public
operator|:
name|void
name|Init
argument_list|()
block|{
name|primary_
operator|.
name|Init
argument_list|()
block|;
name|secondary_
operator|.
name|Init
argument_list|()
block|;   }
name|void
operator|*
name|Allocate
argument_list|(
argument|AllocatorCache *cache
argument_list|,
argument|uptr size
argument_list|,
argument|uptr alignment
argument_list|,
argument|bool cleared = false
argument_list|)
block|{
comment|// Returning 0 on malloc(0) may break a lot of code.
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|alignment
operator|>
literal|8
condition|)
name|size
operator|=
name|RoundUpTo
argument_list|(
name|size
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
name|void
operator|*
name|res
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|primary_
operator|.
name|CanAllocate
argument_list|(
name|size
argument_list|,
name|alignment
argument_list|)
condition|)
name|res
operator|=
name|cache
operator|->
name|Allocate
argument_list|(
operator|&
name|primary_
argument_list|,
name|primary_
operator|.
name|ClassID
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|res
operator|=
name|secondary_
operator|.
name|Allocate
argument_list|(
name|size
argument_list|,
name|alignment
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|alignment
operator|>
literal|8
condition|)
name|CHECK_EQ
argument_list|(
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|res
operator|)
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|cleared
condition|)
name|internal_memset
argument_list|(
name|res
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
end_if

begin_return
return|return
name|res
return|;
end_return

begin_macro
unit|}    void
name|Deallocate
argument_list|(
argument|AllocatorCache *cache
argument_list|,
argument|void *p
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|p
condition|)
return|return;
if|if
condition|(
name|primary_
operator|.
name|PointerIsMine
argument_list|(
name|p
argument_list|)
condition|)
name|cache
operator|->
name|Deallocate
argument_list|(
operator|&
name|primary_
argument_list|,
name|primary_
operator|.
name|GetSizeClass
argument_list|(
name|p
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
name|secondary_
operator|.
name|Deallocate
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
modifier|*
name|Reallocate
parameter_list|(
name|AllocatorCache
modifier|*
name|cache
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|uptr
name|new_size
parameter_list|,
name|uptr
name|alignment
parameter_list|)
block|{
if|if
condition|(
operator|!
name|p
condition|)
return|return
name|Allocate
argument_list|(
name|cache
argument_list|,
name|new_size
argument_list|,
name|alignment
argument_list|)
return|;
if|if
condition|(
operator|!
name|new_size
condition|)
block|{
name|Deallocate
argument_list|(
name|cache
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|CHECK
argument_list|(
name|PointerIsMine
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|uptr
name|old_size
init|=
name|GetActuallyAllocatedSize
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|uptr
name|memcpy_size
init|=
name|Min
argument_list|(
name|new_size
argument_list|,
name|old_size
argument_list|)
decl_stmt|;
name|void
modifier|*
name|new_p
init|=
name|Allocate
argument_list|(
name|cache
argument_list|,
name|new_size
argument_list|,
name|alignment
argument_list|)
decl_stmt|;
if|if
condition|(
name|new_p
condition|)
name|internal_memcpy
argument_list|(
name|new_p
argument_list|,
name|p
argument_list|,
name|memcpy_size
argument_list|)
expr_stmt|;
name|Deallocate
argument_list|(
name|cache
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|new_p
return|;
block|}
end_function

begin_function
name|bool
name|PointerIsMine
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|primary_
operator|.
name|PointerIsMine
argument_list|(
name|p
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|secondary_
operator|.
name|PointerIsMine
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|GetMetaData
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|primary_
operator|.
name|PointerIsMine
argument_list|(
name|p
argument_list|)
condition|)
return|return
name|primary_
operator|.
name|GetMetaData
argument_list|(
name|p
argument_list|)
return|;
return|return
name|secondary_
operator|.
name|GetMetaData
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function

begin_function
name|uptr
name|GetActuallyAllocatedSize
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
block|{
if|if
condition|(
name|primary_
operator|.
name|PointerIsMine
argument_list|(
name|p
argument_list|)
condition|)
return|return
name|primary_
operator|.
name|GetActuallyAllocatedSize
argument_list|(
name|p
argument_list|)
return|;
return|return
name|secondary_
operator|.
name|GetActuallyAllocatedSize
argument_list|(
name|p
argument_list|)
return|;
block|}
end_function

begin_function
name|uptr
name|TotalMemoryUsed
parameter_list|()
block|{
return|return
name|primary_
operator|.
name|TotalMemoryUsed
argument_list|()
operator|+
name|secondary_
operator|.
name|TotalMemoryUsed
argument_list|()
return|;
block|}
end_function

begin_function
name|void
name|TestOnlyUnmap
parameter_list|()
block|{
name|primary_
operator|.
name|TestOnlyUnmap
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|SwallowCache
parameter_list|(
name|AllocatorCache
modifier|*
name|cache
parameter_list|)
block|{
name|cache
operator|->
name|Drain
argument_list|(
operator|&
name|primary_
argument_list|)
expr_stmt|;
block|}
end_function

begin_label
name|private
label|:
end_label

begin_decl_stmt
name|PrimaryAllocator
name|primary_
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SecondaryAllocator
name|secondary_
decl_stmt|;
end_decl_stmt

begin_comment
unit|};  }
comment|// namespace __sanitizer
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// SANITIZER_ALLOCATOR_H
end_comment

end_unit

