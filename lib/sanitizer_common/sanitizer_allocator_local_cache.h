begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- sanitizer_allocator_local_cache.h -----------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Part of the Sanitizer Allocator.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SANITIZER_ALLOCATOR_H
end_ifndef

begin_error
error|#
directive|error
error|This file must be included inside sanitizer_allocator.h
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// Objects of this type should be used as local caches for SizeClassAllocator64
end_comment

begin_comment
comment|// or SizeClassAllocator32. Since the typical use of this class is to have one
end_comment

begin_comment
comment|// object per thread in TLS, is has to be POD.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|SizeClassAllocator
operator|>
expr|struct
name|SizeClassAllocatorLocalCache
operator|:
name|SizeClassAllocator
operator|::
name|AllocatorCache
block|{ }
expr_stmt|;
end_expr_stmt

begin_comment
comment|// Cache used by SizeClassAllocator64.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|SizeClassAllocator
operator|>
expr|struct
name|SizeClassAllocator64LocalCache
block|{
typedef|typedef
name|SizeClassAllocator
name|Allocator
typedef|;
specifier|static
specifier|const
name|uptr
name|kNumClasses
operator|=
name|SizeClassAllocator
operator|::
name|kNumClasses
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|Allocator
operator|::
name|SizeClassMapT
name|SizeClassMap
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|typename
name|Allocator
operator|::
name|CompactPtrT
name|CompactPtrT
expr_stmt|;
end_typedef

begin_function
name|void
name|Init
parameter_list|(
name|AllocatorGlobalStats
modifier|*
name|s
parameter_list|)
block|{
name|stats_
operator|.
name|Init
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|s
operator|->
name|Register
argument_list|(
operator|&
name|stats_
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Destroy
parameter_list|(
name|SizeClassAllocator
modifier|*
name|allocator
parameter_list|,
name|AllocatorGlobalStats
modifier|*
name|s
parameter_list|)
block|{
name|Drain
argument_list|(
name|allocator
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|s
operator|->
name|Unregister
argument_list|(
operator|&
name|stats_
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|Allocate
parameter_list|(
name|SizeClassAllocator
modifier|*
name|allocator
parameter_list|,
name|uptr
name|class_id
parameter_list|)
block|{
name|CHECK_NE
argument_list|(
name|class_id
argument_list|,
literal|0UL
argument_list|)
expr_stmt|;
name|CHECK_LT
argument_list|(
name|class_id
argument_list|,
name|kNumClasses
argument_list|)
expr_stmt|;
name|PerClass
modifier|*
name|c
init|=
operator|&
name|per_class_
index|[
name|class_id
index|]
decl_stmt|;
if|if
condition|(
name|UNLIKELY
argument_list|(
name|c
operator|->
name|count
operator|==
literal|0
argument_list|)
condition|)
name|Refill
argument_list|(
name|c
argument_list|,
name|allocator
argument_list|,
name|class_id
argument_list|)
expr_stmt|;
name|stats_
operator|.
name|Add
argument_list|(
name|AllocatorStatAllocated
argument_list|,
name|c
operator|->
name|class_size
argument_list|)
expr_stmt|;
name|CHECK_GT
argument_list|(
name|c
operator|->
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|CompactPtrT
name|chunk
init|=
name|c
operator|->
name|chunks
index|[
operator|--
name|c
operator|->
name|count
index|]
decl_stmt|;
name|void
modifier|*
name|res
init|=
name|reinterpret_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|allocator
operator|->
name|CompactPtrToPointer
argument_list|(
name|allocator
operator|->
name|GetRegionBeginBySizeClass
argument_list|(
name|class_id
argument_list|)
argument_list|,
name|chunk
argument_list|)
operator|)
decl_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
name|void
name|Deallocate
parameter_list|(
name|SizeClassAllocator
modifier|*
name|allocator
parameter_list|,
name|uptr
name|class_id
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|CHECK_NE
argument_list|(
name|class_id
argument_list|,
literal|0UL
argument_list|)
expr_stmt|;
name|CHECK_LT
argument_list|(
name|class_id
argument_list|,
name|kNumClasses
argument_list|)
expr_stmt|;
comment|// If the first allocator call on a new thread is a deallocation, then
comment|// max_count will be zero, leading to check failure.
name|InitCache
argument_list|()
expr_stmt|;
name|PerClass
modifier|*
name|c
init|=
operator|&
name|per_class_
index|[
name|class_id
index|]
decl_stmt|;
name|stats_
operator|.
name|Sub
argument_list|(
name|AllocatorStatAllocated
argument_list|,
name|c
operator|->
name|class_size
argument_list|)
expr_stmt|;
name|CHECK_NE
argument_list|(
name|c
operator|->
name|max_count
argument_list|,
literal|0UL
argument_list|)
expr_stmt|;
if|if
condition|(
name|UNLIKELY
argument_list|(
name|c
operator|->
name|count
operator|==
name|c
operator|->
name|max_count
argument_list|)
condition|)
name|Drain
argument_list|(
name|c
argument_list|,
name|allocator
argument_list|,
name|class_id
argument_list|,
name|c
operator|->
name|max_count
operator|/
literal|2
argument_list|)
expr_stmt|;
name|CompactPtrT
name|chunk
init|=
name|allocator
operator|->
name|PointerToCompactPtr
argument_list|(
name|allocator
operator|->
name|GetRegionBeginBySizeClass
argument_list|(
name|class_id
argument_list|)
argument_list|,
name|reinterpret_cast
operator|<
name|uptr
operator|>
operator|(
name|p
operator|)
argument_list|)
decl_stmt|;
name|c
operator|->
name|chunks
index|[
name|c
operator|->
name|count
operator|++
index|]
operator|=
name|chunk
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Drain
parameter_list|(
name|SizeClassAllocator
modifier|*
name|allocator
parameter_list|)
block|{
for|for
control|(
name|uptr
name|class_id
init|=
literal|0
init|;
name|class_id
operator|<
name|kNumClasses
condition|;
name|class_id
operator|++
control|)
block|{
name|PerClass
modifier|*
name|c
init|=
operator|&
name|per_class_
index|[
name|class_id
index|]
decl_stmt|;
while|while
condition|(
name|c
operator|->
name|count
operator|>
literal|0
condition|)
name|Drain
argument_list|(
name|c
argument_list|,
name|allocator
argument_list|,
name|class_id
argument_list|,
name|c
operator|->
name|count
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|// private:
end_comment

begin_struct
struct|struct
name|PerClass
block|{
name|u32
name|count
decl_stmt|;
name|u32
name|max_count
decl_stmt|;
name|uptr
name|class_size
decl_stmt|;
name|CompactPtrT
name|chunks
index|[
literal|2
operator|*
name|SizeClassMap
operator|::
name|kMaxNumCachedHint
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|PerClass
name|per_class_
index|[
name|kNumClasses
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|AllocatorStats
name|stats_
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|InitCache
parameter_list|()
block|{
if|if
condition|(
name|per_class_
index|[
literal|1
index|]
operator|.
name|max_count
condition|)
return|return;
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|kNumClasses
condition|;
name|i
operator|++
control|)
block|{
name|PerClass
modifier|*
name|c
init|=
operator|&
name|per_class_
index|[
name|i
index|]
decl_stmt|;
name|c
operator|->
name|max_count
operator|=
literal|2
operator|*
name|SizeClassMap
operator|::
name|MaxCachedHint
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|c
operator|->
name|class_size
operator|=
name|Allocator
operator|::
name|ClassIdToSize
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|NOINLINE
name|void
name|Refill
parameter_list|(
name|PerClass
modifier|*
name|c
parameter_list|,
name|SizeClassAllocator
modifier|*
name|allocator
parameter_list|,
name|uptr
name|class_id
parameter_list|)
block|{
name|InitCache
argument_list|()
expr_stmt|;
name|uptr
name|num_requested_chunks
init|=
name|c
operator|->
name|max_count
operator|/
literal|2
decl_stmt|;
name|allocator
operator|->
name|GetFromAllocator
argument_list|(
operator|&
name|stats_
argument_list|,
name|class_id
argument_list|,
name|c
operator|->
name|chunks
argument_list|,
name|num_requested_chunks
argument_list|)
expr_stmt|;
name|c
operator|->
name|count
operator|=
name|num_requested_chunks
expr_stmt|;
block|}
end_function

begin_function
name|NOINLINE
name|void
name|Drain
parameter_list|(
name|PerClass
modifier|*
name|c
parameter_list|,
name|SizeClassAllocator
modifier|*
name|allocator
parameter_list|,
name|uptr
name|class_id
parameter_list|,
name|uptr
name|count
parameter_list|)
block|{
name|InitCache
argument_list|()
expr_stmt|;
name|CHECK_GE
argument_list|(
name|c
operator|->
name|count
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|uptr
name|first_idx_to_drain
init|=
name|c
operator|->
name|count
operator|-
name|count
decl_stmt|;
name|c
operator|->
name|count
operator|-=
name|count
expr_stmt|;
name|allocator
operator|->
name|ReturnToAllocator
argument_list|(
operator|&
name|stats_
argument_list|,
name|class_id
argument_list|,
operator|&
name|c
operator|->
name|chunks
index|[
name|first_idx_to_drain
index|]
argument_list|,
name|count
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
unit|};
comment|// Cache used by SizeClassAllocator32.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|SizeClassAllocator
operator|>
expr|struct
name|SizeClassAllocator32LocalCache
block|{
typedef|typedef
name|SizeClassAllocator
name|Allocator
typedef|;
end_expr_stmt

begin_typedef
typedef|typedef
name|typename
name|Allocator
operator|::
name|TransferBatch
name|TransferBatch
expr_stmt|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|uptr
name|kNumClasses
init|=
name|SizeClassAllocator
operator|::
name|kNumClasses
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|Init
parameter_list|(
name|AllocatorGlobalStats
modifier|*
name|s
parameter_list|)
block|{
name|stats_
operator|.
name|Init
argument_list|()
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|s
operator|->
name|Register
argument_list|(
operator|&
name|stats_
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Destroy
parameter_list|(
name|SizeClassAllocator
modifier|*
name|allocator
parameter_list|,
name|AllocatorGlobalStats
modifier|*
name|s
parameter_list|)
block|{
name|Drain
argument_list|(
name|allocator
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|s
operator|->
name|Unregister
argument_list|(
operator|&
name|stats_
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|Allocate
parameter_list|(
name|SizeClassAllocator
modifier|*
name|allocator
parameter_list|,
name|uptr
name|class_id
parameter_list|)
block|{
name|CHECK_NE
argument_list|(
name|class_id
argument_list|,
literal|0UL
argument_list|)
expr_stmt|;
name|CHECK_LT
argument_list|(
name|class_id
argument_list|,
name|kNumClasses
argument_list|)
expr_stmt|;
name|PerClass
modifier|*
name|c
init|=
operator|&
name|per_class_
index|[
name|class_id
index|]
decl_stmt|;
if|if
condition|(
name|UNLIKELY
argument_list|(
name|c
operator|->
name|count
operator|==
literal|0
argument_list|)
condition|)
name|Refill
argument_list|(
name|allocator
argument_list|,
name|class_id
argument_list|)
expr_stmt|;
name|stats_
operator|.
name|Add
argument_list|(
name|AllocatorStatAllocated
argument_list|,
name|c
operator|->
name|class_size
argument_list|)
expr_stmt|;
name|void
modifier|*
name|res
init|=
name|c
operator|->
name|batch
index|[
operator|--
name|c
operator|->
name|count
index|]
decl_stmt|;
name|PREFETCH
argument_list|(
name|c
operator|->
name|batch
index|[
name|c
operator|->
name|count
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_function
name|void
name|Deallocate
parameter_list|(
name|SizeClassAllocator
modifier|*
name|allocator
parameter_list|,
name|uptr
name|class_id
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|CHECK_NE
argument_list|(
name|class_id
argument_list|,
literal|0UL
argument_list|)
expr_stmt|;
name|CHECK_LT
argument_list|(
name|class_id
argument_list|,
name|kNumClasses
argument_list|)
expr_stmt|;
comment|// If the first allocator call on a new thread is a deallocation, then
comment|// max_count will be zero, leading to check failure.
name|InitCache
argument_list|()
expr_stmt|;
name|PerClass
modifier|*
name|c
init|=
operator|&
name|per_class_
index|[
name|class_id
index|]
decl_stmt|;
name|stats_
operator|.
name|Sub
argument_list|(
name|AllocatorStatAllocated
argument_list|,
name|c
operator|->
name|class_size
argument_list|)
expr_stmt|;
name|CHECK_NE
argument_list|(
name|c
operator|->
name|max_count
argument_list|,
literal|0UL
argument_list|)
expr_stmt|;
if|if
condition|(
name|UNLIKELY
argument_list|(
name|c
operator|->
name|count
operator|==
name|c
operator|->
name|max_count
argument_list|)
condition|)
name|Drain
argument_list|(
name|allocator
argument_list|,
name|class_id
argument_list|)
expr_stmt|;
name|c
operator|->
name|batch
index|[
name|c
operator|->
name|count
operator|++
index|]
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Drain
parameter_list|(
name|SizeClassAllocator
modifier|*
name|allocator
parameter_list|)
block|{
for|for
control|(
name|uptr
name|class_id
init|=
literal|0
init|;
name|class_id
operator|<
name|kNumClasses
condition|;
name|class_id
operator|++
control|)
block|{
name|PerClass
modifier|*
name|c
init|=
operator|&
name|per_class_
index|[
name|class_id
index|]
decl_stmt|;
while|while
condition|(
name|c
operator|->
name|count
operator|>
literal|0
condition|)
name|Drain
argument_list|(
name|allocator
argument_list|,
name|class_id
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|// private:
end_comment

begin_typedef
typedef|typedef
name|typename
name|SizeClassAllocator
operator|::
name|SizeClassMapT
name|SizeClassMap
expr_stmt|;
end_typedef

begin_struct
struct|struct
name|PerClass
block|{
name|uptr
name|count
decl_stmt|;
name|uptr
name|max_count
decl_stmt|;
name|uptr
name|class_size
decl_stmt|;
name|void
modifier|*
name|batch
index|[
literal|2
operator|*
name|TransferBatch
operator|::
name|kMaxNumCached
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|PerClass
name|per_class_
index|[
name|kNumClasses
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|AllocatorStats
name|stats_
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|InitCache
parameter_list|()
block|{
if|if
condition|(
name|per_class_
index|[
literal|1
index|]
operator|.
name|max_count
condition|)
return|return;
for|for
control|(
name|uptr
name|i
init|=
literal|0
init|;
name|i
operator|<
name|kNumClasses
condition|;
name|i
operator|++
control|)
block|{
name|PerClass
modifier|*
name|c
init|=
operator|&
name|per_class_
index|[
name|i
index|]
decl_stmt|;
name|c
operator|->
name|max_count
operator|=
literal|2
operator|*
name|TransferBatch
operator|::
name|MaxCached
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|c
operator|->
name|class_size
operator|=
name|Allocator
operator|::
name|ClassIdToSize
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|// TransferBatch class is declared in SizeClassAllocator.
end_comment

begin_comment
comment|// We transfer chunks between central and thread-local free lists in batches.
end_comment

begin_comment
comment|// For small size classes we allocate batches separately.
end_comment

begin_comment
comment|// For large size classes we may use one of the chunks to store the batch.
end_comment

begin_comment
comment|// sizeof(TransferBatch) must be a power of 2 for more efficient allocation.
end_comment

begin_function
specifier|static
name|uptr
name|SizeClassForTransferBatch
parameter_list|(
name|uptr
name|class_id
parameter_list|)
block|{
if|if
condition|(
name|Allocator
operator|::
name|ClassIdToSize
argument_list|(
name|class_id
argument_list|)
operator|<
name|TransferBatch
operator|::
name|AllocationSizeRequiredForNElements
argument_list|(
name|TransferBatch
operator|::
name|MaxCached
argument_list|(
name|class_id
argument_list|)
argument_list|)
condition|)
return|return
name|SizeClassMap
operator|::
name|ClassID
argument_list|(
sizeof|sizeof
argument_list|(
name|TransferBatch
argument_list|)
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|// Returns a TransferBatch suitable for class_id.
end_comment

begin_comment
comment|// For small size classes allocates the batch from the allocator.
end_comment

begin_comment
comment|// For large size classes simply returns b.
end_comment

begin_function
name|TransferBatch
modifier|*
name|CreateBatch
parameter_list|(
name|uptr
name|class_id
parameter_list|,
name|SizeClassAllocator
modifier|*
name|allocator
parameter_list|,
name|TransferBatch
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
name|uptr
name|batch_class_id
init|=
name|SizeClassForTransferBatch
argument_list|(
name|class_id
argument_list|)
condition|)
return|return
operator|(
name|TransferBatch
operator|*
operator|)
name|Allocate
argument_list|(
name|allocator
argument_list|,
name|batch_class_id
argument_list|)
return|;
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|// Destroys TransferBatch b.
end_comment

begin_comment
comment|// For small size classes deallocates b to the allocator.
end_comment

begin_comment
comment|// Does notthing for large size classes.
end_comment

begin_function
name|void
name|DestroyBatch
parameter_list|(
name|uptr
name|class_id
parameter_list|,
name|SizeClassAllocator
modifier|*
name|allocator
parameter_list|,
name|TransferBatch
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
name|uptr
name|batch_class_id
init|=
name|SizeClassForTransferBatch
argument_list|(
name|class_id
argument_list|)
condition|)
name|Deallocate
argument_list|(
name|allocator
argument_list|,
name|batch_class_id
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|NOINLINE
name|void
name|Refill
parameter_list|(
name|SizeClassAllocator
modifier|*
name|allocator
parameter_list|,
name|uptr
name|class_id
parameter_list|)
block|{
name|InitCache
argument_list|()
expr_stmt|;
name|PerClass
modifier|*
name|c
init|=
operator|&
name|per_class_
index|[
name|class_id
index|]
decl_stmt|;
name|TransferBatch
modifier|*
name|b
init|=
name|allocator
operator|->
name|AllocateBatch
argument_list|(
operator|&
name|stats_
argument_list|,
name|this
argument_list|,
name|class_id
argument_list|)
decl_stmt|;
name|CHECK_GT
argument_list|(
name|b
operator|->
name|Count
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|b
operator|->
name|CopyToArray
argument_list|(
name|c
operator|->
name|batch
argument_list|)
expr_stmt|;
name|c
operator|->
name|count
operator|=
name|b
operator|->
name|Count
argument_list|()
expr_stmt|;
name|DestroyBatch
argument_list|(
name|class_id
argument_list|,
name|allocator
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|NOINLINE
name|void
name|Drain
parameter_list|(
name|SizeClassAllocator
modifier|*
name|allocator
parameter_list|,
name|uptr
name|class_id
parameter_list|)
block|{
name|InitCache
argument_list|()
expr_stmt|;
name|PerClass
modifier|*
name|c
init|=
operator|&
name|per_class_
index|[
name|class_id
index|]
decl_stmt|;
name|uptr
name|cnt
init|=
name|Min
argument_list|(
name|c
operator|->
name|max_count
operator|/
literal|2
argument_list|,
name|c
operator|->
name|count
argument_list|)
decl_stmt|;
name|uptr
name|first_idx_to_drain
init|=
name|c
operator|->
name|count
operator|-
name|cnt
decl_stmt|;
name|TransferBatch
modifier|*
name|b
init|=
name|CreateBatch
argument_list|(
name|class_id
argument_list|,
name|allocator
argument_list|,
operator|(
name|TransferBatch
operator|*
operator|)
name|c
operator|->
name|batch
index|[
name|first_idx_to_drain
index|]
argument_list|)
decl_stmt|;
name|b
operator|->
name|SetFromArray
argument_list|(
name|allocator
operator|->
name|GetRegionBeginBySizeClass
argument_list|(
name|class_id
argument_list|)
argument_list|,
operator|&
name|c
operator|->
name|batch
index|[
name|first_idx_to_drain
index|]
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|c
operator|->
name|count
operator|-=
name|cnt
expr_stmt|;
name|allocator
operator|->
name|DeallocateBatch
argument_list|(
operator|&
name|stats_
argument_list|,
name|class_id
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
end_function

unit|};
end_unit

