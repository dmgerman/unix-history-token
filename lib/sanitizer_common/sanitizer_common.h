begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- sanitizer_common.h --------------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is shared between AddressSanitizer and ThreadSanitizer
end_comment

begin_comment
comment|// run-time libraries.
end_comment

begin_comment
comment|// It declares common functions and classes that are used in both runtimes.
end_comment

begin_comment
comment|// Implementation of some functions are provided in sanitizer_common, while
end_comment

begin_comment
comment|// others must be defined by run-time library itself.
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SANITIZER_COMMON_H
end_ifndef

begin_define
define|#
directive|define
name|SANITIZER_COMMON_H
end_define

begin_include
include|#
directive|include
file|"sanitizer_internal_defs.h"
end_include

begin_decl_stmt
name|namespace
name|__sanitizer
block|{
comment|// Constants.
specifier|const
name|uptr
name|kWordSize
init|=
name|SANITIZER_WORDSIZE
operator|/
literal|8
decl_stmt|;
specifier|const
name|uptr
name|kWordSizeInBits
init|=
literal|8
operator|*
name|kWordSize
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__powerpc__
argument_list|)
operator|||
name|defined
argument_list|(
name|__powerpc64__
argument_list|)
specifier|const
name|uptr
name|kCacheLineSize
init|=
literal|128
decl_stmt|;
else|#
directive|else
specifier|const
name|uptr
name|kCacheLineSize
init|=
literal|64
decl_stmt|;
endif|#
directive|endif
name|uptr
name|GetPageSize
parameter_list|()
function_decl|;
name|uptr
name|GetPageSizeCached
parameter_list|()
function_decl|;
name|uptr
name|GetMmapGranularity
parameter_list|()
function_decl|;
comment|// Threads
name|int
name|GetPid
parameter_list|()
function_decl|;
name|uptr
name|GetTid
parameter_list|()
function_decl|;
name|uptr
name|GetThreadSelf
parameter_list|()
function_decl|;
name|void
name|GetThreadStackTopAndBottom
parameter_list|(
name|bool
name|at_initialization
parameter_list|,
name|uptr
modifier|*
name|stack_top
parameter_list|,
name|uptr
modifier|*
name|stack_bottom
parameter_list|)
function_decl|;
comment|// Memory management
name|void
modifier|*
name|MmapOrDie
parameter_list|(
name|uptr
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|mem_type
parameter_list|)
function_decl|;
name|void
name|UnmapOrDie
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|uptr
name|size
parameter_list|)
function_decl|;
name|void
modifier|*
name|MmapFixedNoReserve
parameter_list|(
name|uptr
name|fixed_addr
parameter_list|,
name|uptr
name|size
parameter_list|)
function_decl|;
name|void
modifier|*
name|MmapFixedOrDie
parameter_list|(
name|uptr
name|fixed_addr
parameter_list|,
name|uptr
name|size
parameter_list|)
function_decl|;
name|void
modifier|*
name|Mprotect
parameter_list|(
name|uptr
name|fixed_addr
parameter_list|,
name|uptr
name|size
parameter_list|)
function_decl|;
comment|// Map aligned chunk of address space; size and alignment are powers of two.
name|void
modifier|*
name|MmapAlignedOrDie
parameter_list|(
name|uptr
name|size
parameter_list|,
name|uptr
name|alignment
parameter_list|,
specifier|const
name|char
modifier|*
name|mem_type
parameter_list|)
function_decl|;
comment|// Used to check if we can map shadow memory to a fixed location.
name|bool
name|MemoryRangeIsAvailable
parameter_list|(
name|uptr
name|range_start
parameter_list|,
name|uptr
name|range_end
parameter_list|)
function_decl|;
name|void
name|FlushUnneededShadowMemory
parameter_list|(
name|uptr
name|addr
parameter_list|,
name|uptr
name|size
parameter_list|)
function_decl|;
comment|// Internal allocator
name|void
modifier|*
name|InternalAlloc
parameter_list|(
name|uptr
name|size
parameter_list|)
function_decl|;
name|void
name|InternalFree
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
function_decl|;
comment|// InternalScopedBuffer can be used instead of large stack arrays to
comment|// keep frame size low.
comment|// FIXME: use InternalAlloc instead of MmapOrDie once
comment|// InternalAlloc is made libc-free.
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|InternalScopedBuffer
block|{
name|public
operator|:
name|explicit
name|InternalScopedBuffer
argument_list|(
argument|uptr cnt
argument_list|)
block|{
name|cnt_
operator|=
name|cnt
block|;
name|ptr_
operator|=
operator|(
name|T
operator|*
operator|)
name|MmapOrDie
argument_list|(
name|cnt
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|,
literal|"InternalScopedBuffer"
argument_list|)
block|;   }
operator|~
name|InternalScopedBuffer
argument_list|()
block|{
name|UnmapOrDie
argument_list|(
name|ptr_
argument_list|,
name|cnt_
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
block|;   }
name|T
operator|&
name|operator
index|[]
operator|(
name|uptr
name|i
operator|)
block|{
return|return
name|ptr_
index|[
name|i
index|]
return|;
block|}
name|T
operator|*
name|data
argument_list|()
block|{
return|return
name|ptr_
return|;
block|}
name|uptr
name|size
argument_list|()
block|{
return|return
name|cnt_
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
return|;
block|}
name|private
operator|:
name|T
operator|*
name|ptr_
block|;
name|uptr
name|cnt_
block|;
comment|// Disallow evil constructors.
name|InternalScopedBuffer
argument_list|(
specifier|const
name|InternalScopedBuffer
operator|&
argument_list|)
block|;
name|void
name|operator
operator|=
operator|(
specifier|const
name|InternalScopedBuffer
operator|&
operator|)
block|; }
expr_stmt|;
comment|// Simple low-level (mmap-based) allocator for internal use. Doesn't have
comment|// constructor, so all instances of LowLevelAllocator should be
comment|// linker initialized.
name|class
name|LowLevelAllocator
block|{
name|public
label|:
comment|// Requires an external lock.
name|void
modifier|*
name|Allocate
parameter_list|(
name|uptr
name|size
parameter_list|)
function_decl|;
name|private
label|:
name|char
modifier|*
name|allocated_end_
decl_stmt|;
name|char
modifier|*
name|allocated_current_
decl_stmt|;
block|}
empty_stmt|;
typedef|typedef
name|void
function_decl|(
modifier|*
name|LowLevelAllocateCallback
function_decl|)
parameter_list|(
name|uptr
name|ptr
parameter_list|,
name|uptr
name|size
parameter_list|)
function_decl|;
comment|// Allows to register tool-specific callbacks for LowLevelAllocator.
comment|// Passing NULL removes the callback.
name|void
name|SetLowLevelAllocateCallback
parameter_list|(
name|LowLevelAllocateCallback
name|callback
parameter_list|)
function_decl|;
comment|// IO
name|void
name|RawWrite
parameter_list|(
specifier|const
name|char
modifier|*
name|buffer
parameter_list|)
function_decl|;
name|bool
name|PrintsToTty
parameter_list|()
function_decl|;
name|void
name|Printf
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
name|void
name|Report
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
name|void
name|SetPrintfAndReportCallback
parameter_list|(
name|void
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
parameter_list|)
function_decl|;
comment|// Opens the file 'file_name" and reads up to 'max_len' bytes.
comment|// The resulting buffer is mmaped and stored in '*buff'.
comment|// The size of the mmaped region is stored in '*buff_size',
comment|// Returns the number of read bytes or 0 if file can not be opened.
name|uptr
name|ReadFileToBuffer
parameter_list|(
specifier|const
name|char
modifier|*
name|file_name
parameter_list|,
name|char
modifier|*
modifier|*
name|buff
parameter_list|,
name|uptr
modifier|*
name|buff_size
parameter_list|,
name|uptr
name|max_len
parameter_list|)
function_decl|;
comment|// Maps given file to virtual memory, and returns pointer to it
comment|// (or NULL if the mapping failes). Stores the size of mmaped region
comment|// in '*buff_size'.
name|void
modifier|*
name|MapFileToMemory
parameter_list|(
specifier|const
name|char
modifier|*
name|file_name
parameter_list|,
name|uptr
modifier|*
name|buff_size
parameter_list|)
function_decl|;
comment|// OS
name|void
name|DisableCoreDumper
parameter_list|()
function_decl|;
name|void
name|DumpProcessMap
parameter_list|()
function_decl|;
name|bool
name|FileExists
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
function_decl|;
specifier|const
name|char
modifier|*
name|GetEnv
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
specifier|const
name|char
modifier|*
name|GetPwd
parameter_list|()
function_decl|;
name|void
name|ReExec
parameter_list|()
function_decl|;
name|bool
name|StackSizeIsUnlimited
parameter_list|()
function_decl|;
name|void
name|SetStackSizeLimitInBytes
parameter_list|(
name|uptr
name|limit
parameter_list|)
function_decl|;
name|void
name|PrepareForSandboxing
parameter_list|()
function_decl|;
comment|// Other
name|void
name|SleepForSeconds
parameter_list|(
name|int
name|seconds
parameter_list|)
function_decl|;
name|void
name|SleepForMillis
parameter_list|(
name|int
name|millis
parameter_list|)
function_decl|;
name|int
name|Atexit
parameter_list|(
name|void
function_decl|(
modifier|*
name|function
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|)
function_decl|;
name|void
name|SortArray
parameter_list|(
name|uptr
modifier|*
name|array
parameter_list|,
name|uptr
name|size
parameter_list|)
function_decl|;
comment|// Exit
name|void
name|NORETURN
name|Abort
parameter_list|()
function_decl|;
name|void
name|NORETURN
name|Exit
parameter_list|(
name|int
name|exitcode
parameter_list|)
function_decl|;
name|void
name|NORETURN
name|Die
parameter_list|()
function_decl|;
name|void
name|NORETURN
name|SANITIZER_INTERFACE_ATTRIBUTE
name|CheckFailed
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|cond
parameter_list|,
name|u64
name|v1
parameter_list|,
name|u64
name|v2
parameter_list|)
function_decl|;
comment|// Set the name of the current thread to 'name', return true on succees.
comment|// The name may be truncated to a system-dependent limit.
name|bool
name|SanitizerSetThreadName
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
comment|// Get the name of the current thread (no more than max_len bytes),
comment|// return true on succees. name should have space for at least max_len+1 bytes.
name|bool
name|SanitizerGetThreadName
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|max_len
parameter_list|)
function_decl|;
comment|// Specific tools may override behavior of "Die" and "CheckFailed" functions
comment|// to do tool-specific job.
name|void
name|SetDieCallback
parameter_list|(
name|void
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|)
function_decl|;
typedef|typedef
name|void
function_decl|(
modifier|*
name|CheckFailedCallbackType
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|u64
parameter_list|,
name|u64
parameter_list|)
function_decl|;
name|void
name|SetCheckFailedCallback
parameter_list|(
name|CheckFailedCallbackType
name|callback
parameter_list|)
function_decl|;
comment|// Math
name|INLINE
name|bool
name|IsPowerOfTwo
parameter_list|(
name|uptr
name|x
parameter_list|)
block|{
return|return
operator|(
name|x
operator|&
operator|(
name|x
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
return|;
block|}
name|INLINE
name|uptr
name|RoundUpTo
parameter_list|(
name|uptr
name|size
parameter_list|,
name|uptr
name|boundary
parameter_list|)
block|{
name|CHECK
argument_list|(
name|IsPowerOfTwo
argument_list|(
name|boundary
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|size
operator|+
name|boundary
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|boundary
operator|-
literal|1
operator|)
return|;
block|}
name|INLINE
name|uptr
name|RoundDownTo
parameter_list|(
name|uptr
name|x
parameter_list|,
name|uptr
name|boundary
parameter_list|)
block|{
return|return
name|x
operator|&
operator|~
operator|(
name|boundary
operator|-
literal|1
operator|)
return|;
block|}
name|INLINE
name|bool
name|IsAligned
parameter_list|(
name|uptr
name|a
parameter_list|,
name|uptr
name|alignment
parameter_list|)
block|{
return|return
operator|(
name|a
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
return|;
block|}
comment|// Don't use std::min, std::max or std::swap, to minimize dependency
comment|// on libstdc++.
name|template
operator|<
name|class
name|T
operator|>
name|T
name|Min
argument_list|(
argument|T a
argument_list|,
argument|T b
argument_list|)
block|{
return|return
name|a
operator|<
name|b
operator|?
name|a
operator|:
name|b
return|;
block|}
name|template
operator|<
name|class
name|T
operator|>
name|T
name|Max
argument_list|(
argument|T a
argument_list|,
argument|T b
argument_list|)
block|{
return|return
name|a
operator|>
name|b
operator|?
name|a
operator|:
name|b
return|;
block|}
name|template
operator|<
name|class
name|T
operator|>
name|void
name|Swap
argument_list|(
argument|T& a
argument_list|,
argument|T& b
argument_list|)
block|{
name|T
name|tmp
operator|=
name|a
block|;
name|a
operator|=
name|b
block|;
name|b
operator|=
name|tmp
block|; }
comment|// Char handling
name|INLINE
name|bool
name|IsSpace
argument_list|(
argument|int c
argument_list|)
block|{
return|return
operator|(
name|c
operator|==
literal|' '
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\t'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\f'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\r'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\v'
operator|)
return|;
block|}
name|INLINE
name|bool
name|IsDigit
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
operator|(
name|c
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|'9'
operator|)
return|;
block|}
name|INLINE
name|int
name|ToLower
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
operator|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
operator|)
condition|?
operator|(
name|c
operator|+
literal|'a'
operator|-
literal|'A'
operator|)
else|:
name|c
return|;
block|}
if|#
directive|if
name|SANITIZER_WORDSIZE
operator|==
literal|64
define|#
directive|define
name|FIRST_32_SECOND_64
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(b)
else|#
directive|else
define|#
directive|define
name|FIRST_32_SECOND_64
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(a)
endif|#
directive|endif
block|}
end_decl_stmt

begin_comment
comment|// namespace __sanitizer
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// SANITIZER_COMMON_H
end_comment

end_unit

