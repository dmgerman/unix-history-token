begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- sanitizer_common.h --------------------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is shared between run-time libraries of sanitizers.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// It declares common functions and classes that are used in both runtimes.
end_comment

begin_comment
comment|// Implementation of some functions are provided in sanitizer_common, while
end_comment

begin_comment
comment|// others must be defined by run-time library itself.
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SANITIZER_COMMON_H
end_ifndef

begin_define
define|#
directive|define
name|SANITIZER_COMMON_H
end_define

begin_include
include|#
directive|include
file|"sanitizer_flags.h"
end_include

begin_include
include|#
directive|include
file|"sanitizer_interface_internal.h"
end_include

begin_include
include|#
directive|include
file|"sanitizer_internal_defs.h"
end_include

begin_include
include|#
directive|include
file|"sanitizer_libc.h"
end_include

begin_include
include|#
directive|include
file|"sanitizer_list.h"
end_include

begin_include
include|#
directive|include
file|"sanitizer_mutex.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__clang__
argument_list|)
end_if

begin_extern
extern|extern
literal|"C"
name|void
name|_ReadWriteBarrier
parameter_list|()
function_decl|;
end_extern

begin_pragma
pragma|#
directive|pragma
name|intrinsic
name|(
name|_ReadWriteBarrier
name|)
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|namespace
name|__sanitizer
block|{
struct_decl|struct
name|StackTrace
struct_decl|;
struct_decl|struct
name|AddressInfo
struct_decl|;
comment|// Constants.
specifier|const
name|uptr
name|kWordSize
init|=
name|SANITIZER_WORDSIZE
operator|/
literal|8
decl_stmt|;
specifier|const
name|uptr
name|kWordSizeInBits
init|=
literal|8
operator|*
name|kWordSize
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__powerpc__
argument_list|)
operator|||
name|defined
argument_list|(
name|__powerpc64__
argument_list|)
specifier|const
name|uptr
name|kCacheLineSize
init|=
literal|128
decl_stmt|;
else|#
directive|else
specifier|const
name|uptr
name|kCacheLineSize
init|=
literal|64
decl_stmt|;
endif|#
directive|endif
specifier|const
name|uptr
name|kMaxPathLength
init|=
literal|4096
decl_stmt|;
specifier|const
name|uptr
name|kMaxThreadStackSize
init|=
literal|1
operator|<<
literal|30
decl_stmt|;
comment|// 1Gb
specifier|static
specifier|const
name|uptr
name|kErrorMessageBufferSize
init|=
literal|1
operator|<<
literal|16
decl_stmt|;
comment|// Denotes fake PC values that come from JIT/JAVA/etc.
comment|// For such PC values __tsan_symbolize_external() will be called.
specifier|const
name|u64
name|kExternalPCBit
init|=
literal|1ULL
operator|<<
literal|60
decl_stmt|;
specifier|extern
specifier|const
name|char
modifier|*
name|SanitizerToolName
decl_stmt|;
comment|// Can be changed by the tool.
specifier|extern
name|atomic_uint32_t
name|current_verbosity
decl_stmt|;
name|INLINE
name|void
name|SetVerbosity
parameter_list|(
name|int
name|verbosity
parameter_list|)
block|{
name|atomic_store
argument_list|(
operator|&
name|current_verbosity
argument_list|,
name|verbosity
argument_list|,
name|memory_order_relaxed
argument_list|)
expr_stmt|;
block|}
name|INLINE
name|int
name|Verbosity
parameter_list|()
block|{
return|return
name|atomic_load
argument_list|(
operator|&
name|current_verbosity
argument_list|,
name|memory_order_relaxed
argument_list|)
return|;
block|}
name|uptr
name|GetPageSize
parameter_list|()
function_decl|;
specifier|extern
name|uptr
name|PageSizeCached
decl_stmt|;
name|INLINE
name|uptr
name|GetPageSizeCached
parameter_list|()
block|{
if|if
condition|(
operator|!
name|PageSizeCached
condition|)
name|PageSizeCached
operator|=
name|GetPageSize
argument_list|()
expr_stmt|;
return|return
name|PageSizeCached
return|;
block|}
name|uptr
name|GetMmapGranularity
parameter_list|()
function_decl|;
name|uptr
name|GetMaxVirtualAddress
parameter_list|()
function_decl|;
comment|// Threads
name|tid_t
name|GetTid
parameter_list|()
function_decl|;
name|uptr
name|GetThreadSelf
parameter_list|()
function_decl|;
name|void
name|GetThreadStackTopAndBottom
parameter_list|(
name|bool
name|at_initialization
parameter_list|,
name|uptr
modifier|*
name|stack_top
parameter_list|,
name|uptr
modifier|*
name|stack_bottom
parameter_list|)
function_decl|;
name|void
name|GetThreadStackAndTls
argument_list|(
name|bool
expr|main
argument_list|,
name|uptr
operator|*
name|stk_addr
argument_list|,
name|uptr
operator|*
name|stk_size
argument_list|,
name|uptr
operator|*
name|tls_addr
argument_list|,
name|uptr
operator|*
name|tls_size
argument_list|)
decl_stmt|;
comment|// Memory management
name|void
modifier|*
name|MmapOrDie
parameter_list|(
name|uptr
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|mem_type
parameter_list|,
name|bool
name|raw_report
init|=
name|false
parameter_list|)
function_decl|;
name|INLINE
name|void
modifier|*
name|MmapOrDieQuietly
parameter_list|(
name|uptr
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|mem_type
parameter_list|)
block|{
return|return
name|MmapOrDie
argument_list|(
name|size
argument_list|,
name|mem_type
argument_list|,
comment|/*raw_report*/
name|true
argument_list|)
return|;
block|}
name|void
name|UnmapOrDie
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|uptr
name|size
parameter_list|)
function_decl|;
name|void
modifier|*
name|MmapFixedNoReserve
parameter_list|(
name|uptr
name|fixed_addr
parameter_list|,
name|uptr
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|name
init|=
name|nullptr
parameter_list|)
function_decl|;
name|void
modifier|*
name|MmapNoReserveOrDie
parameter_list|(
name|uptr
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|mem_type
parameter_list|)
function_decl|;
name|void
modifier|*
name|MmapFixedOrDie
parameter_list|(
name|uptr
name|fixed_addr
parameter_list|,
name|uptr
name|size
parameter_list|)
function_decl|;
name|void
modifier|*
name|MmapFixedNoAccess
parameter_list|(
name|uptr
name|fixed_addr
parameter_list|,
name|uptr
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|name
init|=
name|nullptr
parameter_list|)
function_decl|;
name|void
modifier|*
name|MmapNoAccess
parameter_list|(
name|uptr
name|size
parameter_list|)
function_decl|;
comment|// Map aligned chunk of address space; size and alignment are powers of two.
name|void
modifier|*
name|MmapAlignedOrDie
parameter_list|(
name|uptr
name|size
parameter_list|,
name|uptr
name|alignment
parameter_list|,
specifier|const
name|char
modifier|*
name|mem_type
parameter_list|)
function_decl|;
comment|// Disallow access to a memory range.  Use MmapFixedNoAccess to allocate an
comment|// unaccessible memory.
name|bool
name|MprotectNoAccess
parameter_list|(
name|uptr
name|addr
parameter_list|,
name|uptr
name|size
parameter_list|)
function_decl|;
name|bool
name|MprotectReadOnly
parameter_list|(
name|uptr
name|addr
parameter_list|,
name|uptr
name|size
parameter_list|)
function_decl|;
comment|// Find an available address space.
name|uptr
name|FindAvailableMemoryRange
parameter_list|(
name|uptr
name|size
parameter_list|,
name|uptr
name|alignment
parameter_list|,
name|uptr
name|left_padding
parameter_list|)
function_decl|;
comment|// Used to check if we can map shadow memory to a fixed location.
name|bool
name|MemoryRangeIsAvailable
parameter_list|(
name|uptr
name|range_start
parameter_list|,
name|uptr
name|range_end
parameter_list|)
function_decl|;
comment|// Releases memory pages entirely within the [beg, end] address range. Noop if
comment|// the provided range does not contain at least one entire page.
name|void
name|ReleaseMemoryPagesToOS
parameter_list|(
name|uptr
name|beg
parameter_list|,
name|uptr
name|end
parameter_list|)
function_decl|;
name|void
name|IncreaseTotalMmap
parameter_list|(
name|uptr
name|size
parameter_list|)
function_decl|;
name|void
name|DecreaseTotalMmap
parameter_list|(
name|uptr
name|size
parameter_list|)
function_decl|;
name|uptr
name|GetRSS
parameter_list|()
function_decl|;
name|void
name|NoHugePagesInRegion
parameter_list|(
name|uptr
name|addr
parameter_list|,
name|uptr
name|length
parameter_list|)
function_decl|;
name|void
name|DontDumpShadowMemory
parameter_list|(
name|uptr
name|addr
parameter_list|,
name|uptr
name|length
parameter_list|)
function_decl|;
comment|// Check if the built VMA size matches the runtime one.
name|void
name|CheckVMASize
parameter_list|()
function_decl|;
name|void
name|RunMallocHooks
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|uptr
name|size
parameter_list|)
function_decl|;
name|void
name|RunFreeHooks
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
comment|// InternalScopedBuffer can be used instead of large stack arrays to
comment|// keep frame size low.
comment|// FIXME: use InternalAlloc instead of MmapOrDie once
comment|// InternalAlloc is made libc-free.
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|InternalScopedBuffer
block|{
name|public
operator|:
name|explicit
name|InternalScopedBuffer
argument_list|(
argument|uptr cnt
argument_list|)
block|{
name|cnt_
operator|=
name|cnt
block|;
name|ptr_
operator|=
operator|(
name|T
operator|*
operator|)
name|MmapOrDie
argument_list|(
name|cnt
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|,
literal|"InternalScopedBuffer"
argument_list|)
block|;   }
operator|~
name|InternalScopedBuffer
argument_list|()
block|{
name|UnmapOrDie
argument_list|(
name|ptr_
argument_list|,
name|cnt_
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
block|; }
name|T
operator|&
name|operator
index|[]
operator|(
name|uptr
name|i
operator|)
block|{
return|return
name|ptr_
index|[
name|i
index|]
return|;
block|}
name|T
operator|*
name|data
argument_list|()
block|{
return|return
name|ptr_
return|;
block|}
name|uptr
name|size
argument_list|()
block|{
return|return
name|cnt_
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
return|;
block|}
name|private
operator|:
name|T
operator|*
name|ptr_
block|;
name|uptr
name|cnt_
block|;
comment|// Disallow copies and moves.
name|InternalScopedBuffer
argument_list|(
specifier|const
name|InternalScopedBuffer
operator|&
argument_list|)
operator|=
name|delete
block|;
name|InternalScopedBuffer
operator|&
name|operator
operator|=
operator|(
specifier|const
name|InternalScopedBuffer
operator|&
operator|)
operator|=
name|delete
block|;
name|InternalScopedBuffer
argument_list|(
name|InternalScopedBuffer
operator|&&
argument_list|)
operator|=
name|delete
block|;
name|InternalScopedBuffer
operator|&
name|operator
operator|=
operator|(
name|InternalScopedBuffer
operator|&&
operator|)
operator|=
name|delete
block|; }
expr_stmt|;
name|class
name|InternalScopedString
range|:
name|public
name|InternalScopedBuffer
operator|<
name|char
operator|>
block|{
name|public
operator|:
name|explicit
name|InternalScopedString
argument_list|(
argument|uptr max_length
argument_list|)
operator|:
name|InternalScopedBuffer
operator|<
name|char
operator|>
operator|(
name|max_length
operator|)
block|,
name|length_
argument_list|(
literal|0
argument_list|)
block|{
operator|(
operator|*
name|this
operator|)
index|[
literal|0
index|]
operator|=
literal|'\0'
block|;   }
name|uptr
name|length
argument_list|()
block|{
return|return
name|length_
return|;
block|}
name|void
name|clear
argument_list|()
block|{
operator|(
operator|*
name|this
operator|)
index|[
literal|0
index|]
operator|=
literal|'\0'
block|;
name|length_
operator|=
literal|0
block|;   }
name|void
name|append
argument_list|(
specifier|const
name|char
operator|*
name|format
argument_list|,
operator|...
argument_list|)
block|;
name|private
operator|:
name|uptr
name|length_
block|; }
decl_stmt|;
comment|// Simple low-level (mmap-based) allocator for internal use. Doesn't have
comment|// constructor, so all instances of LowLevelAllocator should be
comment|// linker initialized.
name|class
name|LowLevelAllocator
block|{
name|public
label|:
comment|// Requires an external lock.
name|void
modifier|*
name|Allocate
parameter_list|(
name|uptr
name|size
parameter_list|)
function_decl|;
name|private
label|:
name|char
modifier|*
name|allocated_end_
decl_stmt|;
name|char
modifier|*
name|allocated_current_
decl_stmt|;
block|}
empty_stmt|;
typedef|typedef
name|void
function_decl|(
modifier|*
name|LowLevelAllocateCallback
function_decl|)
parameter_list|(
name|uptr
name|ptr
parameter_list|,
name|uptr
name|size
parameter_list|)
function_decl|;
comment|// Allows to register tool-specific callbacks for LowLevelAllocator.
comment|// Passing NULL removes the callback.
name|void
name|SetLowLevelAllocateCallback
parameter_list|(
name|LowLevelAllocateCallback
name|callback
parameter_list|)
function_decl|;
comment|// IO
name|void
name|RawWrite
parameter_list|(
specifier|const
name|char
modifier|*
name|buffer
parameter_list|)
function_decl|;
name|bool
name|ColorizeReports
parameter_list|()
function_decl|;
name|void
name|RemoveANSIEscapeSequencesFromString
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|)
function_decl|;
name|void
name|Printf
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
name|void
name|Report
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
name|void
name|SetPrintfAndReportCallback
parameter_list|(
name|void
function_decl|(
modifier|*
name|callback
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
parameter_list|)
function_decl|;
define|#
directive|define
name|VReport
parameter_list|(
name|level
parameter_list|,
modifier|...
parameter_list|)
define|\
value|do {                                                                   \     if ((uptr)Verbosity()>= (level)) Report(__VA_ARGS__); \   } while (0)
define|#
directive|define
name|VPrintf
parameter_list|(
name|level
parameter_list|,
modifier|...
parameter_list|)
define|\
value|do {                                                                   \     if ((uptr)Verbosity()>= (level)) Printf(__VA_ARGS__); \   } while (0)
comment|// Can be used to prevent mixing error reports from different sanitizers.
specifier|extern
name|StaticSpinMutex
name|CommonSanitizerReportMutex
decl_stmt|;
struct|struct
name|ReportFile
block|{
name|void
name|Write
parameter_list|(
specifier|const
name|char
modifier|*
name|buffer
parameter_list|,
name|uptr
name|length
parameter_list|)
function_decl|;
name|bool
name|SupportsColors
parameter_list|()
function_decl|;
name|void
name|SetReportPath
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
function_decl|;
comment|// Don't use fields directly. They are only declared public to allow
comment|// aggregate initialization.
comment|// Protects fields below.
name|StaticSpinMutex
modifier|*
name|mu
decl_stmt|;
comment|// Opened file descriptor. Defaults to stderr. It may be equal to
comment|// kInvalidFd, in which case new file will be opened when necessary.
name|fd_t
name|fd
decl_stmt|;
comment|// Path prefix of report file, set via __sanitizer_set_report_path.
name|char
name|path_prefix
index|[
name|kMaxPathLength
index|]
decl_stmt|;
comment|// Full path to report, obtained as<path_prefix>.PID
name|char
name|full_path
index|[
name|kMaxPathLength
index|]
decl_stmt|;
comment|// PID of the process that opened fd. If a fork() occurs,
comment|// the PID of child will be different from fd_pid.
name|uptr
name|fd_pid
decl_stmt|;
name|private
label|:
name|void
name|ReopenIfNecessary
parameter_list|()
function_decl|;
block|}
struct|;
specifier|extern
name|ReportFile
name|report_file
decl_stmt|;
specifier|extern
name|uptr
name|stoptheworld_tracer_pid
decl_stmt|;
specifier|extern
name|uptr
name|stoptheworld_tracer_ppid
decl_stmt|;
enum|enum
name|FileAccessMode
block|{
name|RdOnly
block|,
name|WrOnly
block|,
name|RdWr
block|}
enum|;
comment|// Returns kInvalidFd on error.
name|fd_t
name|OpenFile
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|FileAccessMode
name|mode
parameter_list|,
name|error_t
modifier|*
name|errno_p
init|=
name|nullptr
parameter_list|)
function_decl|;
name|void
name|CloseFile
parameter_list|(
name|fd_t
parameter_list|)
function_decl|;
comment|// Return true on success, false on error.
name|bool
name|ReadFromFile
parameter_list|(
name|fd_t
name|fd
parameter_list|,
name|void
modifier|*
name|buff
parameter_list|,
name|uptr
name|buff_size
parameter_list|,
name|uptr
modifier|*
name|bytes_read
init|=
name|nullptr
parameter_list|,
name|error_t
modifier|*
name|error_p
init|=
name|nullptr
parameter_list|)
function_decl|;
name|bool
name|WriteToFile
parameter_list|(
name|fd_t
name|fd
parameter_list|,
specifier|const
name|void
modifier|*
name|buff
parameter_list|,
name|uptr
name|buff_size
parameter_list|,
name|uptr
modifier|*
name|bytes_written
init|=
name|nullptr
parameter_list|,
name|error_t
modifier|*
name|error_p
init|=
name|nullptr
parameter_list|)
function_decl|;
name|bool
name|RenameFile
parameter_list|(
specifier|const
name|char
modifier|*
name|oldpath
parameter_list|,
specifier|const
name|char
modifier|*
name|newpath
parameter_list|,
name|error_t
modifier|*
name|error_p
init|=
name|nullptr
parameter_list|)
function_decl|;
comment|// Scoped file handle closer.
struct|struct
name|FileCloser
block|{
name|explicit
name|FileCloser
argument_list|(
argument|fd_t fd
argument_list|)
block|:
name|fd
argument_list|(
argument|fd
argument_list|)
block|{}
operator|~
name|FileCloser
argument_list|()
block|{
name|CloseFile
argument_list|(
name|fd
argument_list|)
block|; }
name|fd_t
name|fd
expr_stmt|;
block|}
struct|;
name|bool
name|SupportsColoredOutput
parameter_list|(
name|fd_t
name|fd
parameter_list|)
function_decl|;
comment|// Opens the file 'file_name" and reads up to 'max_len' bytes.
comment|// The resulting buffer is mmaped and stored in '*buff'.
comment|// The size of the mmaped region is stored in '*buff_size'.
comment|// The total number of read bytes is stored in '*read_len'.
comment|// Returns true if file was successfully opened and read.
name|bool
name|ReadFileToBuffer
parameter_list|(
specifier|const
name|char
modifier|*
name|file_name
parameter_list|,
name|char
modifier|*
modifier|*
name|buff
parameter_list|,
name|uptr
modifier|*
name|buff_size
parameter_list|,
name|uptr
modifier|*
name|read_len
parameter_list|,
name|uptr
name|max_len
init|=
literal|1
operator|<<
literal|26
parameter_list|,
name|error_t
modifier|*
name|errno_p
init|=
name|nullptr
parameter_list|)
function_decl|;
comment|// Maps given file to virtual memory, and returns pointer to it
comment|// (or NULL if mapping fails). Stores the size of mmaped region
comment|// in '*buff_size'.
name|void
modifier|*
name|MapFileToMemory
parameter_list|(
specifier|const
name|char
modifier|*
name|file_name
parameter_list|,
name|uptr
modifier|*
name|buff_size
parameter_list|)
function_decl|;
name|void
modifier|*
name|MapWritableFileToMemory
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|uptr
name|size
parameter_list|,
name|fd_t
name|fd
parameter_list|,
name|OFF_T
name|offset
parameter_list|)
function_decl|;
name|bool
name|IsAccessibleMemoryRange
parameter_list|(
name|uptr
name|beg
parameter_list|,
name|uptr
name|size
parameter_list|)
function_decl|;
comment|// Error report formatting.
specifier|const
name|char
modifier|*
name|StripPathPrefix
parameter_list|(
specifier|const
name|char
modifier|*
name|filepath
parameter_list|,
specifier|const
name|char
modifier|*
name|strip_file_prefix
parameter_list|)
function_decl|;
comment|// Strip the directories from the module name.
specifier|const
name|char
modifier|*
name|StripModuleName
parameter_list|(
specifier|const
name|char
modifier|*
name|module
parameter_list|)
function_decl|;
comment|// OS
name|uptr
name|ReadBinaryName
parameter_list|(
comment|/*out*/
name|char
modifier|*
name|buf
parameter_list|,
name|uptr
name|buf_len
parameter_list|)
function_decl|;
name|uptr
name|ReadBinaryNameCached
parameter_list|(
comment|/*out*/
name|char
modifier|*
name|buf
parameter_list|,
name|uptr
name|buf_len
parameter_list|)
function_decl|;
name|uptr
name|ReadLongProcessName
parameter_list|(
comment|/*out*/
name|char
modifier|*
name|buf
parameter_list|,
name|uptr
name|buf_len
parameter_list|)
function_decl|;
specifier|const
name|char
modifier|*
name|GetProcessName
parameter_list|()
function_decl|;
name|void
name|UpdateProcessName
parameter_list|()
function_decl|;
name|void
name|CacheBinaryName
parameter_list|()
function_decl|;
name|void
name|DisableCoreDumperIfNecessary
parameter_list|()
function_decl|;
name|void
name|DumpProcessMap
parameter_list|()
function_decl|;
name|void
name|PrintModuleMap
parameter_list|()
function_decl|;
name|bool
name|FileExists
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
function_decl|;
specifier|const
name|char
modifier|*
name|GetEnv
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
name|bool
name|SetEnv
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
function_decl|;
specifier|const
name|char
modifier|*
name|GetPwd
parameter_list|()
function_decl|;
name|char
modifier|*
name|FindPathToBinary
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
name|bool
name|IsPathSeparator
parameter_list|(
specifier|const
name|char
name|c
parameter_list|)
function_decl|;
name|bool
name|IsAbsolutePath
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
function_decl|;
comment|// Starts a subprocess and returs its pid.
comment|// If *_fd parameters are not kInvalidFd their corresponding input/output
comment|// streams will be redirect to the file. The files will always be closed
comment|// in parent process even in case of an error.
comment|// The child process will close all fds after STDERR_FILENO
comment|// before passing control to a program.
name|pid_t
name|StartSubprocess
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
name|argv
index|[]
parameter_list|,
name|fd_t
name|stdin_fd
init|=
name|kInvalidFd
parameter_list|,
name|fd_t
name|stdout_fd
init|=
name|kInvalidFd
parameter_list|,
name|fd_t
name|stderr_fd
init|=
name|kInvalidFd
parameter_list|)
function_decl|;
comment|// Checks if specified process is still running
name|bool
name|IsProcessRunning
parameter_list|(
name|pid_t
name|pid
parameter_list|)
function_decl|;
comment|// Waits for the process to finish and returns its exit code.
comment|// Returns -1 in case of an error.
name|int
name|WaitForProcess
parameter_list|(
name|pid_t
name|pid
parameter_list|)
function_decl|;
name|u32
name|GetUid
parameter_list|()
function_decl|;
name|void
name|ReExec
parameter_list|()
function_decl|;
name|char
modifier|*
modifier|*
name|GetArgv
parameter_list|()
function_decl|;
name|void
name|PrintCmdline
parameter_list|()
function_decl|;
name|bool
name|StackSizeIsUnlimited
parameter_list|()
function_decl|;
name|uptr
name|GetStackSizeLimitInBytes
parameter_list|()
function_decl|;
name|void
name|SetStackSizeLimitInBytes
parameter_list|(
name|uptr
name|limit
parameter_list|)
function_decl|;
name|bool
name|AddressSpaceIsUnlimited
parameter_list|()
function_decl|;
name|void
name|SetAddressSpaceUnlimited
parameter_list|()
function_decl|;
name|void
name|AdjustStackSize
parameter_list|(
name|void
modifier|*
name|attr
parameter_list|)
function_decl|;
name|void
name|PrepareForSandboxing
parameter_list|(
name|__sanitizer_sandbox_arguments
modifier|*
name|args
parameter_list|)
function_decl|;
name|void
name|CovPrepareForSandboxing
parameter_list|(
name|__sanitizer_sandbox_arguments
modifier|*
name|args
parameter_list|)
function_decl|;
name|void
name|SetSandboxingCallback
parameter_list|(
name|void
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|()
parameter_list|)
function_decl|;
name|void
name|CoverageUpdateMapping
parameter_list|()
function_decl|;
name|void
name|CovBeforeFork
parameter_list|()
function_decl|;
name|void
name|CovAfterFork
parameter_list|(
name|int
name|child_pid
parameter_list|)
function_decl|;
name|void
name|InitializeCoverage
parameter_list|(
name|bool
name|enabled
parameter_list|,
specifier|const
name|char
modifier|*
name|coverage_dir
parameter_list|)
function_decl|;
name|void
name|ReInitializeCoverage
parameter_list|(
name|bool
name|enabled
parameter_list|,
specifier|const
name|char
modifier|*
name|coverage_dir
parameter_list|)
function_decl|;
name|void
name|InitTlsSize
parameter_list|()
function_decl|;
name|uptr
name|GetTlsSize
parameter_list|()
function_decl|;
comment|// Other
name|void
name|SleepForSeconds
parameter_list|(
name|int
name|seconds
parameter_list|)
function_decl|;
name|void
name|SleepForMillis
parameter_list|(
name|int
name|millis
parameter_list|)
function_decl|;
name|u64
name|NanoTime
parameter_list|()
function_decl|;
name|int
name|Atexit
parameter_list|(
name|void
function_decl|(
modifier|*
name|function
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|)
function_decl|;
name|void
name|SortArray
parameter_list|(
name|uptr
modifier|*
name|array
parameter_list|,
name|uptr
name|size
parameter_list|)
function_decl|;
name|void
name|SortArray
parameter_list|(
name|u32
modifier|*
name|array
parameter_list|,
name|uptr
name|size
parameter_list|)
function_decl|;
name|bool
name|TemplateMatch
parameter_list|(
specifier|const
name|char
modifier|*
name|templ
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
function_decl|;
comment|// Exit
name|void
name|NORETURN
name|Abort
parameter_list|()
function_decl|;
name|void
name|NORETURN
name|Die
parameter_list|()
function_decl|;
name|void
name|NORETURN
name|CheckFailed
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|cond
parameter_list|,
name|u64
name|v1
parameter_list|,
name|u64
name|v2
parameter_list|)
function_decl|;
name|void
name|NORETURN
name|ReportMmapFailureAndDie
parameter_list|(
name|uptr
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|mem_type
parameter_list|,
specifier|const
name|char
modifier|*
name|mmap_type
parameter_list|,
name|error_t
name|err
parameter_list|,
name|bool
name|raw_report
init|=
name|false
parameter_list|)
function_decl|;
comment|// Set the name of the current thread to 'name', return true on succees.
comment|// The name may be truncated to a system-dependent limit.
name|bool
name|SanitizerSetThreadName
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
comment|// Get the name of the current thread (no more than max_len bytes),
comment|// return true on succees. name should have space for at least max_len+1 bytes.
name|bool
name|SanitizerGetThreadName
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|max_len
parameter_list|)
function_decl|;
comment|// Specific tools may override behavior of "Die" and "CheckFailed" functions
comment|// to do tool-specific job.
typedef|typedef
name|void
function_decl|(
modifier|*
name|DieCallbackType
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|// It's possible to add several callbacks that would be run when "Die" is
comment|// called. The callbacks will be run in the opposite order. The tools are
comment|// strongly recommended to setup all callbacks during initialization, when there
comment|// is only a single thread.
name|bool
name|AddDieCallback
parameter_list|(
name|DieCallbackType
name|callback
parameter_list|)
function_decl|;
name|bool
name|RemoveDieCallback
parameter_list|(
name|DieCallbackType
name|callback
parameter_list|)
function_decl|;
name|void
name|SetUserDieCallback
parameter_list|(
name|DieCallbackType
name|callback
parameter_list|)
function_decl|;
typedef|typedef
name|void
function_decl|(
modifier|*
name|CheckFailedCallbackType
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|u64
parameter_list|,
name|u64
parameter_list|)
function_decl|;
name|void
name|SetCheckFailedCallback
parameter_list|(
name|CheckFailedCallbackType
name|callback
parameter_list|)
function_decl|;
comment|// Callback will be called if soft_rss_limit_mb is given and the limit is
comment|// exceeded (exceeded==true) or if rss went down below the limit
comment|// (exceeded==false).
comment|// The callback should be registered once at the tool init time.
name|void
name|SetSoftRssLimitExceededCallback
parameter_list|(
name|void
function_decl|(
modifier|*
name|Callback
function_decl|)
parameter_list|(
name|bool
name|exceeded
parameter_list|)
parameter_list|)
function_decl|;
comment|// Functions related to signal handling.
typedef|typedef
name|void
function_decl|(
modifier|*
name|SignalHandlerType
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|bool
name|IsHandledDeadlySignal
parameter_list|(
name|int
name|signum
parameter_list|)
function_decl|;
name|void
name|InstallDeadlySignalHandlers
parameter_list|(
name|SignalHandlerType
name|handler
parameter_list|)
function_decl|;
specifier|const
name|char
modifier|*
name|DescribeSignalOrException
parameter_list|(
name|int
name|signo
parameter_list|)
function_decl|;
comment|// Alternative signal stack (POSIX-only).
name|void
name|SetAlternateSignalStack
parameter_list|()
function_decl|;
name|void
name|UnsetAlternateSignalStack
parameter_list|()
function_decl|;
comment|// We don't want a summary too long.
specifier|const
name|int
name|kMaxSummaryLength
init|=
literal|1024
decl_stmt|;
comment|// Construct a one-line string:
comment|//   SUMMARY: SanitizerToolName: error_message
comment|// and pass it to __sanitizer_report_error_summary.
comment|// If alt_tool_name is provided, it's used in place of SanitizerToolName.
name|void
name|ReportErrorSummary
parameter_list|(
specifier|const
name|char
modifier|*
name|error_message
parameter_list|,
specifier|const
name|char
modifier|*
name|alt_tool_name
init|=
name|nullptr
parameter_list|)
function_decl|;
comment|// Same as above, but construct error_message as:
comment|//   error_type file:line[:column][ function]
name|void
name|ReportErrorSummary
parameter_list|(
specifier|const
name|char
modifier|*
name|error_type
parameter_list|,
specifier|const
name|AddressInfo
modifier|&
name|info
parameter_list|,
specifier|const
name|char
modifier|*
name|alt_tool_name
init|=
name|nullptr
parameter_list|)
function_decl|;
comment|// Same as above, but obtains AddressInfo by symbolizing top stack trace frame.
name|void
name|ReportErrorSummary
parameter_list|(
specifier|const
name|char
modifier|*
name|error_type
parameter_list|,
specifier|const
name|StackTrace
modifier|*
name|trace
parameter_list|,
specifier|const
name|char
modifier|*
name|alt_tool_name
init|=
name|nullptr
parameter_list|)
function_decl|;
comment|// Math
if|#
directive|if
name|SANITIZER_WINDOWS
operator|&&
operator|!
name|defined
argument_list|(
name|__clang__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__GNUC__
argument_list|)
extern|extern
literal|"C"
block|{
name|unsigned
name|char
name|_BitScanForward
parameter_list|(
name|unsigned
name|long
modifier|*
name|index
parameter_list|,
name|unsigned
name|long
name|mask
parameter_list|)
function_decl|;
comment|// NOLINT
name|unsigned
name|char
name|_BitScanReverse
parameter_list|(
name|unsigned
name|long
modifier|*
name|index
parameter_list|,
name|unsigned
name|long
name|mask
parameter_list|)
function_decl|;
comment|// NOLINT
if|#
directive|if
name|defined
argument_list|(
name|_WIN64
argument_list|)
name|unsigned
name|char
name|_BitScanForward64
parameter_list|(
name|unsigned
name|long
modifier|*
name|index
parameter_list|,
name|unsigned
name|__int64
name|mask
parameter_list|)
function_decl|;
comment|// NOLINT
name|unsigned
name|char
name|_BitScanReverse64
parameter_list|(
name|unsigned
name|long
modifier|*
name|index
parameter_list|,
name|unsigned
name|__int64
name|mask
parameter_list|)
function_decl|;
comment|// NOLINT
endif|#
directive|endif
block|}
endif|#
directive|endif
name|INLINE
name|uptr
name|MostSignificantSetBitIndex
parameter_list|(
name|uptr
name|x
parameter_list|)
block|{
name|CHECK_NE
argument_list|(
name|x
argument_list|,
literal|0U
argument_list|)
expr_stmt|;
name|unsigned
name|long
name|up
decl_stmt|;
comment|// NOLINT
if|#
directive|if
operator|!
name|SANITIZER_WINDOWS
operator|||
name|defined
argument_list|(
name|__clang__
argument_list|)
operator|||
name|defined
argument_list|(
name|__GNUC__
argument_list|)
ifdef|#
directive|ifdef
name|_WIN64
name|up
operator|=
name|SANITIZER_WORDSIZE
operator|-
literal|1
operator|-
name|__builtin_clzll
argument_list|(
name|x
argument_list|)
expr_stmt|;
else|#
directive|else
name|up
operator|=
name|SANITIZER_WORDSIZE
operator|-
literal|1
operator|-
name|__builtin_clzl
argument_list|(
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
elif|#
directive|elif
name|defined
argument_list|(
name|_WIN64
argument_list|)
name|_BitScanReverse64
argument_list|(
operator|&
name|up
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|#
directive|else
name|_BitScanReverse
argument_list|(
operator|&
name|up
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|up
return|;
block|}
name|INLINE
name|uptr
name|LeastSignificantSetBitIndex
parameter_list|(
name|uptr
name|x
parameter_list|)
block|{
name|CHECK_NE
argument_list|(
name|x
argument_list|,
literal|0U
argument_list|)
expr_stmt|;
name|unsigned
name|long
name|up
decl_stmt|;
comment|// NOLINT
if|#
directive|if
operator|!
name|SANITIZER_WINDOWS
operator|||
name|defined
argument_list|(
name|__clang__
argument_list|)
operator|||
name|defined
argument_list|(
name|__GNUC__
argument_list|)
ifdef|#
directive|ifdef
name|_WIN64
name|up
operator|=
name|__builtin_ctzll
argument_list|(
name|x
argument_list|)
expr_stmt|;
else|#
directive|else
name|up
operator|=
name|__builtin_ctzl
argument_list|(
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
elif|#
directive|elif
name|defined
argument_list|(
name|_WIN64
argument_list|)
name|_BitScanForward64
argument_list|(
operator|&
name|up
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|#
directive|else
name|_BitScanForward
argument_list|(
operator|&
name|up
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|up
return|;
block|}
name|INLINE
name|bool
name|IsPowerOfTwo
parameter_list|(
name|uptr
name|x
parameter_list|)
block|{
return|return
operator|(
name|x
operator|&
operator|(
name|x
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
return|;
block|}
name|INLINE
name|uptr
name|RoundUpToPowerOfTwo
parameter_list|(
name|uptr
name|size
parameter_list|)
block|{
name|CHECK
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|IsPowerOfTwo
argument_list|(
name|size
argument_list|)
condition|)
return|return
name|size
return|;
name|uptr
name|up
init|=
name|MostSignificantSetBitIndex
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|CHECK_LT
argument_list|(
name|size
argument_list|,
operator|(
literal|1ULL
operator|<<
operator|(
name|up
operator|+
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
name|CHECK_GT
argument_list|(
name|size
argument_list|,
operator|(
literal|1ULL
operator|<<
name|up
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1ULL
operator|<<
operator|(
name|up
operator|+
literal|1
operator|)
return|;
block|}
name|INLINE
name|uptr
name|RoundUpTo
parameter_list|(
name|uptr
name|size
parameter_list|,
name|uptr
name|boundary
parameter_list|)
block|{
name|RAW_CHECK
argument_list|(
name|IsPowerOfTwo
argument_list|(
name|boundary
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|size
operator|+
name|boundary
operator|-
literal|1
operator|)
operator|&
operator|~
operator|(
name|boundary
operator|-
literal|1
operator|)
return|;
block|}
name|INLINE
name|uptr
name|RoundDownTo
parameter_list|(
name|uptr
name|x
parameter_list|,
name|uptr
name|boundary
parameter_list|)
block|{
return|return
name|x
operator|&
operator|~
operator|(
name|boundary
operator|-
literal|1
operator|)
return|;
block|}
name|INLINE
name|bool
name|IsAligned
parameter_list|(
name|uptr
name|a
parameter_list|,
name|uptr
name|alignment
parameter_list|)
block|{
return|return
operator|(
name|a
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
return|;
block|}
name|INLINE
name|uptr
name|Log2
parameter_list|(
name|uptr
name|x
parameter_list|)
block|{
name|CHECK
argument_list|(
name|IsPowerOfTwo
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|LeastSignificantSetBitIndex
argument_list|(
name|x
argument_list|)
return|;
block|}
comment|// Don't use std::min, std::max or std::swap, to minimize dependency
comment|// on libstdc++.
name|template
operator|<
name|class
name|T
operator|>
name|T
name|Min
argument_list|(
argument|T a
argument_list|,
argument|T b
argument_list|)
block|{
return|return
name|a
operator|<
name|b
operator|?
name|a
operator|:
name|b
return|;
block|}
name|template
operator|<
name|class
name|T
operator|>
name|T
name|Max
argument_list|(
argument|T a
argument_list|,
argument|T b
argument_list|)
block|{
return|return
name|a
operator|>
name|b
operator|?
name|a
operator|:
name|b
return|;
block|}
name|template
operator|<
name|class
name|T
operator|>
name|void
name|Swap
argument_list|(
argument|T& a
argument_list|,
argument|T& b
argument_list|)
block|{
name|T
name|tmp
operator|=
name|a
block|;
name|a
operator|=
name|b
block|;
name|b
operator|=
name|tmp
block|; }
comment|// Char handling
name|INLINE
name|bool
name|IsSpace
argument_list|(
argument|int c
argument_list|)
block|{
return|return
operator|(
name|c
operator|==
literal|' '
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\n'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\t'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\f'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\r'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'\v'
operator|)
return|;
block|}
name|INLINE
name|bool
name|IsDigit
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
operator|(
name|c
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|'9'
operator|)
return|;
block|}
name|INLINE
name|int
name|ToLower
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
operator|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
operator|)
condition|?
operator|(
name|c
operator|+
literal|'a'
operator|-
literal|'A'
operator|)
else|:
name|c
return|;
block|}
comment|// A low-level vector based on mmap. May incur a significant memory overhead for
comment|// small vectors.
comment|// WARNING: The current implementation supports only POD types.
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|InternalMmapVectorNoCtor
block|{
name|public
operator|:
name|void
name|Initialize
argument_list|(
argument|uptr initial_capacity
argument_list|)
block|{
name|capacity_
operator|=
name|Max
argument_list|(
name|initial_capacity
argument_list|,
operator|(
name|uptr
operator|)
literal|1
argument_list|)
block|;
name|size_
operator|=
literal|0
block|;
name|data_
operator|=
operator|(
name|T
operator|*
operator|)
name|MmapOrDie
argument_list|(
name|capacity_
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|,
literal|"InternalMmapVectorNoCtor"
argument_list|)
block|;   }
name|void
name|Destroy
argument_list|()
block|{
name|UnmapOrDie
argument_list|(
name|data_
argument_list|,
name|capacity_
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
block|;   }
name|T
operator|&
name|operator
index|[]
operator|(
name|uptr
name|i
operator|)
block|{
name|CHECK_LT
argument_list|(
name|i
argument_list|,
name|size_
argument_list|)
block|;
return|return
name|data_
index|[
name|i
index|]
return|;
block|}
specifier|const
name|T
operator|&
name|operator
index|[]
operator|(
name|uptr
name|i
operator|)
specifier|const
block|{
name|CHECK_LT
argument_list|(
name|i
argument_list|,
name|size_
argument_list|)
block|;
return|return
name|data_
index|[
name|i
index|]
return|;
block|}
name|void
name|push_back
argument_list|(
argument|const T&element
argument_list|)
block|{
name|CHECK_LE
argument_list|(
name|size_
argument_list|,
name|capacity_
argument_list|)
block|;
if|if
condition|(
name|size_
operator|==
name|capacity_
condition|)
block|{
name|uptr
name|new_capacity
init|=
name|RoundUpToPowerOfTwo
argument_list|(
name|size_
operator|+
literal|1
argument_list|)
decl_stmt|;
name|Resize
argument_list|(
name|new_capacity
argument_list|)
expr_stmt|;
block|}
name|internal_memcpy
argument_list|(
operator|&
name|data_
index|[
name|size_
operator|++
index|]
argument_list|,
operator|&
name|element
argument_list|,
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|T
operator|&
name|back
argument_list|()
block|{
name|CHECK_GT
argument_list|(
name|size_
argument_list|,
literal|0
argument_list|)
block|;
return|return
name|data_
index|[
name|size_
operator|-
literal|1
index|]
return|;
block|}
name|void
name|pop_back
argument_list|()
block|{
name|CHECK_GT
argument_list|(
name|size_
argument_list|,
literal|0
argument_list|)
block|;
name|size_
operator|--
block|;   }
name|uptr
name|size
argument_list|()
specifier|const
block|{
return|return
name|size_
return|;
block|}
specifier|const
name|T
operator|*
name|data
argument_list|()
specifier|const
block|{
return|return
name|data_
return|;
block|}
name|T
operator|*
name|data
argument_list|()
block|{
return|return
name|data_
return|;
block|}
name|uptr
name|capacity
argument_list|()
specifier|const
block|{
return|return
name|capacity_
return|;
block|}
name|void
name|resize
argument_list|(
argument|uptr new_size
argument_list|)
block|{
name|Resize
argument_list|(
name|new_size
argument_list|)
block|;
if|if
condition|(
name|new_size
operator|>
name|size_
condition|)
block|{
name|internal_memset
argument_list|(
operator|&
name|data_
index|[
name|size_
index|]
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|T
argument_list|)
operator|*
operator|(
name|new_size
operator|-
name|size_
operator|)
argument_list|)
expr_stmt|;
block|}
name|size_
operator|=
name|new_size
expr_stmt|;
block|}
name|void
name|clear
argument_list|()
block|{
name|size_
operator|=
literal|0
block|; }
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|size
argument_list|()
operator|==
literal|0
return|;
block|}
specifier|const
name|T
operator|*
name|begin
argument_list|()
specifier|const
block|{
return|return
name|data
argument_list|()
return|;
block|}
name|T
operator|*
name|begin
argument_list|()
block|{
return|return
name|data
argument_list|()
return|;
block|}
specifier|const
name|T
operator|*
name|end
argument_list|()
specifier|const
block|{
return|return
name|data
argument_list|()
operator|+
name|size
argument_list|()
return|;
block|}
name|T
operator|*
name|end
argument_list|()
block|{
return|return
name|data
argument_list|()
operator|+
name|size
argument_list|()
return|;
block|}
name|private
operator|:
name|void
name|Resize
argument_list|(
argument|uptr new_capacity
argument_list|)
block|{
name|CHECK_GT
argument_list|(
name|new_capacity
argument_list|,
literal|0
argument_list|)
block|;
name|CHECK_LE
argument_list|(
name|size_
argument_list|,
name|new_capacity
argument_list|)
block|;
name|T
operator|*
name|new_data
operator|=
operator|(
name|T
operator|*
operator|)
name|MmapOrDie
argument_list|(
name|new_capacity
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|,
literal|"InternalMmapVector"
argument_list|)
block|;
name|internal_memcpy
argument_list|(
name|new_data
argument_list|,
name|data_
argument_list|,
name|size_
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
block|;
name|T
operator|*
name|old_data
operator|=
name|data_
block|;
name|data_
operator|=
name|new_data
block|;
name|UnmapOrDie
argument_list|(
name|old_data
argument_list|,
name|capacity_
operator|*
sizeof|sizeof
argument_list|(
name|T
argument_list|)
argument_list|)
block|;
name|capacity_
operator|=
name|new_capacity
block|;   }
name|T
operator|*
name|data_
block|;
name|uptr
name|capacity_
block|;
name|uptr
name|size_
block|; }
expr_stmt|;
name|template
operator|<
name|typename
name|T
operator|>
name|class
name|InternalMmapVector
operator|:
name|public
name|InternalMmapVectorNoCtor
operator|<
name|T
operator|>
block|{
name|public
operator|:
name|explicit
name|InternalMmapVector
argument_list|(
argument|uptr initial_capacity
argument_list|)
block|{
name|InternalMmapVectorNoCtor
operator|<
name|T
operator|>
operator|::
name|Initialize
argument_list|(
name|initial_capacity
argument_list|)
block|;   }
operator|~
name|InternalMmapVector
argument_list|()
block|{
name|InternalMmapVectorNoCtor
operator|<
name|T
operator|>
operator|::
name|Destroy
argument_list|()
block|; }
comment|// Disallow evil constructors.
name|InternalMmapVector
argument_list|(
specifier|const
name|InternalMmapVector
operator|&
argument_list|)
block|;
name|void
name|operator
operator|=
operator|(
specifier|const
name|InternalMmapVector
operator|&
operator|)
block|; }
expr_stmt|;
comment|// HeapSort for arrays and InternalMmapVector.
name|template
operator|<
name|class
name|Container
operator|,
name|class
name|Compare
operator|>
name|void
name|InternalSort
argument_list|(
argument|Container *v
argument_list|,
argument|uptr size
argument_list|,
argument|Compare comp
argument_list|)
block|{
if|if
condition|(
name|size
operator|<
literal|2
condition|)
return|return;
comment|// Stage 1: insert elements to the heap.
for|for
control|(
name|uptr
name|i
init|=
literal|1
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|uptr
name|j
decl_stmt|,
name|p
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|=
name|p
control|)
block|{
name|p
operator|=
operator|(
name|j
operator|-
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|comp
argument_list|(
operator|(
operator|*
name|v
operator|)
index|[
name|p
index|]
argument_list|,
operator|(
operator|*
name|v
operator|)
index|[
name|j
index|]
argument_list|)
condition|)
name|Swap
argument_list|(
operator|(
operator|*
name|v
operator|)
index|[
name|j
index|]
argument_list|,
operator|(
operator|*
name|v
operator|)
index|[
name|p
index|]
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
block|}
comment|// Stage 2: swap largest element with the last one,
comment|// and sink the new top.
for|for
control|(
name|uptr
name|i
init|=
name|size
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|Swap
argument_list|(
operator|(
operator|*
name|v
operator|)
index|[
literal|0
index|]
argument_list|,
operator|(
operator|*
name|v
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|uptr
name|j
decl_stmt|,
name|max_ind
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|=
name|max_ind
control|)
block|{
name|uptr
name|left
init|=
literal|2
operator|*
name|j
operator|+
literal|1
decl_stmt|;
name|uptr
name|right
init|=
literal|2
operator|*
name|j
operator|+
literal|2
decl_stmt|;
name|max_ind
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|left
operator|<
name|i
operator|&&
name|comp
argument_list|(
operator|(
operator|*
name|v
operator|)
index|[
name|max_ind
index|]
argument_list|,
operator|(
operator|*
name|v
operator|)
index|[
name|left
index|]
argument_list|)
condition|)
name|max_ind
operator|=
name|left
expr_stmt|;
if|if
condition|(
name|right
operator|<
name|i
operator|&&
name|comp
argument_list|(
operator|(
operator|*
name|v
operator|)
index|[
name|max_ind
index|]
argument_list|,
operator|(
operator|*
name|v
operator|)
index|[
name|right
index|]
argument_list|)
condition|)
name|max_ind
operator|=
name|right
expr_stmt|;
if|if
condition|(
name|max_ind
operator|!=
name|j
condition|)
name|Swap
argument_list|(
operator|(
operator|*
name|v
operator|)
index|[
name|j
index|]
argument_list|,
operator|(
operator|*
name|v
operator|)
index|[
name|max_ind
index|]
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
block|}
block|}
end_decl_stmt

begin_comment
comment|// Works like std::lower_bound: finds the first element that is not less
end_comment

begin_comment
comment|// than the val.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|Container
operator|,
name|class
name|Value
operator|,
name|class
name|Compare
operator|>
name|uptr
name|InternalLowerBound
argument_list|(
argument|const Container&v
argument_list|,
argument|uptr first
argument_list|,
argument|uptr last
argument_list|,
argument|const Value&val
argument_list|,
argument|Compare comp
argument_list|)
block|{
while|while
condition|(
name|last
operator|>
name|first
condition|)
block|{
name|uptr
name|mid
init|=
operator|(
name|first
operator|+
name|last
operator|)
operator|/
literal|2
decl_stmt|;
if|if
condition|(
name|comp
argument_list|(
name|v
index|[
name|mid
index|]
argument_list|,
name|val
argument_list|)
condition|)
name|first
operator|=
name|mid
operator|+
literal|1
expr_stmt|;
else|else
name|last
operator|=
name|mid
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|first
return|;
end_return

begin_macro
unit|}  enum
name|ModuleArch
end_macro

begin_block
block|{
name|kModuleArchUnknown
operator|,
name|kModuleArchI386
operator|,
name|kModuleArchX86_64
operator|,
name|kModuleArchX86_64H
operator|,
name|kModuleArchARMV6
operator|,
name|kModuleArchARMV7
operator|,
name|kModuleArchARMV7S
operator|,
name|kModuleArchARMV7K
operator|,
name|kModuleArchARM64
block|}
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// When adding a new architecture, don't forget to also update
end_comment

begin_comment
comment|// script/asan_symbolize.py and sanitizer_symbolizer_libcdep.cc.
end_comment

begin_function
specifier|inline
specifier|const
name|char
modifier|*
name|ModuleArchToString
parameter_list|(
name|ModuleArch
name|arch
parameter_list|)
block|{
switch|switch
condition|(
name|arch
condition|)
block|{
case|case
name|kModuleArchUnknown
case|:
return|return
literal|""
return|;
case|case
name|kModuleArchI386
case|:
return|return
literal|"i386"
return|;
case|case
name|kModuleArchX86_64
case|:
return|return
literal|"x86_64"
return|;
case|case
name|kModuleArchX86_64H
case|:
return|return
literal|"x86_64h"
return|;
case|case
name|kModuleArchARMV6
case|:
return|return
literal|"armv6"
return|;
case|case
name|kModuleArchARMV7
case|:
return|return
literal|"armv7"
return|;
case|case
name|kModuleArchARMV7S
case|:
return|return
literal|"armv7s"
return|;
case|case
name|kModuleArchARMV7K
case|:
return|return
literal|"armv7k"
return|;
case|case
name|kModuleArchARM64
case|:
return|return
literal|"arm64"
return|;
block|}
name|CHECK
argument_list|(
literal|0
operator|&&
literal|"Invalid module arch"
argument_list|)
expr_stmt|;
return|return
literal|""
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|uptr
name|kModuleUUIDSize
init|=
literal|16
decl_stmt|;
end_decl_stmt

begin_comment
comment|// Represents a binary loaded into virtual memory (e.g. this can be an
end_comment

begin_comment
comment|// executable or a shared object).
end_comment

begin_decl_stmt
name|class
name|LoadedModule
block|{
name|public
label|:
name|LoadedModule
argument_list|()
operator|:
name|full_name_
argument_list|(
name|nullptr
argument_list|)
operator|,
name|base_address_
argument_list|(
literal|0
argument_list|)
operator|,
name|max_executable_address_
argument_list|(
literal|0
argument_list|)
operator|,
name|arch_
argument_list|(
name|kModuleArchUnknown
argument_list|)
operator|,
name|instrumented_
argument_list|(
argument|false
argument_list|)
block|{
name|internal_memset
argument_list|(
name|uuid_
argument_list|,
literal|0
argument_list|,
name|kModuleUUIDSize
argument_list|)
block|;
name|ranges_
operator|.
name|clear
argument_list|()
block|;   }
name|void
name|set
argument_list|(
argument|const char *module_name
argument_list|,
argument|uptr base_address
argument_list|)
expr_stmt|;
name|void
name|set
parameter_list|(
specifier|const
name|char
modifier|*
name|module_name
parameter_list|,
name|uptr
name|base_address
parameter_list|,
name|ModuleArch
name|arch
parameter_list|,
name|u8
name|uuid
index|[
name|kModuleUUIDSize
index|]
parameter_list|,
name|bool
name|instrumented
parameter_list|)
function_decl|;
name|void
name|clear
parameter_list|()
function_decl|;
name|void
name|addAddressRange
parameter_list|(
name|uptr
name|beg
parameter_list|,
name|uptr
name|end
parameter_list|,
name|bool
name|executable
parameter_list|,
name|bool
name|writable
parameter_list|)
function_decl|;
name|bool
name|containsAddress
argument_list|(
name|uptr
name|address
argument_list|)
decl|const
decl_stmt|;
specifier|const
name|char
operator|*
name|full_name
argument_list|()
specifier|const
block|{
return|return
name|full_name_
return|;
block|}
name|uptr
name|base_address
argument_list|()
specifier|const
block|{
return|return
name|base_address_
return|;
block|}
name|uptr
name|max_executable_address
argument_list|()
specifier|const
block|{
return|return
name|max_executable_address_
return|;
block|}
name|ModuleArch
name|arch
argument_list|()
specifier|const
block|{
return|return
name|arch_
return|;
block|}
specifier|const
name|u8
operator|*
name|uuid
argument_list|()
specifier|const
block|{
return|return
name|uuid_
return|;
block|}
name|bool
name|instrumented
argument_list|()
specifier|const
block|{
return|return
name|instrumented_
return|;
block|}
struct|struct
name|AddressRange
block|{
name|AddressRange
modifier|*
name|next
decl_stmt|;
name|uptr
name|beg
decl_stmt|;
name|uptr
name|end
decl_stmt|;
name|bool
name|executable
decl_stmt|;
name|bool
name|writable
decl_stmt|;
name|AddressRange
argument_list|(
argument|uptr beg
argument_list|,
argument|uptr end
argument_list|,
argument|bool executable
argument_list|,
argument|bool writable
argument_list|)
block|:
name|next
argument_list|(
name|nullptr
argument_list|)
operator|,
name|beg
argument_list|(
name|beg
argument_list|)
operator|,
name|end
argument_list|(
name|end
argument_list|)
operator|,
name|executable
argument_list|(
name|executable
argument_list|)
operator|,
name|writable
argument_list|(
argument|writable
argument_list|)
block|{}
block|}
struct|;
specifier|const
name|IntrusiveList
operator|<
name|AddressRange
operator|>
operator|&
name|ranges
argument_list|()
specifier|const
block|{
return|return
name|ranges_
return|;
block|}
name|private
label|:
name|char
modifier|*
name|full_name_
decl_stmt|;
comment|// Owned.
name|uptr
name|base_address_
decl_stmt|;
name|uptr
name|max_executable_address_
decl_stmt|;
name|ModuleArch
name|arch_
decl_stmt|;
name|u8
name|uuid_
index|[
name|kModuleUUIDSize
index|]
decl_stmt|;
name|bool
name|instrumented_
decl_stmt|;
name|IntrusiveList
operator|<
name|AddressRange
operator|>
name|ranges_
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// List of LoadedModules. OS-dependent implementation is responsible for
end_comment

begin_comment
comment|// filling this information.
end_comment

begin_decl_stmt
name|class
name|ListOfModules
block|{
name|public
label|:
name|ListOfModules
argument_list|()
operator|:
name|modules_
argument_list|(
argument|kInitialCapacity
argument_list|)
block|{}
operator|~
name|ListOfModules
argument_list|()
block|{
name|clear
argument_list|()
block|; }
name|void
name|init
argument_list|()
expr_stmt|;
specifier|const
name|LoadedModule
operator|*
name|begin
argument_list|()
specifier|const
block|{
return|return
name|modules_
operator|.
name|begin
argument_list|()
return|;
block|}
name|LoadedModule
modifier|*
name|begin
parameter_list|()
block|{
return|return
name|modules_
operator|.
name|begin
argument_list|()
return|;
block|}
specifier|const
name|LoadedModule
operator|*
name|end
argument_list|()
specifier|const
block|{
return|return
name|modules_
operator|.
name|end
argument_list|()
return|;
block|}
name|LoadedModule
modifier|*
name|end
parameter_list|()
block|{
return|return
name|modules_
operator|.
name|end
argument_list|()
return|;
block|}
name|uptr
name|size
argument_list|()
specifier|const
block|{
return|return
name|modules_
operator|.
name|size
argument_list|()
return|;
block|}
specifier|const
name|LoadedModule
modifier|&
name|operator
index|[]
argument_list|(
name|uptr
name|i
argument_list|)
decl|const
block|{
name|CHECK_LT
argument_list|(
name|i
argument_list|,
name|modules_
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|modules_
index|[
name|i
index|]
return|;
block|}
name|private
label|:
name|void
name|clear
parameter_list|()
block|{
for|for
control|(
name|auto
operator|&
name|module
operator|:
name|modules_
control|)
name|module
operator|.
name|clear
argument_list|()
expr_stmt|;
name|modules_
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|InternalMmapVector
operator|<
name|LoadedModule
operator|>
name|modules_
expr_stmt|;
comment|// We rarely have more than 16K loaded modules.
specifier|static
specifier|const
name|uptr
name|kInitialCapacity
init|=
literal|1
operator|<<
literal|14
decl_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|// Callback type for iterating over a set of memory ranges.
end_comment

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|RangeIteratorCallback
function_decl|)
parameter_list|(
name|uptr
name|begin
parameter_list|,
name|uptr
name|end
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_typedef

begin_enum
enum|enum
name|AndroidApiLevel
block|{
name|ANDROID_NOT_ANDROID
init|=
literal|0
block|,
name|ANDROID_KITKAT
init|=
literal|19
block|,
name|ANDROID_LOLLIPOP_MR1
init|=
literal|22
block|,
name|ANDROID_POST_LOLLIPOP
init|=
literal|23
block|}
enum|;
end_enum

begin_function_decl
name|void
name|WriteToSyslog
parameter_list|(
specifier|const
name|char
modifier|*
name|buffer
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|SANITIZER_MAC
end_if

begin_function_decl
name|void
name|LogFullErrorReport
parameter_list|(
specifier|const
name|char
modifier|*
name|buffer
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function
name|INLINE
name|void
name|LogFullErrorReport
parameter_list|(
specifier|const
name|char
modifier|*
name|buffer
parameter_list|)
block|{}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|SANITIZER_LINUX
operator|||
name|SANITIZER_MAC
end_if

begin_function_decl
name|void
name|WriteOneLineToSyslog
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|LogMessageOnPrintf
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function
name|INLINE
name|void
name|WriteOneLineToSyslog
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{}
end_function

begin_function
name|INLINE
name|void
name|LogMessageOnPrintf
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|SANITIZER_LINUX
end_if

begin_comment
comment|// Initialize Android logging. Any writes before this are silently lost.
end_comment

begin_function_decl
name|void
name|AndroidLogInit
parameter_list|()
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function
name|INLINE
name|void
name|AndroidLogInit
parameter_list|()
block|{}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|SANITIZER_ANDROID
end_if

begin_function_decl
name|void
name|SanitizerInitializeUnwinder
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|AndroidApiLevel
name|AndroidGetApiLevel
parameter_list|()
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function
name|INLINE
name|void
name|AndroidLogWrite
parameter_list|(
specifier|const
name|char
modifier|*
name|buffer_unused
parameter_list|)
block|{}
end_function

begin_function
name|INLINE
name|void
name|SanitizerInitializeUnwinder
parameter_list|()
block|{}
end_function

begin_function
name|INLINE
name|AndroidApiLevel
name|AndroidGetApiLevel
parameter_list|()
block|{
return|return
name|ANDROID_NOT_ANDROID
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|INLINE
name|uptr
name|GetPthreadDestructorIterations
parameter_list|()
block|{
if|#
directive|if
name|SANITIZER_ANDROID
return|return
operator|(
name|AndroidGetApiLevel
argument_list|()
operator|==
name|ANDROID_LOLLIPOP_MR1
operator|)
condition|?
literal|8
else|:
literal|4
return|;
elif|#
directive|elif
name|SANITIZER_POSIX
return|return
literal|4
return|;
else|#
directive|else
comment|// Unused on Windows.
return|return
literal|0
return|;
endif|#
directive|endif
block|}
end_function

begin_function_decl
name|void
modifier|*
name|internal_start_thread
parameter_list|(
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|internal_join_thread
parameter_list|(
name|void
modifier|*
name|th
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|MaybeStartBackgroudThread
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|// Make the compiler think that something is going on there.
end_comment

begin_comment
comment|// Use this inside a loop that looks like memset/memcpy/etc to prevent the
end_comment

begin_comment
comment|// compiler from recognising it and turning it into an actual call to
end_comment

begin_comment
comment|// memset/memcpy/etc.
end_comment

begin_function
specifier|static
specifier|inline
name|void
name|SanitizerBreakOptimization
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__clang__
argument_list|)
name|_ReadWriteBarrier
argument_list|()
expr_stmt|;
else|#
directive|else
asm|__asm__
specifier|__volatile__
asm|("" : : "r" (arg) : "memory");
endif|#
directive|endif
block|}
end_function

begin_struct
struct|struct
name|SignalContext
block|{
name|void
modifier|*
name|context
decl_stmt|;
name|uptr
name|addr
decl_stmt|;
name|uptr
name|pc
decl_stmt|;
name|uptr
name|sp
decl_stmt|;
name|uptr
name|bp
decl_stmt|;
name|bool
name|is_memory_access
decl_stmt|;
enum|enum
name|WriteFlag
block|{
name|UNKNOWN
block|,
name|READ
block|,
name|WRITE
block|}
name|write_flag
enum|;
name|SignalContext
argument_list|(
argument|void *context
argument_list|,
argument|uptr addr
argument_list|,
argument|uptr pc
argument_list|,
argument|uptr sp
argument_list|,
argument|uptr bp
argument_list|,
argument|bool is_memory_access
argument_list|,
argument|WriteFlag write_flag
argument_list|)
block|:
name|context
argument_list|(
name|context
argument_list|)
operator|,
name|addr
argument_list|(
name|addr
argument_list|)
operator|,
name|pc
argument_list|(
name|pc
argument_list|)
operator|,
name|sp
argument_list|(
name|sp
argument_list|)
operator|,
name|bp
argument_list|(
name|bp
argument_list|)
operator|,
name|is_memory_access
argument_list|(
name|is_memory_access
argument_list|)
operator|,
name|write_flag
argument_list|(
argument|write_flag
argument_list|)
block|{}
specifier|static
name|void
name|DumpAllRegisters
argument_list|(
name|void
operator|*
name|context
argument_list|)
expr_stmt|;
comment|// Creates signal context in a platform-specific manner.
specifier|static
name|SignalContext
name|Create
parameter_list|(
name|void
modifier|*
name|siginfo
parameter_list|,
name|void
modifier|*
name|context
parameter_list|)
function_decl|;
comment|// Returns true if the "context" indicates a memory write.
specifier|static
name|WriteFlag
name|GetWriteFlag
parameter_list|(
name|void
modifier|*
name|context
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_function_decl
name|void
name|GetPcSpBp
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
name|uptr
modifier|*
name|pc
parameter_list|,
name|uptr
modifier|*
name|sp
parameter_list|,
name|uptr
modifier|*
name|bp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|MaybeReexec
parameter_list|()
function_decl|;
end_function_decl

begin_expr_stmt
name|template
operator|<
name|typename
name|Fn
operator|>
name|class
name|RunOnDestruction
block|{
name|public
operator|:
name|explicit
name|RunOnDestruction
argument_list|(
argument|Fn fn
argument_list|)
operator|:
name|fn_
argument_list|(
argument|fn
argument_list|)
block|{}
operator|~
name|RunOnDestruction
argument_list|()
block|{
name|fn_
argument_list|()
block|; }
name|private
operator|:
name|Fn
name|fn_
block|; }
expr_stmt|;
end_expr_stmt

begin_comment
comment|// A simple scope guard. Usage:
end_comment

begin_comment
comment|// auto cleanup = at_scope_exit([]{ do_cleanup; });
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|Fn
operator|>
name|RunOnDestruction
operator|<
name|Fn
operator|>
name|at_scope_exit
argument_list|(
argument|Fn fn
argument_list|)
block|{
return|return
name|RunOnDestruction
operator|<
name|Fn
operator|>
operator|(
name|fn
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|// Linux on 64-bit s390 had a nasty bug that crashes the whole machine
end_comment

begin_comment
comment|// if a process uses virtual memory over 4TB (as many sanitizers like
end_comment

begin_comment
comment|// to do).  This function will abort the process if running on a kernel
end_comment

begin_comment
comment|// that looks vulnerable.
end_comment

begin_if
if|#
directive|if
name|SANITIZER_LINUX
operator|&&
name|SANITIZER_S390_64
end_if

begin_function_decl
name|void
name|AvoidCVE_2016_2143
parameter_list|()
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function
name|INLINE
name|void
name|AvoidCVE_2016_2143
parameter_list|()
block|{}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|StackDepotStats
block|{
name|uptr
name|n_uniq_ids
decl_stmt|;
name|uptr
name|allocated
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|// The default value for allocator_release_to_os_interval_ms common flag to
end_comment

begin_comment
comment|// indicate that sanitizer allocator should not attempt to release memory to OS.
end_comment

begin_decl_stmt
specifier|const
name|s32
name|kReleaseToOSIntervalNever
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|CheckNoDeepBind
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|flag
parameter_list|)
function_decl|;
end_function_decl

begin_comment
unit|}
comment|// namespace __sanitizer
end_comment

begin_decl_stmt
unit|inline
name|void
modifier|*
name|operator
name|new
argument_list|(
name|__sanitizer
operator|::
name|operator_new_size_type
name|size
argument_list|,
name|__sanitizer
operator|::
name|LowLevelAllocator
operator|&
name|alloc
argument_list|)
block|{
return|return
name|alloc
operator|.
name|Allocate
argument_list|(
name|size
argument_list|)
return|;
block|}
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// SANITIZER_COMMON_H
end_comment

end_unit

