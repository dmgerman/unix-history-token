begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- BitcodeReader.h - Internal BitcodeReader impl ------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This header defines the BitcodeReader class.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BITCODE_READER_H
end_ifndef

begin_define
define|#
directive|define
name|BITCODE_READER_H
end_define

begin_include
include|#
directive|include
file|"llvm/ModuleProvider.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Attributes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Type.h"
end_include

begin_include
include|#
directive|include
file|"llvm/OperandTraits.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Bitcode/BitstreamReader.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Bitcode/LLVMBitCodes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ValueHandle.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|MemoryBuffer
decl_stmt|;
name|class
name|LLVMContext
decl_stmt|;
comment|//===----------------------------------------------------------------------===//
comment|//                          BitcodeReaderValueList Class
comment|//===----------------------------------------------------------------------===//
name|class
name|BitcodeReaderValueList
block|{
name|std
operator|::
name|vector
operator|<
name|WeakVH
operator|>
name|ValuePtrs
expr_stmt|;
comment|/// ResolveConstants - As we resolve forward-referenced constants, we add
comment|/// information about them to this vector.  This allows us to resolve them in
comment|/// bulk instead of resolving each reference at a time.  See the code in
comment|/// ResolveConstantForwardRefs for more information about this.
comment|///
comment|/// The key of this vector is the placeholder constant, the value is the slot
comment|/// number that holds the resolved value.
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|Constant
operator|*
operator|,
name|unsigned
operator|>
expr|>
name|ResolveConstantsTy
expr_stmt|;
name|ResolveConstantsTy
name|ResolveConstants
decl_stmt|;
name|LLVMContext
modifier|&
name|Context
decl_stmt|;
name|public
label|:
name|BitcodeReaderValueList
argument_list|(
name|LLVMContext
operator|&
name|C
argument_list|)
operator|:
name|Context
argument_list|(
argument|C
argument_list|)
block|{}
operator|~
name|BitcodeReaderValueList
argument_list|()
block|{
name|assert
argument_list|(
name|ResolveConstants
operator|.
name|empty
argument_list|()
operator|&&
literal|"Constants not resolved?"
argument_list|)
block|;   }
comment|// vector compatibility methods
name|unsigned
name|size
argument_list|()
specifier|const
block|{
return|return
name|ValuePtrs
operator|.
name|size
argument_list|()
return|;
block|}
name|void
name|resize
parameter_list|(
name|unsigned
name|N
parameter_list|)
block|{
name|ValuePtrs
operator|.
name|resize
argument_list|(
name|N
argument_list|)
expr_stmt|;
block|}
name|void
name|push_back
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|)
block|{
name|ValuePtrs
operator|.
name|push_back
argument_list|(
name|V
argument_list|)
expr_stmt|;
block|}
name|void
name|clear
parameter_list|()
block|{
name|assert
argument_list|(
name|ResolveConstants
operator|.
name|empty
argument_list|()
operator|&&
literal|"Constants not resolved?"
argument_list|)
expr_stmt|;
name|ValuePtrs
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|Value
modifier|*
name|operator
index|[]
argument_list|(
name|unsigned
name|i
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|i
operator|<
name|ValuePtrs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|ValuePtrs
index|[
name|i
index|]
return|;
block|}
name|Value
operator|*
name|back
argument_list|()
specifier|const
block|{
return|return
name|ValuePtrs
operator|.
name|back
argument_list|()
return|;
block|}
name|void
name|pop_back
parameter_list|()
block|{
name|ValuePtrs
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|ValuePtrs
operator|.
name|empty
argument_list|()
return|;
block|}
name|void
name|shrinkTo
parameter_list|(
name|unsigned
name|N
parameter_list|)
block|{
name|assert
argument_list|(
name|N
operator|<=
name|size
argument_list|()
operator|&&
literal|"Invalid shrinkTo request!"
argument_list|)
expr_stmt|;
name|ValuePtrs
operator|.
name|resize
argument_list|(
name|N
argument_list|)
expr_stmt|;
block|}
name|Constant
modifier|*
name|getConstantFwdRef
parameter_list|(
name|unsigned
name|Idx
parameter_list|,
specifier|const
name|Type
modifier|*
name|Ty
parameter_list|)
function_decl|;
name|Value
modifier|*
name|getValueFwdRef
parameter_list|(
name|unsigned
name|Idx
parameter_list|,
specifier|const
name|Type
modifier|*
name|Ty
parameter_list|)
function_decl|;
name|void
name|AssignValue
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|unsigned
name|Idx
parameter_list|)
function_decl|;
comment|/// ResolveConstantForwardRefs - Once all constants are read, this method bulk
comment|/// resolves any forward references.
name|void
name|ResolveConstantForwardRefs
parameter_list|()
function_decl|;
block|}
empty_stmt|;
comment|//===----------------------------------------------------------------------===//
comment|//                          BitcodeReaderMDValueList Class
comment|//===----------------------------------------------------------------------===//
name|class
name|BitcodeReaderMDValueList
block|{
name|std
operator|::
name|vector
operator|<
name|WeakVH
operator|>
name|MDValuePtrs
expr_stmt|;
name|LLVMContext
modifier|&
name|Context
decl_stmt|;
name|public
label|:
name|BitcodeReaderMDValueList
argument_list|(
name|LLVMContext
operator|&
name|C
argument_list|)
operator|:
name|Context
argument_list|(
argument|C
argument_list|)
block|{}
comment|// vector compatibility methods
name|unsigned
name|size
argument_list|()
specifier|const
block|{
return|return
name|MDValuePtrs
operator|.
name|size
argument_list|()
return|;
block|}
name|void
name|resize
parameter_list|(
name|unsigned
name|N
parameter_list|)
block|{
name|MDValuePtrs
operator|.
name|resize
argument_list|(
name|N
argument_list|)
expr_stmt|;
block|}
name|void
name|push_back
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|)
block|{
name|MDValuePtrs
operator|.
name|push_back
argument_list|(
name|V
argument_list|)
expr_stmt|;
block|}
name|void
name|clear
parameter_list|()
block|{
name|MDValuePtrs
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|Value
operator|*
name|back
argument_list|()
specifier|const
block|{
return|return
name|MDValuePtrs
operator|.
name|back
argument_list|()
return|;
block|}
name|void
name|pop_back
parameter_list|()
block|{
name|MDValuePtrs
operator|.
name|pop_back
argument_list|()
expr_stmt|;
block|}
name|bool
name|empty
argument_list|()
specifier|const
block|{
return|return
name|MDValuePtrs
operator|.
name|empty
argument_list|()
return|;
block|}
name|Value
modifier|*
name|operator
index|[]
argument_list|(
name|unsigned
name|i
argument_list|)
decl|const
block|{
name|assert
argument_list|(
name|i
operator|<
name|MDValuePtrs
operator|.
name|size
argument_list|()
argument_list|)
expr_stmt|;
return|return
name|MDValuePtrs
index|[
name|i
index|]
return|;
block|}
name|void
name|shrinkTo
parameter_list|(
name|unsigned
name|N
parameter_list|)
block|{
name|assert
argument_list|(
name|N
operator|<=
name|size
argument_list|()
operator|&&
literal|"Invalid shrinkTo request!"
argument_list|)
expr_stmt|;
name|MDValuePtrs
operator|.
name|resize
argument_list|(
name|N
argument_list|)
expr_stmt|;
block|}
name|Value
modifier|*
name|getValueFwdRef
parameter_list|(
name|unsigned
name|Idx
parameter_list|)
function_decl|;
name|void
name|AssignValue
parameter_list|(
name|Value
modifier|*
name|V
parameter_list|,
name|unsigned
name|Idx
parameter_list|)
function_decl|;
block|}
empty_stmt|;
name|class
name|BitcodeReader
range|:
name|public
name|ModuleProvider
block|{
name|LLVMContext
operator|&
name|Context
block|;
name|MemoryBuffer
operator|*
name|Buffer
block|;
name|BitstreamReader
name|StreamFile
block|;
name|BitstreamCursor
name|Stream
block|;
specifier|const
name|char
operator|*
name|ErrorString
block|;
name|std
operator|::
name|vector
operator|<
name|PATypeHolder
operator|>
name|TypeList
block|;
name|BitcodeReaderValueList
name|ValueList
block|;
name|BitcodeReaderMDValueList
name|MDValueList
block|;
name|SmallVector
operator|<
name|Instruction
operator|*
block|,
literal|64
operator|>
name|InstructionList
block|;
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|GlobalVariable
operator|*
block|,
name|unsigned
operator|>
expr|>
name|GlobalInits
block|;
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|GlobalAlias
operator|*
block|,
name|unsigned
operator|>
expr|>
name|AliasInits
block|;
comment|/// MAttributes - The set of attributes by index.  Index zero in the
comment|/// file is for null, and is thus not represented here.  As such all indices
comment|/// are off by one.
name|std
operator|::
name|vector
operator|<
name|AttrListPtr
operator|>
name|MAttributes
block|;
comment|/// FunctionBBs - While parsing a function body, this is a list of the basic
comment|/// blocks for the function.
name|std
operator|::
name|vector
operator|<
name|BasicBlock
operator|*
operator|>
name|FunctionBBs
block|;
comment|// When reading the module header, this list is populated with functions that
comment|// have bodies later in the file.
name|std
operator|::
name|vector
operator|<
name|Function
operator|*
operator|>
name|FunctionsWithBodies
block|;
comment|// When intrinsic functions are encountered which require upgrading they are
comment|// stored here with their replacement function.
typedef|typedef
name|std
operator|::
name|vector
operator|<
name|std
operator|::
name|pair
operator|<
name|Function
operator|*
operator|,
name|Function
operator|*
operator|>
expr|>
name|UpgradedIntrinsicMap
expr_stmt|;
name|UpgradedIntrinsicMap
name|UpgradedIntrinsics
decl_stmt|;
comment|// After the module header has been read, the FunctionsWithBodies list is
comment|// reversed.  This keeps track of whether we've done this yet.
name|bool
name|HasReversedFunctionsWithBodies
decl_stmt|;
comment|/// DeferredFunctionInfo - When function bodies are initially scanned, this
comment|/// map contains info about where to find deferred function body (in the
comment|/// stream) and what linkage the original function had.
name|DenseMap
operator|<
name|Function
operator|*
operator|,
name|std
operator|::
name|pair
operator|<
name|uint64_t
operator|,
name|unsigned
operator|>
expr|>
name|DeferredFunctionInfo
expr_stmt|;
name|public
label|:
name|explicit
name|BitcodeReader
argument_list|(
name|MemoryBuffer
operator|*
name|buffer
argument_list|,
name|LLVMContext
operator|&
name|C
argument_list|)
operator|:
name|Context
argument_list|(
name|C
argument_list|)
operator|,
name|Buffer
argument_list|(
name|buffer
argument_list|)
operator|,
name|ErrorString
argument_list|(
literal|0
argument_list|)
operator|,
name|ValueList
argument_list|(
name|C
argument_list|)
operator|,
name|MDValueList
argument_list|(
argument|C
argument_list|)
block|{
name|HasReversedFunctionsWithBodies
operator|=
name|false
block|;   }
operator|~
name|BitcodeReader
argument_list|()
block|{
name|FreeState
argument_list|()
block|;   }
name|void
name|FreeState
argument_list|()
expr_stmt|;
comment|/// releaseMemoryBuffer - This causes the reader to completely forget about
comment|/// the memory buffer it contains, which prevents the buffer from being
comment|/// destroyed when it is deleted.
name|void
name|releaseMemoryBuffer
parameter_list|()
block|{
name|Buffer
operator|=
literal|0
expr_stmt|;
block|}
name|virtual
name|bool
name|materializeFunction
argument_list|(
name|Function
operator|*
name|F
argument_list|,
name|std
operator|::
name|string
operator|*
name|ErrInfo
operator|=
literal|0
argument_list|)
decl_stmt|;
name|virtual
name|Module
modifier|*
name|materializeModule
argument_list|(
name|std
operator|::
name|string
operator|*
name|ErrInfo
operator|=
literal|0
argument_list|)
decl_stmt|;
name|virtual
name|void
name|dematerializeFunction
parameter_list|(
name|Function
modifier|*
name|F
parameter_list|)
function_decl|;
name|virtual
name|Module
modifier|*
name|releaseModule
argument_list|(
name|std
operator|::
name|string
operator|*
name|ErrInfo
operator|=
literal|0
argument_list|)
decl_stmt|;
name|bool
name|Error
parameter_list|(
specifier|const
name|char
modifier|*
name|Str
parameter_list|)
block|{
name|ErrorString
operator|=
name|Str
expr_stmt|;
return|return
name|true
return|;
block|}
specifier|const
name|char
operator|*
name|getErrorString
argument_list|()
specifier|const
block|{
return|return
name|ErrorString
return|;
block|}
comment|/// @brief Main interface to parsing a bitcode buffer.
comment|/// @returns true if an error occurred.
name|bool
name|ParseBitcode
parameter_list|()
function_decl|;
name|private
label|:
specifier|const
name|Type
modifier|*
name|getTypeByID
parameter_list|(
name|unsigned
name|ID
parameter_list|,
name|bool
name|isTypeTable
init|=
name|false
parameter_list|)
function_decl|;
name|Value
modifier|*
name|getFnValueByID
parameter_list|(
name|unsigned
name|ID
parameter_list|,
specifier|const
name|Type
modifier|*
name|Ty
parameter_list|)
block|{
if|if
condition|(
name|Ty
operator|==
name|Type
operator|::
name|getMetadataTy
argument_list|(
name|Context
argument_list|)
condition|)
return|return
name|MDValueList
operator|.
name|getValueFwdRef
argument_list|(
name|ID
argument_list|)
return|;
else|else
return|return
name|ValueList
operator|.
name|getValueFwdRef
argument_list|(
name|ID
argument_list|,
name|Ty
argument_list|)
return|;
block|}
name|BasicBlock
modifier|*
name|getBasicBlock
argument_list|(
name|unsigned
name|ID
argument_list|)
decl|const
block|{
if|if
condition|(
name|ID
operator|>=
name|FunctionBBs
operator|.
name|size
argument_list|()
condition|)
return|return
literal|0
return|;
comment|// Invalid ID
return|return
name|FunctionBBs
index|[
name|ID
index|]
return|;
block|}
name|AttrListPtr
name|getAttributes
argument_list|(
name|unsigned
name|i
argument_list|)
decl|const
block|{
if|if
condition|(
name|i
operator|-
literal|1
operator|<
name|MAttributes
operator|.
name|size
argument_list|()
condition|)
return|return
name|MAttributes
index|[
name|i
operator|-
literal|1
index|]
return|;
return|return
name|AttrListPtr
argument_list|()
return|;
block|}
comment|/// getValueTypePair - Read a value/type pair out of the specified record from
comment|/// slot 'Slot'.  Increment Slot past the number of slots used in the record.
comment|/// Return true on failure.
name|bool
name|getValueTypePair
argument_list|(
name|SmallVector
operator|<
name|uint64_t
argument_list|,
literal|64
operator|>
operator|&
name|Record
argument_list|,
name|unsigned
operator|&
name|Slot
argument_list|,
name|unsigned
name|InstNum
argument_list|,
name|Value
operator|*
operator|&
name|ResVal
argument_list|)
block|{
if|if
condition|(
name|Slot
operator|==
name|Record
operator|.
name|size
argument_list|()
condition|)
return|return
name|true
return|;
name|unsigned
name|ValNo
init|=
operator|(
name|unsigned
operator|)
name|Record
index|[
name|Slot
operator|++
index|]
decl_stmt|;
if|if
condition|(
name|ValNo
operator|<
name|InstNum
condition|)
block|{
comment|// If this is not a forward reference, just return the value we already
comment|// have.
name|ResVal
operator|=
name|getFnValueByID
argument_list|(
name|ValNo
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|ResVal
operator|==
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|Slot
operator|==
name|Record
operator|.
name|size
argument_list|()
condition|)
block|{
return|return
name|true
return|;
block|}
name|unsigned
name|TypeNo
init|=
operator|(
name|unsigned
operator|)
name|Record
index|[
name|Slot
operator|++
index|]
decl_stmt|;
name|ResVal
operator|=
name|getFnValueByID
argument_list|(
name|ValNo
argument_list|,
name|getTypeByID
argument_list|(
name|TypeNo
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ResVal
operator|==
literal|0
return|;
block|}
name|bool
name|getValue
argument_list|(
name|SmallVector
operator|<
name|uint64_t
argument_list|,
literal|64
operator|>
operator|&
name|Record
argument_list|,
name|unsigned
operator|&
name|Slot
argument_list|,
specifier|const
name|Type
operator|*
name|Ty
argument_list|,
name|Value
operator|*
operator|&
name|ResVal
argument_list|)
block|{
if|if
condition|(
name|Slot
operator|==
name|Record
operator|.
name|size
argument_list|()
condition|)
return|return
name|true
return|;
name|unsigned
name|ValNo
init|=
operator|(
name|unsigned
operator|)
name|Record
index|[
name|Slot
operator|++
index|]
decl_stmt|;
name|ResVal
operator|=
name|getFnValueByID
argument_list|(
name|ValNo
argument_list|,
name|Ty
argument_list|)
expr_stmt|;
return|return
name|ResVal
operator|==
literal|0
return|;
block|}
name|bool
name|ParseModule
argument_list|(
specifier|const
name|std
operator|::
name|string
operator|&
name|ModuleID
argument_list|)
decl_stmt|;
name|bool
name|ParseAttributeBlock
parameter_list|()
function_decl|;
name|bool
name|ParseTypeTable
parameter_list|()
function_decl|;
name|bool
name|ParseTypeSymbolTable
parameter_list|()
function_decl|;
name|bool
name|ParseValueSymbolTable
parameter_list|()
function_decl|;
name|bool
name|ParseConstants
parameter_list|()
function_decl|;
name|bool
name|RememberAndSkipFunctionBody
parameter_list|()
function_decl|;
name|bool
name|ParseFunctionBody
parameter_list|(
name|Function
modifier|*
name|F
parameter_list|)
function_decl|;
name|bool
name|ResolveGlobalAndAliasInits
parameter_list|()
function_decl|;
name|bool
name|ParseMetadata
parameter_list|()
function_decl|;
name|bool
name|ParseMetadataAttachment
parameter_list|()
function_decl|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// End llvm namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

