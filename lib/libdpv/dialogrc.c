begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2013-2014 Devin Teske<dteske@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<figpar.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<string_m.h>
end_include

begin_include
include|#
directive|include
file|"dialogrc.h"
end_include

begin_define
define|#
directive|define
name|STR_BUFSIZE
value|255
end_define

begin_comment
comment|/* dialog(1) `.dialogrc' characteristics */
end_comment

begin_decl_stmt
name|uint8_t
name|use_colors
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint8_t
name|use_shadow
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|gauge_color
index|[
name|STR_BUFSIZE
index|]
init|=
literal|"47b"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (BLUE,WHITE,ON) */
end_comment

begin_decl_stmt
name|char
name|separator
index|[
name|STR_BUFSIZE
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function prototypes */
end_comment

begin_function_decl
specifier|static
name|int
name|setattr
parameter_list|(
name|struct
name|fp_config
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|setbool
parameter_list|(
name|struct
name|fp_config
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|setnum
parameter_list|(
name|struct
name|fp_config
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|setstr
parameter_list|(
name|struct
name|fp_config
modifier|*
parameter_list|,
name|uint32_t
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Anatomy of DIALOGRC (~/.dialogrc by default)  * NOTE: Must appear after private function prototypes (above)  * NB: Brace-initialization of union requires cast to *first* member of union  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|fp_config
name|dialogrc_config
index|[]
init|=
block|{
comment|/* TYPE        Directive                     DEFAULT        HANDLER */
block|{
name|FP_TYPE_INT
block|,
literal|"aspect"
block|,
block|{
operator|(
name|void
operator|*
operator|)
literal|0
block|}
block|,
operator|&
name|setnum
block|}
block|,
block|{
name|FP_TYPE_STR
block|,
literal|"separate_widget"
block|,
block|{
name|separator
block|}
block|,
operator|&
name|setstr
block|}
block|,
block|{
name|FP_TYPE_INT
block|,
literal|"tab_len"
block|,
block|{
operator|(
name|void
operator|*
operator|)
literal|0
block|}
block|,
operator|&
name|setnum
block|}
block|,
block|{
name|FP_TYPE_BOOL
block|,
literal|"visit_items"
block|,
block|{
operator|(
name|void
operator|*
operator|)
literal|0
block|}
block|,
operator|&
name|setbool
block|}
block|,
block|{
name|FP_TYPE_BOOL
block|,
literal|"use_shadow"
block|,
block|{
operator|(
name|void
operator|*
operator|)
literal|1
block|}
block|,
operator|&
name|setbool
block|}
block|,
block|{
name|FP_TYPE_BOOL
block|,
literal|"use_colors"
block|,
block|{
operator|(
name|void
operator|*
operator|)
literal|1
block|}
block|,
operator|&
name|setbool
block|}
block|,
block|{
name|FP_TYPE_STR
block|,
literal|"screen_color"
block|,
block|{
name|NULL
block|}
block|,
operator|&
name|setattr
block|}
block|,
block|{
name|FP_TYPE_STR
block|,
literal|"shadow_color"
block|,
block|{
name|NULL
block|}
block|,
operator|&
name|setattr
block|}
block|,
block|{
name|FP_TYPE_STR
block|,
literal|"dialog_color"
block|,
block|{
name|NULL
block|}
block|,
operator|&
name|setattr
block|}
block|,
block|{
name|FP_TYPE_STR
block|,
literal|"title_color"
block|,
block|{
name|NULL
block|}
block|,
operator|&
name|setattr
block|}
block|,
block|{
name|FP_TYPE_STR
block|,
literal|"border_color"
block|,
block|{
name|NULL
block|}
block|,
operator|&
name|setattr
block|}
block|,
block|{
name|FP_TYPE_STR
block|,
literal|"button_active_color"
block|,
block|{
name|NULL
block|}
block|,
operator|&
name|setattr
block|}
block|,
block|{
name|FP_TYPE_STR
block|,
literal|"button_inactive_color"
block|,
block|{
name|NULL
block|}
block|,
operator|&
name|setattr
block|}
block|,
block|{
name|FP_TYPE_STR
block|,
literal|"button_key_active_color"
block|,
block|{
name|NULL
block|}
block|,
operator|&
name|setattr
block|}
block|,
block|{
name|FP_TYPE_STR
block|,
literal|"button_key_inactive_color"
block|,
block|{
name|NULL
block|}
block|,
operator|&
name|setattr
block|}
block|,
block|{
name|FP_TYPE_STR
block|,
literal|"button_label_active_color"
block|,
block|{
name|NULL
block|}
block|,
operator|&
name|setattr
block|}
block|,
block|{
name|FP_TYPE_STR
block|,
literal|"button_label_inactive_color"
block|,
block|{
name|NULL
block|}
block|,
operator|&
name|setattr
block|}
block|,
block|{
name|FP_TYPE_STR
block|,
literal|"inputbox_color"
block|,
block|{
name|NULL
block|}
block|,
operator|&
name|setattr
block|}
block|,
block|{
name|FP_TYPE_STR
block|,
literal|"inputbox_border_color"
block|,
block|{
name|NULL
block|}
block|,
operator|&
name|setattr
block|}
block|,
block|{
name|FP_TYPE_STR
block|,
literal|"searchbox_color"
block|,
block|{
name|NULL
block|}
block|,
operator|&
name|setattr
block|}
block|,
block|{
name|FP_TYPE_STR
block|,
literal|"searchbox_title_color"
block|,
block|{
name|NULL
block|}
block|,
operator|&
name|setattr
block|}
block|,
block|{
name|FP_TYPE_STR
block|,
literal|"searchbox_border_color"
block|,
block|{
name|NULL
block|}
block|,
operator|&
name|setattr
block|}
block|,
block|{
name|FP_TYPE_STR
block|,
literal|"position_indicator_color"
block|,
block|{
name|NULL
block|}
block|,
operator|&
name|setattr
block|}
block|,
block|{
name|FP_TYPE_STR
block|,
literal|"menubox_color"
block|,
block|{
name|NULL
block|}
block|,
operator|&
name|setattr
block|}
block|,
block|{
name|FP_TYPE_STR
block|,
literal|"menubox_border_color"
block|,
block|{
name|NULL
block|}
block|,
operator|&
name|setattr
block|}
block|,
block|{
name|FP_TYPE_STR
block|,
literal|"item_color"
block|,
block|{
name|NULL
block|}
block|,
operator|&
name|setattr
block|}
block|,
block|{
name|FP_TYPE_STR
block|,
literal|"item_selected_color"
block|,
block|{
name|NULL
block|}
block|,
operator|&
name|setattr
block|}
block|,
block|{
name|FP_TYPE_STR
block|,
literal|"tag_color"
block|,
block|{
name|NULL
block|}
block|,
operator|&
name|setattr
block|}
block|,
block|{
name|FP_TYPE_STR
block|,
literal|"tag_selected_color"
block|,
block|{
name|NULL
block|}
block|,
operator|&
name|setattr
block|}
block|,
block|{
name|FP_TYPE_STR
block|,
literal|"tag_key_color"
block|,
block|{
name|NULL
block|}
block|,
operator|&
name|setattr
block|}
block|,
block|{
name|FP_TYPE_STR
block|,
literal|"tag_key_selected_color"
block|,
block|{
name|NULL
block|}
block|,
operator|&
name|setattr
block|}
block|,
block|{
name|FP_TYPE_STR
block|,
literal|"check_color"
block|,
block|{
name|NULL
block|}
block|,
operator|&
name|setattr
block|}
block|,
block|{
name|FP_TYPE_STR
block|,
literal|"check_selected_color"
block|,
block|{
name|NULL
block|}
block|,
operator|&
name|setattr
block|}
block|,
block|{
name|FP_TYPE_STR
block|,
literal|"uarrow_color"
block|,
block|{
name|NULL
block|}
block|,
operator|&
name|setattr
block|}
block|,
block|{
name|FP_TYPE_STR
block|,
literal|"darrow_color"
block|,
block|{
name|NULL
block|}
block|,
operator|&
name|setattr
block|}
block|,
block|{
name|FP_TYPE_STR
block|,
literal|"itemhelp_color"
block|,
block|{
name|NULL
block|}
block|,
operator|&
name|setattr
block|}
block|,
block|{
name|FP_TYPE_STR
block|,
literal|"form_active_text_color"
block|,
block|{
name|NULL
block|}
block|,
operator|&
name|setattr
block|}
block|,
block|{
name|FP_TYPE_STR
block|,
literal|"form_text_color"
block|,
block|{
name|NULL
block|}
block|,
operator|&
name|setattr
block|}
block|,
block|{
name|FP_TYPE_STR
block|,
literal|"form_item_readonly_color"
block|,
block|{
name|NULL
block|}
block|,
operator|&
name|setattr
block|}
block|,
block|{
name|FP_TYPE_STR
block|,
literal|"gauge_color"
block|,
block|{
name|gauge_color
block|}
block|,
operator|&
name|setattr
block|}
block|,
block|{
literal|0
block|,
name|NULL
block|,
block|{
literal|0
block|}
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * figpar call-back for interpreting value as .dialogrc `Attribute'  */
end_comment

begin_function
specifier|static
name|int
name|setattr
parameter_list|(
name|struct
name|fp_config
modifier|*
name|option
parameter_list|,
name|uint32_t
name|line
name|__unused
parameter_list|,
name|char
modifier|*
name|directive
name|__unused
parameter_list|,
name|char
modifier|*
name|value
parameter_list|)
block|{
name|char
modifier|*
name|cp
init|=
name|value
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|char
name|attrbuf
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|option
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s:%d:%s: Missing callback parameter"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Abort processing */
block|}
comment|/* Allocate memory for the data if not already done */
if|if
condition|(
name|option
operator|->
name|value
operator|.
name|str
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|option
operator|->
name|value
operator|.
name|str
operator|=
name|malloc
argument_list|(
name|STR_BUFSIZE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * If the first character is left-parenthesis, the format is 	 * `(background,foreground,highlight)' otherwise, we should take it 	 * as a reference to another color. 	 */
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'('
condition|)
block|{
comment|/* Copy the [current] value from the referenced color */
name|val
operator|=
name|dialogrc_config_option
argument_list|(
name|cp
argument_list|)
operator|->
name|value
operator|.
name|str
expr_stmt|;
if|if
condition|(
name|val
operator|!=
name|NULL
condition|)
name|snprintf
argument_list|(
name|option
operator|->
name|value
operator|.
name|str
argument_list|,
name|STR_BUFSIZE
argument_list|,
literal|"%s"
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
name|cp
operator|++
expr_stmt|;
name|strtolower
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* Initialize the attrbuf (fg,bg,hi,NUL) */
name|attrbuf
index|[
literal|0
index|]
operator|=
literal|'0'
expr_stmt|;
name|attrbuf
index|[
literal|1
index|]
operator|=
literal|'0'
expr_stmt|;
name|attrbuf
index|[
literal|2
index|]
operator|=
literal|'B'
expr_stmt|;
comment|/* \ZB = disable; \Zb = enable (see dialog(1)) */
name|attrbuf
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Interpret the foreground color */
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"red,"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|attrbuf
index|[
literal|0
index|]
operator|=
literal|'1'
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"green,"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
name|attrbuf
index|[
literal|0
index|]
operator|=
literal|'2'
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"yellow,"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
name|attrbuf
index|[
literal|0
index|]
operator|=
literal|'3'
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"blue,"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
name|attrbuf
index|[
literal|0
index|]
operator|=
literal|'4'
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"magenta,"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
name|attrbuf
index|[
literal|0
index|]
operator|=
literal|'5'
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"cyan,"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
name|attrbuf
index|[
literal|0
index|]
operator|=
literal|'6'
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"white,"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
name|attrbuf
index|[
literal|0
index|]
operator|=
literal|'7'
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"black,"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
name|attrbuf
index|[
literal|0
index|]
operator|=
literal|'8'
expr_stmt|;
comment|/* Advance to the background color */
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
goto|goto
name|write_attrbuf
goto|;
else|else
name|cp
operator|++
expr_stmt|;
comment|/* Interpret the background color */
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"red,"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|attrbuf
index|[
literal|1
index|]
operator|=
literal|'1'
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"green,"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
name|attrbuf
index|[
literal|1
index|]
operator|=
literal|'2'
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"yellow,"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
name|attrbuf
index|[
literal|1
index|]
operator|=
literal|'3'
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"blue,"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
name|attrbuf
index|[
literal|1
index|]
operator|=
literal|'4'
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"magenta,"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
name|attrbuf
index|[
literal|1
index|]
operator|=
literal|'5'
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"cyan,"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
name|attrbuf
index|[
literal|1
index|]
operator|=
literal|'6'
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"white,"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
name|attrbuf
index|[
literal|1
index|]
operator|=
literal|'7'
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"black,"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
name|attrbuf
index|[
literal|1
index|]
operator|=
literal|'8'
expr_stmt|;
comment|/* Advance to the highlight */
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|','
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
goto|goto
name|write_attrbuf
goto|;
else|else
name|cp
operator|++
expr_stmt|;
comment|/* Trim trailing parenthesis */
name|len
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|')'
condition|)
name|cp
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Interpret the highlight (initialized to off above) */
if|if
condition|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"on"
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"on,"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|attrbuf
index|[
literal|2
index|]
operator|=
literal|'b'
expr_stmt|;
comment|/* \Zb = enable bold (see dialog(1)) */
name|write_attrbuf
label|:
name|sprintf
argument_list|(
name|option
operator|->
name|value
operator|.
name|str
argument_list|,
literal|"%s"
argument_list|,
name|attrbuf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * figpar call-back for interpreting value as .dialogrc `Boolean'  */
end_comment

begin_function
specifier|static
name|int
name|setbool
parameter_list|(
name|struct
name|fp_config
modifier|*
name|option
parameter_list|,
name|uint32_t
name|line
name|__unused
parameter_list|,
name|char
modifier|*
name|directive
name|__unused
parameter_list|,
name|char
modifier|*
name|value
parameter_list|)
block|{
if|if
condition|(
name|option
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s:%d:%s: Missing callback parameter"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Abort processing */
block|}
comment|/* Assume ON, check for OFF (case-insensitive) */
name|option
operator|->
name|value
operator|.
name|boolean
operator|=
literal|1
expr_stmt|;
name|strtolower
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"off"
argument_list|)
operator|==
literal|0
condition|)
name|option
operator|->
name|value
operator|.
name|boolean
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * figpar call-back for interpreting value as .dialogrc `Number'  */
end_comment

begin_function
specifier|static
name|int
name|setnum
parameter_list|(
name|struct
name|fp_config
modifier|*
name|option
parameter_list|,
name|uint32_t
name|line
name|__unused
parameter_list|,
name|char
modifier|*
name|directive
name|__unused
parameter_list|,
name|char
modifier|*
name|value
parameter_list|)
block|{
if|if
condition|(
name|option
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s:%d:%s: Missing callback parameter"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Abort processing */
block|}
comment|/* Convert the string to a 32-bit signed integer */
name|option
operator|->
name|value
operator|.
name|num
operator|=
operator|(
name|int32_t
operator|)
name|strtol
argument_list|(
name|value
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * figpar call-back for interpreting value as .dialogrc `String'  */
end_comment

begin_function
specifier|static
name|int
name|setstr
parameter_list|(
name|struct
name|fp_config
modifier|*
name|option
parameter_list|,
name|uint32_t
name|line
name|__unused
parameter_list|,
name|char
modifier|*
name|directive
name|__unused
parameter_list|,
name|char
modifier|*
name|value
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|option
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"%s:%d:%s: Missing callback parameter"
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|,
name|__func__
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Abort processing */
block|}
comment|/* Allocate memory for the data if not already done */
if|if
condition|(
name|option
operator|->
name|value
operator|.
name|str
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|option
operator|->
name|value
operator|.
name|str
operator|=
name|malloc
argument_list|(
name|STR_BUFSIZE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Trim leading quote */
if|if
condition|(
operator|*
name|value
operator|==
literal|'"'
condition|)
name|value
operator|++
expr_stmt|;
comment|/* Write the data into the buffer */
name|snprintf
argument_list|(
name|option
operator|->
name|value
operator|.
name|str
argument_list|,
name|STR_BUFSIZE
argument_list|,
literal|"%s"
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Trim trailing quote */
name|len
operator|=
name|strlen
argument_list|(
name|option
operator|->
name|value
operator|.
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|value
operator|.
name|str
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'"'
condition|)
name|option
operator|->
name|value
operator|.
name|str
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse (in order of preference) $DIALOGRC or `$HOME/.dialogrc'. Returns zero  * on success, -1 on failure (and errno should be consulted).  */
end_comment

begin_function
name|int
name|parse_dialogrc
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|res
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|char
name|path
index|[
name|PATH_MAX
index|]
decl_stmt|;
comment|/* Allow $DIALOGRC to override `$HOME/.dialogrc' default */
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
name|ENV_DIALOGRC
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|snprintf
argument_list|(
name|path
argument_list|,
name|PATH_MAX
argument_list|,
literal|"%s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
name|ENV_HOME
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Copy $HOME into buffer and append trailing `/' if missing */
name|snprintf
argument_list|(
name|path
argument_list|,
name|PATH_MAX
argument_list|,
literal|"%s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|cp
operator|=
name|path
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|len
operator|<
operator|(
name|PATH_MAX
operator|-
literal|1
operator|)
operator|&&
operator|*
operator|(
name|cp
operator|-
literal|1
operator|)
operator|!=
literal|'/'
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'/'
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
comment|/* If we still have room, shove in the name of rc file */
if|if
condition|(
name|len
operator|<
operator|(
name|PATH_MAX
operator|-
literal|1
operator|)
condition|)
name|snprintf
argument_list|(
name|cp
argument_list|,
name|PATH_MAX
operator|-
name|len
argument_list|,
literal|"%s"
argument_list|,
name|DIALOGRC
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Like dialog(1), don't process a file if $HOME is unset */
name|errno
operator|=
name|ENOENT
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Process file (either $DIALOGRC if set, or `$HOME/.dialogrc') */
name|res
operator|=
name|parse_config
argument_list|(
name|dialogrc_config
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|,
name|FP_BREAK_ON_EQUALS
argument_list|)
expr_stmt|;
comment|/* Set some globals based on what we parsed */
name|use_shadow
operator|=
name|dialogrc_config_option
argument_list|(
literal|"use_shadow"
argument_list|)
operator|->
name|value
operator|.
name|boolean
expr_stmt|;
name|use_colors
operator|=
name|dialogrc_config_option
argument_list|(
literal|"use_colors"
argument_list|)
operator|->
name|value
operator|.
name|boolean
expr_stmt|;
name|snprintf
argument_list|(
name|gauge_color
argument_list|,
name|STR_BUFSIZE
argument_list|,
literal|"%s"
argument_list|,
name|dialogrc_config_option
argument_list|(
literal|"gauge_color"
argument_list|)
operator|->
name|value
operator|.
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return a pointer to the `.dialogrc' config option specific to `directive' or  * static fp_dummy_config (full of NULLs) if none found (see  * get_config_option(3); part of figpar(3)).  */
end_comment

begin_function
name|struct
name|fp_config
modifier|*
name|dialogrc_config_option
parameter_list|(
specifier|const
name|char
modifier|*
name|directive
parameter_list|)
block|{
return|return
operator|(
name|get_config_option
argument_list|(
name|dialogrc_config
argument_list|,
name|directive
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free allocated items initialized by setattr() (via parse_config() callback  * matrix [dialogrc_config] used in parse_dialogrc() above).  */
end_comment

begin_function
name|void
name|dialogrc_free
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|value
decl_stmt|;
name|uint32_t
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|dialogrc_config
index|[
name|n
index|]
operator|.
name|directive
operator|!=
name|NULL
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|dialogrc_config
index|[
name|n
index|]
operator|.
name|action
operator|!=
operator|&
name|setattr
condition|)
continue|continue;
name|value
operator|=
name|dialogrc_config
index|[
name|n
index|]
operator|.
name|value
operator|.
name|str
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
operator|&&
name|value
operator|!=
name|gauge_color
condition|)
block|{
name|free
argument_list|(
name|dialogrc_config
index|[
name|n
index|]
operator|.
name|value
operator|.
name|str
argument_list|)
expr_stmt|;
name|dialogrc_config
index|[
name|n
index|]
operator|.
name|value
operator|.
name|str
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

