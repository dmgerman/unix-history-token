begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- tsan_update_shadow_word_inl.h ---------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is a part of ThreadSanitizer (TSan), a race detector.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Body of the hottest inner loop.
end_comment

begin_comment
comment|// If we wrap this body into a function, compilers (both gcc and clang)
end_comment

begin_comment
comment|// produce sligtly less efficient code.
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_do
do|do
block|{
name|StatInc
argument_list|(
name|thr
argument_list|,
name|StatShadowProcessed
argument_list|)
expr_stmt|;
specifier|const
name|unsigned
name|kAccessSize
init|=
literal|1
operator|<<
name|kAccessSizeLog
decl_stmt|;
name|unsigned
name|off
init|=
name|cur
operator|.
name|ComputeSearchOffset
argument_list|()
decl_stmt|;
name|u64
modifier|*
name|sp
init|=
operator|&
name|shadow_mem
index|[
operator|(
name|idx
operator|+
name|off
operator|)
operator|%
name|kShadowCnt
index|]
decl_stmt|;
name|old
operator|=
name|LoadShadow
argument_list|(
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|.
name|IsZero
argument_list|()
condition|)
block|{
name|StatInc
argument_list|(
name|thr
argument_list|,
name|StatShadowZero
argument_list|)
expr_stmt|;
if|if
condition|(
name|store_word
condition|)
name|StoreIfNotYetStored
argument_list|(
name|sp
argument_list|,
operator|&
name|store_word
argument_list|)
expr_stmt|;
comment|// The above StoreIfNotYetStored could be done unconditionally
comment|// and it even shows 4% gain on synthetic benchmarks (r4307).
break|break;
block|}
comment|// is the memory access equal to the previous?
if|if
condition|(
name|Shadow
operator|::
name|Addr0AndSizeAreEqual
argument_list|(
name|cur
argument_list|,
name|old
argument_list|)
condition|)
block|{
name|StatInc
argument_list|(
name|thr
argument_list|,
name|StatShadowSameSize
argument_list|)
expr_stmt|;
comment|// same thread?
if|if
condition|(
name|Shadow
operator|::
name|TidsAreEqual
argument_list|(
name|old
argument_list|,
name|cur
argument_list|)
condition|)
block|{
name|StatInc
argument_list|(
name|thr
argument_list|,
name|StatShadowSameThread
argument_list|)
expr_stmt|;
if|if
condition|(
name|OldIsInSameSynchEpoch
argument_list|(
name|old
argument_list|,
name|thr
argument_list|)
condition|)
block|{
if|if
condition|(
name|old
operator|.
name|IsRWNotWeaker
argument_list|(
name|kAccessIsWrite
argument_list|,
name|kIsAtomic
argument_list|)
condition|)
block|{
comment|// found a slot that holds effectively the same info
comment|// (that is, same tid, same sync epoch and same size)
name|StatInc
argument_list|(
name|thr
argument_list|,
name|StatMopSame
argument_list|)
expr_stmt|;
return|return;
block|}
name|StoreIfNotYetStored
argument_list|(
name|sp
argument_list|,
operator|&
name|store_word
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|old
operator|.
name|IsRWWeakerOrEqual
argument_list|(
name|kAccessIsWrite
argument_list|,
name|kIsAtomic
argument_list|)
condition|)
name|StoreIfNotYetStored
argument_list|(
name|sp
argument_list|,
operator|&
name|store_word
argument_list|)
expr_stmt|;
break|break;
block|}
name|StatInc
argument_list|(
name|thr
argument_list|,
name|StatShadowAnotherThread
argument_list|)
expr_stmt|;
if|if
condition|(
name|HappensBefore
argument_list|(
name|old
argument_list|,
name|thr
argument_list|)
condition|)
block|{
name|StoreIfNotYetStored
argument_list|(
name|sp
argument_list|,
operator|&
name|store_word
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|old
operator|.
name|IsBothReadsOrAtomic
argument_list|(
name|kAccessIsWrite
argument_list|,
name|kIsAtomic
argument_list|)
condition|)
break|break;
goto|goto
name|RACE
goto|;
block|}
comment|// Do the memory access intersect?
if|if
condition|(
name|Shadow
operator|::
name|TwoRangesIntersect
argument_list|(
name|old
argument_list|,
name|cur
argument_list|,
name|kAccessSize
argument_list|)
condition|)
block|{
name|StatInc
argument_list|(
name|thr
argument_list|,
name|StatShadowIntersect
argument_list|)
expr_stmt|;
if|if
condition|(
name|Shadow
operator|::
name|TidsAreEqual
argument_list|(
name|old
argument_list|,
name|cur
argument_list|)
condition|)
block|{
name|StatInc
argument_list|(
name|thr
argument_list|,
name|StatShadowSameThread
argument_list|)
expr_stmt|;
break|break;
block|}
name|StatInc
argument_list|(
name|thr
argument_list|,
name|StatShadowAnotherThread
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|.
name|IsBothReadsOrAtomic
argument_list|(
name|kAccessIsWrite
argument_list|,
name|kIsAtomic
argument_list|)
condition|)
break|break;
if|if
condition|(
name|HappensBefore
argument_list|(
name|old
argument_list|,
name|thr
argument_list|)
condition|)
break|break;
goto|goto
name|RACE
goto|;
block|}
comment|// The accesses do not intersect.
name|StatInc
argument_list|(
name|thr
argument_list|,
name|StatShadowNotIntersect
argument_list|)
expr_stmt|;
break|break;
block|}
do|while
condition|(
literal|0
condition|)
do|;
end_do

end_unit

