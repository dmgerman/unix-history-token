begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2008 Joseph Koshy  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpuset.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/pmc.h>
end_include

begin_include
include|#
directive|include
file|<sys/imgact_aout.h>
end_include

begin_include
include|#
directive|include
file|<sys/imgact_elf.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<pmc.h>
end_include

begin_include
include|#
directive|include
file|<pmclog.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"libpmcstat.h"
end_include

begin_define
define|#
directive|define
name|min
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|((A)< (B) ? (A) : (B))
end_define

begin_define
define|#
directive|define
name|max
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|((A)> (B) ? (A) : (B))
end_define

begin_comment
comment|/*  * Add the list of symbols in the given section to the list associated  * with the object.  */
end_comment

begin_function
name|void
name|pmcstat_image_add_symbols
parameter_list|(
name|struct
name|pmcstat_image
modifier|*
name|image
parameter_list|,
name|Elf
modifier|*
name|e
parameter_list|,
name|Elf_Scn
modifier|*
name|scn
parameter_list|,
name|GElf_Shdr
modifier|*
name|sh
parameter_list|)
block|{
name|int
name|firsttime
decl_stmt|;
name|size_t
name|n
decl_stmt|,
name|newsyms
decl_stmt|,
name|nshsyms
decl_stmt|,
name|nfuncsyms
decl_stmt|;
name|struct
name|pmcstat_symbol
modifier|*
name|symptr
decl_stmt|;
name|char
modifier|*
name|fnname
decl_stmt|;
name|GElf_Sym
name|sym
decl_stmt|;
name|Elf_Data
modifier|*
name|data
decl_stmt|;
if|if
condition|(
operator|(
name|data
operator|=
name|elf_getdata
argument_list|(
name|scn
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
comment|/* 	 * Determine the number of functions named in this 	 * section. 	 */
name|nshsyms
operator|=
name|sh
operator|->
name|sh_size
operator|/
name|sh
operator|->
name|sh_entsize
expr_stmt|;
for|for
control|(
name|n
operator|=
name|nfuncsyms
operator|=
literal|0
init|;
name|n
operator|<
name|nshsyms
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|gelf_getsym
argument_list|(
name|data
argument_list|,
operator|(
name|int
operator|)
name|n
argument_list|,
operator|&
name|sym
argument_list|)
operator|!=
operator|&
name|sym
condition|)
return|return;
if|if
condition|(
name|GELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
operator|==
name|STT_FUNC
condition|)
name|nfuncsyms
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|nfuncsyms
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Allocate space for the new entries. 	 */
name|firsttime
operator|=
name|image
operator|->
name|pi_symbols
operator|==
name|NULL
expr_stmt|;
name|symptr
operator|=
name|reallocarray
argument_list|(
name|image
operator|->
name|pi_symbols
argument_list|,
name|image
operator|->
name|pi_symcount
operator|+
name|nfuncsyms
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|symptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|symptr
operator|==
name|image
operator|->
name|pi_symbols
condition|)
comment|/* realloc() failed. */
return|return;
name|image
operator|->
name|pi_symbols
operator|=
name|symptr
expr_stmt|;
comment|/* 	 * Append new symbols to the end of the current table. 	 */
name|symptr
operator|+=
name|image
operator|->
name|pi_symcount
expr_stmt|;
for|for
control|(
name|n
operator|=
name|newsyms
operator|=
literal|0
init|;
name|n
operator|<
name|nshsyms
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|gelf_getsym
argument_list|(
name|data
argument_list|,
operator|(
name|int
operator|)
name|n
argument_list|,
operator|&
name|sym
argument_list|)
operator|!=
operator|&
name|sym
condition|)
return|return;
if|if
condition|(
name|GELF_ST_TYPE
argument_list|(
name|sym
operator|.
name|st_info
argument_list|)
operator|!=
name|STT_FUNC
condition|)
continue|continue;
if|if
condition|(
name|sym
operator|.
name|st_shndx
operator|==
name|STN_UNDEF
condition|)
continue|continue;
if|if
condition|(
operator|!
name|firsttime
operator|&&
name|pmcstat_symbol_search
argument_list|(
name|image
argument_list|,
name|sym
operator|.
name|st_value
argument_list|)
condition|)
continue|continue;
comment|/* We've seen this symbol already. */
if|if
condition|(
operator|(
name|fnname
operator|=
name|elf_strptr
argument_list|(
name|e
argument_list|,
name|sh
operator|->
name|sh_link
argument_list|,
name|sym
operator|.
name|st_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|__arm__
comment|/* Remove spurious ARM function name. */
if|if
condition|(
name|fnname
index|[
literal|0
index|]
operator|==
literal|'$'
operator|&&
operator|(
name|fnname
index|[
literal|1
index|]
operator|==
literal|'a'
operator|||
name|fnname
index|[
literal|1
index|]
operator|==
literal|'t'
operator|||
name|fnname
index|[
literal|1
index|]
operator|==
literal|'d'
operator|)
operator|&&
name|fnname
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
endif|#
directive|endif
name|symptr
operator|->
name|ps_name
operator|=
name|pmcstat_string_intern
argument_list|(
name|fnname
argument_list|)
expr_stmt|;
name|symptr
operator|->
name|ps_start
operator|=
name|sym
operator|.
name|st_value
operator|-
name|image
operator|->
name|pi_vaddr
expr_stmt|;
name|symptr
operator|->
name|ps_end
operator|=
name|symptr
operator|->
name|ps_start
operator|+
name|sym
operator|.
name|st_size
expr_stmt|;
name|symptr
operator|++
expr_stmt|;
name|newsyms
operator|++
expr_stmt|;
block|}
name|image
operator|->
name|pi_symcount
operator|+=
name|newsyms
expr_stmt|;
if|if
condition|(
name|image
operator|->
name|pi_symcount
operator|==
literal|0
condition|)
return|return;
name|assert
argument_list|(
name|newsyms
operator|<=
name|nfuncsyms
argument_list|)
expr_stmt|;
comment|/* 	 * Return space to the system if there were duplicates. 	 */
if|if
condition|(
name|newsyms
operator|<
name|nfuncsyms
condition|)
name|image
operator|->
name|pi_symbols
operator|=
name|reallocarray
argument_list|(
name|image
operator|->
name|pi_symbols
argument_list|,
name|image
operator|->
name|pi_symcount
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|symptr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Keep the list of symbols sorted. 	 */
name|qsort
argument_list|(
name|image
operator|->
name|pi_symbols
argument_list|,
name|image
operator|->
name|pi_symcount
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|symptr
argument_list|)
argument_list|,
name|pmcstat_symbol_compare
argument_list|)
expr_stmt|;
comment|/* 	 * Deal with function symbols that have a size of 'zero' by 	 * making them extend to the next higher address.  These 	 * symbols are usually defined in assembly code. 	 */
for|for
control|(
name|symptr
operator|=
name|image
operator|->
name|pi_symbols
init|;
name|symptr
operator|<
name|image
operator|->
name|pi_symbols
operator|+
operator|(
name|image
operator|->
name|pi_symcount
operator|-
literal|1
operator|)
condition|;
name|symptr
operator|++
control|)
if|if
condition|(
name|symptr
operator|->
name|ps_start
operator|==
name|symptr
operator|->
name|ps_end
condition|)
name|symptr
operator|->
name|ps_end
operator|=
operator|(
name|symptr
operator|+
literal|1
operator|)
operator|->
name|ps_start
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Record the fact that PC values from 'start' to 'end' come from  * image 'image'.  */
end_comment

begin_function
name|void
name|pmcstat_image_link
parameter_list|(
name|struct
name|pmcstat_process
modifier|*
name|pp
parameter_list|,
name|struct
name|pmcstat_image
modifier|*
name|image
parameter_list|,
name|uintfptr_t
name|start
parameter_list|)
block|{
name|struct
name|pmcstat_pcmap
modifier|*
name|pcm
decl_stmt|,
modifier|*
name|pcmnew
decl_stmt|;
name|uintfptr_t
name|offset
decl_stmt|;
name|assert
argument_list|(
name|image
operator|->
name|pi_type
operator|!=
name|PMCSTAT_IMAGE_UNKNOWN
operator|&&
name|image
operator|->
name|pi_type
operator|!=
name|PMCSTAT_IMAGE_INDETERMINABLE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pcmnew
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pcmnew
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"ERROR: Cannot create a map entry"
argument_list|)
expr_stmt|;
comment|/* 	 * Adjust the map entry to only cover the text portion 	 * of the object. 	 */
name|offset
operator|=
name|start
operator|-
name|image
operator|->
name|pi_vaddr
expr_stmt|;
name|pcmnew
operator|->
name|ppm_lowpc
operator|=
name|image
operator|->
name|pi_start
operator|+
name|offset
expr_stmt|;
name|pcmnew
operator|->
name|ppm_highpc
operator|=
name|image
operator|->
name|pi_end
operator|+
name|offset
expr_stmt|;
name|pcmnew
operator|->
name|ppm_image
operator|=
name|image
expr_stmt|;
name|assert
argument_list|(
name|pcmnew
operator|->
name|ppm_lowpc
operator|<
name|pcmnew
operator|->
name|ppm_highpc
argument_list|)
expr_stmt|;
comment|/* Overlapped mmap()'s are assumed to never occur. */
name|TAILQ_FOREACH
argument_list|(
argument|pcm
argument_list|,
argument|&pp->pp_map
argument_list|,
argument|ppm_next
argument_list|)
if|if
condition|(
name|pcm
operator|->
name|ppm_lowpc
operator|>=
name|pcmnew
operator|->
name|ppm_highpc
condition|)
break|break;
if|if
condition|(
name|pcm
operator|==
name|NULL
condition|)
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|pp
operator|->
name|pp_map
argument_list|,
name|pcmnew
argument_list|,
name|ppm_next
argument_list|)
expr_stmt|;
else|else
name|TAILQ_INSERT_BEFORE
argument_list|(
name|pcm
argument_list|,
name|pcmnew
argument_list|,
name|ppm_next
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Determine whether a given executable image is an A.OUT object, and  * if so, fill in its parameters from the text file.  * Sets image->pi_type.  */
end_comment

begin_function
name|void
name|pmcstat_image_get_aout_params
parameter_list|(
name|struct
name|pmcstat_image
modifier|*
name|image
parameter_list|,
name|struct
name|pmcstat_args
modifier|*
name|args
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|ssize_t
name|nbytes
decl_stmt|;
name|struct
name|exec
name|ex
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|char
name|buffer
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|path
operator|=
name|pmcstat_string_unintern
argument_list|(
name|image
operator|->
name|pi_execpath
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|path
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|image
operator|->
name|pi_iskernelmodule
condition|)
name|errx
argument_list|(
name|EX_SOFTWARE
argument_list|,
literal|"ERROR: a.out kernel modules are unsupported \"%s\""
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|args
operator|->
name|pa_fsroot
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|buffer
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
operator|||
operator|(
name|nbytes
operator|=
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|ex
argument_list|,
sizeof|sizeof
argument_list|(
name|ex
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|args
operator|->
name|pa_verbosity
operator|>=
literal|2
condition|)
name|warn
argument_list|(
literal|"WARNING: Cannot determine type of \"%s\""
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|image
operator|->
name|pi_type
operator|=
name|PMCSTAT_IMAGE_INDETERMINABLE
expr_stmt|;
if|if
condition|(
name|fd
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|nbytes
operator|!=
sizeof|sizeof
argument_list|(
name|ex
argument_list|)
operator|||
name|N_BADMAG
argument_list|(
name|ex
argument_list|)
condition|)
return|return;
name|image
operator|->
name|pi_type
operator|=
name|PMCSTAT_IMAGE_AOUT
expr_stmt|;
comment|/* TODO: the rest of a.out processing */
return|return;
block|}
end_function

begin_comment
comment|/*  * Examine an ELF file to determine the size of its text segment.  * Sets image->pi_type if anything conclusive can be determined about  * this image.  */
end_comment

begin_function
name|void
name|pmcstat_image_get_elf_params
parameter_list|(
name|struct
name|pmcstat_image
modifier|*
name|image
parameter_list|,
name|struct
name|pmcstat_args
modifier|*
name|args
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|nph
decl_stmt|,
name|nsh
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|elfbase
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|endp
decl_stmt|;
name|uintfptr_t
name|minva
decl_stmt|,
name|maxva
decl_stmt|;
name|Elf
modifier|*
name|e
decl_stmt|;
name|Elf_Scn
modifier|*
name|scn
decl_stmt|;
name|GElf_Ehdr
name|eh
decl_stmt|;
name|GElf_Phdr
name|ph
decl_stmt|;
name|GElf_Shdr
name|sh
decl_stmt|;
name|enum
name|pmcstat_image_type
name|image_type
decl_stmt|;
name|char
name|buffer
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|assert
argument_list|(
name|image
operator|->
name|pi_type
operator|==
name|PMCSTAT_IMAGE_UNKNOWN
argument_list|)
expr_stmt|;
name|image
operator|->
name|pi_start
operator|=
name|minva
operator|=
operator|~
operator|(
name|uintfptr_t
operator|)
literal|0
expr_stmt|;
name|image
operator|->
name|pi_end
operator|=
name|maxva
operator|=
operator|(
name|uintfptr_t
operator|)
literal|0
expr_stmt|;
name|image
operator|->
name|pi_type
operator|=
name|image_type
operator|=
name|PMCSTAT_IMAGE_INDETERMINABLE
expr_stmt|;
name|image
operator|->
name|pi_isdynamic
operator|=
literal|0
expr_stmt|;
name|image
operator|->
name|pi_dynlinkerpath
operator|=
name|NULL
expr_stmt|;
name|image
operator|->
name|pi_vaddr
operator|=
literal|0
expr_stmt|;
name|path
operator|=
name|pmcstat_string_unintern
argument_list|(
name|image
operator|->
name|pi_execpath
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|path
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Look for kernel modules under FSROOT/KERNELPATH/NAME, 	 * and user mode executable objects under FSROOT/PATHNAME. 	 */
if|if
condition|(
name|image
operator|->
name|pi_iskernelmodule
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"%s%s/%s"
argument_list|,
name|args
operator|->
name|pa_fsroot
argument_list|,
name|args
operator|->
name|pa_kernel
argument_list|,
name|path
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"%s%s"
argument_list|,
name|args
operator|->
name|pa_fsroot
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|e
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|buffer
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"WARNING: Cannot open \"%s\"."
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|elf_version
argument_list|(
name|EV_CURRENT
argument_list|)
operator|==
name|EV_NONE
condition|)
block|{
name|warnx
argument_list|(
literal|"WARNING: failed to init elf\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
name|e
operator|=
name|elf_begin
argument_list|(
name|fd
argument_list|,
name|ELF_C_READ
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"WARNING: Cannot read \"%s\"."
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|elf_kind
argument_list|(
name|e
argument_list|)
operator|!=
name|ELF_K_ELF
condition|)
block|{
if|if
condition|(
name|args
operator|->
name|pa_verbosity
operator|>=
literal|2
condition|)
name|warnx
argument_list|(
literal|"WARNING: Cannot determine the type of \"%s\"."
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|gelf_getehdr
argument_list|(
name|e
argument_list|,
operator|&
name|eh
argument_list|)
operator|!=
operator|&
name|eh
condition|)
block|{
name|warnx
argument_list|(
literal|"WARNING: Cannot retrieve the ELF Header for \"%s\": %s."
argument_list|,
name|buffer
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|eh
operator|.
name|e_type
operator|!=
name|ET_EXEC
operator|&&
name|eh
operator|.
name|e_type
operator|!=
name|ET_DYN
operator|&&
operator|!
operator|(
name|image
operator|->
name|pi_iskernelmodule
operator|&&
name|eh
operator|.
name|e_type
operator|==
name|ET_REL
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"WARNING: \"%s\" is of an unsupported ELF type."
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|image_type
operator|=
name|eh
operator|.
name|e_ident
index|[
name|EI_CLASS
index|]
operator|==
name|ELFCLASS32
condition|?
name|PMCSTAT_IMAGE_ELF32
else|:
name|PMCSTAT_IMAGE_ELF64
expr_stmt|;
comment|/* 	 * Determine the virtual address where an executable would be 	 * loaded.  Additionally, for dynamically linked executables, 	 * save the pathname to the runtime linker. 	 */
if|if
condition|(
name|eh
operator|.
name|e_type
operator|==
name|ET_EXEC
condition|)
block|{
if|if
condition|(
name|elf_getphnum
argument_list|(
name|e
argument_list|,
operator|&
name|nph
argument_list|)
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"WARNING: Could not determine the number of program headers in \"%s\": %s."
argument_list|,
name|buffer
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|eh
operator|.
name|e_phnum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|gelf_getphdr
argument_list|(
name|e
argument_list|,
name|i
argument_list|,
operator|&
name|ph
argument_list|)
operator|!=
operator|&
name|ph
condition|)
block|{
name|warnx
argument_list|(
literal|"WARNING: Retrieval of PHDR entry #%ju in \"%s\" failed: %s."
argument_list|,
operator|(
name|uintmax_t
operator|)
name|i
argument_list|,
name|buffer
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
switch|switch
condition|(
name|ph
operator|.
name|p_type
condition|)
block|{
case|case
name|PT_DYNAMIC
case|:
name|image
operator|->
name|pi_isdynamic
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|PT_INTERP
case|:
if|if
condition|(
operator|(
name|elfbase
operator|=
name|elf_rawfile
argument_list|(
name|e
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"WARNING: Cannot retrieve the interpreter for \"%s\": %s."
argument_list|,
name|buffer
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|image
operator|->
name|pi_dynlinkerpath
operator|=
name|pmcstat_string_intern
argument_list|(
name|elfbase
operator|+
name|ph
operator|.
name|p_offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|PT_LOAD
case|:
if|if
condition|(
operator|(
name|ph
operator|.
name|p_flags
operator|&
name|PF_X
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|ph
operator|.
name|p_offset
operator|&
operator|(
operator|-
name|ph
operator|.
name|p_align
operator|)
operator|)
operator|==
literal|0
condition|)
name|image
operator|->
name|pi_vaddr
operator|=
name|ph
operator|.
name|p_vaddr
operator|&
operator|(
operator|-
name|ph
operator|.
name|p_align
operator|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* 	 * Get the min and max VA associated with this ELF object. 	 */
if|if
condition|(
name|elf_getshnum
argument_list|(
name|e
argument_list|,
operator|&
name|nsh
argument_list|)
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"WARNING: Could not determine the number of sections for \"%s\": %s."
argument_list|,
name|buffer
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsh
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|scn
operator|=
name|elf_getscn
argument_list|(
name|e
argument_list|,
name|i
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|gelf_getshdr
argument_list|(
name|scn
argument_list|,
operator|&
name|sh
argument_list|)
operator|!=
operator|&
name|sh
condition|)
block|{
name|warnx
argument_list|(
literal|"WARNING: Could not retrieve section header #%ju in \"%s\": %s."
argument_list|,
operator|(
name|uintmax_t
operator|)
name|i
argument_list|,
name|buffer
argument_list|,
name|elf_errmsg
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|sh
operator|.
name|sh_flags
operator|&
name|SHF_EXECINSTR
condition|)
block|{
name|minva
operator|=
name|min
argument_list|(
name|minva
argument_list|,
name|sh
operator|.
name|sh_addr
argument_list|)
expr_stmt|;
name|maxva
operator|=
name|max
argument_list|(
name|maxva
argument_list|,
name|sh
operator|.
name|sh_addr
operator|+
name|sh
operator|.
name|sh_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sh
operator|.
name|sh_type
operator|==
name|SHT_SYMTAB
operator|||
name|sh
operator|.
name|sh_type
operator|==
name|SHT_DYNSYM
condition|)
name|pmcstat_image_add_symbols
argument_list|(
name|image
argument_list|,
name|e
argument_list|,
name|scn
argument_list|,
operator|&
name|sh
argument_list|)
expr_stmt|;
block|}
name|image
operator|->
name|pi_start
operator|=
name|minva
expr_stmt|;
name|image
operator|->
name|pi_end
operator|=
name|maxva
expr_stmt|;
name|image
operator|->
name|pi_type
operator|=
name|image_type
expr_stmt|;
name|image
operator|->
name|pi_fullpath
operator|=
name|pmcstat_string_intern
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
comment|/* Build display name 	 */
name|endp
operator|=
name|buffer
expr_stmt|;
for|for
control|(
name|p
operator|=
name|buffer
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
name|endp
operator|=
name|p
operator|+
literal|1
expr_stmt|;
name|image
operator|->
name|pi_name
operator|=
name|pmcstat_string_intern
argument_list|(
name|endp
argument_list|)
expr_stmt|;
name|done
label|:
operator|(
name|void
operator|)
name|elf_end
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Given an image descriptor, determine whether it is an ELF, or AOUT.  * If no handler claims the image, set its type to 'INDETERMINABLE'.  */
end_comment

begin_function
name|void
name|pmcstat_image_determine_type
parameter_list|(
name|struct
name|pmcstat_image
modifier|*
name|image
parameter_list|,
name|struct
name|pmcstat_args
modifier|*
name|args
parameter_list|)
block|{
name|assert
argument_list|(
name|image
operator|->
name|pi_type
operator|==
name|PMCSTAT_IMAGE_UNKNOWN
argument_list|)
expr_stmt|;
comment|/* Try each kind of handler in turn */
if|if
condition|(
name|image
operator|->
name|pi_type
operator|==
name|PMCSTAT_IMAGE_UNKNOWN
condition|)
name|pmcstat_image_get_elf_params
argument_list|(
name|image
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|image
operator|->
name|pi_type
operator|==
name|PMCSTAT_IMAGE_UNKNOWN
condition|)
name|pmcstat_image_get_aout_params
argument_list|(
name|image
argument_list|,
name|args
argument_list|)
expr_stmt|;
comment|/* 	 * Otherwise, remember that we tried to determine 	 * the object's type and had failed. 	 */
if|if
condition|(
name|image
operator|->
name|pi_type
operator|==
name|PMCSTAT_IMAGE_UNKNOWN
condition|)
name|image
operator|->
name|pi_type
operator|=
name|PMCSTAT_IMAGE_INDETERMINABLE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Locate an image descriptor given an interned path, adding a fresh  * descriptor to the cache if necessary.  This function also finds a  * suitable name for this image's sample file.  *  * We defer filling in the file format specific parts of the image  * structure till the time we actually see a sample that would fall  * into this image.  */
end_comment

begin_function
name|struct
name|pmcstat_image
modifier|*
name|pmcstat_image_from_path
parameter_list|(
name|pmcstat_interned_string
name|internedpath
parameter_list|,
name|int
name|iskernelmodule
parameter_list|,
name|struct
name|pmcstat_args
modifier|*
name|args
parameter_list|,
name|struct
name|pmc_plugins
modifier|*
name|plugins
parameter_list|)
block|{
name|int
name|hash
decl_stmt|;
name|struct
name|pmcstat_image
modifier|*
name|pi
decl_stmt|;
name|hash
operator|=
name|pmcstat_string_lookup_hash
argument_list|(
name|internedpath
argument_list|)
expr_stmt|;
comment|/* First, look for an existing entry. */
name|LIST_FOREACH
argument_list|(
argument|pi
argument_list|,
argument|&pmcstat_image_hash[hash]
argument_list|,
argument|pi_next
argument_list|)
if|if
condition|(
name|pi
operator|->
name|pi_execpath
operator|==
name|internedpath
operator|&&
name|pi
operator|->
name|pi_iskernelmodule
operator|==
name|iskernelmodule
condition|)
return|return
operator|(
name|pi
operator|)
return|;
comment|/* 	 * Allocate a new entry and place it at the head of the hash 	 * and LRU lists. 	 */
name|pi
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pi
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|pi
operator|->
name|pi_type
operator|=
name|PMCSTAT_IMAGE_UNKNOWN
expr_stmt|;
name|pi
operator|->
name|pi_execpath
operator|=
name|internedpath
expr_stmt|;
name|pi
operator|->
name|pi_start
operator|=
operator|~
literal|0
expr_stmt|;
name|pi
operator|->
name|pi_end
operator|=
literal|0
expr_stmt|;
name|pi
operator|->
name|pi_entry
operator|=
literal|0
expr_stmt|;
name|pi
operator|->
name|pi_vaddr
operator|=
literal|0
expr_stmt|;
name|pi
operator|->
name|pi_isdynamic
operator|=
literal|0
expr_stmt|;
name|pi
operator|->
name|pi_iskernelmodule
operator|=
name|iskernelmodule
expr_stmt|;
name|pi
operator|->
name|pi_dynlinkerpath
operator|=
name|NULL
expr_stmt|;
name|pi
operator|->
name|pi_symbols
operator|=
name|NULL
expr_stmt|;
name|pi
operator|->
name|pi_symcount
operator|=
literal|0
expr_stmt|;
name|pi
operator|->
name|pi_addr2line
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|plugins
index|[
name|args
operator|->
name|pa_pplugin
index|]
operator|.
name|pl_initimage
operator|!=
name|NULL
condition|)
name|plugins
index|[
name|args
operator|->
name|pa_pplugin
index|]
operator|.
name|pl_initimage
argument_list|(
name|pi
argument_list|)
expr_stmt|;
if|if
condition|(
name|plugins
index|[
name|args
operator|->
name|pa_plugin
index|]
operator|.
name|pl_initimage
operator|!=
name|NULL
condition|)
name|plugins
index|[
name|args
operator|->
name|pa_plugin
index|]
operator|.
name|pl_initimage
argument_list|(
name|pi
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|pmcstat_image_hash
index|[
name|hash
index|]
argument_list|,
name|pi
argument_list|,
name|pi_next
argument_list|)
expr_stmt|;
return|return
operator|(
name|pi
operator|)
return|;
block|}
end_function

end_unit

