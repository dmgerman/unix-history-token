begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2008 Joseph Koshy  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpuset.h>
end_include

begin_include
include|#
directive|include
file|<sys/event.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/module.h>
end_include

begin_include
include|#
directive|include
file|<sys/pmc.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<pmc.h>
end_include

begin_include
include|#
directive|include
file|<pmclog.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"libpmcstat.h"
end_include

begin_comment
comment|/*  * Associate an AOUT image with a process.  */
end_comment

begin_function
name|void
name|pmcstat_process_aout_exec
parameter_list|(
name|struct
name|pmcstat_process
modifier|*
name|pp
parameter_list|,
name|struct
name|pmcstat_image
modifier|*
name|image
parameter_list|,
name|uintfptr_t
name|entryaddr
parameter_list|)
block|{
operator|(
name|void
operator|)
name|pp
expr_stmt|;
operator|(
name|void
operator|)
name|image
expr_stmt|;
operator|(
name|void
operator|)
name|entryaddr
expr_stmt|;
comment|/* TODO Implement a.out handling */
block|}
end_function

begin_comment
comment|/*  * Associate an ELF image with a process.  */
end_comment

begin_function
name|void
name|pmcstat_process_elf_exec
parameter_list|(
name|struct
name|pmcstat_process
modifier|*
name|pp
parameter_list|,
name|struct
name|pmcstat_image
modifier|*
name|image
parameter_list|,
name|uintfptr_t
name|entryaddr
parameter_list|,
name|struct
name|pmcstat_args
modifier|*
name|args
parameter_list|,
name|struct
name|pmc_plugins
modifier|*
name|plugins
parameter_list|,
name|struct
name|pmcstat_stats
modifier|*
name|pmcstat_stats
parameter_list|)
block|{
name|uintmax_t
name|libstart
decl_stmt|;
name|struct
name|pmcstat_image
modifier|*
name|rtldimage
decl_stmt|;
name|assert
argument_list|(
name|image
operator|->
name|pi_type
operator|==
name|PMCSTAT_IMAGE_ELF32
operator|||
name|image
operator|->
name|pi_type
operator|==
name|PMCSTAT_IMAGE_ELF64
argument_list|)
expr_stmt|;
comment|/* Create a map entry for the base executable. */
name|pmcstat_image_link
argument_list|(
name|pp
argument_list|,
name|image
argument_list|,
name|image
operator|->
name|pi_vaddr
argument_list|)
expr_stmt|;
comment|/* 	 * For dynamically linked executables we need to determine 	 * where the dynamic linker was mapped to for this process, 	 * Subsequent executable objects that are mapped in by the 	 * dynamic linker will be tracked by log events of type 	 * PMCLOG_TYPE_MAP_IN. 	 */
if|if
condition|(
name|image
operator|->
name|pi_isdynamic
condition|)
block|{
comment|/* 		 * The runtime loader gets loaded just after the maximum 		 * possible heap address.  Like so: 		 * 		 * [  TEXT DATA BSS HEAP -->*RTLD  SHLIBS<--STACK] 		 * ^					            ^ 		 * 0				   VM_MAXUSER_ADDRESS  		 * 		 * The exact address where the loader gets mapped in 		 * will vary according to the size of the executable 		 * and the limits on the size of the process'es data 		 * segment at the time of exec().  The entry address 		 * recorded at process exec time corresponds to the 		 * 'start' address inside the dynamic linker.  From 		 * this we can figure out the address where the 		 * runtime loader's file object had been mapped to. 		 */
name|rtldimage
operator|=
name|pmcstat_image_from_path
argument_list|(
name|image
operator|->
name|pi_dynlinkerpath
argument_list|,
literal|0
argument_list|,
name|args
argument_list|,
name|plugins
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtldimage
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"WARNING: Cannot find image for \"%s\"."
argument_list|,
name|pmcstat_string_unintern
argument_list|(
name|image
operator|->
name|pi_dynlinkerpath
argument_list|)
argument_list|)
expr_stmt|;
name|pmcstat_stats
operator|->
name|ps_exec_errors
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|rtldimage
operator|->
name|pi_type
operator|==
name|PMCSTAT_IMAGE_UNKNOWN
condition|)
name|pmcstat_image_get_elf_params
argument_list|(
name|rtldimage
argument_list|,
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtldimage
operator|->
name|pi_type
operator|!=
name|PMCSTAT_IMAGE_ELF32
operator|&&
name|rtldimage
operator|->
name|pi_type
operator|!=
name|PMCSTAT_IMAGE_ELF64
condition|)
block|{
name|warnx
argument_list|(
literal|"WARNING: rtld not an ELF object \"%s\"."
argument_list|,
name|pmcstat_string_unintern
argument_list|(
name|image
operator|->
name|pi_dynlinkerpath
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|libstart
operator|=
name|entryaddr
operator|-
name|rtldimage
operator|->
name|pi_entry
expr_stmt|;
name|pmcstat_image_link
argument_list|(
name|pp
argument_list|,
name|rtldimage
argument_list|,
name|libstart
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Associate an image and a process.  */
end_comment

begin_function
name|void
name|pmcstat_process_exec
parameter_list|(
name|struct
name|pmcstat_process
modifier|*
name|pp
parameter_list|,
name|pmcstat_interned_string
name|path
parameter_list|,
name|uintfptr_t
name|entryaddr
parameter_list|,
name|struct
name|pmcstat_args
modifier|*
name|args
parameter_list|,
name|struct
name|pmc_plugins
modifier|*
name|plugins
parameter_list|,
name|struct
name|pmcstat_stats
modifier|*
name|pmcstat_stats
parameter_list|)
block|{
name|struct
name|pmcstat_image
modifier|*
name|image
decl_stmt|;
if|if
condition|(
operator|(
name|image
operator|=
name|pmcstat_image_from_path
argument_list|(
name|path
argument_list|,
literal|0
argument_list|,
name|args
argument_list|,
name|plugins
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|pmcstat_stats
operator|->
name|ps_exec_errors
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|image
operator|->
name|pi_type
operator|==
name|PMCSTAT_IMAGE_UNKNOWN
condition|)
name|pmcstat_image_determine_type
argument_list|(
name|image
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|image
operator|->
name|pi_type
operator|!=
name|PMCSTAT_IMAGE_UNKNOWN
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|image
operator|->
name|pi_type
condition|)
block|{
case|case
name|PMCSTAT_IMAGE_ELF32
case|:
case|case
name|PMCSTAT_IMAGE_ELF64
case|:
name|pmcstat_stats
operator|->
name|ps_exec_elf
operator|++
expr_stmt|;
name|pmcstat_process_elf_exec
argument_list|(
name|pp
argument_list|,
name|image
argument_list|,
name|entryaddr
argument_list|,
name|args
argument_list|,
name|plugins
argument_list|,
name|pmcstat_stats
argument_list|)
expr_stmt|;
break|break;
case|case
name|PMCSTAT_IMAGE_AOUT
case|:
name|pmcstat_stats
operator|->
name|ps_exec_aout
operator|++
expr_stmt|;
name|pmcstat_process_aout_exec
argument_list|(
name|pp
argument_list|,
name|image
argument_list|,
name|entryaddr
argument_list|)
expr_stmt|;
break|break;
case|case
name|PMCSTAT_IMAGE_INDETERMINABLE
case|:
name|pmcstat_stats
operator|->
name|ps_exec_indeterminable
operator|++
expr_stmt|;
break|break;
default|default:
name|err
argument_list|(
name|EX_SOFTWARE
argument_list|,
literal|"ERROR: Unsupported executable type for \"%s\""
argument_list|,
name|pmcstat_string_unintern
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Find the map entry associated with process 'p' at PC value 'pc'.  */
end_comment

begin_function
name|struct
name|pmcstat_pcmap
modifier|*
name|pmcstat_process_find_map
parameter_list|(
name|struct
name|pmcstat_process
modifier|*
name|p
parameter_list|,
name|uintfptr_t
name|pc
parameter_list|)
block|{
name|struct
name|pmcstat_pcmap
modifier|*
name|ppm
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|ppm
argument_list|,
argument|&p->pp_map
argument_list|,
argument|ppm_next
argument_list|)
block|{
if|if
condition|(
name|pc
operator|>=
name|ppm
operator|->
name|ppm_lowpc
operator|&&
name|pc
operator|<
name|ppm
operator|->
name|ppm_highpc
condition|)
return|return
operator|(
name|ppm
operator|)
return|;
if|if
condition|(
name|pc
operator|<
name|ppm
operator|->
name|ppm_lowpc
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find the process descriptor corresponding to a PID.  If 'allocate'  * is zero, we return a NULL if a pid descriptor could not be found or  * a process descriptor process.  If 'allocate' is non-zero, then we  * will attempt to allocate a fresh process descriptor.  Zombie  * process descriptors are only removed if a fresh allocation for the  * same PID is requested.  */
end_comment

begin_function
name|struct
name|pmcstat_process
modifier|*
name|pmcstat_process_lookup
parameter_list|(
name|pid_t
name|pid
parameter_list|,
name|int
name|allocate
parameter_list|)
block|{
name|uint32_t
name|hash
decl_stmt|;
name|struct
name|pmcstat_pcmap
modifier|*
name|ppm
decl_stmt|,
modifier|*
name|ppmtmp
decl_stmt|;
name|struct
name|pmcstat_process
modifier|*
name|pp
decl_stmt|,
modifier|*
name|pptmp
decl_stmt|;
name|hash
operator|=
operator|(
name|uint32_t
operator|)
name|pid
operator|&
name|PMCSTAT_HASH_MASK
expr_stmt|;
comment|/* simplicity wins */
name|LIST_FOREACH_SAFE
argument_list|(
argument|pp
argument_list|,
argument|&pmcstat_process_hash[hash]
argument_list|,
argument|pp_next
argument_list|,
argument|pptmp
argument_list|)
if|if
condition|(
name|pp
operator|->
name|pp_pid
operator|==
name|pid
condition|)
block|{
comment|/* Found a descriptor, check and process zombies */
if|if
condition|(
name|allocate
operator|&&
name|pp
operator|->
name|pp_isactive
operator|==
literal|0
condition|)
block|{
comment|/* remove maps */
name|TAILQ_FOREACH_SAFE
argument_list|(
argument|ppm
argument_list|,
argument|&pp->pp_map
argument_list|,
argument|ppm_next
argument_list|,
argument|ppmtmp
argument_list|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|pp
operator|->
name|pp_map
argument_list|,
name|ppm
argument_list|,
name|ppm_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ppm
argument_list|)
expr_stmt|;
block|}
comment|/* remove process entry */
name|LIST_REMOVE
argument_list|(
name|pp
argument_list|,
name|pp_next
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pp
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|pp
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|allocate
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|pp
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pp
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"ERROR: Cannot allocate pid descriptor"
argument_list|)
expr_stmt|;
name|pp
operator|->
name|pp_pid
operator|=
name|pid
expr_stmt|;
name|pp
operator|->
name|pp_isactive
operator|=
literal|1
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|pp
operator|->
name|pp_map
argument_list|)
expr_stmt|;
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|pmcstat_process_hash
index|[
name|hash
index|]
argument_list|,
name|pp
argument_list|,
name|pp_next
argument_list|)
expr_stmt|;
return|return
operator|(
name|pp
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pmcstat_create_process
parameter_list|(
name|int
modifier|*
name|pmcstat_sockpair
parameter_list|,
name|struct
name|pmcstat_args
modifier|*
name|args
parameter_list|,
name|int
name|pmcstat_kq
parameter_list|)
block|{
name|char
name|token
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|struct
name|kevent
name|kev
decl_stmt|;
name|struct
name|pmcstat_target
modifier|*
name|pt
decl_stmt|;
if|if
condition|(
name|socketpair
argument_list|(
name|AF_UNIX
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|,
name|pmcstat_sockpair
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"ERROR: cannot create socket pair"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pid
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"ERROR: cannot fork"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
case|case
literal|0
case|:
comment|/* child */
operator|(
name|void
operator|)
name|close
argument_list|(
name|pmcstat_sockpair
index|[
name|PARENTSOCKET
index|]
argument_list|)
expr_stmt|;
comment|/* Write a token to tell our parent we've started executing. */
if|if
condition|(
name|write
argument_list|(
name|pmcstat_sockpair
index|[
name|CHILDSOCKET
index|]
argument_list|,
literal|"+"
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"ERROR (child): cannot write token"
argument_list|)
expr_stmt|;
comment|/* Wait for our parent to signal us to start. */
if|if
condition|(
name|read
argument_list|(
name|pmcstat_sockpair
index|[
name|CHILDSOCKET
index|]
argument_list|,
operator|&
name|token
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"ERROR (child): cannot read token"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|pmcstat_sockpair
index|[
name|CHILDSOCKET
index|]
argument_list|)
expr_stmt|;
comment|/* exec() the program requested */
name|execvp
argument_list|(
operator|*
name|args
operator|->
name|pa_argv
argument_list|,
name|args
operator|->
name|pa_argv
argument_list|)
expr_stmt|;
comment|/* and if that fails, notify the parent */
name|kill
argument_list|(
name|getppid
argument_list|()
argument_list|,
name|SIGCHLD
argument_list|)
expr_stmt|;
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"ERROR: execvp \"%s\" failed"
argument_list|,
operator|*
name|args
operator|->
name|pa_argv
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
default|default:
comment|/* parent */
operator|(
name|void
operator|)
name|close
argument_list|(
name|pmcstat_sockpair
index|[
name|CHILDSOCKET
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Ask to be notified via a kevent when the target process exits. */
name|EV_SET
argument_list|(
operator|&
name|kev
argument_list|,
name|pid
argument_list|,
name|EVFILT_PROC
argument_list|,
name|EV_ADD
operator||
name|EV_ONESHOT
argument_list|,
name|NOTE_EXIT
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|kevent
argument_list|(
name|pmcstat_kq
argument_list|,
operator|&
name|kev
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"ERROR: cannot monitor child process %d"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pt
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pt
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_SOFTWARE
argument_list|,
literal|"ERROR: Out of memory."
argument_list|)
expr_stmt|;
name|pt
operator|->
name|pt_pid
operator|=
name|pid
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|args
operator|->
name|pa_targets
argument_list|,
name|pt
argument_list|,
name|pt_next
argument_list|)
expr_stmt|;
comment|/* Wait for the child to signal that its ready to go. */
if|if
condition|(
name|read
argument_list|(
name|pmcstat_sockpair
index|[
name|PARENTSOCKET
index|]
argument_list|,
operator|&
name|token
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"ERROR (parent): cannot read token"
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Do process profiling  *  * If a pid was specified, attach each allocated PMC to the target  * process.  Otherwise, fork a child and attach the PMCs to the child,  * and have the child exec() the target program.  */
end_comment

begin_function
name|void
name|pmcstat_start_process
parameter_list|(
name|int
modifier|*
name|pmcstat_sockpair
parameter_list|)
block|{
comment|/* Signal the child to proceed. */
if|if
condition|(
name|write
argument_list|(
name|pmcstat_sockpair
index|[
name|PARENTSOCKET
index|]
argument_list|,
literal|"!"
argument_list|,
literal|1
argument_list|)
operator|!=
literal|1
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"ERROR (parent): write of token failed"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|pmcstat_sockpair
index|[
name|PARENTSOCKET
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pmcstat_attach_pmcs
parameter_list|(
name|struct
name|pmcstat_args
modifier|*
name|args
parameter_list|)
block|{
name|struct
name|pmcstat_ev
modifier|*
name|ev
decl_stmt|;
name|struct
name|pmcstat_target
modifier|*
name|pt
decl_stmt|;
name|int
name|count
decl_stmt|;
comment|/* Attach all process PMCs to target processes. */
name|count
operator|=
literal|0
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|ev
argument_list|,
argument|&args->pa_events
argument_list|,
argument|ev_next
argument_list|)
block|{
if|if
condition|(
name|PMC_IS_SYSTEM_MODE
argument_list|(
name|ev
operator|->
name|ev_mode
argument_list|)
condition|)
continue|continue;
name|SLIST_FOREACH
argument_list|(
argument|pt
argument_list|,
argument|&args->pa_targets
argument_list|,
argument|pt_next
argument_list|)
block|{
if|if
condition|(
name|pmc_attach
argument_list|(
name|ev
operator|->
name|ev_pmcid
argument_list|,
name|pt
operator|->
name|pt_pid
argument_list|)
operator|==
literal|0
condition|)
name|count
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|errno
operator|!=
name|ESRCH
condition|)
name|err
argument_list|(
name|EX_OSERR
argument_list|,
literal|"ERROR: cannot attach pmc \"%s\" to process %d"
argument_list|,
name|ev
operator|->
name|ev_name
argument_list|,
operator|(
name|int
operator|)
name|pt
operator|->
name|pt_pid
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
name|errx
argument_list|(
name|EX_DATAERR
argument_list|,
literal|"ERROR: No processes were attached to."
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

