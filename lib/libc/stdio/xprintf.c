begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2005 Poul-Henning Kamp  * Copyright (c) 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Chris Torek.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<namespace.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<namespace.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<wchar.h>
end_include

begin_include
include|#
directive|include
file|<un-namespace.h>
end_include

begin_include
include|#
directive|include
file|"printf.h"
end_include

begin_include
include|#
directive|include
file|"fvwrite.h"
end_include

begin_decl_stmt
name|int
name|__use_xprintf
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* private stuff -----------------------------------------------------*/
end_comment

begin_union
union|union
name|arg
block|{
name|int
name|intarg
decl_stmt|;
name|long
name|longarg
decl_stmt|;
name|intmax_t
name|intmaxarg
decl_stmt|;
ifndef|#
directive|ifndef
name|NO_FLOATING_POINT
name|double
name|doublearg
decl_stmt|;
name|long
name|double
name|longdoublearg
decl_stmt|;
endif|#
directive|endif
name|wint_t
name|wintarg
decl_stmt|;
name|char
modifier|*
name|pchararg
decl_stmt|;
name|wchar_t
modifier|*
name|pwchararg
decl_stmt|;
name|void
modifier|*
name|pvoidarg
decl_stmt|;
block|}
union|;
end_union

begin_comment
comment|/*  * Macros for converting digits to letters and vice versa  */
end_comment

begin_define
define|#
directive|define
name|to_digit
parameter_list|(
name|c
parameter_list|)
value|((c) - '0')
end_define

begin_define
define|#
directive|define
name|is_digit
parameter_list|(
name|c
parameter_list|)
value|(((unsigned)to_digit(c))<= 9)
end_define

begin_comment
comment|/* various globals ---------------------------------------------------*/
end_comment

begin_decl_stmt
specifier|const
name|char
name|__lowercase_hex
index|[
literal|17
index|]
init|=
literal|"0123456789abcdef?"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*lint !e784 */
end_comment

begin_decl_stmt
specifier|const
name|char
name|__uppercase_hex
index|[
literal|17
index|]
init|=
literal|"0123456789ABCDEF?"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*lint !e784 */
end_comment

begin_define
define|#
directive|define
name|PADSIZE
value|16
end_define

begin_decl_stmt
specifier|static
name|char
name|blanks
index|[
name|PADSIZE
index|]
init|=
block|{
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|,
literal|' '
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|zeroes
index|[
name|PADSIZE
index|]
init|=
block|{
literal|'0'
block|,
literal|'0'
block|,
literal|'0'
block|,
literal|'0'
block|,
literal|'0'
block|,
literal|'0'
block|,
literal|'0'
block|,
literal|'0'
block|,
literal|'0'
block|,
literal|'0'
block|,
literal|'0'
block|,
literal|'0'
block|,
literal|'0'
block|,
literal|'0'
block|,
literal|'0'
block|,
literal|'0'
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* printing and padding functions ------------------------------------*/
end_comment

begin_define
define|#
directive|define
name|NIOV
value|8
end_define

begin_struct
struct|struct
name|__printf_io
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|__suio
name|uio
decl_stmt|;
name|struct
name|__siov
name|iov
index|[
name|NIOV
index|]
decl_stmt|;
name|struct
name|__siov
modifier|*
name|iovp
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|__printf_init
parameter_list|(
name|struct
name|__printf_io
modifier|*
name|io
parameter_list|)
block|{
name|io
operator|->
name|uio
operator|.
name|uio_iov
operator|=
name|io
operator|->
name|iovp
operator|=
operator|&
name|io
operator|->
name|iov
index|[
literal|0
index|]
expr_stmt|;
name|io
operator|->
name|uio
operator|.
name|uio_resid
operator|=
literal|0
expr_stmt|;
name|io
operator|->
name|uio
operator|.
name|uio_iovcnt
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|__printf_flush
parameter_list|(
name|struct
name|__printf_io
modifier|*
name|io
parameter_list|)
block|{
name|__sfvwrite
argument_list|(
name|io
operator|->
name|fp
argument_list|,
operator|&
name|io
operator|->
name|uio
argument_list|)
expr_stmt|;
name|__printf_init
argument_list|(
name|io
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|__printf_puts
parameter_list|(
name|struct
name|__printf_io
modifier|*
name|io
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
if|if
condition|(
name|io
operator|->
name|fp
operator|->
name|_flags
operator|&
name|__SERR
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|io
operator|->
name|iovp
operator|->
name|iov_base
operator|=
name|__DECONST
argument_list|(
name|void
operator|*
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|io
operator|->
name|iovp
operator|->
name|iov_len
operator|=
name|len
expr_stmt|;
name|io
operator|->
name|uio
operator|.
name|uio_resid
operator|+=
name|len
expr_stmt|;
name|io
operator|->
name|iovp
operator|++
expr_stmt|;
name|io
operator|->
name|uio
operator|.
name|uio_iovcnt
operator|++
expr_stmt|;
if|if
condition|(
name|io
operator|->
name|uio
operator|.
name|uio_iovcnt
operator|>=
name|NIOV
condition|)
name|__printf_flush
argument_list|(
name|io
argument_list|)
expr_stmt|;
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_function
name|int
name|__printf_pad
parameter_list|(
name|struct
name|__printf_io
modifier|*
name|io
parameter_list|,
name|int
name|howmany
parameter_list|,
name|int
name|zero
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
specifier|const
name|char
modifier|*
name|with
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|zero
condition|)
name|with
operator|=
name|zeroes
expr_stmt|;
else|else
name|with
operator|=
name|blanks
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
operator|(
name|howmany
operator|)
operator|)
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|n
operator|>
name|PADSIZE
condition|)
block|{
name|ret
operator|+=
name|__printf_puts
argument_list|(
name|io
argument_list|,
name|with
argument_list|,
name|PADSIZE
argument_list|)
expr_stmt|;
name|n
operator|-=
name|PADSIZE
expr_stmt|;
block|}
name|ret
operator|+=
name|__printf_puts
argument_list|(
name|io
argument_list|,
name|with
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|__printf_out
parameter_list|(
name|struct
name|__printf_io
modifier|*
name|io
parameter_list|,
specifier|const
name|struct
name|printf_info
modifier|*
name|pi
parameter_list|,
specifier|const
name|void
modifier|*
name|ptr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|pi
operator|->
name|left
operator|)
operator|&&
name|pi
operator|->
name|width
operator|>
name|len
condition|)
name|ret
operator|+=
name|__printf_pad
argument_list|(
name|io
argument_list|,
name|pi
operator|->
name|width
operator|-
name|len
argument_list|,
name|pi
operator|->
name|pad
operator|==
literal|'0'
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|__printf_puts
argument_list|(
name|io
argument_list|,
name|ptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|left
operator|&&
name|pi
operator|->
name|width
operator|>
name|len
condition|)
name|ret
operator|+=
name|__printf_pad
argument_list|(
name|io
argument_list|,
name|pi
operator|->
name|width
operator|-
name|len
argument_list|,
name|pi
operator|->
name|pad
operator|==
literal|'0'
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* percent handling  -------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|__printf_arginfo_pct
parameter_list|(
specifier|const
name|struct
name|printf_info
modifier|*
name|pi
name|__unused
parameter_list|,
name|size_t
name|n
name|__unused
parameter_list|,
name|int
modifier|*
name|argt
name|__unused
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__printf_render_pct
parameter_list|(
name|struct
name|__printf_io
modifier|*
name|io
parameter_list|,
specifier|const
name|struct
name|printf_info
modifier|*
name|pi
name|__unused
parameter_list|,
specifier|const
name|void
modifier|*
specifier|const
modifier|*
name|arg
name|__unused
parameter_list|)
block|{
return|return
operator|(
name|__printf_puts
argument_list|(
name|io
argument_list|,
literal|"%"
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* 'n' ---------------------------------------------------------------*/
end_comment

begin_function
specifier|static
name|int
name|__printf_arginfo_n
parameter_list|(
specifier|const
name|struct
name|printf_info
modifier|*
name|pi
parameter_list|,
name|size_t
name|n
parameter_list|,
name|int
modifier|*
name|argt
parameter_list|)
block|{
name|assert
argument_list|(
name|n
operator|>=
literal|1
argument_list|)
expr_stmt|;
name|argt
index|[
literal|0
index|]
operator|=
name|PA_POINTER
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is a printf_render so that all output has been flushed before it  * gets called.  */
end_comment

begin_function
specifier|static
name|int
name|__printf_render_n
parameter_list|(
name|FILE
modifier|*
name|io
name|__unused
parameter_list|,
specifier|const
name|struct
name|printf_info
modifier|*
name|pi
parameter_list|,
specifier|const
name|void
modifier|*
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|pi
operator|->
name|is_char
condition|)
operator|*
operator|*
operator|(
operator|(
name|signed
name|char
operator|*
operator|*
operator|)
name|arg
index|[
literal|0
index|]
operator|)
operator|=
operator|(
name|signed
name|char
operator|)
name|pi
operator|->
name|sofar
expr_stmt|;
elseif|else
if|if
condition|(
name|pi
operator|->
name|is_short
condition|)
operator|*
operator|*
operator|(
operator|(
name|short
operator|*
operator|*
operator|)
name|arg
index|[
literal|0
index|]
operator|)
operator|=
operator|(
name|short
operator|)
name|pi
operator|->
name|sofar
expr_stmt|;
elseif|else
if|if
condition|(
name|pi
operator|->
name|is_long
condition|)
operator|*
operator|*
operator|(
operator|(
name|long
operator|*
operator|*
operator|)
name|arg
index|[
literal|0
index|]
operator|)
operator|=
name|pi
operator|->
name|sofar
expr_stmt|;
elseif|else
if|if
condition|(
name|pi
operator|->
name|is_long_double
condition|)
operator|*
operator|*
operator|(
operator|(
name|long
name|long
operator|*
operator|*
operator|)
name|arg
index|[
literal|0
index|]
operator|)
operator|=
name|pi
operator|->
name|sofar
expr_stmt|;
elseif|else
if|if
condition|(
name|pi
operator|->
name|is_intmax
condition|)
operator|*
operator|*
operator|(
operator|(
name|intmax_t
operator|*
operator|*
operator|)
name|arg
index|[
literal|0
index|]
operator|)
operator|=
name|pi
operator|->
name|sofar
expr_stmt|;
elseif|else
if|if
condition|(
name|pi
operator|->
name|is_ptrdiff
condition|)
operator|*
operator|*
operator|(
operator|(
name|ptrdiff_t
operator|*
operator|*
operator|)
name|arg
index|[
literal|0
index|]
operator|)
operator|=
name|pi
operator|->
name|sofar
expr_stmt|;
elseif|else
if|if
condition|(
name|pi
operator|->
name|is_quad
condition|)
operator|*
operator|*
operator|(
operator|(
name|quad_t
operator|*
operator|*
operator|)
name|arg
index|[
literal|0
index|]
operator|)
operator|=
name|pi
operator|->
name|sofar
expr_stmt|;
elseif|else
if|if
condition|(
name|pi
operator|->
name|is_size
condition|)
operator|*
operator|*
operator|(
operator|(
name|size_t
operator|*
operator|*
operator|)
name|arg
index|[
literal|0
index|]
operator|)
operator|=
name|pi
operator|->
name|sofar
expr_stmt|;
else|else
operator|*
operator|*
operator|(
operator|(
name|int
operator|*
operator|*
operator|)
name|arg
index|[
literal|0
index|]
operator|)
operator|=
name|pi
operator|->
name|sofar
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* table -------------------------------------------------------------*/
end_comment

begin_comment
comment|/*lint -esym(785, printf_tbl) */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|printf_arginfo_function
modifier|*
name|arginfo
decl_stmt|;
name|printf_function
modifier|*
name|gnurender
decl_stmt|;
name|printf_render
modifier|*
name|render
decl_stmt|;
block|}
name|printf_tbl
index|[
literal|256
index|]
init|=
block|{
index|[
literal|'%'
index|]
operator|=
block|{
name|__printf_arginfo_pct
block|,
name|NULL
block|,
name|__printf_render_pct
block|}
block|,
index|[
literal|'A'
index|]
operator|=
block|{
name|__printf_arginfo_float
block|,
name|NULL
block|,
name|__printf_render_float
block|}
block|,
index|[
literal|'C'
index|]
operator|=
block|{
name|__printf_arginfo_chr
block|,
name|NULL
block|,
name|__printf_render_chr
block|}
block|,
index|[
literal|'E'
index|]
operator|=
block|{
name|__printf_arginfo_float
block|,
name|NULL
block|,
name|__printf_render_float
block|}
block|,
index|[
literal|'F'
index|]
operator|=
block|{
name|__printf_arginfo_float
block|,
name|NULL
block|,
name|__printf_render_float
block|}
block|,
index|[
literal|'G'
index|]
operator|=
block|{
name|__printf_arginfo_float
block|,
name|NULL
block|,
name|__printf_render_float
block|}
block|,
index|[
literal|'S'
index|]
operator|=
block|{
name|__printf_arginfo_str
block|,
name|NULL
block|,
name|__printf_render_str
block|}
block|,
index|[
literal|'X'
index|]
operator|=
block|{
name|__printf_arginfo_int
block|,
name|NULL
block|,
name|__printf_render_int
block|}
block|,
index|[
literal|'a'
index|]
operator|=
block|{
name|__printf_arginfo_float
block|,
name|NULL
block|,
name|__printf_render_float
block|}
block|,
index|[
literal|'c'
index|]
operator|=
block|{
name|__printf_arginfo_chr
block|,
name|NULL
block|,
name|__printf_render_chr
block|}
block|,
index|[
literal|'d'
index|]
operator|=
block|{
name|__printf_arginfo_int
block|,
name|NULL
block|,
name|__printf_render_int
block|}
block|,
index|[
literal|'e'
index|]
operator|=
block|{
name|__printf_arginfo_float
block|,
name|NULL
block|,
name|__printf_render_float
block|}
block|,
index|[
literal|'f'
index|]
operator|=
block|{
name|__printf_arginfo_float
block|,
name|NULL
block|,
name|__printf_render_float
block|}
block|,
index|[
literal|'g'
index|]
operator|=
block|{
name|__printf_arginfo_float
block|,
name|NULL
block|,
name|__printf_render_float
block|}
block|,
index|[
literal|'i'
index|]
operator|=
block|{
name|__printf_arginfo_int
block|,
name|NULL
block|,
name|__printf_render_int
block|}
block|,
index|[
literal|'n'
index|]
operator|=
block|{
name|__printf_arginfo_n
block|,
name|__printf_render_n
block|,
name|NULL
block|}
block|,
index|[
literal|'o'
index|]
operator|=
block|{
name|__printf_arginfo_int
block|,
name|NULL
block|,
name|__printf_render_int
block|}
block|,
index|[
literal|'p'
index|]
operator|=
block|{
name|__printf_arginfo_ptr
block|,
name|NULL
block|,
name|__printf_render_ptr
block|}
block|,
index|[
literal|'q'
index|]
operator|=
block|{
name|__printf_arginfo_int
block|,
name|NULL
block|,
name|__printf_render_int
block|}
block|,
index|[
literal|'s'
index|]
operator|=
block|{
name|__printf_arginfo_str
block|,
name|NULL
block|,
name|__printf_render_str
block|}
block|,
index|[
literal|'u'
index|]
operator|=
block|{
name|__printf_arginfo_int
block|,
name|NULL
block|,
name|__printf_render_int
block|}
block|,
index|[
literal|'x'
index|]
operator|=
block|{
name|__printf_arginfo_int
block|,
name|NULL
block|,
name|__printf_render_int
block|}
block|, }
struct|;
end_struct

begin_function
specifier|static
name|int
name|__v2printf
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt0
parameter_list|,
name|unsigned
name|pct
parameter_list|,
specifier|const
name|va_list
name|ap
parameter_list|)
block|{
name|struct
name|printf_info
modifier|*
name|pi
decl_stmt|,
modifier|*
name|pil
decl_stmt|;
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|struct
name|printf_info
name|pia
index|[
name|pct
operator|+
literal|10
index|]
decl_stmt|;
name|int
name|argt
index|[
name|pct
operator|+
literal|10
index|]
decl_stmt|;
name|union
name|arg
name|args
index|[
name|pct
operator|+
literal|10
index|]
decl_stmt|;
name|int
name|nextarg
decl_stmt|;
name|int
name|maxarg
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|int
name|n
decl_stmt|;
name|struct
name|__printf_io
name|io
decl_stmt|;
name|__printf_init
argument_list|(
operator|&
name|io
argument_list|)
expr_stmt|;
name|io
operator|.
name|fp
operator|=
name|fp
expr_stmt|;
name|fmt
operator|=
name|fmt0
expr_stmt|;
name|maxarg
operator|=
literal|0
expr_stmt|;
name|nextarg
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
name|argt
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|argt
argument_list|)
expr_stmt|;
for|for
control|(
name|pi
operator|=
name|pia
init|;
condition|;
name|pi
operator|++
control|)
block|{
name|memset
argument_list|(
name|pi
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|pi
argument_list|)
expr_stmt|;
name|pil
operator|=
name|pi
expr_stmt|;
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'\0'
condition|)
break|break;
name|pil
operator|=
name|pi
operator|+
literal|1
expr_stmt|;
name|pi
operator|->
name|prec
operator|=
operator|-
literal|1
expr_stmt|;
name|pi
operator|->
name|pad
operator|=
literal|' '
expr_stmt|;
name|pi
operator|->
name|begin
operator|=
name|pi
operator|->
name|end
operator|=
name|fmt
expr_stmt|;
while|while
condition|(
operator|*
name|fmt
operator|!=
literal|'\0'
operator|&&
operator|*
name|fmt
operator|!=
literal|'%'
condition|)
name|pi
operator|->
name|end
operator|=
operator|++
name|fmt
expr_stmt|;
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'\0'
condition|)
break|break;
name|fmt
operator|++
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|pi
operator|->
name|spec
operator|=
operator|*
name|fmt
expr_stmt|;
switch|switch
condition|(
name|pi
operator|->
name|spec
condition|)
block|{
case|case
literal|' '
case|:
comment|/*- 				 * ``If the space and + flags both appear, the space 				 * flag will be ignored.'' 				 *      -- ANSI X3J11 				 */
if|if
condition|(
name|pi
operator|->
name|showsign
operator|==
literal|0
condition|)
name|pi
operator|->
name|showsign
operator|=
literal|' '
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'#'
case|:
name|pi
operator|->
name|alt
operator|=
literal|1
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'.'
case|:
name|pi
operator|->
name|prec
operator|=
literal|0
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'*'
condition|)
block|{
name|fmt
operator|++
expr_stmt|;
name|pi
operator|->
name|get_prec
operator|=
name|nextarg
expr_stmt|;
name|argt
index|[
name|nextarg
operator|++
index|]
operator|=
name|PA_INT
expr_stmt|;
continue|continue;
block|}
while|while
condition|(
operator|*
name|fmt
operator|!=
literal|'\0'
operator|&&
name|is_digit
argument_list|(
operator|*
name|fmt
argument_list|)
condition|)
block|{
name|pi
operator|->
name|prec
operator|*=
literal|10
expr_stmt|;
name|pi
operator|->
name|prec
operator|+=
name|to_digit
argument_list|(
operator|*
name|fmt
argument_list|)
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
block|}
continue|continue;
case|case
literal|'-'
case|:
name|pi
operator|->
name|left
operator|=
literal|1
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'+'
case|:
name|pi
operator|->
name|showsign
operator|=
literal|'+'
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'*'
case|:
name|fmt
operator|++
expr_stmt|;
name|pi
operator|->
name|get_width
operator|=
name|nextarg
expr_stmt|;
name|argt
index|[
name|nextarg
operator|++
index|]
operator|=
name|PA_INT
expr_stmt|;
continue|continue;
case|case
literal|'%'
case|:
name|fmt
operator|++
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|pi
operator|->
name|group
operator|=
literal|1
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'0'
case|:
comment|/*- 				 * ``Note that 0 is taken as a flag, not as the 				 * beginning of a field width.'' 				 *      -- ANSI X3J11 				 */
name|pi
operator|->
name|pad
operator|=
literal|'0'
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|fmt
operator|!=
literal|'\0'
operator|&&
name|is_digit
argument_list|(
operator|*
name|fmt
argument_list|)
condition|)
block|{
name|n
operator|*=
literal|10
expr_stmt|;
name|n
operator|+=
name|to_digit
argument_list|(
operator|*
name|fmt
argument_list|)
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'$'
condition|)
block|{
if|if
condition|(
name|nextarg
operator|>
name|maxarg
condition|)
name|maxarg
operator|=
name|nextarg
expr_stmt|;
name|nextarg
operator|=
name|n
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
block|}
else|else
name|pi
operator|->
name|width
operator|=
name|n
expr_stmt|;
continue|continue;
case|case
literal|'D'
case|:
case|case
literal|'O'
case|:
case|case
literal|'U'
case|:
name|pi
operator|->
name|spec
operator|+=
operator|(
literal|'a'
operator|-
literal|'A'
operator|)
expr_stmt|;
name|pi
operator|->
name|is_intmax
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|is_long_double
operator|||
name|pi
operator|->
name|is_quad
condition|)
block|{
name|pi
operator|->
name|is_long
operator|=
literal|0
expr_stmt|;
name|pi
operator|->
name|is_long_double
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|pi
operator|->
name|is_long
operator|=
literal|1
expr_stmt|;
name|pi
operator|->
name|is_long_double
operator|=
literal|0
expr_stmt|;
block|}
name|fmt
operator|++
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|pi
operator|->
name|is_intmax
operator|=
literal|1
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'q'
case|:
name|pi
operator|->
name|is_long
operator|=
literal|0
expr_stmt|;
name|pi
operator|->
name|is_quad
operator|=
literal|1
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'L'
case|:
name|pi
operator|->
name|is_long_double
operator|=
literal|1
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'h'
case|:
name|fmt
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'h'
condition|)
block|{
name|fmt
operator|++
expr_stmt|;
name|pi
operator|->
name|is_char
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|pi
operator|->
name|is_short
operator|=
literal|1
expr_stmt|;
block|}
continue|continue;
case|case
literal|'l'
case|:
name|fmt
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'l'
condition|)
block|{
name|fmt
operator|++
expr_stmt|;
name|pi
operator|->
name|is_long_double
operator|=
literal|1
expr_stmt|;
name|pi
operator|->
name|is_quad
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|pi
operator|->
name|is_quad
operator|=
literal|0
expr_stmt|;
name|pi
operator|->
name|is_long
operator|=
literal|1
expr_stmt|;
block|}
continue|continue;
case|case
literal|'t'
case|:
name|pi
operator|->
name|is_ptrdiff
operator|=
literal|1
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'z'
case|:
name|pi
operator|->
name|is_size
operator|=
literal|1
expr_stmt|;
name|fmt
operator|++
expr_stmt|;
continue|continue;
default|default:
name|fmt
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|printf_tbl
index|[
name|pi
operator|->
name|spec
index|]
operator|.
name|arginfo
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"arginfo[%c] = NULL"
argument_list|,
name|pi
operator|->
name|spec
argument_list|)
expr_stmt|;
name|ch
operator|=
name|printf_tbl
index|[
name|pi
operator|->
name|spec
index|]
operator|.
name|arginfo
argument_list|(
name|pi
argument_list|,
name|__PRINTFMAXARG
argument_list|,
operator|&
name|argt
index|[
name|nextarg
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|>
literal|0
condition|)
name|pi
operator|->
name|arg
index|[
literal|0
index|]
operator|=
operator|&
name|args
index|[
name|nextarg
index|]
expr_stmt|;
if|if
condition|(
name|ch
operator|>
literal|1
condition|)
name|pi
operator|->
name|arg
index|[
literal|1
index|]
operator|=
operator|&
name|args
index|[
name|nextarg
operator|+
literal|1
index|]
expr_stmt|;
name|nextarg
operator|+=
name|ch
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|nextarg
operator|>
name|maxarg
condition|)
name|maxarg
operator|=
name|nextarg
expr_stmt|;
if|#
directive|if
literal|0
block|fprintf(stderr, "fmt0<%s>\n", fmt0); 	fprintf(stderr, "pil %p\n", pil);
endif|#
directive|endif
for|for
control|(
name|ch
operator|=
literal|1
init|;
name|ch
operator|<
name|maxarg
condition|;
name|ch
operator|++
control|)
block|{
if|#
directive|if
literal|0
block|fprintf(stderr, "arg %d %x\n", ch, argt[ch]);
endif|#
directive|endif
switch|switch
condition|(
name|argt
index|[
name|ch
index|]
condition|)
block|{
case|case
name|PA_CHAR
case|:
name|args
index|[
name|ch
index|]
operator|.
name|intarg
operator|=
operator|(
name|char
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
name|PA_INT
case|:
name|args
index|[
name|ch
index|]
operator|.
name|intarg
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
name|PA_INT
operator||
name|PA_FLAG_SHORT
case|:
name|args
index|[
name|ch
index|]
operator|.
name|intarg
operator|=
operator|(
name|short
operator|)
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
break|break;
case|case
name|PA_INT
operator||
name|PA_FLAG_LONG
case|:
name|args
index|[
name|ch
index|]
operator|.
name|longarg
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|long
argument_list|)
expr_stmt|;
break|break;
case|case
name|PA_INT
operator||
name|PA_FLAG_INTMAX
case|:
name|args
index|[
name|ch
index|]
operator|.
name|intmaxarg
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|intmax_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|PA_INT
operator||
name|PA_FLAG_QUAD
case|:
name|args
index|[
name|ch
index|]
operator|.
name|intmaxarg
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|quad_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|PA_INT
operator||
name|PA_FLAG_LONG_LONG
case|:
name|args
index|[
name|ch
index|]
operator|.
name|intmaxarg
operator|=
name|va_arg
argument_list|(
argument|ap
argument_list|,
argument|long long
argument_list|)
expr_stmt|;
break|break;
case|case
name|PA_INT
operator||
name|PA_FLAG_SIZE
case|:
name|args
index|[
name|ch
index|]
operator|.
name|intmaxarg
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|size_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|PA_INT
operator||
name|PA_FLAG_PTRDIFF
case|:
name|args
index|[
name|ch
index|]
operator|.
name|intmaxarg
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|ptrdiff_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|PA_WCHAR
case|:
name|args
index|[
name|ch
index|]
operator|.
name|wintarg
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|wint_t
argument_list|)
expr_stmt|;
break|break;
case|case
name|PA_POINTER
case|:
name|args
index|[
name|ch
index|]
operator|.
name|pvoidarg
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|PA_STRING
case|:
name|args
index|[
name|ch
index|]
operator|.
name|pchararg
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|PA_WSTRING
case|:
name|args
index|[
name|ch
index|]
operator|.
name|pwchararg
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|wchar_t
operator|*
argument_list|)
expr_stmt|;
break|break;
case|case
name|PA_DOUBLE
case|:
name|args
index|[
name|ch
index|]
operator|.
name|doublearg
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|double
argument_list|)
expr_stmt|;
break|break;
case|case
name|PA_DOUBLE
operator||
name|PA_FLAG_LONG_DOUBLE
case|:
name|args
index|[
name|ch
index|]
operator|.
name|longdoublearg
operator|=
name|va_arg
argument_list|(
argument|ap
argument_list|,
argument|long double
argument_list|)
expr_stmt|;
break|break;
default|default:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"argtype = %x (fmt = \"%s\")\n"
argument_list|,
name|argt
index|[
name|ch
index|]
argument_list|,
name|fmt0
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|pi
operator|=
name|pia
init|;
name|pi
operator|<
name|pil
condition|;
name|pi
operator|++
control|)
block|{
if|#
directive|if
literal|0
block|fprintf(stderr, "pi %p", pi); 		fprintf(stderr, " spec '%c'", pi->spec); 		fprintf(stderr, " args %d", 		    ((uintptr_t)pi->arg[0] - (uintptr_t)args) / sizeof args[0]); 		if (pi->width) fprintf(stderr, " width %d", pi->width); 		if (pi->pad) fprintf(stderr, " pad 0x%x", pi->pad); 		if (pi->left) fprintf(stderr, " left"); 		if (pi->showsign) fprintf(stderr, " showsign"); 		if (pi->prec != -1) fprintf(stderr, " prec %d", pi->prec); 		if (pi->is_char) fprintf(stderr, " char"); 		if (pi->is_short) fprintf(stderr, " short"); 		if (pi->is_long) fprintf(stderr, " long"); 		if (pi->is_long_double) fprintf(stderr, " long_double"); 		fprintf(stderr, "\n"); 		fprintf(stderr, "\t\"%.*s\"\n", pi->end - pi->begin, pi->begin);
endif|#
directive|endif
if|if
condition|(
name|pi
operator|->
name|get_width
condition|)
block|{
name|pi
operator|->
name|width
operator|=
name|args
index|[
name|pi
operator|->
name|get_width
index|]
operator|.
name|intarg
expr_stmt|;
comment|/*- 			 * ``A negative field width argument is taken as a 			 * - flag followed by a positive field width.'' 			 *      -- ANSI X3J11 			 * They don't exclude field widths read from args. 			 */
if|if
condition|(
name|pi
operator|->
name|width
operator|<
literal|0
condition|)
block|{
name|pi
operator|->
name|left
operator|=
literal|1
expr_stmt|;
name|pi
operator|->
name|width
operator|=
operator|-
name|pi
operator|->
name|width
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pi
operator|->
name|get_prec
condition|)
name|pi
operator|->
name|prec
operator|=
name|args
index|[
name|pi
operator|->
name|get_prec
index|]
operator|.
name|intarg
expr_stmt|;
name|ret
operator|+=
name|__printf_puts
argument_list|(
operator|&
name|io
argument_list|,
name|pi
operator|->
name|begin
argument_list|,
name|pi
operator|->
name|end
operator|-
name|pi
operator|->
name|begin
argument_list|)
expr_stmt|;
if|if
condition|(
name|printf_tbl
index|[
name|pi
operator|->
name|spec
index|]
operator|.
name|gnurender
operator|!=
name|NULL
condition|)
block|{
name|__printf_flush
argument_list|(
operator|&
name|io
argument_list|)
expr_stmt|;
name|pi
operator|->
name|sofar
operator|=
name|ret
expr_stmt|;
name|ret
operator|+=
name|printf_tbl
index|[
name|pi
operator|->
name|spec
index|]
operator|.
name|gnurender
argument_list|(
name|fp
argument_list|,
name|pi
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|pi
operator|->
name|arg
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|printf_tbl
index|[
name|pi
operator|->
name|spec
index|]
operator|.
name|render
operator|!=
name|NULL
condition|)
block|{
name|pi
operator|->
name|sofar
operator|=
name|ret
expr_stmt|;
name|n
operator|=
name|printf_tbl
index|[
name|pi
operator|->
name|spec
index|]
operator|.
name|render
argument_list|(
operator|&
name|io
argument_list|,
name|pi
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|pi
operator|->
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|io
operator|.
name|fp
operator|->
name|_flags
operator||=
name|__SERR
expr_stmt|;
else|else
name|ret
operator|+=
name|n
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pi
operator|->
name|begin
operator|==
name|pi
operator|->
name|end
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"render[%c] = NULL"
argument_list|,
operator|*
name|fmt
argument_list|)
expr_stmt|;
block|}
name|__printf_flush
argument_list|(
operator|&
name|io
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|extern
name|int
name|__fflush
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Helper function for `fprintf to unbuffered unix file': creates a  * temporary buffer.  We only work on write-only files; this avoids  * worries about ungetc buffers and so forth.  */
end_comment

begin_function
specifier|static
name|int
name|__v3printf
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
name|int
name|pct
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|FILE
name|fake
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/* copy the important variables */
name|fake
operator|.
name|_flags
operator|=
name|fp
operator|->
name|_flags
operator|&
operator|~
name|__SNBF
expr_stmt|;
name|fake
operator|.
name|_file
operator|=
name|fp
operator|->
name|_file
expr_stmt|;
name|fake
operator|.
name|_cookie
operator|=
name|fp
operator|->
name|_cookie
expr_stmt|;
name|fake
operator|.
name|_write
operator|=
name|fp
operator|->
name|_write
expr_stmt|;
name|fake
operator|.
name|_extra
operator|=
name|fp
operator|->
name|_extra
expr_stmt|;
comment|/* set up the buffer */
name|fake
operator|.
name|_bf
operator|.
name|_base
operator|=
name|fake
operator|.
name|_p
operator|=
name|buf
expr_stmt|;
name|fake
operator|.
name|_bf
operator|.
name|_size
operator|=
name|fake
operator|.
name|_w
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|fake
operator|.
name|_lbfsize
operator|=
literal|0
expr_stmt|;
comment|/* not actually used, but Just In Case */
comment|/* do the work, then copy any error status */
name|ret
operator|=
name|__v2printf
argument_list|(
operator|&
name|fake
argument_list|,
name|fmt
argument_list|,
name|pct
argument_list|,
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>=
literal|0
operator|&&
name|__fflush
argument_list|(
operator|&
name|fake
argument_list|)
condition|)
name|ret
operator|=
name|EOF
expr_stmt|;
if|if
condition|(
name|fake
operator|.
name|_flags
operator|&
name|__SERR
condition|)
name|fp
operator|->
name|_flags
operator||=
name|__SERR
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|__xvprintf
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt0
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|unsigned
name|u
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Count number of '%' signs handling double '%' signs */
for|for
control|(
name|p
operator|=
name|fmt0
operator|,
name|u
operator|=
literal|0
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|'%'
condition|)
continue|continue;
name|u
operator|++
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'%'
condition|)
name|p
operator|++
expr_stmt|;
block|}
comment|/* optimise fprintf(stderr) (and other unbuffered Unix files) */
if|if
condition|(
operator|(
name|fp
operator|->
name|_flags
operator|&
operator|(
name|__SNBF
operator||
name|__SWR
operator||
name|__SRW
operator|)
operator|)
operator|==
operator|(
name|__SNBF
operator||
name|__SWR
operator|)
operator|&&
name|fp
operator|->
name|_file
operator|>=
literal|0
condition|)
return|return
operator|(
name|__v3printf
argument_list|(
name|fp
argument_list|,
name|fmt0
argument_list|,
name|u
argument_list|,
name|ap
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|__v2printf
argument_list|(
name|fp
argument_list|,
name|fmt0
argument_list|,
name|u
argument_list|,
name|ap
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* extending ---------------------------------------------------------*/
end_comment

begin_function
name|int
name|register_printf_function
parameter_list|(
name|int
name|spec
parameter_list|,
name|printf_function
modifier|*
name|render
parameter_list|,
name|printf_arginfo_function
modifier|*
name|arginfo
parameter_list|)
block|{
if|if
condition|(
name|spec
operator|>
literal|255
operator|||
name|spec
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|printf_tbl
index|[
name|spec
index|]
operator|.
name|gnurender
operator|=
name|render
expr_stmt|;
name|printf_tbl
index|[
name|spec
index|]
operator|.
name|arginfo
operator|=
name|arginfo
expr_stmt|;
name|__use_xprintf
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|register_printf_render
parameter_list|(
name|int
name|spec
parameter_list|,
name|printf_render
modifier|*
name|render
parameter_list|,
name|printf_arginfo_function
modifier|*
name|arginfo
parameter_list|)
block|{
if|if
condition|(
name|spec
operator|>
literal|255
operator|||
name|spec
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|printf_tbl
index|[
name|spec
index|]
operator|.
name|render
operator|=
name|render
expr_stmt|;
name|printf_tbl
index|[
name|spec
index|]
operator|.
name|arginfo
operator|=
name|arginfo
expr_stmt|;
name|__use_xprintf
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|register_printf_render_std
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|specs
parameter_list|)
block|{
for|for
control|(
init|;
operator|*
name|specs
operator|!=
literal|'\0'
condition|;
name|specs
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|specs
condition|)
block|{
case|case
literal|'H'
case|:
name|register_printf_render
argument_list|(
operator|*
name|specs
argument_list|,
name|__printf_render_hexdump
argument_list|,
name|__printf_arginfo_hexdump
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|register_printf_render
argument_list|(
operator|*
name|specs
argument_list|,
name|__printf_render_errno
argument_list|,
name|__printf_arginfo_errno
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
name|register_printf_render
argument_list|(
operator|*
name|specs
argument_list|,
name|__printf_render_quote
argument_list|,
name|__printf_arginfo_quote
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|register_printf_render
argument_list|(
operator|*
name|specs
argument_list|,
name|__printf_render_time
argument_list|,
name|__printf_arginfo_time
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|register_printf_render
argument_list|(
operator|*
name|specs
argument_list|,
name|__printf_render_vis
argument_list|,
name|__printf_arginfo_vis
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

