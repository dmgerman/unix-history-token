begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2005 Poul-Henning Kamp  * Copyright (c) 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Chris Torek.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<namespace.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<wchar.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_define
define|#
directive|define
name|dtoa
value|__dtoa
end_define

begin_define
define|#
directive|define
name|freedtoa
value|__freedtoa
end_define

begin_include
include|#
directive|include
file|<float.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|"gdtoa.h"
end_include

begin_include
include|#
directive|include
file|"floatio.h"
end_include

begin_include
include|#
directive|include
file|"printf.h"
end_include

begin_include
include|#
directive|include
file|<un-namespace.h>
end_include

begin_comment
comment|/*  * The size of the buffer we use as scratch space for integer  * conversions, among other things.  Technically, we would need the  * most space for base 10 conversions with thousands' grouping  * characters between each pair of digits.  100 bytes is a  * conservative overestimate even for a 128-bit uintmax_t.  */
end_comment

begin_define
define|#
directive|define
name|BUF
value|100
end_define

begin_define
define|#
directive|define
name|DEFPREC
value|6
end_define

begin_comment
comment|/* Default FP precision */
end_comment

begin_comment
comment|/* various globals ---------------------------------------------------*/
end_comment

begin_comment
comment|/* padding function---------------------------------------------------*/
end_comment

begin_define
define|#
directive|define
name|PRINTANDPAD
parameter_list|(
name|p
parameter_list|,
name|ep
parameter_list|,
name|len
parameter_list|,
name|with
parameter_list|)
value|do {		\ 	n2 = (ep) - (p);       				\ 	if (n2> (len))					\ 		n2 = (len);				\ 	if (n2> 0)					\ 		ret += __printf_puts(io, (p), n2);		\ 	ret += __printf_pad(io, (len) - (n2> 0 ? n2 : 0), (with));	\ } while(0)
end_define

begin_comment
comment|/* misc --------------------------------------------------------------*/
end_comment

begin_define
define|#
directive|define
name|to_char
parameter_list|(
name|n
parameter_list|)
value|((n) + '0')
end_define

begin_function
specifier|static
name|int
name|exponent
parameter_list|(
name|char
modifier|*
name|p0
parameter_list|,
name|int
name|expo
parameter_list|,
name|int
name|fmtch
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|char
name|expbuf
index|[
name|MAXEXPDIG
index|]
decl_stmt|;
name|p
operator|=
name|p0
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|fmtch
expr_stmt|;
if|if
condition|(
name|expo
operator|<
literal|0
condition|)
block|{
name|expo
operator|=
operator|-
name|expo
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'-'
expr_stmt|;
block|}
else|else
operator|*
name|p
operator|++
operator|=
literal|'+'
expr_stmt|;
name|t
operator|=
name|expbuf
operator|+
name|MAXEXPDIG
expr_stmt|;
if|if
condition|(
name|expo
operator|>
literal|9
condition|)
block|{
do|do
block|{
operator|*
operator|--
name|t
operator|=
name|to_char
argument_list|(
name|expo
operator|%
literal|10
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|expo
operator|/=
literal|10
operator|)
operator|>
literal|9
condition|)
do|;
operator|*
operator|--
name|t
operator|=
name|to_char
argument_list|(
name|expo
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|t
operator|<
name|expbuf
operator|+
name|MAXEXPDIG
condition|;
operator|*
name|p
operator|++
operator|=
operator|*
name|t
operator|++
control|)
empty_stmt|;
block|}
else|else
block|{
comment|/* 		 * Exponents for decimal floating point conversions 		 * (%[eEgG]) must be at least two characters long, 		 * whereas exponents for hexadecimal conversions can 		 * be only one character long. 		 */
if|if
condition|(
name|fmtch
operator|==
literal|'e'
operator|||
name|fmtch
operator|==
literal|'E'
condition|)
operator|*
name|p
operator|++
operator|=
literal|'0'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|to_char
argument_list|(
name|expo
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|-
name|p0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* 'f' ---------------------------------------------------------------*/
end_comment

begin_function
name|int
name|__printf_arginfo_float
parameter_list|(
specifier|const
name|struct
name|printf_info
modifier|*
name|pi
parameter_list|,
name|size_t
name|n
parameter_list|,
name|int
modifier|*
name|argt
parameter_list|)
block|{
name|assert
argument_list|(
name|n
operator|>
literal|0
argument_list|)
expr_stmt|;
name|argt
index|[
literal|0
index|]
operator|=
name|PA_DOUBLE
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|is_long_double
condition|)
name|argt
index|[
literal|0
index|]
operator||=
name|PA_FLAG_LONG_DOUBLE
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We can decompose the printed representation of floating  * point numbers into several parts, some of which may be empty:  *  * [+|-| ] [0x|0X] MMM . NNN [e|E|p|P] [+|-] ZZ  *    A       B     ---C---      D       E   F  *  * A:	'sign' holds this value if present; '\0' otherwise  * B:	ox[1] holds the 'x' or 'X'; '\0' if not hexadecimal  * C:	cp points to the string MMMNNN.  Leading and trailing  *	zeros are not in the string and must be added.  * D:	expchar holds this character; '\0' if no exponent, e.g. %f  * F:	at least two digits for decimal, at least one digit for hex  */
end_comment

begin_function
name|int
name|__printf_render_float
parameter_list|(
name|struct
name|__printf_io
modifier|*
name|io
parameter_list|,
specifier|const
name|struct
name|printf_info
modifier|*
name|pi
parameter_list|,
specifier|const
name|void
modifier|*
specifier|const
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|prec
decl_stmt|;
comment|/* precision from format;<0 for N/A */
name|char
modifier|*
name|dtoaresult
decl_stmt|;
comment|/* buffer allocated by dtoa */
name|char
name|expchar
decl_stmt|;
comment|/* exponent character: [eEpP\0] */
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|expt
decl_stmt|;
comment|/* integer value of exponent */
name|int
name|signflag
decl_stmt|;
comment|/* true if float is negative */
name|char
modifier|*
name|dtoaend
decl_stmt|;
comment|/* pointer to end of converted digits */
name|char
name|sign
decl_stmt|;
comment|/* sign prefix (' ', '+', '-', or \0) */
name|int
name|size
decl_stmt|;
comment|/* size of converted field or string */
name|int
name|ndig
decl_stmt|;
comment|/* actual number of digits returned by dtoa */
name|int
name|expsize
decl_stmt|;
comment|/* character count for expstr */
name|char
name|expstr
index|[
name|MAXEXPDIG
operator|+
literal|2
index|]
decl_stmt|;
comment|/* buffer for exponent string: e+ZZZ */
name|int
name|nseps
decl_stmt|;
comment|/* number of group separators with ' */
name|int
name|nrepeats
decl_stmt|;
comment|/* number of repeats of the last group */
specifier|const
name|char
modifier|*
name|grouping
decl_stmt|;
comment|/* locale specific numeric grouping rules */
name|int
name|lead
decl_stmt|;
comment|/* sig figs before decimal or group sep */
name|long
name|double
name|ld
decl_stmt|;
name|double
name|d
decl_stmt|;
name|int
name|realsz
decl_stmt|;
comment|/* field size expanded by dprec, sign, etc */
name|int
name|dprec
decl_stmt|;
comment|/* a copy of prec if [diouxX], 0 otherwise */
name|char
name|ox
index|[
literal|2
index|]
decl_stmt|;
comment|/* space for 0x; ox[1] is either x, X, or \0 */
name|int
name|ret
decl_stmt|;
comment|/* return value accumulator */
name|char
modifier|*
name|decimal_point
decl_stmt|;
comment|/* locale specific decimal point */
name|int
name|n2
decl_stmt|;
comment|/* XXX: for PRINTANDPAD */
name|char
name|thousands_sep
decl_stmt|;
comment|/* locale specific thousands separator */
name|char
name|buf
index|[
name|BUF
index|]
decl_stmt|;
comment|/* buffer with space for digits of uintmax_t */
specifier|const
name|char
modifier|*
name|xdigs
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|prec
operator|=
name|pi
operator|->
name|prec
expr_stmt|;
name|ox
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|sign
operator|=
name|pi
operator|->
name|showsign
expr_stmt|;
name|flag
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|thousands_sep
operator|=
operator|*
operator|(
name|localeconv
argument_list|()
operator|->
name|thousands_sep
operator|)
expr_stmt|;
name|grouping
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|alt
condition|)
name|grouping
operator|=
name|localeconv
argument_list|()
operator|->
name|grouping
expr_stmt|;
name|decimal_point
operator|=
name|localeconv
argument_list|()
operator|->
name|decimal_point
expr_stmt|;
name|dprec
operator|=
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|pi
operator|->
name|spec
condition|)
block|{
case|case
literal|'a'
case|:
case|case
literal|'A'
case|:
if|if
condition|(
name|pi
operator|->
name|spec
operator|==
literal|'a'
condition|)
block|{
name|ox
index|[
literal|1
index|]
operator|=
literal|'x'
expr_stmt|;
name|xdigs
operator|=
name|__lowercase_hex
expr_stmt|;
name|expchar
operator|=
literal|'p'
expr_stmt|;
block|}
else|else
block|{
name|ox
index|[
literal|1
index|]
operator|=
literal|'X'
expr_stmt|;
name|xdigs
operator|=
name|__uppercase_hex
expr_stmt|;
name|expchar
operator|=
literal|'P'
expr_stmt|;
block|}
if|if
condition|(
name|prec
operator|>=
literal|0
condition|)
name|prec
operator|++
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|is_long_double
condition|)
block|{
name|ld
operator|=
operator|*
operator|(
operator|(
name|long
name|double
operator|*
operator|)
name|arg
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|dtoaresult
operator|=
name|cp
operator|=
name|__hldtoa
argument_list|(
name|ld
argument_list|,
name|xdigs
argument_list|,
name|prec
argument_list|,
operator|&
name|expt
argument_list|,
operator|&
name|signflag
argument_list|,
operator|&
name|dtoaend
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|=
operator|*
operator|(
operator|(
name|double
operator|*
operator|)
name|arg
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|dtoaresult
operator|=
name|cp
operator|=
name|__hdtoa
argument_list|(
name|d
argument_list|,
name|xdigs
argument_list|,
name|prec
argument_list|,
operator|&
name|expt
argument_list|,
operator|&
name|signflag
argument_list|,
operator|&
name|dtoaend
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prec
operator|<
literal|0
condition|)
name|prec
operator|=
name|dtoaend
operator|-
name|cp
expr_stmt|;
if|if
condition|(
name|expt
operator|==
name|INT_MAX
condition|)
name|ox
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
goto|goto
name|fp_common
goto|;
case|case
literal|'e'
case|:
case|case
literal|'E'
case|:
name|expchar
operator|=
name|pi
operator|->
name|spec
expr_stmt|;
if|if
condition|(
name|prec
operator|<
literal|0
condition|)
comment|/* account for digit before decpt */
name|prec
operator|=
name|DEFPREC
operator|+
literal|1
expr_stmt|;
else|else
name|prec
operator|++
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
case|case
literal|'F'
case|:
name|expchar
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
case|case
literal|'G'
case|:
name|expchar
operator|=
name|pi
operator|->
name|spec
operator|-
operator|(
literal|'g'
operator|-
literal|'e'
operator|)
expr_stmt|;
if|if
condition|(
name|prec
operator|==
literal|0
condition|)
name|prec
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
name|pi
operator|->
name|spec
operator|==
literal|'f'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prec
operator|<
literal|0
condition|)
name|prec
operator|=
name|DEFPREC
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|is_long_double
condition|)
block|{
name|ld
operator|=
operator|*
operator|(
operator|(
name|long
name|double
operator|*
operator|)
name|arg
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|dtoaresult
operator|=
name|cp
operator|=
name|__ldtoa
argument_list|(
operator|&
name|ld
argument_list|,
name|expchar
condition|?
literal|2
else|:
literal|3
argument_list|,
name|prec
argument_list|,
operator|&
name|expt
argument_list|,
operator|&
name|signflag
argument_list|,
operator|&
name|dtoaend
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|d
operator|=
operator|*
operator|(
operator|(
name|double
operator|*
operator|)
name|arg
index|[
literal|0
index|]
operator|)
expr_stmt|;
name|dtoaresult
operator|=
name|cp
operator|=
name|dtoa
argument_list|(
name|d
argument_list|,
name|expchar
condition|?
literal|2
else|:
literal|3
argument_list|,
name|prec
argument_list|,
operator|&
name|expt
argument_list|,
operator|&
name|signflag
argument_list|,
operator|&
name|dtoaend
argument_list|)
expr_stmt|;
if|if
condition|(
name|expt
operator|==
literal|9999
condition|)
name|expt
operator|=
name|INT_MAX
expr_stmt|;
block|}
name|fp_common
label|:
if|if
condition|(
name|signflag
condition|)
name|sign
operator|=
literal|'-'
expr_stmt|;
if|if
condition|(
name|expt
operator|==
name|INT_MAX
condition|)
block|{
comment|/* inf or nan */
if|if
condition|(
operator|*
name|cp
operator|==
literal|'N'
condition|)
block|{
name|cp
operator|=
operator|(
name|pi
operator|->
name|spec
operator|>=
literal|'a'
operator|)
condition|?
literal|"nan"
else|:
literal|"NAN"
expr_stmt|;
name|sign
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|cp
operator|=
operator|(
name|pi
operator|->
name|spec
operator|>=
literal|'a'
operator|)
condition|?
literal|"inf"
else|:
literal|"INF"
expr_stmt|;
name|size
operator|=
literal|3
expr_stmt|;
name|flag
operator|=
literal|1
expr_stmt|;
goto|goto
name|here
goto|;
block|}
name|ndig
operator|=
name|dtoaend
operator|-
name|cp
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|spec
operator|==
literal|'g'
operator|||
name|pi
operator|->
name|spec
operator|==
literal|'G'
condition|)
block|{
if|if
condition|(
name|expt
operator|>
operator|-
literal|4
operator|&&
name|expt
operator|<=
name|prec
condition|)
block|{
comment|/* Make %[gG] smell like %[fF] */
name|expchar
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|pi
operator|->
name|alt
condition|)
name|prec
operator|-=
name|expt
expr_stmt|;
else|else
name|prec
operator|=
name|ndig
operator|-
name|expt
expr_stmt|;
if|if
condition|(
name|prec
operator|<
literal|0
condition|)
name|prec
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Make %[gG] smell like %[eE], but 			 * trim trailing zeroes if no # flag. 			 */
if|if
condition|(
operator|!
name|pi
operator|->
name|alt
condition|)
name|prec
operator|=
name|ndig
expr_stmt|;
block|}
block|}
if|if
condition|(
name|expchar
condition|)
block|{
name|expsize
operator|=
name|exponent
argument_list|(
name|expstr
argument_list|,
name|expt
operator|-
literal|1
argument_list|,
name|expchar
argument_list|)
expr_stmt|;
name|size
operator|=
name|expsize
operator|+
name|prec
expr_stmt|;
if|if
condition|(
name|prec
operator|>
literal|1
operator|||
name|pi
operator|->
name|alt
condition|)
operator|++
name|size
expr_stmt|;
block|}
else|else
block|{
comment|/* space for digits before decimal point */
if|if
condition|(
name|expt
operator|>
literal|0
condition|)
name|size
operator|=
name|expt
expr_stmt|;
else|else
comment|/* "0" */
name|size
operator|=
literal|1
expr_stmt|;
comment|/* space for decimal pt and following digits */
if|if
condition|(
name|prec
operator|||
name|pi
operator|->
name|alt
condition|)
name|size
operator|+=
name|prec
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|grouping
operator|&&
name|expt
operator|>
literal|0
condition|)
block|{
comment|/* space for thousands' grouping */
name|nseps
operator|=
name|nrepeats
operator|=
literal|0
expr_stmt|;
name|lead
operator|=
name|expt
expr_stmt|;
while|while
condition|(
operator|*
name|grouping
operator|!=
name|CHAR_MAX
condition|)
block|{
if|if
condition|(
name|lead
operator|<=
operator|*
name|grouping
condition|)
break|break;
name|lead
operator|-=
operator|*
name|grouping
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|grouping
operator|+
literal|1
operator|)
condition|)
block|{
name|nseps
operator|++
expr_stmt|;
name|grouping
operator|++
expr_stmt|;
block|}
else|else
name|nrepeats
operator|++
expr_stmt|;
block|}
name|size
operator|+=
name|nseps
operator|+
name|nrepeats
expr_stmt|;
block|}
else|else
name|lead
operator|=
name|expt
expr_stmt|;
block|}
name|here
label|:
comment|/* 	 * All reasonable formats wind up here.  At this point, `cp' 	 * points to a string which (if not flags&LADJUST) should be 	 * padded out to `width' places.  If flags&ZEROPAD, it should 	 * first be prefixed by any sign or other prefix; otherwise, 	 * it should be blank padded before the prefix is emitted. 	 * After any left-hand padding and prefixing, emit zeroes 	 * required by a decimal [diouxX] precision, then print the 	 * string proper, then emit zeroes required by any leftover 	 * floating precision; finally, if LADJUST, pad with blanks. 	 * 	 * Compute actual size, so we know how much to pad. 	 * size excludes decimal prec; realsz includes it. 	 */
name|realsz
operator|=
name|dprec
operator|>
name|size
condition|?
name|dprec
else|:
name|size
expr_stmt|;
if|if
condition|(
name|sign
condition|)
name|realsz
operator|++
expr_stmt|;
if|if
condition|(
name|ox
index|[
literal|1
index|]
condition|)
name|realsz
operator|+=
literal|2
expr_stmt|;
comment|/* right-adjusting blank padding */
if|if
condition|(
name|pi
operator|->
name|pad
operator|!=
literal|'0'
operator|&&
name|pi
operator|->
name|left
operator|==
literal|0
condition|)
name|ret
operator|+=
name|__printf_pad
argument_list|(
name|io
argument_list|,
name|pi
operator|->
name|width
operator|-
name|realsz
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* prefix */
if|if
condition|(
name|sign
condition|)
name|ret
operator|+=
name|__printf_puts
argument_list|(
name|io
argument_list|,
operator|&
name|sign
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ox
index|[
literal|1
index|]
condition|)
block|{
comment|/* ox[1] is either x, X, or \0 */
name|ox
index|[
literal|0
index|]
operator|=
literal|'0'
expr_stmt|;
name|ret
operator|+=
name|__printf_puts
argument_list|(
name|io
argument_list|,
name|ox
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
comment|/* right-adjusting zero padding */
if|if
condition|(
name|pi
operator|->
name|pad
operator|==
literal|'0'
operator|&&
name|pi
operator|->
name|left
operator|==
literal|0
condition|)
name|ret
operator|+=
name|__printf_pad
argument_list|(
name|io
argument_list|,
name|pi
operator|->
name|width
operator|-
name|realsz
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* leading zeroes from decimal precision */
name|ret
operator|+=
name|__printf_pad
argument_list|(
name|io
argument_list|,
name|dprec
operator|-
name|size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
condition|)
name|ret
operator|+=
name|__printf_puts
argument_list|(
name|io
argument_list|,
name|cp
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* glue together f_p fragments */
if|if
condition|(
operator|!
name|expchar
condition|)
block|{
comment|/* %[fF] or sufficiently short %[gG] */
if|if
condition|(
name|expt
operator|<=
literal|0
condition|)
block|{
name|ret
operator|+=
name|__printf_puts
argument_list|(
name|io
argument_list|,
literal|"0"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|prec
operator|||
name|pi
operator|->
name|alt
condition|)
name|ret
operator|+=
name|__printf_puts
argument_list|(
name|io
argument_list|,
name|decimal_point
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|__printf_pad
argument_list|(
name|io
argument_list|,
operator|-
name|expt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* already handled initial 0's */
name|prec
operator|+=
name|expt
expr_stmt|;
block|}
else|else
block|{
name|PRINTANDPAD
argument_list|(
name|cp
argument_list|,
name|dtoaend
argument_list|,
name|lead
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|lead
expr_stmt|;
if|if
condition|(
name|grouping
condition|)
block|{
while|while
condition|(
name|nseps
operator|>
literal|0
operator|||
name|nrepeats
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|nrepeats
operator|>
literal|0
condition|)
name|nrepeats
operator|--
expr_stmt|;
else|else
block|{
name|grouping
operator|--
expr_stmt|;
name|nseps
operator|--
expr_stmt|;
block|}
name|ret
operator|+=
name|__printf_puts
argument_list|(
name|io
argument_list|,
operator|&
name|thousands_sep
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|PRINTANDPAD
argument_list|(
name|cp
argument_list|,
name|dtoaend
argument_list|,
operator|*
name|grouping
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|cp
operator|+=
operator|*
name|grouping
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|>
name|dtoaend
condition|)
name|cp
operator|=
name|dtoaend
expr_stmt|;
block|}
if|if
condition|(
name|prec
operator|||
name|pi
operator|->
name|alt
condition|)
name|ret
operator|+=
name|__printf_puts
argument_list|(
name|io
argument_list|,
name|decimal_point
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|PRINTANDPAD
argument_list|(
name|cp
argument_list|,
name|dtoaend
argument_list|,
name|prec
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* %[eE] or sufficiently long %[gG] */
if|if
condition|(
name|prec
operator|>
literal|1
operator|||
name|pi
operator|->
name|alt
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
operator|*
name|decimal_point
expr_stmt|;
name|ret
operator|+=
name|__printf_puts
argument_list|(
name|io
argument_list|,
name|buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|__printf_puts
argument_list|(
name|io
argument_list|,
name|cp
argument_list|,
name|ndig
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|__printf_pad
argument_list|(
name|io
argument_list|,
name|prec
operator|-
name|ndig
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* XeYYY */
name|ret
operator|+=
name|__printf_puts
argument_list|(
name|io
argument_list|,
name|cp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|+=
name|__printf_puts
argument_list|(
name|io
argument_list|,
name|expstr
argument_list|,
name|expsize
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* left-adjusting padding (always blank) */
if|if
condition|(
name|pi
operator|->
name|left
condition|)
name|ret
operator|+=
name|__printf_pad
argument_list|(
name|io
argument_list|,
name|pi
operator|->
name|width
operator|-
name|realsz
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__printf_flush
argument_list|(
name|io
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtoaresult
operator|!=
name|NULL
condition|)
name|freedtoa
argument_list|(
name|dtoaresult
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

end_unit

