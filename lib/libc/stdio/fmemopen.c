begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*- Copyright (C) 2013 Pietro Cerutti<gahr@FreeBSD.org>  Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: 1. Redistributions of source code must retain the above copyright    notice, this list of conditions and the following disclaimer. 2. Redistributions in binary form must reproduce the above copyright    notice, this list of conditions and the following disclaimer in the    documentation and/or other materials provided with the distribution.  THIS SOFTWARE IS PROVIDED BY AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_struct
struct|struct
name|__fmemopen_cookie
block|{
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* pointer to the memory region */
name|char
name|own
decl_stmt|;
comment|/* did we allocate the buffer ourselves? */
name|long
name|len
decl_stmt|;
comment|/* buffer length in bytes */
name|long
name|off
decl_stmt|;
comment|/* current offset into the buffer */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|fmemopen_read
parameter_list|(
name|void
modifier|*
name|cookie
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|nbytes
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fmemopen_write
parameter_list|(
name|void
modifier|*
name|cookie
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|nbytes
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|fpos_t
name|fmemopen_seek
parameter_list|(
name|void
modifier|*
name|cookie
parameter_list|,
name|fpos_t
name|offset
parameter_list|,
name|int
name|whence
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fmemopen_close
parameter_list|(
name|void
modifier|*
name|cookie
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|FILE
modifier|*
name|fmemopen
parameter_list|(
name|void
modifier|*
name|__restrict
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|__restrict
name|mode
parameter_list|)
block|{
comment|/* allocate cookie */
name|struct
name|__fmemopen_cookie
modifier|*
name|ck
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|__fmemopen_cookie
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|ck
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ck
operator|->
name|off
operator|=
literal|0
expr_stmt|;
name|ck
operator|->
name|len
operator|=
name|size
expr_stmt|;
comment|/* do we have to allocate the buffer ourselves? */
name|ck
operator|->
name|own
operator|=
operator|(
operator|(
name|ck
operator|->
name|buf
operator|=
name|buf
operator|)
operator|==
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|ck
operator|->
name|own
condition|)
block|{
name|ck
operator|->
name|buf
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ck
operator|->
name|buf
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ck
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ck
operator|->
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|mode
index|[
literal|0
index|]
operator|==
literal|'a'
condition|)
name|ck
operator|->
name|off
operator|=
name|strnlen
argument_list|(
name|ck
operator|->
name|buf
argument_list|,
name|ck
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* actuall wrapper */
name|FILE
modifier|*
name|f
init|=
name|funopen
argument_list|(
operator|(
name|void
operator|*
operator|)
name|ck
argument_list|,
name|fmemopen_read
argument_list|,
name|fmemopen_write
argument_list|,
name|fmemopen_seek
argument_list|,
name|fmemopen_close
argument_list|)
decl_stmt|;
if|if
condition|(
name|f
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ck
operator|->
name|own
condition|)
name|free
argument_list|(
name|ck
operator|->
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ck
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* turn off buffering, so a write past the end of the buffer 	 * correctly returns a short object count */
name|setvbuf
argument_list|(
name|f
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
name|_IONBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|f
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fmemopen_read
parameter_list|(
name|void
modifier|*
name|cookie
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|nbytes
parameter_list|)
block|{
name|struct
name|__fmemopen_cookie
modifier|*
name|ck
init|=
name|cookie
decl_stmt|;
if|if
condition|(
name|nbytes
operator|>
name|ck
operator|->
name|len
operator|-
name|ck
operator|->
name|off
condition|)
name|nbytes
operator|=
name|ck
operator|->
name|len
operator|-
name|ck
operator|->
name|off
expr_stmt|;
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|ck
operator|->
name|buf
operator|+
name|ck
operator|->
name|off
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|ck
operator|->
name|off
operator|+=
name|nbytes
expr_stmt|;
return|return
operator|(
name|nbytes
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fmemopen_write
parameter_list|(
name|void
modifier|*
name|cookie
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|nbytes
parameter_list|)
block|{
name|struct
name|__fmemopen_cookie
modifier|*
name|ck
init|=
name|cookie
decl_stmt|;
if|if
condition|(
name|nbytes
operator|>
name|ck
operator|->
name|len
operator|-
name|ck
operator|->
name|off
condition|)
name|nbytes
operator|=
name|ck
operator|->
name|len
operator|-
name|ck
operator|->
name|off
expr_stmt|;
if|if
condition|(
name|nbytes
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|memcpy
argument_list|(
name|ck
operator|->
name|buf
operator|+
name|ck
operator|->
name|off
argument_list|,
name|buf
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|ck
operator|->
name|off
operator|+=
name|nbytes
expr_stmt|;
if|if
condition|(
name|ck
operator|->
name|off
operator|<
name|ck
operator|->
name|len
operator|&&
name|ck
operator|->
name|buf
index|[
name|ck
operator|->
name|off
operator|-
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|ck
operator|->
name|buf
index|[
name|ck
operator|->
name|off
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|nbytes
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|fpos_t
name|fmemopen_seek
parameter_list|(
name|void
modifier|*
name|cookie
parameter_list|,
name|fpos_t
name|offset
parameter_list|,
name|int
name|whence
parameter_list|)
block|{
name|struct
name|__fmemopen_cookie
modifier|*
name|ck
init|=
name|cookie
decl_stmt|;
switch|switch
condition|(
name|whence
condition|)
block|{
case|case
name|SEEK_SET
case|:
if|if
condition|(
name|offset
operator|>
name|ck
operator|->
name|len
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ck
operator|->
name|off
operator|=
name|offset
expr_stmt|;
break|break;
case|case
name|SEEK_CUR
case|:
if|if
condition|(
name|ck
operator|->
name|off
operator|+
name|offset
operator|>
name|ck
operator|->
name|len
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ck
operator|->
name|off
operator|+=
name|offset
expr_stmt|;
break|break;
case|case
name|SEEK_END
case|:
if|if
condition|(
name|offset
operator|>
literal|0
operator|||
operator|-
name|offset
operator|>
name|ck
operator|->
name|len
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ck
operator|->
name|off
operator|=
name|ck
operator|->
name|len
operator|+
name|offset
expr_stmt|;
break|break;
default|default:
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|ck
operator|->
name|off
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fmemopen_close
parameter_list|(
name|void
modifier|*
name|cookie
parameter_list|)
block|{
name|struct
name|__fmemopen_cookie
modifier|*
name|ck
init|=
name|cookie
decl_stmt|;
if|if
condition|(
name|ck
operator|->
name|own
condition|)
name|free
argument_list|(
name|ck
operator|->
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ck
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

