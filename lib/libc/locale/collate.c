begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright 2014 Garrett D'Amore<garrett@damore.org>  * Copright 2010 Nexenta Systems, Inc.  All rights reserved.  * Copyright (c) 1995 Alex Tatmanjants<alex@elvisti.kiev.ua>  *		at Electronni Visti IA, Kiev, Ukraine.  *			All rights reserved.  *  * Copyright (c) 2011 The FreeBSD Foundation  * All rights reserved.  * Portions of this software were developed by David Chisnall  * under sponsorship from the FreeBSD Foundation.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * Adapted to xlocale by John Marino<draco@marino.st>  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"namespace.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<wchar.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|"un-namespace.h"
end_include

begin_include
include|#
directive|include
file|"collate.h"
end_include

begin_include
include|#
directive|include
file|"setlocale.h"
end_include

begin_include
include|#
directive|include
file|"ldpart.h"
end_include

begin_include
include|#
directive|include
file|"libc_private.h"
end_include

begin_decl_stmt
name|struct
name|xlocale_collate
name|__xlocale_global_collate
init|=
block|{
block|{
block|{
literal|0
block|}
block|,
literal|"C"
block|}
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|xlocale_collate
name|__xlocale_C_collate
init|=
block|{
block|{
block|{
literal|0
block|}
block|,
literal|"C"
block|}
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|__collate_load_tables_l
parameter_list|(
specifier|const
name|char
modifier|*
name|encoding
parameter_list|,
name|struct
name|xlocale_collate
modifier|*
name|table
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|destruct_collate
parameter_list|(
name|void
modifier|*
name|t
parameter_list|)
block|{
name|struct
name|xlocale_collate
modifier|*
name|table
init|=
name|t
decl_stmt|;
if|if
condition|(
name|table
operator|->
name|map
operator|&&
operator|(
name|table
operator|->
name|maplen
operator|>
literal|0
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|munmap
argument_list|(
name|table
operator|->
name|map
argument_list|,
name|table
operator|->
name|maplen
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|__collate_load
parameter_list|(
specifier|const
name|char
modifier|*
name|encoding
parameter_list|,
name|__unused
name|locale_t
name|unused
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|encoding
argument_list|,
literal|"C"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|encoding
argument_list|,
literal|"POSIX"
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|&
name|__xlocale_C_collate
return|;
block|}
name|struct
name|xlocale_collate
modifier|*
name|table
init|=
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|xlocale_collate
argument_list|)
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|table
operator|->
name|header
operator|.
name|header
operator|.
name|destructor
operator|=
name|destruct_collate
expr_stmt|;
comment|// FIXME: Make sure that _LDP_CACHE is never returned.  We should be doing
comment|// the caching outside of this section
if|if
condition|(
name|__collate_load_tables_l
argument_list|(
name|encoding
argument_list|,
name|table
argument_list|)
operator|!=
name|_LDP_LOADED
condition|)
block|{
name|xlocale_release
argument_list|(
name|table
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|table
return|;
block|}
end_function

begin_comment
comment|/**  * Load the collation tables for the specified encoding into the global table.  */
end_comment

begin_function
name|int
name|__collate_load_tables
parameter_list|(
specifier|const
name|char
modifier|*
name|encoding
parameter_list|)
block|{
return|return
operator|(
name|__collate_load_tables_l
argument_list|(
name|encoding
argument_list|,
operator|&
name|__xlocale_global_collate
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|__collate_load_tables_l
parameter_list|(
specifier|const
name|char
modifier|*
name|encoding
parameter_list|,
name|struct
name|xlocale_collate
modifier|*
name|table
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|chains
decl_stmt|,
name|z
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|TMP
decl_stmt|;
name|char
modifier|*
name|map
decl_stmt|;
name|collate_info_t
modifier|*
name|info
decl_stmt|;
name|struct
name|stat
name|sbuf
decl_stmt|;
name|int
name|fd
decl_stmt|;
comment|/* 'encoding' must be already checked. */
if|if
condition|(
name|strcmp
argument_list|(
name|encoding
argument_list|,
literal|"C"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|encoding
argument_list|,
literal|"POSIX"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|table
operator|->
name|__collate_load_error
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|_LDP_CACHE
operator|)
return|;
block|}
name|asnprintf
argument_list|(
operator|&
name|buf
argument_list|,
literal|"%s/%s/LC_COLLATE"
argument_list|,
name|_PathLocale
argument_list|,
name|encoding
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|_LDP_ERROR
operator|)
return|;
if|if
condition|(
operator|(
name|fd
operator|=
name|_open
argument_list|(
name|buf
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|_LDP_ERROR
operator|)
return|;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|_fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|_LDP_ERROR
operator|)
return|;
block|}
if|if
condition|(
name|sbuf
operator|.
name|st_size
operator|<
operator|(
name|COLLATE_STR_LEN
operator|+
sizeof|sizeof
argument_list|(
name|info
argument_list|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|_LDP_ERROR
operator|)
return|;
block|}
name|map
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|sbuf
operator|.
name|st_size
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_PRIVATE
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|TMP
operator|=
name|map
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|_LDP_ERROR
operator|)
return|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|TMP
argument_list|,
name|COLLATE_VERSION
argument_list|,
name|COLLATE_STR_LEN
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|munmap
argument_list|(
name|map
argument_list|,
name|sbuf
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|_LDP_ERROR
operator|)
return|;
block|}
name|TMP
operator|+=
name|COLLATE_STR_LEN
expr_stmt|;
name|info
operator|=
operator|(
name|void
operator|*
operator|)
name|TMP
expr_stmt|;
name|TMP
operator|+=
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|info
operator|->
name|directive_count
operator|<
literal|1
operator|)
operator|||
operator|(
name|info
operator|->
name|directive_count
operator|>=
name|COLL_WEIGHTS_MAX
operator|)
operator|||
operator|(
operator|(
name|chains
operator|=
name|info
operator|->
name|chain_count
operator|)
operator|<
literal|0
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|munmap
argument_list|(
name|map
argument_list|,
name|sbuf
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|_LDP_ERROR
operator|)
return|;
block|}
name|i
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|collate_char_t
argument_list|)
operator|*
operator|(
name|UCHAR_MAX
operator|+
literal|1
operator|)
operator|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|collate_chain_t
argument_list|)
operator|*
name|chains
operator|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|collate_large_t
argument_list|)
operator|*
name|info
operator|->
name|large_count
operator|)
expr_stmt|;
for|for
control|(
name|z
operator|=
literal|0
init|;
name|z
operator|<
operator|(
name|info
operator|->
name|directive_count
operator|)
condition|;
name|z
operator|++
control|)
block|{
name|i
operator|+=
sizeof|sizeof
argument_list|(
name|collate_subst_t
argument_list|)
operator|*
name|info
operator|->
name|subst_count
index|[
name|z
index|]
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
operator|(
name|sbuf
operator|.
name|st_size
operator|-
operator|(
name|TMP
operator|-
name|map
operator|)
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|munmap
argument_list|(
name|map
argument_list|,
name|sbuf
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|_LDP_ERROR
operator|)
return|;
block|}
name|table
operator|->
name|char_pri_table
operator|=
operator|(
name|void
operator|*
operator|)
name|TMP
expr_stmt|;
name|TMP
operator|+=
sizeof|sizeof
argument_list|(
name|collate_char_t
argument_list|)
operator|*
operator|(
name|UCHAR_MAX
operator|+
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|z
operator|=
literal|0
init|;
name|z
operator|<
name|info
operator|->
name|directive_count
condition|;
name|z
operator|++
control|)
block|{
if|if
condition|(
name|info
operator|->
name|subst_count
index|[
name|z
index|]
operator|>
literal|0
condition|)
block|{
name|table
operator|->
name|subst_table
index|[
name|z
index|]
operator|=
operator|(
name|void
operator|*
operator|)
name|TMP
expr_stmt|;
name|TMP
operator|+=
name|info
operator|->
name|subst_count
index|[
name|z
index|]
operator|*
sizeof|sizeof
argument_list|(
name|collate_subst_t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|table
operator|->
name|subst_table
index|[
name|z
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|chains
operator|>
literal|0
condition|)
block|{
name|table
operator|->
name|chain_pri_table
operator|=
operator|(
name|void
operator|*
operator|)
name|TMP
expr_stmt|;
name|TMP
operator|+=
name|chains
operator|*
sizeof|sizeof
argument_list|(
name|collate_chain_t
argument_list|)
expr_stmt|;
block|}
else|else
name|table
operator|->
name|chain_pri_table
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|large_count
operator|>
literal|0
condition|)
name|table
operator|->
name|large_pri_table
operator|=
operator|(
name|void
operator|*
operator|)
name|TMP
expr_stmt|;
else|else
name|table
operator|->
name|large_pri_table
operator|=
name|NULL
expr_stmt|;
name|table
operator|->
name|info
operator|=
name|info
expr_stmt|;
name|table
operator|->
name|__collate_load_error
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|_LDP_LOADED
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Note: for performance reasons, we have expanded bsearch here.  This avoids  * function call overhead with each comparison.  */
end_comment

begin_function
specifier|static
name|int32_t
modifier|*
name|substsearch
parameter_list|(
name|struct
name|xlocale_collate
modifier|*
name|table
parameter_list|,
specifier|const
name|wchar_t
name|key
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
name|collate_subst_t
modifier|*
name|p
decl_stmt|;
name|int
name|n
init|=
name|table
operator|->
name|info
operator|->
name|subst_count
index|[
name|pass
index|]
decl_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|pass
operator|>=
name|table
operator|->
name|info
operator|->
name|directive_count
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|key
operator|&
name|COLLATE_SUBST_PRIORITY
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|p
operator|=
name|table
operator|->
name|subst_table
index|[
name|pass
index|]
operator|+
operator|(
name|key
operator|&
operator|~
name|COLLATE_SUBST_PRIORITY
operator|)
expr_stmt|;
return|return
operator|(
name|p
operator|->
name|pri
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|collate_chain_t
modifier|*
name|chainsearch
parameter_list|(
name|struct
name|xlocale_collate
modifier|*
name|table
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|key
parameter_list|,
name|int
modifier|*
name|len
parameter_list|)
block|{
name|int
name|low
decl_stmt|;
name|int
name|high
decl_stmt|;
name|int
name|next
decl_stmt|,
name|compar
decl_stmt|,
name|l
decl_stmt|;
name|collate_chain_t
modifier|*
name|p
decl_stmt|;
name|collate_chain_t
modifier|*
name|tab
decl_stmt|;
if|if
condition|(
name|table
operator|->
name|info
operator|->
name|chain_count
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|low
operator|=
literal|0
expr_stmt|;
name|high
operator|=
name|table
operator|->
name|info
operator|->
name|chain_count
operator|-
literal|1
expr_stmt|;
name|tab
operator|=
name|table
operator|->
name|chain_pri_table
expr_stmt|;
while|while
condition|(
name|low
operator|<=
name|high
condition|)
block|{
name|next
operator|=
operator|(
name|low
operator|+
name|high
operator|)
operator|/
literal|2
expr_stmt|;
name|p
operator|=
name|tab
operator|+
name|next
expr_stmt|;
name|compar
operator|=
operator|*
name|key
operator|-
operator|*
name|p
operator|->
name|str
expr_stmt|;
if|if
condition|(
name|compar
operator|==
literal|0
condition|)
block|{
name|l
operator|=
name|wcsnlen
argument_list|(
name|p
operator|->
name|str
argument_list|,
name|COLLATE_STR_LEN
argument_list|)
expr_stmt|;
name|compar
operator|=
name|wcsncmp
argument_list|(
name|key
argument_list|,
name|p
operator|->
name|str
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|compar
operator|==
literal|0
condition|)
block|{
operator|*
name|len
operator|=
name|l
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
block|}
if|if
condition|(
name|compar
operator|>
literal|0
condition|)
name|low
operator|=
name|next
operator|+
literal|1
expr_stmt|;
else|else
name|high
operator|=
name|next
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|collate_large_t
modifier|*
name|largesearch
parameter_list|(
name|struct
name|xlocale_collate
modifier|*
name|table
parameter_list|,
specifier|const
name|wchar_t
name|key
parameter_list|)
block|{
name|int
name|low
init|=
literal|0
decl_stmt|;
name|int
name|high
init|=
name|table
operator|->
name|info
operator|->
name|large_count
operator|-
literal|1
decl_stmt|;
name|int
name|next
decl_stmt|,
name|compar
decl_stmt|;
name|collate_large_t
modifier|*
name|p
decl_stmt|;
name|collate_large_t
modifier|*
name|tab
init|=
name|table
operator|->
name|large_pri_table
decl_stmt|;
if|if
condition|(
name|table
operator|->
name|info
operator|->
name|large_count
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
while|while
condition|(
name|low
operator|<=
name|high
condition|)
block|{
name|next
operator|=
operator|(
name|low
operator|+
name|high
operator|)
operator|/
literal|2
expr_stmt|;
name|p
operator|=
name|tab
operator|+
name|next
expr_stmt|;
name|compar
operator|=
name|key
operator|-
name|p
operator|->
name|val
expr_stmt|;
if|if
condition|(
name|compar
operator|==
literal|0
condition|)
return|return
operator|(
name|p
operator|)
return|;
if|if
condition|(
name|compar
operator|>
literal|0
condition|)
name|low
operator|=
name|next
operator|+
literal|1
expr_stmt|;
else|else
name|high
operator|=
name|next
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|_collate_lookup
parameter_list|(
name|struct
name|xlocale_collate
modifier|*
name|table
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|len
parameter_list|,
name|int
modifier|*
name|pri
parameter_list|,
name|int
name|which
parameter_list|,
specifier|const
name|int
modifier|*
modifier|*
name|state
parameter_list|)
block|{
name|collate_chain_t
modifier|*
name|p2
decl_stmt|;
name|collate_large_t
modifier|*
name|match
decl_stmt|;
name|int
name|p
decl_stmt|,
name|l
decl_stmt|;
specifier|const
name|int
modifier|*
name|sptr
decl_stmt|;
comment|/* 	 * If this is the "last" pass for the UNDEFINED, then 	 * we just return the priority itself. 	 */
if|if
condition|(
name|which
operator|>=
name|table
operator|->
name|info
operator|->
name|directive_count
condition|)
block|{
operator|*
name|pri
operator|=
operator|*
name|t
expr_stmt|;
operator|*
name|len
operator|=
literal|1
expr_stmt|;
operator|*
name|state
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
comment|/* 	 * If we have remaining substitution data from a previous 	 * call, consume it first. 	 */
if|if
condition|(
operator|(
name|sptr
operator|=
operator|*
name|state
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|pri
operator|=
operator|*
name|sptr
expr_stmt|;
name|sptr
operator|++
expr_stmt|;
operator|*
name|state
operator|=
operator|*
name|sptr
condition|?
name|sptr
else|:
name|NULL
expr_stmt|;
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return;
block|}
comment|/* No active substitutions */
operator|*
name|len
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Check for composites such as dipthongs that collate as a 	 * single element (aka chains or collating-elements). 	 */
if|if
condition|(
operator|(
operator|(
name|p2
operator|=
name|chainsearch
argument_list|(
name|table
argument_list|,
name|t
argument_list|,
operator|&
name|l
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|p
operator|=
name|p2
operator|->
name|pri
index|[
name|which
index|]
operator|)
operator|>=
literal|0
operator|)
condition|)
block|{
operator|*
name|len
operator|=
name|l
expr_stmt|;
operator|*
name|pri
operator|=
name|p
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|t
operator|<=
name|UCHAR_MAX
condition|)
block|{
comment|/* 		 * Character is a small (8-bit) character. 		 * We just look these up directly for speed. 		 */
operator|*
name|pri
operator|=
name|table
operator|->
name|char_pri_table
index|[
operator|*
name|t
index|]
operator|.
name|pri
index|[
name|which
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|table
operator|->
name|info
operator|->
name|large_count
operator|>
literal|0
operator|)
operator|&&
operator|(
operator|(
name|match
operator|=
name|largesearch
argument_list|(
name|table
argument_list|,
operator|*
name|t
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|/* 		 * Character was found in the extended table. 		 */
operator|*
name|pri
operator|=
name|match
operator|->
name|pri
operator|.
name|pri
index|[
name|which
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Character lacks a specific definition. 		 */
if|if
condition|(
name|table
operator|->
name|info
operator|->
name|directive
index|[
name|which
index|]
operator|&
name|DIRECTIVE_UNDEFINED
condition|)
block|{
comment|/* Mask off sign bit to prevent ordering confusion. */
operator|*
name|pri
operator|=
operator|(
operator|*
name|t
operator|&
name|COLLATE_MAX_PRIORITY
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|pri
operator|=
name|table
operator|->
name|info
operator|->
name|undef_pri
index|[
name|which
index|]
expr_stmt|;
block|}
comment|/* No substitutions for undefined characters! */
return|return;
block|}
comment|/* 	 * Try substituting (expanding) the character.  We are 	 * currently doing this *after* the chain compression.  I 	 * think it should not matter, but this way might be slightly 	 * faster. 	 * 	 * We do this after the priority search, as this will help us 	 * to identify a single key value.  In order for this to work, 	 * its important that the priority assigned to a given element 	 * to be substituted be unique for that level.  The localedef 	 * code ensures this for us. 	 */
if|if
condition|(
operator|(
name|sptr
operator|=
name|substsearch
argument_list|(
name|table
argument_list|,
operator|*
name|pri
argument_list|,
name|which
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|pri
operator|=
operator|*
name|sptr
operator|)
operator|!=
literal|0
condition|)
block|{
name|sptr
operator|++
expr_stmt|;
operator|*
name|state
operator|=
operator|*
name|sptr
condition|?
name|sptr
else|:
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * This is the meaty part of wcsxfrm& strxfrm.  Note that it does  * NOT NULL terminate.  That is left to the caller.  */
end_comment

begin_function
name|size_t
name|_collate_wxfrm
parameter_list|(
name|struct
name|xlocale_collate
modifier|*
name|table
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|src
parameter_list|,
name|wchar_t
modifier|*
name|xf
parameter_list|,
name|size_t
name|room
parameter_list|)
block|{
name|int
name|pri
decl_stmt|;
name|int
name|len
decl_stmt|;
specifier|const
name|wchar_t
modifier|*
name|t
decl_stmt|;
name|wchar_t
modifier|*
name|tr
init|=
name|NULL
decl_stmt|;
name|int
name|direc
decl_stmt|;
name|int
name|pass
decl_stmt|;
specifier|const
name|int32_t
modifier|*
name|state
decl_stmt|;
name|size_t
name|want
init|=
literal|0
decl_stmt|;
name|size_t
name|need
init|=
literal|0
decl_stmt|;
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<=
name|table
operator|->
name|info
operator|->
name|directive_count
condition|;
name|pass
operator|++
control|)
block|{
name|state
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pass
operator|!=
literal|0
condition|)
block|{
comment|/* insert level separator from the previous pass */
if|if
condition|(
name|room
condition|)
block|{
operator|*
name|xf
operator|++
operator|=
literal|1
expr_stmt|;
name|room
operator|--
expr_stmt|;
block|}
name|want
operator|++
expr_stmt|;
block|}
comment|/* special pass for undefined */
if|if
condition|(
name|pass
operator|==
name|table
operator|->
name|info
operator|->
name|directive_count
condition|)
block|{
name|direc
operator|=
name|DIRECTIVE_FORWARD
operator||
name|DIRECTIVE_UNDEFINED
expr_stmt|;
block|}
else|else
block|{
name|direc
operator|=
name|table
operator|->
name|info
operator|->
name|directive
index|[
name|pass
index|]
expr_stmt|;
block|}
name|t
operator|=
name|src
expr_stmt|;
if|if
condition|(
name|direc
operator|&
name|DIRECTIVE_BACKWARD
condition|)
block|{
name|wchar_t
modifier|*
name|bp
decl_stmt|,
modifier|*
name|fp
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
name|tr
condition|)
name|free
argument_list|(
name|tr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tr
operator|=
name|wcsdup
argument_list|(
name|t
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|bp
operator|=
name|tr
expr_stmt|;
name|fp
operator|=
name|tr
operator|+
name|wcslen
argument_list|(
name|tr
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|bp
operator|<
name|fp
condition|)
block|{
name|c
operator|=
operator|*
name|bp
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
operator|*
name|fp
expr_stmt|;
operator|*
name|fp
operator|--
operator|=
name|c
expr_stmt|;
block|}
name|t
operator|=
operator|(
specifier|const
name|wchar_t
operator|*
operator|)
name|tr
expr_stmt|;
block|}
if|if
condition|(
name|direc
operator|&
name|DIRECTIVE_POSITION
condition|)
block|{
while|while
condition|(
operator|*
name|t
operator|||
name|state
condition|)
block|{
name|_collate_lookup
argument_list|(
name|table
argument_list|,
name|t
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|pri
argument_list|,
name|pass
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
name|t
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|pri
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|pri
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|pri
operator|=
name|COLLATE_MAX_PRIORITY
expr_stmt|;
block|}
if|if
condition|(
name|room
condition|)
block|{
operator|*
name|xf
operator|++
operator|=
name|pri
expr_stmt|;
name|room
operator|--
expr_stmt|;
block|}
name|want
operator|++
expr_stmt|;
name|need
operator|=
name|want
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
operator|*
name|t
operator|||
name|state
condition|)
block|{
name|_collate_lookup
argument_list|(
name|table
argument_list|,
name|t
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|pri
argument_list|,
name|pass
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
name|t
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|pri
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|pri
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
continue|continue;
block|}
if|if
condition|(
name|room
condition|)
block|{
operator|*
name|xf
operator|++
operator|=
name|pri
expr_stmt|;
name|room
operator|--
expr_stmt|;
block|}
name|want
operator|++
expr_stmt|;
name|need
operator|=
name|want
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|tr
condition|)
name|free
argument_list|(
name|tr
argument_list|)
expr_stmt|;
return|return
operator|(
name|need
operator|)
return|;
name|fail
label|:
if|if
condition|(
name|tr
condition|)
name|free
argument_list|(
name|tr
argument_list|)
expr_stmt|;
return|return
operator|(
call|(
name|size_t
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * In the non-POSIX case, we transform each character into a string of  * characters representing the character's priority.  Since char is usually  * signed, we are limited by 7 bits per byte.  To avoid zero, we need to add  * XFRM_OFFSET, so we can't use a full 7 bits.  For simplicity, we choose 6  * bits per byte.  *  * It turns out that we sometimes have real priorities that are  * 31-bits wide.  (But: be careful using priorities where the high  * order bit is set -- i.e. the priority is negative.  The sort order  * may be surprising!)  *  * TODO: This would be a good area to optimize somewhat.  It turns out  * that real prioririties *except for the last UNDEFINED pass* are generally  * very small.  We need the localedef code to precalculate the max  * priority for us, and ideally also give us a mask, and then we could  * severely limit what we expand to.  */
end_comment

begin_define
define|#
directive|define
name|XFRM_BYTES
value|6
end_define

begin_define
define|#
directive|define
name|XFRM_OFFSET
value|('0')
end_define

begin_comment
comment|/* make all printable characters */
end_comment

begin_define
define|#
directive|define
name|XFRM_SHIFT
value|6
end_define

begin_define
define|#
directive|define
name|XFRM_MASK
value|((1<< XFRM_SHIFT) - 1)
end_define

begin_define
define|#
directive|define
name|XFRM_SEP
value|('.')
end_define

begin_comment
comment|/* chosen to be less than XFRM_OFFSET */
end_comment

begin_function
specifier|static
name|int
name|xfrm
parameter_list|(
name|struct
name|xlocale_collate
modifier|*
name|table
parameter_list|,
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|int
name|pri
parameter_list|,
name|int
name|pass
parameter_list|)
block|{
comment|/* we use unsigned to ensure zero fill on right shift */
name|uint32_t
name|val
init|=
operator|(
name|uint32_t
operator|)
name|table
operator|->
name|info
operator|->
name|pri_count
index|[
name|pass
index|]
decl_stmt|;
name|int
name|nc
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|val
condition|)
block|{
operator|*
name|p
operator|=
operator|(
name|pri
operator|&
name|XFRM_MASK
operator|)
operator|+
name|XFRM_OFFSET
expr_stmt|;
name|pri
operator|>>=
name|XFRM_SHIFT
expr_stmt|;
name|val
operator|>>=
name|XFRM_SHIFT
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|nc
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|nc
operator|)
return|;
block|}
end_function

begin_function
name|size_t
name|_collate_sxfrm
parameter_list|(
name|struct
name|xlocale_collate
modifier|*
name|table
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|src
parameter_list|,
name|char
modifier|*
name|xf
parameter_list|,
name|size_t
name|room
parameter_list|)
block|{
name|int
name|pri
decl_stmt|;
name|int
name|len
decl_stmt|;
specifier|const
name|wchar_t
modifier|*
name|t
decl_stmt|;
name|wchar_t
modifier|*
name|tr
init|=
name|NULL
decl_stmt|;
name|int
name|direc
decl_stmt|;
name|int
name|pass
decl_stmt|;
specifier|const
name|int32_t
modifier|*
name|state
decl_stmt|;
name|size_t
name|want
init|=
literal|0
decl_stmt|;
name|size_t
name|need
init|=
literal|0
decl_stmt|;
name|int
name|b
decl_stmt|;
name|uint8_t
name|buf
index|[
name|XFRM_BYTES
index|]
decl_stmt|;
for|for
control|(
name|pass
operator|=
literal|0
init|;
name|pass
operator|<=
name|table
operator|->
name|info
operator|->
name|directive_count
condition|;
name|pass
operator|++
control|)
block|{
name|state
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|pass
operator|!=
literal|0
condition|)
block|{
comment|/* insert level separator from the previous pass */
if|if
condition|(
name|room
condition|)
block|{
operator|*
name|xf
operator|++
operator|=
name|XFRM_SEP
expr_stmt|;
name|room
operator|--
expr_stmt|;
block|}
name|want
operator|++
expr_stmt|;
block|}
comment|/* special pass for undefined */
if|if
condition|(
name|pass
operator|==
name|table
operator|->
name|info
operator|->
name|directive_count
condition|)
block|{
name|direc
operator|=
name|DIRECTIVE_FORWARD
operator||
name|DIRECTIVE_UNDEFINED
expr_stmt|;
block|}
else|else
block|{
name|direc
operator|=
name|table
operator|->
name|info
operator|->
name|directive
index|[
name|pass
index|]
expr_stmt|;
block|}
name|t
operator|=
name|src
expr_stmt|;
if|if
condition|(
name|direc
operator|&
name|DIRECTIVE_BACKWARD
condition|)
block|{
name|wchar_t
modifier|*
name|bp
decl_stmt|,
modifier|*
name|fp
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
name|tr
condition|)
name|free
argument_list|(
name|tr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tr
operator|=
name|wcsdup
argument_list|(
name|t
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|bp
operator|=
name|tr
expr_stmt|;
name|fp
operator|=
name|tr
operator|+
name|wcslen
argument_list|(
name|tr
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|bp
operator|<
name|fp
condition|)
block|{
name|c
operator|=
operator|*
name|bp
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
operator|*
name|fp
expr_stmt|;
operator|*
name|fp
operator|--
operator|=
name|c
expr_stmt|;
block|}
name|t
operator|=
operator|(
specifier|const
name|wchar_t
operator|*
operator|)
name|tr
expr_stmt|;
block|}
if|if
condition|(
name|direc
operator|&
name|DIRECTIVE_POSITION
condition|)
block|{
while|while
condition|(
operator|*
name|t
operator|||
name|state
condition|)
block|{
name|_collate_lookup
argument_list|(
name|table
argument_list|,
name|t
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|pri
argument_list|,
name|pass
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
name|t
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|pri
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|pri
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|pri
operator|=
name|COLLATE_MAX_PRIORITY
expr_stmt|;
block|}
name|b
operator|=
name|xfrm
argument_list|(
name|table
argument_list|,
name|buf
argument_list|,
name|pri
argument_list|,
name|pass
argument_list|)
expr_stmt|;
name|want
operator|+=
name|b
expr_stmt|;
if|if
condition|(
name|room
condition|)
block|{
while|while
condition|(
name|b
condition|)
block|{
name|b
operator|--
expr_stmt|;
if|if
condition|(
name|room
condition|)
block|{
operator|*
name|xf
operator|++
operator|=
name|buf
index|[
name|b
index|]
expr_stmt|;
name|room
operator|--
expr_stmt|;
block|}
block|}
block|}
name|need
operator|=
name|want
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
operator|*
name|t
operator|||
name|state
condition|)
block|{
name|_collate_lookup
argument_list|(
name|table
argument_list|,
name|t
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|pri
argument_list|,
name|pass
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
name|t
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|pri
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|pri
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
continue|continue;
block|}
name|b
operator|=
name|xfrm
argument_list|(
name|table
argument_list|,
name|buf
argument_list|,
name|pri
argument_list|,
name|pass
argument_list|)
expr_stmt|;
name|want
operator|+=
name|b
expr_stmt|;
if|if
condition|(
name|room
condition|)
block|{
while|while
condition|(
name|b
condition|)
block|{
name|b
operator|--
expr_stmt|;
if|if
condition|(
name|room
condition|)
block|{
operator|*
name|xf
operator|++
operator|=
name|buf
index|[
name|b
index|]
expr_stmt|;
name|room
operator|--
expr_stmt|;
block|}
block|}
block|}
name|need
operator|=
name|want
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|tr
condition|)
name|free
argument_list|(
name|tr
argument_list|)
expr_stmt|;
return|return
operator|(
name|need
operator|)
return|;
name|fail
label|:
if|if
condition|(
name|tr
condition|)
name|free
argument_list|(
name|tr
argument_list|)
expr_stmt|;
return|return
operator|(
call|(
name|size_t
call|)
argument_list|(
operator|-
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * __collate_equiv_value returns the primary collation value for the given  * collating symbol specified by str and len.  Zero or negative is returned  * if the collating symbol was not found.  This function is used by bracket  * code in the TRE regex library.  */
end_comment

begin_function
name|int
name|__collate_equiv_value
parameter_list|(
name|locale_t
name|locale
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|str
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|int32_t
name|e
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|1
operator|||
name|len
operator|>=
name|COLLATE_STR_LEN
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|FIX_LOCALE
argument_list|(
name|locale
argument_list|)
expr_stmt|;
name|struct
name|xlocale_collate
modifier|*
name|table
init|=
operator|(
expr|struct
name|xlocale_collate
operator|*
operator|)
name|locale
operator|->
name|components
index|[
name|XLC_COLLATE
index|]
decl_stmt|;
if|if
condition|(
name|table
operator|->
name|__collate_load_error
condition|)
return|return
operator|(
operator|(
name|len
operator|==
literal|1
operator|&&
operator|*
name|str
operator|<=
name|UCHAR_MAX
operator|)
condition|?
operator|*
name|str
else|:
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|len
operator|==
literal|1
condition|)
block|{
name|e
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|<=
name|UCHAR_MAX
condition|)
name|e
operator|=
name|table
operator|->
name|char_pri_table
index|[
operator|*
name|str
index|]
operator|.
name|pri
index|[
literal|0
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|table
operator|->
name|info
operator|->
name|large_count
operator|>
literal|0
condition|)
block|{
name|collate_large_t
modifier|*
name|match_large
decl_stmt|;
name|match_large
operator|=
name|largesearch
argument_list|(
name|table
argument_list|,
operator|*
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|match_large
condition|)
name|e
operator|=
name|match_large
operator|->
name|pri
operator|.
name|pri
index|[
literal|0
index|]
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|e
operator|>
literal|0
condition|?
name|e
else|:
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|table
operator|->
name|info
operator|->
name|chain_count
operator|>
literal|0
condition|)
block|{
name|wchar_t
name|name
index|[
name|COLLATE_STR_LEN
index|]
decl_stmt|;
name|collate_chain_t
modifier|*
name|match_chain
decl_stmt|;
name|int
name|clen
decl_stmt|;
name|wcsncpy
argument_list|(
name|name
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|name
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|match_chain
operator|=
name|chainsearch
argument_list|(
name|table
argument_list|,
name|name
argument_list|,
operator|&
name|clen
argument_list|)
expr_stmt|;
if|if
condition|(
name|match_chain
condition|)
block|{
name|e
operator|=
name|match_chain
operator|->
name|pri
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|e
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|e
operator|<
literal|0
condition|?
operator|-
name|e
else|:
name|e
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

