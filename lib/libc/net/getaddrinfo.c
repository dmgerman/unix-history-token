begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$FreeBSD$        */
end_comment

begin_comment
comment|/*	$KAME: getaddrinfo.c,v 1.15 2000/07/09 04:37:24 itojun Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the project nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * "#ifdef FAITH" part is local hack for supporting IPv4-v6 translator.  *  * Issues to be discussed:  * - Thread safe-ness must be checked.  * - Return values.  There are nonstandard return values defined and used  *   in the source code.  This is because RFC2553 is silent about which error  *   code must be returned for which situation.  * - freeaddrinfo(NULL).  RFC2553 is silent about it.  XNET 5.2 says it is  *   invalid.  *   current code - SEGV on freeaddrinfo(NULL)  * Note:  * - We use getipnodebyname() just for thread-safeness.  There's no intent  *   to let it do PF_UNSPEC (actually we never pass PF_UNSPEC to  *   getipnodebyname().  * - The code filters out AFs that are not supported by the kernel,  *   when globbing NULL hostname (to loopback, or wildcard).  Is it the right  *   thing to do?  What is the relationship with post-RFC2553 AI_ADDRCONFIG  *   in ai_flags?  * - (post-2553) semantics of AI_ADDRCONFIG itself is too vague.  *   (1) what should we do against numeric hostname (2) what should we do  *   against NULL hostname (3) what is AI_ADDRCONFIG itself.  AF not ready?  *   non-loopback address configured?  global address configured?  * - To avoid search order issue, we have a big amount of code duplicate  *   from gethnamaddr.c and some other places.  The issues that there's no  *   lower layer function to lookup "IPv4 or IPv6" record.  Calling  *   gethostbyname2 from getaddrinfo will end up in wrong search order, as  *   follows:  *	- The code makes use of following calls when asked to resolver with  *	  ai_family  = PF_UNSPEC:  *		getipnodebyname(host, AF_INET6);  *		getipnodebyname(host, AF_INET);  *	  This will result in the following queries if the node is configure to  *	  prefer /etc/hosts than DNS:  *		lookup /etc/hosts for IPv6 address  *		lookup DNS for IPv6 address  *		lookup /etc/hosts for IPv4 address  *		lookup DNS for IPv4 address  *	  which may not meet people's requirement.  *	  The right thing to happen is to have underlying layer which does  *	  PF_UNSPEC lookup (lookup both) and return chain of addrinfos.  *	  This would result in a bit of code duplicate with _dns_ghbyname() and  *	  friends.  */
end_comment

begin_comment
comment|/*  * diffs with other KAME platforms:  * - other KAME platforms already nuked FAITH ($GAI), but as FreeBSD  *   4.0-RELEASE supplies it, we still have the code here.  * - AI_ADDRCONFIG support is supplied  * - some of FreeBSD style (#define tabify and others)  * - classful IPv4 numeric (127.1) is allowed.  */
end_comment

begin_include
include|#
directive|include
file|"namespace.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<nsswitch.h>
end_include

begin_include
include|#
directive|include
file|"un-namespace.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__KAME__
argument_list|)
operator|&&
name|defined
argument_list|(
name|INET6
argument_list|)
end_if

begin_define
define|#
directive|define
name|FAITH
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SUCCESS
value|0
end_define

begin_define
define|#
directive|define
name|ANY
value|0
end_define

begin_define
define|#
directive|define
name|YES
value|1
end_define

begin_define
define|#
directive|define
name|NO
value|0
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
name|in_addrany
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|in6_addrany
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|in_loopback
index|[]
init|=
block|{
literal|127
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|in6_loopback
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_struct
specifier|static
specifier|const
struct|struct
name|afd
block|{
name|int
name|a_af
decl_stmt|;
name|int
name|a_addrlen
decl_stmt|;
name|int
name|a_socklen
decl_stmt|;
name|int
name|a_off
decl_stmt|;
specifier|const
name|char
modifier|*
name|a_addrany
decl_stmt|;
specifier|const
name|char
modifier|*
name|a_loopback
decl_stmt|;
name|int
name|a_scoped
decl_stmt|;
block|}
name|afdl
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|INET6
define|#
directive|define
name|N_INET6
value|0
block|{
name|PF_INET6
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|,
name|sin6_addr
argument_list|)
block|,
name|in6_addrany
block|,
name|in6_loopback
block|,
literal|1
block|}
block|,
define|#
directive|define
name|N_INET
value|1
else|#
directive|else
define|#
directive|define
name|N_INET
value|0
endif|#
directive|endif
block|{
name|PF_INET
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|,
name|sin_addr
argument_list|)
block|,
name|in_addrany
block|,
name|in_loopback
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|, }
struct|;
end_struct

begin_struct
struct|struct
name|explore
block|{
name|int
name|e_af
decl_stmt|;
name|int
name|e_socktype
decl_stmt|;
name|int
name|e_protocol
decl_stmt|;
specifier|const
name|char
modifier|*
name|e_protostr
decl_stmt|;
name|int
name|e_wild
decl_stmt|;
define|#
directive|define
name|WILD_AF
parameter_list|(
name|ex
parameter_list|)
value|((ex)->e_wild& 0x01)
define|#
directive|define
name|WILD_SOCKTYPE
parameter_list|(
name|ex
parameter_list|)
value|((ex)->e_wild& 0x02)
define|#
directive|define
name|WILD_PROTOCOL
parameter_list|(
name|ex
parameter_list|)
value|((ex)->e_wild& 0x04)
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|explore
name|explore
index|[]
init|=
block|{
if|#
directive|if
literal|0
block|{ PF_LOCAL, 0, ANY, ANY, NULL, 0x01 },
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
block|{
name|PF_INET6
block|,
name|SOCK_DGRAM
block|,
name|IPPROTO_UDP
block|,
literal|"udp"
block|,
literal|0x07
block|}
block|,
block|{
name|PF_INET6
block|,
name|SOCK_STREAM
block|,
name|IPPROTO_TCP
block|,
literal|"tcp"
block|,
literal|0x07
block|}
block|,
block|{
name|PF_INET6
block|,
name|SOCK_RAW
block|,
name|ANY
block|,
name|NULL
block|,
literal|0x05
block|}
block|,
endif|#
directive|endif
block|{
name|PF_INET
block|,
name|SOCK_DGRAM
block|,
name|IPPROTO_UDP
block|,
literal|"udp"
block|,
literal|0x07
block|}
block|,
block|{
name|PF_INET
block|,
name|SOCK_STREAM
block|,
name|IPPROTO_TCP
block|,
literal|"tcp"
block|,
literal|0x07
block|}
block|,
block|{
name|PF_INET
block|,
name|SOCK_RAW
block|,
name|ANY
block|,
name|NULL
block|,
literal|0x05
block|}
block|,
block|{
name|PF_UNSPEC
block|,
name|SOCK_DGRAM
block|,
name|IPPROTO_UDP
block|,
literal|"udp"
block|,
literal|0x07
block|}
block|,
block|{
name|PF_UNSPEC
block|,
name|SOCK_STREAM
block|,
name|IPPROTO_TCP
block|,
literal|"tcp"
block|,
literal|0x07
block|}
block|,
block|{
name|PF_UNSPEC
block|,
name|SOCK_RAW
block|,
name|ANY
block|,
name|NULL
block|,
literal|0x05
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_define
define|#
directive|define
name|PTON_MAX
value|16
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PTON_MAX
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|ns_src
name|default_dns_files
index|[]
init|=
block|{
block|{
name|NSSRC_FILES
block|,
name|NS_SUCCESS
block|}
block|,
block|{
name|NSSRC_DNS
block|,
name|NS_SUCCESS
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|PACKETSZ
operator|>
literal|1024
end_if

begin_define
define|#
directive|define
name|MAXPACKET
value|PACKETSZ
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MAXPACKET
value|1024
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
union|union
block|{
name|HEADER
name|hdr
decl_stmt|;
name|u_char
name|buf
index|[
name|MAXPACKET
index|]
decl_stmt|;
block|}
name|querybuf
typedef|;
end_typedef

begin_struct
struct|struct
name|res_target
block|{
name|struct
name|res_target
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* domain name */
name|int
name|qclass
decl_stmt|,
name|qtype
decl_stmt|;
comment|/* class and type of query */
name|u_char
modifier|*
name|answer
decl_stmt|;
comment|/* buffer to put answer */
name|int
name|anslen
decl_stmt|;
comment|/* size of answer buffer */
name|int
name|n
decl_stmt|;
comment|/* result length */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|int
name|str_isnumber
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|explore_fqdn
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|addrinfo
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
expr|struct
name|addrinfo
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|explore_null
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|addrinfo
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
expr|struct
name|addrinfo
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|explore_numeric
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|addrinfo
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
expr|struct
name|addrinfo
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|explore_numeric_scope
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|addrinfo
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
expr|struct
name|addrinfo
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_canonname
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|addrinfo
operator|*
operator|,
expr|struct
name|addrinfo
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|addrinfo
modifier|*
name|get_ai
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|addrinfo
operator|*
operator|,
specifier|const
expr|struct
name|afd
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_portmatch
name|__P
argument_list|(
operator|(
specifier|const
expr|struct
name|addrinfo
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|get_port
name|__P
argument_list|(
operator|(
expr|struct
name|addrinfo
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|afd
modifier|*
name|find_afd
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|addrconfig
name|__P
argument_list|(
operator|(
expr|struct
name|addrinfo
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|ip6_str2scopeid
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
expr|struct
name|sockaddr_in6
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|addrinfo
modifier|*
name|getanswer
name|__P
argument_list|(
operator|(
specifier|const
name|querybuf
operator|*
operator|,
name|int
operator|,
specifier|const
name|char
operator|*
operator|,
name|int
operator|,
specifier|const
expr|struct
name|addrinfo
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_dns_getaddrinfo
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|void
operator|*
operator|,
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|_sethtent
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|_endhtent
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|addrinfo
modifier|*
name|_gethtent
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
expr|struct
name|addrinfo
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_files_getaddrinfo
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|void
operator|*
operator|,
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|YP
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|addrinfo
modifier|*
name|_yphostent
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
specifier|const
expr|struct
name|addrinfo
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|_yp_getaddrinfo
name|__P
argument_list|(
operator|(
name|void
operator|*
operator|,
name|void
operator|*
operator|,
name|va_list
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|res_queryN
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
expr|struct
name|res_target
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|res_searchN
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
expr|struct
name|res_target
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|res_querydomainN
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
expr|struct
name|res_target
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ai_errlist
index|[]
init|=
block|{
literal|"Success"
block|,
literal|"Address family for hostname not supported"
block|,
comment|/* EAI_ADDRFAMILY */
literal|"Temporary failure in name resolution"
block|,
comment|/* EAI_AGAIN      */
literal|"Invalid value for ai_flags"
block|,
comment|/* EAI_BADFLAGS   */
literal|"Non-recoverable failure in name resolution"
block|,
comment|/* EAI_FAIL       */
literal|"ai_family not supported"
block|,
comment|/* EAI_FAMILY     */
literal|"Memory allocation failure"
block|,
comment|/* EAI_MEMORY     */
literal|"No address associated with hostname"
block|,
comment|/* EAI_NODATA     */
literal|"hostname nor servname provided, or not known"
block|,
comment|/* EAI_NONAME     */
literal|"servname not supported for ai_socktype"
block|,
comment|/* EAI_SERVICE    */
literal|"ai_socktype not supported"
block|,
comment|/* EAI_SOCKTYPE   */
literal|"System error returned in errno"
block|,
comment|/* EAI_SYSTEM     */
literal|"Invalid value for hints"
block|,
comment|/* EAI_BADHINTS	  */
literal|"Resolved protocol is unknown"
block|,
comment|/* EAI_PROTOCOL   */
literal|"Unknown error"
block|,
comment|/* EAI_MAX        */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX macros that make external reference is BAD. */
end_comment

begin_define
define|#
directive|define
name|GET_AI
parameter_list|(
name|ai
parameter_list|,
name|afd
parameter_list|,
name|addr
parameter_list|)
define|\
value|do { \
comment|/* external reference: pai, error, and label free */
value|\ 	(ai) = get_ai(pai, (afd), (addr)); \ 	if ((ai) == NULL) { \ 		error = EAI_MEMORY; \ 		goto free; \ 	} \ } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_define
define|#
directive|define
name|GET_PORT
parameter_list|(
name|ai
parameter_list|,
name|serv
parameter_list|)
define|\
value|do { \
comment|/* external reference: error and label free */
value|\ 	error = get_port((ai), (serv), 0); \ 	if (error != 0) \ 		goto free; \ } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_define
define|#
directive|define
name|GET_CANONNAME
parameter_list|(
name|ai
parameter_list|,
name|str
parameter_list|)
define|\
value|do { \
comment|/* external reference: pai, error and label free */
value|\ 	error = get_canonname(pai, (ai), (str)); \ 	if (error != 0) \ 		goto free; \ } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_define
define|#
directive|define
name|ERR
parameter_list|(
name|err
parameter_list|)
define|\
value|do { \
comment|/* external reference: error, and label bad */
value|\ 	error = (err); \ 	goto bad; \
comment|/*NOTREACHED*/
value|\ } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_define
define|#
directive|define
name|MATCH_FAMILY
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|w
parameter_list|)
define|\
value|((x) == (y) || (
comment|/*CONSTCOND*/
value|(w)&& ((x) == PF_UNSPEC || (y) == PF_UNSPEC)))
end_define

begin_define
define|#
directive|define
name|MATCH
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|w
parameter_list|)
define|\
value|((x) == (y) || (
comment|/*CONSTCOND*/
value|(w)&& ((x) == ANY || (y) == ANY)))
end_define

begin_function
name|char
modifier|*
name|gai_strerror
parameter_list|(
name|ecode
parameter_list|)
name|int
name|ecode
decl_stmt|;
block|{
if|if
condition|(
name|ecode
operator|<
literal|0
operator|||
name|ecode
operator|>
name|EAI_MAX
condition|)
name|ecode
operator|=
name|EAI_MAX
expr_stmt|;
return|return
name|ai_errlist
index|[
name|ecode
index|]
return|;
block|}
end_function

begin_function
name|void
name|freeaddrinfo
parameter_list|(
name|ai
parameter_list|)
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
block|{
name|struct
name|addrinfo
modifier|*
name|next
decl_stmt|;
do|do
block|{
name|next
operator|=
name|ai
operator|->
name|ai_next
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|ai_canonname
condition|)
name|free
argument_list|(
name|ai
operator|->
name|ai_canonname
argument_list|)
expr_stmt|;
comment|/* no need to free(ai->ai_addr) */
name|free
argument_list|(
name|ai
argument_list|)
expr_stmt|;
name|ai
operator|=
name|next
expr_stmt|;
block|}
do|while
condition|(
name|ai
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|int
name|str_isnumber
parameter_list|(
name|p
parameter_list|)
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|char
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
name|NO
return|;
name|ep
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|&&
operator|*
name|ep
operator|==
literal|'\0'
condition|)
return|return
name|YES
return|;
else|else
return|return
name|NO
return|;
block|}
end_function

begin_function
name|int
name|getaddrinfo
parameter_list|(
name|hostname
parameter_list|,
name|servname
parameter_list|,
name|hints
parameter_list|,
name|res
parameter_list|)
specifier|const
name|char
modifier|*
name|hostname
decl_stmt|,
decl|*
name|servname
decl_stmt|;
end_function

begin_decl_stmt
specifier|const
name|struct
name|addrinfo
modifier|*
name|hints
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|addrinfo
modifier|*
modifier|*
name|res
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|addrinfo
name|sentinel
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|cur
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|addrinfo
name|ai
decl_stmt|;
name|struct
name|addrinfo
name|ai0
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
specifier|const
name|struct
name|explore
modifier|*
name|ex
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sentinel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sentinel
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
operator|&
name|sentinel
expr_stmt|;
name|pai
operator|=
operator|&
name|ai
expr_stmt|;
name|pai
operator|->
name|ai_flags
operator|=
literal|0
expr_stmt|;
name|pai
operator|->
name|ai_family
operator|=
name|PF_UNSPEC
expr_stmt|;
name|pai
operator|->
name|ai_socktype
operator|=
name|ANY
expr_stmt|;
name|pai
operator|->
name|ai_protocol
operator|=
name|ANY
expr_stmt|;
name|pai
operator|->
name|ai_addrlen
operator|=
literal|0
expr_stmt|;
name|pai
operator|->
name|ai_canonname
operator|=
name|NULL
expr_stmt|;
name|pai
operator|->
name|ai_addr
operator|=
name|NULL
expr_stmt|;
name|pai
operator|->
name|ai_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|hostname
operator|==
name|NULL
operator|&&
name|servname
operator|==
name|NULL
condition|)
return|return
name|EAI_NONAME
return|;
if|if
condition|(
name|hints
condition|)
block|{
comment|/* error check for hints */
if|if
condition|(
name|hints
operator|->
name|ai_addrlen
operator|||
name|hints
operator|->
name|ai_canonname
operator|||
name|hints
operator|->
name|ai_addr
operator|||
name|hints
operator|->
name|ai_next
condition|)
name|ERR
argument_list|(
name|EAI_BADHINTS
argument_list|)
expr_stmt|;
comment|/* xxx */
if|if
condition|(
name|hints
operator|->
name|ai_flags
operator|&
operator|~
name|AI_MASK
condition|)
name|ERR
argument_list|(
name|EAI_BADFLAGS
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hints
operator|->
name|ai_family
condition|)
block|{
case|case
name|PF_UNSPEC
case|:
case|case
name|PF_INET
case|:
ifdef|#
directive|ifdef
name|INET6
case|case
name|PF_INET6
case|:
endif|#
directive|endif
break|break;
default|default:
name|ERR
argument_list|(
name|EAI_FAMILY
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|pai
argument_list|,
name|hints
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pai
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * if both socktype/protocol are specified, check if they 		 * are meaningful combination. 		 */
if|if
condition|(
name|pai
operator|->
name|ai_socktype
operator|!=
name|ANY
operator|&&
name|pai
operator|->
name|ai_protocol
operator|!=
name|ANY
condition|)
block|{
for|for
control|(
name|ex
operator|=
name|explore
init|;
name|ex
operator|->
name|e_af
operator|>=
literal|0
condition|;
name|ex
operator|++
control|)
block|{
if|if
condition|(
name|pai
operator|->
name|ai_family
operator|!=
name|ex
operator|->
name|e_af
condition|)
continue|continue;
if|if
condition|(
name|ex
operator|->
name|e_socktype
operator|==
name|ANY
condition|)
continue|continue;
if|if
condition|(
name|ex
operator|->
name|e_protocol
operator|==
name|ANY
condition|)
continue|continue;
if|if
condition|(
name|pai
operator|->
name|ai_socktype
operator|==
name|ex
operator|->
name|e_socktype
operator|&&
name|pai
operator|->
name|ai_protocol
operator|!=
name|ex
operator|->
name|e_protocol
condition|)
block|{
name|ERR
argument_list|(
name|EAI_BADHINTS
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* 	 * post-2553: AI_ALL and AI_V4MAPPED are effective only against 	 * AF_INET6 query.  They needs to be ignored if specified in other 	 * occassions. 	 */
switch|switch
condition|(
name|pai
operator|->
name|ai_flags
operator|&
operator|(
name|AI_ALL
operator||
name|AI_V4MAPPED
operator|)
condition|)
block|{
case|case
name|AI_V4MAPPED
case|:
case|case
name|AI_ALL
operator||
name|AI_V4MAPPED
case|:
if|if
condition|(
name|pai
operator|->
name|ai_family
operator|!=
name|AF_INET6
condition|)
name|pai
operator|->
name|ai_flags
operator|&=
operator|~
operator|(
name|AI_ALL
operator||
name|AI_V4MAPPED
operator|)
expr_stmt|;
break|break;
case|case
name|AI_ALL
case|:
if|#
directive|if
literal|1
comment|/* illegal */
name|ERR
argument_list|(
name|EAI_BADFLAGS
argument_list|)
expr_stmt|;
else|#
directive|else
name|pai
operator|->
name|ai_flags
operator|&=
operator|~
operator|(
name|AI_ALL
operator||
name|AI_V4MAPPED
operator|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
comment|/* 	 * check for special cases.  (1) numeric servname is disallowed if 	 * socktype/protocol are left unspecified. (2) servname is disallowed 	 * for raw and other inet{,6} sockets. 	 */
if|if
condition|(
name|MATCH_FAMILY
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|,
name|PF_INET
argument_list|,
literal|1
argument_list|)
ifdef|#
directive|ifdef
name|PF_INET6
operator|||
name|MATCH_FAMILY
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|,
name|PF_INET6
argument_list|,
literal|1
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|ai0
operator|=
operator|*
name|pai
expr_stmt|;
comment|/* backup *pai */
if|if
condition|(
name|pai
operator|->
name|ai_family
operator|==
name|PF_UNSPEC
condition|)
block|{
ifdef|#
directive|ifdef
name|PF_INET6
name|pai
operator|->
name|ai_family
operator|=
name|PF_INET6
expr_stmt|;
else|#
directive|else
name|pai
operator|->
name|ai_family
operator|=
name|PF_INET
expr_stmt|;
endif|#
directive|endif
block|}
name|error
operator|=
name|get_portmatch
argument_list|(
name|pai
argument_list|,
name|servname
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|ERR
argument_list|(
name|error
argument_list|)
expr_stmt|;
operator|*
name|pai
operator|=
name|ai0
expr_stmt|;
block|}
name|ai0
operator|=
operator|*
name|pai
expr_stmt|;
comment|/* NULL hostname, or numeric hostname */
for|for
control|(
name|ex
operator|=
name|explore
init|;
name|ex
operator|->
name|e_af
operator|>=
literal|0
condition|;
name|ex
operator|++
control|)
block|{
operator|*
name|pai
operator|=
name|ai0
expr_stmt|;
comment|/* PF_UNSPEC entries are prepared for DNS queries only */
if|if
condition|(
name|ex
operator|->
name|e_af
operator|==
name|PF_UNSPEC
condition|)
continue|continue;
if|if
condition|(
operator|!
name|MATCH_FAMILY
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|,
name|ex
operator|->
name|e_af
argument_list|,
name|WILD_AF
argument_list|(
name|ex
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|pai
operator|->
name|ai_socktype
argument_list|,
name|ex
operator|->
name|e_socktype
argument_list|,
name|WILD_SOCKTYPE
argument_list|(
name|ex
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|pai
operator|->
name|ai_protocol
argument_list|,
name|ex
operator|->
name|e_protocol
argument_list|,
name|WILD_PROTOCOL
argument_list|(
name|ex
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|pai
operator|->
name|ai_family
operator|==
name|PF_UNSPEC
condition|)
name|pai
operator|->
name|ai_family
operator|=
name|ex
operator|->
name|e_af
expr_stmt|;
if|if
condition|(
name|pai
operator|->
name|ai_socktype
operator|==
name|ANY
operator|&&
name|ex
operator|->
name|e_socktype
operator|!=
name|ANY
condition|)
name|pai
operator|->
name|ai_socktype
operator|=
name|ex
operator|->
name|e_socktype
expr_stmt|;
if|if
condition|(
name|pai
operator|->
name|ai_protocol
operator|==
name|ANY
operator|&&
name|ex
operator|->
name|e_protocol
operator|!=
name|ANY
condition|)
name|pai
operator|->
name|ai_protocol
operator|=
name|ex
operator|->
name|e_protocol
expr_stmt|;
if|if
condition|(
name|hostname
operator|==
name|NULL
condition|)
name|error
operator|=
name|explore_null
argument_list|(
name|pai
argument_list|,
name|servname
argument_list|,
operator|&
name|cur
operator|->
name|ai_next
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|explore_numeric_scope
argument_list|(
name|pai
argument_list|,
name|hostname
argument_list|,
name|servname
argument_list|,
operator|&
name|cur
operator|->
name|ai_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|free
goto|;
while|while
condition|(
name|cur
operator|&&
name|cur
operator|->
name|ai_next
condition|)
name|cur
operator|=
name|cur
operator|->
name|ai_next
expr_stmt|;
block|}
comment|/* 	 * XXX 	 * If numreic representation of AF1 can be interpreted as FQDN 	 * representation of AF2, we need to think again about the code below. 	 */
if|if
condition|(
name|sentinel
operator|.
name|ai_next
condition|)
goto|goto
name|good
goto|;
if|if
condition|(
name|pai
operator|->
name|ai_flags
operator|&
name|AI_NUMERICHOST
condition|)
name|ERR
argument_list|(
name|EAI_NONAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostname
operator|==
name|NULL
condition|)
name|ERR
argument_list|(
name|EAI_NODATA
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pai
operator|->
name|ai_flags
operator|&
name|AI_ADDRCONFIG
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|addrconfig
argument_list|(
operator|&
name|ai0
argument_list|)
condition|)
name|ERR
argument_list|(
name|EAI_FAIL
argument_list|)
expr_stmt|;
comment|/* 	 * hostname as alphabetical name. 	 * we would like to prefer AF_INET6 than AF_INET, so we'll make a 	 * outer loop by AFs. 	 */
for|for
control|(
name|ex
operator|=
name|explore
init|;
name|ex
operator|->
name|e_af
operator|>=
literal|0
condition|;
name|ex
operator|++
control|)
block|{
operator|*
name|pai
operator|=
name|ai0
expr_stmt|;
comment|/* require exact match for family field */
if|if
condition|(
name|pai
operator|->
name|ai_family
operator|!=
name|ex
operator|->
name|e_af
condition|)
continue|continue;
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|pai
operator|->
name|ai_socktype
argument_list|,
name|ex
operator|->
name|e_socktype
argument_list|,
name|WILD_SOCKTYPE
argument_list|(
name|ex
argument_list|)
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|pai
operator|->
name|ai_protocol
argument_list|,
name|ex
operator|->
name|e_protocol
argument_list|,
name|WILD_PROTOCOL
argument_list|(
name|ex
argument_list|)
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|pai
operator|->
name|ai_socktype
operator|==
name|ANY
operator|&&
name|ex
operator|->
name|e_socktype
operator|!=
name|ANY
condition|)
name|pai
operator|->
name|ai_socktype
operator|=
name|ex
operator|->
name|e_socktype
expr_stmt|;
if|if
condition|(
name|pai
operator|->
name|ai_protocol
operator|==
name|ANY
operator|&&
name|ex
operator|->
name|e_protocol
operator|!=
name|ANY
condition|)
name|pai
operator|->
name|ai_protocol
operator|=
name|ex
operator|->
name|e_protocol
expr_stmt|;
name|error
operator|=
name|explore_fqdn
argument_list|(
name|pai
argument_list|,
name|hostname
argument_list|,
name|servname
argument_list|,
operator|&
name|cur
operator|->
name|ai_next
argument_list|)
expr_stmt|;
while|while
condition|(
name|cur
operator|&&
name|cur
operator|->
name|ai_next
condition|)
name|cur
operator|=
name|cur
operator|->
name|ai_next
expr_stmt|;
block|}
comment|/* XXX */
if|if
condition|(
name|sentinel
operator|.
name|ai_next
condition|)
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|free
goto|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sentinel
operator|.
name|ai_next
condition|)
block|{
name|good
label|:
operator|*
name|res
operator|=
name|sentinel
operator|.
name|ai_next
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
else|else
name|error
operator|=
name|EAI_FAIL
expr_stmt|;
block|}
name|free
label|:
name|bad
label|:
if|if
condition|(
name|sentinel
operator|.
name|ai_next
condition|)
name|freeaddrinfo
argument_list|(
name|sentinel
operator|.
name|ai_next
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
name|NULL
expr_stmt|;
return|return
name|error
return|;
block|}
end_block

begin_comment
comment|/*  * FQDN hostname, DNS lookup  */
end_comment

begin_function
specifier|static
name|int
name|explore_fqdn
parameter_list|(
name|pai
parameter_list|,
name|hostname
parameter_list|,
name|servname
parameter_list|,
name|res
parameter_list|)
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
specifier|const
name|char
modifier|*
name|hostname
decl_stmt|;
specifier|const
name|char
modifier|*
name|servname
decl_stmt|;
name|struct
name|addrinfo
modifier|*
modifier|*
name|res
decl_stmt|;
block|{
name|struct
name|addrinfo
modifier|*
name|result
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|cur
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
specifier|static
specifier|const
name|ns_dtab
name|dtab
index|[]
init|=
block|{
name|NS_FILES_CB
argument_list|(
argument|_files_getaddrinfo
argument_list|,
argument|NULL
argument_list|)
block|{
name|NSSRC_DNS
block|,
name|_dns_getaddrinfo
block|,
name|NULL
block|}
block|,
comment|/* force -DHESIOD */
name|NS_NIS_CB
argument_list|(
argument|_yp_getaddrinfo
argument_list|,
argument|NULL
argument_list|)
block|{
literal|0
block|}
block|}
decl_stmt|;
name|result
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * if the servname does not match socktype/protocol, ignore it. 	 */
if|if
condition|(
name|get_portmatch
argument_list|(
name|pai
argument_list|,
name|servname
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|nsdispatch
argument_list|(
operator|&
name|result
argument_list|,
name|dtab
argument_list|,
name|NSDB_HOSTS
argument_list|,
literal|"getaddrinfo"
argument_list|,
name|default_dns_files
argument_list|,
name|hostname
argument_list|,
name|pai
argument_list|)
condition|)
block|{
case|case
name|NS_TRYAGAIN
case|:
name|error
operator|=
name|EAI_AGAIN
expr_stmt|;
goto|goto
name|free
goto|;
case|case
name|NS_UNAVAIL
case|:
name|error
operator|=
name|EAI_FAIL
expr_stmt|;
goto|goto
name|free
goto|;
case|case
name|NS_NOTFOUND
case|:
name|error
operator|=
name|EAI_NODATA
expr_stmt|;
goto|goto
name|free
goto|;
case|case
name|NS_SUCCESS
case|:
name|error
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cur
operator|=
name|result
init|;
name|cur
condition|;
name|cur
operator|=
name|cur
operator|->
name|ai_next
control|)
block|{
name|GET_PORT
argument_list|(
name|cur
argument_list|,
name|servname
argument_list|)
expr_stmt|;
comment|/* canonname should be filled already */
block|}
break|break;
block|}
operator|*
name|res
operator|=
name|result
expr_stmt|;
return|return
literal|0
return|;
name|free
label|:
if|if
condition|(
name|result
condition|)
name|freeaddrinfo
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * hostname == NULL.  * passive socket -> anyaddr (0.0.0.0 or ::)  * non-passive socket -> localhost (127.0.0.1 or ::1)  */
end_comment

begin_function
specifier|static
name|int
name|explore_null
parameter_list|(
name|pai
parameter_list|,
name|servname
parameter_list|,
name|res
parameter_list|)
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
specifier|const
name|char
modifier|*
name|servname
decl_stmt|;
name|struct
name|addrinfo
modifier|*
modifier|*
name|res
decl_stmt|;
block|{
name|int
name|s
decl_stmt|;
specifier|const
name|struct
name|afd
modifier|*
name|afd
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|cur
decl_stmt|;
name|struct
name|addrinfo
name|sentinel
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|*
name|res
operator|=
name|NULL
expr_stmt|;
name|sentinel
operator|.
name|ai_next
operator|=
name|NULL
expr_stmt|;
name|cur
operator|=
operator|&
name|sentinel
expr_stmt|;
comment|/* 	 * filter out AFs that are not supported by the kernel 	 * XXX errno? 	 */
name|s
operator|=
name|_socket
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EMFILE
condition|)
return|return
literal|0
return|;
block|}
else|else
name|_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* 	 * if the servname does not match socktype/protocol, ignore it. 	 */
if|if
condition|(
name|get_portmatch
argument_list|(
name|pai
argument_list|,
name|servname
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|afd
operator|=
name|find_afd
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|)
expr_stmt|;
if|if
condition|(
name|afd
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|pai
operator|->
name|ai_flags
operator|&
name|AI_PASSIVE
condition|)
block|{
name|GET_AI
argument_list|(
name|cur
operator|->
name|ai_next
argument_list|,
name|afd
argument_list|,
name|afd
operator|->
name|a_addrany
argument_list|)
expr_stmt|;
comment|/* xxx meaningless? 		 * GET_CANONNAME(cur->ai_next, "anyaddr"); 		 */
name|GET_PORT
argument_list|(
name|cur
operator|->
name|ai_next
argument_list|,
name|servname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|GET_AI
argument_list|(
name|cur
operator|->
name|ai_next
argument_list|,
name|afd
argument_list|,
name|afd
operator|->
name|a_loopback
argument_list|)
expr_stmt|;
comment|/* xxx meaningless? 		 * GET_CANONNAME(cur->ai_next, "localhost"); 		 */
name|GET_PORT
argument_list|(
name|cur
operator|->
name|ai_next
argument_list|,
name|servname
argument_list|)
expr_stmt|;
block|}
name|cur
operator|=
name|cur
operator|->
name|ai_next
expr_stmt|;
operator|*
name|res
operator|=
name|sentinel
operator|.
name|ai_next
expr_stmt|;
return|return
literal|0
return|;
name|free
label|:
if|if
condition|(
name|sentinel
operator|.
name|ai_next
condition|)
name|freeaddrinfo
argument_list|(
name|sentinel
operator|.
name|ai_next
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * numeric hostname  */
end_comment

begin_function
specifier|static
name|int
name|explore_numeric
parameter_list|(
name|pai
parameter_list|,
name|hostname
parameter_list|,
name|servname
parameter_list|,
name|res
parameter_list|)
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
specifier|const
name|char
modifier|*
name|hostname
decl_stmt|;
specifier|const
name|char
modifier|*
name|servname
decl_stmt|;
name|struct
name|addrinfo
modifier|*
modifier|*
name|res
decl_stmt|;
block|{
specifier|const
name|struct
name|afd
modifier|*
name|afd
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|cur
decl_stmt|;
name|struct
name|addrinfo
name|sentinel
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
name|pton
index|[
name|PTON_MAX
index|]
decl_stmt|;
operator|*
name|res
operator|=
name|NULL
expr_stmt|;
name|sentinel
operator|.
name|ai_next
operator|=
name|NULL
expr_stmt|;
name|cur
operator|=
operator|&
name|sentinel
expr_stmt|;
comment|/* 	 * if the servname does not match socktype/protocol, ignore it. 	 */
if|if
condition|(
name|get_portmatch
argument_list|(
name|pai
argument_list|,
name|servname
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|afd
operator|=
name|find_afd
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|)
expr_stmt|;
if|if
condition|(
name|afd
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|afd
operator|->
name|a_af
condition|)
block|{
if|#
directive|if
literal|1
comment|/*X/Open spec*/
case|case
name|AF_INET
case|:
if|if
condition|(
name|inet_aton
argument_list|(
name|hostname
argument_list|,
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|pton
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|pai
operator|->
name|ai_family
operator|==
name|afd
operator|->
name|a_af
operator|||
name|pai
operator|->
name|ai_family
operator|==
name|PF_UNSPEC
comment|/*?*/
condition|)
block|{
name|GET_AI
argument_list|(
name|cur
operator|->
name|ai_next
argument_list|,
name|afd
argument_list|,
name|pton
argument_list|)
expr_stmt|;
name|GET_PORT
argument_list|(
name|cur
operator|->
name|ai_next
argument_list|,
name|servname
argument_list|)
expr_stmt|;
while|while
condition|(
name|cur
operator|&&
name|cur
operator|->
name|ai_next
condition|)
name|cur
operator|=
name|cur
operator|->
name|ai_next
expr_stmt|;
block|}
else|else
name|ERR
argument_list|(
name|EAI_FAMILY
argument_list|)
expr_stmt|;
comment|/*xxx*/
block|}
break|break;
endif|#
directive|endif
default|default:
if|if
condition|(
name|inet_pton
argument_list|(
name|afd
operator|->
name|a_af
argument_list|,
name|hostname
argument_list|,
name|pton
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|pai
operator|->
name|ai_family
operator|==
name|afd
operator|->
name|a_af
operator|||
name|pai
operator|->
name|ai_family
operator|==
name|PF_UNSPEC
comment|/*?*/
condition|)
block|{
name|GET_AI
argument_list|(
name|cur
operator|->
name|ai_next
argument_list|,
name|afd
argument_list|,
name|pton
argument_list|)
expr_stmt|;
name|GET_PORT
argument_list|(
name|cur
operator|->
name|ai_next
argument_list|,
name|servname
argument_list|)
expr_stmt|;
while|while
condition|(
name|cur
operator|&&
name|cur
operator|->
name|ai_next
condition|)
name|cur
operator|=
name|cur
operator|->
name|ai_next
expr_stmt|;
block|}
else|else
name|ERR
argument_list|(
name|EAI_FAMILY
argument_list|)
expr_stmt|;
comment|/*xxx*/
block|}
break|break;
block|}
operator|*
name|res
operator|=
name|sentinel
operator|.
name|ai_next
expr_stmt|;
return|return
literal|0
return|;
name|free
label|:
name|bad
label|:
if|if
condition|(
name|sentinel
operator|.
name|ai_next
condition|)
name|freeaddrinfo
argument_list|(
name|sentinel
operator|.
name|ai_next
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * numeric hostname with scope  */
end_comment

begin_function
specifier|static
name|int
name|explore_numeric_scope
parameter_list|(
name|pai
parameter_list|,
name|hostname
parameter_list|,
name|servname
parameter_list|,
name|res
parameter_list|)
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
specifier|const
name|char
modifier|*
name|hostname
decl_stmt|;
specifier|const
name|char
modifier|*
name|servname
decl_stmt|;
name|struct
name|addrinfo
modifier|*
modifier|*
name|res
decl_stmt|;
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SCOPE_DELIMITER
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|INET6
argument_list|)
return|return
name|explore_numeric
argument_list|(
name|pai
argument_list|,
name|hostname
argument_list|,
name|servname
argument_list|,
name|res
argument_list|)
return|;
else|#
directive|else
specifier|const
name|struct
name|afd
modifier|*
name|afd
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|cur
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|hostname2
init|=
name|NULL
decl_stmt|,
modifier|*
name|scope
decl_stmt|,
modifier|*
name|addr
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
comment|/* 	 * if the servname does not match socktype/protocol, ignore it. 	 */
if|if
condition|(
name|get_portmatch
argument_list|(
name|pai
argument_list|,
name|servname
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|afd
operator|=
name|find_afd
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|)
expr_stmt|;
if|if
condition|(
name|afd
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|afd
operator|->
name|a_scoped
condition|)
return|return
name|explore_numeric
argument_list|(
name|pai
argument_list|,
name|hostname
argument_list|,
name|servname
argument_list|,
name|res
argument_list|)
return|;
name|cp
operator|=
name|strchr
argument_list|(
name|hostname
argument_list|,
name|SCOPE_DELIMITER
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
name|explore_numeric
argument_list|(
name|pai
argument_list|,
name|hostname
argument_list|,
name|servname
argument_list|,
name|res
argument_list|)
return|;
comment|/* 	 * Handle special case of<scoped_address><delimiter><scope id> 	 */
name|hostname2
operator|=
name|strdup
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostname2
operator|==
name|NULL
condition|)
return|return
name|EAI_MEMORY
return|;
comment|/* terminate at the delimiter */
name|hostname2
index|[
name|cp
operator|-
name|hostname
index|]
operator|=
literal|'\0'
expr_stmt|;
name|addr
operator|=
name|hostname2
expr_stmt|;
name|scope
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
name|error
operator|=
name|explore_numeric
argument_list|(
name|pai
argument_list|,
name|addr
argument_list|,
name|servname
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|int
name|scopeid
decl_stmt|;
for|for
control|(
name|cur
operator|=
operator|*
name|res
init|;
name|cur
condition|;
name|cur
operator|=
name|cur
operator|->
name|ai_next
control|)
block|{
if|if
condition|(
name|cur
operator|->
name|ai_family
operator|!=
name|AF_INET6
condition|)
continue|continue;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|cur
operator|->
name|ai_addr
expr_stmt|;
if|if
condition|(
operator|(
name|scopeid
operator|=
name|ip6_str2scopeid
argument_list|(
name|scope
argument_list|,
name|sin6
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|free
argument_list|(
name|hostname2
argument_list|)
expr_stmt|;
return|return
operator|(
name|EAI_NODATA
operator|)
return|;
comment|/* XXX: is return OK? */
block|}
name|sin6
operator|->
name|sin6_scope_id
operator|=
name|scopeid
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|hostname2
argument_list|)
expr_stmt|;
return|return
name|error
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|get_canonname
parameter_list|(
name|pai
parameter_list|,
name|ai
parameter_list|,
name|str
parameter_list|)
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
if|if
condition|(
operator|(
name|pai
operator|->
name|ai_flags
operator|&
name|AI_CANONNAME
operator|)
operator|!=
literal|0
condition|)
block|{
name|ai
operator|->
name|ai_canonname
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|ai_canonname
operator|==
name|NULL
condition|)
return|return
name|EAI_MEMORY
return|;
name|strcpy
argument_list|(
name|ai
operator|->
name|ai_canonname
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|addrinfo
modifier|*
name|get_ai
parameter_list|(
name|pai
parameter_list|,
name|afd
parameter_list|,
name|addr
parameter_list|)
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
specifier|const
name|struct
name|afd
modifier|*
name|afd
decl_stmt|;
specifier|const
name|char
modifier|*
name|addr
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
ifdef|#
directive|ifdef
name|FAITH
name|struct
name|in6_addr
name|faith_prefix
decl_stmt|;
name|char
modifier|*
name|fp_str
decl_stmt|;
name|int
name|translate
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FAITH
comment|/* 	 * Transfrom an IPv4 addr into a special IPv6 addr format for 	 * IPv6->IPv4 translation gateway. (only TCP is supported now) 	 * 	 * +-----------------------------------+------------+ 	 * | faith prefix part (12 bytes)      | embedded   | 	 * |                                   | IPv4 addr part (4 bytes) 	 * +-----------------------------------+------------+ 	 * 	 * faith prefix part is specified as ascii IPv6 addr format 	 * in environmental variable GAI. 	 * For FAITH to work correctly, routing to faith prefix must be 	 * setup toward a machine where a FAITH daemon operates. 	 * Also, the machine must enable some mechanizm 	 * (e.g. faith interface hack) to divert those packet with 	 * faith prefixed destination addr to user-land FAITH daemon. 	 */
name|fp_str
operator|=
name|getenv
argument_list|(
literal|"GAI"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp_str
operator|&&
name|inet_pton
argument_list|(
name|AF_INET6
argument_list|,
name|fp_str
argument_list|,
operator|&
name|faith_prefix
argument_list|)
operator|==
literal|1
operator|&&
name|afd
operator|->
name|a_af
operator|==
name|AF_INET
operator|&&
name|pai
operator|->
name|ai_socktype
operator|==
name|SOCK_STREAM
condition|)
block|{
name|u_int32_t
name|v4a
decl_stmt|;
name|u_int8_t
name|v4a_top
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|v4a
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
name|v4a
argument_list|)
expr_stmt|;
name|v4a_top
operator|=
name|v4a
operator|>>
name|IN_CLASSA_NSHIFT
expr_stmt|;
if|if
condition|(
operator|!
name|IN_MULTICAST
argument_list|(
name|v4a
argument_list|)
operator|&&
operator|!
name|IN_EXPERIMENTAL
argument_list|(
name|v4a
argument_list|)
operator|&&
name|v4a_top
operator|!=
literal|0
operator|&&
name|v4a
operator|!=
name|IN_LOOPBACKNET
condition|)
block|{
name|afd
operator|=
operator|&
name|afdl
index|[
name|N_INET6
index|]
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|faith_prefix
operator|.
name|s6_addr
index|[
literal|12
index|]
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
name|translate
operator|=
literal|1
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|ai
operator|=
operator|(
expr|struct
name|addrinfo
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|addrinfo
argument_list|)
operator|+
operator|(
name|afd
operator|->
name|a_socklen
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memcpy
argument_list|(
name|ai
argument_list|,
name|pai
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|addrinfo
argument_list|)
argument_list|)
expr_stmt|;
name|ai
operator|->
name|ai_addr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
name|ai
operator|+
literal|1
operator|)
expr_stmt|;
name|memset
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|,
literal|0
argument_list|,
operator|(
name|size_t
operator|)
name|afd
operator|->
name|a_socklen
argument_list|)
expr_stmt|;
name|ai
operator|->
name|ai_addr
operator|->
name|sa_len
operator|=
name|afd
operator|->
name|a_socklen
expr_stmt|;
name|ai
operator|->
name|ai_addrlen
operator|=
name|afd
operator|->
name|a_socklen
expr_stmt|;
name|ai
operator|->
name|ai_addr
operator|->
name|sa_family
operator|=
name|ai
operator|->
name|ai_family
operator|=
name|afd
operator|->
name|a_af
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
name|ai
operator|->
name|ai_addr
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FAITH
if|if
condition|(
name|translate
operator|==
literal|1
condition|)
name|memcpy
argument_list|(
name|p
operator|+
name|afd
operator|->
name|a_off
argument_list|,
operator|&
name|faith_prefix
argument_list|,
operator|(
name|size_t
operator|)
name|afd
operator|->
name|a_addrlen
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|memcpy
argument_list|(
name|p
operator|+
name|afd
operator|->
name|a_off
argument_list|,
name|addr
argument_list|,
operator|(
name|size_t
operator|)
name|afd
operator|->
name|a_addrlen
argument_list|)
expr_stmt|;
return|return
name|ai
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_portmatch
parameter_list|(
name|ai
parameter_list|,
name|servname
parameter_list|)
specifier|const
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
specifier|const
name|char
modifier|*
name|servname
decl_stmt|;
block|{
comment|/* get_port does not touch first argument. when matchonly == 1. */
comment|/* LINTED const cast */
return|return
name|get_port
argument_list|(
operator|(
expr|struct
name|addrinfo
operator|*
operator|)
name|ai
argument_list|,
name|servname
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_port
parameter_list|(
name|ai
parameter_list|,
name|servname
parameter_list|,
name|matchonly
parameter_list|)
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
specifier|const
name|char
modifier|*
name|servname
decl_stmt|;
name|int
name|matchonly
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|proto
decl_stmt|;
name|struct
name|servent
modifier|*
name|sp
decl_stmt|;
name|int
name|port
decl_stmt|;
name|int
name|allownumeric
decl_stmt|;
if|if
condition|(
name|servname
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|ai
operator|->
name|ai_family
condition|)
block|{
case|case
name|AF_INET
case|:
ifdef|#
directive|ifdef
name|AF_INET6
case|case
name|AF_INET6
case|:
endif|#
directive|endif
break|break;
default|default:
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|ai
operator|->
name|ai_socktype
condition|)
block|{
case|case
name|SOCK_RAW
case|:
return|return
name|EAI_SERVICE
return|;
case|case
name|SOCK_DGRAM
case|:
case|case
name|SOCK_STREAM
case|:
name|allownumeric
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ANY
case|:
name|allownumeric
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
return|return
name|EAI_SOCKTYPE
return|;
block|}
if|if
condition|(
name|str_isnumber
argument_list|(
name|servname
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|allownumeric
condition|)
return|return
name|EAI_SERVICE
return|;
name|port
operator|=
name|htons
argument_list|(
name|atoi
argument_list|(
name|servname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|port
operator|<
literal|0
operator|||
name|port
operator|>
literal|65535
condition|)
return|return
name|EAI_SERVICE
return|;
block|}
else|else
block|{
switch|switch
condition|(
name|ai
operator|->
name|ai_socktype
condition|)
block|{
case|case
name|SOCK_DGRAM
case|:
name|proto
operator|=
literal|"udp"
expr_stmt|;
break|break;
case|case
name|SOCK_STREAM
case|:
name|proto
operator|=
literal|"tcp"
expr_stmt|;
break|break;
default|default:
name|proto
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|sp
operator|=
name|getservbyname
argument_list|(
name|servname
argument_list|,
name|proto
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|EAI_SERVICE
return|;
name|port
operator|=
name|sp
operator|->
name|s_port
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|matchonly
condition|)
block|{
switch|switch
condition|(
name|ai
operator|->
name|ai_family
condition|)
block|{
case|case
name|AF_INET
case|:
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|ai
operator|->
name|ai_addr
operator|)
operator|->
name|sin_port
operator|=
name|port
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|ai
operator|->
name|ai_addr
operator|)
operator|->
name|sin6_port
operator|=
name|port
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|struct
name|afd
modifier|*
name|find_afd
parameter_list|(
name|af
parameter_list|)
name|int
name|af
decl_stmt|;
block|{
specifier|const
name|struct
name|afd
modifier|*
name|afd
decl_stmt|;
if|if
condition|(
name|af
operator|==
name|PF_UNSPEC
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|afd
operator|=
name|afdl
init|;
name|afd
operator|->
name|a_af
condition|;
name|afd
operator|++
control|)
block|{
if|if
condition|(
name|afd
operator|->
name|a_af
operator|==
name|af
condition|)
return|return
name|afd
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * post-2553: AI_ADDRCONFIG check.  if we use getipnodeby* as backend, backend  * will take care of it.  * the semantics of AI_ADDRCONFIG is not defined well.  we are not sure  * if the code is right or not.  *  * XXX PF_UNSPEC -> PF_INET6 + PF_INET mapping needs to be in sync with  * _dns_getaddrinfo.  */
end_comment

begin_function
specifier|static
name|int
name|addrconfig
parameter_list|(
name|pai
parameter_list|)
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
block|{
name|int
name|s
decl_stmt|,
name|af
decl_stmt|;
comment|/* 	 * TODO: 	 * Note that implementation dependent test for address 	 * configuration should be done everytime called 	 * (or apropriate interval), 	 * because addresses will be dynamically assigned or deleted. 	 */
name|af
operator|=
name|pai
operator|->
name|ai_family
expr_stmt|;
if|if
condition|(
name|af
operator|==
name|AF_UNSPEC
condition|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|_socket
argument_list|(
name|AF_INET6
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|af
operator|=
name|AF_INET
expr_stmt|;
else|else
block|{
name|_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|_socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|af
operator|=
name|AF_INET6
expr_stmt|;
else|else
name|_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|af
operator|!=
name|AF_UNSPEC
condition|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|_socket
argument_list|(
name|af
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|pai
operator|->
name|ai_family
operator|=
name|af
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_comment
comment|/* convert a string to a scope identifier. XXX: IPv6 specific */
end_comment

begin_function
specifier|static
name|int
name|ip6_str2scopeid
parameter_list|(
name|scope
parameter_list|,
name|sin6
parameter_list|)
name|char
modifier|*
name|scope
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
block|{
name|int
name|scopeid
decl_stmt|;
name|struct
name|in6_addr
modifier|*
name|a6
init|=
operator|&
name|sin6
operator|->
name|sin6_addr
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
comment|/* empty scopeid portion is invalid */
if|if
condition|(
operator|*
name|scope
operator|==
literal|'\0'
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
name|a6
argument_list|)
operator|||
name|IN6_IS_ADDR_MC_LINKLOCAL
argument_list|(
name|a6
argument_list|)
condition|)
block|{
comment|/* 		 * We currently assume a one-to-one mapping between links 		 * and interfaces, so we simply use interface indices for 		 * like-local scopes. 		 */
name|scopeid
operator|=
name|if_nametoindex
argument_list|(
name|scope
argument_list|)
expr_stmt|;
if|if
condition|(
name|scopeid
operator|==
literal|0
condition|)
goto|goto
name|trynumeric
goto|;
return|return
operator|(
name|scopeid
operator|)
return|;
block|}
comment|/* still unclear about literal, allow numeric only - placeholder */
if|if
condition|(
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
name|a6
argument_list|)
operator|||
name|IN6_IS_ADDR_MC_SITELOCAL
argument_list|(
name|a6
argument_list|)
condition|)
goto|goto
name|trynumeric
goto|;
if|if
condition|(
name|IN6_IS_ADDR_MC_ORGLOCAL
argument_list|(
name|a6
argument_list|)
condition|)
goto|goto
name|trynumeric
goto|;
else|else
goto|goto
name|trynumeric
goto|;
comment|/* global */
comment|/* try to convert to a numeric id as a last resort */
name|trynumeric
label|:
name|scopeid
operator|=
operator|(
name|int
operator|)
name|strtoul
argument_list|(
name|scope
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ep
operator|==
literal|'\0'
condition|)
return|return
name|scopeid
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|AskedForGot
index|[]
init|=
literal|"gethostby*.getanswer: asked for \"%s\", got \"%s\""
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|hostf
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|struct
name|addrinfo
modifier|*
name|getanswer
parameter_list|(
name|answer
parameter_list|,
name|anslen
parameter_list|,
name|qname
parameter_list|,
name|qtype
parameter_list|,
name|pai
parameter_list|)
specifier|const
name|querybuf
modifier|*
name|answer
decl_stmt|;
name|int
name|anslen
decl_stmt|;
specifier|const
name|char
modifier|*
name|qname
decl_stmt|;
name|int
name|qtype
decl_stmt|;
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
block|{
name|struct
name|addrinfo
name|sentinel
decl_stmt|,
modifier|*
name|cur
decl_stmt|;
name|struct
name|addrinfo
name|ai
decl_stmt|;
specifier|const
name|struct
name|afd
modifier|*
name|afd
decl_stmt|;
name|char
modifier|*
name|canonname
decl_stmt|;
specifier|const
name|HEADER
modifier|*
name|hp
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|cp
decl_stmt|;
name|int
name|n
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|eom
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|;
name|int
name|type
decl_stmt|,
name|class
decl_stmt|,
name|buflen
decl_stmt|,
name|ancount
decl_stmt|,
name|qdcount
decl_stmt|;
name|int
name|haveanswer
decl_stmt|,
name|had_error
decl_stmt|;
name|char
name|tbuf
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|int
argument_list|(
argument|*name_ok
argument_list|)
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
expr_stmt|;
name|char
name|hostbuf
index|[
literal|8
operator|*
literal|1024
index|]
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sentinel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sentinel
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
operator|&
name|sentinel
expr_stmt|;
name|canonname
operator|=
name|NULL
expr_stmt|;
name|eom
operator|=
name|answer
operator|->
name|buf
operator|+
name|anslen
expr_stmt|;
switch|switch
condition|(
name|qtype
condition|)
block|{
case|case
name|T_A
case|:
case|case
name|T_AAAA
case|:
case|case
name|T_ANY
case|:
comment|/*use T_ANY only for T_A/T_AAAA lookup*/
name|name_ok
operator|=
name|res_hnok
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* XXX should be abort(); */
block|}
comment|/* 	 * find first satisfactory answer 	 */
name|hp
operator|=
operator|&
name|answer
operator|->
name|hdr
expr_stmt|;
name|ancount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|qdcount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|qdcount
argument_list|)
expr_stmt|;
name|bp
operator|=
name|hostbuf
expr_stmt|;
name|buflen
operator|=
sizeof|sizeof
name|hostbuf
expr_stmt|;
name|cp
operator|=
name|answer
operator|->
name|buf
operator|+
name|HFIXEDSZ
expr_stmt|;
if|if
condition|(
name|qdcount
operator|!=
literal|1
condition|)
block|{
name|h_errno
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|n
operator|=
name|dn_expand
argument_list|(
name|answer
operator|->
name|buf
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
name|bp
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|<
literal|0
operator|)
operator|||
operator|!
call|(
modifier|*
name|name_ok
call|)
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|h_errno
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|cp
operator|+=
name|n
operator|+
name|QFIXEDSZ
expr_stmt|;
if|if
condition|(
name|qtype
operator|==
name|T_A
operator|||
name|qtype
operator|==
name|T_AAAA
operator|||
name|qtype
operator|==
name|T_ANY
condition|)
block|{
comment|/* res_send() has already verified that the query name is the 		 * same as the one we sent; this just gets the expanded name 		 * (i.e., with the succeeding search-domain tacked on). 		 */
name|n
operator|=
name|strlen
argument_list|(
name|bp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* for the \0 */
if|if
condition|(
name|n
operator|>=
name|MAXHOSTNAMELEN
condition|)
block|{
name|h_errno
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|canonname
operator|=
name|bp
expr_stmt|;
name|bp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
comment|/* The qname can be abbreviated, but h_name is now absolute. */
name|qname
operator|=
name|canonname
expr_stmt|;
block|}
name|haveanswer
operator|=
literal|0
expr_stmt|;
name|had_error
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ancount
operator|--
operator|>
literal|0
operator|&&
name|cp
operator|<
name|eom
operator|&&
operator|!
name|had_error
condition|)
block|{
name|n
operator|=
name|dn_expand
argument_list|(
name|answer
operator|->
name|buf
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
name|bp
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|<
literal|0
operator|)
operator|||
operator|!
call|(
modifier|*
name|name_ok
call|)
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|had_error
operator|++
expr_stmt|;
continue|continue;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* name */
name|type
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
comment|/* type */
name|class
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
operator|+
name|INT32SZ
expr_stmt|;
comment|/* class, TTL */
name|n
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
comment|/* len */
if|if
condition|(
name|class
operator|!=
name|C_IN
condition|)
block|{
comment|/* XXX - debug? syslog? */
name|cp
operator|+=
name|n
expr_stmt|;
continue|continue;
comment|/* XXX - had_error++ ? */
block|}
if|if
condition|(
operator|(
name|qtype
operator|==
name|T_A
operator|||
name|qtype
operator|==
name|T_AAAA
operator|||
name|qtype
operator|==
name|T_ANY
operator|)
operator|&&
name|type
operator|==
name|T_CNAME
condition|)
block|{
name|n
operator|=
name|dn_expand
argument_list|(
name|answer
operator|->
name|buf
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
name|tbuf
argument_list|,
sizeof|sizeof
name|tbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|<
literal|0
operator|)
operator|||
operator|!
call|(
modifier|*
name|name_ok
call|)
argument_list|(
name|tbuf
argument_list|)
condition|)
block|{
name|had_error
operator|++
expr_stmt|;
continue|continue;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* Get canonical name. */
name|n
operator|=
name|strlen
argument_list|(
name|tbuf
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* for the \0 */
if|if
condition|(
name|n
operator|>
name|buflen
operator|||
name|n
operator|>=
name|MAXHOSTNAMELEN
condition|)
block|{
name|had_error
operator|++
expr_stmt|;
continue|continue;
block|}
name|strcpy
argument_list|(
name|bp
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
name|canonname
operator|=
name|bp
expr_stmt|;
name|bp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|qtype
operator|==
name|T_ANY
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|type
operator|==
name|T_A
operator|||
name|type
operator|==
name|T_AAAA
operator|)
condition|)
block|{
name|cp
operator|+=
name|n
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
name|qtype
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|type
operator|!=
name|T_KEY
operator|&&
name|type
operator|!=
name|T_SIG
condition|)
name|syslog
argument_list|(
name|LOG_NOTICE
operator||
name|LOG_AUTH
argument_list|,
literal|"gethostby*.getanswer: asked for \"%s %s %s\", got type \"%s\""
argument_list|,
name|qname
argument_list|,
name|p_class
argument_list|(
name|C_IN
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|qtype
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cp
operator|+=
name|n
expr_stmt|;
continue|continue;
comment|/* XXX - had_error++ ? */
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_A
case|:
case|case
name|T_AAAA
case|:
if|if
condition|(
name|strcasecmp
argument_list|(
name|canonname
argument_list|,
name|bp
argument_list|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|syslog
argument_list|(
name|LOG_NOTICE
operator||
name|LOG_AUTH
argument_list|,
name|AskedForGot
argument_list|,
name|canonname
argument_list|,
name|bp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cp
operator|+=
name|n
expr_stmt|;
continue|continue;
comment|/* XXX - had_error++ ? */
block|}
if|if
condition|(
name|type
operator|==
name|T_A
operator|&&
name|n
operator|!=
name|INADDRSZ
condition|)
block|{
name|cp
operator|+=
name|n
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|type
operator|==
name|T_AAAA
operator|&&
name|n
operator|!=
name|IN6ADDRSZ
condition|)
block|{
name|cp
operator|+=
name|n
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|FILTER_V4MAPPED
if|if
condition|(
name|type
operator|==
name|T_AAAA
condition|)
block|{
name|struct
name|in6_addr
name|in6
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|in6
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|in6
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|in6
argument_list|)
condition|)
block|{
name|cp
operator|+=
name|n
expr_stmt|;
continue|continue;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|haveanswer
condition|)
block|{
name|int
name|nn
decl_stmt|;
name|canonname
operator|=
name|bp
expr_stmt|;
name|nn
operator|=
name|strlen
argument_list|(
name|bp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* for the \0 */
name|bp
operator|+=
name|nn
expr_stmt|;
name|buflen
operator|-=
name|nn
expr_stmt|;
block|}
comment|/* don't overwrite pai */
name|ai
operator|=
operator|*
name|pai
expr_stmt|;
name|ai
operator|.
name|ai_family
operator|=
operator|(
name|type
operator|==
name|T_A
operator|)
condition|?
name|AF_INET
else|:
name|AF_INET6
expr_stmt|;
name|afd
operator|=
name|find_afd
argument_list|(
name|ai
operator|.
name|ai_family
argument_list|)
expr_stmt|;
if|if
condition|(
name|afd
operator|==
name|NULL
condition|)
block|{
name|cp
operator|+=
name|n
expr_stmt|;
continue|continue;
block|}
name|cur
operator|->
name|ai_next
operator|=
name|get_ai
argument_list|(
operator|&
name|ai
argument_list|,
name|afd
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|->
name|ai_next
operator|==
name|NULL
condition|)
name|had_error
operator|++
expr_stmt|;
while|while
condition|(
name|cur
operator|&&
name|cur
operator|->
name|ai_next
condition|)
name|cur
operator|=
name|cur
operator|->
name|ai_next
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|had_error
condition|)
name|haveanswer
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|haveanswer
condition|)
block|{
if|if
condition|(
operator|!
name|canonname
condition|)
operator|(
name|void
operator|)
name|get_canonname
argument_list|(
name|pai
argument_list|,
name|sentinel
operator|.
name|ai_next
argument_list|,
name|qname
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|get_canonname
argument_list|(
name|pai
argument_list|,
name|sentinel
operator|.
name|ai_next
argument_list|,
name|canonname
argument_list|)
expr_stmt|;
name|h_errno
operator|=
name|NETDB_SUCCESS
expr_stmt|;
return|return
name|sentinel
operator|.
name|ai_next
return|;
block|}
name|h_errno
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|_dns_getaddrinfo
parameter_list|(
name|rv
parameter_list|,
name|cb_data
parameter_list|,
name|ap
parameter_list|)
name|void
modifier|*
name|rv
decl_stmt|;
name|void
modifier|*
name|cb_data
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
block|{
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
name|querybuf
name|buf
decl_stmt|,
name|buf2
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
name|struct
name|addrinfo
name|sentinel
decl_stmt|,
modifier|*
name|cur
decl_stmt|;
name|struct
name|res_target
name|q
decl_stmt|,
name|q2
decl_stmt|;
name|name
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|pai
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
expr|struct
name|addrinfo
operator|*
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|q
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|q2
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|q2
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|q2
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sentinel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sentinel
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
operator|&
name|sentinel
expr_stmt|;
switch|switch
condition|(
name|pai
operator|->
name|ai_family
condition|)
block|{
case|case
name|AF_UNSPEC
case|:
comment|/* prefer IPv6 */
name|q
operator|.
name|qclass
operator|=
name|C_IN
expr_stmt|;
name|q
operator|.
name|qtype
operator|=
name|T_AAAA
expr_stmt|;
name|q
operator|.
name|answer
operator|=
name|buf
operator|.
name|buf
expr_stmt|;
name|q
operator|.
name|anslen
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|q
operator|.
name|next
operator|=
operator|&
name|q2
expr_stmt|;
name|q2
operator|.
name|qclass
operator|=
name|C_IN
expr_stmt|;
name|q2
operator|.
name|qtype
operator|=
name|T_A
expr_stmt|;
name|q2
operator|.
name|answer
operator|=
name|buf2
operator|.
name|buf
expr_stmt|;
name|q2
operator|.
name|anslen
operator|=
sizeof|sizeof
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_INET
case|:
name|q
operator|.
name|qclass
operator|=
name|C_IN
expr_stmt|;
name|q
operator|.
name|qtype
operator|=
name|T_A
expr_stmt|;
name|q
operator|.
name|answer
operator|=
name|buf
operator|.
name|buf
expr_stmt|;
name|q
operator|.
name|anslen
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
name|q
operator|.
name|qclass
operator|=
name|C_IN
expr_stmt|;
name|q
operator|.
name|qtype
operator|=
name|T_AAAA
expr_stmt|;
name|q
operator|.
name|answer
operator|=
name|buf
operator|.
name|buf
expr_stmt|;
name|q
operator|.
name|anslen
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|NS_UNAVAIL
return|;
block|}
if|if
condition|(
name|res_searchN
argument_list|(
name|name
argument_list|,
operator|&
name|q
argument_list|)
operator|<
literal|0
condition|)
return|return
name|NS_NOTFOUND
return|;
name|ai
operator|=
name|getanswer
argument_list|(
operator|&
name|buf
argument_list|,
name|q
operator|.
name|n
argument_list|,
name|q
operator|.
name|name
argument_list|,
name|q
operator|.
name|qtype
argument_list|,
name|pai
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
condition|)
block|{
name|cur
operator|->
name|ai_next
operator|=
name|ai
expr_stmt|;
while|while
condition|(
name|cur
operator|&&
name|cur
operator|->
name|ai_next
condition|)
name|cur
operator|=
name|cur
operator|->
name|ai_next
expr_stmt|;
block|}
if|if
condition|(
name|q
operator|.
name|next
condition|)
block|{
name|ai
operator|=
name|getanswer
argument_list|(
operator|&
name|buf2
argument_list|,
name|q2
operator|.
name|n
argument_list|,
name|q2
operator|.
name|name
argument_list|,
name|q2
operator|.
name|qtype
argument_list|,
name|pai
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
condition|)
name|cur
operator|->
name|ai_next
operator|=
name|ai
expr_stmt|;
block|}
if|if
condition|(
name|sentinel
operator|.
name|ai_next
operator|==
name|NULL
condition|)
switch|switch
condition|(
name|h_errno
condition|)
block|{
case|case
name|HOST_NOT_FOUND
case|:
return|return
name|NS_NOTFOUND
return|;
case|case
name|TRY_AGAIN
case|:
return|return
name|NS_TRYAGAIN
return|;
default|default:
return|return
name|NS_UNAVAIL
return|;
block|}
operator|*
operator|(
operator|(
expr|struct
name|addrinfo
operator|*
operator|*
operator|)
name|rv
operator|)
operator|=
name|sentinel
operator|.
name|ai_next
expr_stmt|;
return|return
name|NS_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_sethtent
parameter_list|()
block|{
if|if
condition|(
operator|!
name|hostf
condition|)
name|hostf
operator|=
name|fopen
argument_list|(
name|_PATH_HOSTS
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
else|else
name|rewind
argument_list|(
name|hostf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_endhtent
parameter_list|()
block|{
if|if
condition|(
name|hostf
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|hostf
argument_list|)
expr_stmt|;
name|hostf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|addrinfo
modifier|*
name|_gethtent
parameter_list|(
name|name
parameter_list|,
name|pai
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|tname
decl_stmt|,
modifier|*
name|cname
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|res0
decl_stmt|,
modifier|*
name|res
decl_stmt|;
name|int
name|error
decl_stmt|;
specifier|const
name|char
modifier|*
name|addr
decl_stmt|;
name|char
name|hostbuf
index|[
literal|8
operator|*
literal|1024
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|hostf
operator|&&
operator|!
operator|(
name|hostf
operator|=
name|fopen
argument_list|(
name|_PATH_HOSTS
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|again
label|:
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|fgets
argument_list|(
name|hostbuf
argument_list|,
sizeof|sizeof
name|hostbuf
argument_list|,
name|hostf
argument_list|)
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'#'
condition|)
goto|goto
name|again
goto|;
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
name|strpbrk
argument_list|(
name|p
argument_list|,
literal|"#\n"
argument_list|)
operator|)
condition|)
goto|goto
name|again
goto|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
name|strpbrk
argument_list|(
name|p
argument_list|,
literal|" \t"
argument_list|)
operator|)
condition|)
goto|goto
name|again
goto|;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|addr
operator|=
name|p
expr_stmt|;
name|cname
operator|=
name|NULL
expr_stmt|;
comment|/* if this is not something we're looking for, skip it. */
while|while
condition|(
name|cp
operator|&&
operator|*
name|cp
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
continue|continue;
block|}
name|tname
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|cname
operator|==
name|NULL
condition|)
name|cname
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strpbrk
argument_list|(
name|cp
argument_list|,
literal|" \t"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|tname
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|found
goto|;
block|}
goto|goto
name|again
goto|;
name|found
label|:
name|hints
operator|=
operator|*
name|pai
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|AI_NUMERICHOST
expr_stmt|;
name|error
operator|=
name|getaddrinfo
argument_list|(
name|addr
argument_list|,
name|NULL
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|res0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|again
goto|;
ifdef|#
directive|ifdef
name|FILTER_V4MAPPED
comment|/* XXX should check all items in the chain */
if|if
condition|(
name|res0
operator|->
name|ai_family
operator|==
name|AF_INET6
operator|&&
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|res0
operator|->
name|ai_addr
operator|)
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|freeaddrinfo
argument_list|(
name|res0
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
endif|#
directive|endif
for|for
control|(
name|res
operator|=
name|res0
init|;
name|res
condition|;
name|res
operator|=
name|res
operator|->
name|ai_next
control|)
block|{
comment|/* cover it up */
name|res
operator|->
name|ai_flags
operator|=
name|pai
operator|->
name|ai_flags
expr_stmt|;
if|if
condition|(
name|pai
operator|->
name|ai_flags
operator|&
name|AI_CANONNAME
condition|)
block|{
if|if
condition|(
name|get_canonname
argument_list|(
name|pai
argument_list|,
name|res
argument_list|,
name|cname
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|freeaddrinfo
argument_list|(
name|res0
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
block|}
return|return
name|res0
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|_files_getaddrinfo
parameter_list|(
name|rv
parameter_list|,
name|cb_data
parameter_list|,
name|ap
parameter_list|)
name|void
modifier|*
name|rv
decl_stmt|;
name|void
modifier|*
name|cb_data
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
name|struct
name|addrinfo
name|sentinel
decl_stmt|,
modifier|*
name|cur
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|p
decl_stmt|;
name|name
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|pai
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
expr|struct
name|addrinfo
operator|*
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sentinel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sentinel
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
operator|&
name|sentinel
expr_stmt|;
name|_sethtent
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|_gethtent
argument_list|(
name|name
argument_list|,
name|pai
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|cur
operator|->
name|ai_next
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|cur
operator|&&
name|cur
operator|->
name|ai_next
condition|)
name|cur
operator|=
name|cur
operator|->
name|ai_next
expr_stmt|;
block|}
name|_endhtent
argument_list|()
expr_stmt|;
operator|*
operator|(
operator|(
expr|struct
name|addrinfo
operator|*
operator|*
operator|)
name|rv
operator|)
operator|=
name|sentinel
operator|.
name|ai_next
expr_stmt|;
if|if
condition|(
name|sentinel
operator|.
name|ai_next
operator|==
name|NULL
condition|)
return|return
name|NS_NOTFOUND
return|;
return|return
name|NS_SUCCESS
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|YP
end_ifdef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|__ypdomain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|struct
name|addrinfo
modifier|*
name|_yphostent
parameter_list|(
name|line
parameter_list|,
name|pai
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
block|{
name|struct
name|addrinfo
name|sentinel
decl_stmt|,
modifier|*
name|cur
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|res
decl_stmt|,
modifier|*
name|res0
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|addr
decl_stmt|,
modifier|*
name|canonname
decl_stmt|;
name|char
modifier|*
name|nextline
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|addr
operator|=
name|canonname
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sentinel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sentinel
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
operator|&
name|sentinel
expr_stmt|;
name|nextline
label|:
comment|/* terminate line */
name|cp
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|nextline
operator|=
name|cp
expr_stmt|;
block|}
else|else
name|nextline
operator|=
name|NULL
expr_stmt|;
name|cp
operator|=
name|strpbrk
argument_list|(
name|p
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|canonname
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
goto|goto
name|done
goto|;
block|}
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|addr
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|cp
operator|&&
operator|*
name|cp
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|canonname
condition|)
name|canonname
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strpbrk
argument_list|(
name|cp
argument_list|,
literal|" \t"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
name|hints
operator|=
operator|*
name|pai
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|AI_NUMERICHOST
expr_stmt|;
name|error
operator|=
name|getaddrinfo
argument_list|(
name|addr
argument_list|,
name|NULL
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|res0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|res
operator|=
name|res0
init|;
name|res
condition|;
name|res
operator|=
name|res
operator|->
name|ai_next
control|)
block|{
comment|/* cover it up */
name|res
operator|->
name|ai_flags
operator|=
name|pai
operator|->
name|ai_flags
expr_stmt|;
if|if
condition|(
name|pai
operator|->
name|ai_flags
operator|&
name|AI_CANONNAME
condition|)
operator|(
name|void
operator|)
name|get_canonname
argument_list|(
name|pai
argument_list|,
name|res
argument_list|,
name|canonname
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|res0
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|res0
condition|)
block|{
name|cur
operator|->
name|ai_next
operator|=
name|res0
expr_stmt|;
while|while
condition|(
name|cur
operator|&&
name|cur
operator|->
name|ai_next
condition|)
name|cur
operator|=
name|cur
operator|->
name|ai_next
expr_stmt|;
block|}
if|if
condition|(
name|nextline
condition|)
block|{
name|p
operator|=
name|nextline
expr_stmt|;
goto|goto
name|nextline
goto|;
block|}
name|done
label|:
return|return
name|sentinel
operator|.
name|ai_next
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|_yp_getaddrinfo
parameter_list|(
name|rv
parameter_list|,
name|cb_data
parameter_list|,
name|ap
parameter_list|)
name|void
modifier|*
name|rv
decl_stmt|;
name|void
modifier|*
name|cb_data
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
block|{
name|struct
name|addrinfo
name|sentinel
decl_stmt|,
modifier|*
name|cur
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|ai
init|=
name|NULL
decl_stmt|;
specifier|static
name|char
modifier|*
name|__ypcurrent
decl_stmt|;
name|int
name|__ypcurrentlen
decl_stmt|,
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
name|name
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|pai
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
expr|struct
name|addrinfo
operator|*
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sentinel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sentinel
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
operator|&
name|sentinel
expr_stmt|;
if|if
condition|(
operator|!
name|__ypdomain
condition|)
block|{
if|if
condition|(
name|_yp_check
argument_list|(
operator|&
name|__ypdomain
argument_list|)
operator|==
literal|0
condition|)
return|return
name|NS_UNAVAIL
return|;
block|}
if|if
condition|(
name|__ypcurrent
condition|)
name|free
argument_list|(
name|__ypcurrent
argument_list|)
expr_stmt|;
name|__ypcurrent
operator|=
name|NULL
expr_stmt|;
comment|/* hosts.byname is only for IPv4 (Solaris8) */
if|if
condition|(
name|pai
operator|->
name|ai_family
operator|==
name|PF_UNSPEC
operator|||
name|pai
operator|->
name|ai_family
operator|==
name|PF_INET
condition|)
block|{
name|r
operator|=
name|yp_match
argument_list|(
name|__ypdomain
argument_list|,
literal|"hosts.byname"
argument_list|,
name|name
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
operator|&
name|__ypcurrent
argument_list|,
operator|&
name|__ypcurrentlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|struct
name|addrinfo
name|ai4
decl_stmt|;
name|ai4
operator|=
operator|*
name|pai
expr_stmt|;
name|ai4
operator|.
name|ai_family
operator|=
name|AF_INET
expr_stmt|;
name|ai
operator|=
name|_yphostent
argument_list|(
name|__ypcurrent
argument_list|,
operator|&
name|ai4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
condition|)
block|{
name|cur
operator|->
name|ai_next
operator|=
name|ai
expr_stmt|;
while|while
condition|(
name|cur
operator|&&
name|cur
operator|->
name|ai_next
condition|)
name|cur
operator|=
name|cur
operator|->
name|ai_next
expr_stmt|;
block|}
block|}
block|}
comment|/* ipnodes.byname can hold both IPv4/v6 */
name|r
operator|=
name|yp_match
argument_list|(
name|__ypdomain
argument_list|,
literal|"ipnodes.byname"
argument_list|,
name|name
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
operator|&
name|__ypcurrent
argument_list|,
operator|&
name|__ypcurrentlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|ai
operator|=
name|_yphostent
argument_list|(
name|__ypcurrent
argument_list|,
name|pai
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
condition|)
block|{
name|cur
operator|->
name|ai_next
operator|=
name|ai
expr_stmt|;
while|while
condition|(
name|cur
operator|&&
name|cur
operator|->
name|ai_next
condition|)
name|cur
operator|=
name|cur
operator|->
name|ai_next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|sentinel
operator|.
name|ai_next
operator|==
name|NULL
condition|)
block|{
name|h_errno
operator|=
name|HOST_NOT_FOUND
expr_stmt|;
return|return
name|NS_NOTFOUND
return|;
block|}
operator|*
operator|(
operator|(
expr|struct
name|addrinfo
operator|*
operator|*
operator|)
name|rv
operator|)
operator|=
name|sentinel
operator|.
name|ai_next
expr_stmt|;
return|return
name|NS_SUCCESS
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* resolver logic */
end_comment

begin_decl_stmt
specifier|extern
specifier|const
name|char
modifier|*
name|__hostalias
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|h_errno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Formulate a normal query, send, and await answer.  * Returned answer is placed in supplied buffer "answer".  * Perform preliminary check of answer, returning success only  * if no error is indicated and the answer count is nonzero.  * Return the size of the response on success, -1 on error.  * Error number is left in h_errno.  *  * Caller must parse answer and determine whether it answers the question.  */
end_comment

begin_function
specifier|static
name|int
name|res_queryN
parameter_list|(
name|name
parameter_list|,
name|target
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* domain name */
name|struct
name|res_target
modifier|*
name|target
decl_stmt|;
block|{
name|u_char
name|buf
index|[
name|MAXPACKET
index|]
decl_stmt|;
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|int
name|n
decl_stmt|;
name|struct
name|res_target
modifier|*
name|t
decl_stmt|;
name|int
name|rcode
decl_stmt|;
name|int
name|ancount
decl_stmt|;
name|rcode
operator|=
name|NOERROR
expr_stmt|;
name|ancount
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_INIT
operator|)
operator|==
literal|0
operator|&&
name|res_init
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
name|h_errno
operator|=
name|NETDB_INTERNAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|t
operator|=
name|target
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
name|int
name|class
decl_stmt|,
name|type
decl_stmt|;
name|u_char
modifier|*
name|answer
decl_stmt|;
name|int
name|anslen
decl_stmt|;
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|t
operator|->
name|answer
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|NOERROR
expr_stmt|;
comment|/* default */
comment|/* make it easier... */
name|class
operator|=
name|t
operator|->
name|qclass
expr_stmt|;
name|type
operator|=
name|t
operator|->
name|qtype
expr_stmt|;
name|answer
operator|=
name|t
operator|->
name|answer
expr_stmt|;
name|anslen
operator|=
name|t
operator|->
name|anslen
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|_res
operator|.
name|options
operator|&
name|RES_DEBUG
condition|)
name|printf
argument_list|(
literal|";; res_query(%s, %d, %d)\n"
argument_list|,
name|name
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|n
operator|=
name|res_mkquery
argument_list|(
name|QUERY
argument_list|,
name|name
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
operator|&&
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_USE_EDNS0
operator|)
operator|!=
literal|0
condition|)
name|n
operator|=
name|res_opt
argument_list|(
name|n
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|anslen
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|_res
operator|.
name|options
operator|&
name|RES_DEBUG
condition|)
name|printf
argument_list|(
literal|";; res_query: mkquery failed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|h_errno
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
name|n
operator|=
name|res_send
argument_list|(
name|buf
argument_list|,
name|n
argument_list|,
name|answer
argument_list|,
name|anslen
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (n< 0) {
ifdef|#
directive|ifdef
name|DEBUG
block|if (_res.options& RES_DEBUG) 				printf(";; res_query: send error\n");
endif|#
directive|endif
block|h_errno = TRY_AGAIN; 			return (n); 		}
endif|#
directive|endif
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|hp
operator|->
name|rcode
operator|!=
name|NOERROR
operator|||
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rcode
operator|=
name|hp
operator|->
name|rcode
expr_stmt|;
comment|/* record most recent error */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|_res
operator|.
name|options
operator|&
name|RES_DEBUG
condition|)
name|printf
argument_list|(
literal|";; rcode = %d, ancount=%d\n"
argument_list|,
name|hp
operator|->
name|rcode
argument_list|,
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
name|ancount
operator|+=
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|t
operator|->
name|n
operator|=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|ancount
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|rcode
condition|)
block|{
case|case
name|NXDOMAIN
case|:
name|h_errno
operator|=
name|HOST_NOT_FOUND
expr_stmt|;
break|break;
case|case
name|SERVFAIL
case|:
name|h_errno
operator|=
name|TRY_AGAIN
expr_stmt|;
break|break;
case|case
name|NOERROR
case|:
name|h_errno
operator|=
name|NO_DATA
expr_stmt|;
break|break;
case|case
name|FORMERR
case|:
case|case
name|NOTIMP
case|:
case|case
name|REFUSED
case|:
default|default:
name|h_errno
operator|=
name|NO_RECOVERY
expr_stmt|;
break|break;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|ancount
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Formulate a normal query, send, and retrieve answer in supplied buffer.  * Return the size of the response on success, -1 on error.  * If enabled, implement search rules until answer or unrecoverable failure  * is detected.  Error code, if any, is left in h_errno.  */
end_comment

begin_function
specifier|static
name|int
name|res_searchN
parameter_list|(
name|name
parameter_list|,
name|target
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* domain name */
name|struct
name|res_target
modifier|*
name|target
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
decl_stmt|const
modifier|*
name|domain
decl_stmt|;
name|HEADER
modifier|*
name|hp
init|=
operator|(
name|HEADER
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|target
operator|->
name|answer
decl_stmt|;
comment|/*XXX*/
name|u_int
name|dots
decl_stmt|;
name|int
name|trailing_dot
decl_stmt|,
name|ret
decl_stmt|,
name|saved_herrno
decl_stmt|;
name|int
name|got_nodata
init|=
literal|0
decl_stmt|,
name|got_servfail
init|=
literal|0
decl_stmt|,
name|tried_as_is
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_INIT
operator|)
operator|==
literal|0
operator|&&
name|res_init
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
name|h_errno
operator|=
name|NETDB_INTERNAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|errno
operator|=
literal|0
expr_stmt|;
name|h_errno
operator|=
name|HOST_NOT_FOUND
expr_stmt|;
comment|/* default, if we never query */
name|dots
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|name
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
name|dots
operator|+=
operator|(
operator|*
name|cp
operator|==
literal|'.'
operator|)
expr_stmt|;
name|trailing_dot
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cp
operator|>
name|name
operator|&&
operator|*
operator|--
name|cp
operator|==
literal|'.'
condition|)
name|trailing_dot
operator|++
expr_stmt|;
comment|/* 	 * if there aren't any dots, it could be a user-level alias 	 */
if|if
condition|(
operator|!
name|dots
operator|&&
operator|(
name|cp
operator|=
name|__hostalias
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|res_queryN
argument_list|(
name|cp
argument_list|,
name|target
argument_list|)
operator|)
return|;
comment|/* 	 * If there are dots in the name already, let's just give it a try 	 * 'as is'.  The threshold can be set with the "ndots" option. 	 */
name|saved_herrno
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|dots
operator|>=
name|_res
operator|.
name|ndots
condition|)
block|{
name|ret
operator|=
name|res_querydomainN
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|saved_herrno
operator|=
name|h_errno
expr_stmt|;
name|tried_as_is
operator|++
expr_stmt|;
block|}
comment|/* 	 * We do at least one level of search if 	 *	- there is no dot and RES_DEFNAME is set, or 	 *	- there is at least one dot, there is no trailing dot, 	 *	  and RES_DNSRCH is set. 	 */
if|if
condition|(
operator|(
operator|!
name|dots
operator|&&
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_DEFNAMES
operator|)
operator|)
operator|||
operator|(
name|dots
operator|&&
operator|!
name|trailing_dot
operator|&&
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_DNSRCH
operator|)
operator|)
condition|)
block|{
name|int
name|done
init|=
literal|0
decl_stmt|;
for|for
control|(
name|domain
operator|=
operator|(
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|)
name|_res
operator|.
name|dnsrch
init|;
operator|*
name|domain
operator|&&
operator|!
name|done
condition|;
name|domain
operator|++
control|)
block|{
name|ret
operator|=
name|res_querydomainN
argument_list|(
name|name
argument_list|,
operator|*
name|domain
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
comment|/* 			 * If no server present, give up. 			 * If name isn't found in this domain, 			 * keep trying higher domains in the search list 			 * (if that's enabled). 			 * On a NO_DATA error, keep trying, otherwise 			 * a wildcard entry of another type could keep us 			 * from finding this entry higher in the domain. 			 * If we get some other error (negative answer or 			 * server failure), then stop searching up, 			 * but try the input name below in case it's 			 * fully-qualified. 			 */
if|if
condition|(
name|errno
operator|==
name|ECONNREFUSED
condition|)
block|{
name|h_errno
operator|=
name|TRY_AGAIN
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
switch|switch
condition|(
name|h_errno
condition|)
block|{
case|case
name|NO_DATA
case|:
name|got_nodata
operator|++
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|HOST_NOT_FOUND
case|:
comment|/* keep trying */
break|break;
case|case
name|TRY_AGAIN
case|:
if|if
condition|(
name|hp
operator|->
name|rcode
operator|==
name|SERVFAIL
condition|)
block|{
comment|/* try next search element, if any */
name|got_servfail
operator|++
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
default|default:
comment|/* anything else implies that we're done */
name|done
operator|++
expr_stmt|;
block|}
comment|/* 			 * if we got here for some reason other than DNSRCH, 			 * we only wanted one iteration of the loop, so stop. 			 */
if|if
condition|(
operator|!
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_DNSRCH
operator|)
condition|)
name|done
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * if we have not already tried the name "as is", do that now. 	 * note that we do this regardless of how many dots were in the 	 * name or whether it ends with a dot. 	 */
if|if
condition|(
operator|!
name|tried_as_is
operator|&&
operator|(
name|dots
operator|||
operator|!
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_NOTLDQUERY
operator|)
operator|)
condition|)
block|{
name|ret
operator|=
name|res_querydomainN
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|target
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* 	 * if we got here, we didn't satisfy the search. 	 * if we did an initial full query, return that query's h_errno 	 * (note that we wouldn't be here if that query had succeeded). 	 * else if we ever got a nodata, send that back as the reason. 	 * else send back meaningless h_errno, that being the one from 	 * the last DNSRCH we did. 	 */
if|if
condition|(
name|saved_herrno
operator|!=
operator|-
literal|1
condition|)
name|h_errno
operator|=
name|saved_herrno
expr_stmt|;
elseif|else
if|if
condition|(
name|got_nodata
condition|)
name|h_errno
operator|=
name|NO_DATA
expr_stmt|;
elseif|else
if|if
condition|(
name|got_servfail
condition|)
name|h_errno
operator|=
name|TRY_AGAIN
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform a call on res_query on the concatenation of name and domain,  * removing a trailing dot from name if domain is NULL.  */
end_comment

begin_function
specifier|static
name|int
name|res_querydomainN
parameter_list|(
name|name
parameter_list|,
name|domain
parameter_list|,
name|target
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|domain
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|res_target
modifier|*
name|target
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|nbuf
index|[
name|MAXDNAME
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|longname
init|=
name|nbuf
decl_stmt|;
name|size_t
name|n
decl_stmt|,
name|d
decl_stmt|;
if|if
condition|(
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_INIT
operator|)
operator|==
literal|0
operator|&&
name|res_init
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
name|h_errno
operator|=
name|NETDB_INTERNAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|_res
operator|.
name|options
operator|&
name|RES_DEBUG
condition|)
name|printf
argument_list|(
literal|";; res_querydomain(%s, %s)\n"
argument_list|,
name|name
argument_list|,
name|domain
condition|?
name|domain
else|:
literal|"<Nil>"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|domain
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Check for trailing '.'; 		 * copy without '.' if present. 		 */
name|n
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|MAXDNAME
condition|)
block|{
name|h_errno
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|>
literal|0
operator|&&
name|name
index|[
operator|--
name|n
index|]
operator|==
literal|'.'
condition|)
block|{
name|strncpy
argument_list|(
name|nbuf
argument_list|,
name|name
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|nbuf
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|longname
operator|=
name|name
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|d
operator|=
name|strlen
argument_list|(
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|+
name|d
operator|+
literal|1
operator|>=
name|MAXDNAME
condition|)
block|{
name|h_errno
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|sprintf
argument_list|(
name|nbuf
argument_list|,
literal|"%s.%s"
argument_list|,
name|name
argument_list|,
name|domain
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|res_queryN
argument_list|(
name|longname
argument_list|,
name|target
argument_list|)
operator|)
return|;
block|}
end_block

end_unit

