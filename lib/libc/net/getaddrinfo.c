begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$KAME: getaddrinfo.c,v 1.15 2000/07/09 04:37:24 itojun Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the project nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * "#ifdef FAITH" part is local hack for supporting IPv4-v6 translator.  *  * Issues to be discussed:  * - Return values.  There are nonstandard return values defined and used  *   in the source code.  This is because RFC2553 is silent about which error  *   code must be returned for which situation.  * - freeaddrinfo(NULL).  RFC2553 is silent about it.  XNET 5.2 says it is  *   invalid.  current code - SEGV on freeaddrinfo(NULL)  *  * Note:  * - The code filters out AFs that are not supported by the kernel,  *   when globbing NULL hostname (to loopback, or wildcard).  Is it the right  *   thing to do?  What is the relationship with post-RFC2553 AI_ADDRCONFIG  *   in ai_flags?  * - (post-2553) semantics of AI_ADDRCONFIG itself is too vague.  *   (1) what should we do against numeric hostname (2) what should we do  *   against NULL hostname (3) what is AI_ADDRCONFIG itself.  AF not ready?  *   non-loopback address configured?  global address configured?  *  * OS specific notes for freebsd4:  * - FreeBSD supported $GAI.  The code does not.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"namespace.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<net/if_types.h>
end_include

begin_include
include|#
directive|include
file|<ifaddrs.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_var.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/nd6.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpc.h>
end_include

begin_include
include|#
directive|include
file|<rpcsvc/yp_prot.h>
end_include

begin_include
include|#
directive|include
file|<rpcsvc/ypclnt.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"res_config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<nsswitch.h>
end_include

begin_include
include|#
directive|include
file|"un-namespace.h"
end_include

begin_include
include|#
directive|include
file|"libc_private.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NS_CACHING
end_ifdef

begin_include
include|#
directive|include
file|"nscache.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__KAME__
argument_list|)
operator|&&
name|defined
argument_list|(
name|INET6
argument_list|)
end_if

begin_define
define|#
directive|define
name|FAITH
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ANY
value|0
end_define

begin_define
define|#
directive|define
name|YES
value|1
end_define

begin_define
define|#
directive|define
name|NO
value|0
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
name|in_addrany
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|in_loopback
index|[]
init|=
block|{
literal|127
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|in6_addrany
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|in6_loopback
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|policyqueue
block|{
name|TAILQ_ENTRY
argument_list|(
argument|policyqueue
argument_list|)
name|pc_entry
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|in6_addrpolicy
name|pc_policy
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|policyhead
argument_list|,
name|policyqueue
argument_list|)
expr_stmt|;
end_expr_stmt

begin_struct
specifier|static
specifier|const
struct|struct
name|afd
block|{
name|int
name|a_af
decl_stmt|;
name|int
name|a_addrlen
decl_stmt|;
name|socklen_t
name|a_socklen
decl_stmt|;
name|int
name|a_off
decl_stmt|;
specifier|const
name|char
modifier|*
name|a_addrany
decl_stmt|;
specifier|const
name|char
modifier|*
name|a_loopback
decl_stmt|;
name|int
name|a_scoped
decl_stmt|;
block|}
name|afdl
index|[]
init|=
block|{
ifdef|#
directive|ifdef
name|INET6
define|#
directive|define
name|N_INET6
value|0
block|{
name|PF_INET6
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|,
name|sin6_addr
argument_list|)
block|,
name|in6_addrany
block|,
name|in6_loopback
block|,
literal|1
block|}
block|,
define|#
directive|define
name|N_INET
value|1
else|#
directive|else
define|#
directive|define
name|N_INET
value|0
endif|#
directive|endif
block|{
name|PF_INET
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
block|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
block|,
name|offsetof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|,
name|sin_addr
argument_list|)
block|,
name|in_addrany
block|,
name|in_loopback
block|,
literal|0
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|}
block|, }
struct|;
end_struct

begin_struct
struct|struct
name|explore
block|{
name|int
name|e_af
decl_stmt|;
name|int
name|e_socktype
decl_stmt|;
name|int
name|e_protocol
decl_stmt|;
name|int
name|e_wild
decl_stmt|;
define|#
directive|define
name|WILD_AF
parameter_list|(
name|ex
parameter_list|)
value|((ex)->e_wild& 0x01)
define|#
directive|define
name|WILD_SOCKTYPE
parameter_list|(
name|ex
parameter_list|)
value|((ex)->e_wild& 0x02)
define|#
directive|define
name|WILD_PROTOCOL
parameter_list|(
name|ex
parameter_list|)
value|((ex)->e_wild& 0x04)
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|explore
name|explore
index|[]
init|=
block|{
if|#
directive|if
literal|0
block|{ PF_LOCAL, ANY, ANY, 0x01 },
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INET6
block|{
name|PF_INET6
block|,
name|SOCK_DGRAM
block|,
name|IPPROTO_UDP
block|,
literal|0x07
block|}
block|,
block|{
name|PF_INET6
block|,
name|SOCK_STREAM
block|,
name|IPPROTO_TCP
block|,
literal|0x07
block|}
block|,
block|{
name|PF_INET6
block|,
name|SOCK_STREAM
block|,
name|IPPROTO_SCTP
block|,
literal|0x03
block|}
block|,
block|{
name|PF_INET6
block|,
name|SOCK_SEQPACKET
block|,
name|IPPROTO_SCTP
block|,
literal|0x07
block|}
block|,
block|{
name|PF_INET6
block|,
name|SOCK_DGRAM
block|,
name|IPPROTO_UDPLITE
block|,
literal|0x03
block|}
block|,
block|{
name|PF_INET6
block|,
name|SOCK_RAW
block|,
name|ANY
block|,
literal|0x05
block|}
block|,
endif|#
directive|endif
block|{
name|PF_INET
block|,
name|SOCK_DGRAM
block|,
name|IPPROTO_UDP
block|,
literal|0x07
block|}
block|,
block|{
name|PF_INET
block|,
name|SOCK_STREAM
block|,
name|IPPROTO_TCP
block|,
literal|0x07
block|}
block|,
block|{
name|PF_INET
block|,
name|SOCK_STREAM
block|,
name|IPPROTO_SCTP
block|,
literal|0x03
block|}
block|,
block|{
name|PF_INET
block|,
name|SOCK_SEQPACKET
block|,
name|IPPROTO_SCTP
block|,
literal|0x07
block|}
block|,
block|{
name|PF_INET
block|,
name|SOCK_DGRAM
block|,
name|IPPROTO_UDPLITE
block|,
literal|0x03
block|}
block|,
block|{
name|PF_INET
block|,
name|SOCK_RAW
block|,
name|ANY
block|,
literal|0x05
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_define
define|#
directive|define
name|PTON_MAX
value|16
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PTON_MAX
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|AIO_SRCFLAG_DEPRECATED
value|0x1
end_define

begin_struct
struct|struct
name|ai_order
block|{
union|union
block|{
name|struct
name|sockaddr_storage
name|aiou_ss
decl_stmt|;
name|struct
name|sockaddr
name|aiou_sa
decl_stmt|;
block|}
name|aio_src_un
union|;
define|#
directive|define
name|aio_srcsa
value|aio_src_un.aiou_sa
name|u_int32_t
name|aio_srcflag
decl_stmt|;
name|int
name|aio_srcscope
decl_stmt|;
name|int
name|aio_dstscope
decl_stmt|;
name|struct
name|policyqueue
modifier|*
name|aio_srcpolicy
decl_stmt|;
name|struct
name|policyqueue
modifier|*
name|aio_dstpolicy
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|aio_ai
decl_stmt|;
name|int
name|aio_matchlen
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|ns_src
name|default_dns_files
index|[]
init|=
block|{
block|{
name|NSSRC_FILES
block|,
name|NS_SUCCESS
block|}
block|,
block|{
name|NSSRC_DNS
block|,
name|NS_SUCCESS
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|res_target
block|{
name|struct
name|res_target
modifier|*
name|next
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* domain name */
name|int
name|qclass
decl_stmt|,
name|qtype
decl_stmt|;
comment|/* class and type of query */
name|u_char
modifier|*
name|answer
decl_stmt|;
comment|/* buffer to put answer */
name|int
name|anslen
decl_stmt|;
comment|/* size of answer buffer */
name|int
name|n
decl_stmt|;
comment|/* result length */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MAXPACKET
value|(64*1024)
end_define

begin_typedef
typedef|typedef
union|union
block|{
name|HEADER
name|hdr
decl_stmt|;
name|u_char
name|buf
index|[
name|MAXPACKET
index|]
decl_stmt|;
block|}
name|querybuf
typedef|;
end_typedef

begin_function_decl
specifier|static
name|int
name|str2number
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|explore_copy
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
parameter_list|,
specifier|const
name|struct
name|addrinfo
modifier|*
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|explore_null
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|explore_numeric
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|explore_numeric_scope
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_canonname
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
parameter_list|,
name|struct
name|addrinfo
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|addrinfo
modifier|*
name|get_ai
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
parameter_list|,
specifier|const
name|struct
name|afd
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|addrinfo
modifier|*
name|copy_ai
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_portmatch
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_port
parameter_list|(
name|struct
name|addrinfo
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|struct
name|afd
modifier|*
name|find_afd
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|addrconfig
parameter_list|(
name|struct
name|addrinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function_decl
specifier|static
name|int
name|is_ifdisabled
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|set_source
parameter_list|(
name|struct
name|ai_order
modifier|*
parameter_list|,
name|struct
name|policyhead
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|comp_dst
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function_decl
specifier|static
name|int
name|ip6_str2scopeid
parameter_list|(
name|char
modifier|*
parameter_list|,
name|struct
name|sockaddr_in6
modifier|*
parameter_list|,
name|u_int32_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|gai_addr2scopetype
parameter_list|(
name|struct
name|sockaddr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|explore_fqdn
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|reorder
parameter_list|(
name|struct
name|addrinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_addrselectpolicy
parameter_list|(
name|struct
name|policyhead
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_addrselectpolicy
parameter_list|(
name|struct
name|policyhead
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|policyqueue
modifier|*
name|match_addrselectpolicy
parameter_list|(
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|struct
name|policyhead
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matchlen
parameter_list|(
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|addrinfo
modifier|*
name|getanswer
parameter_list|(
specifier|const
name|querybuf
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|struct
name|addrinfo
modifier|*
parameter_list|,
name|res_state
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|defined
argument_list|(
name|RESOLVSORT
argument_list|)
end_if

begin_function_decl
specifier|static
name|int
name|addr4sort
parameter_list|(
name|struct
name|addrinfo
modifier|*
parameter_list|,
name|res_state
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|_dns_getaddrinfo
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|va_list
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_sethtent
parameter_list|(
name|FILE
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_endhtent
parameter_list|(
name|FILE
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|addrinfo
modifier|*
name|_gethtent
parameter_list|(
name|FILE
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|struct
name|addrinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_files_getaddrinfo
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|va_list
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|YP
end_ifdef

begin_function_decl
specifier|static
name|struct
name|addrinfo
modifier|*
name|_yphostent
parameter_list|(
name|char
modifier|*
parameter_list|,
specifier|const
name|struct
name|addrinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_yp_getaddrinfo
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|va_list
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NS_CACHING
end_ifdef

begin_function_decl
specifier|static
name|int
name|addrinfo_id_func
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|va_list
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|addrinfo_marshal_func
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|va_list
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|addrinfo_unmarshal_func
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|va_list
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|res_queryN
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|res_target
modifier|*
parameter_list|,
name|res_state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|res_searchN
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|res_target
modifier|*
parameter_list|,
name|res_state
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|res_querydomainN
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|res_target
modifier|*
parameter_list|,
name|res_state
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* XXX macros that make external reference is BAD. */
end_comment

begin_define
define|#
directive|define
name|GET_AI
parameter_list|(
name|ai
parameter_list|,
name|afd
parameter_list|,
name|addr
parameter_list|)
define|\
value|do { \
comment|/* external reference: pai, error, and label free */
value|\ 	(ai) = get_ai(pai, (afd), (addr)); \ 	if ((ai) == NULL) { \ 		error = EAI_MEMORY; \ 		goto free; \ 	} \ } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_define
define|#
directive|define
name|GET_PORT
parameter_list|(
name|ai
parameter_list|,
name|serv
parameter_list|)
define|\
value|do { \
comment|/* external reference: error and label free */
value|\ 	error = get_port((ai), (serv), 0); \ 	if (error != 0) \ 		goto free; \ } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_define
define|#
directive|define
name|GET_CANONNAME
parameter_list|(
name|ai
parameter_list|,
name|str
parameter_list|)
define|\
value|do { \
comment|/* external reference: pai, error and label free */
value|\ 	error = get_canonname(pai, (ai), (str)); \ 	if (error != 0) \ 		goto free; \ } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_define
define|#
directive|define
name|ERR
parameter_list|(
name|err
parameter_list|)
define|\
value|do { \
comment|/* external reference: error, and label bad */
value|\ 	error = (err); \ 	goto bad; \
comment|/*NOTREACHED*/
value|\ } while (
comment|/*CONSTCOND*/
value|0)
end_define

begin_define
define|#
directive|define
name|MATCH_FAMILY
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|w
parameter_list|)
define|\
value|((x) == (y) || (
comment|/*CONSTCOND*/
value|(w)&& ((x) == PF_UNSPEC || (y) == PF_UNSPEC)))
end_define

begin_define
define|#
directive|define
name|MATCH
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|,
name|w
parameter_list|)
define|\
value|((x) == (y) || (
comment|/*CONSTCOND*/
value|(w)&& ((x) == ANY || (y) == ANY)))
end_define

begin_function
name|void
name|freeaddrinfo
parameter_list|(
name|struct
name|addrinfo
modifier|*
name|ai
parameter_list|)
block|{
name|struct
name|addrinfo
modifier|*
name|next
decl_stmt|;
do|do
block|{
name|next
operator|=
name|ai
operator|->
name|ai_next
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|ai_canonname
condition|)
name|free
argument_list|(
name|ai
operator|->
name|ai_canonname
argument_list|)
expr_stmt|;
comment|/* no need to free(ai->ai_addr) */
name|free
argument_list|(
name|ai
argument_list|)
expr_stmt|;
name|ai
operator|=
name|next
expr_stmt|;
block|}
do|while
condition|(
name|ai
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|int
name|str2number
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|int
modifier|*
name|portp
parameter_list|)
block|{
name|char
modifier|*
name|ep
decl_stmt|;
name|unsigned
name|long
name|v
decl_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
return|return
operator|-
literal|1
return|;
name|ep
operator|=
name|NULL
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|v
operator|=
name|strtoul
argument_list|(
name|p
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
literal|0
operator|&&
name|ep
operator|&&
operator|*
name|ep
operator|==
literal|'\0'
operator|&&
name|v
operator|<=
name|UINT_MAX
condition|)
block|{
operator|*
name|portp
operator|=
name|v
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|int
name|getaddrinfo
parameter_list|(
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
specifier|const
name|char
modifier|*
name|servname
parameter_list|,
specifier|const
name|struct
name|addrinfo
modifier|*
name|hints
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|addrinfo
name|sentinel
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|cur
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|struct
name|addrinfo
name|ai
decl_stmt|,
name|ai0
decl_stmt|,
modifier|*
name|afai
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
specifier|const
name|struct
name|afd
modifier|*
name|afd
decl_stmt|;
specifier|const
name|struct
name|explore
modifier|*
name|ex
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|afailist
index|[
sizeof|sizeof
argument_list|(
name|afdl
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|afdl
index|[
literal|0
index|]
argument_list|)
index|]
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|afai_unspec
decl_stmt|;
name|int
name|found
decl_stmt|;
name|int
name|numeric
init|=
literal|0
decl_stmt|;
comment|/* ensure we return NULL on errors */
operator|*
name|res
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ai
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ai
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|afailist
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|afailist
argument_list|)
argument_list|)
expr_stmt|;
name|afai_unspec
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sentinel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sentinel
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
operator|&
name|sentinel
expr_stmt|;
name|pai
operator|=
operator|&
name|ai
expr_stmt|;
name|pai
operator|->
name|ai_flags
operator|=
literal|0
expr_stmt|;
name|pai
operator|->
name|ai_family
operator|=
name|PF_UNSPEC
expr_stmt|;
name|pai
operator|->
name|ai_socktype
operator|=
name|ANY
expr_stmt|;
name|pai
operator|->
name|ai_protocol
operator|=
name|ANY
expr_stmt|;
name|pai
operator|->
name|ai_addrlen
operator|=
literal|0
expr_stmt|;
name|pai
operator|->
name|ai_canonname
operator|=
name|NULL
expr_stmt|;
name|pai
operator|->
name|ai_addr
operator|=
name|NULL
expr_stmt|;
name|pai
operator|->
name|ai_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|hostname
operator|==
name|NULL
operator|&&
name|servname
operator|==
name|NULL
condition|)
return|return
name|EAI_NONAME
return|;
if|if
condition|(
name|hints
condition|)
block|{
comment|/* error check for hints */
if|if
condition|(
name|hints
operator|->
name|ai_addrlen
operator|||
name|hints
operator|->
name|ai_canonname
operator|||
name|hints
operator|->
name|ai_addr
operator|||
name|hints
operator|->
name|ai_next
condition|)
name|ERR
argument_list|(
name|EAI_BADHINTS
argument_list|)
expr_stmt|;
comment|/* xxx */
if|if
condition|(
name|hints
operator|->
name|ai_flags
operator|&
operator|~
name|AI_MASK
condition|)
name|ERR
argument_list|(
name|EAI_BADFLAGS
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hints
operator|->
name|ai_family
condition|)
block|{
case|case
name|PF_UNSPEC
case|:
case|case
name|PF_INET
case|:
ifdef|#
directive|ifdef
name|INET6
case|case
name|PF_INET6
case|:
endif|#
directive|endif
break|break;
default|default:
name|ERR
argument_list|(
name|EAI_FAMILY
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|pai
argument_list|,
name|hints
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pai
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * if both socktype/protocol are specified, check if they 		 * are meaningful combination. 		 */
if|if
condition|(
name|pai
operator|->
name|ai_socktype
operator|!=
name|ANY
operator|&&
name|pai
operator|->
name|ai_protocol
operator|!=
name|ANY
condition|)
block|{
for|for
control|(
name|ex
operator|=
name|explore
init|;
name|ex
operator|->
name|e_af
operator|>=
literal|0
condition|;
name|ex
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|MATCH_FAMILY
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|,
name|ex
operator|->
name|e_af
argument_list|,
name|WILD_AF
argument_list|(
name|ex
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|pai
operator|->
name|ai_socktype
argument_list|,
name|ex
operator|->
name|e_socktype
argument_list|,
name|WILD_SOCKTYPE
argument_list|(
name|ex
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|pai
operator|->
name|ai_protocol
argument_list|,
name|ex
operator|->
name|e_protocol
argument_list|,
name|WILD_PROTOCOL
argument_list|(
name|ex
argument_list|)
argument_list|)
condition|)
continue|continue;
comment|/* matched */
break|break;
block|}
if|if
condition|(
name|ex
operator|->
name|e_af
operator|<
literal|0
condition|)
name|ERR
argument_list|(
name|EAI_BADHINTS
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * check for special cases.  (1) numeric servname is disallowed if 	 * socktype/protocol are left unspecified. (2) servname is disallowed 	 * for raw and other inet{,6} sockets. 	 */
if|if
condition|(
name|MATCH_FAMILY
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|,
name|PF_INET
argument_list|,
literal|1
argument_list|)
ifdef|#
directive|ifdef
name|PF_INET6
operator|||
name|MATCH_FAMILY
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|,
name|PF_INET6
argument_list|,
literal|1
argument_list|)
endif|#
directive|endif
condition|)
block|{
name|ai0
operator|=
operator|*
name|pai
expr_stmt|;
comment|/* backup *pai */
if|if
condition|(
name|pai
operator|->
name|ai_family
operator|==
name|PF_UNSPEC
condition|)
block|{
ifdef|#
directive|ifdef
name|PF_INET6
name|pai
operator|->
name|ai_family
operator|=
name|PF_INET6
expr_stmt|;
else|#
directive|else
name|pai
operator|->
name|ai_family
operator|=
name|PF_INET
expr_stmt|;
endif|#
directive|endif
block|}
name|error
operator|=
name|get_portmatch
argument_list|(
name|pai
argument_list|,
name|servname
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|bad
goto|;
operator|*
name|pai
operator|=
name|ai0
expr_stmt|;
block|}
name|ai0
operator|=
operator|*
name|pai
expr_stmt|;
comment|/* 	 * NULL hostname, or numeric hostname. 	 * If numeric representation of AF1 can be interpreted as FQDN 	 * representation of AF2, we need to think again about the code below. 	 */
name|found
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|afd
operator|=
name|afdl
init|;
name|afd
operator|->
name|a_af
condition|;
name|afd
operator|++
control|)
block|{
operator|*
name|pai
operator|=
name|ai0
expr_stmt|;
if|if
condition|(
operator|!
name|MATCH_FAMILY
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|,
name|afd
operator|->
name|a_af
argument_list|,
literal|1
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|pai
operator|->
name|ai_family
operator|==
name|PF_UNSPEC
condition|)
name|pai
operator|->
name|ai_family
operator|=
name|afd
operator|->
name|a_af
expr_stmt|;
if|if
condition|(
name|hostname
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|explore_null
argument_list|(
name|pai
argument_list|,
name|servname
argument_list|,
operator|&
name|afailist
index|[
name|afd
operator|-
name|afdl
index|]
argument_list|)
expr_stmt|;
comment|/* 			 * Errors from explore_null should be unexpected and 			 * be caught to avoid returning an incomplete result. 			 */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
block|}
else|else
block|{
name|error
operator|=
name|explore_numeric_scope
argument_list|(
name|pai
argument_list|,
name|hostname
argument_list|,
name|servname
argument_list|,
operator|&
name|afailist
index|[
name|afd
operator|-
name|afdl
index|]
argument_list|)
expr_stmt|;
comment|/* 			 * explore_numeric_scope returns an error for address 			 * families that do not match that of hostname. 			 * Thus we should not catch the error at this moment.  			 */
block|}
if|if
condition|(
operator|!
name|error
operator|&&
name|afailist
index|[
name|afd
operator|-
name|afdl
index|]
condition|)
name|found
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|found
condition|)
block|{
name|numeric
operator|=
literal|1
expr_stmt|;
goto|goto
name|globcopy
goto|;
block|}
if|if
condition|(
name|hostname
operator|==
name|NULL
condition|)
name|ERR
argument_list|(
name|EAI_NONAME
argument_list|)
expr_stmt|;
comment|/* used to be EAI_NODATA */
if|if
condition|(
name|pai
operator|->
name|ai_flags
operator|&
name|AI_NUMERICHOST
condition|)
name|ERR
argument_list|(
name|EAI_NONAME
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pai
operator|->
name|ai_flags
operator|&
name|AI_ADDRCONFIG
operator|)
operator|!=
literal|0
operator|&&
operator|!
name|addrconfig
argument_list|(
operator|&
name|ai0
argument_list|)
condition|)
name|ERR
argument_list|(
name|EAI_FAIL
argument_list|)
expr_stmt|;
comment|/* 	 * hostname as alphabetical name. 	 */
operator|*
name|pai
operator|=
name|ai0
expr_stmt|;
name|error
operator|=
name|explore_fqdn
argument_list|(
name|pai
argument_list|,
name|hostname
argument_list|,
name|servname
argument_list|,
operator|&
name|afai_unspec
argument_list|)
expr_stmt|;
name|globcopy
label|:
for|for
control|(
name|ex
operator|=
name|explore
init|;
name|ex
operator|->
name|e_af
operator|>=
literal|0
condition|;
name|ex
operator|++
control|)
block|{
operator|*
name|pai
operator|=
name|ai0
expr_stmt|;
if|if
condition|(
operator|!
name|MATCH_FAMILY
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|,
name|ex
operator|->
name|e_af
argument_list|,
name|WILD_AF
argument_list|(
name|ex
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|pai
operator|->
name|ai_socktype
argument_list|,
name|ex
operator|->
name|e_socktype
argument_list|,
name|WILD_SOCKTYPE
argument_list|(
name|ex
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|MATCH
argument_list|(
name|pai
operator|->
name|ai_protocol
argument_list|,
name|ex
operator|->
name|e_protocol
argument_list|,
name|WILD_PROTOCOL
argument_list|(
name|ex
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|pai
operator|->
name|ai_family
operator|==
name|PF_UNSPEC
condition|)
name|pai
operator|->
name|ai_family
operator|=
name|ex
operator|->
name|e_af
expr_stmt|;
if|if
condition|(
name|pai
operator|->
name|ai_socktype
operator|==
name|ANY
operator|&&
name|ex
operator|->
name|e_socktype
operator|!=
name|ANY
condition|)
name|pai
operator|->
name|ai_socktype
operator|=
name|ex
operator|->
name|e_socktype
expr_stmt|;
if|if
condition|(
name|pai
operator|->
name|ai_protocol
operator|==
name|ANY
operator|&&
name|ex
operator|->
name|e_protocol
operator|!=
name|ANY
condition|)
name|pai
operator|->
name|ai_protocol
operator|=
name|ex
operator|->
name|e_protocol
expr_stmt|;
comment|/* 		 * if the servname does not match socktype/protocol, ignore it. 		 */
if|if
condition|(
name|get_portmatch
argument_list|(
name|pai
argument_list|,
name|servname
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|afai_unspec
condition|)
name|afai
operator|=
name|afai_unspec
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|afd
operator|=
name|find_afd
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
comment|/* XXX assumes that afd points inside afdl[] */
name|afai
operator|=
name|afailist
index|[
name|afd
operator|-
name|afdl
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|afai
condition|)
continue|continue;
name|error
operator|=
name|explore_copy
argument_list|(
name|pai
argument_list|,
name|afai
argument_list|,
operator|&
name|cur
operator|->
name|ai_next
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|bad
goto|;
while|while
condition|(
name|cur
operator|&&
name|cur
operator|->
name|ai_next
condition|)
name|cur
operator|=
name|cur
operator|->
name|ai_next
expr_stmt|;
block|}
comment|/* 	 * ensure we return either: 	 * - error == 0, non-NULL *res 	 * - error != 0, NULL *res 	 */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sentinel
operator|.
name|ai_next
condition|)
block|{
comment|/* 			 * If the returned entry is for an active connection, 			 * and the given name is not numeric, reorder the 			 * list, so that the application would try the list 			 * in the most efficient order.  Since the head entry 			 * of the original list may contain ai_canonname and 			 * that entry may be moved elsewhere in the new list, 			 * we keep the pointer and will  restore it in the new 			 * head entry.  (Note that RFC3493 requires the head 			 * entry store it when requested by the caller). 			 */
if|if
condition|(
name|hints
operator|==
name|NULL
operator|||
operator|!
operator|(
name|hints
operator|->
name|ai_flags
operator|&
name|AI_PASSIVE
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|numeric
condition|)
block|{
name|char
modifier|*
name|canonname
decl_stmt|;
name|canonname
operator|=
name|sentinel
operator|.
name|ai_next
operator|->
name|ai_canonname
expr_stmt|;
name|sentinel
operator|.
name|ai_next
operator|->
name|ai_canonname
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|reorder
argument_list|(
operator|&
name|sentinel
argument_list|)
expr_stmt|;
if|if
condition|(
name|sentinel
operator|.
name|ai_next
operator|->
name|ai_canonname
operator|==
name|NULL
condition|)
block|{
name|sentinel
operator|.
name|ai_next
operator|->
name|ai_canonname
operator|=
name|canonname
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|canonname
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|canonname
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|res
operator|=
name|sentinel
operator|.
name|ai_next
expr_stmt|;
block|}
else|else
name|error
operator|=
name|EAI_FAIL
expr_stmt|;
block|}
name|bad
label|:
if|if
condition|(
name|afai_unspec
condition|)
name|freeaddrinfo
argument_list|(
name|afai_unspec
argument_list|)
expr_stmt|;
for|for
control|(
name|afd
operator|=
name|afdl
init|;
name|afd
operator|->
name|a_af
condition|;
name|afd
operator|++
control|)
block|{
if|if
condition|(
name|afailist
index|[
name|afd
operator|-
name|afdl
index|]
condition|)
name|freeaddrinfo
argument_list|(
name|afailist
index|[
name|afd
operator|-
name|afdl
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|res
condition|)
if|if
condition|(
name|sentinel
operator|.
name|ai_next
condition|)
name|freeaddrinfo
argument_list|(
name|sentinel
operator|.
name|ai_next
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|reorder
parameter_list|(
name|struct
name|addrinfo
modifier|*
name|sentinel
parameter_list|)
block|{
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|,
modifier|*
modifier|*
name|aip
decl_stmt|;
name|struct
name|ai_order
modifier|*
name|aio
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|struct
name|policyhead
name|policyhead
decl_stmt|;
comment|/* count the number of addrinfo elements for sorting. */
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|ai
operator|=
name|sentinel
operator|->
name|ai_next
init|;
name|ai
operator|!=
name|NULL
condition|;
name|ai
operator|=
name|ai
operator|->
name|ai_next
operator|,
name|n
operator|++
control|)
empty_stmt|;
comment|/* 	 * If the number is small enough, we can skip the reordering process. 	 */
if|if
condition|(
name|n
operator|<=
literal|1
condition|)
return|return
operator|(
name|n
operator|)
return|;
comment|/* allocate a temporary array for sort and initialization of it. */
if|if
condition|(
operator|(
name|aio
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|aio
argument_list|)
operator|*
name|n
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|n
operator|)
return|;
comment|/* give up reordering */
name|memset
argument_list|(
name|aio
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|aio
argument_list|)
operator|*
name|n
argument_list|)
expr_stmt|;
comment|/* retrieve address selection policy from the kernel */
name|TAILQ_INIT
argument_list|(
operator|&
name|policyhead
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_addrselectpolicy
argument_list|(
operator|&
name|policyhead
argument_list|)
condition|)
block|{
comment|/* no policy is installed into kernel, we don't sort. */
name|free
argument_list|(
name|aio
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|ai
operator|=
name|sentinel
operator|->
name|ai_next
init|;
name|i
operator|<
name|n
condition|;
name|ai
operator|=
name|ai
operator|->
name|ai_next
operator|,
name|i
operator|++
control|)
block|{
name|aio
index|[
name|i
index|]
operator|.
name|aio_ai
operator|=
name|ai
expr_stmt|;
name|aio
index|[
name|i
index|]
operator|.
name|aio_dstscope
operator|=
name|gai_addr2scopetype
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|)
expr_stmt|;
name|aio
index|[
name|i
index|]
operator|.
name|aio_dstpolicy
operator|=
name|match_addrselectpolicy
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|,
operator|&
name|policyhead
argument_list|)
expr_stmt|;
name|set_source
argument_list|(
operator|&
name|aio
index|[
name|i
index|]
argument_list|,
operator|&
name|policyhead
argument_list|)
expr_stmt|;
block|}
comment|/* perform sorting. */
name|qsort
argument_list|(
name|aio
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|aio
argument_list|)
argument_list|,
name|comp_dst
argument_list|)
expr_stmt|;
comment|/* reorder the addrinfo chain. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|aip
operator|=
operator|&
name|sentinel
operator|->
name|ai_next
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|aip
operator|=
name|aio
index|[
name|i
index|]
operator|.
name|aio_ai
expr_stmt|;
name|aip
operator|=
operator|&
name|aio
index|[
name|i
index|]
operator|.
name|aio_ai
operator|->
name|ai_next
expr_stmt|;
block|}
operator|*
name|aip
operator|=
name|NULL
expr_stmt|;
comment|/* cleanup and return */
name|free
argument_list|(
name|aio
argument_list|)
expr_stmt|;
name|free_addrselectpolicy
argument_list|(
operator|&
name|policyhead
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_addrselectpolicy
parameter_list|(
name|struct
name|policyhead
modifier|*
name|head
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INET6
name|int
name|mib
index|[]
init|=
block|{
name|CTL_NET
block|,
name|PF_INET6
block|,
name|IPPROTO_IPV6
block|,
name|IPV6CTL_ADDRCTLPOLICY
block|}
decl_stmt|;
name|size_t
name|l
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|struct
name|in6_addrpolicy
modifier|*
name|pol
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
sizeof|sizeof
argument_list|(
name|mib
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mib
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|l
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
name|l
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
sizeof|sizeof
argument_list|(
name|mib
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mib
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|buf
argument_list|,
operator|&
name|l
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ep
operator|=
operator|(
expr|struct
name|in6_addrpolicy
operator|*
operator|)
operator|(
name|buf
operator|+
name|l
operator|)
expr_stmt|;
for|for
control|(
name|pol
operator|=
operator|(
expr|struct
name|in6_addrpolicy
operator|*
operator|)
name|buf
init|;
name|pol
operator|+
literal|1
operator|<=
name|ep
condition|;
name|pol
operator|++
control|)
block|{
name|struct
name|policyqueue
modifier|*
name|new
decl_stmt|;
if|if
condition|(
operator|(
name|new
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free_addrselectpolicy
argument_list|(
name|head
argument_list|)
expr_stmt|;
comment|/* make the list empty */
break|break;
block|}
name|new
operator|->
name|pc_policy
operator|=
operator|*
name|pol
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|head
argument_list|,
name|new
argument_list|,
name|pc_entry
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|free_addrselectpolicy
parameter_list|(
name|struct
name|policyhead
modifier|*
name|head
parameter_list|)
block|{
name|struct
name|policyqueue
modifier|*
name|ent
decl_stmt|,
modifier|*
name|nent
decl_stmt|;
for|for
control|(
name|ent
operator|=
name|TAILQ_FIRST
argument_list|(
name|head
argument_list|)
init|;
name|ent
condition|;
name|ent
operator|=
name|nent
control|)
block|{
name|nent
operator|=
name|TAILQ_NEXT
argument_list|(
name|ent
argument_list|,
name|pc_entry
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|head
argument_list|,
name|ent
argument_list|,
name|pc_entry
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ent
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|policyqueue
modifier|*
name|match_addrselectpolicy
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|addr
parameter_list|,
name|struct
name|policyhead
modifier|*
name|head
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INET6
name|struct
name|policyqueue
modifier|*
name|ent
decl_stmt|,
modifier|*
name|bestent
init|=
name|NULL
decl_stmt|;
name|struct
name|in6_addrpolicy
modifier|*
name|pol
decl_stmt|;
name|int
name|matchlen
decl_stmt|,
name|bestmatchlen
init|=
operator|-
literal|1
decl_stmt|;
name|u_char
modifier|*
name|mp
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|k
decl_stmt|,
modifier|*
name|p
decl_stmt|,
name|m
decl_stmt|;
name|struct
name|sockaddr_in6
name|key
decl_stmt|;
switch|switch
condition|(
name|addr
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET6
case|:
name|key
operator|=
operator|*
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
expr_stmt|;
break|break;
case|case
name|AF_INET
case|:
comment|/* convert the address into IPv4-mapped IPv6 address. */
name|memset
argument_list|(
operator|&
name|key
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|key
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|key
operator|.
name|sin6_addr
operator|.
name|s6_addr
index|[
literal|10
index|]
operator|=
literal|0xff
expr_stmt|;
name|key
operator|.
name|sin6_addr
operator|.
name|s6_addr
index|[
literal|11
index|]
operator|=
literal|0xff
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|key
operator|.
name|sin6_addr
operator|.
name|s6_addr
index|[
literal|12
index|]
argument_list|,
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin_addr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
for|for
control|(
name|ent
operator|=
name|TAILQ_FIRST
argument_list|(
name|head
argument_list|)
init|;
name|ent
condition|;
name|ent
operator|=
name|TAILQ_NEXT
argument_list|(
name|ent
argument_list|,
name|pc_entry
argument_list|)
control|)
block|{
name|pol
operator|=
operator|&
name|ent
operator|->
name|pc_policy
expr_stmt|;
name|matchlen
operator|=
literal|0
expr_stmt|;
name|mp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|pol
operator|->
name|addrmask
operator|.
name|sin6_addr
expr_stmt|;
name|ep
operator|=
name|mp
operator|+
literal|16
expr_stmt|;
comment|/* XXX: scope field? */
name|k
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|key
operator|.
name|sin6_addr
expr_stmt|;
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|pol
operator|->
name|addr
operator|.
name|sin6_addr
expr_stmt|;
for|for
control|(
init|;
name|mp
operator|<
name|ep
operator|&&
operator|*
name|mp
condition|;
name|mp
operator|++
operator|,
name|k
operator|++
operator|,
name|p
operator|++
control|)
block|{
name|m
operator|=
operator|*
name|mp
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|k
operator|&
name|m
operator|)
operator|!=
operator|*
name|p
condition|)
goto|goto
name|next
goto|;
comment|/* not match */
if|if
condition|(
name|m
operator|==
literal|0xff
condition|)
comment|/* short cut for a typical case */
name|matchlen
operator|+=
literal|8
expr_stmt|;
else|else
block|{
while|while
condition|(
name|m
operator|>=
literal|0x80
condition|)
block|{
name|matchlen
operator|++
expr_stmt|;
name|m
operator|<<=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* matched.  check if this is better than the current best. */
if|if
condition|(
name|matchlen
operator|>
name|bestmatchlen
condition|)
block|{
name|bestent
operator|=
name|ent
expr_stmt|;
name|bestmatchlen
operator|=
name|matchlen
expr_stmt|;
block|}
name|next
label|:
continue|continue;
block|}
return|return
operator|(
name|bestent
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|NULL
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|set_source
parameter_list|(
name|struct
name|ai_order
modifier|*
name|aio
parameter_list|,
name|struct
name|policyhead
modifier|*
name|ph
parameter_list|)
block|{
name|struct
name|addrinfo
name|ai
init|=
operator|*
name|aio
operator|->
name|aio_ai
decl_stmt|;
name|struct
name|sockaddr_storage
name|ss
decl_stmt|;
name|socklen_t
name|srclen
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* set unspec ("no source is available"), just in case */
name|aio
operator|->
name|aio_srcsa
operator|.
name|sa_family
operator|=
name|AF_UNSPEC
expr_stmt|;
name|aio
operator|->
name|aio_srcscope
operator|=
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|ai
operator|.
name|ai_family
condition|)
block|{
case|case
name|AF_INET
case|:
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
endif|#
directive|endif
break|break;
default|default:
comment|/* ignore unsupported AFs explicitly */
return|return;
block|}
comment|/* XXX: make a dummy addrinfo to call connect() */
name|ai
operator|.
name|ai_socktype
operator|=
name|SOCK_DGRAM
expr_stmt|;
name|ai
operator|.
name|ai_protocol
operator|=
name|IPPROTO_UDP
expr_stmt|;
comment|/* is UDP too specific? */
name|ai
operator|.
name|ai_next
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ss
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ss
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ss
argument_list|,
name|ai
operator|.
name|ai_addr
argument_list|,
name|ai
operator|.
name|ai_addrlen
argument_list|)
expr_stmt|;
name|ai
operator|.
name|ai_addr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
expr_stmt|;
name|get_port
argument_list|(
operator|&
name|ai
argument_list|,
literal|"1"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* open a socket to get the source address for the given dst */
if|if
condition|(
operator|(
name|s
operator|=
name|_socket
argument_list|(
name|ai
operator|.
name|ai_family
argument_list|,
name|ai
operator|.
name|ai_socktype
operator||
name|SOCK_CLOEXEC
argument_list|,
name|ai
operator|.
name|ai_protocol
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
comment|/* give up */
if|if
condition|(
name|_connect
argument_list|(
name|s
argument_list|,
name|ai
operator|.
name|ai_addr
argument_list|,
name|ai
operator|.
name|ai_addrlen
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|cleanup
goto|;
name|srclen
operator|=
name|ai
operator|.
name|ai_addrlen
expr_stmt|;
if|if
condition|(
name|_getsockname
argument_list|(
name|s
argument_list|,
operator|&
name|aio
operator|->
name|aio_srcsa
argument_list|,
operator|&
name|srclen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|aio
operator|->
name|aio_srcsa
operator|.
name|sa_family
operator|=
name|AF_UNSPEC
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|aio
operator|->
name|aio_srcscope
operator|=
name|gai_addr2scopetype
argument_list|(
operator|&
name|aio
operator|->
name|aio_srcsa
argument_list|)
expr_stmt|;
name|aio
operator|->
name|aio_srcpolicy
operator|=
name|match_addrselectpolicy
argument_list|(
operator|&
name|aio
operator|->
name|aio_srcsa
argument_list|,
name|ph
argument_list|)
expr_stmt|;
name|aio
operator|->
name|aio_matchlen
operator|=
name|matchlen
argument_list|(
operator|&
name|aio
operator|->
name|aio_srcsa
argument_list|,
name|aio
operator|->
name|aio_ai
operator|->
name|ai_addr
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|ai
operator|.
name|ai_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|in6_ifreq
name|ifr6
decl_stmt|;
name|u_int32_t
name|flags6
decl_stmt|;
name|memset
argument_list|(
operator|&
name|ifr6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr6
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ifr6
operator|.
name|ifr_addr
argument_list|,
name|ai
operator|.
name|ai_addr
argument_list|,
name|ai
operator|.
name|ai_addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|_ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFAFLAG_IN6
argument_list|,
operator|&
name|ifr6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|flags6
operator|=
name|ifr6
operator|.
name|ifr_ifru
operator|.
name|ifru_flags6
expr_stmt|;
if|if
condition|(
operator|(
name|flags6
operator|&
name|IN6_IFF_DEPRECATED
operator|)
condition|)
name|aio
operator|->
name|aio_srcflag
operator||=
name|AIO_SRCFLAG_DEPRECATED
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|cleanup
label|:
name|_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|matchlen
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|src
parameter_list|,
name|struct
name|sockaddr
modifier|*
name|dst
parameter_list|)
block|{
name|int
name|match
init|=
literal|0
decl_stmt|;
name|u_char
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|u_char
modifier|*
name|lim
decl_stmt|,
name|r
decl_stmt|;
name|int
name|addrlen
decl_stmt|;
switch|switch
condition|(
name|src
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|s
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|src
operator|)
operator|->
name|sin6_addr
expr_stmt|;
name|d
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|dst
operator|)
operator|->
name|sin6_addr
expr_stmt|;
name|addrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
expr_stmt|;
name|lim
operator|=
name|s
operator|+
name|addrlen
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|AF_INET
case|:
name|s
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|src
operator|)
operator|->
name|sin_addr
expr_stmt|;
name|d
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|dst
operator|)
operator|->
name|sin_addr
expr_stmt|;
name|addrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
name|lim
operator|=
name|s
operator|+
name|addrlen
expr_stmt|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
while|while
condition|(
name|s
operator|<
name|lim
condition|)
if|if
condition|(
operator|(
name|r
operator|=
operator|(
operator|*
name|d
operator|++
operator|^
operator|*
name|s
operator|++
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
name|r
operator|<
name|addrlen
operator|*
literal|8
condition|)
block|{
name|match
operator|++
expr_stmt|;
name|r
operator|<<=
literal|1
expr_stmt|;
block|}
break|break;
block|}
else|else
name|match
operator|+=
literal|8
expr_stmt|;
return|return
operator|(
name|match
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|comp_dst
parameter_list|(
specifier|const
name|void
modifier|*
name|arg1
parameter_list|,
specifier|const
name|void
modifier|*
name|arg2
parameter_list|)
block|{
specifier|const
name|struct
name|ai_order
modifier|*
name|dst1
init|=
name|arg1
decl_stmt|,
modifier|*
name|dst2
init|=
name|arg2
decl_stmt|;
comment|/* 	 * Rule 1: Avoid unusable destinations. 	 * XXX: we currently do not consider if an appropriate route exists. 	 */
if|if
condition|(
name|dst1
operator|->
name|aio_srcsa
operator|.
name|sa_family
operator|!=
name|AF_UNSPEC
operator|&&
name|dst2
operator|->
name|aio_srcsa
operator|.
name|sa_family
operator|==
name|AF_UNSPEC
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dst1
operator|->
name|aio_srcsa
operator|.
name|sa_family
operator|==
name|AF_UNSPEC
operator|&&
name|dst2
operator|->
name|aio_srcsa
operator|.
name|sa_family
operator|!=
name|AF_UNSPEC
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Rule 2: Prefer matching scope. */
if|if
condition|(
name|dst1
operator|->
name|aio_dstscope
operator|==
name|dst1
operator|->
name|aio_srcscope
operator|&&
name|dst2
operator|->
name|aio_dstscope
operator|!=
name|dst2
operator|->
name|aio_srcscope
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dst1
operator|->
name|aio_dstscope
operator|!=
name|dst1
operator|->
name|aio_srcscope
operator|&&
name|dst2
operator|->
name|aio_dstscope
operator|==
name|dst2
operator|->
name|aio_srcscope
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Rule 3: Avoid deprecated addresses. */
if|if
condition|(
name|dst1
operator|->
name|aio_srcsa
operator|.
name|sa_family
operator|!=
name|AF_UNSPEC
operator|&&
name|dst2
operator|->
name|aio_srcsa
operator|.
name|sa_family
operator|!=
name|AF_UNSPEC
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|dst1
operator|->
name|aio_srcflag
operator|&
name|AIO_SRCFLAG_DEPRECATED
operator|)
operator|&&
operator|(
name|dst2
operator|->
name|aio_srcflag
operator|&
name|AIO_SRCFLAG_DEPRECATED
operator|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|dst1
operator|->
name|aio_srcflag
operator|&
name|AIO_SRCFLAG_DEPRECATED
operator|)
operator|&&
operator|!
operator|(
name|dst2
operator|->
name|aio_srcflag
operator|&
name|AIO_SRCFLAG_DEPRECATED
operator|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* Rule 4: Prefer home addresses. */
comment|/* XXX: not implemented yet */
comment|/* Rule 5: Prefer matching label. */
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|dst1
operator|->
name|aio_srcpolicy
operator|&&
name|dst1
operator|->
name|aio_dstpolicy
operator|&&
name|dst1
operator|->
name|aio_srcpolicy
operator|->
name|pc_policy
operator|.
name|label
operator|==
name|dst1
operator|->
name|aio_dstpolicy
operator|->
name|pc_policy
operator|.
name|label
operator|&&
operator|(
name|dst2
operator|->
name|aio_srcpolicy
operator|==
name|NULL
operator|||
name|dst2
operator|->
name|aio_dstpolicy
operator|==
name|NULL
operator|||
name|dst2
operator|->
name|aio_srcpolicy
operator|->
name|pc_policy
operator|.
name|label
operator|!=
name|dst2
operator|->
name|aio_dstpolicy
operator|->
name|pc_policy
operator|.
name|label
operator|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dst2
operator|->
name|aio_srcpolicy
operator|&&
name|dst2
operator|->
name|aio_dstpolicy
operator|&&
name|dst2
operator|->
name|aio_srcpolicy
operator|->
name|pc_policy
operator|.
name|label
operator|==
name|dst2
operator|->
name|aio_dstpolicy
operator|->
name|pc_policy
operator|.
name|label
operator|&&
operator|(
name|dst1
operator|->
name|aio_srcpolicy
operator|==
name|NULL
operator|||
name|dst1
operator|->
name|aio_dstpolicy
operator|==
name|NULL
operator|||
name|dst1
operator|->
name|aio_srcpolicy
operator|->
name|pc_policy
operator|.
name|label
operator|!=
name|dst1
operator|->
name|aio_dstpolicy
operator|->
name|pc_policy
operator|.
name|label
operator|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* Rule 6: Prefer higher precedence. */
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|dst1
operator|->
name|aio_dstpolicy
operator|&&
operator|(
name|dst2
operator|->
name|aio_dstpolicy
operator|==
name|NULL
operator|||
name|dst1
operator|->
name|aio_dstpolicy
operator|->
name|pc_policy
operator|.
name|preced
operator|>
name|dst2
operator|->
name|aio_dstpolicy
operator|->
name|pc_policy
operator|.
name|preced
operator|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dst2
operator|->
name|aio_dstpolicy
operator|&&
operator|(
name|dst1
operator|->
name|aio_dstpolicy
operator|==
name|NULL
operator|||
name|dst2
operator|->
name|aio_dstpolicy
operator|->
name|pc_policy
operator|.
name|preced
operator|>
name|dst1
operator|->
name|aio_dstpolicy
operator|->
name|pc_policy
operator|.
name|preced
operator|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* Rule 7: Prefer native transport. */
comment|/* XXX: not implemented yet */
comment|/* Rule 8: Prefer smaller scope. */
if|if
condition|(
name|dst1
operator|->
name|aio_dstscope
operator|>=
literal|0
operator|&&
name|dst1
operator|->
name|aio_dstscope
operator|<
name|dst2
operator|->
name|aio_dstscope
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dst2
operator|->
name|aio_dstscope
operator|>=
literal|0
operator|&&
name|dst2
operator|->
name|aio_dstscope
operator|<
name|dst1
operator|->
name|aio_dstscope
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Rule 9: Use longest matching prefix. 	 * We compare the match length in a same AF only. 	 */
if|if
condition|(
name|dst1
operator|->
name|aio_ai
operator|->
name|ai_addr
operator|->
name|sa_family
operator|==
name|dst2
operator|->
name|aio_ai
operator|->
name|ai_addr
operator|->
name|sa_family
operator|&&
name|dst1
operator|->
name|aio_ai
operator|->
name|ai_addr
operator|->
name|sa_family
operator|!=
name|AF_INET
condition|)
block|{
if|if
condition|(
name|dst1
operator|->
name|aio_matchlen
operator|>
name|dst2
operator|->
name|aio_matchlen
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dst1
operator|->
name|aio_matchlen
operator|<
name|dst2
operator|->
name|aio_matchlen
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* Rule 10: Otherwise, leave the order unchanged. */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy from scope.c.  * XXX: we should standardize the functions and link them as standard  * library.  */
end_comment

begin_function
specifier|static
name|int
name|gai_addr2scopetype
parameter_list|(
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in6
modifier|*
name|sa6
decl_stmt|;
endif|#
directive|endif
name|struct
name|sockaddr_in
modifier|*
name|sa4
decl_stmt|;
switch|switch
condition|(
name|sa
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|sa6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|sa6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* just use the scope field of the multicast address */
return|return
operator|(
name|sa6
operator|->
name|sin6_addr
operator|.
name|s6_addr
index|[
literal|2
index|]
operator|&
literal|0x0f
operator|)
return|;
block|}
comment|/* 		 * Unicast addresses: map scope type to corresponding scope 		 * value defined for multcast addresses. 		 * XXX: hardcoded scope type values are bad... 		 */
if|if
condition|(
name|IN6_IS_ADDR_LOOPBACK
argument_list|(
operator|&
name|sa6
operator|->
name|sin6_addr
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* node local scope */
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|sa6
operator|->
name|sin6_addr
argument_list|)
condition|)
return|return
operator|(
literal|2
operator|)
return|;
comment|/* link-local scope */
if|if
condition|(
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
operator|&
name|sa6
operator|->
name|sin6_addr
argument_list|)
condition|)
return|return
operator|(
literal|5
operator|)
return|;
comment|/* site-local scope */
return|return
operator|(
literal|14
operator|)
return|;
comment|/* global scope */
break|break;
endif|#
directive|endif
case|case
name|AF_INET
case|:
comment|/* 		 * IPv4 pseudo scoping according to RFC 3484. 		 */
name|sa4
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
expr_stmt|;
comment|/* IPv4 autoconfiguration addresses have link-local scope. */
if|if
condition|(
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|sa4
operator|->
name|sin_addr
operator|)
index|[
literal|0
index|]
operator|==
literal|169
operator|&&
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|sa4
operator|->
name|sin_addr
operator|)
index|[
literal|1
index|]
operator|==
literal|254
condition|)
return|return
operator|(
literal|2
operator|)
return|;
comment|/* Private addresses have site-local scope. */
if|if
condition|(
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|sa4
operator|->
name|sin_addr
operator|)
index|[
literal|0
index|]
operator|==
literal|10
operator|||
operator|(
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|sa4
operator|->
name|sin_addr
operator|)
index|[
literal|0
index|]
operator|==
literal|172
operator|&&
operator|(
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|sa4
operator|->
name|sin_addr
operator|)
index|[
literal|1
index|]
operator|&
literal|0xf0
operator|)
operator|==
literal|16
operator|)
operator|||
operator|(
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|sa4
operator|->
name|sin_addr
operator|)
index|[
literal|0
index|]
operator|==
literal|192
operator|&&
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|sa4
operator|->
name|sin_addr
operator|)
index|[
literal|1
index|]
operator|==
literal|168
operator|)
condition|)
return|return
operator|(
literal|14
operator|)
return|;
comment|/* XXX: It should be 5 unless NAT */
comment|/* Loopback addresses have link-local scope. */
if|if
condition|(
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|sa4
operator|->
name|sin_addr
operator|)
index|[
literal|0
index|]
operator|==
literal|127
condition|)
return|return
operator|(
literal|2
operator|)
return|;
return|return
operator|(
literal|14
operator|)
return|;
break|break;
default|default:
name|errno
operator|=
name|EAFNOSUPPORT
expr_stmt|;
comment|/* is this a good error? */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|explore_copy
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
parameter_list|,
specifier|const
name|struct
name|addrinfo
modifier|*
name|src0
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
name|res
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|addrinfo
name|sentinel
decl_stmt|,
modifier|*
name|cur
decl_stmt|;
specifier|const
name|struct
name|addrinfo
modifier|*
name|src
decl_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
name|sentinel
operator|.
name|ai_next
operator|=
name|NULL
expr_stmt|;
name|cur
operator|=
operator|&
name|sentinel
expr_stmt|;
for|for
control|(
name|src
operator|=
name|src0
init|;
name|src
operator|!=
name|NULL
condition|;
name|src
operator|=
name|src
operator|->
name|ai_next
control|)
block|{
if|if
condition|(
name|src
operator|->
name|ai_family
operator|!=
name|pai
operator|->
name|ai_family
condition|)
continue|continue;
name|cur
operator|->
name|ai_next
operator|=
name|copy_ai
argument_list|(
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cur
operator|->
name|ai_next
condition|)
block|{
name|error
operator|=
name|EAI_MEMORY
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
name|cur
operator|->
name|ai_next
operator|->
name|ai_socktype
operator|=
name|pai
operator|->
name|ai_socktype
expr_stmt|;
name|cur
operator|->
name|ai_next
operator|->
name|ai_protocol
operator|=
name|pai
operator|->
name|ai_protocol
expr_stmt|;
name|cur
operator|=
name|cur
operator|->
name|ai_next
expr_stmt|;
block|}
operator|*
name|res
operator|=
name|sentinel
operator|.
name|ai_next
expr_stmt|;
return|return
literal|0
return|;
name|fail
label|:
name|freeaddrinfo
argument_list|(
name|sentinel
operator|.
name|ai_next
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * hostname == NULL.  * passive socket -> anyaddr (0.0.0.0 or ::)  * non-passive socket -> localhost (127.0.0.1 or ::1)  */
end_comment

begin_function
specifier|static
name|int
name|explore_null
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
parameter_list|,
specifier|const
name|char
modifier|*
name|servname
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
name|res
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
specifier|const
name|struct
name|afd
modifier|*
name|afd
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|*
name|res
operator|=
name|NULL
expr_stmt|;
name|ai
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * filter out AFs that are not supported by the kernel 	 * XXX errno? 	 */
name|s
operator|=
name|_socket
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|,
name|SOCK_DGRAM
operator||
name|SOCK_CLOEXEC
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EMFILE
condition|)
return|return
literal|0
return|;
block|}
else|else
name|_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|afd
operator|=
name|find_afd
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|)
expr_stmt|;
if|if
condition|(
name|afd
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|pai
operator|->
name|ai_flags
operator|&
name|AI_PASSIVE
condition|)
block|{
name|GET_AI
argument_list|(
name|ai
argument_list|,
name|afd
argument_list|,
name|afd
operator|->
name|a_addrany
argument_list|)
expr_stmt|;
name|GET_PORT
argument_list|(
name|ai
argument_list|,
name|servname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|GET_AI
argument_list|(
name|ai
argument_list|,
name|afd
argument_list|,
name|afd
operator|->
name|a_loopback
argument_list|)
expr_stmt|;
name|GET_PORT
argument_list|(
name|ai
argument_list|,
name|servname
argument_list|)
expr_stmt|;
block|}
operator|*
name|res
operator|=
name|ai
expr_stmt|;
return|return
literal|0
return|;
name|free
label|:
if|if
condition|(
name|ai
operator|!=
name|NULL
condition|)
name|freeaddrinfo
argument_list|(
name|ai
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * numeric hostname  */
end_comment

begin_function
specifier|static
name|int
name|explore_numeric
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
parameter_list|,
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
specifier|const
name|char
modifier|*
name|servname
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
name|res
parameter_list|,
specifier|const
name|char
modifier|*
name|canonname
parameter_list|)
block|{
specifier|const
name|struct
name|afd
modifier|*
name|afd
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
name|pton
index|[
name|PTON_MAX
index|]
decl_stmt|;
operator|*
name|res
operator|=
name|NULL
expr_stmt|;
name|ai
operator|=
name|NULL
expr_stmt|;
name|afd
operator|=
name|find_afd
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|)
expr_stmt|;
if|if
condition|(
name|afd
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|afd
operator|->
name|a_af
condition|)
block|{
case|case
name|AF_INET
case|:
comment|/* 		 * RFC3493 requires getaddrinfo() to accept AF_INET formats 		 * that are accepted by inet_addr() and its family.  The 		 * accepted forms includes the "classful" one, which inet_pton 		 * does not accept.  So we need to separate the case for 		 * AF_INET. 		 */
if|if
condition|(
name|inet_aton
argument_list|(
name|hostname
argument_list|,
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|pton
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
break|break;
default|default:
if|if
condition|(
name|inet_pton
argument_list|(
name|afd
operator|->
name|a_af
argument_list|,
name|hostname
argument_list|,
name|pton
argument_list|)
operator|!=
literal|1
condition|)
return|return
literal|0
return|;
break|break;
block|}
if|if
condition|(
name|pai
operator|->
name|ai_family
operator|==
name|afd
operator|->
name|a_af
condition|)
block|{
name|GET_AI
argument_list|(
name|ai
argument_list|,
name|afd
argument_list|,
name|pton
argument_list|)
expr_stmt|;
name|GET_PORT
argument_list|(
name|ai
argument_list|,
name|servname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pai
operator|->
name|ai_flags
operator|&
name|AI_CANONNAME
operator|)
condition|)
block|{
comment|/* 			 * Set the numeric address itself as the canonical 			 * name, based on a clarification in RFC3493. 			 */
name|GET_CANONNAME
argument_list|(
name|ai
argument_list|,
name|canonname
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * XXX: This should not happen since we already matched the AF 		 * by find_afd. 		 */
name|ERR
argument_list|(
name|EAI_FAMILY
argument_list|)
expr_stmt|;
block|}
operator|*
name|res
operator|=
name|ai
expr_stmt|;
return|return
literal|0
return|;
name|free
label|:
name|bad
label|:
if|if
condition|(
name|ai
operator|!=
name|NULL
condition|)
name|freeaddrinfo
argument_list|(
name|ai
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * numeric hostname with scope  */
end_comment

begin_function
specifier|static
name|int
name|explore_numeric_scope
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
parameter_list|,
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
specifier|const
name|char
modifier|*
name|servname
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
name|res
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SCOPE_DELIMITER
argument_list|)
operator|||
operator|!
name|defined
argument_list|(
name|INET6
argument_list|)
return|return
name|explore_numeric
argument_list|(
name|pai
argument_list|,
name|hostname
argument_list|,
name|servname
argument_list|,
name|res
argument_list|,
name|hostname
argument_list|)
return|;
else|#
directive|else
specifier|const
name|struct
name|afd
modifier|*
name|afd
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|cur
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|hostname2
init|=
name|NULL
decl_stmt|,
modifier|*
name|scope
decl_stmt|,
modifier|*
name|addr
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|afd
operator|=
name|find_afd
argument_list|(
name|pai
operator|->
name|ai_family
argument_list|)
expr_stmt|;
if|if
condition|(
name|afd
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|!
name|afd
operator|->
name|a_scoped
condition|)
return|return
name|explore_numeric
argument_list|(
name|pai
argument_list|,
name|hostname
argument_list|,
name|servname
argument_list|,
name|res
argument_list|,
name|hostname
argument_list|)
return|;
name|cp
operator|=
name|strchr
argument_list|(
name|hostname
argument_list|,
name|SCOPE_DELIMITER
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
name|explore_numeric
argument_list|(
name|pai
argument_list|,
name|hostname
argument_list|,
name|servname
argument_list|,
name|res
argument_list|,
name|hostname
argument_list|)
return|;
comment|/* 	 * Handle special case of<scoped_address><delimiter><scope id> 	 */
name|hostname2
operator|=
name|strdup
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostname2
operator|==
name|NULL
condition|)
return|return
name|EAI_MEMORY
return|;
comment|/* terminate at the delimiter */
name|hostname2
index|[
name|cp
operator|-
name|hostname
index|]
operator|=
literal|'\0'
expr_stmt|;
name|addr
operator|=
name|hostname2
expr_stmt|;
name|scope
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
name|error
operator|=
name|explore_numeric
argument_list|(
name|pai
argument_list|,
name|addr
argument_list|,
name|servname
argument_list|,
name|res
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|u_int32_t
name|scopeid
decl_stmt|;
for|for
control|(
name|cur
operator|=
operator|*
name|res
init|;
name|cur
condition|;
name|cur
operator|=
name|cur
operator|->
name|ai_next
control|)
block|{
if|if
condition|(
name|cur
operator|->
name|ai_family
operator|!=
name|AF_INET6
condition|)
continue|continue;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|cur
operator|->
name|ai_addr
expr_stmt|;
if|if
condition|(
name|ip6_str2scopeid
argument_list|(
name|scope
argument_list|,
name|sin6
argument_list|,
operator|&
name|scopeid
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|free
argument_list|(
name|hostname2
argument_list|)
expr_stmt|;
name|freeaddrinfo
argument_list|(
operator|*
name|res
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|EAI_NONAME
operator|)
return|;
comment|/* XXX: is return OK? */
block|}
name|sin6
operator|->
name|sin6_scope_id
operator|=
name|scopeid
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|hostname2
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
operator|*
name|res
condition|)
block|{
name|freeaddrinfo
argument_list|(
operator|*
name|res
argument_list|)
expr_stmt|;
operator|*
name|res
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|error
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|int
name|get_canonname
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
parameter_list|,
name|struct
name|addrinfo
modifier|*
name|ai
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
if|if
condition|(
operator|(
name|pai
operator|->
name|ai_flags
operator|&
name|AI_CANONNAME
operator|)
operator|!=
literal|0
condition|)
block|{
name|ai
operator|->
name|ai_canonname
operator|=
name|strdup
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|->
name|ai_canonname
operator|==
name|NULL
condition|)
return|return
name|EAI_MEMORY
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|addrinfo
modifier|*
name|get_ai
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
parameter_list|,
specifier|const
name|struct
name|afd
modifier|*
name|afd
parameter_list|,
specifier|const
name|char
modifier|*
name|addr
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
ifdef|#
directive|ifdef
name|FAITH
name|struct
name|in6_addr
name|faith_prefix
decl_stmt|;
name|char
modifier|*
name|fp_str
decl_stmt|;
name|int
name|translate
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|FAITH
comment|/* 	 * Transfrom an IPv4 addr into a special IPv6 addr format for 	 * IPv6->IPv4 translation gateway. (only TCP is supported now) 	 * 	 * +-----------------------------------+------------+ 	 * | faith prefix part (12 bytes)      | embedded   | 	 * |                                   | IPv4 addr part (4 bytes) 	 * +-----------------------------------+------------+ 	 * 	 * faith prefix part is specified as ascii IPv6 addr format 	 * in environmental variable GAI. 	 * For FAITH to work correctly, routing to faith prefix must be 	 * setup toward a machine where a FAITH daemon operates. 	 * Also, the machine must enable some mechanizm 	 * (e.g. faith interface hack) to divert those packet with 	 * faith prefixed destination addr to user-land FAITH daemon. 	 */
name|fp_str
operator|=
name|getenv
argument_list|(
literal|"GAI"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp_str
operator|&&
name|inet_pton
argument_list|(
name|AF_INET6
argument_list|,
name|fp_str
argument_list|,
operator|&
name|faith_prefix
argument_list|)
operator|==
literal|1
operator|&&
name|afd
operator|->
name|a_af
operator|==
name|AF_INET
operator|&&
name|pai
operator|->
name|ai_socktype
operator|==
name|SOCK_STREAM
condition|)
block|{
name|u_int32_t
name|v4a
decl_stmt|;
name|u_int8_t
name|v4a_top
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|v4a
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
name|v4a
argument_list|)
expr_stmt|;
name|v4a_top
operator|=
name|v4a
operator|>>
name|IN_CLASSA_NSHIFT
expr_stmt|;
if|if
condition|(
operator|!
name|IN_MULTICAST
argument_list|(
name|v4a
argument_list|)
operator|&&
operator|!
name|IN_EXPERIMENTAL
argument_list|(
name|v4a
argument_list|)
operator|&&
name|v4a_top
operator|!=
literal|0
operator|&&
name|v4a
operator|!=
name|IN_LOOPBACKNET
condition|)
block|{
name|afd
operator|=
operator|&
name|afdl
index|[
name|N_INET6
index|]
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|faith_prefix
operator|.
name|s6_addr
index|[
literal|12
index|]
argument_list|,
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
name|translate
operator|=
literal|1
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|ai
operator|=
operator|(
expr|struct
name|addrinfo
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|addrinfo
argument_list|)
operator|+
operator|(
name|afd
operator|->
name|a_socklen
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memcpy
argument_list|(
name|ai
argument_list|,
name|pai
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|addrinfo
argument_list|)
argument_list|)
expr_stmt|;
name|ai
operator|->
name|ai_addr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
name|ai
operator|+
literal|1
operator|)
expr_stmt|;
name|memset
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|,
literal|0
argument_list|,
operator|(
name|size_t
operator|)
name|afd
operator|->
name|a_socklen
argument_list|)
expr_stmt|;
name|ai
operator|->
name|ai_addr
operator|->
name|sa_len
operator|=
name|afd
operator|->
name|a_socklen
expr_stmt|;
name|ai
operator|->
name|ai_addrlen
operator|=
name|afd
operator|->
name|a_socklen
expr_stmt|;
name|ai
operator|->
name|ai_addr
operator|->
name|sa_family
operator|=
name|ai
operator|->
name|ai_family
operator|=
name|afd
operator|->
name|a_af
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
name|ai
operator|->
name|ai_addr
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FAITH
if|if
condition|(
name|translate
operator|==
literal|1
condition|)
name|memcpy
argument_list|(
name|p
operator|+
name|afd
operator|->
name|a_off
argument_list|,
operator|&
name|faith_prefix
argument_list|,
operator|(
name|size_t
operator|)
name|afd
operator|->
name|a_addrlen
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|memcpy
argument_list|(
name|p
operator|+
name|afd
operator|->
name|a_off
argument_list|,
name|addr
argument_list|,
operator|(
name|size_t
operator|)
name|afd
operator|->
name|a_addrlen
argument_list|)
expr_stmt|;
return|return
name|ai
return|;
block|}
end_function

begin_comment
comment|/* XXX need to malloc() the same way we do from other functions! */
end_comment

begin_function
specifier|static
name|struct
name|addrinfo
modifier|*
name|copy_ai
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
parameter_list|)
block|{
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
name|size_t
name|l
decl_stmt|;
name|l
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|ai
argument_list|)
operator|+
name|pai
operator|->
name|ai_addrlen
expr_stmt|;
if|if
condition|(
operator|(
name|ai
operator|=
operator|(
expr|struct
name|addrinfo
operator|*
operator|)
name|malloc
argument_list|(
name|l
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|memset
argument_list|(
name|ai
argument_list|,
literal|0
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ai
argument_list|,
name|pai
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ai
argument_list|)
argument_list|)
expr_stmt|;
name|ai
operator|->
name|ai_addr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
name|ai
operator|+
literal|1
operator|)
expr_stmt|;
name|memcpy
argument_list|(
name|ai
operator|->
name|ai_addr
argument_list|,
name|pai
operator|->
name|ai_addr
argument_list|,
name|pai
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|pai
operator|->
name|ai_canonname
condition|)
block|{
name|l
operator|=
name|strlen
argument_list|(
name|pai
operator|->
name|ai_canonname
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|ai
operator|->
name|ai_canonname
operator|=
name|malloc
argument_list|(
name|l
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ai
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|strlcpy
argument_list|(
name|ai
operator|->
name|ai_canonname
argument_list|,
name|pai
operator|->
name|ai_canonname
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* just to make sure */
name|ai
operator|->
name|ai_canonname
operator|=
name|NULL
expr_stmt|;
block|}
name|ai
operator|->
name|ai_next
operator|=
name|NULL
expr_stmt|;
return|return
name|ai
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_portmatch
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
name|ai
parameter_list|,
specifier|const
name|char
modifier|*
name|servname
parameter_list|)
block|{
comment|/* get_port does not touch first argument when matchonly == 1. */
comment|/* LINTED const cast */
return|return
name|get_port
argument_list|(
operator|(
expr|struct
name|addrinfo
operator|*
operator|)
name|ai
argument_list|,
name|servname
argument_list|,
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_port
parameter_list|(
name|struct
name|addrinfo
modifier|*
name|ai
parameter_list|,
specifier|const
name|char
modifier|*
name|servname
parameter_list|,
name|int
name|matchonly
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|proto
decl_stmt|;
name|struct
name|servent
modifier|*
name|sp
decl_stmt|;
name|int
name|port
decl_stmt|,
name|error
decl_stmt|;
name|int
name|allownumeric
decl_stmt|;
if|if
condition|(
name|servname
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|ai
operator|->
name|ai_family
condition|)
block|{
case|case
name|AF_INET
case|:
ifdef|#
directive|ifdef
name|AF_INET6
case|case
name|AF_INET6
case|:
endif|#
directive|endif
break|break;
default|default:
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|ai
operator|->
name|ai_socktype
condition|)
block|{
case|case
name|SOCK_RAW
case|:
return|return
name|EAI_SERVICE
return|;
case|case
name|SOCK_DGRAM
case|:
case|case
name|SOCK_STREAM
case|:
case|case
name|SOCK_SEQPACKET
case|:
name|allownumeric
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ANY
case|:
switch|switch
condition|(
name|ai
operator|->
name|ai_family
condition|)
block|{
case|case
name|AF_INET
case|:
ifdef|#
directive|ifdef
name|AF_INET6
case|case
name|AF_INET6
case|:
endif|#
directive|endif
name|allownumeric
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|allownumeric
operator|=
literal|0
expr_stmt|;
break|break;
block|}
break|break;
default|default:
return|return
name|EAI_SOCKTYPE
return|;
block|}
name|error
operator|=
name|str2number
argument_list|(
name|servname
argument_list|,
operator|&
name|port
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|allownumeric
condition|)
return|return
name|EAI_SERVICE
return|;
if|if
condition|(
name|port
operator|<
literal|0
operator|||
name|port
operator|>
literal|65535
condition|)
return|return
name|EAI_SERVICE
return|;
name|port
operator|=
name|htons
argument_list|(
name|port
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ai
operator|->
name|ai_flags
operator|&
name|AI_NUMERICSERV
condition|)
return|return
name|EAI_NONAME
return|;
switch|switch
condition|(
name|ai
operator|->
name|ai_protocol
condition|)
block|{
case|case
name|IPPROTO_UDP
case|:
name|proto
operator|=
literal|"udp"
expr_stmt|;
break|break;
case|case
name|IPPROTO_TCP
case|:
name|proto
operator|=
literal|"tcp"
expr_stmt|;
break|break;
case|case
name|IPPROTO_SCTP
case|:
name|proto
operator|=
literal|"sctp"
expr_stmt|;
break|break;
case|case
name|IPPROTO_UDPLITE
case|:
name|proto
operator|=
literal|"udplite"
expr_stmt|;
break|break;
default|default:
name|proto
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|sp
operator|=
name|getservbyname
argument_list|(
name|servname
argument_list|,
name|proto
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|EAI_SERVICE
return|;
name|port
operator|=
name|sp
operator|->
name|s_port
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|matchonly
condition|)
block|{
switch|switch
condition|(
name|ai
operator|->
name|ai_family
condition|)
block|{
case|case
name|AF_INET
case|:
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|ai
operator|->
name|ai_addr
operator|)
operator|->
name|sin_port
operator|=
name|port
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|ai
operator|->
name|ai_addr
operator|)
operator|->
name|sin6_port
operator|=
name|port
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|struct
name|afd
modifier|*
name|find_afd
parameter_list|(
name|int
name|af
parameter_list|)
block|{
specifier|const
name|struct
name|afd
modifier|*
name|afd
decl_stmt|;
if|if
condition|(
name|af
operator|==
name|PF_UNSPEC
condition|)
return|return
name|NULL
return|;
for|for
control|(
name|afd
operator|=
name|afdl
init|;
name|afd
operator|->
name|a_af
condition|;
name|afd
operator|++
control|)
block|{
if|if
condition|(
name|afd
operator|->
name|a_af
operator|==
name|af
condition|)
return|return
name|afd
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * RFC 3493: AI_ADDRCONFIG check.  Determines which address families are  * configured on the local system and correlates with pai->ai_family value.  * If an address family is not configured on the system, it will not be  * queried for.  For this purpose, loopback addresses are not considered  * configured addresses.  *  * XXX PF_UNSPEC -> PF_INET6 + PF_INET mapping needs to be in sync with  * _dns_getaddrinfo.  */
end_comment

begin_function
specifier|static
name|int
name|addrconfig
parameter_list|(
name|struct
name|addrinfo
modifier|*
name|pai
parameter_list|)
block|{
name|struct
name|ifaddrs
modifier|*
name|ifaddrs
decl_stmt|,
modifier|*
name|ifa
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
endif|#
directive|endif
name|int
name|seen_inet
init|=
literal|0
decl_stmt|,
name|seen_inet6
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|getifaddrs
argument_list|(
operator|&
name|ifaddrs
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|ifa
operator|=
name|ifaddrs
init|;
name|ifa
operator|!=
name|NULL
condition|;
name|ifa
operator|=
name|ifa
operator|->
name|ifa_next
control|)
block|{
if|if
condition|(
name|ifa
operator|->
name|ifa_addr
operator|==
name|NULL
operator|||
operator|(
name|ifa
operator|->
name|ifa_flags
operator|&
name|IFF_UP
operator|)
operator|==
literal|0
condition|)
continue|continue;
switch|switch
condition|(
name|ifa
operator|->
name|ifa_addr
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
name|seen_inet
condition|)
continue|continue;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|(
name|ifa
operator|->
name|ifa_addr
operator|)
expr_stmt|;
if|if
condition|(
name|IN_LOOPBACK
argument_list|(
name|htonl
argument_list|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
argument_list|)
condition|)
continue|continue;
name|seen_inet
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|seen_inet6
condition|)
continue|continue;
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|(
name|ifa
operator|->
name|ifa_addr
operator|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_LOOPBACK
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|ifa
operator|->
name|ifa_flags
operator|&
name|IFT_LOOP
operator|)
operator|!=
literal|0
operator|&&
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|is_ifdisabled
argument_list|(
name|ifa
operator|->
name|ifa_name
argument_list|)
condition|)
continue|continue;
name|seen_inet6
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
block|}
name|freeifaddrs
argument_list|(
name|ifaddrs
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pai
operator|->
name|ai_family
condition|)
block|{
case|case
name|AF_INET6
case|:
return|return
operator|(
name|seen_inet6
operator|)
return|;
case|case
name|AF_INET
case|:
return|return
operator|(
name|seen_inet
operator|)
return|;
case|case
name|AF_UNSPEC
case|:
if|if
condition|(
name|seen_inet
operator|==
name|seen_inet6
condition|)
return|return
operator|(
name|seen_inet
operator|)
return|;
name|pai
operator|->
name|ai_family
operator|=
name|seen_inet
condition|?
name|AF_INET
else|:
name|AF_INET6
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function
specifier|static
name|int
name|is_ifdisabled
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|in6_ndireq
name|nd
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|_socket
argument_list|(
name|AF_INET6
argument_list|,
name|SOCK_DGRAM
operator||
name|SOCK_CLOEXEC
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|memset
argument_list|(
operator|&
name|nd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|nd
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|nd
operator|.
name|ifname
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|nd
operator|.
name|ifname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|_ioctl
argument_list|(
name|fd
argument_list|,
name|SIOCGIFINFO_IN6
argument_list|,
operator|&
name|nd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|nd
operator|.
name|ndi
operator|.
name|flags
operator|&
name|ND6_IFF_IFDISABLED
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* convert a string to a scope identifier. XXX: IPv6 specific */
end_comment

begin_function
specifier|static
name|int
name|ip6_str2scopeid
parameter_list|(
name|char
modifier|*
name|scope
parameter_list|,
name|struct
name|sockaddr_in6
modifier|*
name|sin6
parameter_list|,
name|u_int32_t
modifier|*
name|scopeid
parameter_list|)
block|{
name|u_long
name|lscopeid
decl_stmt|;
name|struct
name|in6_addr
modifier|*
name|a6
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
name|a6
operator|=
operator|&
name|sin6
operator|->
name|sin6_addr
expr_stmt|;
comment|/* empty scopeid portion is invalid */
if|if
condition|(
operator|*
name|scope
operator|==
literal|'\0'
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
name|a6
argument_list|)
operator|||
name|IN6_IS_ADDR_MC_LINKLOCAL
argument_list|(
name|a6
argument_list|)
operator|||
name|IN6_IS_ADDR_MC_NODELOCAL
argument_list|(
name|a6
argument_list|)
condition|)
block|{
comment|/* 		 * We currently assume a one-to-one mapping between links 		 * and interfaces, so we simply use interface indices for 		 * like-local scopes. 		 */
operator|*
name|scopeid
operator|=
name|if_nametoindex
argument_list|(
name|scope
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|scopeid
operator|==
literal|0
condition|)
goto|goto
name|trynumeric
goto|;
return|return
literal|0
return|;
block|}
comment|/* still unclear about literal, allow numeric only - placeholder */
if|if
condition|(
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
name|a6
argument_list|)
operator|||
name|IN6_IS_ADDR_MC_SITELOCAL
argument_list|(
name|a6
argument_list|)
condition|)
goto|goto
name|trynumeric
goto|;
if|if
condition|(
name|IN6_IS_ADDR_MC_ORGLOCAL
argument_list|(
name|a6
argument_list|)
condition|)
goto|goto
name|trynumeric
goto|;
else|else
goto|goto
name|trynumeric
goto|;
comment|/* global */
comment|/* try to convert to a numeric id as a last resort */
name|trynumeric
label|:
name|errno
operator|=
literal|0
expr_stmt|;
name|lscopeid
operator|=
name|strtoul
argument_list|(
name|scope
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
operator|*
name|scopeid
operator|=
call|(
name|u_int32_t
call|)
argument_list|(
name|lscopeid
operator|&
literal|0xffffffffUL
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
literal|0
operator|&&
name|ep
operator|&&
operator|*
name|ep
operator|==
literal|'\0'
operator|&&
operator|*
name|scopeid
operator|==
name|lscopeid
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NS_CACHING
end_ifdef

begin_function
specifier|static
name|int
name|addrinfo_id_func
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|buffer_size
parameter_list|,
name|va_list
name|ap
parameter_list|,
name|void
modifier|*
name|cache_mdata
parameter_list|)
block|{
name|res_state
name|statp
decl_stmt|;
name|u_long
name|res_options
decl_stmt|;
specifier|const
name|int
name|op_id
init|=
literal|0
decl_stmt|;
comment|/* identifies the getaddrinfo for the cache */
name|char
modifier|*
name|hostname
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|hints
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|ai_flags
decl_stmt|,
name|ai_family
decl_stmt|,
name|ai_socktype
decl_stmt|,
name|ai_protocol
decl_stmt|;
name|size_t
name|desired_size
decl_stmt|,
name|size
decl_stmt|;
name|statp
operator|=
name|__res_state
argument_list|()
expr_stmt|;
name|res_options
operator|=
name|statp
operator|->
name|options
operator|&
operator|(
name|RES_RECURSE
operator||
name|RES_DEFNAMES
operator||
name|RES_DNSRCH
operator||
name|RES_NOALIASES
operator||
name|RES_USE_INET6
operator|)
expr_stmt|;
name|hostname
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|hints
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
expr|struct
name|addrinfo
operator|*
argument_list|)
expr_stmt|;
name|desired_size
operator|=
sizeof|sizeof
argument_list|(
name|res_options
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
literal|4
expr_stmt|;
if|if
condition|(
name|hostname
operator|!=
name|NULL
condition|)
block|{
name|size
operator|=
name|strlen
argument_list|(
name|hostname
argument_list|)
expr_stmt|;
name|desired_size
operator|+=
name|size
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|desired_size
operator|>
operator|*
name|buffer_size
condition|)
block|{
operator|*
name|buffer_size
operator|=
name|desired_size
expr_stmt|;
return|return
operator|(
name|NS_RETURN
operator|)
return|;
block|}
if|if
condition|(
name|hints
operator|==
name|NULL
condition|)
name|ai_flags
operator|=
name|ai_family
operator|=
name|ai_socktype
operator|=
name|ai_protocol
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|ai_flags
operator|=
name|hints
operator|->
name|ai_flags
expr_stmt|;
name|ai_family
operator|=
name|hints
operator|->
name|ai_family
expr_stmt|;
name|ai_socktype
operator|=
name|hints
operator|->
name|ai_socktype
expr_stmt|;
name|ai_protocol
operator|=
name|hints
operator|->
name|ai_protocol
expr_stmt|;
block|}
name|p
operator|=
name|buffer
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
operator|&
name|res_options
argument_list|,
sizeof|sizeof
argument_list|(
name|res_options
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|res_options
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
operator|&
name|op_id
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
operator|&
name|ai_flags
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
operator|&
name|ai_family
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
operator|&
name|ai_socktype
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
operator|&
name|ai_protocol
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|hostname
operator|!=
name|NULL
condition|)
name|memcpy
argument_list|(
name|p
argument_list|,
name|hostname
argument_list|,
name|size
argument_list|)
expr_stmt|;
operator|*
name|buffer_size
operator|=
name|desired_size
expr_stmt|;
return|return
operator|(
name|NS_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|addrinfo_marshal_func
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
modifier|*
name|buffer_size
parameter_list|,
name|void
modifier|*
name|retval
parameter_list|,
name|va_list
name|ap
parameter_list|,
name|void
modifier|*
name|cache_mdata
parameter_list|)
block|{
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|,
modifier|*
name|cai
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|desired_size
decl_stmt|,
name|size
decl_stmt|,
name|ai_size
decl_stmt|;
name|ai
operator|=
operator|*
operator|(
operator|(
expr|struct
name|addrinfo
operator|*
operator|*
operator|)
name|retval
operator|)
expr_stmt|;
name|desired_size
operator|=
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
expr_stmt|;
name|ai_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cai
operator|=
name|ai
init|;
name|cai
operator|!=
name|NULL
condition|;
name|cai
operator|=
name|cai
operator|->
name|ai_next
control|)
block|{
name|desired_size
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|addrinfo
argument_list|)
operator|+
name|cai
operator|->
name|ai_addrlen
expr_stmt|;
if|if
condition|(
name|cai
operator|->
name|ai_canonname
operator|!=
name|NULL
condition|)
name|desired_size
operator|+=
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|+
name|strlen
argument_list|(
name|cai
operator|->
name|ai_canonname
argument_list|)
expr_stmt|;
operator|++
name|ai_size
expr_stmt|;
block|}
if|if
condition|(
name|desired_size
operator|>
operator|*
name|buffer_size
condition|)
block|{
comment|/* this assignment is here for future use */
name|errno
operator|=
name|ERANGE
expr_stmt|;
operator|*
name|buffer_size
operator|=
name|desired_size
expr_stmt|;
return|return
operator|(
name|NS_RETURN
operator|)
return|;
block|}
name|memset
argument_list|(
name|buffer
argument_list|,
literal|0
argument_list|,
name|desired_size
argument_list|)
expr_stmt|;
name|p
operator|=
name|buffer
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
operator|&
name|ai_size
argument_list|,
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
expr_stmt|;
for|for
control|(
name|cai
operator|=
name|ai
init|;
name|cai
operator|!=
name|NULL
condition|;
name|cai
operator|=
name|cai
operator|->
name|ai_next
control|)
block|{
name|memcpy
argument_list|(
name|p
argument_list|,
name|cai
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|addrinfo
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|addrinfo
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|cai
operator|->
name|ai_addr
argument_list|,
name|cai
operator|->
name|ai_addrlen
argument_list|)
expr_stmt|;
name|p
operator|+=
name|cai
operator|->
name|ai_addrlen
expr_stmt|;
if|if
condition|(
name|cai
operator|->
name|ai_canonname
operator|!=
name|NULL
condition|)
block|{
name|size
operator|=
name|strlen
argument_list|(
name|cai
operator|->
name|ai_canonname
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
operator|&
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|p
argument_list|,
name|cai
operator|->
name|ai_canonname
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|p
operator|+=
name|size
expr_stmt|;
block|}
block|}
return|return
operator|(
name|NS_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|addrinfo_unmarshal_func
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|size_t
name|buffer_size
parameter_list|,
name|void
modifier|*
name|retval
parameter_list|,
name|va_list
name|ap
parameter_list|,
name|void
modifier|*
name|cache_mdata
parameter_list|)
block|{
name|struct
name|addrinfo
name|new_ai
decl_stmt|,
modifier|*
name|result
decl_stmt|,
modifier|*
name|sentinel
decl_stmt|,
modifier|*
name|lasts
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|ai_size
decl_stmt|,
name|ai_i
decl_stmt|,
name|size
decl_stmt|;
name|p
operator|=
name|buffer
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ai_size
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
expr_stmt|;
name|result
operator|=
name|NULL
expr_stmt|;
name|lasts
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|ai_i
operator|=
literal|0
init|;
name|ai_i
operator|<
name|ai_size
condition|;
operator|++
name|ai_i
control|)
block|{
name|memcpy
argument_list|(
operator|&
name|new_ai
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|addrinfo
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
expr|struct
name|addrinfo
argument_list|)
expr_stmt|;
name|size
operator|=
name|new_ai
operator|.
name|ai_addrlen
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|addrinfo
argument_list|)
operator|+
name|_ALIGNBYTES
expr_stmt|;
name|sentinel
operator|=
operator|(
expr|struct
name|addrinfo
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sentinel
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|sentinel
argument_list|,
operator|&
name|new_ai
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|addrinfo
argument_list|)
argument_list|)
expr_stmt|;
name|sentinel
operator|->
name|ai_addr
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|_ALIGN
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sentinel
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|addrinfo
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|sentinel
operator|->
name|ai_addr
argument_list|,
name|p
argument_list|,
name|new_ai
operator|.
name|ai_addrlen
argument_list|)
expr_stmt|;
name|p
operator|+=
name|new_ai
operator|.
name|ai_addrlen
expr_stmt|;
if|if
condition|(
name|new_ai
operator|.
name|ai_canonname
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|size
argument_list|,
name|p
argument_list|,
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|+=
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
expr_stmt|;
name|sentinel
operator|->
name|ai_canonname
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|sentinel
operator|->
name|ai_canonname
argument_list|,
literal|0
argument_list|,
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|sentinel
operator|->
name|ai_canonname
argument_list|,
name|p
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|p
operator|+=
name|size
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
name|sentinel
expr_stmt|;
name|lasts
operator|=
name|sentinel
expr_stmt|;
block|}
else|else
block|{
name|lasts
operator|->
name|ai_next
operator|=
name|sentinel
expr_stmt|;
name|lasts
operator|=
name|sentinel
expr_stmt|;
block|}
block|}
operator|*
operator|(
operator|(
expr|struct
name|addrinfo
operator|*
operator|*
operator|)
name|retval
operator|)
operator|=
name|result
expr_stmt|;
return|return
operator|(
name|NS_SUCCESS
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* NS_CACHING */
end_comment

begin_comment
comment|/*  * FQDN hostname, DNS lookup  */
end_comment

begin_function
specifier|static
name|int
name|explore_fqdn
parameter_list|(
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
parameter_list|,
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
specifier|const
name|char
modifier|*
name|servname
parameter_list|,
name|struct
name|addrinfo
modifier|*
modifier|*
name|res
parameter_list|)
block|{
name|struct
name|addrinfo
modifier|*
name|result
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|cur
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|NS_CACHING
specifier|static
specifier|const
name|nss_cache_info
name|cache_info
init|=
name|NS_COMMON_CACHE_INFO_INITIALIZER
argument_list|(
name|hosts
argument_list|,
name|NULL
argument_list|,
name|addrinfo_id_func
argument_list|,
name|addrinfo_marshal_func
argument_list|,
name|addrinfo_unmarshal_func
argument_list|)
decl_stmt|;
endif|#
directive|endif
specifier|static
specifier|const
name|ns_dtab
name|dtab
index|[]
init|=
block|{
name|NS_FILES_CB
argument_list|(
argument|_files_getaddrinfo
argument_list|,
argument|NULL
argument_list|)
block|{
name|NSSRC_DNS
block|,
name|_dns_getaddrinfo
block|,
name|NULL
block|}
block|,
comment|/* force -DHESIOD */
name|NS_NIS_CB
argument_list|(
argument|_yp_getaddrinfo
argument_list|,
argument|NULL
argument_list|)
ifdef|#
directive|ifdef
name|NS_CACHING
name|NS_CACHE_CB
argument_list|(
argument|&cache_info
argument_list|)
endif|#
directive|endif
block|{
literal|0
block|}
block|}
decl_stmt|;
name|result
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * if the servname does not match socktype/protocol, ignore it. 	 */
if|if
condition|(
name|get_portmatch
argument_list|(
name|pai
argument_list|,
name|servname
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
switch|switch
condition|(
name|_nsdispatch
argument_list|(
operator|&
name|result
argument_list|,
name|dtab
argument_list|,
name|NSDB_HOSTS
argument_list|,
literal|"getaddrinfo"
argument_list|,
name|default_dns_files
argument_list|,
name|hostname
argument_list|,
name|pai
argument_list|)
condition|)
block|{
case|case
name|NS_TRYAGAIN
case|:
name|error
operator|=
name|EAI_AGAIN
expr_stmt|;
goto|goto
name|free
goto|;
case|case
name|NS_UNAVAIL
case|:
name|error
operator|=
name|EAI_FAIL
expr_stmt|;
goto|goto
name|free
goto|;
case|case
name|NS_NOTFOUND
case|:
name|error
operator|=
name|EAI_NONAME
expr_stmt|;
goto|goto
name|free
goto|;
case|case
name|NS_SUCCESS
case|:
name|error
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cur
operator|=
name|result
init|;
name|cur
condition|;
name|cur
operator|=
name|cur
operator|->
name|ai_next
control|)
block|{
name|GET_PORT
argument_list|(
name|cur
argument_list|,
name|servname
argument_list|)
expr_stmt|;
comment|/* canonname should be filled already */
block|}
break|break;
block|}
operator|*
name|res
operator|=
name|result
expr_stmt|;
return|return
literal|0
return|;
name|free
label|:
if|if
condition|(
name|result
condition|)
name|freeaddrinfo
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|error
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|AskedForGot
index|[]
init|=
literal|"gethostby*.getanswer: asked for \"%s\", got \"%s\""
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|struct
name|addrinfo
modifier|*
name|getanswer
parameter_list|(
specifier|const
name|querybuf
modifier|*
name|answer
parameter_list|,
name|int
name|anslen
parameter_list|,
specifier|const
name|char
modifier|*
name|qname
parameter_list|,
name|int
name|qtype
parameter_list|,
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
parameter_list|,
name|res_state
name|res
parameter_list|)
block|{
name|struct
name|addrinfo
name|sentinel
decl_stmt|,
modifier|*
name|cur
decl_stmt|;
name|struct
name|addrinfo
name|ai
decl_stmt|;
specifier|const
name|struct
name|afd
modifier|*
name|afd
decl_stmt|;
name|char
modifier|*
name|canonname
decl_stmt|;
specifier|const
name|HEADER
modifier|*
name|hp
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|cp
decl_stmt|;
name|int
name|n
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|eom
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|int
name|type
decl_stmt|,
name|class
decl_stmt|,
name|ancount
decl_stmt|,
name|qdcount
decl_stmt|;
name|int
name|haveanswer
decl_stmt|,
name|had_error
decl_stmt|;
name|char
name|tbuf
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|int
function_decl|(
modifier|*
name|name_ok
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|char
name|hostbuf
index|[
literal|8
operator|*
literal|1024
index|]
decl_stmt|;
name|memset
argument_list|(
operator|&
name|sentinel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sentinel
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
operator|&
name|sentinel
expr_stmt|;
name|canonname
operator|=
name|NULL
expr_stmt|;
name|eom
operator|=
name|answer
operator|->
name|buf
operator|+
name|anslen
expr_stmt|;
switch|switch
condition|(
name|qtype
condition|)
block|{
case|case
name|T_A
case|:
case|case
name|T_AAAA
case|:
case|case
name|T_ANY
case|:
comment|/*use T_ANY only for T_A/T_AAAA lookup*/
name|name_ok
operator|=
name|res_hnok
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* XXX should be abort(); */
block|}
comment|/* 	 * find first satisfactory answer 	 */
name|hp
operator|=
operator|&
name|answer
operator|->
name|hdr
expr_stmt|;
name|ancount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|qdcount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|qdcount
argument_list|)
expr_stmt|;
name|bp
operator|=
name|hostbuf
expr_stmt|;
name|ep
operator|=
name|hostbuf
operator|+
sizeof|sizeof
name|hostbuf
expr_stmt|;
name|cp
operator|=
name|answer
operator|->
name|buf
operator|+
name|HFIXEDSZ
expr_stmt|;
if|if
condition|(
name|qdcount
operator|!=
literal|1
condition|)
block|{
name|RES_SET_H_ERRNO
argument_list|(
name|res
argument_list|,
name|NO_RECOVERY
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|n
operator|=
name|dn_expand
argument_list|(
name|answer
operator|->
name|buf
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
name|bp
argument_list|,
name|ep
operator|-
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|<
literal|0
operator|)
operator|||
operator|!
call|(
modifier|*
name|name_ok
call|)
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|RES_SET_H_ERRNO
argument_list|(
name|res
argument_list|,
name|NO_RECOVERY
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|cp
operator|+=
name|n
operator|+
name|QFIXEDSZ
expr_stmt|;
if|if
condition|(
name|qtype
operator|==
name|T_A
operator|||
name|qtype
operator|==
name|T_AAAA
operator|||
name|qtype
operator|==
name|T_ANY
condition|)
block|{
comment|/* res_send() has already verified that the query name is the 		 * same as the one we sent; this just gets the expanded name 		 * (i.e., with the succeeding search-domain tacked on). 		 */
name|n
operator|=
name|strlen
argument_list|(
name|bp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* for the \0 */
if|if
condition|(
name|n
operator|>=
name|MAXHOSTNAMELEN
condition|)
block|{
name|RES_SET_H_ERRNO
argument_list|(
name|res
argument_list|,
name|NO_RECOVERY
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|canonname
operator|=
name|bp
expr_stmt|;
name|bp
operator|+=
name|n
expr_stmt|;
comment|/* The qname can be abbreviated, but h_name is now absolute. */
name|qname
operator|=
name|canonname
expr_stmt|;
block|}
name|haveanswer
operator|=
literal|0
expr_stmt|;
name|had_error
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ancount
operator|--
operator|>
literal|0
operator|&&
name|cp
operator|<
name|eom
operator|&&
operator|!
name|had_error
condition|)
block|{
name|n
operator|=
name|dn_expand
argument_list|(
name|answer
operator|->
name|buf
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
name|bp
argument_list|,
name|ep
operator|-
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|<
literal|0
operator|)
operator|||
operator|!
call|(
modifier|*
name|name_ok
call|)
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|had_error
operator|++
expr_stmt|;
continue|continue;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* name */
name|type
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
comment|/* type */
name|class
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
operator|+
name|INT32SZ
expr_stmt|;
comment|/* class, TTL */
name|n
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
comment|/* len */
if|if
condition|(
name|class
operator|!=
name|C_IN
condition|)
block|{
comment|/* XXX - debug? syslog? */
name|cp
operator|+=
name|n
expr_stmt|;
continue|continue;
comment|/* XXX - had_error++ ? */
block|}
if|if
condition|(
operator|(
name|qtype
operator|==
name|T_A
operator|||
name|qtype
operator|==
name|T_AAAA
operator|||
name|qtype
operator|==
name|T_ANY
operator|)
operator|&&
name|type
operator|==
name|T_CNAME
condition|)
block|{
name|n
operator|=
name|dn_expand
argument_list|(
name|answer
operator|->
name|buf
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
name|tbuf
argument_list|,
sizeof|sizeof
name|tbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|<
literal|0
operator|)
operator|||
operator|!
call|(
modifier|*
name|name_ok
call|)
argument_list|(
name|tbuf
argument_list|)
condition|)
block|{
name|had_error
operator|++
expr_stmt|;
continue|continue;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* Get canonical name. */
name|n
operator|=
name|strlen
argument_list|(
name|tbuf
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* for the \0 */
if|if
condition|(
name|n
operator|>
name|ep
operator|-
name|bp
operator|||
name|n
operator|>=
name|MAXHOSTNAMELEN
condition|)
block|{
name|had_error
operator|++
expr_stmt|;
continue|continue;
block|}
name|strlcpy
argument_list|(
name|bp
argument_list|,
name|tbuf
argument_list|,
name|ep
operator|-
name|bp
argument_list|)
expr_stmt|;
name|canonname
operator|=
name|bp
expr_stmt|;
name|bp
operator|+=
name|n
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|qtype
operator|==
name|T_ANY
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|type
operator|==
name|T_A
operator|||
name|type
operator|==
name|T_AAAA
operator|)
condition|)
block|{
name|cp
operator|+=
name|n
expr_stmt|;
continue|continue;
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
name|qtype
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|type
operator|!=
name|T_KEY
operator|&&
name|type
operator|!=
name|T_SIG
operator|&&
name|type
operator|!=
name|ns_t_dname
condition|)
name|syslog
argument_list|(
name|LOG_NOTICE
operator||
name|LOG_AUTH
argument_list|,
literal|"gethostby*.getanswer: asked for \"%s %s %s\", got type \"%s\""
argument_list|,
name|qname
argument_list|,
name|p_class
argument_list|(
name|C_IN
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|qtype
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cp
operator|+=
name|n
expr_stmt|;
continue|continue;
comment|/* XXX - had_error++ ? */
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_A
case|:
case|case
name|T_AAAA
case|:
if|if
condition|(
name|strcasecmp
argument_list|(
name|canonname
argument_list|,
name|bp
argument_list|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|syslog
argument_list|(
name|LOG_NOTICE
operator||
name|LOG_AUTH
argument_list|,
name|AskedForGot
argument_list|,
name|canonname
argument_list|,
name|bp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cp
operator|+=
name|n
expr_stmt|;
continue|continue;
comment|/* XXX - had_error++ ? */
block|}
if|if
condition|(
name|type
operator|==
name|T_A
operator|&&
name|n
operator|!=
name|INADDRSZ
condition|)
block|{
name|cp
operator|+=
name|n
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|type
operator|==
name|T_AAAA
operator|&&
name|n
operator|!=
name|IN6ADDRSZ
condition|)
block|{
name|cp
operator|+=
name|n
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|FILTER_V4MAPPED
if|if
condition|(
name|type
operator|==
name|T_AAAA
condition|)
block|{
name|struct
name|in6_addr
name|in6
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|in6
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|in6
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|in6
argument_list|)
condition|)
block|{
name|cp
operator|+=
name|n
expr_stmt|;
continue|continue;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|haveanswer
condition|)
block|{
name|int
name|nn
decl_stmt|;
name|canonname
operator|=
name|bp
expr_stmt|;
name|nn
operator|=
name|strlen
argument_list|(
name|bp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* for the \0 */
name|bp
operator|+=
name|nn
expr_stmt|;
block|}
comment|/* don't overwrite pai */
name|ai
operator|=
operator|*
name|pai
expr_stmt|;
name|ai
operator|.
name|ai_family
operator|=
operator|(
name|type
operator|==
name|T_A
operator|)
condition|?
name|AF_INET
else|:
name|AF_INET6
expr_stmt|;
name|afd
operator|=
name|find_afd
argument_list|(
name|ai
operator|.
name|ai_family
argument_list|)
expr_stmt|;
if|if
condition|(
name|afd
operator|==
name|NULL
condition|)
block|{
name|cp
operator|+=
name|n
expr_stmt|;
continue|continue;
block|}
name|cur
operator|->
name|ai_next
operator|=
name|get_ai
argument_list|(
operator|&
name|ai
argument_list|,
name|afd
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
operator|->
name|ai_next
operator|==
name|NULL
condition|)
name|had_error
operator|++
expr_stmt|;
while|while
condition|(
name|cur
operator|&&
name|cur
operator|->
name|ai_next
condition|)
name|cur
operator|=
name|cur
operator|->
name|ai_next
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|had_error
condition|)
name|haveanswer
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|haveanswer
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|RESOLVSORT
argument_list|)
comment|/* 		 * We support only IPv4 address for backward 		 * compatibility against gethostbyname(3). 		 */
if|if
condition|(
name|res
operator|->
name|nsort
operator|&&
name|qtype
operator|==
name|T_A
condition|)
block|{
if|if
condition|(
name|addr4sort
argument_list|(
operator|&
name|sentinel
argument_list|,
name|res
argument_list|)
operator|<
literal|0
condition|)
block|{
name|freeaddrinfo
argument_list|(
name|sentinel
operator|.
name|ai_next
argument_list|)
expr_stmt|;
name|RES_SET_H_ERRNO
argument_list|(
name|res
argument_list|,
name|NO_RECOVERY
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
endif|#
directive|endif
comment|/*RESOLVSORT*/
if|if
condition|(
operator|!
name|canonname
condition|)
operator|(
name|void
operator|)
name|get_canonname
argument_list|(
name|pai
argument_list|,
name|sentinel
operator|.
name|ai_next
argument_list|,
name|qname
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|get_canonname
argument_list|(
name|pai
argument_list|,
name|sentinel
operator|.
name|ai_next
argument_list|,
name|canonname
argument_list|)
expr_stmt|;
name|RES_SET_H_ERRNO
argument_list|(
name|res
argument_list|,
name|NETDB_SUCCESS
argument_list|)
expr_stmt|;
return|return
name|sentinel
operator|.
name|ai_next
return|;
block|}
name|RES_SET_H_ERRNO
argument_list|(
name|res
argument_list|,
name|NO_RECOVERY
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|RESOLVSORT
end_ifdef

begin_struct
struct|struct
name|addr_ptr
block|{
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
name|int
name|aval
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|addr4sort
parameter_list|(
name|struct
name|addrinfo
modifier|*
name|sentinel
parameter_list|,
name|res_state
name|res
parameter_list|)
block|{
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
name|struct
name|addr_ptr
modifier|*
name|addrs
decl_stmt|,
name|addr
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|int
name|naddrs
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|needsort
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|sentinel
condition|)
return|return
operator|-
literal|1
return|;
name|naddrs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ai
operator|=
name|sentinel
operator|->
name|ai_next
init|;
name|ai
condition|;
name|ai
operator|=
name|ai
operator|->
name|ai_next
control|)
name|naddrs
operator|++
expr_stmt|;
if|if
condition|(
name|naddrs
operator|<
literal|2
condition|)
return|return
literal|0
return|;
comment|/* We don't need sorting. */
if|if
condition|(
operator|(
name|addrs
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|addr_ptr
argument_list|)
operator|*
name|naddrs
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ai
operator|=
name|sentinel
operator|->
name|ai_next
init|;
name|ai
condition|;
name|ai
operator|=
name|ai
operator|->
name|ai_next
control|)
block|{
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|ai
operator|->
name|ai_addr
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
operator|(
name|unsigned
operator|)
name|j
operator|<
name|res
operator|->
name|nsort
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|res
operator|->
name|sort_list
index|[
name|j
index|]
operator|.
name|addr
operator|.
name|s_addr
operator|==
operator|(
name|sin
operator|->
name|sin_addr
operator|.
name|s_addr
operator|&
name|res
operator|->
name|sort_list
index|[
name|j
index|]
operator|.
name|mask
operator|)
condition|)
break|break;
block|}
name|addrs
index|[
name|i
index|]
operator|.
name|ai
operator|=
name|ai
expr_stmt|;
name|addrs
index|[
name|i
index|]
operator|.
name|aval
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|needsort
operator|==
literal|0
operator|&&
name|i
operator|>
literal|0
operator|&&
name|j
operator|<
name|addrs
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|aval
condition|)
name|needsort
operator|=
name|i
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|needsort
condition|)
block|{
name|free
argument_list|(
name|addrs
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
while|while
condition|(
name|needsort
operator|<
name|naddrs
condition|)
block|{
for|for
control|(
name|j
operator|=
name|needsort
operator|-
literal|1
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
name|addrs
index|[
name|j
index|]
operator|.
name|aval
operator|>
name|addrs
index|[
name|j
operator|+
literal|1
index|]
operator|.
name|aval
condition|)
block|{
name|addr
operator|=
name|addrs
index|[
name|j
index|]
expr_stmt|;
name|addrs
index|[
name|j
index|]
operator|=
name|addrs
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
name|addrs
index|[
name|j
operator|+
literal|1
index|]
operator|=
name|addr
expr_stmt|;
block|}
else|else
break|break;
block|}
name|needsort
operator|++
expr_stmt|;
block|}
name|ai
operator|=
name|sentinel
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|naddrs
condition|;
operator|++
name|i
control|)
block|{
name|ai
operator|->
name|ai_next
operator|=
name|addrs
index|[
name|i
index|]
operator|.
name|ai
expr_stmt|;
name|ai
operator|=
name|ai
operator|->
name|ai_next
expr_stmt|;
block|}
name|ai
operator|->
name|ai_next
operator|=
name|NULL
expr_stmt|;
name|free
argument_list|(
name|addrs
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*RESOLVSORT*/
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|_dns_getaddrinfo
parameter_list|(
name|void
modifier|*
name|rv
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|struct
name|addrinfo
modifier|*
name|ai
decl_stmt|;
name|querybuf
modifier|*
name|buf
decl_stmt|,
modifier|*
name|buf2
decl_stmt|;
specifier|const
name|char
modifier|*
name|hostname
decl_stmt|;
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
name|struct
name|addrinfo
name|sentinel
decl_stmt|,
modifier|*
name|cur
decl_stmt|;
name|struct
name|res_target
name|q
decl_stmt|,
name|q2
decl_stmt|;
name|res_state
name|res
decl_stmt|;
name|hostname
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|pai
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
expr|struct
name|addrinfo
operator|*
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|q
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|q2
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|q2
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sentinel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sentinel
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
operator|&
name|sentinel
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
block|{
name|RES_SET_H_ERRNO
argument_list|(
name|res
argument_list|,
name|NETDB_INTERNAL
argument_list|)
expr_stmt|;
return|return
name|NS_NOTFOUND
return|;
block|}
name|buf2
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|buf2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf2
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|RES_SET_H_ERRNO
argument_list|(
name|res
argument_list|,
name|NETDB_INTERNAL
argument_list|)
expr_stmt|;
return|return
name|NS_NOTFOUND
return|;
block|}
switch|switch
condition|(
name|pai
operator|->
name|ai_family
condition|)
block|{
case|case
name|AF_UNSPEC
case|:
name|q
operator|.
name|name
operator|=
name|hostname
expr_stmt|;
name|q
operator|.
name|qclass
operator|=
name|C_IN
expr_stmt|;
name|q
operator|.
name|qtype
operator|=
name|T_A
expr_stmt|;
name|q
operator|.
name|answer
operator|=
name|buf
operator|->
name|buf
expr_stmt|;
name|q
operator|.
name|anslen
operator|=
sizeof|sizeof
argument_list|(
name|buf
operator|->
name|buf
argument_list|)
expr_stmt|;
name|q
operator|.
name|next
operator|=
operator|&
name|q2
expr_stmt|;
name|q2
operator|.
name|name
operator|=
name|hostname
expr_stmt|;
name|q2
operator|.
name|qclass
operator|=
name|C_IN
expr_stmt|;
name|q2
operator|.
name|qtype
operator|=
name|T_AAAA
expr_stmt|;
name|q2
operator|.
name|answer
operator|=
name|buf2
operator|->
name|buf
expr_stmt|;
name|q2
operator|.
name|anslen
operator|=
sizeof|sizeof
argument_list|(
name|buf2
operator|->
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_INET
case|:
name|q
operator|.
name|name
operator|=
name|hostname
expr_stmt|;
name|q
operator|.
name|qclass
operator|=
name|C_IN
expr_stmt|;
name|q
operator|.
name|qtype
operator|=
name|T_A
expr_stmt|;
name|q
operator|.
name|answer
operator|=
name|buf
operator|->
name|buf
expr_stmt|;
name|q
operator|.
name|anslen
operator|=
sizeof|sizeof
argument_list|(
name|buf
operator|->
name|buf
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
name|q
operator|.
name|name
operator|=
name|hostname
expr_stmt|;
name|q
operator|.
name|qclass
operator|=
name|C_IN
expr_stmt|;
name|q
operator|.
name|qtype
operator|=
name|T_AAAA
expr_stmt|;
name|q
operator|.
name|answer
operator|=
name|buf
operator|->
name|buf
expr_stmt|;
name|q
operator|.
name|anslen
operator|=
sizeof|sizeof
argument_list|(
name|buf
operator|->
name|buf
argument_list|)
expr_stmt|;
break|break;
default|default:
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
return|return
name|NS_UNAVAIL
return|;
block|}
name|res
operator|=
name|__res_state
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|res
operator|->
name|options
operator|&
name|RES_INIT
operator|)
operator|==
literal|0
operator|&&
name|res_ninit
argument_list|(
name|res
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|RES_SET_H_ERRNO
argument_list|(
name|res
argument_list|,
name|NETDB_INTERNAL
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
return|return
name|NS_NOTFOUND
return|;
block|}
if|if
condition|(
name|res_searchN
argument_list|(
name|hostname
argument_list|,
operator|&
name|q
argument_list|,
name|res
argument_list|)
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
return|return
name|NS_NOTFOUND
return|;
block|}
comment|/* prefer IPv6 */
if|if
condition|(
name|q
operator|.
name|next
condition|)
block|{
name|ai
operator|=
name|getanswer
argument_list|(
name|buf2
argument_list|,
name|q2
operator|.
name|n
argument_list|,
name|q2
operator|.
name|name
argument_list|,
name|q2
operator|.
name|qtype
argument_list|,
name|pai
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
condition|)
block|{
name|cur
operator|->
name|ai_next
operator|=
name|ai
expr_stmt|;
while|while
condition|(
name|cur
operator|&&
name|cur
operator|->
name|ai_next
condition|)
name|cur
operator|=
name|cur
operator|->
name|ai_next
expr_stmt|;
block|}
block|}
name|ai
operator|=
name|getanswer
argument_list|(
name|buf
argument_list|,
name|q
operator|.
name|n
argument_list|,
name|q
operator|.
name|name
argument_list|,
name|q
operator|.
name|qtype
argument_list|,
name|pai
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
condition|)
name|cur
operator|->
name|ai_next
operator|=
name|ai
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf2
argument_list|)
expr_stmt|;
if|if
condition|(
name|sentinel
operator|.
name|ai_next
operator|==
name|NULL
condition|)
switch|switch
condition|(
name|res
operator|->
name|res_h_errno
condition|)
block|{
case|case
name|HOST_NOT_FOUND
case|:
return|return
name|NS_NOTFOUND
return|;
case|case
name|TRY_AGAIN
case|:
return|return
name|NS_TRYAGAIN
return|;
default|default:
return|return
name|NS_UNAVAIL
return|;
block|}
operator|*
operator|(
operator|(
expr|struct
name|addrinfo
operator|*
operator|*
operator|)
name|rv
operator|)
operator|=
name|sentinel
operator|.
name|ai_next
expr_stmt|;
return|return
name|NS_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_sethtent
parameter_list|(
name|FILE
modifier|*
modifier|*
name|hostf
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|*
name|hostf
condition|)
operator|*
name|hostf
operator|=
name|fopen
argument_list|(
name|_PATH_HOSTS
argument_list|,
literal|"re"
argument_list|)
expr_stmt|;
else|else
name|rewind
argument_list|(
operator|*
name|hostf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_endhtent
parameter_list|(
name|FILE
modifier|*
modifier|*
name|hostf
parameter_list|)
block|{
if|if
condition|(
operator|*
name|hostf
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
operator|*
name|hostf
argument_list|)
expr_stmt|;
operator|*
name|hostf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|addrinfo
modifier|*
name|_gethtent
parameter_list|(
name|FILE
modifier|*
modifier|*
name|hostf
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|tname
decl_stmt|,
modifier|*
name|cname
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|res0
decl_stmt|,
modifier|*
name|res
decl_stmt|;
name|int
name|error
decl_stmt|;
specifier|const
name|char
modifier|*
name|addr
decl_stmt|;
name|char
name|hostbuf
index|[
literal|8
operator|*
literal|1024
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|hostf
operator|&&
operator|!
operator|(
operator|*
name|hostf
operator|=
name|fopen
argument_list|(
name|_PATH_HOSTS
argument_list|,
literal|"re"
argument_list|)
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|again
label|:
if|if
condition|(
operator|!
operator|(
name|p
operator|=
name|fgets
argument_list|(
name|hostbuf
argument_list|,
sizeof|sizeof
name|hostbuf
argument_list|,
operator|*
name|hostf
argument_list|)
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'#'
condition|)
goto|goto
name|again
goto|;
name|cp
operator|=
name|strpbrk
argument_list|(
name|p
argument_list|,
literal|"#\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cp
operator|=
name|strpbrk
argument_list|(
name|p
argument_list|,
literal|" \t"
argument_list|)
operator|)
condition|)
goto|goto
name|again
goto|;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|addr
operator|=
name|p
expr_stmt|;
name|cname
operator|=
name|NULL
expr_stmt|;
comment|/* if this is not something we're looking for, skip it. */
while|while
condition|(
name|cp
operator|&&
operator|*
name|cp
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
continue|continue;
block|}
name|tname
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|cname
operator|==
name|NULL
condition|)
name|cname
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strpbrk
argument_list|(
name|cp
argument_list|,
literal|" \t"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|tname
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|found
goto|;
block|}
goto|goto
name|again
goto|;
name|found
label|:
comment|/* we should not glob socktype/protocol here */
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hints
argument_list|)
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|pai
operator|->
name|ai_family
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|SOCK_DGRAM
expr_stmt|;
name|hints
operator|.
name|ai_protocol
operator|=
literal|0
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|AI_NUMERICHOST
expr_stmt|;
name|error
operator|=
name|getaddrinfo
argument_list|(
name|addr
argument_list|,
literal|"0"
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|res0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|again
goto|;
ifdef|#
directive|ifdef
name|FILTER_V4MAPPED
comment|/* XXX should check all items in the chain */
if|if
condition|(
name|res0
operator|->
name|ai_family
operator|==
name|AF_INET6
operator|&&
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|res0
operator|->
name|ai_addr
operator|)
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
name|freeaddrinfo
argument_list|(
name|res0
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
endif|#
directive|endif
for|for
control|(
name|res
operator|=
name|res0
init|;
name|res
condition|;
name|res
operator|=
name|res
operator|->
name|ai_next
control|)
block|{
comment|/* cover it up */
name|res
operator|->
name|ai_flags
operator|=
name|pai
operator|->
name|ai_flags
expr_stmt|;
name|res
operator|->
name|ai_socktype
operator|=
name|pai
operator|->
name|ai_socktype
expr_stmt|;
name|res
operator|->
name|ai_protocol
operator|=
name|pai
operator|->
name|ai_protocol
expr_stmt|;
if|if
condition|(
name|pai
operator|->
name|ai_flags
operator|&
name|AI_CANONNAME
condition|)
block|{
if|if
condition|(
name|get_canonname
argument_list|(
name|pai
argument_list|,
name|res
argument_list|,
name|cname
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|freeaddrinfo
argument_list|(
name|res0
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
block|}
block|}
return|return
name|res0
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|_files_getaddrinfo
parameter_list|(
name|void
modifier|*
name|rv
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
name|struct
name|addrinfo
name|sentinel
decl_stmt|,
modifier|*
name|cur
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|p
decl_stmt|;
name|FILE
modifier|*
name|hostf
init|=
name|NULL
decl_stmt|;
name|name
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|pai
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
expr|struct
name|addrinfo
operator|*
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sentinel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sentinel
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
operator|&
name|sentinel
expr_stmt|;
name|_sethtent
argument_list|(
operator|&
name|hostf
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|_gethtent
argument_list|(
operator|&
name|hostf
argument_list|,
name|name
argument_list|,
name|pai
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|cur
operator|->
name|ai_next
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|cur
operator|&&
name|cur
operator|->
name|ai_next
condition|)
name|cur
operator|=
name|cur
operator|->
name|ai_next
expr_stmt|;
block|}
name|_endhtent
argument_list|(
operator|&
name|hostf
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|(
expr|struct
name|addrinfo
operator|*
operator|*
operator|)
name|rv
operator|)
operator|=
name|sentinel
operator|.
name|ai_next
expr_stmt|;
if|if
condition|(
name|sentinel
operator|.
name|ai_next
operator|==
name|NULL
condition|)
return|return
name|NS_NOTFOUND
return|;
return|return
name|NS_SUCCESS
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|YP
end_ifdef

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|struct
name|addrinfo
modifier|*
name|_yphostent
parameter_list|(
name|char
modifier|*
name|line
parameter_list|,
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
parameter_list|)
block|{
name|struct
name|addrinfo
name|sentinel
decl_stmt|,
modifier|*
name|cur
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|res
decl_stmt|,
modifier|*
name|res0
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|addr
decl_stmt|,
modifier|*
name|canonname
decl_stmt|;
name|char
modifier|*
name|nextline
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|addr
operator|=
name|canonname
operator|=
name|NULL
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sentinel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sentinel
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
operator|&
name|sentinel
expr_stmt|;
name|nextline
label|:
comment|/* terminate line */
name|cp
operator|=
name|strchr
argument_list|(
name|p
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|nextline
operator|=
name|cp
expr_stmt|;
block|}
else|else
name|nextline
operator|=
name|NULL
expr_stmt|;
name|cp
operator|=
name|strpbrk
argument_list|(
name|p
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|canonname
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
goto|goto
name|done
goto|;
block|}
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|addr
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|cp
operator|&&
operator|*
name|cp
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
condition|)
block|{
name|cp
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|canonname
condition|)
name|canonname
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strpbrk
argument_list|(
name|cp
argument_list|,
literal|" \t"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
name|hints
operator|=
operator|*
name|pai
expr_stmt|;
name|hints
operator|.
name|ai_flags
operator|=
name|AI_NUMERICHOST
expr_stmt|;
name|error
operator|=
name|getaddrinfo
argument_list|(
name|addr
argument_list|,
name|NULL
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|res0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|res
operator|=
name|res0
init|;
name|res
condition|;
name|res
operator|=
name|res
operator|->
name|ai_next
control|)
block|{
comment|/* cover it up */
name|res
operator|->
name|ai_flags
operator|=
name|pai
operator|->
name|ai_flags
expr_stmt|;
if|if
condition|(
name|pai
operator|->
name|ai_flags
operator|&
name|AI_CANONNAME
condition|)
operator|(
name|void
operator|)
name|get_canonname
argument_list|(
name|pai
argument_list|,
name|res
argument_list|,
name|canonname
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|res0
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|res0
condition|)
block|{
name|cur
operator|->
name|ai_next
operator|=
name|res0
expr_stmt|;
while|while
condition|(
name|cur
operator|&&
name|cur
operator|->
name|ai_next
condition|)
name|cur
operator|=
name|cur
operator|->
name|ai_next
expr_stmt|;
block|}
if|if
condition|(
name|nextline
condition|)
block|{
name|p
operator|=
name|nextline
expr_stmt|;
goto|goto
name|nextline
goto|;
block|}
name|done
label|:
return|return
name|sentinel
operator|.
name|ai_next
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|_yp_getaddrinfo
parameter_list|(
name|void
modifier|*
name|rv
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|struct
name|addrinfo
name|sentinel
decl_stmt|,
modifier|*
name|cur
decl_stmt|;
name|struct
name|addrinfo
modifier|*
name|ai
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ypbuf
decl_stmt|;
name|int
name|ypbuflen
decl_stmt|,
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|struct
name|addrinfo
modifier|*
name|pai
decl_stmt|;
name|char
modifier|*
name|ypdomain
decl_stmt|;
if|if
condition|(
name|_yp_check
argument_list|(
operator|&
name|ypdomain
argument_list|)
operator|==
literal|0
condition|)
return|return
name|NS_UNAVAIL
return|;
name|name
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|pai
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
expr|struct
name|addrinfo
operator|*
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sentinel
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sentinel
argument_list|)
argument_list|)
expr_stmt|;
name|cur
operator|=
operator|&
name|sentinel
expr_stmt|;
comment|/* hosts.byname is only for IPv4 (Solaris8) */
if|if
condition|(
name|pai
operator|->
name|ai_family
operator|==
name|PF_UNSPEC
operator|||
name|pai
operator|->
name|ai_family
operator|==
name|PF_INET
condition|)
block|{
name|r
operator|=
name|yp_match
argument_list|(
name|ypdomain
argument_list|,
literal|"hosts.byname"
argument_list|,
name|name
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
operator|&
name|ypbuf
argument_list|,
operator|&
name|ypbuflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|struct
name|addrinfo
name|ai4
decl_stmt|;
name|ai4
operator|=
operator|*
name|pai
expr_stmt|;
name|ai4
operator|.
name|ai_family
operator|=
name|AF_INET
expr_stmt|;
name|ai
operator|=
name|_yphostent
argument_list|(
name|ypbuf
argument_list|,
operator|&
name|ai4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
condition|)
block|{
name|cur
operator|->
name|ai_next
operator|=
name|ai
expr_stmt|;
while|while
condition|(
name|cur
operator|&&
name|cur
operator|->
name|ai_next
condition|)
name|cur
operator|=
name|cur
operator|->
name|ai_next
expr_stmt|;
block|}
name|free
argument_list|(
name|ypbuf
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* ipnodes.byname can hold both IPv4/v6 */
name|r
operator|=
name|yp_match
argument_list|(
name|ypdomain
argument_list|,
literal|"ipnodes.byname"
argument_list|,
name|name
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
operator|&
name|ypbuf
argument_list|,
operator|&
name|ypbuflen
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|ai
operator|=
name|_yphostent
argument_list|(
name|ypbuf
argument_list|,
name|pai
argument_list|)
expr_stmt|;
if|if
condition|(
name|ai
condition|)
name|cur
operator|->
name|ai_next
operator|=
name|ai
expr_stmt|;
name|free
argument_list|(
name|ypbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sentinel
operator|.
name|ai_next
operator|==
name|NULL
condition|)
block|{
name|RES_SET_H_ERRNO
argument_list|(
name|__res_state
argument_list|()
argument_list|,
name|HOST_NOT_FOUND
argument_list|)
expr_stmt|;
return|return
name|NS_NOTFOUND
return|;
block|}
operator|*
operator|(
operator|(
expr|struct
name|addrinfo
operator|*
operator|*
operator|)
name|rv
operator|)
operator|=
name|sentinel
operator|.
name|ai_next
expr_stmt|;
return|return
name|NS_SUCCESS
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* resolver logic */
end_comment

begin_comment
comment|/*  * Formulate a normal query, send, and await answer.  * Returned answer is placed in supplied buffer "answer".  * Perform preliminary check of answer, returning success only  * if no error is indicated and the answer count is nonzero.  * Return the size of the response on success, -1 on error.  * Error number is left in h_errno.  *  * Caller must parse answer and determine whether it answers the question.  */
end_comment

begin_function
specifier|static
name|int
name|res_queryN
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|res_target
modifier|*
name|target
parameter_list|,
name|res_state
name|res
parameter_list|)
block|{
name|u_char
modifier|*
name|buf
decl_stmt|;
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|int
name|n
decl_stmt|;
name|u_int
name|oflags
decl_stmt|;
name|struct
name|res_target
modifier|*
name|t
decl_stmt|;
name|int
name|rcode
decl_stmt|;
name|int
name|ancount
decl_stmt|;
name|rcode
operator|=
name|NOERROR
expr_stmt|;
name|ancount
operator|=
literal|0
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|MAXPACKET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|buf
condition|)
block|{
name|RES_SET_H_ERRNO
argument_list|(
name|res
argument_list|,
name|NETDB_INTERNAL
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
for|for
control|(
name|t
operator|=
name|target
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|next
control|)
block|{
name|int
name|class
decl_stmt|,
name|type
decl_stmt|;
name|u_char
modifier|*
name|answer
decl_stmt|;
name|int
name|anslen
decl_stmt|;
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|t
operator|->
name|answer
expr_stmt|;
comment|/* make it easier... */
name|class
operator|=
name|t
operator|->
name|qclass
expr_stmt|;
name|type
operator|=
name|t
operator|->
name|qtype
expr_stmt|;
name|answer
operator|=
name|t
operator|->
name|answer
expr_stmt|;
name|anslen
operator|=
name|t
operator|->
name|anslen
expr_stmt|;
name|oflags
operator|=
name|res
operator|->
name|_flags
expr_stmt|;
name|again
label|:
name|hp
operator|->
name|rcode
operator|=
name|NOERROR
expr_stmt|;
comment|/* default */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|res
operator|->
name|options
operator|&
name|RES_DEBUG
condition|)
name|printf
argument_list|(
literal|";; res_query(%s, %d, %d)\n"
argument_list|,
name|name
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|n
operator|=
name|res_nmkquery
argument_list|(
name|res
argument_list|,
name|QUERY
argument_list|,
name|name
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|buf
argument_list|,
name|MAXPACKET
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
operator|&&
operator|(
name|res
operator|->
name|_flags
operator|&
name|RES_F_EDNS0ERR
operator|)
operator|==
literal|0
operator|&&
operator|(
name|res
operator|->
name|options
operator|&
operator|(
name|RES_USE_EDNS0
operator||
name|RES_USE_DNSSEC
operator|)
operator|)
operator|!=
literal|0U
condition|)
name|n
operator|=
name|res_nopt
argument_list|(
name|res
argument_list|,
name|n
argument_list|,
name|buf
argument_list|,
name|MAXPACKET
argument_list|,
name|anslen
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|res
operator|->
name|options
operator|&
name|RES_DEBUG
condition|)
name|printf
argument_list|(
literal|";; res_query: mkquery failed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|RES_SET_H_ERRNO
argument_list|(
name|res
argument_list|,
name|NO_RECOVERY
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
name|n
operator|=
name|res_nsend
argument_list|(
name|res
argument_list|,
name|buf
argument_list|,
name|n
argument_list|,
name|answer
argument_list|,
name|anslen
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
comment|/* 			 * if the query choked with EDNS0, retry 			 * without EDNS0 			 */
if|if
condition|(
operator|(
name|res
operator|->
name|options
operator|&
operator|(
name|RES_USE_EDNS0
operator||
name|RES_USE_DNSSEC
operator|)
operator|)
operator|!=
literal|0U
operator|&&
operator|(
operator|(
name|oflags
operator|^
name|res
operator|->
name|_flags
operator|)
operator|&
name|RES_F_EDNS0ERR
operator|)
operator|!=
literal|0
condition|)
block|{
name|res
operator|->
name|_flags
operator||=
name|RES_F_EDNS0ERR
expr_stmt|;
if|if
condition|(
name|res
operator|->
name|options
operator|&
name|RES_DEBUG
condition|)
name|printf
argument_list|(
literal|";; res_nquery: retry without EDNS0\n"
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|rcode
operator|=
name|hp
operator|->
name|rcode
expr_stmt|;
comment|/* record most recent error */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|res
operator|->
name|options
operator|&
name|RES_DEBUG
condition|)
name|printf
argument_list|(
literal|";; res_query: send error\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
name|n
operator|>
name|anslen
condition|)
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
comment|/* XXX not very informative */
if|if
condition|(
name|hp
operator|->
name|rcode
operator|!=
name|NOERROR
operator|||
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rcode
operator|=
name|hp
operator|->
name|rcode
expr_stmt|;
comment|/* record most recent error */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|res
operator|->
name|options
operator|&
name|RES_DEBUG
condition|)
name|printf
argument_list|(
literal|";; rcode = %u, ancount=%u\n"
argument_list|,
name|hp
operator|->
name|rcode
argument_list|,
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
name|ancount
operator|+=
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|t
operator|->
name|n
operator|=
name|n
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ancount
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|rcode
condition|)
block|{
case|case
name|NXDOMAIN
case|:
name|RES_SET_H_ERRNO
argument_list|(
name|res
argument_list|,
name|HOST_NOT_FOUND
argument_list|)
expr_stmt|;
break|break;
case|case
name|SERVFAIL
case|:
name|RES_SET_H_ERRNO
argument_list|(
name|res
argument_list|,
name|TRY_AGAIN
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOERROR
case|:
name|RES_SET_H_ERRNO
argument_list|(
name|res
argument_list|,
name|NO_DATA
argument_list|)
expr_stmt|;
break|break;
case|case
name|FORMERR
case|:
case|case
name|NOTIMP
case|:
case|case
name|REFUSED
case|:
default|default:
name|RES_SET_H_ERRNO
argument_list|(
name|res
argument_list|,
name|NO_RECOVERY
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|ancount
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Formulate a normal query, send, and retrieve answer in supplied buffer.  * Return the size of the response on success, -1 on error.  * If enabled, implement search rules until answer or unrecoverable failure  * is detected.  Error code, if any, is left in h_errno.  */
end_comment

begin_function
specifier|static
name|int
name|res_searchN
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|res_target
modifier|*
name|target
parameter_list|,
name|res_state
name|res
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
decl_stmt|const
modifier|*
name|domain
decl_stmt|;
name|HEADER
modifier|*
name|hp
init|=
operator|(
name|HEADER
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|target
operator|->
name|answer
decl_stmt|;
comment|/*XXX*/
name|u_int
name|dots
decl_stmt|;
name|int
name|trailing_dot
decl_stmt|,
name|ret
decl_stmt|,
name|saved_herrno
decl_stmt|;
name|int
name|got_nodata
init|=
literal|0
decl_stmt|,
name|got_servfail
init|=
literal|0
decl_stmt|,
name|root_on_list
init|=
literal|0
decl_stmt|;
name|int
name|tried_as_is
init|=
literal|0
decl_stmt|;
name|int
name|searched
init|=
literal|0
decl_stmt|;
name|char
name|abuf
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|RES_SET_H_ERRNO
argument_list|(
name|res
argument_list|,
name|HOST_NOT_FOUND
argument_list|)
expr_stmt|;
comment|/* default, if we never query */
name|dots
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|name
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
name|dots
operator|+=
operator|(
operator|*
name|cp
operator|==
literal|'.'
operator|)
expr_stmt|;
name|trailing_dot
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cp
operator|>
name|name
operator|&&
operator|*
operator|--
name|cp
operator|==
literal|'.'
condition|)
name|trailing_dot
operator|++
expr_stmt|;
comment|/* 	 * if there aren't any dots, it could be a user-level alias 	 */
if|if
condition|(
operator|!
name|dots
operator|&&
operator|(
name|cp
operator|=
name|res_hostalias
argument_list|(
name|res
argument_list|,
name|name
argument_list|,
name|abuf
argument_list|,
sizeof|sizeof
argument_list|(
name|abuf
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|res_queryN
argument_list|(
name|cp
argument_list|,
name|target
argument_list|,
name|res
argument_list|)
operator|)
return|;
comment|/* 	 * If there are enough dots in the name, let's just give it a 	 * try 'as is'. The threshold can be set with the "ndots" option. 	 * Also, query 'as is', if there is a trailing dot in the name. 	 */
name|saved_herrno
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|dots
operator|>=
name|res
operator|->
name|ndots
operator|||
name|trailing_dot
condition|)
block|{
name|ret
operator|=
name|res_querydomainN
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|target
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
operator|||
name|trailing_dot
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|errno
operator|==
name|ECONNREFUSED
condition|)
block|{
name|RES_SET_H_ERRNO
argument_list|(
name|res
argument_list|,
name|TRY_AGAIN
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
switch|switch
condition|(
name|res
operator|->
name|res_h_errno
condition|)
block|{
case|case
name|NO_DATA
case|:
case|case
name|HOST_NOT_FOUND
case|:
break|break;
case|case
name|TRY_AGAIN
case|:
if|if
condition|(
name|hp
operator|->
name|rcode
operator|==
name|SERVFAIL
condition|)
break|break;
comment|/* FALLTHROUGH */
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|saved_herrno
operator|=
name|res
operator|->
name|res_h_errno
expr_stmt|;
name|tried_as_is
operator|++
expr_stmt|;
block|}
comment|/* 	 * We do at least one level of search if 	 *	- there is no dot and RES_DEFNAME is set, or 	 *	- there is at least one dot, there is no trailing dot, 	 *	  and RES_DNSRCH is set. 	 */
if|if
condition|(
operator|(
operator|!
name|dots
operator|&&
operator|(
name|res
operator|->
name|options
operator|&
name|RES_DEFNAMES
operator|)
operator|)
operator|||
operator|(
name|dots
operator|&&
operator|!
name|trailing_dot
operator|&&
operator|(
name|res
operator|->
name|options
operator|&
name|RES_DNSRCH
operator|)
operator|)
condition|)
block|{
name|int
name|done
init|=
literal|0
decl_stmt|;
for|for
control|(
name|domain
operator|=
operator|(
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|)
name|res
operator|->
name|dnsrch
init|;
operator|*
name|domain
operator|&&
operator|!
name|done
condition|;
name|domain
operator|++
control|)
block|{
name|searched
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|domain
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|domain
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|domain
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
name|root_on_list
operator|++
expr_stmt|;
if|if
condition|(
name|root_on_list
operator|&&
name|tried_as_is
condition|)
continue|continue;
name|ret
operator|=
name|res_querydomainN
argument_list|(
name|name
argument_list|,
operator|*
name|domain
argument_list|,
name|target
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
comment|/* 			 * If no server present, give up. 			 * If name isn't found in this domain, 			 * keep trying higher domains in the search list 			 * (if that's enabled). 			 * On a NO_DATA error, keep trying, otherwise 			 * a wildcard entry of another type could keep us 			 * from finding this entry higher in the domain. 			 * If we get some other error (negative answer or 			 * server failure), then stop searching up, 			 * but try the input name below in case it's 			 * fully-qualified. 			 */
if|if
condition|(
name|errno
operator|==
name|ECONNREFUSED
condition|)
block|{
name|RES_SET_H_ERRNO
argument_list|(
name|res
argument_list|,
name|TRY_AGAIN
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
switch|switch
condition|(
name|res
operator|->
name|res_h_errno
condition|)
block|{
case|case
name|NO_DATA
case|:
name|got_nodata
operator|++
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|HOST_NOT_FOUND
case|:
comment|/* keep trying */
break|break;
case|case
name|TRY_AGAIN
case|:
name|got_servfail
operator|++
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|rcode
operator|==
name|SERVFAIL
condition|)
block|{
comment|/* try next search element, if any */
break|break;
block|}
comment|/* FALLTHROUGH */
default|default:
comment|/* anything else implies that we're done */
name|done
operator|++
expr_stmt|;
block|}
comment|/* 			 * if we got here for some reason other than DNSRCH, 			 * we only wanted one iteration of the loop, so stop. 			 */
if|if
condition|(
operator|!
operator|(
name|res
operator|->
name|options
operator|&
name|RES_DNSRCH
operator|)
condition|)
name|done
operator|++
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|res
operator|->
name|res_h_errno
condition|)
block|{
case|case
name|NO_DATA
case|:
case|case
name|HOST_NOT_FOUND
case|:
break|break;
case|case
name|TRY_AGAIN
case|:
if|if
condition|(
name|hp
operator|->
name|rcode
operator|==
name|SERVFAIL
condition|)
break|break;
comment|/* FALLTHROUGH */
default|default:
goto|goto
name|giveup
goto|;
block|}
comment|/* 	 * If the query has not already been tried as is then try it 	 * unless RES_NOTLDQUERY is set and there were no dots. 	 */
if|if
condition|(
operator|(
name|dots
operator|||
operator|!
name|searched
operator|||
operator|!
operator|(
name|res
operator|->
name|options
operator|&
name|RES_NOTLDQUERY
operator|)
operator|)
operator|&&
operator|!
operator|(
name|tried_as_is
operator|||
name|root_on_list
operator|)
condition|)
block|{
name|ret
operator|=
name|res_querydomainN
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|target
argument_list|,
name|res
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* 	 * if we got here, we didn't satisfy the search. 	 * if we did an initial full query, return that query's h_errno 	 * (note that we wouldn't be here if that query had succeeded). 	 * else if we ever got a nodata, send that back as the reason. 	 * else send back meaningless h_errno, that being the one from 	 * the last DNSRCH we did. 	 */
name|giveup
label|:
if|if
condition|(
name|saved_herrno
operator|!=
operator|-
literal|1
condition|)
name|RES_SET_H_ERRNO
argument_list|(
name|res
argument_list|,
name|saved_herrno
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|got_nodata
condition|)
name|RES_SET_H_ERRNO
argument_list|(
name|res
argument_list|,
name|NO_DATA
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|got_servfail
condition|)
name|RES_SET_H_ERRNO
argument_list|(
name|res
argument_list|,
name|TRY_AGAIN
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Perform a call on res_query on the concatenation of name and domain,  * removing a trailing dot from name if domain is NULL.  */
end_comment

begin_function
specifier|static
name|int
name|res_querydomainN
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|domain
parameter_list|,
name|struct
name|res_target
modifier|*
name|target
parameter_list|,
name|res_state
name|res
parameter_list|)
block|{
name|char
name|nbuf
index|[
name|MAXDNAME
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|longname
init|=
name|nbuf
decl_stmt|;
name|size_t
name|n
decl_stmt|,
name|d
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|res
operator|->
name|options
operator|&
name|RES_DEBUG
condition|)
name|printf
argument_list|(
literal|";; res_querydomain(%s, %s)\n"
argument_list|,
name|name
argument_list|,
name|domain
condition|?
name|domain
else|:
literal|"<Nil>"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|domain
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Check for trailing '.'; 		 * copy without '.' if present. 		 */
name|n
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|MAXDNAME
condition|)
block|{
name|RES_SET_H_ERRNO
argument_list|(
name|res
argument_list|,
name|NO_RECOVERY
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|>
literal|0
operator|&&
name|name
index|[
operator|--
name|n
index|]
operator|==
literal|'.'
condition|)
block|{
name|strncpy
argument_list|(
name|nbuf
argument_list|,
name|name
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|nbuf
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|longname
operator|=
name|name
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|d
operator|=
name|strlen
argument_list|(
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|+
name|d
operator|+
literal|1
operator|>=
name|MAXDNAME
condition|)
block|{
name|RES_SET_H_ERRNO
argument_list|(
name|res
argument_list|,
name|NO_RECOVERY
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|snprintf
argument_list|(
name|nbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|nbuf
argument_list|)
argument_list|,
literal|"%s.%s"
argument_list|,
name|name
argument_list|,
name|domain
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|res_queryN
argument_list|(
name|longname
argument_list|,
name|target
argument_list|,
name|res
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

