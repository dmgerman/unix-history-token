begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: hesiod.c,v 1.9 1999/02/11 06:16:38 simonb Exp $	*/
end_comment

begin_comment
comment|/* Copyright (c) 1996 by Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS  * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE  * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_comment
comment|/* Copyright 1996 by the Massachusetts Institute of Technology.  *  * Permission to use, copy, modify, and distribute this  * software and its documentation for any purpose and without  * fee is hereby granted, provided that the above copyright  * notice appear in all copies and that both that copyright  * notice and this permission notice appear in supporting  * documentation, and that the name of M.I.T. not be used in  * advertising or publicity pertaining to distribution of the  * software without specific, written prior permission.  * M.I.T. makes no representations about the suitability of  * this software for any purpose.  It is provided "as is"  * without express or implied warranty.  */
end_comment

begin_comment
comment|/* This file is part of the hesiod library.  It implements the core  * portion of the hesiod resolver.  *  * This file is loosely based on an interim version of hesiod.c from  * the BIND IRS library, which was in turn based on an earlier version  * of this file.  Extensive changes have been made on each step of the  * path.  *  * This implementation is not truly thread-safe at the moment because  * it uses res_send() and accesses _res.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
modifier|*
name|orig_rcsid
init|=
literal|"$NetBSD: hesiod.c,v 1.9 1999/02/11 06:16:38 simonb Exp $"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBC_SCCS and not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<hesiod.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_struct
struct|struct
name|hesiod_p
block|{
name|char
modifier|*
name|lhs
decl_stmt|;
comment|/* normally ".ns" */
name|char
modifier|*
name|rhs
decl_stmt|;
comment|/* AKA the default hesiod domain */
name|int
name|classes
index|[
literal|2
index|]
decl_stmt|;
comment|/* The class search order. */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|MAX_HESRESP
value|1024
end_define

begin_decl_stmt
specifier|static
name|int
name|read_config_file
name|__P
argument_list|(
operator|(
expr|struct
name|hesiod_p
operator|*
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|get_txt_records
name|__P
argument_list|(
operator|(
name|int
operator|,
specifier|const
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|init_context
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|translate_errors
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * hesiod_init --  *	initialize a hesiod_p.  */
end_comment

begin_function
name|int
name|hesiod_init
parameter_list|(
name|context
parameter_list|)
name|void
modifier|*
modifier|*
name|context
decl_stmt|;
block|{
name|struct
name|hesiod_p
modifier|*
name|ctx
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|configname
decl_stmt|;
name|int
name|trust
decl_stmt|;
name|trust
operator|=
name|geteuid
argument_list|()
operator|==
name|getuid
argument_list|()
operator|&&
name|getegid
argument_list|()
operator|==
name|getgid
argument_list|()
expr_stmt|;
name|ctx
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hesiod_p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
condition|)
block|{
operator|*
name|context
operator|=
name|ctx
expr_stmt|;
if|if
condition|(
name|trust
condition|)
name|configname
operator|=
name|getenv
argument_list|(
literal|"HESIOD_CONFIG"
argument_list|)
expr_stmt|;
else|else
name|configname
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|configname
condition|)
name|configname
operator|=
name|_PATH_HESIOD_CONF
expr_stmt|;
if|if
condition|(
name|read_config_file
argument_list|(
name|ctx
argument_list|,
name|configname
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* 			 * The default rhs can be overridden by an 			 * environment variable. 			 */
if|if
condition|(
name|trust
condition|)
name|p
operator|=
name|getenv
argument_list|(
literal|"HES_DOMAIN"
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|rhs
condition|)
name|free
argument_list|(
name|ctx
operator|->
name|rhs
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|rhs
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|rhs
condition|)
block|{
operator|*
name|ctx
operator|->
name|rhs
operator|=
literal|'.'
expr_stmt|;
name|strcpy
argument_list|(
name|ctx
operator|->
name|rhs
operator|+
literal|1
argument_list|,
operator|(
operator|*
name|p
operator|==
literal|'.'
operator|)
condition|?
name|p
operator|+
literal|1
else|:
name|p
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
name|errno
operator|=
name|ENOMEM
expr_stmt|;
block|}
else|else
return|return
literal|0
return|;
block|}
block|}
else|else
name|errno
operator|=
name|ENOMEM
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|lhs
condition|)
name|free
argument_list|(
name|ctx
operator|->
name|lhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|rhs
condition|)
name|free
argument_list|(
name|ctx
operator|->
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
condition|)
name|free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * hesiod_end --  *	Deallocates the hesiod_p.  */
end_comment

begin_function
name|void
name|hesiod_end
parameter_list|(
name|context
parameter_list|)
name|void
modifier|*
name|context
decl_stmt|;
block|{
name|struct
name|hesiod_p
modifier|*
name|ctx
init|=
operator|(
expr|struct
name|hesiod_p
operator|*
operator|)
name|context
decl_stmt|;
name|free
argument_list|(
name|ctx
operator|->
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|lhs
condition|)
name|free
argument_list|(
name|ctx
operator|->
name|lhs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * hesiod_to_bind --  * 	takes a hesiod (name, type) and returns a DNS  *	name which is to be resolved.  */
end_comment

begin_function
name|char
modifier|*
name|hesiod_to_bind
parameter_list|(
name|void
modifier|*
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|type
parameter_list|)
block|{
name|struct
name|hesiod_p
modifier|*
name|ctx
init|=
operator|(
expr|struct
name|hesiod_p
operator|*
operator|)
name|context
decl_stmt|;
name|char
name|bindname
index|[
name|MAXDNAME
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|ret
decl_stmt|,
modifier|*
modifier|*
name|rhs_list
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|rhs
decl_stmt|;
name|int
name|len
decl_stmt|;
name|strcpy
argument_list|(
name|bindname
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* 		 * Find the right right hand side to use, possibly 		 * truncating bindname. 		 */
name|p
operator|=
name|strchr
argument_list|(
name|bindname
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|p
argument_list|,
literal|'.'
argument_list|)
condition|)
name|rhs
operator|=
name|name
operator|+
operator|(
name|p
operator|-
name|bindname
operator|)
expr_stmt|;
else|else
block|{
name|rhs_list
operator|=
name|hesiod_resolve
argument_list|(
name|context
argument_list|,
name|p
argument_list|,
literal|"rhs-extension"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rhs_list
condition|)
name|rhs
operator|=
operator|*
name|rhs_list
expr_stmt|;
else|else
block|{
name|errno
operator|=
name|ENOENT
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
block|}
else|else
name|rhs
operator|=
name|ctx
operator|->
name|rhs
expr_stmt|;
comment|/* See if we have enough room. */
name|len
operator|=
name|strlen
argument_list|(
name|bindname
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|lhs
condition|)
name|len
operator|+=
name|strlen
argument_list|(
name|ctx
operator|->
name|lhs
argument_list|)
operator|+
operator|(
operator|(
name|ctx
operator|->
name|lhs
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|len
operator|+=
name|strlen
argument_list|(
name|rhs
argument_list|)
operator|+
operator|(
operator|(
name|rhs
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|bindname
argument_list|)
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|rhs_list
condition|)
name|hesiod_free_list
argument_list|(
name|context
argument_list|,
name|rhs_list
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EMSGSIZE
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Put together the rest of the domain. */
name|strcat
argument_list|(
name|bindname
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|bindname
argument_list|,
name|type
argument_list|)
expr_stmt|;
comment|/* Only append lhs if it isn't empty. */
if|if
condition|(
name|ctx
operator|->
name|lhs
operator|&&
name|ctx
operator|->
name|lhs
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|lhs
index|[
literal|0
index|]
operator|!=
literal|'.'
condition|)
name|strcat
argument_list|(
name|bindname
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|bindname
argument_list|,
name|ctx
operator|->
name|lhs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rhs
index|[
literal|0
index|]
operator|!=
literal|'.'
condition|)
name|strcat
argument_list|(
name|bindname
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|bindname
argument_list|,
name|rhs
argument_list|)
expr_stmt|;
comment|/* rhs_list is no longer needed, since we're done with rhs. */
if|if
condition|(
name|rhs_list
condition|)
name|hesiod_free_list
argument_list|(
name|context
argument_list|,
name|rhs_list
argument_list|)
expr_stmt|;
comment|/* Make a copy of the result and return it to the caller. */
name|ret
operator|=
name|strdup
argument_list|(
name|bindname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * hesiod_resolve --  *	Given a hesiod name and type, return an array of strings returned  *	by the resolver.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|hesiod_resolve
parameter_list|(
name|context
parameter_list|,
name|name
parameter_list|,
name|type
parameter_list|)
name|void
modifier|*
name|context
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|type
decl_stmt|;
block|{
name|struct
name|hesiod_p
modifier|*
name|ctx
init|=
operator|(
expr|struct
name|hesiod_p
operator|*
operator|)
name|context
decl_stmt|;
name|char
modifier|*
name|bindname
decl_stmt|,
modifier|*
modifier|*
name|retvec
decl_stmt|;
name|bindname
operator|=
name|hesiod_to_bind
argument_list|(
name|context
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bindname
condition|)
return|return
name|NULL
return|;
name|retvec
operator|=
name|get_txt_records
argument_list|(
name|ctx
operator|->
name|classes
index|[
literal|0
index|]
argument_list|,
name|bindname
argument_list|)
expr_stmt|;
if|if
condition|(
name|retvec
operator|==
name|NULL
operator|&&
name|errno
operator|==
name|ENOENT
operator|&&
name|ctx
operator|->
name|classes
index|[
literal|1
index|]
condition|)
name|retvec
operator|=
name|get_txt_records
argument_list|(
name|ctx
operator|->
name|classes
index|[
literal|1
index|]
argument_list|,
name|bindname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bindname
argument_list|)
expr_stmt|;
return|return
name|retvec
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|hesiod_free_list
parameter_list|(
name|context
parameter_list|,
name|list
parameter_list|)
name|void
modifier|*
name|context
decl_stmt|;
name|char
modifier|*
modifier|*
name|list
decl_stmt|;
block|{
name|char
modifier|*
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|p
operator|=
name|list
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
name|free
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* read_config_file --  *	Parse the /etc/hesiod.conf file.  Returns 0 on success,  *	-1 on failure.  On failure, it might leave values in ctx->lhs  *	or ctx->rhs which need to be freed by the caller.  */
end_comment

begin_function
specifier|static
name|int
name|read_config_file
parameter_list|(
name|ctx
parameter_list|,
name|filename
parameter_list|)
name|struct
name|hesiod_p
modifier|*
name|ctx
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|char
modifier|*
name|key
decl_stmt|,
modifier|*
name|data
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|which
decl_stmt|;
name|char
name|buf
index|[
name|MAXDNAME
operator|+
literal|7
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* Set default query classes. */
name|ctx
operator|->
name|classes
index|[
literal|0
index|]
operator|=
name|C_IN
expr_stmt|;
name|ctx
operator|->
name|classes
index|[
literal|1
index|]
operator|=
name|C_HS
expr_stmt|;
comment|/* Try to open the configuration file. */
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
comment|/* Use compiled in default domain names. */
name|ctx
operator|->
name|lhs
operator|=
name|strdup
argument_list|(
name|DEF_LHS
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|rhs
operator|=
name|strdup
argument_list|(
name|DEF_RHS
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|lhs
operator|&&
name|ctx
operator|->
name|rhs
condition|)
return|return
literal|0
return|;
else|else
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|ctx
operator|->
name|lhs
operator|=
name|NULL
expr_stmt|;
name|ctx
operator|->
name|rhs
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|buf
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'#'
operator|||
operator|*
name|p
operator|==
literal|'\n'
operator|||
operator|*
name|p
operator|==
literal|'\r'
condition|)
continue|continue;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
name|key
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|' '
operator|&&
operator|*
name|p
operator|!=
literal|'\t'
operator|&&
operator|*
name|p
operator|!=
literal|'='
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
operator|||
operator|*
name|p
operator|==
literal|'='
condition|)
name|p
operator|++
expr_stmt|;
name|data
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|p
argument_list|)
condition|)
name|p
operator|++
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|key
argument_list|,
literal|"lhs"
argument_list|)
operator|==
literal|0
operator|||
name|strcasecmp
argument_list|(
name|key
argument_list|,
literal|"rhs"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|which
operator|=
operator|(
name|strcasecmp
argument_list|(
name|key
argument_list|,
literal|"lhs"
argument_list|)
operator|==
literal|0
operator|)
condition|?
operator|&
name|ctx
operator|->
name|lhs
else|:
operator|&
name|ctx
operator|->
name|rhs
expr_stmt|;
operator|*
name|which
operator|=
name|strdup
argument_list|(
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|which
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|key
argument_list|,
literal|"classes"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|data
operator|&&
name|n
operator|<
literal|2
condition|)
block|{
name|p
operator|=
name|data
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|','
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
condition|)
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|data
argument_list|,
literal|"IN"
argument_list|)
operator|==
literal|0
condition|)
name|ctx
operator|->
name|classes
index|[
name|n
operator|++
index|]
operator|=
name|C_IN
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|data
argument_list|,
literal|"HS"
argument_list|)
operator|==
literal|0
condition|)
name|ctx
operator|->
name|classes
index|[
name|n
operator|++
index|]
operator|=
name|C_HS
expr_stmt|;
name|data
operator|=
name|p
expr_stmt|;
block|}
while|while
condition|(
name|n
operator|<
literal|2
condition|)
name|ctx
operator|->
name|classes
index|[
name|n
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|rhs
operator|||
name|ctx
operator|->
name|classes
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|ctx
operator|->
name|classes
index|[
literal|0
index|]
operator|==
name|ctx
operator|->
name|classes
index|[
literal|1
index|]
condition|)
block|{
name|errno
operator|=
name|ENOEXEC
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * get_txt_records --  *	Given a DNS class and a DNS name, do a lookup for TXT records, and  *	return a list of them.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
modifier|*
name|get_txt_records
parameter_list|(
name|qclass
parameter_list|,
name|name
parameter_list|)
name|int
name|qclass
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|unsigned
name|char
name|qbuf
index|[
name|PACKETSZ
index|]
decl_stmt|,
name|abuf
index|[
name|MAX_HESRESP
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|eom
decl_stmt|,
modifier|*
name|eor
decl_stmt|;
name|char
modifier|*
name|dst
decl_stmt|,
modifier|*
modifier|*
name|list
decl_stmt|;
name|int
name|ancount
decl_stmt|,
name|qdcount
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
decl_stmt|,
name|skip
decl_stmt|,
name|type
decl_stmt|,
name|class
decl_stmt|,
name|len
decl_stmt|;
comment|/* Make sure the resolver is initialized. */
if|if
condition|(
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_INIT
operator|)
operator|==
literal|0
operator|&&
name|res_init
argument_list|()
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
comment|/* Construct the query. */
name|n
operator|=
name|res_mkquery
argument_list|(
name|QUERY
argument_list|,
name|name
argument_list|,
name|qclass
argument_list|,
name|T_TXT
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|qbuf
argument_list|,
name|PACKETSZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
comment|/* Send the query. */
name|n
operator|=
name|res_send
argument_list|(
name|qbuf
argument_list|,
name|n
argument_list|,
name|abuf
argument_list|,
name|MAX_HESRESP
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
name|ECONNREFUSED
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Parse the header of the result. */
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|abuf
expr_stmt|;
name|ancount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|qdcount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|qdcount
argument_list|)
expr_stmt|;
name|p
operator|=
name|abuf
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
expr_stmt|;
name|eom
operator|=
name|abuf
operator|+
name|n
expr_stmt|;
comment|/* 		 * Skip questions, trying to get to the answer section 		 * which follows. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qdcount
condition|;
name|i
operator|++
control|)
block|{
name|skip
operator|=
name|dn_skipname
argument_list|(
name|p
argument_list|,
name|eom
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip
operator|<
literal|0
operator|||
name|p
operator|+
name|skip
operator|+
name|QFIXEDSZ
operator|>
name|eom
condition|)
block|{
name|errno
operator|=
name|EMSGSIZE
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|p
operator|+=
name|skip
operator|+
name|QFIXEDSZ
expr_stmt|;
block|}
comment|/* Allocate space for the text record answers. */
name|list
operator|=
name|malloc
argument_list|(
operator|(
name|ancount
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|list
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* Parse the answers. */
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ancount
condition|;
name|i
operator|++
control|)
block|{
comment|/* Parse the header of this answer. */
name|skip
operator|=
name|dn_skipname
argument_list|(
name|p
argument_list|,
name|eom
argument_list|)
expr_stmt|;
if|if
condition|(
name|skip
operator|<
literal|0
operator|||
name|p
operator|+
name|skip
operator|+
literal|10
operator|>
name|eom
condition|)
break|break;
name|type
operator|=
name|p
index|[
name|skip
operator|+
literal|0
index|]
operator|<<
literal|8
operator||
name|p
index|[
name|skip
operator|+
literal|1
index|]
expr_stmt|;
name|class
operator|=
name|p
index|[
name|skip
operator|+
literal|2
index|]
operator|<<
literal|8
operator||
name|p
index|[
name|skip
operator|+
literal|3
index|]
expr_stmt|;
name|len
operator|=
name|p
index|[
name|skip
operator|+
literal|8
index|]
operator|<<
literal|8
operator||
name|p
index|[
name|skip
operator|+
literal|9
index|]
expr_stmt|;
name|p
operator|+=
name|skip
operator|+
literal|10
expr_stmt|;
if|if
condition|(
name|p
operator|+
name|len
operator|>
name|eom
condition|)
block|{
name|errno
operator|=
name|EMSGSIZE
expr_stmt|;
break|break;
block|}
comment|/* Skip entries of the wrong class and type. */
if|if
condition|(
name|class
operator|!=
name|qclass
operator|||
name|type
operator|!=
name|T_TXT
condition|)
block|{
name|p
operator|+=
name|len
expr_stmt|;
continue|continue;
block|}
comment|/* Allocate space for this answer. */
name|list
index|[
name|j
index|]
operator|=
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|list
index|[
name|j
index|]
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
break|break;
block|}
name|dst
operator|=
name|list
index|[
name|j
operator|++
index|]
expr_stmt|;
comment|/* Copy answer data into the allocated area. */
name|eor
operator|=
name|p
operator|+
name|len
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|eor
condition|)
block|{
name|n
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|+
name|n
operator|>
name|eor
condition|)
block|{
name|errno
operator|=
name|EMSGSIZE
expr_stmt|;
break|break;
block|}
name|memcpy
argument_list|(
name|dst
argument_list|,
name|p
argument_list|,
operator|(
name|size_t
operator|)
name|n
argument_list|)
expr_stmt|;
name|p
operator|+=
name|n
expr_stmt|;
name|dst
operator|+=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|<
name|eor
condition|)
block|{
name|errno
operator|=
name|EMSGSIZE
expr_stmt|;
break|break;
block|}
operator|*
name|dst
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * If we didn't terminate the loop normally, something 		 * went wrong. 		 */
if|if
condition|(
name|i
operator|<
name|ancount
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|j
condition|;
name|i
operator|++
control|)
name|free
argument_list|(
name|list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|j
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|ENOENT
expr_stmt|;
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|list
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|list
return|;
block|}
end_function

begin_comment
comment|/* 		 *	COMPATIBILITY FUNCTIONS 		 */
end_comment

begin_decl_stmt
specifier|static
name|int
name|inited
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|context
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|errval
init|=
name|HES_ER_UNINIT
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|hes_init
parameter_list|()
block|{
name|init_context
argument_list|()
expr_stmt|;
return|return
name|errval
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|hes_to_bind
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|type
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
name|bindname
decl_stmt|;
if|if
condition|(
name|init_context
argument_list|()
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|bindname
condition|)
name|free
argument_list|(
name|bindname
argument_list|)
expr_stmt|;
name|bindname
operator|=
name|hesiod_to_bind
argument_list|(
name|context
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bindname
condition|)
name|translate_errors
argument_list|()
expr_stmt|;
return|return
name|bindname
return|;
block|}
end_function

begin_function
name|char
modifier|*
modifier|*
name|hes_resolve
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|type
decl_stmt|;
block|{
specifier|static
name|char
modifier|*
modifier|*
name|list
decl_stmt|;
if|if
condition|(
name|init_context
argument_list|()
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
comment|/* 	 * In the old Hesiod interface, the caller was responsible for 	 * freeing the returned strings but not the vector of strings itself. 	 */
if|if
condition|(
name|list
condition|)
name|free
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|list
operator|=
name|hesiod_resolve
argument_list|(
name|context
argument_list|,
name|name
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|list
condition|)
name|translate_errors
argument_list|()
expr_stmt|;
return|return
name|list
return|;
block|}
end_function

begin_function
name|int
name|hes_error
parameter_list|()
block|{
return|return
name|errval
return|;
block|}
end_function

begin_function
name|void
name|hes_free
parameter_list|(
name|hp
parameter_list|)
name|char
modifier|*
modifier|*
name|hp
decl_stmt|;
block|{
name|hesiod_free_list
argument_list|(
name|context
argument_list|,
name|hp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|init_context
parameter_list|()
block|{
if|if
condition|(
operator|!
name|inited
condition|)
block|{
name|inited
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|hesiod_init
argument_list|(
operator|&
name|context
argument_list|)
operator|<
literal|0
condition|)
block|{
name|errval
operator|=
name|HES_ER_CONFIG
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|errval
operator|=
name|HES_ER_OK
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|translate_errors
parameter_list|()
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOENT
case|:
name|errval
operator|=
name|HES_ER_NOTFOUND
expr_stmt|;
break|break;
case|case
name|ECONNREFUSED
case|:
case|case
name|EMSGSIZE
case|:
name|errval
operator|=
name|HES_ER_NET
expr_stmt|;
break|break;
case|case
name|ENOMEM
case|:
default|default:
comment|/* Not a good match, but the best we can do. */
name|errval
operator|=
name|HES_ER_CONFIG
expr_stmt|;
break|break;
block|}
block|}
end_function

end_unit

