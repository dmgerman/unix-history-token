begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1996 by Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS  * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE  * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Based on the Dynamic DNS reference implementation by Viraj Bais  *<viraj_bais@ccm.fm.intel.com>  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/*  * Separate a linked list of records into groups so that all records  * in a group will belong to a single zone on the nameserver.  * Create a dynamic update packet for each zone and send it to the  * nameservers for that zone, and await answer.  * Abort if error occurs in updating any zone.  * Return the number of zones updated on success,< 0 on error.  *  * On error, caller must deal with the unsynchronized zones  * eg. an A record might have been successfully added to the forward  * zone but the corresponding PTR record would be missing if error  * was encountered while updating the reverse zone.  */
end_comment

begin_define
define|#
directive|define
name|NSMAX
value|16
end_define

begin_struct
struct|struct
name|ns1
block|{
name|char
name|nsname
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|struct
name|in_addr
name|nsaddr1
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|zonegrp
block|{
name|char
name|z_origin
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|int16_t
name|z_class
decl_stmt|;
name|char
name|z_soardata
index|[
name|MAXDNAME
operator|+
literal|5
operator|*
name|INT32SZ
index|]
decl_stmt|;
name|struct
name|ns1
name|z_ns
index|[
name|NSMAX
index|]
decl_stmt|;
name|int
name|z_nscount
decl_stmt|;
name|ns_updrec
modifier|*
name|z_rr
decl_stmt|;
name|struct
name|zonegrp
modifier|*
name|z_next
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|int
name|res_update
parameter_list|(
name|ns_updrec
modifier|*
name|rrecp_in
parameter_list|)
block|{
name|ns_updrec
modifier|*
name|rrecp
decl_stmt|,
modifier|*
name|tmprrecp
decl_stmt|;
name|u_char
name|buf
index|[
name|PACKETSZ
index|]
decl_stmt|,
name|answer
index|[
name|PACKETSZ
index|]
decl_stmt|,
name|packet
index|[
literal|2
operator|*
name|PACKETSZ
index|]
decl_stmt|;
name|char
name|name
index|[
name|MAXDNAME
index|]
decl_stmt|,
name|zname
index|[
name|MAXDNAME
index|]
decl_stmt|,
name|primary
index|[
name|MAXDNAME
index|]
decl_stmt|,
name|mailaddr
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|u_char
name|soardata
index|[
literal|2
operator|*
name|MAXCDNAME
operator|+
literal|5
operator|*
name|INT32SZ
index|]
decl_stmt|;
name|char
modifier|*
name|dname
decl_stmt|,
modifier|*
name|svdname
decl_stmt|,
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|target
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|eom
decl_stmt|;
name|HEADER
modifier|*
name|hp
init|=
operator|(
name|HEADER
operator|*
operator|)
name|answer
decl_stmt|;
name|struct
name|zonegrp
modifier|*
name|zptr
init|=
name|NULL
decl_stmt|,
modifier|*
name|tmpzptr
decl_stmt|,
modifier|*
name|prevzptr
decl_stmt|,
modifier|*
name|zgrp_start
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
init|=
literal|0
decl_stmt|,
name|n
decl_stmt|,
name|ancount
decl_stmt|,
name|nscount
decl_stmt|,
name|arcount
decl_stmt|,
name|rcode
decl_stmt|,
name|rdatasize
decl_stmt|,
name|newgroup
decl_stmt|,
name|done
decl_stmt|,
name|myzone
decl_stmt|,
name|seen_before
decl_stmt|,
name|numzones
init|=
literal|0
decl_stmt|;
name|u_int16_t
name|dlen
decl_stmt|,
name|class
decl_stmt|,
name|qclass
decl_stmt|,
name|type
decl_stmt|,
name|qtype
decl_stmt|;
name|u_int32_t
name|ttl
decl_stmt|;
if|if
condition|(
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_INIT
operator|)
operator|==
literal|0
operator|&&
name|res_init
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
name|h_errno
operator|=
name|NETDB_INTERNAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|rrecp
operator|=
name|rrecp_in
init|;
name|rrecp
condition|;
name|rrecp
operator|=
name|rrecp
operator|->
name|r_next
control|)
block|{
name|dname
operator|=
name|rrecp
operator|->
name|r_dname
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|dname
index|[
name|n
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
name|dname
index|[
name|n
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|qtype
operator|=
name|T_SOA
expr_stmt|;
name|qclass
operator|=
name|rrecp
operator|->
name|r_class
expr_stmt|;
name|done
operator|=
literal|0
expr_stmt|;
name|seen_before
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|done
operator|&&
name|dname
condition|)
block|{
if|if
condition|(
name|qtype
operator|==
name|T_SOA
condition|)
block|{
for|for
control|(
name|tmpzptr
operator|=
name|zgrp_start
init|;
name|tmpzptr
operator|&&
operator|!
name|seen_before
condition|;
name|tmpzptr
operator|=
name|tmpzptr
operator|->
name|z_next
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|dname
argument_list|,
name|tmpzptr
operator|->
name|z_origin
argument_list|)
operator|==
literal|0
operator|&&
name|tmpzptr
operator|->
name|z_class
operator|==
name|qclass
condition|)
name|seen_before
operator|++
expr_stmt|;
for|for
control|(
name|tmprrecp
operator|=
name|tmpzptr
operator|->
name|z_rr
init|;
name|tmprrecp
operator|&&
operator|!
name|seen_before
condition|;
name|tmprrecp
operator|=
name|tmprrecp
operator|->
name|r_grpnext
control|)
if|if
condition|(
name|strcasecmp
argument_list|(
name|dname
argument_list|,
name|tmprrecp
operator|->
name|r_dname
argument_list|)
operator|==
literal|0
operator|&&
name|tmprrecp
operator|->
name|r_class
operator|==
name|qclass
condition|)
block|{
name|seen_before
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|seen_before
condition|)
block|{
comment|/* 					 * Append to the end of 					 * current group. 					 */
for|for
control|(
name|tmprrecp
operator|=
name|tmpzptr
operator|->
name|z_rr
init|;
name|tmprrecp
operator|->
name|r_grpnext
condition|;
name|tmprrecp
operator|=
name|tmprrecp
operator|->
name|r_grpnext
control|)
operator|(
name|void
operator|)
name|NULL
expr_stmt|;
name|tmprrecp
operator|->
name|r_grpnext
operator|=
name|rrecp
expr_stmt|;
name|rrecp
operator|->
name|r_grpnext
operator|=
name|NULL
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|qtype
operator|==
name|T_A
condition|)
block|{
for|for
control|(
name|tmpzptr
operator|=
name|zgrp_start
init|;
name|tmpzptr
operator|&&
operator|!
name|done
condition|;
name|tmpzptr
operator|=
name|tmpzptr
operator|->
name|z_next
control|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tmpzptr
operator|->
name|z_nscount
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|tmpzptr
operator|->
name|z_class
operator|==
name|qclass
operator|&&
name|strcasecmp
argument_list|(
name|tmpzptr
operator|->
name|z_ns
index|[
name|i
index|]
operator|.
name|nsname
argument_list|,
name|dname
argument_list|)
operator|==
literal|0
operator|&&
name|tmpzptr
operator|->
name|z_ns
index|[
name|i
index|]
operator|.
name|nsaddr1
operator|.
name|s_addr
operator|!=
literal|0
condition|)
block|{
name|zptr
operator|->
name|z_ns
index|[
name|k
index|]
operator|.
name|nsaddr1
operator|.
name|s_addr
operator|=
name|tmpzptr
operator|->
name|z_ns
index|[
name|i
index|]
operator|.
name|nsaddr1
operator|.
name|s_addr
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|done
condition|)
break|break;
name|n
operator|=
name|res_mkquery
argument_list|(
name|QUERY
argument_list|,
name|dname
argument_list|,
name|qclass
argument_list|,
name|qtype
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"res_update: mkquery failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
name|n
operator|=
name|res_send
argument_list|(
name|buf
argument_list|,
name|n
argument_list|,
name|answer
argument_list|,
sizeof|sizeof
name|answer
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"res_update: send error for %s\n"
argument_list|,
name|rrecp
operator|->
name|r_dname
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|<
name|HFIXEDSZ
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|ancount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|nscount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|nscount
argument_list|)
expr_stmt|;
name|arcount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|arcount
argument_list|)
expr_stmt|;
name|rcode
operator|=
name|hp
operator|->
name|rcode
expr_stmt|;
name|cp
operator|=
name|answer
operator|+
name|HFIXEDSZ
expr_stmt|;
name|eom
operator|=
name|answer
operator|+
name|n
expr_stmt|;
comment|/* skip the question section */
name|n
operator|=
name|dn_skipname
argument_list|(
name|cp
argument_list|,
name|eom
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|cp
operator|+
name|n
operator|+
literal|2
operator|*
name|INT16SZ
operator|>
name|eom
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|+=
name|n
operator|+
literal|2
operator|*
name|INT16SZ
expr_stmt|;
if|if
condition|(
name|qtype
operator|==
name|T_SOA
condition|)
block|{
if|if
condition|(
name|ancount
operator|==
literal|0
operator|&&
name|nscount
operator|==
literal|0
operator|&&
name|arcount
operator|==
literal|0
condition|)
block|{
comment|/* 			 * if (rcode == NOERROR) then the dname exists but 			 * has no soa record associated with it. 			 * if (rcode == NXDOMAIN) then the dname does not 			 * exist and the server is replying out of NCACHE. 			 * in either case, proceed with the next try 			 */
name|dname
operator|=
name|strchr
argument_list|(
name|dname
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|dname
operator|!=
name|NULL
condition|)
name|dname
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|(
name|rcode
operator|==
name|NOERROR
operator|||
name|rcode
operator|==
name|NXDOMAIN
operator|)
operator|&&
name|ancount
operator|==
literal|0
operator|&&
name|nscount
operator|==
literal|1
operator|&&
name|arcount
operator|==
literal|0
condition|)
block|{
comment|/* 			 * name/data does not exist, soa record supplied in the 			 * authority section 			 */
comment|/* authority section must contain the soa record */
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
name|answer
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
name|zname
argument_list|,
sizeof|sizeof
name|zname
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|n
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|cp
operator|+
literal|2
operator|*
name|INT16SZ
operator|>
name|eom
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|GETSHORT
argument_list|(
name|type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|T_SOA
operator|||
name|class
operator|!=
name|qclass
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unknown answer\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|myzone
operator|=
literal|0
expr_stmt|;
name|svdname
operator|=
name|dname
expr_stmt|;
while|while
condition|(
name|dname
condition|)
if|if
condition|(
name|strcasecmp
argument_list|(
name|dname
argument_list|,
name|zname
argument_list|)
operator|==
literal|0
condition|)
block|{
name|myzone
operator|=
literal|1
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|dname
operator|=
name|strchr
argument_list|(
name|dname
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|dname
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|myzone
condition|)
block|{
name|dname
operator|=
name|strchr
argument_list|(
name|svdname
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|dname
operator|!=
name|NULL
condition|)
name|dname
operator|++
expr_stmt|;
continue|continue;
block|}
name|nscount
operator|=
literal|0
expr_stmt|;
comment|/* fallthrough */
block|}
elseif|else
if|if
condition|(
name|rcode
operator|==
name|NOERROR
operator|&&
name|ancount
operator|==
literal|1
condition|)
block|{
comment|/* 			 * found the zone name 			 * new servers will supply NS records for the zone 			 * in authority section and A records for those  			 * nameservers in the additional section 			 * older servers have to be explicitly queried for 			 * NS records for the zone 			 */
comment|/* answer section must contain the soa record */
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
name|answer
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
name|zname
argument_list|,
sizeof|sizeof
name|zname
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|n
operator|)
return|;
else|else
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|cp
operator|+
literal|2
operator|*
name|INT16SZ
operator|>
name|eom
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|GETSHORT
argument_list|(
name|type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_CNAME
condition|)
block|{
name|dname
operator|=
name|strchr
argument_list|(
name|dname
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|dname
operator|!=
name|NULL
condition|)
name|dname
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strcasecmp
argument_list|(
name|dname
argument_list|,
name|zname
argument_list|)
operator|!=
literal|0
operator|||
name|type
operator|!=
name|T_SOA
operator|||
name|class
operator|!=
name|rrecp
operator|->
name|r_class
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unknown answer\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* FALLTHROUGH */
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unknown response: ans=%d, auth=%d, add=%d, rcode=%d\n"
argument_list|,
name|ancount
argument_list|,
name|nscount
argument_list|,
name|arcount
argument_list|,
name|hp
operator|->
name|rcode
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|cp
operator|+
name|INT32SZ
operator|+
name|INT16SZ
operator|>
name|eom
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* continue processing the soa record */
name|GETLONG
argument_list|(
name|ttl
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|dlen
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|+
name|dlen
operator|>
name|eom
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|newgroup
operator|=
literal|1
expr_stmt|;
name|zptr
operator|=
name|zgrp_start
expr_stmt|;
name|prevzptr
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|zptr
condition|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|zname
argument_list|,
name|zptr
operator|->
name|z_origin
argument_list|)
operator|==
literal|0
operator|&&
name|type
operator|==
name|T_SOA
operator|&&
name|class
operator|==
name|qclass
condition|)
block|{
name|newgroup
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|prevzptr
operator|=
name|zptr
expr_stmt|;
name|zptr
operator|=
name|zptr
operator|->
name|z_next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|newgroup
condition|)
block|{
for|for
control|(
name|tmprrecp
operator|=
name|zptr
operator|->
name|z_rr
init|;
name|tmprrecp
operator|->
name|r_grpnext
condition|;
name|tmprrecp
operator|=
name|tmprrecp
operator|->
name|r_grpnext
control|)
empty_stmt|;
name|tmprrecp
operator|->
name|r_grpnext
operator|=
name|rrecp
expr_stmt|;
name|rrecp
operator|->
name|r_grpnext
operator|=
name|NULL
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
name|cp
operator|+=
name|dlen
expr_stmt|;
break|break;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
name|answer
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
name|primary
argument_list|,
sizeof|sizeof
name|primary
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|n
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
comment|/*  			 * We don't have to bounds check here because the 			 * next use of 'cp' is in dn_expand(). 			 */
name|cp1
operator|=
operator|(
name|char
operator|*
operator|)
name|soardata
expr_stmt|;
name|strcpy
argument_list|(
name|cp1
argument_list|,
name|primary
argument_list|)
expr_stmt|;
name|cp1
operator|+=
name|strlen
argument_list|(
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
name|answer
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
name|mailaddr
argument_list|,
sizeof|sizeof
name|mailaddr
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|n
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
name|strcpy
argument_list|(
name|cp1
argument_list|,
name|mailaddr
argument_list|)
expr_stmt|;
name|cp1
operator|+=
name|strlen
argument_list|(
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|cp
operator|+
literal|5
operator|*
name|INT32SZ
operator|>
name|eom
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|memcpy
argument_list|(
name|cp1
argument_list|,
name|cp
argument_list|,
literal|5
operator|*
name|INT32SZ
argument_list|)
expr_stmt|;
name|cp
operator|+=
literal|5
operator|*
name|INT32SZ
expr_stmt|;
name|cp1
operator|+=
literal|5
operator|*
name|INT32SZ
expr_stmt|;
name|rdatasize
operator|=
operator|(
name|u_char
operator|*
operator|)
name|cp1
operator|-
name|soardata
expr_stmt|;
name|zptr
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|zonegrp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zptr
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|zgrp_start
operator|==
name|NULL
condition|)
name|zgrp_start
operator|=
name|zptr
expr_stmt|;
else|else
name|prevzptr
operator|->
name|z_next
operator|=
name|zptr
expr_stmt|;
name|zptr
operator|->
name|z_rr
operator|=
name|rrecp
expr_stmt|;
name|rrecp
operator|->
name|r_grpnext
operator|=
name|NULL
expr_stmt|;
name|strcpy
argument_list|(
name|zptr
operator|->
name|z_origin
argument_list|,
name|zname
argument_list|)
expr_stmt|;
name|zptr
operator|->
name|z_class
operator|=
name|class
expr_stmt|;
name|memcpy
argument_list|(
name|zptr
operator|->
name|z_soardata
argument_list|,
name|soardata
argument_list|,
name|rdatasize
argument_list|)
expr_stmt|;
comment|/* fallthrough to process NS and A records */
block|}
block|}
elseif|else
if|if
condition|(
name|qtype
operator|==
name|T_NS
condition|)
block|{
if|if
condition|(
name|rcode
operator|==
name|NOERROR
operator|&&
name|ancount
operator|>
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|zname
argument_list|,
name|dname
argument_list|)
expr_stmt|;
for|for
control|(
name|zptr
operator|=
name|zgrp_start
init|;
name|zptr
condition|;
name|zptr
operator|=
name|zptr
operator|->
name|z_next
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|zname
argument_list|,
name|zptr
operator|->
name|z_origin
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|zptr
operator|==
name|NULL
condition|)
comment|/* should not happen */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|nscount
operator|>
literal|0
condition|)
block|{
comment|/* 			     * answer and authority sections contain 			     * the same information, skip answer section 			     */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ancount
condition|;
name|j
operator|++
control|)
block|{
name|n
operator|=
name|dn_skipname
argument_list|(
name|cp
argument_list|,
name|eom
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|n
operator|+=
literal|2
operator|*
name|INT16SZ
operator|+
name|INT32SZ
expr_stmt|;
if|if
condition|(
name|cp
operator|+
name|n
operator|+
name|INT16SZ
operator|>
name|eom
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
name|GETSHORT
argument_list|(
name|dlen
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|dlen
expr_stmt|;
block|}
block|}
else|else
name|nscount
operator|=
name|ancount
expr_stmt|;
comment|/* fallthrough to process NS and A records */
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cannot determine nameservers for %s:\ ans=%d, auth=%d, add=%d, rcode=%d\n"
argument_list|,
name|dname
argument_list|,
name|ancount
argument_list|,
name|nscount
argument_list|,
name|arcount
argument_list|,
name|hp
operator|->
name|rcode
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|qtype
operator|==
name|T_A
condition|)
block|{
if|if
condition|(
name|rcode
operator|==
name|NOERROR
operator|&&
name|ancount
operator|>
literal|0
condition|)
block|{
name|arcount
operator|=
name|ancount
expr_stmt|;
name|ancount
operator|=
name|nscount
operator|=
literal|0
expr_stmt|;
comment|/* fallthrough to process A records */
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cannot determine address for %s:\ ans=%d, auth=%d, add=%d, rcode=%d\n"
argument_list|,
name|dname
argument_list|,
name|ancount
argument_list|,
name|nscount
argument_list|,
name|arcount
argument_list|,
name|hp
operator|->
name|rcode
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* process NS records for the zone */
name|j
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nscount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
name|answer
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|n
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|cp
operator|+
literal|3
operator|*
name|INT16SZ
operator|+
name|INT32SZ
operator|>
name|eom
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|GETSHORT
argument_list|(
name|type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|ttl
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|dlen
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|+
name|dlen
operator|>
name|eom
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|zname
argument_list|)
operator|==
literal|0
operator|&&
name|type
operator|==
name|T_NS
operator|&&
name|class
operator|==
name|qclass
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
name|answer
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|n
operator|)
return|;
name|target
operator|=
name|zptr
operator|->
name|z_ns
index|[
name|j
operator|++
index|]
operator|.
name|nsname
expr_stmt|;
name|strcpy
argument_list|(
name|target
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|cp
operator|+=
name|dlen
expr_stmt|;
block|}
if|if
condition|(
name|zptr
operator|->
name|z_nscount
operator|==
literal|0
condition|)
name|zptr
operator|->
name|z_nscount
operator|=
name|j
expr_stmt|;
comment|/* get addresses for the nameservers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|arcount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
name|answer
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|n
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|cp
operator|+
literal|3
operator|*
name|INT16SZ
operator|+
name|INT32SZ
operator|>
name|eom
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|GETSHORT
argument_list|(
name|type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|ttl
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|dlen
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|+
name|dlen
operator|>
name|eom
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|type
operator|==
name|T_A
operator|&&
name|dlen
operator|==
name|INT32SZ
operator|&&
name|class
operator|==
name|qclass
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|zptr
operator|->
name|z_nscount
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|zptr
operator|->
name|z_ns
index|[
name|j
index|]
operator|.
name|nsname
argument_list|)
operator|==
literal|0
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|zptr
operator|->
name|z_ns
index|[
name|j
index|]
operator|.
name|nsaddr1
operator|.
name|s_addr
argument_list|,
name|cp
argument_list|,
name|INT32SZ
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|cp
operator|+=
name|dlen
expr_stmt|;
block|}
if|if
condition|(
name|zptr
operator|->
name|z_nscount
operator|==
literal|0
condition|)
block|{
name|dname
operator|=
name|zname
expr_stmt|;
name|qtype
operator|=
name|T_NS
expr_stmt|;
continue|continue;
block|}
name|done
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|zptr
operator|->
name|z_nscount
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|zptr
operator|->
name|z_ns
index|[
name|k
index|]
operator|.
name|nsaddr1
operator|.
name|s_addr
operator|==
literal|0
condition|)
block|{
name|done
operator|=
literal|0
expr_stmt|;
name|dname
operator|=
name|zptr
operator|->
name|z_ns
index|[
name|k
index|]
operator|.
name|nsname
expr_stmt|;
name|qtype
operator|=
name|T_A
expr_stmt|;
block|}
block|}
comment|/* while */
block|}
name|_res
operator|.
name|options
operator||=
name|RES_DEBUG
expr_stmt|;
for|for
control|(
name|zptr
operator|=
name|zgrp_start
init|;
name|zptr
condition|;
name|zptr
operator|=
name|zptr
operator|->
name|z_next
control|)
block|{
comment|/* append zone section */
name|rrecp
operator|=
name|res_mkupdrec
argument_list|(
name|ns_s_zn
argument_list|,
name|zptr
operator|->
name|z_origin
argument_list|,
name|zptr
operator|->
name|z_class
argument_list|,
name|ns_t_soa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrecp
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"saverrec error\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|rrecp
operator|->
name|r_grpnext
operator|=
name|zptr
operator|->
name|z_rr
expr_stmt|;
name|zptr
operator|->
name|z_rr
operator|=
name|rrecp
expr_stmt|;
name|n
operator|=
name|res_mkupdate
argument_list|(
name|zptr
operator|->
name|z_rr
argument_list|,
name|packet
argument_list|,
sizeof|sizeof
name|packet
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"res_mkupdate error\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"res_mkupdate: packet size = %d\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* 		 * Override the list of NS records from res_init() with 		 * the authoritative nameservers for the zone being updated. 		 * Sort primary to be the first in the list of nameservers. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|zptr
operator|->
name|z_nscount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|zptr
operator|->
name|z_ns
index|[
name|i
index|]
operator|.
name|nsname
argument_list|,
name|zptr
operator|->
name|z_soardata
argument_list|)
operator|==
literal|0
condition|)
block|{
name|struct
name|in_addr
name|tmpaddr
decl_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|zptr
operator|->
name|z_ns
index|[
name|i
index|]
operator|.
name|nsname
argument_list|,
name|zptr
operator|->
name|z_ns
index|[
literal|0
index|]
operator|.
name|nsname
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|zptr
operator|->
name|z_ns
index|[
literal|0
index|]
operator|.
name|nsname
argument_list|,
name|zptr
operator|->
name|z_soardata
argument_list|)
expr_stmt|;
name|tmpaddr
operator|=
name|zptr
operator|->
name|z_ns
index|[
name|i
index|]
operator|.
name|nsaddr1
expr_stmt|;
name|zptr
operator|->
name|z_ns
index|[
name|i
index|]
operator|.
name|nsaddr1
operator|=
name|zptr
operator|->
name|z_ns
index|[
literal|0
index|]
operator|.
name|nsaddr1
expr_stmt|;
name|zptr
operator|->
name|z_ns
index|[
literal|0
index|]
operator|.
name|nsaddr1
operator|=
name|tmpaddr
expr_stmt|;
block|}
break|break;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXNS
condition|;
name|i
operator|++
control|)
block|{
name|_res
operator|.
name|nsaddr_list
index|[
name|i
index|]
operator|.
name|sin_addr
operator|=
name|zptr
operator|->
name|z_ns
index|[
name|i
index|]
operator|.
name|nsaddr1
expr_stmt|;
name|_res
operator|.
name|nsaddr_list
index|[
name|i
index|]
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|_res
operator|.
name|nsaddr_list
index|[
name|i
index|]
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|NAMESERVER_PORT
argument_list|)
expr_stmt|;
block|}
name|_res
operator|.
name|nscount
operator|=
operator|(
name|zptr
operator|->
name|z_nscount
operator|<
name|MAXNS
operator|)
condition|?
name|zptr
operator|->
name|z_nscount
else|:
name|MAXNS
expr_stmt|;
name|n
operator|=
name|res_send
argument_list|(
name|packet
argument_list|,
name|n
argument_list|,
name|answer
argument_list|,
sizeof|sizeof
argument_list|(
name|answer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"res_send: send error, n=%d\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|numzones
operator|++
expr_stmt|;
block|}
comment|/* free malloc'ed memory */
while|while
condition|(
name|zgrp_start
condition|)
block|{
name|zptr
operator|=
name|zgrp_start
expr_stmt|;
name|zgrp_start
operator|=
name|zgrp_start
operator|->
name|z_next
expr_stmt|;
name|res_freeupdrec
argument_list|(
name|zptr
operator|->
name|z_rr
argument_list|)
expr_stmt|;
comment|/* Zone section we allocated. */
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|zptr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|numzones
operator|)
return|;
block|}
end_function

end_unit

