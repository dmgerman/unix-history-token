begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$KAME: name6.c,v 1.25 2000/06/26 16:44:40 itojun Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (C) 1995, 1996, 1997, 1998, and 1999 WIDE Project.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the project nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * ++Copyright++ 1985, 1988, 1993  * -  * Copyright (c) 1985, 1988, 1993  *    The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  * 	This product includes software developed by the University of  * 	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  * -  * Portions Copyright (c) 1993 by Digital Equipment Corporation.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies, and that  * the name of Digital Equipment Corporation not be used in advertising or  * publicity pertaining to distribution of the document or software without  * specific, written prior permission.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL  * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT  * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  * -  * --Copyright--  */
end_comment

begin_comment
comment|/*  *	Atsushi Onoe<onoe@sm.sony.co.jp>  */
end_comment

begin_comment
comment|/*  * TODO for thread safe  *	use mutex for _hostconf, _hostconf_init.  *	rewrite resolvers to be thread safe  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"namespace.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<nsswitch.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"un-namespace.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_PATH_HOSTS
end_ifndef

begin_define
define|#
directive|define
name|_PATH_HOSTS
value|"/etc/hosts"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAXALIASES
end_ifndef

begin_define
define|#
directive|define
name|MAXALIASES
value|10
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAXADDRS
end_ifndef

begin_define
define|#
directive|define
name|MAXADDRS
value|20
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAXDNAME
end_ifndef

begin_define
define|#
directive|define
name|MAXDNAME
value|1025
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_define
define|#
directive|define
name|ADDRLEN
parameter_list|(
name|af
parameter_list|)
value|((af) == AF_INET6 ? sizeof(struct in6_addr) : \ 					    sizeof(struct in_addr))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ADDRLEN
parameter_list|(
name|af
parameter_list|)
value|sizeof(struct in_addr)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAPADDR
parameter_list|(
name|ab
parameter_list|,
name|ina
parameter_list|)
define|\
value|do {									\ 	memcpy(&(ab)->map_inaddr, ina, sizeof(struct in_addr));		\ 	memset((ab)->map_zero, 0, sizeof((ab)->map_zero));		\ 	memset((ab)->map_one, 0xff, sizeof((ab)->map_one));		\ } while (0)
end_define

begin_define
define|#
directive|define
name|MAPADDRENABLED
parameter_list|(
name|flags
parameter_list|)
define|\
value|(((flags)& AI_V4MAPPED) || \ 	 (((flags)& AI_V4MAPPED_CFG)&& _mapped_addr_enabled()))
end_define

begin_union
union|union
name|inx_addr
block|{
name|struct
name|in_addr
name|in_addr
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|in6_addr
name|in6_addr
decl_stmt|;
endif|#
directive|endif
struct|struct
block|{
name|u_char
name|mau_zero
index|[
literal|10
index|]
decl_stmt|;
name|u_char
name|mau_one
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|in_addr
name|mau_inaddr
decl_stmt|;
block|}
name|map_addr_un
struct|;
define|#
directive|define
name|map_zero
value|map_addr_un.mau_zero
define|#
directive|define
name|map_one
value|map_addr_un.mau_one
define|#
directive|define
name|map_inaddr
value|map_addr_un.mau_inaddr
block|}
union|;
end_union

begin_function_decl
specifier|static
name|struct
name|hostent
modifier|*
name|_hpcopy
parameter_list|(
name|struct
name|hostent
modifier|*
name|hp
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|hostent
modifier|*
name|_hpaddr
parameter_list|(
name|int
name|af
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|hostent
modifier|*
name|_hpmerge
parameter_list|(
name|struct
name|hostent
modifier|*
name|hp1
parameter_list|,
name|struct
name|hostent
modifier|*
name|hp2
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function_decl
specifier|static
name|struct
name|hostent
modifier|*
name|_hpmapv6
parameter_list|(
name|struct
name|hostent
modifier|*
name|hp
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|struct
name|hostent
modifier|*
name|_hpsort
parameter_list|(
name|struct
name|hostent
modifier|*
name|hp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|hostent
modifier|*
name|_ghbyname
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|af
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|_hgetword
parameter_list|(
name|char
modifier|*
modifier|*
name|pp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_mapped_addr_enabled
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|FILE
modifier|*
name|_files_open
parameter_list|(
name|int
modifier|*
name|errp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_files_ghbyname
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|va_list
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_files_ghbyaddr
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|va_list
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_files_shent
parameter_list|(
name|int
name|stayopen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_files_ehent
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|YP
end_ifdef

begin_function_decl
specifier|static
name|int
name|_nis_ghbyname
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|va_list
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_nis_ghbyaddr
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|va_list
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|_dns_ghbyname
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|va_list
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_dns_ghbyaddr
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|va_list
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_dns_shent
parameter_list|(
name|int
name|stayopen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_dns_ehent
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|ICMPNL
end_ifdef

begin_function_decl
specifier|static
name|int
name|_icmp_ghbyaddr
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|va_list
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ICMPNL */
end_comment

begin_comment
comment|/* Host lookup order if nsswitch.conf is broken or nonexistant */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|ns_src
name|default_src
index|[]
init|=
block|{
block|{
name|NSSRC_FILES
block|,
name|NS_SUCCESS
block|}
block|,
block|{
name|NSSRC_DNS
block|,
name|NS_SUCCESS
block|}
block|,
ifdef|#
directive|ifdef
name|ICMPNL
define|#
directive|define
name|NSSRC_ICMP
value|"icmp"
block|{
name|NSSRC_ICMP
block|,
name|NS_SUCCESS
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Check if kernel supports mapped address.  *	implementation dependent  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__KAME__
end_ifdef

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __KAME__ */
end_comment

begin_function
specifier|static
name|int
name|_mapped_addr_enabled
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* implementation dependent check */
if|#
directive|if
name|defined
argument_list|(
name|__KAME__
argument_list|)
operator|&&
name|defined
argument_list|(
name|IPV6CTL_MAPPED_ADDR
argument_list|)
name|int
name|mib
index|[
literal|4
index|]
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|val
decl_stmt|;
name|mib
index|[
literal|0
index|]
operator|=
name|CTL_NET
expr_stmt|;
name|mib
index|[
literal|1
index|]
operator|=
name|PF_INET6
expr_stmt|;
name|mib
index|[
literal|2
index|]
operator|=
name|IPPROTO_IPV6
expr_stmt|;
name|mib
index|[
literal|3
index|]
operator|=
name|IPV6CTL_MAPPED_ADDR
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|4
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|len
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|&&
name|val
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
comment|/* __KAME__&& IPV6CTL_MAPPED_ADDR */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Functions defined in RFC2553  *	getipnodebyname, getipnodebyaddr, freehostent  */
end_comment

begin_function
specifier|static
name|struct
name|hostent
modifier|*
name|_ghbyname
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|af
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|int
name|rval
decl_stmt|;
specifier|static
specifier|const
name|ns_dtab
name|dtab
index|[]
init|=
block|{
name|NS_FILES_CB
argument_list|(
argument|_files_ghbyname
argument_list|,
argument|NULL
argument_list|)
block|{
name|NSSRC_DNS
block|,
name|_dns_ghbyname
block|,
name|NULL
block|}
block|,
name|NS_NIS_CB
argument_list|(
argument|_nis_ghbyname
argument_list|,
argument|NULL
argument_list|)
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|AI_ADDRCONFIG
condition|)
block|{
name|int
name|s
decl_stmt|;
comment|/* 		 * TODO: 		 * Note that implementation dependent test for address 		 * configuration should be done everytime called 		 * (or apropriate interval), 		 * because addresses will be dynamically assigned or deleted. 		 */
if|if
condition|(
name|af
operator|==
name|AF_UNSPEC
condition|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|_socket
argument_list|(
name|AF_INET6
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|af
operator|=
name|AF_INET
expr_stmt|;
else|else
block|{
name|_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|_socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|af
operator|=
name|AF_INET6
expr_stmt|;
else|else
name|_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|af
operator|!=
name|AF_UNSPEC
condition|)
block|{
if|if
condition|(
operator|(
name|s
operator|=
name|_socket
argument_list|(
name|af
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
name|_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
block|}
name|rval
operator|=
name|nsdispatch
argument_list|(
operator|&
name|hp
argument_list|,
name|dtab
argument_list|,
name|NSDB_HOSTS
argument_list|,
literal|"ghbyname"
argument_list|,
name|default_src
argument_list|,
name|name
argument_list|,
name|af
argument_list|,
name|errp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|==
name|NS_SUCCESS
operator|)
condition|?
name|hp
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* getipnodebyname() internal routine for multiple query(PF_UNSPEC) support. */
end_comment

begin_function
name|struct
name|hostent
modifier|*
name|_getipnodebyname_multi
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|af
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|union
name|inx_addr
name|addrbuf
decl_stmt|;
comment|/* XXX: PF_UNSPEC is only supposed to be passed from getaddrinfo() */
if|if
condition|(
name|af
operator|!=
name|AF_INET
ifdef|#
directive|ifdef
name|INET6
operator|&&
name|af
operator|!=
name|AF_INET6
endif|#
directive|endif
operator|&&
name|af
operator|!=
name|PF_UNSPEC
condition|)
block|{
operator|*
name|errp
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
name|NULL
return|;
block|}
ifdef|#
directive|ifdef
name|INET6
comment|/* special case for literal address */
if|if
condition|(
name|inet_pton
argument_list|(
name|AF_INET6
argument_list|,
name|name
argument_list|,
operator|&
name|addrbuf
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|af
operator|!=
name|AF_INET6
condition|)
block|{
operator|*
name|errp
operator|=
name|HOST_NOT_FOUND
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|_hpaddr
argument_list|(
name|af
argument_list|,
name|name
argument_list|,
operator|&
name|addrbuf
argument_list|,
name|errp
argument_list|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|inet_aton
argument_list|(
name|name
argument_list|,
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|&
name|addrbuf
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|af
operator|!=
name|AF_INET
condition|)
block|{
if|if
condition|(
name|MAPADDRENABLED
argument_list|(
name|flags
argument_list|)
condition|)
block|{
name|MAPADDR
argument_list|(
operator|&
name|addrbuf
argument_list|,
operator|&
name|addrbuf
operator|.
name|in_addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|errp
operator|=
name|HOST_NOT_FOUND
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
return|return
name|_hpaddr
argument_list|(
name|af
argument_list|,
name|name
argument_list|,
operator|&
name|addrbuf
argument_list|,
name|errp
argument_list|)
return|;
block|}
operator|*
name|errp
operator|=
name|HOST_NOT_FOUND
expr_stmt|;
name|hp
operator|=
name|_ghbyname
argument_list|(
name|name
argument_list|,
name|af
argument_list|,
name|flags
argument_list|,
name|errp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|af
operator|==
name|AF_INET6
operator|&&
operator|(
operator|(
name|flags
operator|&
name|AI_ALL
operator|)
operator|||
name|hp
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|MAPADDRENABLED
argument_list|(
name|flags
argument_list|)
operator|)
condition|)
block|{
name|struct
name|hostent
modifier|*
name|hp2
init|=
name|_ghbyname
argument_list|(
name|name
argument_list|,
name|AF_INET
argument_list|,
name|flags
argument_list|,
name|errp
argument_list|)
decl_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
name|hp
operator|=
name|_hpmapv6
argument_list|(
name|hp2
argument_list|,
name|errp
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|hp2
operator|&&
name|strcmp
argument_list|(
name|hp
operator|->
name|h_name
argument_list|,
name|hp2
operator|->
name|h_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|freehostent
argument_list|(
name|hp2
argument_list|)
expr_stmt|;
name|hp2
operator|=
name|NULL
expr_stmt|;
block|}
name|hp
operator|=
name|_hpmerge
argument_list|(
name|hp
argument_list|,
name|hp2
argument_list|,
name|errp
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
name|_hpsort
argument_list|(
name|hp
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|hostent
modifier|*
name|getipnodebyname
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|af
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
block|{
if|if
condition|(
name|af
operator|!=
name|AF_INET
ifdef|#
directive|ifdef
name|INET6
operator|&&
name|af
operator|!=
name|AF_INET6
endif|#
directive|endif
condition|)
block|{
operator|*
name|errp
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
operator|(
name|_getipnodebyname_multi
argument_list|(
name|name
argument_list|,
name|af
argument_list|,
name|flags
argument_list|,
name|errp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|hostent
modifier|*
name|getipnodebyaddr
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|af
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|int
name|rval
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|in6_addr
name|addrbuf
decl_stmt|;
else|#
directive|else
name|struct
name|in_addr
name|addrbuf
decl_stmt|;
endif|#
directive|endif
specifier|static
specifier|const
name|ns_dtab
name|dtab
index|[]
init|=
block|{
name|NS_FILES_CB
argument_list|(
argument|_files_ghbyaddr
argument_list|,
argument|NULL
argument_list|)
block|{
name|NSSRC_DNS
block|,
name|_dns_ghbyaddr
block|,
name|NULL
block|}
block|,
name|NS_NIS_CB
argument_list|(
argument|_nis_ghbyaddr
argument_list|,
argument|NULL
argument_list|)
ifdef|#
directive|ifdef
name|ICMPNL
block|{
name|NSSRC_ICMP
block|,
name|_icmp_ghbyaddr
block|,
name|NULL
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|}
block|}
decl_stmt|;
operator|*
name|errp
operator|=
name|HOST_NOT_FOUND
expr_stmt|;
switch|switch
condition|(
name|af
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
condition|)
block|{
operator|*
name|errp
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|long
operator|)
name|src
operator|&
operator|~
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
operator|-
literal|1
operator|)
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|addrbuf
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|src
operator|=
operator|&
name|addrbuf
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|src
operator|)
operator|->
name|s_addr
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
condition|)
block|{
operator|*
name|errp
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|long
operator|)
name|src
operator|&
operator|~
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|/
literal|2
operator|-
literal|1
operator|)
condition|)
block|{
comment|/*XXX*/
name|memcpy
argument_list|(
operator|&
name|addrbuf
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|src
operator|=
operator|&
name|addrbuf
expr_stmt|;
block|}
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|(
expr|struct
name|in6_addr
operator|*
operator|)
name|src
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|(
expr|struct
name|in6_addr
operator|*
operator|)
name|src
argument_list|)
operator|||
name|IN6_IS_ADDR_V4COMPAT
argument_list|(
operator|(
expr|struct
name|in6_addr
operator|*
operator|)
name|src
argument_list|)
condition|)
block|{
name|src
operator|=
operator|(
name|char
operator|*
operator|)
name|src
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
operator|)
expr_stmt|;
name|af
operator|=
name|AF_INET
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
operator|*
name|errp
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|rval
operator|=
name|nsdispatch
argument_list|(
operator|&
name|hp
argument_list|,
name|dtab
argument_list|,
name|NSDB_HOSTS
argument_list|,
literal|"ghbyaddr"
argument_list|,
name|default_src
argument_list|,
name|src
argument_list|,
name|len
argument_list|,
name|af
argument_list|,
name|errp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|==
name|NS_SUCCESS
operator|)
condition|?
name|hp
else|:
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|freehostent
parameter_list|(
name|struct
name|hostent
modifier|*
name|ptr
parameter_list|)
block|{
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* XXX: should be deprecated */
end_comment

begin_ifdef
unit|struct hostent * getnodebyname(const char *name, int af, int flags) { 	return getipnodebyname(name, af, flags,&h_errno); }
ifdef|#
directive|ifdef
name|__warn_references
end_ifdef

begin_endif
unit|__warn_references(getnodebyname, 	"warning: getnodebyname() deprecated, " 	"should use getaddrinfo() or getipnodebyname()");
endif|#
directive|endif
end_endif

begin_ifdef
unit|struct hostent * getnodebyaddr(const void *src, size_t len, int af) { 	return getipnodebyaddr(src, len, af,&h_errno); }
ifdef|#
directive|ifdef
name|__warn_references
end_ifdef

begin_endif
unit|__warn_references(getnodebyaddr, 	"warning: getnodebyaddr() deprecated, " 	"should use getnameinfo() or getipnodebyaddr()");
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Private utility functions  */
end_comment

begin_comment
comment|/*  * _hpcopy: allocate and copy hostent structure  */
end_comment

begin_function
specifier|static
name|struct
name|hostent
modifier|*
name|_hpcopy
parameter_list|(
name|struct
name|hostent
modifier|*
name|hp
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
block|{
name|struct
name|hostent
modifier|*
name|nhp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|int
name|size
decl_stmt|,
name|addrsize
decl_stmt|;
name|int
name|nalias
init|=
literal|0
decl_stmt|,
name|naddr
init|=
literal|0
decl_stmt|;
name|int
name|al_off
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
return|return
name|hp
return|;
comment|/* count size to be allocated */
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|hostent
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|h_name
operator|!=
name|NULL
condition|)
name|size
operator|+=
name|strlen
argument_list|(
name|hp
operator|->
name|h_name
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|=
name|hp
operator|->
name|h_aliases
operator|)
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|i
operator|++
operator|,
name|pp
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'\0'
condition|)
block|{
name|size
operator|+=
name|strlen
argument_list|(
operator|*
name|pp
argument_list|)
operator|+
literal|1
expr_stmt|;
name|nalias
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* adjust alignment */
name|size
operator|=
name|ALIGN
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|al_off
operator|=
name|size
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|nalias
operator|+
literal|1
operator|)
expr_stmt|;
name|addrsize
operator|=
name|ALIGN
argument_list|(
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|=
name|hp
operator|->
name|h_addr_list
operator|)
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|*
name|pp
operator|++
operator|!=
name|NULL
condition|)
name|naddr
operator|++
expr_stmt|;
block|}
name|size
operator|+=
name|addrsize
operator|*
name|naddr
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|naddr
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* copy */
if|if
condition|(
operator|(
name|nhp
operator|=
operator|(
expr|struct
name|hostent
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|errp
operator|=
name|TRY_AGAIN
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|nhp
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|h_name
operator|!=
name|NULL
condition|)
block|{
name|nhp
operator|->
name|h_name
operator|=
name|cp
expr_stmt|;
name|strcpy
argument_list|(
name|cp
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|nhp
operator|->
name|h_name
operator|=
name|NULL
expr_stmt|;
name|nhp
operator|->
name|h_aliases
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|nhp
operator|+
name|al_off
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|=
name|hp
operator|->
name|h_aliases
operator|)
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'\0'
condition|)
block|{
name|nhp
operator|->
name|h_aliases
index|[
name|i
operator|++
index|]
operator|=
name|cp
expr_stmt|;
name|strcpy
argument_list|(
name|cp
argument_list|,
operator|*
name|pp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
name|nhp
operator|->
name|h_aliases
index|[
name|nalias
index|]
operator|=
name|NULL
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|nhp
operator|->
name|h_aliases
index|[
name|nalias
operator|+
literal|1
index|]
expr_stmt|;
name|nhp
operator|->
name|h_addrtype
operator|=
name|hp
operator|->
name|h_addrtype
expr_stmt|;
name|nhp
operator|->
name|h_length
operator|=
name|hp
operator|->
name|h_length
expr_stmt|;
name|nhp
operator|->
name|h_addr_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|cp
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|=
name|hp
operator|->
name|h_addr_list
operator|)
operator|!=
name|NULL
condition|)
block|{
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|nhp
operator|->
name|h_addr_list
index|[
name|naddr
operator|+
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|++
control|)
block|{
name|nhp
operator|->
name|h_addr_list
index|[
name|i
operator|++
index|]
operator|=
name|cp
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
operator|*
name|pp
argument_list|,
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|addrsize
expr_stmt|;
block|}
block|}
name|nhp
operator|->
name|h_addr_list
index|[
name|naddr
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|nhp
return|;
block|}
end_function

begin_comment
comment|/*  * _hpaddr: construct hostent structure with one address  */
end_comment

begin_function
specifier|static
name|struct
name|hostent
modifier|*
name|_hpaddr
parameter_list|(
name|int
name|af
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|,
name|hpbuf
decl_stmt|;
name|char
modifier|*
name|addrs
index|[
literal|2
index|]
decl_stmt|;
name|hp
operator|=
operator|&
name|hpbuf
expr_stmt|;
name|hp
operator|->
name|h_name
operator|=
operator|(
name|char
operator|*
operator|)
name|name
expr_stmt|;
name|hp
operator|->
name|h_aliases
operator|=
name|NULL
expr_stmt|;
name|hp
operator|->
name|h_addrtype
operator|=
name|af
expr_stmt|;
name|hp
operator|->
name|h_length
operator|=
name|ADDRLEN
argument_list|(
name|af
argument_list|)
expr_stmt|;
name|hp
operator|->
name|h_addr_list
operator|=
name|addrs
expr_stmt|;
name|addrs
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|addr
expr_stmt|;
name|addrs
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|_hpcopy
argument_list|(
name|hp
argument_list|,
name|errp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * _hpmerge: merge 2 hostent structure, arguments will be freed  */
end_comment

begin_function
specifier|static
name|struct
name|hostent
modifier|*
name|_hpmerge
parameter_list|(
name|struct
name|hostent
modifier|*
name|hp1
parameter_list|,
name|struct
name|hostent
modifier|*
name|hp2
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|naddr
decl_stmt|,
name|nalias
decl_stmt|;
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|,
name|hpbuf
decl_stmt|;
name|char
modifier|*
name|aliases
index|[
name|MAXALIASES
operator|+
literal|1
index|]
decl_stmt|,
modifier|*
name|addrs
index|[
name|MAXADDRS
operator|+
literal|1
index|]
decl_stmt|;
name|union
name|inx_addr
name|addrbuf
index|[
name|MAXADDRS
index|]
decl_stmt|;
if|if
condition|(
name|hp1
operator|==
name|NULL
condition|)
return|return
name|hp2
return|;
if|if
condition|(
name|hp2
operator|==
name|NULL
condition|)
return|return
name|hp1
return|;
define|#
directive|define
name|HP
parameter_list|(
name|i
parameter_list|)
value|(i == 1 ? hp1 : hp2)
name|hp
operator|=
operator|&
name|hpbuf
expr_stmt|;
name|hp
operator|->
name|h_name
operator|=
operator|(
name|hp1
operator|->
name|h_name
operator|!=
name|NULL
condition|?
name|hp1
operator|->
name|h_name
else|:
name|hp2
operator|->
name|h_name
operator|)
expr_stmt|;
name|hp
operator|->
name|h_aliases
operator|=
name|aliases
expr_stmt|;
name|nalias
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pp
operator|=
name|HP
argument_list|(
name|i
argument_list|)
operator|->
name|h_aliases
operator|)
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
init|;
name|nalias
operator|<
name|MAXALIASES
operator|&&
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|++
control|)
block|{
comment|/* check duplicates */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nalias
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|strcasecmp
argument_list|(
operator|*
name|pp
argument_list|,
name|aliases
index|[
name|j
index|]
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|j
operator|==
name|nalias
condition|)
name|aliases
index|[
name|nalias
operator|++
index|]
operator|=
operator|*
name|pp
expr_stmt|;
block|}
block|}
name|aliases
index|[
name|nalias
index|]
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|hp1
operator|->
name|h_length
operator|!=
name|hp2
operator|->
name|h_length
condition|)
block|{
name|hp
operator|->
name|h_addrtype
operator|=
name|AF_INET6
expr_stmt|;
name|hp
operator|->
name|h_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
name|hp
operator|->
name|h_addrtype
operator|=
name|hp1
operator|->
name|h_addrtype
expr_stmt|;
name|hp
operator|->
name|h_length
operator|=
name|hp1
operator|->
name|h_length
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
block|}
endif|#
directive|endif
name|hp
operator|->
name|h_addr_list
operator|=
name|addrs
expr_stmt|;
name|naddr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pp
operator|=
name|HP
argument_list|(
name|i
argument_list|)
operator|->
name|h_addr_list
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|HP
argument_list|(
name|i
argument_list|)
operator|->
name|h_length
operator|==
name|hp
operator|->
name|h_length
condition|)
block|{
while|while
condition|(
name|naddr
operator|<
name|MAXADDRS
operator|&&
operator|*
name|pp
operator|!=
name|NULL
condition|)
name|addrs
index|[
name|naddr
operator|++
index|]
operator|=
operator|*
name|pp
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* copy IPv4 addr as mapped IPv6 addr */
while|while
condition|(
name|naddr
operator|<
name|MAXADDRS
operator|&&
operator|*
name|pp
operator|!=
name|NULL
condition|)
block|{
name|MAPADDR
argument_list|(
operator|&
name|addrbuf
index|[
name|naddr
index|]
argument_list|,
operator|*
name|pp
operator|++
argument_list|)
expr_stmt|;
name|addrs
index|[
name|naddr
index|]
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|addrbuf
index|[
name|naddr
index|]
expr_stmt|;
name|naddr
operator|++
expr_stmt|;
block|}
block|}
block|}
name|addrs
index|[
name|naddr
index|]
operator|=
name|NULL
expr_stmt|;
name|hp
operator|=
name|_hpcopy
argument_list|(
name|hp
argument_list|,
name|errp
argument_list|)
expr_stmt|;
name|freehostent
argument_list|(
name|hp1
argument_list|)
expr_stmt|;
name|freehostent
argument_list|(
name|hp2
argument_list|)
expr_stmt|;
return|return
name|hp
return|;
block|}
end_function

begin_comment
comment|/*  * _hpmapv6: convert IPv4 hostent into IPv4-mapped IPv6 addresses  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function
specifier|static
name|struct
name|hostent
modifier|*
name|_hpmapv6
parameter_list|(
name|struct
name|hostent
modifier|*
name|hp
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
block|{
name|struct
name|hostent
modifier|*
name|hp6
decl_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|hp
operator|->
name|h_addrtype
operator|==
name|AF_INET6
condition|)
return|return
name|hp
return|;
comment|/* make dummy hostent to convert IPv6 address */
if|if
condition|(
operator|(
name|hp6
operator|=
operator|(
expr|struct
name|hostent
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hostent
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|errp
operator|=
name|TRY_AGAIN
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|hp6
operator|->
name|h_name
operator|=
name|NULL
expr_stmt|;
name|hp6
operator|->
name|h_aliases
operator|=
name|NULL
expr_stmt|;
name|hp6
operator|->
name|h_addrtype
operator|=
name|AF_INET6
expr_stmt|;
name|hp6
operator|->
name|h_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
expr_stmt|;
name|hp6
operator|->
name|h_addr_list
operator|=
name|NULL
expr_stmt|;
return|return
name|_hpmerge
argument_list|(
name|hp6
argument_list|,
name|hp
argument_list|,
name|errp
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * _hpsort: sort address by sortlist  */
end_comment

begin_function
specifier|static
name|struct
name|hostent
modifier|*
name|_hpsort
parameter_list|(
name|struct
name|hostent
modifier|*
name|hp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
decl_stmt|;
name|u_char
modifier|*
name|ap
decl_stmt|,
modifier|*
name|sp
decl_stmt|,
modifier|*
name|mp
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|char
name|t
decl_stmt|;
name|char
name|order
index|[
name|MAXADDRS
index|]
decl_stmt|;
name|int
name|nsort
init|=
name|_res
operator|.
name|nsort
decl_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
operator|||
name|hp
operator|->
name|h_addr_list
index|[
literal|1
index|]
operator|==
name|NULL
operator|||
name|nsort
operator|==
literal|0
condition|)
return|return
name|hp
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|ap
operator|=
operator|(
name|u_char
operator|*
operator|)
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nsort
condition|;
name|j
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|_res_ext
operator|.
name|sort_list
index|[
name|j
index|]
operator|.
name|af
operator|!=
name|hp
operator|->
name|h_addrtype
condition|)
continue|continue;
name|sp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|_res_ext
operator|.
name|sort_list
index|[
name|j
index|]
operator|.
name|addr
expr_stmt|;
name|mp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|_res_ext
operator|.
name|sort_list
index|[
name|j
index|]
operator|.
name|mask
expr_stmt|;
else|#
directive|else
name|sp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|_res
operator|.
name|sort_list
index|[
name|j
index|]
operator|.
name|addr
expr_stmt|;
name|mp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|_res
operator|.
name|sort_list
index|[
name|j
index|]
operator|.
name|mask
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|hp
operator|->
name|h_length
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ap
index|[
name|n
index|]
operator|&
name|mp
index|[
name|n
index|]
operator|)
operator|!=
name|sp
index|[
name|n
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|n
operator|==
name|hp
operator|->
name|h_length
condition|)
break|break;
block|}
name|order
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
block|}
name|n
operator|=
name|i
expr_stmt|;
name|pp
operator|=
operator|(
name|u_char
operator|*
operator|*
operator|)
name|hp
operator|->
name|h_addr_list
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|order
index|[
name|i
index|]
operator|>
name|order
index|[
name|j
index|]
condition|)
block|{
name|ap
operator|=
name|pp
index|[
name|i
index|]
expr_stmt|;
name|pp
index|[
name|i
index|]
operator|=
name|pp
index|[
name|j
index|]
expr_stmt|;
name|pp
index|[
name|j
index|]
operator|=
name|ap
expr_stmt|;
name|t
operator|=
name|order
index|[
name|i
index|]
expr_stmt|;
name|order
index|[
name|i
index|]
operator|=
name|order
index|[
name|j
index|]
expr_stmt|;
name|order
index|[
name|j
index|]
operator|=
name|t
expr_stmt|;
block|}
block|}
block|}
return|return
name|hp
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|_hgetword
parameter_list|(
name|char
modifier|*
modifier|*
name|pp
parameter_list|)
block|{
name|char
name|c
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|ret
decl_stmt|;
specifier|const
name|char
modifier|*
name|sp
decl_stmt|;
specifier|static
specifier|const
name|char
name|sep
index|[]
init|=
literal|"# \t\n"
decl_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|pp
init|;
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
for|for
control|(
name|sp
operator|=
name|sep
init|;
operator|*
name|sp
operator|!=
literal|'\0'
condition|;
name|sp
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
operator|*
name|sp
condition|)
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
name|p
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* ignore rest of line */
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
literal|'\0'
condition|)
name|ret
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|sp
operator|!=
literal|'\0'
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
block|}
operator|*
name|pp
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
operator|||
operator|*
name|ret
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * FILES (/etc/hosts)  */
end_comment

begin_function
specifier|static
name|FILE
modifier|*
name|_files_open
parameter_list|(
name|int
modifier|*
name|errp
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|_PATH_HOSTS
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
operator|*
name|errp
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
name|fp
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_files_ghbyname
parameter_list|(
name|void
modifier|*
name|rval
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|af
decl_stmt|;
name|int
modifier|*
name|errp
decl_stmt|;
name|int
name|match
decl_stmt|,
name|nalias
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|line
decl_stmt|,
modifier|*
name|addrstr
decl_stmt|,
modifier|*
name|cname
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|hostent
modifier|*
name|rethp
decl_stmt|,
modifier|*
name|hp
decl_stmt|,
name|hpbuf
decl_stmt|;
name|char
modifier|*
name|aliases
index|[
name|MAXALIASES
operator|+
literal|1
index|]
decl_stmt|,
modifier|*
name|addrs
index|[
literal|2
index|]
decl_stmt|;
name|union
name|inx_addr
name|addrbuf
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|af0
decl_stmt|;
name|name
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|af
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|errp
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
operator|*
argument_list|)
expr_stmt|;
operator|*
operator|(
expr|struct
name|hostent
operator|*
operator|*
operator|)
name|rval
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|_files_open
argument_list|(
name|errp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NS_UNAVAIL
return|;
name|rethp
operator|=
name|hp
operator|=
name|NULL
expr_stmt|;
name|af0
operator|=
name|af
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
condition|)
block|{
name|line
operator|=
name|buf
expr_stmt|;
if|if
condition|(
operator|(
name|addrstr
operator|=
name|_hgetword
argument_list|(
operator|&
name|line
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|cname
operator|=
name|_hgetword
argument_list|(
operator|&
name|line
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
name|match
operator|=
operator|(
name|strcasecmp
argument_list|(
name|cname
argument_list|,
name|name
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
name|nalias
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|_hgetword
argument_list|(
operator|&
name|line
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|match
condition|)
name|match
operator|=
operator|(
name|strcasecmp
argument_list|(
name|p
argument_list|,
name|name
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|nalias
operator|<
name|MAXALIASES
condition|)
name|aliases
index|[
name|nalias
operator|++
index|]
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|match
condition|)
continue|continue;
switch|switch
condition|(
name|af0
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
name|inet_aton
argument_list|(
name|addrstr
argument_list|,
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|&
name|addrbuf
argument_list|)
operator|!=
literal|1
condition|)
block|{
operator|*
name|errp
operator|=
name|NO_DATA
expr_stmt|;
comment|/* name found */
continue|continue;
block|}
name|af
operator|=
name|af0
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|inet_pton
argument_list|(
name|af
argument_list|,
name|addrstr
argument_list|,
operator|&
name|addrbuf
argument_list|)
operator|!=
literal|1
condition|)
block|{
operator|*
name|errp
operator|=
name|NO_DATA
expr_stmt|;
comment|/* name found */
continue|continue;
block|}
name|af
operator|=
name|af0
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|AF_UNSPEC
case|:
if|if
condition|(
name|inet_aton
argument_list|(
name|addrstr
argument_list|,
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|&
name|addrbuf
argument_list|)
operator|==
literal|1
condition|)
block|{
name|af
operator|=
name|AF_INET
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|inet_pton
argument_list|(
name|AF_INET6
argument_list|,
name|addrstr
argument_list|,
operator|&
name|addrbuf
argument_list|)
operator|==
literal|1
condition|)
block|{
name|af
operator|=
name|AF_INET6
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
operator|*
name|errp
operator|=
name|NO_DATA
expr_stmt|;
comment|/* name found */
continue|continue;
comment|/* NOTREACHED */
block|}
name|hp
operator|=
operator|&
name|hpbuf
expr_stmt|;
name|hp
operator|->
name|h_name
operator|=
name|cname
expr_stmt|;
name|hp
operator|->
name|h_aliases
operator|=
name|aliases
expr_stmt|;
name|aliases
index|[
name|nalias
index|]
operator|=
name|NULL
expr_stmt|;
name|hp
operator|->
name|h_addrtype
operator|=
name|af
expr_stmt|;
name|hp
operator|->
name|h_length
operator|=
name|ADDRLEN
argument_list|(
name|af
argument_list|)
expr_stmt|;
name|hp
operator|->
name|h_addr_list
operator|=
name|addrs
expr_stmt|;
name|addrs
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|addrbuf
expr_stmt|;
name|addrs
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|hp
operator|=
name|_hpcopy
argument_list|(
name|hp
argument_list|,
name|errp
argument_list|)
expr_stmt|;
name|rethp
operator|=
name|_hpmerge
argument_list|(
name|rethp
argument_list|,
name|hp
argument_list|,
name|errp
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|*
operator|(
expr|struct
name|hostent
operator|*
operator|*
operator|)
name|rval
operator|=
name|rethp
expr_stmt|;
return|return
operator|(
name|rethp
operator|!=
name|NULL
operator|)
condition|?
name|NS_SUCCESS
else|:
name|NS_NOTFOUND
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_files_ghbyaddr
parameter_list|(
name|void
modifier|*
name|rval
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|addr
decl_stmt|;
name|int
name|addrlen
decl_stmt|;
name|int
name|af
decl_stmt|;
name|int
modifier|*
name|errp
decl_stmt|;
name|int
name|nalias
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|line
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|,
name|hpbuf
decl_stmt|;
name|char
modifier|*
name|aliases
index|[
name|MAXALIASES
operator|+
literal|1
index|]
decl_stmt|,
modifier|*
name|addrs
index|[
literal|2
index|]
decl_stmt|;
name|union
name|inx_addr
name|addrbuf
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|addr
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
expr_stmt|;
name|addrlen
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|af
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|errp
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
operator|*
argument_list|)
expr_stmt|;
operator|*
operator|(
expr|struct
name|hostent
operator|*
operator|*
operator|)
name|rval
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|_files_open
argument_list|(
name|errp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NS_UNAVAIL
return|;
name|hp
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
condition|)
block|{
name|line
operator|=
name|buf
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|_hgetword
argument_list|(
operator|&
name|line
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|af
operator|==
name|AF_INET
condition|?
name|inet_aton
argument_list|(
name|p
argument_list|,
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|&
name|addrbuf
argument_list|)
else|:
name|inet_pton
argument_list|(
name|af
argument_list|,
name|p
argument_list|,
operator|&
name|addrbuf
argument_list|)
operator|)
operator|!=
literal|1
operator|||
name|memcmp
argument_list|(
name|addr
argument_list|,
operator|&
name|addrbuf
argument_list|,
name|addrlen
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|p
operator|=
name|_hgetword
argument_list|(
operator|&
name|line
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
name|hp
operator|=
operator|&
name|hpbuf
expr_stmt|;
name|hp
operator|->
name|h_name
operator|=
name|p
expr_stmt|;
name|hp
operator|->
name|h_aliases
operator|=
name|aliases
expr_stmt|;
name|nalias
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|_hgetword
argument_list|(
operator|&
name|line
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nalias
operator|<
name|MAXALIASES
condition|)
name|aliases
index|[
name|nalias
operator|++
index|]
operator|=
name|p
expr_stmt|;
block|}
name|aliases
index|[
name|nalias
index|]
operator|=
name|NULL
expr_stmt|;
name|hp
operator|->
name|h_addrtype
operator|=
name|af
expr_stmt|;
name|hp
operator|->
name|h_length
operator|=
name|addrlen
expr_stmt|;
name|hp
operator|->
name|h_addr_list
operator|=
name|addrs
expr_stmt|;
name|addrs
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|addrbuf
expr_stmt|;
name|addrs
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|hp
operator|=
name|_hpcopy
argument_list|(
name|hp
argument_list|,
name|errp
argument_list|)
expr_stmt|;
break|break;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|*
operator|(
expr|struct
name|hostent
operator|*
operator|*
operator|)
name|rval
operator|=
name|hp
expr_stmt|;
return|return
operator|(
name|hp
operator|!=
name|NULL
operator|)
condition|?
name|NS_SUCCESS
else|:
name|NS_NOTFOUND
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|YP
end_ifdef

begin_comment
comment|/*  * NIS  *  * XXX actually a hack, these are INET4 specific.  */
end_comment

begin_function
specifier|static
name|int
name|_nis_ghbyname
parameter_list|(
name|void
modifier|*
name|rval
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|af
decl_stmt|;
name|int
modifier|*
name|errp
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
init|=
name|NULL
decl_stmt|;
name|name
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|af
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|errp
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|af
operator|==
name|AF_UNSPEC
condition|)
name|af
operator|=
name|AF_INET
expr_stmt|;
if|if
condition|(
name|af
operator|==
name|AF_INET
condition|)
block|{
name|hp
operator|=
name|_gethostbynisname
argument_list|(
name|name
argument_list|,
name|af
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|!=
name|NULL
condition|)
name|hp
operator|=
name|_hpcopy
argument_list|(
name|hp
argument_list|,
name|errp
argument_list|)
expr_stmt|;
block|}
operator|*
operator|(
expr|struct
name|hostent
operator|*
operator|*
operator|)
name|rval
operator|=
name|hp
expr_stmt|;
return|return
operator|(
name|hp
operator|!=
name|NULL
operator|)
condition|?
name|NS_SUCCESS
else|:
name|NS_NOTFOUND
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_nis_ghbyaddr
parameter_list|(
name|void
modifier|*
name|rval
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|addr
decl_stmt|;
name|int
name|addrlen
decl_stmt|;
name|int
name|af
decl_stmt|;
name|int
modifier|*
name|errp
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
init|=
name|NULL
decl_stmt|;
name|addr
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
expr_stmt|;
name|addrlen
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|af
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|af
operator|==
name|AF_INET
condition|)
block|{
name|hp
operator|=
name|_gethostbynisaddr
argument_list|(
name|addr
argument_list|,
name|addrlen
argument_list|,
name|af
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|!=
name|NULL
condition|)
name|hp
operator|=
name|_hpcopy
argument_list|(
name|hp
argument_list|,
name|errp
argument_list|)
expr_stmt|;
block|}
operator|*
operator|(
expr|struct
name|hostent
operator|*
operator|*
operator|)
name|rval
operator|=
name|hp
expr_stmt|;
return|return
operator|(
name|hp
operator|!=
name|NULL
operator|)
condition|?
name|NS_SUCCESS
else|:
name|NS_NOTFOUND
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|__res_type_list
block|{
name|SLIST_ENTRY
argument_list|(
argument|__res_type_list
argument_list|)
name|rtl_entry
expr_stmt|;
name|int
name|rtl_type
decl_stmt|;
block|}
struct|;
end_struct

begin_if
if|#
directive|if
name|PACKETSZ
operator|>
literal|1024
end_if

begin_define
define|#
directive|define
name|MAXPACKET
value|PACKETSZ
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MAXPACKET
value|1024
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_typedef
typedef|typedef
union|union
block|{
name|HEADER
name|hdr
decl_stmt|;
name|u_char
name|buf
index|[
name|MAXPACKET
index|]
decl_stmt|;
block|}
name|querybuf
typedef|;
end_typedef

begin_function_decl
specifier|static
name|struct
name|hostent
modifier|*
name|getanswer
parameter_list|(
specifier|const
name|querybuf
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|hostent
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * we don't need to take care about sorting, nor IPv4 mapped address here.  */
end_comment

begin_function
specifier|static
name|struct
name|hostent
modifier|*
name|getanswer
parameter_list|(
name|answer
parameter_list|,
name|anslen
parameter_list|,
name|qname
parameter_list|,
name|qtype
parameter_list|,
name|template
parameter_list|,
name|errp
parameter_list|)
specifier|const
name|querybuf
modifier|*
name|answer
decl_stmt|;
name|int
name|anslen
decl_stmt|;
specifier|const
name|char
modifier|*
name|qname
decl_stmt|;
name|int
name|qtype
decl_stmt|;
name|struct
name|hostent
modifier|*
name|template
decl_stmt|;
name|int
modifier|*
name|errp
decl_stmt|;
block|{
specifier|const
name|HEADER
modifier|*
name|hp
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|cp
decl_stmt|;
name|int
name|n
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|eom
decl_stmt|,
modifier|*
name|erdata
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
modifier|*
name|ap
decl_stmt|,
modifier|*
modifier|*
name|hap
decl_stmt|;
name|int
name|type
decl_stmt|,
name|class
decl_stmt|,
name|buflen
decl_stmt|,
name|ancount
decl_stmt|,
name|qdcount
decl_stmt|;
name|int
name|haveanswer
decl_stmt|,
name|had_error
decl_stmt|;
name|char
name|tbuf
index|[
name|MAXDNAME
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|tname
decl_stmt|;
name|int
function_decl|(
modifier|*
name|name_ok
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
specifier|static
name|char
modifier|*
name|h_addr_ptrs
index|[
name|MAXADDRS
operator|+
literal|1
index|]
decl_stmt|;
specifier|static
name|char
modifier|*
name|host_aliases
index|[
name|MAXALIASES
index|]
decl_stmt|;
specifier|static
name|char
name|hostbuf
index|[
literal|8
operator|*
literal|1024
index|]
decl_stmt|;
define|#
directive|define
name|BOUNDED_INCR
parameter_list|(
name|x
parameter_list|)
define|\
value|do { \ 		cp += x; \ 		if (cp> eom) { \ 			*errp = NO_RECOVERY; \ 			return (NULL); \ 		} \ 	} while (0)
define|#
directive|define
name|BOUNDS_CHECK
parameter_list|(
name|ptr
parameter_list|,
name|count
parameter_list|)
define|\
value|do { \ 		if ((ptr) + (count)> eom) { \ 			*errp = NO_RECOVERY; \ 			return (NULL); \ 		} \ 	} while (0)
comment|/* XXX do {} while (0) cannot be put here */
define|#
directive|define
name|DNS_ASSERT
parameter_list|(
name|x
parameter_list|)
define|\
value|{				\ 		if (!(x)) {		\ 			cp += n;	\ 			continue;	\ 		}			\ 	}
comment|/* XXX do {} while (0) cannot be put here */
define|#
directive|define
name|DNS_FATAL
parameter_list|(
name|x
parameter_list|)
define|\
value|{				\ 		if (!(x)) {		\ 			had_error++;	\ 			continue;	\ 		}			\ 	}
name|tname
operator|=
name|qname
expr_stmt|;
name|template
operator|->
name|h_name
operator|=
name|NULL
expr_stmt|;
name|eom
operator|=
name|answer
operator|->
name|buf
operator|+
name|anslen
expr_stmt|;
switch|switch
condition|(
name|qtype
condition|)
block|{
case|case
name|T_A
case|:
case|case
name|T_AAAA
case|:
name|name_ok
operator|=
name|res_hnok
expr_stmt|;
break|break;
case|case
name|T_PTR
case|:
name|name_ok
operator|=
name|res_dnok
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* XXX should be abort(); */
block|}
comment|/* 	 * find first satisfactory answer 	 */
name|hp
operator|=
operator|&
name|answer
operator|->
name|hdr
expr_stmt|;
name|ancount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|qdcount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|qdcount
argument_list|)
expr_stmt|;
name|bp
operator|=
name|hostbuf
expr_stmt|;
name|buflen
operator|=
sizeof|sizeof
name|hostbuf
expr_stmt|;
name|cp
operator|=
name|answer
operator|->
name|buf
expr_stmt|;
name|BOUNDED_INCR
argument_list|(
name|HFIXEDSZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|qdcount
operator|!=
literal|1
condition|)
block|{
operator|*
name|errp
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|n
operator|=
name|dn_expand
argument_list|(
name|answer
operator|->
name|buf
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
name|bp
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|<
literal|0
operator|)
operator|||
operator|!
call|(
modifier|*
name|name_ok
call|)
argument_list|(
name|bp
argument_list|)
condition|)
block|{
operator|*
name|errp
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|BOUNDED_INCR
argument_list|(
name|n
operator|+
name|QFIXEDSZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|qtype
operator|==
name|T_A
operator|||
name|qtype
operator|==
name|T_AAAA
condition|)
block|{
comment|/* res_send() has already verified that the query name is the 		 * same as the one we sent; this just gets the expanded name 		 * (i.e., with the succeeding search-domain tacked on). 		 */
name|n
operator|=
name|strlen
argument_list|(
name|bp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* for the \0 */
if|if
condition|(
name|n
operator|>=
name|MAXHOSTNAMELEN
condition|)
block|{
operator|*
name|errp
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|template
operator|->
name|h_name
operator|=
name|bp
expr_stmt|;
name|bp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
comment|/* The qname can be abbreviated, but h_name is now absolute. */
name|qname
operator|=
name|template
operator|->
name|h_name
expr_stmt|;
block|}
name|ap
operator|=
name|host_aliases
expr_stmt|;
operator|*
name|ap
operator|=
name|NULL
expr_stmt|;
name|template
operator|->
name|h_aliases
operator|=
name|host_aliases
expr_stmt|;
name|hap
operator|=
name|h_addr_ptrs
expr_stmt|;
operator|*
name|hap
operator|=
name|NULL
expr_stmt|;
name|template
operator|->
name|h_addr_list
operator|=
name|h_addr_ptrs
expr_stmt|;
name|haveanswer
operator|=
literal|0
expr_stmt|;
name|had_error
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ancount
operator|--
operator|>
literal|0
operator|&&
name|cp
operator|<
name|eom
operator|&&
operator|!
name|had_error
condition|)
block|{
name|n
operator|=
name|dn_expand
argument_list|(
name|answer
operator|->
name|buf
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
name|bp
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
name|DNS_FATAL
argument_list|(
name|n
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|DNS_FATAL
argument_list|(
call|(
modifier|*
name|name_ok
call|)
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* name */
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
literal|3
operator|*
name|INT16SZ
operator|+
name|INT32SZ
argument_list|)
expr_stmt|;
name|type
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
comment|/* type */
name|class
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
operator|+
name|INT32SZ
expr_stmt|;
comment|/* class, TTL */
name|n
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
comment|/* len */
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|erdata
operator|=
name|cp
operator|+
name|n
expr_stmt|;
name|DNS_ASSERT
argument_list|(
name|class
operator|==
name|C_IN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|qtype
operator|==
name|T_A
operator|||
name|qtype
operator|==
name|T_AAAA
operator|)
operator|&&
name|type
operator|==
name|T_CNAME
condition|)
block|{
if|if
condition|(
name|ap
operator|>=
operator|&
name|host_aliases
index|[
name|MAXALIASES
operator|-
literal|1
index|]
condition|)
continue|continue;
name|n
operator|=
name|dn_expand
argument_list|(
name|answer
operator|->
name|buf
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
name|tbuf
argument_list|,
sizeof|sizeof
name|tbuf
argument_list|)
expr_stmt|;
name|DNS_FATAL
argument_list|(
name|n
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|DNS_FATAL
argument_list|(
call|(
modifier|*
name|name_ok
call|)
argument_list|(
name|tbuf
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|erdata
condition|)
block|{
operator|*
name|errp
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Store alias. */
operator|*
name|ap
operator|++
operator|=
name|bp
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|bp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* for the \0 */
name|DNS_FATAL
argument_list|(
name|n
operator|<
name|MAXHOSTNAMELEN
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
comment|/* Get canonical name. */
name|n
operator|=
name|strlen
argument_list|(
name|tbuf
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* for the \0 */
name|DNS_FATAL
argument_list|(
name|n
operator|<=
name|buflen
argument_list|)
expr_stmt|;
name|DNS_FATAL
argument_list|(
name|n
operator|<
name|MAXHOSTNAMELEN
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|bp
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
name|template
operator|->
name|h_name
operator|=
name|bp
expr_stmt|;
name|bp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|qtype
operator|==
name|T_PTR
operator|&&
name|type
operator|==
name|T_CNAME
condition|)
block|{
name|n
operator|=
name|dn_expand
argument_list|(
name|answer
operator|->
name|buf
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
name|tbuf
argument_list|,
sizeof|sizeof
name|tbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
operator|!
name|res_dnok
argument_list|(
name|tbuf
argument_list|)
condition|)
block|{
name|had_error
operator|++
expr_stmt|;
continue|continue;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|erdata
condition|)
block|{
operator|*
name|errp
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Get canonical name. */
name|n
operator|=
name|strlen
argument_list|(
name|tbuf
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* for the \0 */
if|if
condition|(
name|n
operator|>
name|buflen
operator|||
name|n
operator|>=
name|MAXHOSTNAMELEN
condition|)
block|{
name|had_error
operator|++
expr_stmt|;
continue|continue;
block|}
name|strcpy
argument_list|(
name|bp
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
name|tname
operator|=
name|bp
expr_stmt|;
name|bp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
continue|continue;
block|}
name|DNS_ASSERT
argument_list|(
name|type
operator|==
name|qtype
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_PTR
case|:
name|DNS_ASSERT
argument_list|(
name|strcasecmp
argument_list|(
name|tname
argument_list|,
name|bp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|n
operator|=
name|dn_expand
argument_list|(
name|answer
operator|->
name|buf
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
name|bp
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
name|DNS_FATAL
argument_list|(
name|n
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|DNS_FATAL
argument_list|(
name|res_hnok
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|MULTI_PTRS_ARE_ALIASES
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|erdata
condition|)
block|{
operator|*
name|errp
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|haveanswer
condition|)
name|template
operator|->
name|h_name
operator|=
name|bp
expr_stmt|;
elseif|else
if|if
condition|(
name|ap
operator|<
operator|&
name|host_aliases
index|[
name|MAXALIASES
operator|-
literal|1
index|]
condition|)
operator|*
name|ap
operator|++
operator|=
name|bp
expr_stmt|;
else|else
name|n
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|!=
operator|-
literal|1
condition|)
block|{
name|n
operator|=
name|strlen
argument_list|(
name|bp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* for the \0 */
if|if
condition|(
name|n
operator|>=
name|MAXHOSTNAMELEN
condition|)
block|{
name|had_error
operator|++
expr_stmt|;
break|break;
block|}
name|bp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
block|}
break|break;
else|#
directive|else
name|template
operator|->
name|h_name
operator|=
name|bp
expr_stmt|;
operator|*
name|errp
operator|=
name|NETDB_SUCCESS
expr_stmt|;
return|return
operator|(
name|template
operator|)
return|;
endif|#
directive|endif
case|case
name|T_A
case|:
case|case
name|T_AAAA
case|:
name|DNS_ASSERT
argument_list|(
name|strcasecmp
argument_list|(
name|template
operator|->
name|h_name
argument_list|,
name|bp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|DNS_ASSERT
argument_list|(
name|n
operator|==
name|template
operator|->
name|h_length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|haveanswer
condition|)
block|{
name|int
name|nn
decl_stmt|;
name|template
operator|->
name|h_name
operator|=
name|bp
expr_stmt|;
name|nn
operator|=
name|strlen
argument_list|(
name|bp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* for the \0 */
name|bp
operator|+=
name|nn
expr_stmt|;
name|buflen
operator|-=
name|nn
expr_stmt|;
block|}
name|bp
operator|=
operator|(
name|char
operator|*
operator|)
name|ALIGN
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|DNS_FATAL
argument_list|(
name|bp
operator|+
name|n
operator|<
operator|&
name|hostbuf
index|[
sizeof|sizeof
name|hostbuf
index|]
argument_list|)
expr_stmt|;
name|DNS_ASSERT
argument_list|(
name|hap
operator|<
operator|&
name|h_addr_ptrs
index|[
name|MAXADDRS
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FILTER_V4MAPPED
if|if
condition|(
name|type
operator|==
name|T_AAAA
condition|)
block|{
name|struct
name|in6_addr
name|in6
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|in6
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|in6
argument_list|)
argument_list|)
expr_stmt|;
name|DNS_ASSERT
argument_list|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|in6
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|bcopy
argument_list|(
name|cp
argument_list|,
operator|*
name|hap
operator|++
operator|=
name|bp
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|erdata
condition|)
block|{
operator|*
name|errp
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|had_error
condition|)
name|haveanswer
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|haveanswer
condition|)
block|{
operator|*
name|ap
operator|=
name|NULL
expr_stmt|;
operator|*
name|hap
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|template
operator|->
name|h_name
condition|)
block|{
name|n
operator|=
name|strlen
argument_list|(
name|qname
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* for the \0 */
if|if
condition|(
name|n
operator|>
name|buflen
operator|||
name|n
operator|>=
name|MAXHOSTNAMELEN
condition|)
goto|goto
name|no_recovery
goto|;
name|strcpy
argument_list|(
name|bp
argument_list|,
name|qname
argument_list|)
expr_stmt|;
name|template
operator|->
name|h_name
operator|=
name|bp
expr_stmt|;
name|bp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
block|}
operator|*
name|errp
operator|=
name|NETDB_SUCCESS
expr_stmt|;
return|return
operator|(
name|template
operator|)
return|;
block|}
name|no_recovery
label|:
operator|*
name|errp
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
undef|#
directive|undef
name|BOUNDED_INCR
undef|#
directive|undef
name|BOUNDS_CHECK
undef|#
directive|undef
name|DNS_ASSERT
undef|#
directive|undef
name|DNS_FATAL
block|}
end_function

begin_comment
comment|/* res_search() variant with multiple query support. */
end_comment

begin_function
specifier|static
name|struct
name|hostent
modifier|*
name|_res_search_multi
parameter_list|(
name|name
parameter_list|,
name|rtl
parameter_list|,
name|errp
parameter_list|)
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* domain name */
name|struct
name|__res_type_list
modifier|*
name|rtl
decl_stmt|;
comment|/* list of query types */
name|int
modifier|*
name|errp
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
decl_stmt|const
modifier|*
name|domain
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp0
init|=
name|NULL
decl_stmt|,
modifier|*
name|hp
decl_stmt|;
name|struct
name|hostent
name|hpbuf
decl_stmt|;
name|u_int
name|dots
decl_stmt|;
name|int
name|trailing_dot
decl_stmt|,
name|ret
decl_stmt|,
name|saved_herrno
decl_stmt|;
name|int
name|got_nodata
init|=
literal|0
decl_stmt|,
name|got_servfail
init|=
literal|0
decl_stmt|,
name|tried_as_is
init|=
literal|0
decl_stmt|;
name|struct
name|__res_type_list
modifier|*
name|rtl0
init|=
name|rtl
decl_stmt|;
name|querybuf
name|buf
decl_stmt|;
if|if
condition|(
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_INIT
operator|)
operator|==
literal|0
operator|&&
name|res_init
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
operator|*
name|errp
operator|=
name|NETDB_INTERNAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|dots
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|name
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
name|dots
operator|+=
operator|(
operator|*
name|cp
operator|==
literal|'.'
operator|)
expr_stmt|;
name|trailing_dot
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cp
operator|>
name|name
operator|&&
operator|*
operator|--
name|cp
operator|==
literal|'.'
condition|)
name|trailing_dot
operator|++
expr_stmt|;
comment|/* If there aren't any dots, it could be a user-level alias */
if|if
condition|(
operator|!
name|dots
operator|&&
operator|(
name|cp
operator|=
name|hostalias
argument_list|(
name|name
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|rtl
operator|=
name|rtl0
init|;
name|rtl
operator|!=
name|NULL
condition|;
name|rtl
operator|=
name|SLIST_NEXT
argument_list|(
name|rtl
argument_list|,
name|rtl_entry
argument_list|)
control|)
block|{
name|ret
operator|=
name|res_query
argument_list|(
name|cp
argument_list|,
name|C_IN
argument_list|,
name|rtl
operator|->
name|rtl_type
argument_list|,
name|buf
operator|.
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
operator|.
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
block|{
name|hpbuf
operator|.
name|h_addrtype
operator|=
operator|(
name|rtl
operator|->
name|rtl_type
operator|==
name|T_AAAA
operator|)
condition|?
name|AF_INET6
else|:
name|AF_INET
expr_stmt|;
name|hpbuf
operator|.
name|h_length
operator|=
name|ADDRLEN
argument_list|(
name|hpbuf
operator|.
name|h_addrtype
argument_list|)
expr_stmt|;
name|hp
operator|=
name|getanswer
argument_list|(
operator|&
name|buf
argument_list|,
name|ret
argument_list|,
name|name
argument_list|,
name|rtl
operator|->
name|rtl_type
argument_list|,
operator|&
name|hpbuf
argument_list|,
name|errp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hp
condition|)
continue|continue;
name|hp
operator|=
name|_hpcopy
argument_list|(
operator|&
name|hpbuf
argument_list|,
name|errp
argument_list|)
expr_stmt|;
name|hp0
operator|=
name|_hpmerge
argument_list|(
name|hp0
argument_list|,
name|hp
argument_list|,
name|errp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|hp0
operator|)
return|;
block|}
comment|/* 	 * If there are dots in the name already, let's just give it a try 	 * 'as is'.  The threshold can be set with the "ndots" option. 	 */
name|saved_herrno
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|dots
operator|>=
name|_res
operator|.
name|ndots
condition|)
block|{
for|for
control|(
name|rtl
operator|=
name|rtl0
init|;
name|rtl
operator|!=
name|NULL
condition|;
name|rtl
operator|=
name|SLIST_NEXT
argument_list|(
name|rtl
argument_list|,
name|rtl_entry
argument_list|)
control|)
block|{
name|ret
operator|=
name|res_querydomain
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|C_IN
argument_list|,
name|rtl
operator|->
name|rtl_type
argument_list|,
name|buf
operator|.
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
operator|.
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
block|{
name|hpbuf
operator|.
name|h_addrtype
operator|=
operator|(
name|rtl
operator|->
name|rtl_type
operator|==
name|T_AAAA
operator|)
condition|?
name|AF_INET6
else|:
name|AF_INET
expr_stmt|;
name|hpbuf
operator|.
name|h_length
operator|=
name|ADDRLEN
argument_list|(
name|hpbuf
operator|.
name|h_addrtype
argument_list|)
expr_stmt|;
name|hp
operator|=
name|getanswer
argument_list|(
operator|&
name|buf
argument_list|,
name|ret
argument_list|,
name|name
argument_list|,
name|rtl
operator|->
name|rtl_type
argument_list|,
operator|&
name|hpbuf
argument_list|,
name|errp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hp
condition|)
continue|continue;
name|hp
operator|=
name|_hpcopy
argument_list|(
operator|&
name|hpbuf
argument_list|,
name|errp
argument_list|)
expr_stmt|;
name|hp0
operator|=
name|_hpmerge
argument_list|(
name|hp0
argument_list|,
name|hp
argument_list|,
name|errp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hp0
operator|!=
name|NULL
condition|)
return|return
operator|(
name|hp0
operator|)
return|;
name|saved_herrno
operator|=
operator|*
name|errp
expr_stmt|;
name|tried_as_is
operator|++
expr_stmt|;
block|}
comment|/* 	 * We do at least one level of search if 	 *	- there is no dot and RES_DEFNAME is set, or 	 *	- there is at least one dot, there is no trailing dot, 	 *	  and RES_DNSRCH is set. 	 */
if|if
condition|(
operator|(
operator|!
name|dots
operator|&&
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_DEFNAMES
operator|)
operator|)
operator|||
operator|(
name|dots
operator|&&
operator|!
name|trailing_dot
operator|&&
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_DNSRCH
operator|)
operator|)
condition|)
block|{
name|int
name|done
init|=
literal|0
decl_stmt|;
for|for
control|(
name|domain
operator|=
operator|(
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|)
name|_res
operator|.
name|dnsrch
init|;
operator|*
name|domain
operator|&&
operator|!
name|done
condition|;
name|domain
operator|++
control|)
block|{
for|for
control|(
name|rtl
operator|=
name|rtl0
init|;
name|rtl
operator|!=
name|NULL
condition|;
name|rtl
operator|=
name|SLIST_NEXT
argument_list|(
name|rtl
argument_list|,
name|rtl_entry
argument_list|)
control|)
block|{
name|ret
operator|=
name|res_querydomain
argument_list|(
name|name
argument_list|,
operator|*
name|domain
argument_list|,
name|C_IN
argument_list|,
name|rtl
operator|->
name|rtl_type
argument_list|,
name|buf
operator|.
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
operator|.
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
block|{
name|hpbuf
operator|.
name|h_addrtype
operator|=
operator|(
name|rtl
operator|->
name|rtl_type
operator|==
name|T_AAAA
operator|)
condition|?
name|AF_INET6
else|:
name|AF_INET
expr_stmt|;
name|hpbuf
operator|.
name|h_length
operator|=
name|ADDRLEN
argument_list|(
name|hpbuf
operator|.
name|h_addrtype
argument_list|)
expr_stmt|;
name|hp
operator|=
name|getanswer
argument_list|(
operator|&
name|buf
argument_list|,
name|ret
argument_list|,
name|name
argument_list|,
name|rtl
operator|->
name|rtl_type
argument_list|,
operator|&
name|hpbuf
argument_list|,
name|errp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hp
condition|)
continue|continue;
name|hp
operator|=
name|_hpcopy
argument_list|(
operator|&
name|hpbuf
argument_list|,
name|errp
argument_list|)
expr_stmt|;
name|hp0
operator|=
name|_hpmerge
argument_list|(
name|hp0
argument_list|,
name|hp
argument_list|,
name|errp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hp0
operator|!=
name|NULL
condition|)
return|return
operator|(
name|hp0
operator|)
return|;
comment|/* 			 * If no server present, give up. 			 * If name isn't found in this domain, 			 * keep trying higher domains in the search list 			 * (if that's enabled). 			 * On a NO_DATA error, keep trying, otherwise 			 * a wildcard entry of another type could keep us 			 * from finding this entry higher in the domain. 			 * If we get some other error (negative answer or 			 * server failure), then stop searching up, 			 * but try the input name below in case it's 			 * fully-qualified. 			 */
if|if
condition|(
name|errno
operator|==
name|ECONNREFUSED
condition|)
block|{
operator|*
name|errp
operator|=
name|TRY_AGAIN
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
switch|switch
condition|(
operator|*
name|errp
condition|)
block|{
case|case
name|NO_DATA
case|:
name|got_nodata
operator|++
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|HOST_NOT_FOUND
case|:
comment|/* keep trying */
break|break;
case|case
name|TRY_AGAIN
case|:
if|if
condition|(
name|buf
operator|.
name|hdr
operator|.
name|rcode
operator|==
name|SERVFAIL
condition|)
block|{
comment|/* try next search element, if any */
name|got_servfail
operator|++
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
default|default:
comment|/* anything else implies that we're done */
name|done
operator|++
expr_stmt|;
block|}
comment|/* if we got here for some reason other than DNSRCH, 			 * we only wanted one iteration of the loop, so stop. 			 */
if|if
condition|(
operator|!
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_DNSRCH
operator|)
condition|)
name|done
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * If we have not already tried the name "as is", do that now. 	 * note that we do this regardless of how many dots were in the 	 * name or whether it ends with a dot unless NOTLDQUERY is set. 	 */
if|if
condition|(
operator|!
name|tried_as_is
operator|&&
operator|(
name|dots
operator|||
operator|!
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_NOTLDQUERY
operator|)
operator|)
condition|)
block|{
for|for
control|(
name|rtl
operator|=
name|rtl0
init|;
name|rtl
operator|!=
name|NULL
condition|;
name|rtl
operator|=
name|SLIST_NEXT
argument_list|(
name|rtl
argument_list|,
name|rtl_entry
argument_list|)
control|)
block|{
name|ret
operator|=
name|res_querydomain
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|C_IN
argument_list|,
name|rtl
operator|->
name|rtl_type
argument_list|,
name|buf
operator|.
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
operator|.
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
block|{
name|hpbuf
operator|.
name|h_addrtype
operator|=
operator|(
name|rtl
operator|->
name|rtl_type
operator|==
name|T_AAAA
operator|)
condition|?
name|AF_INET6
else|:
name|AF_INET
expr_stmt|;
name|hpbuf
operator|.
name|h_length
operator|=
name|ADDRLEN
argument_list|(
name|hpbuf
operator|.
name|h_addrtype
argument_list|)
expr_stmt|;
name|hp
operator|=
name|getanswer
argument_list|(
operator|&
name|buf
argument_list|,
name|ret
argument_list|,
name|name
argument_list|,
name|rtl
operator|->
name|rtl_type
argument_list|,
operator|&
name|hpbuf
argument_list|,
name|errp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hp
condition|)
continue|continue;
name|hp
operator|=
name|_hpcopy
argument_list|(
operator|&
name|hpbuf
argument_list|,
name|errp
argument_list|)
expr_stmt|;
name|hp0
operator|=
name|_hpmerge
argument_list|(
name|hp0
argument_list|,
name|hp
argument_list|,
name|errp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|hp0
operator|!=
name|NULL
condition|)
return|return
operator|(
name|hp0
operator|)
return|;
block|}
comment|/* if we got here, we didn't satisfy the search. 	 * if we did an initial full query, return that query's h_errno 	 * (note that we wouldn't be here if that query had succeeded). 	 * else if we ever got a nodata, send that back as the reason. 	 * else send back meaningless h_errno, that being the one from 	 * the last DNSRCH we did. 	 */
if|if
condition|(
name|saved_herrno
operator|!=
operator|-
literal|1
condition|)
operator|*
name|errp
operator|=
name|saved_herrno
expr_stmt|;
elseif|else
if|if
condition|(
name|got_nodata
condition|)
operator|*
name|errp
operator|=
name|NO_DATA
expr_stmt|;
elseif|else
if|if
condition|(
name|got_servfail
condition|)
operator|*
name|errp
operator|=
name|TRY_AGAIN
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_dns_ghbyname
parameter_list|(
name|void
modifier|*
name|rval
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|af
decl_stmt|;
name|int
modifier|*
name|errp
decl_stmt|;
name|struct
name|__res_type_list
modifier|*
name|rtl
decl_stmt|,
name|rtl4
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|__res_type_list
name|rtl6
decl_stmt|;
endif|#
directive|endif
name|name
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|af
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|errp
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
operator|*
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
switch|switch
condition|(
name|af
condition|)
block|{
case|case
name|AF_UNSPEC
case|:
name|SLIST_NEXT
argument_list|(
operator|&
name|rtl4
argument_list|,
name|rtl_entry
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|rtl4
operator|.
name|rtl_type
operator|=
name|T_A
expr_stmt|;
name|SLIST_NEXT
argument_list|(
operator|&
name|rtl6
argument_list|,
name|rtl_entry
argument_list|)
operator|=
operator|&
name|rtl4
expr_stmt|;
name|rtl6
operator|.
name|rtl_type
operator|=
name|T_AAAA
expr_stmt|;
name|rtl
operator|=
operator|&
name|rtl6
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
name|SLIST_NEXT
argument_list|(
operator|&
name|rtl6
argument_list|,
name|rtl_entry
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|rtl6
operator|.
name|rtl_type
operator|=
name|T_AAAA
expr_stmt|;
name|rtl
operator|=
operator|&
name|rtl6
expr_stmt|;
break|break;
case|case
name|AF_INET
case|:
name|SLIST_NEXT
argument_list|(
operator|&
name|rtl4
argument_list|,
name|rtl_entry
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|rtl4
operator|.
name|rtl_type
operator|=
name|T_A
expr_stmt|;
name|rtl
operator|=
operator|&
name|rtl4
expr_stmt|;
break|break;
block|}
else|#
directive|else
name|SLIST_NEXT
argument_list|(
operator|&
name|rtl4
argument_list|,
name|rtl_entry
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|rtl4
operator|.
name|rtl_type
operator|=
name|T_A
expr_stmt|;
name|rtl
operator|=
operator|&
name|rtl4
expr_stmt|;
endif|#
directive|endif
operator|*
operator|(
expr|struct
name|hostent
operator|*
operator|*
operator|)
name|rval
operator|=
name|_res_search_multi
argument_list|(
name|name
argument_list|,
name|rtl
argument_list|,
name|errp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
operator|(
expr|struct
name|hostent
operator|*
operator|*
operator|)
name|rval
operator|!=
name|NULL
operator|)
condition|?
name|NS_SUCCESS
else|:
name|NS_NOTFOUND
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_dns_ghbyaddr
parameter_list|(
name|void
modifier|*
name|rval
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|addr
decl_stmt|;
name|int
name|addrlen
decl_stmt|;
name|int
name|af
decl_stmt|;
name|int
modifier|*
name|errp
decl_stmt|;
name|int
name|n
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|u_char
name|c
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|;
name|struct
name|hostent
name|hbuf
decl_stmt|;
name|int
name|na
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
specifier|static
specifier|const
name|char
name|hex
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
endif|#
directive|endif
name|querybuf
name|buf
decl_stmt|;
name|char
name|qbuf
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|hlist
index|[
literal|2
index|]
decl_stmt|;
name|addr
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
expr_stmt|;
name|addrlen
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|af
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|errp
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
operator|*
argument_list|)
expr_stmt|;
operator|*
operator|(
expr|struct
name|hostent
operator|*
operator|*
operator|)
name|rval
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
comment|/* XXX */
if|if
condition|(
name|af
operator|==
name|AF_INET6
operator|&&
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|(
expr|struct
name|in6_addr
operator|*
operator|)
name|addr
argument_list|)
condition|)
return|return
name|NS_NOTFOUND
return|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_INIT
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|res_init
argument_list|()
operator|<
literal|0
condition|)
block|{
operator|*
name|errp
operator|=
name|h_errno
expr_stmt|;
return|return
name|NS_UNAVAIL
return|;
block|}
block|}
name|memset
argument_list|(
operator|&
name|hbuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hbuf
argument_list|)
argument_list|)
expr_stmt|;
name|hbuf
operator|.
name|h_name
operator|=
name|NULL
expr_stmt|;
name|hbuf
operator|.
name|h_addrtype
operator|=
name|af
expr_stmt|;
name|hbuf
operator|.
name|h_length
operator|=
name|addrlen
expr_stmt|;
name|na
operator|=
literal|0
expr_stmt|;
comment|/* XXX assumes that MAXDNAME is big enough */
name|n
operator|=
literal|0
expr_stmt|;
name|bp
operator|=
name|qbuf
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|addr
operator|+
name|addrlen
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
for|for
control|(
init|;
name|n
operator|<
name|addrlen
condition|;
name|n
operator|++
operator|,
name|cp
operator|--
control|)
block|{
name|c
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
name|hex
index|[
name|c
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
name|hex
index|[
name|c
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|bp
argument_list|,
literal|"ip6.int"
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
for|for
control|(
init|;
name|n
operator|<
name|addrlen
condition|;
name|n
operator|++
operator|,
name|cp
operator|--
control|)
block|{
name|c
operator|=
operator|*
name|cp
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|100
condition|)
operator|*
name|bp
operator|++
operator|=
literal|'0'
operator|+
name|c
operator|/
literal|100
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|10
condition|)
operator|*
name|bp
operator|++
operator|=
literal|'0'
operator|+
operator|(
name|c
operator|%
literal|100
operator|)
operator|/
literal|10
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'0'
operator|+
name|c
operator|%
literal|10
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|bp
argument_list|,
literal|"in-addr.arpa"
argument_list|)
expr_stmt|;
break|break;
block|}
name|n
operator|=
name|res_query
argument_list|(
name|qbuf
argument_list|,
name|C_IN
argument_list|,
name|T_PTR
argument_list|,
name|buf
operator|.
name|buf
argument_list|,
sizeof|sizeof
name|buf
operator|.
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
operator|*
name|errp
operator|=
name|h_errno
expr_stmt|;
return|return
name|NS_UNAVAIL
return|;
block|}
name|hp
operator|=
name|getanswer
argument_list|(
operator|&
name|buf
argument_list|,
name|n
argument_list|,
name|qbuf
argument_list|,
name|T_PTR
argument_list|,
operator|&
name|hbuf
argument_list|,
name|errp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hp
condition|)
return|return
name|NS_NOTFOUND
return|;
name|hbuf
operator|.
name|h_addrtype
operator|=
name|af
expr_stmt|;
name|hbuf
operator|.
name|h_length
operator|=
name|addrlen
expr_stmt|;
name|hbuf
operator|.
name|h_addr_list
operator|=
name|hlist
expr_stmt|;
name|hlist
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|addr
expr_stmt|;
name|hlist
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
operator|(
expr|struct
name|hostent
operator|*
operator|*
operator|)
name|rval
operator|=
name|_hpcopy
argument_list|(
operator|&
name|hbuf
argument_list|,
name|errp
argument_list|)
expr_stmt|;
return|return
name|NS_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_dns_shent
parameter_list|(
name|int
name|stayopen
parameter_list|)
block|{
if|if
condition|(
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_INIT
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|res_init
argument_list|()
operator|<
literal|0
condition|)
return|return;
block|}
if|if
condition|(
name|stayopen
condition|)
name|_res
operator|.
name|options
operator||=
name|RES_STAYOPEN
operator||
name|RES_USEVC
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_dns_ehent
parameter_list|(
name|void
parameter_list|)
block|{
name|_res
operator|.
name|options
operator|&=
operator|~
operator|(
name|RES_STAYOPEN
operator||
name|RES_USEVC
operator|)
expr_stmt|;
name|res_close
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ICMPNL
end_ifdef

begin_comment
comment|/*  * experimental:  *	draft-ietf-ipngwg-icmp-namelookups-02.txt  *	ifindex is assumed to be encoded in addr.  */
end_comment

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/icmp6.h>
end_include

begin_struct
struct|struct
name|_icmp_host_cache
block|{
name|struct
name|_icmp_host_cache
modifier|*
name|hc_next
decl_stmt|;
name|int
name|hc_ifindex
decl_stmt|;
name|struct
name|in6_addr
name|hc_addr
decl_stmt|;
name|char
modifier|*
name|hc_name
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|char
modifier|*
name|_icmp_fqdn_query
parameter_list|(
specifier|const
name|struct
name|in6_addr
modifier|*
name|addr
parameter_list|,
name|int
name|ifindex
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|struct
name|icmp6_filter
name|filter
decl_stmt|;
name|struct
name|msghdr
name|msg
decl_stmt|;
name|struct
name|cmsghdr
modifier|*
name|cmsg
decl_stmt|;
name|struct
name|in6_pktinfo
modifier|*
name|pkt
decl_stmt|;
name|char
name|cbuf
index|[
literal|256
index|]
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|cc
decl_stmt|;
name|struct
name|icmp6_fqdn_query
modifier|*
name|fq
decl_stmt|;
name|struct
name|icmp6_fqdn_reply
modifier|*
name|fr
decl_stmt|;
name|struct
name|_icmp_host_cache
modifier|*
name|hc
decl_stmt|;
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
name|struct
name|iovec
name|iov
decl_stmt|;
name|fd_set
name|s_fds
decl_stmt|,
name|fds
decl_stmt|;
name|struct
name|timeval
name|tout
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
specifier|static
name|int
name|pid
decl_stmt|;
specifier|static
name|struct
name|_icmp_host_cache
modifier|*
name|hc_head
decl_stmt|;
for|for
control|(
name|hc
operator|=
name|hc_head
init|;
name|hc
condition|;
name|hc
operator|=
name|hc
operator|->
name|hc_next
control|)
block|{
if|if
condition|(
name|hc
operator|->
name|hc_ifindex
operator|==
name|ifindex
operator|&&
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|hc
operator|->
name|hc_addr
argument_list|,
name|addr
argument_list|)
condition|)
return|return
name|hc
operator|->
name|hc_name
return|;
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|ICMP6_FILTER_SETBLOCKALL
argument_list|(
operator|&
name|filter
argument_list|)
expr_stmt|;
name|ICMP6_FILTER_SETPASS
argument_list|(
name|ICMP6_FQDN_REPLY
argument_list|,
operator|&
name|filter
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|s_fds
argument_list|)
expr_stmt|;
name|tout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|tout
operator|.
name|tv_usec
operator|=
literal|200000
expr_stmt|;
comment|/*XXX: 200ms*/
name|fq
operator|=
operator|(
expr|struct
name|icmp6_fqdn_query
operator|*
operator|)
name|buf
expr_stmt|;
name|fq
operator|->
name|icmp6_fqdn_type
operator|=
name|ICMP6_FQDN_QUERY
expr_stmt|;
name|fq
operator|->
name|icmp6_fqdn_code
operator|=
literal|0
expr_stmt|;
name|fq
operator|->
name|icmp6_fqdn_cksum
operator|=
literal|0
expr_stmt|;
name|fq
operator|->
name|icmp6_fqdn_id
operator|=
operator|(
name|u_short
operator|)
name|pid
expr_stmt|;
name|fq
operator|->
name|icmp6_fqdn_unused
operator|=
literal|0
expr_stmt|;
name|fq
operator|->
name|icmp6_fqdn_cookie
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|fq
operator|->
name|icmp6_fqdn_cookie
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sin6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|.
name|sin6_addr
operator|=
operator|*
name|addr
expr_stmt|;
name|memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|.
name|msg_name
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|sin6
expr_stmt|;
name|msg
operator|.
name|msg_namelen
operator|=
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
name|msg
operator|.
name|msg_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|msg
operator|.
name|msg_iovlen
operator|=
literal|1
expr_stmt|;
name|msg
operator|.
name|msg_control
operator|=
name|NULL
expr_stmt|;
name|msg
operator|.
name|msg_controllen
operator|=
literal|0
expr_stmt|;
name|iov
operator|.
name|iov_base
operator|=
operator|(
name|caddr_t
operator|)
name|buf
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|icmp6_fqdn_query
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifindex
condition|)
block|{
name|msg
operator|.
name|msg_control
operator|=
name|cbuf
expr_stmt|;
name|msg
operator|.
name|msg_controllen
operator|=
sizeof|sizeof
argument_list|(
name|cbuf
argument_list|)
expr_stmt|;
name|cmsg
operator|=
name|CMSG_FIRSTHDR
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
name|cmsg
operator|->
name|cmsg_len
operator|=
name|CMSG_LEN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_pktinfo
argument_list|)
argument_list|)
expr_stmt|;
name|cmsg
operator|->
name|cmsg_level
operator|=
name|IPPROTO_IPV6
expr_stmt|;
name|cmsg
operator|->
name|cmsg_type
operator|=
name|IPV6_PKTINFO
expr_stmt|;
name|pkt
operator|=
operator|(
expr|struct
name|in6_pktinfo
operator|*
operator|)
operator|&
name|cmsg
index|[
literal|1
index|]
expr_stmt|;
name|memset
argument_list|(
operator|&
name|pkt
operator|->
name|ipi6_addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|pkt
operator|->
name|ipi6_ifindex
operator|=
name|ifindex
expr_stmt|;
name|cmsg
operator|=
name|CMSG_NXTHDR
argument_list|(
operator|&
name|msg
argument_list|,
name|cmsg
argument_list|)
expr_stmt|;
name|msg
operator|.
name|msg_controllen
operator|=
operator|(
name|char
operator|*
operator|)
name|cmsg
operator|-
name|cbuf
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|s
operator|=
name|_socket
argument_list|(
name|PF_INET6
argument_list|,
name|SOCK_RAW
argument_list|,
name|IPPROTO_ICMPV6
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
operator|(
name|void
operator|)
name|_setsockopt
argument_list|(
name|s
argument_list|,
name|IPPROTO_ICMPV6
argument_list|,
name|ICMP6_FILTER
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|filter
argument_list|,
sizeof|sizeof
argument_list|(
name|filter
argument_list|)
argument_list|)
expr_stmt|;
name|cc
operator|=
name|_sendmsg
argument_list|(
name|s
argument_list|,
operator|&
name|msg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|<
literal|0
condition|)
block|{
name|_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|FD_SET
argument_list|(
name|s
argument_list|,
operator|&
name|s_fds
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|fds
operator|=
name|s_fds
expr_stmt|;
if|if
condition|(
name|_select
argument_list|(
name|s
operator|+
literal|1
argument_list|,
operator|&
name|fds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|tout
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|len
operator|=
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
name|cc
operator|=
name|_recvfrom
argument_list|(
name|s
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|<=
literal|0
condition|)
block|{
name|_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|cc
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|icmp6_hdr
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|IN6_ARE_ADDR_EQUAL
argument_list|(
name|addr
argument_list|,
operator|&
name|sin6
operator|.
name|sin6_addr
argument_list|)
condition|)
continue|continue;
name|fr
operator|=
operator|(
expr|struct
name|icmp6_fqdn_reply
operator|*
operator|)
operator|(
name|buf
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|fr
operator|->
name|icmp6_fqdn_type
operator|==
name|ICMP6_FQDN_REPLY
condition|)
break|break;
block|}
name|_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr
operator|->
name|icmp6_fqdn_cookie
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* rfc1788 type */
name|name
operator|=
name|buf
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|icmp6_hdr
argument_list|)
operator|+
literal|4
expr_stmt|;
name|len
operator|=
operator|(
name|buf
operator|+
name|cc
operator|)
operator|-
name|name
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|fr
operator|->
name|icmp6_fqdn_namelen
expr_stmt|;
name|name
operator|=
name|fr
operator|->
name|icmp6_fqdn_name
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
return|return
name|NULL
return|;
name|name
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|hc
operator|=
operator|(
expr|struct
name|_icmp_host_cache
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|hc
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* XXX: limit number of cached entries */
name|hc
operator|->
name|hc_ifindex
operator|=
name|ifindex
expr_stmt|;
name|hc
operator|->
name|hc_addr
operator|=
operator|*
name|addr
expr_stmt|;
name|hc
operator|->
name|hc_name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|hc
operator|->
name|hc_next
operator|=
name|hc_head
expr_stmt|;
name|hc_head
operator|=
name|hc
expr_stmt|;
return|return
name|hc
operator|->
name|hc_name
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|hostent
modifier|*
name|_icmp_ghbyaddr
parameter_list|(
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|int
name|addrlen
parameter_list|,
name|int
name|af
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
block|{
name|char
modifier|*
name|hname
decl_stmt|;
name|int
name|ifindex
decl_stmt|;
name|struct
name|in6_addr
name|addr6
decl_stmt|;
if|if
condition|(
name|af
operator|!=
name|AF_INET6
condition|)
block|{
comment|/* 		 * Note: rfc1788 defines Who Are You for IPv4, 		 * but no one implements it. 		 */
return|return
name|NULL
return|;
block|}
name|memcpy
argument_list|(
operator|&
name|addr6
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
name|ifindex
operator|=
operator|(
name|addr6
operator|.
name|s6_addr
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|addr6
operator|.
name|s6_addr
index|[
literal|3
index|]
expr_stmt|;
name|addr6
operator|.
name|s6_addr
index|[
literal|2
index|]
operator|=
name|addr6
operator|.
name|s6_addr
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|addr6
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/*XXX*/
if|if
condition|(
operator|(
name|hname
operator|=
name|_icmp_fqdn_query
argument_list|(
operator|&
name|addr6
argument_list|,
name|ifindex
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
name|_hpaddr
argument_list|(
name|af
argument_list|,
name|hname
argument_list|,
operator|&
name|addr6
argument_list|,
name|errp
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ICMPNL */
end_comment

end_unit

