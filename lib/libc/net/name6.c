begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$KAME: name6.c,v 1.25 2000/06/26 16:44:40 itojun Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (C) 1995, 1996, 1997, 1998, and 1999 WIDE Project.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the project nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * ++Copyright++ 1985, 1988, 1993  * -  * Copyright (c) 1985, 1988, 1993  *    The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  * 	This product includes software developed by the University of  * 	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  * -  * Portions Copyright (c) 1993 by Digital Equipment Corporation.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies, and that  * the name of Digital Equipment Corporation not be used in advertising or  * publicity pertaining to distribution of the document or software without  * specific, written prior permission.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL  * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT  * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  * -  * --Copyright--  */
end_comment

begin_comment
comment|/*  *	Atsushi Onoe<onoe@sm.sony.co.jp>  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"namespace.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|YP
argument_list|)
operator|||
name|defined
argument_list|(
name|ICMPNL
argument_list|)
end_if

begin_include
include|#
directive|include
file|"reentrant.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<net/if_var.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<netinet6/in6_var.h>
end_include

begin_comment
comment|/* XXX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<nsswitch.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"un-namespace.h"
end_include

begin_include
include|#
directive|include
file|"netdb_private.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|_PATH_HOSTS
end_ifndef

begin_define
define|#
directive|define
name|_PATH_HOSTS
value|"/etc/hosts"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAXALIASES
end_ifndef

begin_define
define|#
directive|define
name|MAXALIASES
value|10
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAXADDRS
end_ifndef

begin_define
define|#
directive|define
name|MAXADDRS
value|20
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAXDNAME
end_ifndef

begin_define
define|#
directive|define
name|MAXDNAME
value|1025
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_define
define|#
directive|define
name|ADDRLEN
parameter_list|(
name|af
parameter_list|)
value|((af) == AF_INET6 ? sizeof(struct in6_addr) : \ 					    sizeof(struct in_addr))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ADDRLEN
parameter_list|(
name|af
parameter_list|)
value|sizeof(struct in_addr)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAPADDR
parameter_list|(
name|ab
parameter_list|,
name|ina
parameter_list|)
define|\
value|do {									\ 	memcpy(&(ab)->map_inaddr, ina, sizeof(struct in_addr));		\ 	memset((ab)->map_zero, 0, sizeof((ab)->map_zero));		\ 	memset((ab)->map_one, 0xff, sizeof((ab)->map_one));		\ } while (0)
end_define

begin_define
define|#
directive|define
name|MAPADDRENABLED
parameter_list|(
name|flags
parameter_list|)
define|\
value|(((flags)& AI_V4MAPPED) || \ 	 (((flags)& AI_V4MAPPED_CFG)&& _mapped_addr_enabled()))
end_define

begin_union
union|union
name|inx_addr
block|{
name|struct
name|in_addr
name|in_addr
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|in6_addr
name|in6_addr
decl_stmt|;
endif|#
directive|endif
struct|struct
block|{
name|u_char
name|mau_zero
index|[
literal|10
index|]
decl_stmt|;
name|u_char
name|mau_one
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|in_addr
name|mau_inaddr
decl_stmt|;
block|}
name|map_addr_un
struct|;
define|#
directive|define
name|map_zero
value|map_addr_un.mau_zero
define|#
directive|define
name|map_one
value|map_addr_un.mau_one
define|#
directive|define
name|map_inaddr
value|map_addr_un.mau_inaddr
block|}
union|;
end_union

begin_struct
struct|struct
name|policyqueue
block|{
name|TAILQ_ENTRY
argument_list|(
argument|policyqueue
argument_list|)
name|pc_entry
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|in6_addrpolicy
name|pc_policy
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_expr_stmt
name|TAILQ_HEAD
argument_list|(
name|policyhead
argument_list|,
name|policyqueue
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|AIO_SRCFLAG_DEPRECATED
value|0x1
end_define

begin_struct
struct|struct
name|hp_order
block|{
union|union
block|{
name|struct
name|sockaddr_storage
name|aiou_ss
decl_stmt|;
name|struct
name|sockaddr
name|aiou_sa
decl_stmt|;
block|}
name|aio_src_un
union|;
define|#
directive|define
name|aio_srcsa
value|aio_src_un.aiou_sa
name|u_int32_t
name|aio_srcflag
decl_stmt|;
name|int
name|aio_srcscope
decl_stmt|;
name|int
name|aio_dstscope
decl_stmt|;
name|struct
name|policyqueue
modifier|*
name|aio_srcpolicy
decl_stmt|;
name|struct
name|policyqueue
modifier|*
name|aio_dstpolicy
decl_stmt|;
union|union
block|{
name|struct
name|sockaddr_storage
name|aiou_ss
decl_stmt|;
name|struct
name|sockaddr
name|aiou_sa
decl_stmt|;
block|}
name|aio_un
union|;
define|#
directive|define
name|aio_sa
value|aio_un.aiou_sa
name|int
name|aio_matchlen
decl_stmt|;
name|u_char
modifier|*
name|aio_h_addr
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|struct
name|hostent
modifier|*
name|_hpcopy
parameter_list|(
name|struct
name|hostent
modifier|*
name|hp
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|hostent
modifier|*
name|_hpaddr
parameter_list|(
name|int
name|af
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|hostent
modifier|*
name|_hpmerge
parameter_list|(
name|struct
name|hostent
modifier|*
name|hp1
parameter_list|,
name|struct
name|hostent
modifier|*
name|hp2
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function_decl
specifier|static
name|struct
name|hostent
modifier|*
name|_hpmapv6
parameter_list|(
name|struct
name|hostent
modifier|*
name|hp
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|struct
name|hostent
modifier|*
name|_hpsort
parameter_list|(
name|struct
name|hostent
modifier|*
name|hp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|hostent
modifier|*
name|_ghbyname
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|af
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|_hgetword
parameter_list|(
name|char
modifier|*
modifier|*
name|pp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_mapped_addr_enabled
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|hostent
modifier|*
name|_hpreorder
parameter_list|(
name|struct
name|hostent
modifier|*
name|hp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_addrselectpolicy
parameter_list|(
name|struct
name|policyhead
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_addrselectpolicy
parameter_list|(
name|struct
name|policyhead
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|policyqueue
modifier|*
name|match_addrselectpolicy
parameter_list|(
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|struct
name|policyhead
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_source
parameter_list|(
name|struct
name|hp_order
modifier|*
parameter_list|,
name|struct
name|policyhead
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|matchlen
parameter_list|(
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|struct
name|sockaddr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|comp_dst
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gai_addr2scopetype
parameter_list|(
name|struct
name|sockaddr
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|FILE
modifier|*
name|_files_open
parameter_list|(
name|int
modifier|*
name|errp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_files_ghbyname
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|va_list
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_files_ghbyaddr
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|va_list
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|YP
end_ifdef

begin_function_decl
specifier|static
name|int
name|_nis_ghbyname
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|va_list
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_nis_ghbyaddr
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|va_list
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|_dns_ghbyname
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|va_list
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_dns_ghbyaddr
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|va_list
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|void
name|_dns_shent
argument_list|(
name|int
name|stayopen
argument_list|)
name|__unused
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|_dns_ehent
argument_list|(
name|void
argument_list|)
name|__unused
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ICMPNL
end_ifdef

begin_function_decl
specifier|static
name|int
name|_icmp_ghbyaddr
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|va_list
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ICMPNL */
end_comment

begin_comment
comment|/*  * XXX: Many dependencies are not thread-safe.  Still, we cannot use  * getipnodeby*() in conjunction with other functions which call them.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|YP
argument_list|)
operator|||
name|defined
argument_list|(
name|ICMPNL
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|mutex_t
name|_getipnodeby_thread_lock
init|=
name|MUTEX_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|THREAD_LOCK
parameter_list|()
value|mutex_lock(&_getipnodeby_thread_lock);
end_define

begin_define
define|#
directive|define
name|THREAD_UNLOCK
parameter_list|()
value|mutex_unlock(&_getipnodeby_thread_lock);
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Host lookup order if nsswitch.conf is broken or nonexistant */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|ns_src
name|default_src
index|[]
init|=
block|{
block|{
name|NSSRC_FILES
block|,
name|NS_SUCCESS
block|}
block|,
block|{
name|NSSRC_DNS
block|,
name|NS_SUCCESS
block|}
block|,
ifdef|#
directive|ifdef
name|ICMPNL
define|#
directive|define
name|NSSRC_ICMP
value|"icmp"
block|{
name|NSSRC_ICMP
block|,
name|NS_SUCCESS
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Check if kernel supports mapped address.  *	implementation dependent  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__KAME__
end_ifdef

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __KAME__ */
end_comment

begin_function
specifier|static
name|int
name|_mapped_addr_enabled
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* implementation dependent check */
if|#
directive|if
name|defined
argument_list|(
name|__KAME__
argument_list|)
operator|&&
name|defined
argument_list|(
name|IPV6CTL_MAPPED_ADDR
argument_list|)
name|int
name|mib
index|[
literal|4
index|]
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|val
decl_stmt|;
name|mib
index|[
literal|0
index|]
operator|=
name|CTL_NET
expr_stmt|;
name|mib
index|[
literal|1
index|]
operator|=
name|PF_INET6
expr_stmt|;
name|mib
index|[
literal|2
index|]
operator|=
name|IPPROTO_IPV6
expr_stmt|;
name|mib
index|[
literal|3
index|]
operator|=
name|IPV6CTL_MAPPED_ADDR
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|4
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|len
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|&&
name|val
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
endif|#
directive|endif
comment|/* __KAME__&& IPV6CTL_MAPPED_ADDR */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Functions defined in RFC2553  *	getipnodebyname, getipnodebyaddr, freehostent  */
end_comment

begin_function
specifier|static
name|struct
name|hostent
modifier|*
name|_ghbyname
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|af
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|int
name|rval
decl_stmt|;
specifier|static
specifier|const
name|ns_dtab
name|dtab
index|[]
init|=
block|{
name|NS_FILES_CB
argument_list|(
argument|_files_ghbyname
argument_list|,
argument|NULL
argument_list|)
block|{
name|NSSRC_DNS
block|,
name|_dns_ghbyname
block|,
name|NULL
block|}
block|,
name|NS_NIS_CB
argument_list|(
argument|_nis_ghbyname
argument_list|,
argument|NULL
argument_list|)
block|{
literal|0
block|}
block|}
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|AI_ADDRCONFIG
condition|)
block|{
name|int
name|s
decl_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|_socket
argument_list|(
name|af
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
comment|/* 		 * TODO: 		 * Note that implementation dependent test for address 		 * configuration should be done everytime called 		 * (or apropriate interval), 		 * because addresses will be dynamically assigned or deleted. 		 */
name|_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|rval
operator|=
name|_nsdispatch
argument_list|(
operator|&
name|hp
argument_list|,
name|dtab
argument_list|,
name|NSDB_HOSTS
argument_list|,
literal|"ghbyname"
argument_list|,
name|default_src
argument_list|,
name|name
argument_list|,
name|af
argument_list|,
name|errp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|==
name|NS_SUCCESS
operator|)
condition|?
name|hp
else|:
name|NULL
return|;
block|}
end_function

begin_function
name|struct
name|hostent
modifier|*
name|getipnodebyname
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|af
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|union
name|inx_addr
name|addrbuf
decl_stmt|;
if|if
condition|(
name|af
operator|!=
name|AF_INET
ifdef|#
directive|ifdef
name|INET6
operator|&&
name|af
operator|!=
name|AF_INET6
endif|#
directive|endif
condition|)
block|{
operator|*
name|errp
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
name|NULL
return|;
block|}
ifdef|#
directive|ifdef
name|INET6
comment|/* special case for literal address */
if|if
condition|(
name|inet_pton
argument_list|(
name|AF_INET6
argument_list|,
name|name
argument_list|,
operator|&
name|addrbuf
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|af
operator|!=
name|AF_INET6
condition|)
block|{
operator|*
name|errp
operator|=
name|HOST_NOT_FOUND
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|_hpaddr
argument_list|(
name|af
argument_list|,
name|name
argument_list|,
operator|&
name|addrbuf
argument_list|,
name|errp
argument_list|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
name|inet_aton
argument_list|(
name|name
argument_list|,
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|&
name|addrbuf
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|af
operator|!=
name|AF_INET
condition|)
block|{
if|if
condition|(
name|MAPADDRENABLED
argument_list|(
name|flags
argument_list|)
condition|)
block|{
name|MAPADDR
argument_list|(
operator|&
name|addrbuf
argument_list|,
operator|&
name|addrbuf
operator|.
name|in_addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|errp
operator|=
name|HOST_NOT_FOUND
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
return|return
name|_hpaddr
argument_list|(
name|af
argument_list|,
name|name
argument_list|,
operator|&
name|addrbuf
argument_list|,
name|errp
argument_list|)
return|;
block|}
operator|*
name|errp
operator|=
name|HOST_NOT_FOUND
expr_stmt|;
name|hp
operator|=
name|_ghbyname
argument_list|(
name|name
argument_list|,
name|af
argument_list|,
name|flags
argument_list|,
name|errp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|af
operator|==
name|AF_INET6
operator|&&
operator|(
operator|(
name|flags
operator|&
name|AI_ALL
operator|)
operator|||
name|hp
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|MAPADDRENABLED
argument_list|(
name|flags
argument_list|)
operator|)
condition|)
block|{
name|struct
name|hostent
modifier|*
name|hp2
init|=
name|_ghbyname
argument_list|(
name|name
argument_list|,
name|AF_INET
argument_list|,
name|flags
argument_list|,
name|errp
argument_list|)
decl_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
name|hp
operator|=
name|_hpmapv6
argument_list|(
name|hp2
argument_list|,
name|errp
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|hp2
operator|&&
name|strcmp
argument_list|(
name|hp
operator|->
name|h_name
argument_list|,
name|hp2
operator|->
name|h_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|freehostent
argument_list|(
name|hp2
argument_list|)
expr_stmt|;
name|hp2
operator|=
name|NULL
expr_stmt|;
block|}
name|hp
operator|=
name|_hpmerge
argument_list|(
name|hp
argument_list|,
name|hp2
argument_list|,
name|errp
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
name|_hpreorder
argument_list|(
name|_hpsort
argument_list|(
name|hp
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|struct
name|hostent
modifier|*
name|getipnodebyaddr
parameter_list|(
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|af
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|int
name|rval
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|in6_addr
name|addrbuf
decl_stmt|;
else|#
directive|else
name|struct
name|in_addr
name|addrbuf
decl_stmt|;
endif|#
directive|endif
specifier|static
specifier|const
name|ns_dtab
name|dtab
index|[]
init|=
block|{
name|NS_FILES_CB
argument_list|(
argument|_files_ghbyaddr
argument_list|,
argument|NULL
argument_list|)
block|{
name|NSSRC_DNS
block|,
name|_dns_ghbyaddr
block|,
name|NULL
block|}
block|,
name|NS_NIS_CB
argument_list|(
argument|_nis_ghbyaddr
argument_list|,
argument|NULL
argument_list|)
ifdef|#
directive|ifdef
name|ICMPNL
block|{
name|NSSRC_ICMP
block|,
name|_icmp_ghbyaddr
block|,
name|NULL
block|}
block|,
endif|#
directive|endif
block|{
literal|0
block|}
block|}
decl_stmt|;
operator|*
name|errp
operator|=
name|HOST_NOT_FOUND
expr_stmt|;
switch|switch
condition|(
name|af
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
condition|)
block|{
operator|*
name|errp
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|long
operator|)
name|src
operator|&
operator|~
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
operator|-
literal|1
operator|)
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|addrbuf
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|src
operator|=
operator|&
name|addrbuf
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|src
operator|)
operator|->
name|s_addr
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
condition|)
block|{
operator|*
name|errp
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|(
name|long
operator|)
name|src
operator|&
operator|~
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|/
literal|2
operator|-
literal|1
operator|)
condition|)
block|{
comment|/*XXX*/
name|memcpy
argument_list|(
operator|&
name|addrbuf
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|src
operator|=
operator|&
name|addrbuf
expr_stmt|;
block|}
if|if
condition|(
name|IN6_IS_ADDR_UNSPECIFIED
argument_list|(
operator|(
expr|struct
name|in6_addr
operator|*
operator|)
name|src
argument_list|)
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|(
expr|struct
name|in6_addr
operator|*
operator|)
name|src
argument_list|)
operator|||
name|IN6_IS_ADDR_V4COMPAT
argument_list|(
operator|(
expr|struct
name|in6_addr
operator|*
operator|)
name|src
argument_list|)
condition|)
block|{
name|src
operator|=
operator|(
name|char
operator|*
operator|)
name|src
operator|+
operator|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
operator|)
expr_stmt|;
name|af
operator|=
name|AF_INET
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
operator|*
name|errp
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|rval
operator|=
name|_nsdispatch
argument_list|(
operator|&
name|hp
argument_list|,
name|dtab
argument_list|,
name|NSDB_HOSTS
argument_list|,
literal|"ghbyaddr"
argument_list|,
name|default_src
argument_list|,
name|src
argument_list|,
name|len
argument_list|,
name|af
argument_list|,
name|errp
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|==
name|NS_SUCCESS
operator|)
condition|?
name|hp
else|:
name|NULL
return|;
block|}
end_function

begin_function
name|void
name|freehostent
parameter_list|(
name|struct
name|hostent
modifier|*
name|ptr
parameter_list|)
block|{
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Private utility functions  */
end_comment

begin_comment
comment|/*  * _hpcopy: allocate and copy hostent structure  */
end_comment

begin_function
specifier|static
name|struct
name|hostent
modifier|*
name|_hpcopy
parameter_list|(
name|struct
name|hostent
modifier|*
name|hp
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
block|{
name|struct
name|hostent
modifier|*
name|nhp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|int
name|size
decl_stmt|,
name|addrsize
decl_stmt|;
name|int
name|nalias
init|=
literal|0
decl_stmt|,
name|naddr
init|=
literal|0
decl_stmt|;
name|int
name|al_off
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
return|return
name|hp
return|;
comment|/* count size to be allocated */
name|size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|hostent
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|h_name
operator|!=
name|NULL
condition|)
name|size
operator|+=
name|strlen
argument_list|(
name|hp
operator|->
name|h_name
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|=
name|hp
operator|->
name|h_aliases
operator|)
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|i
operator|++
operator|,
name|pp
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'\0'
condition|)
block|{
name|size
operator|+=
name|strlen
argument_list|(
operator|*
name|pp
argument_list|)
operator|+
literal|1
expr_stmt|;
name|nalias
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* adjust alignment */
name|size
operator|=
name|ALIGN
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|al_off
operator|=
name|size
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|nalias
operator|+
literal|1
operator|)
expr_stmt|;
name|addrsize
operator|=
name|ALIGN
argument_list|(
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|=
name|hp
operator|->
name|h_addr_list
operator|)
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|*
name|pp
operator|++
operator|!=
name|NULL
condition|)
name|naddr
operator|++
expr_stmt|;
block|}
name|size
operator|+=
name|addrsize
operator|*
name|naddr
expr_stmt|;
name|size
operator|+=
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|naddr
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* copy */
if|if
condition|(
operator|(
name|nhp
operator|=
operator|(
expr|struct
name|hostent
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|errp
operator|=
name|TRY_AGAIN
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|nhp
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|h_name
operator|!=
name|NULL
condition|)
block|{
name|nhp
operator|->
name|h_name
operator|=
name|cp
expr_stmt|;
name|strcpy
argument_list|(
name|cp
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|nhp
operator|->
name|h_name
operator|=
name|NULL
expr_stmt|;
name|nhp
operator|->
name|h_aliases
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|nhp
operator|+
name|al_off
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|=
name|hp
operator|->
name|h_aliases
operator|)
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|++
control|)
block|{
if|if
condition|(
operator|*
operator|*
name|pp
operator|!=
literal|'\0'
condition|)
block|{
name|nhp
operator|->
name|h_aliases
index|[
name|i
operator|++
index|]
operator|=
name|cp
expr_stmt|;
name|strcpy
argument_list|(
name|cp
argument_list|,
operator|*
name|pp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
name|nhp
operator|->
name|h_aliases
index|[
name|nalias
index|]
operator|=
name|NULL
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|nhp
operator|->
name|h_aliases
index|[
name|nalias
operator|+
literal|1
index|]
expr_stmt|;
name|nhp
operator|->
name|h_addrtype
operator|=
name|hp
operator|->
name|h_addrtype
expr_stmt|;
name|nhp
operator|->
name|h_length
operator|=
name|hp
operator|->
name|h_length
expr_stmt|;
name|nhp
operator|->
name|h_addr_list
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|cp
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|=
name|hp
operator|->
name|h_addr_list
operator|)
operator|!=
name|NULL
condition|)
block|{
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|nhp
operator|->
name|h_addr_list
index|[
name|naddr
operator|+
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|++
control|)
block|{
name|nhp
operator|->
name|h_addr_list
index|[
name|i
operator|++
index|]
operator|=
name|cp
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
operator|*
name|pp
argument_list|,
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|addrsize
expr_stmt|;
block|}
block|}
name|nhp
operator|->
name|h_addr_list
index|[
name|naddr
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|nhp
return|;
block|}
end_function

begin_comment
comment|/*  * _hpaddr: construct hostent structure with one address  */
end_comment

begin_function
specifier|static
name|struct
name|hostent
modifier|*
name|_hpaddr
parameter_list|(
name|int
name|af
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|,
name|hpbuf
decl_stmt|;
name|char
modifier|*
name|addrs
index|[
literal|2
index|]
decl_stmt|;
name|hp
operator|=
operator|&
name|hpbuf
expr_stmt|;
name|hp
operator|->
name|h_name
operator|=
operator|(
name|char
operator|*
operator|)
name|name
expr_stmt|;
name|hp
operator|->
name|h_aliases
operator|=
name|NULL
expr_stmt|;
name|hp
operator|->
name|h_addrtype
operator|=
name|af
expr_stmt|;
name|hp
operator|->
name|h_length
operator|=
name|ADDRLEN
argument_list|(
name|af
argument_list|)
expr_stmt|;
name|hp
operator|->
name|h_addr_list
operator|=
name|addrs
expr_stmt|;
name|addrs
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|addr
expr_stmt|;
name|addrs
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|_hpcopy
argument_list|(
name|hp
argument_list|,
name|errp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * _hpmerge: merge 2 hostent structure, arguments will be freed  */
end_comment

begin_function
specifier|static
name|struct
name|hostent
modifier|*
name|_hpmerge
parameter_list|(
name|struct
name|hostent
modifier|*
name|hp1
parameter_list|,
name|struct
name|hostent
modifier|*
name|hp2
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|naddr
decl_stmt|,
name|nalias
decl_stmt|;
name|char
modifier|*
modifier|*
name|pp
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|,
name|hpbuf
decl_stmt|;
name|char
modifier|*
name|aliases
index|[
name|MAXALIASES
operator|+
literal|1
index|]
decl_stmt|,
modifier|*
name|addrs
index|[
name|MAXADDRS
operator|+
literal|1
index|]
decl_stmt|;
name|union
name|inx_addr
name|addrbuf
index|[
name|MAXADDRS
index|]
decl_stmt|;
if|if
condition|(
name|hp1
operator|==
name|NULL
condition|)
return|return
name|hp2
return|;
if|if
condition|(
name|hp2
operator|==
name|NULL
condition|)
return|return
name|hp1
return|;
define|#
directive|define
name|HP
parameter_list|(
name|i
parameter_list|)
value|(i == 1 ? hp1 : hp2)
name|hp
operator|=
operator|&
name|hpbuf
expr_stmt|;
name|hp
operator|->
name|h_name
operator|=
operator|(
name|hp1
operator|->
name|h_name
operator|!=
name|NULL
condition|?
name|hp1
operator|->
name|h_name
else|:
name|hp2
operator|->
name|h_name
operator|)
expr_stmt|;
name|hp
operator|->
name|h_aliases
operator|=
name|aliases
expr_stmt|;
name|nalias
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pp
operator|=
name|HP
argument_list|(
name|i
argument_list|)
operator|->
name|h_aliases
operator|)
operator|==
name|NULL
condition|)
continue|continue;
for|for
control|(
init|;
name|nalias
operator|<
name|MAXALIASES
operator|&&
operator|*
name|pp
operator|!=
name|NULL
condition|;
name|pp
operator|++
control|)
block|{
comment|/* check duplicates */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nalias
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|strcasecmp
argument_list|(
operator|*
name|pp
argument_list|,
name|aliases
index|[
name|j
index|]
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|j
operator|==
name|nalias
condition|)
name|aliases
index|[
name|nalias
operator|++
index|]
operator|=
operator|*
name|pp
expr_stmt|;
block|}
block|}
name|aliases
index|[
name|nalias
index|]
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|hp1
operator|->
name|h_length
operator|!=
name|hp2
operator|->
name|h_length
condition|)
block|{
name|hp
operator|->
name|h_addrtype
operator|=
name|AF_INET6
expr_stmt|;
name|hp
operator|->
name|h_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
name|hp
operator|->
name|h_addrtype
operator|=
name|hp1
operator|->
name|h_addrtype
expr_stmt|;
name|hp
operator|->
name|h_length
operator|=
name|hp1
operator|->
name|h_length
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
block|}
endif|#
directive|endif
name|hp
operator|->
name|h_addr_list
operator|=
name|addrs
expr_stmt|;
name|naddr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pp
operator|=
name|HP
argument_list|(
name|i
argument_list|)
operator|->
name|h_addr_list
operator|)
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|HP
argument_list|(
name|i
argument_list|)
operator|->
name|h_length
operator|==
name|hp
operator|->
name|h_length
condition|)
block|{
while|while
condition|(
name|naddr
operator|<
name|MAXADDRS
operator|&&
operator|*
name|pp
operator|!=
name|NULL
condition|)
name|addrs
index|[
name|naddr
operator|++
index|]
operator|=
operator|*
name|pp
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* copy IPv4 addr as mapped IPv6 addr */
while|while
condition|(
name|naddr
operator|<
name|MAXADDRS
operator|&&
operator|*
name|pp
operator|!=
name|NULL
condition|)
block|{
name|MAPADDR
argument_list|(
operator|&
name|addrbuf
index|[
name|naddr
index|]
argument_list|,
operator|*
name|pp
operator|++
argument_list|)
expr_stmt|;
name|addrs
index|[
name|naddr
index|]
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|addrbuf
index|[
name|naddr
index|]
expr_stmt|;
name|naddr
operator|++
expr_stmt|;
block|}
block|}
block|}
name|addrs
index|[
name|naddr
index|]
operator|=
name|NULL
expr_stmt|;
name|hp
operator|=
name|_hpcopy
argument_list|(
name|hp
argument_list|,
name|errp
argument_list|)
expr_stmt|;
name|freehostent
argument_list|(
name|hp1
argument_list|)
expr_stmt|;
name|freehostent
argument_list|(
name|hp2
argument_list|)
expr_stmt|;
return|return
name|hp
return|;
block|}
end_function

begin_comment
comment|/*  * _hpmapv6: convert IPv4 hostent into IPv4-mapped IPv6 addresses  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INET6
end_ifdef

begin_function
specifier|static
name|struct
name|hostent
modifier|*
name|_hpmapv6
parameter_list|(
name|struct
name|hostent
modifier|*
name|hp
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
block|{
name|struct
name|hostent
modifier|*
name|hp6
decl_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|hp
operator|->
name|h_addrtype
operator|==
name|AF_INET6
condition|)
return|return
name|hp
return|;
comment|/* make dummy hostent to convert IPv6 address */
if|if
condition|(
operator|(
name|hp6
operator|=
operator|(
expr|struct
name|hostent
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|hostent
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|errp
operator|=
name|TRY_AGAIN
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|hp6
operator|->
name|h_name
operator|=
name|NULL
expr_stmt|;
name|hp6
operator|->
name|h_aliases
operator|=
name|NULL
expr_stmt|;
name|hp6
operator|->
name|h_addrtype
operator|=
name|AF_INET6
expr_stmt|;
name|hp6
operator|->
name|h_length
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
expr_stmt|;
name|hp6
operator|->
name|h_addr_list
operator|=
name|NULL
expr_stmt|;
return|return
name|_hpmerge
argument_list|(
name|hp6
argument_list|,
name|hp
argument_list|,
name|errp
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * _hpsort: sort address by sortlist  */
end_comment

begin_function
specifier|static
name|struct
name|hostent
modifier|*
name|_hpsort
parameter_list|(
name|struct
name|hostent
modifier|*
name|hp
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
decl_stmt|;
name|u_char
modifier|*
name|ap
decl_stmt|,
modifier|*
name|sp
decl_stmt|,
modifier|*
name|mp
decl_stmt|,
modifier|*
modifier|*
name|pp
decl_stmt|;
name|char
name|t
decl_stmt|;
name|char
name|order
index|[
name|MAXADDRS
index|]
decl_stmt|;
name|int
name|nsort
init|=
name|_res
operator|.
name|nsort
decl_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
operator|||
name|hp
operator|->
name|h_addr_list
index|[
literal|1
index|]
operator|==
name|NULL
operator|||
name|nsort
operator|==
literal|0
condition|)
return|return
name|hp
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|ap
operator|=
operator|(
name|u_char
operator|*
operator|)
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nsort
condition|;
name|j
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|_res_ext
operator|.
name|sort_list
index|[
name|j
index|]
operator|.
name|af
operator|!=
name|hp
operator|->
name|h_addrtype
condition|)
continue|continue;
name|sp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|_res_ext
operator|.
name|sort_list
index|[
name|j
index|]
operator|.
name|addr
expr_stmt|;
name|mp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|_res_ext
operator|.
name|sort_list
index|[
name|j
index|]
operator|.
name|mask
expr_stmt|;
else|#
directive|else
name|sp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|_res
operator|.
name|sort_list
index|[
name|j
index|]
operator|.
name|addr
expr_stmt|;
name|mp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|_res
operator|.
name|sort_list
index|[
name|j
index|]
operator|.
name|mask
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|hp
operator|->
name|h_length
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ap
index|[
name|n
index|]
operator|&
name|mp
index|[
name|n
index|]
operator|)
operator|!=
name|sp
index|[
name|n
index|]
condition|)
break|break;
block|}
if|if
condition|(
name|n
operator|==
name|hp
operator|->
name|h_length
condition|)
break|break;
block|}
name|order
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
block|}
name|n
operator|=
name|i
expr_stmt|;
name|pp
operator|=
operator|(
name|u_char
operator|*
operator|*
operator|)
name|hp
operator|->
name|h_addr_list
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|order
index|[
name|i
index|]
operator|>
name|order
index|[
name|j
index|]
condition|)
block|{
name|ap
operator|=
name|pp
index|[
name|i
index|]
expr_stmt|;
name|pp
index|[
name|i
index|]
operator|=
name|pp
index|[
name|j
index|]
expr_stmt|;
name|pp
index|[
name|j
index|]
operator|=
name|ap
expr_stmt|;
name|t
operator|=
name|order
index|[
name|i
index|]
expr_stmt|;
name|order
index|[
name|i
index|]
operator|=
name|order
index|[
name|j
index|]
expr_stmt|;
name|order
index|[
name|j
index|]
operator|=
name|t
expr_stmt|;
block|}
block|}
block|}
return|return
name|hp
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|_hgetword
parameter_list|(
name|char
modifier|*
modifier|*
name|pp
parameter_list|)
block|{
name|char
name|c
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|ret
decl_stmt|;
specifier|const
name|char
modifier|*
name|sp
decl_stmt|;
specifier|static
specifier|const
name|char
name|sep
index|[]
init|=
literal|"# \t\n"
decl_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|pp
init|;
operator|(
name|c
operator|=
operator|*
name|p
operator|)
operator|!=
literal|'\0'
condition|;
name|p
operator|++
control|)
block|{
for|for
control|(
name|sp
operator|=
name|sep
init|;
operator|*
name|sp
operator|!=
literal|'\0'
condition|;
name|sp
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
operator|*
name|sp
condition|)
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'#'
condition|)
name|p
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* ignore rest of line */
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
literal|'\0'
condition|)
name|ret
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|sp
operator|!=
literal|'\0'
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
block|}
block|}
operator|*
name|pp
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
operator|||
operator|*
name|ret
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * _hpreorder: sort address by default address selection  */
end_comment

begin_function
specifier|static
name|struct
name|hostent
modifier|*
name|_hpreorder
parameter_list|(
name|struct
name|hostent
modifier|*
name|hp
parameter_list|)
block|{
name|struct
name|hp_order
modifier|*
name|aio
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|u_char
modifier|*
name|ap
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
name|struct
name|policyhead
name|policyhead
decl_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
return|return
name|hp
return|;
switch|switch
condition|(
name|hp
operator|->
name|h_addrtype
condition|)
block|{
case|case
name|AF_INET
case|:
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
endif|#
directive|endif
break|break;
default|default:
name|free_addrselectpolicy
argument_list|(
operator|&
name|policyhead
argument_list|)
expr_stmt|;
return|return
name|hp
return|;
block|}
comment|/* count the number of addrinfo elements for sorting. */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|hp
operator|->
name|h_addr_list
index|[
name|n
index|]
operator|!=
name|NULL
condition|;
name|n
operator|++
control|)
empty_stmt|;
comment|/* 	 * If the number is small enough, we can skip the reordering process. 	 */
if|if
condition|(
name|n
operator|<=
literal|1
condition|)
return|return
name|hp
return|;
comment|/* allocate a temporary array for sort and initialization of it. */
if|if
condition|(
operator|(
name|aio
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|aio
argument_list|)
operator|*
name|n
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|hp
return|;
comment|/* give up reordering */
name|memset
argument_list|(
name|aio
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|aio
argument_list|)
operator|*
name|n
argument_list|)
expr_stmt|;
comment|/* retrieve address selection policy from the kernel */
name|TAILQ_INIT
argument_list|(
operator|&
name|policyhead
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|get_addrselectpolicy
argument_list|(
operator|&
name|policyhead
argument_list|)
condition|)
block|{
comment|/* no policy is installed into kernel, we don't sort. */
name|free
argument_list|(
name|aio
argument_list|)
expr_stmt|;
return|return
name|hp
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|ap
operator|=
operator|(
name|u_char
operator|*
operator|)
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
expr_stmt|;
name|aio
index|[
name|i
index|]
operator|.
name|aio_h_addr
operator|=
name|ap
expr_stmt|;
name|sa
operator|=
operator|&
name|aio
index|[
name|i
index|]
operator|.
name|aio_sa
expr_stmt|;
switch|switch
condition|(
name|hp
operator|->
name|h_addrtype
condition|)
block|{
case|case
name|AF_INET
case|:
name|sa
operator|->
name|sa_family
operator|=
name|AF_INET
expr_stmt|;
name|sa
operator|->
name|sa_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin_addr
argument_list|,
name|ap
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|(
expr|struct
name|in6_addr
operator|*
operator|)
name|ap
argument_list|)
condition|)
block|{
name|sa
operator|->
name|sa_family
operator|=
name|AF_INET
expr_stmt|;
name|sa
operator|->
name|sa_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin_addr
argument_list|,
operator|&
name|ap
index|[
literal|12
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sa
operator|->
name|sa_family
operator|=
name|AF_INET6
expr_stmt|;
name|sa
operator|->
name|sa_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in6
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
operator|)
operator|->
name|sin6_addr
argument_list|,
name|ap
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
block|}
name|aio
index|[
name|i
index|]
operator|.
name|aio_dstscope
operator|=
name|gai_addr2scopetype
argument_list|(
name|sa
argument_list|)
expr_stmt|;
name|aio
index|[
name|i
index|]
operator|.
name|aio_dstpolicy
operator|=
name|match_addrselectpolicy
argument_list|(
name|sa
argument_list|,
operator|&
name|policyhead
argument_list|)
expr_stmt|;
name|set_source
argument_list|(
operator|&
name|aio
index|[
name|i
index|]
argument_list|,
operator|&
name|policyhead
argument_list|)
expr_stmt|;
block|}
comment|/* perform sorting. */
name|qsort
argument_list|(
name|aio
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|aio
argument_list|)
argument_list|,
name|comp_dst
argument_list|)
expr_stmt|;
comment|/* reorder the h_addr_list. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|hp
operator|->
name|h_addr_list
index|[
name|i
index|]
operator|=
name|aio
index|[
name|i
index|]
operator|.
name|aio_h_addr
expr_stmt|;
comment|/* cleanup and return */
name|free
argument_list|(
name|aio
argument_list|)
expr_stmt|;
name|free_addrselectpolicy
argument_list|(
operator|&
name|policyhead
argument_list|)
expr_stmt|;
return|return
name|hp
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_addrselectpolicy
parameter_list|(
name|head
parameter_list|)
name|struct
name|policyhead
modifier|*
name|head
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|INET6
name|int
name|mib
index|[]
init|=
block|{
name|CTL_NET
block|,
name|PF_INET6
block|,
name|IPPROTO_IPV6
block|,
name|IPV6CTL_ADDRCTLPOLICY
block|}
decl_stmt|;
name|size_t
name|l
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|struct
name|in6_addrpolicy
modifier|*
name|pol
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
sizeof|sizeof
argument_list|(
name|mib
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mib
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|l
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
name|l
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
sizeof|sizeof
argument_list|(
name|mib
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mib
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|buf
argument_list|,
operator|&
name|l
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ep
operator|=
operator|(
expr|struct
name|in6_addrpolicy
operator|*
operator|)
operator|(
name|buf
operator|+
name|l
operator|)
expr_stmt|;
for|for
control|(
name|pol
operator|=
operator|(
expr|struct
name|in6_addrpolicy
operator|*
operator|)
name|buf
init|;
name|pol
operator|+
literal|1
operator|<=
name|ep
condition|;
name|pol
operator|++
control|)
block|{
name|struct
name|policyqueue
modifier|*
name|new
decl_stmt|;
if|if
condition|(
operator|(
name|new
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free_addrselectpolicy
argument_list|(
name|head
argument_list|)
expr_stmt|;
comment|/* make the list empty */
break|break;
block|}
name|new
operator|->
name|pc_policy
operator|=
operator|*
name|pol
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
name|head
argument_list|,
name|new
argument_list|,
name|pc_entry
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
else|#
directive|else
return|return
operator|(
literal|0
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|free_addrselectpolicy
parameter_list|(
name|head
parameter_list|)
name|struct
name|policyhead
modifier|*
name|head
decl_stmt|;
block|{
name|struct
name|policyqueue
modifier|*
name|ent
decl_stmt|,
modifier|*
name|nent
decl_stmt|;
for|for
control|(
name|ent
operator|=
name|TAILQ_FIRST
argument_list|(
name|head
argument_list|)
init|;
name|ent
condition|;
name|ent
operator|=
name|nent
control|)
block|{
name|nent
operator|=
name|TAILQ_NEXT
argument_list|(
name|ent
argument_list|,
name|pc_entry
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|head
argument_list|,
name|ent
argument_list|,
name|pc_entry
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ent
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|policyqueue
modifier|*
name|match_addrselectpolicy
parameter_list|(
name|addr
parameter_list|,
name|head
parameter_list|)
name|struct
name|sockaddr
modifier|*
name|addr
decl_stmt|;
name|struct
name|policyhead
modifier|*
name|head
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|INET6
name|struct
name|policyqueue
modifier|*
name|ent
decl_stmt|,
modifier|*
name|bestent
init|=
name|NULL
decl_stmt|;
name|struct
name|in6_addrpolicy
modifier|*
name|pol
decl_stmt|;
name|int
name|matchlen
decl_stmt|,
name|bestmatchlen
init|=
operator|-
literal|1
decl_stmt|;
name|u_char
modifier|*
name|mp
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
name|k
decl_stmt|,
modifier|*
name|p
decl_stmt|,
name|m
decl_stmt|;
name|struct
name|sockaddr_in6
name|key
decl_stmt|;
switch|switch
condition|(
name|addr
operator|->
name|sa_family
condition|)
block|{
case|case
name|AF_INET6
case|:
name|key
operator|=
operator|*
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|addr
expr_stmt|;
break|break;
case|case
name|AF_INET
case|:
comment|/* convert the address into IPv4-mapped IPv6 address. */
name|memset
argument_list|(
operator|&
name|key
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|key
operator|.
name|sin6_len
operator|=
sizeof|sizeof
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|key
operator|.
name|sin6_addr
operator|.
name|s6_addr
index|[
literal|10
index|]
operator|=
literal|0xff
expr_stmt|;
name|key
operator|.
name|sin6_addr
operator|.
name|s6_addr
index|[
literal|11
index|]
operator|=
literal|0xff
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|key
operator|.
name|sin6_addr
operator|.
name|s6_addr
index|[
literal|12
index|]
argument_list|,
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|addr
operator|)
operator|->
name|sin_addr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
for|for
control|(
name|ent
operator|=
name|TAILQ_FIRST
argument_list|(
name|head
argument_list|)
init|;
name|ent
condition|;
name|ent
operator|=
name|TAILQ_NEXT
argument_list|(
name|ent
argument_list|,
name|pc_entry
argument_list|)
control|)
block|{
name|pol
operator|=
operator|&
name|ent
operator|->
name|pc_policy
expr_stmt|;
name|matchlen
operator|=
literal|0
expr_stmt|;
name|mp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|pol
operator|->
name|addrmask
operator|.
name|sin6_addr
expr_stmt|;
name|ep
operator|=
name|mp
operator|+
literal|16
expr_stmt|;
comment|/* XXX: scope field? */
name|k
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|key
operator|.
name|sin6_addr
expr_stmt|;
name|p
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|pol
operator|->
name|addr
operator|.
name|sin6_addr
expr_stmt|;
for|for
control|(
init|;
name|mp
operator|<
name|ep
operator|&&
operator|*
name|mp
condition|;
name|mp
operator|++
operator|,
name|k
operator|++
operator|,
name|p
operator|++
control|)
block|{
name|m
operator|=
operator|*
name|mp
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|k
operator|&
name|m
operator|)
operator|!=
operator|*
name|p
condition|)
goto|goto
name|next
goto|;
comment|/* not match */
if|if
condition|(
name|m
operator|==
literal|0xff
condition|)
comment|/* short cut for a typical case */
name|matchlen
operator|+=
literal|8
expr_stmt|;
else|else
block|{
while|while
condition|(
name|m
operator|>=
literal|0x80
condition|)
block|{
name|matchlen
operator|++
expr_stmt|;
name|m
operator|<<=
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* matched.  check if this is better than the current best. */
if|if
condition|(
name|matchlen
operator|>
name|bestmatchlen
condition|)
block|{
name|bestent
operator|=
name|ent
expr_stmt|;
name|bestmatchlen
operator|=
name|matchlen
expr_stmt|;
block|}
name|next
label|:
continue|continue;
block|}
return|return
operator|(
name|bestent
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|NULL
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|set_source
parameter_list|(
name|aio
parameter_list|,
name|ph
parameter_list|)
name|struct
name|hp_order
modifier|*
name|aio
decl_stmt|;
name|struct
name|policyhead
modifier|*
name|ph
decl_stmt|;
block|{
name|struct
name|sockaddr_storage
name|ss
init|=
name|aio
operator|->
name|aio_un
operator|.
name|aiou_ss
decl_stmt|;
name|socklen_t
name|srclen
decl_stmt|;
name|int
name|s
decl_stmt|;
comment|/* set unspec ("no source is available"), just in case */
name|aio
operator|->
name|aio_srcsa
operator|.
name|sa_family
operator|=
name|AF_UNSPEC
expr_stmt|;
name|aio
operator|->
name|aio_srcscope
operator|=
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|ss
operator|.
name|ss_family
condition|)
block|{
case|case
name|AF_INET
case|:
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|ss
operator|)
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|&
name|ss
operator|)
operator|->
name|sin6_port
operator|=
name|htons
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
comment|/* ignore unsupported AFs explicitly */
return|return;
block|}
comment|/* open a socket to get the source address for the given dst */
if|if
condition|(
operator|(
name|s
operator|=
name|_socket
argument_list|(
name|ss
operator|.
name|ss_family
argument_list|,
name|SOCK_DGRAM
argument_list|,
name|IPPROTO_UDP
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
comment|/* give up */
if|if
condition|(
name|_connect
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
argument_list|,
name|ss
operator|.
name|ss_len
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|cleanup
goto|;
name|srclen
operator|=
name|ss
operator|.
name|ss_len
expr_stmt|;
if|if
condition|(
name|_getsockname
argument_list|(
name|s
argument_list|,
operator|&
name|aio
operator|->
name|aio_srcsa
argument_list|,
operator|&
name|srclen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|aio
operator|->
name|aio_srcsa
operator|.
name|sa_family
operator|=
name|AF_UNSPEC
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|aio
operator|->
name|aio_srcscope
operator|=
name|gai_addr2scopetype
argument_list|(
operator|&
name|aio
operator|->
name|aio_srcsa
argument_list|)
expr_stmt|;
name|aio
operator|->
name|aio_srcpolicy
operator|=
name|match_addrselectpolicy
argument_list|(
operator|&
name|aio
operator|->
name|aio_srcsa
argument_list|,
name|ph
argument_list|)
expr_stmt|;
name|aio
operator|->
name|aio_matchlen
operator|=
name|matchlen
argument_list|(
operator|&
name|aio
operator|->
name|aio_srcsa
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ss
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|ss
operator|.
name|ss_family
operator|==
name|AF_INET6
condition|)
block|{
name|struct
name|in6_ifreq
name|ifr6
decl_stmt|;
name|u_int32_t
name|flags6
decl_stmt|;
comment|/* XXX: interface name should not be hardcoded */
name|strncpy
argument_list|(
name|ifr6
operator|.
name|ifr_name
argument_list|,
literal|"lo0"
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr6
operator|.
name|ifr_name
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ifr6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ifr6
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ifr6
operator|.
name|ifr_addr
argument_list|,
operator|&
name|ss
argument_list|,
name|ss
operator|.
name|ss_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|_ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFAFLAG_IN6
argument_list|,
operator|&
name|ifr6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|flags6
operator|=
name|ifr6
operator|.
name|ifr_ifru
operator|.
name|ifru_flags6
expr_stmt|;
if|if
condition|(
operator|(
name|flags6
operator|&
name|IN6_IFF_DEPRECATED
operator|)
condition|)
name|aio
operator|->
name|aio_srcflag
operator||=
name|AIO_SRCFLAG_DEPRECATED
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|cleanup
label|:
name|_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|int
name|matchlen
parameter_list|(
name|src
parameter_list|,
name|dst
parameter_list|)
name|struct
name|sockaddr
modifier|*
name|src
decl_stmt|,
decl|*
name|dst
decl_stmt|;
end_function

begin_block
block|{
name|int
name|match
init|=
literal|0
decl_stmt|;
name|u_char
modifier|*
name|s
decl_stmt|,
modifier|*
name|d
decl_stmt|;
name|u_char
modifier|*
name|lim
decl_stmt|,
name|r
decl_stmt|;
name|int
name|addrlen
decl_stmt|;
switch|switch
condition|(
name|src
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|s
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|src
operator|)
operator|->
name|sin6_addr
expr_stmt|;
name|d
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|dst
operator|)
operator|->
name|sin6_addr
expr_stmt|;
name|addrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
expr_stmt|;
name|lim
operator|=
name|s
operator|+
name|addrlen
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|AF_INET
case|:
name|s
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|src
operator|)
operator|->
name|sin6_addr
expr_stmt|;
name|d
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|dst
operator|)
operator|->
name|sin6_addr
expr_stmt|;
name|addrlen
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
expr_stmt|;
name|lim
operator|=
name|s
operator|+
name|addrlen
expr_stmt|;
break|break;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
while|while
condition|(
name|s
operator|<
name|lim
condition|)
if|if
condition|(
operator|(
name|r
operator|=
operator|(
operator|*
name|d
operator|++
operator|^
operator|*
name|s
operator|++
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
while|while
condition|(
name|r
operator|<
name|addrlen
operator|*
literal|8
condition|)
block|{
name|match
operator|++
expr_stmt|;
name|r
operator|<<=
literal|1
expr_stmt|;
block|}
break|break;
block|}
else|else
name|match
operator|+=
literal|8
expr_stmt|;
return|return
operator|(
name|match
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|comp_dst
parameter_list|(
name|arg1
parameter_list|,
name|arg2
parameter_list|)
specifier|const
name|void
modifier|*
name|arg1
decl_stmt|,
decl|*
name|arg2
decl_stmt|;
end_function

begin_block
block|{
specifier|const
name|struct
name|hp_order
modifier|*
name|dst1
init|=
name|arg1
decl_stmt|,
modifier|*
name|dst2
init|=
name|arg2
decl_stmt|;
comment|/* 	 * Rule 1: Avoid unusable destinations. 	 * XXX: we currently do not consider if an appropriate route exists. 	 */
if|if
condition|(
name|dst1
operator|->
name|aio_srcsa
operator|.
name|sa_family
operator|!=
name|AF_UNSPEC
operator|&&
name|dst2
operator|->
name|aio_srcsa
operator|.
name|sa_family
operator|==
name|AF_UNSPEC
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dst1
operator|->
name|aio_srcsa
operator|.
name|sa_family
operator|==
name|AF_UNSPEC
operator|&&
name|dst2
operator|->
name|aio_srcsa
operator|.
name|sa_family
operator|!=
name|AF_UNSPEC
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Rule 2: Prefer matching scope. */
if|if
condition|(
name|dst1
operator|->
name|aio_dstscope
operator|==
name|dst1
operator|->
name|aio_srcscope
operator|&&
name|dst2
operator|->
name|aio_dstscope
operator|!=
name|dst2
operator|->
name|aio_srcscope
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dst1
operator|->
name|aio_dstscope
operator|!=
name|dst1
operator|->
name|aio_srcscope
operator|&&
name|dst2
operator|->
name|aio_dstscope
operator|==
name|dst2
operator|->
name|aio_srcscope
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* Rule 3: Avoid deprecated addresses. */
if|if
condition|(
name|dst1
operator|->
name|aio_srcsa
operator|.
name|sa_family
operator|!=
name|AF_UNSPEC
operator|&&
name|dst2
operator|->
name|aio_srcsa
operator|.
name|sa_family
operator|!=
name|AF_UNSPEC
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|dst1
operator|->
name|aio_srcflag
operator|&
name|AIO_SRCFLAG_DEPRECATED
operator|)
operator|&&
operator|(
name|dst2
operator|->
name|aio_srcflag
operator|&
name|AIO_SRCFLAG_DEPRECATED
operator|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|dst1
operator|->
name|aio_srcflag
operator|&
name|AIO_SRCFLAG_DEPRECATED
operator|)
operator|&&
operator|!
operator|(
name|dst2
operator|->
name|aio_srcflag
operator|&
name|AIO_SRCFLAG_DEPRECATED
operator|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* Rule 4: Prefer home addresses. */
comment|/* XXX: not implemented yet */
comment|/* Rule 5: Prefer matching label. */
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|dst1
operator|->
name|aio_srcpolicy
operator|&&
name|dst1
operator|->
name|aio_dstpolicy
operator|&&
name|dst1
operator|->
name|aio_srcpolicy
operator|->
name|pc_policy
operator|.
name|label
operator|==
name|dst1
operator|->
name|aio_dstpolicy
operator|->
name|pc_policy
operator|.
name|label
operator|&&
operator|(
name|dst2
operator|->
name|aio_srcpolicy
operator|==
name|NULL
operator|||
name|dst2
operator|->
name|aio_dstpolicy
operator|==
name|NULL
operator|||
name|dst2
operator|->
name|aio_srcpolicy
operator|->
name|pc_policy
operator|.
name|label
operator|!=
name|dst2
operator|->
name|aio_dstpolicy
operator|->
name|pc_policy
operator|.
name|label
operator|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dst2
operator|->
name|aio_srcpolicy
operator|&&
name|dst2
operator|->
name|aio_dstpolicy
operator|&&
name|dst2
operator|->
name|aio_srcpolicy
operator|->
name|pc_policy
operator|.
name|label
operator|==
name|dst2
operator|->
name|aio_dstpolicy
operator|->
name|pc_policy
operator|.
name|label
operator|&&
operator|(
name|dst1
operator|->
name|aio_srcpolicy
operator|==
name|NULL
operator|||
name|dst1
operator|->
name|aio_dstpolicy
operator|==
name|NULL
operator|||
name|dst1
operator|->
name|aio_srcpolicy
operator|->
name|pc_policy
operator|.
name|label
operator|!=
name|dst1
operator|->
name|aio_dstpolicy
operator|->
name|pc_policy
operator|.
name|label
operator|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* Rule 6: Prefer higher precedence. */
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|dst1
operator|->
name|aio_dstpolicy
operator|&&
operator|(
name|dst2
operator|->
name|aio_dstpolicy
operator|==
name|NULL
operator|||
name|dst1
operator|->
name|aio_dstpolicy
operator|->
name|pc_policy
operator|.
name|preced
operator|>
name|dst2
operator|->
name|aio_dstpolicy
operator|->
name|pc_policy
operator|.
name|preced
operator|)
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dst2
operator|->
name|aio_dstpolicy
operator|&&
operator|(
name|dst1
operator|->
name|aio_dstpolicy
operator|==
name|NULL
operator|||
name|dst2
operator|->
name|aio_dstpolicy
operator|->
name|pc_policy
operator|.
name|preced
operator|>
name|dst1
operator|->
name|aio_dstpolicy
operator|->
name|pc_policy
operator|.
name|preced
operator|)
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* Rule 7: Prefer native transport. */
comment|/* XXX: not implemented yet */
comment|/* Rule 8: Prefer smaller scope. */
if|if
condition|(
name|dst1
operator|->
name|aio_dstscope
operator|>=
literal|0
operator|&&
name|dst1
operator|->
name|aio_dstscope
operator|<
name|dst2
operator|->
name|aio_dstscope
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dst2
operator|->
name|aio_dstscope
operator|>=
literal|0
operator|&&
name|dst2
operator|->
name|aio_dstscope
operator|<
name|dst1
operator|->
name|aio_dstscope
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * Rule 9: Use longest matching prefix. 	 * We compare the match length in a same AF only. 	 */
if|if
condition|(
name|dst1
operator|->
name|aio_sa
operator|.
name|sa_family
operator|==
name|dst2
operator|->
name|aio_sa
operator|.
name|sa_family
condition|)
block|{
if|if
condition|(
name|dst1
operator|->
name|aio_matchlen
operator|>
name|dst2
operator|->
name|aio_matchlen
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dst1
operator|->
name|aio_matchlen
operator|<
name|dst2
operator|->
name|aio_matchlen
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* Rule 10: Otherwise, leave the order unchanged. */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Copy from scope.c.  * XXX: we should standardize the functions and link them as standard  * library.  */
end_comment

begin_function
specifier|static
name|int
name|gai_addr2scopetype
parameter_list|(
name|sa
parameter_list|)
name|struct
name|sockaddr
modifier|*
name|sa
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in6
modifier|*
name|sa6
decl_stmt|;
endif|#
directive|endif
name|struct
name|sockaddr_in
modifier|*
name|sa4
decl_stmt|;
switch|switch
condition|(
name|sa
operator|->
name|sa_family
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|sa6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|sa
expr_stmt|;
if|if
condition|(
name|IN6_IS_ADDR_MULTICAST
argument_list|(
operator|&
name|sa6
operator|->
name|sin6_addr
argument_list|)
condition|)
block|{
comment|/* just use the scope field of the multicast address */
return|return
operator|(
name|sa6
operator|->
name|sin6_addr
operator|.
name|s6_addr
index|[
literal|2
index|]
operator|&
literal|0x0f
operator|)
return|;
block|}
comment|/* 		 * Unicast addresses: map scope type to corresponding scope 		 * value defined for multcast addresses. 		 * XXX: hardcoded scope type values are bad... 		 */
if|if
condition|(
name|IN6_IS_ADDR_LOOPBACK
argument_list|(
operator|&
name|sa6
operator|->
name|sin6_addr
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* node local scope */
if|if
condition|(
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|sa6
operator|->
name|sin6_addr
argument_list|)
condition|)
return|return
operator|(
literal|2
operator|)
return|;
comment|/* link-local scope */
if|if
condition|(
name|IN6_IS_ADDR_SITELOCAL
argument_list|(
operator|&
name|sa6
operator|->
name|sin6_addr
argument_list|)
condition|)
return|return
operator|(
literal|5
operator|)
return|;
comment|/* site-local scope */
return|return
operator|(
literal|14
operator|)
return|;
comment|/* global scope */
break|break;
endif|#
directive|endif
case|case
name|AF_INET
case|:
comment|/* 		 * IPv4 pseudo scoping according to RFC 3484. 		 */
name|sa4
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
expr_stmt|;
comment|/* IPv4 autoconfiguration addresses have link-local scope. */
if|if
condition|(
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|sa4
operator|->
name|sin_addr
operator|)
index|[
literal|0
index|]
operator|==
literal|169
operator|&&
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|sa4
operator|->
name|sin_addr
operator|)
index|[
literal|1
index|]
operator|==
literal|254
condition|)
return|return
operator|(
literal|2
operator|)
return|;
comment|/* Private addresses have site-local scope. */
if|if
condition|(
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|sa4
operator|->
name|sin_addr
operator|)
index|[
literal|0
index|]
operator|==
literal|10
operator|||
operator|(
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|sa4
operator|->
name|sin_addr
operator|)
index|[
literal|0
index|]
operator|==
literal|172
operator|&&
operator|(
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|sa4
operator|->
name|sin_addr
operator|)
index|[
literal|1
index|]
operator|&
literal|0xf0
operator|)
operator|==
literal|16
operator|)
operator|||
operator|(
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|sa4
operator|->
name|sin_addr
operator|)
index|[
literal|0
index|]
operator|==
literal|192
operator|&&
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|sa4
operator|->
name|sin_addr
operator|)
index|[
literal|1
index|]
operator|==
literal|168
operator|)
condition|)
return|return
operator|(
literal|14
operator|)
return|;
comment|/* XXX: It should be 5 unless NAT */
comment|/* Loopback addresses have link-local scope. */
if|if
condition|(
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|sa4
operator|->
name|sin_addr
operator|)
index|[
literal|0
index|]
operator|==
literal|127
condition|)
return|return
operator|(
literal|2
operator|)
return|;
return|return
operator|(
literal|14
operator|)
return|;
break|break;
default|default:
name|errno
operator|=
name|EAFNOSUPPORT
expr_stmt|;
comment|/* is this a good error? */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * FILES (/etc/hosts)  */
end_comment

begin_function
specifier|static
name|FILE
modifier|*
name|_files_open
parameter_list|(
name|int
modifier|*
name|errp
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|_PATH_HOSTS
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
operator|*
name|errp
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
name|fp
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_files_ghbyname
parameter_list|(
name|void
modifier|*
name|rval
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|af
decl_stmt|;
name|int
modifier|*
name|errp
decl_stmt|;
name|int
name|match
decl_stmt|,
name|nalias
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|line
decl_stmt|,
modifier|*
name|addrstr
decl_stmt|,
modifier|*
name|cname
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|hostent
modifier|*
name|rethp
decl_stmt|,
modifier|*
name|hp
decl_stmt|,
name|hpbuf
decl_stmt|;
name|char
modifier|*
name|aliases
index|[
name|MAXALIASES
operator|+
literal|1
index|]
decl_stmt|,
modifier|*
name|addrs
index|[
literal|2
index|]
decl_stmt|;
name|union
name|inx_addr
name|addrbuf
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|name
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|af
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|errp
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
operator|*
argument_list|)
expr_stmt|;
operator|*
operator|(
expr|struct
name|hostent
operator|*
operator|*
operator|)
name|rval
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|_files_open
argument_list|(
name|errp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NS_UNAVAIL
return|;
name|rethp
operator|=
name|hp
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
condition|)
block|{
name|line
operator|=
name|buf
expr_stmt|;
if|if
condition|(
operator|(
name|addrstr
operator|=
name|_hgetword
argument_list|(
operator|&
name|line
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|cname
operator|=
name|_hgetword
argument_list|(
operator|&
name|line
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
name|match
operator|=
operator|(
name|strcasecmp
argument_list|(
name|cname
argument_list|,
name|name
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
name|nalias
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|_hgetword
argument_list|(
operator|&
name|line
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|match
condition|)
name|match
operator|=
operator|(
name|strcasecmp
argument_list|(
name|p
argument_list|,
name|name
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|nalias
operator|<
name|MAXALIASES
condition|)
name|aliases
index|[
name|nalias
operator|++
index|]
operator|=
name|p
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|match
condition|)
continue|continue;
switch|switch
condition|(
name|af
condition|)
block|{
case|case
name|AF_INET
case|:
if|if
condition|(
name|inet_aton
argument_list|(
name|addrstr
argument_list|,
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|&
name|addrbuf
argument_list|)
operator|!=
literal|1
condition|)
block|{
operator|*
name|errp
operator|=
name|NO_DATA
expr_stmt|;
comment|/* name found */
continue|continue;
block|}
break|break;
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
if|if
condition|(
name|inet_pton
argument_list|(
name|af
argument_list|,
name|addrstr
argument_list|,
operator|&
name|addrbuf
argument_list|)
operator|!=
literal|1
condition|)
block|{
operator|*
name|errp
operator|=
name|NO_DATA
expr_stmt|;
comment|/* name found */
continue|continue;
block|}
break|break;
endif|#
directive|endif
block|}
name|hp
operator|=
operator|&
name|hpbuf
expr_stmt|;
name|hp
operator|->
name|h_name
operator|=
name|cname
expr_stmt|;
name|hp
operator|->
name|h_aliases
operator|=
name|aliases
expr_stmt|;
name|aliases
index|[
name|nalias
index|]
operator|=
name|NULL
expr_stmt|;
name|hp
operator|->
name|h_addrtype
operator|=
name|af
expr_stmt|;
name|hp
operator|->
name|h_length
operator|=
name|ADDRLEN
argument_list|(
name|af
argument_list|)
expr_stmt|;
name|hp
operator|->
name|h_addr_list
operator|=
name|addrs
expr_stmt|;
name|addrs
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|addrbuf
expr_stmt|;
name|addrs
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|hp
operator|=
name|_hpcopy
argument_list|(
name|hp
argument_list|,
name|errp
argument_list|)
expr_stmt|;
name|rethp
operator|=
name|_hpmerge
argument_list|(
name|rethp
argument_list|,
name|hp
argument_list|,
name|errp
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|*
operator|(
expr|struct
name|hostent
operator|*
operator|*
operator|)
name|rval
operator|=
name|rethp
expr_stmt|;
return|return
operator|(
name|rethp
operator|!=
name|NULL
operator|)
condition|?
name|NS_SUCCESS
else|:
name|NS_NOTFOUND
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_files_ghbyaddr
parameter_list|(
name|void
modifier|*
name|rval
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|addr
decl_stmt|;
name|int
name|addrlen
decl_stmt|;
name|int
name|af
decl_stmt|;
name|int
modifier|*
name|errp
decl_stmt|;
name|int
name|nalias
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|line
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|,
name|hpbuf
decl_stmt|;
name|char
modifier|*
name|aliases
index|[
name|MAXALIASES
operator|+
literal|1
index|]
decl_stmt|,
modifier|*
name|addrs
index|[
literal|2
index|]
decl_stmt|;
name|union
name|inx_addr
name|addrbuf
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|addr
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
expr_stmt|;
name|addrlen
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|af
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|errp
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
operator|*
argument_list|)
expr_stmt|;
operator|*
operator|(
expr|struct
name|hostent
operator|*
operator|*
operator|)
name|rval
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|_files_open
argument_list|(
name|errp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NS_UNAVAIL
return|;
name|hp
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
condition|)
block|{
name|line
operator|=
name|buf
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|_hgetword
argument_list|(
operator|&
name|line
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|af
operator|==
name|AF_INET
condition|?
name|inet_aton
argument_list|(
name|p
argument_list|,
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|&
name|addrbuf
argument_list|)
else|:
name|inet_pton
argument_list|(
name|af
argument_list|,
name|p
argument_list|,
operator|&
name|addrbuf
argument_list|)
operator|)
operator|!=
literal|1
operator|||
name|memcmp
argument_list|(
name|addr
argument_list|,
operator|&
name|addrbuf
argument_list|,
name|addrlen
argument_list|)
operator|!=
literal|0
operator|||
operator|(
name|p
operator|=
name|_hgetword
argument_list|(
operator|&
name|line
argument_list|)
operator|)
operator|==
name|NULL
condition|)
continue|continue;
name|hp
operator|=
operator|&
name|hpbuf
expr_stmt|;
name|hp
operator|->
name|h_name
operator|=
name|p
expr_stmt|;
name|hp
operator|->
name|h_aliases
operator|=
name|aliases
expr_stmt|;
name|nalias
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|p
operator|=
name|_hgetword
argument_list|(
operator|&
name|line
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nalias
operator|<
name|MAXALIASES
condition|)
name|aliases
index|[
name|nalias
operator|++
index|]
operator|=
name|p
expr_stmt|;
block|}
name|aliases
index|[
name|nalias
index|]
operator|=
name|NULL
expr_stmt|;
name|hp
operator|->
name|h_addrtype
operator|=
name|af
expr_stmt|;
name|hp
operator|->
name|h_length
operator|=
name|addrlen
expr_stmt|;
name|hp
operator|->
name|h_addr_list
operator|=
name|addrs
expr_stmt|;
name|addrs
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|addrbuf
expr_stmt|;
name|addrs
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|hp
operator|=
name|_hpcopy
argument_list|(
name|hp
argument_list|,
name|errp
argument_list|)
expr_stmt|;
break|break;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
operator|*
operator|(
expr|struct
name|hostent
operator|*
operator|*
operator|)
name|rval
operator|=
name|hp
expr_stmt|;
return|return
operator|(
name|hp
operator|!=
name|NULL
operator|)
condition|?
name|NS_SUCCESS
else|:
name|NS_NOTFOUND
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|YP
end_ifdef

begin_comment
comment|/*  * NIS  *  * XXX actually a hack, these are INET4 specific.  */
end_comment

begin_function
specifier|static
name|int
name|_nis_ghbyname
parameter_list|(
name|void
modifier|*
name|rval
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|af
decl_stmt|;
name|int
modifier|*
name|errp
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
init|=
name|NULL
decl_stmt|;
name|name
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|af
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|errp
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|af
operator|==
name|AF_INET
condition|)
block|{
name|THREAD_LOCK
argument_list|()
expr_stmt|;
name|hp
operator|=
name|_gethostbynisname
argument_list|(
name|name
argument_list|,
name|af
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|!=
name|NULL
condition|)
name|hp
operator|=
name|_hpcopy
argument_list|(
name|hp
argument_list|,
name|errp
argument_list|)
expr_stmt|;
name|THREAD_UNLOCK
argument_list|()
expr_stmt|;
block|}
operator|*
operator|(
expr|struct
name|hostent
operator|*
operator|*
operator|)
name|rval
operator|=
name|hp
expr_stmt|;
return|return
operator|(
name|hp
operator|!=
name|NULL
operator|)
condition|?
name|NS_SUCCESS
else|:
name|NS_NOTFOUND
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_nis_ghbyaddr
parameter_list|(
name|void
modifier|*
name|rval
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|addr
decl_stmt|;
name|int
name|addrlen
decl_stmt|;
name|int
name|af
decl_stmt|;
name|int
modifier|*
name|errp
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
init|=
name|NULL
decl_stmt|;
name|addr
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
expr_stmt|;
name|addrlen
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|af
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
if|if
condition|(
name|af
operator|==
name|AF_INET
condition|)
block|{
name|THREAD_LOCK
argument_list|()
expr_stmt|;
name|hp
operator|=
name|_gethostbynisaddr
argument_list|(
name|addr
argument_list|,
name|addrlen
argument_list|,
name|af
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|!=
name|NULL
condition|)
name|hp
operator|=
name|_hpcopy
argument_list|(
name|hp
argument_list|,
name|errp
argument_list|)
expr_stmt|;
name|THREAD_UNLOCK
argument_list|()
expr_stmt|;
block|}
operator|*
operator|(
expr|struct
name|hostent
operator|*
operator|*
operator|)
name|rval
operator|=
name|hp
expr_stmt|;
return|return
operator|(
name|hp
operator|!=
name|NULL
operator|)
condition|?
name|NS_SUCCESS
else|:
name|NS_NOTFOUND
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAXPACKET
value|(64*1024)
end_define

begin_typedef
typedef|typedef
union|union
block|{
name|HEADER
name|hdr
decl_stmt|;
name|u_char
name|buf
index|[
name|MAXPACKET
index|]
decl_stmt|;
block|}
name|querybuf
typedef|;
end_typedef

begin_function_decl
specifier|static
name|struct
name|hostent
modifier|*
name|getanswer
parameter_list|(
specifier|const
name|querybuf
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|hostent
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * we don't need to take care about sorting, nor IPv4 mapped address here.  */
end_comment

begin_function
specifier|static
name|struct
name|hostent
modifier|*
name|getanswer
parameter_list|(
name|answer
parameter_list|,
name|anslen
parameter_list|,
name|qname
parameter_list|,
name|qtype
parameter_list|,
name|template
parameter_list|,
name|errp
parameter_list|)
specifier|const
name|querybuf
modifier|*
name|answer
decl_stmt|;
name|int
name|anslen
decl_stmt|;
specifier|const
name|char
modifier|*
name|qname
decl_stmt|;
name|int
name|qtype
decl_stmt|;
name|struct
name|hostent
modifier|*
name|template
decl_stmt|;
name|int
modifier|*
name|errp
decl_stmt|;
block|{
specifier|const
name|HEADER
modifier|*
name|hp
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|cp
decl_stmt|;
name|int
name|n
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|eom
decl_stmt|,
modifier|*
name|erdata
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|ep
decl_stmt|,
modifier|*
modifier|*
name|ap
decl_stmt|,
modifier|*
modifier|*
name|hap
decl_stmt|;
name|int
name|type
decl_stmt|,
name|class
decl_stmt|,
name|ancount
decl_stmt|,
name|qdcount
decl_stmt|;
name|int
name|haveanswer
decl_stmt|,
name|had_error
decl_stmt|;
name|char
name|tbuf
index|[
name|MAXDNAME
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|tname
decl_stmt|;
name|int
function_decl|(
modifier|*
name|name_ok
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
specifier|static
name|char
modifier|*
name|h_addr_ptrs
index|[
name|MAXADDRS
operator|+
literal|1
index|]
decl_stmt|;
specifier|static
name|char
modifier|*
name|host_aliases
index|[
name|MAXALIASES
index|]
decl_stmt|;
specifier|static
name|char
name|hostbuf
index|[
literal|8
operator|*
literal|1024
index|]
decl_stmt|;
define|#
directive|define
name|BOUNDED_INCR
parameter_list|(
name|x
parameter_list|)
define|\
value|do { \ 		cp += x; \ 		if (cp> eom) { \ 			*errp = NO_RECOVERY; \ 			return (NULL); \ 		} \ 	} while (0)
define|#
directive|define
name|BOUNDS_CHECK
parameter_list|(
name|ptr
parameter_list|,
name|count
parameter_list|)
define|\
value|do { \ 		if ((ptr) + (count)> eom) { \ 			*errp = NO_RECOVERY; \ 			return (NULL); \ 		} \ 	} while (0)
comment|/* XXX do {} while (0) cannot be put here */
define|#
directive|define
name|DNS_ASSERT
parameter_list|(
name|x
parameter_list|)
define|\
value|{				\ 		if (!(x)) {		\ 			cp += n;	\ 			continue;	\ 		}			\ 	}
comment|/* XXX do {} while (0) cannot be put here */
define|#
directive|define
name|DNS_FATAL
parameter_list|(
name|x
parameter_list|)
define|\
value|{				\ 		if (!(x)) {		\ 			had_error++;	\ 			continue;	\ 		}			\ 	}
name|tname
operator|=
name|qname
expr_stmt|;
name|template
operator|->
name|h_name
operator|=
name|NULL
expr_stmt|;
name|eom
operator|=
name|answer
operator|->
name|buf
operator|+
name|anslen
expr_stmt|;
switch|switch
condition|(
name|qtype
condition|)
block|{
case|case
name|T_A
case|:
case|case
name|T_AAAA
case|:
name|name_ok
operator|=
name|res_hnok
expr_stmt|;
break|break;
case|case
name|T_PTR
case|:
name|name_ok
operator|=
name|res_dnok
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* XXX should be abort(); */
block|}
comment|/* 	 * find first satisfactory answer 	 */
name|hp
operator|=
operator|&
name|answer
operator|->
name|hdr
expr_stmt|;
name|ancount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|qdcount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|qdcount
argument_list|)
expr_stmt|;
name|bp
operator|=
name|hostbuf
expr_stmt|;
name|ep
operator|=
name|hostbuf
operator|+
sizeof|sizeof
name|hostbuf
expr_stmt|;
name|cp
operator|=
name|answer
operator|->
name|buf
expr_stmt|;
name|BOUNDED_INCR
argument_list|(
name|HFIXEDSZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|qdcount
operator|!=
literal|1
condition|)
block|{
operator|*
name|errp
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|n
operator|=
name|dn_expand
argument_list|(
name|answer
operator|->
name|buf
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
name|bp
argument_list|,
name|ep
operator|-
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|<
literal|0
operator|)
operator|||
operator|!
call|(
modifier|*
name|name_ok
call|)
argument_list|(
name|bp
argument_list|)
condition|)
block|{
operator|*
name|errp
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|BOUNDED_INCR
argument_list|(
name|n
operator|+
name|QFIXEDSZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|qtype
operator|==
name|T_A
operator|||
name|qtype
operator|==
name|T_AAAA
condition|)
block|{
comment|/* res_send() has already verified that the query name is the 		 * same as the one we sent; this just gets the expanded name 		 * (i.e., with the succeeding search-domain tacked on). 		 */
name|n
operator|=
name|strlen
argument_list|(
name|bp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* for the \0 */
if|if
condition|(
name|n
operator|>=
name|MAXHOSTNAMELEN
condition|)
block|{
operator|*
name|errp
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|template
operator|->
name|h_name
operator|=
name|bp
expr_stmt|;
name|bp
operator|+=
name|n
expr_stmt|;
comment|/* The qname can be abbreviated, but h_name is now absolute. */
name|qname
operator|=
name|template
operator|->
name|h_name
expr_stmt|;
block|}
name|ap
operator|=
name|host_aliases
expr_stmt|;
operator|*
name|ap
operator|=
name|NULL
expr_stmt|;
name|template
operator|->
name|h_aliases
operator|=
name|host_aliases
expr_stmt|;
name|hap
operator|=
name|h_addr_ptrs
expr_stmt|;
operator|*
name|hap
operator|=
name|NULL
expr_stmt|;
name|template
operator|->
name|h_addr_list
operator|=
name|h_addr_ptrs
expr_stmt|;
name|haveanswer
operator|=
literal|0
expr_stmt|;
name|had_error
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ancount
operator|--
operator|>
literal|0
operator|&&
name|cp
operator|<
name|eom
operator|&&
operator|!
name|had_error
condition|)
block|{
name|n
operator|=
name|dn_expand
argument_list|(
name|answer
operator|->
name|buf
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
name|bp
argument_list|,
name|ep
operator|-
name|bp
argument_list|)
expr_stmt|;
name|DNS_FATAL
argument_list|(
name|n
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|DNS_FATAL
argument_list|(
call|(
modifier|*
name|name_ok
call|)
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* name */
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
literal|3
operator|*
name|INT16SZ
operator|+
name|INT32SZ
argument_list|)
expr_stmt|;
name|type
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
comment|/* type */
name|class
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
operator|+
name|INT32SZ
expr_stmt|;
comment|/* class, TTL */
name|n
operator|=
name|_getshort
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
comment|/* len */
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|erdata
operator|=
name|cp
operator|+
name|n
expr_stmt|;
name|DNS_ASSERT
argument_list|(
name|class
operator|==
name|C_IN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|qtype
operator|==
name|T_A
operator|||
name|qtype
operator|==
name|T_AAAA
operator|)
operator|&&
name|type
operator|==
name|T_CNAME
condition|)
block|{
if|if
condition|(
name|ap
operator|>=
operator|&
name|host_aliases
index|[
name|MAXALIASES
operator|-
literal|1
index|]
condition|)
continue|continue;
name|n
operator|=
name|dn_expand
argument_list|(
name|answer
operator|->
name|buf
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
name|tbuf
argument_list|,
sizeof|sizeof
name|tbuf
argument_list|)
expr_stmt|;
name|DNS_FATAL
argument_list|(
name|n
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|DNS_FATAL
argument_list|(
call|(
modifier|*
name|name_ok
call|)
argument_list|(
name|tbuf
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|erdata
condition|)
block|{
operator|*
name|errp
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Store alias. */
operator|*
name|ap
operator|++
operator|=
name|bp
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|bp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* for the \0 */
name|DNS_FATAL
argument_list|(
name|n
operator|<
name|MAXHOSTNAMELEN
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|n
expr_stmt|;
comment|/* Get canonical name. */
name|n
operator|=
name|strlen
argument_list|(
name|tbuf
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* for the \0 */
name|DNS_FATAL
argument_list|(
name|n
operator|<=
name|ep
operator|-
name|bp
argument_list|)
expr_stmt|;
name|DNS_FATAL
argument_list|(
name|n
operator|<
name|MAXHOSTNAMELEN
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|bp
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
name|template
operator|->
name|h_name
operator|=
name|bp
expr_stmt|;
name|bp
operator|+=
name|n
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|qtype
operator|==
name|T_PTR
operator|&&
name|type
operator|==
name|T_CNAME
condition|)
block|{
name|n
operator|=
name|dn_expand
argument_list|(
name|answer
operator|->
name|buf
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
name|tbuf
argument_list|,
sizeof|sizeof
name|tbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
operator|!
name|res_dnok
argument_list|(
name|tbuf
argument_list|)
condition|)
block|{
name|had_error
operator|++
expr_stmt|;
continue|continue;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|erdata
condition|)
block|{
operator|*
name|errp
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Get canonical name. */
name|n
operator|=
name|strlen
argument_list|(
name|tbuf
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* for the \0 */
if|if
condition|(
name|n
operator|>
name|ep
operator|-
name|bp
operator|||
name|n
operator|>=
name|MAXHOSTNAMELEN
condition|)
block|{
name|had_error
operator|++
expr_stmt|;
continue|continue;
block|}
name|strcpy
argument_list|(
name|bp
argument_list|,
name|tbuf
argument_list|)
expr_stmt|;
name|tname
operator|=
name|bp
expr_stmt|;
name|bp
operator|+=
name|n
expr_stmt|;
continue|continue;
block|}
name|DNS_ASSERT
argument_list|(
name|type
operator|==
name|qtype
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_PTR
case|:
name|DNS_ASSERT
argument_list|(
name|strcasecmp
argument_list|(
name|tname
argument_list|,
name|bp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|n
operator|=
name|dn_expand
argument_list|(
name|answer
operator|->
name|buf
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
name|bp
argument_list|,
name|ep
operator|-
name|bp
argument_list|)
expr_stmt|;
name|DNS_FATAL
argument_list|(
name|n
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|DNS_FATAL
argument_list|(
name|res_hnok
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|MULTI_PTRS_ARE_ALIASES
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|erdata
condition|)
block|{
operator|*
name|errp
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|haveanswer
condition|)
name|template
operator|->
name|h_name
operator|=
name|bp
expr_stmt|;
elseif|else
if|if
condition|(
name|ap
operator|<
operator|&
name|host_aliases
index|[
name|MAXALIASES
operator|-
literal|1
index|]
condition|)
operator|*
name|ap
operator|++
operator|=
name|bp
expr_stmt|;
else|else
name|n
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|n
operator|!=
operator|-
literal|1
condition|)
block|{
name|n
operator|=
name|strlen
argument_list|(
name|bp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* for the \0 */
if|if
condition|(
name|n
operator|>=
name|MAXHOSTNAMELEN
condition|)
block|{
name|had_error
operator|++
expr_stmt|;
break|break;
block|}
name|bp
operator|+=
name|n
expr_stmt|;
block|}
break|break;
else|#
directive|else
name|template
operator|->
name|h_name
operator|=
name|bp
expr_stmt|;
operator|*
name|errp
operator|=
name|NETDB_SUCCESS
expr_stmt|;
return|return
operator|(
name|template
operator|)
return|;
endif|#
directive|endif
case|case
name|T_A
case|:
case|case
name|T_AAAA
case|:
name|DNS_ASSERT
argument_list|(
name|strcasecmp
argument_list|(
name|template
operator|->
name|h_name
argument_list|,
name|bp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|DNS_ASSERT
argument_list|(
name|n
operator|==
name|template
operator|->
name|h_length
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|haveanswer
condition|)
block|{
name|int
name|nn
decl_stmt|;
name|template
operator|->
name|h_name
operator|=
name|bp
expr_stmt|;
name|nn
operator|=
name|strlen
argument_list|(
name|bp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* for the \0 */
name|bp
operator|+=
name|nn
expr_stmt|;
block|}
name|bp
operator|=
operator|(
name|char
operator|*
operator|)
name|ALIGN
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|DNS_FATAL
argument_list|(
name|bp
operator|+
name|n
operator|<
name|ep
argument_list|)
expr_stmt|;
name|DNS_ASSERT
argument_list|(
name|hap
operator|<
operator|&
name|h_addr_ptrs
index|[
name|MAXADDRS
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FILTER_V4MAPPED
if|if
condition|(
name|type
operator|==
name|T_AAAA
condition|)
block|{
name|struct
name|in6_addr
name|in6
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|in6
argument_list|,
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|in6
argument_list|)
argument_list|)
expr_stmt|;
name|DNS_ASSERT
argument_list|(
name|IN6_IS_ADDR_V4MAPPED
argument_list|(
operator|&
name|in6
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|bcopy
argument_list|(
name|cp
argument_list|,
operator|*
name|hap
operator|++
operator|=
name|bp
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|n
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|erdata
condition|)
block|{
operator|*
name|errp
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|had_error
condition|)
name|haveanswer
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|haveanswer
condition|)
block|{
operator|*
name|ap
operator|=
name|NULL
expr_stmt|;
operator|*
name|hap
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|template
operator|->
name|h_name
condition|)
block|{
name|n
operator|=
name|strlen
argument_list|(
name|qname
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* for the \0 */
if|if
condition|(
name|n
operator|>
name|ep
operator|-
name|bp
operator|||
name|n
operator|>=
name|MAXHOSTNAMELEN
condition|)
goto|goto
name|no_recovery
goto|;
name|strcpy
argument_list|(
name|bp
argument_list|,
name|qname
argument_list|)
expr_stmt|;
name|template
operator|->
name|h_name
operator|=
name|bp
expr_stmt|;
name|bp
operator|+=
name|n
expr_stmt|;
block|}
operator|*
name|errp
operator|=
name|NETDB_SUCCESS
expr_stmt|;
return|return
operator|(
name|template
operator|)
return|;
block|}
name|no_recovery
label|:
operator|*
name|errp
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
undef|#
directive|undef
name|BOUNDED_INCR
undef|#
directive|undef
name|BOUNDS_CHECK
undef|#
directive|undef
name|DNS_ASSERT
undef|#
directive|undef
name|DNS_FATAL
block|}
end_function

begin_function
specifier|static
name|int
name|_dns_ghbyname
parameter_list|(
name|void
modifier|*
name|rval
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|af
decl_stmt|;
name|int
modifier|*
name|errp
decl_stmt|;
name|int
name|n
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|int
name|qtype
decl_stmt|;
name|struct
name|hostent
name|hbuf
decl_stmt|;
name|querybuf
modifier|*
name|buf
decl_stmt|;
name|name
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|af
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|errp
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_INIT
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|res_init
argument_list|()
operator|<
literal|0
condition|)
block|{
operator|*
name|errp
operator|=
name|h_errno
expr_stmt|;
return|return
name|NS_UNAVAIL
return|;
block|}
block|}
name|memset
argument_list|(
operator|&
name|hbuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hbuf
argument_list|)
argument_list|)
expr_stmt|;
name|hbuf
operator|.
name|h_addrtype
operator|=
name|af
expr_stmt|;
name|hbuf
operator|.
name|h_length
operator|=
name|ADDRLEN
argument_list|(
name|af
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|qtype
operator|=
name|T_AAAA
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|AF_INET
case|:
name|qtype
operator|=
name|T_A
expr_stmt|;
break|break;
default|default:
operator|*
name|errp
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
name|NS_NOTFOUND
return|;
block|}
name|buf
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
operator|*
name|errp
operator|=
name|NETDB_INTERNAL
expr_stmt|;
return|return
name|NS_UNAVAIL
return|;
block|}
name|n
operator|=
name|res_search
argument_list|(
name|name
argument_list|,
name|C_IN
argument_list|,
name|qtype
argument_list|,
name|buf
operator|->
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
operator|->
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|*
name|errp
operator|=
name|h_errno
expr_stmt|;
return|return
name|NS_UNAVAIL
return|;
block|}
name|hp
operator|=
name|getanswer
argument_list|(
name|buf
argument_list|,
name|n
argument_list|,
name|name
argument_list|,
name|qtype
argument_list|,
operator|&
name|hbuf
argument_list|,
name|errp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hp
condition|)
block|{
operator|*
name|errp
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
name|NS_NOTFOUND
return|;
block|}
operator|*
operator|(
expr|struct
name|hostent
operator|*
operator|*
operator|)
name|rval
operator|=
name|_hpcopy
argument_list|(
operator|&
name|hbuf
argument_list|,
name|errp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
expr|struct
name|hostent
operator|*
operator|*
operator|)
name|rval
operator|!=
name|NULL
condition|)
return|return
name|NS_SUCCESS
return|;
elseif|else
if|if
condition|(
operator|*
name|errp
operator|==
name|TRY_AGAIN
condition|)
return|return
name|NS_TRYAGAIN
return|;
else|else
return|return
name|NS_NOTFOUND
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|_dns_ghbyaddr
parameter_list|(
name|void
modifier|*
name|rval
parameter_list|,
name|void
modifier|*
name|cb_data
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
specifier|const
name|void
modifier|*
name|addr
decl_stmt|;
name|int
name|addrlen
decl_stmt|;
name|int
name|af
decl_stmt|;
name|int
modifier|*
name|errp
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|err
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|u_char
name|c
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|bp
decl_stmt|;
name|struct
name|hostent
name|hbuf
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
specifier|static
specifier|const
name|char
name|hex
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
endif|#
directive|endif
name|querybuf
modifier|*
name|buf
decl_stmt|;
name|char
name|qbuf
index|[
name|MAXDNAME
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|hlist
index|[
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|tld6
index|[]
init|=
block|{
literal|"ip6.arpa"
block|,
name|NULL
block|}
decl_stmt|;
name|char
modifier|*
name|tld4
index|[]
init|=
block|{
literal|"in-addr.arpa"
block|,
name|NULL
block|}
decl_stmt|;
name|char
modifier|*
modifier|*
name|tld
decl_stmt|;
name|addr
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
expr_stmt|;
name|addrlen
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|af
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|errp
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
operator|*
argument_list|)
expr_stmt|;
operator|*
operator|(
expr|struct
name|hostent
operator|*
operator|*
operator|)
name|rval
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|INET6
comment|/* XXX */
if|if
condition|(
name|af
operator|==
name|AF_INET6
operator|&&
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|(
expr|struct
name|in6_addr
operator|*
operator|)
name|addr
argument_list|)
condition|)
return|return
name|NS_NOTFOUND
return|;
endif|#
directive|endif
switch|switch
condition|(
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
name|tld
operator|=
name|tld6
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|AF_INET
case|:
name|tld
operator|=
name|tld4
expr_stmt|;
break|break;
default|default:
return|return
name|NS_NOTFOUND
return|;
block|}
if|if
condition|(
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_INIT
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|res_init
argument_list|()
operator|<
literal|0
condition|)
block|{
operator|*
name|errp
operator|=
name|h_errno
expr_stmt|;
return|return
name|NS_UNAVAIL
return|;
block|}
block|}
name|memset
argument_list|(
operator|&
name|hbuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hbuf
argument_list|)
argument_list|)
expr_stmt|;
name|hbuf
operator|.
name|h_name
operator|=
name|NULL
expr_stmt|;
name|hbuf
operator|.
name|h_addrtype
operator|=
name|af
expr_stmt|;
name|hbuf
operator|.
name|h_length
operator|=
name|addrlen
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
operator|*
name|errp
operator|=
name|NETDB_INTERNAL
expr_stmt|;
return|return
name|NS_UNAVAIL
return|;
block|}
name|err
operator|=
name|NS_SUCCESS
expr_stmt|;
for|for
control|(
comment|/* nothing */
init|;
operator|*
name|tld
condition|;
name|tld
operator|++
control|)
block|{
comment|/* 		 * XXX assumes that MAXDNAME is big enough - error checks 		 * has been made by callers 		 */
name|n
operator|=
literal|0
expr_stmt|;
name|bp
operator|=
name|qbuf
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|addr
operator|+
name|addrlen
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|af
condition|)
block|{
ifdef|#
directive|ifdef
name|INET6
case|case
name|AF_INET6
case|:
for|for
control|(
init|;
name|n
operator|<
name|addrlen
condition|;
name|n
operator|++
operator|,
name|cp
operator|--
control|)
block|{
name|c
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
name|hex
index|[
name|c
operator|&
literal|0xf
index|]
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
name|hex
index|[
name|c
operator|>>
literal|4
index|]
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|bp
argument_list|,
operator|*
name|tld
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
name|AF_INET
case|:
for|for
control|(
init|;
name|n
operator|<
name|addrlen
condition|;
name|n
operator|++
operator|,
name|cp
operator|--
control|)
block|{
name|c
operator|=
operator|*
name|cp
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|100
condition|)
operator|*
name|bp
operator|++
operator|=
literal|'0'
operator|+
name|c
operator|/
literal|100
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|10
condition|)
operator|*
name|bp
operator|++
operator|=
literal|'0'
operator|+
operator|(
name|c
operator|%
literal|100
operator|)
operator|/
literal|10
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'0'
operator|+
name|c
operator|%
literal|10
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|bp
argument_list|,
operator|*
name|tld
argument_list|)
expr_stmt|;
break|break;
block|}
name|n
operator|=
name|res_query
argument_list|(
name|qbuf
argument_list|,
name|C_IN
argument_list|,
name|T_PTR
argument_list|,
name|buf
operator|->
name|buf
argument_list|,
sizeof|sizeof
name|buf
operator|->
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
operator|*
name|errp
operator|=
name|h_errno
expr_stmt|;
name|err
operator|=
name|NS_UNAVAIL
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|n
operator|>
sizeof|sizeof
argument_list|(
name|buf
operator|->
name|buf
argument_list|)
condition|)
block|{
if|#
directive|if
literal|0
block|errno = ERANGE;
comment|/* XXX is it OK to set errno here? */
endif|#
directive|endif
operator|*
name|errp
operator|=
name|NETDB_INTERNAL
expr_stmt|;
name|err
operator|=
name|NS_UNAVAIL
expr_stmt|;
continue|continue;
block|}
name|hp
operator|=
name|getanswer
argument_list|(
name|buf
argument_list|,
name|n
argument_list|,
name|qbuf
argument_list|,
name|T_PTR
argument_list|,
operator|&
name|hbuf
argument_list|,
name|errp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hp
condition|)
block|{
name|err
operator|=
name|NS_NOTFOUND
expr_stmt|;
continue|continue;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|hbuf
operator|.
name|h_addrtype
operator|=
name|af
expr_stmt|;
name|hbuf
operator|.
name|h_length
operator|=
name|addrlen
expr_stmt|;
name|hbuf
operator|.
name|h_addr_list
operator|=
name|hlist
expr_stmt|;
name|hlist
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|*
operator|)
name|addr
expr_stmt|;
name|hlist
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
operator|(
expr|struct
name|hostent
operator|*
operator|*
operator|)
name|rval
operator|=
name|_hpcopy
argument_list|(
operator|&
name|hbuf
argument_list|,
name|errp
argument_list|)
expr_stmt|;
return|return
name|NS_SUCCESS
return|;
block|}
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_dns_shent
parameter_list|(
name|int
name|stayopen
parameter_list|)
block|{
if|if
condition|(
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_INIT
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|res_init
argument_list|()
operator|<
literal|0
condition|)
return|return;
block|}
if|if
condition|(
name|stayopen
condition|)
name|_res
operator|.
name|options
operator||=
name|RES_STAYOPEN
operator||
name|RES_USEVC
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|_dns_ehent
parameter_list|(
name|void
parameter_list|)
block|{
name|_res
operator|.
name|options
operator|&=
operator|~
operator|(
name|RES_STAYOPEN
operator||
name|RES_USEVC
operator|)
expr_stmt|;
name|res_close
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ICMPNL
end_ifdef

begin_comment
comment|/*  * experimental:  *	draft-ietf-ipngwg-icmp-namelookups-02.txt  *	ifindex is assumed to be encoded in addr.  */
end_comment

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<netinet/ip6.h>
end_include

begin_include
include|#
directive|include
file|<netinet/icmp6.h>
end_include

begin_struct
struct|struct
name|_icmp_host_cache
block|{
name|struct
name|_icmp_host_cache
modifier|*
name|hc_next
decl_stmt|;
name|int
name|hc_ifindex
decl_stmt|;
name|struct
name|in6_addr
name|hc_addr
decl_stmt|;
name|char
modifier|*
name|hc_name
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|char
modifier|*
name|_icmp_fqdn_query
parameter_list|(
specifier|const
name|struct
name|in6_addr
modifier|*
name|addr
parameter_list|,
name|int
name|ifindex
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|struct
name|icmp6_filter
name|filter
decl_stmt|;
name|struct
name|msghdr
name|msg
decl_stmt|;
name|struct
name|cmsghdr
modifier|*
name|cmsg
decl_stmt|;
name|struct
name|in6_pktinfo
modifier|*
name|pkt
decl_stmt|;
name|char
name|cbuf
index|[
literal|256
index|]
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|cc
decl_stmt|;
name|struct
name|icmp6_fqdn_query
modifier|*
name|fq
decl_stmt|;
name|struct
name|icmp6_fqdn_reply
modifier|*
name|fr
decl_stmt|;
name|struct
name|_icmp_host_cache
modifier|*
name|hc
decl_stmt|;
name|struct
name|sockaddr_in6
name|sin6
decl_stmt|;
name|struct
name|iovec
name|iov
decl_stmt|;
name|fd_set
name|s_fds
decl_stmt|,
name|fds
decl_stmt|;
name|struct
name|timeval
name|tout
decl_stmt|;
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
specifier|static
name|struct
name|_icmp_host_cache
modifier|*
name|hc_head
decl_stmt|;
name|THREAD_LOCK
argument_list|()
expr_stmt|;
for|for
control|(
name|hc
operator|=
name|hc_head
init|;
name|hc
condition|;
name|hc
operator|=
name|hc
operator|->
name|hc_next
control|)
block|{
if|if
condition|(
name|hc
operator|->
name|hc_ifindex
operator|==
name|ifindex
operator|&&
name|IN6_ARE_ADDR_EQUAL
argument_list|(
operator|&
name|hc
operator|->
name|hc_addr
argument_list|,
name|addr
argument_list|)
condition|)
block|{
name|THREAD_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|hc
operator|->
name|hc_name
return|;
comment|/* XXX: never freed */
block|}
block|}
name|THREAD_UNLOCK
argument_list|()
expr_stmt|;
name|ICMP6_FILTER_SETBLOCKALL
argument_list|(
operator|&
name|filter
argument_list|)
expr_stmt|;
name|ICMP6_FILTER_SETPASS
argument_list|(
name|ICMP6_FQDN_REPLY
argument_list|,
operator|&
name|filter
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|s_fds
argument_list|)
expr_stmt|;
name|tout
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|tout
operator|.
name|tv_usec
operator|=
literal|200000
expr_stmt|;
comment|/*XXX: 200ms*/
name|fq
operator|=
operator|(
expr|struct
name|icmp6_fqdn_query
operator|*
operator|)
name|buf
expr_stmt|;
name|fq
operator|->
name|icmp6_fqdn_type
operator|=
name|ICMP6_FQDN_QUERY
expr_stmt|;
name|fq
operator|->
name|icmp6_fqdn_code
operator|=
literal|0
expr_stmt|;
name|fq
operator|->
name|icmp6_fqdn_cksum
operator|=
literal|0
expr_stmt|;
name|fq
operator|->
name|icmp6_fqdn_id
operator|=
operator|(
name|u_short
operator|)
name|getpid
argument_list|()
expr_stmt|;
name|fq
operator|->
name|icmp6_fqdn_unused
operator|=
literal|0
expr_stmt|;
name|fq
operator|->
name|icmp6_fqdn_cookie
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|fq
operator|->
name|icmp6_fqdn_cookie
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sin6
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
argument_list|)
expr_stmt|;
name|sin6
operator|.
name|sin6_family
operator|=
name|AF_INET6
expr_stmt|;
name|sin6
operator|.
name|sin6_addr
operator|=
operator|*
name|addr
expr_stmt|;
name|memset
argument_list|(
operator|&
name|msg
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|.
name|msg_name
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|sin6
expr_stmt|;
name|msg
operator|.
name|msg_namelen
operator|=
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
name|msg
operator|.
name|msg_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|msg
operator|.
name|msg_iovlen
operator|=
literal|1
expr_stmt|;
name|msg
operator|.
name|msg_control
operator|=
name|NULL
expr_stmt|;
name|msg
operator|.
name|msg_controllen
operator|=
literal|0
expr_stmt|;
name|iov
operator|.
name|iov_base
operator|=
operator|(
name|caddr_t
operator|)
name|buf
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|icmp6_fqdn_query
argument_list|)
expr_stmt|;
if|if
condition|(
name|ifindex
condition|)
block|{
name|msg
operator|.
name|msg_control
operator|=
name|cbuf
expr_stmt|;
name|msg
operator|.
name|msg_controllen
operator|=
sizeof|sizeof
argument_list|(
name|cbuf
argument_list|)
expr_stmt|;
name|cmsg
operator|=
name|CMSG_FIRSTHDR
argument_list|(
operator|&
name|msg
argument_list|)
expr_stmt|;
name|cmsg
operator|->
name|cmsg_len
operator|=
name|CMSG_LEN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|in6_pktinfo
argument_list|)
argument_list|)
expr_stmt|;
name|cmsg
operator|->
name|cmsg_level
operator|=
name|IPPROTO_IPV6
expr_stmt|;
name|cmsg
operator|->
name|cmsg_type
operator|=
name|IPV6_PKTINFO
expr_stmt|;
name|pkt
operator|=
operator|(
expr|struct
name|in6_pktinfo
operator|*
operator|)
operator|&
name|cmsg
index|[
literal|1
index|]
expr_stmt|;
name|memset
argument_list|(
operator|&
name|pkt
operator|->
name|ipi6_addr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in6_addr
argument_list|)
argument_list|)
expr_stmt|;
name|pkt
operator|->
name|ipi6_ifindex
operator|=
name|ifindex
expr_stmt|;
name|cmsg
operator|=
name|CMSG_NXTHDR
argument_list|(
operator|&
name|msg
argument_list|,
name|cmsg
argument_list|)
expr_stmt|;
name|msg
operator|.
name|msg_controllen
operator|=
operator|(
name|char
operator|*
operator|)
name|cmsg
operator|-
name|cbuf
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|s
operator|=
name|_socket
argument_list|(
name|PF_INET6
argument_list|,
name|SOCK_RAW
argument_list|,
name|IPPROTO_ICMPV6
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
name|NULL
return|;
operator|(
name|void
operator|)
name|_setsockopt
argument_list|(
name|s
argument_list|,
name|IPPROTO_ICMPV6
argument_list|,
name|ICMP6_FILTER
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|filter
argument_list|,
sizeof|sizeof
argument_list|(
name|filter
argument_list|)
argument_list|)
expr_stmt|;
name|cc
operator|=
name|_sendmsg
argument_list|(
name|s
argument_list|,
operator|&
name|msg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|<
literal|0
condition|)
block|{
name|_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|FD_SET
argument_list|(
name|s
argument_list|,
operator|&
name|s_fds
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|fds
operator|=
name|s_fds
expr_stmt|;
if|if
condition|(
name|_select
argument_list|(
name|s
operator|+
literal|1
argument_list|,
operator|&
name|fds
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|tout
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|len
operator|=
sizeof|sizeof
argument_list|(
name|sin6
argument_list|)
expr_stmt|;
name|cc
operator|=
name|_recvfrom
argument_list|(
name|s
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin6
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|<=
literal|0
condition|)
block|{
name|_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|cc
operator|<
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|icmp6_hdr
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|IN6_ARE_ADDR_EQUAL
argument_list|(
name|addr
argument_list|,
operator|&
name|sin6
operator|.
name|sin6_addr
argument_list|)
condition|)
continue|continue;
name|fr
operator|=
operator|(
expr|struct
name|icmp6_fqdn_reply
operator|*
operator|)
operator|(
name|buf
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|fr
operator|->
name|icmp6_fqdn_type
operator|==
name|ICMP6_FQDN_REPLY
condition|)
break|break;
block|}
name|_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|fr
operator|->
name|icmp6_fqdn_cookie
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* rfc1788 type */
name|name
operator|=
name|buf
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|ip6_hdr
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|icmp6_hdr
argument_list|)
operator|+
literal|4
expr_stmt|;
name|len
operator|=
operator|(
name|buf
operator|+
name|cc
operator|)
operator|-
name|name
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|fr
operator|->
name|icmp6_fqdn_namelen
expr_stmt|;
name|name
operator|=
name|fr
operator|->
name|icmp6_fqdn_name
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|<=
literal|0
condition|)
return|return
name|NULL
return|;
name|name
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|hc
operator|=
operator|(
expr|struct
name|_icmp_host_cache
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|hc
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* XXX: limit number of cached entries */
name|hc
operator|->
name|hc_ifindex
operator|=
name|ifindex
expr_stmt|;
name|hc
operator|->
name|hc_addr
operator|=
operator|*
name|addr
expr_stmt|;
name|hc
operator|->
name|hc_name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|THREAD_LOCK
argument_list|()
expr_stmt|;
name|hc
operator|->
name|hc_next
operator|=
name|hc_head
expr_stmt|;
name|hc_head
operator|=
name|hc
expr_stmt|;
name|THREAD_UNLOCK
argument_list|()
expr_stmt|;
return|return
name|hc
operator|->
name|hc_name
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|hostent
modifier|*
name|_icmp_ghbyaddr
parameter_list|(
specifier|const
name|void
modifier|*
name|addr
parameter_list|,
name|int
name|addrlen
parameter_list|,
name|int
name|af
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
block|{
name|char
modifier|*
name|hname
decl_stmt|;
name|int
name|ifindex
decl_stmt|;
name|struct
name|in6_addr
name|addr6
decl_stmt|;
if|if
condition|(
name|af
operator|!=
name|AF_INET6
condition|)
block|{
comment|/* 		 * Note: rfc1788 defines Who Are You for IPv4, 		 * but no one implements it. 		 */
return|return
name|NULL
return|;
block|}
name|memcpy
argument_list|(
operator|&
name|addr6
argument_list|,
name|addr
argument_list|,
name|addrlen
argument_list|)
expr_stmt|;
name|ifindex
operator|=
operator|(
name|addr6
operator|.
name|s6_addr
index|[
literal|2
index|]
operator|<<
literal|8
operator|)
operator||
name|addr6
operator|.
name|s6_addr
index|[
literal|3
index|]
expr_stmt|;
name|addr6
operator|.
name|s6_addr
index|[
literal|2
index|]
operator|=
name|addr6
operator|.
name|s6_addr
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|IN6_IS_ADDR_LINKLOCAL
argument_list|(
operator|&
name|addr6
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/*XXX*/
if|if
condition|(
operator|(
name|hname
operator|=
name|_icmp_fqdn_query
argument_list|(
operator|&
name|addr6
argument_list|,
name|ifindex
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
name|_hpaddr
argument_list|(
name|af
argument_list|,
name|hname
argument_list|,
operator|&
name|addr6
argument_list|,
name|errp
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ICMPNL */
end_comment

end_unit

