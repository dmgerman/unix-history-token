begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: clnt_vc.c,v 1.4 2000/07/14 08:40:42 fvdl Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 2009, Sun Microsystems, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without   * modification, are permitted provided that the following conditions are met:  * - Redistributions of source code must retain the above copyright notice,   *   this list of conditions and the following disclaimer.  * - Redistributions in binary form must reproduce the above copyright notice,   *   this list of conditions and the following disclaimer in the documentation   *   and/or other materials provided with the distribution.  * - Neither the name of Sun Microsystems, Inc. nor the names of its   *   contributors may be used to endorse or promote products derived   *   from this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid2
init|=
literal|"@(#)clnt_tcp.c 1.37 87/10/05 Copyr 1984 Sun Micro"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)clnt_tcp.c	2.2 88/08/01 4.0 RPCSRC"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|sccsid3
index|[]
init|=
literal|"@(#)clnt_vc.c 1.19 89/03/16 Copyr 1988 Sun Micro"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * clnt_tcp.c, Implements a TCP/IP based, client side RPC.  *  * Copyright (C) 1984, Sun Microsystems, Inc.  *  * TCP based RPC supports 'batched calls'.  * A sequence of calls may be batched-up in a send buffer.  The rpc call  * return immediately to the client even though the call was not necessarily  * sent.  The batching occurs if the results' xdr routine is NULL (0) AND  * the rpc timeout value is zero (see clnt.h, rpc).  *  * Clients should NOT casually batch calls that in fact return results; that is,  * the server side should be aware that a call is batched and not produce any  * return message.  Batched calls that produce many result messages can  * deadlock (netlock) the client and the server....  *  * Now go hang yourself.  */
end_comment

begin_include
include|#
directive|include
file|"namespace.h"
end_include

begin_include
include|#
directive|include
file|"reentrant.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslog.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpc.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpcsec_gss.h>
end_include

begin_include
include|#
directive|include
file|"un-namespace.h"
end_include

begin_include
include|#
directive|include
file|"rpc_com.h"
end_include

begin_include
include|#
directive|include
file|"mt_misc.h"
end_include

begin_define
define|#
directive|define
name|MCALL_MSG_SIZE
value|24
end_define

begin_struct
struct|struct
name|cmessage
block|{
name|struct
name|cmsghdr
name|cmsg
decl_stmt|;
name|struct
name|cmsgcred
name|cmcred
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|enum
name|clnt_stat
name|clnt_vc_call
parameter_list|(
name|CLIENT
modifier|*
parameter_list|,
name|rpcproc_t
parameter_list|,
name|xdrproc_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|xdrproc_t
parameter_list|,
name|void
modifier|*
parameter_list|,
name|struct
name|timeval
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clnt_vc_geterr
parameter_list|(
name|CLIENT
modifier|*
parameter_list|,
name|struct
name|rpc_err
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|clnt_vc_freeres
parameter_list|(
name|CLIENT
modifier|*
parameter_list|,
name|xdrproc_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clnt_vc_abort
parameter_list|(
name|CLIENT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|clnt_vc_control
parameter_list|(
name|CLIENT
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clnt_vc_destroy
parameter_list|(
name|CLIENT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|clnt_ops
modifier|*
name|clnt_vc_ops
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|time_not_ok
parameter_list|(
name|struct
name|timeval
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_vc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|write_vc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|__msgwrite
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|__msgread
parameter_list|(
name|int
parameter_list|,
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|ct_data
block|{
name|int
name|ct_fd
decl_stmt|;
comment|/* connection's fd */
name|bool_t
name|ct_closeit
decl_stmt|;
comment|/* close it on destroy */
name|struct
name|timeval
name|ct_wait
decl_stmt|;
comment|/* wait interval in milliseconds */
name|bool_t
name|ct_waitset
decl_stmt|;
comment|/* wait set by clnt_control? */
name|struct
name|netbuf
name|ct_addr
decl_stmt|;
comment|/* remote addr */
name|struct
name|rpc_err
name|ct_error
decl_stmt|;
union|union
block|{
name|char
name|ct_mcallc
index|[
name|MCALL_MSG_SIZE
index|]
decl_stmt|;
comment|/* marshalled callmsg */
name|u_int32_t
name|ct_mcalli
decl_stmt|;
block|}
name|ct_u
union|;
name|u_int
name|ct_mpos
decl_stmt|;
comment|/* pos after marshal */
name|XDR
name|ct_xdrs
decl_stmt|;
comment|/* XDR stream */
block|}
struct|;
end_struct

begin_comment
comment|/*  *      This machinery implements per-fd locks for MT-safety.  It is not  *      sufficient to do per-CLIENT handle locks for MT-safety because a  *      user may create more than one CLIENT handle with the same fd behind  *      it.  Therfore, we allocate an array of flags (vc_fd_locks), protected  *      by the clnt_fd_lock mutex, and an array (vc_cv) of condition variables  *      similarly protected.  Vc_fd_lock[fd] == 1 => a call is activte on some  *      CLIENT handle created for that fd.  *      The current implementation holds locks across the entire RPC and reply.  *      Yes, this is silly, and as soon as this code is proven to work, this  *      should be the first thing fixed.  One step at a time.  */
end_comment

begin_decl_stmt
specifier|static
name|int
modifier|*
name|vc_fd_locks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cond_t
modifier|*
name|vc_cv
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|release_fd_lock
parameter_list|(
name|fd
parameter_list|,
name|mask
parameter_list|)
value|{	\ 	mutex_lock(&clnt_fd_lock);	\ 	vc_fd_locks[fd] = 0;		\ 	mutex_unlock(&clnt_fd_lock);	\ 	thr_sigsetmask(SIG_SETMASK,&(mask), (sigset_t *) NULL);	\ 	cond_signal(&vc_cv[fd]);	\ }
end_define

begin_decl_stmt
specifier|static
specifier|const
name|char
name|clnt_vc_errstr
index|[]
init|=
literal|"%s : %s"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|clnt_vc_str
index|[]
init|=
literal|"clnt_vc_create"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|__no_mem_str
index|[]
init|=
literal|"out of memory"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Create a client handle for a connection.  * Default options are set, which the user can change using clnt_control()'s.  * The rpc/vc package does buffering similar to stdio, so the client  * must pick send and receive buffer sizes, 0 => use the default.  * NB: fd is copied into a private area.  * NB: The rpch->cl_auth is set null authentication. Caller may wish to  * set this something more useful.  *  * fd should be an open socket  *  * fd - open file descriptor  * raddr - servers address  * prog  - program number  * vers  - version number  * sendsz - buffer send size  * recvsz - buffer recv size  */
end_comment

begin_function
name|CLIENT
modifier|*
name|clnt_vc_create
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|struct
name|netbuf
modifier|*
name|raddr
parameter_list|,
specifier|const
name|rpcprog_t
name|prog
parameter_list|,
specifier|const
name|rpcvers_t
name|vers
parameter_list|,
name|u_int
name|sendsz
parameter_list|,
name|u_int
name|recvsz
parameter_list|)
block|{
name|CLIENT
modifier|*
name|cl
decl_stmt|;
comment|/* client handle */
name|struct
name|ct_data
modifier|*
name|ct
init|=
name|NULL
decl_stmt|;
comment|/* client handle */
name|struct
name|timeval
name|now
decl_stmt|;
name|struct
name|rpc_msg
name|call_msg
decl_stmt|;
specifier|static
name|u_int32_t
name|disrupt
decl_stmt|;
name|sigset_t
name|mask
decl_stmt|;
name|sigset_t
name|newmask
decl_stmt|;
name|struct
name|sockaddr_storage
name|ss
decl_stmt|;
name|socklen_t
name|slen
decl_stmt|;
name|struct
name|__rpc_sockinfo
name|si
decl_stmt|;
if|if
condition|(
name|disrupt
operator|==
literal|0
condition|)
name|disrupt
operator|=
operator|(
name|u_int32_t
operator|)
operator|(
name|long
operator|)
name|raddr
expr_stmt|;
name|cl
operator|=
operator|(
name|CLIENT
operator|*
operator|)
name|mem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|cl
argument_list|)
argument_list|)
expr_stmt|;
name|ct
operator|=
operator|(
expr|struct
name|ct_data
operator|*
operator|)
name|mem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ct
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cl
operator|==
operator|(
name|CLIENT
operator|*
operator|)
name|NULL
operator|)
operator|||
operator|(
name|ct
operator|==
operator|(
expr|struct
name|ct_data
operator|*
operator|)
name|NULL
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
name|clnt_vc_errstr
argument_list|,
name|clnt_vc_str
argument_list|,
name|__no_mem_str
argument_list|)
expr_stmt|;
name|rpc_createerr
operator|.
name|cf_stat
operator|=
name|RPC_SYSTEMERROR
expr_stmt|;
name|rpc_createerr
operator|.
name|cf_error
operator|.
name|re_errno
operator|=
name|errno
expr_stmt|;
goto|goto
name|err
goto|;
block|}
name|ct
operator|->
name|ct_addr
operator|.
name|buf
operator|=
name|NULL
expr_stmt|;
name|sigfillset
argument_list|(
operator|&
name|newmask
argument_list|)
expr_stmt|;
name|thr_sigsetmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|newmask
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|clnt_fd_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|vc_fd_locks
operator|==
operator|(
name|int
operator|*
operator|)
name|NULL
condition|)
block|{
name|int
name|cv_allocsz
decl_stmt|,
name|fd_allocsz
decl_stmt|;
name|int
name|dtbsize
init|=
name|__rpc_dtbsize
argument_list|()
decl_stmt|;
name|fd_allocsz
operator|=
name|dtbsize
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
name|vc_fd_locks
operator|=
operator|(
name|int
operator|*
operator|)
name|mem_alloc
argument_list|(
name|fd_allocsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|vc_fd_locks
operator|==
operator|(
name|int
operator|*
operator|)
name|NULL
condition|)
block|{
name|mutex_unlock
argument_list|(
operator|&
name|clnt_fd_lock
argument_list|)
expr_stmt|;
name|thr_sigsetmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
operator|(
name|mask
operator|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
else|else
name|memset
argument_list|(
name|vc_fd_locks
argument_list|,
literal|'\0'
argument_list|,
name|fd_allocsz
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|vc_cv
operator|==
operator|(
name|cond_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|cv_allocsz
operator|=
name|dtbsize
operator|*
sizeof|sizeof
argument_list|(
name|cond_t
argument_list|)
expr_stmt|;
name|vc_cv
operator|=
operator|(
name|cond_t
operator|*
operator|)
name|mem_alloc
argument_list|(
name|cv_allocsz
argument_list|)
expr_stmt|;
if|if
condition|(
name|vc_cv
operator|==
operator|(
name|cond_t
operator|*
operator|)
name|NULL
condition|)
block|{
name|mem_free
argument_list|(
name|vc_fd_locks
argument_list|,
name|fd_allocsz
argument_list|)
expr_stmt|;
name|vc_fd_locks
operator|=
operator|(
name|int
operator|*
operator|)
name|NULL
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|clnt_fd_lock
argument_list|)
expr_stmt|;
name|thr_sigsetmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
operator|(
name|mask
operator|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dtbsize
condition|;
name|i
operator|++
control|)
name|cond_init
argument_list|(
operator|&
name|vc_cv
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|assert
argument_list|(
name|vc_cv
operator|!=
operator|(
name|cond_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * XXX - fvdl connecting while holding a mutex? 	 */
name|slen
operator|=
sizeof|sizeof
name|ss
expr_stmt|;
if|if
condition|(
name|_getpeername
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|&
name|ss
argument_list|,
operator|&
name|slen
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOTCONN
condition|)
block|{
name|rpc_createerr
operator|.
name|cf_stat
operator|=
name|RPC_SYSTEMERROR
expr_stmt|;
name|rpc_createerr
operator|.
name|cf_error
operator|.
name|re_errno
operator|=
name|errno
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|clnt_fd_lock
argument_list|)
expr_stmt|;
name|thr_sigsetmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
operator|(
name|mask
operator|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|_connect
argument_list|(
name|fd
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|raddr
operator|->
name|buf
argument_list|,
name|raddr
operator|->
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|rpc_createerr
operator|.
name|cf_stat
operator|=
name|RPC_SYSTEMERROR
expr_stmt|;
name|rpc_createerr
operator|.
name|cf_error
operator|.
name|re_errno
operator|=
name|errno
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|clnt_fd_lock
argument_list|)
expr_stmt|;
name|thr_sigsetmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
operator|(
name|mask
operator|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
name|mutex_unlock
argument_list|(
operator|&
name|clnt_fd_lock
argument_list|)
expr_stmt|;
name|thr_sigsetmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
operator|(
name|mask
operator|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|__rpc_fd2sockinfo
argument_list|(
name|fd
argument_list|,
operator|&
name|si
argument_list|)
condition|)
goto|goto
name|err
goto|;
name|ct
operator|->
name|ct_closeit
operator|=
name|FALSE
expr_stmt|;
comment|/* 	 * Set up private data struct 	 */
name|ct
operator|->
name|ct_fd
operator|=
name|fd
expr_stmt|;
name|ct
operator|->
name|ct_wait
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
name|ct
operator|->
name|ct_waitset
operator|=
name|FALSE
expr_stmt|;
name|ct
operator|->
name|ct_addr
operator|.
name|buf
operator|=
name|malloc
argument_list|(
name|raddr
operator|->
name|maxlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|ct_addr
operator|.
name|buf
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|memcpy
argument_list|(
name|ct
operator|->
name|ct_addr
operator|.
name|buf
argument_list|,
name|raddr
operator|->
name|buf
argument_list|,
name|raddr
operator|->
name|len
argument_list|)
expr_stmt|;
name|ct
operator|->
name|ct_addr
operator|.
name|len
operator|=
name|raddr
operator|->
name|len
expr_stmt|;
name|ct
operator|->
name|ct_addr
operator|.
name|maxlen
operator|=
name|raddr
operator|->
name|maxlen
expr_stmt|;
comment|/* 	 * Initialize call message 	 */
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|now
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|call_msg
operator|.
name|rm_xid
operator|=
operator|(
operator|(
name|u_int32_t
operator|)
operator|++
name|disrupt
operator|)
operator|^
name|__RPC_GETXID
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|call_msg
operator|.
name|rm_direction
operator|=
name|CALL
expr_stmt|;
name|call_msg
operator|.
name|rm_call
operator|.
name|cb_rpcvers
operator|=
name|RPC_MSG_VERSION
expr_stmt|;
name|call_msg
operator|.
name|rm_call
operator|.
name|cb_prog
operator|=
operator|(
name|u_int32_t
operator|)
name|prog
expr_stmt|;
name|call_msg
operator|.
name|rm_call
operator|.
name|cb_vers
operator|=
operator|(
name|u_int32_t
operator|)
name|vers
expr_stmt|;
comment|/* 	 * pre-serialize the static part of the call msg and stash it away 	 */
name|xdrmem_create
argument_list|(
operator|&
operator|(
name|ct
operator|->
name|ct_xdrs
operator|)
argument_list|,
name|ct
operator|->
name|ct_u
operator|.
name|ct_mcallc
argument_list|,
name|MCALL_MSG_SIZE
argument_list|,
name|XDR_ENCODE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xdr_callhdr
argument_list|(
operator|&
operator|(
name|ct
operator|->
name|ct_xdrs
operator|)
argument_list|,
operator|&
name|call_msg
argument_list|)
condition|)
block|{
if|if
condition|(
name|ct
operator|->
name|ct_closeit
condition|)
block|{
operator|(
name|void
operator|)
name|_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
goto|goto
name|err
goto|;
block|}
name|ct
operator|->
name|ct_mpos
operator|=
name|XDR_GETPOS
argument_list|(
operator|&
operator|(
name|ct
operator|->
name|ct_xdrs
operator|)
argument_list|)
expr_stmt|;
name|XDR_DESTROY
argument_list|(
operator|&
operator|(
name|ct
operator|->
name|ct_xdrs
operator|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ct
operator|->
name|ct_mpos
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|<=
name|MCALL_MSG_SIZE
argument_list|)
expr_stmt|;
comment|/* 	 * Create a client handle which uses xdrrec for serialization 	 * and authnone for authentication. 	 */
name|cl
operator|->
name|cl_ops
operator|=
name|clnt_vc_ops
argument_list|()
expr_stmt|;
name|cl
operator|->
name|cl_private
operator|=
name|ct
expr_stmt|;
name|cl
operator|->
name|cl_auth
operator|=
name|authnone_create
argument_list|()
expr_stmt|;
name|sendsz
operator|=
name|__rpc_get_t_size
argument_list|(
name|si
operator|.
name|si_af
argument_list|,
name|si
operator|.
name|si_proto
argument_list|,
operator|(
name|int
operator|)
name|sendsz
argument_list|)
expr_stmt|;
name|recvsz
operator|=
name|__rpc_get_t_size
argument_list|(
name|si
operator|.
name|si_af
argument_list|,
name|si
operator|.
name|si_proto
argument_list|,
operator|(
name|int
operator|)
name|recvsz
argument_list|)
expr_stmt|;
name|xdrrec_create
argument_list|(
operator|&
operator|(
name|ct
operator|->
name|ct_xdrs
operator|)
argument_list|,
name|sendsz
argument_list|,
name|recvsz
argument_list|,
name|cl
operator|->
name|cl_private
argument_list|,
name|read_vc
argument_list|,
name|write_vc
argument_list|)
expr_stmt|;
return|return
operator|(
name|cl
operator|)
return|;
name|err
label|:
if|if
condition|(
name|ct
condition|)
block|{
if|if
condition|(
name|ct
operator|->
name|ct_addr
operator|.
name|len
condition|)
name|mem_free
argument_list|(
name|ct
operator|->
name|ct_addr
operator|.
name|buf
argument_list|,
name|ct
operator|->
name|ct_addr
operator|.
name|len
argument_list|)
expr_stmt|;
name|mem_free
argument_list|(
name|ct
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ct_data
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cl
condition|)
name|mem_free
argument_list|(
name|cl
argument_list|,
sizeof|sizeof
argument_list|(
name|CLIENT
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|CLIENT
operator|*
operator|)
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|clnt_stat
name|clnt_vc_call
parameter_list|(
name|CLIENT
modifier|*
name|cl
parameter_list|,
name|rpcproc_t
name|proc
parameter_list|,
name|xdrproc_t
name|xdr_args
parameter_list|,
name|void
modifier|*
name|args_ptr
parameter_list|,
name|xdrproc_t
name|xdr_results
parameter_list|,
name|void
modifier|*
name|results_ptr
parameter_list|,
name|struct
name|timeval
name|timeout
parameter_list|)
block|{
name|struct
name|ct_data
modifier|*
name|ct
init|=
operator|(
expr|struct
name|ct_data
operator|*
operator|)
name|cl
operator|->
name|cl_private
decl_stmt|;
name|XDR
modifier|*
name|xdrs
init|=
operator|&
operator|(
name|ct
operator|->
name|ct_xdrs
operator|)
decl_stmt|;
name|struct
name|rpc_msg
name|reply_msg
decl_stmt|;
name|u_int32_t
name|x_id
decl_stmt|;
name|u_int32_t
modifier|*
name|msg_x_id
init|=
operator|&
name|ct
operator|->
name|ct_u
operator|.
name|ct_mcalli
decl_stmt|;
comment|/* yuk */
name|bool_t
name|shipnow
decl_stmt|;
name|int
name|refreshes
init|=
literal|2
decl_stmt|;
name|sigset_t
name|mask
decl_stmt|,
name|newmask
decl_stmt|;
name|int
name|rpc_lock_value
decl_stmt|;
name|bool_t
name|reply_stat
decl_stmt|;
name|assert
argument_list|(
name|cl
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|sigfillset
argument_list|(
operator|&
name|newmask
argument_list|)
expr_stmt|;
name|thr_sigsetmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|newmask
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|clnt_fd_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|vc_fd_locks
index|[
name|ct
operator|->
name|ct_fd
index|]
condition|)
name|cond_wait
argument_list|(
operator|&
name|vc_cv
index|[
name|ct
operator|->
name|ct_fd
index|]
argument_list|,
operator|&
name|clnt_fd_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|__isthreaded
condition|)
name|rpc_lock_value
operator|=
literal|1
expr_stmt|;
else|else
name|rpc_lock_value
operator|=
literal|0
expr_stmt|;
name|vc_fd_locks
index|[
name|ct
operator|->
name|ct_fd
index|]
operator|=
name|rpc_lock_value
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|clnt_fd_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ct
operator|->
name|ct_waitset
condition|)
block|{
comment|/* If time is not within limits, we ignore it. */
if|if
condition|(
name|time_not_ok
argument_list|(
operator|&
name|timeout
argument_list|)
operator|==
name|FALSE
condition|)
name|ct
operator|->
name|ct_wait
operator|=
name|timeout
expr_stmt|;
block|}
name|shipnow
operator|=
operator|(
name|xdr_results
operator|==
name|NULL
operator|&&
name|timeout
operator|.
name|tv_sec
operator|==
literal|0
operator|&&
name|timeout
operator|.
name|tv_usec
operator|==
literal|0
operator|)
condition|?
name|FALSE
else|:
name|TRUE
expr_stmt|;
name|call_again
label|:
name|xdrs
operator|->
name|x_op
operator|=
name|XDR_ENCODE
expr_stmt|;
name|ct
operator|->
name|ct_error
operator|.
name|re_status
operator|=
name|RPC_SUCCESS
expr_stmt|;
name|x_id
operator|=
name|ntohl
argument_list|(
operator|--
operator|(
operator|*
name|msg_x_id
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|cl_auth
operator|->
name|ah_cred
operator|.
name|oa_flavor
operator|!=
name|RPCSEC_GSS
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|XDR_PUTBYTES
argument_list|(
name|xdrs
argument_list|,
name|ct
operator|->
name|ct_u
operator|.
name|ct_mcallc
argument_list|,
name|ct
operator|->
name|ct_mpos
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|XDR_PUTINT32
argument_list|(
name|xdrs
argument_list|,
operator|&
name|proc
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|AUTH_MARSHALL
argument_list|(
name|cl
operator|->
name|cl_auth
argument_list|,
name|xdrs
argument_list|)
operator|)
operator|||
operator|(
operator|!
call|(
modifier|*
name|xdr_args
call|)
argument_list|(
name|xdrs
argument_list|,
name|args_ptr
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|ct
operator|->
name|ct_error
operator|.
name|re_status
operator|==
name|RPC_SUCCESS
condition|)
name|ct
operator|->
name|ct_error
operator|.
name|re_status
operator|=
name|RPC_CANTENCODEARGS
expr_stmt|;
operator|(
name|void
operator|)
name|xdrrec_endofrecord
argument_list|(
name|xdrs
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|release_fd_lock
argument_list|(
name|ct
operator|->
name|ct_fd
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
operator|(
name|ct
operator|->
name|ct_error
operator|.
name|re_status
operator|)
return|;
block|}
block|}
else|else
block|{
operator|*
operator|(
name|uint32_t
operator|*
operator|)
operator|&
name|ct
operator|->
name|ct_u
operator|.
name|ct_mcallc
index|[
name|ct
operator|->
name|ct_mpos
index|]
operator|=
name|htonl
argument_list|(
name|proc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|__rpc_gss_wrap
argument_list|(
name|cl
operator|->
name|cl_auth
argument_list|,
name|ct
operator|->
name|ct_u
operator|.
name|ct_mcallc
argument_list|,
name|ct
operator|->
name|ct_mpos
operator|+
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|xdrs
argument_list|,
name|xdr_args
argument_list|,
name|args_ptr
argument_list|)
condition|)
block|{
if|if
condition|(
name|ct
operator|->
name|ct_error
operator|.
name|re_status
operator|==
name|RPC_SUCCESS
condition|)
name|ct
operator|->
name|ct_error
operator|.
name|re_status
operator|=
name|RPC_CANTENCODEARGS
expr_stmt|;
operator|(
name|void
operator|)
name|xdrrec_endofrecord
argument_list|(
name|xdrs
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|release_fd_lock
argument_list|(
name|ct
operator|->
name|ct_fd
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
operator|(
name|ct
operator|->
name|ct_error
operator|.
name|re_status
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|xdrrec_endofrecord
argument_list|(
name|xdrs
argument_list|,
name|shipnow
argument_list|)
condition|)
block|{
name|release_fd_lock
argument_list|(
name|ct
operator|->
name|ct_fd
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
operator|(
name|ct
operator|->
name|ct_error
operator|.
name|re_status
operator|=
name|RPC_CANTSEND
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|shipnow
condition|)
block|{
name|release_fd_lock
argument_list|(
name|ct
operator|->
name|ct_fd
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
operator|(
name|RPC_SUCCESS
operator|)
return|;
block|}
comment|/* 	 * Hack to provide rpc-based message passing 	 */
if|if
condition|(
name|timeout
operator|.
name|tv_sec
operator|==
literal|0
operator|&&
name|timeout
operator|.
name|tv_usec
operator|==
literal|0
condition|)
block|{
name|release_fd_lock
argument_list|(
name|ct
operator|->
name|ct_fd
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
operator|(
name|ct
operator|->
name|ct_error
operator|.
name|re_status
operator|=
name|RPC_TIMEDOUT
operator|)
return|;
block|}
comment|/* 	 * Keep receiving until we get a valid transaction id 	 */
name|xdrs
operator|->
name|x_op
operator|=
name|XDR_DECODE
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|reply_msg
operator|.
name|acpted_rply
operator|.
name|ar_verf
operator|=
name|_null_auth
expr_stmt|;
name|reply_msg
operator|.
name|acpted_rply
operator|.
name|ar_results
operator|.
name|where
operator|=
name|NULL
expr_stmt|;
name|reply_msg
operator|.
name|acpted_rply
operator|.
name|ar_results
operator|.
name|proc
operator|=
operator|(
name|xdrproc_t
operator|)
name|xdr_void
expr_stmt|;
if|if
condition|(
operator|!
name|xdrrec_skiprecord
argument_list|(
name|xdrs
argument_list|)
condition|)
block|{
name|release_fd_lock
argument_list|(
name|ct
operator|->
name|ct_fd
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
operator|(
name|ct
operator|->
name|ct_error
operator|.
name|re_status
operator|)
return|;
block|}
comment|/* now decode and validate the response header */
if|if
condition|(
operator|!
name|xdr_replymsg
argument_list|(
name|xdrs
argument_list|,
operator|&
name|reply_msg
argument_list|)
condition|)
block|{
if|if
condition|(
name|ct
operator|->
name|ct_error
operator|.
name|re_status
operator|==
name|RPC_SUCCESS
condition|)
continue|continue;
name|release_fd_lock
argument_list|(
name|ct
operator|->
name|ct_fd
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
operator|(
name|ct
operator|->
name|ct_error
operator|.
name|re_status
operator|)
return|;
block|}
if|if
condition|(
name|reply_msg
operator|.
name|rm_xid
operator|==
name|x_id
condition|)
break|break;
block|}
comment|/* 	 * process header 	 */
name|_seterr_reply
argument_list|(
operator|&
name|reply_msg
argument_list|,
operator|&
operator|(
name|ct
operator|->
name|ct_error
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|ct_error
operator|.
name|re_status
operator|==
name|RPC_SUCCESS
condition|)
block|{
if|if
condition|(
operator|!
name|AUTH_VALIDATE
argument_list|(
name|cl
operator|->
name|cl_auth
argument_list|,
operator|&
name|reply_msg
operator|.
name|acpted_rply
operator|.
name|ar_verf
argument_list|)
condition|)
block|{
name|ct
operator|->
name|ct_error
operator|.
name|re_status
operator|=
name|RPC_AUTHERROR
expr_stmt|;
name|ct
operator|->
name|ct_error
operator|.
name|re_why
operator|=
name|AUTH_INVALIDRESP
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cl
operator|->
name|cl_auth
operator|->
name|ah_cred
operator|.
name|oa_flavor
operator|!=
name|RPCSEC_GSS
condition|)
block|{
name|reply_stat
operator|=
call|(
modifier|*
name|xdr_results
call|)
argument_list|(
name|xdrs
argument_list|,
name|results_ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|reply_stat
operator|=
name|__rpc_gss_unwrap
argument_list|(
name|cl
operator|->
name|cl_auth
argument_list|,
name|xdrs
argument_list|,
name|xdr_results
argument_list|,
name|results_ptr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|reply_stat
condition|)
block|{
if|if
condition|(
name|ct
operator|->
name|ct_error
operator|.
name|re_status
operator|==
name|RPC_SUCCESS
condition|)
name|ct
operator|->
name|ct_error
operator|.
name|re_status
operator|=
name|RPC_CANTDECODERES
expr_stmt|;
block|}
block|}
comment|/* free verifier ... */
if|if
condition|(
name|reply_msg
operator|.
name|acpted_rply
operator|.
name|ar_verf
operator|.
name|oa_base
operator|!=
name|NULL
condition|)
block|{
name|xdrs
operator|->
name|x_op
operator|=
name|XDR_FREE
expr_stmt|;
operator|(
name|void
operator|)
name|xdr_opaque_auth
argument_list|(
name|xdrs
argument_list|,
operator|&
operator|(
name|reply_msg
operator|.
name|acpted_rply
operator|.
name|ar_verf
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* end successful completion */
else|else
block|{
comment|/* maybe our credentials need to be refreshed ... */
if|if
condition|(
name|refreshes
operator|--
operator|&&
name|AUTH_REFRESH
argument_list|(
name|cl
operator|->
name|cl_auth
argument_list|,
operator|&
name|reply_msg
argument_list|)
condition|)
goto|goto
name|call_again
goto|;
block|}
comment|/* end of unsuccessful completion */
name|release_fd_lock
argument_list|(
name|ct
operator|->
name|ct_fd
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
operator|(
name|ct
operator|->
name|ct_error
operator|.
name|re_status
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|clnt_vc_geterr
parameter_list|(
name|CLIENT
modifier|*
name|cl
parameter_list|,
name|struct
name|rpc_err
modifier|*
name|errp
parameter_list|)
block|{
name|struct
name|ct_data
modifier|*
name|ct
decl_stmt|;
name|assert
argument_list|(
name|cl
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|errp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ct
operator|=
operator|(
expr|struct
name|ct_data
operator|*
operator|)
name|cl
operator|->
name|cl_private
expr_stmt|;
operator|*
name|errp
operator|=
name|ct
operator|->
name|ct_error
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool_t
name|clnt_vc_freeres
parameter_list|(
name|CLIENT
modifier|*
name|cl
parameter_list|,
name|xdrproc_t
name|xdr_res
parameter_list|,
name|void
modifier|*
name|res_ptr
parameter_list|)
block|{
name|struct
name|ct_data
modifier|*
name|ct
decl_stmt|;
name|XDR
modifier|*
name|xdrs
decl_stmt|;
name|bool_t
name|dummy
decl_stmt|;
name|sigset_t
name|mask
decl_stmt|;
name|sigset_t
name|newmask
decl_stmt|;
name|assert
argument_list|(
name|cl
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ct
operator|=
operator|(
expr|struct
name|ct_data
operator|*
operator|)
name|cl
operator|->
name|cl_private
expr_stmt|;
name|xdrs
operator|=
operator|&
operator|(
name|ct
operator|->
name|ct_xdrs
operator|)
expr_stmt|;
name|sigfillset
argument_list|(
operator|&
name|newmask
argument_list|)
expr_stmt|;
name|thr_sigsetmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|newmask
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|clnt_fd_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|vc_fd_locks
index|[
name|ct
operator|->
name|ct_fd
index|]
condition|)
name|cond_wait
argument_list|(
operator|&
name|vc_cv
index|[
name|ct
operator|->
name|ct_fd
index|]
argument_list|,
operator|&
name|clnt_fd_lock
argument_list|)
expr_stmt|;
name|xdrs
operator|->
name|x_op
operator|=
name|XDR_FREE
expr_stmt|;
name|dummy
operator|=
call|(
modifier|*
name|xdr_res
call|)
argument_list|(
name|xdrs
argument_list|,
name|res_ptr
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|clnt_fd_lock
argument_list|)
expr_stmt|;
name|thr_sigsetmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
operator|(
name|mask
operator|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cond_signal
argument_list|(
operator|&
name|vc_cv
index|[
name|ct
operator|->
name|ct_fd
index|]
argument_list|)
expr_stmt|;
return|return
name|dummy
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|clnt_vc_abort
parameter_list|(
name|CLIENT
modifier|*
name|cl
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|__inline
name|void
name|htonlp
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|,
name|uint32_t
name|incr
parameter_list|)
block|{
comment|/* We are aligned, so we think */
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|dst
operator|=
name|htonl
argument_list|(
operator|*
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|src
operator|+
name|incr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|ntohlp
parameter_list|(
name|void
modifier|*
name|dst
parameter_list|,
specifier|const
name|void
modifier|*
name|src
parameter_list|)
block|{
comment|/* We are aligned, so we think */
operator|*
operator|(
name|uint32_t
operator|*
operator|)
name|dst
operator|=
name|htonl
argument_list|(
operator|*
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|src
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool_t
name|clnt_vc_control
parameter_list|(
name|CLIENT
modifier|*
name|cl
parameter_list|,
name|u_int
name|request
parameter_list|,
name|void
modifier|*
name|info
parameter_list|)
block|{
name|struct
name|ct_data
modifier|*
name|ct
decl_stmt|;
name|void
modifier|*
name|infop
init|=
name|info
decl_stmt|;
name|sigset_t
name|mask
decl_stmt|;
name|sigset_t
name|newmask
decl_stmt|;
name|int
name|rpc_lock_value
decl_stmt|;
name|assert
argument_list|(
name|cl
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ct
operator|=
operator|(
expr|struct
name|ct_data
operator|*
operator|)
name|cl
operator|->
name|cl_private
expr_stmt|;
name|sigfillset
argument_list|(
operator|&
name|newmask
argument_list|)
expr_stmt|;
name|thr_sigsetmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|newmask
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|clnt_fd_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|vc_fd_locks
index|[
name|ct
operator|->
name|ct_fd
index|]
condition|)
name|cond_wait
argument_list|(
operator|&
name|vc_cv
index|[
name|ct
operator|->
name|ct_fd
index|]
argument_list|,
operator|&
name|clnt_fd_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|__isthreaded
condition|)
name|rpc_lock_value
operator|=
literal|1
expr_stmt|;
else|else
name|rpc_lock_value
operator|=
literal|0
expr_stmt|;
name|vc_fd_locks
index|[
name|ct
operator|->
name|ct_fd
index|]
operator|=
name|rpc_lock_value
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|clnt_fd_lock
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|request
condition|)
block|{
case|case
name|CLSET_FD_CLOSE
case|:
name|ct
operator|->
name|ct_closeit
operator|=
name|TRUE
expr_stmt|;
name|release_fd_lock
argument_list|(
name|ct
operator|->
name|ct_fd
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
case|case
name|CLSET_FD_NCLOSE
case|:
name|ct
operator|->
name|ct_closeit
operator|=
name|FALSE
expr_stmt|;
name|release_fd_lock
argument_list|(
name|ct
operator|->
name|ct_fd
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
default|default:
break|break;
block|}
comment|/* for other requests which use info */
if|if
condition|(
name|info
operator|==
name|NULL
condition|)
block|{
name|release_fd_lock
argument_list|(
name|ct
operator|->
name|ct_fd
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
switch|switch
condition|(
name|request
condition|)
block|{
case|case
name|CLSET_TIMEOUT
case|:
if|if
condition|(
name|time_not_ok
argument_list|(
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|info
argument_list|)
condition|)
block|{
name|release_fd_lock
argument_list|(
name|ct
operator|->
name|ct_fd
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|ct
operator|->
name|ct_wait
operator|=
operator|*
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|infop
expr_stmt|;
name|ct
operator|->
name|ct_waitset
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|CLGET_TIMEOUT
case|:
operator|*
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|infop
operator|=
name|ct
operator|->
name|ct_wait
expr_stmt|;
break|break;
case|case
name|CLGET_SERVER_ADDR
case|:
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|info
argument_list|,
name|ct
operator|->
name|ct_addr
operator|.
name|buf
argument_list|,
operator|(
name|size_t
operator|)
name|ct
operator|->
name|ct_addr
operator|.
name|len
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLGET_FD
case|:
operator|*
operator|(
name|int
operator|*
operator|)
name|info
operator|=
name|ct
operator|->
name|ct_fd
expr_stmt|;
break|break;
case|case
name|CLGET_SVC_ADDR
case|:
comment|/* The caller should not free this memory area */
operator|*
operator|(
expr|struct
name|netbuf
operator|*
operator|)
name|info
operator|=
name|ct
operator|->
name|ct_addr
expr_stmt|;
break|break;
case|case
name|CLSET_SVC_ADDR
case|:
comment|/* set to new address */
name|release_fd_lock
argument_list|(
name|ct
operator|->
name|ct_fd
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
case|case
name|CLGET_XID
case|:
comment|/* 		 * use the knowledge that xid is the 		 * first element in the call structure 		 * This will get the xid of the PREVIOUS call 		 */
name|ntohlp
argument_list|(
name|info
argument_list|,
operator|&
name|ct
operator|->
name|ct_u
operator|.
name|ct_mcalli
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLSET_XID
case|:
comment|/* This will set the xid of the NEXT call */
comment|/* increment by 1 as clnt_vc_call() decrements once */
name|htonlp
argument_list|(
operator|&
name|ct
operator|->
name|ct_u
operator|.
name|ct_mcalli
argument_list|,
name|info
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLGET_VERS
case|:
comment|/* 		 * This RELIES on the information that, in the call body, 		 * the version number field is the fifth field from the 		 * begining of the RPC header. MUST be changed if the 		 * call_struct is changed 		 */
name|ntohlp
argument_list|(
name|info
argument_list|,
name|ct
operator|->
name|ct_u
operator|.
name|ct_mcallc
operator|+
literal|4
operator|*
name|BYTES_PER_XDR_UNIT
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLSET_VERS
case|:
name|htonlp
argument_list|(
name|ct
operator|->
name|ct_u
operator|.
name|ct_mcallc
operator|+
literal|4
operator|*
name|BYTES_PER_XDR_UNIT
argument_list|,
name|info
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLGET_PROG
case|:
comment|/* 		 * This RELIES on the information that, in the call body, 		 * the program number field is the fourth field from the 		 * begining of the RPC header. MUST be changed if the 		 * call_struct is changed 		 */
name|ntohlp
argument_list|(
name|info
argument_list|,
name|ct
operator|->
name|ct_u
operator|.
name|ct_mcallc
operator|+
literal|3
operator|*
name|BYTES_PER_XDR_UNIT
argument_list|)
expr_stmt|;
break|break;
case|case
name|CLSET_PROG
case|:
name|htonlp
argument_list|(
name|ct
operator|->
name|ct_u
operator|.
name|ct_mcallc
operator|+
literal|3
operator|*
name|BYTES_PER_XDR_UNIT
argument_list|,
name|info
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
default|default:
name|release_fd_lock
argument_list|(
name|ct
operator|->
name|ct_fd
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|release_fd_lock
argument_list|(
name|ct
operator|->
name|ct_fd
argument_list|,
name|mask
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|clnt_vc_destroy
parameter_list|(
name|CLIENT
modifier|*
name|cl
parameter_list|)
block|{
name|struct
name|ct_data
modifier|*
name|ct
init|=
operator|(
expr|struct
name|ct_data
operator|*
operator|)
name|cl
operator|->
name|cl_private
decl_stmt|;
name|int
name|ct_fd
init|=
name|ct
operator|->
name|ct_fd
decl_stmt|;
name|sigset_t
name|mask
decl_stmt|;
name|sigset_t
name|newmask
decl_stmt|;
name|assert
argument_list|(
name|cl
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ct
operator|=
operator|(
expr|struct
name|ct_data
operator|*
operator|)
name|cl
operator|->
name|cl_private
expr_stmt|;
name|sigfillset
argument_list|(
operator|&
name|newmask
argument_list|)
expr_stmt|;
name|thr_sigsetmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|newmask
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|clnt_fd_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|vc_fd_locks
index|[
name|ct_fd
index|]
condition|)
name|cond_wait
argument_list|(
operator|&
name|vc_cv
index|[
name|ct_fd
index|]
argument_list|,
operator|&
name|clnt_fd_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ct
operator|->
name|ct_closeit
operator|&&
name|ct
operator|->
name|ct_fd
operator|!=
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|_close
argument_list|(
name|ct
operator|->
name|ct_fd
argument_list|)
expr_stmt|;
block|}
name|XDR_DESTROY
argument_list|(
operator|&
operator|(
name|ct
operator|->
name|ct_xdrs
operator|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ct
operator|->
name|ct_addr
operator|.
name|buf
argument_list|)
expr_stmt|;
name|mem_free
argument_list|(
name|ct
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|ct_data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|cl_netid
operator|&&
name|cl
operator|->
name|cl_netid
index|[
literal|0
index|]
condition|)
name|mem_free
argument_list|(
name|cl
operator|->
name|cl_netid
argument_list|,
name|strlen
argument_list|(
name|cl
operator|->
name|cl_netid
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cl
operator|->
name|cl_tp
operator|&&
name|cl
operator|->
name|cl_tp
index|[
literal|0
index|]
condition|)
name|mem_free
argument_list|(
name|cl
operator|->
name|cl_tp
argument_list|,
name|strlen
argument_list|(
name|cl
operator|->
name|cl_tp
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|mem_free
argument_list|(
name|cl
argument_list|,
sizeof|sizeof
argument_list|(
name|CLIENT
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_unlock
argument_list|(
operator|&
name|clnt_fd_lock
argument_list|)
expr_stmt|;
name|thr_sigsetmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
operator|(
name|mask
operator|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cond_signal
argument_list|(
operator|&
name|vc_cv
index|[
name|ct_fd
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Interface between xdr serializer and tcp connection.  * Behaves like the system calls, read& write, but keeps some error state  * around for the rpc level.  */
end_comment

begin_function
specifier|static
name|int
name|read_vc
parameter_list|(
name|void
modifier|*
name|ctp
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|sockaddr
name|sa
decl_stmt|;
name|socklen_t
name|sal
decl_stmt|;
name|struct
name|ct_data
modifier|*
name|ct
init|=
operator|(
expr|struct
name|ct_data
operator|*
operator|)
name|ctp
decl_stmt|;
name|struct
name|pollfd
name|fd
decl_stmt|;
name|int
name|milliseconds
init|=
call|(
name|int
call|)
argument_list|(
operator|(
name|ct
operator|->
name|ct_wait
operator|.
name|tv_sec
operator|*
literal|1000
operator|)
operator|+
operator|(
name|ct
operator|->
name|ct_wait
operator|.
name|tv_usec
operator|/
literal|1000
operator|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|fd
operator|.
name|fd
operator|=
name|ct
operator|->
name|ct_fd
expr_stmt|;
name|fd
operator|.
name|events
operator|=
name|POLLIN
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|_poll
argument_list|(
operator|&
name|fd
argument_list|,
literal|1
argument_list|,
name|milliseconds
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|ct
operator|->
name|ct_error
operator|.
name|re_status
operator|=
name|RPC_TIMEDOUT
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
operator|-
literal|1
case|:
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
continue|continue;
name|ct
operator|->
name|ct_error
operator|.
name|re_status
operator|=
name|RPC_CANTRECV
expr_stmt|;
name|ct
operator|->
name|ct_error
operator|.
name|re_errno
operator|=
name|errno
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
break|break;
block|}
name|sal
operator|=
sizeof|sizeof
argument_list|(
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|_getpeername
argument_list|(
name|ct
operator|->
name|ct_fd
argument_list|,
operator|&
name|sa
argument_list|,
operator|&
name|sal
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sa
operator|.
name|sa_family
operator|==
name|AF_LOCAL
operator|)
condition|)
block|{
name|len
operator|=
name|__msgread
argument_list|(
name|ct
operator|->
name|ct_fd
argument_list|,
name|buf
argument_list|,
operator|(
name|size_t
operator|)
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|_read
argument_list|(
name|ct
operator|->
name|ct_fd
argument_list|,
name|buf
argument_list|,
operator|(
name|size_t
operator|)
name|len
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|0
case|:
comment|/* premature eof */
name|ct
operator|->
name|ct_error
operator|.
name|re_errno
operator|=
name|ECONNRESET
expr_stmt|;
name|ct
operator|->
name|ct_error
operator|.
name|re_status
operator|=
name|RPC_CANTRECV
expr_stmt|;
name|len
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* it's really an error */
break|break;
case|case
operator|-
literal|1
case|:
name|ct
operator|->
name|ct_error
operator|.
name|re_errno
operator|=
name|errno
expr_stmt|;
name|ct
operator|->
name|ct_error
operator|.
name|re_status
operator|=
name|RPC_CANTRECV
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|write_vc
parameter_list|(
name|void
modifier|*
name|ctp
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|struct
name|sockaddr
name|sa
decl_stmt|;
name|socklen_t
name|sal
decl_stmt|;
name|struct
name|ct_data
modifier|*
name|ct
init|=
operator|(
expr|struct
name|ct_data
operator|*
operator|)
name|ctp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|cnt
decl_stmt|;
name|sal
operator|=
sizeof|sizeof
argument_list|(
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|_getpeername
argument_list|(
name|ct
operator|->
name|ct_fd
argument_list|,
operator|&
name|sa
argument_list|,
operator|&
name|sal
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sa
operator|.
name|sa_family
operator|==
name|AF_LOCAL
operator|)
condition|)
block|{
for|for
control|(
name|cnt
operator|=
name|len
init|;
name|cnt
operator|>
literal|0
condition|;
name|cnt
operator|-=
name|i
operator|,
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
name|i
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|__msgwrite
argument_list|(
name|ct
operator|->
name|ct_fd
argument_list|,
name|buf
argument_list|,
operator|(
name|size_t
operator|)
name|cnt
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ct
operator|->
name|ct_error
operator|.
name|re_errno
operator|=
name|errno
expr_stmt|;
name|ct
operator|->
name|ct_error
operator|.
name|re_status
operator|=
name|RPC_CANTSEND
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|cnt
operator|=
name|len
init|;
name|cnt
operator|>
literal|0
condition|;
name|cnt
operator|-=
name|i
operator|,
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|buf
operator|+
name|i
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|_write
argument_list|(
name|ct
operator|->
name|ct_fd
argument_list|,
name|buf
argument_list|,
operator|(
name|size_t
operator|)
name|cnt
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ct
operator|->
name|ct_error
operator|.
name|re_errno
operator|=
name|errno
expr_stmt|;
name|ct
operator|->
name|ct_error
operator|.
name|re_status
operator|=
name|RPC_CANTSEND
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|len
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|clnt_ops
modifier|*
name|clnt_vc_ops
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|struct
name|clnt_ops
name|ops
decl_stmt|;
name|sigset_t
name|mask
decl_stmt|,
name|newmask
decl_stmt|;
comment|/* VARIABLES PROTECTED BY ops_lock: ops */
name|sigfillset
argument_list|(
operator|&
name|newmask
argument_list|)
expr_stmt|;
name|thr_sigsetmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|newmask
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
name|mutex_lock
argument_list|(
operator|&
name|ops_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ops
operator|.
name|cl_call
operator|==
name|NULL
condition|)
block|{
name|ops
operator|.
name|cl_call
operator|=
name|clnt_vc_call
expr_stmt|;
name|ops
operator|.
name|cl_abort
operator|=
name|clnt_vc_abort
expr_stmt|;
name|ops
operator|.
name|cl_geterr
operator|=
name|clnt_vc_geterr
expr_stmt|;
name|ops
operator|.
name|cl_freeres
operator|=
name|clnt_vc_freeres
expr_stmt|;
name|ops
operator|.
name|cl_destroy
operator|=
name|clnt_vc_destroy
expr_stmt|;
name|ops
operator|.
name|cl_control
operator|=
name|clnt_vc_control
expr_stmt|;
block|}
name|mutex_unlock
argument_list|(
operator|&
name|ops_lock
argument_list|)
expr_stmt|;
name|thr_sigsetmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
operator|(
name|mask
operator|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|ops
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Make sure that the time is not garbage.   -1 value is disallowed.  * Note this is different from time_not_ok in clnt_dg.c  */
end_comment

begin_function
specifier|static
name|bool_t
name|time_not_ok
parameter_list|(
name|struct
name|timeval
modifier|*
name|t
parameter_list|)
block|{
return|return
operator|(
name|t
operator|->
name|tv_sec
operator|<=
operator|-
literal|1
operator|||
name|t
operator|->
name|tv_sec
operator|>
literal|100000000
operator|||
name|t
operator|->
name|tv_usec
operator|<=
operator|-
literal|1
operator|||
name|t
operator|->
name|tv_usec
operator|>
literal|1000000
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__msgread
parameter_list|(
name|int
name|sock
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|cnt
parameter_list|)
block|{
name|struct
name|iovec
name|iov
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|msghdr
name|msg
decl_stmt|;
union|union
block|{
name|struct
name|cmsghdr
name|cmsg
decl_stmt|;
name|char
name|control
index|[
name|CMSG_SPACE
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cmsgcred
argument_list|)
argument_list|)
index|]
decl_stmt|;
block|}
name|cm
union|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|cm
argument_list|,
sizeof|sizeof
argument_list|(
name|cm
argument_list|)
argument_list|)
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
name|buf
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
name|cnt
expr_stmt|;
name|msg
operator|.
name|msg_iov
operator|=
name|iov
expr_stmt|;
name|msg
operator|.
name|msg_iovlen
operator|=
literal|1
expr_stmt|;
name|msg
operator|.
name|msg_name
operator|=
name|NULL
expr_stmt|;
name|msg
operator|.
name|msg_namelen
operator|=
literal|0
expr_stmt|;
name|msg
operator|.
name|msg_control
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|cm
expr_stmt|;
name|msg
operator|.
name|msg_controllen
operator|=
name|CMSG_SPACE
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cmsgcred
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|.
name|msg_flags
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|_recvmsg
argument_list|(
name|sock
argument_list|,
operator|&
name|msg
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|__msgwrite
parameter_list|(
name|int
name|sock
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|cnt
parameter_list|)
block|{
name|struct
name|iovec
name|iov
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|msghdr
name|msg
decl_stmt|;
union|union
block|{
name|struct
name|cmsghdr
name|cmsg
decl_stmt|;
name|char
name|control
index|[
name|CMSG_SPACE
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cmsgcred
argument_list|)
argument_list|)
index|]
decl_stmt|;
block|}
name|cm
union|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|cm
argument_list|,
sizeof|sizeof
argument_list|(
name|cm
argument_list|)
argument_list|)
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
name|buf
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
name|cnt
expr_stmt|;
name|cm
operator|.
name|cmsg
operator|.
name|cmsg_type
operator|=
name|SCM_CREDS
expr_stmt|;
name|cm
operator|.
name|cmsg
operator|.
name|cmsg_level
operator|=
name|SOL_SOCKET
expr_stmt|;
name|cm
operator|.
name|cmsg
operator|.
name|cmsg_len
operator|=
name|CMSG_LEN
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cmsgcred
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|.
name|msg_iov
operator|=
name|iov
expr_stmt|;
name|msg
operator|.
name|msg_iovlen
operator|=
literal|1
expr_stmt|;
name|msg
operator|.
name|msg_name
operator|=
name|NULL
expr_stmt|;
name|msg
operator|.
name|msg_namelen
operator|=
literal|0
expr_stmt|;
name|msg
operator|.
name|msg_control
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|cm
expr_stmt|;
name|msg
operator|.
name|msg_controllen
operator|=
name|CMSG_SPACE
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|cmsgcred
argument_list|)
argument_list|)
expr_stmt|;
name|msg
operator|.
name|msg_flags
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|_sendmsg
argument_list|(
name|sock
argument_list|,
operator|&
name|msg
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

