begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: clnt_bcast.c,v 1.3 2000/07/06 03:05:20 christos Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 2009, Sun Microsystems, Inc.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without   * modification, are permitted provided that the following conditions are met:  * - Redistributions of source code must retain the above copyright notice,   *   this list of conditions and the following disclaimer.  * - Redistributions in binary form must reproduce the above copyright notice,   *   this list of conditions and the following disclaimer in the documentation   *   and/or other materials provided with the distribution.  * - Neither the name of Sun Microsystems, Inc. nor the names of its   *   contributors may be used to endorse or promote products derived   *   from this software without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"   * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE   * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE   * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR   * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF   * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS   * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN   * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)   * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE   * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1986-1991 by Sun Microsystems Inc.   */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_empty
empty|#ident	"@(#)clnt_bcast.c	1.18	94/05/03 SMI"
end_empty

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)clnt_bcast.c 1.15 89/04/21 Copyr 1988 Sun Micro"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * clnt_bcast.c  * Client interface to broadcast service.  *  * Copyright (C) 1988, Sun Microsystems, Inc.  *  * The following is kludged-up support for simple rpc broadcasts.  * Someday a large, complicated system will replace these routines.  */
end_comment

begin_include
include|#
directive|include
file|"namespace.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<ifaddrs.h>
end_include

begin_include
include|#
directive|include
file|<sys/poll.h>
end_include

begin_include
include|#
directive|include
file|<rpc/rpc.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PORTMAP
end_ifdef

begin_include
include|#
directive|include
file|<rpc/pmap_prot.h>
end_include

begin_include
include|#
directive|include
file|<rpc/pmap_clnt.h>
end_include

begin_include
include|#
directive|include
file|<rpc/pmap_rmt.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PORTMAP */
end_comment

begin_include
include|#
directive|include
file|<rpc/nettype.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|RPC_DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"un-namespace.h"
end_include

begin_include
include|#
directive|include
file|"rpc_com.h"
end_include

begin_define
define|#
directive|define
name|MAXBCAST
value|20
end_define

begin_comment
comment|/* Max no of broadcasting transports */
end_comment

begin_define
define|#
directive|define
name|INITTIME
value|4000
end_define

begin_comment
comment|/* Time to wait initially */
end_comment

begin_define
define|#
directive|define
name|WAITTIME
value|8000
end_define

begin_comment
comment|/* Maximum time to wait */
end_comment

begin_comment
comment|/*  * If nettype is NULL, it broadcasts on all the available  * datagram_n transports. May potentially lead to broadacst storms  * and hence should be used with caution, care and courage.  *  * The current parameter xdr packet size is limited by the max tsdu  * size of the transport. If the max tsdu size of any transport is  * smaller than the parameter xdr packet, then broadcast is not  * sent on that transport.  *  * Also, the packet size should be less the packet size of  * the data link layer (for ethernet it is 1400 bytes).  There is  * no easy way to find out the max size of the data link layer and  * we are assuming that the args would be smaller than that.  *  * The result size has to be smaller than the transport tsdu size.  *  * If PORTMAP has been defined, we send two packets for UDP, one for  * rpcbind and one for portmap. For those machines which support  * both rpcbind and portmap, it will cause them to reply twice, and  * also here it will get two responses ... inefficient and clumsy.  */
end_comment

begin_struct
struct|struct
name|broadif
block|{
name|int
name|index
decl_stmt|;
name|struct
name|sockaddr_storage
name|broadaddr
decl_stmt|;
name|TAILQ_ENTRY
argument_list|(
argument|broadif
argument_list|)
name|link
expr_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|broadif
argument_list|)
name|broadlist_t
expr_stmt|;
end_typedef

begin_function_decl
name|int
name|__rpc_getbroadifs
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|broadlist_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__rpc_freebroadifs
parameter_list|(
name|broadlist_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|__rpc_broadenable
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|struct
name|broadif
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|__rpc_lowvers
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|__rpc_getbroadifs
parameter_list|(
name|int
name|af
parameter_list|,
name|int
name|proto
parameter_list|,
name|int
name|socktype
parameter_list|,
name|broadlist_t
modifier|*
name|list
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|struct
name|broadif
modifier|*
name|bip
decl_stmt|;
name|struct
name|ifaddrs
modifier|*
name|ifap
decl_stmt|,
modifier|*
name|ifp
decl_stmt|;
ifdef|#
directive|ifdef
name|INET6
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
endif|#
directive|endif
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|struct
name|addrinfo
name|hints
decl_stmt|,
modifier|*
name|res
decl_stmt|;
if|if
condition|(
name|getifaddrs
argument_list|(
operator|&
name|ifp
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|memset
argument_list|(
operator|&
name|hints
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|hints
argument_list|)
expr_stmt|;
name|hints
operator|.
name|ai_family
operator|=
name|af
expr_stmt|;
name|hints
operator|.
name|ai_protocol
operator|=
name|proto
expr_stmt|;
name|hints
operator|.
name|ai_socktype
operator|=
name|socktype
expr_stmt|;
if|if
condition|(
name|getaddrinfo
argument_list|(
name|NULL
argument_list|,
literal|"sunrpc"
argument_list|,
operator|&
name|hints
argument_list|,
operator|&
name|res
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|freeifaddrs
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
for|for
control|(
name|ifap
operator|=
name|ifp
init|;
name|ifap
operator|!=
name|NULL
condition|;
name|ifap
operator|=
name|ifap
operator|->
name|ifa_next
control|)
block|{
if|if
condition|(
name|ifap
operator|->
name|ifa_addr
operator|->
name|sa_family
operator|!=
name|af
operator|||
operator|!
operator|(
name|ifap
operator|->
name|ifa_flags
operator|&
name|IFF_UP
operator|)
condition|)
continue|continue;
name|bip
operator|=
operator|(
expr|struct
name|broadif
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|bip
argument_list|)
expr_stmt|;
if|if
condition|(
name|bip
operator|==
name|NULL
condition|)
break|break;
name|bip
operator|->
name|index
operator|=
name|if_nametoindex
argument_list|(
name|ifap
operator|->
name|ifa_name
argument_list|)
expr_stmt|;
if|if
condition|(
ifdef|#
directive|ifdef
name|INET6
name|af
operator|!=
name|AF_INET6
operator|&&
endif|#
directive|endif
operator|(
name|ifap
operator|->
name|ifa_flags
operator|&
name|IFF_BROADCAST
operator|)
operator|&&
name|ifap
operator|->
name|ifa_broadaddr
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|bip
operator|->
name|broadaddr
argument_list|,
name|ifap
operator|->
name|ifa_broadaddr
argument_list|,
operator|(
name|size_t
operator|)
name|ifap
operator|->
name|ifa_broadaddr
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|&
name|bip
operator|->
name|broadaddr
expr_stmt|;
name|sin
operator|->
name|sin_port
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|res
operator|->
name|ai_addr
operator|)
operator|->
name|sin_port
expr_stmt|;
block|}
elseif|else
ifdef|#
directive|ifdef
name|INET6
if|if
condition|(
name|af
operator|==
name|AF_INET6
operator|&&
operator|(
name|ifap
operator|->
name|ifa_flags
operator|&
name|IFF_MULTICAST
operator|)
condition|)
block|{
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|&
name|bip
operator|->
name|broadaddr
expr_stmt|;
name|inet_pton
argument_list|(
name|af
argument_list|,
name|RPCB_MULTICAST_ADDR
argument_list|,
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|)
expr_stmt|;
name|sin6
operator|->
name|sin6_family
operator|=
name|af
expr_stmt|;
name|sin6
operator|->
name|sin6_len
operator|=
sizeof|sizeof
expr|*
name|sin6
expr_stmt|;
name|sin6
operator|->
name|sin6_port
operator|=
operator|(
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|res
operator|->
name|ai_addr
operator|)
operator|->
name|sin6_port
expr_stmt|;
name|sin6
operator|->
name|sin6_scope_id
operator|=
name|bip
operator|->
name|index
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|free
argument_list|(
name|bip
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|TAILQ_INSERT_TAIL
argument_list|(
name|list
argument_list|,
name|bip
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|freeifaddrs
argument_list|(
name|ifp
argument_list|)
expr_stmt|;
name|freeaddrinfo
argument_list|(
name|res
argument_list|)
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_function
name|void
name|__rpc_freebroadifs
parameter_list|(
name|broadlist_t
modifier|*
name|list
parameter_list|)
block|{
name|struct
name|broadif
modifier|*
name|bip
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|bip
operator|=
name|TAILQ_FIRST
argument_list|(
name|list
argument_list|)
expr_stmt|;
while|while
condition|(
name|bip
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|TAILQ_NEXT
argument_list|(
name|bip
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bip
argument_list|)
expr_stmt|;
name|bip
operator|=
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
comment|/*ARGSUSED*/
name|__rpc_broadenable
parameter_list|(
name|int
name|af
parameter_list|,
name|int
name|s
parameter_list|,
name|struct
name|broadif
modifier|*
name|bip
parameter_list|)
block|{
name|int
name|o
init|=
literal|1
decl_stmt|;
if|#
directive|if
literal|0
block|if (af == AF_INET6) { 		fprintf(stderr, "set v6 multicast if to %d\n", bip->index); 		if (_setsockopt(s, IPPROTO_IPV6, IPV6_MULTICAST_IF,&bip->index, 		    sizeof bip->index)< 0) 			return -1; 	} else
endif|#
directive|endif
if|if
condition|(
name|_setsockopt
argument_list|(
name|s
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_BROADCAST
argument_list|,
operator|&
name|o
argument_list|,
sizeof|sizeof
name|o
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|enum
name|clnt_stat
name|rpc_broadcast_exp
parameter_list|(
name|prog
parameter_list|,
name|vers
parameter_list|,
name|proc
parameter_list|,
name|xargs
parameter_list|,
name|argsp
parameter_list|,
name|xresults
parameter_list|,
name|resultsp
parameter_list|,
name|eachresult
parameter_list|,
name|inittime
parameter_list|,
name|waittime
parameter_list|,
name|nettype
parameter_list|)
name|rpcprog_t
name|prog
decl_stmt|;
comment|/* program number */
name|rpcvers_t
name|vers
decl_stmt|;
comment|/* version number */
name|rpcproc_t
name|proc
decl_stmt|;
comment|/* procedure number */
name|xdrproc_t
name|xargs
decl_stmt|;
comment|/* xdr routine for args */
name|caddr_t
name|argsp
decl_stmt|;
comment|/* pointer to args */
name|xdrproc_t
name|xresults
decl_stmt|;
comment|/* xdr routine for results */
name|caddr_t
name|resultsp
decl_stmt|;
comment|/* pointer to results */
name|resultproc_t
name|eachresult
decl_stmt|;
comment|/* call with each result obtained */
name|int
name|inittime
decl_stmt|;
comment|/* how long to wait initially */
name|int
name|waittime
decl_stmt|;
comment|/* maximum time to wait */
specifier|const
name|char
modifier|*
name|nettype
decl_stmt|;
comment|/* transport type */
block|{
name|enum
name|clnt_stat
name|stat
init|=
name|RPC_SUCCESS
decl_stmt|;
comment|/* Return status */
name|XDR
name|xdr_stream
decl_stmt|;
comment|/* XDR stream */
name|XDR
modifier|*
name|xdrs
init|=
operator|&
name|xdr_stream
decl_stmt|;
name|struct
name|rpc_msg
name|msg
decl_stmt|;
comment|/* RPC message */
name|struct
name|timeval
name|t
decl_stmt|;
name|char
modifier|*
name|outbuf
init|=
name|NULL
decl_stmt|;
comment|/* Broadcast msg buffer */
name|char
modifier|*
name|inbuf
init|=
name|NULL
decl_stmt|;
comment|/* Reply buf */
name|int
name|inlen
decl_stmt|;
name|u_int
name|maxbufsize
init|=
literal|0
decl_stmt|;
name|AUTH
modifier|*
name|sys_auth
init|=
name|authunix_create_default
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
name|void
modifier|*
name|handle
decl_stmt|;
name|char
name|uaddress
index|[
literal|1024
index|]
decl_stmt|;
comment|/* A self imposed limit */
name|char
modifier|*
name|uaddrp
init|=
name|uaddress
decl_stmt|;
name|int
name|pmap_reply_flag
decl_stmt|;
comment|/* reply recvd from PORTMAP */
comment|/* An array of all the suitable broadcast transports */
struct|struct
block|{
name|int
name|fd
decl_stmt|;
comment|/* File descriptor */
name|int
name|af
decl_stmt|;
name|int
name|proto
decl_stmt|;
name|struct
name|netconfig
modifier|*
name|nconf
decl_stmt|;
comment|/* Netconfig structure */
name|u_int
name|asize
decl_stmt|;
comment|/* Size of the addr buf */
name|u_int
name|dsize
decl_stmt|;
comment|/* Size of the data buf */
name|struct
name|sockaddr_storage
name|raddr
decl_stmt|;
comment|/* Remote address */
name|broadlist_t
name|nal
decl_stmt|;
block|}
name|fdlist
index|[
name|MAXBCAST
index|]
struct|;
name|struct
name|pollfd
name|pfd
index|[
name|MAXBCAST
index|]
decl_stmt|;
name|size_t
name|fdlistno
init|=
literal|0
decl_stmt|;
name|struct
name|r_rpcb_rmtcallargs
name|barg
decl_stmt|;
comment|/* Remote arguments */
name|struct
name|r_rpcb_rmtcallres
name|bres
decl_stmt|;
comment|/* Remote results */
name|size_t
name|outlen
decl_stmt|;
name|struct
name|netconfig
modifier|*
name|nconf
decl_stmt|;
name|int
name|msec
decl_stmt|;
name|int
name|pollretval
decl_stmt|;
name|int
name|fds_found
decl_stmt|;
ifdef|#
directive|ifdef
name|PORTMAP
name|size_t
name|outlen_pmap
init|=
literal|0
decl_stmt|;
name|u_long
name|port
decl_stmt|;
comment|/* Remote port number */
name|int
name|pmap_flag
init|=
literal|0
decl_stmt|;
comment|/* UDP exists ? */
name|char
modifier|*
name|outbuf_pmap
init|=
name|NULL
decl_stmt|;
name|struct
name|rmtcallargs
name|barg_pmap
decl_stmt|;
comment|/* Remote arguments */
name|struct
name|rmtcallres
name|bres_pmap
decl_stmt|;
comment|/* Remote results */
name|u_int
name|udpbufsz
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* PORTMAP */
if|if
condition|(
name|sys_auth
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|RPC_SYSTEMERROR
operator|)
return|;
block|}
comment|/* 	 * initialization: create a fd, a broadcast address, and send the 	 * request on the broadcast transport. 	 * Listen on all of them and on replies, call the user supplied 	 * function. 	 */
if|if
condition|(
name|nettype
operator|==
name|NULL
condition|)
name|nettype
operator|=
literal|"datagram_n"
expr_stmt|;
if|if
condition|(
operator|(
name|handle
operator|=
name|__rpc_setconf
argument_list|(
name|nettype
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|AUTH_DESTROY
argument_list|(
name|sys_auth
argument_list|)
expr_stmt|;
return|return
operator|(
name|RPC_UNKNOWNPROTO
operator|)
return|;
block|}
while|while
condition|(
operator|(
name|nconf
operator|=
name|__rpc_getconf
argument_list|(
name|handle
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|int
name|fd
decl_stmt|;
name|struct
name|__rpc_sockinfo
name|si
decl_stmt|;
if|if
condition|(
name|nconf
operator|->
name|nc_semantics
operator|!=
name|NC_TPI_CLTS
condition|)
continue|continue;
if|if
condition|(
name|fdlistno
operator|>=
name|MAXBCAST
condition|)
break|break;
comment|/* No more slots available */
if|if
condition|(
operator|!
name|__rpc_nconf2sockinfo
argument_list|(
name|nconf
argument_list|,
operator|&
name|si
argument_list|)
condition|)
continue|continue;
name|TAILQ_INIT
argument_list|(
operator|&
name|fdlist
index|[
name|fdlistno
index|]
operator|.
name|nal
argument_list|)
expr_stmt|;
if|if
condition|(
name|__rpc_getbroadifs
argument_list|(
name|si
operator|.
name|si_af
argument_list|,
name|si
operator|.
name|si_proto
argument_list|,
name|si
operator|.
name|si_socktype
argument_list|,
operator|&
name|fdlist
index|[
name|fdlistno
index|]
operator|.
name|nal
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|fd
operator|=
name|_socket
argument_list|(
name|si
operator|.
name|si_af
argument_list|,
name|si
operator|.
name|si_socktype
argument_list|,
name|si
operator|.
name|si_proto
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|stat
operator|=
name|RPC_CANTSEND
expr_stmt|;
continue|continue;
block|}
name|fdlist
index|[
name|fdlistno
index|]
operator|.
name|af
operator|=
name|si
operator|.
name|si_af
expr_stmt|;
name|fdlist
index|[
name|fdlistno
index|]
operator|.
name|proto
operator|=
name|si
operator|.
name|si_proto
expr_stmt|;
name|fdlist
index|[
name|fdlistno
index|]
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
name|fdlist
index|[
name|fdlistno
index|]
operator|.
name|nconf
operator|=
name|nconf
expr_stmt|;
name|fdlist
index|[
name|fdlistno
index|]
operator|.
name|asize
operator|=
name|__rpc_get_a_size
argument_list|(
name|si
operator|.
name|si_af
argument_list|)
expr_stmt|;
name|pfd
index|[
name|fdlistno
index|]
operator|.
name|events
operator|=
name|POLLIN
operator||
name|POLLPRI
operator||
name|POLLRDNORM
operator||
name|POLLRDBAND
expr_stmt|;
name|pfd
index|[
name|fdlistno
index|]
operator|.
name|fd
operator|=
name|fdlist
index|[
name|fdlistno
index|]
operator|.
name|fd
operator|=
name|fd
expr_stmt|;
name|fdlist
index|[
name|fdlistno
index|]
operator|.
name|dsize
operator|=
name|__rpc_get_t_size
argument_list|(
name|si
operator|.
name|si_af
argument_list|,
name|si
operator|.
name|si_proto
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxbufsize
operator|<=
name|fdlist
index|[
name|fdlistno
index|]
operator|.
name|dsize
condition|)
name|maxbufsize
operator|=
name|fdlist
index|[
name|fdlistno
index|]
operator|.
name|dsize
expr_stmt|;
ifdef|#
directive|ifdef
name|PORTMAP
if|if
condition|(
name|si
operator|.
name|si_af
operator|==
name|AF_INET
operator|&&
name|si
operator|.
name|si_proto
operator|==
name|IPPROTO_UDP
condition|)
block|{
name|udpbufsz
operator|=
name|fdlist
index|[
name|fdlistno
index|]
operator|.
name|dsize
expr_stmt|;
if|if
condition|(
operator|(
name|outbuf_pmap
operator|=
name|malloc
argument_list|(
name|udpbufsz
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|stat
operator|=
name|RPC_SYSTEMERROR
expr_stmt|;
goto|goto
name|done_broad
goto|;
block|}
name|pmap_flag
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* PORTMAP */
name|fdlistno
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|fdlistno
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|stat
operator|==
name|RPC_SUCCESS
condition|)
name|stat
operator|=
name|RPC_UNKNOWNPROTO
expr_stmt|;
goto|goto
name|done_broad
goto|;
block|}
if|if
condition|(
name|maxbufsize
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|stat
operator|==
name|RPC_SUCCESS
condition|)
name|stat
operator|=
name|RPC_CANTSEND
expr_stmt|;
goto|goto
name|done_broad
goto|;
block|}
name|inbuf
operator|=
name|malloc
argument_list|(
name|maxbufsize
argument_list|)
expr_stmt|;
name|outbuf
operator|=
name|malloc
argument_list|(
name|maxbufsize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|inbuf
operator|==
name|NULL
operator|)
operator|||
operator|(
name|outbuf
operator|==
name|NULL
operator|)
condition|)
block|{
name|stat
operator|=
name|RPC_SYSTEMERROR
expr_stmt|;
goto|goto
name|done_broad
goto|;
block|}
comment|/* Serialize all the arguments which have to be sent */
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|msg
operator|.
name|rm_xid
operator|=
name|__RPC_GETXID
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|msg
operator|.
name|rm_direction
operator|=
name|CALL
expr_stmt|;
name|msg
operator|.
name|rm_call
operator|.
name|cb_rpcvers
operator|=
name|RPC_MSG_VERSION
expr_stmt|;
name|msg
operator|.
name|rm_call
operator|.
name|cb_prog
operator|=
name|RPCBPROG
expr_stmt|;
name|msg
operator|.
name|rm_call
operator|.
name|cb_vers
operator|=
name|RPCBVERS
expr_stmt|;
name|msg
operator|.
name|rm_call
operator|.
name|cb_proc
operator|=
name|RPCBPROC_CALLIT
expr_stmt|;
name|barg
operator|.
name|prog
operator|=
name|prog
expr_stmt|;
name|barg
operator|.
name|vers
operator|=
name|vers
expr_stmt|;
name|barg
operator|.
name|proc
operator|=
name|proc
expr_stmt|;
name|barg
operator|.
name|args
operator|.
name|args_val
operator|=
name|argsp
expr_stmt|;
name|barg
operator|.
name|xdr_args
operator|=
name|xargs
expr_stmt|;
name|bres
operator|.
name|addr
operator|=
name|uaddrp
expr_stmt|;
name|bres
operator|.
name|results
operator|.
name|results_val
operator|=
name|resultsp
expr_stmt|;
name|bres
operator|.
name|xdr_res
operator|=
name|xresults
expr_stmt|;
name|msg
operator|.
name|rm_call
operator|.
name|cb_cred
operator|=
name|sys_auth
operator|->
name|ah_cred
expr_stmt|;
name|msg
operator|.
name|rm_call
operator|.
name|cb_verf
operator|=
name|sys_auth
operator|->
name|ah_verf
expr_stmt|;
name|xdrmem_create
argument_list|(
name|xdrs
argument_list|,
name|outbuf
argument_list|,
name|maxbufsize
argument_list|,
name|XDR_ENCODE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|xdr_callmsg
argument_list|(
name|xdrs
argument_list|,
operator|&
name|msg
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|xdr_rpcb_rmtcallargs
argument_list|(
name|xdrs
argument_list|,
operator|(
expr|struct
name|rpcb_rmtcallargs
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|&
name|barg
argument_list|)
operator|)
condition|)
block|{
name|stat
operator|=
name|RPC_CANTENCODEARGS
expr_stmt|;
goto|goto
name|done_broad
goto|;
block|}
name|outlen
operator|=
name|xdr_getpos
argument_list|(
name|xdrs
argument_list|)
expr_stmt|;
name|xdr_destroy
argument_list|(
name|xdrs
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PORTMAP
comment|/* Prepare the packet for version 2 PORTMAP */
if|if
condition|(
name|pmap_flag
condition|)
block|{
name|msg
operator|.
name|rm_xid
operator|++
expr_stmt|;
comment|/* One way to distinguish */
name|msg
operator|.
name|rm_call
operator|.
name|cb_prog
operator|=
name|PMAPPROG
expr_stmt|;
name|msg
operator|.
name|rm_call
operator|.
name|cb_vers
operator|=
name|PMAPVERS
expr_stmt|;
name|msg
operator|.
name|rm_call
operator|.
name|cb_proc
operator|=
name|PMAPPROC_CALLIT
expr_stmt|;
name|barg_pmap
operator|.
name|prog
operator|=
name|prog
expr_stmt|;
name|barg_pmap
operator|.
name|vers
operator|=
name|vers
expr_stmt|;
name|barg_pmap
operator|.
name|proc
operator|=
name|proc
expr_stmt|;
name|barg_pmap
operator|.
name|args_ptr
operator|=
name|argsp
expr_stmt|;
name|barg_pmap
operator|.
name|xdr_args
operator|=
name|xargs
expr_stmt|;
name|bres_pmap
operator|.
name|port_ptr
operator|=
operator|&
name|port
expr_stmt|;
name|bres_pmap
operator|.
name|xdr_results
operator|=
name|xresults
expr_stmt|;
name|bres_pmap
operator|.
name|results_ptr
operator|=
name|resultsp
expr_stmt|;
name|xdrmem_create
argument_list|(
name|xdrs
argument_list|,
name|outbuf_pmap
argument_list|,
name|udpbufsz
argument_list|,
name|XDR_ENCODE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|xdr_callmsg
argument_list|(
name|xdrs
argument_list|,
operator|&
name|msg
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|xdr_rmtcall_args
argument_list|(
name|xdrs
argument_list|,
operator|&
name|barg_pmap
argument_list|)
operator|)
condition|)
block|{
name|stat
operator|=
name|RPC_CANTENCODEARGS
expr_stmt|;
goto|goto
name|done_broad
goto|;
block|}
name|outlen_pmap
operator|=
name|xdr_getpos
argument_list|(
name|xdrs
argument_list|)
expr_stmt|;
name|xdr_destroy
argument_list|(
name|xdrs
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* PORTMAP */
comment|/* 	 * Basic loop: broadcast the packets to transports which 	 * support data packets of size such that one can encode 	 * all the arguments. 	 * Wait a while for response(s). 	 * The response timeout grows larger per iteration. 	 */
for|for
control|(
name|msec
operator|=
name|inittime
init|;
name|msec
operator|<=
name|waittime
condition|;
name|msec
operator|+=
name|msec
control|)
block|{
name|struct
name|broadif
modifier|*
name|bip
decl_stmt|;
comment|/* Broadcast all the packets now */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fdlistno
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|fdlist
index|[
name|i
index|]
operator|.
name|dsize
operator|<
name|outlen
condition|)
block|{
name|stat
operator|=
name|RPC_CANTSEND
expr_stmt|;
continue|continue;
block|}
for|for
control|(
name|bip
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|fdlist
index|[
name|i
index|]
operator|.
name|nal
argument_list|)
init|;
name|bip
operator|!=
name|NULL
condition|;
name|bip
operator|=
name|TAILQ_NEXT
argument_list|(
name|bip
argument_list|,
name|link
argument_list|)
control|)
block|{
name|void
modifier|*
name|addr
decl_stmt|;
name|addr
operator|=
operator|&
name|bip
operator|->
name|broadaddr
expr_stmt|;
name|__rpc_broadenable
argument_list|(
name|fdlist
index|[
name|i
index|]
operator|.
name|af
argument_list|,
name|fdlist
index|[
name|i
index|]
operator|.
name|fd
argument_list|,
name|bip
argument_list|)
expr_stmt|;
comment|/* 				 * Only use version 3 if lowvers is not set 				 */
if|if
condition|(
operator|!
name|__rpc_lowvers
condition|)
if|if
condition|(
name|_sendto
argument_list|(
name|fdlist
index|[
name|i
index|]
operator|.
name|fd
argument_list|,
name|outbuf
argument_list|,
name|outlen
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|addr
argument_list|,
operator|(
name|size_t
operator|)
name|fdlist
index|[
name|i
index|]
operator|.
name|asize
argument_list|)
operator|!=
name|outlen
condition|)
block|{
ifdef|#
directive|ifdef
name|RPC_DEBUG
name|perror
argument_list|(
literal|"sendto"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|warnx
argument_list|(
literal|"clnt_bcast: cannot send "
literal|"broadcast packet"
argument_list|)
expr_stmt|;
name|stat
operator|=
name|RPC_CANTSEND
expr_stmt|;
continue|continue;
block|}
empty_stmt|;
ifdef|#
directive|ifdef
name|RPC_DEBUG
if|if
condition|(
operator|!
name|__rpc_lowvers
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Broadcast packet sent "
literal|"for %s\n"
argument_list|,
name|fdlist
index|[
name|i
index|]
operator|.
name|nconf
operator|->
name|nc_netid
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|PORTMAP
comment|/* 				 * Send the version 2 packet also 				 * for UDP/IP 				 */
if|if
condition|(
name|pmap_flag
operator|&&
name|fdlist
index|[
name|i
index|]
operator|.
name|proto
operator|==
name|IPPROTO_UDP
condition|)
block|{
if|if
condition|(
name|_sendto
argument_list|(
name|fdlist
index|[
name|i
index|]
operator|.
name|fd
argument_list|,
name|outbuf_pmap
argument_list|,
name|outlen_pmap
argument_list|,
literal|0
argument_list|,
name|addr
argument_list|,
operator|(
name|size_t
operator|)
name|fdlist
index|[
name|i
index|]
operator|.
name|asize
argument_list|)
operator|!=
name|outlen_pmap
condition|)
block|{
name|warnx
argument_list|(
literal|"clnt_bcast: "
literal|"Cannot send broadcast packet"
argument_list|)
expr_stmt|;
name|stat
operator|=
name|RPC_CANTSEND
expr_stmt|;
continue|continue;
block|}
block|}
ifdef|#
directive|ifdef
name|RPC_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"PMAP Broadcast packet "
literal|"sent for %s\n"
argument_list|,
name|fdlist
index|[
name|i
index|]
operator|.
name|nconf
operator|->
name|nc_netid
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* PORTMAP */
block|}
comment|/* End for sending all packets on this transport */
block|}
comment|/* End for sending on all transports */
if|if
condition|(
name|eachresult
operator|==
name|NULL
condition|)
block|{
name|stat
operator|=
name|RPC_SUCCESS
expr_stmt|;
goto|goto
name|done_broad
goto|;
block|}
comment|/* 		 * Get all the replies from these broadcast requests 		 */
name|recv_again
label|:
switch|switch
condition|(
name|pollretval
operator|=
name|_poll
argument_list|(
name|pfd
argument_list|,
name|fdlistno
argument_list|,
name|msec
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
comment|/* timed out */
name|stat
operator|=
name|RPC_TIMEDOUT
expr_stmt|;
continue|continue;
case|case
operator|-
literal|1
case|:
comment|/* some kind of error - we ignore it */
goto|goto
name|recv_again
goto|;
block|}
comment|/* end of poll results switch */
for|for
control|(
name|i
operator|=
name|fds_found
operator|=
literal|0
init|;
name|i
operator|<
name|fdlistno
operator|&&
name|fds_found
operator|<
name|pollretval
condition|;
name|i
operator|++
control|)
block|{
name|bool_t
name|done
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|pfd
index|[
name|i
index|]
operator|.
name|revents
operator|==
literal|0
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|pfd
index|[
name|i
index|]
operator|.
name|revents
operator|&
name|POLLNVAL
condition|)
block|{
comment|/* 				 * Something bad has happened to this descri- 				 * ptor. We can cause _poll() to ignore 				 * it simply by using a negative fd.  We do that 				 * rather than compacting the pfd[] and fdlist[] 				 * arrays. 				 */
name|pfd
index|[
name|i
index|]
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
name|fds_found
operator|++
expr_stmt|;
continue|continue;
block|}
else|else
name|fds_found
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|RPC_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"response for %s\n"
argument_list|,
name|fdlist
index|[
name|i
index|]
operator|.
name|nconf
operator|->
name|nc_netid
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|try_again
label|:
name|inlen
operator|=
name|_recvfrom
argument_list|(
name|fdlist
index|[
name|i
index|]
operator|.
name|fd
argument_list|,
name|inbuf
argument_list|,
name|fdlist
index|[
name|i
index|]
operator|.
name|dsize
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|&
name|fdlist
index|[
name|i
index|]
operator|.
name|raddr
argument_list|,
operator|&
name|fdlist
index|[
name|i
index|]
operator|.
name|asize
argument_list|)
expr_stmt|;
if|if
condition|(
name|inlen
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
goto|goto
name|try_again
goto|;
name|warnx
argument_list|(
literal|"clnt_bcast: Cannot receive reply to "
literal|"broadcast"
argument_list|)
expr_stmt|;
name|stat
operator|=
name|RPC_CANTRECV
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|inlen
operator|<
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
condition|)
continue|continue;
comment|/* Drop that and go ahead */
comment|/* 			 * see if reply transaction id matches sent id. 			 * If so, decode the results. If return id is xid + 1 			 * it was a PORTMAP reply 			 */
if|if
condition|(
operator|*
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
name|inbuf
operator|)
operator|)
operator|==
operator|*
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
name|outbuf
operator|)
operator|)
condition|)
block|{
name|pmap_reply_flag
operator|=
literal|0
expr_stmt|;
name|msg
operator|.
name|acpted_rply
operator|.
name|ar_verf
operator|=
name|_null_auth
expr_stmt|;
name|msg
operator|.
name|acpted_rply
operator|.
name|ar_results
operator|.
name|where
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|void
operator|*
argument_list|)
operator|&
name|bres
expr_stmt|;
name|msg
operator|.
name|acpted_rply
operator|.
name|ar_results
operator|.
name|proc
operator|=
operator|(
name|xdrproc_t
operator|)
name|xdr_rpcb_rmtcallres
expr_stmt|;
ifdef|#
directive|ifdef
name|PORTMAP
block|}
elseif|else
if|if
condition|(
name|pmap_flag
operator|&&
operator|*
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
name|inbuf
operator|)
operator|)
operator|==
operator|*
operator|(
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
name|outbuf_pmap
operator|)
operator|)
condition|)
block|{
name|pmap_reply_flag
operator|=
literal|1
expr_stmt|;
name|msg
operator|.
name|acpted_rply
operator|.
name|ar_verf
operator|=
name|_null_auth
expr_stmt|;
name|msg
operator|.
name|acpted_rply
operator|.
name|ar_results
operator|.
name|where
operator|=
call|(
name|caddr_t
call|)
argument_list|(
name|void
operator|*
argument_list|)
operator|&
name|bres_pmap
expr_stmt|;
name|msg
operator|.
name|acpted_rply
operator|.
name|ar_results
operator|.
name|proc
operator|=
operator|(
name|xdrproc_t
operator|)
name|xdr_rmtcallres
expr_stmt|;
endif|#
directive|endif
comment|/* PORTMAP */
block|}
else|else
continue|continue;
name|xdrmem_create
argument_list|(
name|xdrs
argument_list|,
name|inbuf
argument_list|,
operator|(
name|u_int
operator|)
name|inlen
argument_list|,
name|XDR_DECODE
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdr_replymsg
argument_list|(
name|xdrs
argument_list|,
operator|&
name|msg
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|msg
operator|.
name|rm_reply
operator|.
name|rp_stat
operator|==
name|MSG_ACCEPTED
operator|)
operator|&&
operator|(
name|msg
operator|.
name|acpted_rply
operator|.
name|ar_stat
operator|==
name|SUCCESS
operator|)
condition|)
block|{
name|struct
name|netbuf
name|taddr
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
ifdef|#
directive|ifdef
name|PORTMAP
if|if
condition|(
name|pmap_flag
operator|&&
name|pmap_reply_flag
condition|)
block|{
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|&
name|fdlist
index|[
name|i
index|]
operator|.
name|raddr
expr_stmt|;
name|sin
operator|->
name|sin_port
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|port
argument_list|)
expr_stmt|;
name|taddr
operator|.
name|len
operator|=
name|taddr
operator|.
name|maxlen
operator|=
name|fdlist
index|[
name|i
index|]
operator|.
name|raddr
operator|.
name|ss_len
expr_stmt|;
name|taddr
operator|.
name|buf
operator|=
operator|&
name|fdlist
index|[
name|i
index|]
operator|.
name|raddr
expr_stmt|;
name|done
operator|=
call|(
modifier|*
name|eachresult
call|)
argument_list|(
name|resultsp
argument_list|,
operator|&
name|taddr
argument_list|,
name|fdlist
index|[
name|i
index|]
operator|.
name|nconf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
comment|/* PORTMAP */
ifdef|#
directive|ifdef
name|RPC_DEBUG
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"uaddr %s\n"
argument_list|,
name|uaddrp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|np
operator|=
name|uaddr2taddr
argument_list|(
name|fdlist
index|[
name|i
index|]
operator|.
name|nconf
argument_list|,
name|uaddrp
argument_list|)
expr_stmt|;
name|done
operator|=
call|(
modifier|*
name|eachresult
call|)
argument_list|(
name|resultsp
argument_list|,
name|np
argument_list|,
name|fdlist
index|[
name|i
index|]
operator|.
name|nconf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|np
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PORTMAP
block|}
endif|#
directive|endif
comment|/* PORTMAP */
block|}
comment|/* otherwise, we just ignore the errors ... */
block|}
comment|/* else some kind of deserialization problem ... */
name|xdrs
operator|->
name|x_op
operator|=
name|XDR_FREE
expr_stmt|;
name|msg
operator|.
name|acpted_rply
operator|.
name|ar_results
operator|.
name|proc
operator|=
operator|(
name|xdrproc_t
operator|)
name|xdr_void
expr_stmt|;
operator|(
name|void
operator|)
name|xdr_replymsg
argument_list|(
name|xdrs
argument_list|,
operator|&
name|msg
argument_list|)
expr_stmt|;
call|(
name|void
call|)
argument_list|(
operator|*
name|xresults
argument_list|)
argument_list|(
name|xdrs
argument_list|,
name|resultsp
argument_list|)
expr_stmt|;
name|XDR_DESTROY
argument_list|(
name|xdrs
argument_list|)
expr_stmt|;
if|if
condition|(
name|done
condition|)
block|{
name|stat
operator|=
name|RPC_SUCCESS
expr_stmt|;
goto|goto
name|done_broad
goto|;
block|}
else|else
block|{
goto|goto
name|recv_again
goto|;
block|}
block|}
comment|/* The recv for loop */
block|}
comment|/* The giant for loop */
name|done_broad
label|:
name|free
argument_list|(
name|inbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|outbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PORTMAP
name|free
argument_list|(
name|outbuf_pmap
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* PORTMAP */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fdlistno
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|_close
argument_list|(
name|fdlist
index|[
name|i
index|]
operator|.
name|fd
argument_list|)
expr_stmt|;
name|__rpc_freebroadifs
argument_list|(
operator|&
name|fdlist
index|[
name|i
index|]
operator|.
name|nal
argument_list|)
expr_stmt|;
block|}
name|AUTH_DESTROY
argument_list|(
name|sys_auth
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|__rpc_endconf
argument_list|(
name|handle
argument_list|)
expr_stmt|;
return|return
operator|(
name|stat
operator|)
return|;
block|}
end_function

begin_function
name|enum
name|clnt_stat
name|rpc_broadcast
parameter_list|(
name|prog
parameter_list|,
name|vers
parameter_list|,
name|proc
parameter_list|,
name|xargs
parameter_list|,
name|argsp
parameter_list|,
name|xresults
parameter_list|,
name|resultsp
parameter_list|,
name|eachresult
parameter_list|,
name|nettype
parameter_list|)
name|rpcprog_t
name|prog
decl_stmt|;
comment|/* program number */
name|rpcvers_t
name|vers
decl_stmt|;
comment|/* version number */
name|rpcproc_t
name|proc
decl_stmt|;
comment|/* procedure number */
name|xdrproc_t
name|xargs
decl_stmt|;
comment|/* xdr routine for args */
name|caddr_t
name|argsp
decl_stmt|;
comment|/* pointer to args */
name|xdrproc_t
name|xresults
decl_stmt|;
comment|/* xdr routine for results */
name|caddr_t
name|resultsp
decl_stmt|;
comment|/* pointer to results */
name|resultproc_t
name|eachresult
decl_stmt|;
comment|/* call with each result obtained */
specifier|const
name|char
modifier|*
name|nettype
decl_stmt|;
comment|/* transport type */
block|{
name|enum
name|clnt_stat
name|dummy
decl_stmt|;
name|dummy
operator|=
name|rpc_broadcast_exp
argument_list|(
name|prog
argument_list|,
name|vers
argument_list|,
name|proc
argument_list|,
name|xargs
argument_list|,
name|argsp
argument_list|,
name|xresults
argument_list|,
name|resultsp
argument_list|,
name|eachresult
argument_list|,
name|INITTIME
argument_list|,
name|WAITTIME
argument_list|,
name|nettype
argument_list|)
expr_stmt|;
return|return
operator|(
name|dummy
operator|)
return|;
block|}
end_function

end_unit

