begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*********************************************************** Copyright 1990, by Alfalfa Software Incorporated, Cambridge, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that Alfalfa's name not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  ALPHALPHA DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL ALPHALPHA BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  If you make any modifications, bugfixes or other changes to this software we'd appreciate it if you could send a copy to us so we can keep things up-to-date.  Many thanks. 				Kee Hinckley 				Alfalfa Software, Inc. 				267 Allston St., #3 				Cambridge, MA 02139  USA 				nazgul@alfalfa.com  ******************************************************************/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBC_SCCS and not lint */
end_comment

begin_comment
comment|/*  * We need a better way of handling errors than printing text.  I need  * to add an error handling routine.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/syslimits.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|<nl_types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"msgcat.h"
end_include

begin_define
define|#
directive|define
name|_DEFAULT_NLS_PATH
value|"/usr/share/nls/%L/%N.cat:/usr/share/nls/%N/%L:/usr/local/share/nls/%L/%N.cat:/usr/local/share/nls/%N/%L"
end_define

begin_define
define|#
directive|define
name|TRUE
value|1
end_define

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|NLERR
value|((nl_catd) -1)
end_define

begin_define
define|#
directive|define
name|NLRETERR
parameter_list|(
name|errc
parameter_list|)
value|errno = errc; return(NLERR);
end_define

begin_function_decl
specifier|static
name|nl_catd
name|loadCat
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|loadSet
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|__nls_free_resources
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|nl_catd
name|catopen
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|)
name|__const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
name|int
name|spcleft
decl_stmt|;
name|char
name|path
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
modifier|*
name|nlspath
decl_stmt|,
modifier|*
name|lang
decl_stmt|,
modifier|*
name|base
decl_stmt|,
modifier|*
name|cptr
decl_stmt|,
modifier|*
name|pathP
decl_stmt|,
modifier|*
name|tmpptr
decl_stmt|;
name|char
modifier|*
name|cptr1
decl_stmt|,
modifier|*
name|plang
decl_stmt|,
modifier|*
name|pter
decl_stmt|,
modifier|*
name|pcode
decl_stmt|;
name|struct
name|stat
name|sbuf
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
operator|*
name|name
operator|==
literal|'\0'
condition|)
block|{
name|NLRETERR
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
block|}
comment|/* is it absolute path ? if yes, load immidiately */
if|if
condition|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
condition|)
return|return
name|loadCat
argument_list|(
name|name
argument_list|)
return|;
if|if
condition|(
name|type
operator|==
name|NL_CAT_LOCALE
condition|)
name|lang
operator|=
name|setlocale
argument_list|(
name|LC_MESSAGES
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|lang
operator|=
name|getenv
argument_list|(
literal|"LANG"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lang
operator|==
name|NULL
operator|||
operator|*
name|lang
operator|==
literal|'\0'
operator|||
name|strchr
argument_list|(
name|lang
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|NULL
condition|)
name|lang
operator|=
literal|"C"
expr_stmt|;
if|if
condition|(
operator|(
name|plang
operator|=
name|cptr1
operator|=
name|strdup
argument_list|(
name|lang
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NLERR
operator|)
return|;
if|if
condition|(
operator|(
name|cptr
operator|=
name|strchr
argument_list|(
name|cptr1
argument_list|,
literal|'@'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cptr
operator|=
literal|'\0'
expr_stmt|;
name|pter
operator|=
name|pcode
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|(
name|cptr
operator|=
name|strchr
argument_list|(
name|cptr1
argument_list|,
literal|'_'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|pter
operator|=
name|cptr1
operator|=
name|cptr
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cptr
operator|=
name|strchr
argument_list|(
name|cptr1
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|pcode
operator|=
name|cptr
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|nlspath
operator|=
name|getenv
argument_list|(
literal|"NLSPATH"
argument_list|)
operator|)
operator|==
name|NULL
ifndef|#
directive|ifndef
name|__NETBSD_SYSCALLS
operator|||
name|issetugid
argument_list|()
endif|#
directive|endif
condition|)
name|nlspath
operator|=
name|_DEFAULT_NLS_PATH
expr_stmt|;
if|if
condition|(
operator|(
name|base
operator|=
name|cptr
operator|=
name|strdup
argument_list|(
name|nlspath
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|plang
argument_list|)
expr_stmt|;
return|return
operator|(
name|NLERR
operator|)
return|;
block|}
while|while
condition|(
operator|(
name|nlspath
operator|=
name|strsep
argument_list|(
operator|&
name|cptr
argument_list|,
literal|":"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pathP
operator|=
name|path
expr_stmt|;
if|if
condition|(
operator|*
name|nlspath
condition|)
block|{
for|for
control|(
init|;
operator|*
name|nlspath
condition|;
operator|++
name|nlspath
control|)
block|{
if|if
condition|(
operator|*
name|nlspath
operator|==
literal|'%'
condition|)
block|{
switch|switch
condition|(
operator|*
operator|(
name|nlspath
operator|+
literal|1
operator|)
condition|)
block|{
case|case
literal|'l'
case|:
name|tmpptr
operator|=
name|plang
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|tmpptr
operator|=
name|pter
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|tmpptr
operator|=
name|pcode
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|tmpptr
operator|=
name|lang
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|tmpptr
operator|=
operator|(
name|char
operator|*
operator|)
name|name
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
operator|++
name|nlspath
expr_stmt|;
comment|/* fallthrough */
default|default:
if|if
condition|(
name|pathP
operator|-
name|path
operator|>=
sizeof|sizeof
argument_list|(
name|path
argument_list|)
operator|-
literal|1
condition|)
goto|goto
name|too_long
goto|;
operator|*
operator|(
name|pathP
operator|++
operator|)
operator|=
operator|*
name|nlspath
expr_stmt|;
continue|continue;
block|}
operator|++
name|nlspath
expr_stmt|;
name|put_tmpptr
label|:
name|spcleft
operator|=
sizeof|sizeof
argument_list|(
name|path
argument_list|)
operator|-
operator|(
name|pathP
operator|-
name|path
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|strlcpy
argument_list|(
name|pathP
argument_list|,
name|tmpptr
argument_list|,
name|spcleft
argument_list|)
operator|>=
name|spcleft
condition|)
block|{
name|too_long
label|:
name|free
argument_list|(
name|plang
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|NLRETERR
argument_list|(
name|ENAMETOOLONG
argument_list|)
expr_stmt|;
block|}
name|pathP
operator|+=
name|strlen
argument_list|(
name|tmpptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pathP
operator|-
name|path
operator|>=
sizeof|sizeof
argument_list|(
name|path
argument_list|)
operator|-
literal|1
condition|)
goto|goto
name|too_long
goto|;
operator|*
operator|(
name|pathP
operator|++
operator|)
operator|=
operator|*
name|nlspath
expr_stmt|;
block|}
block|}
operator|*
name|pathP
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|plang
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
name|loadCat
argument_list|(
name|path
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|tmpptr
operator|=
operator|(
name|char
operator|*
operator|)
name|name
expr_stmt|;
operator|--
name|nlspath
expr_stmt|;
goto|goto
name|put_tmpptr
goto|;
block|}
block|}
name|free
argument_list|(
name|plang
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|NLRETERR
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We've got an odd situation here.  The odds are real good that the  * number we are looking for is almost the same as the index.  We could  * use the index, check the difference and do something intelligent, but  * I haven't quite figured out what's intelligent.  *  * Here's a start.  *	Take an id N.  If there are> N items in the list, then N cannot  *	be more than N items from the start, since otherwise there would  *	have to be duplicate items.  So we can safely set the top to N+1  *	(after taking into account that ids start at 1, and arrays at 0)  *  *	Let's say we are at position P, and we are looking for N, but have  *	V.  If N> V, then the furthest away that N could be is  *	P + (N-V).  So we can safely set hi to P+(N-V)+1.  For example:  *		We are looking for 10, but have 8  *		8	?	?	?	?  *>=9>=10>=11  *  */
end_comment

begin_define
define|#
directive|define
name|LOOKUP
parameter_list|(
name|PARENT
parameter_list|,
name|CHILD
parameter_list|,
name|ID
parameter_list|,
name|NUM
parameter_list|,
name|SET
parameter_list|)
value|{	\     lo = 0; 					\     if (ID - 1< PARENT->NUM) {			\ 	cur = ID - 1; hi = ID;			\     } else {					\ 	hi = PARENT->NUM; cur = (hi - lo) / 2;	\     }						\     while (TRUE) {				\ 	CHILD = PARENT->SET + cur;		\ 	if (CHILD->ID == ID) break;		\ 	if (CHILD->ID< ID) {			\ 	    lo = cur+1;				\ 	    if (hi> cur+(ID-CHILD->ID)+1)	\ 		hi = cur+(ID-CHILD->ID)+1;	\ 	    dir = 1;				\ 	} else {				\ 	    hi = cur; dir = -1;			\ 	}					\ 	if (lo>= hi) return(NULL);		\ 	if (hi - lo == 1) cur += dir;		\ 	else cur += ((hi - lo) / 2) * dir;	\     }						\   }
end_define

begin_function
specifier|static
name|MCSetT
modifier|*
name|MCGetSet
parameter_list|(
name|cat
parameter_list|,
name|setId
parameter_list|)
name|MCCatT
modifier|*
name|cat
decl_stmt|;
name|int
name|setId
decl_stmt|;
block|{
name|MCSetT
modifier|*
name|set
decl_stmt|;
name|long
name|lo
decl_stmt|,
name|hi
decl_stmt|,
name|cur
decl_stmt|,
name|dir
decl_stmt|;
if|if
condition|(
name|cat
operator|==
name|NULL
operator|||
name|setId
operator|<=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|LOOKUP
argument_list|(
name|cat
argument_list|,
name|set
argument_list|,
name|setId
argument_list|,
name|numSets
argument_list|,
name|sets
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|->
name|invalid
operator|&&
name|loadSet
argument_list|(
name|cat
argument_list|,
name|set
argument_list|)
operator|<=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|set
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|MCMsgT
modifier|*
name|MCGetMsg
parameter_list|(
name|set
parameter_list|,
name|msgId
parameter_list|)
name|MCSetT
modifier|*
name|set
decl_stmt|;
name|int
name|msgId
decl_stmt|;
block|{
name|MCMsgT
modifier|*
name|msg
decl_stmt|;
name|long
name|lo
decl_stmt|,
name|hi
decl_stmt|,
name|cur
decl_stmt|,
name|dir
decl_stmt|;
if|if
condition|(
name|set
operator|==
name|NULL
operator|||
name|set
operator|->
name|invalid
operator|||
name|msgId
operator|<=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|LOOKUP
argument_list|(
name|set
argument_list|,
name|msg
argument_list|,
name|msgId
argument_list|,
name|numMsgs
argument_list|,
name|u
operator|.
name|msgs
argument_list|)
expr_stmt|;
return|return
operator|(
name|msg
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|catgets
parameter_list|(
name|catd
parameter_list|,
name|setId
parameter_list|,
name|msgId
parameter_list|,
name|dflt
parameter_list|)
name|nl_catd
name|catd
decl_stmt|;
name|int
name|setId
decl_stmt|;
name|int
name|msgId
decl_stmt|;
name|__const
name|char
modifier|*
name|dflt
decl_stmt|;
block|{
name|MCMsgT
modifier|*
name|msg
decl_stmt|;
name|MCCatT
modifier|*
name|cat
init|=
operator|(
name|MCCatT
operator|*
operator|)
name|catd
decl_stmt|;
name|__const
name|char
modifier|*
name|cptr
decl_stmt|;
if|if
condition|(
name|catd
operator|==
name|NULL
operator|||
name|catd
operator|==
name|NLERR
condition|)
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|dflt
operator|)
return|;
name|msg
operator|=
name|MCGetMsg
argument_list|(
name|MCGetSet
argument_list|(
name|cat
argument_list|,
name|setId
argument_list|)
argument_list|,
name|msgId
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
name|cptr
operator|=
name|msg
operator|->
name|msg
operator|.
name|str
expr_stmt|;
else|else
name|cptr
operator|=
name|dflt
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|cptr
operator|)
return|;
block|}
end_function

begin_function
name|int
name|catclose
parameter_list|(
name|catd
parameter_list|)
name|nl_catd
name|catd
decl_stmt|;
block|{
name|MCCatT
modifier|*
name|cat
init|=
operator|(
name|MCCatT
operator|*
operator|)
name|catd
decl_stmt|;
if|if
condition|(
name|catd
operator|==
name|NULL
operator|||
name|catd
operator|==
name|NLERR
condition|)
block|{
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|#
directive|if
literal|0
block|if (cat->loadType != MCLoadAll)
endif|#
directive|endif
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|cat
operator|->
name|fp
argument_list|)
expr_stmt|;
name|__nls_free_resources
argument_list|(
name|cat
argument_list|,
name|cat
operator|->
name|numSets
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cat
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Internal routines  */
end_comment

begin_comment
comment|/* Note that only malloc failures are allowed to return an error */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|_errowner
init|=
literal|"Message Catalog System"
decl_stmt|;
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_define
define|#
directive|define
name|CORRUPT
parameter_list|()
value|{ 						\ 	fprintf(stderr, "%s: corrupt file.", _errowner);	\ 		free(cat);					\ 		NLRETERR(EINVAL);				\ 	}
end_define

begin_define
define|#
directive|define
name|NOSPACE
parameter_list|()
value|{						\ 	fprintf(stderr, "%s: no more memory.", _errowner);	\ 		free(cat);					\ 		return(NLERR);					\ 	}
end_define

begin_function
specifier|static
name|void
name|__nls_free_resources
parameter_list|(
name|cat
parameter_list|,
name|i
parameter_list|)
name|MCCatT
modifier|*
name|cat
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
name|MCSetT
modifier|*
name|set
decl_stmt|;
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|set
operator|=
name|cat
operator|->
name|sets
operator|+
name|j
expr_stmt|;
if|if
condition|(
operator|!
name|set
operator|->
name|invalid
condition|)
block|{
name|free
argument_list|(
name|set
operator|->
name|data
operator|.
name|str
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|set
operator|->
name|u
operator|.
name|msgs
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|cat
operator|->
name|sets
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|nl_catd
name|loadCat
parameter_list|(
name|catpath
parameter_list|)
name|__const
name|char
modifier|*
name|catpath
decl_stmt|;
block|{
name|MCHeaderT
name|header
decl_stmt|;
name|MCCatT
modifier|*
name|cat
decl_stmt|;
name|MCSetT
modifier|*
name|set
decl_stmt|;
name|long
name|i
decl_stmt|;
name|off_t
name|nextSet
decl_stmt|;
name|cat
operator|=
operator|(
name|MCCatT
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|MCCatT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cat
operator|==
name|NULL
condition|)
return|return
operator|(
name|NLERR
operator|)
return|;
name|cat
operator|->
name|loadType
operator|=
name|MCLoadBySet
expr_stmt|;
if|if
condition|(
operator|(
name|cat
operator|->
name|fp
operator|=
name|fopen
argument_list|(
name|catpath
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|cat
argument_list|)
expr_stmt|;
return|return
operator|(
name|NLERR
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|_fcntl
argument_list|(
name|fileno
argument_list|(
name|cat
operator|->
name|fp
argument_list|)
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
name|header
argument_list|)
argument_list|,
literal|1
argument_list|,
name|cat
operator|->
name|fp
argument_list|)
operator|!=
literal|1
condition|)
name|CORRUPT
argument_list|()
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|header
operator|.
name|magic
argument_list|,
name|MCMagic
argument_list|,
name|MCMagicLen
argument_list|)
operator|!=
literal|0
condition|)
name|CORRUPT
argument_list|()
expr_stmt|;
if|if
condition|(
name|header
operator|.
name|majorVer
operator|!=
name|MCMajorVer
condition|)
block|{
name|free
argument_list|(
name|cat
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s is version %ld, we need %ld.\n"
argument_list|,
name|_errowner
argument_list|,
name|catpath
argument_list|,
name|header
operator|.
name|majorVer
argument_list|,
name|MCMajorVer
argument_list|)
expr_stmt|;
name|NLRETERR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|header
operator|.
name|numSets
operator|<=
literal|0
condition|)
block|{
name|free
argument_list|(
name|cat
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s has %ld sets!\n"
argument_list|,
name|_errowner
argument_list|,
name|catpath
argument_list|,
name|header
operator|.
name|numSets
argument_list|)
expr_stmt|;
name|NLRETERR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
name|cat
operator|->
name|numSets
operator|=
name|header
operator|.
name|numSets
expr_stmt|;
name|cat
operator|->
name|sets
operator|=
operator|(
name|MCSetT
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|MCSetT
argument_list|)
operator|*
name|header
operator|.
name|numSets
argument_list|)
expr_stmt|;
if|if
condition|(
name|cat
operator|->
name|sets
operator|==
name|NULL
condition|)
name|NOSPACE
argument_list|()
expr_stmt|;
name|nextSet
operator|=
name|header
operator|.
name|firstSet
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cat
operator|->
name|numSets
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|fseeko
argument_list|(
name|cat
operator|->
name|fp
argument_list|,
name|nextSet
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|__nls_free_resources
argument_list|(
name|cat
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|CORRUPT
argument_list|()
expr_stmt|;
block|}
comment|/* read in the set header */
name|set
operator|=
name|cat
operator|->
name|sets
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|set
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|set
argument_list|)
argument_list|,
literal|1
argument_list|,
name|cat
operator|->
name|fp
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|__nls_free_resources
argument_list|(
name|cat
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|CORRUPT
argument_list|()
expr_stmt|;
block|}
comment|/* if it's invalid, skip over it (and backup 'i') */
if|if
condition|(
name|set
operator|->
name|invalid
condition|)
block|{
operator|--
name|i
expr_stmt|;
name|nextSet
operator|=
name|set
operator|->
name|nextSet
expr_stmt|;
continue|continue;
block|}
if|#
directive|if
literal|0
block|if (cat->loadType == MCLoadAll) { 	    int res;  	    if ((res = loadSet(cat, set))<= 0) { 		__nls_free_resources(cat, i); 		if (res< 0) NOSPACE(); 		CORRUPT(); 	    } 	} else
endif|#
directive|endif
name|set
operator|->
name|invalid
operator|=
name|TRUE
expr_stmt|;
name|nextSet
operator|=
name|set
operator|->
name|nextSet
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|if (cat->loadType == MCLoadAll) { 	(void) fclose(cat->fp); 	cat->fp = NULL;     }
endif|#
directive|endif
return|return
operator|(
operator|(
name|nl_catd
operator|)
name|cat
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|loadSet
parameter_list|(
name|cat
parameter_list|,
name|set
parameter_list|)
name|MCCatT
modifier|*
name|cat
decl_stmt|;
name|MCSetT
modifier|*
name|set
decl_stmt|;
block|{
name|MCMsgT
modifier|*
name|msg
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Get the data */
if|if
condition|(
name|fseeko
argument_list|(
name|cat
operator|->
name|fp
argument_list|,
name|set
operator|->
name|data
operator|.
name|off
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|set
operator|->
name|data
operator|.
name|str
operator|=
name|malloc
argument_list|(
name|set
operator|->
name|dataLen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|fread
argument_list|(
name|set
operator|->
name|data
operator|.
name|str
argument_list|,
name|set
operator|->
name|dataLen
argument_list|,
literal|1
argument_list|,
name|cat
operator|->
name|fp
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|free
argument_list|(
name|set
operator|->
name|data
operator|.
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Get the messages */
if|if
condition|(
name|fseeko
argument_list|(
name|cat
operator|->
name|fp
argument_list|,
name|set
operator|->
name|u
operator|.
name|firstMsg
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|free
argument_list|(
name|set
operator|->
name|data
operator|.
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|set
operator|->
name|u
operator|.
name|msgs
operator|=
operator|(
name|MCMsgT
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|MCMsgT
argument_list|)
operator|*
name|set
operator|->
name|numMsgs
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|set
operator|->
name|data
operator|.
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|set
operator|->
name|numMsgs
condition|;
operator|++
name|i
control|)
block|{
name|msg
operator|=
name|set
operator|->
name|u
operator|.
name|msgs
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|fread
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|msg
argument_list|)
argument_list|,
literal|1
argument_list|,
name|cat
operator|->
name|fp
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|free
argument_list|(
name|set
operator|->
name|u
operator|.
name|msgs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|set
operator|->
name|data
operator|.
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|msg
operator|->
name|invalid
condition|)
block|{
operator|--
name|i
expr_stmt|;
continue|continue;
block|}
name|msg
operator|->
name|msg
operator|.
name|str
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|set
operator|->
name|data
operator|.
name|str
operator|+
name|msg
operator|->
name|msg
operator|.
name|off
operator|)
expr_stmt|;
block|}
name|set
operator|->
name|invalid
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

