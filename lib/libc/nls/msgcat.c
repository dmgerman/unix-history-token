begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************** Copyright 1990, by Alfalfa Software Incorporated, Cambridge, Massachusetts. Copyright 2010, Gabor Kovesdan<gabor@FreeBSD.org>                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that Alfalfa's name not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  ALPHALPHA DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL ALPHALPHA BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  If you make any modifications, bugfixes or other changes to this software we'd appreciate it if you could send a copy to us so we can keep things up-to-date.  Many thanks. 				Kee Hinckley 				Alfalfa Software, Inc. 				267 Allston St., #3 				Cambridge, MA 02139  USA 				nazgul@alfalfa.com  ******************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|_NLS_PRIVATE
end_define

begin_include
include|#
directive|include
file|"namespace.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_comment
comment|/* for ntohl() */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|<nl_types.h>
end_include

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"un-namespace.h"
end_include

begin_include
include|#
directive|include
file|"../locale/setlocale.h"
end_include

begin_comment
comment|/* for ENCODING_LEN */
end_comment

begin_define
define|#
directive|define
name|_DEFAULT_NLS_PATH
value|"/usr/share/nls/%L/%N.cat:/usr/share/nls/%N/%L:/usr/local/share/nls/%L/%N.cat:/usr/local/share/nls/%N/%L"
end_define

begin_define
define|#
directive|define
name|RLOCK
parameter_list|(
name|fail
parameter_list|)
value|{ int ret;						\ 			  if (__isthreaded&&					\ 			      ((ret = _pthread_rwlock_rdlock(&rwlock)) != 0)) {	\ 				  errno = ret;					\ 				  return (fail);				\ 			  }}
end_define

begin_define
define|#
directive|define
name|WLOCK
parameter_list|(
name|fail
parameter_list|)
value|{ int ret;						\ 			  if (__isthreaded&&					\ 			      ((ret = _pthread_rwlock_wrlock(&rwlock)) != 0)) {	\ 				  errno = ret;					\ 				  return (fail);				\ 			  }}
end_define

begin_define
define|#
directive|define
name|UNLOCK
value|{ if (__isthreaded)					\ 			      _pthread_rwlock_unlock(&rwlock); }
end_define

begin_define
define|#
directive|define
name|NLERR
value|((nl_catd) -1)
end_define

begin_define
define|#
directive|define
name|NLRETERR
parameter_list|(
name|errc
parameter_list|)
value|{ errno = errc; return (NLERR); }
end_define

begin_define
define|#
directive|define
name|SAVEFAIL
parameter_list|(
name|n
parameter_list|,
name|l
parameter_list|,
name|e
parameter_list|)
value|{ WLOCK(NLERR);					\ 				  np = malloc(sizeof(struct catentry));		\ 				  if (np != NULL) {				\ 				  	np->name = strdup(n);			\ 					np->path = NULL;			\ 					np->catd = NLERR;			\ 					np->refcount = 0;			\ 					np->lang = (l == NULL) ? NULL :		\ 					    strdup(l);				\ 					np->caterrno = e;			\ 				  	SLIST_INSERT_HEAD(&cache, np, list);	\ 				  }						\ 				  UNLOCK;					\ 				  errno = e;					\ 				}
end_define

begin_function_decl
specifier|static
name|nl_catd
name|load_msgcat
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|pthread_rwlock_t
name|rwlock
init|=
name|PTHREAD_RWLOCK_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|catentry
block|{
name|SLIST_ENTRY
argument_list|(
argument|catentry
argument_list|)
name|list
expr_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|caterrno
decl_stmt|;
name|nl_catd
name|catd
decl_stmt|;
name|char
modifier|*
name|lang
decl_stmt|;
name|int
name|refcount
decl_stmt|;
block|}
struct|;
end_struct

begin_macro
name|SLIST_HEAD
argument_list|(
argument|listhead
argument_list|,
argument|catentry
argument_list|)
end_macro

begin_expr_stmt
name|cache
operator|=
name|SLIST_HEAD_INITIALIZER
argument_list|(
name|cache
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|nl_catd
name|catopen
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|stat
name|sbuf
decl_stmt|;
name|struct
name|catentry
modifier|*
name|np
decl_stmt|;
name|char
modifier|*
name|base
decl_stmt|,
modifier|*
name|cptr
decl_stmt|,
modifier|*
name|cptr1
decl_stmt|,
modifier|*
name|lang
decl_stmt|,
modifier|*
name|nlspath
decl_stmt|,
modifier|*
name|pathP
decl_stmt|,
modifier|*
name|pcode
decl_stmt|;
name|char
modifier|*
name|plang
decl_stmt|,
modifier|*
name|pter
decl_stmt|,
modifier|*
name|tmpptr
decl_stmt|;
name|int
name|saverr
decl_stmt|,
name|spcleft
decl_stmt|;
name|char
name|path
index|[
name|PATH_MAX
index|]
decl_stmt|;
comment|/* sanity checking */
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
operator|*
name|name
operator|==
literal|'\0'
condition|)
name|NLRETERR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|NULL
condition|)
comment|/* have a pathname */
name|lang
operator|=
name|NULL
expr_stmt|;
else|else
block|{
if|if
condition|(
name|type
operator|==
name|NL_CAT_LOCALE
condition|)
name|lang
operator|=
name|setlocale
argument_list|(
name|LC_MESSAGES
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|lang
operator|=
name|getenv
argument_list|(
literal|"LANG"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lang
operator|==
name|NULL
operator|||
operator|*
name|lang
operator|==
literal|'\0'
operator|||
name|strlen
argument_list|(
name|lang
argument_list|)
operator|>
name|ENCODING_LEN
operator|||
operator|(
name|lang
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|lang
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|lang
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|lang
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
operator|)
operator|)
operator|||
name|strchr
argument_list|(
name|lang
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|NULL
condition|)
name|lang
operator|=
literal|"C"
expr_stmt|;
block|}
comment|/* Try to get it from the cache first */
name|RLOCK
argument_list|(
name|NLERR
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|np
argument_list|,
argument|&cache
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|np
operator|->
name|name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
name|lang
operator|!=
name|NULL
operator|&&
name|np
operator|->
name|lang
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|np
operator|->
name|lang
argument_list|,
name|lang
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|np
operator|->
name|lang
operator|==
name|lang
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|caterrno
operator|!=
literal|0
condition|)
block|{
comment|/* Found cached failing entry */
name|UNLOCK
expr_stmt|;
name|NLRETERR
argument_list|(
name|np
operator|->
name|caterrno
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Found cached successful entry */
name|np
operator|->
name|refcount
operator|++
expr_stmt|;
name|UNLOCK
expr_stmt|;
return|return
operator|(
name|np
operator|->
name|catd
operator|)
return|;
block|}
block|}
block|}
name|UNLOCK
expr_stmt|;
comment|/* is it absolute path ? if yes, load immediately */
if|if
condition|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|load_msgcat
argument_list|(
name|name
argument_list|,
name|name
argument_list|,
name|lang
argument_list|)
operator|)
return|;
comment|/* sanity checking */
if|if
condition|(
operator|(
name|plang
operator|=
name|cptr1
operator|=
name|strdup
argument_list|(
name|lang
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NLERR
operator|)
return|;
if|if
condition|(
operator|(
name|cptr
operator|=
name|strchr
argument_list|(
name|cptr1
argument_list|,
literal|'@'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cptr
operator|=
literal|'\0'
expr_stmt|;
name|pter
operator|=
name|pcode
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|(
name|cptr
operator|=
name|strchr
argument_list|(
name|cptr1
argument_list|,
literal|'_'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|pter
operator|=
name|cptr1
operator|=
name|cptr
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cptr
operator|=
name|strchr
argument_list|(
name|cptr1
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|pcode
operator|=
name|cptr
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|nlspath
operator|=
name|getenv
argument_list|(
literal|"NLSPATH"
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|issetugid
argument_list|()
condition|)
name|nlspath
operator|=
name|_DEFAULT_NLS_PATH
expr_stmt|;
if|if
condition|(
operator|(
name|base
operator|=
name|cptr
operator|=
name|strdup
argument_list|(
name|nlspath
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|saverr
operator|=
name|errno
expr_stmt|;
name|free
argument_list|(
name|plang
argument_list|)
expr_stmt|;
name|errno
operator|=
name|saverr
expr_stmt|;
return|return
operator|(
name|NLERR
operator|)
return|;
block|}
while|while
condition|(
operator|(
name|nlspath
operator|=
name|strsep
argument_list|(
operator|&
name|cptr
argument_list|,
literal|":"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pathP
operator|=
name|path
expr_stmt|;
if|if
condition|(
operator|*
name|nlspath
condition|)
block|{
for|for
control|(
init|;
operator|*
name|nlspath
condition|;
operator|++
name|nlspath
control|)
block|{
if|if
condition|(
operator|*
name|nlspath
operator|==
literal|'%'
condition|)
block|{
switch|switch
condition|(
operator|*
operator|(
name|nlspath
operator|+
literal|1
operator|)
condition|)
block|{
case|case
literal|'l'
case|:
name|tmpptr
operator|=
name|plang
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|tmpptr
operator|=
name|pter
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|tmpptr
operator|=
name|pcode
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|tmpptr
operator|=
name|lang
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|tmpptr
operator|=
operator|(
name|char
operator|*
operator|)
name|name
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
operator|++
name|nlspath
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
if|if
condition|(
name|pathP
operator|-
name|path
operator|>=
sizeof|sizeof
argument_list|(
name|path
argument_list|)
operator|-
literal|1
condition|)
goto|goto
name|too_long
goto|;
operator|*
operator|(
name|pathP
operator|++
operator|)
operator|=
operator|*
name|nlspath
expr_stmt|;
continue|continue;
block|}
operator|++
name|nlspath
expr_stmt|;
name|put_tmpptr
label|:
name|spcleft
operator|=
sizeof|sizeof
argument_list|(
name|path
argument_list|)
operator|-
operator|(
name|pathP
operator|-
name|path
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|strlcpy
argument_list|(
name|pathP
argument_list|,
name|tmpptr
argument_list|,
name|spcleft
argument_list|)
operator|>=
name|spcleft
condition|)
block|{
name|too_long
label|:
name|free
argument_list|(
name|plang
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|SAVEFAIL
argument_list|(
name|name
argument_list|,
name|lang
argument_list|,
name|ENAMETOOLONG
argument_list|)
expr_stmt|;
name|NLRETERR
argument_list|(
name|ENAMETOOLONG
argument_list|)
expr_stmt|;
block|}
name|pathP
operator|+=
name|strlen
argument_list|(
name|tmpptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pathP
operator|-
name|path
operator|>=
sizeof|sizeof
argument_list|(
name|path
argument_list|)
operator|-
literal|1
condition|)
goto|goto
name|too_long
goto|;
operator|*
operator|(
name|pathP
operator|++
operator|)
operator|=
operator|*
name|nlspath
expr_stmt|;
block|}
block|}
operator|*
name|pathP
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|plang
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|base
argument_list|)
expr_stmt|;
return|return
operator|(
name|load_msgcat
argument_list|(
name|path
argument_list|,
name|name
argument_list|,
name|lang
argument_list|)
operator|)
return|;
block|}
block|}
else|else
block|{
name|tmpptr
operator|=
operator|(
name|char
operator|*
operator|)
name|name
expr_stmt|;
operator|--
name|nlspath
expr_stmt|;
goto|goto
name|put_tmpptr
goto|;
block|}
block|}
name|free
argument_list|(
name|plang
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|base
argument_list|)
expr_stmt|;
name|SAVEFAIL
argument_list|(
name|name
argument_list|,
name|lang
argument_list|,
name|ENOENT
argument_list|)
expr_stmt|;
name|NLRETERR
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|catgets
parameter_list|(
name|nl_catd
name|catd
parameter_list|,
name|int
name|set_id
parameter_list|,
name|int
name|msg_id
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|struct
name|_nls_cat_hdr
modifier|*
name|cat_hdr
decl_stmt|;
name|struct
name|_nls_msg_hdr
modifier|*
name|msg_hdr
decl_stmt|;
name|struct
name|_nls_set_hdr
modifier|*
name|set_hdr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|l
decl_stmt|,
name|r
decl_stmt|,
name|u
decl_stmt|;
if|if
condition|(
name|catd
operator|==
name|NULL
operator|||
name|catd
operator|==
name|NLERR
condition|)
block|{
name|errno
operator|=
name|EBADF
expr_stmt|;
comment|/* LINTED interface problem */
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|s
operator|)
return|;
block|}
name|cat_hdr
operator|=
operator|(
expr|struct
name|_nls_cat_hdr
operator|*
operator|)
name|catd
operator|->
name|__data
expr_stmt|;
name|set_hdr
operator|=
operator|(
expr|struct
name|_nls_set_hdr
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|catd
operator|->
name|__data
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|_nls_cat_hdr
argument_list|)
operator|)
expr_stmt|;
comment|/* binary search, see knuth algorithm b */
name|l
operator|=
literal|0
expr_stmt|;
name|u
operator|=
name|ntohl
argument_list|(
operator|(
name|u_int32_t
operator|)
name|cat_hdr
operator|->
name|__nsets
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|l
operator|<=
name|u
condition|)
block|{
name|i
operator|=
operator|(
name|l
operator|+
name|u
operator|)
operator|/
literal|2
expr_stmt|;
name|r
operator|=
name|set_id
operator|-
name|ntohl
argument_list|(
operator|(
name|u_int32_t
operator|)
name|set_hdr
index|[
name|i
index|]
operator|.
name|__setno
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
name|msg_hdr
operator|=
operator|(
expr|struct
name|_nls_msg_hdr
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|catd
operator|->
name|__data
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|_nls_cat_hdr
argument_list|)
operator|+
name|ntohl
argument_list|(
operator|(
name|u_int32_t
operator|)
name|cat_hdr
operator|->
name|__msg_hdr_offset
argument_list|)
operator|)
expr_stmt|;
name|l
operator|=
name|ntohl
argument_list|(
operator|(
name|u_int32_t
operator|)
name|set_hdr
index|[
name|i
index|]
operator|.
name|__index
argument_list|)
expr_stmt|;
name|u
operator|=
name|l
operator|+
name|ntohl
argument_list|(
operator|(
name|u_int32_t
operator|)
name|set_hdr
index|[
name|i
index|]
operator|.
name|__nmsgs
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|l
operator|<=
name|u
condition|)
block|{
name|i
operator|=
operator|(
name|l
operator|+
name|u
operator|)
operator|/
literal|2
expr_stmt|;
name|r
operator|=
name|msg_id
operator|-
name|ntohl
argument_list|(
operator|(
name|u_int32_t
operator|)
name|msg_hdr
index|[
name|i
index|]
operator|.
name|__msgno
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
literal|0
condition|)
block|{
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|catd
operator|->
name|__data
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|_nls_cat_hdr
argument_list|)
operator|+
name|ntohl
argument_list|(
operator|(
name|u_int32_t
operator|)
name|cat_hdr
operator|->
name|__msg_txt_offset
argument_list|)
operator|+
name|ntohl
argument_list|(
operator|(
name|u_int32_t
operator|)
name|msg_hdr
index|[
name|i
index|]
operator|.
name|__offset
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|u
operator|=
name|i
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|l
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/* not found */
goto|goto
name|notfound
goto|;
block|}
elseif|else
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|u
operator|=
name|i
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|l
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|notfound
label|:
comment|/* not found */
name|errno
operator|=
name|ENOMSG
expr_stmt|;
comment|/* LINTED interface problem */
return|return
operator|(
operator|(
name|char
operator|*
operator|)
name|s
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|catfree
parameter_list|(
name|struct
name|catentry
modifier|*
name|np
parameter_list|)
block|{
if|if
condition|(
name|np
operator|->
name|catd
operator|!=
name|NULL
operator|&&
name|np
operator|->
name|catd
operator|!=
name|NLERR
condition|)
block|{
name|munmap
argument_list|(
name|np
operator|->
name|catd
operator|->
name|__data
argument_list|,
operator|(
name|size_t
operator|)
name|np
operator|->
name|catd
operator|->
name|__size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|np
operator|->
name|catd
argument_list|)
expr_stmt|;
block|}
name|SLIST_REMOVE
argument_list|(
operator|&
name|cache
argument_list|,
name|np
argument_list|,
name|catentry
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|np
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|np
operator|->
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|np
operator|->
name|lang
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|catclose
parameter_list|(
name|nl_catd
name|catd
parameter_list|)
block|{
name|struct
name|catentry
modifier|*
name|np
decl_stmt|;
comment|/* sanity checking */
if|if
condition|(
name|catd
operator|==
name|NULL
operator|||
name|catd
operator|==
name|NLERR
condition|)
block|{
name|errno
operator|=
name|EBADF
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Remove from cache if not referenced any more */
name|WLOCK
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|np
argument_list|,
argument|&cache
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
name|catd
operator|==
name|np
operator|->
name|catd
condition|)
block|{
name|np
operator|->
name|refcount
operator|--
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|refcount
operator|==
literal|0
condition|)
name|catfree
argument_list|(
name|np
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|UNLOCK
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Internal support functions  */
end_comment

begin_function
specifier|static
name|nl_catd
name|load_msgcat
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|lang
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|nl_catd
name|catd
decl_stmt|;
name|struct
name|catentry
modifier|*
name|np
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
name|int
name|fd
decl_stmt|;
comment|/* path/name will never be NULL here */
comment|/* 	 * One more try in cache; if it was not found by name, 	 * it might still be found by absolute path. 	 */
name|RLOCK
argument_list|(
name|NLERR
argument_list|)
expr_stmt|;
name|SLIST_FOREACH
argument_list|(
argument|np
argument_list|,
argument|&cache
argument_list|,
argument|list
argument_list|)
block|{
if|if
condition|(
operator|(
name|np
operator|->
name|path
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|np
operator|->
name|path
argument_list|,
name|path
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|np
operator|->
name|refcount
operator|++
expr_stmt|;
name|UNLOCK
expr_stmt|;
return|return
operator|(
name|np
operator|->
name|catd
operator|)
return|;
block|}
block|}
name|UNLOCK
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|_open
argument_list|(
name|path
argument_list|,
name|O_RDONLY
operator||
name|O_CLOEXEC
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|SAVEFAIL
argument_list|(
name|name
argument_list|,
name|lang
argument_list|,
name|errno
argument_list|)
expr_stmt|;
name|NLRETERR
argument_list|(
name|errno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|_fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|st
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|SAVEFAIL
argument_list|(
name|name
argument_list|,
name|lang
argument_list|,
name|EFTYPE
argument_list|)
expr_stmt|;
name|NLRETERR
argument_list|(
name|EFTYPE
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the file size cannot be held in size_t we cannot mmap() 	 * it to the memory.  Probably, this will not be a problem given 	 * that catalog files are usually small. 	 */
if|if
condition|(
name|st
operator|.
name|st_size
operator|>
name|SIZE_T_MAX
condition|)
block|{
name|_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|SAVEFAIL
argument_list|(
name|name
argument_list|,
name|lang
argument_list|,
name|EFBIG
argument_list|)
expr_stmt|;
name|NLRETERR
argument_list|(
name|EFBIG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|data
operator|=
name|mmap
argument_list|(
literal|0
argument_list|,
operator|(
name|size_t
operator|)
name|st
operator|.
name|st_size
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_FILE
operator||
name|MAP_SHARED
argument_list|,
name|fd
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|)
operator|)
operator|==
name|MAP_FAILED
condition|)
block|{
name|int
name|saved_errno
init|=
name|errno
decl_stmt|;
name|_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|SAVEFAIL
argument_list|(
name|name
argument_list|,
name|lang
argument_list|,
name|saved_errno
argument_list|)
expr_stmt|;
name|NLRETERR
argument_list|(
name|saved_errno
argument_list|)
expr_stmt|;
block|}
name|_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntohl
argument_list|(
call|(
name|u_int32_t
call|)
argument_list|(
operator|(
expr|struct
name|_nls_cat_hdr
operator|*
operator|)
name|data
argument_list|)
operator|->
name|__magic
argument_list|)
operator|!=
name|_NLS_MAGIC
condition|)
block|{
name|munmap
argument_list|(
name|data
argument_list|,
operator|(
name|size_t
operator|)
name|st
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|SAVEFAIL
argument_list|(
name|name
argument_list|,
name|lang
argument_list|,
name|EFTYPE
argument_list|)
expr_stmt|;
name|NLRETERR
argument_list|(
name|EFTYPE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|catd
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|catd
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|munmap
argument_list|(
name|data
argument_list|,
operator|(
name|size_t
operator|)
name|st
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|SAVEFAIL
argument_list|(
name|name
argument_list|,
name|lang
argument_list|,
name|ENOMEM
argument_list|)
expr_stmt|;
name|NLRETERR
argument_list|(
name|ENOMEM
argument_list|)
expr_stmt|;
block|}
name|catd
operator|->
name|__data
operator|=
name|data
expr_stmt|;
name|catd
operator|->
name|__size
operator|=
operator|(
name|int
operator|)
name|st
operator|.
name|st_size
expr_stmt|;
comment|/* Caching opened catalog */
name|WLOCK
argument_list|(
name|NLERR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|np
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|catentry
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|np
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|np
operator|->
name|path
operator|=
name|strdup
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|np
operator|->
name|catd
operator|=
name|catd
expr_stmt|;
name|np
operator|->
name|lang
operator|=
operator|(
name|lang
operator|==
name|NULL
operator|)
condition|?
name|NULL
else|:
name|strdup
argument_list|(
name|lang
argument_list|)
expr_stmt|;
name|np
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
name|np
operator|->
name|caterrno
operator|=
literal|0
expr_stmt|;
name|SLIST_INSERT_HEAD
argument_list|(
operator|&
name|cache
argument_list|,
name|np
argument_list|,
name|list
argument_list|)
expr_stmt|;
block|}
name|UNLOCK
expr_stmt|;
return|return
operator|(
name|catd
operator|)
return|;
block|}
end_function

end_unit

