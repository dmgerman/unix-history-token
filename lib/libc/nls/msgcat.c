begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$Id: msgcat.c,v 1.11 1997/05/10 04:40:40 ache Exp $ */
end_comment

begin_comment
comment|/*********************************************************** Copyright 1990, by Alfalfa Software Incorporated, Cambridge, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that Alfalfa's name not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  ALPHALPHA DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL ALPHALPHA BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  If you make any modifications, bugfixes or other changes to this software we'd appreciate it if you could send a copy to us so we can keep things up-to-date.  Many thanks. 				Kee Hinckley 				Alfalfa Software, Inc. 				267 Allston St., #3 				Cambridge, MA 02139  USA 				nazgul@alfalfa.com  ******************************************************************/
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$NetBSD: msgcat.c,v 1.11 1995/02/27 13:06:51 cgd Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBC_SCCS and not lint */
end_comment

begin_comment
comment|/* Edit History  03/06/91   4 schulert	remove working directory from nlspath 01/18/91   2 hamilton	#if not rescanned 01/12/91   3 schulert	conditionally use prototypes 11/03/90   1 hamilton	Alphalpha->Alfalfa& OmegaMail->Poste 10/15/90   2 schulert> #include<unistd.h> if MIPS 08/13/90   1 schulert	move from ua to omu */
end_comment

begin_comment
comment|/*  * We need a better way of handling errors than printing text.  I need  * to add an error handling routine.  */
end_comment

begin_include
include|#
directive|include
file|"nl_types.h"
end_include

begin_include
include|#
directive|include
file|"msgcat.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|True
end_ifndef

begin_define
define|#
directive|define
name|True
value|~0
end_define

begin_define
define|#
directive|define
name|False
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* take care of sysv diffs */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAXPATHLEN
end_ifndef

begin_define
define|#
directive|define
name|MAXPATHLEN
value|1024
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FD_CLOEXEC
end_ifndef

begin_define
define|#
directive|define
name|FD_CLOEXEC
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NLERR
value|((nl_catd) -1)
end_define

begin_function_decl
specifier|static
name|nl_catd
name|loadCat
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|nl_catd
name|loadSet
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|nl_catd
name|_catopen
parameter_list|(
name|name
parameter_list|,
name|type
parameter_list|)
name|__const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
name|char
name|path
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|__const
name|char
modifier|*
name|catpath
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|nlspath
decl_stmt|;
name|char
modifier|*
name|lang
decl_stmt|;
name|long
name|len
decl_stmt|;
name|char
modifier|*
name|base
decl_stmt|,
modifier|*
name|cptr
decl_stmt|,
modifier|*
name|pathP
decl_stmt|;
name|struct
name|stat
name|sbuf
decl_stmt|;
if|if
condition|(
operator|!
name|name
operator|||
operator|!
operator|*
name|name
condition|)
return|return
operator|(
name|NLERR
operator|)
return|;
if|if
condition|(
name|strchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
condition|)
block|{
name|catpath
operator|=
name|name
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|catpath
argument_list|,
operator|&
name|sbuf
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|lang
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"LANG"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|lang
operator|=
literal|"C"
expr_stmt|;
if|if
condition|(
operator|(
name|nlspath
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"NLSPATH"
argument_list|)
operator|)
operator|==
name|NULL
ifndef|#
directive|ifndef
name|__NETBSD_SYSCALLS
operator|||
name|issetugid
argument_list|()
endif|#
directive|endif
condition|)
name|nlspath
operator|=
literal|"/usr/share/nls/%L/%N.cat:/usr/share/nls/%N/%L:/usr/local/share/nls/%L/%N.cat:/usr/local/share/nls/%N/%L"
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|nlspath
argument_list|)
expr_stmt|;
name|base
operator|=
name|cptr
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|base
condition|)
return|return
operator|(
name|NLERR
operator|)
return|;
name|strcpy
argument_list|(
name|cptr
argument_list|,
name|nlspath
argument_list|)
expr_stmt|;
name|cptr
index|[
name|len
index|]
operator|=
literal|':'
expr_stmt|;
name|cptr
index|[
name|len
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|nlspath
operator|=
name|cptr
init|;
operator|*
name|cptr
condition|;
operator|++
name|cptr
control|)
block|{
if|if
condition|(
operator|*
name|cptr
operator|==
literal|':'
condition|)
block|{
operator|*
name|cptr
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|pathP
operator|=
name|path
init|;
operator|*
name|nlspath
condition|;
operator|++
name|nlspath
control|)
block|{
if|if
condition|(
operator|*
name|nlspath
operator|==
literal|'%'
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|nlspath
operator|+
literal|1
operator|)
operator|==
literal|'L'
condition|)
block|{
operator|++
name|nlspath
expr_stmt|;
name|strcpy
argument_list|(
name|pathP
argument_list|,
name|lang
argument_list|)
expr_stmt|;
name|pathP
operator|+=
name|strlen
argument_list|(
name|lang
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|(
name|nlspath
operator|+
literal|1
operator|)
operator|==
literal|'N'
condition|)
block|{
operator|++
name|nlspath
expr_stmt|;
name|strcpy
argument_list|(
name|pathP
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|pathP
operator|+=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
operator|(
name|pathP
operator|++
operator|)
operator|=
operator|*
name|nlspath
expr_stmt|;
block|}
else|else
operator|*
operator|(
name|pathP
operator|++
operator|)
operator|=
operator|*
name|nlspath
expr_stmt|;
block|}
operator|*
name|pathP
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|==
literal|0
condition|)
block|{
name|catpath
operator|=
name|path
expr_stmt|;
break|break;
block|}
name|nlspath
operator|=
name|cptr
operator|+
literal|1
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|base
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|catpath
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|loadCat
argument_list|(
name|catpath
argument_list|,
name|type
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We've got an odd situation here.  The odds are real good that the  * number we are looking for is almost the same as the index.  We could  * use the index, check the difference and do something intelligent, but  * I haven't quite figured out what's intelligent.  *  * Here's a start.  *	Take an id N.  If there are> N items in the list, then N cannot  *	be more than N items from the start, since otherwise there would  *	have to be duplicate items.  So we can safely set the top to N+1  *	(after taking into account that ids start at 1, and arrays at 0)  *  *	Let's say we are at position P, and we are looking for N, but have  *	V.  If N> V, then the furthest away that N could be is  *	P + (N-V).  So we can safely set hi to P+(N-V)+1.  For example:  *		We are looking for 10, but have 8  *		8	?	?	?	?  *>=9>=10>=11  *  */
end_comment

begin_function
specifier|static
name|MCSetT
modifier|*
name|MCGetSet
parameter_list|(
name|cat
parameter_list|,
name|setId
parameter_list|)
name|MCCatT
modifier|*
name|cat
decl_stmt|;
name|int
name|setId
decl_stmt|;
block|{
name|MCSetT
modifier|*
name|set
decl_stmt|;
name|long
name|lo
decl_stmt|,
name|hi
decl_stmt|,
name|cur
decl_stmt|,
name|dir
decl_stmt|;
if|if
condition|(
operator|!
name|cat
operator|||
name|setId
operator|<=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|lo
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|setId
operator|-
literal|1
operator|<
name|cat
operator|->
name|numSets
condition|)
block|{
name|cur
operator|=
name|setId
operator|-
literal|1
expr_stmt|;
name|hi
operator|=
name|setId
expr_stmt|;
block|}
else|else
block|{
name|hi
operator|=
name|cat
operator|->
name|numSets
expr_stmt|;
name|cur
operator|=
operator|(
name|hi
operator|-
name|lo
operator|)
operator|/
literal|2
expr_stmt|;
block|}
while|while
condition|(
name|True
condition|)
block|{
name|set
operator|=
name|cat
operator|->
name|sets
operator|+
name|cur
expr_stmt|;
if|if
condition|(
name|set
operator|->
name|setId
operator|==
name|setId
condition|)
break|break;
if|if
condition|(
name|set
operator|->
name|setId
operator|<
name|setId
condition|)
block|{
name|lo
operator|=
name|cur
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|hi
operator|>
name|cur
operator|+
operator|(
name|setId
operator|-
name|set
operator|->
name|setId
operator|)
operator|+
literal|1
condition|)
name|hi
operator|=
name|cur
operator|+
operator|(
name|setId
operator|-
name|set
operator|->
name|setId
operator|)
operator|+
literal|1
expr_stmt|;
name|dir
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|hi
operator|=
name|cur
expr_stmt|;
name|dir
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|lo
operator|>=
name|hi
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|hi
operator|-
name|lo
operator|==
literal|1
condition|)
name|cur
operator|+=
name|dir
expr_stmt|;
else|else
name|cur
operator|+=
operator|(
operator|(
name|hi
operator|-
name|lo
operator|)
operator|/
literal|2
operator|)
operator|*
name|dir
expr_stmt|;
block|}
if|if
condition|(
name|set
operator|->
name|invalid
condition|)
name|loadSet
argument_list|(
name|cat
argument_list|,
name|set
argument_list|)
expr_stmt|;
return|return
operator|(
name|set
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|MCMsgT
modifier|*
name|MCGetMsg
parameter_list|(
name|set
parameter_list|,
name|msgId
parameter_list|)
name|MCSetT
modifier|*
name|set
decl_stmt|;
name|int
name|msgId
decl_stmt|;
block|{
name|MCMsgT
modifier|*
name|msg
decl_stmt|;
name|long
name|lo
decl_stmt|,
name|hi
decl_stmt|,
name|cur
decl_stmt|,
name|dir
decl_stmt|;
if|if
condition|(
operator|!
name|set
operator|||
name|set
operator|->
name|invalid
operator|||
name|msgId
operator|<=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|lo
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|msgId
operator|-
literal|1
operator|<
name|set
operator|->
name|numMsgs
condition|)
block|{
name|cur
operator|=
name|msgId
operator|-
literal|1
expr_stmt|;
name|hi
operator|=
name|msgId
expr_stmt|;
block|}
else|else
block|{
name|hi
operator|=
name|set
operator|->
name|numMsgs
expr_stmt|;
name|cur
operator|=
operator|(
name|hi
operator|-
name|lo
operator|)
operator|/
literal|2
expr_stmt|;
block|}
while|while
condition|(
name|True
condition|)
block|{
name|msg
operator|=
name|set
operator|->
name|u
operator|.
name|msgs
operator|+
name|cur
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|msgId
operator|==
name|msgId
condition|)
break|break;
if|if
condition|(
name|msg
operator|->
name|msgId
operator|<
name|msgId
condition|)
block|{
name|lo
operator|=
name|cur
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|hi
operator|>
name|cur
operator|+
operator|(
name|msgId
operator|-
name|msg
operator|->
name|msgId
operator|)
operator|+
literal|1
condition|)
name|hi
operator|=
name|cur
operator|+
operator|(
name|msgId
operator|-
name|msg
operator|->
name|msgId
operator|)
operator|+
literal|1
expr_stmt|;
name|dir
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|hi
operator|=
name|cur
expr_stmt|;
name|dir
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|lo
operator|>=
name|hi
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|hi
operator|-
name|lo
operator|==
literal|1
condition|)
name|cur
operator|+=
name|dir
expr_stmt|;
else|else
name|cur
operator|+=
operator|(
operator|(
name|hi
operator|-
name|lo
operator|)
operator|/
literal|2
operator|)
operator|*
name|dir
expr_stmt|;
block|}
return|return
operator|(
name|msg
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|_catgets
parameter_list|(
name|catd
parameter_list|,
name|setId
parameter_list|,
name|msgId
parameter_list|,
name|dflt
parameter_list|)
name|nl_catd
name|catd
decl_stmt|;
name|int
name|setId
decl_stmt|;
name|int
name|msgId
decl_stmt|;
name|char
modifier|*
name|dflt
decl_stmt|;
block|{
name|MCMsgT
modifier|*
name|msg
decl_stmt|;
name|MCCatT
modifier|*
name|cat
init|=
operator|(
name|MCCatT
operator|*
operator|)
name|catd
decl_stmt|;
name|char
modifier|*
name|cptr
decl_stmt|;
name|msg
operator|=
name|MCGetMsg
argument_list|(
name|MCGetSet
argument_list|(
name|cat
argument_list|,
name|setId
argument_list|)
argument_list|,
name|msgId
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
condition|)
name|cptr
operator|=
name|msg
operator|->
name|msg
operator|.
name|str
expr_stmt|;
else|else
name|cptr
operator|=
name|dflt
expr_stmt|;
return|return
operator|(
name|cptr
operator|)
return|;
block|}
end_function

begin_function
name|int
name|_catclose
parameter_list|(
name|catd
parameter_list|)
name|nl_catd
name|catd
decl_stmt|;
block|{
name|MCCatT
modifier|*
name|cat
init|=
operator|(
name|MCCatT
operator|*
operator|)
name|catd
decl_stmt|;
name|MCSetT
modifier|*
name|set
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|cat
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|cat
operator|->
name|loadType
operator|!=
name|MCLoadAll
condition|)
name|close
argument_list|(
name|cat
operator|->
name|fd
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cat
operator|->
name|numSets
condition|;
operator|++
name|i
control|)
block|{
name|set
operator|=
name|cat
operator|->
name|sets
operator|+
name|i
expr_stmt|;
if|if
condition|(
operator|!
name|set
operator|->
name|invalid
condition|)
block|{
name|free
argument_list|(
name|set
operator|->
name|data
operator|.
name|str
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|set
operator|->
name|u
operator|.
name|msgs
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|cat
operator|->
name|sets
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cat
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Internal routines  */
end_comment

begin_comment
comment|/* Note that only malloc failures are allowed to return an error */
end_comment

begin_define
define|#
directive|define
name|ERRNAME
value|"Message Catalog System"
end_define

begin_define
define|#
directive|define
name|CORRUPT
parameter_list|()
value|{fprintf(stderr, "%s: corrupt file.\n", ERRNAME); free(cat); return(0);}
end_define

begin_define
define|#
directive|define
name|NOSPACE
parameter_list|()
value|{fprintf(stderr, "%s: no more memory.\n", ERRNAME); free(cat); return(NLERR);}
end_define

begin_function
specifier|static
name|nl_catd
name|loadCat
parameter_list|(
name|catpath
parameter_list|,
name|type
parameter_list|)
name|__const
name|char
modifier|*
name|catpath
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
name|MCHeaderT
name|header
decl_stmt|;
name|MCCatT
modifier|*
name|cat
decl_stmt|;
name|MCSetT
modifier|*
name|set
decl_stmt|;
name|long
name|i
decl_stmt|,
name|j
decl_stmt|;
name|off_t
name|nextSet
decl_stmt|;
name|cat
operator|=
operator|(
name|MCCatT
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|MCCatT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cat
condition|)
return|return
operator|(
name|NLERR
operator|)
return|;
name|cat
operator|->
name|loadType
operator|=
name|type
expr_stmt|;
if|if
condition|(
operator|(
name|cat
operator|->
name|fd
operator|=
name|open
argument_list|(
name|catpath
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|free
argument_list|(
name|cat
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|cat
operator|->
name|fd
argument_list|,
name|F_SETFD
argument_list|,
name|FD_CLOEXEC
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|cat
operator|->
name|fd
argument_list|,
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
name|header
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|header
argument_list|)
condition|)
name|CORRUPT
argument_list|()
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|header
operator|.
name|magic
argument_list|,
name|MCMagic
argument_list|,
name|MCMagicLen
argument_list|)
operator|!=
literal|0
condition|)
name|CORRUPT
argument_list|()
expr_stmt|;
if|if
condition|(
name|header
operator|.
name|majorVer
operator|!=
name|MCMajorVer
condition|)
block|{
name|free
argument_list|(
name|cat
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s is version %ld, we need %ld.\n"
argument_list|,
name|ERRNAME
argument_list|,
name|catpath
argument_list|,
name|header
operator|.
name|majorVer
argument_list|,
name|MCMajorVer
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|header
operator|.
name|numSets
operator|<=
literal|0
condition|)
block|{
name|free
argument_list|(
name|cat
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s has %ld sets!\n"
argument_list|,
name|ERRNAME
argument_list|,
name|catpath
argument_list|,
name|header
operator|.
name|numSets
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cat
operator|->
name|numSets
operator|=
name|header
operator|.
name|numSets
expr_stmt|;
name|cat
operator|->
name|sets
operator|=
operator|(
name|MCSetT
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|MCSetT
argument_list|)
operator|*
name|header
operator|.
name|numSets
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cat
operator|->
name|sets
condition|)
name|NOSPACE
argument_list|()
expr_stmt|;
name|nextSet
operator|=
name|header
operator|.
name|firstSet
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cat
operator|->
name|numSets
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|lseek
argument_list|(
name|cat
operator|->
name|fd
argument_list|,
name|nextSet
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|set
operator|=
name|cat
operator|->
name|sets
operator|+
name|j
expr_stmt|;
if|if
condition|(
operator|!
name|set
operator|->
name|invalid
condition|)
block|{
name|free
argument_list|(
name|set
operator|->
name|data
operator|.
name|str
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|set
operator|->
name|u
operator|.
name|msgs
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|cat
operator|->
name|sets
argument_list|)
expr_stmt|;
name|CORRUPT
argument_list|()
expr_stmt|;
block|}
comment|/* read in the set header */
name|set
operator|=
name|cat
operator|->
name|sets
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|cat
operator|->
name|fd
argument_list|,
name|set
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|set
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|set
argument_list|)
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|set
operator|=
name|cat
operator|->
name|sets
operator|+
name|j
expr_stmt|;
if|if
condition|(
operator|!
name|set
operator|->
name|invalid
condition|)
block|{
name|free
argument_list|(
name|set
operator|->
name|data
operator|.
name|str
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|set
operator|->
name|u
operator|.
name|msgs
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|cat
operator|->
name|sets
argument_list|)
expr_stmt|;
name|CORRUPT
argument_list|()
expr_stmt|;
block|}
comment|/* if it's invalid, skip over it (and backup 'i') */
if|if
condition|(
name|set
operator|->
name|invalid
condition|)
block|{
operator|--
name|i
expr_stmt|;
name|nextSet
operator|=
name|set
operator|->
name|nextSet
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|cat
operator|->
name|loadType
operator|==
name|MCLoadAll
condition|)
block|{
name|nl_catd
name|res
decl_stmt|;
if|if
condition|(
operator|(
name|res
operator|=
name|loadSet
argument_list|(
name|cat
argument_list|,
name|set
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|i
condition|;
name|j
operator|++
control|)
block|{
name|set
operator|=
name|cat
operator|->
name|sets
operator|+
name|j
expr_stmt|;
if|if
condition|(
operator|!
name|set
operator|->
name|invalid
condition|)
block|{
name|free
argument_list|(
name|set
operator|->
name|data
operator|.
name|str
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|set
operator|->
name|u
operator|.
name|msgs
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|cat
operator|->
name|sets
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|==
operator|-
literal|1
condition|)
name|NOSPACE
argument_list|()
expr_stmt|;
name|CORRUPT
argument_list|()
expr_stmt|;
block|}
block|}
else|else
name|set
operator|->
name|invalid
operator|=
name|True
expr_stmt|;
name|nextSet
operator|=
name|set
operator|->
name|nextSet
expr_stmt|;
block|}
if|if
condition|(
name|cat
operator|->
name|loadType
operator|==
name|MCLoadAll
condition|)
block|{
name|close
argument_list|(
name|cat
operator|->
name|fd
argument_list|)
expr_stmt|;
name|cat
operator|->
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|nl_catd
operator|)
name|cat
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|nl_catd
name|loadSet
parameter_list|(
name|cat
parameter_list|,
name|set
parameter_list|)
name|MCCatT
modifier|*
name|cat
decl_stmt|;
name|MCSetT
modifier|*
name|set
decl_stmt|;
block|{
name|MCMsgT
modifier|*
name|msg
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Get the data */
if|if
condition|(
name|lseek
argument_list|(
name|cat
operator|->
name|fd
argument_list|,
name|set
operator|->
name|data
operator|.
name|off
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|set
operator|->
name|data
operator|.
name|str
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|set
operator|->
name|dataLen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|read
argument_list|(
name|cat
operator|->
name|fd
argument_list|,
name|set
operator|->
name|data
operator|.
name|str
argument_list|,
name|set
operator|->
name|dataLen
argument_list|)
operator|!=
name|set
operator|->
name|dataLen
condition|)
block|{
name|free
argument_list|(
name|set
operator|->
name|data
operator|.
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Get the messages */
if|if
condition|(
name|lseek
argument_list|(
name|cat
operator|->
name|fd
argument_list|,
name|set
operator|->
name|u
operator|.
name|firstMsg
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|free
argument_list|(
name|set
operator|->
name|data
operator|.
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|set
operator|->
name|u
operator|.
name|msgs
operator|=
operator|(
name|MCMsgT
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|MCMsgT
argument_list|)
operator|*
name|set
operator|->
name|numMsgs
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|set
operator|->
name|data
operator|.
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|set
operator|->
name|numMsgs
condition|;
operator|++
name|i
control|)
block|{
name|msg
operator|=
name|set
operator|->
name|u
operator|.
name|msgs
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|cat
operator|->
name|fd
argument_list|,
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|msg
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|msg
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|set
operator|->
name|u
operator|.
name|msgs
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|set
operator|->
name|data
operator|.
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|msg
operator|->
name|invalid
condition|)
block|{
operator|--
name|i
expr_stmt|;
continue|continue;
block|}
name|msg
operator|->
name|msg
operator|.
name|str
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|set
operator|->
name|data
operator|.
name|str
operator|+
name|msg
operator|->
name|msg
operator|.
name|off
operator|)
expr_stmt|;
block|}
name|set
operator|->
name|invalid
operator|=
name|False
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

end_unit

