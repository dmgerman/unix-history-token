begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993, 1994 Henry Spencer.  * Copyright (c) 1992, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  *  * Copyright (c) 2011 The FreeBSD Foundation  * All rights reserved.  * Portions of this software were developed by David Chisnall  * under sponsorship from the FreeBSD Foundation.  *  * This code is derived from software contributed to Berkeley by  * Henry Spencer.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)regcomp.c	8.5 (Berkeley) 3/20/94  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)regcomp.c	8.5 (Berkeley) 3/20/94"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBC_SCCS and not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_include
include|#
directive|include
file|<runetype.h>
end_include

begin_include
include|#
directive|include
file|<wchar.h>
end_include

begin_include
include|#
directive|include
file|<wctype.h>
end_include

begin_include
include|#
directive|include
file|"collate.h"
end_include

begin_include
include|#
directive|include
file|"utils.h"
end_include

begin_include
include|#
directive|include
file|"regex2.h"
end_include

begin_include
include|#
directive|include
file|"cname.h"
end_include

begin_comment
comment|/*  * parse structure, passed up and down to avoid global variables and  * other clumsinesses  */
end_comment

begin_struct
struct|struct
name|parse
block|{
name|char
modifier|*
name|next
decl_stmt|;
comment|/* next character in RE */
name|char
modifier|*
name|end
decl_stmt|;
comment|/* end of string (-> NUL normally) */
name|int
name|error
decl_stmt|;
comment|/* has an error been seen? */
name|sop
modifier|*
name|strip
decl_stmt|;
comment|/* malloced strip */
name|sopno
name|ssize
decl_stmt|;
comment|/* malloced strip size (allocated) */
name|sopno
name|slen
decl_stmt|;
comment|/* malloced strip length (used) */
name|int
name|ncsalloc
decl_stmt|;
comment|/* number of csets allocated */
name|struct
name|re_guts
modifier|*
name|g
decl_stmt|;
define|#
directive|define
name|NPAREN
value|10
comment|/* we need to remember () 1-9 for back refs */
name|sopno
name|pbegin
index|[
name|NPAREN
index|]
decl_stmt|;
comment|/* -> ( ([0] unused) */
name|sopno
name|pend
index|[
name|NPAREN
index|]
decl_stmt|;
comment|/* -> ) ([0] unused) */
block|}
struct|;
end_struct

begin_comment
comment|/* ========= begin header generated by ./mkh ========= */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/* === regcomp.c === */
specifier|static
name|void
name|p_ere
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|wint_t
name|stop
parameter_list|)
function_decl|;
specifier|static
name|void
name|p_ere_exp
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|)
function_decl|;
specifier|static
name|void
name|p_str
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|)
function_decl|;
specifier|static
name|void
name|p_bre
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|wint_t
name|end1
parameter_list|,
name|wint_t
name|end2
parameter_list|)
function_decl|;
specifier|static
name|int
name|p_simp_re
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|int
name|starordinary
parameter_list|)
function_decl|;
specifier|static
name|int
name|p_count
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|)
function_decl|;
specifier|static
name|void
name|p_bracket
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|)
function_decl|;
specifier|static
name|void
name|p_b_term
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|cset
modifier|*
name|cs
parameter_list|)
function_decl|;
specifier|static
name|void
name|p_b_cclass
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|cset
modifier|*
name|cs
parameter_list|)
function_decl|;
specifier|static
name|void
name|p_b_eclass
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|cset
modifier|*
name|cs
parameter_list|)
function_decl|;
specifier|static
name|wint_t
name|p_b_symbol
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|)
function_decl|;
specifier|static
name|wint_t
name|p_b_coll_elem
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|wint_t
name|endc
parameter_list|)
function_decl|;
specifier|static
name|wint_t
name|othercase
parameter_list|(
name|wint_t
name|ch
parameter_list|)
function_decl|;
specifier|static
name|void
name|bothcases
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|wint_t
name|ch
parameter_list|)
function_decl|;
specifier|static
name|void
name|ordinary
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|wint_t
name|ch
parameter_list|)
function_decl|;
specifier|static
name|void
name|nonnewline
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|)
function_decl|;
specifier|static
name|void
name|repeat
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|sopno
name|start
parameter_list|,
name|int
name|from
parameter_list|,
name|int
name|to
parameter_list|)
function_decl|;
specifier|static
name|int
name|seterr
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|int
name|e
parameter_list|)
function_decl|;
specifier|static
name|cset
modifier|*
name|allocset
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|)
function_decl|;
specifier|static
name|void
name|freeset
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|cset
modifier|*
name|cs
parameter_list|)
function_decl|;
specifier|static
name|void
name|CHadd
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|cset
modifier|*
name|cs
parameter_list|,
name|wint_t
name|ch
parameter_list|)
function_decl|;
specifier|static
name|void
name|CHaddrange
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|cset
modifier|*
name|cs
parameter_list|,
name|wint_t
name|min
parameter_list|,
name|wint_t
name|max
parameter_list|)
function_decl|;
specifier|static
name|void
name|CHaddtype
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|cset
modifier|*
name|cs
parameter_list|,
name|wctype_t
name|wct
parameter_list|)
function_decl|;
specifier|static
name|wint_t
name|singleton
parameter_list|(
name|cset
modifier|*
name|cs
parameter_list|)
function_decl|;
specifier|static
name|sopno
name|dupl
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|sopno
name|start
parameter_list|,
name|sopno
name|finish
parameter_list|)
function_decl|;
specifier|static
name|void
name|doemit
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|sop
name|op
parameter_list|,
name|size_t
name|opnd
parameter_list|)
function_decl|;
specifier|static
name|void
name|doinsert
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|sop
name|op
parameter_list|,
name|size_t
name|opnd
parameter_list|,
name|sopno
name|pos
parameter_list|)
function_decl|;
specifier|static
name|void
name|dofwd
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|sopno
name|pos
parameter_list|,
name|sop
name|value
parameter_list|)
function_decl|;
specifier|static
name|void
name|enlarge
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|sopno
name|size
parameter_list|)
function_decl|;
specifier|static
name|void
name|stripsnug
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|struct
name|re_guts
modifier|*
name|g
parameter_list|)
function_decl|;
specifier|static
name|void
name|findmust
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|struct
name|re_guts
modifier|*
name|g
parameter_list|)
function_decl|;
specifier|static
name|int
name|altoffset
parameter_list|(
name|sop
modifier|*
name|scan
parameter_list|,
name|int
name|offset
parameter_list|)
function_decl|;
specifier|static
name|void
name|computejumps
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|struct
name|re_guts
modifier|*
name|g
parameter_list|)
function_decl|;
specifier|static
name|void
name|computematchjumps
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|struct
name|re_guts
modifier|*
name|g
parameter_list|)
function_decl|;
specifier|static
name|sopno
name|pluscount
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|struct
name|re_guts
modifier|*
name|g
parameter_list|)
function_decl|;
specifier|static
name|wint_t
name|wgetnext
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ========= end header generated by ./mkh ========= */
end_comment

begin_decl_stmt
specifier|static
name|char
name|nuls
index|[
literal|10
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* place to point scanner in event of error */
end_comment

begin_comment
comment|/*  * macros for use with parse structure  * BEWARE:  these know that the parse structure is named `p' !!!  */
end_comment

begin_define
define|#
directive|define
name|PEEK
parameter_list|()
value|(*p->next)
end_define

begin_define
define|#
directive|define
name|PEEK2
parameter_list|()
value|(*(p->next+1))
end_define

begin_define
define|#
directive|define
name|MORE
parameter_list|()
value|(p->next< p->end)
end_define

begin_define
define|#
directive|define
name|MORE2
parameter_list|()
value|(p->next+1< p->end)
end_define

begin_define
define|#
directive|define
name|SEE
parameter_list|(
name|c
parameter_list|)
value|(MORE()&& PEEK() == (c))
end_define

begin_define
define|#
directive|define
name|SEETWO
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(MORE()&& MORE2()&& PEEK() == (a)&& PEEK2() == (b))
end_define

begin_define
define|#
directive|define
name|EAT
parameter_list|(
name|c
parameter_list|)
value|((SEE(c)) ? (NEXT(), 1) : 0)
end_define

begin_define
define|#
directive|define
name|EATTWO
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((SEETWO(a, b)) ? (NEXT2(), 1) : 0)
end_define

begin_define
define|#
directive|define
name|NEXT
parameter_list|()
value|(p->next++)
end_define

begin_define
define|#
directive|define
name|NEXT2
parameter_list|()
value|(p->next += 2)
end_define

begin_define
define|#
directive|define
name|NEXTn
parameter_list|(
name|n
parameter_list|)
value|(p->next += (n))
end_define

begin_define
define|#
directive|define
name|GETNEXT
parameter_list|()
value|(*p->next++)
end_define

begin_define
define|#
directive|define
name|WGETNEXT
parameter_list|()
value|wgetnext(p)
end_define

begin_define
define|#
directive|define
name|SETERROR
parameter_list|(
name|e
parameter_list|)
value|seterr(p, (e))
end_define

begin_define
define|#
directive|define
name|REQUIRE
parameter_list|(
name|co
parameter_list|,
name|e
parameter_list|)
value|((co) || SETERROR(e))
end_define

begin_define
define|#
directive|define
name|MUSTSEE
parameter_list|(
name|c
parameter_list|,
name|e
parameter_list|)
value|(REQUIRE(MORE()&& PEEK() == (c), e))
end_define

begin_define
define|#
directive|define
name|MUSTEAT
parameter_list|(
name|c
parameter_list|,
name|e
parameter_list|)
value|(REQUIRE(MORE()&& GETNEXT() == (c), e))
end_define

begin_define
define|#
directive|define
name|MUSTNOTSEE
parameter_list|(
name|c
parameter_list|,
name|e
parameter_list|)
value|(REQUIRE(!MORE() || PEEK() != (c), e))
end_define

begin_define
define|#
directive|define
name|EMIT
parameter_list|(
name|op
parameter_list|,
name|sopnd
parameter_list|)
value|doemit(p, (sop)(op), (size_t)(sopnd))
end_define

begin_define
define|#
directive|define
name|INSERT
parameter_list|(
name|op
parameter_list|,
name|pos
parameter_list|)
value|doinsert(p, (sop)(op), HERE()-(pos)+1, pos)
end_define

begin_define
define|#
directive|define
name|AHEAD
parameter_list|(
name|pos
parameter_list|)
value|dofwd(p, pos, HERE()-(pos))
end_define

begin_define
define|#
directive|define
name|ASTERN
parameter_list|(
name|sop
parameter_list|,
name|pos
parameter_list|)
value|EMIT(sop, HERE()-pos)
end_define

begin_define
define|#
directive|define
name|HERE
parameter_list|()
value|(p->slen)
end_define

begin_define
define|#
directive|define
name|THERE
parameter_list|()
value|(p->slen - 1)
end_define

begin_define
define|#
directive|define
name|THERETHERE
parameter_list|()
value|(p->slen - 2)
end_define

begin_define
define|#
directive|define
name|DROP
parameter_list|(
name|n
parameter_list|)
value|(p->slen -= (n))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|NDEBUG
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|never
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for use in asserts; shuts lint up */
end_comment

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|never
value|0
end_define

begin_comment
comment|/* some<assert.h>s have bugs too */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Macro used by computejump()/computematchjump() */
end_comment

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)<(b)?(a):(b))
end_define

begin_comment
comment|/*  - regcomp - interface for parser and compilation  = extern int regcomp(regex_t *, const char *, int);  = #define	REG_BASIC	0000  = #define	REG_EXTENDED	0001  = #define	REG_ICASE	0002  = #define	REG_NOSUB	0004  = #define	REG_NEWLINE	0010  = #define	REG_NOSPEC	0020  = #define	REG_PEND	0040  = #define	REG_DUMP	0200  */
end_comment

begin_function
name|int
comment|/* 0 success, otherwise REG_something */
name|regcomp
parameter_list|(
name|regex_t
modifier|*
name|__restrict
name|preg
parameter_list|,
specifier|const
name|char
modifier|*
name|__restrict
name|pattern
parameter_list|,
name|int
name|cflags
parameter_list|)
block|{
name|struct
name|parse
name|pa
decl_stmt|;
name|struct
name|re_guts
modifier|*
name|g
decl_stmt|;
name|struct
name|parse
modifier|*
name|p
init|=
operator|&
name|pa
decl_stmt|;
name|int
name|i
decl_stmt|;
name|size_t
name|len
decl_stmt|;
ifdef|#
directive|ifdef
name|REDEBUG
define|#
directive|define
name|GOODFLAGS
parameter_list|(
name|f
parameter_list|)
value|(f)
else|#
directive|else
define|#
directive|define
name|GOODFLAGS
parameter_list|(
name|f
parameter_list|)
value|((f)&~REG_DUMP)
endif|#
directive|endif
name|cflags
operator|=
name|GOODFLAGS
argument_list|(
name|cflags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cflags
operator|&
name|REG_EXTENDED
operator|)
operator|&&
operator|(
name|cflags
operator|&
name|REG_NOSPEC
operator|)
condition|)
return|return
operator|(
name|REG_INVARG
operator|)
return|;
if|if
condition|(
name|cflags
operator|&
name|REG_PEND
condition|)
block|{
if|if
condition|(
name|preg
operator|->
name|re_endp
operator|<
name|pattern
condition|)
return|return
operator|(
name|REG_INVARG
operator|)
return|;
name|len
operator|=
name|preg
operator|->
name|re_endp
operator|-
name|pattern
expr_stmt|;
block|}
else|else
name|len
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pattern
argument_list|)
expr_stmt|;
comment|/* do the mallocs early so failure handling is easy */
name|g
operator|=
operator|(
expr|struct
name|re_guts
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|re_guts
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
return|return
operator|(
name|REG_ESPACE
operator|)
return|;
name|p
operator|->
name|ssize
operator|=
name|len
operator|/
operator|(
name|size_t
operator|)
literal|2
operator|*
operator|(
name|size_t
operator|)
literal|3
operator|+
operator|(
name|size_t
operator|)
literal|1
expr_stmt|;
comment|/* ugh */
name|p
operator|->
name|strip
operator|=
operator|(
name|sop
operator|*
operator|)
name|malloc
argument_list|(
name|p
operator|->
name|ssize
operator|*
sizeof|sizeof
argument_list|(
name|sop
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|slen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|strip
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|g
argument_list|)
expr_stmt|;
return|return
operator|(
name|REG_ESPACE
operator|)
return|;
block|}
comment|/* set things up */
name|p
operator|->
name|g
operator|=
name|g
expr_stmt|;
name|p
operator|->
name|next
operator|=
operator|(
name|char
operator|*
operator|)
name|pattern
expr_stmt|;
comment|/* convenience; we do not modify it */
name|p
operator|->
name|end
operator|=
name|p
operator|->
name|next
operator|+
name|len
expr_stmt|;
name|p
operator|->
name|error
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|ncsalloc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NPAREN
condition|;
name|i
operator|++
control|)
block|{
name|p
operator|->
name|pbegin
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|pend
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|g
operator|->
name|sets
operator|=
name|NULL
expr_stmt|;
name|g
operator|->
name|ncsets
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|cflags
operator|=
name|cflags
expr_stmt|;
name|g
operator|->
name|iflags
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|nbol
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|neol
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|must
operator|=
name|NULL
expr_stmt|;
name|g
operator|->
name|moffset
operator|=
operator|-
literal|1
expr_stmt|;
name|g
operator|->
name|charjump
operator|=
name|NULL
expr_stmt|;
name|g
operator|->
name|matchjump
operator|=
name|NULL
expr_stmt|;
name|g
operator|->
name|mlen
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|nsub
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|backrefs
operator|=
literal|0
expr_stmt|;
comment|/* do it */
name|EMIT
argument_list|(
name|OEND
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g
operator|->
name|firststate
operator|=
name|THERE
argument_list|()
expr_stmt|;
if|if
condition|(
name|cflags
operator|&
name|REG_EXTENDED
condition|)
name|p_ere
argument_list|(
name|p
argument_list|,
name|OUT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cflags
operator|&
name|REG_NOSPEC
condition|)
name|p_str
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|p_bre
argument_list|(
name|p
argument_list|,
name|OUT
argument_list|,
name|OUT
argument_list|)
expr_stmt|;
name|EMIT
argument_list|(
name|OEND
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g
operator|->
name|laststate
operator|=
name|THERE
argument_list|()
expr_stmt|;
comment|/* tidy up loose ends and fill things in */
name|stripsnug
argument_list|(
name|p
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|findmust
argument_list|(
name|p
argument_list|,
name|g
argument_list|)
expr_stmt|;
comment|/* only use Boyer-Moore algorithm if the pattern is bigger 	 * than three characters 	 */
if|if
condition|(
name|g
operator|->
name|mlen
operator|>
literal|3
condition|)
block|{
name|computejumps
argument_list|(
name|p
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|computematchjumps
argument_list|(
name|p
argument_list|,
name|g
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|matchjump
operator|==
name|NULL
operator|&&
name|g
operator|->
name|charjump
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|g
operator|->
name|charjump
argument_list|)
expr_stmt|;
name|g
operator|->
name|charjump
operator|=
name|NULL
expr_stmt|;
block|}
block|}
name|g
operator|->
name|nplus
operator|=
name|pluscount
argument_list|(
name|p
argument_list|,
name|g
argument_list|)
expr_stmt|;
name|g
operator|->
name|magic
operator|=
name|MAGIC2
expr_stmt|;
name|preg
operator|->
name|re_nsub
operator|=
name|g
operator|->
name|nsub
expr_stmt|;
name|preg
operator|->
name|re_g
operator|=
name|g
expr_stmt|;
name|preg
operator|->
name|re_magic
operator|=
name|MAGIC1
expr_stmt|;
ifndef|#
directive|ifndef
name|REDEBUG
comment|/* not debugging, so can't rely on the assert() in regexec() */
if|if
condition|(
name|g
operator|->
name|iflags
operator|&
name|BAD
condition|)
name|SETERROR
argument_list|(
name|REG_ASSERT
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* win or lose, we're done */
if|if
condition|(
name|p
operator|->
name|error
operator|!=
literal|0
condition|)
comment|/* lose */
name|regfree
argument_list|(
name|preg
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|->
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - p_ere - ERE parser top level, concatenation and alternation  == static void p_ere(struct parse *p, int stop);  */
end_comment

begin_function
specifier|static
name|void
name|p_ere
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|int
name|stop
parameter_list|)
comment|/* character this ERE should end at */
block|{
name|char
name|c
decl_stmt|;
name|sopno
name|prevback
decl_stmt|;
name|sopno
name|prevfwd
decl_stmt|;
name|sopno
name|conc
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
comment|/* is this the first alternative? */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* do a bunch of concatenated expressions */
name|conc
operator|=
name|HERE
argument_list|()
expr_stmt|;
while|while
condition|(
name|MORE
argument_list|()
operator|&&
operator|(
name|c
operator|=
name|PEEK
argument_list|()
operator|)
operator|!=
literal|'|'
operator|&&
name|c
operator|!=
name|stop
condition|)
name|p_ere_exp
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|REQUIRE
argument_list|(
name|HERE
argument_list|()
operator|!=
name|conc
argument_list|,
name|REG_EMPTY
argument_list|)
expr_stmt|;
comment|/* require nonempty */
if|if
condition|(
operator|!
name|EAT
argument_list|(
literal|'|'
argument_list|)
condition|)
break|break;
comment|/* NOTE BREAK OUT */
if|if
condition|(
name|first
condition|)
block|{
name|INSERT
argument_list|(
name|OCH_
argument_list|,
name|conc
argument_list|)
expr_stmt|;
comment|/* offset is wrong */
name|prevfwd
operator|=
name|conc
expr_stmt|;
name|prevback
operator|=
name|conc
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
name|ASTERN
argument_list|(
name|OOR1
argument_list|,
name|prevback
argument_list|)
expr_stmt|;
name|prevback
operator|=
name|THERE
argument_list|()
expr_stmt|;
name|AHEAD
argument_list|(
name|prevfwd
argument_list|)
expr_stmt|;
comment|/* fix previous offset */
name|prevfwd
operator|=
name|HERE
argument_list|()
expr_stmt|;
name|EMIT
argument_list|(
name|OOR2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* offset is very wrong */
block|}
if|if
condition|(
operator|!
name|first
condition|)
block|{
comment|/* tail-end fixups */
name|AHEAD
argument_list|(
name|prevfwd
argument_list|)
expr_stmt|;
name|ASTERN
argument_list|(
name|O_CH
argument_list|,
name|prevback
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
operator|!
name|MORE
argument_list|()
operator|||
name|SEE
argument_list|(
name|stop
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - p_ere_exp - parse one subERE, an atom possibly followed by a repetition op  == static void p_ere_exp(struct parse *p);  */
end_comment

begin_function
specifier|static
name|void
name|p_ere_exp
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
name|wint_t
name|wc
decl_stmt|;
name|sopno
name|pos
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|count2
decl_stmt|;
name|sopno
name|subno
decl_stmt|;
name|int
name|wascaret
init|=
literal|0
decl_stmt|;
name|assert
argument_list|(
name|MORE
argument_list|()
argument_list|)
expr_stmt|;
comment|/* caller should have ensured this */
name|c
operator|=
name|GETNEXT
argument_list|()
expr_stmt|;
name|pos
operator|=
name|HERE
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'('
case|:
operator|(
name|void
operator|)
name|REQUIRE
argument_list|(
name|MORE
argument_list|()
argument_list|,
name|REG_EPAREN
argument_list|)
expr_stmt|;
name|p
operator|->
name|g
operator|->
name|nsub
operator|++
expr_stmt|;
name|subno
operator|=
name|p
operator|->
name|g
operator|->
name|nsub
expr_stmt|;
if|if
condition|(
name|subno
operator|<
name|NPAREN
condition|)
name|p
operator|->
name|pbegin
index|[
name|subno
index|]
operator|=
name|HERE
argument_list|()
expr_stmt|;
name|EMIT
argument_list|(
name|OLPAREN
argument_list|,
name|subno
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SEE
argument_list|(
literal|')'
argument_list|)
condition|)
name|p_ere
argument_list|(
name|p
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|subno
operator|<
name|NPAREN
condition|)
block|{
name|p
operator|->
name|pend
index|[
name|subno
index|]
operator|=
name|HERE
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|p
operator|->
name|pend
index|[
name|subno
index|]
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
name|EMIT
argument_list|(
name|ORPAREN
argument_list|,
name|subno
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|MUSTEAT
argument_list|(
literal|')'
argument_list|,
name|REG_EPAREN
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|POSIX_MISTAKE
case|case
literal|')'
case|:
comment|/* happens only if no current unmatched ( */
comment|/* 		 * You may ask, why the ifndef?  Because I didn't notice 		 * this until slightly too late for 1003.2, and none of the 		 * other 1003.2 regular-expression reviewers noticed it at 		 * all.  So an unmatched ) is legal POSIX, at least until 		 * we can get it fixed. 		 */
name|SETERROR
argument_list|(
name|REG_EPAREN
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'^'
case|:
name|EMIT
argument_list|(
name|OBOL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|g
operator|->
name|iflags
operator||=
name|USEBOL
expr_stmt|;
name|p
operator|->
name|g
operator|->
name|nbol
operator|++
expr_stmt|;
name|wascaret
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
name|EMIT
argument_list|(
name|OEOL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|g
operator|->
name|iflags
operator||=
name|USEEOL
expr_stmt|;
name|p
operator|->
name|g
operator|->
name|neol
operator|++
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
name|SETERROR
argument_list|(
name|REG_EMPTY
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
case|case
literal|'+'
case|:
case|case
literal|'?'
case|:
name|SETERROR
argument_list|(
name|REG_BADRPT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
if|if
condition|(
name|p
operator|->
name|g
operator|->
name|cflags
operator|&
name|REG_NEWLINE
condition|)
name|nonnewline
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|EMIT
argument_list|(
name|OANY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'['
case|:
name|p_bracket
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
operator|(
name|void
operator|)
name|REQUIRE
argument_list|(
name|MORE
argument_list|()
argument_list|,
name|REG_EESCAPE
argument_list|)
expr_stmt|;
name|wc
operator|=
name|WGETNEXT
argument_list|()
expr_stmt|;
name|ordinary
argument_list|(
name|p
argument_list|,
name|wc
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
comment|/* okay as ordinary except if digit follows */
operator|(
name|void
operator|)
name|REQUIRE
argument_list|(
operator|!
name|MORE
argument_list|()
operator|||
operator|!
name|isdigit
argument_list|(
operator|(
name|uch
operator|)
name|PEEK
argument_list|()
argument_list|)
argument_list|,
name|REG_BADRPT
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
name|p
operator|->
name|next
operator|--
expr_stmt|;
name|wc
operator|=
name|WGETNEXT
argument_list|()
expr_stmt|;
name|ordinary
argument_list|(
name|p
argument_list|,
name|wc
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|MORE
argument_list|()
condition|)
return|return;
name|c
operator|=
name|PEEK
argument_list|()
expr_stmt|;
comment|/* we call { a repetition if followed by a digit */
if|if
condition|(
operator|!
operator|(
name|c
operator|==
literal|'*'
operator|||
name|c
operator|==
literal|'+'
operator|||
name|c
operator|==
literal|'?'
operator|||
operator|(
name|c
operator|==
literal|'{'
operator|&&
name|MORE2
argument_list|()
operator|&&
name|isdigit
argument_list|(
operator|(
name|uch
operator|)
name|PEEK2
argument_list|()
argument_list|)
operator|)
operator|)
condition|)
return|return;
comment|/* no repetition, we're done */
name|NEXT
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|REQUIRE
argument_list|(
operator|!
name|wascaret
argument_list|,
name|REG_BADRPT
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'*'
case|:
comment|/* implemented as +? */
comment|/* this case does not require the (y|) trick, noKLUDGE */
name|INSERT
argument_list|(
name|OPLUS_
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|ASTERN
argument_list|(
name|O_PLUS
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|INSERT
argument_list|(
name|OQUEST_
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|ASTERN
argument_list|(
name|O_QUEST
argument_list|,
name|pos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|INSERT
argument_list|(
name|OPLUS_
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|ASTERN
argument_list|(
name|O_PLUS
argument_list|,
name|pos
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
comment|/* KLUDGE: emit y? as (y|) until subtle bug gets fixed */
name|INSERT
argument_list|(
name|OCH_
argument_list|,
name|pos
argument_list|)
expr_stmt|;
comment|/* offset slightly wrong */
name|ASTERN
argument_list|(
name|OOR1
argument_list|,
name|pos
argument_list|)
expr_stmt|;
comment|/* this one's right */
name|AHEAD
argument_list|(
name|pos
argument_list|)
expr_stmt|;
comment|/* fix the OCH_ */
name|EMIT
argument_list|(
name|OOR2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* offset very wrong... */
name|AHEAD
argument_list|(
name|THERE
argument_list|()
argument_list|)
expr_stmt|;
comment|/* ...so fix it */
name|ASTERN
argument_list|(
name|O_CH
argument_list|,
name|THERETHERE
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
name|count
operator|=
name|p_count
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|EAT
argument_list|(
literal|','
argument_list|)
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|uch
operator|)
name|PEEK
argument_list|()
argument_list|)
condition|)
block|{
name|count2
operator|=
name|p_count
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|REQUIRE
argument_list|(
name|count
operator|<=
name|count2
argument_list|,
name|REG_BADBR
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* single number with comma */
name|count2
operator|=
name|INFINITY
expr_stmt|;
block|}
else|else
comment|/* just a single number */
name|count2
operator|=
name|count
expr_stmt|;
name|repeat
argument_list|(
name|p
argument_list|,
name|pos
argument_list|,
name|count
argument_list|,
name|count2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EAT
argument_list|(
literal|'}'
argument_list|)
condition|)
block|{
comment|/* error heuristics */
while|while
condition|(
name|MORE
argument_list|()
operator|&&
name|PEEK
argument_list|()
operator|!=
literal|'}'
condition|)
name|NEXT
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|REQUIRE
argument_list|(
name|MORE
argument_list|()
argument_list|,
name|REG_EBRACE
argument_list|)
expr_stmt|;
name|SETERROR
argument_list|(
name|REG_BADBR
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
operator|!
name|MORE
argument_list|()
condition|)
return|return;
name|c
operator|=
name|PEEK
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|==
literal|'*'
operator|||
name|c
operator|==
literal|'+'
operator|||
name|c
operator|==
literal|'?'
operator|||
operator|(
name|c
operator|==
literal|'{'
operator|&&
name|MORE2
argument_list|()
operator|&&
name|isdigit
argument_list|(
operator|(
name|uch
operator|)
name|PEEK2
argument_list|()
argument_list|)
operator|)
operator|)
condition|)
return|return;
name|SETERROR
argument_list|(
name|REG_BADRPT
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - p_str - string (no metacharacters) "parser"  == static void p_str(struct parse *p);  */
end_comment

begin_function
specifier|static
name|void
name|p_str
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|)
block|{
operator|(
name|void
operator|)
name|REQUIRE
argument_list|(
name|MORE
argument_list|()
argument_list|,
name|REG_EMPTY
argument_list|)
expr_stmt|;
while|while
condition|(
name|MORE
argument_list|()
condition|)
name|ordinary
argument_list|(
name|p
argument_list|,
name|WGETNEXT
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - p_bre - BRE parser top level, anchoring and concatenation  == static void p_bre(struct parse *p, int end1, \  ==	int end2);  * Giving end1 as OUT essentially eliminates the end1/end2 check.  *  * This implementation is a bit of a kludge, in that a trailing $ is first  * taken as an ordinary character and then revised to be an anchor.  * The amount of lookahead needed to avoid this kludge is excessive.  */
end_comment

begin_function
specifier|static
name|void
name|p_bre
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|int
name|end1
parameter_list|,
comment|/* first terminating character */
name|int
name|end2
parameter_list|)
comment|/* second terminating character */
block|{
name|sopno
name|start
init|=
name|HERE
argument_list|()
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
comment|/* first subexpression? */
name|int
name|wasdollar
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|EAT
argument_list|(
literal|'^'
argument_list|)
condition|)
block|{
name|EMIT
argument_list|(
name|OBOL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|g
operator|->
name|iflags
operator||=
name|USEBOL
expr_stmt|;
name|p
operator|->
name|g
operator|->
name|nbol
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|MORE
argument_list|()
operator|&&
operator|!
name|SEETWO
argument_list|(
name|end1
argument_list|,
name|end2
argument_list|)
condition|)
block|{
name|wasdollar
operator|=
name|p_simp_re
argument_list|(
name|p
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|wasdollar
condition|)
block|{
comment|/* oops, that was a trailing anchor */
name|DROP
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|EMIT
argument_list|(
name|OEOL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|g
operator|->
name|iflags
operator||=
name|USEEOL
expr_stmt|;
name|p
operator|->
name|g
operator|->
name|neol
operator|++
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|REQUIRE
argument_list|(
name|HERE
argument_list|()
operator|!=
name|start
argument_list|,
name|REG_EMPTY
argument_list|)
expr_stmt|;
comment|/* require nonempty */
block|}
end_function

begin_comment
comment|/*  - p_simp_re - parse a simple RE, an atom possibly followed by a repetition  == static int p_simp_re(struct parse *p, int starordinary);  */
end_comment

begin_function
specifier|static
name|int
comment|/* was the simple RE an unbackslashed $? */
name|p_simp_re
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|int
name|starordinary
parameter_list|)
comment|/* is a leading * an ordinary character? */
block|{
name|int
name|c
decl_stmt|;
name|int
name|count
decl_stmt|;
name|int
name|count2
decl_stmt|;
name|sopno
name|pos
decl_stmt|;
name|int
name|i
decl_stmt|;
name|wint_t
name|wc
decl_stmt|;
name|sopno
name|subno
decl_stmt|;
define|#
directive|define
name|BACKSL
value|(1<<CHAR_BIT)
name|pos
operator|=
name|HERE
argument_list|()
expr_stmt|;
comment|/* repetion op, if any, covers from here */
name|assert
argument_list|(
name|MORE
argument_list|()
argument_list|)
expr_stmt|;
comment|/* caller should have ensured this */
name|c
operator|=
name|GETNEXT
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
operator|(
name|void
operator|)
name|REQUIRE
argument_list|(
name|MORE
argument_list|()
argument_list|,
name|REG_EESCAPE
argument_list|)
expr_stmt|;
name|c
operator|=
name|BACKSL
operator||
name|GETNEXT
argument_list|()
expr_stmt|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'.'
case|:
if|if
condition|(
name|p
operator|->
name|g
operator|->
name|cflags
operator|&
name|REG_NEWLINE
condition|)
name|nonnewline
argument_list|(
name|p
argument_list|)
expr_stmt|;
else|else
name|EMIT
argument_list|(
name|OANY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'['
case|:
name|p_bracket
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|BACKSL
operator||
literal|'{'
case|:
name|SETERROR
argument_list|(
name|REG_BADRPT
argument_list|)
expr_stmt|;
break|break;
case|case
name|BACKSL
operator||
literal|'('
case|:
name|p
operator|->
name|g
operator|->
name|nsub
operator|++
expr_stmt|;
name|subno
operator|=
name|p
operator|->
name|g
operator|->
name|nsub
expr_stmt|;
if|if
condition|(
name|subno
operator|<
name|NPAREN
condition|)
name|p
operator|->
name|pbegin
index|[
name|subno
index|]
operator|=
name|HERE
argument_list|()
expr_stmt|;
name|EMIT
argument_list|(
name|OLPAREN
argument_list|,
name|subno
argument_list|)
expr_stmt|;
comment|/* the MORE here is an error heuristic */
if|if
condition|(
name|MORE
argument_list|()
operator|&&
operator|!
name|SEETWO
argument_list|(
literal|'\\'
argument_list|,
literal|')'
argument_list|)
condition|)
name|p_bre
argument_list|(
name|p
argument_list|,
literal|'\\'
argument_list|,
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|subno
operator|<
name|NPAREN
condition|)
block|{
name|p
operator|->
name|pend
index|[
name|subno
index|]
operator|=
name|HERE
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|p
operator|->
name|pend
index|[
name|subno
index|]
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
name|EMIT
argument_list|(
name|ORPAREN
argument_list|,
name|subno
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|REQUIRE
argument_list|(
name|EATTWO
argument_list|(
literal|'\\'
argument_list|,
literal|')'
argument_list|)
argument_list|,
name|REG_EPAREN
argument_list|)
expr_stmt|;
break|break;
case|case
name|BACKSL
operator||
literal|')'
case|:
comment|/* should not get here -- must be user */
case|case
name|BACKSL
operator||
literal|'}'
case|:
name|SETERROR
argument_list|(
name|REG_EPAREN
argument_list|)
expr_stmt|;
break|break;
case|case
name|BACKSL
operator||
literal|'1'
case|:
case|case
name|BACKSL
operator||
literal|'2'
case|:
case|case
name|BACKSL
operator||
literal|'3'
case|:
case|case
name|BACKSL
operator||
literal|'4'
case|:
case|case
name|BACKSL
operator||
literal|'5'
case|:
case|case
name|BACKSL
operator||
literal|'6'
case|:
case|case
name|BACKSL
operator||
literal|'7'
case|:
case|case
name|BACKSL
operator||
literal|'8'
case|:
case|case
name|BACKSL
operator||
literal|'9'
case|:
name|i
operator|=
operator|(
name|c
operator|&
operator|~
name|BACKSL
operator|)
operator|-
literal|'0'
expr_stmt|;
name|assert
argument_list|(
name|i
operator|<
name|NPAREN
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|pend
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|assert
argument_list|(
name|i
operator|<=
name|p
operator|->
name|g
operator|->
name|nsub
argument_list|)
expr_stmt|;
name|EMIT
argument_list|(
name|OBACK_
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|p
operator|->
name|pbegin
index|[
name|i
index|]
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|OP
argument_list|(
name|p
operator|->
name|strip
index|[
name|p
operator|->
name|pbegin
index|[
name|i
index|]
index|]
argument_list|)
operator|==
name|OLPAREN
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|OP
argument_list|(
name|p
operator|->
name|strip
index|[
name|p
operator|->
name|pend
index|[
name|i
index|]
index|]
argument_list|)
operator|==
name|ORPAREN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dupl
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|pbegin
index|[
name|i
index|]
operator|+
literal|1
argument_list|,
name|p
operator|->
name|pend
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|EMIT
argument_list|(
name|O_BACK
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
name|SETERROR
argument_list|(
name|REG_ESUBREG
argument_list|)
expr_stmt|;
name|p
operator|->
name|g
operator|->
name|backrefs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
operator|(
name|void
operator|)
name|REQUIRE
argument_list|(
name|starordinary
argument_list|,
name|REG_BADRPT
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
name|p
operator|->
name|next
operator|--
expr_stmt|;
name|wc
operator|=
name|WGETNEXT
argument_list|()
expr_stmt|;
name|ordinary
argument_list|(
name|p
argument_list|,
name|wc
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|EAT
argument_list|(
literal|'*'
argument_list|)
condition|)
block|{
comment|/* implemented as +? */
comment|/* this case does not require the (y|) trick, noKLUDGE */
name|INSERT
argument_list|(
name|OPLUS_
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|ASTERN
argument_list|(
name|O_PLUS
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|INSERT
argument_list|(
name|OQUEST_
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|ASTERN
argument_list|(
name|O_QUEST
argument_list|,
name|pos
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|EATTWO
argument_list|(
literal|'\\'
argument_list|,
literal|'{'
argument_list|)
condition|)
block|{
name|count
operator|=
name|p_count
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|EAT
argument_list|(
literal|','
argument_list|)
condition|)
block|{
if|if
condition|(
name|MORE
argument_list|()
operator|&&
name|isdigit
argument_list|(
operator|(
name|uch
operator|)
name|PEEK
argument_list|()
argument_list|)
condition|)
block|{
name|count2
operator|=
name|p_count
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|REQUIRE
argument_list|(
name|count
operator|<=
name|count2
argument_list|,
name|REG_BADBR
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* single number with comma */
name|count2
operator|=
name|INFINITY
expr_stmt|;
block|}
else|else
comment|/* just a single number */
name|count2
operator|=
name|count
expr_stmt|;
name|repeat
argument_list|(
name|p
argument_list|,
name|pos
argument_list|,
name|count
argument_list|,
name|count2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EATTWO
argument_list|(
literal|'\\'
argument_list|,
literal|'}'
argument_list|)
condition|)
block|{
comment|/* error heuristics */
while|while
condition|(
name|MORE
argument_list|()
operator|&&
operator|!
name|SEETWO
argument_list|(
literal|'\\'
argument_list|,
literal|'}'
argument_list|)
condition|)
name|NEXT
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|REQUIRE
argument_list|(
name|MORE
argument_list|()
argument_list|,
name|REG_EBRACE
argument_list|)
expr_stmt|;
name|SETERROR
argument_list|(
name|REG_BADBR
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'$'
condition|)
comment|/* $ (but not \$) ends it */
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - p_count - parse a repetition count  == static int p_count(struct parse *p);  */
end_comment

begin_function
specifier|static
name|int
comment|/* the value */
name|p_count
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|ndigits
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|MORE
argument_list|()
operator|&&
name|isdigit
argument_list|(
operator|(
name|uch
operator|)
name|PEEK
argument_list|()
argument_list|)
operator|&&
name|count
operator|<=
name|DUPMAX
condition|)
block|{
name|count
operator|=
name|count
operator|*
literal|10
operator|+
operator|(
name|GETNEXT
argument_list|()
operator|-
literal|'0'
operator|)
expr_stmt|;
name|ndigits
operator|++
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|REQUIRE
argument_list|(
name|ndigits
operator|>
literal|0
operator|&&
name|count
operator|<=
name|DUPMAX
argument_list|,
name|REG_BADBR
argument_list|)
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - p_bracket - parse a bracketed character list  == static void p_bracket(struct parse *p);  */
end_comment

begin_function
specifier|static
name|void
name|p_bracket
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|)
block|{
name|cset
modifier|*
name|cs
decl_stmt|;
name|wint_t
name|ch
decl_stmt|;
comment|/* Dept of Truly Sickening Special-Case Kludges */
if|if
condition|(
name|p
operator|->
name|next
operator|+
literal|5
operator|<
name|p
operator|->
name|end
operator|&&
name|strncmp
argument_list|(
name|p
operator|->
name|next
argument_list|,
literal|"[:<:]]"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|EMIT
argument_list|(
name|OBOW
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NEXTn
argument_list|(
literal|6
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p
operator|->
name|next
operator|+
literal|5
operator|<
name|p
operator|->
name|end
operator|&&
name|strncmp
argument_list|(
name|p
operator|->
name|next
argument_list|,
literal|"[:>:]]"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|EMIT
argument_list|(
name|OEOW
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|NEXTn
argument_list|(
literal|6
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|cs
operator|=
name|allocset
argument_list|(
name|p
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|p
operator|->
name|g
operator|->
name|cflags
operator|&
name|REG_ICASE
condition|)
name|cs
operator|->
name|icase
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|EAT
argument_list|(
literal|'^'
argument_list|)
condition|)
name|cs
operator|->
name|invert
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|EAT
argument_list|(
literal|']'
argument_list|)
condition|)
name|CHadd
argument_list|(
name|p
argument_list|,
name|cs
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|EAT
argument_list|(
literal|'-'
argument_list|)
condition|)
name|CHadd
argument_list|(
name|p
argument_list|,
name|cs
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
while|while
condition|(
name|MORE
argument_list|()
operator|&&
name|PEEK
argument_list|()
operator|!=
literal|']'
operator|&&
operator|!
name|SEETWO
argument_list|(
literal|'-'
argument_list|,
literal|']'
argument_list|)
condition|)
name|p_b_term
argument_list|(
name|p
argument_list|,
name|cs
argument_list|)
expr_stmt|;
if|if
condition|(
name|EAT
argument_list|(
literal|'-'
argument_list|)
condition|)
name|CHadd
argument_list|(
name|p
argument_list|,
name|cs
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|MUSTEAT
argument_list|(
literal|']'
argument_list|,
name|REG_EBRACK
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|error
operator|!=
literal|0
condition|)
comment|/* don't mess things up further */
return|return;
if|if
condition|(
name|cs
operator|->
name|invert
operator|&&
name|p
operator|->
name|g
operator|->
name|cflags
operator|&
name|REG_NEWLINE
condition|)
name|cs
operator|->
name|bmp
index|[
literal|'\n'
operator|>>
literal|3
index|]
operator||=
literal|1
operator|<<
operator|(
literal|'\n'
operator|&
literal|7
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|=
name|singleton
argument_list|(
name|cs
argument_list|)
operator|)
operator|!=
name|OUT
condition|)
block|{
comment|/* optimize singleton sets */
name|ordinary
argument_list|(
name|p
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|freeset
argument_list|(
name|p
argument_list|,
name|cs
argument_list|)
expr_stmt|;
block|}
else|else
name|EMIT
argument_list|(
name|OANYOF
argument_list|,
call|(
name|int
call|)
argument_list|(
name|cs
operator|-
name|p
operator|->
name|g
operator|->
name|sets
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - p_b_term - parse one term of a bracketed character list  == static void p_b_term(struct parse *p, cset *cs);  */
end_comment

begin_function
specifier|static
name|void
name|p_b_term
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|cset
modifier|*
name|cs
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
name|wint_t
name|start
decl_stmt|,
name|finish
decl_stmt|;
name|wint_t
name|i
decl_stmt|;
name|struct
name|xlocale_collate
modifier|*
name|table
init|=
operator|(
expr|struct
name|xlocale_collate
operator|*
operator|)
name|__get_locale
argument_list|()
operator|->
name|components
index|[
name|XLC_COLLATE
index|]
decl_stmt|;
comment|/* classify what we've got */
switch|switch
condition|(
operator|(
name|MORE
argument_list|()
operator|)
condition|?
name|PEEK
argument_list|()
else|:
literal|'\0'
condition|)
block|{
case|case
literal|'['
case|:
name|c
operator|=
operator|(
name|MORE2
argument_list|()
operator|)
condition|?
name|PEEK2
argument_list|()
else|:
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|SETERROR
argument_list|(
name|REG_ERANGE
argument_list|)
expr_stmt|;
return|return;
comment|/* NOTE RETURN */
default|default:
name|c
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|':'
case|:
comment|/* character class */
name|NEXT2
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|REQUIRE
argument_list|(
name|MORE
argument_list|()
argument_list|,
name|REG_EBRACK
argument_list|)
expr_stmt|;
name|c
operator|=
name|PEEK
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|REQUIRE
argument_list|(
name|c
operator|!=
literal|'-'
operator|&&
name|c
operator|!=
literal|']'
argument_list|,
name|REG_ECTYPE
argument_list|)
expr_stmt|;
name|p_b_cclass
argument_list|(
name|p
argument_list|,
name|cs
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|REQUIRE
argument_list|(
name|MORE
argument_list|()
argument_list|,
name|REG_EBRACK
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|REQUIRE
argument_list|(
name|EATTWO
argument_list|(
literal|':'
argument_list|,
literal|']'
argument_list|)
argument_list|,
name|REG_ECTYPE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'='
case|:
comment|/* equivalence class */
name|NEXT2
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|REQUIRE
argument_list|(
name|MORE
argument_list|()
argument_list|,
name|REG_EBRACK
argument_list|)
expr_stmt|;
name|c
operator|=
name|PEEK
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|REQUIRE
argument_list|(
name|c
operator|!=
literal|'-'
operator|&&
name|c
operator|!=
literal|']'
argument_list|,
name|REG_ECOLLATE
argument_list|)
expr_stmt|;
name|p_b_eclass
argument_list|(
name|p
argument_list|,
name|cs
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|REQUIRE
argument_list|(
name|MORE
argument_list|()
argument_list|,
name|REG_EBRACK
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|REQUIRE
argument_list|(
name|EATTWO
argument_list|(
literal|'='
argument_list|,
literal|']'
argument_list|)
argument_list|,
name|REG_ECOLLATE
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* symbol, ordinary character, or range */
name|start
operator|=
name|p_b_symbol
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|SEE
argument_list|(
literal|'-'
argument_list|)
operator|&&
name|MORE2
argument_list|()
operator|&&
name|PEEK2
argument_list|()
operator|!=
literal|']'
condition|)
block|{
comment|/* range */
name|NEXT
argument_list|()
expr_stmt|;
if|if
condition|(
name|EAT
argument_list|(
literal|'-'
argument_list|)
condition|)
name|finish
operator|=
literal|'-'
expr_stmt|;
else|else
name|finish
operator|=
name|p_b_symbol
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
name|finish
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|start
operator|==
name|finish
condition|)
name|CHadd
argument_list|(
name|p
argument_list|,
name|cs
argument_list|,
name|start
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|table
operator|->
name|__collate_load_error
condition|)
block|{
operator|(
name|void
operator|)
name|REQUIRE
argument_list|(
operator|(
name|uch
operator|)
name|start
operator|<=
operator|(
name|uch
operator|)
name|finish
argument_list|,
name|REG_ERANGE
argument_list|)
expr_stmt|;
name|CHaddrange
argument_list|(
name|p
argument_list|,
name|cs
argument_list|,
name|start
argument_list|,
name|finish
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|REQUIRE
argument_list|(
name|__collate_range_cmp
argument_list|(
name|table
argument_list|,
name|start
argument_list|,
name|finish
argument_list|)
operator|<=
literal|0
argument_list|,
name|REG_ERANGE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|UCHAR_MAX
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|__collate_range_cmp
argument_list|(
name|table
argument_list|,
name|start
argument_list|,
name|i
argument_list|)
operator|<=
literal|0
operator|&&
name|__collate_range_cmp
argument_list|(
name|table
argument_list|,
name|i
argument_list|,
name|finish
argument_list|)
operator|<=
literal|0
condition|)
name|CHadd
argument_list|(
name|p
argument_list|,
name|cs
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  - p_b_cclass - parse a character-class name and deal with it  == static void p_b_cclass(struct parse *p, cset *cs);  */
end_comment

begin_function
specifier|static
name|void
name|p_b_cclass
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|cset
modifier|*
name|cs
parameter_list|)
block|{
name|char
modifier|*
name|sp
init|=
name|p
operator|->
name|next
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|wctype_t
name|wct
decl_stmt|;
name|char
name|clname
index|[
literal|16
index|]
decl_stmt|;
while|while
condition|(
name|MORE
argument_list|()
operator|&&
name|isalpha
argument_list|(
operator|(
name|uch
operator|)
name|PEEK
argument_list|()
argument_list|)
condition|)
name|NEXT
argument_list|()
expr_stmt|;
name|len
operator|=
name|p
operator|->
name|next
operator|-
name|sp
expr_stmt|;
if|if
condition|(
name|len
operator|>=
sizeof|sizeof
argument_list|(
name|clname
argument_list|)
operator|-
literal|1
condition|)
block|{
name|SETERROR
argument_list|(
name|REG_ECTYPE
argument_list|)
expr_stmt|;
return|return;
block|}
name|memcpy
argument_list|(
name|clname
argument_list|,
name|sp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|clname
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|wct
operator|=
name|wctype
argument_list|(
name|clname
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|SETERROR
argument_list|(
name|REG_ECTYPE
argument_list|)
expr_stmt|;
return|return;
block|}
name|CHaddtype
argument_list|(
name|p
argument_list|,
name|cs
argument_list|,
name|wct
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - p_b_eclass - parse an equivalence-class name and deal with it  == static void p_b_eclass(struct parse *p, cset *cs);  *  * This implementation is incomplete. xxx  */
end_comment

begin_function
specifier|static
name|void
name|p_b_eclass
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|cset
modifier|*
name|cs
parameter_list|)
block|{
name|wint_t
name|c
decl_stmt|;
name|c
operator|=
name|p_b_coll_elem
argument_list|(
name|p
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
name|CHadd
argument_list|(
name|p
argument_list|,
name|cs
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - p_b_symbol - parse a character or [..]ed multicharacter collating symbol  == static char p_b_symbol(struct parse *p);  */
end_comment

begin_function
specifier|static
name|wint_t
comment|/* value of symbol */
name|p_b_symbol
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|)
block|{
name|wint_t
name|value
decl_stmt|;
operator|(
name|void
operator|)
name|REQUIRE
argument_list|(
name|MORE
argument_list|()
argument_list|,
name|REG_EBRACK
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EATTWO
argument_list|(
literal|'['
argument_list|,
literal|'.'
argument_list|)
condition|)
return|return
operator|(
name|WGETNEXT
argument_list|()
operator|)
return|;
comment|/* collating symbol */
name|value
operator|=
name|p_b_coll_elem
argument_list|(
name|p
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|REQUIRE
argument_list|(
name|EATTWO
argument_list|(
literal|'.'
argument_list|,
literal|']'
argument_list|)
argument_list|,
name|REG_ECOLLATE
argument_list|)
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - p_b_coll_elem - parse a collating-element name and look it up  == static char p_b_coll_elem(struct parse *p, int endc);  */
end_comment

begin_function
specifier|static
name|wint_t
comment|/* value of collating element */
name|p_b_coll_elem
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|wint_t
name|endc
parameter_list|)
comment|/* name ended by endc,']' */
block|{
name|char
modifier|*
name|sp
init|=
name|p
operator|->
name|next
decl_stmt|;
name|struct
name|cname
modifier|*
name|cp
decl_stmt|;
name|int
name|len
decl_stmt|;
name|mbstate_t
name|mbs
decl_stmt|;
name|wchar_t
name|wc
decl_stmt|;
name|size_t
name|clen
decl_stmt|;
while|while
condition|(
name|MORE
argument_list|()
operator|&&
operator|!
name|SEETWO
argument_list|(
name|endc
argument_list|,
literal|']'
argument_list|)
condition|)
name|NEXT
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|MORE
argument_list|()
condition|)
block|{
name|SETERROR
argument_list|(
name|REG_EBRACK
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|len
operator|=
name|p
operator|->
name|next
operator|-
name|sp
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|cnames
init|;
name|cp
operator|->
name|name
operator|!=
name|NULL
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|cp
operator|->
name|name
argument_list|,
name|sp
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
name|cp
operator|->
name|name
index|[
name|len
index|]
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|cp
operator|->
name|code
operator|)
return|;
comment|/* known name */
name|memset
argument_list|(
operator|&
name|mbs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|clen
operator|=
name|mbrtowc
argument_list|(
operator|&
name|wc
argument_list|,
name|sp
argument_list|,
name|len
argument_list|,
operator|&
name|mbs
argument_list|)
operator|)
operator|==
name|len
condition|)
return|return
operator|(
name|wc
operator|)
return|;
comment|/* single character */
elseif|else
if|if
condition|(
name|clen
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|||
name|clen
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|2
condition|)
name|SETERROR
argument_list|(
name|REG_ILLSEQ
argument_list|)
expr_stmt|;
else|else
name|SETERROR
argument_list|(
name|REG_ECOLLATE
argument_list|)
expr_stmt|;
comment|/* neither */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - othercase - return the case counterpart of an alphabetic  == static char othercase(int ch);  */
end_comment

begin_function
specifier|static
name|wint_t
comment|/* if no counterpart, return ch */
name|othercase
parameter_list|(
name|wint_t
name|ch
parameter_list|)
block|{
name|assert
argument_list|(
name|iswalpha
argument_list|(
name|ch
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iswupper
argument_list|(
name|ch
argument_list|)
condition|)
return|return
operator|(
name|towlower
argument_list|(
name|ch
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|iswlower
argument_list|(
name|ch
argument_list|)
condition|)
return|return
operator|(
name|towupper
argument_list|(
name|ch
argument_list|)
operator|)
return|;
else|else
comment|/* peculiar, but could happen */
return|return
operator|(
name|ch
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - bothcases - emit a dualcase version of a two-case character  == static void bothcases(struct parse *p, int ch);  *  * Boy, is this implementation ever a kludge...  */
end_comment

begin_function
specifier|static
name|void
name|bothcases
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|wint_t
name|ch
parameter_list|)
block|{
name|char
modifier|*
name|oldnext
init|=
name|p
operator|->
name|next
decl_stmt|;
name|char
modifier|*
name|oldend
init|=
name|p
operator|->
name|end
decl_stmt|;
name|char
name|bracket
index|[
literal|3
operator|+
name|MB_LEN_MAX
index|]
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|mbstate_t
name|mbs
decl_stmt|;
name|assert
argument_list|(
name|othercase
argument_list|(
name|ch
argument_list|)
operator|!=
name|ch
argument_list|)
expr_stmt|;
comment|/* p_bracket() would recurse */
name|p
operator|->
name|next
operator|=
name|bracket
expr_stmt|;
name|memset
argument_list|(
operator|&
name|mbs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbs
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|wcrtomb
argument_list|(
name|bracket
argument_list|,
name|ch
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|n
operator|!=
operator|(
name|size_t
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|bracket
index|[
name|n
index|]
operator|=
literal|']'
expr_stmt|;
name|bracket
index|[
name|n
operator|+
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|->
name|end
operator|=
name|bracket
operator|+
name|n
operator|+
literal|1
expr_stmt|;
name|p_bracket
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|p
operator|->
name|next
operator|==
name|p
operator|->
name|end
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|oldnext
expr_stmt|;
name|p
operator|->
name|end
operator|=
name|oldend
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - ordinary - emit an ordinary character  == static void ordinary(struct parse *p, int ch);  */
end_comment

begin_function
specifier|static
name|void
name|ordinary
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|wint_t
name|ch
parameter_list|)
block|{
name|cset
modifier|*
name|cs
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|->
name|g
operator|->
name|cflags
operator|&
name|REG_ICASE
operator|)
operator|&&
name|iswalpha
argument_list|(
name|ch
argument_list|)
operator|&&
name|othercase
argument_list|(
name|ch
argument_list|)
operator|!=
name|ch
condition|)
name|bothcases
argument_list|(
name|p
argument_list|,
name|ch
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ch
operator|&
name|OPDMASK
operator|)
operator|==
name|ch
condition|)
name|EMIT
argument_list|(
name|OCHAR
argument_list|,
name|ch
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 		 * Kludge: character is too big to fit into an OCHAR operand. 		 * Emit a singleton set. 		 */
if|if
condition|(
operator|(
name|cs
operator|=
name|allocset
argument_list|(
name|p
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
name|CHadd
argument_list|(
name|p
argument_list|,
name|cs
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|EMIT
argument_list|(
name|OANYOF
argument_list|,
call|(
name|int
call|)
argument_list|(
name|cs
operator|-
name|p
operator|->
name|g
operator|->
name|sets
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  - nonnewline - emit REG_NEWLINE version of OANY  == static void nonnewline(struct parse *p);  *  * Boy, is this implementation ever a kludge...  */
end_comment

begin_function
specifier|static
name|void
name|nonnewline
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|)
block|{
name|char
modifier|*
name|oldnext
init|=
name|p
operator|->
name|next
decl_stmt|;
name|char
modifier|*
name|oldend
init|=
name|p
operator|->
name|end
decl_stmt|;
name|char
name|bracket
index|[
literal|4
index|]
decl_stmt|;
name|p
operator|->
name|next
operator|=
name|bracket
expr_stmt|;
name|p
operator|->
name|end
operator|=
name|bracket
operator|+
literal|3
expr_stmt|;
name|bracket
index|[
literal|0
index|]
operator|=
literal|'^'
expr_stmt|;
name|bracket
index|[
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
name|bracket
index|[
literal|2
index|]
operator|=
literal|']'
expr_stmt|;
name|bracket
index|[
literal|3
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p_bracket
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|p
operator|->
name|next
operator|==
name|bracket
operator|+
literal|3
argument_list|)
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|oldnext
expr_stmt|;
name|p
operator|->
name|end
operator|=
name|oldend
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - repeat - generate code for a bounded repetition, recursively if needed  == static void repeat(struct parse *p, sopno start, int from, int to);  */
end_comment

begin_function
specifier|static
name|void
name|repeat
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|sopno
name|start
parameter_list|,
comment|/* operand from here to end of strip */
name|int
name|from
parameter_list|,
comment|/* repeated from this number */
name|int
name|to
parameter_list|)
comment|/* to this number of times (maybe INFINITY) */
block|{
name|sopno
name|finish
init|=
name|HERE
argument_list|()
decl_stmt|;
define|#
directive|define
name|N
value|2
define|#
directive|define
name|INF
value|3
define|#
directive|define
name|REP
parameter_list|(
name|f
parameter_list|,
name|t
parameter_list|)
value|((f)*8 + (t))
define|#
directive|define
name|MAP
parameter_list|(
name|n
parameter_list|)
value|(((n)<= 1) ? (n) : ((n) == INFINITY) ? INF : N)
name|sopno
name|copy
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|error
operator|!=
literal|0
condition|)
comment|/* head off possible runaway recursion */
return|return;
name|assert
argument_list|(
name|from
operator|<=
name|to
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|REP
argument_list|(
name|MAP
argument_list|(
name|from
argument_list|)
argument_list|,
name|MAP
argument_list|(
name|to
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|REP
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
case|:
comment|/* must be user doing this */
name|DROP
argument_list|(
name|finish
operator|-
name|start
argument_list|)
expr_stmt|;
comment|/* drop the operand */
break|break;
case|case
name|REP
argument_list|(
literal|0
argument_list|,
literal|1
argument_list|)
case|:
comment|/* as x{1,1}? */
case|case
name|REP
argument_list|(
literal|0
argument_list|,
name|N
argument_list|)
case|:
comment|/* as x{1,n}? */
case|case
name|REP
argument_list|(
literal|0
argument_list|,
name|INF
argument_list|)
case|:
comment|/* as x{1,}? */
comment|/* KLUDGE: emit y? as (y|) until subtle bug gets fixed */
name|INSERT
argument_list|(
name|OCH_
argument_list|,
name|start
argument_list|)
expr_stmt|;
comment|/* offset is wrong... */
name|repeat
argument_list|(
name|p
argument_list|,
name|start
operator|+
literal|1
argument_list|,
literal|1
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|ASTERN
argument_list|(
name|OOR1
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|AHEAD
argument_list|(
name|start
argument_list|)
expr_stmt|;
comment|/* ... fix it */
name|EMIT
argument_list|(
name|OOR2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|AHEAD
argument_list|(
name|THERE
argument_list|()
argument_list|)
expr_stmt|;
name|ASTERN
argument_list|(
name|O_CH
argument_list|,
name|THERETHERE
argument_list|()
argument_list|)
expr_stmt|;
break|break;
case|case
name|REP
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
case|:
comment|/* trivial case */
comment|/* done */
break|break;
case|case
name|REP
argument_list|(
literal|1
argument_list|,
name|N
argument_list|)
case|:
comment|/* as x?x{1,n-1} */
comment|/* KLUDGE: emit y? as (y|) until subtle bug gets fixed */
name|INSERT
argument_list|(
name|OCH_
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|ASTERN
argument_list|(
name|OOR1
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|AHEAD
argument_list|(
name|start
argument_list|)
expr_stmt|;
name|EMIT
argument_list|(
name|OOR2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* offset very wrong... */
name|AHEAD
argument_list|(
name|THERE
argument_list|()
argument_list|)
expr_stmt|;
comment|/* ...so fix it */
name|ASTERN
argument_list|(
name|O_CH
argument_list|,
name|THERETHERE
argument_list|()
argument_list|)
expr_stmt|;
name|copy
operator|=
name|dupl
argument_list|(
name|p
argument_list|,
name|start
operator|+
literal|1
argument_list|,
name|finish
operator|+
literal|1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|copy
operator|==
name|finish
operator|+
literal|4
argument_list|)
expr_stmt|;
name|repeat
argument_list|(
name|p
argument_list|,
name|copy
argument_list|,
literal|1
argument_list|,
name|to
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|REP
argument_list|(
literal|1
argument_list|,
name|INF
argument_list|)
case|:
comment|/* as x+ */
name|INSERT
argument_list|(
name|OPLUS_
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|ASTERN
argument_list|(
name|O_PLUS
argument_list|,
name|start
argument_list|)
expr_stmt|;
break|break;
case|case
name|REP
argument_list|(
name|N
argument_list|,
name|N
argument_list|)
case|:
comment|/* as xx{m-1,n-1} */
name|copy
operator|=
name|dupl
argument_list|(
name|p
argument_list|,
name|start
argument_list|,
name|finish
argument_list|)
expr_stmt|;
name|repeat
argument_list|(
name|p
argument_list|,
name|copy
argument_list|,
name|from
operator|-
literal|1
argument_list|,
name|to
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|REP
argument_list|(
name|N
argument_list|,
name|INF
argument_list|)
case|:
comment|/* as xx{n-1,INF} */
name|copy
operator|=
name|dupl
argument_list|(
name|p
argument_list|,
name|start
argument_list|,
name|finish
argument_list|)
expr_stmt|;
name|repeat
argument_list|(
name|p
argument_list|,
name|copy
argument_list|,
name|from
operator|-
literal|1
argument_list|,
name|to
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* "can't happen" */
name|SETERROR
argument_list|(
name|REG_ASSERT
argument_list|)
expr_stmt|;
comment|/* just in case */
break|break;
block|}
block|}
end_function

begin_comment
comment|/*  - wgetnext - helper function for WGETNEXT() macro. Gets the next wide  - character from the parse struct, signals a REG_ILLSEQ error if the  - character can't be converted. Returns the number of bytes consumed.  */
end_comment

begin_function
specifier|static
name|wint_t
name|wgetnext
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|)
block|{
name|mbstate_t
name|mbs
decl_stmt|;
name|wchar_t
name|wc
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|memset
argument_list|(
operator|&
name|mbs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbs
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|mbrtowc
argument_list|(
operator|&
name|wc
argument_list|,
name|p
operator|->
name|next
argument_list|,
name|p
operator|->
name|end
operator|-
name|p
operator|->
name|next
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|||
name|n
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|2
condition|)
block|{
name|SETERROR
argument_list|(
name|REG_ILLSEQ
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|n
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|next
operator|+=
name|n
expr_stmt|;
return|return
operator|(
name|wc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - seterr - set an error condition  == static int seterr(struct parse *p, int e);  */
end_comment

begin_function
specifier|static
name|int
comment|/* useless but makes type checking happy */
name|seterr
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|int
name|e
parameter_list|)
block|{
if|if
condition|(
name|p
operator|->
name|error
operator|==
literal|0
condition|)
comment|/* keep earliest error condition */
name|p
operator|->
name|error
operator|=
name|e
expr_stmt|;
name|p
operator|->
name|next
operator|=
name|nuls
expr_stmt|;
comment|/* try to bring things to a halt */
name|p
operator|->
name|end
operator|=
name|nuls
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* make the return value well-defined */
block|}
end_function

begin_comment
comment|/*  - allocset - allocate a set of characters for []  == static cset *allocset(struct parse *p);  */
end_comment

begin_function
specifier|static
name|cset
modifier|*
name|allocset
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|)
block|{
name|cset
modifier|*
name|cs
decl_stmt|,
modifier|*
name|ncs
decl_stmt|;
name|ncs
operator|=
name|realloc
argument_list|(
name|p
operator|->
name|g
operator|->
name|sets
argument_list|,
operator|(
name|p
operator|->
name|g
operator|->
name|ncsets
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ncs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ncs
operator|==
name|NULL
condition|)
block|{
name|SETERROR
argument_list|(
name|REG_ESPACE
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|p
operator|->
name|g
operator|->
name|sets
operator|=
name|ncs
expr_stmt|;
name|cs
operator|=
operator|&
name|p
operator|->
name|g
operator|->
name|sets
index|[
name|p
operator|->
name|g
operator|->
name|ncsets
operator|++
index|]
expr_stmt|;
name|memset
argument_list|(
name|cs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cs
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|cs
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - freeset - free a now-unused set  == static void freeset(struct parse *p, cset *cs);  */
end_comment

begin_function
specifier|static
name|void
name|freeset
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|cset
modifier|*
name|cs
parameter_list|)
block|{
name|cset
modifier|*
name|top
init|=
operator|&
name|p
operator|->
name|g
operator|->
name|sets
index|[
name|p
operator|->
name|g
operator|->
name|ncsets
index|]
decl_stmt|;
name|free
argument_list|(
name|cs
operator|->
name|wides
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cs
operator|->
name|ranges
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cs
operator|->
name|types
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|cs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs
operator|==
name|top
operator|-
literal|1
condition|)
comment|/* recover only the easy case */
name|p
operator|->
name|g
operator|->
name|ncsets
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - singleton - Determine whether a set contains only one character,  - returning it if so, otherwise returning OUT.  */
end_comment

begin_function
specifier|static
name|wint_t
name|singleton
parameter_list|(
name|cset
modifier|*
name|cs
parameter_list|)
block|{
name|wint_t
name|i
decl_stmt|,
name|s
decl_stmt|,
name|n
decl_stmt|;
for|for
control|(
name|i
operator|=
name|n
operator|=
literal|0
init|;
name|i
operator|<
name|NC
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|CHIN
argument_list|(
name|cs
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|n
operator|++
expr_stmt|;
name|s
operator|=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
literal|1
condition|)
return|return
operator|(
name|s
operator|)
return|;
if|if
condition|(
name|cs
operator|->
name|nwides
operator|==
literal|1
operator|&&
name|cs
operator|->
name|nranges
operator|==
literal|0
operator|&&
name|cs
operator|->
name|ntypes
operator|==
literal|0
operator|&&
name|cs
operator|->
name|icase
operator|==
literal|0
condition|)
return|return
operator|(
name|cs
operator|->
name|wides
index|[
literal|0
index|]
operator|)
return|;
comment|/* Don't bother handling the other cases. */
return|return
operator|(
name|OUT
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - CHadd - add character to character set.  */
end_comment

begin_function
specifier|static
name|void
name|CHadd
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|cset
modifier|*
name|cs
parameter_list|,
name|wint_t
name|ch
parameter_list|)
block|{
name|wint_t
name|nch
decl_stmt|,
modifier|*
name|newwides
decl_stmt|;
name|assert
argument_list|(
name|ch
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|<
name|NC
condition|)
name|cs
operator|->
name|bmp
index|[
name|ch
operator|>>
literal|3
index|]
operator||=
literal|1
operator|<<
operator|(
name|ch
operator|&
literal|7
operator|)
expr_stmt|;
else|else
block|{
name|newwides
operator|=
name|realloc
argument_list|(
name|cs
operator|->
name|wides
argument_list|,
operator|(
name|cs
operator|->
name|nwides
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cs
operator|->
name|wides
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newwides
operator|==
name|NULL
condition|)
block|{
name|SETERROR
argument_list|(
name|REG_ESPACE
argument_list|)
expr_stmt|;
return|return;
block|}
name|cs
operator|->
name|wides
operator|=
name|newwides
expr_stmt|;
name|cs
operator|->
name|wides
index|[
name|cs
operator|->
name|nwides
operator|++
index|]
operator|=
name|ch
expr_stmt|;
block|}
if|if
condition|(
name|cs
operator|->
name|icase
condition|)
block|{
if|if
condition|(
operator|(
name|nch
operator|=
name|towlower
argument_list|(
name|ch
argument_list|)
operator|)
operator|<
name|NC
condition|)
name|cs
operator|->
name|bmp
index|[
name|nch
operator|>>
literal|3
index|]
operator||=
literal|1
operator|<<
operator|(
name|nch
operator|&
literal|7
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|nch
operator|=
name|towupper
argument_list|(
name|ch
argument_list|)
operator|)
operator|<
name|NC
condition|)
name|cs
operator|->
name|bmp
index|[
name|nch
operator|>>
literal|3
index|]
operator||=
literal|1
operator|<<
operator|(
name|nch
operator|&
literal|7
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  - CHaddrange - add all characters in the range [min,max] to a character set.  */
end_comment

begin_function
specifier|static
name|void
name|CHaddrange
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|cset
modifier|*
name|cs
parameter_list|,
name|wint_t
name|min
parameter_list|,
name|wint_t
name|max
parameter_list|)
block|{
name|crange
modifier|*
name|newranges
decl_stmt|;
for|for
control|(
init|;
name|min
operator|<
name|NC
operator|&&
name|min
operator|<=
name|max
condition|;
name|min
operator|++
control|)
name|CHadd
argument_list|(
name|p
argument_list|,
name|cs
argument_list|,
name|min
argument_list|)
expr_stmt|;
if|if
condition|(
name|min
operator|>=
name|max
condition|)
return|return;
name|newranges
operator|=
name|realloc
argument_list|(
name|cs
operator|->
name|ranges
argument_list|,
operator|(
name|cs
operator|->
name|nranges
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cs
operator|->
name|ranges
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newranges
operator|==
name|NULL
condition|)
block|{
name|SETERROR
argument_list|(
name|REG_ESPACE
argument_list|)
expr_stmt|;
return|return;
block|}
name|cs
operator|->
name|ranges
operator|=
name|newranges
expr_stmt|;
name|cs
operator|->
name|ranges
index|[
name|cs
operator|->
name|nranges
index|]
operator|.
name|min
operator|=
name|min
expr_stmt|;
name|cs
operator|->
name|ranges
index|[
name|cs
operator|->
name|nranges
index|]
operator|.
name|max
operator|=
name|max
expr_stmt|;
name|cs
operator|->
name|nranges
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - CHaddtype - add all characters of a certain type to a character set.  */
end_comment

begin_function
specifier|static
name|void
name|CHaddtype
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|cset
modifier|*
name|cs
parameter_list|,
name|wctype_t
name|wct
parameter_list|)
block|{
name|wint_t
name|i
decl_stmt|;
name|wctype_t
modifier|*
name|newtypes
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NC
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|iswctype
argument_list|(
name|i
argument_list|,
name|wct
argument_list|)
condition|)
name|CHadd
argument_list|(
name|p
argument_list|,
name|cs
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|newtypes
operator|=
name|realloc
argument_list|(
name|cs
operator|->
name|types
argument_list|,
operator|(
name|cs
operator|->
name|ntypes
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|cs
operator|->
name|types
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newtypes
operator|==
name|NULL
condition|)
block|{
name|SETERROR
argument_list|(
name|REG_ESPACE
argument_list|)
expr_stmt|;
return|return;
block|}
name|cs
operator|->
name|types
operator|=
name|newtypes
expr_stmt|;
name|cs
operator|->
name|types
index|[
name|cs
operator|->
name|ntypes
operator|++
index|]
operator|=
name|wct
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - dupl - emit a duplicate of a bunch of sops  == static sopno dupl(struct parse *p, sopno start, sopno finish);  */
end_comment

begin_function
specifier|static
name|sopno
comment|/* start of duplicate */
name|dupl
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|sopno
name|start
parameter_list|,
comment|/* from here */
name|sopno
name|finish
parameter_list|)
comment|/* to this less one */
block|{
name|sopno
name|ret
init|=
name|HERE
argument_list|()
decl_stmt|;
name|sopno
name|len
init|=
name|finish
operator|-
name|start
decl_stmt|;
name|assert
argument_list|(
name|finish
operator|>=
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|enlarge
argument_list|(
name|p
argument_list|,
name|p
operator|->
name|ssize
operator|+
name|len
argument_list|)
expr_stmt|;
comment|/* this many unexpected additions */
name|assert
argument_list|(
name|p
operator|->
name|ssize
operator|>=
name|p
operator|->
name|slen
operator|+
name|len
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|->
name|strip
operator|+
name|p
operator|->
name|slen
operator|)
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|->
name|strip
operator|+
name|start
operator|)
argument_list|,
operator|(
name|size_t
operator|)
name|len
operator|*
sizeof|sizeof
argument_list|(
name|sop
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|slen
operator|+=
name|len
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - doemit - emit a strip operator  == static void doemit(struct parse *p, sop op, size_t opnd);  *  * It might seem better to implement this as a macro with a function as  * hard-case backup, but it's just too big and messy unless there are  * some changes to the data structures.  Maybe later.  */
end_comment

begin_function
specifier|static
name|void
name|doemit
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|sop
name|op
parameter_list|,
name|size_t
name|opnd
parameter_list|)
block|{
comment|/* avoid making error situations worse */
if|if
condition|(
name|p
operator|->
name|error
operator|!=
literal|0
condition|)
return|return;
comment|/* deal with oversize operands ("can't happen", more or less) */
name|assert
argument_list|(
name|opnd
operator|<
literal|1
operator|<<
name|OPSHIFT
argument_list|)
expr_stmt|;
comment|/* deal with undersized strip */
if|if
condition|(
name|p
operator|->
name|slen
operator|>=
name|p
operator|->
name|ssize
condition|)
name|enlarge
argument_list|(
name|p
argument_list|,
operator|(
name|p
operator|->
name|ssize
operator|+
literal|1
operator|)
operator|/
literal|2
operator|*
literal|3
argument_list|)
expr_stmt|;
comment|/* +50% */
name|assert
argument_list|(
name|p
operator|->
name|slen
operator|<
name|p
operator|->
name|ssize
argument_list|)
expr_stmt|;
comment|/* finally, it's all reduced to the easy case */
name|p
operator|->
name|strip
index|[
name|p
operator|->
name|slen
operator|++
index|]
operator|=
name|SOP
argument_list|(
name|op
argument_list|,
name|opnd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - doinsert - insert a sop into the strip  == static void doinsert(struct parse *p, sop op, size_t opnd, sopno pos);  */
end_comment

begin_function
specifier|static
name|void
name|doinsert
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|sop
name|op
parameter_list|,
name|size_t
name|opnd
parameter_list|,
name|sopno
name|pos
parameter_list|)
block|{
name|sopno
name|sn
decl_stmt|;
name|sop
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* avoid making error situations worse */
if|if
condition|(
name|p
operator|->
name|error
operator|!=
literal|0
condition|)
return|return;
name|sn
operator|=
name|HERE
argument_list|()
expr_stmt|;
name|EMIT
argument_list|(
name|op
argument_list|,
name|opnd
argument_list|)
expr_stmt|;
comment|/* do checks, ensure space */
name|assert
argument_list|(
name|HERE
argument_list|()
operator|==
name|sn
operator|+
literal|1
argument_list|)
expr_stmt|;
name|s
operator|=
name|p
operator|->
name|strip
index|[
name|sn
index|]
expr_stmt|;
comment|/* adjust paren pointers */
name|assert
argument_list|(
name|pos
operator|>
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NPAREN
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p
operator|->
name|pbegin
index|[
name|i
index|]
operator|>=
name|pos
condition|)
block|{
name|p
operator|->
name|pbegin
index|[
name|i
index|]
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|pend
index|[
name|i
index|]
operator|>=
name|pos
condition|)
block|{
name|p
operator|->
name|pend
index|[
name|i
index|]
operator|++
expr_stmt|;
block|}
block|}
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|p
operator|->
name|strip
index|[
name|pos
operator|+
literal|1
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|p
operator|->
name|strip
index|[
name|pos
index|]
argument_list|,
operator|(
name|HERE
argument_list|()
operator|-
name|pos
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|sop
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|strip
index|[
name|pos
index|]
operator|=
name|s
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - dofwd - complete a forward reference  == static void dofwd(struct parse *p, sopno pos, sop value);  */
end_comment

begin_function
specifier|static
name|void
name|dofwd
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|sopno
name|pos
parameter_list|,
name|sop
name|value
parameter_list|)
block|{
comment|/* avoid making error situations worse */
if|if
condition|(
name|p
operator|->
name|error
operator|!=
literal|0
condition|)
return|return;
name|assert
argument_list|(
name|value
operator|<
literal|1
operator|<<
name|OPSHIFT
argument_list|)
expr_stmt|;
name|p
operator|->
name|strip
index|[
name|pos
index|]
operator|=
name|OP
argument_list|(
name|p
operator|->
name|strip
index|[
name|pos
index|]
argument_list|)
operator||
name|value
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - enlarge - enlarge the strip  == static void enlarge(struct parse *p, sopno size);  */
end_comment

begin_function
specifier|static
name|void
name|enlarge
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|sopno
name|size
parameter_list|)
block|{
name|sop
modifier|*
name|sp
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|ssize
operator|>=
name|size
condition|)
return|return;
name|sp
operator|=
operator|(
name|sop
operator|*
operator|)
name|realloc
argument_list|(
name|p
operator|->
name|strip
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
name|sop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
block|{
name|SETERROR
argument_list|(
name|REG_ESPACE
argument_list|)
expr_stmt|;
return|return;
block|}
name|p
operator|->
name|strip
operator|=
name|sp
expr_stmt|;
name|p
operator|->
name|ssize
operator|=
name|size
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - stripsnug - compact the strip  == static void stripsnug(struct parse *p, struct re_guts *g);  */
end_comment

begin_function
specifier|static
name|void
name|stripsnug
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|struct
name|re_guts
modifier|*
name|g
parameter_list|)
block|{
name|g
operator|->
name|nstates
operator|=
name|p
operator|->
name|slen
expr_stmt|;
name|g
operator|->
name|strip
operator|=
operator|(
name|sop
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|->
name|strip
argument_list|,
name|p
operator|->
name|slen
operator|*
sizeof|sizeof
argument_list|(
name|sop
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|strip
operator|==
name|NULL
condition|)
block|{
name|SETERROR
argument_list|(
name|REG_ESPACE
argument_list|)
expr_stmt|;
name|g
operator|->
name|strip
operator|=
name|p
operator|->
name|strip
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  - findmust - fill in must and mlen with longest mandatory literal string  == static void findmust(struct parse *p, struct re_guts *g);  *  * This algorithm could do fancy things like analyzing the operands of |  * for common subsequences.  Someday.  This code is simple and finds most  * of the interesting cases.  *  * Note that must and mlen got initialized during setup.  */
end_comment

begin_function
specifier|static
name|void
name|findmust
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|struct
name|re_guts
modifier|*
name|g
parameter_list|)
block|{
name|sop
modifier|*
name|scan
decl_stmt|;
name|sop
modifier|*
name|start
decl_stmt|;
name|sop
modifier|*
name|newstart
decl_stmt|;
name|sopno
name|newlen
decl_stmt|;
name|sop
name|s
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|char
name|buf
index|[
name|MB_LEN_MAX
index|]
decl_stmt|;
name|size_t
name|clen
decl_stmt|;
name|mbstate_t
name|mbs
decl_stmt|;
comment|/* avoid making error situations worse */
if|if
condition|(
name|p
operator|->
name|error
operator|!=
literal|0
condition|)
return|return;
comment|/* 	 * It's not generally safe to do a ``char'' substring search on 	 * multibyte character strings, but it's safe for at least 	 * UTF-8 (see RFC 3629). 	 */
if|if
condition|(
name|MB_CUR_MAX
operator|>
literal|1
operator|&&
name|strcmp
argument_list|(
name|_CurrentRuneLocale
operator|->
name|__encoding
argument_list|,
literal|"UTF-8"
argument_list|)
operator|!=
literal|0
condition|)
return|return;
comment|/* find the longest OCHAR sequence in strip */
name|newlen
operator|=
literal|0
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|moffset
operator|=
literal|0
expr_stmt|;
name|scan
operator|=
name|g
operator|->
name|strip
operator|+
literal|1
expr_stmt|;
do|do
block|{
name|s
operator|=
operator|*
name|scan
operator|++
expr_stmt|;
switch|switch
condition|(
name|OP
argument_list|(
name|s
argument_list|)
condition|)
block|{
case|case
name|OCHAR
case|:
comment|/* sequence member */
if|if
condition|(
name|newlen
operator|==
literal|0
condition|)
block|{
comment|/* new sequence */
name|memset
argument_list|(
operator|&
name|mbs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbs
argument_list|)
argument_list|)
expr_stmt|;
name|newstart
operator|=
name|scan
operator|-
literal|1
expr_stmt|;
block|}
name|clen
operator|=
name|wcrtomb
argument_list|(
name|buf
argument_list|,
name|OPND
argument_list|(
name|s
argument_list|)
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
if|if
condition|(
name|clen
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
goto|goto
name|toohard
goto|;
name|newlen
operator|+=
name|clen
expr_stmt|;
break|break;
case|case
name|OPLUS_
case|:
comment|/* things that don't break one */
case|case
name|OLPAREN
case|:
case|case
name|ORPAREN
case|:
break|break;
case|case
name|OQUEST_
case|:
comment|/* things that must be skipped */
case|case
name|OCH_
case|:
name|offset
operator|=
name|altoffset
argument_list|(
name|scan
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|scan
operator|--
expr_stmt|;
do|do
block|{
name|scan
operator|+=
name|OPND
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
operator|*
name|scan
expr_stmt|;
comment|/* assert() interferes w debug printouts */
if|if
condition|(
name|OP
argument_list|(
name|s
argument_list|)
operator|!=
name|O_QUEST
operator|&&
name|OP
argument_list|(
name|s
argument_list|)
operator|!=
name|O_CH
operator|&&
name|OP
argument_list|(
name|s
argument_list|)
operator|!=
name|OOR2
condition|)
block|{
name|g
operator|->
name|iflags
operator||=
name|BAD
expr_stmt|;
return|return;
block|}
block|}
do|while
condition|(
name|OP
argument_list|(
name|s
argument_list|)
operator|!=
name|O_QUEST
operator|&&
name|OP
argument_list|(
name|s
argument_list|)
operator|!=
name|O_CH
condition|)
do|;
comment|/* FALLTHROUGH */
case|case
name|OBOW
case|:
comment|/* things that break a sequence */
case|case
name|OEOW
case|:
case|case
name|OBOL
case|:
case|case
name|OEOL
case|:
case|case
name|O_QUEST
case|:
case|case
name|O_CH
case|:
case|case
name|OEND
case|:
if|if
condition|(
name|newlen
operator|>
name|g
operator|->
name|mlen
condition|)
block|{
comment|/* ends one */
name|start
operator|=
name|newstart
expr_stmt|;
name|g
operator|->
name|mlen
operator|=
name|newlen
expr_stmt|;
if|if
condition|(
name|offset
operator|>
operator|-
literal|1
condition|)
block|{
name|g
operator|->
name|moffset
operator|+=
name|offset
expr_stmt|;
name|offset
operator|=
name|newlen
expr_stmt|;
block|}
else|else
name|g
operator|->
name|moffset
operator|=
name|offset
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|offset
operator|>
operator|-
literal|1
condition|)
name|offset
operator|+=
name|newlen
expr_stmt|;
block|}
name|newlen
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OANY
case|:
if|if
condition|(
name|newlen
operator|>
name|g
operator|->
name|mlen
condition|)
block|{
comment|/* ends one */
name|start
operator|=
name|newstart
expr_stmt|;
name|g
operator|->
name|mlen
operator|=
name|newlen
expr_stmt|;
if|if
condition|(
name|offset
operator|>
operator|-
literal|1
condition|)
block|{
name|g
operator|->
name|moffset
operator|+=
name|offset
expr_stmt|;
name|offset
operator|=
name|newlen
expr_stmt|;
block|}
else|else
name|g
operator|->
name|moffset
operator|=
name|offset
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|offset
operator|>
operator|-
literal|1
condition|)
name|offset
operator|+=
name|newlen
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|>
operator|-
literal|1
condition|)
name|offset
operator|++
expr_stmt|;
name|newlen
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OANYOF
case|:
comment|/* may or may not invalidate offset */
comment|/* First, everything as OANY */
if|if
condition|(
name|newlen
operator|>
name|g
operator|->
name|mlen
condition|)
block|{
comment|/* ends one */
name|start
operator|=
name|newstart
expr_stmt|;
name|g
operator|->
name|mlen
operator|=
name|newlen
expr_stmt|;
if|if
condition|(
name|offset
operator|>
operator|-
literal|1
condition|)
block|{
name|g
operator|->
name|moffset
operator|+=
name|offset
expr_stmt|;
name|offset
operator|=
name|newlen
expr_stmt|;
block|}
else|else
name|g
operator|->
name|moffset
operator|=
name|offset
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|offset
operator|>
operator|-
literal|1
condition|)
name|offset
operator|+=
name|newlen
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|>
operator|-
literal|1
condition|)
name|offset
operator|++
expr_stmt|;
name|newlen
operator|=
literal|0
expr_stmt|;
break|break;
name|toohard
label|:
default|default:
comment|/* Anything here makes it impossible or too hard 			 * to calculate the offset -- so we give up; 			 * save the last known good offset, in case the 			 * must sequence doesn't occur later. 			 */
if|if
condition|(
name|newlen
operator|>
name|g
operator|->
name|mlen
condition|)
block|{
comment|/* ends one */
name|start
operator|=
name|newstart
expr_stmt|;
name|g
operator|->
name|mlen
operator|=
name|newlen
expr_stmt|;
if|if
condition|(
name|offset
operator|>
operator|-
literal|1
condition|)
name|g
operator|->
name|moffset
operator|+=
name|offset
expr_stmt|;
else|else
name|g
operator|->
name|moffset
operator|=
name|offset
expr_stmt|;
block|}
name|offset
operator|=
operator|-
literal|1
expr_stmt|;
name|newlen
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|OP
argument_list|(
name|s
argument_list|)
operator|!=
name|OEND
condition|)
do|;
if|if
condition|(
name|g
operator|->
name|mlen
operator|==
literal|0
condition|)
block|{
comment|/* there isn't one */
name|g
operator|->
name|moffset
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
comment|/* turn it into a character string */
name|g
operator|->
name|must
operator|=
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
name|g
operator|->
name|mlen
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|must
operator|==
name|NULL
condition|)
block|{
comment|/* argh; just forget it */
name|g
operator|->
name|mlen
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|moffset
operator|=
operator|-
literal|1
expr_stmt|;
return|return;
block|}
name|cp
operator|=
name|g
operator|->
name|must
expr_stmt|;
name|scan
operator|=
name|start
expr_stmt|;
name|memset
argument_list|(
operator|&
name|mbs
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mbs
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|g
operator|->
name|must
operator|+
name|g
operator|->
name|mlen
condition|)
block|{
while|while
condition|(
name|OP
argument_list|(
name|s
operator|=
operator|*
name|scan
operator|++
argument_list|)
operator|!=
name|OCHAR
condition|)
continue|continue;
name|clen
operator|=
name|wcrtomb
argument_list|(
name|cp
argument_list|,
name|OPND
argument_list|(
name|s
argument_list|)
argument_list|,
operator|&
name|mbs
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|clen
operator|!=
operator|(
name|size_t
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|clen
expr_stmt|;
block|}
name|assert
argument_list|(
name|cp
operator|==
name|g
operator|->
name|must
operator|+
name|g
operator|->
name|mlen
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* just on general principles */
block|}
end_function

begin_comment
comment|/*  - altoffset - choose biggest offset among multiple choices  == static int altoffset(sop *scan, int offset);  *  * Compute, recursively if necessary, the largest offset among multiple  * re paths.  */
end_comment

begin_function
specifier|static
name|int
name|altoffset
parameter_list|(
name|sop
modifier|*
name|scan
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|int
name|largest
decl_stmt|;
name|int
name|try
decl_stmt|;
name|sop
name|s
decl_stmt|;
comment|/* If we gave up already on offsets, return */
if|if
condition|(
name|offset
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|largest
operator|=
literal|0
expr_stmt|;
name|try
operator|=
literal|0
expr_stmt|;
name|s
operator|=
operator|*
name|scan
operator|++
expr_stmt|;
while|while
condition|(
name|OP
argument_list|(
name|s
argument_list|)
operator|!=
name|O_QUEST
operator|&&
name|OP
argument_list|(
name|s
argument_list|)
operator|!=
name|O_CH
condition|)
block|{
switch|switch
condition|(
name|OP
argument_list|(
name|s
argument_list|)
condition|)
block|{
case|case
name|OOR1
case|:
if|if
condition|(
name|try
operator|>
name|largest
condition|)
name|largest
operator|=
name|try
expr_stmt|;
name|try
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|OQUEST_
case|:
case|case
name|OCH_
case|:
name|try
operator|=
name|altoffset
argument_list|(
name|scan
argument_list|,
name|try
argument_list|)
expr_stmt|;
if|if
condition|(
name|try
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|scan
operator|--
expr_stmt|;
do|do
block|{
name|scan
operator|+=
name|OPND
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
operator|*
name|scan
expr_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|s
argument_list|)
operator|!=
name|O_QUEST
operator|&&
name|OP
argument_list|(
name|s
argument_list|)
operator|!=
name|O_CH
operator|&&
name|OP
argument_list|(
name|s
argument_list|)
operator|!=
name|OOR2
condition|)
return|return
operator|-
literal|1
return|;
block|}
do|while
condition|(
name|OP
argument_list|(
name|s
argument_list|)
operator|!=
name|O_QUEST
operator|&&
name|OP
argument_list|(
name|s
argument_list|)
operator|!=
name|O_CH
condition|)
do|;
comment|/* We must skip to the next position, or we'll 			 * leave altoffset() too early. 			 */
name|scan
operator|++
expr_stmt|;
break|break;
case|case
name|OANYOF
case|:
case|case
name|OCHAR
case|:
case|case
name|OANY
case|:
name|try
operator|++
expr_stmt|;
case|case
name|OBOW
case|:
case|case
name|OEOW
case|:
case|case
name|OLPAREN
case|:
case|case
name|ORPAREN
case|:
case|case
name|OOR2
case|:
break|break;
default|default:
name|try
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|try
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|s
operator|=
operator|*
name|scan
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|try
operator|>
name|largest
condition|)
name|largest
operator|=
name|try
expr_stmt|;
return|return
name|largest
operator|+
name|offset
return|;
block|}
end_function

begin_comment
comment|/*  - computejumps - compute char jumps for BM scan  == static void computejumps(struct parse *p, struct re_guts *g);  *  * This algorithm assumes g->must exists and is has size greater than  * zero. It's based on the algorithm found on Computer Algorithms by  * Sara Baase.  *  * A char jump is the number of characters one needs to jump based on  * the value of the character from the text that was mismatched.  */
end_comment

begin_function
specifier|static
name|void
name|computejumps
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|struct
name|re_guts
modifier|*
name|g
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
name|int
name|mindex
decl_stmt|;
comment|/* Avoid making errors worse */
if|if
condition|(
name|p
operator|->
name|error
operator|!=
literal|0
condition|)
return|return;
name|g
operator|->
name|charjump
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|NC
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|charjump
operator|==
name|NULL
condition|)
comment|/* Not a fatal error */
return|return;
comment|/* Adjust for signed chars, if necessary */
name|g
operator|->
name|charjump
operator|=
operator|&
name|g
operator|->
name|charjump
index|[
operator|-
operator|(
name|CHAR_MIN
operator|)
index|]
expr_stmt|;
comment|/* If the character does not exist in the pattern, the jump 	 * is equal to the number of characters in the pattern. 	 */
for|for
control|(
name|ch
operator|=
name|CHAR_MIN
init|;
name|ch
operator|<
operator|(
name|CHAR_MAX
operator|+
literal|1
operator|)
condition|;
name|ch
operator|++
control|)
name|g
operator|->
name|charjump
index|[
name|ch
index|]
operator|=
name|g
operator|->
name|mlen
expr_stmt|;
comment|/* If the character does exist, compute the jump that would 	 * take us to the last character in the pattern equal to it 	 * (notice that we match right to left, so that last character 	 * is the first one that would be matched). 	 */
for|for
control|(
name|mindex
operator|=
literal|0
init|;
name|mindex
operator|<
name|g
operator|->
name|mlen
condition|;
name|mindex
operator|++
control|)
name|g
operator|->
name|charjump
index|[
operator|(
name|int
operator|)
name|g
operator|->
name|must
index|[
name|mindex
index|]
index|]
operator|=
name|g
operator|->
name|mlen
operator|-
name|mindex
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - computematchjumps - compute match jumps for BM scan  == static void computematchjumps(struct parse *p, struct re_guts *g);  *  * This algorithm assumes g->must exists and is has size greater than  * zero. It's based on the algorithm found on Computer Algorithms by  * Sara Baase.  *  * A match jump is the number of characters one needs to advance based  * on the already-matched suffix.  * Notice that all values here are minus (g->mlen-1), because of the way  * the search algorithm works.  */
end_comment

begin_function
specifier|static
name|void
name|computematchjumps
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|struct
name|re_guts
modifier|*
name|g
parameter_list|)
block|{
name|int
name|mindex
decl_stmt|;
comment|/* General "must" iterator */
name|int
name|suffix
decl_stmt|;
comment|/* Keeps track of matching suffix */
name|int
name|ssuffix
decl_stmt|;
comment|/* Keeps track of suffixes' suffix */
name|int
modifier|*
name|pmatches
decl_stmt|;
comment|/* pmatches[k] points to the next i 				 * such that i+1...mlen is a substring 				 * of k+1...k+mlen-i-1 				 */
comment|/* Avoid making errors worse */
if|if
condition|(
name|p
operator|->
name|error
operator|!=
literal|0
condition|)
return|return;
name|pmatches
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
name|g
operator|->
name|mlen
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pmatches
operator|==
name|NULL
condition|)
block|{
name|g
operator|->
name|matchjump
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|g
operator|->
name|matchjump
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
name|g
operator|->
name|mlen
operator|*
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|matchjump
operator|==
name|NULL
condition|)
comment|/* Not a fatal error */
return|return;
comment|/* Set maximum possible jump for each character in the pattern */
for|for
control|(
name|mindex
operator|=
literal|0
init|;
name|mindex
operator|<
name|g
operator|->
name|mlen
condition|;
name|mindex
operator|++
control|)
name|g
operator|->
name|matchjump
index|[
name|mindex
index|]
operator|=
literal|2
operator|*
name|g
operator|->
name|mlen
operator|-
name|mindex
operator|-
literal|1
expr_stmt|;
comment|/* Compute pmatches[] */
for|for
control|(
name|mindex
operator|=
name|g
operator|->
name|mlen
operator|-
literal|1
operator|,
name|suffix
operator|=
name|g
operator|->
name|mlen
init|;
name|mindex
operator|>=
literal|0
condition|;
name|mindex
operator|--
operator|,
name|suffix
operator|--
control|)
block|{
name|pmatches
index|[
name|mindex
index|]
operator|=
name|suffix
expr_stmt|;
comment|/* If a mismatch is found, interrupting the substring, 		 * compute the matchjump for that position. If no 		 * mismatch is found, then a text substring mismatched 		 * against the suffix will also mismatch against the 		 * substring. 		 */
while|while
condition|(
name|suffix
operator|<
name|g
operator|->
name|mlen
operator|&&
name|g
operator|->
name|must
index|[
name|mindex
index|]
operator|!=
name|g
operator|->
name|must
index|[
name|suffix
index|]
condition|)
block|{
name|g
operator|->
name|matchjump
index|[
name|suffix
index|]
operator|=
name|MIN
argument_list|(
name|g
operator|->
name|matchjump
index|[
name|suffix
index|]
argument_list|,
name|g
operator|->
name|mlen
operator|-
name|mindex
operator|-
literal|1
argument_list|)
expr_stmt|;
name|suffix
operator|=
name|pmatches
index|[
name|suffix
index|]
expr_stmt|;
block|}
block|}
comment|/* Compute the matchjump up to the last substring found to jump 	 * to the beginning of the largest must pattern prefix matching 	 * it's own suffix. 	 */
for|for
control|(
name|mindex
operator|=
literal|0
init|;
name|mindex
operator|<=
name|suffix
condition|;
name|mindex
operator|++
control|)
name|g
operator|->
name|matchjump
index|[
name|mindex
index|]
operator|=
name|MIN
argument_list|(
name|g
operator|->
name|matchjump
index|[
name|mindex
index|]
argument_list|,
name|g
operator|->
name|mlen
operator|+
name|suffix
operator|-
name|mindex
argument_list|)
expr_stmt|;
name|ssuffix
operator|=
name|pmatches
index|[
name|suffix
index|]
expr_stmt|;
while|while
condition|(
name|suffix
operator|<
name|g
operator|->
name|mlen
condition|)
block|{
while|while
condition|(
name|suffix
operator|<=
name|ssuffix
operator|&&
name|suffix
operator|<
name|g
operator|->
name|mlen
condition|)
block|{
name|g
operator|->
name|matchjump
index|[
name|suffix
index|]
operator|=
name|MIN
argument_list|(
name|g
operator|->
name|matchjump
index|[
name|suffix
index|]
argument_list|,
name|g
operator|->
name|mlen
operator|+
name|ssuffix
operator|-
name|suffix
argument_list|)
expr_stmt|;
name|suffix
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|suffix
operator|<
name|g
operator|->
name|mlen
condition|)
name|ssuffix
operator|=
name|pmatches
index|[
name|ssuffix
index|]
expr_stmt|;
block|}
name|free
argument_list|(
name|pmatches
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - pluscount - count + nesting  == static sopno pluscount(struct parse *p, struct re_guts *g);  */
end_comment

begin_function
specifier|static
name|sopno
comment|/* nesting depth */
name|pluscount
parameter_list|(
name|struct
name|parse
modifier|*
name|p
parameter_list|,
name|struct
name|re_guts
modifier|*
name|g
parameter_list|)
block|{
name|sop
modifier|*
name|scan
decl_stmt|;
name|sop
name|s
decl_stmt|;
name|sopno
name|plusnest
init|=
literal|0
decl_stmt|;
name|sopno
name|maxnest
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* there may not be an OEND */
name|scan
operator|=
name|g
operator|->
name|strip
operator|+
literal|1
expr_stmt|;
do|do
block|{
name|s
operator|=
operator|*
name|scan
operator|++
expr_stmt|;
switch|switch
condition|(
name|OP
argument_list|(
name|s
argument_list|)
condition|)
block|{
case|case
name|OPLUS_
case|:
name|plusnest
operator|++
expr_stmt|;
break|break;
case|case
name|O_PLUS
case|:
if|if
condition|(
name|plusnest
operator|>
name|maxnest
condition|)
name|maxnest
operator|=
name|plusnest
expr_stmt|;
name|plusnest
operator|--
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|OP
argument_list|(
name|s
argument_list|)
operator|!=
name|OEND
condition|)
do|;
if|if
condition|(
name|plusnest
operator|!=
literal|0
condition|)
name|g
operator|->
name|iflags
operator||=
name|BAD
expr_stmt|;
return|return
operator|(
name|maxnest
operator|)
return|;
block|}
end_function

end_unit

