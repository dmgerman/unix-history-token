begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $OpenBSD: fts.c,v 1.22 1999/10/03 19:22:22 millert Exp $  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_endif
unit|static char sccsid[] = "@(#)fts.c	8.6 (Berkeley) 8/14/94";
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBC_SCCS and not lint */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"namespace.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"fts-compat.h"
end_include

begin_include
include|#
directive|include
file|"un-namespace.h"
end_include

begin_function_decl
name|FTSENT
modifier|*
name|__fts_children_44bsd
parameter_list|(
name|FTS
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|__fts_close_44bsd
parameter_list|(
name|FTS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
modifier|*
name|__fts_get_clientptr_44bsd
parameter_list|(
name|FTS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|FTS
modifier|*
name|__fts_get_stream_44bsd
parameter_list|(
name|FTSENT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|FTS
modifier|*
name|__fts_open_44bsd
parameter_list|(
name|char
modifier|*
specifier|const
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
function_decl|(
modifier|*
function_decl|)
parameter_list|(
specifier|const
name|FTSENT
modifier|*
specifier|const
modifier|*
parameter_list|,
specifier|const
name|FTSENT
modifier|*
specifier|const
modifier|*
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|FTSENT
modifier|*
name|__fts_read_44bsd
parameter_list|(
name|FTS
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|__fts_set_44bsd
parameter_list|(
name|FTS
modifier|*
parameter_list|,
name|FTSENT
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|__fts_set_clientptr_44bsd
parameter_list|(
name|FTS
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|FTSENT
modifier|*
name|fts_alloc
parameter_list|(
name|FTS
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|FTSENT
modifier|*
name|fts_build
parameter_list|(
name|FTS
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fts_lfree
parameter_list|(
name|FTSENT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fts_load
parameter_list|(
name|FTS
modifier|*
parameter_list|,
name|FTSENT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|fts_maxarglen
parameter_list|(
name|char
modifier|*
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fts_padjust
parameter_list|(
name|FTS
modifier|*
parameter_list|,
name|FTSENT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fts_palloc
parameter_list|(
name|FTS
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|FTSENT
modifier|*
name|fts_sort
parameter_list|(
name|FTS
modifier|*
parameter_list|,
name|FTSENT
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_short
name|fts_stat
parameter_list|(
name|FTS
modifier|*
parameter_list|,
name|FTSENT
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fts_safe_changedir
parameter_list|(
name|FTS
modifier|*
parameter_list|,
name|FTSENT
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|fts_ufslinks
parameter_list|(
name|FTS
modifier|*
parameter_list|,
specifier|const
name|FTSENT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|ISDOT
parameter_list|(
name|a
parameter_list|)
value|(a[0] == '.'&& (!a[1] || (a[1] == '.'&& !a[2])))
end_define

begin_define
define|#
directive|define
name|CLR
parameter_list|(
name|opt
parameter_list|)
value|(sp->fts_options&= ~(opt))
end_define

begin_define
define|#
directive|define
name|ISSET
parameter_list|(
name|opt
parameter_list|)
value|(sp->fts_options& (opt))
end_define

begin_define
define|#
directive|define
name|SET
parameter_list|(
name|opt
parameter_list|)
value|(sp->fts_options |= (opt))
end_define

begin_define
define|#
directive|define
name|FCHDIR
parameter_list|(
name|sp
parameter_list|,
name|fd
parameter_list|)
value|(!ISSET(FTS_NOCHDIR)&& fchdir(fd))
end_define

begin_comment
comment|/* fts_build flags */
end_comment

begin_define
define|#
directive|define
name|BCHILD
value|1
end_define

begin_comment
comment|/* fts_children */
end_comment

begin_define
define|#
directive|define
name|BNAMES
value|2
end_define

begin_comment
comment|/* fts_children, names only */
end_comment

begin_define
define|#
directive|define
name|BREAD
value|3
end_define

begin_comment
comment|/* fts_read */
end_comment

begin_comment
comment|/*  * Internal representation of an FTS, including extra implementation  * details.  The FTS returned from fts_open points to this structure's  * ftsp_fts member (and can be cast to an _fts_private as required)  */
end_comment

begin_struct
struct|struct
name|_fts_private
block|{
name|FTS
name|ftsp_fts
decl_stmt|;
name|struct
name|statfs
name|ftsp_statfs
decl_stmt|;
name|dev_t
name|ftsp_dev
decl_stmt|;
name|int
name|ftsp_linksreliable
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * The "FTS_NOSTAT" option can avoid a lot of calls to stat(2) if it  * knows that a directory could not possibly have subdirectories.  This  * is decided by looking at the link count: a subdirectory would  * increment its parent's link count by virtue of its own ".." entry.  * This assumption only holds for UFS-like filesystems that implement  * links and directories this way, so we must punt for others.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ufslike_filesystems
index|[]
init|=
block|{
literal|"ufs"
block|,
literal|"nfs"
block|,
literal|"nfs4"
block|,
literal|"ext2fs"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FTS
modifier|*
name|__fts_open_44bsd
argument_list|(
name|argv
argument_list|,
name|options
argument_list|,
name|compar
argument_list|)
name|char
modifier|*
decl|const
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|options
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|compar
function_decl|)
parameter_list|(
specifier|const
name|FTSENT
modifier|*
specifier|const
modifier|*
parameter_list|,
specifier|const
name|FTSENT
modifier|*
specifier|const
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_block
block|{
name|struct
name|_fts_private
modifier|*
name|priv
decl_stmt|;
name|FTS
modifier|*
name|sp
decl_stmt|;
name|FTSENT
modifier|*
name|p
decl_stmt|,
modifier|*
name|root
decl_stmt|;
name|int
name|nitems
decl_stmt|;
name|FTSENT
modifier|*
name|parent
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* Options check. */
if|if
condition|(
name|options
operator|&
operator|~
name|FTS_OPTIONMASK
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Allocate/initialize the stream. */
if|if
condition|(
operator|(
name|priv
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|memset
argument_list|(
name|priv
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|priv
argument_list|)
argument_list|)
expr_stmt|;
name|sp
operator|=
operator|&
name|priv
operator|->
name|ftsp_fts
expr_stmt|;
name|sp
operator|->
name|fts_compar
operator|=
name|compar
expr_stmt|;
name|sp
operator|->
name|fts_options
operator|=
name|options
expr_stmt|;
comment|/* Shush, GCC. */
name|tmp
operator|=
name|NULL
expr_stmt|;
comment|/* Logical walks turn on NOCHDIR; symbolic links are too hard. */
if|if
condition|(
name|ISSET
argument_list|(
name|FTS_LOGICAL
argument_list|)
condition|)
name|SET
argument_list|(
name|FTS_NOCHDIR
argument_list|)
expr_stmt|;
comment|/* 	 * Start out with 1K of path space, and enough, in any case, 	 * to hold the user's paths. 	 */
if|if
condition|(
name|fts_palloc
argument_list|(
name|sp
argument_list|,
name|MAX
argument_list|(
name|fts_maxarglen
argument_list|(
name|argv
argument_list|)
argument_list|,
name|MAXPATHLEN
argument_list|)
argument_list|)
condition|)
goto|goto
name|mem1
goto|;
comment|/* Allocate/initialize root's parent. */
if|if
condition|(
operator|(
name|parent
operator|=
name|fts_alloc
argument_list|(
name|sp
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|mem2
goto|;
name|parent
operator|->
name|fts_level
operator|=
name|FTS_ROOTPARENTLEVEL
expr_stmt|;
comment|/* Allocate/initialize root(s). */
for|for
control|(
name|root
operator|=
name|NULL
operator|,
name|nitems
operator|=
literal|0
init|;
operator|*
name|argv
operator|!=
name|NULL
condition|;
operator|++
name|argv
operator|,
operator|++
name|nitems
control|)
block|{
comment|/* Don't allow zero-length paths. */
if|if
condition|(
operator|(
name|len
operator|=
name|strlen
argument_list|(
operator|*
name|argv
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|mem3
goto|;
block|}
name|p
operator|=
name|fts_alloc
argument_list|(
name|sp
argument_list|,
operator|*
name|argv
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|p
operator|->
name|fts_level
operator|=
name|FTS_ROOTLEVEL
expr_stmt|;
name|p
operator|->
name|fts_parent
operator|=
name|parent
expr_stmt|;
name|p
operator|->
name|fts_accpath
operator|=
name|p
operator|->
name|fts_name
expr_stmt|;
name|p
operator|->
name|fts_info
operator|=
name|fts_stat
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
name|ISSET
argument_list|(
name|FTS_COMFOLLOW
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Command-line "." and ".." are real directories. */
if|if
condition|(
name|p
operator|->
name|fts_info
operator|==
name|FTS_DOT
condition|)
name|p
operator|->
name|fts_info
operator|=
name|FTS_D
expr_stmt|;
comment|/* 		 * If comparison routine supplied, traverse in sorted 		 * order; otherwise traverse in the order specified. 		 */
if|if
condition|(
name|compar
condition|)
block|{
name|p
operator|->
name|fts_link
operator|=
name|root
expr_stmt|;
name|root
operator|=
name|p
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|fts_link
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|root
operator|==
name|NULL
condition|)
name|tmp
operator|=
name|root
operator|=
name|p
expr_stmt|;
else|else
block|{
name|tmp
operator|->
name|fts_link
operator|=
name|p
expr_stmt|;
name|tmp
operator|=
name|p
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|compar
operator|&&
name|nitems
operator|>
literal|1
condition|)
name|root
operator|=
name|fts_sort
argument_list|(
name|sp
argument_list|,
name|root
argument_list|,
name|nitems
argument_list|)
expr_stmt|;
comment|/* 	 * Allocate a dummy pointer and make fts_read think that we've just 	 * finished the node before the root(s); set p->fts_info to FTS_INIT 	 * so that everything about the "current" node is ignored. 	 */
if|if
condition|(
operator|(
name|sp
operator|->
name|fts_cur
operator|=
name|fts_alloc
argument_list|(
name|sp
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|mem3
goto|;
name|sp
operator|->
name|fts_cur
operator|->
name|fts_link
operator|=
name|root
expr_stmt|;
name|sp
operator|->
name|fts_cur
operator|->
name|fts_info
operator|=
name|FTS_INIT
expr_stmt|;
comment|/* 	 * If using chdir(2), grab a file descriptor pointing to dot to ensure 	 * that we can get back here; this could be avoided for some paths, 	 * but almost certainly not worth the effort.  Slashes, symbolic links, 	 * and ".." are all fairly nasty problems.  Note, if we can't get the 	 * descriptor we run anyway, just more slowly. 	 */
if|if
condition|(
operator|!
name|ISSET
argument_list|(
name|FTS_NOCHDIR
argument_list|)
operator|&&
operator|(
name|sp
operator|->
name|fts_rfd
operator|=
name|_open
argument_list|(
literal|"."
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|SET
argument_list|(
name|FTS_NOCHDIR
argument_list|)
expr_stmt|;
return|return
operator|(
name|sp
operator|)
return|;
name|mem3
label|:
name|fts_lfree
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|mem2
label|:
name|free
argument_list|(
name|sp
operator|->
name|fts_path
argument_list|)
expr_stmt|;
name|mem1
label|:
name|free
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|fts_load
parameter_list|(
name|sp
parameter_list|,
name|p
parameter_list|)
name|FTS
modifier|*
name|sp
decl_stmt|;
name|FTSENT
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* 	 * Load the stream structure for the next traversal.  Since we don't 	 * actually enter the directory until after the preorder visit, set 	 * the fts_accpath field specially so the chdir gets done to the right 	 * place and the user can access the first node.  From fts_open it's 	 * known that the path will fit. 	 */
name|len
operator|=
name|p
operator|->
name|fts_pathlen
operator|=
name|p
operator|->
name|fts_namelen
expr_stmt|;
name|memmove
argument_list|(
name|sp
operator|->
name|fts_path
argument_list|,
name|p
operator|->
name|fts_name
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strrchr
argument_list|(
name|p
operator|->
name|fts_name
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|&&
operator|(
name|cp
operator|!=
name|p
operator|->
name|fts_name
operator|||
name|cp
index|[
literal|1
index|]
operator|)
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
operator|++
name|cp
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|p
operator|->
name|fts_name
argument_list|,
name|cp
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|->
name|fts_namelen
operator|=
name|len
expr_stmt|;
block|}
name|p
operator|->
name|fts_accpath
operator|=
name|p
operator|->
name|fts_path
operator|=
name|sp
operator|->
name|fts_path
expr_stmt|;
name|sp
operator|->
name|fts_dev
operator|=
name|p
operator|->
name|fts_dev
expr_stmt|;
block|}
end_function

begin_function
name|int
name|__fts_close_44bsd
parameter_list|(
name|sp
parameter_list|)
name|FTS
modifier|*
name|sp
decl_stmt|;
block|{
name|FTSENT
modifier|*
name|freep
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|saved_errno
decl_stmt|;
comment|/* 	 * This still works if we haven't read anything -- the dummy structure 	 * points to the root list, so we step through to the end of the root 	 * list which has a valid parent pointer. 	 */
if|if
condition|(
name|sp
operator|->
name|fts_cur
condition|)
block|{
for|for
control|(
name|p
operator|=
name|sp
operator|->
name|fts_cur
init|;
name|p
operator|->
name|fts_level
operator|>=
name|FTS_ROOTLEVEL
condition|;
control|)
block|{
name|freep
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|fts_link
operator|!=
name|NULL
condition|?
name|p
operator|->
name|fts_link
else|:
name|p
operator|->
name|fts_parent
expr_stmt|;
name|free
argument_list|(
name|freep
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* Free up child linked list, sort array, path buffer. */
if|if
condition|(
name|sp
operator|->
name|fts_child
condition|)
name|fts_lfree
argument_list|(
name|sp
operator|->
name|fts_child
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|fts_array
condition|)
name|free
argument_list|(
name|sp
operator|->
name|fts_array
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|sp
operator|->
name|fts_path
argument_list|)
expr_stmt|;
comment|/* Return to original directory, save errno if necessary. */
if|if
condition|(
operator|!
name|ISSET
argument_list|(
name|FTS_NOCHDIR
argument_list|)
condition|)
block|{
name|saved_errno
operator|=
name|fchdir
argument_list|(
name|sp
operator|->
name|fts_rfd
argument_list|)
condition|?
name|errno
else|:
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|_close
argument_list|(
name|sp
operator|->
name|fts_rfd
argument_list|)
expr_stmt|;
comment|/* Set errno and return. */
if|if
condition|(
name|saved_errno
operator|!=
literal|0
condition|)
block|{
comment|/* Free up the stream pointer. */
name|free
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|errno
operator|=
name|saved_errno
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* Free up the stream pointer. */
name|free
argument_list|(
name|sp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Special case of "/" at the end of the path so that slashes aren't  * appended which would cause paths to be written as "....//foo".  */
end_comment

begin_define
define|#
directive|define
name|NAPPEND
parameter_list|(
name|p
parameter_list|)
define|\
value|(p->fts_path[p->fts_pathlen - 1] == '/'				\ 	    ? p->fts_pathlen - 1 : p->fts_pathlen)
end_define

begin_function
name|FTSENT
modifier|*
name|__fts_read_44bsd
parameter_list|(
name|sp
parameter_list|)
name|FTS
modifier|*
name|sp
decl_stmt|;
block|{
name|FTSENT
modifier|*
name|p
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|int
name|instr
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
name|int
name|saved_errno
decl_stmt|;
comment|/* If finished or unrecoverable error, return NULL. */
if|if
condition|(
name|sp
operator|->
name|fts_cur
operator|==
name|NULL
operator|||
name|ISSET
argument_list|(
name|FTS_STOP
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Set current node pointer. */
name|p
operator|=
name|sp
operator|->
name|fts_cur
expr_stmt|;
comment|/* Save and zero out user instructions. */
name|instr
operator|=
name|p
operator|->
name|fts_instr
expr_stmt|;
name|p
operator|->
name|fts_instr
operator|=
name|FTS_NOINSTR
expr_stmt|;
comment|/* Any type of file may be re-visited; re-stat and re-turn. */
if|if
condition|(
name|instr
operator|==
name|FTS_AGAIN
condition|)
block|{
name|p
operator|->
name|fts_info
operator|=
name|fts_stat
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
comment|/* 	 * Following a symlink -- SLNONE test allows application to see 	 * SLNONE and recover.  If indirecting through a symlink, have 	 * keep a pointer to current location.  If unable to get that 	 * pointer, follow fails. 	 */
if|if
condition|(
name|instr
operator|==
name|FTS_FOLLOW
operator|&&
operator|(
name|p
operator|->
name|fts_info
operator|==
name|FTS_SL
operator|||
name|p
operator|->
name|fts_info
operator|==
name|FTS_SLNONE
operator|)
condition|)
block|{
name|p
operator|->
name|fts_info
operator|=
name|fts_stat
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|fts_info
operator|==
name|FTS_D
operator|&&
operator|!
name|ISSET
argument_list|(
name|FTS_NOCHDIR
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|->
name|fts_symfd
operator|=
name|_open
argument_list|(
literal|"."
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|p
operator|->
name|fts_errno
operator|=
name|errno
expr_stmt|;
name|p
operator|->
name|fts_info
operator|=
name|FTS_ERR
expr_stmt|;
block|}
else|else
name|p
operator|->
name|fts_flags
operator||=
name|FTS_SYMFOLLOW
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
comment|/* Directory in pre-order. */
if|if
condition|(
name|p
operator|->
name|fts_info
operator|==
name|FTS_D
condition|)
block|{
comment|/* If skipped or crossed mount point, do post-order visit. */
if|if
condition|(
name|instr
operator|==
name|FTS_SKIP
operator|||
operator|(
name|ISSET
argument_list|(
name|FTS_XDEV
argument_list|)
operator|&&
name|p
operator|->
name|fts_dev
operator|!=
name|sp
operator|->
name|fts_dev
operator|)
condition|)
block|{
if|if
condition|(
name|p
operator|->
name|fts_flags
operator|&
name|FTS_SYMFOLLOW
condition|)
operator|(
name|void
operator|)
name|_close
argument_list|(
name|p
operator|->
name|fts_symfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|->
name|fts_child
condition|)
block|{
name|fts_lfree
argument_list|(
name|sp
operator|->
name|fts_child
argument_list|)
expr_stmt|;
name|sp
operator|->
name|fts_child
operator|=
name|NULL
expr_stmt|;
block|}
name|p
operator|->
name|fts_info
operator|=
name|FTS_DP
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
comment|/* Rebuild if only read the names and now traversing. */
if|if
condition|(
name|sp
operator|->
name|fts_child
operator|!=
name|NULL
operator|&&
name|ISSET
argument_list|(
name|FTS_NAMEONLY
argument_list|)
condition|)
block|{
name|CLR
argument_list|(
name|FTS_NAMEONLY
argument_list|)
expr_stmt|;
name|fts_lfree
argument_list|(
name|sp
operator|->
name|fts_child
argument_list|)
expr_stmt|;
name|sp
operator|->
name|fts_child
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 		 * Cd to the subdirectory. 		 * 		 * If have already read and now fail to chdir, whack the list 		 * to make the names come out right, and set the parent errno 		 * so the application will eventually get an error condition. 		 * Set the FTS_DONTCHDIR flag so that when we logically change 		 * directories back to the parent we don't do a chdir. 		 * 		 * If haven't read do so.  If the read fails, fts_build sets 		 * FTS_STOP or the fts_info field of the node. 		 */
if|if
condition|(
name|sp
operator|->
name|fts_child
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fts_safe_changedir
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
operator|-
literal|1
argument_list|,
name|p
operator|->
name|fts_accpath
argument_list|)
condition|)
block|{
name|p
operator|->
name|fts_errno
operator|=
name|errno
expr_stmt|;
name|p
operator|->
name|fts_flags
operator||=
name|FTS_DONTCHDIR
expr_stmt|;
for|for
control|(
name|p
operator|=
name|sp
operator|->
name|fts_child
init|;
name|p
operator|!=
name|NULL
condition|;
name|p
operator|=
name|p
operator|->
name|fts_link
control|)
name|p
operator|->
name|fts_accpath
operator|=
name|p
operator|->
name|fts_parent
operator|->
name|fts_accpath
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|sp
operator|->
name|fts_child
operator|=
name|fts_build
argument_list|(
name|sp
argument_list|,
name|BREAD
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ISSET
argument_list|(
name|FTS_STOP
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|p
operator|)
return|;
block|}
name|p
operator|=
name|sp
operator|->
name|fts_child
expr_stmt|;
name|sp
operator|->
name|fts_child
operator|=
name|NULL
expr_stmt|;
goto|goto
name|name
goto|;
block|}
comment|/* Move to the next node on this level. */
name|next
label|:
name|tmp
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|p
operator|->
name|fts_link
operator|)
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
comment|/* 		 * If reached the top, return to the original directory (or 		 * the root of the tree), and load the paths for the next root. 		 */
if|if
condition|(
name|p
operator|->
name|fts_level
operator|==
name|FTS_ROOTLEVEL
condition|)
block|{
if|if
condition|(
name|FCHDIR
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|fts_rfd
argument_list|)
condition|)
block|{
name|SET
argument_list|(
name|FTS_STOP
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|fts_load
argument_list|(
name|sp
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|sp
operator|->
name|fts_cur
operator|=
name|p
operator|)
return|;
block|}
comment|/* 		 * User may have called fts_set on the node.  If skipped, 		 * ignore.  If followed, get a file descriptor so we can 		 * get back if necessary. 		 */
if|if
condition|(
name|p
operator|->
name|fts_instr
operator|==
name|FTS_SKIP
condition|)
goto|goto
name|next
goto|;
if|if
condition|(
name|p
operator|->
name|fts_instr
operator|==
name|FTS_FOLLOW
condition|)
block|{
name|p
operator|->
name|fts_info
operator|=
name|fts_stat
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|fts_info
operator|==
name|FTS_D
operator|&&
operator|!
name|ISSET
argument_list|(
name|FTS_NOCHDIR
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|->
name|fts_symfd
operator|=
name|_open
argument_list|(
literal|"."
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|p
operator|->
name|fts_errno
operator|=
name|errno
expr_stmt|;
name|p
operator|->
name|fts_info
operator|=
name|FTS_ERR
expr_stmt|;
block|}
else|else
name|p
operator|->
name|fts_flags
operator||=
name|FTS_SYMFOLLOW
expr_stmt|;
block|}
name|p
operator|->
name|fts_instr
operator|=
name|FTS_NOINSTR
expr_stmt|;
block|}
name|name
label|:
name|t
operator|=
name|sp
operator|->
name|fts_path
operator|+
name|NAPPEND
argument_list|(
name|p
operator|->
name|fts_parent
argument_list|)
expr_stmt|;
operator|*
name|t
operator|++
operator|=
literal|'/'
expr_stmt|;
name|memmove
argument_list|(
name|t
argument_list|,
name|p
operator|->
name|fts_name
argument_list|,
name|p
operator|->
name|fts_namelen
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|sp
operator|->
name|fts_cur
operator|=
name|p
operator|)
return|;
block|}
comment|/* Move up to the parent node. */
name|p
operator|=
name|tmp
operator|->
name|fts_parent
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|fts_level
operator|==
name|FTS_ROOTPARENTLEVEL
condition|)
block|{
comment|/* 		 * Done; free everything up and set errno to 0 so the user 		 * can distinguish between error and EOF. 		 */
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|sp
operator|->
name|fts_cur
operator|=
name|NULL
operator|)
return|;
block|}
comment|/* NUL terminate the pathname. */
name|sp
operator|->
name|fts_path
index|[
name|p
operator|->
name|fts_pathlen
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * Return to the parent directory.  If at a root node or came through 	 * a symlink, go back through the file descriptor.  Otherwise, cd up 	 * one directory. 	 */
if|if
condition|(
name|p
operator|->
name|fts_level
operator|==
name|FTS_ROOTLEVEL
condition|)
block|{
if|if
condition|(
name|FCHDIR
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|fts_rfd
argument_list|)
condition|)
block|{
name|SET
argument_list|(
name|FTS_STOP
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|fts_flags
operator|&
name|FTS_SYMFOLLOW
condition|)
block|{
if|if
condition|(
name|FCHDIR
argument_list|(
name|sp
argument_list|,
name|p
operator|->
name|fts_symfd
argument_list|)
condition|)
block|{
name|saved_errno
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|_close
argument_list|(
name|p
operator|->
name|fts_symfd
argument_list|)
expr_stmt|;
name|errno
operator|=
name|saved_errno
expr_stmt|;
name|SET
argument_list|(
name|FTS_STOP
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|_close
argument_list|(
name|p
operator|->
name|fts_symfd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|p
operator|->
name|fts_flags
operator|&
name|FTS_DONTCHDIR
operator|)
operator|&&
name|fts_safe_changedir
argument_list|(
name|sp
argument_list|,
name|p
operator|->
name|fts_parent
argument_list|,
operator|-
literal|1
argument_list|,
literal|".."
argument_list|)
condition|)
block|{
name|SET
argument_list|(
name|FTS_STOP
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|p
operator|->
name|fts_info
operator|=
name|p
operator|->
name|fts_errno
condition|?
name|FTS_ERR
else|:
name|FTS_DP
expr_stmt|;
return|return
operator|(
name|sp
operator|->
name|fts_cur
operator|=
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fts_set takes the stream as an argument although it's not used in this  * implementation; it would be necessary if anyone wanted to add global  * semantics to fts using fts_set.  An error return is allowed for similar  * reasons.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|__fts_set_44bsd
parameter_list|(
name|sp
parameter_list|,
name|p
parameter_list|,
name|instr
parameter_list|)
name|FTS
modifier|*
name|sp
decl_stmt|;
name|FTSENT
modifier|*
name|p
decl_stmt|;
name|int
name|instr
decl_stmt|;
block|{
if|if
condition|(
name|instr
operator|!=
literal|0
operator|&&
name|instr
operator|!=
name|FTS_AGAIN
operator|&&
name|instr
operator|!=
name|FTS_FOLLOW
operator|&&
name|instr
operator|!=
name|FTS_NOINSTR
operator|&&
name|instr
operator|!=
name|FTS_SKIP
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|p
operator|->
name|fts_instr
operator|=
name|instr
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|FTSENT
modifier|*
name|__fts_children_44bsd
parameter_list|(
name|sp
parameter_list|,
name|instr
parameter_list|)
name|FTS
modifier|*
name|sp
decl_stmt|;
name|int
name|instr
decl_stmt|;
block|{
name|FTSENT
modifier|*
name|p
decl_stmt|;
name|int
name|fd
decl_stmt|;
if|if
condition|(
name|instr
operator|!=
literal|0
operator|&&
name|instr
operator|!=
name|FTS_NAMEONLY
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Set current node pointer. */
name|p
operator|=
name|sp
operator|->
name|fts_cur
expr_stmt|;
comment|/* 	 * Errno set to 0 so user can distinguish empty directory from 	 * an error. 	 */
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* Fatal errors stop here. */
if|if
condition|(
name|ISSET
argument_list|(
name|FTS_STOP
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Return logical hierarchy of user's arguments. */
if|if
condition|(
name|p
operator|->
name|fts_info
operator|==
name|FTS_INIT
condition|)
return|return
operator|(
name|p
operator|->
name|fts_link
operator|)
return|;
comment|/* 	 * If not a directory being visited in pre-order, stop here.  Could 	 * allow FTS_DNR, assuming the user has fixed the problem, but the 	 * same effect is available with FTS_AGAIN. 	 */
if|if
condition|(
name|p
operator|->
name|fts_info
operator|!=
name|FTS_D
comment|/*&& p->fts_info != FTS_DNR */
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Free up any previous child list. */
if|if
condition|(
name|sp
operator|->
name|fts_child
operator|!=
name|NULL
condition|)
name|fts_lfree
argument_list|(
name|sp
operator|->
name|fts_child
argument_list|)
expr_stmt|;
if|if
condition|(
name|instr
operator|==
name|FTS_NAMEONLY
condition|)
block|{
name|SET
argument_list|(
name|FTS_NAMEONLY
argument_list|)
expr_stmt|;
name|instr
operator|=
name|BNAMES
expr_stmt|;
block|}
else|else
name|instr
operator|=
name|BCHILD
expr_stmt|;
comment|/* 	 * If using chdir on a relative path and called BEFORE fts_read does 	 * its chdir to the root of a traversal, we can lose -- we need to 	 * chdir into the subdirectory, and we don't know where the current 	 * directory is, so we can't get back so that the upcoming chdir by 	 * fts_read will work. 	 */
if|if
condition|(
name|p
operator|->
name|fts_level
operator|!=
name|FTS_ROOTLEVEL
operator|||
name|p
operator|->
name|fts_accpath
index|[
literal|0
index|]
operator|==
literal|'/'
operator|||
name|ISSET
argument_list|(
name|FTS_NOCHDIR
argument_list|)
condition|)
return|return
operator|(
name|sp
operator|->
name|fts_child
operator|=
name|fts_build
argument_list|(
name|sp
argument_list|,
name|instr
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|fd
operator|=
name|_open
argument_list|(
literal|"."
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|sp
operator|->
name|fts_child
operator|=
name|fts_build
argument_list|(
name|sp
argument_list|,
name|instr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fchdir
argument_list|(
name|fd
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
operator|(
name|void
operator|)
name|_close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|sp
operator|->
name|fts_child
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|fts_get_clientptr
end_ifndef

begin_error
error|#
directive|error
literal|"fts_get_clientptr not defined"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
modifier|*
function|(
name|__fts_get_clientptr_44bsd
function|)
parameter_list|(
name|FTS
modifier|*
name|sp
parameter_list|)
block|{
return|return
operator|(
name|fts_get_clientptr
argument_list|(
name|sp
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|fts_get_stream
end_ifndef

begin_error
error|#
directive|error
literal|"fts_get_stream not defined"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|FTS
modifier|*
function|(
name|__fts_get_stream_44bsd
function|)
parameter_list|(
name|FTSENT
modifier|*
name|p
parameter_list|)
block|{
return|return
operator|(
name|fts_get_stream
argument_list|(
name|p
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|__fts_set_clientptr_44bsd
parameter_list|(
name|FTS
modifier|*
name|sp
parameter_list|,
name|void
modifier|*
name|clientptr
parameter_list|)
block|{
name|sp
operator|->
name|fts_clientptr
operator|=
name|clientptr
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is the tricky part -- do not casually change *anything* in here.  The  * idea is to build the linked list of entries that are used by fts_children  * and fts_read.  There are lots of special cases.  *  * The real slowdown in walking the tree is the stat calls.  If FTS_NOSTAT is  * set and it's a physical walk (so that symbolic links can't be directories),  * we can do things quickly.  First, if it's a 4.4BSD file system, the type  * of the file is in the directory entry.  Otherwise, we assume that the number  * of subdirectories in a node is equal to the number of links to the parent.  * The former skips all stat calls.  The latter skips stat calls in any leaf  * directories and for any files after the subdirectories in the directory have  * been found, cutting the stat calls by about 2/3.  */
end_comment

begin_function
specifier|static
name|FTSENT
modifier|*
name|fts_build
parameter_list|(
name|sp
parameter_list|,
name|type
parameter_list|)
name|FTS
modifier|*
name|sp
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|FTSENT
modifier|*
name|p
decl_stmt|,
modifier|*
name|head
decl_stmt|;
name|int
name|nitems
decl_stmt|;
name|FTSENT
modifier|*
name|cur
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
name|DIR
modifier|*
name|dirp
decl_stmt|;
name|void
modifier|*
name|oldaddr
decl_stmt|;
name|size_t
name|dnamlen
decl_stmt|;
name|int
name|cderrno
decl_stmt|,
name|descend
decl_stmt|,
name|len
decl_stmt|,
name|level
decl_stmt|,
name|maxlen
decl_stmt|,
name|nlinks
decl_stmt|,
name|oflag
decl_stmt|,
name|saved_errno
decl_stmt|,
name|nostat
decl_stmt|,
name|doadjust
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* Set current node pointer. */
name|cur
operator|=
name|sp
operator|->
name|fts_cur
expr_stmt|;
comment|/* 	 * Open the directory for reading.  If this fails, we're done. 	 * If being called from fts_read, set the fts_info field. 	 */
ifdef|#
directive|ifdef
name|FTS_WHITEOUT
if|if
condition|(
name|ISSET
argument_list|(
name|FTS_WHITEOUT
argument_list|)
condition|)
name|oflag
operator|=
name|DTF_NODUP
operator||
name|DTF_REWIND
expr_stmt|;
else|else
name|oflag
operator|=
name|DTF_HIDEW
operator||
name|DTF_NODUP
operator||
name|DTF_REWIND
expr_stmt|;
else|#
directive|else
define|#
directive|define
name|__opendir2
parameter_list|(
name|path
parameter_list|,
name|flag
parameter_list|)
value|opendir(path)
endif|#
directive|endif
if|if
condition|(
operator|(
name|dirp
operator|=
name|__opendir2
argument_list|(
name|cur
operator|->
name|fts_accpath
argument_list|,
name|oflag
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|BREAD
condition|)
block|{
name|cur
operator|->
name|fts_info
operator|=
name|FTS_DNR
expr_stmt|;
name|cur
operator|->
name|fts_errno
operator|=
name|errno
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Nlinks is the number of possible entries of type directory in the 	 * directory if we're cheating on stat calls, 0 if we're not doing 	 * any stat calls at all, -1 if we're doing stats on everything. 	 */
if|if
condition|(
name|type
operator|==
name|BNAMES
condition|)
block|{
name|nlinks
operator|=
literal|0
expr_stmt|;
comment|/* Be quiet about nostat, GCC. */
name|nostat
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ISSET
argument_list|(
name|FTS_NOSTAT
argument_list|)
operator|&&
name|ISSET
argument_list|(
name|FTS_PHYSICAL
argument_list|)
condition|)
block|{
if|if
condition|(
name|fts_ufslinks
argument_list|(
name|sp
argument_list|,
name|cur
argument_list|)
condition|)
name|nlinks
operator|=
name|cur
operator|->
name|fts_nlink
operator|-
operator|(
name|ISSET
argument_list|(
name|FTS_SEEDOT
argument_list|)
condition|?
literal|0
else|:
literal|2
operator|)
expr_stmt|;
else|else
name|nlinks
operator|=
operator|-
literal|1
expr_stmt|;
name|nostat
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|nlinks
operator|=
operator|-
literal|1
expr_stmt|;
name|nostat
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|notdef
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"nlinks == %d (cur: %d)\n"
argument_list|,
name|nlinks
argument_list|,
name|cur
operator|->
name|fts_nlink
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"NOSTAT %d PHYSICAL %d SEEDOT %d\n"
argument_list|,
name|ISSET
argument_list|(
name|FTS_NOSTAT
argument_list|)
argument_list|,
name|ISSET
argument_list|(
name|FTS_PHYSICAL
argument_list|)
argument_list|,
name|ISSET
argument_list|(
name|FTS_SEEDOT
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * If we're going to need to stat anything or we want to descend 	 * and stay in the directory, chdir.  If this fails we keep going, 	 * but set a flag so we don't chdir after the post-order visit. 	 * We won't be able to stat anything, but we can still return the 	 * names themselves.  Note, that since fts_read won't be able to 	 * chdir into the directory, it will have to return different path 	 * names than before, i.e. "a/b" instead of "b".  Since the node 	 * has already been visited in pre-order, have to wait until the 	 * post-order visit to return the error.  There is a special case 	 * here, if there was nothing to stat then it's not an error to 	 * not be able to stat.  This is all fairly nasty.  If a program 	 * needed sorted entries or stat information, they had better be 	 * checking FTS_NS on the returned nodes. 	 */
name|cderrno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nlinks
operator|||
name|type
operator|==
name|BREAD
condition|)
block|{
if|if
condition|(
name|fts_safe_changedir
argument_list|(
name|sp
argument_list|,
name|cur
argument_list|,
name|dirfd
argument_list|(
name|dirp
argument_list|)
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
if|if
condition|(
name|nlinks
operator|&&
name|type
operator|==
name|BREAD
condition|)
name|cur
operator|->
name|fts_errno
operator|=
name|errno
expr_stmt|;
name|cur
operator|->
name|fts_flags
operator||=
name|FTS_DONTCHDIR
expr_stmt|;
name|descend
operator|=
literal|0
expr_stmt|;
name|cderrno
operator|=
name|errno
expr_stmt|;
block|}
else|else
name|descend
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|descend
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Figure out the max file name length that can be stored in the 	 * current path -- the inner loop allocates more path as necessary. 	 * We really wouldn't have to do the maxlen calculations here, we 	 * could do them in fts_read before returning the path, but it's a 	 * lot easier here since the length is part of the dirent structure. 	 * 	 * If not changing directories set a pointer so that can just append 	 * each new name into the path. 	 */
name|len
operator|=
name|NAPPEND
argument_list|(
name|cur
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISSET
argument_list|(
name|FTS_NOCHDIR
argument_list|)
condition|)
block|{
name|cp
operator|=
name|sp
operator|->
name|fts_path
operator|+
name|len
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|'/'
expr_stmt|;
block|}
else|else
block|{
comment|/* GCC, you're too verbose. */
name|cp
operator|=
name|NULL
expr_stmt|;
block|}
name|len
operator|++
expr_stmt|;
name|maxlen
operator|=
name|sp
operator|->
name|fts_pathlen
operator|-
name|len
expr_stmt|;
name|level
operator|=
name|cur
operator|->
name|fts_level
operator|+
literal|1
expr_stmt|;
comment|/* Read the directory, attaching each entry to the `link' pointer. */
name|doadjust
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|head
operator|=
name|tail
operator|=
name|NULL
operator|,
name|nitems
operator|=
literal|0
init|;
name|dirp
operator|&&
operator|(
name|dp
operator|=
name|readdir
argument_list|(
name|dirp
argument_list|)
operator|)
condition|;
control|)
block|{
name|dnamlen
operator|=
name|dp
operator|->
name|d_namlen
expr_stmt|;
if|if
condition|(
operator|!
name|ISSET
argument_list|(
name|FTS_SEEDOT
argument_list|)
operator|&&
name|ISDOT
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|p
operator|=
name|fts_alloc
argument_list|(
name|sp
argument_list|,
name|dp
operator|->
name|d_name
argument_list|,
operator|(
name|int
operator|)
name|dnamlen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|mem1
goto|;
if|if
condition|(
name|dnamlen
operator|>=
name|maxlen
condition|)
block|{
comment|/* include space for NUL */
name|oldaddr
operator|=
name|sp
operator|->
name|fts_path
expr_stmt|;
if|if
condition|(
name|fts_palloc
argument_list|(
name|sp
argument_list|,
name|dnamlen
operator|+
name|len
operator|+
literal|1
argument_list|)
condition|)
block|{
comment|/* 				 * No more memory for path or structures.  Save 				 * errno, free up the current structure and the 				 * structures already allocated. 				 */
name|mem1
label|:
name|saved_errno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|p
condition|)
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|fts_lfree
argument_list|(
name|head
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
name|cur
operator|->
name|fts_info
operator|=
name|FTS_ERR
expr_stmt|;
name|SET
argument_list|(
name|FTS_STOP
argument_list|)
expr_stmt|;
name|errno
operator|=
name|saved_errno
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Did realloc() change the pointer? */
if|if
condition|(
name|oldaddr
operator|!=
name|sp
operator|->
name|fts_path
condition|)
block|{
name|doadjust
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ISSET
argument_list|(
name|FTS_NOCHDIR
argument_list|)
condition|)
name|cp
operator|=
name|sp
operator|->
name|fts_path
operator|+
name|len
expr_stmt|;
block|}
name|maxlen
operator|=
name|sp
operator|->
name|fts_pathlen
operator|-
name|len
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|+
name|dnamlen
operator|>=
name|USHRT_MAX
condition|)
block|{
comment|/* 			 * In an FTSENT, fts_pathlen is a u_short so it is 			 * possible to wraparound here.  If we do, free up 			 * the current structure and the structures already 			 * allocated, then error out with ENAMETOOLONG. 			 */
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|fts_lfree
argument_list|(
name|head
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
name|cur
operator|->
name|fts_info
operator|=
name|FTS_ERR
expr_stmt|;
name|SET
argument_list|(
name|FTS_STOP
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENAMETOOLONG
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|p
operator|->
name|fts_level
operator|=
name|level
expr_stmt|;
name|p
operator|->
name|fts_parent
operator|=
name|sp
operator|->
name|fts_cur
expr_stmt|;
name|p
operator|->
name|fts_pathlen
operator|=
name|len
operator|+
name|dnamlen
expr_stmt|;
ifdef|#
directive|ifdef
name|FTS_WHITEOUT
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|DT_WHT
condition|)
name|p
operator|->
name|fts_flags
operator||=
name|FTS_ISW
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|cderrno
condition|)
block|{
if|if
condition|(
name|nlinks
condition|)
block|{
name|p
operator|->
name|fts_info
operator|=
name|FTS_NS
expr_stmt|;
name|p
operator|->
name|fts_errno
operator|=
name|cderrno
expr_stmt|;
block|}
else|else
name|p
operator|->
name|fts_info
operator|=
name|FTS_NSOK
expr_stmt|;
name|p
operator|->
name|fts_accpath
operator|=
name|cur
operator|->
name|fts_accpath
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nlinks
operator|==
literal|0
ifdef|#
directive|ifdef
name|DT_DIR
operator|||
operator|(
name|nostat
operator|&&
name|dp
operator|->
name|d_type
operator|!=
name|DT_DIR
operator|&&
name|dp
operator|->
name|d_type
operator|!=
name|DT_UNKNOWN
operator|)
endif|#
directive|endif
condition|)
block|{
name|p
operator|->
name|fts_accpath
operator|=
name|ISSET
argument_list|(
name|FTS_NOCHDIR
argument_list|)
condition|?
name|p
operator|->
name|fts_path
else|:
name|p
operator|->
name|fts_name
expr_stmt|;
name|p
operator|->
name|fts_info
operator|=
name|FTS_NSOK
expr_stmt|;
block|}
else|else
block|{
comment|/* Build a file name for fts_stat to stat. */
if|if
condition|(
name|ISSET
argument_list|(
name|FTS_NOCHDIR
argument_list|)
condition|)
block|{
name|p
operator|->
name|fts_accpath
operator|=
name|p
operator|->
name|fts_path
expr_stmt|;
name|memmove
argument_list|(
name|cp
argument_list|,
name|p
operator|->
name|fts_name
argument_list|,
name|p
operator|->
name|fts_namelen
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|->
name|fts_accpath
operator|=
name|p
operator|->
name|fts_name
expr_stmt|;
comment|/* Stat it. */
name|p
operator|->
name|fts_info
operator|=
name|fts_stat
argument_list|(
name|sp
argument_list|,
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Decrement link count if applicable. */
if|if
condition|(
name|nlinks
operator|>
literal|0
operator|&&
operator|(
name|p
operator|->
name|fts_info
operator|==
name|FTS_D
operator|||
name|p
operator|->
name|fts_info
operator|==
name|FTS_DC
operator|||
name|p
operator|->
name|fts_info
operator|==
name|FTS_DOT
operator|)
condition|)
operator|--
name|nlinks
expr_stmt|;
block|}
comment|/* We walk in directory order so "ls -f" doesn't get upset. */
name|p
operator|->
name|fts_link
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
name|head
operator|=
name|tail
operator|=
name|p
expr_stmt|;
else|else
block|{
name|tail
operator|->
name|fts_link
operator|=
name|p
expr_stmt|;
name|tail
operator|=
name|p
expr_stmt|;
block|}
operator|++
name|nitems
expr_stmt|;
block|}
if|if
condition|(
name|dirp
condition|)
operator|(
name|void
operator|)
name|closedir
argument_list|(
name|dirp
argument_list|)
expr_stmt|;
comment|/* 	 * If realloc() changed the address of the path, adjust the 	 * addresses for the rest of the tree and the dir list. 	 */
if|if
condition|(
name|doadjust
condition|)
name|fts_padjust
argument_list|(
name|sp
argument_list|,
name|head
argument_list|)
expr_stmt|;
comment|/* 	 * If not changing directories, reset the path back to original 	 * state. 	 */
if|if
condition|(
name|ISSET
argument_list|(
name|FTS_NOCHDIR
argument_list|)
condition|)
block|{
if|if
condition|(
name|len
operator|==
name|sp
operator|->
name|fts_pathlen
operator|||
name|nitems
operator|==
literal|0
condition|)
operator|--
name|cp
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* 	 * If descended after called from fts_children or after called from 	 * fts_read and nothing found, get back.  At the root level we use 	 * the saved fd; if one of fts_open()'s arguments is a relative path 	 * to an empty directory, we wind up here with no other way back.  If 	 * can't get back, we're done. 	 */
if|if
condition|(
name|descend
operator|&&
operator|(
name|type
operator|==
name|BCHILD
operator|||
operator|!
name|nitems
operator|)
operator|&&
operator|(
name|cur
operator|->
name|fts_level
operator|==
name|FTS_ROOTLEVEL
condition|?
name|FCHDIR
argument_list|(
name|sp
argument_list|,
name|sp
operator|->
name|fts_rfd
argument_list|)
else|:
name|fts_safe_changedir
argument_list|(
name|sp
argument_list|,
name|cur
operator|->
name|fts_parent
argument_list|,
operator|-
literal|1
argument_list|,
literal|".."
argument_list|)
operator|)
condition|)
block|{
name|cur
operator|->
name|fts_info
operator|=
name|FTS_ERR
expr_stmt|;
name|SET
argument_list|(
name|FTS_STOP
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* If didn't find anything, return NULL. */
if|if
condition|(
operator|!
name|nitems
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|BREAD
condition|)
name|cur
operator|->
name|fts_info
operator|=
name|FTS_DP
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Sort the entries. */
if|if
condition|(
name|sp
operator|->
name|fts_compar
operator|&&
name|nitems
operator|>
literal|1
condition|)
name|head
operator|=
name|fts_sort
argument_list|(
name|sp
argument_list|,
name|head
argument_list|,
name|nitems
argument_list|)
expr_stmt|;
return|return
operator|(
name|head
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_short
name|fts_stat
parameter_list|(
name|sp
parameter_list|,
name|p
parameter_list|,
name|follow
parameter_list|)
name|FTS
modifier|*
name|sp
decl_stmt|;
name|FTSENT
modifier|*
name|p
decl_stmt|;
name|int
name|follow
decl_stmt|;
block|{
name|FTSENT
modifier|*
name|t
decl_stmt|;
name|dev_t
name|dev
decl_stmt|;
name|ino_t
name|ino
decl_stmt|;
name|struct
name|stat
modifier|*
name|sbp
decl_stmt|,
name|sb
decl_stmt|;
name|int
name|saved_errno
decl_stmt|;
comment|/* If user needs stat info, stat buffer already allocated. */
name|sbp
operator|=
name|ISSET
argument_list|(
name|FTS_NOSTAT
argument_list|)
condition|?
operator|&
name|sb
else|:
name|p
operator|->
name|fts_statp
expr_stmt|;
ifdef|#
directive|ifdef
name|FTS_WHITEOUT
comment|/* Check for whiteout. */
if|if
condition|(
name|p
operator|->
name|fts_flags
operator|&
name|FTS_ISW
condition|)
block|{
if|if
condition|(
name|sbp
operator|!=
operator|&
name|sb
condition|)
block|{
name|memset
argument_list|(
name|sbp
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sbp
argument_list|)
argument_list|)
expr_stmt|;
name|sbp
operator|->
name|st_mode
operator|=
name|S_IFWHT
expr_stmt|;
block|}
return|return
operator|(
name|FTS_W
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* 	 * If doing a logical walk, or application requested FTS_FOLLOW, do 	 * a stat(2).  If that fails, check for a non-existent symlink.  If 	 * fail, set the errno from the stat call. 	 */
if|if
condition|(
name|ISSET
argument_list|(
name|FTS_LOGICAL
argument_list|)
operator|||
name|follow
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|p
operator|->
name|fts_accpath
argument_list|,
name|sbp
argument_list|)
condition|)
block|{
name|saved_errno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
operator|!
name|lstat
argument_list|(
name|p
operator|->
name|fts_accpath
argument_list|,
name|sbp
argument_list|)
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|FTS_SLNONE
operator|)
return|;
block|}
name|p
operator|->
name|fts_errno
operator|=
name|saved_errno
expr_stmt|;
goto|goto
name|err
goto|;
block|}
block|}
elseif|else
if|if
condition|(
name|lstat
argument_list|(
name|p
operator|->
name|fts_accpath
argument_list|,
name|sbp
argument_list|)
condition|)
block|{
name|p
operator|->
name|fts_errno
operator|=
name|errno
expr_stmt|;
name|err
label|:
name|memset
argument_list|(
name|sbp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|stat
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FTS_NS
operator|)
return|;
block|}
if|if
condition|(
name|S_ISDIR
argument_list|(
name|sbp
operator|->
name|st_mode
argument_list|)
condition|)
block|{
comment|/* 		 * Set the device/inode.  Used to find cycles and check for 		 * crossing mount points.  Also remember the link count, used 		 * in fts_build to limit the number of stat calls.  It is 		 * understood that these fields are only referenced if fts_info 		 * is set to FTS_D. 		 */
name|dev
operator|=
name|p
operator|->
name|fts_dev
operator|=
name|sbp
operator|->
name|st_dev
expr_stmt|;
name|ino
operator|=
name|p
operator|->
name|fts_ino
operator|=
name|sbp
operator|->
name|st_ino
expr_stmt|;
name|p
operator|->
name|fts_nlink
operator|=
name|sbp
operator|->
name|st_nlink
expr_stmt|;
if|if
condition|(
name|ISDOT
argument_list|(
name|p
operator|->
name|fts_name
argument_list|)
condition|)
return|return
operator|(
name|FTS_DOT
operator|)
return|;
comment|/* 		 * Cycle detection is done by brute force when the directory 		 * is first encountered.  If the tree gets deep enough or the 		 * number of symbolic links to directories is high enough, 		 * something faster might be worthwhile. 		 */
for|for
control|(
name|t
operator|=
name|p
operator|->
name|fts_parent
init|;
name|t
operator|->
name|fts_level
operator|>=
name|FTS_ROOTLEVEL
condition|;
name|t
operator|=
name|t
operator|->
name|fts_parent
control|)
if|if
condition|(
name|ino
operator|==
name|t
operator|->
name|fts_ino
operator|&&
name|dev
operator|==
name|t
operator|->
name|fts_dev
condition|)
block|{
name|p
operator|->
name|fts_cycle
operator|=
name|t
expr_stmt|;
return|return
operator|(
name|FTS_DC
operator|)
return|;
block|}
return|return
operator|(
name|FTS_D
operator|)
return|;
block|}
if|if
condition|(
name|S_ISLNK
argument_list|(
name|sbp
operator|->
name|st_mode
argument_list|)
condition|)
return|return
operator|(
name|FTS_SL
operator|)
return|;
if|if
condition|(
name|S_ISREG
argument_list|(
name|sbp
operator|->
name|st_mode
argument_list|)
condition|)
return|return
operator|(
name|FTS_F
operator|)
return|;
return|return
operator|(
name|FTS_DEFAULT
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The comparison function takes pointers to pointers to FTSENT structures.  * Qsort wants a comparison function that takes pointers to void.  * (Both with appropriate levels of const-poisoning, of course!)  * Use a trampoline function to deal with the difference.  */
end_comment

begin_function
specifier|static
name|int
name|fts_compar
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
name|FTS
modifier|*
name|parent
decl_stmt|;
name|parent
operator|=
operator|(
operator|*
operator|(
specifier|const
name|FTSENT
operator|*
specifier|const
operator|*
operator|)
name|a
operator|)
operator|->
name|fts_fts
expr_stmt|;
return|return
call|(
modifier|*
name|parent
operator|->
name|fts_compar
call|)
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|FTSENT
modifier|*
name|fts_sort
parameter_list|(
name|sp
parameter_list|,
name|head
parameter_list|,
name|nitems
parameter_list|)
name|FTS
modifier|*
name|sp
decl_stmt|;
name|FTSENT
modifier|*
name|head
decl_stmt|;
name|int
name|nitems
decl_stmt|;
block|{
name|FTSENT
modifier|*
modifier|*
name|ap
decl_stmt|,
modifier|*
name|p
decl_stmt|;
comment|/* 	 * Construct an array of pointers to the structures and call qsort(3). 	 * Reassemble the array in the order returned by qsort.  If unable to 	 * sort for memory reasons, return the directory entries in their 	 * current order.  Allocate enough space for the current needs plus 	 * 40 so don't realloc one entry at a time. 	 */
if|if
condition|(
name|nitems
operator|>
name|sp
operator|->
name|fts_nitems
condition|)
block|{
name|sp
operator|->
name|fts_nitems
operator|=
name|nitems
operator|+
literal|40
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|->
name|fts_array
operator|=
name|reallocf
argument_list|(
name|sp
operator|->
name|fts_array
argument_list|,
name|sp
operator|->
name|fts_nitems
operator|*
sizeof|sizeof
argument_list|(
name|FTSENT
operator|*
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|sp
operator|->
name|fts_nitems
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|head
operator|)
return|;
block|}
block|}
for|for
control|(
name|ap
operator|=
name|sp
operator|->
name|fts_array
operator|,
name|p
operator|=
name|head
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|fts_link
control|)
operator|*
name|ap
operator|++
operator|=
name|p
expr_stmt|;
name|qsort
argument_list|(
name|sp
operator|->
name|fts_array
argument_list|,
name|nitems
argument_list|,
sizeof|sizeof
argument_list|(
name|FTSENT
operator|*
argument_list|)
argument_list|,
name|fts_compar
argument_list|)
expr_stmt|;
for|for
control|(
name|head
operator|=
operator|*
operator|(
name|ap
operator|=
name|sp
operator|->
name|fts_array
operator|)
init|;
operator|--
name|nitems
condition|;
operator|++
name|ap
control|)
name|ap
index|[
literal|0
index|]
operator|->
name|fts_link
operator|=
name|ap
index|[
literal|1
index|]
expr_stmt|;
name|ap
index|[
literal|0
index|]
operator|->
name|fts_link
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|head
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|FTSENT
modifier|*
name|fts_alloc
parameter_list|(
name|sp
parameter_list|,
name|name
parameter_list|,
name|namelen
parameter_list|)
name|FTS
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|namelen
decl_stmt|;
block|{
name|FTSENT
modifier|*
name|p
decl_stmt|;
name|size_t
name|len
decl_stmt|;
struct|struct
name|ftsent_withstat
block|{
name|FTSENT
name|ent
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
block|}
struct|;
comment|/* 	 * The file name is a variable length array and no stat structure is 	 * necessary if the user has set the nostat bit.  Allocate the FTSENT 	 * structure, the file name and the stat structure in one chunk, but 	 * be careful that the stat structure is reasonably aligned. 	 */
if|if
condition|(
name|ISSET
argument_list|(
name|FTS_NOSTAT
argument_list|)
condition|)
name|len
operator|=
sizeof|sizeof
argument_list|(
name|FTSENT
argument_list|)
operator|+
name|namelen
operator|+
literal|1
expr_stmt|;
else|else
name|len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|ftsent_withstat
argument_list|)
operator|+
name|namelen
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|ISSET
argument_list|(
name|FTS_NOSTAT
argument_list|)
condition|)
block|{
name|p
operator|->
name|fts_name
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|p
operator|+
literal|1
operator|)
expr_stmt|;
name|p
operator|->
name|fts_statp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|fts_name
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
operator|(
expr|struct
name|ftsent_withstat
operator|*
operator|)
name|p
operator|+
literal|1
operator|)
expr_stmt|;
name|p
operator|->
name|fts_statp
operator|=
operator|&
operator|(
operator|(
expr|struct
name|ftsent_withstat
operator|*
operator|)
name|p
operator|)
operator|->
name|statbuf
expr_stmt|;
block|}
comment|/* Copy the name and guarantee NUL termination. */
name|memcpy
argument_list|(
name|p
operator|->
name|fts_name
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|p
operator|->
name|fts_name
index|[
name|namelen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|->
name|fts_namelen
operator|=
name|namelen
expr_stmt|;
name|p
operator|->
name|fts_path
operator|=
name|sp
operator|->
name|fts_path
expr_stmt|;
name|p
operator|->
name|fts_errno
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|fts_flags
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|fts_instr
operator|=
name|FTS_NOINSTR
expr_stmt|;
name|p
operator|->
name|fts_number
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|fts_pointer
operator|=
name|NULL
expr_stmt|;
name|p
operator|->
name|fts_fts
operator|=
name|sp
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fts_lfree
parameter_list|(
name|head
parameter_list|)
name|FTSENT
modifier|*
name|head
decl_stmt|;
block|{
name|FTSENT
modifier|*
name|p
decl_stmt|;
comment|/* Free a linked list of structures. */
while|while
condition|(
operator|(
name|p
operator|=
name|head
operator|)
condition|)
block|{
name|head
operator|=
name|head
operator|->
name|fts_link
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Allow essentially unlimited paths; find, rm, ls should all work on any tree.  * Most systems will allow creation of paths much longer than MAXPATHLEN, even  * though the kernel won't resolve them.  Add the size (not just what's needed)  * plus 256 bytes so don't realloc the path 2 bytes at a time.  */
end_comment

begin_function
specifier|static
name|int
name|fts_palloc
parameter_list|(
name|sp
parameter_list|,
name|more
parameter_list|)
name|FTS
modifier|*
name|sp
decl_stmt|;
name|size_t
name|more
decl_stmt|;
block|{
name|sp
operator|->
name|fts_pathlen
operator|+=
name|more
operator|+
literal|256
expr_stmt|;
comment|/* 	 * Check for possible wraparound.  In an FTS, fts_pathlen is 	 * a signed int but in an FTSENT it is an unsigned short. 	 * We limit fts_pathlen to USHRT_MAX to be safe in both cases. 	 */
if|if
condition|(
name|sp
operator|->
name|fts_pathlen
operator|<
literal|0
operator|||
name|sp
operator|->
name|fts_pathlen
operator|>=
name|USHRT_MAX
condition|)
block|{
if|if
condition|(
name|sp
operator|->
name|fts_path
condition|)
name|free
argument_list|(
name|sp
operator|->
name|fts_path
argument_list|)
expr_stmt|;
name|sp
operator|->
name|fts_path
operator|=
name|NULL
expr_stmt|;
name|errno
operator|=
name|ENAMETOOLONG
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|sp
operator|->
name|fts_path
operator|=
name|reallocf
argument_list|(
name|sp
operator|->
name|fts_path
argument_list|,
name|sp
operator|->
name|fts_pathlen
argument_list|)
expr_stmt|;
return|return
operator|(
name|sp
operator|->
name|fts_path
operator|==
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * When the path is realloc'd, have to fix all of the pointers in structures  * already returned.  */
end_comment

begin_function
specifier|static
name|void
name|fts_padjust
parameter_list|(
name|sp
parameter_list|,
name|head
parameter_list|)
name|FTS
modifier|*
name|sp
decl_stmt|;
name|FTSENT
modifier|*
name|head
decl_stmt|;
block|{
name|FTSENT
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|addr
init|=
name|sp
operator|->
name|fts_path
decl_stmt|;
define|#
directive|define
name|ADJUST
parameter_list|(
name|p
parameter_list|)
value|do {							\ 	if ((p)->fts_accpath != (p)->fts_name) {			\ 		(p)->fts_accpath =					\ 		    (char *)addr + ((p)->fts_accpath - (p)->fts_path);	\ 	}								\ 	(p)->fts_path = addr;						\ } while (0)
comment|/* Adjust the current set of children. */
for|for
control|(
name|p
operator|=
name|sp
operator|->
name|fts_child
init|;
name|p
condition|;
name|p
operator|=
name|p
operator|->
name|fts_link
control|)
name|ADJUST
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* Adjust the rest of the tree, including the current level. */
for|for
control|(
name|p
operator|=
name|head
init|;
name|p
operator|->
name|fts_level
operator|>=
name|FTS_ROOTLEVEL
condition|;
control|)
block|{
name|ADJUST
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|p
operator|->
name|fts_link
condition|?
name|p
operator|->
name|fts_link
else|:
name|p
operator|->
name|fts_parent
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|size_t
name|fts_maxarglen
parameter_list|(
name|argv
parameter_list|)
name|char
modifier|*
specifier|const
modifier|*
name|argv
decl_stmt|;
block|{
name|size_t
name|len
decl_stmt|,
name|max
decl_stmt|;
for|for
control|(
name|max
operator|=
literal|0
init|;
operator|*
name|argv
condition|;
operator|++
name|argv
control|)
if|if
condition|(
operator|(
name|len
operator|=
name|strlen
argument_list|(
operator|*
name|argv
argument_list|)
operator|)
operator|>
name|max
condition|)
name|max
operator|=
name|len
expr_stmt|;
return|return
operator|(
name|max
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Change to dir specified by fd or p->fts_accpath without getting  * tricked by someone changing the world out from underneath us.  * Assumes p->fts_dev and p->fts_ino are filled in.  */
end_comment

begin_function
specifier|static
name|int
name|fts_safe_changedir
parameter_list|(
name|sp
parameter_list|,
name|p
parameter_list|,
name|fd
parameter_list|,
name|path
parameter_list|)
name|FTS
modifier|*
name|sp
decl_stmt|;
name|FTSENT
modifier|*
name|p
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
block|{
name|int
name|ret
decl_stmt|,
name|oerrno
decl_stmt|,
name|newfd
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|newfd
operator|=
name|fd
expr_stmt|;
if|if
condition|(
name|ISSET
argument_list|(
name|FTS_NOCHDIR
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|fd
operator|<
literal|0
operator|&&
operator|(
name|newfd
operator|=
name|_open
argument_list|(
name|path
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|_fstat
argument_list|(
name|newfd
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|bail
goto|;
block|}
if|if
condition|(
name|p
operator|->
name|fts_dev
operator|!=
name|sb
operator|.
name|st_dev
operator|||
name|p
operator|->
name|fts_ino
operator|!=
name|sb
operator|.
name|st_ino
condition|)
block|{
name|errno
operator|=
name|ENOENT
expr_stmt|;
comment|/* disinformation */
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|bail
goto|;
block|}
name|ret
operator|=
name|fchdir
argument_list|(
name|newfd
argument_list|)
expr_stmt|;
name|bail
label|:
name|oerrno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
operator|(
name|void
operator|)
name|_close
argument_list|(
name|newfd
argument_list|)
expr_stmt|;
name|errno
operator|=
name|oerrno
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if the filesystem for "ent" has UFS-style links.  */
end_comment

begin_function
specifier|static
name|int
name|fts_ufslinks
parameter_list|(
name|FTS
modifier|*
name|sp
parameter_list|,
specifier|const
name|FTSENT
modifier|*
name|ent
parameter_list|)
block|{
name|struct
name|_fts_private
modifier|*
name|priv
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|cpp
decl_stmt|;
name|priv
operator|=
operator|(
expr|struct
name|_fts_private
operator|*
operator|)
name|sp
expr_stmt|;
comment|/* 	 * If this node's device is different from the previous, grab 	 * the filesystem information, and decide on the reliability 	 * of the link information from this filesystem for stat(2) 	 * avoidance. 	 */
if|if
condition|(
name|priv
operator|->
name|ftsp_dev
operator|!=
name|ent
operator|->
name|fts_dev
condition|)
block|{
if|if
condition|(
name|statfs
argument_list|(
name|ent
operator|->
name|fts_path
argument_list|,
operator|&
name|priv
operator|->
name|ftsp_statfs
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|priv
operator|->
name|ftsp_dev
operator|=
name|ent
operator|->
name|fts_dev
expr_stmt|;
name|priv
operator|->
name|ftsp_linksreliable
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cpp
operator|=
name|ufslike_filesystems
init|;
operator|*
name|cpp
condition|;
name|cpp
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|priv
operator|->
name|ftsp_statfs
operator|.
name|f_fstypename
argument_list|,
operator|*
name|cpp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|priv
operator|->
name|ftsp_linksreliable
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|priv
operator|->
name|ftsp_linksreliable
operator|=
literal|0
expr_stmt|;
block|}
block|}
return|return
operator|(
name|priv
operator|->
name|ftsp_linksreliable
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|__sym_compat
argument_list|(
name|fts_open
argument_list|,
name|__fts_open_44bsd
argument_list|,
name|FBSD_1
literal|.0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__sym_compat
argument_list|(
name|fts_close
argument_list|,
name|__fts_close_44bsd
argument_list|,
name|FBSD_1
literal|.0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__sym_compat
argument_list|(
name|fts_read
argument_list|,
name|__fts_read_44bsd
argument_list|,
name|FBSD_1
literal|.0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__sym_compat
argument_list|(
name|fts_set
argument_list|,
name|__fts_set_44bsd
argument_list|,
name|FBSD_1
literal|.0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__sym_compat
argument_list|(
name|fts_children
argument_list|,
name|__fts_children_44bsd
argument_list|,
name|FBSD_1
literal|.0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__sym_compat
argument_list|(
name|fts_get_clientptr
argument_list|,
name|__fts_get_clientptr_44bsd
argument_list|,
name|FBSD_1
literal|.0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__sym_compat
argument_list|(
name|fts_get_stream
argument_list|,
name|__fts_get_stream_44bsd
argument_list|,
name|FBSD_1
literal|.0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__sym_compat
argument_list|(
name|fts_set_clientptr
argument_list|,
name|__fts_set_clientptr_44bsd
argument_list|,
name|FBSD_1
literal|.0
argument_list|)
expr_stmt|;
end_expr_stmt

end_unit

