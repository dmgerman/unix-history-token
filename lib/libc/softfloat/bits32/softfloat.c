begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $NetBSD: softfloat.c,v 1.1 2002/05/21 23:51:07 bjh21 Exp $ */
end_comment

begin_comment
comment|/*  * This version hacked for use with gcc -msoft-float by bjh21.  * (Mostly a case of #ifdefing out things GCC doesn't need or provides  *  itself).  */
end_comment

begin_comment
comment|/*  * Things you may want to define:  *  * SOFTFLOAT_FOR_GCC - build only those functions necessary for GCC (with  *   -msoft-float) to work.  Include "softfloat-for-gcc.h" to get them  *   properly renamed.  */
end_comment

begin_comment
comment|/*  * This differs from the standard bits32/softfloat.c in that float64  * is defined to be a 64-bit integer rather than a structure.  The  * structure is float64s, with translation between the two going via  * float64u.  */
end_comment

begin_comment
comment|/* ===============================================================================  This C source file is part of the SoftFloat IEC/IEEE Floating-Point Arithmetic Package, Release 2a.  Written by John R. Hauser.  This work was made possible in part by the International Computer Science Institute, located at Suite 600, 1947 Center Street, Berkeley, California 94704.  Funding was partially provided by the National Science Foundation under grant MIP-9311980.  The original version of this code was written as part of a project to build a fixed-point vector processor in collaboration with the University of California at Berkeley, overseen by Profs. Nelson Morgan and John Wawrzynek.  More information is available through the Web page `http://HTTP.CS.Berkeley.EDU/~jhauser/ arithmetic/SoftFloat.html'.  THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort has been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT TIMES RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO PERSONS AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ANY AND ALL LOSSES, COSTS, OR OTHER PROBLEMS ARISING FROM ITS USE.  Derivative works are acceptable, even for commercial purposes, so long as (1) they include prominent notice that the work is derivative, and (2) they include prominent notice akin to these four paragraphs for those parts of this code that are retained.  =============================================================================== */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SOFTFLOAT_FOR_GCC
end_ifdef

begin_include
include|#
directive|include
file|"softfloat-for-gcc.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"milieu.h"
end_include

begin_include
include|#
directive|include
file|"softfloat.h"
end_include

begin_comment
comment|/*  * Conversions between floats as stored in memory and floats as  * SoftFloat uses them  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FLOAT64_DEMANGLE
end_ifndef

begin_define
define|#
directive|define
name|FLOAT64_DEMANGLE
parameter_list|(
name|a
parameter_list|)
value|(a)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FLOAT64_MANGLE
end_ifndef

begin_define
define|#
directive|define
name|FLOAT64_MANGLE
parameter_list|(
name|a
parameter_list|)
value|(a)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ------------------------------------------------------------------------------- Floating-point rounding mode and exception flags. ------------------------------------------------------------------------------- */
end_comment

begin_decl_stmt
name|fp_rnd_t
name|float_rounding_mode
init|=
name|float_round_nearest_even
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|fp_except
name|float_exception_flags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ------------------------------------------------------------------------------- Primitive arithmetic functions, including multi-word arithmetic, and division and square root approximations.  (Can be specialized to target if desired.) ------------------------------------------------------------------------------- */
end_comment

begin_include
include|#
directive|include
file|"softfloat-macros"
end_include

begin_comment
comment|/* ------------------------------------------------------------------------------- Functions and definitions to determine:  (1) whether tininess for underflow is detected before or after rounding by default, (2) what (if anything) happens when exceptions are raised, (3) how signaling NaNs are distinguished from quiet NaNs, (4) the default generated quiet NaNs, and (4) how NaNs are propagated from function inputs to output.  These details are target- specific. ------------------------------------------------------------------------------- */
end_comment

begin_include
include|#
directive|include
file|"softfloat-specialize"
end_include

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the fraction bits of the single-precision floating-point value `a'. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|INLINE
name|bits32
name|extractFloat32Frac
parameter_list|(
name|float32
name|a
parameter_list|)
block|{
return|return
name|a
operator|&
literal|0x007FFFFF
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the exponent bits of the single-precision floating-point value `a'. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|INLINE
name|int16
name|extractFloat32Exp
parameter_list|(
name|float32
name|a
parameter_list|)
block|{
return|return
operator|(
name|a
operator|>>
literal|23
operator|)
operator|&
literal|0xFF
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the sign bit of the single-precision floating-point value `a'. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|INLINE
name|flag
name|extractFloat32Sign
parameter_list|(
name|float32
name|a
parameter_list|)
block|{
return|return
name|a
operator|>>
literal|31
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Normalizes the subnormal single-precision floating-point value represented by the denormalized significand `aSig'.  The normalized exponent and significand are stored at the locations pointed to by `zExpPtr' and `zSigPtr', respectively. ------------------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|void
name|normalizeFloat32Subnormal
parameter_list|(
name|bits32
name|aSig
parameter_list|,
name|int16
modifier|*
name|zExpPtr
parameter_list|,
name|bits32
modifier|*
name|zSigPtr
parameter_list|)
block|{
name|int8
name|shiftCount
decl_stmt|;
name|shiftCount
operator|=
name|countLeadingZeros32
argument_list|(
name|aSig
argument_list|)
operator|-
literal|8
expr_stmt|;
operator|*
name|zSigPtr
operator|=
name|aSig
operator|<<
name|shiftCount
expr_stmt|;
operator|*
name|zExpPtr
operator|=
literal|1
operator|-
name|shiftCount
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Packs the sign `zSign', exponent `zExp', and significand `zSig' into a single-precision floating-point value, returning the result.  After being shifted into the proper positions, the three fields are simply added together to form the result.  This means that any integer portion of `zSig' will be added into the exponent.  Since a properly normalized significand will have an integer portion equal to 1, the `zExp' input should be 1 less than the desired result exponent whenever `zSig' is a complete, normalized significand. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|INLINE
name|float32
name|packFloat32
parameter_list|(
name|flag
name|zSign
parameter_list|,
name|int16
name|zExp
parameter_list|,
name|bits32
name|zSig
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|bits32
operator|)
name|zSign
operator|)
operator|<<
literal|31
operator|)
operator|+
operator|(
operator|(
operator|(
name|bits32
operator|)
name|zExp
operator|)
operator|<<
literal|23
operator|)
operator|+
name|zSig
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Takes an abstract floating-point value having sign `zSign', exponent `zExp', and significand `zSig', and returns the proper single-precision floating- point value corresponding to the abstract input.  Ordinarily, the abstract value is simply rounded and packed into the single-precision format, with the inexact exception raised if the abstract input cannot be represented exactly.  However, if the abstract value is too large, the overflow and inexact exceptions are raised and an infinity or maximal finite value is returned.  If the abstract value is too small, the input value is rounded to a subnormal number, and the underflow and inexact exceptions are raised if the abstract input cannot be represented exactly as a subnormal single- precision floating-point number.     The input significand `zSig' has its binary point between bits 30 and 29, which is 7 bits to the left of the usual location.  This shifted significand must be normalized or smaller.  If `zSig' is not normalized, `zExp' must be 0; in that case, the result returned is a subnormal number, and it must not require rounding.  In the usual case that `zSig' is normalized, `zExp' must be 1 less than the ``true'' floating-point exponent. The handling of underflow and overflow follows the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|float32
name|roundAndPackFloat32
parameter_list|(
name|flag
name|zSign
parameter_list|,
name|int16
name|zExp
parameter_list|,
name|bits32
name|zSig
parameter_list|)
block|{
name|int8
name|roundingMode
decl_stmt|;
name|flag
name|roundNearestEven
decl_stmt|;
name|int8
name|roundIncrement
decl_stmt|,
name|roundBits
decl_stmt|;
name|flag
name|isTiny
decl_stmt|;
name|roundingMode
operator|=
name|float_rounding_mode
expr_stmt|;
name|roundNearestEven
operator|=
name|roundingMode
operator|==
name|float_round_nearest_even
expr_stmt|;
name|roundIncrement
operator|=
literal|0x40
expr_stmt|;
if|if
condition|(
operator|!
name|roundNearestEven
condition|)
block|{
if|if
condition|(
name|roundingMode
operator|==
name|float_round_to_zero
condition|)
block|{
name|roundIncrement
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|roundIncrement
operator|=
literal|0x7F
expr_stmt|;
if|if
condition|(
name|zSign
condition|)
block|{
if|if
condition|(
name|roundingMode
operator|==
name|float_round_up
condition|)
name|roundIncrement
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|roundingMode
operator|==
name|float_round_down
condition|)
name|roundIncrement
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|roundBits
operator|=
name|zSig
operator|&
literal|0x7F
expr_stmt|;
if|if
condition|(
literal|0xFD
operator|<=
operator|(
name|bits16
operator|)
name|zExp
condition|)
block|{
if|if
condition|(
operator|(
literal|0xFD
operator|<
name|zExp
operator|)
operator|||
operator|(
operator|(
name|zExp
operator|==
literal|0xFD
operator|)
operator|&&
operator|(
call|(
name|sbits32
call|)
argument_list|(
name|zSig
operator|+
name|roundIncrement
argument_list|)
operator|<
literal|0
operator|)
operator|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_overflow
operator||
name|float_flag_inexact
argument_list|)
expr_stmt|;
return|return
name|packFloat32
argument_list|(
name|zSign
argument_list|,
literal|0xFF
argument_list|,
literal|0
argument_list|)
operator|-
operator|(
name|roundIncrement
operator|==
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|zExp
operator|<
literal|0
condition|)
block|{
name|isTiny
operator|=
operator|(
name|float_detect_tininess
operator|==
name|float_tininess_before_rounding
operator|)
operator|||
operator|(
name|zExp
operator|<
operator|-
literal|1
operator|)
operator|||
operator|(
name|zSig
operator|+
name|roundIncrement
operator|<
literal|0x80000000
operator|)
expr_stmt|;
name|shift32RightJamming
argument_list|(
name|zSig
argument_list|,
operator|-
name|zExp
argument_list|,
operator|&
name|zSig
argument_list|)
expr_stmt|;
name|zExp
operator|=
literal|0
expr_stmt|;
name|roundBits
operator|=
name|zSig
operator|&
literal|0x7F
expr_stmt|;
if|if
condition|(
name|isTiny
operator|&&
name|roundBits
condition|)
name|float_raise
argument_list|(
name|float_flag_underflow
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|roundBits
condition|)
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
name|zSig
operator|=
operator|(
name|zSig
operator|+
name|roundIncrement
operator|)
operator|>>
literal|7
expr_stmt|;
name|zSig
operator|&=
operator|~
operator|(
operator|(
operator|(
name|roundBits
operator|^
literal|0x40
operator|)
operator|==
literal|0
operator|)
operator|&
name|roundNearestEven
operator|)
expr_stmt|;
if|if
condition|(
name|zSig
operator|==
literal|0
condition|)
name|zExp
operator|=
literal|0
expr_stmt|;
return|return
name|packFloat32
argument_list|(
name|zSign
argument_list|,
name|zExp
argument_list|,
name|zSig
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Takes an abstract floating-point value having sign `zSign', exponent `zExp', and significand `zSig', and returns the proper single-precision floating- point value corresponding to the abstract input.  This routine is just like `roundAndPackFloat32' except that `zSig' does not have to be normalized. Bit 31 of `zSig' must be zero, and `zExp' must be 1 less than the ``true'' floating-point exponent. ------------------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|float32
name|normalizeRoundAndPackFloat32
parameter_list|(
name|flag
name|zSign
parameter_list|,
name|int16
name|zExp
parameter_list|,
name|bits32
name|zSig
parameter_list|)
block|{
name|int8
name|shiftCount
decl_stmt|;
name|shiftCount
operator|=
name|countLeadingZeros32
argument_list|(
name|zSig
argument_list|)
operator|-
literal|1
expr_stmt|;
return|return
name|roundAndPackFloat32
argument_list|(
name|zSign
argument_list|,
name|zExp
operator|-
name|shiftCount
argument_list|,
name|zSig
operator|<<
name|shiftCount
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the least-significant 32 fraction bits of the double-precision floating-point value `a'. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|INLINE
name|bits32
name|extractFloat64Frac1
parameter_list|(
name|float64
name|a
parameter_list|)
block|{
return|return
name|FLOAT64_DEMANGLE
argument_list|(
name|a
argument_list|)
operator|&
name|LIT64
argument_list|(
literal|0x00000000FFFFFFFF
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the most-significant 20 fraction bits of the double-precision floating-point value `a'. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|INLINE
name|bits32
name|extractFloat64Frac0
parameter_list|(
name|float64
name|a
parameter_list|)
block|{
return|return
operator|(
name|FLOAT64_DEMANGLE
argument_list|(
name|a
argument_list|)
operator|>>
literal|32
operator|)
operator|&
literal|0x000FFFFF
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the exponent bits of the double-precision floating-point value `a'. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|INLINE
name|int16
name|extractFloat64Exp
parameter_list|(
name|float64
name|a
parameter_list|)
block|{
return|return
operator|(
name|FLOAT64_DEMANGLE
argument_list|(
name|a
argument_list|)
operator|>>
literal|52
operator|)
operator|&
literal|0x7FF
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the sign bit of the double-precision floating-point value `a'. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|INLINE
name|flag
name|extractFloat64Sign
parameter_list|(
name|float64
name|a
parameter_list|)
block|{
return|return
name|FLOAT64_DEMANGLE
argument_list|(
name|a
argument_list|)
operator|>>
literal|63
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Normalizes the subnormal double-precision floating-point value represented by the denormalized significand formed by the concatenation of `aSig0' and `aSig1'.  The normalized exponent is stored at the location pointed to by `zExpPtr'.  The most significant 21 bits of the normalized significand are stored at the location pointed to by `zSig0Ptr', and the least significant 32 bits of the normalized significand are stored at the location pointed to by `zSig1Ptr'. ------------------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|void
name|normalizeFloat64Subnormal
parameter_list|(
name|bits32
name|aSig0
parameter_list|,
name|bits32
name|aSig1
parameter_list|,
name|int16
modifier|*
name|zExpPtr
parameter_list|,
name|bits32
modifier|*
name|zSig0Ptr
parameter_list|,
name|bits32
modifier|*
name|zSig1Ptr
parameter_list|)
block|{
name|int8
name|shiftCount
decl_stmt|;
if|if
condition|(
name|aSig0
operator|==
literal|0
condition|)
block|{
name|shiftCount
operator|=
name|countLeadingZeros32
argument_list|(
name|aSig1
argument_list|)
operator|-
literal|11
expr_stmt|;
if|if
condition|(
name|shiftCount
operator|<
literal|0
condition|)
block|{
operator|*
name|zSig0Ptr
operator|=
name|aSig1
operator|>>
operator|(
operator|-
name|shiftCount
operator|)
expr_stmt|;
operator|*
name|zSig1Ptr
operator|=
name|aSig1
operator|<<
operator|(
name|shiftCount
operator|&
literal|31
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|zSig0Ptr
operator|=
name|aSig1
operator|<<
name|shiftCount
expr_stmt|;
operator|*
name|zSig1Ptr
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|zExpPtr
operator|=
operator|-
name|shiftCount
operator|-
literal|31
expr_stmt|;
block|}
else|else
block|{
name|shiftCount
operator|=
name|countLeadingZeros32
argument_list|(
name|aSig0
argument_list|)
operator|-
literal|11
expr_stmt|;
name|shortShift64Left
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
name|shiftCount
argument_list|,
name|zSig0Ptr
argument_list|,
name|zSig1Ptr
argument_list|)
expr_stmt|;
operator|*
name|zExpPtr
operator|=
literal|1
operator|-
name|shiftCount
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Packs the sign `zSign', the exponent `zExp', and the significand formed by the concatenation of `zSig0' and `zSig1' into a double-precision floating- point value, returning the result.  After being shifted into the proper positions, the three fields `zSign', `zExp', and `zSig0' are simply added together to form the most significant 32 bits of the result.  This means that any integer portion of `zSig0' will be added into the exponent.  Since a properly normalized significand will have an integer portion equal to 1, the `zExp' input should be 1 less than the desired result exponent whenever `zSig0' and `zSig1' concatenated form a complete, normalized significand. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|INLINE
name|float64
name|packFloat64
parameter_list|(
name|flag
name|zSign
parameter_list|,
name|int16
name|zExp
parameter_list|,
name|bits32
name|zSig0
parameter_list|,
name|bits32
name|zSig1
parameter_list|)
block|{
return|return
name|FLOAT64_MANGLE
argument_list|(
operator|(
operator|(
operator|(
name|bits64
operator|)
name|zSign
operator|)
operator|<<
literal|63
operator|)
operator|+
operator|(
operator|(
operator|(
name|bits64
operator|)
name|zExp
operator|)
operator|<<
literal|52
operator|)
operator|+
operator|(
operator|(
operator|(
name|bits64
operator|)
name|zSig0
operator|)
operator|<<
literal|32
operator|)
operator|+
name|zSig1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Takes an abstract floating-point value having sign `zSign', exponent `zExp', and extended significand formed by the concatenation of `zSig0', `zSig1', and `zSig2', and returns the proper double-precision floating-point value corresponding to the abstract input.  Ordinarily, the abstract value is simply rounded and packed into the double-precision format, with the inexact exception raised if the abstract input cannot be represented exactly. However, if the abstract value is too large, the overflow and inexact exceptions are raised and an infinity or maximal finite value is returned. If the abstract value is too small, the input value is rounded to a subnormal number, and the underflow and inexact exceptions are raised if the abstract input cannot be represented exactly as a subnormal double-precision floating-point number.     The input significand must be normalized or smaller.  If the input significand is not normalized, `zExp' must be 0; in that case, the result returned is a subnormal number, and it must not require rounding.  In the usual case that the input significand is normalized, `zExp' must be 1 less than the ``true'' floating-point exponent.  The handling of underflow and overflow follows the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|float64
name|roundAndPackFloat64
parameter_list|(
name|flag
name|zSign
parameter_list|,
name|int16
name|zExp
parameter_list|,
name|bits32
name|zSig0
parameter_list|,
name|bits32
name|zSig1
parameter_list|,
name|bits32
name|zSig2
parameter_list|)
block|{
name|int8
name|roundingMode
decl_stmt|;
name|flag
name|roundNearestEven
decl_stmt|,
name|increment
decl_stmt|,
name|isTiny
decl_stmt|;
name|roundingMode
operator|=
name|float_rounding_mode
expr_stmt|;
name|roundNearestEven
operator|=
operator|(
name|roundingMode
operator|==
name|float_round_nearest_even
operator|)
expr_stmt|;
name|increment
operator|=
operator|(
operator|(
name|sbits32
operator|)
name|zSig2
operator|<
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|roundNearestEven
condition|)
block|{
if|if
condition|(
name|roundingMode
operator|==
name|float_round_to_zero
condition|)
block|{
name|increment
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|zSign
condition|)
block|{
name|increment
operator|=
operator|(
name|roundingMode
operator|==
name|float_round_down
operator|)
operator|&&
name|zSig2
expr_stmt|;
block|}
else|else
block|{
name|increment
operator|=
operator|(
name|roundingMode
operator|==
name|float_round_up
operator|)
operator|&&
name|zSig2
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
literal|0x7FD
operator|<=
operator|(
name|bits16
operator|)
name|zExp
condition|)
block|{
if|if
condition|(
operator|(
literal|0x7FD
operator|<
name|zExp
operator|)
operator|||
operator|(
operator|(
name|zExp
operator|==
literal|0x7FD
operator|)
operator|&&
name|eq64
argument_list|(
literal|0x001FFFFF
argument_list|,
literal|0xFFFFFFFF
argument_list|,
name|zSig0
argument_list|,
name|zSig1
argument_list|)
operator|&&
name|increment
operator|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_overflow
operator||
name|float_flag_inexact
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|roundingMode
operator|==
name|float_round_to_zero
operator|)
operator|||
operator|(
name|zSign
operator|&&
operator|(
name|roundingMode
operator|==
name|float_round_up
operator|)
operator|)
operator|||
operator|(
operator|!
name|zSign
operator|&&
operator|(
name|roundingMode
operator|==
name|float_round_down
operator|)
operator|)
condition|)
block|{
return|return
name|packFloat64
argument_list|(
name|zSign
argument_list|,
literal|0x7FE
argument_list|,
literal|0x000FFFFF
argument_list|,
literal|0xFFFFFFFF
argument_list|)
return|;
block|}
return|return
name|packFloat64
argument_list|(
name|zSign
argument_list|,
literal|0x7FF
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|zExp
operator|<
literal|0
condition|)
block|{
name|isTiny
operator|=
operator|(
name|float_detect_tininess
operator|==
name|float_tininess_before_rounding
operator|)
operator|||
operator|(
name|zExp
operator|<
operator|-
literal|1
operator|)
operator|||
operator|!
name|increment
operator|||
name|lt64
argument_list|(
name|zSig0
argument_list|,
name|zSig1
argument_list|,
literal|0x001FFFFF
argument_list|,
literal|0xFFFFFFFF
argument_list|)
expr_stmt|;
name|shift64ExtraRightJamming
argument_list|(
name|zSig0
argument_list|,
name|zSig1
argument_list|,
name|zSig2
argument_list|,
operator|-
name|zExp
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|,
operator|&
name|zSig2
argument_list|)
expr_stmt|;
name|zExp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isTiny
operator|&&
name|zSig2
condition|)
name|float_raise
argument_list|(
name|float_flag_underflow
argument_list|)
expr_stmt|;
if|if
condition|(
name|roundNearestEven
condition|)
block|{
name|increment
operator|=
operator|(
operator|(
name|sbits32
operator|)
name|zSig2
operator|<
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|zSign
condition|)
block|{
name|increment
operator|=
operator|(
name|roundingMode
operator|==
name|float_round_down
operator|)
operator|&&
name|zSig2
expr_stmt|;
block|}
else|else
block|{
name|increment
operator|=
operator|(
name|roundingMode
operator|==
name|float_round_up
operator|)
operator|&&
name|zSig2
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|zSig2
condition|)
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
if|if
condition|(
name|increment
condition|)
block|{
name|add64
argument_list|(
name|zSig0
argument_list|,
name|zSig1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|)
expr_stmt|;
name|zSig1
operator|&=
operator|~
operator|(
operator|(
name|zSig2
operator|+
name|zSig2
operator|==
literal|0
operator|)
operator|&
name|roundNearestEven
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|zSig0
operator||
name|zSig1
operator|)
operator|==
literal|0
condition|)
name|zExp
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|packFloat64
argument_list|(
name|zSign
argument_list|,
name|zExp
argument_list|,
name|zSig0
argument_list|,
name|zSig1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Takes an abstract floating-point value having sign `zSign', exponent `zExp', and significand formed by the concatenation of `zSig0' and `zSig1', and returns the proper double-precision floating-point value corresponding to the abstract input.  This routine is just like `roundAndPackFloat64' except that the input significand has fewer bits and does not have to be normalized.  In all cases, `zExp' must be 1 less than the ``true'' floating- point exponent. ------------------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|float64
name|normalizeRoundAndPackFloat64
parameter_list|(
name|flag
name|zSign
parameter_list|,
name|int16
name|zExp
parameter_list|,
name|bits32
name|zSig0
parameter_list|,
name|bits32
name|zSig1
parameter_list|)
block|{
name|int8
name|shiftCount
decl_stmt|;
name|bits32
name|zSig2
decl_stmt|;
if|if
condition|(
name|zSig0
operator|==
literal|0
condition|)
block|{
name|zSig0
operator|=
name|zSig1
expr_stmt|;
name|zSig1
operator|=
literal|0
expr_stmt|;
name|zExp
operator|-=
literal|32
expr_stmt|;
block|}
name|shiftCount
operator|=
name|countLeadingZeros32
argument_list|(
name|zSig0
argument_list|)
operator|-
literal|11
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|shiftCount
condition|)
block|{
name|zSig2
operator|=
literal|0
expr_stmt|;
name|shortShift64Left
argument_list|(
name|zSig0
argument_list|,
name|zSig1
argument_list|,
name|shiftCount
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|shift64ExtraRightJamming
argument_list|(
name|zSig0
argument_list|,
name|zSig1
argument_list|,
literal|0
argument_list|,
operator|-
name|shiftCount
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|,
operator|&
name|zSig2
argument_list|)
expr_stmt|;
block|}
name|zExp
operator|-=
name|shiftCount
expr_stmt|;
return|return
name|roundAndPackFloat64
argument_list|(
name|zSign
argument_list|,
name|zExp
argument_list|,
name|zSig0
argument_list|,
name|zSig1
argument_list|,
name|zSig2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the 32-bit two's complement integer `a' to the single-precision floating-point format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float32
name|int32_to_float32
parameter_list|(
name|int32
name|a
parameter_list|)
block|{
name|flag
name|zSign
decl_stmt|;
if|if
condition|(
name|a
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|a
operator|==
operator|(
name|sbits32
operator|)
literal|0x80000000
condition|)
return|return
name|packFloat32
argument_list|(
literal|1
argument_list|,
literal|0x9E
argument_list|,
literal|0
argument_list|)
return|;
name|zSign
operator|=
operator|(
name|a
operator|<
literal|0
operator|)
expr_stmt|;
return|return
name|normalizeRoundAndPackFloat32
argument_list|(
name|zSign
argument_list|,
literal|0x9C
argument_list|,
name|zSign
condition|?
operator|-
name|a
else|:
name|a
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the 32-bit two's complement integer `a' to the double-precision floating-point format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float64
name|int32_to_float64
parameter_list|(
name|int32
name|a
parameter_list|)
block|{
name|flag
name|zSign
decl_stmt|;
name|bits32
name|absA
decl_stmt|;
name|int8
name|shiftCount
decl_stmt|;
name|bits32
name|zSig0
decl_stmt|,
name|zSig1
decl_stmt|;
if|if
condition|(
name|a
operator|==
literal|0
condition|)
return|return
name|packFloat64
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|zSign
operator|=
operator|(
name|a
operator|<
literal|0
operator|)
expr_stmt|;
name|absA
operator|=
name|zSign
condition|?
operator|-
name|a
else|:
name|a
expr_stmt|;
name|shiftCount
operator|=
name|countLeadingZeros32
argument_list|(
name|absA
argument_list|)
operator|-
literal|11
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|shiftCount
condition|)
block|{
name|zSig0
operator|=
name|absA
operator|<<
name|shiftCount
expr_stmt|;
name|zSig1
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|shift64Right
argument_list|(
name|absA
argument_list|,
literal|0
argument_list|,
operator|-
name|shiftCount
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|)
expr_stmt|;
block|}
return|return
name|packFloat64
argument_list|(
name|zSign
argument_list|,
literal|0x412
operator|-
name|shiftCount
argument_list|,
name|zSig0
argument_list|,
name|zSig1
argument_list|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SOFTFLOAT_FOR_GCC
end_ifndef

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the single-precision floating-point value `a' to the 32-bit two's complement integer format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic---which means in particular that the conversion is rounded according to the current rounding mode.  If `a' is a NaN, the largest positive integer is returned.  Otherwise, if the conversion overflows, the largest integer with the same sign as `a' is returned. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|int32
name|float32_to_int32
parameter_list|(
name|float32
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|,
name|shiftCount
decl_stmt|;
name|bits32
name|aSig
decl_stmt|,
name|aSigExtra
decl_stmt|;
name|int32
name|z
decl_stmt|;
name|int8
name|roundingMode
decl_stmt|;
name|aSig
operator|=
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat32Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat32Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|shiftCount
operator|=
name|aExp
operator|-
literal|0x96
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|shiftCount
condition|)
block|{
if|if
condition|(
literal|0x9E
operator|<=
name|aExp
condition|)
block|{
if|if
condition|(
name|a
operator|!=
literal|0xCF000000
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aSign
operator|||
operator|(
operator|(
name|aExp
operator|==
literal|0xFF
operator|)
operator|&&
name|aSig
operator|)
condition|)
block|{
return|return
literal|0x7FFFFFFF
return|;
block|}
block|}
return|return
operator|(
name|sbits32
operator|)
literal|0x80000000
return|;
block|}
name|z
operator|=
operator|(
name|aSig
operator||
literal|0x00800000
operator|)
operator|<<
name|shiftCount
expr_stmt|;
if|if
condition|(
name|aSign
condition|)
name|z
operator|=
operator|-
name|z
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|aExp
operator|<
literal|0x7E
condition|)
block|{
name|aSigExtra
operator|=
name|aExp
operator||
name|aSig
expr_stmt|;
name|z
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|aSig
operator||=
literal|0x00800000
expr_stmt|;
name|aSigExtra
operator|=
name|aSig
operator|<<
operator|(
name|shiftCount
operator|&
literal|31
operator|)
expr_stmt|;
name|z
operator|=
name|aSig
operator|>>
operator|(
operator|-
name|shiftCount
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|aSigExtra
condition|)
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
name|roundingMode
operator|=
name|float_rounding_mode
expr_stmt|;
if|if
condition|(
name|roundingMode
operator|==
name|float_round_nearest_even
condition|)
block|{
if|if
condition|(
operator|(
name|sbits32
operator|)
name|aSigExtra
operator|<
literal|0
condition|)
block|{
operator|++
name|z
expr_stmt|;
if|if
condition|(
call|(
name|bits32
call|)
argument_list|(
name|aSigExtra
operator|<<
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|z
operator|&=
operator|~
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|aSign
condition|)
name|z
operator|=
operator|-
name|z
expr_stmt|;
block|}
else|else
block|{
name|aSigExtra
operator|=
operator|(
name|aSigExtra
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|aSign
condition|)
block|{
name|z
operator|+=
operator|(
name|roundingMode
operator|==
name|float_round_down
operator|)
operator|&
name|aSigExtra
expr_stmt|;
name|z
operator|=
operator|-
name|z
expr_stmt|;
block|}
else|else
block|{
name|z
operator|+=
operator|(
name|roundingMode
operator|==
name|float_round_up
operator|)
operator|&
name|aSigExtra
expr_stmt|;
block|}
block|}
block|}
return|return
name|z
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the single-precision floating-point value `a' to the 32-bit two's complement integer format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic, except that the conversion is always rounded toward zero. If `a' is a NaN, the largest positive integer is returned.  Otherwise, if the conversion overflows, the largest integer with the same sign as `a' is returned. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|int32
name|float32_to_int32_round_to_zero
parameter_list|(
name|float32
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|,
name|shiftCount
decl_stmt|;
name|bits32
name|aSig
decl_stmt|;
name|int32
name|z
decl_stmt|;
name|aSig
operator|=
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat32Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat32Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|shiftCount
operator|=
name|aExp
operator|-
literal|0x9E
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|shiftCount
condition|)
block|{
if|if
condition|(
name|a
operator|!=
literal|0xCF000000
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aSign
operator|||
operator|(
operator|(
name|aExp
operator|==
literal|0xFF
operator|)
operator|&&
name|aSig
operator|)
condition|)
return|return
literal|0x7FFFFFFF
return|;
block|}
return|return
operator|(
name|sbits32
operator|)
literal|0x80000000
return|;
block|}
elseif|else
if|if
condition|(
name|aExp
operator|<=
literal|0x7E
condition|)
block|{
if|if
condition|(
name|aExp
operator||
name|aSig
condition|)
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
return|return
literal|0
return|;
block|}
name|aSig
operator|=
operator|(
name|aSig
operator||
literal|0x00800000
operator|)
operator|<<
literal|8
expr_stmt|;
name|z
operator|=
name|aSig
operator|>>
operator|(
operator|-
name|shiftCount
operator|)
expr_stmt|;
if|if
condition|(
call|(
name|bits32
call|)
argument_list|(
name|aSig
operator|<<
operator|(
name|shiftCount
operator|&
literal|31
operator|)
argument_list|)
condition|)
block|{
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
block|}
if|if
condition|(
name|aSign
condition|)
name|z
operator|=
operator|-
name|z
expr_stmt|;
return|return
name|z
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the single-precision floating-point value `a' to the double-precision floating-point format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float64
name|float32_to_float64
parameter_list|(
name|float32
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|;
name|bits32
name|aSig
decl_stmt|,
name|zSig0
decl_stmt|,
name|zSig1
decl_stmt|;
name|aSig
operator|=
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat32Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat32Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0xFF
condition|)
block|{
if|if
condition|(
name|aSig
condition|)
return|return
name|commonNaNToFloat64
argument_list|(
name|float32ToCommonNaN
argument_list|(
name|a
argument_list|)
argument_list|)
return|;
return|return
name|packFloat64
argument_list|(
name|aSign
argument_list|,
literal|0x7FF
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|aSig
operator|==
literal|0
condition|)
return|return
name|packFloat64
argument_list|(
name|aSign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|normalizeFloat32Subnormal
argument_list|(
name|aSig
argument_list|,
operator|&
name|aExp
argument_list|,
operator|&
name|aSig
argument_list|)
expr_stmt|;
operator|--
name|aExp
expr_stmt|;
block|}
name|shift64Right
argument_list|(
name|aSig
argument_list|,
literal|0
argument_list|,
literal|3
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|)
expr_stmt|;
return|return
name|packFloat64
argument_list|(
name|aSign
argument_list|,
name|aExp
operator|+
literal|0x380
argument_list|,
name|zSig0
argument_list|,
name|zSig1
argument_list|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SOFTFLOAT_FOR_GCC
end_ifndef

begin_comment
comment|/* ------------------------------------------------------------------------------- Rounds the single-precision floating-point value `a' to an integer, and returns the result as a single-precision floating-point value.  The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float32
name|float32_round_to_int
parameter_list|(
name|float32
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|;
name|bits32
name|lastBitMask
decl_stmt|,
name|roundBitsMask
decl_stmt|;
name|int8
name|roundingMode
decl_stmt|;
name|float32
name|z
decl_stmt|;
name|aExp
operator|=
name|extractFloat32Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0x96
operator|<=
name|aExp
condition|)
block|{
if|if
condition|(
operator|(
name|aExp
operator|==
literal|0xFF
operator|)
operator|&&
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
condition|)
block|{
return|return
name|propagateFloat32NaN
argument_list|(
name|a
argument_list|,
name|a
argument_list|)
return|;
block|}
return|return
name|a
return|;
block|}
if|if
condition|(
name|aExp
operator|<=
literal|0x7E
condition|)
block|{
if|if
condition|(
call|(
name|bits32
call|)
argument_list|(
name|a
operator|<<
literal|1
argument_list|)
operator|==
literal|0
condition|)
return|return
name|a
return|;
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
name|aSign
operator|=
name|extractFloat32Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|float_rounding_mode
condition|)
block|{
case|case
name|float_round_nearest_even
case|:
if|if
condition|(
operator|(
name|aExp
operator|==
literal|0x7E
operator|)
operator|&&
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
condition|)
block|{
return|return
name|packFloat32
argument_list|(
name|aSign
argument_list|,
literal|0x7F
argument_list|,
literal|0
argument_list|)
return|;
block|}
break|break;
case|case
name|float_round_to_zero
case|:
break|break;
case|case
name|float_round_down
case|:
return|return
name|aSign
condition|?
literal|0xBF800000
else|:
literal|0
return|;
case|case
name|float_round_up
case|:
return|return
name|aSign
condition|?
literal|0x80000000
else|:
literal|0x3F800000
return|;
block|}
return|return
name|packFloat32
argument_list|(
name|aSign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|lastBitMask
operator|=
literal|1
expr_stmt|;
name|lastBitMask
operator|<<=
literal|0x96
operator|-
name|aExp
expr_stmt|;
name|roundBitsMask
operator|=
name|lastBitMask
operator|-
literal|1
expr_stmt|;
name|z
operator|=
name|a
expr_stmt|;
name|roundingMode
operator|=
name|float_rounding_mode
expr_stmt|;
if|if
condition|(
name|roundingMode
operator|==
name|float_round_nearest_even
condition|)
block|{
name|z
operator|+=
name|lastBitMask
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|z
operator|&
name|roundBitsMask
operator|)
operator|==
literal|0
condition|)
name|z
operator|&=
operator|~
name|lastBitMask
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|roundingMode
operator|!=
name|float_round_to_zero
condition|)
block|{
if|if
condition|(
name|extractFloat32Sign
argument_list|(
name|z
argument_list|)
operator|^
operator|(
name|roundingMode
operator|==
name|float_round_up
operator|)
condition|)
block|{
name|z
operator|+=
name|roundBitsMask
expr_stmt|;
block|}
block|}
name|z
operator|&=
operator|~
name|roundBitsMask
expr_stmt|;
if|if
condition|(
name|z
operator|!=
name|a
condition|)
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
return|return
name|z
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of adding the absolute values of the single-precision floating-point values `a' and `b'.  If `zSign' is 1, the sum is negated before being returned.  `zSign' is ignored if the result is a NaN. The addition is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|float32
name|addFloat32Sigs
parameter_list|(
name|float32
name|a
parameter_list|,
name|float32
name|b
parameter_list|,
name|flag
name|zSign
parameter_list|)
block|{
name|int16
name|aExp
decl_stmt|,
name|bExp
decl_stmt|,
name|zExp
decl_stmt|;
name|bits32
name|aSig
decl_stmt|,
name|bSig
decl_stmt|,
name|zSig
decl_stmt|;
name|int16
name|expDiff
decl_stmt|;
name|aSig
operator|=
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat32Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSig
operator|=
name|extractFloat32Frac
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bExp
operator|=
name|extractFloat32Exp
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|expDiff
operator|=
name|aExp
operator|-
name|bExp
expr_stmt|;
name|aSig
operator|<<=
literal|6
expr_stmt|;
name|bSig
operator|<<=
literal|6
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|expDiff
condition|)
block|{
if|if
condition|(
name|aExp
operator|==
literal|0xFF
condition|)
block|{
if|if
condition|(
name|aSig
condition|)
return|return
name|propagateFloat32NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|a
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0
condition|)
block|{
operator|--
name|expDiff
expr_stmt|;
block|}
else|else
block|{
name|bSig
operator||=
literal|0x20000000
expr_stmt|;
block|}
name|shift32RightJamming
argument_list|(
name|bSig
argument_list|,
name|expDiff
argument_list|,
operator|&
name|bSig
argument_list|)
expr_stmt|;
name|zExp
operator|=
name|aExp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expDiff
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|bExp
operator|==
literal|0xFF
condition|)
block|{
if|if
condition|(
name|bSig
condition|)
return|return
name|propagateFloat32NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|packFloat32
argument_list|(
name|zSign
argument_list|,
literal|0xFF
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
operator|++
name|expDiff
expr_stmt|;
block|}
else|else
block|{
name|aSig
operator||=
literal|0x20000000
expr_stmt|;
block|}
name|shift32RightJamming
argument_list|(
name|aSig
argument_list|,
operator|-
name|expDiff
argument_list|,
operator|&
name|aSig
argument_list|)
expr_stmt|;
name|zExp
operator|=
name|bExp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|aExp
operator|==
literal|0xFF
condition|)
block|{
if|if
condition|(
name|aSig
operator||
name|bSig
condition|)
return|return
name|propagateFloat32NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|a
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
return|return
name|packFloat32
argument_list|(
name|zSign
argument_list|,
literal|0
argument_list|,
operator|(
name|aSig
operator|+
name|bSig
operator|)
operator|>>
literal|6
argument_list|)
return|;
name|zSig
operator|=
literal|0x40000000
operator|+
name|aSig
operator|+
name|bSig
expr_stmt|;
name|zExp
operator|=
name|aExp
expr_stmt|;
goto|goto
name|roundAndPack
goto|;
block|}
name|aSig
operator||=
literal|0x20000000
expr_stmt|;
name|zSig
operator|=
operator|(
name|aSig
operator|+
name|bSig
operator|)
operator|<<
literal|1
expr_stmt|;
operator|--
name|zExp
expr_stmt|;
if|if
condition|(
operator|(
name|sbits32
operator|)
name|zSig
operator|<
literal|0
condition|)
block|{
name|zSig
operator|=
name|aSig
operator|+
name|bSig
expr_stmt|;
operator|++
name|zExp
expr_stmt|;
block|}
name|roundAndPack
label|:
return|return
name|roundAndPackFloat32
argument_list|(
name|zSign
argument_list|,
name|zExp
argument_list|,
name|zSig
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of subtracting the absolute values of the single- precision floating-point values `a' and `b'.  If `zSign' is 1, the difference is negated before being returned.  `zSign' is ignored if the result is a NaN.  The subtraction is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|float32
name|subFloat32Sigs
parameter_list|(
name|float32
name|a
parameter_list|,
name|float32
name|b
parameter_list|,
name|flag
name|zSign
parameter_list|)
block|{
name|int16
name|aExp
decl_stmt|,
name|bExp
decl_stmt|,
name|zExp
decl_stmt|;
name|bits32
name|aSig
decl_stmt|,
name|bSig
decl_stmt|,
name|zSig
decl_stmt|;
name|int16
name|expDiff
decl_stmt|;
name|aSig
operator|=
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat32Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSig
operator|=
name|extractFloat32Frac
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bExp
operator|=
name|extractFloat32Exp
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|expDiff
operator|=
name|aExp
operator|-
name|bExp
expr_stmt|;
name|aSig
operator|<<=
literal|7
expr_stmt|;
name|bSig
operator|<<=
literal|7
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|expDiff
condition|)
goto|goto
name|aExpBigger
goto|;
if|if
condition|(
name|expDiff
operator|<
literal|0
condition|)
goto|goto
name|bExpBigger
goto|;
if|if
condition|(
name|aExp
operator|==
literal|0xFF
condition|)
block|{
if|if
condition|(
name|aSig
operator||
name|bSig
condition|)
return|return
name|propagateFloat32NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|float32_default_nan
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
name|aExp
operator|=
literal|1
expr_stmt|;
name|bExp
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bSig
operator|<
name|aSig
condition|)
goto|goto
name|aBigger
goto|;
if|if
condition|(
name|aSig
operator|<
name|bSig
condition|)
goto|goto
name|bBigger
goto|;
return|return
name|packFloat32
argument_list|(
name|float_rounding_mode
operator|==
name|float_round_down
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|bExpBigger
label|:
if|if
condition|(
name|bExp
operator|==
literal|0xFF
condition|)
block|{
if|if
condition|(
name|bSig
condition|)
return|return
name|propagateFloat32NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|packFloat32
argument_list|(
name|zSign
operator|^
literal|1
argument_list|,
literal|0xFF
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
operator|++
name|expDiff
expr_stmt|;
block|}
else|else
block|{
name|aSig
operator||=
literal|0x40000000
expr_stmt|;
block|}
name|shift32RightJamming
argument_list|(
name|aSig
argument_list|,
operator|-
name|expDiff
argument_list|,
operator|&
name|aSig
argument_list|)
expr_stmt|;
name|bSig
operator||=
literal|0x40000000
expr_stmt|;
name|bBigger
label|:
name|zSig
operator|=
name|bSig
operator|-
name|aSig
expr_stmt|;
name|zExp
operator|=
name|bExp
expr_stmt|;
name|zSign
operator|^=
literal|1
expr_stmt|;
goto|goto
name|normalizeRoundAndPack
goto|;
name|aExpBigger
label|:
if|if
condition|(
name|aExp
operator|==
literal|0xFF
condition|)
block|{
if|if
condition|(
name|aSig
condition|)
return|return
name|propagateFloat32NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|a
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0
condition|)
block|{
operator|--
name|expDiff
expr_stmt|;
block|}
else|else
block|{
name|bSig
operator||=
literal|0x40000000
expr_stmt|;
block|}
name|shift32RightJamming
argument_list|(
name|bSig
argument_list|,
name|expDiff
argument_list|,
operator|&
name|bSig
argument_list|)
expr_stmt|;
name|aSig
operator||=
literal|0x40000000
expr_stmt|;
name|aBigger
label|:
name|zSig
operator|=
name|aSig
operator|-
name|bSig
expr_stmt|;
name|zExp
operator|=
name|aExp
expr_stmt|;
name|normalizeRoundAndPack
label|:
operator|--
name|zExp
expr_stmt|;
return|return
name|normalizeRoundAndPackFloat32
argument_list|(
name|zSign
argument_list|,
name|zExp
argument_list|,
name|zSig
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of adding the single-precision floating-point values `a' and `b'.  The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float32
name|float32_add
parameter_list|(
name|float32
name|a
parameter_list|,
name|float32
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|;
name|aSign
operator|=
name|extractFloat32Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat32Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aSign
operator|==
name|bSign
condition|)
block|{
return|return
name|addFloat32Sigs
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|aSign
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|subFloat32Sigs
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|aSign
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of subtracting the single-precision floating-point values `a' and `b'.  The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float32
name|float32_sub
parameter_list|(
name|float32
name|a
parameter_list|,
name|float32
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|;
name|aSign
operator|=
name|extractFloat32Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat32Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aSign
operator|==
name|bSign
condition|)
block|{
return|return
name|subFloat32Sigs
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|aSign
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|addFloat32Sigs
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|aSign
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of multiplying the single-precision floating-point values `a' and `b'.  The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float32
name|float32_mul
parameter_list|(
name|float32
name|a
parameter_list|,
name|float32
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|,
name|zSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|,
name|bExp
decl_stmt|,
name|zExp
decl_stmt|;
name|bits32
name|aSig
decl_stmt|,
name|bSig
decl_stmt|,
name|zSig0
decl_stmt|,
name|zSig1
decl_stmt|;
name|aSig
operator|=
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat32Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat32Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSig
operator|=
name|extractFloat32Frac
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bExp
operator|=
name|extractFloat32Exp
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat32Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|zSign
operator|=
name|aSign
operator|^
name|bSign
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0xFF
condition|)
block|{
if|if
condition|(
name|aSig
operator|||
operator|(
operator|(
name|bExp
operator|==
literal|0xFF
operator|)
operator|&&
name|bSig
operator|)
condition|)
block|{
return|return
name|propagateFloat32NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|bExp
operator||
name|bSig
operator|)
operator|==
literal|0
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|float32_default_nan
return|;
block|}
return|return
name|packFloat32
argument_list|(
name|zSign
argument_list|,
literal|0xFF
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0xFF
condition|)
block|{
if|if
condition|(
name|bSig
condition|)
return|return
name|propagateFloat32NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
if|if
condition|(
operator|(
name|aExp
operator||
name|aSig
operator|)
operator|==
literal|0
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|float32_default_nan
return|;
block|}
return|return
name|packFloat32
argument_list|(
name|zSign
argument_list|,
literal|0xFF
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|aSig
operator|==
literal|0
condition|)
return|return
name|packFloat32
argument_list|(
name|zSign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|normalizeFloat32Subnormal
argument_list|(
name|aSig
argument_list|,
operator|&
name|aExp
argument_list|,
operator|&
name|aSig
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bSig
operator|==
literal|0
condition|)
return|return
name|packFloat32
argument_list|(
name|zSign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|normalizeFloat32Subnormal
argument_list|(
name|bSig
argument_list|,
operator|&
name|bExp
argument_list|,
operator|&
name|bSig
argument_list|)
expr_stmt|;
block|}
name|zExp
operator|=
name|aExp
operator|+
name|bExp
operator|-
literal|0x7F
expr_stmt|;
name|aSig
operator|=
operator|(
name|aSig
operator||
literal|0x00800000
operator|)
operator|<<
literal|7
expr_stmt|;
name|bSig
operator|=
operator|(
name|bSig
operator||
literal|0x00800000
operator|)
operator|<<
literal|8
expr_stmt|;
name|mul32To64
argument_list|(
name|aSig
argument_list|,
name|bSig
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|)
expr_stmt|;
name|zSig0
operator||=
operator|(
name|zSig1
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
call|(
name|sbits32
call|)
argument_list|(
name|zSig0
operator|<<
literal|1
argument_list|)
condition|)
block|{
name|zSig0
operator|<<=
literal|1
expr_stmt|;
operator|--
name|zExp
expr_stmt|;
block|}
return|return
name|roundAndPackFloat32
argument_list|(
name|zSign
argument_list|,
name|zExp
argument_list|,
name|zSig0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of dividing the single-precision floating-point value `a' by the corresponding value `b'.  The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float32
name|float32_div
parameter_list|(
name|float32
name|a
parameter_list|,
name|float32
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|,
name|zSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|,
name|bExp
decl_stmt|,
name|zExp
decl_stmt|;
name|bits32
name|aSig
decl_stmt|,
name|bSig
decl_stmt|,
name|zSig
decl_stmt|,
name|rem0
decl_stmt|,
name|rem1
decl_stmt|,
name|term0
decl_stmt|,
name|term1
decl_stmt|;
name|aSig
operator|=
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat32Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat32Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSig
operator|=
name|extractFloat32Frac
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bExp
operator|=
name|extractFloat32Exp
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat32Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|zSign
operator|=
name|aSign
operator|^
name|bSign
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0xFF
condition|)
block|{
if|if
condition|(
name|aSig
condition|)
return|return
name|propagateFloat32NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
if|if
condition|(
name|bExp
operator|==
literal|0xFF
condition|)
block|{
if|if
condition|(
name|bSig
condition|)
return|return
name|propagateFloat32NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|float32_default_nan
return|;
block|}
return|return
name|packFloat32
argument_list|(
name|zSign
argument_list|,
literal|0xFF
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0xFF
condition|)
block|{
if|if
condition|(
name|bSig
condition|)
return|return
name|propagateFloat32NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|packFloat32
argument_list|(
name|zSign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bSig
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|aExp
operator||
name|aSig
operator|)
operator|==
literal|0
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|float32_default_nan
return|;
block|}
name|float_raise
argument_list|(
name|float_flag_divbyzero
argument_list|)
expr_stmt|;
return|return
name|packFloat32
argument_list|(
name|zSign
argument_list|,
literal|0xFF
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|normalizeFloat32Subnormal
argument_list|(
name|bSig
argument_list|,
operator|&
name|bExp
argument_list|,
operator|&
name|bSig
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|aSig
operator|==
literal|0
condition|)
return|return
name|packFloat32
argument_list|(
name|zSign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|normalizeFloat32Subnormal
argument_list|(
name|aSig
argument_list|,
operator|&
name|aExp
argument_list|,
operator|&
name|aSig
argument_list|)
expr_stmt|;
block|}
name|zExp
operator|=
name|aExp
operator|-
name|bExp
operator|+
literal|0x7D
expr_stmt|;
name|aSig
operator|=
operator|(
name|aSig
operator||
literal|0x00800000
operator|)
operator|<<
literal|7
expr_stmt|;
name|bSig
operator|=
operator|(
name|bSig
operator||
literal|0x00800000
operator|)
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|bSig
operator|<=
operator|(
name|aSig
operator|+
name|aSig
operator|)
condition|)
block|{
name|aSig
operator|>>=
literal|1
expr_stmt|;
operator|++
name|zExp
expr_stmt|;
block|}
name|zSig
operator|=
name|estimateDiv64To32
argument_list|(
name|aSig
argument_list|,
literal|0
argument_list|,
name|bSig
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zSig
operator|&
literal|0x3F
operator|)
operator|<=
literal|2
condition|)
block|{
name|mul32To64
argument_list|(
name|bSig
argument_list|,
name|zSig
argument_list|,
operator|&
name|term0
argument_list|,
operator|&
name|term1
argument_list|)
expr_stmt|;
name|sub64
argument_list|(
name|aSig
argument_list|,
literal|0
argument_list|,
name|term0
argument_list|,
name|term1
argument_list|,
operator|&
name|rem0
argument_list|,
operator|&
name|rem1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|sbits32
operator|)
name|rem0
operator|<
literal|0
condition|)
block|{
operator|--
name|zSig
expr_stmt|;
name|add64
argument_list|(
name|rem0
argument_list|,
name|rem1
argument_list|,
literal|0
argument_list|,
name|bSig
argument_list|,
operator|&
name|rem0
argument_list|,
operator|&
name|rem1
argument_list|)
expr_stmt|;
block|}
name|zSig
operator||=
operator|(
name|rem1
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
return|return
name|roundAndPackFloat32
argument_list|(
name|zSign
argument_list|,
name|zExp
argument_list|,
name|zSig
argument_list|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SOFTFLOAT_FOR_GCC
end_ifndef

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the remainder of the single-precision floating-point value `a' with respect to the corresponding value `b'.  The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float32
name|float32_rem
parameter_list|(
name|float32
name|a
parameter_list|,
name|float32
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|,
name|zSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|,
name|bExp
decl_stmt|,
name|expDiff
decl_stmt|;
name|bits32
name|aSig
decl_stmt|,
name|bSig
decl_stmt|,
name|q
decl_stmt|,
name|allZero
decl_stmt|,
name|alternateASig
decl_stmt|;
name|sbits32
name|sigMean
decl_stmt|;
name|aSig
operator|=
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat32Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat32Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSig
operator|=
name|extractFloat32Frac
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bExp
operator|=
name|extractFloat32Exp
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat32Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0xFF
condition|)
block|{
if|if
condition|(
name|aSig
operator|||
operator|(
operator|(
name|bExp
operator|==
literal|0xFF
operator|)
operator|&&
name|bSig
operator|)
condition|)
block|{
return|return
name|propagateFloat32NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|float32_default_nan
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0xFF
condition|)
block|{
if|if
condition|(
name|bSig
condition|)
return|return
name|propagateFloat32NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|a
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bSig
operator|==
literal|0
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|float32_default_nan
return|;
block|}
name|normalizeFloat32Subnormal
argument_list|(
name|bSig
argument_list|,
operator|&
name|bExp
argument_list|,
operator|&
name|bSig
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|aSig
operator|==
literal|0
condition|)
return|return
name|a
return|;
name|normalizeFloat32Subnormal
argument_list|(
name|aSig
argument_list|,
operator|&
name|aExp
argument_list|,
operator|&
name|aSig
argument_list|)
expr_stmt|;
block|}
name|expDiff
operator|=
name|aExp
operator|-
name|bExp
expr_stmt|;
name|aSig
operator|=
operator|(
name|aSig
operator||
literal|0x00800000
operator|)
operator|<<
literal|8
expr_stmt|;
name|bSig
operator|=
operator|(
name|bSig
operator||
literal|0x00800000
operator|)
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|expDiff
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|expDiff
operator|<
operator|-
literal|1
condition|)
return|return
name|a
return|;
name|aSig
operator|>>=
literal|1
expr_stmt|;
block|}
name|q
operator|=
operator|(
name|bSig
operator|<=
name|aSig
operator|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
name|aSig
operator|-=
name|bSig
expr_stmt|;
name|expDiff
operator|-=
literal|32
expr_stmt|;
while|while
condition|(
literal|0
operator|<
name|expDiff
condition|)
block|{
name|q
operator|=
name|estimateDiv64To32
argument_list|(
name|aSig
argument_list|,
literal|0
argument_list|,
name|bSig
argument_list|)
expr_stmt|;
name|q
operator|=
operator|(
literal|2
operator|<
name|q
operator|)
condition|?
name|q
operator|-
literal|2
else|:
literal|0
expr_stmt|;
name|aSig
operator|=
operator|-
operator|(
operator|(
name|bSig
operator|>>
literal|2
operator|)
operator|*
name|q
operator|)
expr_stmt|;
name|expDiff
operator|-=
literal|30
expr_stmt|;
block|}
name|expDiff
operator|+=
literal|32
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|expDiff
condition|)
block|{
name|q
operator|=
name|estimateDiv64To32
argument_list|(
name|aSig
argument_list|,
literal|0
argument_list|,
name|bSig
argument_list|)
expr_stmt|;
name|q
operator|=
operator|(
literal|2
operator|<
name|q
operator|)
condition|?
name|q
operator|-
literal|2
else|:
literal|0
expr_stmt|;
name|q
operator|>>=
literal|32
operator|-
name|expDiff
expr_stmt|;
name|bSig
operator|>>=
literal|2
expr_stmt|;
name|aSig
operator|=
operator|(
operator|(
name|aSig
operator|>>
literal|1
operator|)
operator|<<
operator|(
name|expDiff
operator|-
literal|1
operator|)
operator|)
operator|-
name|bSig
operator|*
name|q
expr_stmt|;
block|}
else|else
block|{
name|aSig
operator|>>=
literal|2
expr_stmt|;
name|bSig
operator|>>=
literal|2
expr_stmt|;
block|}
do|do
block|{
name|alternateASig
operator|=
name|aSig
expr_stmt|;
operator|++
name|q
expr_stmt|;
name|aSig
operator|-=
name|bSig
expr_stmt|;
block|}
do|while
condition|(
literal|0
operator|<=
operator|(
name|sbits32
operator|)
name|aSig
condition|)
do|;
name|sigMean
operator|=
name|aSig
operator|+
name|alternateASig
expr_stmt|;
if|if
condition|(
operator|(
name|sigMean
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|sigMean
operator|==
literal|0
operator|)
operator|&&
operator|(
name|q
operator|&
literal|1
operator|)
operator|)
condition|)
block|{
name|aSig
operator|=
name|alternateASig
expr_stmt|;
block|}
name|zSign
operator|=
operator|(
operator|(
name|sbits32
operator|)
name|aSig
operator|<
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|zSign
condition|)
name|aSig
operator|=
operator|-
name|aSig
expr_stmt|;
return|return
name|normalizeRoundAndPackFloat32
argument_list|(
name|aSign
operator|^
name|zSign
argument_list|,
name|bExp
argument_list|,
name|aSig
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SOFTFLOAT_FOR_GCC
end_ifndef

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the square root of the single-precision floating-point value `a'. The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float32
name|float32_sqrt
parameter_list|(
name|float32
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|,
name|zExp
decl_stmt|;
name|bits32
name|aSig
decl_stmt|,
name|zSig
decl_stmt|,
name|rem0
decl_stmt|,
name|rem1
decl_stmt|,
name|term0
decl_stmt|,
name|term1
decl_stmt|;
name|aSig
operator|=
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat32Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat32Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0xFF
condition|)
block|{
if|if
condition|(
name|aSig
condition|)
return|return
name|propagateFloat32NaN
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
operator|!
name|aSign
condition|)
return|return
name|a
return|;
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|float32_default_nan
return|;
block|}
if|if
condition|(
name|aSign
condition|)
block|{
if|if
condition|(
operator|(
name|aExp
operator||
name|aSig
operator|)
operator|==
literal|0
condition|)
return|return
name|a
return|;
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|float32_default_nan
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|aSig
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|normalizeFloat32Subnormal
argument_list|(
name|aSig
argument_list|,
operator|&
name|aExp
argument_list|,
operator|&
name|aSig
argument_list|)
expr_stmt|;
block|}
name|zExp
operator|=
operator|(
operator|(
name|aExp
operator|-
literal|0x7F
operator|)
operator|>>
literal|1
operator|)
operator|+
literal|0x7E
expr_stmt|;
name|aSig
operator|=
operator|(
name|aSig
operator||
literal|0x00800000
operator|)
operator|<<
literal|8
expr_stmt|;
name|zSig
operator|=
name|estimateSqrt32
argument_list|(
name|aExp
argument_list|,
name|aSig
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|zSig
operator|&
literal|0x7F
operator|)
operator|<=
literal|5
condition|)
block|{
if|if
condition|(
name|zSig
operator|<
literal|2
condition|)
block|{
name|zSig
operator|=
literal|0x7FFFFFFF
expr_stmt|;
goto|goto
name|roundAndPack
goto|;
block|}
else|else
block|{
name|aSig
operator|>>=
name|aExp
operator|&
literal|1
expr_stmt|;
name|mul32To64
argument_list|(
name|zSig
argument_list|,
name|zSig
argument_list|,
operator|&
name|term0
argument_list|,
operator|&
name|term1
argument_list|)
expr_stmt|;
name|sub64
argument_list|(
name|aSig
argument_list|,
literal|0
argument_list|,
name|term0
argument_list|,
name|term1
argument_list|,
operator|&
name|rem0
argument_list|,
operator|&
name|rem1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|sbits32
operator|)
name|rem0
operator|<
literal|0
condition|)
block|{
operator|--
name|zSig
expr_stmt|;
name|shortShift64Left
argument_list|(
literal|0
argument_list|,
name|zSig
argument_list|,
literal|1
argument_list|,
operator|&
name|term0
argument_list|,
operator|&
name|term1
argument_list|)
expr_stmt|;
name|term1
operator||=
literal|1
expr_stmt|;
name|add64
argument_list|(
name|rem0
argument_list|,
name|rem1
argument_list|,
name|term0
argument_list|,
name|term1
argument_list|,
operator|&
name|rem0
argument_list|,
operator|&
name|rem1
argument_list|)
expr_stmt|;
block|}
name|zSig
operator||=
operator|(
operator|(
name|rem0
operator||
name|rem1
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
block|}
name|shift32RightJamming
argument_list|(
name|zSig
argument_list|,
literal|1
argument_list|,
operator|&
name|zSig
argument_list|)
expr_stmt|;
name|roundAndPack
label|:
return|return
name|roundAndPackFloat32
argument_list|(
literal|0
argument_list|,
name|zExp
argument_list|,
name|zSig
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns 1 if the single-precision floating-point value `a' is equal to the corresponding value `b', and 0 otherwise.  The comparison is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|flag
name|float32_eq
parameter_list|(
name|float32
name|a
parameter_list|,
name|float32
name|b
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|extractFloat32Exp
argument_list|(
name|a
argument_list|)
operator|==
literal|0xFF
operator|)
operator|&&
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|extractFloat32Exp
argument_list|(
name|b
argument_list|)
operator|==
literal|0xFF
operator|)
operator|&&
name|extractFloat32Frac
argument_list|(
name|b
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|float32_is_signaling_nan
argument_list|(
name|a
argument_list|)
operator|||
name|float32_is_signaling_nan
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
return|return
operator|(
name|a
operator|==
name|b
operator|)
operator|||
operator|(
call|(
name|bits32
call|)
argument_list|(
operator|(
name|a
operator||
name|b
operator|)
operator|<<
literal|1
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns 1 if the single-precision floating-point value `a' is less than or equal to the corresponding value `b', and 0 otherwise.  The comparison is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|flag
name|float32_le
parameter_list|(
name|float32
name|a
parameter_list|,
name|float32
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|extractFloat32Exp
argument_list|(
name|a
argument_list|)
operator|==
literal|0xFF
operator|)
operator|&&
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|extractFloat32Exp
argument_list|(
name|b
argument_list|)
operator|==
literal|0xFF
operator|)
operator|&&
name|extractFloat32Frac
argument_list|(
name|b
argument_list|)
operator|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|aSign
operator|=
name|extractFloat32Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat32Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aSign
operator|!=
name|bSign
condition|)
return|return
name|aSign
operator|||
operator|(
call|(
name|bits32
call|)
argument_list|(
operator|(
name|a
operator||
name|b
operator|)
operator|<<
literal|1
argument_list|)
operator|==
literal|0
operator|)
return|;
return|return
operator|(
name|a
operator|==
name|b
operator|)
operator|||
operator|(
name|aSign
operator|^
operator|(
name|a
operator|<
name|b
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns 1 if the single-precision floating-point value `a' is less than the corresponding value `b', and 0 otherwise.  The comparison is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|flag
name|float32_lt
parameter_list|(
name|float32
name|a
parameter_list|,
name|float32
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|extractFloat32Exp
argument_list|(
name|a
argument_list|)
operator|==
literal|0xFF
operator|)
operator|&&
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|extractFloat32Exp
argument_list|(
name|b
argument_list|)
operator|==
literal|0xFF
operator|)
operator|&&
name|extractFloat32Frac
argument_list|(
name|b
argument_list|)
operator|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|aSign
operator|=
name|extractFloat32Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat32Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aSign
operator|!=
name|bSign
condition|)
return|return
name|aSign
operator|&&
operator|(
call|(
name|bits32
call|)
argument_list|(
operator|(
name|a
operator||
name|b
operator|)
operator|<<
literal|1
argument_list|)
operator|!=
literal|0
operator|)
return|;
return|return
operator|(
name|a
operator|!=
name|b
operator|)
operator|&&
operator|(
name|aSign
operator|^
operator|(
name|a
operator|<
name|b
operator|)
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SOFTFLOAT_FOR_GCC
end_ifndef

begin_comment
comment|/* Not needed */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns 1 if the single-precision floating-point value `a' is equal to the corresponding value `b', and 0 otherwise.  The invalid exception is raised if either operand is a NaN.  Otherwise, the comparison is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|flag
name|float32_eq_signaling
parameter_list|(
name|float32
name|a
parameter_list|,
name|float32
name|b
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|extractFloat32Exp
argument_list|(
name|a
argument_list|)
operator|==
literal|0xFF
operator|)
operator|&&
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|extractFloat32Exp
argument_list|(
name|b
argument_list|)
operator|==
literal|0xFF
operator|)
operator|&&
name|extractFloat32Frac
argument_list|(
name|b
argument_list|)
operator|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|(
name|a
operator|==
name|b
operator|)
operator|||
operator|(
call|(
name|bits32
call|)
argument_list|(
operator|(
name|a
operator||
name|b
operator|)
operator|<<
literal|1
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns 1 if the single-precision floating-point value `a' is less than or equal to the corresponding value `b', and 0 otherwise.  Quiet NaNs do not cause an exception.  Otherwise, the comparison is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|flag
name|float32_le_quiet
parameter_list|(
name|float32
name|a
parameter_list|,
name|float32
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|,
name|bExp
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|extractFloat32Exp
argument_list|(
name|a
argument_list|)
operator|==
literal|0xFF
operator|)
operator|&&
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|extractFloat32Exp
argument_list|(
name|b
argument_list|)
operator|==
literal|0xFF
operator|)
operator|&&
name|extractFloat32Frac
argument_list|(
name|b
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|float32_is_signaling_nan
argument_list|(
name|a
argument_list|)
operator|||
name|float32_is_signaling_nan
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|aSign
operator|=
name|extractFloat32Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat32Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aSign
operator|!=
name|bSign
condition|)
return|return
name|aSign
operator|||
operator|(
call|(
name|bits32
call|)
argument_list|(
operator|(
name|a
operator||
name|b
operator|)
operator|<<
literal|1
argument_list|)
operator|==
literal|0
operator|)
return|;
return|return
operator|(
name|a
operator|==
name|b
operator|)
operator|||
operator|(
name|aSign
operator|^
operator|(
name|a
operator|<
name|b
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns 1 if the single-precision floating-point value `a' is less than the corresponding value `b', and 0 otherwise.  Quiet NaNs do not cause an exception.  Otherwise, the comparison is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|flag
name|float32_lt_quiet
parameter_list|(
name|float32
name|a
parameter_list|,
name|float32
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|extractFloat32Exp
argument_list|(
name|a
argument_list|)
operator|==
literal|0xFF
operator|)
operator|&&
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|extractFloat32Exp
argument_list|(
name|b
argument_list|)
operator|==
literal|0xFF
operator|)
operator|&&
name|extractFloat32Frac
argument_list|(
name|b
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|float32_is_signaling_nan
argument_list|(
name|a
argument_list|)
operator|||
name|float32_is_signaling_nan
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|aSign
operator|=
name|extractFloat32Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat32Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aSign
operator|!=
name|bSign
condition|)
return|return
name|aSign
operator|&&
operator|(
call|(
name|bits32
call|)
argument_list|(
operator|(
name|a
operator||
name|b
operator|)
operator|<<
literal|1
argument_list|)
operator|!=
literal|0
operator|)
return|;
return|return
operator|(
name|a
operator|!=
name|b
operator|)
operator|&&
operator|(
name|aSign
operator|^
operator|(
name|a
operator|<
name|b
operator|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SOFTFLOAT_FOR_GCC */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SOFTFLOAT_FOR_GCC
end_ifndef

begin_comment
comment|/* Not needed */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the double-precision floating-point value `a' to the 32-bit two's complement integer format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic---which means in particular that the conversion is rounded according to the current rounding mode.  If `a' is a NaN, the largest positive integer is returned.  Otherwise, if the conversion overflows, the largest integer with the same sign as `a' is returned. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|int32
name|float64_to_int32
parameter_list|(
name|float64
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|,
name|shiftCount
decl_stmt|;
name|bits32
name|aSig0
decl_stmt|,
name|aSig1
decl_stmt|,
name|absZ
decl_stmt|,
name|aSigExtra
decl_stmt|;
name|int32
name|z
decl_stmt|;
name|int8
name|roundingMode
decl_stmt|;
name|aSig1
operator|=
name|extractFloat64Frac1
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSig0
operator|=
name|extractFloat64Frac0
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat64Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat64Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|shiftCount
operator|=
name|aExp
operator|-
literal|0x413
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|shiftCount
condition|)
block|{
if|if
condition|(
literal|0x41E
operator|<
name|aExp
condition|)
block|{
if|if
condition|(
operator|(
name|aExp
operator|==
literal|0x7FF
operator|)
operator|&&
operator|(
name|aSig0
operator||
name|aSig1
operator|)
condition|)
name|aSign
operator|=
literal|0
expr_stmt|;
goto|goto
name|invalid
goto|;
block|}
name|shortShift64Left
argument_list|(
name|aSig0
operator||
literal|0x00100000
argument_list|,
name|aSig1
argument_list|,
name|shiftCount
argument_list|,
operator|&
name|absZ
argument_list|,
operator|&
name|aSigExtra
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0x80000000
operator|<
name|absZ
condition|)
goto|goto
name|invalid
goto|;
block|}
else|else
block|{
name|aSig1
operator|=
operator|(
name|aSig1
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|aExp
operator|<
literal|0x3FE
condition|)
block|{
name|aSigExtra
operator|=
name|aExp
operator||
name|aSig0
operator||
name|aSig1
expr_stmt|;
name|absZ
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|aSig0
operator||=
literal|0x00100000
expr_stmt|;
name|aSigExtra
operator|=
operator|(
name|aSig0
operator|<<
operator|(
name|shiftCount
operator|&
literal|31
operator|)
operator|)
operator||
name|aSig1
expr_stmt|;
name|absZ
operator|=
name|aSig0
operator|>>
operator|(
operator|-
name|shiftCount
operator|)
expr_stmt|;
block|}
block|}
name|roundingMode
operator|=
name|float_rounding_mode
expr_stmt|;
if|if
condition|(
name|roundingMode
operator|==
name|float_round_nearest_even
condition|)
block|{
if|if
condition|(
operator|(
name|sbits32
operator|)
name|aSigExtra
operator|<
literal|0
condition|)
block|{
operator|++
name|absZ
expr_stmt|;
if|if
condition|(
call|(
name|bits32
call|)
argument_list|(
name|aSigExtra
operator|<<
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|absZ
operator|&=
operator|~
literal|1
expr_stmt|;
block|}
name|z
operator|=
name|aSign
condition|?
operator|-
name|absZ
else|:
name|absZ
expr_stmt|;
block|}
else|else
block|{
name|aSigExtra
operator|=
operator|(
name|aSigExtra
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|aSign
condition|)
block|{
name|z
operator|=
operator|-
operator|(
name|absZ
operator|+
operator|(
operator|(
name|roundingMode
operator|==
name|float_round_down
operator|)
operator|&
name|aSigExtra
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|z
operator|=
name|absZ
operator|+
operator|(
operator|(
name|roundingMode
operator|==
name|float_round_up
operator|)
operator|&
name|aSigExtra
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|aSign
operator|^
operator|(
name|z
operator|<
literal|0
operator|)
operator|)
operator|&&
name|z
condition|)
block|{
name|invalid
label|:
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|aSign
condition|?
operator|(
name|sbits32
operator|)
literal|0x80000000
else|:
literal|0x7FFFFFFF
return|;
block|}
if|if
condition|(
name|aSigExtra
condition|)
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
return|return
name|z
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SOFTFLOAT_FOR_GCC */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the double-precision floating-point value `a' to the 32-bit two's complement integer format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic, except that the conversion is always rounded toward zero. If `a' is a NaN, the largest positive integer is returned.  Otherwise, if the conversion overflows, the largest integer with the same sign as `a' is returned. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|int32
name|float64_to_int32_round_to_zero
parameter_list|(
name|float64
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|,
name|shiftCount
decl_stmt|;
name|bits32
name|aSig0
decl_stmt|,
name|aSig1
decl_stmt|,
name|absZ
decl_stmt|,
name|aSigExtra
decl_stmt|;
name|int32
name|z
decl_stmt|;
name|aSig1
operator|=
name|extractFloat64Frac1
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSig0
operator|=
name|extractFloat64Frac0
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat64Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat64Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|shiftCount
operator|=
name|aExp
operator|-
literal|0x413
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|shiftCount
condition|)
block|{
if|if
condition|(
literal|0x41E
operator|<
name|aExp
condition|)
block|{
if|if
condition|(
operator|(
name|aExp
operator|==
literal|0x7FF
operator|)
operator|&&
operator|(
name|aSig0
operator||
name|aSig1
operator|)
condition|)
name|aSign
operator|=
literal|0
expr_stmt|;
goto|goto
name|invalid
goto|;
block|}
name|shortShift64Left
argument_list|(
name|aSig0
operator||
literal|0x00100000
argument_list|,
name|aSig1
argument_list|,
name|shiftCount
argument_list|,
operator|&
name|absZ
argument_list|,
operator|&
name|aSigExtra
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|aExp
operator|<
literal|0x3FF
condition|)
block|{
if|if
condition|(
name|aExp
operator||
name|aSig0
operator||
name|aSig1
condition|)
block|{
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|aSig0
operator||=
literal|0x00100000
expr_stmt|;
name|aSigExtra
operator|=
operator|(
name|aSig0
operator|<<
operator|(
name|shiftCount
operator|&
literal|31
operator|)
operator|)
operator||
name|aSig1
expr_stmt|;
name|absZ
operator|=
name|aSig0
operator|>>
operator|(
operator|-
name|shiftCount
operator|)
expr_stmt|;
block|}
name|z
operator|=
name|aSign
condition|?
operator|-
name|absZ
else|:
name|absZ
expr_stmt|;
if|if
condition|(
operator|(
name|aSign
operator|^
operator|(
name|z
operator|<
literal|0
operator|)
operator|)
operator|&&
name|z
condition|)
block|{
name|invalid
label|:
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|aSign
condition|?
operator|(
name|sbits32
operator|)
literal|0x80000000
else|:
literal|0x7FFFFFFF
return|;
block|}
if|if
condition|(
name|aSigExtra
condition|)
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
return|return
name|z
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the double-precision floating-point value `a' to the single-precision floating-point format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float32
name|float64_to_float32
parameter_list|(
name|float64
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|;
name|bits32
name|aSig0
decl_stmt|,
name|aSig1
decl_stmt|,
name|zSig
decl_stmt|;
name|bits32
name|allZero
decl_stmt|;
name|aSig1
operator|=
name|extractFloat64Frac1
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSig0
operator|=
name|extractFloat64Frac0
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat64Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat64Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0x7FF
condition|)
block|{
if|if
condition|(
name|aSig0
operator||
name|aSig1
condition|)
block|{
return|return
name|commonNaNToFloat32
argument_list|(
name|float64ToCommonNaN
argument_list|(
name|a
argument_list|)
argument_list|)
return|;
block|}
return|return
name|packFloat32
argument_list|(
name|aSign
argument_list|,
literal|0xFF
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|shift64RightJamming
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
literal|22
argument_list|,
operator|&
name|allZero
argument_list|,
operator|&
name|zSig
argument_list|)
expr_stmt|;
if|if
condition|(
name|aExp
condition|)
name|zSig
operator||=
literal|0x40000000
expr_stmt|;
return|return
name|roundAndPackFloat32
argument_list|(
name|aSign
argument_list|,
name|aExp
operator|-
literal|0x381
argument_list|,
name|zSig
argument_list|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SOFTFLOAT_FOR_GCC
end_ifndef

begin_comment
comment|/* ------------------------------------------------------------------------------- Rounds the double-precision floating-point value `a' to an integer, and returns the result as a double-precision floating-point value.  The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float64
name|float64_round_to_int
parameter_list|(
name|float64
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|;
name|bits32
name|lastBitMask
decl_stmt|,
name|roundBitsMask
decl_stmt|;
name|int8
name|roundingMode
decl_stmt|;
name|float64
name|z
decl_stmt|;
name|aExp
operator|=
name|extractFloat64Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0x413
operator|<=
name|aExp
condition|)
block|{
if|if
condition|(
literal|0x433
operator|<=
name|aExp
condition|)
block|{
if|if
condition|(
operator|(
name|aExp
operator|==
literal|0x7FF
operator|)
operator|&&
operator|(
name|extractFloat64Frac0
argument_list|(
name|a
argument_list|)
operator||
name|extractFloat64Frac1
argument_list|(
name|a
argument_list|)
operator|)
condition|)
block|{
return|return
name|propagateFloat64NaN
argument_list|(
name|a
argument_list|,
name|a
argument_list|)
return|;
block|}
return|return
name|a
return|;
block|}
name|lastBitMask
operator|=
literal|1
expr_stmt|;
name|lastBitMask
operator|=
operator|(
name|lastBitMask
operator|<<
operator|(
literal|0x432
operator|-
name|aExp
operator|)
operator|)
operator|<<
literal|1
expr_stmt|;
name|roundBitsMask
operator|=
name|lastBitMask
operator|-
literal|1
expr_stmt|;
name|z
operator|=
name|a
expr_stmt|;
name|roundingMode
operator|=
name|float_rounding_mode
expr_stmt|;
if|if
condition|(
name|roundingMode
operator|==
name|float_round_nearest_even
condition|)
block|{
if|if
condition|(
name|lastBitMask
condition|)
block|{
name|add64
argument_list|(
name|z
operator|.
name|high
argument_list|,
name|z
operator|.
name|low
argument_list|,
literal|0
argument_list|,
name|lastBitMask
operator|>>
literal|1
argument_list|,
operator|&
name|z
operator|.
name|high
argument_list|,
operator|&
name|z
operator|.
name|low
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|z
operator|.
name|low
operator|&
name|roundBitsMask
operator|)
operator|==
literal|0
condition|)
name|z
operator|.
name|low
operator|&=
operator|~
name|lastBitMask
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|sbits32
operator|)
name|z
operator|.
name|low
operator|<
literal|0
condition|)
block|{
operator|++
name|z
operator|.
name|high
expr_stmt|;
if|if
condition|(
call|(
name|bits32
call|)
argument_list|(
name|z
operator|.
name|low
operator|<<
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|z
operator|.
name|high
operator|&=
operator|~
literal|1
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|roundingMode
operator|!=
name|float_round_to_zero
condition|)
block|{
if|if
condition|(
name|extractFloat64Sign
argument_list|(
name|z
argument_list|)
operator|^
operator|(
name|roundingMode
operator|==
name|float_round_up
operator|)
condition|)
block|{
name|add64
argument_list|(
name|z
operator|.
name|high
argument_list|,
name|z
operator|.
name|low
argument_list|,
literal|0
argument_list|,
name|roundBitsMask
argument_list|,
operator|&
name|z
operator|.
name|high
argument_list|,
operator|&
name|z
operator|.
name|low
argument_list|)
expr_stmt|;
block|}
block|}
name|z
operator|.
name|low
operator|&=
operator|~
name|roundBitsMask
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|aExp
operator|<=
literal|0x3FE
condition|)
block|{
if|if
condition|(
operator|(
operator|(
call|(
name|bits32
call|)
argument_list|(
name|a
operator|.
name|high
operator|<<
literal|1
argument_list|)
operator|)
operator||
name|a
operator|.
name|low
operator|)
operator|==
literal|0
condition|)
return|return
name|a
return|;
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
name|aSign
operator|=
name|extractFloat64Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|float_rounding_mode
condition|)
block|{
case|case
name|float_round_nearest_even
case|:
if|if
condition|(
operator|(
name|aExp
operator|==
literal|0x3FE
operator|)
operator|&&
operator|(
name|extractFloat64Frac0
argument_list|(
name|a
argument_list|)
operator||
name|extractFloat64Frac1
argument_list|(
name|a
argument_list|)
operator|)
condition|)
block|{
return|return
name|packFloat64
argument_list|(
name|aSign
argument_list|,
literal|0x3FF
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
break|break;
case|case
name|float_round_down
case|:
return|return
name|aSign
condition|?
name|packFloat64
argument_list|(
literal|1
argument_list|,
literal|0x3FF
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
else|:
name|packFloat64
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|float_round_up
case|:
return|return
name|aSign
condition|?
name|packFloat64
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
else|:
name|packFloat64
argument_list|(
literal|0
argument_list|,
literal|0x3FF
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
name|packFloat64
argument_list|(
name|aSign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|lastBitMask
operator|=
literal|1
expr_stmt|;
name|lastBitMask
operator|<<=
literal|0x413
operator|-
name|aExp
expr_stmt|;
name|roundBitsMask
operator|=
name|lastBitMask
operator|-
literal|1
expr_stmt|;
name|z
operator|.
name|low
operator|=
literal|0
expr_stmt|;
name|z
operator|.
name|high
operator|=
name|a
operator|.
name|high
expr_stmt|;
name|roundingMode
operator|=
name|float_rounding_mode
expr_stmt|;
if|if
condition|(
name|roundingMode
operator|==
name|float_round_nearest_even
condition|)
block|{
name|z
operator|.
name|high
operator|+=
name|lastBitMask
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|z
operator|.
name|high
operator|&
name|roundBitsMask
operator|)
operator||
name|a
operator|.
name|low
operator|)
operator|==
literal|0
condition|)
block|{
name|z
operator|.
name|high
operator|&=
operator|~
name|lastBitMask
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|roundingMode
operator|!=
name|float_round_to_zero
condition|)
block|{
if|if
condition|(
name|extractFloat64Sign
argument_list|(
name|z
argument_list|)
operator|^
operator|(
name|roundingMode
operator|==
name|float_round_up
operator|)
condition|)
block|{
name|z
operator|.
name|high
operator||=
operator|(
name|a
operator|.
name|low
operator|!=
literal|0
operator|)
expr_stmt|;
name|z
operator|.
name|high
operator|+=
name|roundBitsMask
expr_stmt|;
block|}
block|}
name|z
operator|.
name|high
operator|&=
operator|~
name|roundBitsMask
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|z
operator|.
name|low
operator|!=
name|a
operator|.
name|low
operator|)
operator|||
operator|(
name|z
operator|.
name|high
operator|!=
name|a
operator|.
name|high
operator|)
condition|)
block|{
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
block|}
return|return
name|z
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of adding the absolute values of the double-precision floating-point values `a' and `b'.  If `zSign' is 1, the sum is negated before being returned.  `zSign' is ignored if the result is a NaN. The addition is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|float64
name|addFloat64Sigs
parameter_list|(
name|float64
name|a
parameter_list|,
name|float64
name|b
parameter_list|,
name|flag
name|zSign
parameter_list|)
block|{
name|int16
name|aExp
decl_stmt|,
name|bExp
decl_stmt|,
name|zExp
decl_stmt|;
name|bits32
name|aSig0
decl_stmt|,
name|aSig1
decl_stmt|,
name|bSig0
decl_stmt|,
name|bSig1
decl_stmt|,
name|zSig0
decl_stmt|,
name|zSig1
decl_stmt|,
name|zSig2
decl_stmt|;
name|int16
name|expDiff
decl_stmt|;
name|aSig1
operator|=
name|extractFloat64Frac1
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSig0
operator|=
name|extractFloat64Frac0
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat64Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSig1
operator|=
name|extractFloat64Frac1
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bSig0
operator|=
name|extractFloat64Frac0
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bExp
operator|=
name|extractFloat64Exp
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|expDiff
operator|=
name|aExp
operator|-
name|bExp
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|expDiff
condition|)
block|{
if|if
condition|(
name|aExp
operator|==
literal|0x7FF
condition|)
block|{
if|if
condition|(
name|aSig0
operator||
name|aSig1
condition|)
return|return
name|propagateFloat64NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|a
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0
condition|)
block|{
operator|--
name|expDiff
expr_stmt|;
block|}
else|else
block|{
name|bSig0
operator||=
literal|0x00100000
expr_stmt|;
block|}
name|shift64ExtraRightJamming
argument_list|(
name|bSig0
argument_list|,
name|bSig1
argument_list|,
literal|0
argument_list|,
name|expDiff
argument_list|,
operator|&
name|bSig0
argument_list|,
operator|&
name|bSig1
argument_list|,
operator|&
name|zSig2
argument_list|)
expr_stmt|;
name|zExp
operator|=
name|aExp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expDiff
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|bExp
operator|==
literal|0x7FF
condition|)
block|{
if|if
condition|(
name|bSig0
operator||
name|bSig1
condition|)
return|return
name|propagateFloat64NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|packFloat64
argument_list|(
name|zSign
argument_list|,
literal|0x7FF
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
operator|++
name|expDiff
expr_stmt|;
block|}
else|else
block|{
name|aSig0
operator||=
literal|0x00100000
expr_stmt|;
block|}
name|shift64ExtraRightJamming
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
literal|0
argument_list|,
operator|-
name|expDiff
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|,
operator|&
name|zSig2
argument_list|)
expr_stmt|;
name|zExp
operator|=
name|bExp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|aExp
operator|==
literal|0x7FF
condition|)
block|{
if|if
condition|(
name|aSig0
operator||
name|aSig1
operator||
name|bSig0
operator||
name|bSig1
condition|)
block|{
return|return
name|propagateFloat64NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
return|return
name|a
return|;
block|}
name|add64
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
name|bSig0
argument_list|,
name|bSig1
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|)
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
return|return
name|packFloat64
argument_list|(
name|zSign
argument_list|,
literal|0
argument_list|,
name|zSig0
argument_list|,
name|zSig1
argument_list|)
return|;
name|zSig2
operator|=
literal|0
expr_stmt|;
name|zSig0
operator||=
literal|0x00200000
expr_stmt|;
name|zExp
operator|=
name|aExp
expr_stmt|;
goto|goto
name|shiftRight1
goto|;
block|}
name|aSig0
operator||=
literal|0x00100000
expr_stmt|;
name|add64
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
name|bSig0
argument_list|,
name|bSig1
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|)
expr_stmt|;
operator|--
name|zExp
expr_stmt|;
if|if
condition|(
name|zSig0
operator|<
literal|0x00200000
condition|)
goto|goto
name|roundAndPack
goto|;
operator|++
name|zExp
expr_stmt|;
name|shiftRight1
label|:
name|shift64ExtraRightJamming
argument_list|(
name|zSig0
argument_list|,
name|zSig1
argument_list|,
name|zSig2
argument_list|,
literal|1
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|,
operator|&
name|zSig2
argument_list|)
expr_stmt|;
name|roundAndPack
label|:
return|return
name|roundAndPackFloat64
argument_list|(
name|zSign
argument_list|,
name|zExp
argument_list|,
name|zSig0
argument_list|,
name|zSig1
argument_list|,
name|zSig2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of subtracting the absolute values of the double- precision floating-point values `a' and `b'.  If `zSign' is 1, the difference is negated before being returned.  `zSign' is ignored if the result is a NaN.  The subtraction is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|float64
name|subFloat64Sigs
parameter_list|(
name|float64
name|a
parameter_list|,
name|float64
name|b
parameter_list|,
name|flag
name|zSign
parameter_list|)
block|{
name|int16
name|aExp
decl_stmt|,
name|bExp
decl_stmt|,
name|zExp
decl_stmt|;
name|bits32
name|aSig0
decl_stmt|,
name|aSig1
decl_stmt|,
name|bSig0
decl_stmt|,
name|bSig1
decl_stmt|,
name|zSig0
decl_stmt|,
name|zSig1
decl_stmt|;
name|int16
name|expDiff
decl_stmt|;
name|aSig1
operator|=
name|extractFloat64Frac1
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSig0
operator|=
name|extractFloat64Frac0
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat64Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSig1
operator|=
name|extractFloat64Frac1
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bSig0
operator|=
name|extractFloat64Frac0
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bExp
operator|=
name|extractFloat64Exp
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|expDiff
operator|=
name|aExp
operator|-
name|bExp
expr_stmt|;
name|shortShift64Left
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
literal|10
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
name|shortShift64Left
argument_list|(
name|bSig0
argument_list|,
name|bSig1
argument_list|,
literal|10
argument_list|,
operator|&
name|bSig0
argument_list|,
operator|&
name|bSig1
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|expDiff
condition|)
goto|goto
name|aExpBigger
goto|;
if|if
condition|(
name|expDiff
operator|<
literal|0
condition|)
goto|goto
name|bExpBigger
goto|;
if|if
condition|(
name|aExp
operator|==
literal|0x7FF
condition|)
block|{
if|if
condition|(
name|aSig0
operator||
name|aSig1
operator||
name|bSig0
operator||
name|bSig1
condition|)
block|{
return|return
name|propagateFloat64NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|float64_default_nan
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
name|aExp
operator|=
literal|1
expr_stmt|;
name|bExp
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bSig0
operator|<
name|aSig0
condition|)
goto|goto
name|aBigger
goto|;
if|if
condition|(
name|aSig0
operator|<
name|bSig0
condition|)
goto|goto
name|bBigger
goto|;
if|if
condition|(
name|bSig1
operator|<
name|aSig1
condition|)
goto|goto
name|aBigger
goto|;
if|if
condition|(
name|aSig1
operator|<
name|bSig1
condition|)
goto|goto
name|bBigger
goto|;
return|return
name|packFloat64
argument_list|(
name|float_rounding_mode
operator|==
name|float_round_down
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|bExpBigger
label|:
if|if
condition|(
name|bExp
operator|==
literal|0x7FF
condition|)
block|{
if|if
condition|(
name|bSig0
operator||
name|bSig1
condition|)
return|return
name|propagateFloat64NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|packFloat64
argument_list|(
name|zSign
operator|^
literal|1
argument_list|,
literal|0x7FF
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
operator|++
name|expDiff
expr_stmt|;
block|}
else|else
block|{
name|aSig0
operator||=
literal|0x40000000
expr_stmt|;
block|}
name|shift64RightJamming
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
operator|-
name|expDiff
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
name|bSig0
operator||=
literal|0x40000000
expr_stmt|;
name|bBigger
label|:
name|sub64
argument_list|(
name|bSig0
argument_list|,
name|bSig1
argument_list|,
name|aSig0
argument_list|,
name|aSig1
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|)
expr_stmt|;
name|zExp
operator|=
name|bExp
expr_stmt|;
name|zSign
operator|^=
literal|1
expr_stmt|;
goto|goto
name|normalizeRoundAndPack
goto|;
name|aExpBigger
label|:
if|if
condition|(
name|aExp
operator|==
literal|0x7FF
condition|)
block|{
if|if
condition|(
name|aSig0
operator||
name|aSig1
condition|)
return|return
name|propagateFloat64NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|a
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0
condition|)
block|{
operator|--
name|expDiff
expr_stmt|;
block|}
else|else
block|{
name|bSig0
operator||=
literal|0x40000000
expr_stmt|;
block|}
name|shift64RightJamming
argument_list|(
name|bSig0
argument_list|,
name|bSig1
argument_list|,
name|expDiff
argument_list|,
operator|&
name|bSig0
argument_list|,
operator|&
name|bSig1
argument_list|)
expr_stmt|;
name|aSig0
operator||=
literal|0x40000000
expr_stmt|;
name|aBigger
label|:
name|sub64
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
name|bSig0
argument_list|,
name|bSig1
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|)
expr_stmt|;
name|zExp
operator|=
name|aExp
expr_stmt|;
name|normalizeRoundAndPack
label|:
operator|--
name|zExp
expr_stmt|;
return|return
name|normalizeRoundAndPackFloat64
argument_list|(
name|zSign
argument_list|,
name|zExp
operator|-
literal|10
argument_list|,
name|zSig0
argument_list|,
name|zSig1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of adding the double-precision floating-point values `a' and `b'.  The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float64
name|float64_add
parameter_list|(
name|float64
name|a
parameter_list|,
name|float64
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|;
name|aSign
operator|=
name|extractFloat64Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat64Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aSign
operator|==
name|bSign
condition|)
block|{
return|return
name|addFloat64Sigs
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|aSign
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|subFloat64Sigs
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|aSign
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of subtracting the double-precision floating-point values `a' and `b'.  The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float64
name|float64_sub
parameter_list|(
name|float64
name|a
parameter_list|,
name|float64
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|;
name|aSign
operator|=
name|extractFloat64Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat64Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aSign
operator|==
name|bSign
condition|)
block|{
return|return
name|subFloat64Sigs
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|aSign
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|addFloat64Sigs
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|aSign
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of multiplying the double-precision floating-point values `a' and `b'.  The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float64
name|float64_mul
parameter_list|(
name|float64
name|a
parameter_list|,
name|float64
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|,
name|zSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|,
name|bExp
decl_stmt|,
name|zExp
decl_stmt|;
name|bits32
name|aSig0
decl_stmt|,
name|aSig1
decl_stmt|,
name|bSig0
decl_stmt|,
name|bSig1
decl_stmt|,
name|zSig0
decl_stmt|,
name|zSig1
decl_stmt|,
name|zSig2
decl_stmt|,
name|zSig3
decl_stmt|;
name|aSig1
operator|=
name|extractFloat64Frac1
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSig0
operator|=
name|extractFloat64Frac0
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat64Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat64Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSig1
operator|=
name|extractFloat64Frac1
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bSig0
operator|=
name|extractFloat64Frac0
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bExp
operator|=
name|extractFloat64Exp
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat64Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|zSign
operator|=
name|aSign
operator|^
name|bSign
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0x7FF
condition|)
block|{
if|if
condition|(
operator|(
name|aSig0
operator||
name|aSig1
operator|)
operator|||
operator|(
operator|(
name|bExp
operator|==
literal|0x7FF
operator|)
operator|&&
operator|(
name|bSig0
operator||
name|bSig1
operator|)
operator|)
condition|)
block|{
return|return
name|propagateFloat64NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|bExp
operator||
name|bSig0
operator||
name|bSig1
operator|)
operator|==
literal|0
condition|)
goto|goto
name|invalid
goto|;
return|return
name|packFloat64
argument_list|(
name|zSign
argument_list|,
literal|0x7FF
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0x7FF
condition|)
block|{
if|if
condition|(
name|bSig0
operator||
name|bSig1
condition|)
return|return
name|propagateFloat64NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
if|if
condition|(
operator|(
name|aExp
operator||
name|aSig0
operator||
name|aSig1
operator|)
operator|==
literal|0
condition|)
block|{
name|invalid
label|:
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|float64_default_nan
return|;
block|}
return|return
name|packFloat64
argument_list|(
name|zSign
argument_list|,
literal|0x7FF
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|aSig0
operator||
name|aSig1
operator|)
operator|==
literal|0
condition|)
return|return
name|packFloat64
argument_list|(
name|zSign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|normalizeFloat64Subnormal
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
operator|&
name|aExp
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|bSig0
operator||
name|bSig1
operator|)
operator|==
literal|0
condition|)
return|return
name|packFloat64
argument_list|(
name|zSign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|normalizeFloat64Subnormal
argument_list|(
name|bSig0
argument_list|,
name|bSig1
argument_list|,
operator|&
name|bExp
argument_list|,
operator|&
name|bSig0
argument_list|,
operator|&
name|bSig1
argument_list|)
expr_stmt|;
block|}
name|zExp
operator|=
name|aExp
operator|+
name|bExp
operator|-
literal|0x400
expr_stmt|;
name|aSig0
operator||=
literal|0x00100000
expr_stmt|;
name|shortShift64Left
argument_list|(
name|bSig0
argument_list|,
name|bSig1
argument_list|,
literal|12
argument_list|,
operator|&
name|bSig0
argument_list|,
operator|&
name|bSig1
argument_list|)
expr_stmt|;
name|mul64To128
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
name|bSig0
argument_list|,
name|bSig1
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|,
operator|&
name|zSig2
argument_list|,
operator|&
name|zSig3
argument_list|)
expr_stmt|;
name|add64
argument_list|(
name|zSig0
argument_list|,
name|zSig1
argument_list|,
name|aSig0
argument_list|,
name|aSig1
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|)
expr_stmt|;
name|zSig2
operator||=
operator|(
name|zSig3
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
literal|0x00200000
operator|<=
name|zSig0
condition|)
block|{
name|shift64ExtraRightJamming
argument_list|(
name|zSig0
argument_list|,
name|zSig1
argument_list|,
name|zSig2
argument_list|,
literal|1
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|,
operator|&
name|zSig2
argument_list|)
expr_stmt|;
operator|++
name|zExp
expr_stmt|;
block|}
return|return
name|roundAndPackFloat64
argument_list|(
name|zSign
argument_list|,
name|zExp
argument_list|,
name|zSig0
argument_list|,
name|zSig1
argument_list|,
name|zSig2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of dividing the double-precision floating-point value `a' by the corresponding value `b'.  The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float64
name|float64_div
parameter_list|(
name|float64
name|a
parameter_list|,
name|float64
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|,
name|zSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|,
name|bExp
decl_stmt|,
name|zExp
decl_stmt|;
name|bits32
name|aSig0
decl_stmt|,
name|aSig1
decl_stmt|,
name|bSig0
decl_stmt|,
name|bSig1
decl_stmt|,
name|zSig0
decl_stmt|,
name|zSig1
decl_stmt|,
name|zSig2
decl_stmt|;
name|bits32
name|rem0
decl_stmt|,
name|rem1
decl_stmt|,
name|rem2
decl_stmt|,
name|rem3
decl_stmt|,
name|term0
decl_stmt|,
name|term1
decl_stmt|,
name|term2
decl_stmt|,
name|term3
decl_stmt|;
name|aSig1
operator|=
name|extractFloat64Frac1
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSig0
operator|=
name|extractFloat64Frac0
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat64Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat64Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSig1
operator|=
name|extractFloat64Frac1
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bSig0
operator|=
name|extractFloat64Frac0
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bExp
operator|=
name|extractFloat64Exp
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat64Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|zSign
operator|=
name|aSign
operator|^
name|bSign
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0x7FF
condition|)
block|{
if|if
condition|(
name|aSig0
operator||
name|aSig1
condition|)
return|return
name|propagateFloat64NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
if|if
condition|(
name|bExp
operator|==
literal|0x7FF
condition|)
block|{
if|if
condition|(
name|bSig0
operator||
name|bSig1
condition|)
return|return
name|propagateFloat64NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
goto|goto
name|invalid
goto|;
block|}
return|return
name|packFloat64
argument_list|(
name|zSign
argument_list|,
literal|0x7FF
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0x7FF
condition|)
block|{
if|if
condition|(
name|bSig0
operator||
name|bSig1
condition|)
return|return
name|propagateFloat64NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|packFloat64
argument_list|(
name|zSign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|bSig0
operator||
name|bSig1
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|aExp
operator||
name|aSig0
operator||
name|aSig1
operator|)
operator|==
literal|0
condition|)
block|{
name|invalid
label|:
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|float64_default_nan
return|;
block|}
name|float_raise
argument_list|(
name|float_flag_divbyzero
argument_list|)
expr_stmt|;
return|return
name|packFloat64
argument_list|(
name|zSign
argument_list|,
literal|0x7FF
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|normalizeFloat64Subnormal
argument_list|(
name|bSig0
argument_list|,
name|bSig1
argument_list|,
operator|&
name|bExp
argument_list|,
operator|&
name|bSig0
argument_list|,
operator|&
name|bSig1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|aSig0
operator||
name|aSig1
operator|)
operator|==
literal|0
condition|)
return|return
name|packFloat64
argument_list|(
name|zSign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|normalizeFloat64Subnormal
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
operator|&
name|aExp
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
block|}
name|zExp
operator|=
name|aExp
operator|-
name|bExp
operator|+
literal|0x3FD
expr_stmt|;
name|shortShift64Left
argument_list|(
name|aSig0
operator||
literal|0x00100000
argument_list|,
name|aSig1
argument_list|,
literal|11
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
name|shortShift64Left
argument_list|(
name|bSig0
operator||
literal|0x00100000
argument_list|,
name|bSig1
argument_list|,
literal|11
argument_list|,
operator|&
name|bSig0
argument_list|,
operator|&
name|bSig1
argument_list|)
expr_stmt|;
if|if
condition|(
name|le64
argument_list|(
name|bSig0
argument_list|,
name|bSig1
argument_list|,
name|aSig0
argument_list|,
name|aSig1
argument_list|)
condition|)
block|{
name|shift64Right
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
literal|1
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
operator|++
name|zExp
expr_stmt|;
block|}
name|zSig0
operator|=
name|estimateDiv64To32
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
name|bSig0
argument_list|)
expr_stmt|;
name|mul64By32To96
argument_list|(
name|bSig0
argument_list|,
name|bSig1
argument_list|,
name|zSig0
argument_list|,
operator|&
name|term0
argument_list|,
operator|&
name|term1
argument_list|,
operator|&
name|term2
argument_list|)
expr_stmt|;
name|sub96
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
literal|0
argument_list|,
name|term0
argument_list|,
name|term1
argument_list|,
name|term2
argument_list|,
operator|&
name|rem0
argument_list|,
operator|&
name|rem1
argument_list|,
operator|&
name|rem2
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|sbits32
operator|)
name|rem0
operator|<
literal|0
condition|)
block|{
operator|--
name|zSig0
expr_stmt|;
name|add96
argument_list|(
name|rem0
argument_list|,
name|rem1
argument_list|,
name|rem2
argument_list|,
literal|0
argument_list|,
name|bSig0
argument_list|,
name|bSig1
argument_list|,
operator|&
name|rem0
argument_list|,
operator|&
name|rem1
argument_list|,
operator|&
name|rem2
argument_list|)
expr_stmt|;
block|}
name|zSig1
operator|=
name|estimateDiv64To32
argument_list|(
name|rem1
argument_list|,
name|rem2
argument_list|,
name|bSig0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zSig1
operator|&
literal|0x3FF
operator|)
operator|<=
literal|4
condition|)
block|{
name|mul64By32To96
argument_list|(
name|bSig0
argument_list|,
name|bSig1
argument_list|,
name|zSig1
argument_list|,
operator|&
name|term1
argument_list|,
operator|&
name|term2
argument_list|,
operator|&
name|term3
argument_list|)
expr_stmt|;
name|sub96
argument_list|(
name|rem1
argument_list|,
name|rem2
argument_list|,
literal|0
argument_list|,
name|term1
argument_list|,
name|term2
argument_list|,
name|term3
argument_list|,
operator|&
name|rem1
argument_list|,
operator|&
name|rem2
argument_list|,
operator|&
name|rem3
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|sbits32
operator|)
name|rem1
operator|<
literal|0
condition|)
block|{
operator|--
name|zSig1
expr_stmt|;
name|add96
argument_list|(
name|rem1
argument_list|,
name|rem2
argument_list|,
name|rem3
argument_list|,
literal|0
argument_list|,
name|bSig0
argument_list|,
name|bSig1
argument_list|,
operator|&
name|rem1
argument_list|,
operator|&
name|rem2
argument_list|,
operator|&
name|rem3
argument_list|)
expr_stmt|;
block|}
name|zSig1
operator||=
operator|(
operator|(
name|rem1
operator||
name|rem2
operator||
name|rem3
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
name|shift64ExtraRightJamming
argument_list|(
name|zSig0
argument_list|,
name|zSig1
argument_list|,
literal|0
argument_list|,
literal|11
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|,
operator|&
name|zSig2
argument_list|)
expr_stmt|;
return|return
name|roundAndPackFloat64
argument_list|(
name|zSign
argument_list|,
name|zExp
argument_list|,
name|zSig0
argument_list|,
name|zSig1
argument_list|,
name|zSig2
argument_list|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SOFTFLOAT_FOR_GCC
end_ifndef

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the remainder of the double-precision floating-point value `a' with respect to the corresponding value `b'.  The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float64
name|float64_rem
parameter_list|(
name|float64
name|a
parameter_list|,
name|float64
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|,
name|zSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|,
name|bExp
decl_stmt|,
name|expDiff
decl_stmt|;
name|bits32
name|aSig0
decl_stmt|,
name|aSig1
decl_stmt|,
name|bSig0
decl_stmt|,
name|bSig1
decl_stmt|,
name|q
decl_stmt|,
name|term0
decl_stmt|,
name|term1
decl_stmt|,
name|term2
decl_stmt|;
name|bits32
name|allZero
decl_stmt|,
name|alternateASig0
decl_stmt|,
name|alternateASig1
decl_stmt|,
name|sigMean1
decl_stmt|;
name|sbits32
name|sigMean0
decl_stmt|;
name|float64
name|z
decl_stmt|;
name|aSig1
operator|=
name|extractFloat64Frac1
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSig0
operator|=
name|extractFloat64Frac0
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat64Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat64Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSig1
operator|=
name|extractFloat64Frac1
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bSig0
operator|=
name|extractFloat64Frac0
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bExp
operator|=
name|extractFloat64Exp
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat64Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0x7FF
condition|)
block|{
if|if
condition|(
operator|(
name|aSig0
operator||
name|aSig1
operator|)
operator|||
operator|(
operator|(
name|bExp
operator|==
literal|0x7FF
operator|)
operator|&&
operator|(
name|bSig0
operator||
name|bSig1
operator|)
operator|)
condition|)
block|{
return|return
name|propagateFloat64NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
goto|goto
name|invalid
goto|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0x7FF
condition|)
block|{
if|if
condition|(
name|bSig0
operator||
name|bSig1
condition|)
return|return
name|propagateFloat64NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|a
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|bSig0
operator||
name|bSig1
operator|)
operator|==
literal|0
condition|)
block|{
name|invalid
label|:
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|float64_default_nan
return|;
block|}
name|normalizeFloat64Subnormal
argument_list|(
name|bSig0
argument_list|,
name|bSig1
argument_list|,
operator|&
name|bExp
argument_list|,
operator|&
name|bSig0
argument_list|,
operator|&
name|bSig1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|aSig0
operator||
name|aSig1
operator|)
operator|==
literal|0
condition|)
return|return
name|a
return|;
name|normalizeFloat64Subnormal
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
operator|&
name|aExp
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
block|}
name|expDiff
operator|=
name|aExp
operator|-
name|bExp
expr_stmt|;
if|if
condition|(
name|expDiff
operator|<
operator|-
literal|1
condition|)
return|return
name|a
return|;
name|shortShift64Left
argument_list|(
name|aSig0
operator||
literal|0x00100000
argument_list|,
name|aSig1
argument_list|,
literal|11
operator|-
operator|(
name|expDiff
operator|<
literal|0
operator|)
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
name|shortShift64Left
argument_list|(
name|bSig0
operator||
literal|0x00100000
argument_list|,
name|bSig1
argument_list|,
literal|11
argument_list|,
operator|&
name|bSig0
argument_list|,
operator|&
name|bSig1
argument_list|)
expr_stmt|;
name|q
operator|=
name|le64
argument_list|(
name|bSig0
argument_list|,
name|bSig1
argument_list|,
name|aSig0
argument_list|,
name|aSig1
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
name|sub64
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
name|bSig0
argument_list|,
name|bSig1
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
name|expDiff
operator|-=
literal|32
expr_stmt|;
while|while
condition|(
literal|0
operator|<
name|expDiff
condition|)
block|{
name|q
operator|=
name|estimateDiv64To32
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
name|bSig0
argument_list|)
expr_stmt|;
name|q
operator|=
operator|(
literal|4
operator|<
name|q
operator|)
condition|?
name|q
operator|-
literal|4
else|:
literal|0
expr_stmt|;
name|mul64By32To96
argument_list|(
name|bSig0
argument_list|,
name|bSig1
argument_list|,
name|q
argument_list|,
operator|&
name|term0
argument_list|,
operator|&
name|term1
argument_list|,
operator|&
name|term2
argument_list|)
expr_stmt|;
name|shortShift96Left
argument_list|(
name|term0
argument_list|,
name|term1
argument_list|,
name|term2
argument_list|,
literal|29
argument_list|,
operator|&
name|term1
argument_list|,
operator|&
name|term2
argument_list|,
operator|&
name|allZero
argument_list|)
expr_stmt|;
name|shortShift64Left
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
literal|29
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|allZero
argument_list|)
expr_stmt|;
name|sub64
argument_list|(
name|aSig0
argument_list|,
literal|0
argument_list|,
name|term1
argument_list|,
name|term2
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
name|expDiff
operator|-=
literal|29
expr_stmt|;
block|}
if|if
condition|(
operator|-
literal|32
operator|<
name|expDiff
condition|)
block|{
name|q
operator|=
name|estimateDiv64To32
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
name|bSig0
argument_list|)
expr_stmt|;
name|q
operator|=
operator|(
literal|4
operator|<
name|q
operator|)
condition|?
name|q
operator|-
literal|4
else|:
literal|0
expr_stmt|;
name|q
operator|>>=
operator|-
name|expDiff
expr_stmt|;
name|shift64Right
argument_list|(
name|bSig0
argument_list|,
name|bSig1
argument_list|,
literal|8
argument_list|,
operator|&
name|bSig0
argument_list|,
operator|&
name|bSig1
argument_list|)
expr_stmt|;
name|expDiff
operator|+=
literal|24
expr_stmt|;
if|if
condition|(
name|expDiff
operator|<
literal|0
condition|)
block|{
name|shift64Right
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
operator|-
name|expDiff
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|shortShift64Left
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
name|expDiff
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
block|}
name|mul64By32To96
argument_list|(
name|bSig0
argument_list|,
name|bSig1
argument_list|,
name|q
argument_list|,
operator|&
name|term0
argument_list|,
operator|&
name|term1
argument_list|,
operator|&
name|term2
argument_list|)
expr_stmt|;
name|sub64
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
name|term1
argument_list|,
name|term2
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|shift64Right
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
literal|8
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
name|shift64Right
argument_list|(
name|bSig0
argument_list|,
name|bSig1
argument_list|,
literal|8
argument_list|,
operator|&
name|bSig0
argument_list|,
operator|&
name|bSig1
argument_list|)
expr_stmt|;
block|}
do|do
block|{
name|alternateASig0
operator|=
name|aSig0
expr_stmt|;
name|alternateASig1
operator|=
name|aSig1
expr_stmt|;
operator|++
name|q
expr_stmt|;
name|sub64
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
name|bSig0
argument_list|,
name|bSig1
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|0
operator|<=
operator|(
name|sbits32
operator|)
name|aSig0
condition|)
do|;
name|add64
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
name|alternateASig0
argument_list|,
name|alternateASig1
argument_list|,
operator|&
name|sigMean0
argument_list|,
operator|&
name|sigMean1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sigMean0
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
operator|(
name|sigMean0
operator||
name|sigMean1
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|q
operator|&
literal|1
operator|)
operator|)
condition|)
block|{
name|aSig0
operator|=
name|alternateASig0
expr_stmt|;
name|aSig1
operator|=
name|alternateASig1
expr_stmt|;
block|}
name|zSign
operator|=
operator|(
operator|(
name|sbits32
operator|)
name|aSig0
operator|<
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|zSign
condition|)
name|sub64
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|aSig0
argument_list|,
name|aSig1
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
return|return
name|normalizeRoundAndPackFloat64
argument_list|(
name|aSign
operator|^
name|zSign
argument_list|,
name|bExp
operator|-
literal|4
argument_list|,
name|aSig0
argument_list|,
name|aSig1
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SOFTFLOAT_FOR_GCC
end_ifndef

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the square root of the double-precision floating-point value `a'. The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float64
name|float64_sqrt
parameter_list|(
name|float64
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|,
name|zExp
decl_stmt|;
name|bits32
name|aSig0
decl_stmt|,
name|aSig1
decl_stmt|,
name|zSig0
decl_stmt|,
name|zSig1
decl_stmt|,
name|zSig2
decl_stmt|,
name|doubleZSig0
decl_stmt|;
name|bits32
name|rem0
decl_stmt|,
name|rem1
decl_stmt|,
name|rem2
decl_stmt|,
name|rem3
decl_stmt|,
name|term0
decl_stmt|,
name|term1
decl_stmt|,
name|term2
decl_stmt|,
name|term3
decl_stmt|;
name|float64
name|z
decl_stmt|;
name|aSig1
operator|=
name|extractFloat64Frac1
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSig0
operator|=
name|extractFloat64Frac0
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat64Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat64Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0x7FF
condition|)
block|{
if|if
condition|(
name|aSig0
operator||
name|aSig1
condition|)
return|return
name|propagateFloat64NaN
argument_list|(
name|a
argument_list|,
name|a
argument_list|)
return|;
if|if
condition|(
operator|!
name|aSign
condition|)
return|return
name|a
return|;
goto|goto
name|invalid
goto|;
block|}
if|if
condition|(
name|aSign
condition|)
block|{
if|if
condition|(
operator|(
name|aExp
operator||
name|aSig0
operator||
name|aSig1
operator|)
operator|==
literal|0
condition|)
return|return
name|a
return|;
name|invalid
label|:
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|float64_default_nan
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|aSig0
operator||
name|aSig1
operator|)
operator|==
literal|0
condition|)
return|return
name|packFloat64
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|normalizeFloat64Subnormal
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
operator|&
name|aExp
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
block|}
name|zExp
operator|=
operator|(
operator|(
name|aExp
operator|-
literal|0x3FF
operator|)
operator|>>
literal|1
operator|)
operator|+
literal|0x3FE
expr_stmt|;
name|aSig0
operator||=
literal|0x00100000
expr_stmt|;
name|shortShift64Left
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
literal|11
argument_list|,
operator|&
name|term0
argument_list|,
operator|&
name|term1
argument_list|)
expr_stmt|;
name|zSig0
operator|=
operator|(
name|estimateSqrt32
argument_list|(
name|aExp
argument_list|,
name|term0
argument_list|)
operator|>>
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|zSig0
operator|==
literal|0
condition|)
name|zSig0
operator|=
literal|0x7FFFFFFF
expr_stmt|;
name|doubleZSig0
operator|=
name|zSig0
operator|+
name|zSig0
expr_stmt|;
name|shortShift64Left
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
literal|9
operator|-
operator|(
name|aExp
operator|&
literal|1
operator|)
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
name|mul32To64
argument_list|(
name|zSig0
argument_list|,
name|zSig0
argument_list|,
operator|&
name|term0
argument_list|,
operator|&
name|term1
argument_list|)
expr_stmt|;
name|sub64
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
name|term0
argument_list|,
name|term1
argument_list|,
operator|&
name|rem0
argument_list|,
operator|&
name|rem1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|sbits32
operator|)
name|rem0
operator|<
literal|0
condition|)
block|{
operator|--
name|zSig0
expr_stmt|;
name|doubleZSig0
operator|-=
literal|2
expr_stmt|;
name|add64
argument_list|(
name|rem0
argument_list|,
name|rem1
argument_list|,
literal|0
argument_list|,
name|doubleZSig0
operator||
literal|1
argument_list|,
operator|&
name|rem0
argument_list|,
operator|&
name|rem1
argument_list|)
expr_stmt|;
block|}
name|zSig1
operator|=
name|estimateDiv64To32
argument_list|(
name|rem1
argument_list|,
literal|0
argument_list|,
name|doubleZSig0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zSig1
operator|&
literal|0x1FF
operator|)
operator|<=
literal|5
condition|)
block|{
if|if
condition|(
name|zSig1
operator|==
literal|0
condition|)
name|zSig1
operator|=
literal|1
expr_stmt|;
name|mul32To64
argument_list|(
name|doubleZSig0
argument_list|,
name|zSig1
argument_list|,
operator|&
name|term1
argument_list|,
operator|&
name|term2
argument_list|)
expr_stmt|;
name|sub64
argument_list|(
name|rem1
argument_list|,
literal|0
argument_list|,
name|term1
argument_list|,
name|term2
argument_list|,
operator|&
name|rem1
argument_list|,
operator|&
name|rem2
argument_list|)
expr_stmt|;
name|mul32To64
argument_list|(
name|zSig1
argument_list|,
name|zSig1
argument_list|,
operator|&
name|term2
argument_list|,
operator|&
name|term3
argument_list|)
expr_stmt|;
name|sub96
argument_list|(
name|rem1
argument_list|,
name|rem2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|term2
argument_list|,
name|term3
argument_list|,
operator|&
name|rem1
argument_list|,
operator|&
name|rem2
argument_list|,
operator|&
name|rem3
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|sbits32
operator|)
name|rem1
operator|<
literal|0
condition|)
block|{
operator|--
name|zSig1
expr_stmt|;
name|shortShift64Left
argument_list|(
literal|0
argument_list|,
name|zSig1
argument_list|,
literal|1
argument_list|,
operator|&
name|term2
argument_list|,
operator|&
name|term3
argument_list|)
expr_stmt|;
name|term3
operator||=
literal|1
expr_stmt|;
name|term2
operator||=
name|doubleZSig0
expr_stmt|;
name|add96
argument_list|(
name|rem1
argument_list|,
name|rem2
argument_list|,
name|rem3
argument_list|,
literal|0
argument_list|,
name|term2
argument_list|,
name|term3
argument_list|,
operator|&
name|rem1
argument_list|,
operator|&
name|rem2
argument_list|,
operator|&
name|rem3
argument_list|)
expr_stmt|;
block|}
name|zSig1
operator||=
operator|(
operator|(
name|rem1
operator||
name|rem2
operator||
name|rem3
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
name|shift64ExtraRightJamming
argument_list|(
name|zSig0
argument_list|,
name|zSig1
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|,
operator|&
name|zSig2
argument_list|)
expr_stmt|;
return|return
name|roundAndPackFloat64
argument_list|(
literal|0
argument_list|,
name|zExp
argument_list|,
name|zSig0
argument_list|,
name|zSig1
argument_list|,
name|zSig2
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns 1 if the double-precision floating-point value `a' is equal to the corresponding value `b', and 0 otherwise.  The comparison is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|flag
name|float64_eq
parameter_list|(
name|float64
name|a
parameter_list|,
name|float64
name|b
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|extractFloat64Exp
argument_list|(
name|a
argument_list|)
operator|==
literal|0x7FF
operator|)
operator|&&
operator|(
name|extractFloat64Frac0
argument_list|(
name|a
argument_list|)
operator||
name|extractFloat64Frac1
argument_list|(
name|a
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|extractFloat64Exp
argument_list|(
name|b
argument_list|)
operator|==
literal|0x7FF
operator|)
operator|&&
operator|(
name|extractFloat64Frac0
argument_list|(
name|b
argument_list|)
operator||
name|extractFloat64Frac1
argument_list|(
name|b
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|float64_is_signaling_nan
argument_list|(
name|a
argument_list|)
operator|||
name|float64_is_signaling_nan
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
return|return
operator|(
name|a
operator|==
name|b
operator|)
operator|||
operator|(
call|(
name|bits64
call|)
argument_list|(
operator|(
name|FLOAT64_DEMANGLE
argument_list|(
name|a
argument_list|)
operator||
name|FLOAT64_DEMANGLE
argument_list|(
name|b
argument_list|)
operator|)
operator|<<
literal|1
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns 1 if the double-precision floating-point value `a' is less than or equal to the corresponding value `b', and 0 otherwise.  The comparison is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|flag
name|float64_le
parameter_list|(
name|float64
name|a
parameter_list|,
name|float64
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|extractFloat64Exp
argument_list|(
name|a
argument_list|)
operator|==
literal|0x7FF
operator|)
operator|&&
operator|(
name|extractFloat64Frac0
argument_list|(
name|a
argument_list|)
operator||
name|extractFloat64Frac1
argument_list|(
name|a
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|extractFloat64Exp
argument_list|(
name|b
argument_list|)
operator|==
literal|0x7FF
operator|)
operator|&&
operator|(
name|extractFloat64Frac0
argument_list|(
name|b
argument_list|)
operator||
name|extractFloat64Frac1
argument_list|(
name|b
argument_list|)
operator|)
operator|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|aSign
operator|=
name|extractFloat64Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat64Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aSign
operator|!=
name|bSign
condition|)
return|return
name|aSign
operator|||
operator|(
call|(
name|bits64
call|)
argument_list|(
operator|(
name|FLOAT64_DEMANGLE
argument_list|(
name|a
argument_list|)
operator||
name|FLOAT64_DEMANGLE
argument_list|(
name|b
argument_list|)
operator|)
operator|<<
literal|1
argument_list|)
operator|==
literal|0
operator|)
return|;
return|return
operator|(
name|a
operator|==
name|b
operator|)
operator|||
operator|(
name|aSign
operator|^
operator|(
name|FLOAT64_DEMANGLE
argument_list|(
name|a
argument_list|)
operator|<
name|FLOAT64_DEMANGLE
argument_list|(
name|b
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns 1 if the double-precision floating-point value `a' is less than the corresponding value `b', and 0 otherwise.  The comparison is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|flag
name|float64_lt
parameter_list|(
name|float64
name|a
parameter_list|,
name|float64
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|extractFloat64Exp
argument_list|(
name|a
argument_list|)
operator|==
literal|0x7FF
operator|)
operator|&&
operator|(
name|extractFloat64Frac0
argument_list|(
name|a
argument_list|)
operator||
name|extractFloat64Frac1
argument_list|(
name|a
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|extractFloat64Exp
argument_list|(
name|b
argument_list|)
operator|==
literal|0x7FF
operator|)
operator|&&
operator|(
name|extractFloat64Frac0
argument_list|(
name|b
argument_list|)
operator||
name|extractFloat64Frac1
argument_list|(
name|b
argument_list|)
operator|)
operator|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|aSign
operator|=
name|extractFloat64Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat64Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aSign
operator|!=
name|bSign
condition|)
return|return
name|aSign
operator|&&
operator|(
call|(
name|bits64
call|)
argument_list|(
operator|(
name|FLOAT64_DEMANGLE
argument_list|(
name|a
argument_list|)
operator||
name|FLOAT64_DEMANGLE
argument_list|(
name|b
argument_list|)
operator|)
operator|<<
literal|1
argument_list|)
operator|!=
literal|0
operator|)
return|;
return|return
operator|(
name|a
operator|!=
name|b
operator|)
operator|&&
operator|(
name|aSign
operator|^
operator|(
name|FLOAT64_DEMANGLE
argument_list|(
name|a
argument_list|)
operator|<
name|FLOAT64_DEMANGLE
argument_list|(
name|b
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SOFTFLOAT_FOR_GCC
end_ifndef

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns 1 if the double-precision floating-point value `a' is equal to the corresponding value `b', and 0 otherwise.  The invalid exception is raised if either operand is a NaN.  Otherwise, the comparison is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|flag
name|float64_eq_signaling
parameter_list|(
name|float64
name|a
parameter_list|,
name|float64
name|b
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|extractFloat64Exp
argument_list|(
name|a
argument_list|)
operator|==
literal|0x7FF
operator|)
operator|&&
operator|(
name|extractFloat64Frac0
argument_list|(
name|a
argument_list|)
operator||
name|extractFloat64Frac1
argument_list|(
name|a
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|extractFloat64Exp
argument_list|(
name|b
argument_list|)
operator|==
literal|0x7FF
operator|)
operator|&&
operator|(
name|extractFloat64Frac0
argument_list|(
name|b
argument_list|)
operator||
name|extractFloat64Frac1
argument_list|(
name|b
argument_list|)
operator|)
operator|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|(
name|a
operator|==
name|b
operator|)
operator|||
operator|(
call|(
name|bits64
call|)
argument_list|(
operator|(
name|a
operator||
name|b
operator|)
operator|<<
literal|1
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns 1 if the double-precision floating-point value `a' is less than or equal to the corresponding value `b', and 0 otherwise.  Quiet NaNs do not cause an exception.  Otherwise, the comparison is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|flag
name|float64_le_quiet
parameter_list|(
name|float64
name|a
parameter_list|,
name|float64
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|extractFloat64Exp
argument_list|(
name|a
argument_list|)
operator|==
literal|0x7FF
operator|)
operator|&&
operator|(
name|extractFloat64Frac0
argument_list|(
name|a
argument_list|)
operator||
name|extractFloat64Frac1
argument_list|(
name|a
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|extractFloat64Exp
argument_list|(
name|b
argument_list|)
operator|==
literal|0x7FF
operator|)
operator|&&
operator|(
name|extractFloat64Frac0
argument_list|(
name|b
argument_list|)
operator||
name|extractFloat64Frac1
argument_list|(
name|b
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|float64_is_signaling_nan
argument_list|(
name|a
argument_list|)
operator|||
name|float64_is_signaling_nan
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|aSign
operator|=
name|extractFloat64Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat64Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aSign
operator|!=
name|bSign
condition|)
return|return
name|aSign
operator|||
operator|(
call|(
name|bits64
call|)
argument_list|(
operator|(
name|a
operator||
name|b
operator|)
operator|<<
literal|1
argument_list|)
operator|==
literal|0
operator|)
return|;
return|return
operator|(
name|a
operator|==
name|b
operator|)
operator|||
operator|(
name|aSign
operator|^
operator|(
name|a
operator|<
name|b
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns 1 if the double-precision floating-point value `a' is less than the corresponding value `b', and 0 otherwise.  Quiet NaNs do not cause an exception.  Otherwise, the comparison is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|flag
name|float64_lt_quiet
parameter_list|(
name|float64
name|a
parameter_list|,
name|float64
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|extractFloat64Exp
argument_list|(
name|a
argument_list|)
operator|==
literal|0x7FF
operator|)
operator|&&
operator|(
name|extractFloat64Frac0
argument_list|(
name|a
argument_list|)
operator||
name|extractFloat64Frac1
argument_list|(
name|a
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|extractFloat64Exp
argument_list|(
name|b
argument_list|)
operator|==
literal|0x7FF
operator|)
operator|&&
operator|(
name|extractFloat64Frac0
argument_list|(
name|b
argument_list|)
operator||
name|extractFloat64Frac1
argument_list|(
name|b
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|float64_is_signaling_nan
argument_list|(
name|a
argument_list|)
operator|||
name|float64_is_signaling_nan
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|aSign
operator|=
name|extractFloat64Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat64Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aSign
operator|!=
name|bSign
condition|)
return|return
name|aSign
operator|&&
operator|(
call|(
name|bits64
call|)
argument_list|(
operator|(
name|a
operator||
name|b
operator|)
operator|<<
literal|1
argument_list|)
operator|!=
literal|0
operator|)
return|;
return|return
operator|(
name|a
operator|!=
name|b
operator|)
operator|&&
operator|(
name|aSign
operator|^
operator|(
name|a
operator|<
name|b
operator|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

