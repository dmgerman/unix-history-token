begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $NetBSD: softfloat.c,v 1.2 2003/07/26 19:24:52 salo Exp $ */
end_comment

begin_comment
comment|/*  * This version hacked for use with gcc -msoft-float by bjh21.  * (Mostly a case of #ifdefing out things GCC doesn't need or provides  *  itself).  */
end_comment

begin_comment
comment|/*  * Things you may want to define:  *  * SOFTFLOAT_FOR_GCC - build only those functions necessary for GCC (with  *   -msoft-float) to work.  Include "softfloat-for-gcc.h" to get them  *   properly renamed.  */
end_comment

begin_comment
comment|/* ===============================================================================  This C source file is part of the SoftFloat IEC/IEEE Floating-point Arithmetic Package, Release 2a.  Written by John R. Hauser.  This work was made possible in part by the International Computer Science Institute, located at Suite 600, 1947 Center Street, Berkeley, California 94704.  Funding was partially provided by the National Science Foundation under grant MIP-9311980.  The original version of this code was written as part of a project to build a fixed-point vector processor in collaboration with the University of California at Berkeley, overseen by Profs. Nelson Morgan and John Wawrzynek.  More information is available through the Web page `http://HTTP.CS.Berkeley.EDU/~jhauser/ arithmetic/SoftFloat.html'.  THIS SOFTWARE IS DISTRIBUTED AS IS, FOR FREE.  Although reasonable effort has been made to avoid it, THIS SOFTWARE MAY CONTAIN FAULTS THAT WILL AT TIMES RESULT IN INCORRECT BEHAVIOR.  USE OF THIS SOFTWARE IS RESTRICTED TO PERSONS AND ORGANIZATIONS WHO CAN AND WILL TAKE FULL RESPONSIBILITY FOR ANY AND ALL LOSSES, COSTS, OR OTHER PROBLEMS ARISING FROM ITS USE.  Derivative works are acceptable, even for commercial purposes, so long as (1) they include prominent notice that the work is derivative, and (2) they include prominent notice akin to these four paragraphs for those parts of this code that are retained.  =============================================================================== */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|SOFTFLOAT_FOR_GCC
end_ifdef

begin_include
include|#
directive|include
file|"softfloat-for-gcc.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"milieu.h"
end_include

begin_include
include|#
directive|include
file|"softfloat.h"
end_include

begin_comment
comment|/*  * Conversions between floats as stored in memory and floats as  * SoftFloat uses them  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|FLOAT64_DEMANGLE
end_ifndef

begin_define
define|#
directive|define
name|FLOAT64_DEMANGLE
parameter_list|(
name|a
parameter_list|)
value|(a)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|FLOAT64_MANGLE
end_ifndef

begin_define
define|#
directive|define
name|FLOAT64_MANGLE
parameter_list|(
name|a
parameter_list|)
value|(a)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ------------------------------------------------------------------------------- Floating-point rounding mode, extended double-precision rounding precision, and exception flags. ------------------------------------------------------------------------------- */
end_comment

begin_decl_stmt
name|int
name|float_rounding_mode
init|=
name|float_round_nearest_even
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|float_exception_flags
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|FLOATX80
end_ifdef

begin_decl_stmt
name|int8
name|floatx80_rounding_precision
init|=
literal|80
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ------------------------------------------------------------------------------- Primitive arithmetic functions, including multi-word arithmetic, and division and square root approximations.  (Can be specialized to target if desired.) ------------------------------------------------------------------------------- */
end_comment

begin_include
include|#
directive|include
file|"softfloat-macros"
end_include

begin_comment
comment|/* ------------------------------------------------------------------------------- Functions and definitions to determine:  (1) whether tininess for underflow is detected before or after rounding by default, (2) what (if anything) happens when exceptions are raised, (3) how signaling NaNs are distinguished from quiet NaNs, (4) the default generated quiet NaNs, and (5) how NaNs are propagated from function inputs to output.  These details are target- specific. ------------------------------------------------------------------------------- */
end_comment

begin_include
include|#
directive|include
file|"softfloat-specialize"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SOFTFLOAT_FOR_GCC
argument_list|)
operator|||
name|defined
argument_list|(
name|FLOATX80
argument_list|)
operator|||
name|defined
argument_list|(
name|FLOAT128
argument_list|)
end_if

begin_comment
comment|/* ------------------------------------------------------------------------------- Takes a 64-bit fixed-point value `absZ' with binary point between bits 6 and 7, and returns the properly rounded 32-bit integer corresponding to the input.  If `zSign' is 1, the input is negated before being converted to an integer.  Bit 63 of `absZ' must be zero.  Ordinarily, the fixed-point input is simply rounded to an integer, with the inexact exception raised if the input cannot be represented exactly as an integer.  However, if the fixed- point input is too large, the invalid exception is raised and the largest positive or negative integer is returned. ------------------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|int32
name|roundAndPackInt32
parameter_list|(
name|flag
name|zSign
parameter_list|,
name|bits64
name|absZ
parameter_list|)
block|{
name|int8
name|roundingMode
decl_stmt|;
name|flag
name|roundNearestEven
decl_stmt|;
name|int8
name|roundIncrement
decl_stmt|,
name|roundBits
decl_stmt|;
name|int32
name|z
decl_stmt|;
name|roundingMode
operator|=
name|float_rounding_mode
expr_stmt|;
name|roundNearestEven
operator|=
operator|(
name|roundingMode
operator|==
name|float_round_nearest_even
operator|)
expr_stmt|;
name|roundIncrement
operator|=
literal|0x40
expr_stmt|;
if|if
condition|(
operator|!
name|roundNearestEven
condition|)
block|{
if|if
condition|(
name|roundingMode
operator|==
name|float_round_to_zero
condition|)
block|{
name|roundIncrement
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|roundIncrement
operator|=
literal|0x7F
expr_stmt|;
if|if
condition|(
name|zSign
condition|)
block|{
if|if
condition|(
name|roundingMode
operator|==
name|float_round_up
condition|)
name|roundIncrement
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|roundingMode
operator|==
name|float_round_down
condition|)
name|roundIncrement
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|roundBits
operator|=
name|absZ
operator|&
literal|0x7F
expr_stmt|;
name|absZ
operator|=
operator|(
name|absZ
operator|+
name|roundIncrement
operator|)
operator|>>
literal|7
expr_stmt|;
name|absZ
operator|&=
operator|~
operator|(
operator|(
operator|(
name|roundBits
operator|^
literal|0x40
operator|)
operator|==
literal|0
operator|)
operator|&
name|roundNearestEven
operator|)
expr_stmt|;
name|z
operator|=
name|absZ
expr_stmt|;
if|if
condition|(
name|zSign
condition|)
name|z
operator|=
operator|-
name|z
expr_stmt|;
if|if
condition|(
operator|(
name|absZ
operator|>>
literal|32
operator|)
operator|||
operator|(
name|z
operator|&&
operator|(
operator|(
name|z
operator|<
literal|0
operator|)
operator|^
name|zSign
operator|)
operator|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|zSign
condition|?
operator|(
name|sbits32
operator|)
literal|0x80000000
else|:
literal|0x7FFFFFFF
return|;
block|}
if|if
condition|(
name|roundBits
condition|)
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
return|return
name|z
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Takes the 128-bit fixed-point value formed by concatenating `absZ0' and `absZ1', with binary point between bits 63 and 64 (between the input words), and returns the properly rounded 64-bit integer corresponding to the input. If `zSign' is 1, the input is negated before being converted to an integer. Ordinarily, the fixed-point input is simply rounded to an integer, with the inexact exception raised if the input cannot be represented exactly as an integer.  However, if the fixed-point input is too large, the invalid exception is raised and the largest positive or negative integer is returned. ------------------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|int64
name|roundAndPackInt64
parameter_list|(
name|flag
name|zSign
parameter_list|,
name|bits64
name|absZ0
parameter_list|,
name|bits64
name|absZ1
parameter_list|)
block|{
name|int8
name|roundingMode
decl_stmt|;
name|flag
name|roundNearestEven
decl_stmt|,
name|increment
decl_stmt|;
name|int64
name|z
decl_stmt|;
name|roundingMode
operator|=
name|float_rounding_mode
expr_stmt|;
name|roundNearestEven
operator|=
operator|(
name|roundingMode
operator|==
name|float_round_nearest_even
operator|)
expr_stmt|;
name|increment
operator|=
operator|(
operator|(
name|sbits64
operator|)
name|absZ1
operator|<
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|roundNearestEven
condition|)
block|{
if|if
condition|(
name|roundingMode
operator|==
name|float_round_to_zero
condition|)
block|{
name|increment
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|zSign
condition|)
block|{
name|increment
operator|=
operator|(
name|roundingMode
operator|==
name|float_round_down
operator|)
operator|&&
name|absZ1
expr_stmt|;
block|}
else|else
block|{
name|increment
operator|=
operator|(
name|roundingMode
operator|==
name|float_round_up
operator|)
operator|&&
name|absZ1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|increment
condition|)
block|{
operator|++
name|absZ0
expr_stmt|;
if|if
condition|(
name|absZ0
operator|==
literal|0
condition|)
goto|goto
name|overflow
goto|;
name|absZ0
operator|&=
operator|~
operator|(
operator|(
call|(
name|bits64
call|)
argument_list|(
name|absZ1
operator|<<
literal|1
argument_list|)
operator|==
literal|0
operator|)
operator|&
name|roundNearestEven
operator|)
expr_stmt|;
block|}
name|z
operator|=
name|absZ0
expr_stmt|;
if|if
condition|(
name|zSign
condition|)
name|z
operator|=
operator|-
name|z
expr_stmt|;
if|if
condition|(
name|z
operator|&&
operator|(
operator|(
name|z
operator|<
literal|0
operator|)
operator|^
name|zSign
operator|)
condition|)
block|{
name|overflow
label|:
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|zSign
condition|?
operator|(
name|sbits64
operator|)
name|LIT64
argument_list|(
literal|0x8000000000000000
argument_list|)
else|:
name|LIT64
argument_list|(
literal|0x7FFFFFFFFFFFFFFF
argument_list|)
return|;
block|}
if|if
condition|(
name|absZ1
condition|)
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
return|return
name|z
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the fraction bits of the single-precision floating-point value `a'. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|INLINE
name|bits32
name|extractFloat32Frac
parameter_list|(
name|float32
name|a
parameter_list|)
block|{
return|return
name|a
operator|&
literal|0x007FFFFF
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the exponent bits of the single-precision floating-point value `a'. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|INLINE
name|int16
name|extractFloat32Exp
parameter_list|(
name|float32
name|a
parameter_list|)
block|{
return|return
operator|(
name|a
operator|>>
literal|23
operator|)
operator|&
literal|0xFF
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the sign bit of the single-precision floating-point value `a'. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|INLINE
name|flag
name|extractFloat32Sign
parameter_list|(
name|float32
name|a
parameter_list|)
block|{
return|return
name|a
operator|>>
literal|31
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Normalizes the subnormal single-precision floating-point value represented by the denormalized significand `aSig'.  The normalized exponent and significand are stored at the locations pointed to by `zExpPtr' and `zSigPtr', respectively. ------------------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|void
name|normalizeFloat32Subnormal
parameter_list|(
name|bits32
name|aSig
parameter_list|,
name|int16
modifier|*
name|zExpPtr
parameter_list|,
name|bits32
modifier|*
name|zSigPtr
parameter_list|)
block|{
name|int8
name|shiftCount
decl_stmt|;
name|shiftCount
operator|=
name|countLeadingZeros32
argument_list|(
name|aSig
argument_list|)
operator|-
literal|8
expr_stmt|;
operator|*
name|zSigPtr
operator|=
name|aSig
operator|<<
name|shiftCount
expr_stmt|;
operator|*
name|zExpPtr
operator|=
literal|1
operator|-
name|shiftCount
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Packs the sign `zSign', exponent `zExp', and significand `zSig' into a single-precision floating-point value, returning the result.  After being shifted into the proper positions, the three fields are simply added together to form the result.  This means that any integer portion of `zSig' will be added into the exponent.  Since a properly normalized significand will have an integer portion equal to 1, the `zExp' input should be 1 less than the desired result exponent whenever `zSig' is a complete, normalized significand. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|INLINE
name|float32
name|packFloat32
parameter_list|(
name|flag
name|zSign
parameter_list|,
name|int16
name|zExp
parameter_list|,
name|bits32
name|zSig
parameter_list|)
block|{
return|return
operator|(
operator|(
operator|(
name|bits32
operator|)
name|zSign
operator|)
operator|<<
literal|31
operator|)
operator|+
operator|(
operator|(
operator|(
name|bits32
operator|)
name|zExp
operator|)
operator|<<
literal|23
operator|)
operator|+
name|zSig
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Takes an abstract floating-point value having sign `zSign', exponent `zExp', and significand `zSig', and returns the proper single-precision floating- point value corresponding to the abstract input.  Ordinarily, the abstract value is simply rounded and packed into the single-precision format, with the inexact exception raised if the abstract input cannot be represented exactly.  However, if the abstract value is too large, the overflow and inexact exceptions are raised and an infinity or maximal finite value is returned.  If the abstract value is too small, the input value is rounded to a subnormal number, and the underflow and inexact exceptions are raised if the abstract input cannot be represented exactly as a subnormal single- precision floating-point number.     The input significand `zSig' has its binary point between bits 30 and 29, which is 7 bits to the left of the usual location.  This shifted significand must be normalized or smaller.  If `zSig' is not normalized, `zExp' must be 0; in that case, the result returned is a subnormal number, and it must not require rounding.  In the usual case that `zSig' is normalized, `zExp' must be 1 less than the ``true'' floating-point exponent. The handling of underflow and overflow follows the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|float32
name|roundAndPackFloat32
parameter_list|(
name|flag
name|zSign
parameter_list|,
name|int16
name|zExp
parameter_list|,
name|bits32
name|zSig
parameter_list|)
block|{
name|int8
name|roundingMode
decl_stmt|;
name|flag
name|roundNearestEven
decl_stmt|;
name|int8
name|roundIncrement
decl_stmt|,
name|roundBits
decl_stmt|;
name|flag
name|isTiny
decl_stmt|;
name|roundingMode
operator|=
name|float_rounding_mode
expr_stmt|;
name|roundNearestEven
operator|=
operator|(
name|roundingMode
operator|==
name|float_round_nearest_even
operator|)
expr_stmt|;
name|roundIncrement
operator|=
literal|0x40
expr_stmt|;
if|if
condition|(
operator|!
name|roundNearestEven
condition|)
block|{
if|if
condition|(
name|roundingMode
operator|==
name|float_round_to_zero
condition|)
block|{
name|roundIncrement
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|roundIncrement
operator|=
literal|0x7F
expr_stmt|;
if|if
condition|(
name|zSign
condition|)
block|{
if|if
condition|(
name|roundingMode
operator|==
name|float_round_up
condition|)
name|roundIncrement
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|roundingMode
operator|==
name|float_round_down
condition|)
name|roundIncrement
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|roundBits
operator|=
name|zSig
operator|&
literal|0x7F
expr_stmt|;
if|if
condition|(
literal|0xFD
operator|<=
operator|(
name|bits16
operator|)
name|zExp
condition|)
block|{
if|if
condition|(
operator|(
literal|0xFD
operator|<
name|zExp
operator|)
operator|||
operator|(
operator|(
name|zExp
operator|==
literal|0xFD
operator|)
operator|&&
operator|(
call|(
name|sbits32
call|)
argument_list|(
name|zSig
operator|+
name|roundIncrement
argument_list|)
operator|<
literal|0
operator|)
operator|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_overflow
operator||
name|float_flag_inexact
argument_list|)
expr_stmt|;
return|return
name|packFloat32
argument_list|(
name|zSign
argument_list|,
literal|0xFF
argument_list|,
literal|0
argument_list|)
operator|-
operator|(
name|roundIncrement
operator|==
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|zExp
operator|<
literal|0
condition|)
block|{
name|isTiny
operator|=
operator|(
name|float_detect_tininess
operator|==
name|float_tininess_before_rounding
operator|)
operator|||
operator|(
name|zExp
operator|<
operator|-
literal|1
operator|)
operator|||
operator|(
name|zSig
operator|+
name|roundIncrement
operator|<
literal|0x80000000
operator|)
expr_stmt|;
name|shift32RightJamming
argument_list|(
name|zSig
argument_list|,
operator|-
name|zExp
argument_list|,
operator|&
name|zSig
argument_list|)
expr_stmt|;
name|zExp
operator|=
literal|0
expr_stmt|;
name|roundBits
operator|=
name|zSig
operator|&
literal|0x7F
expr_stmt|;
if|if
condition|(
name|isTiny
operator|&&
name|roundBits
condition|)
name|float_raise
argument_list|(
name|float_flag_underflow
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|roundBits
condition|)
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
name|zSig
operator|=
operator|(
name|zSig
operator|+
name|roundIncrement
operator|)
operator|>>
literal|7
expr_stmt|;
name|zSig
operator|&=
operator|~
operator|(
operator|(
operator|(
name|roundBits
operator|^
literal|0x40
operator|)
operator|==
literal|0
operator|)
operator|&
name|roundNearestEven
operator|)
expr_stmt|;
if|if
condition|(
name|zSig
operator|==
literal|0
condition|)
name|zExp
operator|=
literal|0
expr_stmt|;
return|return
name|packFloat32
argument_list|(
name|zSign
argument_list|,
name|zExp
argument_list|,
name|zSig
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Takes an abstract floating-point value having sign `zSign', exponent `zExp', and significand `zSig', and returns the proper single-precision floating- point value corresponding to the abstract input.  This routine is just like `roundAndPackFloat32' except that `zSig' does not have to be normalized. Bit 31 of `zSig' must be zero, and `zExp' must be 1 less than the ``true'' floating-point exponent. ------------------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|float32
name|normalizeRoundAndPackFloat32
parameter_list|(
name|flag
name|zSign
parameter_list|,
name|int16
name|zExp
parameter_list|,
name|bits32
name|zSig
parameter_list|)
block|{
name|int8
name|shiftCount
decl_stmt|;
name|shiftCount
operator|=
name|countLeadingZeros32
argument_list|(
name|zSig
argument_list|)
operator|-
literal|1
expr_stmt|;
return|return
name|roundAndPackFloat32
argument_list|(
name|zSign
argument_list|,
name|zExp
operator|-
name|shiftCount
argument_list|,
name|zSig
operator|<<
name|shiftCount
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the fraction bits of the double-precision floating-point value `a'. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|INLINE
name|bits64
name|extractFloat64Frac
parameter_list|(
name|float64
name|a
parameter_list|)
block|{
return|return
name|FLOAT64_DEMANGLE
argument_list|(
name|a
argument_list|)
operator|&
name|LIT64
argument_list|(
literal|0x000FFFFFFFFFFFFF
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the exponent bits of the double-precision floating-point value `a'. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|INLINE
name|int16
name|extractFloat64Exp
parameter_list|(
name|float64
name|a
parameter_list|)
block|{
return|return
operator|(
name|FLOAT64_DEMANGLE
argument_list|(
name|a
argument_list|)
operator|>>
literal|52
operator|)
operator|&
literal|0x7FF
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the sign bit of the double-precision floating-point value `a'. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|INLINE
name|flag
name|extractFloat64Sign
parameter_list|(
name|float64
name|a
parameter_list|)
block|{
return|return
name|FLOAT64_DEMANGLE
argument_list|(
name|a
argument_list|)
operator|>>
literal|63
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Normalizes the subnormal double-precision floating-point value represented by the denormalized significand `aSig'.  The normalized exponent and significand are stored at the locations pointed to by `zExpPtr' and `zSigPtr', respectively. ------------------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|void
name|normalizeFloat64Subnormal
parameter_list|(
name|bits64
name|aSig
parameter_list|,
name|int16
modifier|*
name|zExpPtr
parameter_list|,
name|bits64
modifier|*
name|zSigPtr
parameter_list|)
block|{
name|int8
name|shiftCount
decl_stmt|;
name|shiftCount
operator|=
name|countLeadingZeros64
argument_list|(
name|aSig
argument_list|)
operator|-
literal|11
expr_stmt|;
operator|*
name|zSigPtr
operator|=
name|aSig
operator|<<
name|shiftCount
expr_stmt|;
operator|*
name|zExpPtr
operator|=
literal|1
operator|-
name|shiftCount
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Packs the sign `zSign', exponent `zExp', and significand `zSig' into a double-precision floating-point value, returning the result.  After being shifted into the proper positions, the three fields are simply added together to form the result.  This means that any integer portion of `zSig' will be added into the exponent.  Since a properly normalized significand will have an integer portion equal to 1, the `zExp' input should be 1 less than the desired result exponent whenever `zSig' is a complete, normalized significand. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|INLINE
name|float64
name|packFloat64
parameter_list|(
name|flag
name|zSign
parameter_list|,
name|int16
name|zExp
parameter_list|,
name|bits64
name|zSig
parameter_list|)
block|{
return|return
name|FLOAT64_MANGLE
argument_list|(
operator|(
operator|(
operator|(
name|bits64
operator|)
name|zSign
operator|)
operator|<<
literal|63
operator|)
operator|+
operator|(
operator|(
operator|(
name|bits64
operator|)
name|zExp
operator|)
operator|<<
literal|52
operator|)
operator|+
name|zSig
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Takes an abstract floating-point value having sign `zSign', exponent `zExp', and significand `zSig', and returns the proper double-precision floating- point value corresponding to the abstract input.  Ordinarily, the abstract value is simply rounded and packed into the double-precision format, with the inexact exception raised if the abstract input cannot be represented exactly.  However, if the abstract value is too large, the overflow and inexact exceptions are raised and an infinity or maximal finite value is returned.  If the abstract value is too small, the input value is rounded to a subnormal number, and the underflow and inexact exceptions are raised if the abstract input cannot be represented exactly as a subnormal double- precision floating-point number.     The input significand `zSig' has its binary point between bits 62 and 61, which is 10 bits to the left of the usual location.  This shifted significand must be normalized or smaller.  If `zSig' is not normalized, `zExp' must be 0; in that case, the result returned is a subnormal number, and it must not require rounding.  In the usual case that `zSig' is normalized, `zExp' must be 1 less than the ``true'' floating-point exponent. The handling of underflow and overflow follows the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|float64
name|roundAndPackFloat64
parameter_list|(
name|flag
name|zSign
parameter_list|,
name|int16
name|zExp
parameter_list|,
name|bits64
name|zSig
parameter_list|)
block|{
name|int8
name|roundingMode
decl_stmt|;
name|flag
name|roundNearestEven
decl_stmt|;
name|int16
name|roundIncrement
decl_stmt|,
name|roundBits
decl_stmt|;
name|flag
name|isTiny
decl_stmt|;
name|roundingMode
operator|=
name|float_rounding_mode
expr_stmt|;
name|roundNearestEven
operator|=
operator|(
name|roundingMode
operator|==
name|float_round_nearest_even
operator|)
expr_stmt|;
name|roundIncrement
operator|=
literal|0x200
expr_stmt|;
if|if
condition|(
operator|!
name|roundNearestEven
condition|)
block|{
if|if
condition|(
name|roundingMode
operator|==
name|float_round_to_zero
condition|)
block|{
name|roundIncrement
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|roundIncrement
operator|=
literal|0x3FF
expr_stmt|;
if|if
condition|(
name|zSign
condition|)
block|{
if|if
condition|(
name|roundingMode
operator|==
name|float_round_up
condition|)
name|roundIncrement
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|roundingMode
operator|==
name|float_round_down
condition|)
name|roundIncrement
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|roundBits
operator|=
name|zSig
operator|&
literal|0x3FF
expr_stmt|;
if|if
condition|(
literal|0x7FD
operator|<=
operator|(
name|bits16
operator|)
name|zExp
condition|)
block|{
if|if
condition|(
operator|(
literal|0x7FD
operator|<
name|zExp
operator|)
operator|||
operator|(
operator|(
name|zExp
operator|==
literal|0x7FD
operator|)
operator|&&
operator|(
call|(
name|sbits64
call|)
argument_list|(
name|zSig
operator|+
name|roundIncrement
argument_list|)
operator|<
literal|0
operator|)
operator|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_overflow
operator||
name|float_flag_inexact
argument_list|)
expr_stmt|;
return|return
name|FLOAT64_MANGLE
argument_list|(
name|FLOAT64_DEMANGLE
argument_list|(
name|packFloat64
argument_list|(
name|zSign
argument_list|,
literal|0x7FF
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|-
operator|(
name|roundIncrement
operator|==
literal|0
operator|)
argument_list|)
return|;
block|}
if|if
condition|(
name|zExp
operator|<
literal|0
condition|)
block|{
name|isTiny
operator|=
operator|(
name|float_detect_tininess
operator|==
name|float_tininess_before_rounding
operator|)
operator|||
operator|(
name|zExp
operator|<
operator|-
literal|1
operator|)
operator|||
operator|(
name|zSig
operator|+
name|roundIncrement
operator|<
name|LIT64
argument_list|(
literal|0x8000000000000000
argument_list|)
operator|)
expr_stmt|;
name|shift64RightJamming
argument_list|(
name|zSig
argument_list|,
operator|-
name|zExp
argument_list|,
operator|&
name|zSig
argument_list|)
expr_stmt|;
name|zExp
operator|=
literal|0
expr_stmt|;
name|roundBits
operator|=
name|zSig
operator|&
literal|0x3FF
expr_stmt|;
if|if
condition|(
name|isTiny
operator|&&
name|roundBits
condition|)
name|float_raise
argument_list|(
name|float_flag_underflow
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|roundBits
condition|)
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
name|zSig
operator|=
operator|(
name|zSig
operator|+
name|roundIncrement
operator|)
operator|>>
literal|10
expr_stmt|;
name|zSig
operator|&=
operator|~
operator|(
operator|(
operator|(
name|roundBits
operator|^
literal|0x200
operator|)
operator|==
literal|0
operator|)
operator|&
name|roundNearestEven
operator|)
expr_stmt|;
if|if
condition|(
name|zSig
operator|==
literal|0
condition|)
name|zExp
operator|=
literal|0
expr_stmt|;
return|return
name|packFloat64
argument_list|(
name|zSign
argument_list|,
name|zExp
argument_list|,
name|zSig
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Takes an abstract floating-point value having sign `zSign', exponent `zExp', and significand `zSig', and returns the proper double-precision floating- point value corresponding to the abstract input.  This routine is just like `roundAndPackFloat64' except that `zSig' does not have to be normalized. Bit 63 of `zSig' must be zero, and `zExp' must be 1 less than the ``true'' floating-point exponent. ------------------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|float64
name|normalizeRoundAndPackFloat64
parameter_list|(
name|flag
name|zSign
parameter_list|,
name|int16
name|zExp
parameter_list|,
name|bits64
name|zSig
parameter_list|)
block|{
name|int8
name|shiftCount
decl_stmt|;
name|shiftCount
operator|=
name|countLeadingZeros64
argument_list|(
name|zSig
argument_list|)
operator|-
literal|1
expr_stmt|;
return|return
name|roundAndPackFloat64
argument_list|(
name|zSign
argument_list|,
name|zExp
operator|-
name|shiftCount
argument_list|,
name|zSig
operator|<<
name|shiftCount
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FLOATX80
end_ifdef

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the fraction bits of the extended double-precision floating-point value `a'. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|INLINE
name|bits64
name|extractFloatx80Frac
parameter_list|(
name|floatx80
name|a
parameter_list|)
block|{
return|return
name|a
operator|.
name|low
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the exponent bits of the extended double-precision floating-point value `a'. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|INLINE
name|int32
name|extractFloatx80Exp
parameter_list|(
name|floatx80
name|a
parameter_list|)
block|{
return|return
name|a
operator|.
name|high
operator|&
literal|0x7FFF
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the sign bit of the extended double-precision floating-point value `a'. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|INLINE
name|flag
name|extractFloatx80Sign
parameter_list|(
name|floatx80
name|a
parameter_list|)
block|{
return|return
name|a
operator|.
name|high
operator|>>
literal|15
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Normalizes the subnormal extended double-precision floating-point value represented by the denormalized significand `aSig'.  The normalized exponent and significand are stored at the locations pointed to by `zExpPtr' and `zSigPtr', respectively. ------------------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|void
name|normalizeFloatx80Subnormal
parameter_list|(
name|bits64
name|aSig
parameter_list|,
name|int32
modifier|*
name|zExpPtr
parameter_list|,
name|bits64
modifier|*
name|zSigPtr
parameter_list|)
block|{
name|int8
name|shiftCount
decl_stmt|;
name|shiftCount
operator|=
name|countLeadingZeros64
argument_list|(
name|aSig
argument_list|)
expr_stmt|;
operator|*
name|zSigPtr
operator|=
name|aSig
operator|<<
name|shiftCount
expr_stmt|;
operator|*
name|zExpPtr
operator|=
literal|1
operator|-
name|shiftCount
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Packs the sign `zSign', exponent `zExp', and significand `zSig' into an extended double-precision floating-point value, returning the result. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|INLINE
name|floatx80
name|packFloatx80
parameter_list|(
name|flag
name|zSign
parameter_list|,
name|int32
name|zExp
parameter_list|,
name|bits64
name|zSig
parameter_list|)
block|{
name|floatx80
name|z
decl_stmt|;
name|z
operator|.
name|low
operator|=
name|zSig
expr_stmt|;
name|z
operator|.
name|high
operator|=
operator|(
operator|(
operator|(
name|bits16
operator|)
name|zSign
operator|)
operator|<<
literal|15
operator|)
operator|+
name|zExp
expr_stmt|;
return|return
name|z
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Takes an abstract floating-point value having sign `zSign', exponent `zExp', and extended significand formed by the concatenation of `zSig0' and `zSig1', and returns the proper extended double-precision floating-point value corresponding to the abstract input.  Ordinarily, the abstract value is rounded and packed into the extended double-precision format, with the inexact exception raised if the abstract input cannot be represented exactly.  However, if the abstract value is too large, the overflow and inexact exceptions are raised and an infinity or maximal finite value is returned.  If the abstract value is too small, the input value is rounded to a subnormal number, and the underflow and inexact exceptions are raised if the abstract input cannot be represented exactly as a subnormal extended double-precision floating-point number.     If `roundingPrecision' is 32 or 64, the result is rounded to the same number of bits as single or double precision, respectively.  Otherwise, the result is rounded to the full precision of the extended double-precision format.     The input significand must be normalized or smaller.  If the input significand is not normalized, `zExp' must be 0; in that case, the result returned is a subnormal number, and it must not require rounding.  The handling of underflow and overflow follows the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|floatx80
name|roundAndPackFloatx80
parameter_list|(
name|int8
name|roundingPrecision
parameter_list|,
name|flag
name|zSign
parameter_list|,
name|int32
name|zExp
parameter_list|,
name|bits64
name|zSig0
parameter_list|,
name|bits64
name|zSig1
parameter_list|)
block|{
name|int8
name|roundingMode
decl_stmt|;
name|flag
name|roundNearestEven
decl_stmt|,
name|increment
decl_stmt|,
name|isTiny
decl_stmt|;
name|int64
name|roundIncrement
decl_stmt|,
name|roundMask
decl_stmt|,
name|roundBits
decl_stmt|;
name|roundingMode
operator|=
name|float_rounding_mode
expr_stmt|;
name|roundNearestEven
operator|=
operator|(
name|roundingMode
operator|==
name|float_round_nearest_even
operator|)
expr_stmt|;
if|if
condition|(
name|roundingPrecision
operator|==
literal|80
condition|)
goto|goto
name|precision80
goto|;
if|if
condition|(
name|roundingPrecision
operator|==
literal|64
condition|)
block|{
name|roundIncrement
operator|=
name|LIT64
argument_list|(
literal|0x0000000000000400
argument_list|)
expr_stmt|;
name|roundMask
operator|=
name|LIT64
argument_list|(
literal|0x00000000000007FF
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|roundingPrecision
operator|==
literal|32
condition|)
block|{
name|roundIncrement
operator|=
name|LIT64
argument_list|(
literal|0x0000008000000000
argument_list|)
expr_stmt|;
name|roundMask
operator|=
name|LIT64
argument_list|(
literal|0x000000FFFFFFFFFF
argument_list|)
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|precision80
goto|;
block|}
name|zSig0
operator||=
operator|(
name|zSig1
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|roundNearestEven
condition|)
block|{
if|if
condition|(
name|roundingMode
operator|==
name|float_round_to_zero
condition|)
block|{
name|roundIncrement
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|roundIncrement
operator|=
name|roundMask
expr_stmt|;
if|if
condition|(
name|zSign
condition|)
block|{
if|if
condition|(
name|roundingMode
operator|==
name|float_round_up
condition|)
name|roundIncrement
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|roundingMode
operator|==
name|float_round_down
condition|)
name|roundIncrement
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|roundBits
operator|=
name|zSig0
operator|&
name|roundMask
expr_stmt|;
if|if
condition|(
literal|0x7FFD
operator|<=
call|(
name|bits32
call|)
argument_list|(
name|zExp
operator|-
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
literal|0x7FFE
operator|<
name|zExp
operator|)
operator|||
operator|(
operator|(
name|zExp
operator|==
literal|0x7FFE
operator|)
operator|&&
operator|(
name|zSig0
operator|+
name|roundIncrement
operator|<
name|zSig0
operator|)
operator|)
condition|)
block|{
goto|goto
name|overflow
goto|;
block|}
if|if
condition|(
name|zExp
operator|<=
literal|0
condition|)
block|{
name|isTiny
operator|=
operator|(
name|float_detect_tininess
operator|==
name|float_tininess_before_rounding
operator|)
operator|||
operator|(
name|zExp
operator|<
literal|0
operator|)
operator|||
operator|(
name|zSig0
operator|<=
name|zSig0
operator|+
name|roundIncrement
operator|)
expr_stmt|;
name|shift64RightJamming
argument_list|(
name|zSig0
argument_list|,
literal|1
operator|-
name|zExp
argument_list|,
operator|&
name|zSig0
argument_list|)
expr_stmt|;
name|zExp
operator|=
literal|0
expr_stmt|;
name|roundBits
operator|=
name|zSig0
operator|&
name|roundMask
expr_stmt|;
if|if
condition|(
name|isTiny
operator|&&
name|roundBits
condition|)
name|float_raise
argument_list|(
name|float_flag_underflow
argument_list|)
expr_stmt|;
if|if
condition|(
name|roundBits
condition|)
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
name|zSig0
operator|+=
name|roundIncrement
expr_stmt|;
if|if
condition|(
operator|(
name|sbits64
operator|)
name|zSig0
operator|<
literal|0
condition|)
name|zExp
operator|=
literal|1
expr_stmt|;
name|roundIncrement
operator|=
name|roundMask
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|roundNearestEven
operator|&&
operator|(
name|roundBits
operator|<<
literal|1
operator|==
name|roundIncrement
operator|)
condition|)
block|{
name|roundMask
operator||=
name|roundIncrement
expr_stmt|;
block|}
name|zSig0
operator|&=
operator|~
name|roundMask
expr_stmt|;
return|return
name|packFloatx80
argument_list|(
name|zSign
argument_list|,
name|zExp
argument_list|,
name|zSig0
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|roundBits
condition|)
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
name|zSig0
operator|+=
name|roundIncrement
expr_stmt|;
if|if
condition|(
name|zSig0
operator|<
name|roundIncrement
condition|)
block|{
operator|++
name|zExp
expr_stmt|;
name|zSig0
operator|=
name|LIT64
argument_list|(
literal|0x8000000000000000
argument_list|)
expr_stmt|;
block|}
name|roundIncrement
operator|=
name|roundMask
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|roundNearestEven
operator|&&
operator|(
name|roundBits
operator|<<
literal|1
operator|==
name|roundIncrement
operator|)
condition|)
block|{
name|roundMask
operator||=
name|roundIncrement
expr_stmt|;
block|}
name|zSig0
operator|&=
operator|~
name|roundMask
expr_stmt|;
if|if
condition|(
name|zSig0
operator|==
literal|0
condition|)
name|zExp
operator|=
literal|0
expr_stmt|;
return|return
name|packFloatx80
argument_list|(
name|zSign
argument_list|,
name|zExp
argument_list|,
name|zSig0
argument_list|)
return|;
name|precision80
label|:
name|increment
operator|=
operator|(
operator|(
name|sbits64
operator|)
name|zSig1
operator|<
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|roundNearestEven
condition|)
block|{
if|if
condition|(
name|roundingMode
operator|==
name|float_round_to_zero
condition|)
block|{
name|increment
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|zSign
condition|)
block|{
name|increment
operator|=
operator|(
name|roundingMode
operator|==
name|float_round_down
operator|)
operator|&&
name|zSig1
expr_stmt|;
block|}
else|else
block|{
name|increment
operator|=
operator|(
name|roundingMode
operator|==
name|float_round_up
operator|)
operator|&&
name|zSig1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
literal|0x7FFD
operator|<=
call|(
name|bits32
call|)
argument_list|(
name|zExp
operator|-
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
literal|0x7FFE
operator|<
name|zExp
operator|)
operator|||
operator|(
operator|(
name|zExp
operator|==
literal|0x7FFE
operator|)
operator|&&
operator|(
name|zSig0
operator|==
name|LIT64
argument_list|(
literal|0xFFFFFFFFFFFFFFFF
argument_list|)
operator|)
operator|&&
name|increment
operator|)
condition|)
block|{
name|roundMask
operator|=
literal|0
expr_stmt|;
name|overflow
label|:
name|float_raise
argument_list|(
name|float_flag_overflow
operator||
name|float_flag_inexact
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|roundingMode
operator|==
name|float_round_to_zero
operator|)
operator|||
operator|(
name|zSign
operator|&&
operator|(
name|roundingMode
operator|==
name|float_round_up
operator|)
operator|)
operator|||
operator|(
operator|!
name|zSign
operator|&&
operator|(
name|roundingMode
operator|==
name|float_round_down
operator|)
operator|)
condition|)
block|{
return|return
name|packFloatx80
argument_list|(
name|zSign
argument_list|,
literal|0x7FFE
argument_list|,
operator|~
name|roundMask
argument_list|)
return|;
block|}
return|return
name|packFloatx80
argument_list|(
name|zSign
argument_list|,
literal|0x7FFF
argument_list|,
name|LIT64
argument_list|(
literal|0x8000000000000000
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|zExp
operator|<=
literal|0
condition|)
block|{
name|isTiny
operator|=
operator|(
name|float_detect_tininess
operator|==
name|float_tininess_before_rounding
operator|)
operator|||
operator|(
name|zExp
operator|<
literal|0
operator|)
operator|||
operator|!
name|increment
operator|||
operator|(
name|zSig0
operator|<
name|LIT64
argument_list|(
literal|0xFFFFFFFFFFFFFFFF
argument_list|)
operator|)
expr_stmt|;
name|shift64ExtraRightJamming
argument_list|(
name|zSig0
argument_list|,
name|zSig1
argument_list|,
literal|1
operator|-
name|zExp
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|)
expr_stmt|;
name|zExp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isTiny
operator|&&
name|zSig1
condition|)
name|float_raise
argument_list|(
name|float_flag_underflow
argument_list|)
expr_stmt|;
if|if
condition|(
name|zSig1
condition|)
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
if|if
condition|(
name|roundNearestEven
condition|)
block|{
name|increment
operator|=
operator|(
operator|(
name|sbits64
operator|)
name|zSig1
operator|<
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|zSign
condition|)
block|{
name|increment
operator|=
operator|(
name|roundingMode
operator|==
name|float_round_down
operator|)
operator|&&
name|zSig1
expr_stmt|;
block|}
else|else
block|{
name|increment
operator|=
operator|(
name|roundingMode
operator|==
name|float_round_up
operator|)
operator|&&
name|zSig1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|increment
condition|)
block|{
operator|++
name|zSig0
expr_stmt|;
name|zSig0
operator|&=
operator|~
operator|(
operator|(
call|(
name|bits64
call|)
argument_list|(
name|zSig1
operator|<<
literal|1
argument_list|)
operator|==
literal|0
operator|)
operator|&
name|roundNearestEven
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|sbits64
operator|)
name|zSig0
operator|<
literal|0
condition|)
name|zExp
operator|=
literal|1
expr_stmt|;
block|}
return|return
name|packFloatx80
argument_list|(
name|zSign
argument_list|,
name|zExp
argument_list|,
name|zSig0
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|zSig1
condition|)
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
if|if
condition|(
name|increment
condition|)
block|{
operator|++
name|zSig0
expr_stmt|;
if|if
condition|(
name|zSig0
operator|==
literal|0
condition|)
block|{
operator|++
name|zExp
expr_stmt|;
name|zSig0
operator|=
name|LIT64
argument_list|(
literal|0x8000000000000000
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zSig0
operator|&=
operator|~
operator|(
operator|(
call|(
name|bits64
call|)
argument_list|(
name|zSig1
operator|<<
literal|1
argument_list|)
operator|==
literal|0
operator|)
operator|&
name|roundNearestEven
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|zSig0
operator|==
literal|0
condition|)
name|zExp
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|packFloatx80
argument_list|(
name|zSign
argument_list|,
name|zExp
argument_list|,
name|zSig0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Takes an abstract floating-point value having sign `zSign', exponent `zExp', and significand formed by the concatenation of `zSig0' and `zSig1', and returns the proper extended double-precision floating-point value corresponding to the abstract input.  This routine is just like `roundAndPackFloatx80' except that the input significand does not have to be normalized. ------------------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|floatx80
name|normalizeRoundAndPackFloatx80
parameter_list|(
name|int8
name|roundingPrecision
parameter_list|,
name|flag
name|zSign
parameter_list|,
name|int32
name|zExp
parameter_list|,
name|bits64
name|zSig0
parameter_list|,
name|bits64
name|zSig1
parameter_list|)
block|{
name|int8
name|shiftCount
decl_stmt|;
if|if
condition|(
name|zSig0
operator|==
literal|0
condition|)
block|{
name|zSig0
operator|=
name|zSig1
expr_stmt|;
name|zSig1
operator|=
literal|0
expr_stmt|;
name|zExp
operator|-=
literal|64
expr_stmt|;
block|}
name|shiftCount
operator|=
name|countLeadingZeros64
argument_list|(
name|zSig0
argument_list|)
expr_stmt|;
name|shortShift128Left
argument_list|(
name|zSig0
argument_list|,
name|zSig1
argument_list|,
name|shiftCount
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|)
expr_stmt|;
name|zExp
operator|-=
name|shiftCount
expr_stmt|;
return|return
name|roundAndPackFloatx80
argument_list|(
name|roundingPrecision
argument_list|,
name|zSign
argument_list|,
name|zExp
argument_list|,
name|zSig0
argument_list|,
name|zSig1
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|FLOAT128
end_ifdef

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the least-significant 64 fraction bits of the quadruple-precision floating-point value `a'. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|INLINE
name|bits64
name|extractFloat128Frac1
parameter_list|(
name|float128
name|a
parameter_list|)
block|{
return|return
name|a
operator|.
name|low
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the most-significant 48 fraction bits of the quadruple-precision floating-point value `a'. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|INLINE
name|bits64
name|extractFloat128Frac0
parameter_list|(
name|float128
name|a
parameter_list|)
block|{
return|return
name|a
operator|.
name|high
operator|&
name|LIT64
argument_list|(
literal|0x0000FFFFFFFFFFFF
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the exponent bits of the quadruple-precision floating-point value `a'. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|INLINE
name|int32
name|extractFloat128Exp
parameter_list|(
name|float128
name|a
parameter_list|)
block|{
return|return
operator|(
name|a
operator|.
name|high
operator|>>
literal|48
operator|)
operator|&
literal|0x7FFF
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the sign bit of the quadruple-precision floating-point value `a'. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|INLINE
name|flag
name|extractFloat128Sign
parameter_list|(
name|float128
name|a
parameter_list|)
block|{
return|return
name|a
operator|.
name|high
operator|>>
literal|63
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Normalizes the subnormal quadruple-precision floating-point value represented by the denormalized significand formed by the concatenation of `aSig0' and `aSig1'.  The normalized exponent is stored at the location pointed to by `zExpPtr'.  The most significant 49 bits of the normalized significand are stored at the location pointed to by `zSig0Ptr', and the least significant 64 bits of the normalized significand are stored at the location pointed to by `zSig1Ptr'. ------------------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|void
name|normalizeFloat128Subnormal
parameter_list|(
name|bits64
name|aSig0
parameter_list|,
name|bits64
name|aSig1
parameter_list|,
name|int32
modifier|*
name|zExpPtr
parameter_list|,
name|bits64
modifier|*
name|zSig0Ptr
parameter_list|,
name|bits64
modifier|*
name|zSig1Ptr
parameter_list|)
block|{
name|int8
name|shiftCount
decl_stmt|;
if|if
condition|(
name|aSig0
operator|==
literal|0
condition|)
block|{
name|shiftCount
operator|=
name|countLeadingZeros64
argument_list|(
name|aSig1
argument_list|)
operator|-
literal|15
expr_stmt|;
if|if
condition|(
name|shiftCount
operator|<
literal|0
condition|)
block|{
operator|*
name|zSig0Ptr
operator|=
name|aSig1
operator|>>
operator|(
operator|-
name|shiftCount
operator|)
expr_stmt|;
operator|*
name|zSig1Ptr
operator|=
name|aSig1
operator|<<
operator|(
name|shiftCount
operator|&
literal|63
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|zSig0Ptr
operator|=
name|aSig1
operator|<<
name|shiftCount
expr_stmt|;
operator|*
name|zSig1Ptr
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|zExpPtr
operator|=
operator|-
name|shiftCount
operator|-
literal|63
expr_stmt|;
block|}
else|else
block|{
name|shiftCount
operator|=
name|countLeadingZeros64
argument_list|(
name|aSig0
argument_list|)
operator|-
literal|15
expr_stmt|;
name|shortShift128Left
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
name|shiftCount
argument_list|,
name|zSig0Ptr
argument_list|,
name|zSig1Ptr
argument_list|)
expr_stmt|;
operator|*
name|zExpPtr
operator|=
literal|1
operator|-
name|shiftCount
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Packs the sign `zSign', the exponent `zExp', and the significand formed by the concatenation of `zSig0' and `zSig1' into a quadruple-precision floating-point value, returning the result.  After being shifted into the proper positions, the three fields `zSign', `zExp', and `zSig0' are simply added together to form the most significant 32 bits of the result.  This means that any integer portion of `zSig0' will be added into the exponent. Since a properly normalized significand will have an integer portion equal to 1, the `zExp' input should be 1 less than the desired result exponent whenever `zSig0' and `zSig1' concatenated form a complete, normalized significand. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|INLINE
name|float128
name|packFloat128
parameter_list|(
name|flag
name|zSign
parameter_list|,
name|int32
name|zExp
parameter_list|,
name|bits64
name|zSig0
parameter_list|,
name|bits64
name|zSig1
parameter_list|)
block|{
name|float128
name|z
decl_stmt|;
name|z
operator|.
name|low
operator|=
name|zSig1
expr_stmt|;
name|z
operator|.
name|high
operator|=
operator|(
operator|(
operator|(
name|bits64
operator|)
name|zSign
operator|)
operator|<<
literal|63
operator|)
operator|+
operator|(
operator|(
operator|(
name|bits64
operator|)
name|zExp
operator|)
operator|<<
literal|48
operator|)
operator|+
name|zSig0
expr_stmt|;
return|return
name|z
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Takes an abstract floating-point value having sign `zSign', exponent `zExp', and extended significand formed by the concatenation of `zSig0', `zSig1', and `zSig2', and returns the proper quadruple-precision floating-point value corresponding to the abstract input.  Ordinarily, the abstract value is simply rounded and packed into the quadruple-precision format, with the inexact exception raised if the abstract input cannot be represented exactly.  However, if the abstract value is too large, the overflow and inexact exceptions are raised and an infinity or maximal finite value is returned.  If the abstract value is too small, the input value is rounded to a subnormal number, and the underflow and inexact exceptions are raised if the abstract input cannot be represented exactly as a subnormal quadruple- precision floating-point number.     The input significand must be normalized or smaller.  If the input significand is not normalized, `zExp' must be 0; in that case, the result returned is a subnormal number, and it must not require rounding.  In the usual case that the input significand is normalized, `zExp' must be 1 less than the ``true'' floating-point exponent.  The handling of underflow and overflow follows the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|float128
name|roundAndPackFloat128
parameter_list|(
name|flag
name|zSign
parameter_list|,
name|int32
name|zExp
parameter_list|,
name|bits64
name|zSig0
parameter_list|,
name|bits64
name|zSig1
parameter_list|,
name|bits64
name|zSig2
parameter_list|)
block|{
name|int8
name|roundingMode
decl_stmt|;
name|flag
name|roundNearestEven
decl_stmt|,
name|increment
decl_stmt|,
name|isTiny
decl_stmt|;
name|roundingMode
operator|=
name|float_rounding_mode
expr_stmt|;
name|roundNearestEven
operator|=
operator|(
name|roundingMode
operator|==
name|float_round_nearest_even
operator|)
expr_stmt|;
name|increment
operator|=
operator|(
operator|(
name|sbits64
operator|)
name|zSig2
operator|<
literal|0
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|roundNearestEven
condition|)
block|{
if|if
condition|(
name|roundingMode
operator|==
name|float_round_to_zero
condition|)
block|{
name|increment
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|zSign
condition|)
block|{
name|increment
operator|=
operator|(
name|roundingMode
operator|==
name|float_round_down
operator|)
operator|&&
name|zSig2
expr_stmt|;
block|}
else|else
block|{
name|increment
operator|=
operator|(
name|roundingMode
operator|==
name|float_round_up
operator|)
operator|&&
name|zSig2
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
literal|0x7FFD
operator|<=
operator|(
name|bits32
operator|)
name|zExp
condition|)
block|{
if|if
condition|(
operator|(
literal|0x7FFD
operator|<
name|zExp
operator|)
operator|||
operator|(
operator|(
name|zExp
operator|==
literal|0x7FFD
operator|)
operator|&&
name|eq128
argument_list|(
name|LIT64
argument_list|(
literal|0x0001FFFFFFFFFFFF
argument_list|)
argument_list|,
name|LIT64
argument_list|(
literal|0xFFFFFFFFFFFFFFFF
argument_list|)
argument_list|,
name|zSig0
argument_list|,
name|zSig1
argument_list|)
operator|&&
name|increment
operator|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_overflow
operator||
name|float_flag_inexact
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|roundingMode
operator|==
name|float_round_to_zero
operator|)
operator|||
operator|(
name|zSign
operator|&&
operator|(
name|roundingMode
operator|==
name|float_round_up
operator|)
operator|)
operator|||
operator|(
operator|!
name|zSign
operator|&&
operator|(
name|roundingMode
operator|==
name|float_round_down
operator|)
operator|)
condition|)
block|{
return|return
name|packFloat128
argument_list|(
name|zSign
argument_list|,
literal|0x7FFE
argument_list|,
name|LIT64
argument_list|(
literal|0x0000FFFFFFFFFFFF
argument_list|)
argument_list|,
name|LIT64
argument_list|(
literal|0xFFFFFFFFFFFFFFFF
argument_list|)
argument_list|)
return|;
block|}
return|return
name|packFloat128
argument_list|(
name|zSign
argument_list|,
literal|0x7FFF
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|zExp
operator|<
literal|0
condition|)
block|{
name|isTiny
operator|=
operator|(
name|float_detect_tininess
operator|==
name|float_tininess_before_rounding
operator|)
operator|||
operator|(
name|zExp
operator|<
operator|-
literal|1
operator|)
operator|||
operator|!
name|increment
operator|||
name|lt128
argument_list|(
name|zSig0
argument_list|,
name|zSig1
argument_list|,
name|LIT64
argument_list|(
literal|0x0001FFFFFFFFFFFF
argument_list|)
argument_list|,
name|LIT64
argument_list|(
literal|0xFFFFFFFFFFFFFFFF
argument_list|)
argument_list|)
expr_stmt|;
name|shift128ExtraRightJamming
argument_list|(
name|zSig0
argument_list|,
name|zSig1
argument_list|,
name|zSig2
argument_list|,
operator|-
name|zExp
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|,
operator|&
name|zSig2
argument_list|)
expr_stmt|;
name|zExp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|isTiny
operator|&&
name|zSig2
condition|)
name|float_raise
argument_list|(
name|float_flag_underflow
argument_list|)
expr_stmt|;
if|if
condition|(
name|roundNearestEven
condition|)
block|{
name|increment
operator|=
operator|(
operator|(
name|sbits64
operator|)
name|zSig2
operator|<
literal|0
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|zSign
condition|)
block|{
name|increment
operator|=
operator|(
name|roundingMode
operator|==
name|float_round_down
operator|)
operator|&&
name|zSig2
expr_stmt|;
block|}
else|else
block|{
name|increment
operator|=
operator|(
name|roundingMode
operator|==
name|float_round_up
operator|)
operator|&&
name|zSig2
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|zSig2
condition|)
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
if|if
condition|(
name|increment
condition|)
block|{
name|add128
argument_list|(
name|zSig0
argument_list|,
name|zSig1
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|)
expr_stmt|;
name|zSig1
operator|&=
operator|~
operator|(
operator|(
name|zSig2
operator|+
name|zSig2
operator|==
literal|0
operator|)
operator|&
name|roundNearestEven
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|zSig0
operator||
name|zSig1
operator|)
operator|==
literal|0
condition|)
name|zExp
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|packFloat128
argument_list|(
name|zSign
argument_list|,
name|zExp
argument_list|,
name|zSig0
argument_list|,
name|zSig1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Takes an abstract floating-point value having sign `zSign', exponent `zExp', and significand formed by the concatenation of `zSig0' and `zSig1', and returns the proper quadruple-precision floating-point value corresponding to the abstract input.  This routine is just like `roundAndPackFloat128' except that the input significand has fewer bits and does not have to be normalized.  In all cases, `zExp' must be 1 less than the ``true'' floating- point exponent. ------------------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|float128
name|normalizeRoundAndPackFloat128
parameter_list|(
name|flag
name|zSign
parameter_list|,
name|int32
name|zExp
parameter_list|,
name|bits64
name|zSig0
parameter_list|,
name|bits64
name|zSig1
parameter_list|)
block|{
name|int8
name|shiftCount
decl_stmt|;
name|bits64
name|zSig2
decl_stmt|;
if|if
condition|(
name|zSig0
operator|==
literal|0
condition|)
block|{
name|zSig0
operator|=
name|zSig1
expr_stmt|;
name|zSig1
operator|=
literal|0
expr_stmt|;
name|zExp
operator|-=
literal|64
expr_stmt|;
block|}
name|shiftCount
operator|=
name|countLeadingZeros64
argument_list|(
name|zSig0
argument_list|)
operator|-
literal|15
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|shiftCount
condition|)
block|{
name|zSig2
operator|=
literal|0
expr_stmt|;
name|shortShift128Left
argument_list|(
name|zSig0
argument_list|,
name|zSig1
argument_list|,
name|shiftCount
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|shift128ExtraRightJamming
argument_list|(
name|zSig0
argument_list|,
name|zSig1
argument_list|,
literal|0
argument_list|,
operator|-
name|shiftCount
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|,
operator|&
name|zSig2
argument_list|)
expr_stmt|;
block|}
name|zExp
operator|-=
name|shiftCount
expr_stmt|;
return|return
name|roundAndPackFloat128
argument_list|(
name|zSign
argument_list|,
name|zExp
argument_list|,
name|zSig0
argument_list|,
name|zSig1
argument_list|,
name|zSig2
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the 32-bit two's complement integer `a' to the single-precision floating-point format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float32
name|int32_to_float32
parameter_list|(
name|int32
name|a
parameter_list|)
block|{
name|flag
name|zSign
decl_stmt|;
if|if
condition|(
name|a
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|a
operator|==
operator|(
name|sbits32
operator|)
literal|0x80000000
condition|)
return|return
name|packFloat32
argument_list|(
literal|1
argument_list|,
literal|0x9E
argument_list|,
literal|0
argument_list|)
return|;
name|zSign
operator|=
operator|(
name|a
operator|<
literal|0
operator|)
expr_stmt|;
return|return
name|normalizeRoundAndPackFloat32
argument_list|(
name|zSign
argument_list|,
literal|0x9C
argument_list|,
name|zSign
condition|?
operator|-
name|a
else|:
name|a
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the 32-bit two's complement integer `a' to the double-precision floating-point format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float64
name|int32_to_float64
parameter_list|(
name|int32
name|a
parameter_list|)
block|{
name|flag
name|zSign
decl_stmt|;
name|uint32
name|absA
decl_stmt|;
name|int8
name|shiftCount
decl_stmt|;
name|bits64
name|zSig
decl_stmt|;
if|if
condition|(
name|a
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|zSign
operator|=
operator|(
name|a
operator|<
literal|0
operator|)
expr_stmt|;
name|absA
operator|=
name|zSign
condition|?
operator|-
name|a
else|:
name|a
expr_stmt|;
name|shiftCount
operator|=
name|countLeadingZeros32
argument_list|(
name|absA
argument_list|)
operator|+
literal|21
expr_stmt|;
name|zSig
operator|=
name|absA
expr_stmt|;
return|return
name|packFloat64
argument_list|(
name|zSign
argument_list|,
literal|0x432
operator|-
name|shiftCount
argument_list|,
name|zSig
operator|<<
name|shiftCount
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FLOATX80
end_ifdef

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the 32-bit two's complement integer `a' to the extended double-precision floating-point format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|floatx80
name|int32_to_floatx80
parameter_list|(
name|int32
name|a
parameter_list|)
block|{
name|flag
name|zSign
decl_stmt|;
name|uint32
name|absA
decl_stmt|;
name|int8
name|shiftCount
decl_stmt|;
name|bits64
name|zSig
decl_stmt|;
if|if
condition|(
name|a
operator|==
literal|0
condition|)
return|return
name|packFloatx80
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|zSign
operator|=
operator|(
name|a
operator|<
literal|0
operator|)
expr_stmt|;
name|absA
operator|=
name|zSign
condition|?
operator|-
name|a
else|:
name|a
expr_stmt|;
name|shiftCount
operator|=
name|countLeadingZeros32
argument_list|(
name|absA
argument_list|)
operator|+
literal|32
expr_stmt|;
name|zSig
operator|=
name|absA
expr_stmt|;
return|return
name|packFloatx80
argument_list|(
name|zSign
argument_list|,
literal|0x403E
operator|-
name|shiftCount
argument_list|,
name|zSig
operator|<<
name|shiftCount
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|FLOAT128
end_ifdef

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the 32-bit two's complement integer `a' to the quadruple-precision floating-point format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float128
name|int32_to_float128
parameter_list|(
name|int32
name|a
parameter_list|)
block|{
name|flag
name|zSign
decl_stmt|;
name|uint32
name|absA
decl_stmt|;
name|int8
name|shiftCount
decl_stmt|;
name|bits64
name|zSig0
decl_stmt|;
if|if
condition|(
name|a
operator|==
literal|0
condition|)
return|return
name|packFloat128
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|zSign
operator|=
operator|(
name|a
operator|<
literal|0
operator|)
expr_stmt|;
name|absA
operator|=
name|zSign
condition|?
operator|-
name|a
else|:
name|a
expr_stmt|;
name|shiftCount
operator|=
name|countLeadingZeros32
argument_list|(
name|absA
argument_list|)
operator|+
literal|17
expr_stmt|;
name|zSig0
operator|=
name|absA
expr_stmt|;
return|return
name|packFloat128
argument_list|(
name|zSign
argument_list|,
literal|0x402E
operator|-
name|shiftCount
argument_list|,
name|zSig0
operator|<<
name|shiftCount
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SOFTFLOAT_FOR_GCC
end_ifndef

begin_comment
comment|/* __floatdi?f is in libgcc2.c */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the 64-bit two's complement integer `a' to the single-precision floating-point format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float32
name|int64_to_float32
parameter_list|(
name|int64
name|a
parameter_list|)
block|{
name|flag
name|zSign
decl_stmt|;
name|uint64
name|absA
decl_stmt|;
name|int8
name|shiftCount
decl_stmt|;
if|if
condition|(
name|a
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|zSign
operator|=
operator|(
name|a
operator|<
literal|0
operator|)
expr_stmt|;
name|absA
operator|=
name|zSign
condition|?
operator|-
name|a
else|:
name|a
expr_stmt|;
name|shiftCount
operator|=
name|countLeadingZeros64
argument_list|(
name|absA
argument_list|)
operator|-
literal|40
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|shiftCount
condition|)
block|{
return|return
name|packFloat32
argument_list|(
name|zSign
argument_list|,
literal|0x95
operator|-
name|shiftCount
argument_list|,
name|absA
operator|<<
name|shiftCount
argument_list|)
return|;
block|}
else|else
block|{
name|shiftCount
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
name|shiftCount
operator|<
literal|0
condition|)
block|{
name|shift64RightJamming
argument_list|(
name|absA
argument_list|,
operator|-
name|shiftCount
argument_list|,
operator|&
name|absA
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|absA
operator|<<=
name|shiftCount
expr_stmt|;
block|}
return|return
name|roundAndPackFloat32
argument_list|(
name|zSign
argument_list|,
literal|0x9C
operator|-
name|shiftCount
argument_list|,
name|absA
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the 64-bit two's complement integer `a' to the double-precision floating-point format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float64
name|int64_to_float64
parameter_list|(
name|int64
name|a
parameter_list|)
block|{
name|flag
name|zSign
decl_stmt|;
if|if
condition|(
name|a
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|a
operator|==
operator|(
name|sbits64
operator|)
name|LIT64
argument_list|(
literal|0x8000000000000000
argument_list|)
condition|)
block|{
return|return
name|packFloat64
argument_list|(
literal|1
argument_list|,
literal|0x43E
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|zSign
operator|=
operator|(
name|a
operator|<
literal|0
operator|)
expr_stmt|;
return|return
name|normalizeRoundAndPackFloat64
argument_list|(
name|zSign
argument_list|,
literal|0x43C
argument_list|,
name|zSign
condition|?
operator|-
name|a
else|:
name|a
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FLOATX80
end_ifdef

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the 64-bit two's complement integer `a' to the extended double-precision floating-point format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|floatx80
name|int64_to_floatx80
parameter_list|(
name|int64
name|a
parameter_list|)
block|{
name|flag
name|zSign
decl_stmt|;
name|uint64
name|absA
decl_stmt|;
name|int8
name|shiftCount
decl_stmt|;
if|if
condition|(
name|a
operator|==
literal|0
condition|)
return|return
name|packFloatx80
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|zSign
operator|=
operator|(
name|a
operator|<
literal|0
operator|)
expr_stmt|;
name|absA
operator|=
name|zSign
condition|?
operator|-
name|a
else|:
name|a
expr_stmt|;
name|shiftCount
operator|=
name|countLeadingZeros64
argument_list|(
name|absA
argument_list|)
expr_stmt|;
return|return
name|packFloatx80
argument_list|(
name|zSign
argument_list|,
literal|0x403E
operator|-
name|shiftCount
argument_list|,
name|absA
operator|<<
name|shiftCount
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SOFTFLOAT_FOR_GCC */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|FLOAT128
end_ifdef

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the 64-bit two's complement integer `a' to the quadruple-precision floating-point format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float128
name|int64_to_float128
parameter_list|(
name|int64
name|a
parameter_list|)
block|{
name|flag
name|zSign
decl_stmt|;
name|uint64
name|absA
decl_stmt|;
name|int8
name|shiftCount
decl_stmt|;
name|int32
name|zExp
decl_stmt|;
name|bits64
name|zSig0
decl_stmt|,
name|zSig1
decl_stmt|;
if|if
condition|(
name|a
operator|==
literal|0
condition|)
return|return
name|packFloat128
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|zSign
operator|=
operator|(
name|a
operator|<
literal|0
operator|)
expr_stmt|;
name|absA
operator|=
name|zSign
condition|?
operator|-
name|a
else|:
name|a
expr_stmt|;
name|shiftCount
operator|=
name|countLeadingZeros64
argument_list|(
name|absA
argument_list|)
operator|+
literal|49
expr_stmt|;
name|zExp
operator|=
literal|0x406E
operator|-
name|shiftCount
expr_stmt|;
if|if
condition|(
literal|64
operator|<=
name|shiftCount
condition|)
block|{
name|zSig1
operator|=
literal|0
expr_stmt|;
name|zSig0
operator|=
name|absA
expr_stmt|;
name|shiftCount
operator|-=
literal|64
expr_stmt|;
block|}
else|else
block|{
name|zSig1
operator|=
name|absA
expr_stmt|;
name|zSig0
operator|=
literal|0
expr_stmt|;
block|}
name|shortShift128Left
argument_list|(
name|zSig0
argument_list|,
name|zSig1
argument_list|,
name|shiftCount
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|)
expr_stmt|;
return|return
name|packFloat128
argument_list|(
name|zSign
argument_list|,
name|zExp
argument_list|,
name|zSig0
argument_list|,
name|zSig1
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SOFTFLOAT_FOR_GCC
end_ifndef

begin_comment
comment|/* Not needed */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the single-precision floating-point value `a' to the 32-bit two's complement integer format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic---which means in particular that the conversion is rounded according to the current rounding mode.  If `a' is a NaN, the largest positive integer is returned.  Otherwise, if the conversion overflows, the largest integer with the same sign as `a' is returned. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|int32
name|float32_to_int32
parameter_list|(
name|float32
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|,
name|shiftCount
decl_stmt|;
name|bits32
name|aSig
decl_stmt|;
name|bits64
name|aSig64
decl_stmt|;
name|aSig
operator|=
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat32Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat32Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|aExp
operator|==
literal|0xFF
operator|)
operator|&&
name|aSig
condition|)
name|aSign
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|aExp
condition|)
name|aSig
operator||=
literal|0x00800000
expr_stmt|;
name|shiftCount
operator|=
literal|0xAF
operator|-
name|aExp
expr_stmt|;
name|aSig64
operator|=
name|aSig
expr_stmt|;
name|aSig64
operator|<<=
literal|32
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|shiftCount
condition|)
name|shift64RightJamming
argument_list|(
name|aSig64
argument_list|,
name|shiftCount
argument_list|,
operator|&
name|aSig64
argument_list|)
expr_stmt|;
return|return
name|roundAndPackInt32
argument_list|(
name|aSign
argument_list|,
name|aSig64
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SOFTFLOAT_FOR_GCC */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the single-precision floating-point value `a' to the 32-bit two's complement integer format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic, except that the conversion is always rounded toward zero. If `a' is a NaN, the largest positive integer is returned.  Otherwise, if the conversion overflows, the largest integer with the same sign as `a' is returned. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|int32
name|float32_to_int32_round_to_zero
parameter_list|(
name|float32
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|,
name|shiftCount
decl_stmt|;
name|bits32
name|aSig
decl_stmt|;
name|int32
name|z
decl_stmt|;
name|aSig
operator|=
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat32Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat32Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|shiftCount
operator|=
name|aExp
operator|-
literal|0x9E
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|shiftCount
condition|)
block|{
if|if
condition|(
name|a
operator|!=
literal|0xCF000000
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aSign
operator|||
operator|(
operator|(
name|aExp
operator|==
literal|0xFF
operator|)
operator|&&
name|aSig
operator|)
condition|)
return|return
literal|0x7FFFFFFF
return|;
block|}
return|return
operator|(
name|sbits32
operator|)
literal|0x80000000
return|;
block|}
elseif|else
if|if
condition|(
name|aExp
operator|<=
literal|0x7E
condition|)
block|{
if|if
condition|(
name|aExp
operator||
name|aSig
condition|)
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
return|return
literal|0
return|;
block|}
name|aSig
operator|=
operator|(
name|aSig
operator||
literal|0x00800000
operator|)
operator|<<
literal|8
expr_stmt|;
name|z
operator|=
name|aSig
operator|>>
operator|(
operator|-
name|shiftCount
operator|)
expr_stmt|;
if|if
condition|(
call|(
name|bits32
call|)
argument_list|(
name|aSig
operator|<<
operator|(
name|shiftCount
operator|&
literal|31
operator|)
argument_list|)
condition|)
block|{
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
block|}
if|if
condition|(
name|aSign
condition|)
name|z
operator|=
operator|-
name|z
expr_stmt|;
return|return
name|z
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SOFTFLOAT_FOR_GCC
end_ifndef

begin_comment
comment|/* __fix?fdi provided by libgcc2.c */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the single-precision floating-point value `a' to the 64-bit two's complement integer format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic---which means in particular that the conversion is rounded according to the current rounding mode.  If `a' is a NaN, the largest positive integer is returned.  Otherwise, if the conversion overflows, the largest integer with the same sign as `a' is returned. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|int64
name|float32_to_int64
parameter_list|(
name|float32
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|,
name|shiftCount
decl_stmt|;
name|bits32
name|aSig
decl_stmt|;
name|bits64
name|aSig64
decl_stmt|,
name|aSigExtra
decl_stmt|;
name|aSig
operator|=
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat32Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat32Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|shiftCount
operator|=
literal|0xBE
operator|-
name|aExp
expr_stmt|;
if|if
condition|(
name|shiftCount
operator|<
literal|0
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aSign
operator|||
operator|(
operator|(
name|aExp
operator|==
literal|0xFF
operator|)
operator|&&
name|aSig
operator|)
condition|)
block|{
return|return
name|LIT64
argument_list|(
literal|0x7FFFFFFFFFFFFFFF
argument_list|)
return|;
block|}
return|return
operator|(
name|sbits64
operator|)
name|LIT64
argument_list|(
literal|0x8000000000000000
argument_list|)
return|;
block|}
if|if
condition|(
name|aExp
condition|)
name|aSig
operator||=
literal|0x00800000
expr_stmt|;
name|aSig64
operator|=
name|aSig
expr_stmt|;
name|aSig64
operator|<<=
literal|40
expr_stmt|;
name|shift64ExtraRightJamming
argument_list|(
name|aSig64
argument_list|,
literal|0
argument_list|,
name|shiftCount
argument_list|,
operator|&
name|aSig64
argument_list|,
operator|&
name|aSigExtra
argument_list|)
expr_stmt|;
return|return
name|roundAndPackInt64
argument_list|(
name|aSign
argument_list|,
name|aSig64
argument_list|,
name|aSigExtra
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the single-precision floating-point value `a' to the 64-bit two's complement integer format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic, except that the conversion is always rounded toward zero.  If `a' is a NaN, the largest positive integer is returned.  Otherwise, if the conversion overflows, the largest integer with the same sign as `a' is returned. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|int64
name|float32_to_int64_round_to_zero
parameter_list|(
name|float32
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|,
name|shiftCount
decl_stmt|;
name|bits32
name|aSig
decl_stmt|;
name|bits64
name|aSig64
decl_stmt|;
name|int64
name|z
decl_stmt|;
name|aSig
operator|=
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat32Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat32Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|shiftCount
operator|=
name|aExp
operator|-
literal|0xBE
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|shiftCount
condition|)
block|{
if|if
condition|(
name|a
operator|!=
literal|0xDF000000
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aSign
operator|||
operator|(
operator|(
name|aExp
operator|==
literal|0xFF
operator|)
operator|&&
name|aSig
operator|)
condition|)
block|{
return|return
name|LIT64
argument_list|(
literal|0x7FFFFFFFFFFFFFFF
argument_list|)
return|;
block|}
block|}
return|return
operator|(
name|sbits64
operator|)
name|LIT64
argument_list|(
literal|0x8000000000000000
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|aExp
operator|<=
literal|0x7E
condition|)
block|{
if|if
condition|(
name|aExp
operator||
name|aSig
condition|)
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
return|return
literal|0
return|;
block|}
name|aSig64
operator|=
name|aSig
operator||
literal|0x00800000
expr_stmt|;
name|aSig64
operator|<<=
literal|40
expr_stmt|;
name|z
operator|=
name|aSig64
operator|>>
operator|(
operator|-
name|shiftCount
operator|)
expr_stmt|;
if|if
condition|(
call|(
name|bits64
call|)
argument_list|(
name|aSig64
operator|<<
operator|(
name|shiftCount
operator|&
literal|63
operator|)
argument_list|)
condition|)
block|{
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
block|}
if|if
condition|(
name|aSign
condition|)
name|z
operator|=
operator|-
name|z
expr_stmt|;
return|return
name|z
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SOFTFLOAT_FOR_GCC */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the single-precision floating-point value `a' to the double-precision floating-point format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float64
name|float32_to_float64
parameter_list|(
name|float32
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|;
name|bits32
name|aSig
decl_stmt|;
name|aSig
operator|=
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat32Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat32Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0xFF
condition|)
block|{
if|if
condition|(
name|aSig
condition|)
return|return
name|commonNaNToFloat64
argument_list|(
name|float32ToCommonNaN
argument_list|(
name|a
argument_list|)
argument_list|)
return|;
return|return
name|packFloat64
argument_list|(
name|aSign
argument_list|,
literal|0x7FF
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|aSig
operator|==
literal|0
condition|)
return|return
name|packFloat64
argument_list|(
name|aSign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|normalizeFloat32Subnormal
argument_list|(
name|aSig
argument_list|,
operator|&
name|aExp
argument_list|,
operator|&
name|aSig
argument_list|)
expr_stmt|;
operator|--
name|aExp
expr_stmt|;
block|}
return|return
name|packFloat64
argument_list|(
name|aSign
argument_list|,
name|aExp
operator|+
literal|0x380
argument_list|,
operator|(
operator|(
name|bits64
operator|)
name|aSig
operator|)
operator|<<
literal|29
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FLOATX80
end_ifdef

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the single-precision floating-point value `a' to the extended double-precision floating-point format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|floatx80
name|float32_to_floatx80
parameter_list|(
name|float32
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|;
name|bits32
name|aSig
decl_stmt|;
name|aSig
operator|=
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat32Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat32Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0xFF
condition|)
block|{
if|if
condition|(
name|aSig
condition|)
return|return
name|commonNaNToFloatx80
argument_list|(
name|float32ToCommonNaN
argument_list|(
name|a
argument_list|)
argument_list|)
return|;
return|return
name|packFloatx80
argument_list|(
name|aSign
argument_list|,
literal|0x7FFF
argument_list|,
name|LIT64
argument_list|(
literal|0x8000000000000000
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|aSig
operator|==
literal|0
condition|)
return|return
name|packFloatx80
argument_list|(
name|aSign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|normalizeFloat32Subnormal
argument_list|(
name|aSig
argument_list|,
operator|&
name|aExp
argument_list|,
operator|&
name|aSig
argument_list|)
expr_stmt|;
block|}
name|aSig
operator||=
literal|0x00800000
expr_stmt|;
return|return
name|packFloatx80
argument_list|(
name|aSign
argument_list|,
name|aExp
operator|+
literal|0x3F80
argument_list|,
operator|(
operator|(
name|bits64
operator|)
name|aSig
operator|)
operator|<<
literal|40
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|FLOAT128
end_ifdef

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the single-precision floating-point value `a' to the double-precision floating-point format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float128
name|float32_to_float128
parameter_list|(
name|float32
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|;
name|bits32
name|aSig
decl_stmt|;
name|aSig
operator|=
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat32Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat32Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0xFF
condition|)
block|{
if|if
condition|(
name|aSig
condition|)
return|return
name|commonNaNToFloat128
argument_list|(
name|float32ToCommonNaN
argument_list|(
name|a
argument_list|)
argument_list|)
return|;
return|return
name|packFloat128
argument_list|(
name|aSign
argument_list|,
literal|0x7FFF
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|aSig
operator|==
literal|0
condition|)
return|return
name|packFloat128
argument_list|(
name|aSign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|normalizeFloat32Subnormal
argument_list|(
name|aSig
argument_list|,
operator|&
name|aExp
argument_list|,
operator|&
name|aSig
argument_list|)
expr_stmt|;
operator|--
name|aExp
expr_stmt|;
block|}
return|return
name|packFloat128
argument_list|(
name|aSign
argument_list|,
name|aExp
operator|+
literal|0x3F80
argument_list|,
operator|(
operator|(
name|bits64
operator|)
name|aSig
operator|)
operator|<<
literal|25
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SOFTFLOAT_FOR_GCC
end_ifndef

begin_comment
comment|/* Not needed */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------------- Rounds the single-precision floating-point value `a' to an integer, and returns the result as a single-precision floating-point value.  The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float32
name|float32_round_to_int
parameter_list|(
name|float32
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|;
name|bits32
name|lastBitMask
decl_stmt|,
name|roundBitsMask
decl_stmt|;
name|int8
name|roundingMode
decl_stmt|;
name|float32
name|z
decl_stmt|;
name|aExp
operator|=
name|extractFloat32Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0x96
operator|<=
name|aExp
condition|)
block|{
if|if
condition|(
operator|(
name|aExp
operator|==
literal|0xFF
operator|)
operator|&&
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
condition|)
block|{
return|return
name|propagateFloat32NaN
argument_list|(
name|a
argument_list|,
name|a
argument_list|)
return|;
block|}
return|return
name|a
return|;
block|}
if|if
condition|(
name|aExp
operator|<=
literal|0x7E
condition|)
block|{
if|if
condition|(
call|(
name|bits32
call|)
argument_list|(
name|a
operator|<<
literal|1
argument_list|)
operator|==
literal|0
condition|)
return|return
name|a
return|;
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
name|aSign
operator|=
name|extractFloat32Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|float_rounding_mode
condition|)
block|{
case|case
name|float_round_nearest_even
case|:
if|if
condition|(
operator|(
name|aExp
operator|==
literal|0x7E
operator|)
operator|&&
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
condition|)
block|{
return|return
name|packFloat32
argument_list|(
name|aSign
argument_list|,
literal|0x7F
argument_list|,
literal|0
argument_list|)
return|;
block|}
break|break;
case|case
name|float_round_to_zero
case|:
break|break;
case|case
name|float_round_down
case|:
return|return
name|aSign
condition|?
literal|0xBF800000
else|:
literal|0
return|;
case|case
name|float_round_up
case|:
return|return
name|aSign
condition|?
literal|0x80000000
else|:
literal|0x3F800000
return|;
block|}
return|return
name|packFloat32
argument_list|(
name|aSign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|lastBitMask
operator|=
literal|1
expr_stmt|;
name|lastBitMask
operator|<<=
literal|0x96
operator|-
name|aExp
expr_stmt|;
name|roundBitsMask
operator|=
name|lastBitMask
operator|-
literal|1
expr_stmt|;
name|z
operator|=
name|a
expr_stmt|;
name|roundingMode
operator|=
name|float_rounding_mode
expr_stmt|;
if|if
condition|(
name|roundingMode
operator|==
name|float_round_nearest_even
condition|)
block|{
name|z
operator|+=
name|lastBitMask
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|z
operator|&
name|roundBitsMask
operator|)
operator|==
literal|0
condition|)
name|z
operator|&=
operator|~
name|lastBitMask
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|roundingMode
operator|!=
name|float_round_to_zero
condition|)
block|{
if|if
condition|(
name|extractFloat32Sign
argument_list|(
name|z
argument_list|)
operator|^
operator|(
name|roundingMode
operator|==
name|float_round_up
operator|)
condition|)
block|{
name|z
operator|+=
name|roundBitsMask
expr_stmt|;
block|}
block|}
name|z
operator|&=
operator|~
name|roundBitsMask
expr_stmt|;
if|if
condition|(
name|z
operator|!=
name|a
condition|)
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
return|return
name|z
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SOFTFLOAT_FOR_GCC */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of adding the absolute values of the single-precision floating-point values `a' and `b'.  If `zSign' is 1, the sum is negated before being returned.  `zSign' is ignored if the result is a NaN. The addition is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|float32
name|addFloat32Sigs
parameter_list|(
name|float32
name|a
parameter_list|,
name|float32
name|b
parameter_list|,
name|flag
name|zSign
parameter_list|)
block|{
name|int16
name|aExp
decl_stmt|,
name|bExp
decl_stmt|,
name|zExp
decl_stmt|;
name|bits32
name|aSig
decl_stmt|,
name|bSig
decl_stmt|,
name|zSig
decl_stmt|;
name|int16
name|expDiff
decl_stmt|;
name|aSig
operator|=
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat32Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSig
operator|=
name|extractFloat32Frac
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bExp
operator|=
name|extractFloat32Exp
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|expDiff
operator|=
name|aExp
operator|-
name|bExp
expr_stmt|;
name|aSig
operator|<<=
literal|6
expr_stmt|;
name|bSig
operator|<<=
literal|6
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|expDiff
condition|)
block|{
if|if
condition|(
name|aExp
operator|==
literal|0xFF
condition|)
block|{
if|if
condition|(
name|aSig
condition|)
return|return
name|propagateFloat32NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|a
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0
condition|)
block|{
operator|--
name|expDiff
expr_stmt|;
block|}
else|else
block|{
name|bSig
operator||=
literal|0x20000000
expr_stmt|;
block|}
name|shift32RightJamming
argument_list|(
name|bSig
argument_list|,
name|expDiff
argument_list|,
operator|&
name|bSig
argument_list|)
expr_stmt|;
name|zExp
operator|=
name|aExp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expDiff
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|bExp
operator|==
literal|0xFF
condition|)
block|{
if|if
condition|(
name|bSig
condition|)
return|return
name|propagateFloat32NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|packFloat32
argument_list|(
name|zSign
argument_list|,
literal|0xFF
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
operator|++
name|expDiff
expr_stmt|;
block|}
else|else
block|{
name|aSig
operator||=
literal|0x20000000
expr_stmt|;
block|}
name|shift32RightJamming
argument_list|(
name|aSig
argument_list|,
operator|-
name|expDiff
argument_list|,
operator|&
name|aSig
argument_list|)
expr_stmt|;
name|zExp
operator|=
name|bExp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|aExp
operator|==
literal|0xFF
condition|)
block|{
if|if
condition|(
name|aSig
operator||
name|bSig
condition|)
return|return
name|propagateFloat32NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|a
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
return|return
name|packFloat32
argument_list|(
name|zSign
argument_list|,
literal|0
argument_list|,
operator|(
name|aSig
operator|+
name|bSig
operator|)
operator|>>
literal|6
argument_list|)
return|;
name|zSig
operator|=
literal|0x40000000
operator|+
name|aSig
operator|+
name|bSig
expr_stmt|;
name|zExp
operator|=
name|aExp
expr_stmt|;
goto|goto
name|roundAndPack
goto|;
block|}
name|aSig
operator||=
literal|0x20000000
expr_stmt|;
name|zSig
operator|=
operator|(
name|aSig
operator|+
name|bSig
operator|)
operator|<<
literal|1
expr_stmt|;
operator|--
name|zExp
expr_stmt|;
if|if
condition|(
operator|(
name|sbits32
operator|)
name|zSig
operator|<
literal|0
condition|)
block|{
name|zSig
operator|=
name|aSig
operator|+
name|bSig
expr_stmt|;
operator|++
name|zExp
expr_stmt|;
block|}
name|roundAndPack
label|:
return|return
name|roundAndPackFloat32
argument_list|(
name|zSign
argument_list|,
name|zExp
argument_list|,
name|zSig
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of subtracting the absolute values of the single- precision floating-point values `a' and `b'.  If `zSign' is 1, the difference is negated before being returned.  `zSign' is ignored if the result is a NaN.  The subtraction is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|float32
name|subFloat32Sigs
parameter_list|(
name|float32
name|a
parameter_list|,
name|float32
name|b
parameter_list|,
name|flag
name|zSign
parameter_list|)
block|{
name|int16
name|aExp
decl_stmt|,
name|bExp
decl_stmt|,
name|zExp
decl_stmt|;
name|bits32
name|aSig
decl_stmt|,
name|bSig
decl_stmt|,
name|zSig
decl_stmt|;
name|int16
name|expDiff
decl_stmt|;
name|aSig
operator|=
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat32Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSig
operator|=
name|extractFloat32Frac
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bExp
operator|=
name|extractFloat32Exp
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|expDiff
operator|=
name|aExp
operator|-
name|bExp
expr_stmt|;
name|aSig
operator|<<=
literal|7
expr_stmt|;
name|bSig
operator|<<=
literal|7
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|expDiff
condition|)
goto|goto
name|aExpBigger
goto|;
if|if
condition|(
name|expDiff
operator|<
literal|0
condition|)
goto|goto
name|bExpBigger
goto|;
if|if
condition|(
name|aExp
operator|==
literal|0xFF
condition|)
block|{
if|if
condition|(
name|aSig
operator||
name|bSig
condition|)
return|return
name|propagateFloat32NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|float32_default_nan
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
name|aExp
operator|=
literal|1
expr_stmt|;
name|bExp
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bSig
operator|<
name|aSig
condition|)
goto|goto
name|aBigger
goto|;
if|if
condition|(
name|aSig
operator|<
name|bSig
condition|)
goto|goto
name|bBigger
goto|;
return|return
name|packFloat32
argument_list|(
name|float_rounding_mode
operator|==
name|float_round_down
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|bExpBigger
label|:
if|if
condition|(
name|bExp
operator|==
literal|0xFF
condition|)
block|{
if|if
condition|(
name|bSig
condition|)
return|return
name|propagateFloat32NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|packFloat32
argument_list|(
name|zSign
operator|^
literal|1
argument_list|,
literal|0xFF
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
operator|++
name|expDiff
expr_stmt|;
block|}
else|else
block|{
name|aSig
operator||=
literal|0x40000000
expr_stmt|;
block|}
name|shift32RightJamming
argument_list|(
name|aSig
argument_list|,
operator|-
name|expDiff
argument_list|,
operator|&
name|aSig
argument_list|)
expr_stmt|;
name|bSig
operator||=
literal|0x40000000
expr_stmt|;
name|bBigger
label|:
name|zSig
operator|=
name|bSig
operator|-
name|aSig
expr_stmt|;
name|zExp
operator|=
name|bExp
expr_stmt|;
name|zSign
operator|^=
literal|1
expr_stmt|;
goto|goto
name|normalizeRoundAndPack
goto|;
name|aExpBigger
label|:
if|if
condition|(
name|aExp
operator|==
literal|0xFF
condition|)
block|{
if|if
condition|(
name|aSig
condition|)
return|return
name|propagateFloat32NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|a
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0
condition|)
block|{
operator|--
name|expDiff
expr_stmt|;
block|}
else|else
block|{
name|bSig
operator||=
literal|0x40000000
expr_stmt|;
block|}
name|shift32RightJamming
argument_list|(
name|bSig
argument_list|,
name|expDiff
argument_list|,
operator|&
name|bSig
argument_list|)
expr_stmt|;
name|aSig
operator||=
literal|0x40000000
expr_stmt|;
name|aBigger
label|:
name|zSig
operator|=
name|aSig
operator|-
name|bSig
expr_stmt|;
name|zExp
operator|=
name|aExp
expr_stmt|;
name|normalizeRoundAndPack
label|:
operator|--
name|zExp
expr_stmt|;
return|return
name|normalizeRoundAndPackFloat32
argument_list|(
name|zSign
argument_list|,
name|zExp
argument_list|,
name|zSig
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of adding the single-precision floating-point values `a' and `b'.  The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float32
name|float32_add
parameter_list|(
name|float32
name|a
parameter_list|,
name|float32
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|;
name|aSign
operator|=
name|extractFloat32Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat32Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aSign
operator|==
name|bSign
condition|)
block|{
return|return
name|addFloat32Sigs
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|aSign
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|subFloat32Sigs
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|aSign
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of subtracting the single-precision floating-point values `a' and `b'.  The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float32
name|float32_sub
parameter_list|(
name|float32
name|a
parameter_list|,
name|float32
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|;
name|aSign
operator|=
name|extractFloat32Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat32Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aSign
operator|==
name|bSign
condition|)
block|{
return|return
name|subFloat32Sigs
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|aSign
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|addFloat32Sigs
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|aSign
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of multiplying the single-precision floating-point values `a' and `b'.  The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float32
name|float32_mul
parameter_list|(
name|float32
name|a
parameter_list|,
name|float32
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|,
name|zSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|,
name|bExp
decl_stmt|,
name|zExp
decl_stmt|;
name|bits32
name|aSig
decl_stmt|,
name|bSig
decl_stmt|;
name|bits64
name|zSig64
decl_stmt|;
name|bits32
name|zSig
decl_stmt|;
name|aSig
operator|=
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat32Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat32Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSig
operator|=
name|extractFloat32Frac
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bExp
operator|=
name|extractFloat32Exp
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat32Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|zSign
operator|=
name|aSign
operator|^
name|bSign
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0xFF
condition|)
block|{
if|if
condition|(
name|aSig
operator|||
operator|(
operator|(
name|bExp
operator|==
literal|0xFF
operator|)
operator|&&
name|bSig
operator|)
condition|)
block|{
return|return
name|propagateFloat32NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|bExp
operator||
name|bSig
operator|)
operator|==
literal|0
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|float32_default_nan
return|;
block|}
return|return
name|packFloat32
argument_list|(
name|zSign
argument_list|,
literal|0xFF
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0xFF
condition|)
block|{
if|if
condition|(
name|bSig
condition|)
return|return
name|propagateFloat32NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
if|if
condition|(
operator|(
name|aExp
operator||
name|aSig
operator|)
operator|==
literal|0
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|float32_default_nan
return|;
block|}
return|return
name|packFloat32
argument_list|(
name|zSign
argument_list|,
literal|0xFF
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|aSig
operator|==
literal|0
condition|)
return|return
name|packFloat32
argument_list|(
name|zSign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|normalizeFloat32Subnormal
argument_list|(
name|aSig
argument_list|,
operator|&
name|aExp
argument_list|,
operator|&
name|aSig
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bSig
operator|==
literal|0
condition|)
return|return
name|packFloat32
argument_list|(
name|zSign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|normalizeFloat32Subnormal
argument_list|(
name|bSig
argument_list|,
operator|&
name|bExp
argument_list|,
operator|&
name|bSig
argument_list|)
expr_stmt|;
block|}
name|zExp
operator|=
name|aExp
operator|+
name|bExp
operator|-
literal|0x7F
expr_stmt|;
name|aSig
operator|=
operator|(
name|aSig
operator||
literal|0x00800000
operator|)
operator|<<
literal|7
expr_stmt|;
name|bSig
operator|=
operator|(
name|bSig
operator||
literal|0x00800000
operator|)
operator|<<
literal|8
expr_stmt|;
name|shift64RightJamming
argument_list|(
operator|(
operator|(
name|bits64
operator|)
name|aSig
operator|)
operator|*
name|bSig
argument_list|,
literal|32
argument_list|,
operator|&
name|zSig64
argument_list|)
expr_stmt|;
name|zSig
operator|=
name|zSig64
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
call|(
name|sbits32
call|)
argument_list|(
name|zSig
operator|<<
literal|1
argument_list|)
condition|)
block|{
name|zSig
operator|<<=
literal|1
expr_stmt|;
operator|--
name|zExp
expr_stmt|;
block|}
return|return
name|roundAndPackFloat32
argument_list|(
name|zSign
argument_list|,
name|zExp
argument_list|,
name|zSig
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of dividing the single-precision floating-point value `a' by the corresponding value `b'.  The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float32
name|float32_div
parameter_list|(
name|float32
name|a
parameter_list|,
name|float32
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|,
name|zSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|,
name|bExp
decl_stmt|,
name|zExp
decl_stmt|;
name|bits32
name|aSig
decl_stmt|,
name|bSig
decl_stmt|,
name|zSig
decl_stmt|;
name|aSig
operator|=
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat32Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat32Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSig
operator|=
name|extractFloat32Frac
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bExp
operator|=
name|extractFloat32Exp
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat32Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|zSign
operator|=
name|aSign
operator|^
name|bSign
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0xFF
condition|)
block|{
if|if
condition|(
name|aSig
condition|)
return|return
name|propagateFloat32NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
if|if
condition|(
name|bExp
operator|==
literal|0xFF
condition|)
block|{
if|if
condition|(
name|bSig
condition|)
return|return
name|propagateFloat32NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|float32_default_nan
return|;
block|}
return|return
name|packFloat32
argument_list|(
name|zSign
argument_list|,
literal|0xFF
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0xFF
condition|)
block|{
if|if
condition|(
name|bSig
condition|)
return|return
name|propagateFloat32NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|packFloat32
argument_list|(
name|zSign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bSig
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|aExp
operator||
name|aSig
operator|)
operator|==
literal|0
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|float32_default_nan
return|;
block|}
name|float_raise
argument_list|(
name|float_flag_divbyzero
argument_list|)
expr_stmt|;
return|return
name|packFloat32
argument_list|(
name|zSign
argument_list|,
literal|0xFF
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|normalizeFloat32Subnormal
argument_list|(
name|bSig
argument_list|,
operator|&
name|bExp
argument_list|,
operator|&
name|bSig
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|aSig
operator|==
literal|0
condition|)
return|return
name|packFloat32
argument_list|(
name|zSign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|normalizeFloat32Subnormal
argument_list|(
name|aSig
argument_list|,
operator|&
name|aExp
argument_list|,
operator|&
name|aSig
argument_list|)
expr_stmt|;
block|}
name|zExp
operator|=
name|aExp
operator|-
name|bExp
operator|+
literal|0x7D
expr_stmt|;
name|aSig
operator|=
operator|(
name|aSig
operator||
literal|0x00800000
operator|)
operator|<<
literal|7
expr_stmt|;
name|bSig
operator|=
operator|(
name|bSig
operator||
literal|0x00800000
operator|)
operator|<<
literal|8
expr_stmt|;
if|if
condition|(
name|bSig
operator|<=
operator|(
name|aSig
operator|+
name|aSig
operator|)
condition|)
block|{
name|aSig
operator|>>=
literal|1
expr_stmt|;
operator|++
name|zExp
expr_stmt|;
block|}
name|zSig
operator|=
operator|(
operator|(
operator|(
name|bits64
operator|)
name|aSig
operator|)
operator|<<
literal|32
operator|)
operator|/
name|bSig
expr_stmt|;
if|if
condition|(
operator|(
name|zSig
operator|&
literal|0x3F
operator|)
operator|==
literal|0
condition|)
block|{
name|zSig
operator||=
operator|(
operator|(
name|bits64
operator|)
name|bSig
operator|*
name|zSig
operator|!=
operator|(
operator|(
name|bits64
operator|)
name|aSig
operator|)
operator|<<
literal|32
operator|)
expr_stmt|;
block|}
return|return
name|roundAndPackFloat32
argument_list|(
name|zSign
argument_list|,
name|zExp
argument_list|,
name|zSig
argument_list|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SOFTFLOAT_FOR_GCC
end_ifndef

begin_comment
comment|/* Not needed */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the remainder of the single-precision floating-point value `a' with respect to the corresponding value `b'.  The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float32
name|float32_rem
parameter_list|(
name|float32
name|a
parameter_list|,
name|float32
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|,
name|zSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|,
name|bExp
decl_stmt|,
name|expDiff
decl_stmt|;
name|bits32
name|aSig
decl_stmt|,
name|bSig
decl_stmt|;
name|bits32
name|q
decl_stmt|;
name|bits64
name|aSig64
decl_stmt|,
name|bSig64
decl_stmt|,
name|q64
decl_stmt|;
name|bits32
name|alternateASig
decl_stmt|;
name|sbits32
name|sigMean
decl_stmt|;
name|aSig
operator|=
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat32Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat32Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSig
operator|=
name|extractFloat32Frac
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bExp
operator|=
name|extractFloat32Exp
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat32Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0xFF
condition|)
block|{
if|if
condition|(
name|aSig
operator|||
operator|(
operator|(
name|bExp
operator|==
literal|0xFF
operator|)
operator|&&
name|bSig
operator|)
condition|)
block|{
return|return
name|propagateFloat32NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|float32_default_nan
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0xFF
condition|)
block|{
if|if
condition|(
name|bSig
condition|)
return|return
name|propagateFloat32NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|a
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bSig
operator|==
literal|0
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|float32_default_nan
return|;
block|}
name|normalizeFloat32Subnormal
argument_list|(
name|bSig
argument_list|,
operator|&
name|bExp
argument_list|,
operator|&
name|bSig
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|aSig
operator|==
literal|0
condition|)
return|return
name|a
return|;
name|normalizeFloat32Subnormal
argument_list|(
name|aSig
argument_list|,
operator|&
name|aExp
argument_list|,
operator|&
name|aSig
argument_list|)
expr_stmt|;
block|}
name|expDiff
operator|=
name|aExp
operator|-
name|bExp
expr_stmt|;
name|aSig
operator||=
literal|0x00800000
expr_stmt|;
name|bSig
operator||=
literal|0x00800000
expr_stmt|;
if|if
condition|(
name|expDiff
operator|<
literal|32
condition|)
block|{
name|aSig
operator|<<=
literal|8
expr_stmt|;
name|bSig
operator|<<=
literal|8
expr_stmt|;
if|if
condition|(
name|expDiff
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|expDiff
operator|<
operator|-
literal|1
condition|)
return|return
name|a
return|;
name|aSig
operator|>>=
literal|1
expr_stmt|;
block|}
name|q
operator|=
operator|(
name|bSig
operator|<=
name|aSig
operator|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
name|aSig
operator|-=
name|bSig
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|expDiff
condition|)
block|{
name|q
operator|=
operator|(
operator|(
operator|(
name|bits64
operator|)
name|aSig
operator|)
operator|<<
literal|32
operator|)
operator|/
name|bSig
expr_stmt|;
name|q
operator|>>=
literal|32
operator|-
name|expDiff
expr_stmt|;
name|bSig
operator|>>=
literal|2
expr_stmt|;
name|aSig
operator|=
operator|(
operator|(
name|aSig
operator|>>
literal|1
operator|)
operator|<<
operator|(
name|expDiff
operator|-
literal|1
operator|)
operator|)
operator|-
name|bSig
operator|*
name|q
expr_stmt|;
block|}
else|else
block|{
name|aSig
operator|>>=
literal|2
expr_stmt|;
name|bSig
operator|>>=
literal|2
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|bSig
operator|<=
name|aSig
condition|)
name|aSig
operator|-=
name|bSig
expr_stmt|;
name|aSig64
operator|=
operator|(
operator|(
name|bits64
operator|)
name|aSig
operator|)
operator|<<
literal|40
expr_stmt|;
name|bSig64
operator|=
operator|(
operator|(
name|bits64
operator|)
name|bSig
operator|)
operator|<<
literal|40
expr_stmt|;
name|expDiff
operator|-=
literal|64
expr_stmt|;
while|while
condition|(
literal|0
operator|<
name|expDiff
condition|)
block|{
name|q64
operator|=
name|estimateDiv128To64
argument_list|(
name|aSig64
argument_list|,
literal|0
argument_list|,
name|bSig64
argument_list|)
expr_stmt|;
name|q64
operator|=
operator|(
literal|2
operator|<
name|q64
operator|)
condition|?
name|q64
operator|-
literal|2
else|:
literal|0
expr_stmt|;
name|aSig64
operator|=
operator|-
operator|(
operator|(
name|bSig
operator|*
name|q64
operator|)
operator|<<
literal|38
operator|)
expr_stmt|;
name|expDiff
operator|-=
literal|62
expr_stmt|;
block|}
name|expDiff
operator|+=
literal|64
expr_stmt|;
name|q64
operator|=
name|estimateDiv128To64
argument_list|(
name|aSig64
argument_list|,
literal|0
argument_list|,
name|bSig64
argument_list|)
expr_stmt|;
name|q64
operator|=
operator|(
literal|2
operator|<
name|q64
operator|)
condition|?
name|q64
operator|-
literal|2
else|:
literal|0
expr_stmt|;
name|q
operator|=
name|q64
operator|>>
operator|(
literal|64
operator|-
name|expDiff
operator|)
expr_stmt|;
name|bSig
operator|<<=
literal|6
expr_stmt|;
name|aSig
operator|=
operator|(
operator|(
name|aSig64
operator|>>
literal|33
operator|)
operator|<<
operator|(
name|expDiff
operator|-
literal|1
operator|)
operator|)
operator|-
name|bSig
operator|*
name|q
expr_stmt|;
block|}
do|do
block|{
name|alternateASig
operator|=
name|aSig
expr_stmt|;
operator|++
name|q
expr_stmt|;
name|aSig
operator|-=
name|bSig
expr_stmt|;
block|}
do|while
condition|(
literal|0
operator|<=
operator|(
name|sbits32
operator|)
name|aSig
condition|)
do|;
name|sigMean
operator|=
name|aSig
operator|+
name|alternateASig
expr_stmt|;
if|if
condition|(
operator|(
name|sigMean
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|sigMean
operator|==
literal|0
operator|)
operator|&&
operator|(
name|q
operator|&
literal|1
operator|)
operator|)
condition|)
block|{
name|aSig
operator|=
name|alternateASig
expr_stmt|;
block|}
name|zSign
operator|=
operator|(
operator|(
name|sbits32
operator|)
name|aSig
operator|<
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|zSign
condition|)
name|aSig
operator|=
operator|-
name|aSig
expr_stmt|;
return|return
name|normalizeRoundAndPackFloat32
argument_list|(
name|aSign
operator|^
name|zSign
argument_list|,
name|bExp
argument_list|,
name|aSig
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SOFTFLOAT_FOR_GCC */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SOFTFLOAT_FOR_GCC
end_ifndef

begin_comment
comment|/* Not needed */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the square root of the single-precision floating-point value `a'. The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float32
name|float32_sqrt
parameter_list|(
name|float32
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|,
name|zExp
decl_stmt|;
name|bits32
name|aSig
decl_stmt|,
name|zSig
decl_stmt|;
name|bits64
name|rem
decl_stmt|,
name|term
decl_stmt|;
name|aSig
operator|=
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat32Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat32Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0xFF
condition|)
block|{
if|if
condition|(
name|aSig
condition|)
return|return
name|propagateFloat32NaN
argument_list|(
name|a
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
operator|!
name|aSign
condition|)
return|return
name|a
return|;
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|float32_default_nan
return|;
block|}
if|if
condition|(
name|aSign
condition|)
block|{
if|if
condition|(
operator|(
name|aExp
operator||
name|aSig
operator|)
operator|==
literal|0
condition|)
return|return
name|a
return|;
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|float32_default_nan
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|aSig
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|normalizeFloat32Subnormal
argument_list|(
name|aSig
argument_list|,
operator|&
name|aExp
argument_list|,
operator|&
name|aSig
argument_list|)
expr_stmt|;
block|}
name|zExp
operator|=
operator|(
operator|(
name|aExp
operator|-
literal|0x7F
operator|)
operator|>>
literal|1
operator|)
operator|+
literal|0x7E
expr_stmt|;
name|aSig
operator|=
operator|(
name|aSig
operator||
literal|0x00800000
operator|)
operator|<<
literal|8
expr_stmt|;
name|zSig
operator|=
name|estimateSqrt32
argument_list|(
name|aExp
argument_list|,
name|aSig
argument_list|)
operator|+
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|zSig
operator|&
literal|0x7F
operator|)
operator|<=
literal|5
condition|)
block|{
if|if
condition|(
name|zSig
operator|<
literal|2
condition|)
block|{
name|zSig
operator|=
literal|0x7FFFFFFF
expr_stmt|;
goto|goto
name|roundAndPack
goto|;
block|}
name|aSig
operator|>>=
name|aExp
operator|&
literal|1
expr_stmt|;
name|term
operator|=
operator|(
operator|(
name|bits64
operator|)
name|zSig
operator|)
operator|*
name|zSig
expr_stmt|;
name|rem
operator|=
operator|(
operator|(
operator|(
name|bits64
operator|)
name|aSig
operator|)
operator|<<
literal|32
operator|)
operator|-
name|term
expr_stmt|;
while|while
condition|(
operator|(
name|sbits64
operator|)
name|rem
operator|<
literal|0
condition|)
block|{
operator|--
name|zSig
expr_stmt|;
name|rem
operator|+=
operator|(
operator|(
operator|(
name|bits64
operator|)
name|zSig
operator|)
operator|<<
literal|1
operator|)
operator||
literal|1
expr_stmt|;
block|}
name|zSig
operator||=
operator|(
name|rem
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
name|shift32RightJamming
argument_list|(
name|zSig
argument_list|,
literal|1
argument_list|,
operator|&
name|zSig
argument_list|)
expr_stmt|;
name|roundAndPack
label|:
return|return
name|roundAndPackFloat32
argument_list|(
literal|0
argument_list|,
name|zExp
argument_list|,
name|zSig
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SOFTFLOAT_FOR_GCC */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns 1 if the single-precision floating-point value `a' is equal to the corresponding value `b', and 0 otherwise.  The comparison is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|flag
name|float32_eq
parameter_list|(
name|float32
name|a
parameter_list|,
name|float32
name|b
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|extractFloat32Exp
argument_list|(
name|a
argument_list|)
operator|==
literal|0xFF
operator|)
operator|&&
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|extractFloat32Exp
argument_list|(
name|b
argument_list|)
operator|==
literal|0xFF
operator|)
operator|&&
name|extractFloat32Frac
argument_list|(
name|b
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|float32_is_signaling_nan
argument_list|(
name|a
argument_list|)
operator|||
name|float32_is_signaling_nan
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
return|return
operator|(
name|a
operator|==
name|b
operator|)
operator|||
operator|(
call|(
name|bits32
call|)
argument_list|(
operator|(
name|a
operator||
name|b
operator|)
operator|<<
literal|1
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns 1 if the single-precision floating-point value `a' is less than or equal to the corresponding value `b', and 0 otherwise.  The comparison is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|flag
name|float32_le
parameter_list|(
name|float32
name|a
parameter_list|,
name|float32
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|extractFloat32Exp
argument_list|(
name|a
argument_list|)
operator|==
literal|0xFF
operator|)
operator|&&
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|extractFloat32Exp
argument_list|(
name|b
argument_list|)
operator|==
literal|0xFF
operator|)
operator|&&
name|extractFloat32Frac
argument_list|(
name|b
argument_list|)
operator|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|aSign
operator|=
name|extractFloat32Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat32Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aSign
operator|!=
name|bSign
condition|)
return|return
name|aSign
operator|||
operator|(
call|(
name|bits32
call|)
argument_list|(
operator|(
name|a
operator||
name|b
operator|)
operator|<<
literal|1
argument_list|)
operator|==
literal|0
operator|)
return|;
return|return
operator|(
name|a
operator|==
name|b
operator|)
operator|||
operator|(
name|aSign
operator|^
operator|(
name|a
operator|<
name|b
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns 1 if the single-precision floating-point value `a' is less than the corresponding value `b', and 0 otherwise.  The comparison is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|flag
name|float32_lt
parameter_list|(
name|float32
name|a
parameter_list|,
name|float32
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|extractFloat32Exp
argument_list|(
name|a
argument_list|)
operator|==
literal|0xFF
operator|)
operator|&&
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|extractFloat32Exp
argument_list|(
name|b
argument_list|)
operator|==
literal|0xFF
operator|)
operator|&&
name|extractFloat32Frac
argument_list|(
name|b
argument_list|)
operator|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|aSign
operator|=
name|extractFloat32Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat32Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aSign
operator|!=
name|bSign
condition|)
return|return
name|aSign
operator|&&
operator|(
call|(
name|bits32
call|)
argument_list|(
operator|(
name|a
operator||
name|b
operator|)
operator|<<
literal|1
argument_list|)
operator|!=
literal|0
operator|)
return|;
return|return
operator|(
name|a
operator|!=
name|b
operator|)
operator|&&
operator|(
name|aSign
operator|^
operator|(
name|a
operator|<
name|b
operator|)
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SOFTFLOAT_FOR_GCC
end_ifndef

begin_comment
comment|/* Not needed */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns 1 if the single-precision floating-point value `a' is equal to the corresponding value `b', and 0 otherwise.  The invalid exception is raised if either operand is a NaN.  Otherwise, the comparison is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|flag
name|float32_eq_signaling
parameter_list|(
name|float32
name|a
parameter_list|,
name|float32
name|b
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|extractFloat32Exp
argument_list|(
name|a
argument_list|)
operator|==
literal|0xFF
operator|)
operator|&&
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|extractFloat32Exp
argument_list|(
name|b
argument_list|)
operator|==
literal|0xFF
operator|)
operator|&&
name|extractFloat32Frac
argument_list|(
name|b
argument_list|)
operator|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|(
name|a
operator|==
name|b
operator|)
operator|||
operator|(
call|(
name|bits32
call|)
argument_list|(
operator|(
name|a
operator||
name|b
operator|)
operator|<<
literal|1
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns 1 if the single-precision floating-point value `a' is less than or equal to the corresponding value `b', and 0 otherwise.  Quiet NaNs do not cause an exception.  Otherwise, the comparison is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|flag
name|float32_le_quiet
parameter_list|(
name|float32
name|a
parameter_list|,
name|float32
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|extractFloat32Exp
argument_list|(
name|a
argument_list|)
operator|==
literal|0xFF
operator|)
operator|&&
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|extractFloat32Exp
argument_list|(
name|b
argument_list|)
operator|==
literal|0xFF
operator|)
operator|&&
name|extractFloat32Frac
argument_list|(
name|b
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|float32_is_signaling_nan
argument_list|(
name|a
argument_list|)
operator|||
name|float32_is_signaling_nan
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|aSign
operator|=
name|extractFloat32Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat32Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aSign
operator|!=
name|bSign
condition|)
return|return
name|aSign
operator|||
operator|(
call|(
name|bits32
call|)
argument_list|(
operator|(
name|a
operator||
name|b
operator|)
operator|<<
literal|1
argument_list|)
operator|==
literal|0
operator|)
return|;
return|return
operator|(
name|a
operator|==
name|b
operator|)
operator|||
operator|(
name|aSign
operator|^
operator|(
name|a
operator|<
name|b
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns 1 if the single-precision floating-point value `a' is less than the corresponding value `b', and 0 otherwise.  Quiet NaNs do not cause an exception.  Otherwise, the comparison is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|flag
name|float32_lt_quiet
parameter_list|(
name|float32
name|a
parameter_list|,
name|float32
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|extractFloat32Exp
argument_list|(
name|a
argument_list|)
operator|==
literal|0xFF
operator|)
operator|&&
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|extractFloat32Exp
argument_list|(
name|b
argument_list|)
operator|==
literal|0xFF
operator|)
operator|&&
name|extractFloat32Frac
argument_list|(
name|b
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|float32_is_signaling_nan
argument_list|(
name|a
argument_list|)
operator|||
name|float32_is_signaling_nan
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|aSign
operator|=
name|extractFloat32Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat32Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aSign
operator|!=
name|bSign
condition|)
return|return
name|aSign
operator|&&
operator|(
call|(
name|bits32
call|)
argument_list|(
operator|(
name|a
operator||
name|b
operator|)
operator|<<
literal|1
argument_list|)
operator|!=
literal|0
operator|)
return|;
return|return
operator|(
name|a
operator|!=
name|b
operator|)
operator|&&
operator|(
name|aSign
operator|^
operator|(
name|a
operator|<
name|b
operator|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SOFTFLOAT_FOR_GCC */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SOFTFLOAT_FOR_GCC
end_ifndef

begin_comment
comment|/* Not needed */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the double-precision floating-point value `a' to the 32-bit two's complement integer format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic---which means in particular that the conversion is rounded according to the current rounding mode.  If `a' is a NaN, the largest positive integer is returned.  Otherwise, if the conversion overflows, the largest integer with the same sign as `a' is returned. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|int32
name|float64_to_int32
parameter_list|(
name|float64
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|,
name|shiftCount
decl_stmt|;
name|bits64
name|aSig
decl_stmt|;
name|aSig
operator|=
name|extractFloat64Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat64Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat64Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|aExp
operator|==
literal|0x7FF
operator|)
operator|&&
name|aSig
condition|)
name|aSign
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|aExp
condition|)
name|aSig
operator||=
name|LIT64
argument_list|(
literal|0x0010000000000000
argument_list|)
expr_stmt|;
name|shiftCount
operator|=
literal|0x42C
operator|-
name|aExp
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|shiftCount
condition|)
name|shift64RightJamming
argument_list|(
name|aSig
argument_list|,
name|shiftCount
argument_list|,
operator|&
name|aSig
argument_list|)
expr_stmt|;
return|return
name|roundAndPackInt32
argument_list|(
name|aSign
argument_list|,
name|aSig
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SOFTFLOAT_FOR_GCC */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the double-precision floating-point value `a' to the 32-bit two's complement integer format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic, except that the conversion is always rounded toward zero. If `a' is a NaN, the largest positive integer is returned.  Otherwise, if the conversion overflows, the largest integer with the same sign as `a' is returned. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|int32
name|float64_to_int32_round_to_zero
parameter_list|(
name|float64
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|,
name|shiftCount
decl_stmt|;
name|bits64
name|aSig
decl_stmt|,
name|savedASig
decl_stmt|;
name|int32
name|z
decl_stmt|;
name|aSig
operator|=
name|extractFloat64Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat64Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat64Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0x41E
operator|<
name|aExp
condition|)
block|{
if|if
condition|(
operator|(
name|aExp
operator|==
literal|0x7FF
operator|)
operator|&&
name|aSig
condition|)
name|aSign
operator|=
literal|0
expr_stmt|;
goto|goto
name|invalid
goto|;
block|}
elseif|else
if|if
condition|(
name|aExp
operator|<
literal|0x3FF
condition|)
block|{
if|if
condition|(
name|aExp
operator|||
name|aSig
condition|)
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
return|return
literal|0
return|;
block|}
name|aSig
operator||=
name|LIT64
argument_list|(
literal|0x0010000000000000
argument_list|)
expr_stmt|;
name|shiftCount
operator|=
literal|0x433
operator|-
name|aExp
expr_stmt|;
name|savedASig
operator|=
name|aSig
expr_stmt|;
name|aSig
operator|>>=
name|shiftCount
expr_stmt|;
name|z
operator|=
name|aSig
expr_stmt|;
if|if
condition|(
name|aSign
condition|)
name|z
operator|=
operator|-
name|z
expr_stmt|;
if|if
condition|(
operator|(
name|z
operator|<
literal|0
operator|)
operator|^
name|aSign
condition|)
block|{
name|invalid
label|:
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|aSign
condition|?
operator|(
name|sbits32
operator|)
literal|0x80000000
else|:
literal|0x7FFFFFFF
return|;
block|}
if|if
condition|(
operator|(
name|aSig
operator|<<
name|shiftCount
operator|)
operator|!=
name|savedASig
condition|)
block|{
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
block|}
return|return
name|z
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SOFTFLOAT_FOR_GCC
end_ifndef

begin_comment
comment|/* Not needed */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the double-precision floating-point value `a' to the 64-bit two's complement integer format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic---which means in particular that the conversion is rounded according to the current rounding mode.  If `a' is a NaN, the largest positive integer is returned.  Otherwise, if the conversion overflows, the largest integer with the same sign as `a' is returned. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|int64
name|float64_to_int64
parameter_list|(
name|float64
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|,
name|shiftCount
decl_stmt|;
name|bits64
name|aSig
decl_stmt|,
name|aSigExtra
decl_stmt|;
name|aSig
operator|=
name|extractFloat64Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat64Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat64Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|aExp
condition|)
name|aSig
operator||=
name|LIT64
argument_list|(
literal|0x0010000000000000
argument_list|)
expr_stmt|;
name|shiftCount
operator|=
literal|0x433
operator|-
name|aExp
expr_stmt|;
if|if
condition|(
name|shiftCount
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
literal|0x43E
operator|<
name|aExp
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aSign
operator|||
operator|(
operator|(
name|aExp
operator|==
literal|0x7FF
operator|)
operator|&&
operator|(
name|aSig
operator|!=
name|LIT64
argument_list|(
literal|0x0010000000000000
argument_list|)
operator|)
operator|)
condition|)
block|{
return|return
name|LIT64
argument_list|(
literal|0x7FFFFFFFFFFFFFFF
argument_list|)
return|;
block|}
return|return
operator|(
name|sbits64
operator|)
name|LIT64
argument_list|(
literal|0x8000000000000000
argument_list|)
return|;
block|}
name|aSigExtra
operator|=
literal|0
expr_stmt|;
name|aSig
operator|<<=
operator|-
name|shiftCount
expr_stmt|;
block|}
else|else
block|{
name|shift64ExtraRightJamming
argument_list|(
name|aSig
argument_list|,
literal|0
argument_list|,
name|shiftCount
argument_list|,
operator|&
name|aSig
argument_list|,
operator|&
name|aSigExtra
argument_list|)
expr_stmt|;
block|}
return|return
name|roundAndPackInt64
argument_list|(
name|aSign
argument_list|,
name|aSig
argument_list|,
name|aSigExtra
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the double-precision floating-point value `a' to the 64-bit two's complement integer format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic, except that the conversion is always rounded toward zero. If `a' is a NaN, the largest positive integer is returned.  Otherwise, if the conversion overflows, the largest integer with the same sign as `a' is returned. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|int64
name|float64_to_int64_round_to_zero
parameter_list|(
name|float64
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|,
name|shiftCount
decl_stmt|;
name|bits64
name|aSig
decl_stmt|;
name|int64
name|z
decl_stmt|;
name|aSig
operator|=
name|extractFloat64Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat64Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat64Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|aExp
condition|)
name|aSig
operator||=
name|LIT64
argument_list|(
literal|0x0010000000000000
argument_list|)
expr_stmt|;
name|shiftCount
operator|=
name|aExp
operator|-
literal|0x433
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|shiftCount
condition|)
block|{
if|if
condition|(
literal|0x43E
operator|<=
name|aExp
condition|)
block|{
if|if
condition|(
name|a
operator|!=
name|LIT64
argument_list|(
literal|0xC3E0000000000000
argument_list|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aSign
operator|||
operator|(
operator|(
name|aExp
operator|==
literal|0x7FF
operator|)
operator|&&
operator|(
name|aSig
operator|!=
name|LIT64
argument_list|(
literal|0x0010000000000000
argument_list|)
operator|)
operator|)
condition|)
block|{
return|return
name|LIT64
argument_list|(
literal|0x7FFFFFFFFFFFFFFF
argument_list|)
return|;
block|}
block|}
return|return
operator|(
name|sbits64
operator|)
name|LIT64
argument_list|(
literal|0x8000000000000000
argument_list|)
return|;
block|}
name|z
operator|=
name|aSig
operator|<<
name|shiftCount
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|aExp
operator|<
literal|0x3FE
condition|)
block|{
if|if
condition|(
name|aExp
operator||
name|aSig
condition|)
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
return|return
literal|0
return|;
block|}
name|z
operator|=
name|aSig
operator|>>
operator|(
operator|-
name|shiftCount
operator|)
expr_stmt|;
if|if
condition|(
call|(
name|bits64
call|)
argument_list|(
name|aSig
operator|<<
operator|(
name|shiftCount
operator|&
literal|63
operator|)
argument_list|)
condition|)
block|{
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
block|}
block|}
if|if
condition|(
name|aSign
condition|)
name|z
operator|=
operator|-
name|z
expr_stmt|;
return|return
name|z
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !SOFTFLOAT_FOR_GCC */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the double-precision floating-point value `a' to the single-precision floating-point format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float32
name|float64_to_float32
parameter_list|(
name|float64
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|;
name|bits64
name|aSig
decl_stmt|;
name|bits32
name|zSig
decl_stmt|;
name|aSig
operator|=
name|extractFloat64Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat64Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat64Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0x7FF
condition|)
block|{
if|if
condition|(
name|aSig
condition|)
return|return
name|commonNaNToFloat32
argument_list|(
name|float64ToCommonNaN
argument_list|(
name|a
argument_list|)
argument_list|)
return|;
return|return
name|packFloat32
argument_list|(
name|aSign
argument_list|,
literal|0xFF
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|shift64RightJamming
argument_list|(
name|aSig
argument_list|,
literal|22
argument_list|,
operator|&
name|aSig
argument_list|)
expr_stmt|;
name|zSig
operator|=
name|aSig
expr_stmt|;
if|if
condition|(
name|aExp
operator|||
name|zSig
condition|)
block|{
name|zSig
operator||=
literal|0x40000000
expr_stmt|;
name|aExp
operator|-=
literal|0x381
expr_stmt|;
block|}
return|return
name|roundAndPackFloat32
argument_list|(
name|aSign
argument_list|,
name|aExp
argument_list|,
name|zSig
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FLOATX80
end_ifdef

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the double-precision floating-point value `a' to the extended double-precision floating-point format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|floatx80
name|float64_to_floatx80
parameter_list|(
name|float64
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|;
name|bits64
name|aSig
decl_stmt|;
name|aSig
operator|=
name|extractFloat64Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat64Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat64Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0x7FF
condition|)
block|{
if|if
condition|(
name|aSig
condition|)
return|return
name|commonNaNToFloatx80
argument_list|(
name|float64ToCommonNaN
argument_list|(
name|a
argument_list|)
argument_list|)
return|;
return|return
name|packFloatx80
argument_list|(
name|aSign
argument_list|,
literal|0x7FFF
argument_list|,
name|LIT64
argument_list|(
literal|0x8000000000000000
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|aSig
operator|==
literal|0
condition|)
return|return
name|packFloatx80
argument_list|(
name|aSign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|normalizeFloat64Subnormal
argument_list|(
name|aSig
argument_list|,
operator|&
name|aExp
argument_list|,
operator|&
name|aSig
argument_list|)
expr_stmt|;
block|}
return|return
name|packFloatx80
argument_list|(
name|aSign
argument_list|,
name|aExp
operator|+
literal|0x3C00
argument_list|,
operator|(
name|aSig
operator||
name|LIT64
argument_list|(
literal|0x0010000000000000
argument_list|)
operator|)
operator|<<
literal|11
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|FLOAT128
end_ifdef

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the double-precision floating-point value `a' to the quadruple-precision floating-point format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float128
name|float64_to_float128
parameter_list|(
name|float64
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|;
name|bits64
name|aSig
decl_stmt|,
name|zSig0
decl_stmt|,
name|zSig1
decl_stmt|;
name|aSig
operator|=
name|extractFloat64Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat64Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat64Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0x7FF
condition|)
block|{
if|if
condition|(
name|aSig
condition|)
return|return
name|commonNaNToFloat128
argument_list|(
name|float64ToCommonNaN
argument_list|(
name|a
argument_list|)
argument_list|)
return|;
return|return
name|packFloat128
argument_list|(
name|aSign
argument_list|,
literal|0x7FFF
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|aSig
operator|==
literal|0
condition|)
return|return
name|packFloat128
argument_list|(
name|aSign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|normalizeFloat64Subnormal
argument_list|(
name|aSig
argument_list|,
operator|&
name|aExp
argument_list|,
operator|&
name|aSig
argument_list|)
expr_stmt|;
operator|--
name|aExp
expr_stmt|;
block|}
name|shift128Right
argument_list|(
name|aSig
argument_list|,
literal|0
argument_list|,
literal|4
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|)
expr_stmt|;
return|return
name|packFloat128
argument_list|(
name|aSign
argument_list|,
name|aExp
operator|+
literal|0x3C00
argument_list|,
name|zSig0
argument_list|,
name|zSig1
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SOFTFLOAT_FOR_GCC
end_ifndef

begin_comment
comment|/* ------------------------------------------------------------------------------- Rounds the double-precision floating-point value `a' to an integer, and returns the result as a double-precision floating-point value.  The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float64
name|float64_round_to_int
parameter_list|(
name|float64
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|;
name|bits64
name|lastBitMask
decl_stmt|,
name|roundBitsMask
decl_stmt|;
name|int8
name|roundingMode
decl_stmt|;
name|float64
name|z
decl_stmt|;
name|aExp
operator|=
name|extractFloat64Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0x433
operator|<=
name|aExp
condition|)
block|{
if|if
condition|(
operator|(
name|aExp
operator|==
literal|0x7FF
operator|)
operator|&&
name|extractFloat64Frac
argument_list|(
name|a
argument_list|)
condition|)
block|{
return|return
name|propagateFloat64NaN
argument_list|(
name|a
argument_list|,
name|a
argument_list|)
return|;
block|}
return|return
name|a
return|;
block|}
if|if
condition|(
name|aExp
operator|<
literal|0x3FF
condition|)
block|{
if|if
condition|(
call|(
name|bits64
call|)
argument_list|(
name|a
operator|<<
literal|1
argument_list|)
operator|==
literal|0
condition|)
return|return
name|a
return|;
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
name|aSign
operator|=
name|extractFloat64Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|float_rounding_mode
condition|)
block|{
case|case
name|float_round_nearest_even
case|:
if|if
condition|(
operator|(
name|aExp
operator|==
literal|0x3FE
operator|)
operator|&&
name|extractFloat64Frac
argument_list|(
name|a
argument_list|)
condition|)
block|{
return|return
name|packFloat64
argument_list|(
name|aSign
argument_list|,
literal|0x3FF
argument_list|,
literal|0
argument_list|)
return|;
block|}
break|break;
case|case
name|float_round_to_zero
case|:
break|break;
case|case
name|float_round_down
case|:
return|return
name|aSign
condition|?
name|LIT64
argument_list|(
literal|0xBFF0000000000000
argument_list|)
else|:
literal|0
return|;
case|case
name|float_round_up
case|:
return|return
name|aSign
condition|?
name|LIT64
argument_list|(
literal|0x8000000000000000
argument_list|)
else|:
name|LIT64
argument_list|(
literal|0x3FF0000000000000
argument_list|)
return|;
block|}
return|return
name|packFloat64
argument_list|(
name|aSign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|lastBitMask
operator|=
literal|1
expr_stmt|;
name|lastBitMask
operator|<<=
literal|0x433
operator|-
name|aExp
expr_stmt|;
name|roundBitsMask
operator|=
name|lastBitMask
operator|-
literal|1
expr_stmt|;
name|z
operator|=
name|a
expr_stmt|;
name|roundingMode
operator|=
name|float_rounding_mode
expr_stmt|;
if|if
condition|(
name|roundingMode
operator|==
name|float_round_nearest_even
condition|)
block|{
name|z
operator|+=
name|lastBitMask
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|z
operator|&
name|roundBitsMask
operator|)
operator|==
literal|0
condition|)
name|z
operator|&=
operator|~
name|lastBitMask
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|roundingMode
operator|!=
name|float_round_to_zero
condition|)
block|{
if|if
condition|(
name|extractFloat64Sign
argument_list|(
name|z
argument_list|)
operator|^
operator|(
name|roundingMode
operator|==
name|float_round_up
operator|)
condition|)
block|{
name|z
operator|+=
name|roundBitsMask
expr_stmt|;
block|}
block|}
name|z
operator|&=
operator|~
name|roundBitsMask
expr_stmt|;
if|if
condition|(
name|z
operator|!=
name|a
condition|)
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
return|return
name|z
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of adding the absolute values of the double-precision floating-point values `a' and `b'.  If `zSign' is 1, the sum is negated before being returned.  `zSign' is ignored if the result is a NaN. The addition is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|float64
name|addFloat64Sigs
parameter_list|(
name|float64
name|a
parameter_list|,
name|float64
name|b
parameter_list|,
name|flag
name|zSign
parameter_list|)
block|{
name|int16
name|aExp
decl_stmt|,
name|bExp
decl_stmt|,
name|zExp
decl_stmt|;
name|bits64
name|aSig
decl_stmt|,
name|bSig
decl_stmt|,
name|zSig
decl_stmt|;
name|int16
name|expDiff
decl_stmt|;
name|aSig
operator|=
name|extractFloat64Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat64Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSig
operator|=
name|extractFloat64Frac
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bExp
operator|=
name|extractFloat64Exp
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|expDiff
operator|=
name|aExp
operator|-
name|bExp
expr_stmt|;
name|aSig
operator|<<=
literal|9
expr_stmt|;
name|bSig
operator|<<=
literal|9
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|expDiff
condition|)
block|{
if|if
condition|(
name|aExp
operator|==
literal|0x7FF
condition|)
block|{
if|if
condition|(
name|aSig
condition|)
return|return
name|propagateFloat64NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|a
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0
condition|)
block|{
operator|--
name|expDiff
expr_stmt|;
block|}
else|else
block|{
name|bSig
operator||=
name|LIT64
argument_list|(
literal|0x2000000000000000
argument_list|)
expr_stmt|;
block|}
name|shift64RightJamming
argument_list|(
name|bSig
argument_list|,
name|expDiff
argument_list|,
operator|&
name|bSig
argument_list|)
expr_stmt|;
name|zExp
operator|=
name|aExp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expDiff
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|bExp
operator|==
literal|0x7FF
condition|)
block|{
if|if
condition|(
name|bSig
condition|)
return|return
name|propagateFloat64NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|packFloat64
argument_list|(
name|zSign
argument_list|,
literal|0x7FF
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
operator|++
name|expDiff
expr_stmt|;
block|}
else|else
block|{
name|aSig
operator||=
name|LIT64
argument_list|(
literal|0x2000000000000000
argument_list|)
expr_stmt|;
block|}
name|shift64RightJamming
argument_list|(
name|aSig
argument_list|,
operator|-
name|expDiff
argument_list|,
operator|&
name|aSig
argument_list|)
expr_stmt|;
name|zExp
operator|=
name|bExp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|aExp
operator|==
literal|0x7FF
condition|)
block|{
if|if
condition|(
name|aSig
operator||
name|bSig
condition|)
return|return
name|propagateFloat64NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|a
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
return|return
name|packFloat64
argument_list|(
name|zSign
argument_list|,
literal|0
argument_list|,
operator|(
name|aSig
operator|+
name|bSig
operator|)
operator|>>
literal|9
argument_list|)
return|;
name|zSig
operator|=
name|LIT64
argument_list|(
literal|0x4000000000000000
argument_list|)
operator|+
name|aSig
operator|+
name|bSig
expr_stmt|;
name|zExp
operator|=
name|aExp
expr_stmt|;
goto|goto
name|roundAndPack
goto|;
block|}
name|aSig
operator||=
name|LIT64
argument_list|(
literal|0x2000000000000000
argument_list|)
expr_stmt|;
name|zSig
operator|=
operator|(
name|aSig
operator|+
name|bSig
operator|)
operator|<<
literal|1
expr_stmt|;
operator|--
name|zExp
expr_stmt|;
if|if
condition|(
operator|(
name|sbits64
operator|)
name|zSig
operator|<
literal|0
condition|)
block|{
name|zSig
operator|=
name|aSig
operator|+
name|bSig
expr_stmt|;
operator|++
name|zExp
expr_stmt|;
block|}
name|roundAndPack
label|:
return|return
name|roundAndPackFloat64
argument_list|(
name|zSign
argument_list|,
name|zExp
argument_list|,
name|zSig
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of subtracting the absolute values of the double- precision floating-point values `a' and `b'.  If `zSign' is 1, the difference is negated before being returned.  `zSign' is ignored if the result is a NaN.  The subtraction is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|float64
name|subFloat64Sigs
parameter_list|(
name|float64
name|a
parameter_list|,
name|float64
name|b
parameter_list|,
name|flag
name|zSign
parameter_list|)
block|{
name|int16
name|aExp
decl_stmt|,
name|bExp
decl_stmt|,
name|zExp
decl_stmt|;
name|bits64
name|aSig
decl_stmt|,
name|bSig
decl_stmt|,
name|zSig
decl_stmt|;
name|int16
name|expDiff
decl_stmt|;
name|aSig
operator|=
name|extractFloat64Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat64Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSig
operator|=
name|extractFloat64Frac
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bExp
operator|=
name|extractFloat64Exp
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|expDiff
operator|=
name|aExp
operator|-
name|bExp
expr_stmt|;
name|aSig
operator|<<=
literal|10
expr_stmt|;
name|bSig
operator|<<=
literal|10
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|expDiff
condition|)
goto|goto
name|aExpBigger
goto|;
if|if
condition|(
name|expDiff
operator|<
literal|0
condition|)
goto|goto
name|bExpBigger
goto|;
if|if
condition|(
name|aExp
operator|==
literal|0x7FF
condition|)
block|{
if|if
condition|(
name|aSig
operator||
name|bSig
condition|)
return|return
name|propagateFloat64NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|float64_default_nan
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
name|aExp
operator|=
literal|1
expr_stmt|;
name|bExp
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bSig
operator|<
name|aSig
condition|)
goto|goto
name|aBigger
goto|;
if|if
condition|(
name|aSig
operator|<
name|bSig
condition|)
goto|goto
name|bBigger
goto|;
return|return
name|packFloat64
argument_list|(
name|float_rounding_mode
operator|==
name|float_round_down
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|bExpBigger
label|:
if|if
condition|(
name|bExp
operator|==
literal|0x7FF
condition|)
block|{
if|if
condition|(
name|bSig
condition|)
return|return
name|propagateFloat64NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|packFloat64
argument_list|(
name|zSign
operator|^
literal|1
argument_list|,
literal|0x7FF
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
operator|++
name|expDiff
expr_stmt|;
block|}
else|else
block|{
name|aSig
operator||=
name|LIT64
argument_list|(
literal|0x4000000000000000
argument_list|)
expr_stmt|;
block|}
name|shift64RightJamming
argument_list|(
name|aSig
argument_list|,
operator|-
name|expDiff
argument_list|,
operator|&
name|aSig
argument_list|)
expr_stmt|;
name|bSig
operator||=
name|LIT64
argument_list|(
literal|0x4000000000000000
argument_list|)
expr_stmt|;
name|bBigger
label|:
name|zSig
operator|=
name|bSig
operator|-
name|aSig
expr_stmt|;
name|zExp
operator|=
name|bExp
expr_stmt|;
name|zSign
operator|^=
literal|1
expr_stmt|;
goto|goto
name|normalizeRoundAndPack
goto|;
name|aExpBigger
label|:
if|if
condition|(
name|aExp
operator|==
literal|0x7FF
condition|)
block|{
if|if
condition|(
name|aSig
condition|)
return|return
name|propagateFloat64NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|a
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0
condition|)
block|{
operator|--
name|expDiff
expr_stmt|;
block|}
else|else
block|{
name|bSig
operator||=
name|LIT64
argument_list|(
literal|0x4000000000000000
argument_list|)
expr_stmt|;
block|}
name|shift64RightJamming
argument_list|(
name|bSig
argument_list|,
name|expDiff
argument_list|,
operator|&
name|bSig
argument_list|)
expr_stmt|;
name|aSig
operator||=
name|LIT64
argument_list|(
literal|0x4000000000000000
argument_list|)
expr_stmt|;
name|aBigger
label|:
name|zSig
operator|=
name|aSig
operator|-
name|bSig
expr_stmt|;
name|zExp
operator|=
name|aExp
expr_stmt|;
name|normalizeRoundAndPack
label|:
operator|--
name|zExp
expr_stmt|;
return|return
name|normalizeRoundAndPackFloat64
argument_list|(
name|zSign
argument_list|,
name|zExp
argument_list|,
name|zSig
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of adding the double-precision floating-point values `a' and `b'.  The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float64
name|float64_add
parameter_list|(
name|float64
name|a
parameter_list|,
name|float64
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|;
name|aSign
operator|=
name|extractFloat64Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat64Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aSign
operator|==
name|bSign
condition|)
block|{
return|return
name|addFloat64Sigs
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|aSign
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|subFloat64Sigs
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|aSign
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of subtracting the double-precision floating-point values `a' and `b'.  The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float64
name|float64_sub
parameter_list|(
name|float64
name|a
parameter_list|,
name|float64
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|;
name|aSign
operator|=
name|extractFloat64Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat64Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aSign
operator|==
name|bSign
condition|)
block|{
return|return
name|subFloat64Sigs
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|aSign
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|addFloat64Sigs
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|aSign
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of multiplying the double-precision floating-point values `a' and `b'.  The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float64
name|float64_mul
parameter_list|(
name|float64
name|a
parameter_list|,
name|float64
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|,
name|zSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|,
name|bExp
decl_stmt|,
name|zExp
decl_stmt|;
name|bits64
name|aSig
decl_stmt|,
name|bSig
decl_stmt|,
name|zSig0
decl_stmt|,
name|zSig1
decl_stmt|;
name|aSig
operator|=
name|extractFloat64Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat64Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat64Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSig
operator|=
name|extractFloat64Frac
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bExp
operator|=
name|extractFloat64Exp
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat64Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|zSign
operator|=
name|aSign
operator|^
name|bSign
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0x7FF
condition|)
block|{
if|if
condition|(
name|aSig
operator|||
operator|(
operator|(
name|bExp
operator|==
literal|0x7FF
operator|)
operator|&&
name|bSig
operator|)
condition|)
block|{
return|return
name|propagateFloat64NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|bExp
operator||
name|bSig
operator|)
operator|==
literal|0
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|float64_default_nan
return|;
block|}
return|return
name|packFloat64
argument_list|(
name|zSign
argument_list|,
literal|0x7FF
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0x7FF
condition|)
block|{
if|if
condition|(
name|bSig
condition|)
return|return
name|propagateFloat64NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
if|if
condition|(
operator|(
name|aExp
operator||
name|aSig
operator|)
operator|==
literal|0
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|float64_default_nan
return|;
block|}
return|return
name|packFloat64
argument_list|(
name|zSign
argument_list|,
literal|0x7FF
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|aSig
operator|==
literal|0
condition|)
return|return
name|packFloat64
argument_list|(
name|zSign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|normalizeFloat64Subnormal
argument_list|(
name|aSig
argument_list|,
operator|&
name|aExp
argument_list|,
operator|&
name|aSig
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bSig
operator|==
literal|0
condition|)
return|return
name|packFloat64
argument_list|(
name|zSign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|normalizeFloat64Subnormal
argument_list|(
name|bSig
argument_list|,
operator|&
name|bExp
argument_list|,
operator|&
name|bSig
argument_list|)
expr_stmt|;
block|}
name|zExp
operator|=
name|aExp
operator|+
name|bExp
operator|-
literal|0x3FF
expr_stmt|;
name|aSig
operator|=
operator|(
name|aSig
operator||
name|LIT64
argument_list|(
literal|0x0010000000000000
argument_list|)
operator|)
operator|<<
literal|10
expr_stmt|;
name|bSig
operator|=
operator|(
name|bSig
operator||
name|LIT64
argument_list|(
literal|0x0010000000000000
argument_list|)
operator|)
operator|<<
literal|11
expr_stmt|;
name|mul64To128
argument_list|(
name|aSig
argument_list|,
name|bSig
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|)
expr_stmt|;
name|zSig0
operator||=
operator|(
name|zSig1
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
call|(
name|sbits64
call|)
argument_list|(
name|zSig0
operator|<<
literal|1
argument_list|)
condition|)
block|{
name|zSig0
operator|<<=
literal|1
expr_stmt|;
operator|--
name|zExp
expr_stmt|;
block|}
return|return
name|roundAndPackFloat64
argument_list|(
name|zSign
argument_list|,
name|zExp
argument_list|,
name|zSig0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of dividing the double-precision floating-point value `a' by the corresponding value `b'.  The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float64
name|float64_div
parameter_list|(
name|float64
name|a
parameter_list|,
name|float64
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|,
name|zSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|,
name|bExp
decl_stmt|,
name|zExp
decl_stmt|;
name|bits64
name|aSig
decl_stmt|,
name|bSig
decl_stmt|,
name|zSig
decl_stmt|;
name|bits64
name|rem0
decl_stmt|,
name|rem1
decl_stmt|;
name|bits64
name|term0
decl_stmt|,
name|term1
decl_stmt|;
name|aSig
operator|=
name|extractFloat64Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat64Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat64Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSig
operator|=
name|extractFloat64Frac
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bExp
operator|=
name|extractFloat64Exp
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat64Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|zSign
operator|=
name|aSign
operator|^
name|bSign
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0x7FF
condition|)
block|{
if|if
condition|(
name|aSig
condition|)
return|return
name|propagateFloat64NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
if|if
condition|(
name|bExp
operator|==
literal|0x7FF
condition|)
block|{
if|if
condition|(
name|bSig
condition|)
return|return
name|propagateFloat64NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|float64_default_nan
return|;
block|}
return|return
name|packFloat64
argument_list|(
name|zSign
argument_list|,
literal|0x7FF
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0x7FF
condition|)
block|{
if|if
condition|(
name|bSig
condition|)
return|return
name|propagateFloat64NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|packFloat64
argument_list|(
name|zSign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bSig
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|aExp
operator||
name|aSig
operator|)
operator|==
literal|0
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|float64_default_nan
return|;
block|}
name|float_raise
argument_list|(
name|float_flag_divbyzero
argument_list|)
expr_stmt|;
return|return
name|packFloat64
argument_list|(
name|zSign
argument_list|,
literal|0x7FF
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|normalizeFloat64Subnormal
argument_list|(
name|bSig
argument_list|,
operator|&
name|bExp
argument_list|,
operator|&
name|bSig
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|aSig
operator|==
literal|0
condition|)
return|return
name|packFloat64
argument_list|(
name|zSign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|normalizeFloat64Subnormal
argument_list|(
name|aSig
argument_list|,
operator|&
name|aExp
argument_list|,
operator|&
name|aSig
argument_list|)
expr_stmt|;
block|}
name|zExp
operator|=
name|aExp
operator|-
name|bExp
operator|+
literal|0x3FD
expr_stmt|;
name|aSig
operator|=
operator|(
name|aSig
operator||
name|LIT64
argument_list|(
literal|0x0010000000000000
argument_list|)
operator|)
operator|<<
literal|10
expr_stmt|;
name|bSig
operator|=
operator|(
name|bSig
operator||
name|LIT64
argument_list|(
literal|0x0010000000000000
argument_list|)
operator|)
operator|<<
literal|11
expr_stmt|;
if|if
condition|(
name|bSig
operator|<=
operator|(
name|aSig
operator|+
name|aSig
operator|)
condition|)
block|{
name|aSig
operator|>>=
literal|1
expr_stmt|;
operator|++
name|zExp
expr_stmt|;
block|}
name|zSig
operator|=
name|estimateDiv128To64
argument_list|(
name|aSig
argument_list|,
literal|0
argument_list|,
name|bSig
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zSig
operator|&
literal|0x1FF
operator|)
operator|<=
literal|2
condition|)
block|{
name|mul64To128
argument_list|(
name|bSig
argument_list|,
name|zSig
argument_list|,
operator|&
name|term0
argument_list|,
operator|&
name|term1
argument_list|)
expr_stmt|;
name|sub128
argument_list|(
name|aSig
argument_list|,
literal|0
argument_list|,
name|term0
argument_list|,
name|term1
argument_list|,
operator|&
name|rem0
argument_list|,
operator|&
name|rem1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|sbits64
operator|)
name|rem0
operator|<
literal|0
condition|)
block|{
operator|--
name|zSig
expr_stmt|;
name|add128
argument_list|(
name|rem0
argument_list|,
name|rem1
argument_list|,
literal|0
argument_list|,
name|bSig
argument_list|,
operator|&
name|rem0
argument_list|,
operator|&
name|rem1
argument_list|)
expr_stmt|;
block|}
name|zSig
operator||=
operator|(
name|rem1
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
return|return
name|roundAndPackFloat64
argument_list|(
name|zSign
argument_list|,
name|zExp
argument_list|,
name|zSig
argument_list|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SOFTFLOAT_FOR_GCC
end_ifndef

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the remainder of the double-precision floating-point value `a' with respect to the corresponding value `b'.  The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float64
name|float64_rem
parameter_list|(
name|float64
name|a
parameter_list|,
name|float64
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|,
name|zSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|,
name|bExp
decl_stmt|,
name|expDiff
decl_stmt|;
name|bits64
name|aSig
decl_stmt|,
name|bSig
decl_stmt|;
name|bits64
name|q
decl_stmt|,
name|alternateASig
decl_stmt|;
name|sbits64
name|sigMean
decl_stmt|;
name|aSig
operator|=
name|extractFloat64Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat64Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat64Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSig
operator|=
name|extractFloat64Frac
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bExp
operator|=
name|extractFloat64Exp
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat64Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0x7FF
condition|)
block|{
if|if
condition|(
name|aSig
operator|||
operator|(
operator|(
name|bExp
operator|==
literal|0x7FF
operator|)
operator|&&
name|bSig
operator|)
condition|)
block|{
return|return
name|propagateFloat64NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|float64_default_nan
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0x7FF
condition|)
block|{
if|if
condition|(
name|bSig
condition|)
return|return
name|propagateFloat64NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|a
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bSig
operator|==
literal|0
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|float64_default_nan
return|;
block|}
name|normalizeFloat64Subnormal
argument_list|(
name|bSig
argument_list|,
operator|&
name|bExp
argument_list|,
operator|&
name|bSig
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|aSig
operator|==
literal|0
condition|)
return|return
name|a
return|;
name|normalizeFloat64Subnormal
argument_list|(
name|aSig
argument_list|,
operator|&
name|aExp
argument_list|,
operator|&
name|aSig
argument_list|)
expr_stmt|;
block|}
name|expDiff
operator|=
name|aExp
operator|-
name|bExp
expr_stmt|;
name|aSig
operator|=
operator|(
name|aSig
operator||
name|LIT64
argument_list|(
literal|0x0010000000000000
argument_list|)
operator|)
operator|<<
literal|11
expr_stmt|;
name|bSig
operator|=
operator|(
name|bSig
operator||
name|LIT64
argument_list|(
literal|0x0010000000000000
argument_list|)
operator|)
operator|<<
literal|11
expr_stmt|;
if|if
condition|(
name|expDiff
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|expDiff
operator|<
operator|-
literal|1
condition|)
return|return
name|a
return|;
name|aSig
operator|>>=
literal|1
expr_stmt|;
block|}
name|q
operator|=
operator|(
name|bSig
operator|<=
name|aSig
operator|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
name|aSig
operator|-=
name|bSig
expr_stmt|;
name|expDiff
operator|-=
literal|64
expr_stmt|;
while|while
condition|(
literal|0
operator|<
name|expDiff
condition|)
block|{
name|q
operator|=
name|estimateDiv128To64
argument_list|(
name|aSig
argument_list|,
literal|0
argument_list|,
name|bSig
argument_list|)
expr_stmt|;
name|q
operator|=
operator|(
literal|2
operator|<
name|q
operator|)
condition|?
name|q
operator|-
literal|2
else|:
literal|0
expr_stmt|;
name|aSig
operator|=
operator|-
operator|(
operator|(
name|bSig
operator|>>
literal|2
operator|)
operator|*
name|q
operator|)
expr_stmt|;
name|expDiff
operator|-=
literal|62
expr_stmt|;
block|}
name|expDiff
operator|+=
literal|64
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|expDiff
condition|)
block|{
name|q
operator|=
name|estimateDiv128To64
argument_list|(
name|aSig
argument_list|,
literal|0
argument_list|,
name|bSig
argument_list|)
expr_stmt|;
name|q
operator|=
operator|(
literal|2
operator|<
name|q
operator|)
condition|?
name|q
operator|-
literal|2
else|:
literal|0
expr_stmt|;
name|q
operator|>>=
literal|64
operator|-
name|expDiff
expr_stmt|;
name|bSig
operator|>>=
literal|2
expr_stmt|;
name|aSig
operator|=
operator|(
operator|(
name|aSig
operator|>>
literal|1
operator|)
operator|<<
operator|(
name|expDiff
operator|-
literal|1
operator|)
operator|)
operator|-
name|bSig
operator|*
name|q
expr_stmt|;
block|}
else|else
block|{
name|aSig
operator|>>=
literal|2
expr_stmt|;
name|bSig
operator|>>=
literal|2
expr_stmt|;
block|}
do|do
block|{
name|alternateASig
operator|=
name|aSig
expr_stmt|;
operator|++
name|q
expr_stmt|;
name|aSig
operator|-=
name|bSig
expr_stmt|;
block|}
do|while
condition|(
literal|0
operator|<=
operator|(
name|sbits64
operator|)
name|aSig
condition|)
do|;
name|sigMean
operator|=
name|aSig
operator|+
name|alternateASig
expr_stmt|;
if|if
condition|(
operator|(
name|sigMean
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|sigMean
operator|==
literal|0
operator|)
operator|&&
operator|(
name|q
operator|&
literal|1
operator|)
operator|)
condition|)
block|{
name|aSig
operator|=
name|alternateASig
expr_stmt|;
block|}
name|zSign
operator|=
operator|(
operator|(
name|sbits64
operator|)
name|aSig
operator|<
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|zSign
condition|)
name|aSig
operator|=
operator|-
name|aSig
expr_stmt|;
return|return
name|normalizeRoundAndPackFloat64
argument_list|(
name|aSign
operator|^
name|zSign
argument_list|,
name|bExp
argument_list|,
name|aSig
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the square root of the double-precision floating-point value `a'. The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float64
name|float64_sqrt
parameter_list|(
name|float64
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|,
name|zExp
decl_stmt|;
name|bits64
name|aSig
decl_stmt|,
name|zSig
decl_stmt|,
name|doubleZSig
decl_stmt|;
name|bits64
name|rem0
decl_stmt|,
name|rem1
decl_stmt|,
name|term0
decl_stmt|,
name|term1
decl_stmt|;
name|aSig
operator|=
name|extractFloat64Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat64Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat64Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0x7FF
condition|)
block|{
if|if
condition|(
name|aSig
condition|)
return|return
name|propagateFloat64NaN
argument_list|(
name|a
argument_list|,
name|a
argument_list|)
return|;
if|if
condition|(
operator|!
name|aSign
condition|)
return|return
name|a
return|;
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|float64_default_nan
return|;
block|}
if|if
condition|(
name|aSign
condition|)
block|{
if|if
condition|(
operator|(
name|aExp
operator||
name|aSig
operator|)
operator|==
literal|0
condition|)
return|return
name|a
return|;
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|float64_default_nan
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|aSig
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|normalizeFloat64Subnormal
argument_list|(
name|aSig
argument_list|,
operator|&
name|aExp
argument_list|,
operator|&
name|aSig
argument_list|)
expr_stmt|;
block|}
name|zExp
operator|=
operator|(
operator|(
name|aExp
operator|-
literal|0x3FF
operator|)
operator|>>
literal|1
operator|)
operator|+
literal|0x3FE
expr_stmt|;
name|aSig
operator||=
name|LIT64
argument_list|(
literal|0x0010000000000000
argument_list|)
expr_stmt|;
name|zSig
operator|=
name|estimateSqrt32
argument_list|(
name|aExp
argument_list|,
name|aSig
operator|>>
literal|21
argument_list|)
expr_stmt|;
name|aSig
operator|<<=
literal|9
operator|-
operator|(
name|aExp
operator|&
literal|1
operator|)
expr_stmt|;
name|zSig
operator|=
name|estimateDiv128To64
argument_list|(
name|aSig
argument_list|,
literal|0
argument_list|,
name|zSig
operator|<<
literal|32
argument_list|)
operator|+
operator|(
name|zSig
operator|<<
literal|30
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|zSig
operator|&
literal|0x1FF
operator|)
operator|<=
literal|5
condition|)
block|{
name|doubleZSig
operator|=
name|zSig
operator|<<
literal|1
expr_stmt|;
name|mul64To128
argument_list|(
name|zSig
argument_list|,
name|zSig
argument_list|,
operator|&
name|term0
argument_list|,
operator|&
name|term1
argument_list|)
expr_stmt|;
name|sub128
argument_list|(
name|aSig
argument_list|,
literal|0
argument_list|,
name|term0
argument_list|,
name|term1
argument_list|,
operator|&
name|rem0
argument_list|,
operator|&
name|rem1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|sbits64
operator|)
name|rem0
operator|<
literal|0
condition|)
block|{
operator|--
name|zSig
expr_stmt|;
name|doubleZSig
operator|-=
literal|2
expr_stmt|;
name|add128
argument_list|(
name|rem0
argument_list|,
name|rem1
argument_list|,
name|zSig
operator|>>
literal|63
argument_list|,
name|doubleZSig
operator||
literal|1
argument_list|,
operator|&
name|rem0
argument_list|,
operator|&
name|rem1
argument_list|)
expr_stmt|;
block|}
name|zSig
operator||=
operator|(
operator|(
name|rem0
operator||
name|rem1
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
return|return
name|roundAndPackFloat64
argument_list|(
literal|0
argument_list|,
name|zExp
argument_list|,
name|zSig
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns 1 if the double-precision floating-point value `a' is equal to the corresponding value `b', and 0 otherwise.  The comparison is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|flag
name|float64_eq
parameter_list|(
name|float64
name|a
parameter_list|,
name|float64
name|b
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|extractFloat64Exp
argument_list|(
name|a
argument_list|)
operator|==
literal|0x7FF
operator|)
operator|&&
name|extractFloat64Frac
argument_list|(
name|a
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|extractFloat64Exp
argument_list|(
name|b
argument_list|)
operator|==
literal|0x7FF
operator|)
operator|&&
name|extractFloat64Frac
argument_list|(
name|b
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|float64_is_signaling_nan
argument_list|(
name|a
argument_list|)
operator|||
name|float64_is_signaling_nan
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
return|return
operator|(
name|a
operator|==
name|b
operator|)
operator|||
operator|(
call|(
name|bits64
call|)
argument_list|(
operator|(
name|FLOAT64_DEMANGLE
argument_list|(
name|a
argument_list|)
operator||
name|FLOAT64_DEMANGLE
argument_list|(
name|b
argument_list|)
operator|)
operator|<<
literal|1
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns 1 if the double-precision floating-point value `a' is less than or equal to the corresponding value `b', and 0 otherwise.  The comparison is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|flag
name|float64_le
parameter_list|(
name|float64
name|a
parameter_list|,
name|float64
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|extractFloat64Exp
argument_list|(
name|a
argument_list|)
operator|==
literal|0x7FF
operator|)
operator|&&
name|extractFloat64Frac
argument_list|(
name|a
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|extractFloat64Exp
argument_list|(
name|b
argument_list|)
operator|==
literal|0x7FF
operator|)
operator|&&
name|extractFloat64Frac
argument_list|(
name|b
argument_list|)
operator|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|aSign
operator|=
name|extractFloat64Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat64Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aSign
operator|!=
name|bSign
condition|)
return|return
name|aSign
operator|||
operator|(
call|(
name|bits64
call|)
argument_list|(
operator|(
name|FLOAT64_DEMANGLE
argument_list|(
name|a
argument_list|)
operator||
name|FLOAT64_DEMANGLE
argument_list|(
name|b
argument_list|)
operator|)
operator|<<
literal|1
argument_list|)
operator|==
literal|0
operator|)
return|;
return|return
operator|(
name|a
operator|==
name|b
operator|)
operator|||
operator|(
name|aSign
operator|^
operator|(
name|FLOAT64_DEMANGLE
argument_list|(
name|a
argument_list|)
operator|<
name|FLOAT64_DEMANGLE
argument_list|(
name|b
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns 1 if the double-precision floating-point value `a' is less than the corresponding value `b', and 0 otherwise.  The comparison is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|flag
name|float64_lt
parameter_list|(
name|float64
name|a
parameter_list|,
name|float64
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|extractFloat64Exp
argument_list|(
name|a
argument_list|)
operator|==
literal|0x7FF
operator|)
operator|&&
name|extractFloat64Frac
argument_list|(
name|a
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|extractFloat64Exp
argument_list|(
name|b
argument_list|)
operator|==
literal|0x7FF
operator|)
operator|&&
name|extractFloat64Frac
argument_list|(
name|b
argument_list|)
operator|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|aSign
operator|=
name|extractFloat64Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat64Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aSign
operator|!=
name|bSign
condition|)
return|return
name|aSign
operator|&&
operator|(
call|(
name|bits64
call|)
argument_list|(
operator|(
name|FLOAT64_DEMANGLE
argument_list|(
name|a
argument_list|)
operator||
name|FLOAT64_DEMANGLE
argument_list|(
name|b
argument_list|)
operator|)
operator|<<
literal|1
argument_list|)
operator|!=
literal|0
operator|)
return|;
return|return
operator|(
name|a
operator|!=
name|b
operator|)
operator|&&
operator|(
name|aSign
operator|^
operator|(
name|FLOAT64_DEMANGLE
argument_list|(
name|a
argument_list|)
operator|<
name|FLOAT64_DEMANGLE
argument_list|(
name|b
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|SOFTFLOAT_FOR_GCC
end_ifndef

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns 1 if the double-precision floating-point value `a' is equal to the corresponding value `b', and 0 otherwise.  The invalid exception is raised if either operand is a NaN.  Otherwise, the comparison is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|flag
name|float64_eq_signaling
parameter_list|(
name|float64
name|a
parameter_list|,
name|float64
name|b
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|extractFloat64Exp
argument_list|(
name|a
argument_list|)
operator|==
literal|0x7FF
operator|)
operator|&&
name|extractFloat64Frac
argument_list|(
name|a
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|extractFloat64Exp
argument_list|(
name|b
argument_list|)
operator|==
literal|0x7FF
operator|)
operator|&&
name|extractFloat64Frac
argument_list|(
name|b
argument_list|)
operator|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|(
name|a
operator|==
name|b
operator|)
operator|||
operator|(
call|(
name|bits64
call|)
argument_list|(
operator|(
name|a
operator||
name|b
operator|)
operator|<<
literal|1
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns 1 if the double-precision floating-point value `a' is less than or equal to the corresponding value `b', and 0 otherwise.  Quiet NaNs do not cause an exception.  Otherwise, the comparison is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|flag
name|float64_le_quiet
parameter_list|(
name|float64
name|a
parameter_list|,
name|float64
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|extractFloat64Exp
argument_list|(
name|a
argument_list|)
operator|==
literal|0x7FF
operator|)
operator|&&
name|extractFloat64Frac
argument_list|(
name|a
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|extractFloat64Exp
argument_list|(
name|b
argument_list|)
operator|==
literal|0x7FF
operator|)
operator|&&
name|extractFloat64Frac
argument_list|(
name|b
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|float64_is_signaling_nan
argument_list|(
name|a
argument_list|)
operator|||
name|float64_is_signaling_nan
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|aSign
operator|=
name|extractFloat64Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat64Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aSign
operator|!=
name|bSign
condition|)
return|return
name|aSign
operator|||
operator|(
call|(
name|bits64
call|)
argument_list|(
operator|(
name|a
operator||
name|b
operator|)
operator|<<
literal|1
argument_list|)
operator|==
literal|0
operator|)
return|;
return|return
operator|(
name|a
operator|==
name|b
operator|)
operator|||
operator|(
name|aSign
operator|^
operator|(
name|a
operator|<
name|b
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns 1 if the double-precision floating-point value `a' is less than the corresponding value `b', and 0 otherwise.  Quiet NaNs do not cause an exception.  Otherwise, the comparison is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|flag
name|float64_lt_quiet
parameter_list|(
name|float64
name|a
parameter_list|,
name|float64
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|extractFloat64Exp
argument_list|(
name|a
argument_list|)
operator|==
literal|0x7FF
operator|)
operator|&&
name|extractFloat64Frac
argument_list|(
name|a
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|extractFloat64Exp
argument_list|(
name|b
argument_list|)
operator|==
literal|0x7FF
operator|)
operator|&&
name|extractFloat64Frac
argument_list|(
name|b
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|float64_is_signaling_nan
argument_list|(
name|a
argument_list|)
operator|||
name|float64_is_signaling_nan
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|aSign
operator|=
name|extractFloat64Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat64Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aSign
operator|!=
name|bSign
condition|)
return|return
name|aSign
operator|&&
operator|(
call|(
name|bits64
call|)
argument_list|(
operator|(
name|a
operator||
name|b
operator|)
operator|<<
literal|1
argument_list|)
operator|!=
literal|0
operator|)
return|;
return|return
operator|(
name|a
operator|!=
name|b
operator|)
operator|&&
operator|(
name|aSign
operator|^
operator|(
name|a
operator|<
name|b
operator|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|FLOATX80
end_ifdef

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the extended double-precision floating- point value `a' to the 32-bit two's complement integer format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic---which means in particular that the conversion is rounded according to the current rounding mode.  If `a' is a NaN, the largest positive integer is returned.  Otherwise, if the conversion overflows, the largest integer with the same sign as `a' is returned. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|int32
name|floatx80_to_int32
parameter_list|(
name|floatx80
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int32
name|aExp
decl_stmt|,
name|shiftCount
decl_stmt|;
name|bits64
name|aSig
decl_stmt|;
name|aSig
operator|=
name|extractFloatx80Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloatx80Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloatx80Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|aExp
operator|==
literal|0x7FFF
operator|)
operator|&&
call|(
name|bits64
call|)
argument_list|(
name|aSig
operator|<<
literal|1
argument_list|)
condition|)
name|aSign
operator|=
literal|0
expr_stmt|;
name|shiftCount
operator|=
literal|0x4037
operator|-
name|aExp
expr_stmt|;
if|if
condition|(
name|shiftCount
operator|<=
literal|0
condition|)
name|shiftCount
operator|=
literal|1
expr_stmt|;
name|shift64RightJamming
argument_list|(
name|aSig
argument_list|,
name|shiftCount
argument_list|,
operator|&
name|aSig
argument_list|)
expr_stmt|;
return|return
name|roundAndPackInt32
argument_list|(
name|aSign
argument_list|,
name|aSig
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the extended double-precision floating- point value `a' to the 32-bit two's complement integer format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic, except that the conversion is always rounded toward zero.  If `a' is a NaN, the largest positive integer is returned. Otherwise, if the conversion overflows, the largest integer with the same sign as `a' is returned. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|int32
name|floatx80_to_int32_round_to_zero
parameter_list|(
name|floatx80
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int32
name|aExp
decl_stmt|,
name|shiftCount
decl_stmt|;
name|bits64
name|aSig
decl_stmt|,
name|savedASig
decl_stmt|;
name|int32
name|z
decl_stmt|;
name|aSig
operator|=
name|extractFloatx80Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloatx80Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloatx80Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0x401E
operator|<
name|aExp
condition|)
block|{
if|if
condition|(
operator|(
name|aExp
operator|==
literal|0x7FFF
operator|)
operator|&&
call|(
name|bits64
call|)
argument_list|(
name|aSig
operator|<<
literal|1
argument_list|)
condition|)
name|aSign
operator|=
literal|0
expr_stmt|;
goto|goto
name|invalid
goto|;
block|}
elseif|else
if|if
condition|(
name|aExp
operator|<
literal|0x3FFF
condition|)
block|{
if|if
condition|(
name|aExp
operator|||
name|aSig
condition|)
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
return|return
literal|0
return|;
block|}
name|shiftCount
operator|=
literal|0x403E
operator|-
name|aExp
expr_stmt|;
name|savedASig
operator|=
name|aSig
expr_stmt|;
name|aSig
operator|>>=
name|shiftCount
expr_stmt|;
name|z
operator|=
name|aSig
expr_stmt|;
if|if
condition|(
name|aSign
condition|)
name|z
operator|=
operator|-
name|z
expr_stmt|;
if|if
condition|(
operator|(
name|z
operator|<
literal|0
operator|)
operator|^
name|aSign
condition|)
block|{
name|invalid
label|:
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|aSign
condition|?
operator|(
name|sbits32
operator|)
literal|0x80000000
else|:
literal|0x7FFFFFFF
return|;
block|}
if|if
condition|(
operator|(
name|aSig
operator|<<
name|shiftCount
operator|)
operator|!=
name|savedASig
condition|)
block|{
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
block|}
return|return
name|z
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the extended double-precision floating- point value `a' to the 64-bit two's complement integer format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic---which means in particular that the conversion is rounded according to the current rounding mode.  If `a' is a NaN, the largest positive integer is returned.  Otherwise, if the conversion overflows, the largest integer with the same sign as `a' is returned. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|int64
name|floatx80_to_int64
parameter_list|(
name|floatx80
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int32
name|aExp
decl_stmt|,
name|shiftCount
decl_stmt|;
name|bits64
name|aSig
decl_stmt|,
name|aSigExtra
decl_stmt|;
name|aSig
operator|=
name|extractFloatx80Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloatx80Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloatx80Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|shiftCount
operator|=
literal|0x403E
operator|-
name|aExp
expr_stmt|;
if|if
condition|(
name|shiftCount
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|shiftCount
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aSign
operator|||
operator|(
operator|(
name|aExp
operator|==
literal|0x7FFF
operator|)
operator|&&
operator|(
name|aSig
operator|!=
name|LIT64
argument_list|(
literal|0x8000000000000000
argument_list|)
operator|)
operator|)
condition|)
block|{
return|return
name|LIT64
argument_list|(
literal|0x7FFFFFFFFFFFFFFF
argument_list|)
return|;
block|}
return|return
operator|(
name|sbits64
operator|)
name|LIT64
argument_list|(
literal|0x8000000000000000
argument_list|)
return|;
block|}
name|aSigExtra
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|shift64ExtraRightJamming
argument_list|(
name|aSig
argument_list|,
literal|0
argument_list|,
name|shiftCount
argument_list|,
operator|&
name|aSig
argument_list|,
operator|&
name|aSigExtra
argument_list|)
expr_stmt|;
block|}
return|return
name|roundAndPackInt64
argument_list|(
name|aSign
argument_list|,
name|aSig
argument_list|,
name|aSigExtra
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the extended double-precision floating- point value `a' to the 64-bit two's complement integer format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic, except that the conversion is always rounded toward zero.  If `a' is a NaN, the largest positive integer is returned. Otherwise, if the conversion overflows, the largest integer with the same sign as `a' is returned. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|int64
name|floatx80_to_int64_round_to_zero
parameter_list|(
name|floatx80
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int32
name|aExp
decl_stmt|,
name|shiftCount
decl_stmt|;
name|bits64
name|aSig
decl_stmt|;
name|int64
name|z
decl_stmt|;
name|aSig
operator|=
name|extractFloatx80Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloatx80Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloatx80Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|shiftCount
operator|=
name|aExp
operator|-
literal|0x403E
expr_stmt|;
if|if
condition|(
literal|0
operator|<=
name|shiftCount
condition|)
block|{
name|aSig
operator|&=
name|LIT64
argument_list|(
literal|0x7FFFFFFFFFFFFFFF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|a
operator|.
name|high
operator|!=
literal|0xC03E
operator|)
operator|||
name|aSig
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aSign
operator|||
operator|(
operator|(
name|aExp
operator|==
literal|0x7FFF
operator|)
operator|&&
name|aSig
operator|)
condition|)
block|{
return|return
name|LIT64
argument_list|(
literal|0x7FFFFFFFFFFFFFFF
argument_list|)
return|;
block|}
block|}
return|return
operator|(
name|sbits64
operator|)
name|LIT64
argument_list|(
literal|0x8000000000000000
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|aExp
operator|<
literal|0x3FFF
condition|)
block|{
if|if
condition|(
name|aExp
operator||
name|aSig
condition|)
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
return|return
literal|0
return|;
block|}
name|z
operator|=
name|aSig
operator|>>
operator|(
operator|-
name|shiftCount
operator|)
expr_stmt|;
if|if
condition|(
call|(
name|bits64
call|)
argument_list|(
name|aSig
operator|<<
operator|(
name|shiftCount
operator|&
literal|63
operator|)
argument_list|)
condition|)
block|{
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
block|}
if|if
condition|(
name|aSign
condition|)
name|z
operator|=
operator|-
name|z
expr_stmt|;
return|return
name|z
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the extended double-precision floating- point value `a' to the single-precision floating-point format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float32
name|floatx80_to_float32
parameter_list|(
name|floatx80
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int32
name|aExp
decl_stmt|;
name|bits64
name|aSig
decl_stmt|;
name|aSig
operator|=
name|extractFloatx80Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloatx80Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloatx80Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0x7FFF
condition|)
block|{
if|if
condition|(
call|(
name|bits64
call|)
argument_list|(
name|aSig
operator|<<
literal|1
argument_list|)
condition|)
block|{
return|return
name|commonNaNToFloat32
argument_list|(
name|floatx80ToCommonNaN
argument_list|(
name|a
argument_list|)
argument_list|)
return|;
block|}
return|return
name|packFloat32
argument_list|(
name|aSign
argument_list|,
literal|0xFF
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|shift64RightJamming
argument_list|(
name|aSig
argument_list|,
literal|33
argument_list|,
operator|&
name|aSig
argument_list|)
expr_stmt|;
if|if
condition|(
name|aExp
operator|||
name|aSig
condition|)
name|aExp
operator|-=
literal|0x3F81
expr_stmt|;
return|return
name|roundAndPackFloat32
argument_list|(
name|aSign
argument_list|,
name|aExp
argument_list|,
name|aSig
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the extended double-precision floating- point value `a' to the double-precision floating-point format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float64
name|floatx80_to_float64
parameter_list|(
name|floatx80
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int32
name|aExp
decl_stmt|;
name|bits64
name|aSig
decl_stmt|,
name|zSig
decl_stmt|;
name|aSig
operator|=
name|extractFloatx80Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloatx80Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloatx80Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0x7FFF
condition|)
block|{
if|if
condition|(
call|(
name|bits64
call|)
argument_list|(
name|aSig
operator|<<
literal|1
argument_list|)
condition|)
block|{
return|return
name|commonNaNToFloat64
argument_list|(
name|floatx80ToCommonNaN
argument_list|(
name|a
argument_list|)
argument_list|)
return|;
block|}
return|return
name|packFloat64
argument_list|(
name|aSign
argument_list|,
literal|0x7FF
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|shift64RightJamming
argument_list|(
name|aSig
argument_list|,
literal|1
argument_list|,
operator|&
name|zSig
argument_list|)
expr_stmt|;
if|if
condition|(
name|aExp
operator|||
name|aSig
condition|)
name|aExp
operator|-=
literal|0x3C01
expr_stmt|;
return|return
name|roundAndPackFloat64
argument_list|(
name|aSign
argument_list|,
name|aExp
argument_list|,
name|zSig
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FLOAT128
end_ifdef

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the extended double-precision floating- point value `a' to the quadruple-precision floating-point format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float128
name|floatx80_to_float128
parameter_list|(
name|floatx80
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|;
name|bits64
name|aSig
decl_stmt|,
name|zSig0
decl_stmt|,
name|zSig1
decl_stmt|;
name|aSig
operator|=
name|extractFloatx80Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloatx80Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloatx80Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|aExp
operator|==
literal|0x7FFF
operator|)
operator|&&
call|(
name|bits64
call|)
argument_list|(
name|aSig
operator|<<
literal|1
argument_list|)
condition|)
block|{
return|return
name|commonNaNToFloat128
argument_list|(
name|floatx80ToCommonNaN
argument_list|(
name|a
argument_list|)
argument_list|)
return|;
block|}
name|shift128Right
argument_list|(
name|aSig
operator|<<
literal|1
argument_list|,
literal|0
argument_list|,
literal|16
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|)
expr_stmt|;
return|return
name|packFloat128
argument_list|(
name|aSign
argument_list|,
name|aExp
argument_list|,
name|zSig0
argument_list|,
name|zSig1
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ------------------------------------------------------------------------------- Rounds the extended double-precision floating-point value `a' to an integer, and returns the result as an extended quadruple-precision floating-point value.  The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|floatx80
name|floatx80_round_to_int
parameter_list|(
name|floatx80
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int32
name|aExp
decl_stmt|;
name|bits64
name|lastBitMask
decl_stmt|,
name|roundBitsMask
decl_stmt|;
name|int8
name|roundingMode
decl_stmt|;
name|floatx80
name|z
decl_stmt|;
name|aExp
operator|=
name|extractFloatx80Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0x403E
operator|<=
name|aExp
condition|)
block|{
if|if
condition|(
operator|(
name|aExp
operator|==
literal|0x7FFF
operator|)
operator|&&
call|(
name|bits64
call|)
argument_list|(
name|extractFloatx80Frac
argument_list|(
name|a
argument_list|)
operator|<<
literal|1
argument_list|)
condition|)
block|{
return|return
name|propagateFloatx80NaN
argument_list|(
name|a
argument_list|,
name|a
argument_list|)
return|;
block|}
return|return
name|a
return|;
block|}
if|if
condition|(
name|aExp
operator|<
literal|0x3FFF
condition|)
block|{
if|if
condition|(
operator|(
name|aExp
operator|==
literal|0
operator|)
operator|&&
operator|(
call|(
name|bits64
call|)
argument_list|(
name|extractFloatx80Frac
argument_list|(
name|a
argument_list|)
operator|<<
literal|1
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
return|return
name|a
return|;
block|}
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
name|aSign
operator|=
name|extractFloatx80Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|float_rounding_mode
condition|)
block|{
case|case
name|float_round_nearest_even
case|:
if|if
condition|(
operator|(
name|aExp
operator|==
literal|0x3FFE
operator|)
operator|&&
call|(
name|bits64
call|)
argument_list|(
name|extractFloatx80Frac
argument_list|(
name|a
argument_list|)
operator|<<
literal|1
argument_list|)
condition|)
block|{
return|return
name|packFloatx80
argument_list|(
name|aSign
argument_list|,
literal|0x3FFF
argument_list|,
name|LIT64
argument_list|(
literal|0x8000000000000000
argument_list|)
argument_list|)
return|;
block|}
break|break;
case|case
name|float_round_to_zero
case|:
break|break;
case|case
name|float_round_down
case|:
return|return
name|aSign
condition|?
name|packFloatx80
argument_list|(
literal|1
argument_list|,
literal|0x3FFF
argument_list|,
name|LIT64
argument_list|(
literal|0x8000000000000000
argument_list|)
argument_list|)
else|:
name|packFloatx80
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|float_round_up
case|:
return|return
name|aSign
condition|?
name|packFloatx80
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
else|:
name|packFloatx80
argument_list|(
literal|0
argument_list|,
literal|0x3FFF
argument_list|,
name|LIT64
argument_list|(
literal|0x8000000000000000
argument_list|)
argument_list|)
return|;
block|}
return|return
name|packFloatx80
argument_list|(
name|aSign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|lastBitMask
operator|=
literal|1
expr_stmt|;
name|lastBitMask
operator|<<=
literal|0x403E
operator|-
name|aExp
expr_stmt|;
name|roundBitsMask
operator|=
name|lastBitMask
operator|-
literal|1
expr_stmt|;
name|z
operator|=
name|a
expr_stmt|;
name|roundingMode
operator|=
name|float_rounding_mode
expr_stmt|;
if|if
condition|(
name|roundingMode
operator|==
name|float_round_nearest_even
condition|)
block|{
name|z
operator|.
name|low
operator|+=
name|lastBitMask
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|z
operator|.
name|low
operator|&
name|roundBitsMask
operator|)
operator|==
literal|0
condition|)
name|z
operator|.
name|low
operator|&=
operator|~
name|lastBitMask
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|roundingMode
operator|!=
name|float_round_to_zero
condition|)
block|{
if|if
condition|(
name|extractFloatx80Sign
argument_list|(
name|z
argument_list|)
operator|^
operator|(
name|roundingMode
operator|==
name|float_round_up
operator|)
condition|)
block|{
name|z
operator|.
name|low
operator|+=
name|roundBitsMask
expr_stmt|;
block|}
block|}
name|z
operator|.
name|low
operator|&=
operator|~
name|roundBitsMask
expr_stmt|;
if|if
condition|(
name|z
operator|.
name|low
operator|==
literal|0
condition|)
block|{
operator|++
name|z
operator|.
name|high
expr_stmt|;
name|z
operator|.
name|low
operator|=
name|LIT64
argument_list|(
literal|0x8000000000000000
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|z
operator|.
name|low
operator|!=
name|a
operator|.
name|low
condition|)
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
return|return
name|z
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of adding the absolute values of the extended double- precision floating-point values `a' and `b'.  If `zSign' is 1, the sum is negated before being returned.  `zSign' is ignored if the result is a NaN. The addition is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|floatx80
name|addFloatx80Sigs
parameter_list|(
name|floatx80
name|a
parameter_list|,
name|floatx80
name|b
parameter_list|,
name|flag
name|zSign
parameter_list|)
block|{
name|int32
name|aExp
decl_stmt|,
name|bExp
decl_stmt|,
name|zExp
decl_stmt|;
name|bits64
name|aSig
decl_stmt|,
name|bSig
decl_stmt|,
name|zSig0
decl_stmt|,
name|zSig1
decl_stmt|;
name|int32
name|expDiff
decl_stmt|;
name|aSig
operator|=
name|extractFloatx80Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloatx80Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSig
operator|=
name|extractFloatx80Frac
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bExp
operator|=
name|extractFloatx80Exp
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|expDiff
operator|=
name|aExp
operator|-
name|bExp
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|expDiff
condition|)
block|{
if|if
condition|(
name|aExp
operator|==
literal|0x7FFF
condition|)
block|{
if|if
condition|(
call|(
name|bits64
call|)
argument_list|(
name|aSig
operator|<<
literal|1
argument_list|)
condition|)
return|return
name|propagateFloatx80NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|a
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0
condition|)
operator|--
name|expDiff
expr_stmt|;
name|shift64ExtraRightJamming
argument_list|(
name|bSig
argument_list|,
literal|0
argument_list|,
name|expDiff
argument_list|,
operator|&
name|bSig
argument_list|,
operator|&
name|zSig1
argument_list|)
expr_stmt|;
name|zExp
operator|=
name|aExp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expDiff
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|bExp
operator|==
literal|0x7FFF
condition|)
block|{
if|if
condition|(
call|(
name|bits64
call|)
argument_list|(
name|bSig
operator|<<
literal|1
argument_list|)
condition|)
return|return
name|propagateFloatx80NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|packFloatx80
argument_list|(
name|zSign
argument_list|,
literal|0x7FFF
argument_list|,
name|LIT64
argument_list|(
literal|0x8000000000000000
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
operator|++
name|expDiff
expr_stmt|;
name|shift64ExtraRightJamming
argument_list|(
name|aSig
argument_list|,
literal|0
argument_list|,
operator|-
name|expDiff
argument_list|,
operator|&
name|aSig
argument_list|,
operator|&
name|zSig1
argument_list|)
expr_stmt|;
name|zExp
operator|=
name|bExp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|aExp
operator|==
literal|0x7FFF
condition|)
block|{
if|if
condition|(
call|(
name|bits64
call|)
argument_list|(
operator|(
name|aSig
operator||
name|bSig
operator|)
operator|<<
literal|1
argument_list|)
condition|)
block|{
return|return
name|propagateFloatx80NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
return|return
name|a
return|;
block|}
name|zSig1
operator|=
literal|0
expr_stmt|;
name|zSig0
operator|=
name|aSig
operator|+
name|bSig
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
name|normalizeFloatx80Subnormal
argument_list|(
name|zSig0
argument_list|,
operator|&
name|zExp
argument_list|,
operator|&
name|zSig0
argument_list|)
expr_stmt|;
goto|goto
name|roundAndPack
goto|;
block|}
name|zExp
operator|=
name|aExp
expr_stmt|;
goto|goto
name|shiftRight1
goto|;
block|}
name|zSig0
operator|=
name|aSig
operator|+
name|bSig
expr_stmt|;
if|if
condition|(
operator|(
name|sbits64
operator|)
name|zSig0
operator|<
literal|0
condition|)
goto|goto
name|roundAndPack
goto|;
name|shiftRight1
label|:
name|shift64ExtraRightJamming
argument_list|(
name|zSig0
argument_list|,
name|zSig1
argument_list|,
literal|1
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|)
expr_stmt|;
name|zSig0
operator||=
name|LIT64
argument_list|(
literal|0x8000000000000000
argument_list|)
expr_stmt|;
operator|++
name|zExp
expr_stmt|;
name|roundAndPack
label|:
return|return
name|roundAndPackFloatx80
argument_list|(
name|floatx80_rounding_precision
argument_list|,
name|zSign
argument_list|,
name|zExp
argument_list|,
name|zSig0
argument_list|,
name|zSig1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of subtracting the absolute values of the extended double-precision floating-point values `a' and `b'.  If `zSign' is 1, the difference is negated before being returned.  `zSign' is ignored if the result is a NaN.  The subtraction is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|floatx80
name|subFloatx80Sigs
parameter_list|(
name|floatx80
name|a
parameter_list|,
name|floatx80
name|b
parameter_list|,
name|flag
name|zSign
parameter_list|)
block|{
name|int32
name|aExp
decl_stmt|,
name|bExp
decl_stmt|,
name|zExp
decl_stmt|;
name|bits64
name|aSig
decl_stmt|,
name|bSig
decl_stmt|,
name|zSig0
decl_stmt|,
name|zSig1
decl_stmt|;
name|int32
name|expDiff
decl_stmt|;
name|floatx80
name|z
decl_stmt|;
name|aSig
operator|=
name|extractFloatx80Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloatx80Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSig
operator|=
name|extractFloatx80Frac
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bExp
operator|=
name|extractFloatx80Exp
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|expDiff
operator|=
name|aExp
operator|-
name|bExp
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|expDiff
condition|)
goto|goto
name|aExpBigger
goto|;
if|if
condition|(
name|expDiff
operator|<
literal|0
condition|)
goto|goto
name|bExpBigger
goto|;
if|if
condition|(
name|aExp
operator|==
literal|0x7FFF
condition|)
block|{
if|if
condition|(
call|(
name|bits64
call|)
argument_list|(
operator|(
name|aSig
operator||
name|bSig
operator|)
operator|<<
literal|1
argument_list|)
condition|)
block|{
return|return
name|propagateFloatx80NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
name|z
operator|.
name|low
operator|=
name|floatx80_default_nan_low
expr_stmt|;
name|z
operator|.
name|high
operator|=
name|floatx80_default_nan_high
expr_stmt|;
return|return
name|z
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
name|aExp
operator|=
literal|1
expr_stmt|;
name|bExp
operator|=
literal|1
expr_stmt|;
block|}
name|zSig1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bSig
operator|<
name|aSig
condition|)
goto|goto
name|aBigger
goto|;
if|if
condition|(
name|aSig
operator|<
name|bSig
condition|)
goto|goto
name|bBigger
goto|;
return|return
name|packFloatx80
argument_list|(
name|float_rounding_mode
operator|==
name|float_round_down
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|bExpBigger
label|:
if|if
condition|(
name|bExp
operator|==
literal|0x7FFF
condition|)
block|{
if|if
condition|(
call|(
name|bits64
call|)
argument_list|(
name|bSig
operator|<<
literal|1
argument_list|)
condition|)
return|return
name|propagateFloatx80NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|packFloatx80
argument_list|(
name|zSign
operator|^
literal|1
argument_list|,
literal|0x7FFF
argument_list|,
name|LIT64
argument_list|(
literal|0x8000000000000000
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
operator|++
name|expDiff
expr_stmt|;
name|shift128RightJamming
argument_list|(
name|aSig
argument_list|,
literal|0
argument_list|,
operator|-
name|expDiff
argument_list|,
operator|&
name|aSig
argument_list|,
operator|&
name|zSig1
argument_list|)
expr_stmt|;
name|bBigger
label|:
name|sub128
argument_list|(
name|bSig
argument_list|,
literal|0
argument_list|,
name|aSig
argument_list|,
name|zSig1
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|)
expr_stmt|;
name|zExp
operator|=
name|bExp
expr_stmt|;
name|zSign
operator|^=
literal|1
expr_stmt|;
goto|goto
name|normalizeRoundAndPack
goto|;
name|aExpBigger
label|:
if|if
condition|(
name|aExp
operator|==
literal|0x7FFF
condition|)
block|{
if|if
condition|(
call|(
name|bits64
call|)
argument_list|(
name|aSig
operator|<<
literal|1
argument_list|)
condition|)
return|return
name|propagateFloatx80NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|a
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0
condition|)
operator|--
name|expDiff
expr_stmt|;
name|shift128RightJamming
argument_list|(
name|bSig
argument_list|,
literal|0
argument_list|,
name|expDiff
argument_list|,
operator|&
name|bSig
argument_list|,
operator|&
name|zSig1
argument_list|)
expr_stmt|;
name|aBigger
label|:
name|sub128
argument_list|(
name|aSig
argument_list|,
literal|0
argument_list|,
name|bSig
argument_list|,
name|zSig1
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|)
expr_stmt|;
name|zExp
operator|=
name|aExp
expr_stmt|;
name|normalizeRoundAndPack
label|:
return|return
name|normalizeRoundAndPackFloatx80
argument_list|(
name|floatx80_rounding_precision
argument_list|,
name|zSign
argument_list|,
name|zExp
argument_list|,
name|zSig0
argument_list|,
name|zSig1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of adding the extended double-precision floating-point values `a' and `b'.  The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|floatx80
name|floatx80_add
parameter_list|(
name|floatx80
name|a
parameter_list|,
name|floatx80
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|;
name|aSign
operator|=
name|extractFloatx80Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloatx80Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aSign
operator|==
name|bSign
condition|)
block|{
return|return
name|addFloatx80Sigs
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|aSign
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|subFloatx80Sigs
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|aSign
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of subtracting the extended double-precision floating- point values `a' and `b'.  The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|floatx80
name|floatx80_sub
parameter_list|(
name|floatx80
name|a
parameter_list|,
name|floatx80
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|;
name|aSign
operator|=
name|extractFloatx80Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloatx80Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aSign
operator|==
name|bSign
condition|)
block|{
return|return
name|subFloatx80Sigs
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|aSign
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|addFloatx80Sigs
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|aSign
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of multiplying the extended double-precision floating- point values `a' and `b'.  The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|floatx80
name|floatx80_mul
parameter_list|(
name|floatx80
name|a
parameter_list|,
name|floatx80
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|,
name|zSign
decl_stmt|;
name|int32
name|aExp
decl_stmt|,
name|bExp
decl_stmt|,
name|zExp
decl_stmt|;
name|bits64
name|aSig
decl_stmt|,
name|bSig
decl_stmt|,
name|zSig0
decl_stmt|,
name|zSig1
decl_stmt|;
name|floatx80
name|z
decl_stmt|;
name|aSig
operator|=
name|extractFloatx80Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloatx80Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloatx80Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSig
operator|=
name|extractFloatx80Frac
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bExp
operator|=
name|extractFloatx80Exp
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloatx80Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|zSign
operator|=
name|aSign
operator|^
name|bSign
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0x7FFF
condition|)
block|{
if|if
condition|(
call|(
name|bits64
call|)
argument_list|(
name|aSig
operator|<<
literal|1
argument_list|)
operator|||
operator|(
operator|(
name|bExp
operator|==
literal|0x7FFF
operator|)
operator|&&
call|(
name|bits64
call|)
argument_list|(
name|bSig
operator|<<
literal|1
argument_list|)
operator|)
condition|)
block|{
return|return
name|propagateFloatx80NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|bExp
operator||
name|bSig
operator|)
operator|==
literal|0
condition|)
goto|goto
name|invalid
goto|;
return|return
name|packFloatx80
argument_list|(
name|zSign
argument_list|,
literal|0x7FFF
argument_list|,
name|LIT64
argument_list|(
literal|0x8000000000000000
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0x7FFF
condition|)
block|{
if|if
condition|(
call|(
name|bits64
call|)
argument_list|(
name|bSig
operator|<<
literal|1
argument_list|)
condition|)
return|return
name|propagateFloatx80NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
if|if
condition|(
operator|(
name|aExp
operator||
name|aSig
operator|)
operator|==
literal|0
condition|)
block|{
name|invalid
label|:
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
name|z
operator|.
name|low
operator|=
name|floatx80_default_nan_low
expr_stmt|;
name|z
operator|.
name|high
operator|=
name|floatx80_default_nan_high
expr_stmt|;
return|return
name|z
return|;
block|}
return|return
name|packFloatx80
argument_list|(
name|zSign
argument_list|,
literal|0x7FFF
argument_list|,
name|LIT64
argument_list|(
literal|0x8000000000000000
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|aSig
operator|==
literal|0
condition|)
return|return
name|packFloatx80
argument_list|(
name|zSign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|normalizeFloatx80Subnormal
argument_list|(
name|aSig
argument_list|,
operator|&
name|aExp
argument_list|,
operator|&
name|aSig
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bSig
operator|==
literal|0
condition|)
return|return
name|packFloatx80
argument_list|(
name|zSign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|normalizeFloatx80Subnormal
argument_list|(
name|bSig
argument_list|,
operator|&
name|bExp
argument_list|,
operator|&
name|bSig
argument_list|)
expr_stmt|;
block|}
name|zExp
operator|=
name|aExp
operator|+
name|bExp
operator|-
literal|0x3FFE
expr_stmt|;
name|mul64To128
argument_list|(
name|aSig
argument_list|,
name|bSig
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<
operator|(
name|sbits64
operator|)
name|zSig0
condition|)
block|{
name|shortShift128Left
argument_list|(
name|zSig0
argument_list|,
name|zSig1
argument_list|,
literal|1
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|)
expr_stmt|;
operator|--
name|zExp
expr_stmt|;
block|}
return|return
name|roundAndPackFloatx80
argument_list|(
name|floatx80_rounding_precision
argument_list|,
name|zSign
argument_list|,
name|zExp
argument_list|,
name|zSig0
argument_list|,
name|zSig1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of dividing the extended double-precision floating-point value `a' by the corresponding value `b'.  The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|floatx80
name|floatx80_div
parameter_list|(
name|floatx80
name|a
parameter_list|,
name|floatx80
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|,
name|zSign
decl_stmt|;
name|int32
name|aExp
decl_stmt|,
name|bExp
decl_stmt|,
name|zExp
decl_stmt|;
name|bits64
name|aSig
decl_stmt|,
name|bSig
decl_stmt|,
name|zSig0
decl_stmt|,
name|zSig1
decl_stmt|;
name|bits64
name|rem0
decl_stmt|,
name|rem1
decl_stmt|,
name|rem2
decl_stmt|,
name|term0
decl_stmt|,
name|term1
decl_stmt|,
name|term2
decl_stmt|;
name|floatx80
name|z
decl_stmt|;
name|aSig
operator|=
name|extractFloatx80Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloatx80Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloatx80Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSig
operator|=
name|extractFloatx80Frac
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bExp
operator|=
name|extractFloatx80Exp
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloatx80Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|zSign
operator|=
name|aSign
operator|^
name|bSign
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0x7FFF
condition|)
block|{
if|if
condition|(
call|(
name|bits64
call|)
argument_list|(
name|aSig
operator|<<
literal|1
argument_list|)
condition|)
return|return
name|propagateFloatx80NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
if|if
condition|(
name|bExp
operator|==
literal|0x7FFF
condition|)
block|{
if|if
condition|(
call|(
name|bits64
call|)
argument_list|(
name|bSig
operator|<<
literal|1
argument_list|)
condition|)
return|return
name|propagateFloatx80NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
goto|goto
name|invalid
goto|;
block|}
return|return
name|packFloatx80
argument_list|(
name|zSign
argument_list|,
literal|0x7FFF
argument_list|,
name|LIT64
argument_list|(
literal|0x8000000000000000
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0x7FFF
condition|)
block|{
if|if
condition|(
call|(
name|bits64
call|)
argument_list|(
name|bSig
operator|<<
literal|1
argument_list|)
condition|)
return|return
name|propagateFloatx80NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|packFloatx80
argument_list|(
name|zSign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bSig
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|aExp
operator||
name|aSig
operator|)
operator|==
literal|0
condition|)
block|{
name|invalid
label|:
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
name|z
operator|.
name|low
operator|=
name|floatx80_default_nan_low
expr_stmt|;
name|z
operator|.
name|high
operator|=
name|floatx80_default_nan_high
expr_stmt|;
return|return
name|z
return|;
block|}
name|float_raise
argument_list|(
name|float_flag_divbyzero
argument_list|)
expr_stmt|;
return|return
name|packFloatx80
argument_list|(
name|zSign
argument_list|,
literal|0x7FFF
argument_list|,
name|LIT64
argument_list|(
literal|0x8000000000000000
argument_list|)
argument_list|)
return|;
block|}
name|normalizeFloatx80Subnormal
argument_list|(
name|bSig
argument_list|,
operator|&
name|bExp
argument_list|,
operator|&
name|bSig
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|aSig
operator|==
literal|0
condition|)
return|return
name|packFloatx80
argument_list|(
name|zSign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|normalizeFloatx80Subnormal
argument_list|(
name|aSig
argument_list|,
operator|&
name|aExp
argument_list|,
operator|&
name|aSig
argument_list|)
expr_stmt|;
block|}
name|zExp
operator|=
name|aExp
operator|-
name|bExp
operator|+
literal|0x3FFE
expr_stmt|;
name|rem1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bSig
operator|<=
name|aSig
condition|)
block|{
name|shift128Right
argument_list|(
name|aSig
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|aSig
argument_list|,
operator|&
name|rem1
argument_list|)
expr_stmt|;
operator|++
name|zExp
expr_stmt|;
block|}
name|zSig0
operator|=
name|estimateDiv128To64
argument_list|(
name|aSig
argument_list|,
name|rem1
argument_list|,
name|bSig
argument_list|)
expr_stmt|;
name|mul64To128
argument_list|(
name|bSig
argument_list|,
name|zSig0
argument_list|,
operator|&
name|term0
argument_list|,
operator|&
name|term1
argument_list|)
expr_stmt|;
name|sub128
argument_list|(
name|aSig
argument_list|,
name|rem1
argument_list|,
name|term0
argument_list|,
name|term1
argument_list|,
operator|&
name|rem0
argument_list|,
operator|&
name|rem1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|sbits64
operator|)
name|rem0
operator|<
literal|0
condition|)
block|{
operator|--
name|zSig0
expr_stmt|;
name|add128
argument_list|(
name|rem0
argument_list|,
name|rem1
argument_list|,
literal|0
argument_list|,
name|bSig
argument_list|,
operator|&
name|rem0
argument_list|,
operator|&
name|rem1
argument_list|)
expr_stmt|;
block|}
name|zSig1
operator|=
name|estimateDiv128To64
argument_list|(
name|rem1
argument_list|,
literal|0
argument_list|,
name|bSig
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
name|bits64
call|)
argument_list|(
name|zSig1
operator|<<
literal|1
argument_list|)
operator|<=
literal|8
condition|)
block|{
name|mul64To128
argument_list|(
name|bSig
argument_list|,
name|zSig1
argument_list|,
operator|&
name|term1
argument_list|,
operator|&
name|term2
argument_list|)
expr_stmt|;
name|sub128
argument_list|(
name|rem1
argument_list|,
literal|0
argument_list|,
name|term1
argument_list|,
name|term2
argument_list|,
operator|&
name|rem1
argument_list|,
operator|&
name|rem2
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|sbits64
operator|)
name|rem1
operator|<
literal|0
condition|)
block|{
operator|--
name|zSig1
expr_stmt|;
name|add128
argument_list|(
name|rem1
argument_list|,
name|rem2
argument_list|,
literal|0
argument_list|,
name|bSig
argument_list|,
operator|&
name|rem1
argument_list|,
operator|&
name|rem2
argument_list|)
expr_stmt|;
block|}
name|zSig1
operator||=
operator|(
operator|(
name|rem1
operator||
name|rem2
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
return|return
name|roundAndPackFloatx80
argument_list|(
name|floatx80_rounding_precision
argument_list|,
name|zSign
argument_list|,
name|zExp
argument_list|,
name|zSig0
argument_list|,
name|zSig1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the remainder of the extended double-precision floating-point value `a' with respect to the corresponding value `b'.  The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|floatx80
name|floatx80_rem
parameter_list|(
name|floatx80
name|a
parameter_list|,
name|floatx80
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|,
name|zSign
decl_stmt|;
name|int32
name|aExp
decl_stmt|,
name|bExp
decl_stmt|,
name|expDiff
decl_stmt|;
name|bits64
name|aSig0
decl_stmt|,
name|aSig1
decl_stmt|,
name|bSig
decl_stmt|;
name|bits64
name|q
decl_stmt|,
name|term0
decl_stmt|,
name|term1
decl_stmt|,
name|alternateASig0
decl_stmt|,
name|alternateASig1
decl_stmt|;
name|floatx80
name|z
decl_stmt|;
name|aSig0
operator|=
name|extractFloatx80Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloatx80Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloatx80Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSig
operator|=
name|extractFloatx80Frac
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bExp
operator|=
name|extractFloatx80Exp
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloatx80Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0x7FFF
condition|)
block|{
if|if
condition|(
call|(
name|bits64
call|)
argument_list|(
name|aSig0
operator|<<
literal|1
argument_list|)
operator|||
operator|(
operator|(
name|bExp
operator|==
literal|0x7FFF
operator|)
operator|&&
call|(
name|bits64
call|)
argument_list|(
name|bSig
operator|<<
literal|1
argument_list|)
operator|)
condition|)
block|{
return|return
name|propagateFloatx80NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
goto|goto
name|invalid
goto|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0x7FFF
condition|)
block|{
if|if
condition|(
call|(
name|bits64
call|)
argument_list|(
name|bSig
operator|<<
literal|1
argument_list|)
condition|)
return|return
name|propagateFloatx80NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|a
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bSig
operator|==
literal|0
condition|)
block|{
name|invalid
label|:
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
name|z
operator|.
name|low
operator|=
name|floatx80_default_nan_low
expr_stmt|;
name|z
operator|.
name|high
operator|=
name|floatx80_default_nan_high
expr_stmt|;
return|return
name|z
return|;
block|}
name|normalizeFloatx80Subnormal
argument_list|(
name|bSig
argument_list|,
operator|&
name|bExp
argument_list|,
operator|&
name|bSig
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
call|(
name|bits64
call|)
argument_list|(
name|aSig0
operator|<<
literal|1
argument_list|)
operator|==
literal|0
condition|)
return|return
name|a
return|;
name|normalizeFloatx80Subnormal
argument_list|(
name|aSig0
argument_list|,
operator|&
name|aExp
argument_list|,
operator|&
name|aSig0
argument_list|)
expr_stmt|;
block|}
name|bSig
operator||=
name|LIT64
argument_list|(
literal|0x8000000000000000
argument_list|)
expr_stmt|;
name|zSign
operator|=
name|aSign
expr_stmt|;
name|expDiff
operator|=
name|aExp
operator|-
name|bExp
expr_stmt|;
name|aSig1
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|expDiff
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|expDiff
operator|<
operator|-
literal|1
condition|)
return|return
name|a
return|;
name|shift128Right
argument_list|(
name|aSig0
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
name|expDiff
operator|=
literal|0
expr_stmt|;
block|}
name|q
operator|=
operator|(
name|bSig
operator|<=
name|aSig0
operator|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
name|aSig0
operator|-=
name|bSig
expr_stmt|;
name|expDiff
operator|-=
literal|64
expr_stmt|;
while|while
condition|(
literal|0
operator|<
name|expDiff
condition|)
block|{
name|q
operator|=
name|estimateDiv128To64
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
name|bSig
argument_list|)
expr_stmt|;
name|q
operator|=
operator|(
literal|2
operator|<
name|q
operator|)
condition|?
name|q
operator|-
literal|2
else|:
literal|0
expr_stmt|;
name|mul64To128
argument_list|(
name|bSig
argument_list|,
name|q
argument_list|,
operator|&
name|term0
argument_list|,
operator|&
name|term1
argument_list|)
expr_stmt|;
name|sub128
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
name|term0
argument_list|,
name|term1
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
name|shortShift128Left
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
literal|62
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
name|expDiff
operator|-=
literal|62
expr_stmt|;
block|}
name|expDiff
operator|+=
literal|64
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|expDiff
condition|)
block|{
name|q
operator|=
name|estimateDiv128To64
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
name|bSig
argument_list|)
expr_stmt|;
name|q
operator|=
operator|(
literal|2
operator|<
name|q
operator|)
condition|?
name|q
operator|-
literal|2
else|:
literal|0
expr_stmt|;
name|q
operator|>>=
literal|64
operator|-
name|expDiff
expr_stmt|;
name|mul64To128
argument_list|(
name|bSig
argument_list|,
name|q
operator|<<
operator|(
literal|64
operator|-
name|expDiff
operator|)
argument_list|,
operator|&
name|term0
argument_list|,
operator|&
name|term1
argument_list|)
expr_stmt|;
name|sub128
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
name|term0
argument_list|,
name|term1
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
name|shortShift128Left
argument_list|(
literal|0
argument_list|,
name|bSig
argument_list|,
literal|64
operator|-
name|expDiff
argument_list|,
operator|&
name|term0
argument_list|,
operator|&
name|term1
argument_list|)
expr_stmt|;
while|while
condition|(
name|le128
argument_list|(
name|term0
argument_list|,
name|term1
argument_list|,
name|aSig0
argument_list|,
name|aSig1
argument_list|)
condition|)
block|{
operator|++
name|q
expr_stmt|;
name|sub128
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
name|term0
argument_list|,
name|term1
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|term1
operator|=
literal|0
expr_stmt|;
name|term0
operator|=
name|bSig
expr_stmt|;
block|}
name|sub128
argument_list|(
name|term0
argument_list|,
name|term1
argument_list|,
name|aSig0
argument_list|,
name|aSig1
argument_list|,
operator|&
name|alternateASig0
argument_list|,
operator|&
name|alternateASig1
argument_list|)
expr_stmt|;
if|if
condition|(
name|lt128
argument_list|(
name|alternateASig0
argument_list|,
name|alternateASig1
argument_list|,
name|aSig0
argument_list|,
name|aSig1
argument_list|)
operator|||
operator|(
name|eq128
argument_list|(
name|alternateASig0
argument_list|,
name|alternateASig1
argument_list|,
name|aSig0
argument_list|,
name|aSig1
argument_list|)
operator|&&
operator|(
name|q
operator|&
literal|1
operator|)
operator|)
condition|)
block|{
name|aSig0
operator|=
name|alternateASig0
expr_stmt|;
name|aSig1
operator|=
name|alternateASig1
expr_stmt|;
name|zSign
operator|=
operator|!
name|zSign
expr_stmt|;
block|}
return|return
name|normalizeRoundAndPackFloatx80
argument_list|(
literal|80
argument_list|,
name|zSign
argument_list|,
name|bExp
operator|+
name|expDiff
argument_list|,
name|aSig0
argument_list|,
name|aSig1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the square root of the extended double-precision floating-point value `a'.  The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|floatx80
name|floatx80_sqrt
parameter_list|(
name|floatx80
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int32
name|aExp
decl_stmt|,
name|zExp
decl_stmt|;
name|bits64
name|aSig0
decl_stmt|,
name|aSig1
decl_stmt|,
name|zSig0
decl_stmt|,
name|zSig1
decl_stmt|,
name|doubleZSig0
decl_stmt|;
name|bits64
name|rem0
decl_stmt|,
name|rem1
decl_stmt|,
name|rem2
decl_stmt|,
name|rem3
decl_stmt|,
name|term0
decl_stmt|,
name|term1
decl_stmt|,
name|term2
decl_stmt|,
name|term3
decl_stmt|;
name|floatx80
name|z
decl_stmt|;
name|aSig0
operator|=
name|extractFloatx80Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloatx80Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloatx80Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0x7FFF
condition|)
block|{
if|if
condition|(
call|(
name|bits64
call|)
argument_list|(
name|aSig0
operator|<<
literal|1
argument_list|)
condition|)
return|return
name|propagateFloatx80NaN
argument_list|(
name|a
argument_list|,
name|a
argument_list|)
return|;
if|if
condition|(
operator|!
name|aSign
condition|)
return|return
name|a
return|;
goto|goto
name|invalid
goto|;
block|}
if|if
condition|(
name|aSign
condition|)
block|{
if|if
condition|(
operator|(
name|aExp
operator||
name|aSig0
operator|)
operator|==
literal|0
condition|)
return|return
name|a
return|;
name|invalid
label|:
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
name|z
operator|.
name|low
operator|=
name|floatx80_default_nan_low
expr_stmt|;
name|z
operator|.
name|high
operator|=
name|floatx80_default_nan_high
expr_stmt|;
return|return
name|z
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|aSig0
operator|==
literal|0
condition|)
return|return
name|packFloatx80
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|normalizeFloatx80Subnormal
argument_list|(
name|aSig0
argument_list|,
operator|&
name|aExp
argument_list|,
operator|&
name|aSig0
argument_list|)
expr_stmt|;
block|}
name|zExp
operator|=
operator|(
operator|(
name|aExp
operator|-
literal|0x3FFF
operator|)
operator|>>
literal|1
operator|)
operator|+
literal|0x3FFF
expr_stmt|;
name|zSig0
operator|=
name|estimateSqrt32
argument_list|(
name|aExp
argument_list|,
name|aSig0
operator|>>
literal|32
argument_list|)
expr_stmt|;
name|shift128Right
argument_list|(
name|aSig0
argument_list|,
literal|0
argument_list|,
literal|2
operator|+
operator|(
name|aExp
operator|&
literal|1
operator|)
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
name|zSig0
operator|=
name|estimateDiv128To64
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
name|zSig0
operator|<<
literal|32
argument_list|)
operator|+
operator|(
name|zSig0
operator|<<
literal|30
operator|)
expr_stmt|;
name|doubleZSig0
operator|=
name|zSig0
operator|<<
literal|1
expr_stmt|;
name|mul64To128
argument_list|(
name|zSig0
argument_list|,
name|zSig0
argument_list|,
operator|&
name|term0
argument_list|,
operator|&
name|term1
argument_list|)
expr_stmt|;
name|sub128
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
name|term0
argument_list|,
name|term1
argument_list|,
operator|&
name|rem0
argument_list|,
operator|&
name|rem1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|sbits64
operator|)
name|rem0
operator|<
literal|0
condition|)
block|{
operator|--
name|zSig0
expr_stmt|;
name|doubleZSig0
operator|-=
literal|2
expr_stmt|;
name|add128
argument_list|(
name|rem0
argument_list|,
name|rem1
argument_list|,
name|zSig0
operator|>>
literal|63
argument_list|,
name|doubleZSig0
operator||
literal|1
argument_list|,
operator|&
name|rem0
argument_list|,
operator|&
name|rem1
argument_list|)
expr_stmt|;
block|}
name|zSig1
operator|=
name|estimateDiv128To64
argument_list|(
name|rem1
argument_list|,
literal|0
argument_list|,
name|doubleZSig0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zSig1
operator|&
name|LIT64
argument_list|(
literal|0x3FFFFFFFFFFFFFFF
argument_list|)
operator|)
operator|<=
literal|5
condition|)
block|{
if|if
condition|(
name|zSig1
operator|==
literal|0
condition|)
name|zSig1
operator|=
literal|1
expr_stmt|;
name|mul64To128
argument_list|(
name|doubleZSig0
argument_list|,
name|zSig1
argument_list|,
operator|&
name|term1
argument_list|,
operator|&
name|term2
argument_list|)
expr_stmt|;
name|sub128
argument_list|(
name|rem1
argument_list|,
literal|0
argument_list|,
name|term1
argument_list|,
name|term2
argument_list|,
operator|&
name|rem1
argument_list|,
operator|&
name|rem2
argument_list|)
expr_stmt|;
name|mul64To128
argument_list|(
name|zSig1
argument_list|,
name|zSig1
argument_list|,
operator|&
name|term2
argument_list|,
operator|&
name|term3
argument_list|)
expr_stmt|;
name|sub192
argument_list|(
name|rem1
argument_list|,
name|rem2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|term2
argument_list|,
name|term3
argument_list|,
operator|&
name|rem1
argument_list|,
operator|&
name|rem2
argument_list|,
operator|&
name|rem3
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|sbits64
operator|)
name|rem1
operator|<
literal|0
condition|)
block|{
operator|--
name|zSig1
expr_stmt|;
name|shortShift128Left
argument_list|(
literal|0
argument_list|,
name|zSig1
argument_list|,
literal|1
argument_list|,
operator|&
name|term2
argument_list|,
operator|&
name|term3
argument_list|)
expr_stmt|;
name|term3
operator||=
literal|1
expr_stmt|;
name|term2
operator||=
name|doubleZSig0
expr_stmt|;
name|add192
argument_list|(
name|rem1
argument_list|,
name|rem2
argument_list|,
name|rem3
argument_list|,
literal|0
argument_list|,
name|term2
argument_list|,
name|term3
argument_list|,
operator|&
name|rem1
argument_list|,
operator|&
name|rem2
argument_list|,
operator|&
name|rem3
argument_list|)
expr_stmt|;
block|}
name|zSig1
operator||=
operator|(
operator|(
name|rem1
operator||
name|rem2
operator||
name|rem3
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
name|shortShift128Left
argument_list|(
literal|0
argument_list|,
name|zSig1
argument_list|,
literal|1
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|)
expr_stmt|;
name|zSig0
operator||=
name|doubleZSig0
expr_stmt|;
return|return
name|roundAndPackFloatx80
argument_list|(
name|floatx80_rounding_precision
argument_list|,
literal|0
argument_list|,
name|zExp
argument_list|,
name|zSig0
argument_list|,
name|zSig1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns 1 if the extended double-precision floating-point value `a' is equal to the corresponding value `b', and 0 otherwise.  The comparison is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|flag
name|floatx80_eq
parameter_list|(
name|floatx80
name|a
parameter_list|,
name|floatx80
name|b
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|extractFloatx80Exp
argument_list|(
name|a
argument_list|)
operator|==
literal|0x7FFF
operator|)
operator|&&
call|(
name|bits64
call|)
argument_list|(
name|extractFloatx80Frac
argument_list|(
name|a
argument_list|)
operator|<<
literal|1
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|extractFloatx80Exp
argument_list|(
name|b
argument_list|)
operator|==
literal|0x7FFF
operator|)
operator|&&
call|(
name|bits64
call|)
argument_list|(
name|extractFloatx80Frac
argument_list|(
name|b
argument_list|)
operator|<<
literal|1
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|floatx80_is_signaling_nan
argument_list|(
name|a
argument_list|)
operator|||
name|floatx80_is_signaling_nan
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
return|return
operator|(
name|a
operator|.
name|low
operator|==
name|b
operator|.
name|low
operator|)
operator|&&
operator|(
operator|(
name|a
operator|.
name|high
operator|==
name|b
operator|.
name|high
operator|)
operator|||
operator|(
operator|(
name|a
operator|.
name|low
operator|==
literal|0
operator|)
operator|&&
operator|(
call|(
name|bits16
call|)
argument_list|(
operator|(
name|a
operator|.
name|high
operator||
name|b
operator|.
name|high
operator|)
operator|<<
literal|1
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns 1 if the extended double-precision floating-point value `a' is less than or equal to the corresponding value `b', and 0 otherwise.  The comparison is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|flag
name|floatx80_le
parameter_list|(
name|floatx80
name|a
parameter_list|,
name|floatx80
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|extractFloatx80Exp
argument_list|(
name|a
argument_list|)
operator|==
literal|0x7FFF
operator|)
operator|&&
call|(
name|bits64
call|)
argument_list|(
name|extractFloatx80Frac
argument_list|(
name|a
argument_list|)
operator|<<
literal|1
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|extractFloatx80Exp
argument_list|(
name|b
argument_list|)
operator|==
literal|0x7FFF
operator|)
operator|&&
call|(
name|bits64
call|)
argument_list|(
name|extractFloatx80Frac
argument_list|(
name|b
argument_list|)
operator|<<
literal|1
argument_list|)
operator|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|aSign
operator|=
name|extractFloatx80Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloatx80Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aSign
operator|!=
name|bSign
condition|)
block|{
return|return
name|aSign
operator|||
operator|(
operator|(
operator|(
call|(
name|bits16
call|)
argument_list|(
operator|(
name|a
operator|.
name|high
operator||
name|b
operator|.
name|high
operator|)
operator|<<
literal|1
argument_list|)
operator|)
operator||
name|a
operator|.
name|low
operator||
name|b
operator|.
name|low
operator|)
operator|==
literal|0
operator|)
return|;
block|}
return|return
name|aSign
condition|?
name|le128
argument_list|(
name|b
operator|.
name|high
argument_list|,
name|b
operator|.
name|low
argument_list|,
name|a
operator|.
name|high
argument_list|,
name|a
operator|.
name|low
argument_list|)
else|:
name|le128
argument_list|(
name|a
operator|.
name|high
argument_list|,
name|a
operator|.
name|low
argument_list|,
name|b
operator|.
name|high
argument_list|,
name|b
operator|.
name|low
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns 1 if the extended double-precision floating-point value `a' is less than the corresponding value `b', and 0 otherwise.  The comparison is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|flag
name|floatx80_lt
parameter_list|(
name|floatx80
name|a
parameter_list|,
name|floatx80
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|extractFloatx80Exp
argument_list|(
name|a
argument_list|)
operator|==
literal|0x7FFF
operator|)
operator|&&
call|(
name|bits64
call|)
argument_list|(
name|extractFloatx80Frac
argument_list|(
name|a
argument_list|)
operator|<<
literal|1
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|extractFloatx80Exp
argument_list|(
name|b
argument_list|)
operator|==
literal|0x7FFF
operator|)
operator|&&
call|(
name|bits64
call|)
argument_list|(
name|extractFloatx80Frac
argument_list|(
name|b
argument_list|)
operator|<<
literal|1
argument_list|)
operator|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|aSign
operator|=
name|extractFloatx80Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloatx80Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aSign
operator|!=
name|bSign
condition|)
block|{
return|return
name|aSign
operator|&&
operator|(
operator|(
operator|(
call|(
name|bits16
call|)
argument_list|(
operator|(
name|a
operator|.
name|high
operator||
name|b
operator|.
name|high
operator|)
operator|<<
literal|1
argument_list|)
operator|)
operator||
name|a
operator|.
name|low
operator||
name|b
operator|.
name|low
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
return|return
name|aSign
condition|?
name|lt128
argument_list|(
name|b
operator|.
name|high
argument_list|,
name|b
operator|.
name|low
argument_list|,
name|a
operator|.
name|high
argument_list|,
name|a
operator|.
name|low
argument_list|)
else|:
name|lt128
argument_list|(
name|a
operator|.
name|high
argument_list|,
name|a
operator|.
name|low
argument_list|,
name|b
operator|.
name|high
argument_list|,
name|b
operator|.
name|low
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns 1 if the extended double-precision floating-point value `a' is equal to the corresponding value `b', and 0 otherwise.  The invalid exception is raised if either operand is a NaN.  Otherwise, the comparison is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|flag
name|floatx80_eq_signaling
parameter_list|(
name|floatx80
name|a
parameter_list|,
name|floatx80
name|b
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|extractFloatx80Exp
argument_list|(
name|a
argument_list|)
operator|==
literal|0x7FFF
operator|)
operator|&&
call|(
name|bits64
call|)
argument_list|(
name|extractFloatx80Frac
argument_list|(
name|a
argument_list|)
operator|<<
literal|1
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|extractFloatx80Exp
argument_list|(
name|b
argument_list|)
operator|==
literal|0x7FFF
operator|)
operator|&&
call|(
name|bits64
call|)
argument_list|(
name|extractFloatx80Frac
argument_list|(
name|b
argument_list|)
operator|<<
literal|1
argument_list|)
operator|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|(
name|a
operator|.
name|low
operator|==
name|b
operator|.
name|low
operator|)
operator|&&
operator|(
operator|(
name|a
operator|.
name|high
operator|==
name|b
operator|.
name|high
operator|)
operator|||
operator|(
operator|(
name|a
operator|.
name|low
operator|==
literal|0
operator|)
operator|&&
operator|(
call|(
name|bits16
call|)
argument_list|(
operator|(
name|a
operator|.
name|high
operator||
name|b
operator|.
name|high
operator|)
operator|<<
literal|1
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns 1 if the extended double-precision floating-point value `a' is less than or equal to the corresponding value `b', and 0 otherwise.  Quiet NaNs do not cause an exception.  Otherwise, the comparison is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|flag
name|floatx80_le_quiet
parameter_list|(
name|floatx80
name|a
parameter_list|,
name|floatx80
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|extractFloatx80Exp
argument_list|(
name|a
argument_list|)
operator|==
literal|0x7FFF
operator|)
operator|&&
call|(
name|bits64
call|)
argument_list|(
name|extractFloatx80Frac
argument_list|(
name|a
argument_list|)
operator|<<
literal|1
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|extractFloatx80Exp
argument_list|(
name|b
argument_list|)
operator|==
literal|0x7FFF
operator|)
operator|&&
call|(
name|bits64
call|)
argument_list|(
name|extractFloatx80Frac
argument_list|(
name|b
argument_list|)
operator|<<
literal|1
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|floatx80_is_signaling_nan
argument_list|(
name|a
argument_list|)
operator|||
name|floatx80_is_signaling_nan
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|aSign
operator|=
name|extractFloatx80Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloatx80Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aSign
operator|!=
name|bSign
condition|)
block|{
return|return
name|aSign
operator|||
operator|(
operator|(
operator|(
call|(
name|bits16
call|)
argument_list|(
operator|(
name|a
operator|.
name|high
operator||
name|b
operator|.
name|high
operator|)
operator|<<
literal|1
argument_list|)
operator|)
operator||
name|a
operator|.
name|low
operator||
name|b
operator|.
name|low
operator|)
operator|==
literal|0
operator|)
return|;
block|}
return|return
name|aSign
condition|?
name|le128
argument_list|(
name|b
operator|.
name|high
argument_list|,
name|b
operator|.
name|low
argument_list|,
name|a
operator|.
name|high
argument_list|,
name|a
operator|.
name|low
argument_list|)
else|:
name|le128
argument_list|(
name|a
operator|.
name|high
argument_list|,
name|a
operator|.
name|low
argument_list|,
name|b
operator|.
name|high
argument_list|,
name|b
operator|.
name|low
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns 1 if the extended double-precision floating-point value `a' is less than the corresponding value `b', and 0 otherwise.  Quiet NaNs do not cause an exception.  Otherwise, the comparison is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|flag
name|floatx80_lt_quiet
parameter_list|(
name|floatx80
name|a
parameter_list|,
name|floatx80
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|extractFloatx80Exp
argument_list|(
name|a
argument_list|)
operator|==
literal|0x7FFF
operator|)
operator|&&
call|(
name|bits64
call|)
argument_list|(
name|extractFloatx80Frac
argument_list|(
name|a
argument_list|)
operator|<<
literal|1
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|extractFloatx80Exp
argument_list|(
name|b
argument_list|)
operator|==
literal|0x7FFF
operator|)
operator|&&
call|(
name|bits64
call|)
argument_list|(
name|extractFloatx80Frac
argument_list|(
name|b
argument_list|)
operator|<<
literal|1
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|floatx80_is_signaling_nan
argument_list|(
name|a
argument_list|)
operator|||
name|floatx80_is_signaling_nan
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|aSign
operator|=
name|extractFloatx80Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloatx80Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aSign
operator|!=
name|bSign
condition|)
block|{
return|return
name|aSign
operator|&&
operator|(
operator|(
operator|(
call|(
name|bits16
call|)
argument_list|(
operator|(
name|a
operator|.
name|high
operator||
name|b
operator|.
name|high
operator|)
operator|<<
literal|1
argument_list|)
operator|)
operator||
name|a
operator|.
name|low
operator||
name|b
operator|.
name|low
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
return|return
name|aSign
condition|?
name|lt128
argument_list|(
name|b
operator|.
name|high
argument_list|,
name|b
operator|.
name|low
argument_list|,
name|a
operator|.
name|high
argument_list|,
name|a
operator|.
name|low
argument_list|)
else|:
name|lt128
argument_list|(
name|a
operator|.
name|high
argument_list|,
name|a
operator|.
name|low
argument_list|,
name|b
operator|.
name|high
argument_list|,
name|b
operator|.
name|low
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|FLOAT128
end_ifdef

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the quadruple-precision floating-point value `a' to the 32-bit two's complement integer format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic---which means in particular that the conversion is rounded according to the current rounding mode.  If `a' is a NaN, the largest positive integer is returned.  Otherwise, if the conversion overflows, the largest integer with the same sign as `a' is returned. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|int32
name|float128_to_int32
parameter_list|(
name|float128
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int32
name|aExp
decl_stmt|,
name|shiftCount
decl_stmt|;
name|bits64
name|aSig0
decl_stmt|,
name|aSig1
decl_stmt|;
name|aSig1
operator|=
name|extractFloat128Frac1
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSig0
operator|=
name|extractFloat128Frac0
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat128Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat128Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|aExp
operator|==
literal|0x7FFF
operator|)
operator|&&
operator|(
name|aSig0
operator||
name|aSig1
operator|)
condition|)
name|aSign
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|aExp
condition|)
name|aSig0
operator||=
name|LIT64
argument_list|(
literal|0x0001000000000000
argument_list|)
expr_stmt|;
name|aSig0
operator||=
operator|(
name|aSig1
operator|!=
literal|0
operator|)
expr_stmt|;
name|shiftCount
operator|=
literal|0x4028
operator|-
name|aExp
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|shiftCount
condition|)
name|shift64RightJamming
argument_list|(
name|aSig0
argument_list|,
name|shiftCount
argument_list|,
operator|&
name|aSig0
argument_list|)
expr_stmt|;
return|return
name|roundAndPackInt32
argument_list|(
name|aSign
argument_list|,
name|aSig0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the quadruple-precision floating-point value `a' to the 32-bit two's complement integer format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic, except that the conversion is always rounded toward zero.  If `a' is a NaN, the largest positive integer is returned.  Otherwise, if the conversion overflows, the largest integer with the same sign as `a' is returned. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|int32
name|float128_to_int32_round_to_zero
parameter_list|(
name|float128
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int32
name|aExp
decl_stmt|,
name|shiftCount
decl_stmt|;
name|bits64
name|aSig0
decl_stmt|,
name|aSig1
decl_stmt|,
name|savedASig
decl_stmt|;
name|int32
name|z
decl_stmt|;
name|aSig1
operator|=
name|extractFloat128Frac1
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSig0
operator|=
name|extractFloat128Frac0
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat128Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat128Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSig0
operator||=
operator|(
name|aSig1
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
literal|0x401E
operator|<
name|aExp
condition|)
block|{
if|if
condition|(
operator|(
name|aExp
operator|==
literal|0x7FFF
operator|)
operator|&&
name|aSig0
condition|)
name|aSign
operator|=
literal|0
expr_stmt|;
goto|goto
name|invalid
goto|;
block|}
elseif|else
if|if
condition|(
name|aExp
operator|<
literal|0x3FFF
condition|)
block|{
if|if
condition|(
name|aExp
operator|||
name|aSig0
condition|)
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
return|return
literal|0
return|;
block|}
name|aSig0
operator||=
name|LIT64
argument_list|(
literal|0x0001000000000000
argument_list|)
expr_stmt|;
name|shiftCount
operator|=
literal|0x402F
operator|-
name|aExp
expr_stmt|;
name|savedASig
operator|=
name|aSig0
expr_stmt|;
name|aSig0
operator|>>=
name|shiftCount
expr_stmt|;
name|z
operator|=
name|aSig0
expr_stmt|;
if|if
condition|(
name|aSign
condition|)
name|z
operator|=
operator|-
name|z
expr_stmt|;
if|if
condition|(
operator|(
name|z
operator|<
literal|0
operator|)
operator|^
name|aSign
condition|)
block|{
name|invalid
label|:
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
name|aSign
condition|?
operator|(
name|sbits32
operator|)
literal|0x80000000
else|:
literal|0x7FFFFFFF
return|;
block|}
if|if
condition|(
operator|(
name|aSig0
operator|<<
name|shiftCount
operator|)
operator|!=
name|savedASig
condition|)
block|{
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
block|}
return|return
name|z
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the quadruple-precision floating-point value `a' to the 64-bit two's complement integer format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic---which means in particular that the conversion is rounded according to the current rounding mode.  If `a' is a NaN, the largest positive integer is returned.  Otherwise, if the conversion overflows, the largest integer with the same sign as `a' is returned. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|int64
name|float128_to_int64
parameter_list|(
name|float128
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int32
name|aExp
decl_stmt|,
name|shiftCount
decl_stmt|;
name|bits64
name|aSig0
decl_stmt|,
name|aSig1
decl_stmt|;
name|aSig1
operator|=
name|extractFloat128Frac1
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSig0
operator|=
name|extractFloat128Frac0
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat128Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat128Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|aExp
condition|)
name|aSig0
operator||=
name|LIT64
argument_list|(
literal|0x0001000000000000
argument_list|)
expr_stmt|;
name|shiftCount
operator|=
literal|0x402F
operator|-
name|aExp
expr_stmt|;
if|if
condition|(
name|shiftCount
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
literal|0x403E
operator|<
name|aExp
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aSign
operator|||
operator|(
operator|(
name|aExp
operator|==
literal|0x7FFF
operator|)
operator|&&
operator|(
name|aSig1
operator|||
operator|(
name|aSig0
operator|!=
name|LIT64
argument_list|(
literal|0x0001000000000000
argument_list|)
operator|)
operator|)
operator|)
condition|)
block|{
return|return
name|LIT64
argument_list|(
literal|0x7FFFFFFFFFFFFFFF
argument_list|)
return|;
block|}
return|return
operator|(
name|sbits64
operator|)
name|LIT64
argument_list|(
literal|0x8000000000000000
argument_list|)
return|;
block|}
name|shortShift128Left
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
operator|-
name|shiftCount
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|shift64ExtraRightJamming
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
name|shiftCount
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
block|}
return|return
name|roundAndPackInt64
argument_list|(
name|aSign
argument_list|,
name|aSig0
argument_list|,
name|aSig1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the quadruple-precision floating-point value `a' to the 64-bit two's complement integer format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic, except that the conversion is always rounded toward zero. If `a' is a NaN, the largest positive integer is returned.  Otherwise, if the conversion overflows, the largest integer with the same sign as `a' is returned. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|int64
name|float128_to_int64_round_to_zero
parameter_list|(
name|float128
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int32
name|aExp
decl_stmt|,
name|shiftCount
decl_stmt|;
name|bits64
name|aSig0
decl_stmt|,
name|aSig1
decl_stmt|;
name|int64
name|z
decl_stmt|;
name|aSig1
operator|=
name|extractFloat128Frac1
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSig0
operator|=
name|extractFloat128Frac0
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat128Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat128Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|aExp
condition|)
name|aSig0
operator||=
name|LIT64
argument_list|(
literal|0x0001000000000000
argument_list|)
expr_stmt|;
name|shiftCount
operator|=
name|aExp
operator|-
literal|0x402F
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|shiftCount
condition|)
block|{
if|if
condition|(
literal|0x403E
operator|<=
name|aExp
condition|)
block|{
name|aSig0
operator|&=
name|LIT64
argument_list|(
literal|0x0000FFFFFFFFFFFF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|a
operator|.
name|high
operator|==
name|LIT64
argument_list|(
literal|0xC03E000000000000
argument_list|)
operator|)
operator|&&
operator|(
name|aSig1
operator|<
name|LIT64
argument_list|(
literal|0x0002000000000000
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|aSig1
condition|)
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
block|}
else|else
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|aSign
operator|||
operator|(
operator|(
name|aExp
operator|==
literal|0x7FFF
operator|)
operator|&&
operator|(
name|aSig0
operator||
name|aSig1
operator|)
operator|)
condition|)
block|{
return|return
name|LIT64
argument_list|(
literal|0x7FFFFFFFFFFFFFFF
argument_list|)
return|;
block|}
block|}
return|return
operator|(
name|sbits64
operator|)
name|LIT64
argument_list|(
literal|0x8000000000000000
argument_list|)
return|;
block|}
name|z
operator|=
operator|(
name|aSig0
operator|<<
name|shiftCount
operator|)
operator||
operator|(
name|aSig1
operator|>>
operator|(
operator|(
operator|-
name|shiftCount
operator|)
operator|&
literal|63
operator|)
operator|)
expr_stmt|;
if|if
condition|(
call|(
name|bits64
call|)
argument_list|(
name|aSig1
operator|<<
name|shiftCount
argument_list|)
condition|)
block|{
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|aExp
operator|<
literal|0x3FFF
condition|)
block|{
if|if
condition|(
name|aExp
operator||
name|aSig0
operator||
name|aSig1
condition|)
block|{
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|z
operator|=
name|aSig0
operator|>>
operator|(
operator|-
name|shiftCount
operator|)
expr_stmt|;
if|if
condition|(
name|aSig1
operator|||
operator|(
name|shiftCount
operator|&&
call|(
name|bits64
call|)
argument_list|(
name|aSig0
operator|<<
operator|(
name|shiftCount
operator|&
literal|63
operator|)
argument_list|)
operator|)
condition|)
block|{
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
block|}
block|}
if|if
condition|(
name|aSign
condition|)
name|z
operator|=
operator|-
name|z
expr_stmt|;
return|return
name|z
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the quadruple-precision floating-point value `a' to the single-precision floating-point format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float32
name|float128_to_float32
parameter_list|(
name|float128
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int32
name|aExp
decl_stmt|;
name|bits64
name|aSig0
decl_stmt|,
name|aSig1
decl_stmt|;
name|bits32
name|zSig
decl_stmt|;
name|aSig1
operator|=
name|extractFloat128Frac1
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSig0
operator|=
name|extractFloat128Frac0
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat128Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat128Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0x7FFF
condition|)
block|{
if|if
condition|(
name|aSig0
operator||
name|aSig1
condition|)
block|{
return|return
name|commonNaNToFloat32
argument_list|(
name|float128ToCommonNaN
argument_list|(
name|a
argument_list|)
argument_list|)
return|;
block|}
return|return
name|packFloat32
argument_list|(
name|aSign
argument_list|,
literal|0xFF
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|aSig0
operator||=
operator|(
name|aSig1
operator|!=
literal|0
operator|)
expr_stmt|;
name|shift64RightJamming
argument_list|(
name|aSig0
argument_list|,
literal|18
argument_list|,
operator|&
name|aSig0
argument_list|)
expr_stmt|;
name|zSig
operator|=
name|aSig0
expr_stmt|;
if|if
condition|(
name|aExp
operator|||
name|zSig
condition|)
block|{
name|zSig
operator||=
literal|0x40000000
expr_stmt|;
name|aExp
operator|-=
literal|0x3F81
expr_stmt|;
block|}
return|return
name|roundAndPackFloat32
argument_list|(
name|aSign
argument_list|,
name|aExp
argument_list|,
name|zSig
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the quadruple-precision floating-point value `a' to the double-precision floating-point format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float64
name|float128_to_float64
parameter_list|(
name|float128
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int32
name|aExp
decl_stmt|;
name|bits64
name|aSig0
decl_stmt|,
name|aSig1
decl_stmt|;
name|aSig1
operator|=
name|extractFloat128Frac1
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSig0
operator|=
name|extractFloat128Frac0
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat128Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat128Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0x7FFF
condition|)
block|{
if|if
condition|(
name|aSig0
operator||
name|aSig1
condition|)
block|{
return|return
name|commonNaNToFloat64
argument_list|(
name|float128ToCommonNaN
argument_list|(
name|a
argument_list|)
argument_list|)
return|;
block|}
return|return
name|packFloat64
argument_list|(
name|aSign
argument_list|,
literal|0x7FF
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|shortShift128Left
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
literal|14
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
name|aSig0
operator||=
operator|(
name|aSig1
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|aExp
operator|||
name|aSig0
condition|)
block|{
name|aSig0
operator||=
name|LIT64
argument_list|(
literal|0x4000000000000000
argument_list|)
expr_stmt|;
name|aExp
operator|-=
literal|0x3C01
expr_stmt|;
block|}
return|return
name|roundAndPackFloat64
argument_list|(
name|aSign
argument_list|,
name|aExp
argument_list|,
name|aSig0
argument_list|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FLOATX80
end_ifdef

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the quadruple-precision floating-point value `a' to the extended double-precision floating-point format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|floatx80
name|float128_to_floatx80
parameter_list|(
name|float128
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int32
name|aExp
decl_stmt|;
name|bits64
name|aSig0
decl_stmt|,
name|aSig1
decl_stmt|;
name|aSig1
operator|=
name|extractFloat128Frac1
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSig0
operator|=
name|extractFloat128Frac0
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat128Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat128Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0x7FFF
condition|)
block|{
if|if
condition|(
name|aSig0
operator||
name|aSig1
condition|)
block|{
return|return
name|commonNaNToFloatx80
argument_list|(
name|float128ToCommonNaN
argument_list|(
name|a
argument_list|)
argument_list|)
return|;
block|}
return|return
name|packFloatx80
argument_list|(
name|aSign
argument_list|,
literal|0x7FFF
argument_list|,
name|LIT64
argument_list|(
literal|0x8000000000000000
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|aSig0
operator||
name|aSig1
operator|)
operator|==
literal|0
condition|)
return|return
name|packFloatx80
argument_list|(
name|aSign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|normalizeFloat128Subnormal
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
operator|&
name|aExp
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|aSig0
operator||=
name|LIT64
argument_list|(
literal|0x0001000000000000
argument_list|)
expr_stmt|;
block|}
name|shortShift128Left
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
literal|15
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
return|return
name|roundAndPackFloatx80
argument_list|(
literal|80
argument_list|,
name|aSign
argument_list|,
name|aExp
argument_list|,
name|aSig0
argument_list|,
name|aSig1
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ------------------------------------------------------------------------------- Rounds the quadruple-precision floating-point value `a' to an integer, and returns the result as a quadruple-precision floating-point value.  The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float128
name|float128_round_to_int
parameter_list|(
name|float128
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int32
name|aExp
decl_stmt|;
name|bits64
name|lastBitMask
decl_stmt|,
name|roundBitsMask
decl_stmt|;
name|int8
name|roundingMode
decl_stmt|;
name|float128
name|z
decl_stmt|;
name|aExp
operator|=
name|extractFloat128Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0x402F
operator|<=
name|aExp
condition|)
block|{
if|if
condition|(
literal|0x406F
operator|<=
name|aExp
condition|)
block|{
if|if
condition|(
operator|(
name|aExp
operator|==
literal|0x7FFF
operator|)
operator|&&
operator|(
name|extractFloat128Frac0
argument_list|(
name|a
argument_list|)
operator||
name|extractFloat128Frac1
argument_list|(
name|a
argument_list|)
operator|)
condition|)
block|{
return|return
name|propagateFloat128NaN
argument_list|(
name|a
argument_list|,
name|a
argument_list|)
return|;
block|}
return|return
name|a
return|;
block|}
name|lastBitMask
operator|=
literal|1
expr_stmt|;
name|lastBitMask
operator|=
operator|(
name|lastBitMask
operator|<<
operator|(
literal|0x406E
operator|-
name|aExp
operator|)
operator|)
operator|<<
literal|1
expr_stmt|;
name|roundBitsMask
operator|=
name|lastBitMask
operator|-
literal|1
expr_stmt|;
name|z
operator|=
name|a
expr_stmt|;
name|roundingMode
operator|=
name|float_rounding_mode
expr_stmt|;
if|if
condition|(
name|roundingMode
operator|==
name|float_round_nearest_even
condition|)
block|{
if|if
condition|(
name|lastBitMask
condition|)
block|{
name|add128
argument_list|(
name|z
operator|.
name|high
argument_list|,
name|z
operator|.
name|low
argument_list|,
literal|0
argument_list|,
name|lastBitMask
operator|>>
literal|1
argument_list|,
operator|&
name|z
operator|.
name|high
argument_list|,
operator|&
name|z
operator|.
name|low
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|z
operator|.
name|low
operator|&
name|roundBitsMask
operator|)
operator|==
literal|0
condition|)
name|z
operator|.
name|low
operator|&=
operator|~
name|lastBitMask
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|sbits64
operator|)
name|z
operator|.
name|low
operator|<
literal|0
condition|)
block|{
operator|++
name|z
operator|.
name|high
expr_stmt|;
if|if
condition|(
call|(
name|bits64
call|)
argument_list|(
name|z
operator|.
name|low
operator|<<
literal|1
argument_list|)
operator|==
literal|0
condition|)
name|z
operator|.
name|high
operator|&=
operator|~
literal|1
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|roundingMode
operator|!=
name|float_round_to_zero
condition|)
block|{
if|if
condition|(
name|extractFloat128Sign
argument_list|(
name|z
argument_list|)
operator|^
operator|(
name|roundingMode
operator|==
name|float_round_up
operator|)
condition|)
block|{
name|add128
argument_list|(
name|z
operator|.
name|high
argument_list|,
name|z
operator|.
name|low
argument_list|,
literal|0
argument_list|,
name|roundBitsMask
argument_list|,
operator|&
name|z
operator|.
name|high
argument_list|,
operator|&
name|z
operator|.
name|low
argument_list|)
expr_stmt|;
block|}
block|}
name|z
operator|.
name|low
operator|&=
operator|~
name|roundBitsMask
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|aExp
operator|<
literal|0x3FFF
condition|)
block|{
if|if
condition|(
operator|(
operator|(
call|(
name|bits64
call|)
argument_list|(
name|a
operator|.
name|high
operator|<<
literal|1
argument_list|)
operator|)
operator||
name|a
operator|.
name|low
operator|)
operator|==
literal|0
condition|)
return|return
name|a
return|;
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
name|aSign
operator|=
name|extractFloat128Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|float_rounding_mode
condition|)
block|{
case|case
name|float_round_nearest_even
case|:
if|if
condition|(
operator|(
name|aExp
operator|==
literal|0x3FFE
operator|)
operator|&&
operator|(
name|extractFloat128Frac0
argument_list|(
name|a
argument_list|)
operator||
name|extractFloat128Frac1
argument_list|(
name|a
argument_list|)
operator|)
condition|)
block|{
return|return
name|packFloat128
argument_list|(
name|aSign
argument_list|,
literal|0x3FFF
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
break|break;
case|case
name|float_round_to_zero
case|:
break|break;
case|case
name|float_round_down
case|:
return|return
name|aSign
condition|?
name|packFloat128
argument_list|(
literal|1
argument_list|,
literal|0x3FFF
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
else|:
name|packFloat128
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
case|case
name|float_round_up
case|:
return|return
name|aSign
condition|?
name|packFloat128
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
else|:
name|packFloat128
argument_list|(
literal|0
argument_list|,
literal|0x3FFF
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
name|packFloat128
argument_list|(
name|aSign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|lastBitMask
operator|=
literal|1
expr_stmt|;
name|lastBitMask
operator|<<=
literal|0x402F
operator|-
name|aExp
expr_stmt|;
name|roundBitsMask
operator|=
name|lastBitMask
operator|-
literal|1
expr_stmt|;
name|z
operator|.
name|low
operator|=
literal|0
expr_stmt|;
name|z
operator|.
name|high
operator|=
name|a
operator|.
name|high
expr_stmt|;
name|roundingMode
operator|=
name|float_rounding_mode
expr_stmt|;
if|if
condition|(
name|roundingMode
operator|==
name|float_round_nearest_even
condition|)
block|{
name|z
operator|.
name|high
operator|+=
name|lastBitMask
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|z
operator|.
name|high
operator|&
name|roundBitsMask
operator|)
operator||
name|a
operator|.
name|low
operator|)
operator|==
literal|0
condition|)
block|{
name|z
operator|.
name|high
operator|&=
operator|~
name|lastBitMask
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|roundingMode
operator|!=
name|float_round_to_zero
condition|)
block|{
if|if
condition|(
name|extractFloat128Sign
argument_list|(
name|z
argument_list|)
operator|^
operator|(
name|roundingMode
operator|==
name|float_round_up
operator|)
condition|)
block|{
name|z
operator|.
name|high
operator||=
operator|(
name|a
operator|.
name|low
operator|!=
literal|0
operator|)
expr_stmt|;
name|z
operator|.
name|high
operator|+=
name|roundBitsMask
expr_stmt|;
block|}
block|}
name|z
operator|.
name|high
operator|&=
operator|~
name|roundBitsMask
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|z
operator|.
name|low
operator|!=
name|a
operator|.
name|low
operator|)
operator|||
operator|(
name|z
operator|.
name|high
operator|!=
name|a
operator|.
name|high
operator|)
condition|)
block|{
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
block|}
return|return
name|z
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of adding the absolute values of the quadruple-precision floating-point values `a' and `b'.  If `zSign' is 1, the sum is negated before being returned.  `zSign' is ignored if the result is a NaN. The addition is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|float128
name|addFloat128Sigs
parameter_list|(
name|float128
name|a
parameter_list|,
name|float128
name|b
parameter_list|,
name|flag
name|zSign
parameter_list|)
block|{
name|int32
name|aExp
decl_stmt|,
name|bExp
decl_stmt|,
name|zExp
decl_stmt|;
name|bits64
name|aSig0
decl_stmt|,
name|aSig1
decl_stmt|,
name|bSig0
decl_stmt|,
name|bSig1
decl_stmt|,
name|zSig0
decl_stmt|,
name|zSig1
decl_stmt|,
name|zSig2
decl_stmt|;
name|int32
name|expDiff
decl_stmt|;
name|aSig1
operator|=
name|extractFloat128Frac1
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSig0
operator|=
name|extractFloat128Frac0
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat128Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSig1
operator|=
name|extractFloat128Frac1
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bSig0
operator|=
name|extractFloat128Frac0
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bExp
operator|=
name|extractFloat128Exp
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|expDiff
operator|=
name|aExp
operator|-
name|bExp
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|expDiff
condition|)
block|{
if|if
condition|(
name|aExp
operator|==
literal|0x7FFF
condition|)
block|{
if|if
condition|(
name|aSig0
operator||
name|aSig1
condition|)
return|return
name|propagateFloat128NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|a
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0
condition|)
block|{
operator|--
name|expDiff
expr_stmt|;
block|}
else|else
block|{
name|bSig0
operator||=
name|LIT64
argument_list|(
literal|0x0001000000000000
argument_list|)
expr_stmt|;
block|}
name|shift128ExtraRightJamming
argument_list|(
name|bSig0
argument_list|,
name|bSig1
argument_list|,
literal|0
argument_list|,
name|expDiff
argument_list|,
operator|&
name|bSig0
argument_list|,
operator|&
name|bSig1
argument_list|,
operator|&
name|zSig2
argument_list|)
expr_stmt|;
name|zExp
operator|=
name|aExp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|expDiff
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|bExp
operator|==
literal|0x7FFF
condition|)
block|{
if|if
condition|(
name|bSig0
operator||
name|bSig1
condition|)
return|return
name|propagateFloat128NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|packFloat128
argument_list|(
name|zSign
argument_list|,
literal|0x7FFF
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
operator|++
name|expDiff
expr_stmt|;
block|}
else|else
block|{
name|aSig0
operator||=
name|LIT64
argument_list|(
literal|0x0001000000000000
argument_list|)
expr_stmt|;
block|}
name|shift128ExtraRightJamming
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
literal|0
argument_list|,
operator|-
name|expDiff
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|,
operator|&
name|zSig2
argument_list|)
expr_stmt|;
name|zExp
operator|=
name|bExp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|aExp
operator|==
literal|0x7FFF
condition|)
block|{
if|if
condition|(
name|aSig0
operator||
name|aSig1
operator||
name|bSig0
operator||
name|bSig1
condition|)
block|{
return|return
name|propagateFloat128NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
return|return
name|a
return|;
block|}
name|add128
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
name|bSig0
argument_list|,
name|bSig1
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|)
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
return|return
name|packFloat128
argument_list|(
name|zSign
argument_list|,
literal|0
argument_list|,
name|zSig0
argument_list|,
name|zSig1
argument_list|)
return|;
name|zSig2
operator|=
literal|0
expr_stmt|;
name|zSig0
operator||=
name|LIT64
argument_list|(
literal|0x0002000000000000
argument_list|)
expr_stmt|;
name|zExp
operator|=
name|aExp
expr_stmt|;
goto|goto
name|shiftRight1
goto|;
block|}
name|aSig0
operator||=
name|LIT64
argument_list|(
literal|0x0001000000000000
argument_list|)
expr_stmt|;
name|add128
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
name|bSig0
argument_list|,
name|bSig1
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|)
expr_stmt|;
operator|--
name|zExp
expr_stmt|;
if|if
condition|(
name|zSig0
operator|<
name|LIT64
argument_list|(
literal|0x0002000000000000
argument_list|)
condition|)
goto|goto
name|roundAndPack
goto|;
operator|++
name|zExp
expr_stmt|;
name|shiftRight1
label|:
name|shift128ExtraRightJamming
argument_list|(
name|zSig0
argument_list|,
name|zSig1
argument_list|,
name|zSig2
argument_list|,
literal|1
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|,
operator|&
name|zSig2
argument_list|)
expr_stmt|;
name|roundAndPack
label|:
return|return
name|roundAndPackFloat128
argument_list|(
name|zSign
argument_list|,
name|zExp
argument_list|,
name|zSig0
argument_list|,
name|zSig1
argument_list|,
name|zSig2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of subtracting the absolute values of the quadruple- precision floating-point values `a' and `b'.  If `zSign' is 1, the difference is negated before being returned.  `zSign' is ignored if the result is a NaN.  The subtraction is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
specifier|static
name|float128
name|subFloat128Sigs
parameter_list|(
name|float128
name|a
parameter_list|,
name|float128
name|b
parameter_list|,
name|flag
name|zSign
parameter_list|)
block|{
name|int32
name|aExp
decl_stmt|,
name|bExp
decl_stmt|,
name|zExp
decl_stmt|;
name|bits64
name|aSig0
decl_stmt|,
name|aSig1
decl_stmt|,
name|bSig0
decl_stmt|,
name|bSig1
decl_stmt|,
name|zSig0
decl_stmt|,
name|zSig1
decl_stmt|;
name|int32
name|expDiff
decl_stmt|;
name|float128
name|z
decl_stmt|;
name|aSig1
operator|=
name|extractFloat128Frac1
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSig0
operator|=
name|extractFloat128Frac0
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat128Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSig1
operator|=
name|extractFloat128Frac1
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bSig0
operator|=
name|extractFloat128Frac0
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bExp
operator|=
name|extractFloat128Exp
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|expDiff
operator|=
name|aExp
operator|-
name|bExp
expr_stmt|;
name|shortShift128Left
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
literal|14
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
name|shortShift128Left
argument_list|(
name|bSig0
argument_list|,
name|bSig1
argument_list|,
literal|14
argument_list|,
operator|&
name|bSig0
argument_list|,
operator|&
name|bSig1
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|expDiff
condition|)
goto|goto
name|aExpBigger
goto|;
if|if
condition|(
name|expDiff
operator|<
literal|0
condition|)
goto|goto
name|bExpBigger
goto|;
if|if
condition|(
name|aExp
operator|==
literal|0x7FFF
condition|)
block|{
if|if
condition|(
name|aSig0
operator||
name|aSig1
operator||
name|bSig0
operator||
name|bSig1
condition|)
block|{
return|return
name|propagateFloat128NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
name|z
operator|.
name|low
operator|=
name|float128_default_nan_low
expr_stmt|;
name|z
operator|.
name|high
operator|=
name|float128_default_nan_high
expr_stmt|;
return|return
name|z
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
name|aExp
operator|=
literal|1
expr_stmt|;
name|bExp
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bSig0
operator|<
name|aSig0
condition|)
goto|goto
name|aBigger
goto|;
if|if
condition|(
name|aSig0
operator|<
name|bSig0
condition|)
goto|goto
name|bBigger
goto|;
if|if
condition|(
name|bSig1
operator|<
name|aSig1
condition|)
goto|goto
name|aBigger
goto|;
if|if
condition|(
name|aSig1
operator|<
name|bSig1
condition|)
goto|goto
name|bBigger
goto|;
return|return
name|packFloat128
argument_list|(
name|float_rounding_mode
operator|==
name|float_round_down
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|bExpBigger
label|:
if|if
condition|(
name|bExp
operator|==
literal|0x7FFF
condition|)
block|{
if|if
condition|(
name|bSig0
operator||
name|bSig1
condition|)
return|return
name|propagateFloat128NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|packFloat128
argument_list|(
name|zSign
operator|^
literal|1
argument_list|,
literal|0x7FFF
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
operator|++
name|expDiff
expr_stmt|;
block|}
else|else
block|{
name|aSig0
operator||=
name|LIT64
argument_list|(
literal|0x4000000000000000
argument_list|)
expr_stmt|;
block|}
name|shift128RightJamming
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
operator|-
name|expDiff
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
name|bSig0
operator||=
name|LIT64
argument_list|(
literal|0x4000000000000000
argument_list|)
expr_stmt|;
name|bBigger
label|:
name|sub128
argument_list|(
name|bSig0
argument_list|,
name|bSig1
argument_list|,
name|aSig0
argument_list|,
name|aSig1
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|)
expr_stmt|;
name|zExp
operator|=
name|bExp
expr_stmt|;
name|zSign
operator|^=
literal|1
expr_stmt|;
goto|goto
name|normalizeRoundAndPack
goto|;
name|aExpBigger
label|:
if|if
condition|(
name|aExp
operator|==
literal|0x7FFF
condition|)
block|{
if|if
condition|(
name|aSig0
operator||
name|aSig1
condition|)
return|return
name|propagateFloat128NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|a
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0
condition|)
block|{
operator|--
name|expDiff
expr_stmt|;
block|}
else|else
block|{
name|bSig0
operator||=
name|LIT64
argument_list|(
literal|0x4000000000000000
argument_list|)
expr_stmt|;
block|}
name|shift128RightJamming
argument_list|(
name|bSig0
argument_list|,
name|bSig1
argument_list|,
name|expDiff
argument_list|,
operator|&
name|bSig0
argument_list|,
operator|&
name|bSig1
argument_list|)
expr_stmt|;
name|aSig0
operator||=
name|LIT64
argument_list|(
literal|0x4000000000000000
argument_list|)
expr_stmt|;
name|aBigger
label|:
name|sub128
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
name|bSig0
argument_list|,
name|bSig1
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|)
expr_stmt|;
name|zExp
operator|=
name|aExp
expr_stmt|;
name|normalizeRoundAndPack
label|:
operator|--
name|zExp
expr_stmt|;
return|return
name|normalizeRoundAndPackFloat128
argument_list|(
name|zSign
argument_list|,
name|zExp
operator|-
literal|14
argument_list|,
name|zSig0
argument_list|,
name|zSig1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of adding the quadruple-precision floating-point values `a' and `b'.  The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float128
name|float128_add
parameter_list|(
name|float128
name|a
parameter_list|,
name|float128
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|;
name|aSign
operator|=
name|extractFloat128Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat128Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aSign
operator|==
name|bSign
condition|)
block|{
return|return
name|addFloat128Sigs
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|aSign
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|subFloat128Sigs
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|aSign
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of subtracting the quadruple-precision floating-point values `a' and `b'.  The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float128
name|float128_sub
parameter_list|(
name|float128
name|a
parameter_list|,
name|float128
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|;
name|aSign
operator|=
name|extractFloat128Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat128Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aSign
operator|==
name|bSign
condition|)
block|{
return|return
name|subFloat128Sigs
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|aSign
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|addFloat128Sigs
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|aSign
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of multiplying the quadruple-precision floating-point values `a' and `b'.  The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float128
name|float128_mul
parameter_list|(
name|float128
name|a
parameter_list|,
name|float128
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|,
name|zSign
decl_stmt|;
name|int32
name|aExp
decl_stmt|,
name|bExp
decl_stmt|,
name|zExp
decl_stmt|;
name|bits64
name|aSig0
decl_stmt|,
name|aSig1
decl_stmt|,
name|bSig0
decl_stmt|,
name|bSig1
decl_stmt|,
name|zSig0
decl_stmt|,
name|zSig1
decl_stmt|,
name|zSig2
decl_stmt|,
name|zSig3
decl_stmt|;
name|float128
name|z
decl_stmt|;
name|aSig1
operator|=
name|extractFloat128Frac1
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSig0
operator|=
name|extractFloat128Frac0
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat128Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat128Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSig1
operator|=
name|extractFloat128Frac1
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bSig0
operator|=
name|extractFloat128Frac0
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bExp
operator|=
name|extractFloat128Exp
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat128Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|zSign
operator|=
name|aSign
operator|^
name|bSign
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0x7FFF
condition|)
block|{
if|if
condition|(
operator|(
name|aSig0
operator||
name|aSig1
operator|)
operator|||
operator|(
operator|(
name|bExp
operator|==
literal|0x7FFF
operator|)
operator|&&
operator|(
name|bSig0
operator||
name|bSig1
operator|)
operator|)
condition|)
block|{
return|return
name|propagateFloat128NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|bExp
operator||
name|bSig0
operator||
name|bSig1
operator|)
operator|==
literal|0
condition|)
goto|goto
name|invalid
goto|;
return|return
name|packFloat128
argument_list|(
name|zSign
argument_list|,
literal|0x7FFF
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0x7FFF
condition|)
block|{
if|if
condition|(
name|bSig0
operator||
name|bSig1
condition|)
return|return
name|propagateFloat128NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
if|if
condition|(
operator|(
name|aExp
operator||
name|aSig0
operator||
name|aSig1
operator|)
operator|==
literal|0
condition|)
block|{
name|invalid
label|:
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
name|z
operator|.
name|low
operator|=
name|float128_default_nan_low
expr_stmt|;
name|z
operator|.
name|high
operator|=
name|float128_default_nan_high
expr_stmt|;
return|return
name|z
return|;
block|}
return|return
name|packFloat128
argument_list|(
name|zSign
argument_list|,
literal|0x7FFF
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|aSig0
operator||
name|aSig1
operator|)
operator|==
literal|0
condition|)
return|return
name|packFloat128
argument_list|(
name|zSign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|normalizeFloat128Subnormal
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
operator|&
name|aExp
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|bSig0
operator||
name|bSig1
operator|)
operator|==
literal|0
condition|)
return|return
name|packFloat128
argument_list|(
name|zSign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|normalizeFloat128Subnormal
argument_list|(
name|bSig0
argument_list|,
name|bSig1
argument_list|,
operator|&
name|bExp
argument_list|,
operator|&
name|bSig0
argument_list|,
operator|&
name|bSig1
argument_list|)
expr_stmt|;
block|}
name|zExp
operator|=
name|aExp
operator|+
name|bExp
operator|-
literal|0x4000
expr_stmt|;
name|aSig0
operator||=
name|LIT64
argument_list|(
literal|0x0001000000000000
argument_list|)
expr_stmt|;
name|shortShift128Left
argument_list|(
name|bSig0
argument_list|,
name|bSig1
argument_list|,
literal|16
argument_list|,
operator|&
name|bSig0
argument_list|,
operator|&
name|bSig1
argument_list|)
expr_stmt|;
name|mul128To256
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
name|bSig0
argument_list|,
name|bSig1
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|,
operator|&
name|zSig2
argument_list|,
operator|&
name|zSig3
argument_list|)
expr_stmt|;
name|add128
argument_list|(
name|zSig0
argument_list|,
name|zSig1
argument_list|,
name|aSig0
argument_list|,
name|aSig1
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|)
expr_stmt|;
name|zSig2
operator||=
operator|(
name|zSig3
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|LIT64
argument_list|(
literal|0x0002000000000000
argument_list|)
operator|<=
name|zSig0
condition|)
block|{
name|shift128ExtraRightJamming
argument_list|(
name|zSig0
argument_list|,
name|zSig1
argument_list|,
name|zSig2
argument_list|,
literal|1
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|,
operator|&
name|zSig2
argument_list|)
expr_stmt|;
operator|++
name|zExp
expr_stmt|;
block|}
return|return
name|roundAndPackFloat128
argument_list|(
name|zSign
argument_list|,
name|zExp
argument_list|,
name|zSig0
argument_list|,
name|zSig1
argument_list|,
name|zSig2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of dividing the quadruple-precision floating-point value `a' by the corresponding value `b'.  The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float128
name|float128_div
parameter_list|(
name|float128
name|a
parameter_list|,
name|float128
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|,
name|zSign
decl_stmt|;
name|int32
name|aExp
decl_stmt|,
name|bExp
decl_stmt|,
name|zExp
decl_stmt|;
name|bits64
name|aSig0
decl_stmt|,
name|aSig1
decl_stmt|,
name|bSig0
decl_stmt|,
name|bSig1
decl_stmt|,
name|zSig0
decl_stmt|,
name|zSig1
decl_stmt|,
name|zSig2
decl_stmt|;
name|bits64
name|rem0
decl_stmt|,
name|rem1
decl_stmt|,
name|rem2
decl_stmt|,
name|rem3
decl_stmt|,
name|term0
decl_stmt|,
name|term1
decl_stmt|,
name|term2
decl_stmt|,
name|term3
decl_stmt|;
name|float128
name|z
decl_stmt|;
name|aSig1
operator|=
name|extractFloat128Frac1
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSig0
operator|=
name|extractFloat128Frac0
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat128Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat128Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSig1
operator|=
name|extractFloat128Frac1
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bSig0
operator|=
name|extractFloat128Frac0
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bExp
operator|=
name|extractFloat128Exp
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat128Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|zSign
operator|=
name|aSign
operator|^
name|bSign
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0x7FFF
condition|)
block|{
if|if
condition|(
name|aSig0
operator||
name|aSig1
condition|)
return|return
name|propagateFloat128NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
if|if
condition|(
name|bExp
operator|==
literal|0x7FFF
condition|)
block|{
if|if
condition|(
name|bSig0
operator||
name|bSig1
condition|)
return|return
name|propagateFloat128NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
goto|goto
name|invalid
goto|;
block|}
return|return
name|packFloat128
argument_list|(
name|zSign
argument_list|,
literal|0x7FFF
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0x7FFF
condition|)
block|{
if|if
condition|(
name|bSig0
operator||
name|bSig1
condition|)
return|return
name|propagateFloat128NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|packFloat128
argument_list|(
name|zSign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|bSig0
operator||
name|bSig1
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|aExp
operator||
name|aSig0
operator||
name|aSig1
operator|)
operator|==
literal|0
condition|)
block|{
name|invalid
label|:
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
name|z
operator|.
name|low
operator|=
name|float128_default_nan_low
expr_stmt|;
name|z
operator|.
name|high
operator|=
name|float128_default_nan_high
expr_stmt|;
return|return
name|z
return|;
block|}
name|float_raise
argument_list|(
name|float_flag_divbyzero
argument_list|)
expr_stmt|;
return|return
name|packFloat128
argument_list|(
name|zSign
argument_list|,
literal|0x7FFF
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
block|}
name|normalizeFloat128Subnormal
argument_list|(
name|bSig0
argument_list|,
name|bSig1
argument_list|,
operator|&
name|bExp
argument_list|,
operator|&
name|bSig0
argument_list|,
operator|&
name|bSig1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|aSig0
operator||
name|aSig1
operator|)
operator|==
literal|0
condition|)
return|return
name|packFloat128
argument_list|(
name|zSign
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|normalizeFloat128Subnormal
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
operator|&
name|aExp
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
block|}
name|zExp
operator|=
name|aExp
operator|-
name|bExp
operator|+
literal|0x3FFD
expr_stmt|;
name|shortShift128Left
argument_list|(
name|aSig0
operator||
name|LIT64
argument_list|(
literal|0x0001000000000000
argument_list|)
argument_list|,
name|aSig1
argument_list|,
literal|15
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
name|shortShift128Left
argument_list|(
name|bSig0
operator||
name|LIT64
argument_list|(
literal|0x0001000000000000
argument_list|)
argument_list|,
name|bSig1
argument_list|,
literal|15
argument_list|,
operator|&
name|bSig0
argument_list|,
operator|&
name|bSig1
argument_list|)
expr_stmt|;
if|if
condition|(
name|le128
argument_list|(
name|bSig0
argument_list|,
name|bSig1
argument_list|,
name|aSig0
argument_list|,
name|aSig1
argument_list|)
condition|)
block|{
name|shift128Right
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
literal|1
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
operator|++
name|zExp
expr_stmt|;
block|}
name|zSig0
operator|=
name|estimateDiv128To64
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
name|bSig0
argument_list|)
expr_stmt|;
name|mul128By64To192
argument_list|(
name|bSig0
argument_list|,
name|bSig1
argument_list|,
name|zSig0
argument_list|,
operator|&
name|term0
argument_list|,
operator|&
name|term1
argument_list|,
operator|&
name|term2
argument_list|)
expr_stmt|;
name|sub192
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
literal|0
argument_list|,
name|term0
argument_list|,
name|term1
argument_list|,
name|term2
argument_list|,
operator|&
name|rem0
argument_list|,
operator|&
name|rem1
argument_list|,
operator|&
name|rem2
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|sbits64
operator|)
name|rem0
operator|<
literal|0
condition|)
block|{
operator|--
name|zSig0
expr_stmt|;
name|add192
argument_list|(
name|rem0
argument_list|,
name|rem1
argument_list|,
name|rem2
argument_list|,
literal|0
argument_list|,
name|bSig0
argument_list|,
name|bSig1
argument_list|,
operator|&
name|rem0
argument_list|,
operator|&
name|rem1
argument_list|,
operator|&
name|rem2
argument_list|)
expr_stmt|;
block|}
name|zSig1
operator|=
name|estimateDiv128To64
argument_list|(
name|rem1
argument_list|,
name|rem2
argument_list|,
name|bSig0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zSig1
operator|&
literal|0x3FFF
operator|)
operator|<=
literal|4
condition|)
block|{
name|mul128By64To192
argument_list|(
name|bSig0
argument_list|,
name|bSig1
argument_list|,
name|zSig1
argument_list|,
operator|&
name|term1
argument_list|,
operator|&
name|term2
argument_list|,
operator|&
name|term3
argument_list|)
expr_stmt|;
name|sub192
argument_list|(
name|rem1
argument_list|,
name|rem2
argument_list|,
literal|0
argument_list|,
name|term1
argument_list|,
name|term2
argument_list|,
name|term3
argument_list|,
operator|&
name|rem1
argument_list|,
operator|&
name|rem2
argument_list|,
operator|&
name|rem3
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|sbits64
operator|)
name|rem1
operator|<
literal|0
condition|)
block|{
operator|--
name|zSig1
expr_stmt|;
name|add192
argument_list|(
name|rem1
argument_list|,
name|rem2
argument_list|,
name|rem3
argument_list|,
literal|0
argument_list|,
name|bSig0
argument_list|,
name|bSig1
argument_list|,
operator|&
name|rem1
argument_list|,
operator|&
name|rem2
argument_list|,
operator|&
name|rem3
argument_list|)
expr_stmt|;
block|}
name|zSig1
operator||=
operator|(
operator|(
name|rem1
operator||
name|rem2
operator||
name|rem3
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
name|shift128ExtraRightJamming
argument_list|(
name|zSig0
argument_list|,
name|zSig1
argument_list|,
literal|0
argument_list|,
literal|15
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|,
operator|&
name|zSig2
argument_list|)
expr_stmt|;
return|return
name|roundAndPackFloat128
argument_list|(
name|zSign
argument_list|,
name|zExp
argument_list|,
name|zSig0
argument_list|,
name|zSig1
argument_list|,
name|zSig2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the remainder of the quadruple-precision floating-point value `a' with respect to the corresponding value `b'.  The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float128
name|float128_rem
parameter_list|(
name|float128
name|a
parameter_list|,
name|float128
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|,
name|zSign
decl_stmt|;
name|int32
name|aExp
decl_stmt|,
name|bExp
decl_stmt|,
name|expDiff
decl_stmt|;
name|bits64
name|aSig0
decl_stmt|,
name|aSig1
decl_stmt|,
name|bSig0
decl_stmt|,
name|bSig1
decl_stmt|,
name|q
decl_stmt|,
name|term0
decl_stmt|,
name|term1
decl_stmt|,
name|term2
decl_stmt|;
name|bits64
name|allZero
decl_stmt|,
name|alternateASig0
decl_stmt|,
name|alternateASig1
decl_stmt|,
name|sigMean1
decl_stmt|;
name|sbits64
name|sigMean0
decl_stmt|;
name|float128
name|z
decl_stmt|;
name|aSig1
operator|=
name|extractFloat128Frac1
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSig0
operator|=
name|extractFloat128Frac0
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat128Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat128Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSig1
operator|=
name|extractFloat128Frac1
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bSig0
operator|=
name|extractFloat128Frac0
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bExp
operator|=
name|extractFloat128Exp
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat128Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0x7FFF
condition|)
block|{
if|if
condition|(
operator|(
name|aSig0
operator||
name|aSig1
operator|)
operator|||
operator|(
operator|(
name|bExp
operator|==
literal|0x7FFF
operator|)
operator|&&
operator|(
name|bSig0
operator||
name|bSig1
operator|)
operator|)
condition|)
block|{
return|return
name|propagateFloat128NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
block|}
goto|goto
name|invalid
goto|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0x7FFF
condition|)
block|{
if|if
condition|(
name|bSig0
operator||
name|bSig1
condition|)
return|return
name|propagateFloat128NaN
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
return|;
return|return
name|a
return|;
block|}
if|if
condition|(
name|bExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|bSig0
operator||
name|bSig1
operator|)
operator|==
literal|0
condition|)
block|{
name|invalid
label|:
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
name|z
operator|.
name|low
operator|=
name|float128_default_nan_low
expr_stmt|;
name|z
operator|.
name|high
operator|=
name|float128_default_nan_high
expr_stmt|;
return|return
name|z
return|;
block|}
name|normalizeFloat128Subnormal
argument_list|(
name|bSig0
argument_list|,
name|bSig1
argument_list|,
operator|&
name|bExp
argument_list|,
operator|&
name|bSig0
argument_list|,
operator|&
name|bSig1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|aSig0
operator||
name|aSig1
operator|)
operator|==
literal|0
condition|)
return|return
name|a
return|;
name|normalizeFloat128Subnormal
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
operator|&
name|aExp
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
block|}
name|expDiff
operator|=
name|aExp
operator|-
name|bExp
expr_stmt|;
if|if
condition|(
name|expDiff
operator|<
operator|-
literal|1
condition|)
return|return
name|a
return|;
name|shortShift128Left
argument_list|(
name|aSig0
operator||
name|LIT64
argument_list|(
literal|0x0001000000000000
argument_list|)
argument_list|,
name|aSig1
argument_list|,
literal|15
operator|-
operator|(
name|expDiff
operator|<
literal|0
operator|)
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
name|shortShift128Left
argument_list|(
name|bSig0
operator||
name|LIT64
argument_list|(
literal|0x0001000000000000
argument_list|)
argument_list|,
name|bSig1
argument_list|,
literal|15
argument_list|,
operator|&
name|bSig0
argument_list|,
operator|&
name|bSig1
argument_list|)
expr_stmt|;
name|q
operator|=
name|le128
argument_list|(
name|bSig0
argument_list|,
name|bSig1
argument_list|,
name|aSig0
argument_list|,
name|aSig1
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
condition|)
name|sub128
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
name|bSig0
argument_list|,
name|bSig1
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
name|expDiff
operator|-=
literal|64
expr_stmt|;
while|while
condition|(
literal|0
operator|<
name|expDiff
condition|)
block|{
name|q
operator|=
name|estimateDiv128To64
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
name|bSig0
argument_list|)
expr_stmt|;
name|q
operator|=
operator|(
literal|4
operator|<
name|q
operator|)
condition|?
name|q
operator|-
literal|4
else|:
literal|0
expr_stmt|;
name|mul128By64To192
argument_list|(
name|bSig0
argument_list|,
name|bSig1
argument_list|,
name|q
argument_list|,
operator|&
name|term0
argument_list|,
operator|&
name|term1
argument_list|,
operator|&
name|term2
argument_list|)
expr_stmt|;
name|shortShift192Left
argument_list|(
name|term0
argument_list|,
name|term1
argument_list|,
name|term2
argument_list|,
literal|61
argument_list|,
operator|&
name|term1
argument_list|,
operator|&
name|term2
argument_list|,
operator|&
name|allZero
argument_list|)
expr_stmt|;
name|shortShift128Left
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
literal|61
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|allZero
argument_list|)
expr_stmt|;
name|sub128
argument_list|(
name|aSig0
argument_list|,
literal|0
argument_list|,
name|term1
argument_list|,
name|term2
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
name|expDiff
operator|-=
literal|61
expr_stmt|;
block|}
if|if
condition|(
operator|-
literal|64
operator|<
name|expDiff
condition|)
block|{
name|q
operator|=
name|estimateDiv128To64
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
name|bSig0
argument_list|)
expr_stmt|;
name|q
operator|=
operator|(
literal|4
operator|<
name|q
operator|)
condition|?
name|q
operator|-
literal|4
else|:
literal|0
expr_stmt|;
name|q
operator|>>=
operator|-
name|expDiff
expr_stmt|;
name|shift128Right
argument_list|(
name|bSig0
argument_list|,
name|bSig1
argument_list|,
literal|12
argument_list|,
operator|&
name|bSig0
argument_list|,
operator|&
name|bSig1
argument_list|)
expr_stmt|;
name|expDiff
operator|+=
literal|52
expr_stmt|;
if|if
condition|(
name|expDiff
operator|<
literal|0
condition|)
block|{
name|shift128Right
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
operator|-
name|expDiff
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|shortShift128Left
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
name|expDiff
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
block|}
name|mul128By64To192
argument_list|(
name|bSig0
argument_list|,
name|bSig1
argument_list|,
name|q
argument_list|,
operator|&
name|term0
argument_list|,
operator|&
name|term1
argument_list|,
operator|&
name|term2
argument_list|)
expr_stmt|;
name|sub128
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
name|term1
argument_list|,
name|term2
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|shift128Right
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
literal|12
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
name|shift128Right
argument_list|(
name|bSig0
argument_list|,
name|bSig1
argument_list|,
literal|12
argument_list|,
operator|&
name|bSig0
argument_list|,
operator|&
name|bSig1
argument_list|)
expr_stmt|;
block|}
do|do
block|{
name|alternateASig0
operator|=
name|aSig0
expr_stmt|;
name|alternateASig1
operator|=
name|aSig1
expr_stmt|;
operator|++
name|q
expr_stmt|;
name|sub128
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
name|bSig0
argument_list|,
name|bSig1
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
literal|0
operator|<=
operator|(
name|sbits64
operator|)
name|aSig0
condition|)
do|;
name|add128
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
name|alternateASig0
argument_list|,
name|alternateASig1
argument_list|,
operator|&
name|sigMean0
argument_list|,
operator|&
name|sigMean1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sigMean0
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
operator|(
name|sigMean0
operator||
name|sigMean1
operator|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|q
operator|&
literal|1
operator|)
operator|)
condition|)
block|{
name|aSig0
operator|=
name|alternateASig0
expr_stmt|;
name|aSig1
operator|=
name|alternateASig1
expr_stmt|;
block|}
name|zSign
operator|=
operator|(
operator|(
name|sbits64
operator|)
name|aSig0
operator|<
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|zSign
condition|)
name|sub128
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|aSig0
argument_list|,
name|aSig1
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
return|return
name|normalizeRoundAndPackFloat128
argument_list|(
name|aSign
operator|^
name|zSign
argument_list|,
name|bExp
operator|-
literal|4
argument_list|,
name|aSig0
argument_list|,
name|aSig1
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the square root of the quadruple-precision floating-point value `a'. The operation is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|float128
name|float128_sqrt
parameter_list|(
name|float128
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int32
name|aExp
decl_stmt|,
name|zExp
decl_stmt|;
name|bits64
name|aSig0
decl_stmt|,
name|aSig1
decl_stmt|,
name|zSig0
decl_stmt|,
name|zSig1
decl_stmt|,
name|zSig2
decl_stmt|,
name|doubleZSig0
decl_stmt|;
name|bits64
name|rem0
decl_stmt|,
name|rem1
decl_stmt|,
name|rem2
decl_stmt|,
name|rem3
decl_stmt|,
name|term0
decl_stmt|,
name|term1
decl_stmt|,
name|term2
decl_stmt|,
name|term3
decl_stmt|;
name|float128
name|z
decl_stmt|;
name|aSig1
operator|=
name|extractFloat128Frac1
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSig0
operator|=
name|extractFloat128Frac0
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat128Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat128Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|aExp
operator|==
literal|0x7FFF
condition|)
block|{
if|if
condition|(
name|aSig0
operator||
name|aSig1
condition|)
return|return
name|propagateFloat128NaN
argument_list|(
name|a
argument_list|,
name|a
argument_list|)
return|;
if|if
condition|(
operator|!
name|aSign
condition|)
return|return
name|a
return|;
goto|goto
name|invalid
goto|;
block|}
if|if
condition|(
name|aSign
condition|)
block|{
if|if
condition|(
operator|(
name|aExp
operator||
name|aSig0
operator||
name|aSig1
operator|)
operator|==
literal|0
condition|)
return|return
name|a
return|;
name|invalid
label|:
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
name|z
operator|.
name|low
operator|=
name|float128_default_nan_low
expr_stmt|;
name|z
operator|.
name|high
operator|=
name|float128_default_nan_high
expr_stmt|;
return|return
name|z
return|;
block|}
if|if
condition|(
name|aExp
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|aSig0
operator||
name|aSig1
operator|)
operator|==
literal|0
condition|)
return|return
name|packFloat128
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
return|;
name|normalizeFloat128Subnormal
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
operator|&
name|aExp
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
block|}
name|zExp
operator|=
operator|(
operator|(
name|aExp
operator|-
literal|0x3FFF
operator|)
operator|>>
literal|1
operator|)
operator|+
literal|0x3FFE
expr_stmt|;
name|aSig0
operator||=
name|LIT64
argument_list|(
literal|0x0001000000000000
argument_list|)
expr_stmt|;
name|zSig0
operator|=
name|estimateSqrt32
argument_list|(
name|aExp
argument_list|,
name|aSig0
operator|>>
literal|17
argument_list|)
expr_stmt|;
name|shortShift128Left
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
literal|13
operator|-
operator|(
name|aExp
operator|&
literal|1
operator|)
argument_list|,
operator|&
name|aSig0
argument_list|,
operator|&
name|aSig1
argument_list|)
expr_stmt|;
name|zSig0
operator|=
name|estimateDiv128To64
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
name|zSig0
operator|<<
literal|32
argument_list|)
operator|+
operator|(
name|zSig0
operator|<<
literal|30
operator|)
expr_stmt|;
name|doubleZSig0
operator|=
name|zSig0
operator|<<
literal|1
expr_stmt|;
name|mul64To128
argument_list|(
name|zSig0
argument_list|,
name|zSig0
argument_list|,
operator|&
name|term0
argument_list|,
operator|&
name|term1
argument_list|)
expr_stmt|;
name|sub128
argument_list|(
name|aSig0
argument_list|,
name|aSig1
argument_list|,
name|term0
argument_list|,
name|term1
argument_list|,
operator|&
name|rem0
argument_list|,
operator|&
name|rem1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|sbits64
operator|)
name|rem0
operator|<
literal|0
condition|)
block|{
operator|--
name|zSig0
expr_stmt|;
name|doubleZSig0
operator|-=
literal|2
expr_stmt|;
name|add128
argument_list|(
name|rem0
argument_list|,
name|rem1
argument_list|,
name|zSig0
operator|>>
literal|63
argument_list|,
name|doubleZSig0
operator||
literal|1
argument_list|,
operator|&
name|rem0
argument_list|,
operator|&
name|rem1
argument_list|)
expr_stmt|;
block|}
name|zSig1
operator|=
name|estimateDiv128To64
argument_list|(
name|rem1
argument_list|,
literal|0
argument_list|,
name|doubleZSig0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zSig1
operator|&
literal|0x1FFF
operator|)
operator|<=
literal|5
condition|)
block|{
if|if
condition|(
name|zSig1
operator|==
literal|0
condition|)
name|zSig1
operator|=
literal|1
expr_stmt|;
name|mul64To128
argument_list|(
name|doubleZSig0
argument_list|,
name|zSig1
argument_list|,
operator|&
name|term1
argument_list|,
operator|&
name|term2
argument_list|)
expr_stmt|;
name|sub128
argument_list|(
name|rem1
argument_list|,
literal|0
argument_list|,
name|term1
argument_list|,
name|term2
argument_list|,
operator|&
name|rem1
argument_list|,
operator|&
name|rem2
argument_list|)
expr_stmt|;
name|mul64To128
argument_list|(
name|zSig1
argument_list|,
name|zSig1
argument_list|,
operator|&
name|term2
argument_list|,
operator|&
name|term3
argument_list|)
expr_stmt|;
name|sub192
argument_list|(
name|rem1
argument_list|,
name|rem2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|term2
argument_list|,
name|term3
argument_list|,
operator|&
name|rem1
argument_list|,
operator|&
name|rem2
argument_list|,
operator|&
name|rem3
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|sbits64
operator|)
name|rem1
operator|<
literal|0
condition|)
block|{
operator|--
name|zSig1
expr_stmt|;
name|shortShift128Left
argument_list|(
literal|0
argument_list|,
name|zSig1
argument_list|,
literal|1
argument_list|,
operator|&
name|term2
argument_list|,
operator|&
name|term3
argument_list|)
expr_stmt|;
name|term3
operator||=
literal|1
expr_stmt|;
name|term2
operator||=
name|doubleZSig0
expr_stmt|;
name|add192
argument_list|(
name|rem1
argument_list|,
name|rem2
argument_list|,
name|rem3
argument_list|,
literal|0
argument_list|,
name|term2
argument_list|,
name|term3
argument_list|,
operator|&
name|rem1
argument_list|,
operator|&
name|rem2
argument_list|,
operator|&
name|rem3
argument_list|)
expr_stmt|;
block|}
name|zSig1
operator||=
operator|(
operator|(
name|rem1
operator||
name|rem2
operator||
name|rem3
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
name|shift128ExtraRightJamming
argument_list|(
name|zSig0
argument_list|,
name|zSig1
argument_list|,
literal|0
argument_list|,
literal|14
argument_list|,
operator|&
name|zSig0
argument_list|,
operator|&
name|zSig1
argument_list|,
operator|&
name|zSig2
argument_list|)
expr_stmt|;
return|return
name|roundAndPackFloat128
argument_list|(
literal|0
argument_list|,
name|zExp
argument_list|,
name|zSig0
argument_list|,
name|zSig1
argument_list|,
name|zSig2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns 1 if the quadruple-precision floating-point value `a' is equal to the corresponding value `b', and 0 otherwise.  The comparison is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|flag
name|float128_eq
parameter_list|(
name|float128
name|a
parameter_list|,
name|float128
name|b
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|extractFloat128Exp
argument_list|(
name|a
argument_list|)
operator|==
literal|0x7FFF
operator|)
operator|&&
operator|(
name|extractFloat128Frac0
argument_list|(
name|a
argument_list|)
operator||
name|extractFloat128Frac1
argument_list|(
name|a
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|extractFloat128Exp
argument_list|(
name|b
argument_list|)
operator|==
literal|0x7FFF
operator|)
operator|&&
operator|(
name|extractFloat128Frac0
argument_list|(
name|b
argument_list|)
operator||
name|extractFloat128Frac1
argument_list|(
name|b
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|float128_is_signaling_nan
argument_list|(
name|a
argument_list|)
operator|||
name|float128_is_signaling_nan
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
return|return
operator|(
name|a
operator|.
name|low
operator|==
name|b
operator|.
name|low
operator|)
operator|&&
operator|(
operator|(
name|a
operator|.
name|high
operator|==
name|b
operator|.
name|high
operator|)
operator|||
operator|(
operator|(
name|a
operator|.
name|low
operator|==
literal|0
operator|)
operator|&&
operator|(
call|(
name|bits64
call|)
argument_list|(
operator|(
name|a
operator|.
name|high
operator||
name|b
operator|.
name|high
operator|)
operator|<<
literal|1
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns 1 if the quadruple-precision floating-point value `a' is less than or equal to the corresponding value `b', and 0 otherwise.  The comparison is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|flag
name|float128_le
parameter_list|(
name|float128
name|a
parameter_list|,
name|float128
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|extractFloat128Exp
argument_list|(
name|a
argument_list|)
operator|==
literal|0x7FFF
operator|)
operator|&&
operator|(
name|extractFloat128Frac0
argument_list|(
name|a
argument_list|)
operator||
name|extractFloat128Frac1
argument_list|(
name|a
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|extractFloat128Exp
argument_list|(
name|b
argument_list|)
operator|==
literal|0x7FFF
operator|)
operator|&&
operator|(
name|extractFloat128Frac0
argument_list|(
name|b
argument_list|)
operator||
name|extractFloat128Frac1
argument_list|(
name|b
argument_list|)
operator|)
operator|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|aSign
operator|=
name|extractFloat128Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat128Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aSign
operator|!=
name|bSign
condition|)
block|{
return|return
name|aSign
operator|||
operator|(
operator|(
operator|(
call|(
name|bits64
call|)
argument_list|(
operator|(
name|a
operator|.
name|high
operator||
name|b
operator|.
name|high
operator|)
operator|<<
literal|1
argument_list|)
operator|)
operator||
name|a
operator|.
name|low
operator||
name|b
operator|.
name|low
operator|)
operator|==
literal|0
operator|)
return|;
block|}
return|return
name|aSign
condition|?
name|le128
argument_list|(
name|b
operator|.
name|high
argument_list|,
name|b
operator|.
name|low
argument_list|,
name|a
operator|.
name|high
argument_list|,
name|a
operator|.
name|low
argument_list|)
else|:
name|le128
argument_list|(
name|a
operator|.
name|high
argument_list|,
name|a
operator|.
name|low
argument_list|,
name|b
operator|.
name|high
argument_list|,
name|b
operator|.
name|low
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns 1 if the quadruple-precision floating-point value `a' is less than the corresponding value `b', and 0 otherwise.  The comparison is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|flag
name|float128_lt
parameter_list|(
name|float128
name|a
parameter_list|,
name|float128
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|extractFloat128Exp
argument_list|(
name|a
argument_list|)
operator|==
literal|0x7FFF
operator|)
operator|&&
operator|(
name|extractFloat128Frac0
argument_list|(
name|a
argument_list|)
operator||
name|extractFloat128Frac1
argument_list|(
name|a
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|extractFloat128Exp
argument_list|(
name|b
argument_list|)
operator|==
literal|0x7FFF
operator|)
operator|&&
operator|(
name|extractFloat128Frac0
argument_list|(
name|b
argument_list|)
operator||
name|extractFloat128Frac1
argument_list|(
name|b
argument_list|)
operator|)
operator|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|aSign
operator|=
name|extractFloat128Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat128Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aSign
operator|!=
name|bSign
condition|)
block|{
return|return
name|aSign
operator|&&
operator|(
operator|(
operator|(
call|(
name|bits64
call|)
argument_list|(
operator|(
name|a
operator|.
name|high
operator||
name|b
operator|.
name|high
operator|)
operator|<<
literal|1
argument_list|)
operator|)
operator||
name|a
operator|.
name|low
operator||
name|b
operator|.
name|low
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
return|return
name|aSign
condition|?
name|lt128
argument_list|(
name|b
operator|.
name|high
argument_list|,
name|b
operator|.
name|low
argument_list|,
name|a
operator|.
name|high
argument_list|,
name|a
operator|.
name|low
argument_list|)
else|:
name|lt128
argument_list|(
name|a
operator|.
name|high
argument_list|,
name|a
operator|.
name|low
argument_list|,
name|b
operator|.
name|high
argument_list|,
name|b
operator|.
name|low
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns 1 if the quadruple-precision floating-point value `a' is equal to the corresponding value `b', and 0 otherwise.  The invalid exception is raised if either operand is a NaN.  Otherwise, the comparison is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|flag
name|float128_eq_signaling
parameter_list|(
name|float128
name|a
parameter_list|,
name|float128
name|b
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|(
name|extractFloat128Exp
argument_list|(
name|a
argument_list|)
operator|==
literal|0x7FFF
operator|)
operator|&&
operator|(
name|extractFloat128Frac0
argument_list|(
name|a
argument_list|)
operator||
name|extractFloat128Frac1
argument_list|(
name|a
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|extractFloat128Exp
argument_list|(
name|b
argument_list|)
operator|==
literal|0x7FFF
operator|)
operator|&&
operator|(
name|extractFloat128Frac0
argument_list|(
name|b
argument_list|)
operator||
name|extractFloat128Frac1
argument_list|(
name|b
argument_list|)
operator|)
operator|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|(
name|a
operator|.
name|low
operator|==
name|b
operator|.
name|low
operator|)
operator|&&
operator|(
operator|(
name|a
operator|.
name|high
operator|==
name|b
operator|.
name|high
operator|)
operator|||
operator|(
operator|(
name|a
operator|.
name|low
operator|==
literal|0
operator|)
operator|&&
operator|(
call|(
name|bits64
call|)
argument_list|(
operator|(
name|a
operator|.
name|high
operator||
name|b
operator|.
name|high
operator|)
operator|<<
literal|1
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns 1 if the quadruple-precision floating-point value `a' is less than or equal to the corresponding value `b', and 0 otherwise.  Quiet NaNs do not cause an exception.  Otherwise, the comparison is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|flag
name|float128_le_quiet
parameter_list|(
name|float128
name|a
parameter_list|,
name|float128
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|extractFloat128Exp
argument_list|(
name|a
argument_list|)
operator|==
literal|0x7FFF
operator|)
operator|&&
operator|(
name|extractFloat128Frac0
argument_list|(
name|a
argument_list|)
operator||
name|extractFloat128Frac1
argument_list|(
name|a
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|extractFloat128Exp
argument_list|(
name|b
argument_list|)
operator|==
literal|0x7FFF
operator|)
operator|&&
operator|(
name|extractFloat128Frac0
argument_list|(
name|b
argument_list|)
operator||
name|extractFloat128Frac1
argument_list|(
name|b
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|float128_is_signaling_nan
argument_list|(
name|a
argument_list|)
operator|||
name|float128_is_signaling_nan
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|aSign
operator|=
name|extractFloat128Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat128Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aSign
operator|!=
name|bSign
condition|)
block|{
return|return
name|aSign
operator|||
operator|(
operator|(
operator|(
call|(
name|bits64
call|)
argument_list|(
operator|(
name|a
operator|.
name|high
operator||
name|b
operator|.
name|high
operator|)
operator|<<
literal|1
argument_list|)
operator|)
operator||
name|a
operator|.
name|low
operator||
name|b
operator|.
name|low
operator|)
operator|==
literal|0
operator|)
return|;
block|}
return|return
name|aSign
condition|?
name|le128
argument_list|(
name|b
operator|.
name|high
argument_list|,
name|b
operator|.
name|low
argument_list|,
name|a
operator|.
name|high
argument_list|,
name|a
operator|.
name|low
argument_list|)
else|:
name|le128
argument_list|(
name|a
operator|.
name|high
argument_list|,
name|a
operator|.
name|low
argument_list|,
name|b
operator|.
name|high
argument_list|,
name|b
operator|.
name|low
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns 1 if the quadruple-precision floating-point value `a' is less than the corresponding value `b', and 0 otherwise.  Quiet NaNs do not cause an exception.  Otherwise, the comparison is performed according to the IEC/IEEE Standard for Binary Floating-Point Arithmetic. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|flag
name|float128_lt_quiet
parameter_list|(
name|float128
name|a
parameter_list|,
name|float128
name|b
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|,
name|bSign
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|extractFloat128Exp
argument_list|(
name|a
argument_list|)
operator|==
literal|0x7FFF
operator|)
operator|&&
operator|(
name|extractFloat128Frac0
argument_list|(
name|a
argument_list|)
operator||
name|extractFloat128Frac1
argument_list|(
name|a
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|extractFloat128Exp
argument_list|(
name|b
argument_list|)
operator|==
literal|0x7FFF
operator|)
operator|&&
operator|(
name|extractFloat128Frac0
argument_list|(
name|b
argument_list|)
operator||
name|extractFloat128Frac1
argument_list|(
name|b
argument_list|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|float128_is_signaling_nan
argument_list|(
name|a
argument_list|)
operator|||
name|float128_is_signaling_nan
argument_list|(
name|b
argument_list|)
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
name|aSign
operator|=
name|extractFloat128Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|bSign
operator|=
name|extractFloat128Sign
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|aSign
operator|!=
name|bSign
condition|)
block|{
return|return
name|aSign
operator|&&
operator|(
operator|(
operator|(
call|(
name|bits64
call|)
argument_list|(
operator|(
name|a
operator|.
name|high
operator||
name|b
operator|.
name|high
operator|)
operator|<<
literal|1
argument_list|)
operator|)
operator||
name|a
operator|.
name|low
operator||
name|b
operator|.
name|low
operator|)
operator|!=
literal|0
operator|)
return|;
block|}
return|return
name|aSign
condition|?
name|lt128
argument_list|(
name|b
operator|.
name|high
argument_list|,
name|b
operator|.
name|low
argument_list|,
name|a
operator|.
name|high
argument_list|,
name|a
operator|.
name|low
argument_list|)
else|:
name|lt128
argument_list|(
name|a
operator|.
name|high
argument_list|,
name|a
operator|.
name|low
argument_list|,
name|b
operator|.
name|high
argument_list|,
name|b
operator|.
name|low
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SOFTFLOAT_FOR_GCC
argument_list|)
operator|&&
name|defined
argument_list|(
name|SOFTFLOAT_NEED_FIXUNS
argument_list|)
end_if

begin_comment
comment|/*  * These two routines are not part of the original softfloat distribution.  *  * They are based on the corresponding conversions to integer but return  * unsigned numbers instead since these functions are required by GCC.  *  * Added by Mark Brinicombe<mark@NetBSD.org>	27/09/97  *  * float64 version overhauled for SoftFloat 2a [bjh21 2000-07-15]  */
end_comment

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the double-precision floating-point value `a' to the 32-bit unsigned integer format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-point Arithmetic, except that the conversion is always rounded toward zero.  If `a' is a NaN, the largest positive integer is returned.  If the conversion overflows, the largest integer positive is returned. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|uint32
name|float64_to_uint32_round_to_zero
parameter_list|(
name|float64
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|,
name|shiftCount
decl_stmt|;
name|bits64
name|aSig
decl_stmt|,
name|savedASig
decl_stmt|;
name|uint32
name|z
decl_stmt|;
name|aSig
operator|=
name|extractFloat64Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat64Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat64Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|aSign
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
literal|0x41E
operator|<
name|aExp
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
literal|0xffffffff
return|;
block|}
elseif|else
if|if
condition|(
name|aExp
operator|<
literal|0x3FF
condition|)
block|{
if|if
condition|(
name|aExp
operator|||
name|aSig
condition|)
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
return|return
literal|0
return|;
block|}
name|aSig
operator||=
name|LIT64
argument_list|(
literal|0x0010000000000000
argument_list|)
expr_stmt|;
name|shiftCount
operator|=
literal|0x433
operator|-
name|aExp
expr_stmt|;
name|savedASig
operator|=
name|aSig
expr_stmt|;
name|aSig
operator|>>=
name|shiftCount
expr_stmt|;
name|z
operator|=
name|aSig
expr_stmt|;
if|if
condition|(
operator|(
name|aSig
operator|<<
name|shiftCount
operator|)
operator|!=
name|savedASig
condition|)
block|{
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
block|}
return|return
name|z
return|;
block|}
end_function

begin_comment
comment|/* ------------------------------------------------------------------------------- Returns the result of converting the single-precision floating-point value `a' to the 32-bit unsigned integer format.  The conversion is performed according to the IEC/IEEE Standard for Binary Floating-point Arithmetic, except that the conversion is always rounded toward zero.  If `a' is a NaN, the largest positive integer is returned.  If the conversion overflows, the largest positive integer is returned. ------------------------------------------------------------------------------- */
end_comment

begin_function
name|uint32
name|float32_to_uint32_round_to_zero
parameter_list|(
name|float32
name|a
parameter_list|)
block|{
name|flag
name|aSign
decl_stmt|;
name|int16
name|aExp
decl_stmt|,
name|shiftCount
decl_stmt|;
name|bits32
name|aSig
decl_stmt|;
name|uint32
name|z
decl_stmt|;
name|aSig
operator|=
name|extractFloat32Frac
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aExp
operator|=
name|extractFloat32Exp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|aSign
operator|=
name|extractFloat32Sign
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|shiftCount
operator|=
name|aExp
operator|-
literal|0x9E
expr_stmt|;
if|if
condition|(
name|aSign
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
literal|0
operator|<
name|shiftCount
condition|)
block|{
name|float_raise
argument_list|(
name|float_flag_invalid
argument_list|)
expr_stmt|;
return|return
literal|0xFFFFFFFF
return|;
block|}
elseif|else
if|if
condition|(
name|aExp
operator|<=
literal|0x7E
condition|)
block|{
if|if
condition|(
name|aExp
operator||
name|aSig
condition|)
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
return|return
literal|0
return|;
block|}
name|aSig
operator|=
operator|(
name|aSig
operator||
literal|0x800000
operator|)
operator|<<
literal|8
expr_stmt|;
name|z
operator|=
name|aSig
operator|>>
operator|(
operator|-
name|shiftCount
operator|)
expr_stmt|;
if|if
condition|(
name|aSig
operator|<<
operator|(
name|shiftCount
operator|&
literal|31
operator|)
condition|)
block|{
name|float_exception_flags
operator||=
name|float_flag_inexact
expr_stmt|;
block|}
return|return
name|z
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

