begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: xdr_rec.c,v 1.18 2000/07/06 03:10:35 christos Exp $	*/
end_comment

begin_comment
comment|/*-  * SPDX-License-Identifier: BSD-3-Clause  *  * Copyright (c) 2010, Oracle America, Inc.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *     * Redistributions of source code must retain the above copyright  *       notice, this list of conditions and the following disclaimer.  *     * Redistributions in binary form must reproduce the above  *       copyright notice, this list of conditions and the following  *       disclaimer in the documentation and/or other materials  *       provided with the distribution.  *     * Neither the name of the "Oracle America, Inc." nor the names of its  *       contributors may be used to endorse or promote products derived  *       from this software without specific prior written permission.  *  *   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS  *   "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT  *   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS  *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE  *   COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,  *   INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  *   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE  *   GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  *   WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING  *   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE  *   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid2
init|=
literal|"@(#)xdr_rec.c 1.21 87/08/11 Copyr 1984 Sun Micro"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)xdr_rec.c	2.2 88/08/01 4.0 RPCSRC"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * xdr_rec.c, Implements TCP/IP based XDR streams with a "record marking"  * layer above tcp (for rpc's use).  *  * These routines interface XDRSTREAMS to a tcp/ip connection.  * There is a record marking layer between the xdr stream  * and the tcp transport level.  A record is composed on one or more  * record fragments.  A record fragment is a thirty-two bit header followed  * by n bytes of data, where n is contained in the header.  The header  * is represented as a htonl(u_long).  Thegh order bit encodes  * whether or not the fragment is the last fragment of the record  * (1 => fragment is last, 0 => more fragments to follow.   * The other 31 bits encode the byte length of the fragment.  */
end_comment

begin_include
include|#
directive|include
file|"namespace.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<rpc/types.h>
end_include

begin_include
include|#
directive|include
file|<rpc/xdr.h>
end_include

begin_include
include|#
directive|include
file|<rpc/auth.h>
end_include

begin_include
include|#
directive|include
file|<rpc/svc.h>
end_include

begin_include
include|#
directive|include
file|<rpc/clnt.h>
end_include

begin_include
include|#
directive|include
file|<sys/stddef.h>
end_include

begin_include
include|#
directive|include
file|"un-namespace.h"
end_include

begin_include
include|#
directive|include
file|"rpc_com.h"
end_include

begin_function_decl
specifier|static
name|bool_t
name|xdrrec_getlong
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|long
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|xdrrec_putlong
parameter_list|(
name|XDR
modifier|*
parameter_list|,
specifier|const
name|long
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|xdrrec_getbytes
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|xdrrec_putbytes
parameter_list|(
name|XDR
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|xdrrec_getpos
parameter_list|(
name|XDR
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|xdrrec_setpos
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
modifier|*
name|xdrrec_inline
parameter_list|(
name|XDR
modifier|*
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xdrrec_destroy
parameter_list|(
name|XDR
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|xdr_ops
name|xdrrec_ops
init|=
block|{
name|xdrrec_getlong
block|,
name|xdrrec_putlong
block|,
name|xdrrec_getbytes
block|,
name|xdrrec_putbytes
block|,
name|xdrrec_getpos
block|,
name|xdrrec_setpos
block|,
name|xdrrec_inline
block|,
name|xdrrec_destroy
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * A record is composed of one or more record fragments.  * A record fragment is a four-byte header followed by zero to  * 2**32-1 bytes.  The header is treated as a long unsigned and is  * encode/decoded to the network via htonl/ntohl.  The low order 31 bits  * are a byte count of the fragment.  The highest order bit is a boolean:  * 1 => this fragment is the last fragment of the record,  * 0 => this fragment is followed by more fragment(s).  *  * The fragment/record machinery is not general;  it is constructed to  * meet the needs of xdr and rpc based on tcp.  */
end_comment

begin_define
define|#
directive|define
name|LAST_FRAG
value|((u_int32_t)(1U<< 31))
end_define

begin_typedef
typedef|typedef
struct|struct
name|rec_strm
block|{
name|char
modifier|*
name|tcp_handle
decl_stmt|;
comment|/* 	 * out-goung bits 	 */
name|int
function_decl|(
modifier|*
name|writeit
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
name|char
modifier|*
name|out_base
decl_stmt|;
comment|/* output buffer (points to frag header) */
name|char
modifier|*
name|out_finger
decl_stmt|;
comment|/* next output position */
name|char
modifier|*
name|out_boundry
decl_stmt|;
comment|/* data cannot up to this address */
name|u_int32_t
modifier|*
name|frag_header
decl_stmt|;
comment|/* beginning of curren fragment */
name|bool_t
name|frag_sent
decl_stmt|;
comment|/* true if buffer sent in middle of record */
comment|/* 	 * in-coming bits 	 */
name|int
function_decl|(
modifier|*
name|readit
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
name|u_long
name|in_size
decl_stmt|;
comment|/* fixed size of the input buffer */
name|char
modifier|*
name|in_base
decl_stmt|;
name|char
modifier|*
name|in_finger
decl_stmt|;
comment|/* location of next byte to be had */
name|char
modifier|*
name|in_boundry
decl_stmt|;
comment|/* can read up to this location */
name|long
name|fbtbc
decl_stmt|;
comment|/* fragment bytes to be consumed */
name|bool_t
name|last_frag
decl_stmt|;
name|u_int
name|sendsize
decl_stmt|;
name|u_int
name|recvsize
decl_stmt|;
name|bool_t
name|nonblock
decl_stmt|;
name|bool_t
name|in_haveheader
decl_stmt|;
name|u_int32_t
name|in_header
decl_stmt|;
name|char
modifier|*
name|in_hdrp
decl_stmt|;
name|int
name|in_hdrlen
decl_stmt|;
name|int
name|in_reclen
decl_stmt|;
name|int
name|in_received
decl_stmt|;
name|int
name|in_maxrec
decl_stmt|;
block|}
name|RECSTREAM
typedef|;
end_typedef

begin_function_decl
specifier|static
name|u_int
name|fix_buf_size
parameter_list|(
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|flush_out
parameter_list|(
name|RECSTREAM
modifier|*
parameter_list|,
name|bool_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|fill_input_buf
parameter_list|(
name|RECSTREAM
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|get_input_bytes
parameter_list|(
name|RECSTREAM
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|set_input_fragment
parameter_list|(
name|RECSTREAM
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|skip_input_bytes
parameter_list|(
name|RECSTREAM
modifier|*
parameter_list|,
name|long
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|realloc_stream
parameter_list|(
name|RECSTREAM
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Create an xdr handle for xdrrec  * xdrrec_create fills in xdrs.  Sendsize and recvsize are  * send and recv buffer sizes (0 => use default).  * tcp_handle is an opaque handle that is passed as the first parameter to  * the procedures readit and writeit.  Readit and writeit are read and  * write respectively.   They are like the system  * calls expect that they take an opaque handle rather than an fd.  */
end_comment

begin_function
name|void
name|xdrrec_create
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|u_int
name|sendsize
parameter_list|,
name|u_int
name|recvsize
parameter_list|,
name|void
modifier|*
name|tcp_handle
parameter_list|,
name|int
function_decl|(
modifier|*
name|readit
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|,
name|int
function_decl|(
modifier|*
name|writeit
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|)
comment|/*  *	XDR *xdrs;  *	u_int sendsize;  *	u_int recvsize;  *	void *tcp_handle;  *	// like read, but pass it a tcp_handle, not sock  *	int (*readit)(void *, void *, int);  *	// like write, but pass it a tcp_handle, not sock  *	int (*writeit)(void *, void *, int);  */
block|{
name|RECSTREAM
modifier|*
name|rstrm
init|=
name|mem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|RECSTREAM
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|rstrm
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"xdrrec_create: out of memory"
argument_list|)
expr_stmt|;
comment|/*  		 *  This is bad.  Should rework xdrrec_create to  		 *  return a handle, and in this case return NULL 		 */
return|return;
block|}
name|rstrm
operator|->
name|sendsize
operator|=
name|sendsize
operator|=
name|fix_buf_size
argument_list|(
name|sendsize
argument_list|)
expr_stmt|;
name|rstrm
operator|->
name|out_base
operator|=
name|mem_alloc
argument_list|(
name|rstrm
operator|->
name|sendsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|rstrm
operator|->
name|out_base
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"xdrrec_create: out of memory"
argument_list|)
expr_stmt|;
name|mem_free
argument_list|(
name|rstrm
argument_list|,
sizeof|sizeof
argument_list|(
name|RECSTREAM
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|rstrm
operator|->
name|recvsize
operator|=
name|recvsize
operator|=
name|fix_buf_size
argument_list|(
name|recvsize
argument_list|)
expr_stmt|;
name|rstrm
operator|->
name|in_base
operator|=
name|mem_alloc
argument_list|(
name|recvsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|rstrm
operator|->
name|in_base
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"xdrrec_create: out of memory"
argument_list|)
expr_stmt|;
name|mem_free
argument_list|(
name|rstrm
operator|->
name|out_base
argument_list|,
name|sendsize
argument_list|)
expr_stmt|;
name|mem_free
argument_list|(
name|rstrm
argument_list|,
sizeof|sizeof
argument_list|(
name|RECSTREAM
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * now the rest ... 	 */
name|xdrs
operator|->
name|x_ops
operator|=
operator|&
name|xdrrec_ops
expr_stmt|;
name|xdrs
operator|->
name|x_private
operator|=
name|rstrm
expr_stmt|;
name|rstrm
operator|->
name|tcp_handle
operator|=
name|tcp_handle
expr_stmt|;
name|rstrm
operator|->
name|readit
operator|=
name|readit
expr_stmt|;
name|rstrm
operator|->
name|writeit
operator|=
name|writeit
expr_stmt|;
name|rstrm
operator|->
name|out_finger
operator|=
name|rstrm
operator|->
name|out_boundry
operator|=
name|rstrm
operator|->
name|out_base
expr_stmt|;
name|rstrm
operator|->
name|frag_header
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|rstrm
operator|->
name|out_base
expr_stmt|;
name|rstrm
operator|->
name|out_finger
operator|+=
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
name|rstrm
operator|->
name|out_boundry
operator|+=
name|sendsize
expr_stmt|;
name|rstrm
operator|->
name|frag_sent
operator|=
name|FALSE
expr_stmt|;
name|rstrm
operator|->
name|in_size
operator|=
name|recvsize
expr_stmt|;
name|rstrm
operator|->
name|in_boundry
operator|=
name|rstrm
operator|->
name|in_base
expr_stmt|;
name|rstrm
operator|->
name|in_finger
operator|=
operator|(
name|rstrm
operator|->
name|in_boundry
operator|+=
name|recvsize
operator|)
expr_stmt|;
name|rstrm
operator|->
name|fbtbc
operator|=
literal|0
expr_stmt|;
name|rstrm
operator|->
name|last_frag
operator|=
name|TRUE
expr_stmt|;
name|rstrm
operator|->
name|in_haveheader
operator|=
name|FALSE
expr_stmt|;
name|rstrm
operator|->
name|in_hdrlen
operator|=
literal|0
expr_stmt|;
name|rstrm
operator|->
name|in_hdrp
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|&
name|rstrm
operator|->
name|in_header
expr_stmt|;
name|rstrm
operator|->
name|nonblock
operator|=
name|FALSE
expr_stmt|;
name|rstrm
operator|->
name|in_reclen
operator|=
literal|0
expr_stmt|;
name|rstrm
operator|->
name|in_received
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The reoutines defined below are the xdr ops which will go into the  * xdr handle filled in by xdrrec_create.  */
end_comment

begin_function
specifier|static
name|bool_t
name|xdrrec_getlong
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|long
modifier|*
name|lp
parameter_list|)
block|{
name|RECSTREAM
modifier|*
name|rstrm
init|=
operator|(
name|RECSTREAM
operator|*
operator|)
operator|(
name|xdrs
operator|->
name|x_private
operator|)
decl_stmt|;
name|int32_t
modifier|*
name|buflp
init|=
operator|(
name|int32_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
name|rstrm
operator|->
name|in_finger
operator|)
decl_stmt|;
name|int32_t
name|mylong
decl_stmt|;
comment|/* first try the inline, fast case */
if|if
condition|(
operator|(
name|rstrm
operator|->
name|fbtbc
operator|>=
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
operator|)
operator|&&
operator|(
operator|(
operator|(
name|long
operator|)
name|rstrm
operator|->
name|in_boundry
operator|-
operator|(
name|long
operator|)
name|buflp
operator|)
operator|>=
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
operator|)
condition|)
block|{
operator|*
name|lp
operator|=
operator|(
name|long
operator|)
name|ntohl
argument_list|(
call|(
name|u_int32_t
call|)
argument_list|(
operator|*
name|buflp
argument_list|)
argument_list|)
expr_stmt|;
name|rstrm
operator|->
name|fbtbc
operator|-=
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
expr_stmt|;
name|rstrm
operator|->
name|in_finger
operator|+=
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|xdrrec_getbytes
argument_list|(
name|xdrs
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|&
name|mylong
argument_list|,
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
operator|*
name|lp
operator|=
operator|(
name|long
operator|)
name|ntohl
argument_list|(
operator|(
name|u_int32_t
operator|)
name|mylong
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool_t
name|xdrrec_putlong
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
specifier|const
name|long
modifier|*
name|lp
parameter_list|)
block|{
name|RECSTREAM
modifier|*
name|rstrm
init|=
operator|(
name|RECSTREAM
operator|*
operator|)
operator|(
name|xdrs
operator|->
name|x_private
operator|)
decl_stmt|;
name|int32_t
modifier|*
name|dest_lp
init|=
operator|(
operator|(
name|int32_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
name|rstrm
operator|->
name|out_finger
operator|)
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|rstrm
operator|->
name|out_finger
operator|+=
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
operator|)
operator|>
name|rstrm
operator|->
name|out_boundry
condition|)
block|{
comment|/* 		 * this case should almost never happen so the code is 		 * inefficient 		 */
name|rstrm
operator|->
name|out_finger
operator|-=
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
expr_stmt|;
name|rstrm
operator|->
name|frag_sent
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|flush_out
argument_list|(
name|rstrm
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|dest_lp
operator|=
operator|(
operator|(
name|int32_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
name|rstrm
operator|->
name|out_finger
operator|)
operator|)
expr_stmt|;
name|rstrm
operator|->
name|out_finger
operator|+=
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
expr_stmt|;
block|}
operator|*
name|dest_lp
operator|=
operator|(
name|int32_t
operator|)
name|htonl
argument_list|(
call|(
name|u_int32_t
call|)
argument_list|(
operator|*
name|lp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool_t
comment|/* must manage buffers, fragments, and records */
name|xdrrec_getbytes
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
name|RECSTREAM
modifier|*
name|rstrm
init|=
operator|(
name|RECSTREAM
operator|*
operator|)
operator|(
name|xdrs
operator|->
name|x_private
operator|)
decl_stmt|;
name|int
name|current
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|current
operator|=
operator|(
name|int
operator|)
name|rstrm
operator|->
name|fbtbc
expr_stmt|;
if|if
condition|(
name|current
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rstrm
operator|->
name|last_frag
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|set_input_fragment
argument_list|(
name|rstrm
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
continue|continue;
block|}
name|current
operator|=
operator|(
name|len
operator|<
name|current
operator|)
condition|?
name|len
else|:
name|current
expr_stmt|;
if|if
condition|(
operator|!
name|get_input_bytes
argument_list|(
name|rstrm
argument_list|,
name|addr
argument_list|,
name|current
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|addr
operator|+=
name|current
expr_stmt|;
name|rstrm
operator|->
name|fbtbc
operator|-=
name|current
expr_stmt|;
name|len
operator|-=
name|current
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool_t
name|xdrrec_putbytes
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
specifier|const
name|char
modifier|*
name|addr
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
name|RECSTREAM
modifier|*
name|rstrm
init|=
operator|(
name|RECSTREAM
operator|*
operator|)
operator|(
name|xdrs
operator|->
name|x_private
operator|)
decl_stmt|;
name|size_t
name|current
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|current
operator|=
call|(
name|size_t
call|)
argument_list|(
operator|(
name|u_long
operator|)
name|rstrm
operator|->
name|out_boundry
operator|-
operator|(
name|u_long
operator|)
name|rstrm
operator|->
name|out_finger
argument_list|)
expr_stmt|;
name|current
operator|=
operator|(
name|len
operator|<
name|current
operator|)
condition|?
name|len
else|:
name|current
expr_stmt|;
name|memmove
argument_list|(
name|rstrm
operator|->
name|out_finger
argument_list|,
name|addr
argument_list|,
name|current
argument_list|)
expr_stmt|;
name|rstrm
operator|->
name|out_finger
operator|+=
name|current
expr_stmt|;
name|addr
operator|+=
name|current
expr_stmt|;
name|len
operator|-=
name|current
expr_stmt|;
if|if
condition|(
name|rstrm
operator|->
name|out_finger
operator|==
name|rstrm
operator|->
name|out_boundry
condition|)
block|{
name|rstrm
operator|->
name|frag_sent
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|flush_out
argument_list|(
name|rstrm
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|xdrrec_getpos
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|)
block|{
name|RECSTREAM
modifier|*
name|rstrm
init|=
operator|(
name|RECSTREAM
operator|*
operator|)
name|xdrs
operator|->
name|x_private
decl_stmt|;
name|off_t
name|pos
decl_stmt|;
name|pos
operator|=
name|lseek
argument_list|(
operator|(
name|int
operator|)
operator|(
name|u_long
operator|)
name|rstrm
operator|->
name|tcp_handle
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
operator|-
literal|1
condition|)
name|pos
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|xdrs
operator|->
name|x_op
condition|)
block|{
case|case
name|XDR_ENCODE
case|:
name|pos
operator|+=
name|rstrm
operator|->
name|out_finger
operator|-
name|rstrm
operator|->
name|out_base
expr_stmt|;
break|break;
case|case
name|XDR_DECODE
case|:
name|pos
operator|-=
name|rstrm
operator|->
name|in_boundry
operator|-
name|rstrm
operator|->
name|in_finger
expr_stmt|;
break|break;
default|default:
name|pos
operator|=
operator|(
name|off_t
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
block|}
return|return
operator|(
operator|(
name|u_int
operator|)
name|pos
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool_t
name|xdrrec_setpos
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|u_int
name|pos
parameter_list|)
block|{
name|RECSTREAM
modifier|*
name|rstrm
init|=
operator|(
name|RECSTREAM
operator|*
operator|)
name|xdrs
operator|->
name|x_private
decl_stmt|;
name|u_int
name|currpos
init|=
name|xdrrec_getpos
argument_list|(
name|xdrs
argument_list|)
decl_stmt|;
name|int
name|delta
init|=
name|currpos
operator|-
name|pos
decl_stmt|;
name|char
modifier|*
name|newpos
decl_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|currpos
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|xdrs
operator|->
name|x_op
condition|)
block|{
case|case
name|XDR_ENCODE
case|:
name|newpos
operator|=
name|rstrm
operator|->
name|out_finger
operator|-
name|delta
expr_stmt|;
if|if
condition|(
operator|(
name|newpos
operator|>
operator|(
name|char
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
name|rstrm
operator|->
name|frag_header
operator|)
operator|)
operator|&&
operator|(
name|newpos
operator|<
name|rstrm
operator|->
name|out_boundry
operator|)
condition|)
block|{
name|rstrm
operator|->
name|out_finger
operator|=
name|newpos
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
break|break;
case|case
name|XDR_DECODE
case|:
name|newpos
operator|=
name|rstrm
operator|->
name|in_finger
operator|-
name|delta
expr_stmt|;
if|if
condition|(
operator|(
name|delta
operator|<
call|(
name|int
call|)
argument_list|(
name|rstrm
operator|->
name|fbtbc
argument_list|)
operator|)
operator|&&
operator|(
name|newpos
operator|<=
name|rstrm
operator|->
name|in_boundry
operator|)
operator|&&
operator|(
name|newpos
operator|>=
name|rstrm
operator|->
name|in_base
operator|)
condition|)
block|{
name|rstrm
operator|->
name|in_finger
operator|=
name|newpos
expr_stmt|;
name|rstrm
operator|->
name|fbtbc
operator|-=
name|delta
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
break|break;
case|case
name|XDR_FREE
case|:
break|break;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
modifier|*
name|xdrrec_inline
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|u_int
name|len
parameter_list|)
block|{
name|RECSTREAM
modifier|*
name|rstrm
init|=
operator|(
name|RECSTREAM
operator|*
operator|)
name|xdrs
operator|->
name|x_private
decl_stmt|;
name|int32_t
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|xdrs
operator|->
name|x_op
condition|)
block|{
case|case
name|XDR_ENCODE
case|:
if|if
condition|(
operator|(
name|rstrm
operator|->
name|out_finger
operator|+
name|len
operator|)
operator|<=
name|rstrm
operator|->
name|out_boundry
condition|)
block|{
name|buf
operator|=
operator|(
name|int32_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|rstrm
operator|->
name|out_finger
expr_stmt|;
name|rstrm
operator|->
name|out_finger
operator|+=
name|len
expr_stmt|;
block|}
break|break;
case|case
name|XDR_DECODE
case|:
if|if
condition|(
operator|(
name|len
operator|<=
name|rstrm
operator|->
name|fbtbc
operator|)
operator|&&
operator|(
operator|(
name|rstrm
operator|->
name|in_finger
operator|+
name|len
operator|)
operator|<=
name|rstrm
operator|->
name|in_boundry
operator|)
condition|)
block|{
name|buf
operator|=
operator|(
name|int32_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|rstrm
operator|->
name|in_finger
expr_stmt|;
name|rstrm
operator|->
name|fbtbc
operator|-=
name|len
expr_stmt|;
name|rstrm
operator|->
name|in_finger
operator|+=
name|len
expr_stmt|;
block|}
break|break;
case|case
name|XDR_FREE
case|:
break|break;
block|}
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xdrrec_destroy
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|)
block|{
name|RECSTREAM
modifier|*
name|rstrm
init|=
operator|(
name|RECSTREAM
operator|*
operator|)
name|xdrs
operator|->
name|x_private
decl_stmt|;
name|mem_free
argument_list|(
name|rstrm
operator|->
name|out_base
argument_list|,
name|rstrm
operator|->
name|sendsize
argument_list|)
expr_stmt|;
name|mem_free
argument_list|(
name|rstrm
operator|->
name|in_base
argument_list|,
name|rstrm
operator|->
name|recvsize
argument_list|)
expr_stmt|;
name|mem_free
argument_list|(
name|rstrm
argument_list|,
sizeof|sizeof
argument_list|(
name|RECSTREAM
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Exported routines to manage xdr records  */
end_comment

begin_comment
comment|/*  * Before reading (deserializing from the stream, one should always call  * this procedure to guarantee proper record alignment.  */
end_comment

begin_function
name|bool_t
name|xdrrec_skiprecord
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|)
block|{
name|RECSTREAM
modifier|*
name|rstrm
init|=
operator|(
name|RECSTREAM
operator|*
operator|)
operator|(
name|xdrs
operator|->
name|x_private
operator|)
decl_stmt|;
name|enum
name|xprt_stat
name|xstat
decl_stmt|;
if|if
condition|(
name|rstrm
operator|->
name|nonblock
condition|)
block|{
if|if
condition|(
name|__xdrrec_getrec
argument_list|(
name|xdrs
argument_list|,
operator|&
name|xstat
argument_list|,
name|FALSE
argument_list|)
condition|)
block|{
name|rstrm
operator|->
name|fbtbc
operator|=
literal|0
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|rstrm
operator|->
name|in_finger
operator|==
name|rstrm
operator|->
name|in_boundry
operator|&&
name|xstat
operator|==
name|XPRT_MOREREQS
condition|)
block|{
name|rstrm
operator|->
name|fbtbc
operator|=
literal|0
expr_stmt|;
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
while|while
condition|(
name|rstrm
operator|->
name|fbtbc
operator|>
literal|0
operator|||
operator|(
operator|!
name|rstrm
operator|->
name|last_frag
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|skip_input_bytes
argument_list|(
name|rstrm
argument_list|,
name|rstrm
operator|->
name|fbtbc
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|rstrm
operator|->
name|fbtbc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|rstrm
operator|->
name|last_frag
operator|)
operator|&&
operator|(
operator|!
name|set_input_fragment
argument_list|(
name|rstrm
argument_list|)
operator|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|rstrm
operator|->
name|last_frag
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look ahead function.  * Returns TRUE iff there is no more input in the buffer  * after consuming the rest of the current record.  */
end_comment

begin_function
name|bool_t
name|xdrrec_eof
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|)
block|{
name|RECSTREAM
modifier|*
name|rstrm
init|=
operator|(
name|RECSTREAM
operator|*
operator|)
operator|(
name|xdrs
operator|->
name|x_private
operator|)
decl_stmt|;
while|while
condition|(
name|rstrm
operator|->
name|fbtbc
operator|>
literal|0
operator|||
operator|(
operator|!
name|rstrm
operator|->
name|last_frag
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|skip_input_bytes
argument_list|(
name|rstrm
argument_list|,
name|rstrm
operator|->
name|fbtbc
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
name|rstrm
operator|->
name|fbtbc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|rstrm
operator|->
name|last_frag
operator|)
operator|&&
operator|(
operator|!
name|set_input_fragment
argument_list|(
name|rstrm
argument_list|)
operator|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
if|if
condition|(
name|rstrm
operator|->
name|in_finger
operator|==
name|rstrm
operator|->
name|in_boundry
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The client must tell the package when an end-of-record has occurred.  * The second paraemters tells whether the record should be flushed to the  * (output) tcp stream.  (This let's the package support batched or  * pipelined procedure calls.)  TRUE => immmediate flush to tcp connection.  */
end_comment

begin_function
name|bool_t
name|xdrrec_endofrecord
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|bool_t
name|sendnow
parameter_list|)
block|{
name|RECSTREAM
modifier|*
name|rstrm
init|=
operator|(
name|RECSTREAM
operator|*
operator|)
operator|(
name|xdrs
operator|->
name|x_private
operator|)
decl_stmt|;
name|u_long
name|len
decl_stmt|;
comment|/* fragment length */
if|if
condition|(
name|sendnow
operator|||
name|rstrm
operator|->
name|frag_sent
operator|||
operator|(
operator|(
name|u_long
operator|)
name|rstrm
operator|->
name|out_finger
operator|+
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|>=
operator|(
name|u_long
operator|)
name|rstrm
operator|->
name|out_boundry
operator|)
condition|)
block|{
name|rstrm
operator|->
name|frag_sent
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|flush_out
argument_list|(
name|rstrm
argument_list|,
name|TRUE
argument_list|)
operator|)
return|;
block|}
name|len
operator|=
call|(
name|u_long
call|)
argument_list|(
name|rstrm
operator|->
name|out_finger
argument_list|)
operator|-
call|(
name|u_long
call|)
argument_list|(
name|rstrm
operator|->
name|frag_header
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
operator|*
operator|(
name|rstrm
operator|->
name|frag_header
operator|)
operator|=
name|htonl
argument_list|(
operator|(
name|u_int32_t
operator|)
name|len
operator||
name|LAST_FRAG
argument_list|)
expr_stmt|;
name|rstrm
operator|->
name|frag_header
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|rstrm
operator|->
name|out_finger
expr_stmt|;
name|rstrm
operator|->
name|out_finger
operator|+=
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fill the stream buffer with a record for a non-blocking connection.  * Return true if a record is available in the buffer, false if not.  */
end_comment

begin_function
name|bool_t
name|__xdrrec_getrec
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|enum
name|xprt_stat
modifier|*
name|statp
parameter_list|,
name|bool_t
name|expectdata
parameter_list|)
block|{
name|RECSTREAM
modifier|*
name|rstrm
init|=
operator|(
name|RECSTREAM
operator|*
operator|)
operator|(
name|xdrs
operator|->
name|x_private
operator|)
decl_stmt|;
name|ssize_t
name|n
decl_stmt|;
name|int
name|fraglen
decl_stmt|;
if|if
condition|(
operator|!
name|rstrm
operator|->
name|in_haveheader
condition|)
block|{
name|n
operator|=
name|rstrm
operator|->
name|readit
argument_list|(
name|rstrm
operator|->
name|tcp_handle
argument_list|,
name|rstrm
operator|->
name|in_hdrp
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|rstrm
operator|->
name|in_header
argument_list|)
operator|-
name|rstrm
operator|->
name|in_hdrlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
operator|*
name|statp
operator|=
name|expectdata
condition|?
name|XPRT_DIED
else|:
name|XPRT_IDLE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
operator|*
name|statp
operator|=
name|XPRT_DIED
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|rstrm
operator|->
name|in_hdrp
operator|+=
name|n
expr_stmt|;
name|rstrm
operator|->
name|in_hdrlen
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|rstrm
operator|->
name|in_hdrlen
operator|<
sizeof|sizeof
argument_list|(
name|rstrm
operator|->
name|in_header
argument_list|)
condition|)
block|{
operator|*
name|statp
operator|=
name|XPRT_MOREREQS
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|rstrm
operator|->
name|in_header
operator|=
name|ntohl
argument_list|(
name|rstrm
operator|->
name|in_header
argument_list|)
expr_stmt|;
name|fraglen
operator|=
call|(
name|int
call|)
argument_list|(
name|rstrm
operator|->
name|in_header
operator|&
operator|~
name|LAST_FRAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|fraglen
operator|==
literal|0
operator|||
name|fraglen
operator|>
name|rstrm
operator|->
name|in_maxrec
operator|||
operator|(
name|rstrm
operator|->
name|in_reclen
operator|+
name|fraglen
operator|)
operator|>
name|rstrm
operator|->
name|in_maxrec
condition|)
block|{
operator|*
name|statp
operator|=
name|XPRT_DIED
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|rstrm
operator|->
name|in_reclen
operator|+=
name|fraglen
expr_stmt|;
if|if
condition|(
name|rstrm
operator|->
name|in_reclen
operator|>
name|rstrm
operator|->
name|recvsize
condition|)
name|realloc_stream
argument_list|(
name|rstrm
argument_list|,
name|rstrm
operator|->
name|in_reclen
argument_list|)
expr_stmt|;
if|if
condition|(
name|rstrm
operator|->
name|in_header
operator|&
name|LAST_FRAG
condition|)
block|{
name|rstrm
operator|->
name|in_header
operator|&=
operator|~
name|LAST_FRAG
expr_stmt|;
name|rstrm
operator|->
name|last_frag
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* 		 * We can only reasonably expect to read once from a 		 * non-blocking stream. Reading the fragment header 		 * may have drained the stream. 		 */
name|expectdata
operator|=
name|FALSE
expr_stmt|;
block|}
name|n
operator|=
name|rstrm
operator|->
name|readit
argument_list|(
name|rstrm
operator|->
name|tcp_handle
argument_list|,
name|rstrm
operator|->
name|in_base
operator|+
name|rstrm
operator|->
name|in_received
argument_list|,
operator|(
name|rstrm
operator|->
name|in_reclen
operator|-
name|rstrm
operator|->
name|in_received
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
operator|*
name|statp
operator|=
name|XPRT_DIED
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
operator|*
name|statp
operator|=
name|expectdata
condition|?
name|XPRT_DIED
else|:
name|XPRT_IDLE
expr_stmt|;
return|return
name|FALSE
return|;
block|}
name|rstrm
operator|->
name|in_received
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|rstrm
operator|->
name|in_received
operator|==
name|rstrm
operator|->
name|in_reclen
condition|)
block|{
name|rstrm
operator|->
name|in_haveheader
operator|=
name|FALSE
expr_stmt|;
name|rstrm
operator|->
name|in_hdrp
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|&
name|rstrm
operator|->
name|in_header
expr_stmt|;
name|rstrm
operator|->
name|in_hdrlen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rstrm
operator|->
name|last_frag
condition|)
block|{
name|rstrm
operator|->
name|fbtbc
operator|=
name|rstrm
operator|->
name|in_reclen
expr_stmt|;
name|rstrm
operator|->
name|in_boundry
operator|=
name|rstrm
operator|->
name|in_base
operator|+
name|rstrm
operator|->
name|in_reclen
expr_stmt|;
name|rstrm
operator|->
name|in_finger
operator|=
name|rstrm
operator|->
name|in_base
expr_stmt|;
name|rstrm
operator|->
name|in_reclen
operator|=
name|rstrm
operator|->
name|in_received
operator|=
literal|0
expr_stmt|;
operator|*
name|statp
operator|=
name|XPRT_MOREREQS
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
operator|*
name|statp
operator|=
name|XPRT_MOREREQS
expr_stmt|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
name|bool_t
name|__xdrrec_setnonblock
parameter_list|(
name|XDR
modifier|*
name|xdrs
parameter_list|,
name|int
name|maxrec
parameter_list|)
block|{
name|RECSTREAM
modifier|*
name|rstrm
init|=
operator|(
name|RECSTREAM
operator|*
operator|)
operator|(
name|xdrs
operator|->
name|x_private
operator|)
decl_stmt|;
name|rstrm
operator|->
name|nonblock
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|maxrec
operator|==
literal|0
condition|)
name|maxrec
operator|=
name|rstrm
operator|->
name|recvsize
expr_stmt|;
name|rstrm
operator|->
name|in_maxrec
operator|=
name|maxrec
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/*  * Internal useful routines  */
end_comment

begin_function
specifier|static
name|bool_t
name|flush_out
parameter_list|(
name|RECSTREAM
modifier|*
name|rstrm
parameter_list|,
name|bool_t
name|eor
parameter_list|)
block|{
name|u_int32_t
name|eormask
init|=
operator|(
name|eor
operator|==
name|TRUE
operator|)
condition|?
name|LAST_FRAG
else|:
literal|0
decl_stmt|;
name|u_int32_t
name|len
init|=
call|(
name|u_int32_t
call|)
argument_list|(
call|(
name|u_long
call|)
argument_list|(
name|rstrm
operator|->
name|out_finger
argument_list|)
operator|-
call|(
name|u_long
call|)
argument_list|(
name|rstrm
operator|->
name|frag_header
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
argument_list|)
decl_stmt|;
operator|*
operator|(
name|rstrm
operator|->
name|frag_header
operator|)
operator|=
name|htonl
argument_list|(
name|len
operator||
name|eormask
argument_list|)
expr_stmt|;
name|len
operator|=
call|(
name|u_int32_t
call|)
argument_list|(
call|(
name|u_long
call|)
argument_list|(
name|rstrm
operator|->
name|out_finger
argument_list|)
operator|-
call|(
name|u_long
call|)
argument_list|(
name|rstrm
operator|->
name|out_base
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
operator|(
name|rstrm
operator|->
name|writeit
operator|)
operator|)
operator|(
name|rstrm
operator|->
name|tcp_handle
operator|,
name|rstrm
operator|->
name|out_base
operator|,
operator|(
name|int
operator|)
name|len
operator|)
operator|!=
operator|(
name|int
operator|)
name|len
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|rstrm
operator|->
name|frag_header
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
name|rstrm
operator|->
name|out_base
expr_stmt|;
name|rstrm
operator|->
name|out_finger
operator|=
operator|(
name|char
operator|*
operator|)
name|rstrm
operator|->
name|out_base
operator|+
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool_t
comment|/* knows nothing about records!  Only about input buffers */
name|fill_input_buf
parameter_list|(
name|RECSTREAM
modifier|*
name|rstrm
parameter_list|)
block|{
name|char
modifier|*
name|where
decl_stmt|;
name|u_int32_t
name|i
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|rstrm
operator|->
name|nonblock
condition|)
return|return
name|FALSE
return|;
name|where
operator|=
name|rstrm
operator|->
name|in_base
expr_stmt|;
name|i
operator|=
call|(
name|u_int32_t
call|)
argument_list|(
operator|(
name|u_long
operator|)
name|rstrm
operator|->
name|in_boundry
operator|%
name|BYTES_PER_XDR_UNIT
argument_list|)
expr_stmt|;
name|where
operator|+=
name|i
expr_stmt|;
name|len
operator|=
call|(
name|u_int32_t
call|)
argument_list|(
name|rstrm
operator|->
name|in_size
operator|-
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
operator|(
operator|*
operator|(
name|rstrm
operator|->
name|readit
operator|)
operator|)
operator|(
name|rstrm
operator|->
name|tcp_handle
operator|,
name|where
operator|,
name|len
operator|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|rstrm
operator|->
name|in_finger
operator|=
name|where
expr_stmt|;
name|where
operator|+=
name|len
expr_stmt|;
name|rstrm
operator|->
name|in_boundry
operator|=
name|where
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool_t
comment|/* knows nothing about records!  Only about input buffers */
name|get_input_bytes
parameter_list|(
name|RECSTREAM
modifier|*
name|rstrm
parameter_list|,
name|char
modifier|*
name|addr
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|size_t
name|current
decl_stmt|;
if|if
condition|(
name|rstrm
operator|->
name|nonblock
condition|)
block|{
if|if
condition|(
name|len
operator|>
call|(
name|int
call|)
argument_list|(
name|rstrm
operator|->
name|in_boundry
operator|-
name|rstrm
operator|->
name|in_finger
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|memcpy
argument_list|(
name|addr
argument_list|,
name|rstrm
operator|->
name|in_finger
argument_list|,
operator|(
name|size_t
operator|)
name|len
argument_list|)
expr_stmt|;
name|rstrm
operator|->
name|in_finger
operator|+=
name|len
expr_stmt|;
return|return
name|TRUE
return|;
block|}
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|current
operator|=
call|(
name|size_t
call|)
argument_list|(
operator|(
name|long
operator|)
name|rstrm
operator|->
name|in_boundry
operator|-
operator|(
name|long
operator|)
name|rstrm
operator|->
name|in_finger
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|fill_input_buf
argument_list|(
name|rstrm
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
continue|continue;
block|}
name|current
operator|=
operator|(
name|len
operator|<
name|current
operator|)
condition|?
name|len
else|:
name|current
expr_stmt|;
name|memmove
argument_list|(
name|addr
argument_list|,
name|rstrm
operator|->
name|in_finger
argument_list|,
name|current
argument_list|)
expr_stmt|;
name|rstrm
operator|->
name|in_finger
operator|+=
name|current
expr_stmt|;
name|addr
operator|+=
name|current
expr_stmt|;
name|len
operator|-=
name|current
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool_t
comment|/* next two bytes of the input stream are treated as a header */
name|set_input_fragment
parameter_list|(
name|RECSTREAM
modifier|*
name|rstrm
parameter_list|)
block|{
name|u_int32_t
name|header
decl_stmt|;
if|if
condition|(
name|rstrm
operator|->
name|nonblock
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|get_input_bytes
argument_list|(
name|rstrm
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
name|header
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|header
operator|=
name|ntohl
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|rstrm
operator|->
name|last_frag
operator|=
operator|(
operator|(
name|header
operator|&
name|LAST_FRAG
operator|)
operator|==
literal|0
operator|)
condition|?
name|FALSE
else|:
name|TRUE
expr_stmt|;
comment|/* 	 * Sanity check. Try not to accept wildly incorrect 	 * record sizes. Unfortunately, the only record size 	 * we can positively identify as being 'wildly incorrect' 	 * is zero. Ridiculously large record sizes may look wrong, 	 * but we don't have any way to be certain that they aren't 	 * what the client actually intended to send us. 	 */
if|if
condition|(
name|header
operator|==
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|rstrm
operator|->
name|fbtbc
operator|=
name|header
operator|&
operator|(
operator|~
name|LAST_FRAG
operator|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool_t
comment|/* consumes input bytes; knows nothing about records! */
name|skip_input_bytes
parameter_list|(
name|RECSTREAM
modifier|*
name|rstrm
parameter_list|,
name|long
name|cnt
parameter_list|)
block|{
name|u_int32_t
name|current
decl_stmt|;
while|while
condition|(
name|cnt
operator|>
literal|0
condition|)
block|{
name|current
operator|=
call|(
name|size_t
call|)
argument_list|(
operator|(
name|long
operator|)
name|rstrm
operator|->
name|in_boundry
operator|-
operator|(
name|long
operator|)
name|rstrm
operator|->
name|in_finger
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|fill_input_buf
argument_list|(
name|rstrm
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
continue|continue;
block|}
name|current
operator|=
call|(
name|u_int32_t
call|)
argument_list|(
operator|(
name|cnt
operator|<
name|current
operator|)
condition|?
name|cnt
else|:
name|current
argument_list|)
expr_stmt|;
name|rstrm
operator|->
name|in_finger
operator|+=
name|current
expr_stmt|;
name|cnt
operator|-=
name|current
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|fix_buf_size
parameter_list|(
name|u_int
name|s
parameter_list|)
block|{
if|if
condition|(
name|s
operator|<
literal|100
condition|)
name|s
operator|=
literal|4000
expr_stmt|;
return|return
operator|(
name|RNDUP
argument_list|(
name|s
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Reallocate the input buffer for a non-block stream.  */
end_comment

begin_function
specifier|static
name|bool_t
name|realloc_stream
parameter_list|(
name|RECSTREAM
modifier|*
name|rstrm
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|ptrdiff_t
name|diff
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|rstrm
operator|->
name|recvsize
condition|)
block|{
name|buf
operator|=
name|realloc
argument_list|(
name|rstrm
operator|->
name|in_base
argument_list|,
operator|(
name|size_t
operator|)
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
name|diff
operator|=
name|buf
operator|-
name|rstrm
operator|->
name|in_base
expr_stmt|;
name|rstrm
operator|->
name|in_finger
operator|+=
name|diff
expr_stmt|;
name|rstrm
operator|->
name|in_base
operator|=
name|buf
expr_stmt|;
name|rstrm
operator|->
name|in_boundry
operator|=
name|buf
operator|+
name|size
expr_stmt|;
name|rstrm
operator|->
name|recvsize
operator|=
name|size
expr_stmt|;
name|rstrm
operator|->
name|in_size
operator|=
name|size
expr_stmt|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

end_unit

