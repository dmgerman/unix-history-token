begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Sun RPC is a product of Sun Microsystems, Inc. and is provided for  * unrestricted use provided that this legend is included on all tape  * media and as a part of the software program in whole or part.  Users  * may copy or modify Sun RPC without charge, but are not authorized  * to license or distribute it to anyone else except as part of a product or  * program developed by the user.  *  * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE  * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR  * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.  *  * Sun RPC is provided with no support and without any obligation on the  * part of Sun Microsystems, Inc. to assist in its use, correction,  * modification or enhancement.  *  * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE  * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC  * OR ANY PART THEREOF.  *  * In no event will Sun Microsystems, Inc. be liable for any lost revenue  * or profits or other special, indirect and consequential damages, even if  * Sun has been advised of the possibility of such damages.  *  * Sun Microsystems, Inc.  * 2550 Garcia Avenue  * Mountain View, California  94043  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_comment
comment|/*static char *sccsid = "from: @(#)xdr_rec.c 1.21 87/08/11 Copyr 1984 Sun Micro";*/
end_comment

begin_comment
comment|/*static char *sccsid = "from: @(#)xdr_rec.c	2.2 88/08/01 4.0 RPCSRC";*/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * xdr_rec.c, Implements TCP/IP based XDR streams with a "record marking"  * layer above tcp (for rpc's use).  *  * Copyright (C) 1984, Sun Microsystems, Inc.  *  * These routines interface XDRSTREAMS to a tcp/ip connection.  * There is a record marking layer between the xdr stream  * and the tcp transport level.  A record is composed on one or more  * record fragments.  A record fragment is a thirty-two bit header followed  * by n bytes of data, where n is contained in the header.  The header  * is represented as a htonl(u_long).  Thegh order bit encodes  * whether or not the fragment is the last fragment of the record  * (1 => fragment is last, 0 => more fragments to follow.  * The other 31 bits encode the byte length of the fragment.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<rpc/types.h>
end_include

begin_include
include|#
directive|include
file|<rpc/xdr.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_function_decl
specifier|static
name|u_int
name|fix_buf_size
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|flush_out
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|get_input_bytes
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|set_input_fragment
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|skip_input_bytes
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|xdrrec_getlong
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|xdrrec_putlong
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|xdrrec_getbytes
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|xdrrec_putbytes
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|xdrrec_getpos
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool_t
name|xdrrec_setpos
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int32_t
modifier|*
name|xdrrec_inline
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|xdrrec_destroy
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|struct
name|xdr_ops
name|xdrrec_ops
init|=
block|{
name|xdrrec_getlong
block|,
name|xdrrec_putlong
block|,
name|xdrrec_getbytes
block|,
name|xdrrec_putbytes
block|,
name|xdrrec_getpos
block|,
name|xdrrec_setpos
block|,
name|xdrrec_inline
block|,
name|xdrrec_destroy
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * A record is composed of one or more record fragments.  * A record fragment is a two-byte header followed by zero to  * 2**32-1 bytes.  The header is treated as a long unsigned and is  * encode/decoded to the network via htonl/ntohl.  The low order 31 bits  * are a byte count of the fragment.  The highest order bit is a boolean:  * 1 => this fragment is the last fragment of the record,  * 0 => this fragment is followed by more fragment(s).  *  * The fragment/record machinery is not general;  it is constructed to  * meet the needs of xdr and rpc based on tcp.  */
end_comment

begin_define
define|#
directive|define
name|LAST_FRAG
value|((u_int32_t)(1<< 31))
end_define

begin_typedef
typedef|typedef
struct|struct
name|rec_strm
block|{
name|caddr_t
name|tcp_handle
decl_stmt|;
name|caddr_t
name|the_buffer
decl_stmt|;
comment|/* 	 * out-goung bits 	 */
name|int
argument_list|(
argument|*writeit
argument_list|)
name|__P
argument_list|(
operator|(
name|caddr_t
operator|,
name|caddr_t
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
name|caddr_t
name|out_base
decl_stmt|;
comment|/* output buffer (points to frag header) */
name|caddr_t
name|out_finger
decl_stmt|;
comment|/* next output position */
name|caddr_t
name|out_boundry
decl_stmt|;
comment|/* data cannot up to this address */
name|u_int32_t
modifier|*
name|frag_header
decl_stmt|;
comment|/* beginning of current fragment */
name|bool_t
name|frag_sent
decl_stmt|;
comment|/* true if buffer sent in middle of record */
comment|/* 	 * in-coming bits 	 */
name|int
argument_list|(
argument|*readit
argument_list|)
name|__P
argument_list|(
operator|(
name|caddr_t
operator|,
name|caddr_t
operator|,
name|int
operator|)
argument_list|)
expr_stmt|;
name|u_long
name|in_size
decl_stmt|;
comment|/* fixed size of the input buffer */
name|caddr_t
name|in_base
decl_stmt|;
name|caddr_t
name|in_finger
decl_stmt|;
comment|/* location of next byte to be had */
name|caddr_t
name|in_boundry
decl_stmt|;
comment|/* can read up to this location */
name|long
name|fbtbc
decl_stmt|;
comment|/* fragment bytes to be consumed */
name|bool_t
name|last_frag
decl_stmt|;
name|u_int
name|sendsize
decl_stmt|;
name|u_int
name|recvsize
decl_stmt|;
block|}
name|RECSTREAM
typedef|;
end_typedef

begin_comment
comment|/*  * Create an xdr handle for xdrrec  * xdrrec_create fills in xdrs.  Sendsize and recvsize are  * send and recv buffer sizes (0 => use default).  * tcp_handle is an opaque handle that is passed as the first parameter to  * the procedures readit and writeit.  Readit and writeit are read and  * write respectively.   They are like the system  * calls expect that they take an opaque handle rather than an fd.  */
end_comment

begin_decl_stmt
name|void
name|xdrrec_create
argument_list|(
name|xdrs
argument_list|,
name|sendsize
argument_list|,
name|recvsize
argument_list|,
name|tcp_handle
argument_list|,
name|readit
argument_list|,
name|writeit
argument_list|)
decl|register
name|XDR
modifier|*
name|xdrs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|u_int
name|sendsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|u_int
name|recvsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|tcp_handle
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|readit
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* like read, but pass it a tcp_handle, not sock */
end_comment

begin_function_decl
name|int
function_decl|(
modifier|*
name|writeit
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* like write, but pass it a tcp_handle, not sock */
end_comment

begin_block
block|{
specifier|register
name|RECSTREAM
modifier|*
name|rstrm
init|=
operator|(
name|RECSTREAM
operator|*
operator|)
name|mem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|RECSTREAM
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|rstrm
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"xdrrec_create: out of memory\n"
argument_list|)
expr_stmt|;
comment|/* 		 *  This is bad.  Should rework xdrrec_create to 		 *  return a handle, and in this case return NULL 		 */
return|return;
block|}
comment|/* 	 * adjust sizes and allocate buffer quad byte aligned 	 */
name|rstrm
operator|->
name|sendsize
operator|=
name|sendsize
operator|=
name|fix_buf_size
argument_list|(
name|sendsize
argument_list|)
expr_stmt|;
name|rstrm
operator|->
name|recvsize
operator|=
name|recvsize
operator|=
name|fix_buf_size
argument_list|(
name|recvsize
argument_list|)
expr_stmt|;
name|rstrm
operator|->
name|the_buffer
operator|=
name|mem_alloc
argument_list|(
name|sendsize
operator|+
name|recvsize
operator|+
name|BYTES_PER_XDR_UNIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|rstrm
operator|->
name|the_buffer
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"xdrrec_create: out of memory\n"
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|rstrm
operator|->
name|out_base
operator|=
name|rstrm
operator|->
name|the_buffer
init|;
operator|(
name|u_long
operator|)
name|rstrm
operator|->
name|out_base
operator|%
name|BYTES_PER_XDR_UNIT
operator|!=
literal|0
condition|;
name|rstrm
operator|->
name|out_base
operator|++
control|)
empty_stmt|;
name|rstrm
operator|->
name|in_base
operator|=
name|rstrm
operator|->
name|out_base
operator|+
name|sendsize
expr_stmt|;
comment|/* 	 * now the rest ... 	 */
name|xdrs
operator|->
name|x_ops
operator|=
operator|&
name|xdrrec_ops
expr_stmt|;
name|xdrs
operator|->
name|x_private
operator|=
operator|(
name|caddr_t
operator|)
name|rstrm
expr_stmt|;
name|rstrm
operator|->
name|tcp_handle
operator|=
name|tcp_handle
expr_stmt|;
name|rstrm
operator|->
name|readit
operator|=
name|readit
expr_stmt|;
name|rstrm
operator|->
name|writeit
operator|=
name|writeit
expr_stmt|;
name|rstrm
operator|->
name|out_finger
operator|=
name|rstrm
operator|->
name|out_boundry
operator|=
name|rstrm
operator|->
name|out_base
expr_stmt|;
name|rstrm
operator|->
name|frag_header
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|rstrm
operator|->
name|out_base
expr_stmt|;
name|rstrm
operator|->
name|out_finger
operator|+=
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
name|rstrm
operator|->
name|out_boundry
operator|+=
name|sendsize
expr_stmt|;
name|rstrm
operator|->
name|frag_sent
operator|=
name|FALSE
expr_stmt|;
name|rstrm
operator|->
name|in_size
operator|=
name|recvsize
expr_stmt|;
name|rstrm
operator|->
name|in_boundry
operator|=
name|rstrm
operator|->
name|in_base
expr_stmt|;
name|rstrm
operator|->
name|in_finger
operator|=
operator|(
name|rstrm
operator|->
name|in_boundry
operator|+=
name|recvsize
operator|)
expr_stmt|;
name|rstrm
operator|->
name|fbtbc
operator|=
literal|0
expr_stmt|;
name|rstrm
operator|->
name|last_frag
operator|=
name|TRUE
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * The reoutines defined below are the xdr ops which will go into the  * xdr handle filled in by xdrrec_create.  */
end_comment

begin_function
specifier|static
name|bool_t
name|xdrrec_getlong
parameter_list|(
name|xdrs
parameter_list|,
name|lp
parameter_list|)
name|XDR
modifier|*
name|xdrs
decl_stmt|;
name|long
modifier|*
name|lp
decl_stmt|;
block|{
specifier|register
name|RECSTREAM
modifier|*
name|rstrm
init|=
operator|(
name|RECSTREAM
operator|*
operator|)
operator|(
name|xdrs
operator|->
name|x_private
operator|)
decl_stmt|;
specifier|register
name|int32_t
modifier|*
name|buflp
init|=
operator|(
name|int32_t
operator|*
operator|)
operator|(
name|rstrm
operator|->
name|in_finger
operator|)
decl_stmt|;
name|int32_t
name|mylong
decl_stmt|;
comment|/* first try the inline, fast case */
if|if
condition|(
operator|(
name|rstrm
operator|->
name|fbtbc
operator|>=
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
operator|)
operator|&&
operator|(
operator|(
operator|(
name|long
operator|)
name|rstrm
operator|->
name|in_boundry
operator|-
operator|(
name|long
operator|)
name|buflp
operator|)
operator|>=
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
operator|)
condition|)
block|{
operator|*
name|lp
operator|=
operator|(
name|long
operator|)
name|ntohl
argument_list|(
call|(
name|u_int32_t
call|)
argument_list|(
operator|*
name|buflp
argument_list|)
argument_list|)
expr_stmt|;
name|rstrm
operator|->
name|fbtbc
operator|-=
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
expr_stmt|;
name|rstrm
operator|->
name|in_finger
operator|+=
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|xdrrec_getbytes
argument_list|(
name|xdrs
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|mylong
argument_list|,
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
operator|*
name|lp
operator|=
operator|(
name|long
operator|)
name|ntohl
argument_list|(
operator|(
name|u_int32_t
operator|)
name|mylong
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool_t
name|xdrrec_putlong
parameter_list|(
name|xdrs
parameter_list|,
name|lp
parameter_list|)
name|XDR
modifier|*
name|xdrs
decl_stmt|;
name|long
modifier|*
name|lp
decl_stmt|;
block|{
specifier|register
name|RECSTREAM
modifier|*
name|rstrm
init|=
operator|(
name|RECSTREAM
operator|*
operator|)
operator|(
name|xdrs
operator|->
name|x_private
operator|)
decl_stmt|;
specifier|register
name|int32_t
modifier|*
name|dest_lp
init|=
operator|(
operator|(
name|int32_t
operator|*
operator|)
operator|(
name|rstrm
operator|->
name|out_finger
operator|)
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|rstrm
operator|->
name|out_finger
operator|+=
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
operator|)
operator|>
name|rstrm
operator|->
name|out_boundry
condition|)
block|{
comment|/* 		 * this case should almost never happen so the code is 		 * inefficient 		 */
name|rstrm
operator|->
name|out_finger
operator|-=
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
expr_stmt|;
name|rstrm
operator|->
name|frag_sent
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|flush_out
argument_list|(
name|rstrm
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|dest_lp
operator|=
operator|(
operator|(
name|int32_t
operator|*
operator|)
operator|(
name|rstrm
operator|->
name|out_finger
operator|)
operator|)
expr_stmt|;
name|rstrm
operator|->
name|out_finger
operator|+=
sizeof|sizeof
argument_list|(
name|int32_t
argument_list|)
expr_stmt|;
block|}
operator|*
name|dest_lp
operator|=
operator|(
name|int32_t
operator|)
name|htonl
argument_list|(
call|(
name|u_int32_t
call|)
argument_list|(
operator|*
name|lp
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool_t
comment|/* must manage buffers, fragments, and records */
name|xdrrec_getbytes
parameter_list|(
name|xdrs
parameter_list|,
name|addr
parameter_list|,
name|len
parameter_list|)
name|XDR
modifier|*
name|xdrs
decl_stmt|;
specifier|register
name|caddr_t
name|addr
decl_stmt|;
specifier|register
name|u_int
name|len
decl_stmt|;
block|{
specifier|register
name|RECSTREAM
modifier|*
name|rstrm
init|=
operator|(
name|RECSTREAM
operator|*
operator|)
operator|(
name|xdrs
operator|->
name|x_private
operator|)
decl_stmt|;
specifier|register
name|int
name|current
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|current
operator|=
name|rstrm
operator|->
name|fbtbc
expr_stmt|;
if|if
condition|(
name|current
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rstrm
operator|->
name|last_frag
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
if|if
condition|(
operator|!
name|set_input_fragment
argument_list|(
name|rstrm
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
continue|continue;
block|}
name|current
operator|=
operator|(
name|len
operator|<
name|current
operator|)
condition|?
name|len
else|:
name|current
expr_stmt|;
if|if
condition|(
operator|!
name|get_input_bytes
argument_list|(
name|rstrm
argument_list|,
name|addr
argument_list|,
name|current
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|addr
operator|+=
name|current
expr_stmt|;
name|rstrm
operator|->
name|fbtbc
operator|-=
name|current
expr_stmt|;
name|len
operator|-=
name|current
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool_t
name|xdrrec_putbytes
parameter_list|(
name|xdrs
parameter_list|,
name|addr
parameter_list|,
name|len
parameter_list|)
name|XDR
modifier|*
name|xdrs
decl_stmt|;
specifier|register
name|caddr_t
name|addr
decl_stmt|;
specifier|register
name|u_int
name|len
decl_stmt|;
block|{
specifier|register
name|RECSTREAM
modifier|*
name|rstrm
init|=
operator|(
name|RECSTREAM
operator|*
operator|)
operator|(
name|xdrs
operator|->
name|x_private
operator|)
decl_stmt|;
specifier|register
name|long
name|current
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|current
operator|=
operator|(
name|u_long
operator|)
name|rstrm
operator|->
name|out_boundry
operator|-
operator|(
name|u_long
operator|)
name|rstrm
operator|->
name|out_finger
expr_stmt|;
name|current
operator|=
operator|(
name|len
operator|<
name|current
operator|)
condition|?
name|len
else|:
name|current
expr_stmt|;
name|memcpy
argument_list|(
name|rstrm
operator|->
name|out_finger
argument_list|,
name|addr
argument_list|,
name|current
argument_list|)
expr_stmt|;
name|rstrm
operator|->
name|out_finger
operator|+=
name|current
expr_stmt|;
name|addr
operator|+=
name|current
expr_stmt|;
name|len
operator|-=
name|current
expr_stmt|;
if|if
condition|(
name|rstrm
operator|->
name|out_finger
operator|==
name|rstrm
operator|->
name|out_boundry
condition|)
block|{
name|rstrm
operator|->
name|frag_sent
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|flush_out
argument_list|(
name|rstrm
argument_list|,
name|FALSE
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|xdrrec_getpos
parameter_list|(
name|xdrs
parameter_list|)
specifier|register
name|XDR
modifier|*
name|xdrs
decl_stmt|;
block|{
specifier|register
name|RECSTREAM
modifier|*
name|rstrm
init|=
operator|(
name|RECSTREAM
operator|*
operator|)
name|xdrs
operator|->
name|x_private
decl_stmt|;
specifier|register
name|long
name|pos
decl_stmt|;
name|pos
operator|=
name|lseek
argument_list|(
operator|(
name|int
operator|)
operator|(
name|long
operator|)
name|rstrm
operator|->
name|tcp_handle
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|xdrs
operator|->
name|x_op
condition|)
block|{
case|case
name|XDR_ENCODE
case|:
name|pos
operator|+=
name|rstrm
operator|->
name|out_finger
operator|-
name|rstrm
operator|->
name|out_base
expr_stmt|;
break|break;
case|case
name|XDR_DECODE
case|:
name|pos
operator|-=
name|rstrm
operator|->
name|in_boundry
operator|-
name|rstrm
operator|->
name|in_finger
expr_stmt|;
break|break;
default|default:
name|pos
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
return|return
operator|(
operator|(
name|u_int
operator|)
name|pos
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool_t
name|xdrrec_setpos
parameter_list|(
name|xdrs
parameter_list|,
name|pos
parameter_list|)
specifier|register
name|XDR
modifier|*
name|xdrs
decl_stmt|;
name|u_int
name|pos
decl_stmt|;
block|{
specifier|register
name|RECSTREAM
modifier|*
name|rstrm
init|=
operator|(
name|RECSTREAM
operator|*
operator|)
name|xdrs
operator|->
name|x_private
decl_stmt|;
name|u_int
name|currpos
init|=
name|xdrrec_getpos
argument_list|(
name|xdrs
argument_list|)
decl_stmt|;
name|int
name|delta
init|=
name|currpos
operator|-
name|pos
decl_stmt|;
name|caddr_t
name|newpos
decl_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|currpos
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|xdrs
operator|->
name|x_op
condition|)
block|{
case|case
name|XDR_ENCODE
case|:
name|newpos
operator|=
name|rstrm
operator|->
name|out_finger
operator|-
name|delta
expr_stmt|;
if|if
condition|(
operator|(
name|newpos
operator|>
call|(
name|caddr_t
call|)
argument_list|(
name|rstrm
operator|->
name|frag_header
argument_list|)
operator|)
operator|&&
operator|(
name|newpos
operator|<
name|rstrm
operator|->
name|out_boundry
operator|)
condition|)
block|{
name|rstrm
operator|->
name|out_finger
operator|=
name|newpos
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
break|break;
case|case
name|XDR_DECODE
case|:
name|newpos
operator|=
name|rstrm
operator|->
name|in_finger
operator|-
name|delta
expr_stmt|;
if|if
condition|(
operator|(
name|delta
operator|<
call|(
name|int
call|)
argument_list|(
name|rstrm
operator|->
name|fbtbc
argument_list|)
operator|)
operator|&&
operator|(
name|newpos
operator|<=
name|rstrm
operator|->
name|in_boundry
operator|)
operator|&&
operator|(
name|newpos
operator|>=
name|rstrm
operator|->
name|in_base
operator|)
condition|)
block|{
name|rstrm
operator|->
name|in_finger
operator|=
name|newpos
expr_stmt|;
name|rstrm
operator|->
name|fbtbc
operator|-=
name|delta
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
break|break;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int32_t
modifier|*
name|xdrrec_inline
parameter_list|(
name|xdrs
parameter_list|,
name|len
parameter_list|)
specifier|register
name|XDR
modifier|*
name|xdrs
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|RECSTREAM
modifier|*
name|rstrm
init|=
operator|(
name|RECSTREAM
operator|*
operator|)
name|xdrs
operator|->
name|x_private
decl_stmt|;
name|int32_t
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
switch|switch
condition|(
name|xdrs
operator|->
name|x_op
condition|)
block|{
case|case
name|XDR_ENCODE
case|:
if|if
condition|(
operator|(
name|rstrm
operator|->
name|out_finger
operator|+
name|len
operator|)
operator|<=
name|rstrm
operator|->
name|out_boundry
condition|)
block|{
name|buf
operator|=
operator|(
name|int32_t
operator|*
operator|)
name|rstrm
operator|->
name|out_finger
expr_stmt|;
name|rstrm
operator|->
name|out_finger
operator|+=
name|len
expr_stmt|;
block|}
break|break;
case|case
name|XDR_DECODE
case|:
if|if
condition|(
operator|(
name|len
operator|<=
name|rstrm
operator|->
name|fbtbc
operator|)
operator|&&
operator|(
operator|(
name|rstrm
operator|->
name|in_finger
operator|+
name|len
operator|)
operator|<=
name|rstrm
operator|->
name|in_boundry
operator|)
condition|)
block|{
name|buf
operator|=
operator|(
name|int32_t
operator|*
operator|)
name|rstrm
operator|->
name|in_finger
expr_stmt|;
name|rstrm
operator|->
name|fbtbc
operator|-=
name|len
expr_stmt|;
name|rstrm
operator|->
name|in_finger
operator|+=
name|len
expr_stmt|;
block|}
break|break;
block|}
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|xdrrec_destroy
parameter_list|(
name|xdrs
parameter_list|)
specifier|register
name|XDR
modifier|*
name|xdrs
decl_stmt|;
block|{
specifier|register
name|RECSTREAM
modifier|*
name|rstrm
init|=
operator|(
name|RECSTREAM
operator|*
operator|)
name|xdrs
operator|->
name|x_private
decl_stmt|;
name|mem_free
argument_list|(
name|rstrm
operator|->
name|the_buffer
argument_list|,
name|rstrm
operator|->
name|sendsize
operator|+
name|rstrm
operator|->
name|recvsize
operator|+
name|BYTES_PER_XDR_UNIT
argument_list|)
expr_stmt|;
name|mem_free
argument_list|(
operator|(
name|caddr_t
operator|)
name|rstrm
argument_list|,
sizeof|sizeof
argument_list|(
name|RECSTREAM
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Exported routines to manage xdr records  */
end_comment

begin_comment
comment|/*  * Before reading (deserializing from the stream, one should always call  * this procedure to guarantee proper record alignment.  */
end_comment

begin_function
name|bool_t
name|xdrrec_skiprecord
parameter_list|(
name|xdrs
parameter_list|)
name|XDR
modifier|*
name|xdrs
decl_stmt|;
block|{
specifier|register
name|RECSTREAM
modifier|*
name|rstrm
init|=
operator|(
name|RECSTREAM
operator|*
operator|)
operator|(
name|xdrs
operator|->
name|x_private
operator|)
decl_stmt|;
while|while
condition|(
name|rstrm
operator|->
name|fbtbc
operator|>
literal|0
operator|||
operator|(
operator|!
name|rstrm
operator|->
name|last_frag
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|skip_input_bytes
argument_list|(
name|rstrm
argument_list|,
name|rstrm
operator|->
name|fbtbc
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|rstrm
operator|->
name|fbtbc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|rstrm
operator|->
name|last_frag
operator|)
operator|&&
operator|(
operator|!
name|set_input_fragment
argument_list|(
name|rstrm
argument_list|)
operator|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
name|rstrm
operator|->
name|last_frag
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look ahead fuction.  * Returns TRUE iff there is no more input in the buffer  * after consuming the rest of the current record.  */
end_comment

begin_function
name|bool_t
name|xdrrec_eof
parameter_list|(
name|xdrs
parameter_list|)
name|XDR
modifier|*
name|xdrs
decl_stmt|;
block|{
specifier|register
name|RECSTREAM
modifier|*
name|rstrm
init|=
operator|(
name|RECSTREAM
operator|*
operator|)
operator|(
name|xdrs
operator|->
name|x_private
operator|)
decl_stmt|;
while|while
condition|(
name|rstrm
operator|->
name|fbtbc
operator|>
literal|0
operator|||
operator|(
operator|!
name|rstrm
operator|->
name|last_frag
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|skip_input_bytes
argument_list|(
name|rstrm
argument_list|,
name|rstrm
operator|->
name|fbtbc
argument_list|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
name|rstrm
operator|->
name|fbtbc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|rstrm
operator|->
name|last_frag
operator|)
operator|&&
operator|(
operator|!
name|set_input_fragment
argument_list|(
name|rstrm
argument_list|)
operator|)
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
if|if
condition|(
name|rstrm
operator|->
name|in_finger
operator|==
name|rstrm
operator|->
name|in_boundry
condition|)
return|return
operator|(
name|TRUE
operator|)
return|;
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The client must tell the package when an end-of-record has occurred.  * The second paraemters tells whether the record should be flushed to the  * (output) tcp stream.  (This let's the package support batched or  * pipelined procedure calls.)  TRUE => immmediate flush to tcp connection.  */
end_comment

begin_function
name|bool_t
name|xdrrec_endofrecord
parameter_list|(
name|xdrs
parameter_list|,
name|sendnow
parameter_list|)
name|XDR
modifier|*
name|xdrs
decl_stmt|;
name|bool_t
name|sendnow
decl_stmt|;
block|{
specifier|register
name|RECSTREAM
modifier|*
name|rstrm
init|=
operator|(
name|RECSTREAM
operator|*
operator|)
operator|(
name|xdrs
operator|->
name|x_private
operator|)
decl_stmt|;
specifier|register
name|u_long
name|len
decl_stmt|;
comment|/* fragment length */
if|if
condition|(
name|sendnow
operator|||
name|rstrm
operator|->
name|frag_sent
operator|||
operator|(
operator|(
name|u_long
operator|)
name|rstrm
operator|->
name|out_finger
operator|+
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
operator|>=
operator|(
name|u_long
operator|)
name|rstrm
operator|->
name|out_boundry
operator|)
condition|)
block|{
name|rstrm
operator|->
name|frag_sent
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|flush_out
argument_list|(
name|rstrm
argument_list|,
name|TRUE
argument_list|)
operator|)
return|;
block|}
name|len
operator|=
call|(
name|u_long
call|)
argument_list|(
name|rstrm
operator|->
name|out_finger
argument_list|)
operator|-
call|(
name|u_long
call|)
argument_list|(
name|rstrm
operator|->
name|frag_header
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
operator|*
operator|(
name|rstrm
operator|->
name|frag_header
operator|)
operator|=
name|htonl
argument_list|(
operator|(
name|u_long
operator|)
name|len
operator||
name|LAST_FRAG
argument_list|)
expr_stmt|;
name|rstrm
operator|->
name|frag_header
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|rstrm
operator|->
name|out_finger
expr_stmt|;
name|rstrm
operator|->
name|out_finger
operator|+=
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Internal useful routines  */
end_comment

begin_function
specifier|static
name|bool_t
name|flush_out
parameter_list|(
name|rstrm
parameter_list|,
name|eor
parameter_list|)
specifier|register
name|RECSTREAM
modifier|*
name|rstrm
decl_stmt|;
name|bool_t
name|eor
decl_stmt|;
block|{
specifier|register
name|u_long
name|eormask
init|=
operator|(
name|eor
operator|==
name|TRUE
operator|)
condition|?
name|LAST_FRAG
else|:
literal|0
decl_stmt|;
specifier|register
name|u_int32_t
name|len
init|=
call|(
name|u_long
call|)
argument_list|(
name|rstrm
operator|->
name|out_finger
argument_list|)
operator|-
call|(
name|u_long
call|)
argument_list|(
name|rstrm
operator|->
name|frag_header
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
decl_stmt|;
operator|*
operator|(
name|rstrm
operator|->
name|frag_header
operator|)
operator|=
name|htonl
argument_list|(
name|len
operator||
name|eormask
argument_list|)
expr_stmt|;
name|len
operator|=
call|(
name|u_long
call|)
argument_list|(
name|rstrm
operator|->
name|out_finger
argument_list|)
operator|-
call|(
name|u_long
call|)
argument_list|(
name|rstrm
operator|->
name|out_base
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
operator|(
name|rstrm
operator|->
name|writeit
operator|)
operator|)
operator|(
name|rstrm
operator|->
name|tcp_handle
operator|,
name|rstrm
operator|->
name|out_base
operator|,
operator|(
name|int
operator|)
name|len
operator|)
operator|!=
operator|(
name|int
operator|)
name|len
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|rstrm
operator|->
name|frag_header
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|rstrm
operator|->
name|out_base
expr_stmt|;
name|rstrm
operator|->
name|out_finger
operator|=
operator|(
name|caddr_t
operator|)
name|rstrm
operator|->
name|out_base
operator|+
sizeof|sizeof
argument_list|(
name|u_int32_t
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool_t
comment|/* knows nothing about records!  Only about input buffers */
name|fill_input_buf
parameter_list|(
name|rstrm
parameter_list|)
specifier|register
name|RECSTREAM
modifier|*
name|rstrm
decl_stmt|;
block|{
specifier|register
name|caddr_t
name|where
decl_stmt|;
name|u_long
name|i
decl_stmt|;
specifier|register
name|long
name|len
decl_stmt|;
name|where
operator|=
name|rstrm
operator|->
name|in_base
expr_stmt|;
name|i
operator|=
operator|(
name|u_long
operator|)
name|rstrm
operator|->
name|in_boundry
operator|%
name|BYTES_PER_XDR_UNIT
expr_stmt|;
name|where
operator|+=
name|i
expr_stmt|;
name|len
operator|=
name|rstrm
operator|->
name|in_size
operator|-
name|i
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|=
operator|(
operator|*
operator|(
name|rstrm
operator|->
name|readit
operator|)
operator|)
operator|(
name|rstrm
operator|->
name|tcp_handle
operator|,
name|where
operator|,
name|len
operator|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|rstrm
operator|->
name|in_finger
operator|=
name|where
expr_stmt|;
name|where
operator|+=
name|len
expr_stmt|;
name|rstrm
operator|->
name|in_boundry
operator|=
name|where
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool_t
comment|/* knows nothing about records!  Only about input buffers */
name|get_input_bytes
parameter_list|(
name|rstrm
parameter_list|,
name|addr
parameter_list|,
name|len
parameter_list|)
specifier|register
name|RECSTREAM
modifier|*
name|rstrm
decl_stmt|;
specifier|register
name|caddr_t
name|addr
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
block|{
specifier|register
name|long
name|current
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|current
operator|=
operator|(
name|long
operator|)
name|rstrm
operator|->
name|in_boundry
operator|-
operator|(
name|long
operator|)
name|rstrm
operator|->
name|in_finger
expr_stmt|;
if|if
condition|(
name|current
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|fill_input_buf
argument_list|(
name|rstrm
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
continue|continue;
block|}
name|current
operator|=
operator|(
name|len
operator|<
name|current
operator|)
condition|?
name|len
else|:
name|current
expr_stmt|;
name|memcpy
argument_list|(
name|addr
argument_list|,
name|rstrm
operator|->
name|in_finger
argument_list|,
name|current
argument_list|)
expr_stmt|;
name|rstrm
operator|->
name|in_finger
operator|+=
name|current
expr_stmt|;
name|addr
operator|+=
name|current
expr_stmt|;
name|len
operator|-=
name|current
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool_t
comment|/* next two bytes of the input stream are treated as a header */
name|set_input_fragment
parameter_list|(
name|rstrm
parameter_list|)
specifier|register
name|RECSTREAM
modifier|*
name|rstrm
decl_stmt|;
block|{
name|u_int32_t
name|header
decl_stmt|;
if|if
condition|(
operator|!
name|get_input_bytes
argument_list|(
name|rstrm
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|header
argument_list|,
sizeof|sizeof
argument_list|(
name|header
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|header
operator|=
operator|(
name|long
operator|)
name|ntohl
argument_list|(
name|header
argument_list|)
expr_stmt|;
name|rstrm
operator|->
name|last_frag
operator|=
operator|(
operator|(
name|header
operator|&
name|LAST_FRAG
operator|)
operator|==
literal|0
operator|)
condition|?
name|FALSE
else|:
name|TRUE
expr_stmt|;
comment|/* 	 * Sanity check. Try not to accept wildly incorrect 	 * record sizes. Unfortunately, the only record size 	 * we can positively identify as being 'wildly incorrect' 	 * is zero. Ridiculously large record sizes may look wrong, 	 * but we don't have any way to be certain that they aren't 	 * what the client actually intended to send us. 	 */
if|if
condition|(
name|header
operator|==
literal|0
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
name|rstrm
operator|->
name|fbtbc
operator|=
name|header
operator|&
operator|(
operator|~
name|LAST_FRAG
operator|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool_t
comment|/* consumes input bytes; knows nothing about records! */
name|skip_input_bytes
parameter_list|(
name|rstrm
parameter_list|,
name|cnt
parameter_list|)
specifier|register
name|RECSTREAM
modifier|*
name|rstrm
decl_stmt|;
name|long
name|cnt
decl_stmt|;
block|{
specifier|register
name|long
name|current
decl_stmt|;
while|while
condition|(
name|cnt
operator|>
literal|0
condition|)
block|{
name|current
operator|=
operator|(
name|long
operator|)
name|rstrm
operator|->
name|in_boundry
operator|-
operator|(
name|long
operator|)
name|rstrm
operator|->
name|in_finger
expr_stmt|;
if|if
condition|(
name|current
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|fill_input_buf
argument_list|(
name|rstrm
argument_list|)
condition|)
return|return
operator|(
name|FALSE
operator|)
return|;
continue|continue;
block|}
name|current
operator|=
operator|(
name|cnt
operator|<
name|current
operator|)
condition|?
name|cnt
else|:
name|current
expr_stmt|;
name|rstrm
operator|->
name|in_finger
operator|+=
name|current
expr_stmt|;
name|cnt
operator|-=
name|current
expr_stmt|;
block|}
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int
name|fix_buf_size
parameter_list|(
name|s
parameter_list|)
specifier|register
name|u_int
name|s
decl_stmt|;
block|{
if|if
condition|(
name|s
operator|<
literal|100
condition|)
name|s
operator|=
literal|4000
expr_stmt|;
return|return
operator|(
name|RNDUP
argument_list|(
name|s
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

