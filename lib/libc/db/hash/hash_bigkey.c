begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Margo Seltzer.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)hash_bigkey.c	8.3 (Berkeley) 5/31/94"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBC_SCCS and not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * PACKAGE: hash  * DESCRIPTION:  *	Big key/data handling for the hashing package.  *  * ROUTINES:  * External  *	__big_keydata  *	__big_split  *	__big_insert  *	__big_return  *	__big_delete  *	__find_last_page  * Internal  *	collect_key  *	collect_data  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<db.h>
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"page.h"
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_function_decl
specifier|static
name|int
name|collect_key
parameter_list|(
name|HTAB
modifier|*
parameter_list|,
name|BUFHEAD
modifier|*
parameter_list|,
name|int
parameter_list|,
name|DBT
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|collect_data
parameter_list|(
name|HTAB
modifier|*
parameter_list|,
name|BUFHEAD
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Big_insert  *  * You need to do an insert and the key/data pair is too big  *  * Returns:  * 0 ==> OK  *-1 ==> ERROR  */
end_comment

begin_function
specifier|extern
name|int
name|__big_insert
parameter_list|(
name|hashp
parameter_list|,
name|bufp
parameter_list|,
name|key
parameter_list|,
name|val
parameter_list|)
name|HTAB
modifier|*
name|hashp
decl_stmt|;
name|BUFHEAD
modifier|*
name|bufp
decl_stmt|;
specifier|const
name|DBT
modifier|*
name|key
decl_stmt|,
decl|*
name|val
decl_stmt|;
end_function

begin_block
block|{
name|u_int16_t
modifier|*
name|p
decl_stmt|;
name|int
name|key_size
decl_stmt|,
name|n
decl_stmt|,
name|val_size
decl_stmt|;
name|u_int16_t
name|space
decl_stmt|,
name|move_bytes
decl_stmt|,
name|off
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|key_data
decl_stmt|,
modifier|*
name|val_data
decl_stmt|;
name|cp
operator|=
name|bufp
operator|->
name|page
expr_stmt|;
comment|/* Character pointer of p. */
name|p
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|cp
expr_stmt|;
name|key_data
operator|=
operator|(
name|char
operator|*
operator|)
name|key
operator|->
name|data
expr_stmt|;
name|key_size
operator|=
name|key
operator|->
name|size
expr_stmt|;
name|val_data
operator|=
operator|(
name|char
operator|*
operator|)
name|val
operator|->
name|data
expr_stmt|;
name|val_size
operator|=
name|val
operator|->
name|size
expr_stmt|;
comment|/* First move the Key */
for|for
control|(
name|space
operator|=
name|FREESPACE
argument_list|(
name|p
argument_list|)
operator|-
name|BIGOVERHEAD
init|;
name|key_size
condition|;
name|space
operator|=
name|FREESPACE
argument_list|(
name|p
argument_list|)
operator|-
name|BIGOVERHEAD
control|)
block|{
name|move_bytes
operator|=
name|MIN
argument_list|(
name|space
argument_list|,
name|key_size
argument_list|)
expr_stmt|;
name|off
operator|=
name|OFFSET
argument_list|(
name|p
argument_list|)
operator|-
name|move_bytes
expr_stmt|;
name|memmove
argument_list|(
name|cp
operator|+
name|off
argument_list|,
name|key_data
argument_list|,
name|move_bytes
argument_list|)
expr_stmt|;
name|key_size
operator|-=
name|move_bytes
expr_stmt|;
name|key_data
operator|+=
name|move_bytes
expr_stmt|;
name|n
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
name|p
index|[
operator|++
name|n
index|]
operator|=
name|off
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
operator|++
name|n
expr_stmt|;
name|FREESPACE
argument_list|(
name|p
argument_list|)
operator|=
name|off
operator|-
name|PAGE_META
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|OFFSET
argument_list|(
name|p
argument_list|)
operator|=
name|off
expr_stmt|;
name|p
index|[
name|n
index|]
operator|=
name|PARTIAL_KEY
expr_stmt|;
name|bufp
operator|=
name|__add_ovflpage
argument_list|(
name|hashp
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bufp
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|n
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|key_size
condition|)
block|{
if|if
condition|(
name|FREESPACE
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|move_bytes
operator|=
name|MIN
argument_list|(
name|FREESPACE
argument_list|(
name|p
argument_list|)
argument_list|,
name|val_size
argument_list|)
expr_stmt|;
name|off
operator|=
name|OFFSET
argument_list|(
name|p
argument_list|)
operator|-
name|move_bytes
expr_stmt|;
name|p
index|[
name|n
index|]
operator|=
name|off
expr_stmt|;
name|memmove
argument_list|(
name|cp
operator|+
name|off
argument_list|,
name|val_data
argument_list|,
name|move_bytes
argument_list|)
expr_stmt|;
name|val_data
operator|+=
name|move_bytes
expr_stmt|;
name|val_size
operator|-=
name|move_bytes
expr_stmt|;
name|p
index|[
name|n
operator|-
literal|2
index|]
operator|=
name|FULL_KEY_DATA
expr_stmt|;
name|FREESPACE
argument_list|(
name|p
argument_list|)
operator|=
name|FREESPACE
argument_list|(
name|p
argument_list|)
operator|-
name|move_bytes
expr_stmt|;
name|OFFSET
argument_list|(
name|p
argument_list|)
operator|=
name|off
expr_stmt|;
block|}
else|else
name|p
index|[
name|n
operator|-
literal|2
index|]
operator|=
name|FULL_KEY
expr_stmt|;
block|}
name|p
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|bufp
operator|->
name|page
expr_stmt|;
name|cp
operator|=
name|bufp
operator|->
name|page
expr_stmt|;
name|bufp
operator|->
name|flags
operator||=
name|BUF_MOD
expr_stmt|;
block|}
comment|/* Now move the data */
for|for
control|(
name|space
operator|=
name|FREESPACE
argument_list|(
name|p
argument_list|)
operator|-
name|BIGOVERHEAD
init|;
name|val_size
condition|;
name|space
operator|=
name|FREESPACE
argument_list|(
name|p
argument_list|)
operator|-
name|BIGOVERHEAD
control|)
block|{
name|move_bytes
operator|=
name|MIN
argument_list|(
name|space
argument_list|,
name|val_size
argument_list|)
expr_stmt|;
comment|/* 		 * Here's the hack to make sure that if the data ends on the 		 * same page as the key ends, FREESPACE is at least one. 		 */
if|if
condition|(
name|space
operator|==
name|val_size
operator|&&
name|val_size
operator|==
name|val
operator|->
name|size
condition|)
name|move_bytes
operator|--
expr_stmt|;
name|off
operator|=
name|OFFSET
argument_list|(
name|p
argument_list|)
operator|-
name|move_bytes
expr_stmt|;
name|memmove
argument_list|(
name|cp
operator|+
name|off
argument_list|,
name|val_data
argument_list|,
name|move_bytes
argument_list|)
expr_stmt|;
name|val_size
operator|-=
name|move_bytes
expr_stmt|;
name|val_data
operator|+=
name|move_bytes
expr_stmt|;
name|n
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
name|p
index|[
operator|++
name|n
index|]
operator|=
name|off
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
operator|++
name|n
expr_stmt|;
name|FREESPACE
argument_list|(
name|p
argument_list|)
operator|=
name|off
operator|-
name|PAGE_META
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|OFFSET
argument_list|(
name|p
argument_list|)
operator|=
name|off
expr_stmt|;
if|if
condition|(
name|val_size
condition|)
block|{
name|p
index|[
name|n
index|]
operator|=
name|FULL_KEY
expr_stmt|;
name|bufp
operator|=
name|__add_ovflpage
argument_list|(
name|hashp
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bufp
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|=
name|bufp
operator|->
name|page
expr_stmt|;
name|p
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|cp
expr_stmt|;
block|}
else|else
name|p
index|[
name|n
index|]
operator|=
name|FULL_KEY_DATA
expr_stmt|;
name|bufp
operator|->
name|flags
operator||=
name|BUF_MOD
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Called when bufp's page  contains a partial key (index should be 1)  *  * All pages in the big key/data pair except bufp are freed.  We cannot  * free bufp because the page pointing to it is lost and we can't get rid  * of its pointer.  *  * Returns:  * 0 => OK  *-1 => ERROR  */
end_comment

begin_function
specifier|extern
name|int
name|__big_delete
parameter_list|(
name|hashp
parameter_list|,
name|bufp
parameter_list|)
name|HTAB
modifier|*
name|hashp
decl_stmt|;
name|BUFHEAD
modifier|*
name|bufp
decl_stmt|;
block|{
name|BUFHEAD
modifier|*
name|last_bfp
decl_stmt|,
modifier|*
name|rbufp
decl_stmt|;
name|u_int16_t
modifier|*
name|bp
decl_stmt|,
name|pageno
decl_stmt|;
name|int
name|key_done
decl_stmt|,
name|n
decl_stmt|;
name|rbufp
operator|=
name|bufp
expr_stmt|;
name|last_bfp
operator|=
name|NULL
expr_stmt|;
name|bp
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|bufp
operator|->
name|page
expr_stmt|;
name|pageno
operator|=
literal|0
expr_stmt|;
name|key_done
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|key_done
operator|||
operator|(
name|bp
index|[
literal|2
index|]
operator|!=
name|FULL_KEY_DATA
operator|)
condition|)
block|{
if|if
condition|(
name|bp
index|[
literal|2
index|]
operator|==
name|FULL_KEY
operator|||
name|bp
index|[
literal|2
index|]
operator|==
name|FULL_KEY_DATA
condition|)
name|key_done
operator|=
literal|1
expr_stmt|;
comment|/* 		 * If there is freespace left on a FULL_KEY_DATA page, then 		 * the data is short and fits entirely on this page, and this 		 * is the last page. 		 */
if|if
condition|(
name|bp
index|[
literal|2
index|]
operator|==
name|FULL_KEY_DATA
operator|&&
name|FREESPACE
argument_list|(
name|bp
argument_list|)
condition|)
break|break;
name|pageno
operator|=
name|bp
index|[
name|bp
index|[
literal|0
index|]
operator|-
literal|1
index|]
expr_stmt|;
name|rbufp
operator|->
name|flags
operator||=
name|BUF_MOD
expr_stmt|;
name|rbufp
operator|=
name|__get_buf
argument_list|(
name|hashp
argument_list|,
name|pageno
argument_list|,
name|rbufp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_bfp
condition|)
name|__free_ovflpage
argument_list|(
name|hashp
argument_list|,
name|last_bfp
argument_list|)
expr_stmt|;
name|last_bfp
operator|=
name|rbufp
expr_stmt|;
if|if
condition|(
operator|!
name|rbufp
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Error. */
name|bp
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|rbufp
operator|->
name|page
expr_stmt|;
block|}
comment|/* 	 * If we get here then rbufp points to the last page of the big 	 * key/data pair.  Bufp points to the first one -- it should now be 	 * empty pointing to the next page after this pair.  Can't free it 	 * because we don't have the page pointing to it. 	 */
comment|/* This is information from the last page of the pair. */
name|n
operator|=
name|bp
index|[
literal|0
index|]
expr_stmt|;
name|pageno
operator|=
name|bp
index|[
name|n
operator|-
literal|1
index|]
expr_stmt|;
comment|/* Now, bp is the first page of the pair. */
name|bp
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|bufp
operator|->
name|page
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|2
condition|)
block|{
comment|/* There is an overflow page. */
name|bp
index|[
literal|1
index|]
operator|=
name|pageno
expr_stmt|;
name|bp
index|[
literal|2
index|]
operator|=
name|OVFLPAGE
expr_stmt|;
name|bufp
operator|->
name|ovfl
operator|=
name|rbufp
operator|->
name|ovfl
expr_stmt|;
block|}
else|else
comment|/* This is the last page. */
name|bufp
operator|->
name|ovfl
operator|=
name|NULL
expr_stmt|;
name|n
operator|-=
literal|2
expr_stmt|;
name|bp
index|[
literal|0
index|]
operator|=
name|n
expr_stmt|;
name|FREESPACE
argument_list|(
name|bp
argument_list|)
operator|=
name|hashp
operator|->
name|BSIZE
operator|-
name|PAGE_META
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|OFFSET
argument_list|(
name|bp
argument_list|)
operator|=
name|hashp
operator|->
name|BSIZE
operator|-
literal|1
expr_stmt|;
name|bufp
operator|->
name|flags
operator||=
name|BUF_MOD
expr_stmt|;
if|if
condition|(
name|rbufp
condition|)
name|__free_ovflpage
argument_list|(
name|hashp
argument_list|,
name|rbufp
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_bfp
operator|!=
name|rbufp
condition|)
name|__free_ovflpage
argument_list|(
name|hashp
argument_list|,
name|last_bfp
argument_list|)
expr_stmt|;
name|hashp
operator|->
name|NKEYS
operator|--
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns:  *  0 = key not found  * -1 = get next overflow page  * -2 means key not found and this is big key/data  * -3 error  */
end_comment

begin_function
specifier|extern
name|int
name|__find_bigpair
parameter_list|(
name|hashp
parameter_list|,
name|bufp
parameter_list|,
name|ndx
parameter_list|,
name|key
parameter_list|,
name|size
parameter_list|)
name|HTAB
modifier|*
name|hashp
decl_stmt|;
name|BUFHEAD
modifier|*
name|bufp
decl_stmt|;
name|int
name|ndx
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
name|u_int16_t
modifier|*
name|bp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|ksize
decl_stmt|;
name|u_int16_t
name|bytes
decl_stmt|;
name|char
modifier|*
name|kkey
decl_stmt|;
name|bp
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|bufp
operator|->
name|page
expr_stmt|;
name|p
operator|=
name|bufp
operator|->
name|page
expr_stmt|;
name|ksize
operator|=
name|size
expr_stmt|;
name|kkey
operator|=
name|key
expr_stmt|;
for|for
control|(
name|bytes
operator|=
name|hashp
operator|->
name|BSIZE
operator|-
name|bp
index|[
name|ndx
index|]
init|;
name|bytes
operator|<=
name|size
operator|&&
name|bp
index|[
name|ndx
operator|+
literal|1
index|]
operator|==
name|PARTIAL_KEY
condition|;
name|bytes
operator|=
name|hashp
operator|->
name|BSIZE
operator|-
name|bp
index|[
name|ndx
index|]
control|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|p
operator|+
name|bp
index|[
name|ndx
index|]
argument_list|,
name|kkey
argument_list|,
name|bytes
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
name|kkey
operator|+=
name|bytes
expr_stmt|;
name|ksize
operator|-=
name|bytes
expr_stmt|;
name|bufp
operator|=
name|__get_buf
argument_list|(
name|hashp
argument_list|,
name|bp
index|[
name|ndx
operator|+
literal|2
index|]
argument_list|,
name|bufp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bufp
condition|)
return|return
operator|(
operator|-
literal|3
operator|)
return|;
name|p
operator|=
name|bufp
operator|->
name|page
expr_stmt|;
name|bp
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|p
expr_stmt|;
name|ndx
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bytes
operator|!=
name|ksize
operator|||
name|memcmp
argument_list|(
name|p
operator|+
name|bp
index|[
name|ndx
index|]
argument_list|,
name|kkey
argument_list|,
name|bytes
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HASH_STATISTICS
operator|++
name|hash_collisions
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
else|else
return|return
operator|(
name|ndx
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given the buffer pointer of the first overflow page of a big pair,  * find the end of the big pair  *  * This will set bpp to the buffer header of the last page of the big pair.  * It will return the pageno of the overflow page following the last page  * of the pair; 0 if there isn't any (i.e. big pair is the last key in the  * bucket)  */
end_comment

begin_function
specifier|extern
name|u_int16_t
name|__find_last_page
parameter_list|(
name|hashp
parameter_list|,
name|bpp
parameter_list|)
name|HTAB
modifier|*
name|hashp
decl_stmt|;
name|BUFHEAD
modifier|*
modifier|*
name|bpp
decl_stmt|;
block|{
name|BUFHEAD
modifier|*
name|bufp
decl_stmt|;
name|u_int16_t
modifier|*
name|bp
decl_stmt|,
name|pageno
decl_stmt|;
name|int
name|n
decl_stmt|;
name|bufp
operator|=
operator|*
name|bpp
expr_stmt|;
name|bp
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|bufp
operator|->
name|page
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|n
operator|=
name|bp
index|[
literal|0
index|]
expr_stmt|;
comment|/* 		 * This is the last page if: the tag is FULL_KEY_DATA and 		 * either only 2 entries OVFLPAGE marker is explicit there 		 * is freespace on the page. 		 */
if|if
condition|(
name|bp
index|[
literal|2
index|]
operator|==
name|FULL_KEY_DATA
operator|&&
operator|(
operator|(
name|n
operator|==
literal|2
operator|)
operator|||
operator|(
name|bp
index|[
name|n
index|]
operator|==
name|OVFLPAGE
operator|)
operator|||
operator|(
name|FREESPACE
argument_list|(
name|bp
argument_list|)
operator|)
operator|)
condition|)
break|break;
name|pageno
operator|=
name|bp
index|[
name|n
operator|-
literal|1
index|]
expr_stmt|;
name|bufp
operator|=
name|__get_buf
argument_list|(
name|hashp
argument_list|,
name|pageno
argument_list|,
name|bufp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bufp
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Need to indicate an error! */
name|bp
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|bufp
operator|->
name|page
expr_stmt|;
block|}
operator|*
name|bpp
operator|=
name|bufp
expr_stmt|;
if|if
condition|(
name|bp
index|[
literal|0
index|]
operator|>
literal|2
condition|)
return|return
operator|(
name|bp
index|[
literal|3
index|]
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the data for the key/data pair that begins on this page at this  * index (index should always be 1).  */
end_comment

begin_function
specifier|extern
name|int
name|__big_return
parameter_list|(
name|hashp
parameter_list|,
name|bufp
parameter_list|,
name|ndx
parameter_list|,
name|val
parameter_list|,
name|set_current
parameter_list|)
name|HTAB
modifier|*
name|hashp
decl_stmt|;
name|BUFHEAD
modifier|*
name|bufp
decl_stmt|;
name|int
name|ndx
decl_stmt|;
name|DBT
modifier|*
name|val
decl_stmt|;
name|int
name|set_current
decl_stmt|;
block|{
name|BUFHEAD
modifier|*
name|save_p
decl_stmt|;
name|u_int16_t
modifier|*
name|bp
decl_stmt|,
name|len
decl_stmt|,
name|off
decl_stmt|,
name|save_addr
decl_stmt|;
name|char
modifier|*
name|tp
decl_stmt|;
name|bp
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|bufp
operator|->
name|page
expr_stmt|;
while|while
condition|(
name|bp
index|[
name|ndx
operator|+
literal|1
index|]
operator|==
name|PARTIAL_KEY
condition|)
block|{
name|bufp
operator|=
name|__get_buf
argument_list|(
name|hashp
argument_list|,
name|bp
index|[
name|bp
index|[
literal|0
index|]
operator|-
literal|1
index|]
argument_list|,
name|bufp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bufp
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bp
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|bufp
operator|->
name|page
expr_stmt|;
name|ndx
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|bp
index|[
name|ndx
operator|+
literal|1
index|]
operator|==
name|FULL_KEY
condition|)
block|{
name|bufp
operator|=
name|__get_buf
argument_list|(
name|hashp
argument_list|,
name|bp
index|[
name|bp
index|[
literal|0
index|]
operator|-
literal|1
index|]
argument_list|,
name|bufp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bufp
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bp
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|bufp
operator|->
name|page
expr_stmt|;
name|save_p
operator|=
name|bufp
expr_stmt|;
name|save_addr
operator|=
name|save_p
operator|->
name|addr
expr_stmt|;
name|off
operator|=
name|bp
index|[
literal|1
index|]
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|FREESPACE
argument_list|(
name|bp
argument_list|)
condition|)
block|{
comment|/* 			 * This is a hack.  We can't distinguish between 			 * FULL_KEY_DATA that contains complete data or 			 * incomplete data, so we require that if the data 			 * is complete, there is at least 1 byte of free 			 * space left. 			 */
name|off
operator|=
name|bp
index|[
name|bp
index|[
literal|0
index|]
index|]
expr_stmt|;
name|len
operator|=
name|bp
index|[
literal|1
index|]
operator|-
name|off
expr_stmt|;
name|save_p
operator|=
name|bufp
expr_stmt|;
name|save_addr
operator|=
name|bufp
operator|->
name|addr
expr_stmt|;
name|bufp
operator|=
name|__get_buf
argument_list|(
name|hashp
argument_list|,
name|bp
index|[
name|bp
index|[
literal|0
index|]
operator|-
literal|1
index|]
argument_list|,
name|bufp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bufp
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bp
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|bufp
operator|->
name|page
expr_stmt|;
block|}
else|else
block|{
comment|/* The data is all on one page. */
name|tp
operator|=
operator|(
name|char
operator|*
operator|)
name|bp
expr_stmt|;
name|off
operator|=
name|bp
index|[
name|bp
index|[
literal|0
index|]
index|]
expr_stmt|;
name|val
operator|->
name|data
operator|=
operator|(
name|u_char
operator|*
operator|)
name|tp
operator|+
name|off
expr_stmt|;
name|val
operator|->
name|size
operator|=
name|bp
index|[
literal|1
index|]
operator|-
name|off
expr_stmt|;
if|if
condition|(
name|set_current
condition|)
block|{
if|if
condition|(
name|bp
index|[
literal|0
index|]
operator|==
literal|2
condition|)
block|{
comment|/* No more buckets in 							 * chain */
name|hashp
operator|->
name|cpage
operator|=
name|NULL
expr_stmt|;
name|hashp
operator|->
name|cbucket
operator|++
expr_stmt|;
name|hashp
operator|->
name|cndx
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|hashp
operator|->
name|cpage
operator|=
name|__get_buf
argument_list|(
name|hashp
argument_list|,
name|bp
index|[
name|bp
index|[
literal|0
index|]
operator|-
literal|1
index|]
argument_list|,
name|bufp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hashp
operator|->
name|cpage
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|hashp
operator|->
name|cndx
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|hashp
operator|->
name|cpage
operator|->
name|page
operator|)
index|[
literal|0
index|]
condition|)
block|{
name|hashp
operator|->
name|cbucket
operator|++
expr_stmt|;
name|hashp
operator|->
name|cpage
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|val
operator|->
name|size
operator|=
name|collect_data
argument_list|(
name|hashp
argument_list|,
name|bufp
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|,
name|set_current
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|->
name|size
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|save_p
operator|->
name|addr
operator|!=
name|save_addr
condition|)
block|{
comment|/* We are pretty short on buffers. */
name|errno
operator|=
name|EINVAL
expr_stmt|;
comment|/* OUT OF BUFFERS */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|memmove
argument_list|(
name|hashp
operator|->
name|tmp_buf
argument_list|,
operator|(
name|save_p
operator|->
name|page
operator|)
operator|+
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|val
operator|->
name|data
operator|=
operator|(
name|u_char
operator|*
operator|)
name|hashp
operator|->
name|tmp_buf
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Count how big the total datasize is by recursing through the pages.  Then  * allocate a buffer and copy the data as you recurse up.  */
end_comment

begin_function
specifier|static
name|int
name|collect_data
parameter_list|(
name|hashp
parameter_list|,
name|bufp
parameter_list|,
name|len
parameter_list|,
name|set
parameter_list|)
name|HTAB
modifier|*
name|hashp
decl_stmt|;
name|BUFHEAD
modifier|*
name|bufp
decl_stmt|;
name|int
name|len
decl_stmt|,
name|set
decl_stmt|;
block|{
name|u_int16_t
modifier|*
name|bp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|BUFHEAD
modifier|*
name|xbp
decl_stmt|;
name|u_int16_t
name|save_addr
decl_stmt|;
name|int
name|mylen
decl_stmt|,
name|totlen
decl_stmt|;
name|p
operator|=
name|bufp
operator|->
name|page
expr_stmt|;
name|bp
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|p
expr_stmt|;
name|mylen
operator|=
name|hashp
operator|->
name|BSIZE
operator|-
name|bp
index|[
literal|1
index|]
expr_stmt|;
name|save_addr
operator|=
name|bufp
operator|->
name|addr
expr_stmt|;
if|if
condition|(
name|bp
index|[
literal|2
index|]
operator|==
name|FULL_KEY_DATA
condition|)
block|{
comment|/* End of Data */
name|totlen
operator|=
name|len
operator|+
name|mylen
expr_stmt|;
if|if
condition|(
name|hashp
operator|->
name|tmp_buf
condition|)
name|free
argument_list|(
name|hashp
operator|->
name|tmp_buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hashp
operator|->
name|tmp_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|totlen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|set
condition|)
block|{
name|hashp
operator|->
name|cndx
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|bp
index|[
literal|0
index|]
operator|==
literal|2
condition|)
block|{
comment|/* No more buckets in chain */
name|hashp
operator|->
name|cpage
operator|=
name|NULL
expr_stmt|;
name|hashp
operator|->
name|cbucket
operator|++
expr_stmt|;
block|}
else|else
block|{
name|hashp
operator|->
name|cpage
operator|=
name|__get_buf
argument_list|(
name|hashp
argument_list|,
name|bp
index|[
name|bp
index|[
literal|0
index|]
operator|-
literal|1
index|]
argument_list|,
name|bufp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hashp
operator|->
name|cpage
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
operator|!
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|hashp
operator|->
name|cpage
operator|->
name|page
operator|)
index|[
literal|0
index|]
condition|)
block|{
name|hashp
operator|->
name|cbucket
operator|++
expr_stmt|;
name|hashp
operator|->
name|cpage
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
name|xbp
operator|=
name|__get_buf
argument_list|(
name|hashp
argument_list|,
name|bp
index|[
name|bp
index|[
literal|0
index|]
operator|-
literal|1
index|]
argument_list|,
name|bufp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xbp
operator|||
operator|(
operator|(
name|totlen
operator|=
name|collect_data
argument_list|(
name|hashp
argument_list|,
name|xbp
argument_list|,
name|len
operator|+
name|mylen
argument_list|,
name|set
argument_list|)
operator|)
operator|<
literal|1
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|bufp
operator|->
name|addr
operator|!=
name|save_addr
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
comment|/* Out of buffers. */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|memmove
argument_list|(
operator|&
name|hashp
operator|->
name|tmp_buf
index|[
name|len
index|]
argument_list|,
operator|(
name|bufp
operator|->
name|page
operator|)
operator|+
name|bp
index|[
literal|1
index|]
argument_list|,
name|mylen
argument_list|)
expr_stmt|;
return|return
operator|(
name|totlen
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fill in the key and data for this big pair.  */
end_comment

begin_function
specifier|extern
name|int
name|__big_keydata
parameter_list|(
name|hashp
parameter_list|,
name|bufp
parameter_list|,
name|key
parameter_list|,
name|val
parameter_list|,
name|set
parameter_list|)
name|HTAB
modifier|*
name|hashp
decl_stmt|;
name|BUFHEAD
modifier|*
name|bufp
decl_stmt|;
name|DBT
modifier|*
name|key
decl_stmt|,
decl|*
name|val
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|set
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|key
operator|->
name|size
operator|=
name|collect_key
argument_list|(
name|hashp
argument_list|,
name|bufp
argument_list|,
literal|0
argument_list|,
name|val
argument_list|,
name|set
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|->
name|size
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|key
operator|->
name|data
operator|=
operator|(
name|u_char
operator|*
operator|)
name|hashp
operator|->
name|tmp_key
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Count how big the total key size is by recursing through the pages.  Then  * collect the data, allocate a buffer and copy the key as you recurse up.  */
end_comment

begin_function
specifier|static
name|int
name|collect_key
parameter_list|(
name|hashp
parameter_list|,
name|bufp
parameter_list|,
name|len
parameter_list|,
name|val
parameter_list|,
name|set
parameter_list|)
name|HTAB
modifier|*
name|hashp
decl_stmt|;
name|BUFHEAD
modifier|*
name|bufp
decl_stmt|;
name|int
name|len
decl_stmt|;
name|DBT
modifier|*
name|val
decl_stmt|;
name|int
name|set
decl_stmt|;
block|{
name|BUFHEAD
modifier|*
name|xbp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|mylen
decl_stmt|,
name|totlen
decl_stmt|;
name|u_int16_t
modifier|*
name|bp
decl_stmt|,
name|save_addr
decl_stmt|;
name|p
operator|=
name|bufp
operator|->
name|page
expr_stmt|;
name|bp
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|p
expr_stmt|;
name|mylen
operator|=
name|hashp
operator|->
name|BSIZE
operator|-
name|bp
index|[
literal|1
index|]
expr_stmt|;
name|save_addr
operator|=
name|bufp
operator|->
name|addr
expr_stmt|;
name|totlen
operator|=
name|len
operator|+
name|mylen
expr_stmt|;
if|if
condition|(
name|bp
index|[
literal|2
index|]
operator|==
name|FULL_KEY
operator|||
name|bp
index|[
literal|2
index|]
operator|==
name|FULL_KEY_DATA
condition|)
block|{
comment|/* End of Key. */
if|if
condition|(
name|hashp
operator|->
name|tmp_key
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|hashp
operator|->
name|tmp_key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hashp
operator|->
name|tmp_key
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|totlen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|__big_return
argument_list|(
name|hashp
argument_list|,
name|bufp
argument_list|,
literal|1
argument_list|,
name|val
argument_list|,
name|set
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
else|else
block|{
name|xbp
operator|=
name|__get_buf
argument_list|(
name|hashp
argument_list|,
name|bp
index|[
name|bp
index|[
literal|0
index|]
operator|-
literal|1
index|]
argument_list|,
name|bufp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xbp
operator|||
operator|(
operator|(
name|totlen
operator|=
name|collect_key
argument_list|(
name|hashp
argument_list|,
name|xbp
argument_list|,
name|totlen
argument_list|,
name|val
argument_list|,
name|set
argument_list|)
operator|)
operator|<
literal|1
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|bufp
operator|->
name|addr
operator|!=
name|save_addr
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
comment|/* MIS -- OUT OF BUFFERS */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|memmove
argument_list|(
operator|&
name|hashp
operator|->
name|tmp_key
index|[
name|len
index|]
argument_list|,
operator|(
name|bufp
operator|->
name|page
operator|)
operator|+
name|bp
index|[
literal|1
index|]
argument_list|,
name|mylen
argument_list|)
expr_stmt|;
return|return
operator|(
name|totlen
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns:  *  0 => OK  * -1 => error  */
end_comment

begin_function
specifier|extern
name|int
name|__big_split
parameter_list|(
name|hashp
parameter_list|,
name|op
parameter_list|,
name|np
parameter_list|,
name|big_keyp
parameter_list|,
name|addr
parameter_list|,
name|obucket
parameter_list|,
name|ret
parameter_list|)
name|HTAB
modifier|*
name|hashp
decl_stmt|;
name|BUFHEAD
modifier|*
name|op
decl_stmt|;
comment|/* Pointer to where to put keys that go in old bucket */
name|BUFHEAD
modifier|*
name|np
decl_stmt|;
comment|/* Pointer to new bucket page */
comment|/* Pointer to first page containing the big key/data */
name|BUFHEAD
modifier|*
name|big_keyp
decl_stmt|;
name|int
name|addr
decl_stmt|;
comment|/* Address of big_keyp */
name|u_int32_t
name|obucket
decl_stmt|;
comment|/* Old Bucket */
name|SPLIT_RETURN
modifier|*
name|ret
decl_stmt|;
block|{
name|BUFHEAD
modifier|*
name|tmpp
decl_stmt|;
name|u_int16_t
modifier|*
name|tp
decl_stmt|;
name|BUFHEAD
modifier|*
name|bp
decl_stmt|;
name|DBT
name|key
decl_stmt|,
name|val
decl_stmt|;
name|u_int32_t
name|change
decl_stmt|;
name|u_int16_t
name|free_space
decl_stmt|,
name|n
decl_stmt|,
name|off
decl_stmt|;
name|bp
operator|=
name|big_keyp
expr_stmt|;
comment|/* Now figure out where the big key/data goes */
if|if
condition|(
name|__big_keydata
argument_list|(
name|hashp
argument_list|,
name|big_keyp
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|val
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|change
operator|=
operator|(
name|__call_hash
argument_list|(
name|hashp
argument_list|,
name|key
operator|.
name|data
argument_list|,
name|key
operator|.
name|size
argument_list|)
operator|!=
name|obucket
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|->
name|next_addr
operator|=
name|__find_last_page
argument_list|(
name|hashp
argument_list|,
operator|&
name|big_keyp
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|ret
operator|->
name|nextp
operator|=
name|__get_buf
argument_list|(
name|hashp
argument_list|,
name|ret
operator|->
name|next_addr
argument_list|,
name|big_keyp
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
empty_stmt|;
block|}
else|else
name|ret
operator|->
name|nextp
operator|=
name|NULL
expr_stmt|;
comment|/* Now make one of np/op point to the big key/data pair */
ifdef|#
directive|ifdef
name|DEBUG
name|assert
argument_list|(
name|np
operator|->
name|ovfl
operator|==
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|change
condition|)
name|tmpp
operator|=
name|np
expr_stmt|;
else|else
name|tmpp
operator|=
name|op
expr_stmt|;
name|tmpp
operator|->
name|flags
operator||=
name|BUF_MOD
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG1
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"BIG_SPLIT: %d->ovfl was %d is now %d\n"
argument_list|,
name|tmpp
operator|->
name|addr
argument_list|,
operator|(
name|tmpp
operator|->
name|ovfl
condition|?
name|tmpp
operator|->
name|ovfl
operator|->
name|addr
else|:
literal|0
operator|)
argument_list|,
operator|(
name|bp
condition|?
name|bp
operator|->
name|addr
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tmpp
operator|->
name|ovfl
operator|=
name|bp
expr_stmt|;
comment|/* one of op/np point to big_keyp */
name|tp
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|tmpp
operator|->
name|page
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|assert
argument_list|(
name|FREESPACE
argument_list|(
name|tp
argument_list|)
operator|>=
name|OVFLSIZE
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|n
operator|=
name|tp
index|[
literal|0
index|]
expr_stmt|;
name|off
operator|=
name|OFFSET
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|free_space
operator|=
name|FREESPACE
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tp
index|[
operator|++
name|n
index|]
operator|=
operator|(
name|u_int16_t
operator|)
name|addr
expr_stmt|;
name|tp
index|[
operator|++
name|n
index|]
operator|=
name|OVFLPAGE
expr_stmt|;
name|tp
index|[
literal|0
index|]
operator|=
name|n
expr_stmt|;
name|OFFSET
argument_list|(
name|tp
argument_list|)
operator|=
name|off
expr_stmt|;
name|FREESPACE
argument_list|(
name|tp
argument_list|)
operator|=
name|free_space
operator|-
name|OVFLSIZE
expr_stmt|;
comment|/* 	 * Finally, set the new and old return values. BIG_KEYP contains a 	 * pointer to the last page of the big key_data pair. Make sure that 	 * big_keyp has no following page (2 elements) or create an empty 	 * following page. 	 */
name|ret
operator|->
name|newp
operator|=
name|np
expr_stmt|;
name|ret
operator|->
name|oldp
operator|=
name|op
expr_stmt|;
name|tp
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|big_keyp
operator|->
name|page
expr_stmt|;
name|big_keyp
operator|->
name|flags
operator||=
name|BUF_MOD
expr_stmt|;
if|if
condition|(
name|tp
index|[
literal|0
index|]
operator|>
literal|2
condition|)
block|{
comment|/* 		 * There may be either one or two offsets on this page.  If 		 * there is one, then the overflow page is linked on normally 		 * and tp[4] is OVFLPAGE.  If there are two, tp[4] contains 		 * the second offset and needs to get stuffed in after the 		 * next overflow page is added. 		 */
name|n
operator|=
name|tp
index|[
literal|4
index|]
expr_stmt|;
name|free_space
operator|=
name|FREESPACE
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|off
operator|=
name|OFFSET
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tp
index|[
literal|0
index|]
operator|-=
literal|2
expr_stmt|;
name|FREESPACE
argument_list|(
name|tp
argument_list|)
operator|=
name|free_space
operator|+
name|OVFLSIZE
expr_stmt|;
name|OFFSET
argument_list|(
name|tp
argument_list|)
operator|=
name|off
expr_stmt|;
name|tmpp
operator|=
name|__add_ovflpage
argument_list|(
name|hashp
argument_list|,
name|big_keyp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmpp
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|tp
index|[
literal|4
index|]
operator|=
name|n
expr_stmt|;
block|}
else|else
name|tmpp
operator|=
name|big_keyp
expr_stmt|;
if|if
condition|(
name|change
condition|)
name|ret
operator|->
name|newp
operator|=
name|tmpp
expr_stmt|;
else|else
name|ret
operator|->
name|oldp
operator|=
name|tmpp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

