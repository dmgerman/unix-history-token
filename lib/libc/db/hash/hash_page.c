begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Margo Seltzer.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)hash_page.c	8.7 (Berkeley) 8/16/94"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBC_SCCS and not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * PACKAGE:  hashing  *  * DESCRIPTION:  *	Page manipulation for hashing package.  *  * ROUTINES:  *  * External  *	__get_page  *	__add_ovflpage  * Internal  *	overflow_page  *	open_temp  */
end_comment

begin_include
include|#
directive|include
file|"namespace.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"un-namespace.h"
end_include

begin_include
include|#
directive|include
file|<db.h>
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"page.h"
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_function_decl
specifier|static
name|u_int32_t
modifier|*
name|fetch_bitmap
parameter_list|(
name|HTAB
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|first_free
parameter_list|(
name|u_int32_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|open_temp
parameter_list|(
name|HTAB
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int16_t
name|overflow_page
parameter_list|(
name|HTAB
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|putpair
parameter_list|(
name|char
modifier|*
parameter_list|,
specifier|const
name|DBT
modifier|*
parameter_list|,
specifier|const
name|DBT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|squeeze_key
parameter_list|(
name|u_int16_t
modifier|*
parameter_list|,
specifier|const
name|DBT
modifier|*
parameter_list|,
specifier|const
name|DBT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ugly_split
parameter_list|(
name|HTAB
modifier|*
parameter_list|,
name|u_int32_t
parameter_list|,
name|BUFHEAD
modifier|*
parameter_list|,
name|BUFHEAD
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|PAGE_INIT
parameter_list|(
name|P
parameter_list|)
value|{ \ 	((u_int16_t *)(P))[0] = 0; \ 	((u_int16_t *)(P))[1] = hashp->BSIZE - 3 * sizeof(u_int16_t); \ 	((u_int16_t *)(P))[2] = hashp->BSIZE; \ }
end_define

begin_comment
comment|/*  * This is called AFTER we have verified that there is room on the page for  * the pair (PAIRFITS has returned true) so we go right ahead and start moving  * stuff on.  */
end_comment

begin_function
specifier|static
name|void
name|putpair
parameter_list|(
name|p
parameter_list|,
name|key
parameter_list|,
name|val
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|DBT
modifier|*
name|key
decl_stmt|,
decl|*
name|val
decl_stmt|;
end_function

begin_block
block|{
name|u_int16_t
modifier|*
name|bp
decl_stmt|,
name|n
decl_stmt|,
name|off
decl_stmt|;
name|bp
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|p
expr_stmt|;
comment|/* Enter the key first. */
name|n
operator|=
name|bp
index|[
literal|0
index|]
expr_stmt|;
name|off
operator|=
name|OFFSET
argument_list|(
name|bp
argument_list|)
operator|-
name|key
operator|->
name|size
expr_stmt|;
name|memmove
argument_list|(
name|p
operator|+
name|off
argument_list|,
name|key
operator|->
name|data
argument_list|,
name|key
operator|->
name|size
argument_list|)
expr_stmt|;
name|bp
index|[
operator|++
name|n
index|]
operator|=
name|off
expr_stmt|;
comment|/* Now the data. */
name|off
operator|-=
name|val
operator|->
name|size
expr_stmt|;
name|memmove
argument_list|(
name|p
operator|+
name|off
argument_list|,
name|val
operator|->
name|data
argument_list|,
name|val
operator|->
name|size
argument_list|)
expr_stmt|;
name|bp
index|[
operator|++
name|n
index|]
operator|=
name|off
expr_stmt|;
comment|/* Adjust page info. */
name|bp
index|[
literal|0
index|]
operator|=
name|n
expr_stmt|;
name|bp
index|[
name|n
operator|+
literal|1
index|]
operator|=
name|off
operator|-
operator|(
operator|(
name|n
operator|+
literal|3
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
operator|)
expr_stmt|;
name|bp
index|[
name|n
operator|+
literal|2
index|]
operator|=
name|off
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Returns:  *	 0 OK  *	-1 error  */
end_comment

begin_function
specifier|extern
name|int
name|__delpair
parameter_list|(
name|hashp
parameter_list|,
name|bufp
parameter_list|,
name|ndx
parameter_list|)
name|HTAB
modifier|*
name|hashp
decl_stmt|;
name|BUFHEAD
modifier|*
name|bufp
decl_stmt|;
name|int
name|ndx
decl_stmt|;
block|{
name|u_int16_t
modifier|*
name|bp
decl_stmt|,
name|newoff
decl_stmt|;
name|int
name|n
decl_stmt|;
name|u_int16_t
name|pairlen
decl_stmt|;
name|bp
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|bufp
operator|->
name|page
expr_stmt|;
name|n
operator|=
name|bp
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|bp
index|[
name|ndx
operator|+
literal|1
index|]
operator|<
name|REAL_KEY
condition|)
return|return
operator|(
name|__big_delete
argument_list|(
name|hashp
argument_list|,
name|bufp
argument_list|)
operator|)
return|;
if|if
condition|(
name|ndx
operator|!=
literal|1
condition|)
name|newoff
operator|=
name|bp
index|[
name|ndx
operator|-
literal|1
index|]
expr_stmt|;
else|else
name|newoff
operator|=
name|hashp
operator|->
name|BSIZE
expr_stmt|;
name|pairlen
operator|=
name|newoff
operator|-
name|bp
index|[
name|ndx
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|ndx
operator|!=
operator|(
name|n
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* Hard Case -- need to shuffle keys */
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|src
init|=
name|bufp
operator|->
name|page
operator|+
operator|(
name|int
operator|)
name|OFFSET
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|char
modifier|*
name|dst
init|=
name|src
operator|+
operator|(
name|int
operator|)
name|pairlen
decl_stmt|;
name|memmove
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|bp
index|[
name|ndx
operator|+
literal|1
index|]
operator|-
name|OFFSET
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now adjust the pointers */
for|for
control|(
name|i
operator|=
name|ndx
operator|+
literal|2
init|;
name|i
operator|<=
name|n
condition|;
name|i
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|bp
index|[
name|i
operator|+
literal|1
index|]
operator|==
name|OVFLPAGE
condition|)
block|{
name|bp
index|[
name|i
operator|-
literal|2
index|]
operator|=
name|bp
index|[
name|i
index|]
expr_stmt|;
name|bp
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|bp
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
name|bp
index|[
name|i
operator|-
literal|2
index|]
operator|=
name|bp
index|[
name|i
index|]
operator|+
name|pairlen
expr_stmt|;
name|bp
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|bp
index|[
name|i
operator|+
literal|1
index|]
operator|+
name|pairlen
expr_stmt|;
block|}
block|}
block|}
comment|/* Finally adjust the page data */
name|bp
index|[
name|n
index|]
operator|=
name|OFFSET
argument_list|(
name|bp
argument_list|)
operator|+
name|pairlen
expr_stmt|;
name|bp
index|[
name|n
operator|-
literal|1
index|]
operator|=
name|bp
index|[
name|n
operator|+
literal|1
index|]
operator|+
name|pairlen
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
expr_stmt|;
name|bp
index|[
literal|0
index|]
operator|=
name|n
operator|-
literal|2
expr_stmt|;
name|hashp
operator|->
name|NKEYS
operator|--
expr_stmt|;
name|bufp
operator|->
name|flags
operator||=
name|BUF_MOD
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns:  *	 0 ==> OK  *	-1 ==> Error  */
end_comment

begin_function
specifier|extern
name|int
name|__split_page
parameter_list|(
name|hashp
parameter_list|,
name|obucket
parameter_list|,
name|nbucket
parameter_list|)
name|HTAB
modifier|*
name|hashp
decl_stmt|;
name|u_int32_t
name|obucket
decl_stmt|,
name|nbucket
decl_stmt|;
block|{
name|BUFHEAD
modifier|*
name|new_bufp
decl_stmt|,
modifier|*
name|old_bufp
decl_stmt|;
name|u_int16_t
modifier|*
name|ino
decl_stmt|;
name|char
modifier|*
name|np
decl_stmt|;
name|DBT
name|key
decl_stmt|,
name|val
decl_stmt|;
name|int
name|n
decl_stmt|,
name|ndx
decl_stmt|,
name|retval
decl_stmt|;
name|u_int16_t
name|copyto
decl_stmt|,
name|diff
decl_stmt|,
name|off
decl_stmt|,
name|moved
decl_stmt|;
name|char
modifier|*
name|op
decl_stmt|;
name|copyto
operator|=
operator|(
name|u_int16_t
operator|)
name|hashp
operator|->
name|BSIZE
expr_stmt|;
name|off
operator|=
operator|(
name|u_int16_t
operator|)
name|hashp
operator|->
name|BSIZE
expr_stmt|;
name|old_bufp
operator|=
name|__get_buf
argument_list|(
name|hashp
argument_list|,
name|obucket
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_bufp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|new_bufp
operator|=
name|__get_buf
argument_list|(
name|hashp
argument_list|,
name|nbucket
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_bufp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|old_bufp
operator|->
name|flags
operator||=
operator|(
name|BUF_MOD
operator||
name|BUF_PIN
operator|)
expr_stmt|;
name|new_bufp
operator|->
name|flags
operator||=
operator|(
name|BUF_MOD
operator||
name|BUF_PIN
operator|)
expr_stmt|;
name|ino
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
operator|(
name|op
operator|=
name|old_bufp
operator|->
name|page
operator|)
expr_stmt|;
name|np
operator|=
name|new_bufp
operator|->
name|page
expr_stmt|;
name|moved
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|1
operator|,
name|ndx
operator|=
literal|1
init|;
name|n
operator|<
name|ino
index|[
literal|0
index|]
condition|;
name|n
operator|+=
literal|2
control|)
block|{
if|if
condition|(
name|ino
index|[
name|n
operator|+
literal|1
index|]
operator|<
name|REAL_KEY
condition|)
block|{
name|retval
operator|=
name|ugly_split
argument_list|(
name|hashp
argument_list|,
name|obucket
argument_list|,
name|old_bufp
argument_list|,
name|new_bufp
argument_list|,
operator|(
name|int
operator|)
name|copyto
argument_list|,
operator|(
name|int
operator|)
name|moved
argument_list|)
expr_stmt|;
name|old_bufp
operator|->
name|flags
operator|&=
operator|~
name|BUF_PIN
expr_stmt|;
name|new_bufp
operator|->
name|flags
operator|&=
operator|~
name|BUF_PIN
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
name|key
operator|.
name|data
operator|=
operator|(
name|u_char
operator|*
operator|)
name|op
operator|+
name|ino
index|[
name|n
index|]
expr_stmt|;
name|key
operator|.
name|size
operator|=
name|off
operator|-
name|ino
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|__call_hash
argument_list|(
name|hashp
argument_list|,
name|key
operator|.
name|data
argument_list|,
name|key
operator|.
name|size
argument_list|)
operator|==
name|obucket
condition|)
block|{
comment|/* Don't switch page */
name|diff
operator|=
name|copyto
operator|-
name|off
expr_stmt|;
if|if
condition|(
name|diff
condition|)
block|{
name|copyto
operator|=
name|ino
index|[
name|n
operator|+
literal|1
index|]
operator|+
name|diff
expr_stmt|;
name|memmove
argument_list|(
name|op
operator|+
name|copyto
argument_list|,
name|op
operator|+
name|ino
index|[
name|n
operator|+
literal|1
index|]
argument_list|,
name|off
operator|-
name|ino
index|[
name|n
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|ino
index|[
name|ndx
index|]
operator|=
name|copyto
operator|+
name|ino
index|[
name|n
index|]
operator|-
name|ino
index|[
name|n
operator|+
literal|1
index|]
expr_stmt|;
name|ino
index|[
name|ndx
operator|+
literal|1
index|]
operator|=
name|copyto
expr_stmt|;
block|}
else|else
name|copyto
operator|=
name|ino
index|[
name|n
operator|+
literal|1
index|]
expr_stmt|;
name|ndx
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
comment|/* Switch page */
name|val
operator|.
name|data
operator|=
operator|(
name|u_char
operator|*
operator|)
name|op
operator|+
name|ino
index|[
name|n
operator|+
literal|1
index|]
expr_stmt|;
name|val
operator|.
name|size
operator|=
name|ino
index|[
name|n
index|]
operator|-
name|ino
index|[
name|n
operator|+
literal|1
index|]
expr_stmt|;
name|putpair
argument_list|(
name|np
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|moved
operator|+=
literal|2
expr_stmt|;
block|}
name|off
operator|=
name|ino
index|[
name|n
operator|+
literal|1
index|]
expr_stmt|;
block|}
comment|/* Now clean up the page */
name|ino
index|[
literal|0
index|]
operator|-=
name|moved
expr_stmt|;
name|FREESPACE
argument_list|(
name|ino
argument_list|)
operator|=
name|copyto
operator|-
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
operator|*
operator|(
name|ino
index|[
literal|0
index|]
operator|+
literal|3
operator|)
expr_stmt|;
name|OFFSET
argument_list|(
name|ino
argument_list|)
operator|=
name|copyto
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG3
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"split %d/%d\n"
argument_list|,
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|np
operator|)
index|[
literal|0
index|]
operator|/
literal|2
argument_list|,
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|op
operator|)
index|[
literal|0
index|]
operator|/
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* unpin both pages */
name|old_bufp
operator|->
name|flags
operator|&=
operator|~
name|BUF_PIN
expr_stmt|;
name|new_bufp
operator|->
name|flags
operator|&=
operator|~
name|BUF_PIN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called when we encounter an overflow or big key/data page during split  * handling.  This is special cased since we have to begin checking whether  * the key/data pairs fit on their respective pages and because we may need  * overflow pages for both the old and new pages.  *  * The first page might be a page with regular key/data pairs in which case  * we have a regular overflow condition and just need to go on to the next  * page or it might be a big key/data pair in which case we need to fix the  * big key/data pair.  *  * Returns:  *	 0 ==> success  *	-1 ==> failure  */
end_comment

begin_function
specifier|static
name|int
name|ugly_split
parameter_list|(
name|hashp
parameter_list|,
name|obucket
parameter_list|,
name|old_bufp
parameter_list|,
name|new_bufp
parameter_list|,
name|copyto
parameter_list|,
name|moved
parameter_list|)
name|HTAB
modifier|*
name|hashp
decl_stmt|;
name|u_int32_t
name|obucket
decl_stmt|;
comment|/* Same as __split_page. */
name|BUFHEAD
modifier|*
name|old_bufp
decl_stmt|,
decl|*
name|new_bufp
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|copyto
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First byte on page which contains key/data values. */
end_comment

begin_decl_stmt
name|int
name|moved
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of pairs moved to new page. */
end_comment

begin_block
block|{
name|BUFHEAD
modifier|*
name|bufp
decl_stmt|;
comment|/* Buffer header for ino */
name|u_int16_t
modifier|*
name|ino
decl_stmt|;
comment|/* Page keys come off of */
name|u_int16_t
modifier|*
name|np
decl_stmt|;
comment|/* New page */
name|u_int16_t
modifier|*
name|op
decl_stmt|;
comment|/* Page keys go on to if they aren't moving */
name|BUFHEAD
modifier|*
name|last_bfp
decl_stmt|;
comment|/* Last buf header OVFL needing to be freed */
name|DBT
name|key
decl_stmt|,
name|val
decl_stmt|;
name|SPLIT_RETURN
name|ret
decl_stmt|;
name|u_int16_t
name|n
decl_stmt|,
name|off
decl_stmt|,
name|ov_addr
decl_stmt|,
name|scopyto
decl_stmt|;
name|char
modifier|*
name|cino
decl_stmt|;
comment|/* Character value of ino */
name|bufp
operator|=
name|old_bufp
expr_stmt|;
name|ino
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|old_bufp
operator|->
name|page
expr_stmt|;
name|np
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|new_bufp
operator|->
name|page
expr_stmt|;
name|op
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|old_bufp
operator|->
name|page
expr_stmt|;
name|last_bfp
operator|=
name|NULL
expr_stmt|;
name|scopyto
operator|=
operator|(
name|u_int16_t
operator|)
name|copyto
expr_stmt|;
comment|/* ANSI */
name|n
operator|=
name|ino
index|[
literal|0
index|]
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|n
operator|<
name|ino
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|ino
index|[
literal|2
index|]
operator|<
name|REAL_KEY
operator|&&
name|ino
index|[
literal|2
index|]
operator|!=
name|OVFLPAGE
condition|)
block|{
if|if
condition|(
name|__big_split
argument_list|(
name|hashp
argument_list|,
name|old_bufp
argument_list|,
name|new_bufp
argument_list|,
name|bufp
argument_list|,
name|bufp
operator|->
name|addr
argument_list|,
name|obucket
argument_list|,
operator|&
name|ret
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|old_bufp
operator|=
name|ret
operator|.
name|oldp
expr_stmt|;
if|if
condition|(
operator|!
name|old_bufp
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|op
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|old_bufp
operator|->
name|page
expr_stmt|;
name|new_bufp
operator|=
name|ret
operator|.
name|newp
expr_stmt|;
if|if
condition|(
operator|!
name|new_bufp
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|np
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|new_bufp
operator|->
name|page
expr_stmt|;
name|bufp
operator|=
name|ret
operator|.
name|nextp
expr_stmt|;
if|if
condition|(
operator|!
name|bufp
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cino
operator|=
operator|(
name|char
operator|*
operator|)
name|bufp
operator|->
name|page
expr_stmt|;
name|ino
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|cino
expr_stmt|;
name|last_bfp
operator|=
name|ret
operator|.
name|nextp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ino
index|[
name|n
operator|+
literal|1
index|]
operator|==
name|OVFLPAGE
condition|)
block|{
name|ov_addr
operator|=
name|ino
index|[
name|n
index|]
expr_stmt|;
comment|/* 			 * Fix up the old page -- the extra 2 are the fields 			 * which contained the overflow information. 			 */
name|ino
index|[
literal|0
index|]
operator|-=
operator|(
name|moved
operator|+
literal|2
operator|)
expr_stmt|;
name|FREESPACE
argument_list|(
name|ino
argument_list|)
operator|=
name|scopyto
operator|-
sizeof|sizeof
argument_list|(
name|u_int16_t
argument_list|)
operator|*
operator|(
name|ino
index|[
literal|0
index|]
operator|+
literal|3
operator|)
expr_stmt|;
name|OFFSET
argument_list|(
name|ino
argument_list|)
operator|=
name|scopyto
expr_stmt|;
name|bufp
operator|=
name|__get_buf
argument_list|(
name|hashp
argument_list|,
name|ov_addr
argument_list|,
name|bufp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bufp
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|ino
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|bufp
operator|->
name|page
expr_stmt|;
name|n
operator|=
literal|1
expr_stmt|;
name|scopyto
operator|=
name|hashp
operator|->
name|BSIZE
expr_stmt|;
name|moved
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|last_bfp
condition|)
name|__free_ovflpage
argument_list|(
name|hashp
argument_list|,
name|last_bfp
argument_list|)
expr_stmt|;
name|last_bfp
operator|=
name|bufp
expr_stmt|;
block|}
comment|/* Move regular sized pairs of there are any */
name|off
operator|=
name|hashp
operator|->
name|BSIZE
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|1
init|;
operator|(
name|n
operator|<
name|ino
index|[
literal|0
index|]
operator|)
operator|&&
operator|(
name|ino
index|[
name|n
operator|+
literal|1
index|]
operator|>=
name|REAL_KEY
operator|)
condition|;
name|n
operator|+=
literal|2
control|)
block|{
name|cino
operator|=
operator|(
name|char
operator|*
operator|)
name|ino
expr_stmt|;
name|key
operator|.
name|data
operator|=
operator|(
name|u_char
operator|*
operator|)
name|cino
operator|+
name|ino
index|[
name|n
index|]
expr_stmt|;
name|key
operator|.
name|size
operator|=
name|off
operator|-
name|ino
index|[
name|n
index|]
expr_stmt|;
name|val
operator|.
name|data
operator|=
operator|(
name|u_char
operator|*
operator|)
name|cino
operator|+
name|ino
index|[
name|n
operator|+
literal|1
index|]
expr_stmt|;
name|val
operator|.
name|size
operator|=
name|ino
index|[
name|n
index|]
operator|-
name|ino
index|[
name|n
operator|+
literal|1
index|]
expr_stmt|;
name|off
operator|=
name|ino
index|[
name|n
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|__call_hash
argument_list|(
name|hashp
argument_list|,
name|key
operator|.
name|data
argument_list|,
name|key
operator|.
name|size
argument_list|)
operator|==
name|obucket
condition|)
block|{
comment|/* Keep on old page */
if|if
condition|(
name|PAIRFITS
argument_list|(
name|op
argument_list|,
operator|(
operator|&
name|key
operator|)
argument_list|,
operator|(
operator|&
name|val
operator|)
argument_list|)
condition|)
name|putpair
argument_list|(
operator|(
name|char
operator|*
operator|)
name|op
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
else|else
block|{
name|old_bufp
operator|=
name|__add_ovflpage
argument_list|(
name|hashp
argument_list|,
name|old_bufp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|old_bufp
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|op
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|old_bufp
operator|->
name|page
expr_stmt|;
name|putpair
argument_list|(
operator|(
name|char
operator|*
operator|)
name|op
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
name|old_bufp
operator|->
name|flags
operator||=
name|BUF_MOD
expr_stmt|;
block|}
else|else
block|{
comment|/* Move to new page */
if|if
condition|(
name|PAIRFITS
argument_list|(
name|np
argument_list|,
operator|(
operator|&
name|key
operator|)
argument_list|,
operator|(
operator|&
name|val
operator|)
argument_list|)
condition|)
name|putpair
argument_list|(
operator|(
name|char
operator|*
operator|)
name|np
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
else|else
block|{
name|new_bufp
operator|=
name|__add_ovflpage
argument_list|(
name|hashp
argument_list|,
name|new_bufp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_bufp
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|np
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|new_bufp
operator|->
name|page
expr_stmt|;
name|putpair
argument_list|(
operator|(
name|char
operator|*
operator|)
name|np
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
name|new_bufp
operator|->
name|flags
operator||=
name|BUF_MOD
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|last_bfp
condition|)
name|__free_ovflpage
argument_list|(
name|hashp
argument_list|,
name|last_bfp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Add the given pair to the page  *  * Returns:  *	0 ==> OK  *	1 ==> failure  */
end_comment

begin_function
specifier|extern
name|int
name|__addel
parameter_list|(
name|hashp
parameter_list|,
name|bufp
parameter_list|,
name|key
parameter_list|,
name|val
parameter_list|)
name|HTAB
modifier|*
name|hashp
decl_stmt|;
name|BUFHEAD
modifier|*
name|bufp
decl_stmt|;
specifier|const
name|DBT
modifier|*
name|key
decl_stmt|,
decl|*
name|val
decl_stmt|;
end_function

begin_block
block|{
name|u_int16_t
modifier|*
name|bp
decl_stmt|,
modifier|*
name|sop
decl_stmt|;
name|int
name|do_expand
decl_stmt|;
name|bp
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|bufp
operator|->
name|page
expr_stmt|;
name|do_expand
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|bp
index|[
literal|0
index|]
operator|&&
operator|(
name|bp
index|[
literal|2
index|]
operator|<
name|REAL_KEY
operator|||
name|bp
index|[
name|bp
index|[
literal|0
index|]
index|]
operator|<
name|REAL_KEY
operator|)
condition|)
comment|/* Exception case */
if|if
condition|(
name|bp
index|[
literal|2
index|]
operator|==
name|FULL_KEY_DATA
operator|&&
name|bp
index|[
literal|0
index|]
operator|==
literal|2
condition|)
comment|/* This is the last page of a big key/data pair 			   and we need to add another page */
break|break;
elseif|else
if|if
condition|(
name|bp
index|[
literal|2
index|]
operator|<
name|REAL_KEY
operator|&&
name|bp
index|[
name|bp
index|[
literal|0
index|]
index|]
operator|!=
name|OVFLPAGE
condition|)
block|{
name|bufp
operator|=
name|__get_buf
argument_list|(
name|hashp
argument_list|,
name|bp
index|[
name|bp
index|[
literal|0
index|]
operator|-
literal|1
index|]
argument_list|,
name|bufp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bufp
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bp
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|bufp
operator|->
name|page
expr_stmt|;
block|}
elseif|else
comment|/* Try to squeeze key on this page */
if|if
condition|(
name|FREESPACE
argument_list|(
name|bp
argument_list|)
operator|>
name|PAIRSIZE
argument_list|(
name|key
argument_list|,
name|val
argument_list|)
condition|)
block|{
name|squeeze_key
argument_list|(
name|bp
argument_list|,
name|key
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|bufp
operator|=
name|__get_buf
argument_list|(
name|hashp
argument_list|,
name|bp
index|[
name|bp
index|[
literal|0
index|]
operator|-
literal|1
index|]
argument_list|,
name|bufp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bufp
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bp
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|bufp
operator|->
name|page
expr_stmt|;
block|}
if|if
condition|(
name|PAIRFITS
argument_list|(
name|bp
argument_list|,
name|key
argument_list|,
name|val
argument_list|)
condition|)
name|putpair
argument_list|(
name|bufp
operator|->
name|page
argument_list|,
name|key
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
block|{
name|do_expand
operator|=
literal|1
expr_stmt|;
name|bufp
operator|=
name|__add_ovflpage
argument_list|(
name|hashp
argument_list|,
name|bufp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bufp
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|sop
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|bufp
operator|->
name|page
expr_stmt|;
if|if
condition|(
name|PAIRFITS
argument_list|(
name|sop
argument_list|,
name|key
argument_list|,
name|val
argument_list|)
condition|)
name|putpair
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sop
argument_list|,
name|key
argument_list|,
name|val
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|__big_insert
argument_list|(
name|hashp
argument_list|,
name|bufp
argument_list|,
name|key
argument_list|,
name|val
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|bufp
operator|->
name|flags
operator||=
name|BUF_MOD
expr_stmt|;
comment|/* 	 * If the average number of keys per bucket exceeds the fill factor, 	 * expand the table. 	 */
name|hashp
operator|->
name|NKEYS
operator|++
expr_stmt|;
if|if
condition|(
name|do_expand
operator|||
operator|(
name|hashp
operator|->
name|NKEYS
operator|/
operator|(
name|hashp
operator|->
name|MAX_BUCKET
operator|+
literal|1
operator|)
operator|>
name|hashp
operator|->
name|FFACTOR
operator|)
condition|)
return|return
operator|(
name|__expand_table
argument_list|(
name|hashp
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  *  * Returns:  *	pointer on success  *	NULL on error  */
end_comment

begin_function
specifier|extern
name|BUFHEAD
modifier|*
name|__add_ovflpage
parameter_list|(
name|hashp
parameter_list|,
name|bufp
parameter_list|)
name|HTAB
modifier|*
name|hashp
decl_stmt|;
name|BUFHEAD
modifier|*
name|bufp
decl_stmt|;
block|{
name|u_int16_t
modifier|*
name|sp
decl_stmt|;
name|u_int16_t
name|ndx
decl_stmt|,
name|ovfl_num
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG1
name|int
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
endif|#
directive|endif
name|sp
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|bufp
operator|->
name|page
expr_stmt|;
comment|/* Check if we are dynamically determining the fill factor */
if|if
condition|(
name|hashp
operator|->
name|FFACTOR
operator|==
name|DEF_FFACTOR
condition|)
block|{
name|hashp
operator|->
name|FFACTOR
operator|=
name|sp
index|[
literal|0
index|]
operator|>>
literal|1
expr_stmt|;
if|if
condition|(
name|hashp
operator|->
name|FFACTOR
operator|<
name|MIN_FFACTOR
condition|)
name|hashp
operator|->
name|FFACTOR
operator|=
name|MIN_FFACTOR
expr_stmt|;
block|}
name|bufp
operator|->
name|flags
operator||=
name|BUF_MOD
expr_stmt|;
name|ovfl_num
operator|=
name|overflow_page
argument_list|(
name|hashp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG1
name|tmp1
operator|=
name|bufp
operator|->
name|addr
expr_stmt|;
name|tmp2
operator|=
name|bufp
operator|->
name|ovfl
condition|?
name|bufp
operator|->
name|ovfl
operator|->
name|addr
else|:
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|ovfl_num
operator|||
operator|!
operator|(
name|bufp
operator|->
name|ovfl
operator|=
name|__get_buf
argument_list|(
name|hashp
argument_list|,
name|ovfl_num
argument_list|,
name|bufp
argument_list|,
literal|1
argument_list|)
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bufp
operator|->
name|ovfl
operator|->
name|flags
operator||=
name|BUF_MOD
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG1
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ADDOVFLPAGE: %d->ovfl was %d is now %d\n"
argument_list|,
name|tmp1
argument_list|,
name|tmp2
argument_list|,
name|bufp
operator|->
name|ovfl
operator|->
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ndx
operator|=
name|sp
index|[
literal|0
index|]
expr_stmt|;
comment|/* 	 * Since a pair is allocated on a page only if there's room to add 	 * an overflow page, we know that the OVFL information will fit on 	 * the page. 	 */
name|sp
index|[
name|ndx
operator|+
literal|4
index|]
operator|=
name|OFFSET
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|sp
index|[
name|ndx
operator|+
literal|3
index|]
operator|=
name|FREESPACE
argument_list|(
name|sp
argument_list|)
operator|-
name|OVFLSIZE
expr_stmt|;
name|sp
index|[
name|ndx
operator|+
literal|1
index|]
operator|=
name|ovfl_num
expr_stmt|;
name|sp
index|[
name|ndx
operator|+
literal|2
index|]
operator|=
name|OVFLPAGE
expr_stmt|;
name|sp
index|[
literal|0
index|]
operator|=
name|ndx
operator|+
literal|2
expr_stmt|;
ifdef|#
directive|ifdef
name|HASH_STATISTICS
name|hash_overflows
operator|++
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|bufp
operator|->
name|ovfl
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns:  *	 0 indicates SUCCESS  *	-1 indicates FAILURE  */
end_comment

begin_function
specifier|extern
name|int
name|__get_page
parameter_list|(
name|hashp
parameter_list|,
name|p
parameter_list|,
name|bucket
parameter_list|,
name|is_bucket
parameter_list|,
name|is_disk
parameter_list|,
name|is_bitmap
parameter_list|)
name|HTAB
modifier|*
name|hashp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|u_int32_t
name|bucket
decl_stmt|;
name|int
name|is_bucket
decl_stmt|,
name|is_disk
decl_stmt|,
name|is_bitmap
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|,
name|page
decl_stmt|,
name|size
decl_stmt|;
name|int
name|rsize
decl_stmt|;
name|u_int16_t
modifier|*
name|bp
decl_stmt|;
name|fd
operator|=
name|hashp
operator|->
name|fp
expr_stmt|;
name|size
operator|=
name|hashp
operator|->
name|BSIZE
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|==
operator|-
literal|1
operator|)
operator|||
operator|!
name|is_disk
condition|)
block|{
name|PAGE_INIT
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|is_bucket
condition|)
name|page
operator|=
name|BUCKET_TO_PAGE
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
else|else
name|page
operator|=
name|OADDR_TO_PAGE
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
name|page
operator|<<
name|hashp
operator|->
name|BSHIFT
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
operator|(
name|rsize
operator|=
name|_read
argument_list|(
name|fd
argument_list|,
name|p
argument_list|,
name|size
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bp
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|p
expr_stmt|;
if|if
condition|(
operator|!
name|rsize
condition|)
name|bp
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* We hit the EOF, so initialize a new page */
elseif|else
if|if
condition|(
name|rsize
operator|!=
name|size
condition|)
block|{
name|errno
operator|=
name|EFTYPE
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|is_bitmap
operator|&&
operator|!
name|bp
index|[
literal|0
index|]
condition|)
block|{
name|PAGE_INIT
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hashp
operator|->
name|LORDER
operator|!=
name|BYTE_ORDER
condition|)
block|{
name|int
name|i
decl_stmt|,
name|max
decl_stmt|;
if|if
condition|(
name|is_bitmap
condition|)
block|{
name|max
operator|=
name|hashp
operator|->
name|BSIZE
operator|>>
literal|2
expr_stmt|;
comment|/* divide by 4 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
name|M_32_SWAP
argument_list|(
operator|(
operator|(
name|int
operator|*
operator|)
name|p
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|M_16_SWAP
argument_list|(
name|bp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|max
operator|=
name|bp
index|[
literal|0
index|]
operator|+
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|max
condition|;
name|i
operator|++
control|)
name|M_16_SWAP
argument_list|(
name|bp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write page p to disk  *  * Returns:  *	 0 ==> OK  *	-1 ==>failure  */
end_comment

begin_function
specifier|extern
name|int
name|__put_page
parameter_list|(
name|hashp
parameter_list|,
name|p
parameter_list|,
name|bucket
parameter_list|,
name|is_bucket
parameter_list|,
name|is_bitmap
parameter_list|)
name|HTAB
modifier|*
name|hashp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|u_int32_t
name|bucket
decl_stmt|;
name|int
name|is_bucket
decl_stmt|,
name|is_bitmap
decl_stmt|;
block|{
name|int
name|fd
decl_stmt|,
name|page
decl_stmt|,
name|size
decl_stmt|;
name|int
name|wsize
decl_stmt|;
name|size
operator|=
name|hashp
operator|->
name|BSIZE
expr_stmt|;
if|if
condition|(
operator|(
name|hashp
operator|->
name|fp
operator|==
operator|-
literal|1
operator|)
operator|&&
name|open_temp
argument_list|(
name|hashp
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|fd
operator|=
name|hashp
operator|->
name|fp
expr_stmt|;
if|if
condition|(
name|hashp
operator|->
name|LORDER
operator|!=
name|BYTE_ORDER
condition|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|max
decl_stmt|;
if|if
condition|(
name|is_bitmap
condition|)
block|{
name|max
operator|=
name|hashp
operator|->
name|BSIZE
operator|>>
literal|2
expr_stmt|;
comment|/* divide by 4 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max
condition|;
name|i
operator|++
control|)
name|M_32_SWAP
argument_list|(
operator|(
operator|(
name|int
operator|*
operator|)
name|p
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|max
operator|=
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|p
operator|)
index|[
literal|0
index|]
operator|+
literal|2
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|max
condition|;
name|i
operator|++
control|)
name|M_16_SWAP
argument_list|(
operator|(
operator|(
name|u_int16_t
operator|*
operator|)
name|p
operator|)
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|is_bucket
condition|)
name|page
operator|=
name|BUCKET_TO_PAGE
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
else|else
name|page
operator|=
name|OADDR_TO_PAGE
argument_list|(
name|bucket
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
name|page
operator|<<
name|hashp
operator|->
name|BSHIFT
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
operator|(
name|wsize
operator|=
name|_write
argument_list|(
name|fd
argument_list|,
name|p
argument_list|,
name|size
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|)
condition|)
comment|/* Errno is set */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|wsize
operator|!=
name|size
condition|)
block|{
name|errno
operator|=
name|EFTYPE
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|BYTE_MASK
value|((1<< INT_BYTE_SHIFT) -1)
end_define

begin_comment
comment|/*  * Initialize a new bitmap page.  Bitmap pages are left in memory  * once they are read in.  */
end_comment

begin_function
specifier|extern
name|int
name|__ibitmap
parameter_list|(
name|hashp
parameter_list|,
name|pnum
parameter_list|,
name|nbits
parameter_list|,
name|ndx
parameter_list|)
name|HTAB
modifier|*
name|hashp
decl_stmt|;
name|int
name|pnum
decl_stmt|,
name|nbits
decl_stmt|,
name|ndx
decl_stmt|;
block|{
name|u_int32_t
modifier|*
name|ip
decl_stmt|;
name|int
name|clearbytes
decl_stmt|,
name|clearints
decl_stmt|;
if|if
condition|(
operator|(
name|ip
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|malloc
argument_list|(
name|hashp
operator|->
name|BSIZE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|hashp
operator|->
name|nmaps
operator|++
expr_stmt|;
name|clearints
operator|=
operator|(
operator|(
name|nbits
operator|-
literal|1
operator|)
operator|>>
name|INT_BYTE_SHIFT
operator|)
operator|+
literal|1
expr_stmt|;
name|clearbytes
operator|=
name|clearints
operator|<<
name|INT_TO_BYTE
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ip
argument_list|,
literal|0
argument_list|,
name|clearbytes
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|(
operator|(
name|char
operator|*
operator|)
name|ip
operator|)
operator|+
name|clearbytes
argument_list|,
literal|0xFF
argument_list|,
name|hashp
operator|->
name|BSIZE
operator|-
name|clearbytes
argument_list|)
expr_stmt|;
name|ip
index|[
name|clearints
operator|-
literal|1
index|]
operator|=
name|ALL_SET
operator|<<
operator|(
name|nbits
operator|&
name|BYTE_MASK
operator|)
expr_stmt|;
name|SETBIT
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|hashp
operator|->
name|BITMAPS
index|[
name|ndx
index|]
operator|=
operator|(
name|u_int16_t
operator|)
name|pnum
expr_stmt|;
name|hashp
operator|->
name|mapp
index|[
name|ndx
index|]
operator|=
name|ip
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|first_free
parameter_list|(
name|map
parameter_list|)
name|u_int32_t
name|map
decl_stmt|;
block|{
name|u_int32_t
name|i
decl_stmt|,
name|mask
decl_stmt|;
name|mask
operator|=
literal|0x1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BITS_PER_MAP
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|mask
operator|&
name|map
operator|)
condition|)
return|return
operator|(
name|i
operator|)
return|;
name|mask
operator|=
name|mask
operator|<<
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|u_int16_t
name|overflow_page
parameter_list|(
name|hashp
parameter_list|)
name|HTAB
modifier|*
name|hashp
decl_stmt|;
block|{
name|u_int32_t
modifier|*
name|freep
decl_stmt|;
name|int
name|max_free
decl_stmt|,
name|offset
decl_stmt|,
name|splitnum
decl_stmt|;
name|u_int16_t
name|addr
decl_stmt|;
name|int
name|bit
decl_stmt|,
name|first_page
decl_stmt|,
name|free_bit
decl_stmt|,
name|free_page
decl_stmt|,
name|i
decl_stmt|,
name|in_use_bits
decl_stmt|,
name|j
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG2
name|int
name|tmp1
decl_stmt|,
name|tmp2
decl_stmt|;
endif|#
directive|endif
name|splitnum
operator|=
name|hashp
operator|->
name|OVFL_POINT
expr_stmt|;
name|max_free
operator|=
name|hashp
operator|->
name|SPARES
index|[
name|splitnum
index|]
expr_stmt|;
name|free_page
operator|=
operator|(
name|max_free
operator|-
literal|1
operator|)
operator|>>
operator|(
name|hashp
operator|->
name|BSHIFT
operator|+
name|BYTE_SHIFT
operator|)
expr_stmt|;
name|free_bit
operator|=
operator|(
name|max_free
operator|-
literal|1
operator|)
operator|&
operator|(
operator|(
name|hashp
operator|->
name|BSIZE
operator|<<
name|BYTE_SHIFT
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Look through all the free maps to find the first free block */
name|first_page
operator|=
name|hashp
operator|->
name|LAST_FREED
operator|>>
operator|(
name|hashp
operator|->
name|BSHIFT
operator|+
name|BYTE_SHIFT
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|first_page
init|;
name|i
operator|<=
name|free_page
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|freep
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|hashp
operator|->
name|mapp
index|[
name|i
index|]
operator|)
operator|&&
operator|!
operator|(
name|freep
operator|=
name|fetch_bitmap
argument_list|(
name|hashp
argument_list|,
name|i
argument_list|)
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|i
operator|==
name|free_page
condition|)
name|in_use_bits
operator|=
name|free_bit
expr_stmt|;
else|else
name|in_use_bits
operator|=
operator|(
name|hashp
operator|->
name|BSIZE
operator|<<
name|BYTE_SHIFT
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|first_page
condition|)
block|{
name|bit
operator|=
name|hashp
operator|->
name|LAST_FREED
operator|&
operator|(
operator|(
name|hashp
operator|->
name|BSIZE
operator|<<
name|BYTE_SHIFT
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|j
operator|=
name|bit
operator|/
name|BITS_PER_MAP
expr_stmt|;
name|bit
operator|=
name|bit
operator|&
operator|~
operator|(
name|BITS_PER_MAP
operator|-
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
name|bit
operator|=
literal|0
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
init|;
name|bit
operator|<=
name|in_use_bits
condition|;
name|j
operator|++
operator|,
name|bit
operator|+=
name|BITS_PER_MAP
control|)
if|if
condition|(
name|freep
index|[
name|j
index|]
operator|!=
name|ALL_SET
condition|)
goto|goto
name|found
goto|;
block|}
comment|/* No Free Page Found */
name|hashp
operator|->
name|LAST_FREED
operator|=
name|hashp
operator|->
name|SPARES
index|[
name|splitnum
index|]
expr_stmt|;
name|hashp
operator|->
name|SPARES
index|[
name|splitnum
index|]
operator|++
expr_stmt|;
name|offset
operator|=
name|hashp
operator|->
name|SPARES
index|[
name|splitnum
index|]
operator|-
operator|(
name|splitnum
condition|?
name|hashp
operator|->
name|SPARES
index|[
name|splitnum
operator|-
literal|1
index|]
else|:
literal|0
operator|)
expr_stmt|;
define|#
directive|define
name|OVMSG
value|"HASH: Out of overflow pages.  Increase page size\n"
if|if
condition|(
name|offset
operator|>
name|SPLITMASK
condition|)
block|{
if|if
condition|(
operator|++
name|splitnum
operator|>=
name|NCACHED
condition|)
block|{
operator|(
name|void
operator|)
name|_write
argument_list|(
name|STDERR_FILENO
argument_list|,
name|OVMSG
argument_list|,
sizeof|sizeof
argument_list|(
name|OVMSG
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|hashp
operator|->
name|OVFL_POINT
operator|=
name|splitnum
expr_stmt|;
name|hashp
operator|->
name|SPARES
index|[
name|splitnum
index|]
operator|=
name|hashp
operator|->
name|SPARES
index|[
name|splitnum
operator|-
literal|1
index|]
expr_stmt|;
name|hashp
operator|->
name|SPARES
index|[
name|splitnum
operator|-
literal|1
index|]
operator|--
expr_stmt|;
name|offset
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Check if we need to allocate a new bitmap page */
if|if
condition|(
name|free_bit
operator|==
operator|(
name|hashp
operator|->
name|BSIZE
operator|<<
name|BYTE_SHIFT
operator|)
operator|-
literal|1
condition|)
block|{
name|free_page
operator|++
expr_stmt|;
if|if
condition|(
name|free_page
operator|>=
name|NCACHED
condition|)
block|{
operator|(
name|void
operator|)
name|_write
argument_list|(
name|STDERR_FILENO
argument_list|,
name|OVMSG
argument_list|,
sizeof|sizeof
argument_list|(
name|OVMSG
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * This is tricky.  The 1 indicates that you want the new page 		 * allocated with 1 clear bit.  Actually, you are going to 		 * allocate 2 pages from this map.  The first is going to be 		 * the map page, the second is the overflow page we were 		 * looking for.  The init_bitmap routine automatically, sets 		 * the first bit of itself to indicate that the bitmap itself 		 * is in use.  We would explicitly set the second bit, but 		 * don't have to if we tell init_bitmap not to leave it clear 		 * in the first place. 		 */
if|if
condition|(
name|__ibitmap
argument_list|(
name|hashp
argument_list|,
operator|(
name|int
operator|)
name|OADDR_OF
argument_list|(
name|splitnum
argument_list|,
name|offset
argument_list|)
argument_list|,
literal|1
argument_list|,
name|free_page
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|hashp
operator|->
name|SPARES
index|[
name|splitnum
index|]
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG2
name|free_bit
operator|=
literal|2
expr_stmt|;
endif|#
directive|endif
name|offset
operator|++
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|SPLITMASK
condition|)
block|{
if|if
condition|(
operator|++
name|splitnum
operator|>=
name|NCACHED
condition|)
block|{
operator|(
name|void
operator|)
name|_write
argument_list|(
name|STDERR_FILENO
argument_list|,
name|OVMSG
argument_list|,
sizeof|sizeof
argument_list|(
name|OVMSG
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|hashp
operator|->
name|OVFL_POINT
operator|=
name|splitnum
expr_stmt|;
name|hashp
operator|->
name|SPARES
index|[
name|splitnum
index|]
operator|=
name|hashp
operator|->
name|SPARES
index|[
name|splitnum
operator|-
literal|1
index|]
expr_stmt|;
name|hashp
operator|->
name|SPARES
index|[
name|splitnum
operator|-
literal|1
index|]
operator|--
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Free_bit addresses the last used bit.  Bump it to address 		 * the first available bit. 		 */
name|free_bit
operator|++
expr_stmt|;
name|SETBIT
argument_list|(
name|freep
argument_list|,
name|free_bit
argument_list|)
expr_stmt|;
block|}
comment|/* Calculate address of the new overflow page */
name|addr
operator|=
name|OADDR_OF
argument_list|(
name|splitnum
argument_list|,
name|offset
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG2
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"OVERFLOW_PAGE: ADDR: %d BIT: %d PAGE %d\n"
argument_list|,
name|addr
argument_list|,
name|free_bit
argument_list|,
name|free_page
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|addr
operator|)
return|;
name|found
label|:
name|bit
operator|=
name|bit
operator|+
name|first_free
argument_list|(
name|freep
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|SETBIT
argument_list|(
name|freep
argument_list|,
name|bit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG2
name|tmp1
operator|=
name|bit
expr_stmt|;
name|tmp2
operator|=
name|i
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Bits are addressed starting with 0, but overflow pages are addressed 	 * beginning at 1. Bit is a bit addressnumber, so we need to increment 	 * it to convert it to a page number. 	 */
name|bit
operator|=
literal|1
operator|+
name|bit
operator|+
operator|(
name|i
operator|*
operator|(
name|hashp
operator|->
name|BSIZE
operator|<<
name|BYTE_SHIFT
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|bit
operator|>=
name|hashp
operator|->
name|LAST_FREED
condition|)
name|hashp
operator|->
name|LAST_FREED
operator|=
name|bit
operator|-
literal|1
expr_stmt|;
comment|/* Calculate the split number for this page */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|i
operator|<
name|splitnum
operator|)
operator|&&
operator|(
name|bit
operator|>
name|hashp
operator|->
name|SPARES
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
name|offset
operator|=
operator|(
name|i
condition|?
name|bit
operator|-
name|hashp
operator|->
name|SPARES
index|[
name|i
operator|-
literal|1
index|]
else|:
name|bit
operator|)
expr_stmt|;
if|if
condition|(
name|offset
operator|>=
name|SPLITMASK
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Out of overflow pages */
name|addr
operator|=
name|OADDR_OF
argument_list|(
name|i
argument_list|,
name|offset
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG2
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"OVERFLOW_PAGE: ADDR: %d BIT: %d PAGE %d\n"
argument_list|,
name|addr
argument_list|,
name|tmp1
argument_list|,
name|tmp2
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Allocate and return the overflow page */
return|return
operator|(
name|addr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Mark this overflow page as free.  */
end_comment

begin_function
specifier|extern
name|void
name|__free_ovflpage
parameter_list|(
name|hashp
parameter_list|,
name|obufp
parameter_list|)
name|HTAB
modifier|*
name|hashp
decl_stmt|;
name|BUFHEAD
modifier|*
name|obufp
decl_stmt|;
block|{
name|u_int16_t
name|addr
decl_stmt|;
name|u_int32_t
modifier|*
name|freep
decl_stmt|;
name|int
name|bit_address
decl_stmt|,
name|free_page
decl_stmt|,
name|free_bit
decl_stmt|;
name|u_int16_t
name|ndx
decl_stmt|;
name|addr
operator|=
name|obufp
operator|->
name|addr
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG1
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Freeing %d\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ndx
operator|=
operator|(
operator|(
operator|(
name|u_int16_t
operator|)
name|addr
operator|)
operator|>>
name|SPLITSHIFT
operator|)
expr_stmt|;
name|bit_address
operator|=
operator|(
name|ndx
condition|?
name|hashp
operator|->
name|SPARES
index|[
name|ndx
operator|-
literal|1
index|]
else|:
literal|0
operator|)
operator|+
operator|(
name|addr
operator|&
name|SPLITMASK
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|bit_address
operator|<
name|hashp
operator|->
name|LAST_FREED
condition|)
name|hashp
operator|->
name|LAST_FREED
operator|=
name|bit_address
expr_stmt|;
name|free_page
operator|=
operator|(
name|bit_address
operator|>>
operator|(
name|hashp
operator|->
name|BSHIFT
operator|+
name|BYTE_SHIFT
operator|)
operator|)
expr_stmt|;
name|free_bit
operator|=
name|bit_address
operator|&
operator|(
operator|(
name|hashp
operator|->
name|BSIZE
operator|<<
name|BYTE_SHIFT
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|freep
operator|=
name|hashp
operator|->
name|mapp
index|[
name|free_page
index|]
operator|)
condition|)
name|freep
operator|=
name|fetch_bitmap
argument_list|(
name|hashp
argument_list|,
name|free_page
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/* 	 * This had better never happen.  It means we tried to read a bitmap 	 * that has already had overflow pages allocated off it, and we 	 * failed to read it from the file. 	 */
if|if
condition|(
operator|!
name|freep
condition|)
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|CLRBIT
argument_list|(
name|freep
argument_list|,
name|free_bit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG2
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"FREE_OVFLPAGE: ADDR: %d BIT: %d PAGE %d\n"
argument_list|,
name|obufp
operator|->
name|addr
argument_list|,
name|free_bit
argument_list|,
name|free_page
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|__reclaim_buf
argument_list|(
name|hashp
argument_list|,
name|obufp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns:  *	 0 success  *	-1 failure  */
end_comment

begin_function
specifier|static
name|int
name|open_temp
parameter_list|(
name|hashp
parameter_list|)
name|HTAB
modifier|*
name|hashp
decl_stmt|;
block|{
name|sigset_t
name|set
decl_stmt|,
name|oset
decl_stmt|;
specifier|static
name|char
name|namestr
index|[]
init|=
literal|"_hashXXXXXX"
decl_stmt|;
comment|/* Block signals; make sure file goes away at process exit. */
operator|(
name|void
operator|)
name|sigfillset
argument_list|(
operator|&
name|set
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|_sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|set
argument_list|,
operator|&
name|oset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hashp
operator|->
name|fp
operator|=
name|mkstemp
argument_list|(
name|namestr
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|namestr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|_fcntl
argument_list|(
name|hashp
operator|->
name|fp
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|_sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|oset
argument_list|,
operator|(
name|sigset_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|hashp
operator|->
name|fp
operator|!=
operator|-
literal|1
condition|?
literal|0
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We have to know that the key will fit, but the last entry on the page is  * an overflow pair, so we need to shift things.  */
end_comment

begin_function
specifier|static
name|void
name|squeeze_key
parameter_list|(
name|sp
parameter_list|,
name|key
parameter_list|,
name|val
parameter_list|)
name|u_int16_t
modifier|*
name|sp
decl_stmt|;
specifier|const
name|DBT
modifier|*
name|key
decl_stmt|,
decl|*
name|val
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|u_int16_t
name|free_space
decl_stmt|,
name|n
decl_stmt|,
name|off
decl_stmt|,
name|pageno
decl_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|sp
expr_stmt|;
name|n
operator|=
name|sp
index|[
literal|0
index|]
expr_stmt|;
name|free_space
operator|=
name|FREESPACE
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|off
operator|=
name|OFFSET
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|pageno
operator|=
name|sp
index|[
name|n
operator|-
literal|1
index|]
expr_stmt|;
name|off
operator|-=
name|key
operator|->
name|size
expr_stmt|;
name|sp
index|[
name|n
operator|-
literal|1
index|]
operator|=
name|off
expr_stmt|;
name|memmove
argument_list|(
name|p
operator|+
name|off
argument_list|,
name|key
operator|->
name|data
argument_list|,
name|key
operator|->
name|size
argument_list|)
expr_stmt|;
name|off
operator|-=
name|val
operator|->
name|size
expr_stmt|;
name|sp
index|[
name|n
index|]
operator|=
name|off
expr_stmt|;
name|memmove
argument_list|(
name|p
operator|+
name|off
argument_list|,
name|val
operator|->
name|data
argument_list|,
name|val
operator|->
name|size
argument_list|)
expr_stmt|;
name|sp
index|[
literal|0
index|]
operator|=
name|n
operator|+
literal|2
expr_stmt|;
name|sp
index|[
name|n
operator|+
literal|1
index|]
operator|=
name|pageno
expr_stmt|;
name|sp
index|[
name|n
operator|+
literal|2
index|]
operator|=
name|OVFLPAGE
expr_stmt|;
name|FREESPACE
argument_list|(
name|sp
argument_list|)
operator|=
name|free_space
operator|-
name|PAIRSIZE
argument_list|(
name|key
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|OFFSET
argument_list|(
name|sp
argument_list|)
operator|=
name|off
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|u_int32_t
modifier|*
name|fetch_bitmap
parameter_list|(
name|hashp
parameter_list|,
name|ndx
parameter_list|)
name|HTAB
modifier|*
name|hashp
decl_stmt|;
name|int
name|ndx
decl_stmt|;
block|{
if|if
condition|(
name|ndx
operator|>=
name|hashp
operator|->
name|nmaps
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|(
name|hashp
operator|->
name|mapp
index|[
name|ndx
index|]
operator|=
operator|(
name|u_int32_t
operator|*
operator|)
name|malloc
argument_list|(
name|hashp
operator|->
name|BSIZE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|__get_page
argument_list|(
name|hashp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|hashp
operator|->
name|mapp
index|[
name|ndx
index|]
argument_list|,
name|hashp
operator|->
name|BITMAPS
index|[
name|ndx
index|]
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|free
argument_list|(
name|hashp
operator|->
name|mapp
index|[
name|ndx
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|hashp
operator|->
name|mapp
index|[
name|ndx
index|]
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG4
end_ifdef

begin_function
name|int
name|print_chain
parameter_list|(
name|addr
parameter_list|)
name|int
name|addr
decl_stmt|;
block|{
name|BUFHEAD
modifier|*
name|bufp
decl_stmt|;
name|short
modifier|*
name|bp
decl_stmt|,
name|oaddr
decl_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d "
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|__get_buf
argument_list|(
name|hashp
argument_list|,
name|addr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bp
operator|=
operator|(
name|short
operator|*
operator|)
name|bufp
operator|->
name|page
expr_stmt|;
while|while
condition|(
name|bp
index|[
literal|0
index|]
operator|&&
operator|(
operator|(
name|bp
index|[
name|bp
index|[
literal|0
index|]
index|]
operator|==
name|OVFLPAGE
operator|)
operator|||
operator|(
operator|(
name|bp
index|[
literal|0
index|]
operator|>
literal|2
operator|)
operator|&&
name|bp
index|[
literal|2
index|]
operator|<
name|REAL_KEY
operator|)
operator|)
condition|)
block|{
name|oaddr
operator|=
name|bp
index|[
name|bp
index|[
literal|0
index|]
operator|-
literal|1
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d "
argument_list|,
operator|(
name|int
operator|)
name|oaddr
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|__get_buf
argument_list|(
name|hashp
argument_list|,
operator|(
name|int
operator|)
name|oaddr
argument_list|,
name|bufp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bp
operator|=
operator|(
name|short
operator|*
operator|)
name|bufp
operator|->
name|page
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

