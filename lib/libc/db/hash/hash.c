begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Margo Seltzer.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)hash.c	8.9 (Berkeley) 6/16/94"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBC_SCCS and not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<db.h>
end_include

begin_include
include|#
directive|include
file|"hash.h"
end_include

begin_include
include|#
directive|include
file|"page.h"
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|alloc_segs
name|__P
argument_list|(
operator|(
name|HTAB
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|flush_meta
name|__P
argument_list|(
operator|(
name|HTAB
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hash_access
name|__P
argument_list|(
operator|(
name|HTAB
operator|*
operator|,
name|ACTION
operator|,
name|DBT
operator|*
operator|,
name|DBT
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hash_close
name|__P
argument_list|(
operator|(
name|DB
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hash_delete
name|__P
argument_list|(
operator|(
specifier|const
name|DB
operator|*
operator|,
specifier|const
name|DBT
operator|*
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hash_fd
name|__P
argument_list|(
operator|(
specifier|const
name|DB
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hash_get
name|__P
argument_list|(
operator|(
specifier|const
name|DB
operator|*
operator|,
specifier|const
name|DBT
operator|*
operator|,
name|DBT
operator|*
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hash_put
name|__P
argument_list|(
operator|(
specifier|const
name|DB
operator|*
operator|,
name|DBT
operator|*
operator|,
specifier|const
name|DBT
operator|*
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|hash_realloc
name|__P
argument_list|(
operator|(
name|SEGMENT
operator|*
operator|*
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hash_seq
name|__P
argument_list|(
operator|(
specifier|const
name|DB
operator|*
operator|,
name|DBT
operator|*
operator|,
name|DBT
operator|*
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hash_sync
name|__P
argument_list|(
operator|(
specifier|const
name|DB
operator|*
operator|,
name|u_int32_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|hdestroy
name|__P
argument_list|(
operator|(
name|HTAB
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|HTAB
modifier|*
name|init_hash
name|__P
argument_list|(
operator|(
name|HTAB
operator|*
operator|,
specifier|const
name|char
operator|*
operator|,
name|HASHINFO
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|init_htab
name|__P
argument_list|(
operator|(
name|HTAB
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|BYTE_ORDER
operator|==
name|LITTLE_ENDIAN
end_if

begin_decl_stmt
specifier|static
name|void
name|swap_header
name|__P
argument_list|(
operator|(
name|HTAB
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|swap_header_copy
name|__P
argument_list|(
operator|(
name|HASHHDR
operator|*
operator|,
name|HASHHDR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Fast arithmetic, relying on powers of 2, */
end_comment

begin_define
define|#
directive|define
name|MOD
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x)& ((y) - 1))
end_define

begin_define
define|#
directive|define
name|RETURN_ERROR
parameter_list|(
name|ERR
parameter_list|,
name|LOC
parameter_list|)
value|{ save_errno = ERR; goto LOC; }
end_define

begin_comment
comment|/* Return values */
end_comment

begin_define
define|#
directive|define
name|SUCCESS
value|(0)
end_define

begin_define
define|#
directive|define
name|ERROR
value|(-1)
end_define

begin_define
define|#
directive|define
name|ABNORMAL
value|(1)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|HASH_STATISTICS
end_ifdef

begin_decl_stmt
name|int
name|hash_accesses
decl_stmt|,
name|hash_collisions
decl_stmt|,
name|hash_expansions
decl_stmt|,
name|hash_overflows
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/************************** INTERFACE ROUTINES ***************************/
end_comment

begin_comment
comment|/* OPEN/CLOSE */
end_comment

begin_function
specifier|extern
name|DB
modifier|*
name|__hash_open
parameter_list|(
name|file
parameter_list|,
name|flags
parameter_list|,
name|mode
parameter_list|,
name|info
parameter_list|,
name|dflags
parameter_list|)
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|flags
decl_stmt|,
name|mode
decl_stmt|,
name|dflags
decl_stmt|;
specifier|const
name|HASHINFO
modifier|*
name|info
decl_stmt|;
comment|/* Special directives for create */
block|{
name|HTAB
modifier|*
name|hashp
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|DB
modifier|*
name|dbp
decl_stmt|;
name|int
name|bpages
decl_stmt|,
name|hdrsize
decl_stmt|,
name|new_table
decl_stmt|,
name|nsegs
decl_stmt|,
name|save_errno
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_WRONLY
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|hashp
operator|=
operator|(
name|HTAB
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|HTAB
argument_list|)
argument_list|)
operator|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|hashp
operator|->
name|fp
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 	 * Even if user wants write only, we need to be able to read 	 * the actual file, so we need to open it read/write. But, the 	 * field in the hashp structure needs to be accurate so that 	 * we can check accesses. 	 */
name|hashp
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|new_table
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|file
operator|||
operator|(
name|flags
operator|&
name|O_TRUNC
operator|)
operator|||
operator|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|&&
operator|(
name|errno
operator|==
name|ENOENT
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* Just in case someone looks at errno */
name|new_table
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|file
condition|)
block|{
if|if
condition|(
operator|(
name|hashp
operator|->
name|fp
operator|=
name|open
argument_list|(
name|file
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
name|RETURN_ERROR
argument_list|(
name|errno
argument_list|,
name|error0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|hashp
operator|->
name|fp
argument_list|,
name|F_SETFD
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|new_table
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|hashp
operator|=
name|init_hash
argument_list|(
name|hashp
argument_list|,
name|file
argument_list|,
operator|(
name|HASHINFO
operator|*
operator|)
name|info
argument_list|)
operator|)
condition|)
name|RETURN_ERROR
argument_list|(
name|errno
argument_list|,
name|error1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Table already exists */
if|if
condition|(
name|info
operator|&&
name|info
operator|->
name|hash
condition|)
name|hashp
operator|->
name|hash
operator|=
name|info
operator|->
name|hash
expr_stmt|;
else|else
name|hashp
operator|->
name|hash
operator|=
name|__default_hash
expr_stmt|;
name|hdrsize
operator|=
name|read
argument_list|(
name|hashp
operator|->
name|fp
argument_list|,
operator|&
name|hashp
operator|->
name|hdr
argument_list|,
sizeof|sizeof
argument_list|(
name|HASHHDR
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|BYTE_ORDER
operator|==
name|LITTLE_ENDIAN
name|swap_header
argument_list|(
name|hashp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hdrsize
operator|==
operator|-
literal|1
condition|)
name|RETURN_ERROR
argument_list|(
name|errno
argument_list|,
name|error1
argument_list|)
expr_stmt|;
if|if
condition|(
name|hdrsize
operator|!=
sizeof|sizeof
argument_list|(
name|HASHHDR
argument_list|)
condition|)
name|RETURN_ERROR
argument_list|(
name|EFTYPE
argument_list|,
name|error1
argument_list|)
expr_stmt|;
comment|/* Verify file type, versions and hash function */
if|if
condition|(
name|hashp
operator|->
name|MAGIC
operator|!=
name|HASHMAGIC
condition|)
name|RETURN_ERROR
argument_list|(
name|EFTYPE
argument_list|,
name|error1
argument_list|)
expr_stmt|;
define|#
directive|define
name|OLDHASHVERSION
value|1
if|if
condition|(
name|hashp
operator|->
name|VERSION
operator|!=
name|HASHVERSION
operator|&&
name|hashp
operator|->
name|VERSION
operator|!=
name|OLDHASHVERSION
condition|)
name|RETURN_ERROR
argument_list|(
name|EFTYPE
argument_list|,
name|error1
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashp
operator|->
name|hash
argument_list|(
name|CHARKEY
argument_list|,
sizeof|sizeof
argument_list|(
name|CHARKEY
argument_list|)
argument_list|)
operator|!=
name|hashp
operator|->
name|H_CHARKEY
condition|)
name|RETURN_ERROR
argument_list|(
name|EFTYPE
argument_list|,
name|error1
argument_list|)
expr_stmt|;
comment|/* 		 * Figure out how many segments we need.  Max_Bucket is the 		 * maximum bucket number, so the number of buckets is 		 * max_bucket + 1. 		 */
name|nsegs
operator|=
operator|(
name|hashp
operator|->
name|MAX_BUCKET
operator|+
literal|1
operator|+
name|hashp
operator|->
name|SGSIZE
operator|-
literal|1
operator|)
operator|/
name|hashp
operator|->
name|SGSIZE
expr_stmt|;
name|hashp
operator|->
name|nsegs
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|alloc_segs
argument_list|(
name|hashp
argument_list|,
name|nsegs
argument_list|)
condition|)
comment|/* 			 * If alloc_segs fails, table will have been destroyed 			 * and errno will have been set. 			 */
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Read in bitmaps */
name|bpages
operator|=
operator|(
name|hashp
operator|->
name|SPARES
index|[
name|hashp
operator|->
name|OVFL_POINT
index|]
operator|+
operator|(
name|hashp
operator|->
name|BSIZE
operator|<<
name|BYTE_SHIFT
operator|)
operator|-
literal|1
operator|)
operator|>>
operator|(
name|hashp
operator|->
name|BSHIFT
operator|+
name|BYTE_SHIFT
operator|)
expr_stmt|;
name|hashp
operator|->
name|nmaps
operator|=
name|bpages
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|&
name|hashp
operator|->
name|mapp
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|,
name|bpages
operator|*
sizeof|sizeof
argument_list|(
name|u_int32_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize Buffer Manager */
if|if
condition|(
name|info
operator|&&
name|info
operator|->
name|cachesize
condition|)
name|__buf_init
argument_list|(
name|hashp
argument_list|,
name|info
operator|->
name|cachesize
argument_list|)
expr_stmt|;
else|else
name|__buf_init
argument_list|(
name|hashp
argument_list|,
name|DEF_BUFSIZE
argument_list|)
expr_stmt|;
name|hashp
operator|->
name|new_file
operator|=
name|new_table
expr_stmt|;
name|hashp
operator|->
name|save_file
operator|=
name|file
operator|&&
operator|(
name|hashp
operator|->
name|flags
operator|&
name|O_RDWR
operator|)
expr_stmt|;
name|hashp
operator|->
name|cbucket
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dbp
operator|=
operator|(
name|DB
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|DB
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|save_errno
operator|=
name|errno
expr_stmt|;
name|hdestroy
argument_list|(
name|hashp
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|dbp
operator|->
name|internal
operator|=
name|hashp
expr_stmt|;
name|dbp
operator|->
name|close
operator|=
name|hash_close
expr_stmt|;
name|dbp
operator|->
name|del
operator|=
name|hash_delete
expr_stmt|;
name|dbp
operator|->
name|fd
operator|=
name|hash_fd
expr_stmt|;
name|dbp
operator|->
name|get
operator|=
name|hash_get
expr_stmt|;
name|dbp
operator|->
name|put
operator|=
name|hash_put
expr_stmt|;
name|dbp
operator|->
name|seq
operator|=
name|hash_seq
expr_stmt|;
name|dbp
operator|->
name|sync
operator|=
name|hash_sync
expr_stmt|;
name|dbp
operator|->
name|type
operator|=
name|DB_HASH
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n%s%x\n%s%d\n%s%d\n%s%d\n%s%d\n%s%d\n%s%d\n%s%d\n%s%d\n%s%d\n%s%x\n%s%x\n%s%d\n%s%d\n"
argument_list|,
literal|"init_htab:"
argument_list|,
literal|"TABLE POINTER   "
argument_list|,
name|hashp
argument_list|,
literal|"BUCKET SIZE     "
argument_list|,
name|hashp
operator|->
name|BSIZE
argument_list|,
literal|"BUCKET SHIFT    "
argument_list|,
name|hashp
operator|->
name|BSHIFT
argument_list|,
literal|"DIRECTORY SIZE  "
argument_list|,
name|hashp
operator|->
name|DSIZE
argument_list|,
literal|"SEGMENT SIZE    "
argument_list|,
name|hashp
operator|->
name|SGSIZE
argument_list|,
literal|"SEGMENT SHIFT   "
argument_list|,
name|hashp
operator|->
name|SSHIFT
argument_list|,
literal|"FILL FACTOR     "
argument_list|,
name|hashp
operator|->
name|FFACTOR
argument_list|,
literal|"MAX BUCKET      "
argument_list|,
name|hashp
operator|->
name|MAX_BUCKET
argument_list|,
literal|"OVFL POINT	     "
argument_list|,
name|hashp
operator|->
name|OVFL_POINT
argument_list|,
literal|"LAST FREED      "
argument_list|,
name|hashp
operator|->
name|LAST_FREED
argument_list|,
literal|"HIGH MASK       "
argument_list|,
name|hashp
operator|->
name|HIGH_MASK
argument_list|,
literal|"LOW  MASK       "
argument_list|,
name|hashp
operator|->
name|LOW_MASK
argument_list|,
literal|"NSEGS           "
argument_list|,
name|hashp
operator|->
name|nsegs
argument_list|,
literal|"NKEYS           "
argument_list|,
name|hashp
operator|->
name|NKEYS
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HASH_STATISTICS
name|hash_overflows
operator|=
name|hash_accesses
operator|=
name|hash_collisions
operator|=
name|hash_expansions
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|dbp
operator|)
return|;
name|error1
label|:
if|if
condition|(
name|hashp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|hashp
operator|->
name|fp
argument_list|)
expr_stmt|;
name|error0
label|:
name|free
argument_list|(
name|hashp
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hash_close
parameter_list|(
name|dbp
parameter_list|)
name|DB
modifier|*
name|dbp
decl_stmt|;
block|{
name|HTAB
modifier|*
name|hashp
decl_stmt|;
name|int
name|retval
decl_stmt|;
if|if
condition|(
operator|!
name|dbp
condition|)
return|return
operator|(
name|ERROR
operator|)
return|;
name|hashp
operator|=
operator|(
name|HTAB
operator|*
operator|)
name|dbp
operator|->
name|internal
expr_stmt|;
name|retval
operator|=
name|hdestroy
argument_list|(
name|hashp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dbp
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hash_fd
parameter_list|(
name|dbp
parameter_list|)
specifier|const
name|DB
modifier|*
name|dbp
decl_stmt|;
block|{
name|HTAB
modifier|*
name|hashp
decl_stmt|;
if|if
condition|(
operator|!
name|dbp
condition|)
return|return
operator|(
name|ERROR
operator|)
return|;
name|hashp
operator|=
operator|(
name|HTAB
operator|*
operator|)
name|dbp
operator|->
name|internal
expr_stmt|;
if|if
condition|(
name|hashp
operator|->
name|fp
operator|==
operator|-
literal|1
condition|)
block|{
name|errno
operator|=
name|ENOENT
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|hashp
operator|->
name|fp
operator|)
return|;
block|}
end_function

begin_comment
comment|/************************** LOCAL CREATION ROUTINES **********************/
end_comment

begin_function
specifier|static
name|HTAB
modifier|*
name|init_hash
parameter_list|(
name|hashp
parameter_list|,
name|file
parameter_list|,
name|info
parameter_list|)
name|HTAB
modifier|*
name|hashp
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|HASHINFO
modifier|*
name|info
decl_stmt|;
block|{
name|struct
name|stat
name|statbuf
decl_stmt|;
name|int
name|nelem
decl_stmt|;
name|nelem
operator|=
literal|1
expr_stmt|;
name|hashp
operator|->
name|NKEYS
operator|=
literal|0
expr_stmt|;
name|hashp
operator|->
name|LORDER
operator|=
name|BYTE_ORDER
expr_stmt|;
name|hashp
operator|->
name|BSIZE
operator|=
name|DEF_BUCKET_SIZE
expr_stmt|;
name|hashp
operator|->
name|BSHIFT
operator|=
name|DEF_BUCKET_SHIFT
expr_stmt|;
name|hashp
operator|->
name|SGSIZE
operator|=
name|DEF_SEGSIZE
expr_stmt|;
name|hashp
operator|->
name|SSHIFT
operator|=
name|DEF_SEGSIZE_SHIFT
expr_stmt|;
name|hashp
operator|->
name|DSIZE
operator|=
name|DEF_DIRSIZE
expr_stmt|;
name|hashp
operator|->
name|FFACTOR
operator|=
name|DEF_FFACTOR
expr_stmt|;
name|hashp
operator|->
name|hash
operator|=
name|__default_hash
expr_stmt|;
name|memset
argument_list|(
name|hashp
operator|->
name|SPARES
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hashp
operator|->
name|SPARES
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|hashp
operator|->
name|BITMAPS
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hashp
operator|->
name|BITMAPS
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fix bucket size to be optimal for file system */
if|if
condition|(
name|file
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|statbuf
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|hashp
operator|->
name|BSIZE
operator|=
name|statbuf
operator|.
name|st_blksize
expr_stmt|;
name|hashp
operator|->
name|BSHIFT
operator|=
name|__log2
argument_list|(
name|hashp
operator|->
name|BSIZE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|bsize
condition|)
block|{
comment|/* Round pagesize up to power of 2 */
name|hashp
operator|->
name|BSHIFT
operator|=
name|__log2
argument_list|(
name|info
operator|->
name|bsize
argument_list|)
expr_stmt|;
name|hashp
operator|->
name|BSIZE
operator|=
literal|1
operator|<<
name|hashp
operator|->
name|BSHIFT
expr_stmt|;
if|if
condition|(
name|hashp
operator|->
name|BSIZE
operator|>
name|MAX_BSIZE
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|info
operator|->
name|ffactor
condition|)
name|hashp
operator|->
name|FFACTOR
operator|=
name|info
operator|->
name|ffactor
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|hash
condition|)
name|hashp
operator|->
name|hash
operator|=
name|info
operator|->
name|hash
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|nelem
condition|)
name|nelem
operator|=
name|info
operator|->
name|nelem
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|lorder
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|lorder
operator|!=
name|BIG_ENDIAN
operator|&&
name|info
operator|->
name|lorder
operator|!=
name|LITTLE_ENDIAN
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|hashp
operator|->
name|LORDER
operator|=
name|info
operator|->
name|lorder
expr_stmt|;
block|}
block|}
comment|/* init_htab should destroy the table and set errno if it fails */
if|if
condition|(
name|init_htab
argument_list|(
name|hashp
argument_list|,
name|nelem
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
return|return
operator|(
name|hashp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This calls alloc_segs which may run out of memory.  Alloc_segs will destroy  * the table and set errno, so we just pass the error information along.  *  * Returns 0 on No Error  */
end_comment

begin_function
specifier|static
name|int
name|init_htab
parameter_list|(
name|hashp
parameter_list|,
name|nelem
parameter_list|)
name|HTAB
modifier|*
name|hashp
decl_stmt|;
name|int
name|nelem
decl_stmt|;
block|{
specifier|register
name|int
name|nbuckets
decl_stmt|,
name|nsegs
decl_stmt|;
name|int
name|l2
decl_stmt|;
comment|/* 	 * Divide number of elements by the fill factor and determine a 	 * desired number of buckets.  Allocate space for the next greater 	 * power of two number of buckets. 	 */
name|nelem
operator|=
operator|(
name|nelem
operator|-
literal|1
operator|)
operator|/
name|hashp
operator|->
name|FFACTOR
operator|+
literal|1
expr_stmt|;
name|l2
operator|=
name|__log2
argument_list|(
name|MAX
argument_list|(
name|nelem
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|nbuckets
operator|=
literal|1
operator|<<
name|l2
expr_stmt|;
name|hashp
operator|->
name|SPARES
index|[
name|l2
index|]
operator|=
name|l2
operator|+
literal|1
expr_stmt|;
name|hashp
operator|->
name|SPARES
index|[
name|l2
operator|+
literal|1
index|]
operator|=
name|l2
operator|+
literal|1
expr_stmt|;
name|hashp
operator|->
name|OVFL_POINT
operator|=
name|l2
expr_stmt|;
name|hashp
operator|->
name|LAST_FREED
operator|=
literal|2
expr_stmt|;
comment|/* First bitmap page is at: splitpoint l2 page offset 1 */
if|if
condition|(
name|__ibitmap
argument_list|(
name|hashp
argument_list|,
name|OADDR_OF
argument_list|(
name|l2
argument_list|,
literal|1
argument_list|)
argument_list|,
name|l2
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|hashp
operator|->
name|MAX_BUCKET
operator|=
name|hashp
operator|->
name|LOW_MASK
operator|=
name|nbuckets
operator|-
literal|1
expr_stmt|;
name|hashp
operator|->
name|HIGH_MASK
operator|=
operator|(
name|nbuckets
operator|<<
literal|1
operator|)
operator|-
literal|1
expr_stmt|;
name|hashp
operator|->
name|HDRPAGES
operator|=
operator|(
operator|(
name|MAX
argument_list|(
sizeof|sizeof
argument_list|(
name|HASHHDR
argument_list|)
argument_list|,
name|MINHDRSIZE
argument_list|)
operator|-
literal|1
operator|)
operator|>>
name|hashp
operator|->
name|BSHIFT
operator|)
operator|+
literal|1
expr_stmt|;
name|nsegs
operator|=
operator|(
name|nbuckets
operator|-
literal|1
operator|)
operator|/
name|hashp
operator|->
name|SGSIZE
operator|+
literal|1
expr_stmt|;
name|nsegs
operator|=
literal|1
operator|<<
name|__log2
argument_list|(
name|nsegs
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsegs
operator|>
name|hashp
operator|->
name|DSIZE
condition|)
name|hashp
operator|->
name|DSIZE
operator|=
name|nsegs
expr_stmt|;
return|return
operator|(
name|alloc_segs
argument_list|(
name|hashp
argument_list|,
name|nsegs
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/********************** DESTROY/CLOSE ROUTINES ************************/
end_comment

begin_comment
comment|/*  * Flushes any changes to the file if necessary and destroys the hashp  * structure, freeing all allocated space.  */
end_comment

begin_function
specifier|static
name|int
name|hdestroy
parameter_list|(
name|hashp
parameter_list|)
name|HTAB
modifier|*
name|hashp
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|save_errno
decl_stmt|;
name|save_errno
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|HASH_STATISTICS
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"hdestroy: accesses %ld collisions %ld\n"
argument_list|,
name|hash_accesses
argument_list|,
name|hash_collisions
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"hdestroy: expansions %ld\n"
argument_list|,
name|hash_expansions
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"hdestroy: overflows %ld\n"
argument_list|,
name|hash_overflows
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"keys %ld maxp %d segmentcount %d\n"
argument_list|,
name|hashp
operator|->
name|NKEYS
argument_list|,
name|hashp
operator|->
name|MAX_BUCKET
argument_list|,
name|hashp
operator|->
name|nsegs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCACHED
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"spares[%d] = %d\n"
argument_list|,
name|i
argument_list|,
name|hashp
operator|->
name|SPARES
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Call on buffer manager to free buffers, and if required, 	 * write them to disk. 	 */
if|if
condition|(
name|__buf_free
argument_list|(
name|hashp
argument_list|,
literal|1
argument_list|,
name|hashp
operator|->
name|save_file
argument_list|)
condition|)
name|save_errno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
name|hashp
operator|->
name|dir
condition|)
block|{
name|free
argument_list|(
operator|*
name|hashp
operator|->
name|dir
argument_list|)
expr_stmt|;
comment|/* Free initial segments */
comment|/* Free extra segments */
while|while
condition|(
name|hashp
operator|->
name|exsegs
operator|--
condition|)
name|free
argument_list|(
name|hashp
operator|->
name|dir
index|[
operator|--
name|hashp
operator|->
name|nsegs
index|]
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hashp
operator|->
name|dir
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flush_meta
argument_list|(
name|hashp
argument_list|)
operator|&&
operator|!
name|save_errno
condition|)
name|save_errno
operator|=
name|errno
expr_stmt|;
comment|/* Free Bigmaps */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hashp
operator|->
name|nmaps
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|hashp
operator|->
name|mapp
index|[
name|i
index|]
condition|)
name|free
argument_list|(
name|hashp
operator|->
name|mapp
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|hashp
operator|->
name|fp
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|hashp
operator|->
name|fp
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hashp
argument_list|)
expr_stmt|;
if|if
condition|(
name|save_errno
condition|)
block|{
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
return|return
operator|(
name|SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write modified pages to disk  *  * Returns:  *	 0 == OK  *	-1 ERROR  */
end_comment

begin_function
specifier|static
name|int
name|hash_sync
parameter_list|(
name|dbp
parameter_list|,
name|flags
parameter_list|)
specifier|const
name|DB
modifier|*
name|dbp
decl_stmt|;
name|u_int32_t
name|flags
decl_stmt|;
block|{
name|HTAB
modifier|*
name|hashp
decl_stmt|;
if|if
condition|(
name|flags
operator|!=
literal|0
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|dbp
condition|)
return|return
operator|(
name|ERROR
operator|)
return|;
name|hashp
operator|=
operator|(
name|HTAB
operator|*
operator|)
name|dbp
operator|->
name|internal
expr_stmt|;
if|if
condition|(
operator|!
name|hashp
operator|->
name|save_file
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|__buf_free
argument_list|(
name|hashp
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
operator|||
name|flush_meta
argument_list|(
name|hashp
argument_list|)
condition|)
return|return
operator|(
name|ERROR
operator|)
return|;
name|hashp
operator|->
name|new_file
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns:  *	 0 == OK  *	-1 indicates that errno should be set  */
end_comment

begin_function
specifier|static
name|int
name|flush_meta
parameter_list|(
name|hashp
parameter_list|)
name|HTAB
modifier|*
name|hashp
decl_stmt|;
block|{
name|HASHHDR
modifier|*
name|whdrp
decl_stmt|;
if|#
directive|if
name|BYTE_ORDER
operator|==
name|LITTLE_ENDIAN
name|HASHHDR
name|whdr
decl_stmt|;
endif|#
directive|endif
name|int
name|fp
decl_stmt|,
name|i
decl_stmt|,
name|wsize
decl_stmt|;
if|if
condition|(
operator|!
name|hashp
operator|->
name|save_file
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|hashp
operator|->
name|MAGIC
operator|=
name|HASHMAGIC
expr_stmt|;
name|hashp
operator|->
name|VERSION
operator|=
name|HASHVERSION
expr_stmt|;
name|hashp
operator|->
name|H_CHARKEY
operator|=
name|hashp
operator|->
name|hash
argument_list|(
name|CHARKEY
argument_list|,
sizeof|sizeof
argument_list|(
name|CHARKEY
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|=
name|hashp
operator|->
name|fp
expr_stmt|;
name|whdrp
operator|=
operator|&
name|hashp
operator|->
name|hdr
expr_stmt|;
if|#
directive|if
name|BYTE_ORDER
operator|==
name|LITTLE_ENDIAN
name|whdrp
operator|=
operator|&
name|whdr
expr_stmt|;
name|swap_header_copy
argument_list|(
operator|&
name|hashp
operator|->
name|hdr
argument_list|,
name|whdrp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|lseek
argument_list|(
name|fp
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
operator|(
name|wsize
operator|=
name|write
argument_list|(
name|fp
argument_list|,
name|whdrp
argument_list|,
sizeof|sizeof
argument_list|(
name|HASHHDR
argument_list|)
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|wsize
operator|!=
sizeof|sizeof
argument_list|(
name|HASHHDR
argument_list|)
condition|)
block|{
name|errno
operator|=
name|EFTYPE
expr_stmt|;
name|hashp
operator|->
name|errno
operator|=
name|errno
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCACHED
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|hashp
operator|->
name|mapp
index|[
name|i
index|]
condition|)
if|if
condition|(
name|__put_page
argument_list|(
name|hashp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|hashp
operator|->
name|mapp
index|[
name|i
index|]
argument_list|,
name|hashp
operator|->
name|BITMAPS
index|[
name|i
index|]
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*******************************SEARCH ROUTINES *****************************/
end_comment

begin_comment
comment|/*  * All the access routines return  *  * Returns:  *	 0 on SUCCESS  *	 1 to indicate an external ERROR (i.e. key not found, etc)  *	-1 to indicate an internal ERROR (i.e. out of memory, etc)  */
end_comment

begin_function
specifier|static
name|int
name|hash_get
parameter_list|(
name|dbp
parameter_list|,
name|key
parameter_list|,
name|data
parameter_list|,
name|flag
parameter_list|)
specifier|const
name|DB
modifier|*
name|dbp
decl_stmt|;
specifier|const
name|DBT
modifier|*
name|key
decl_stmt|;
name|DBT
modifier|*
name|data
decl_stmt|;
name|u_int32_t
name|flag
decl_stmt|;
block|{
name|HTAB
modifier|*
name|hashp
decl_stmt|;
name|hashp
operator|=
operator|(
name|HTAB
operator|*
operator|)
name|dbp
operator|->
name|internal
expr_stmt|;
if|if
condition|(
name|flag
condition|)
block|{
name|hashp
operator|->
name|errno
operator|=
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
return|return
operator|(
name|hash_access
argument_list|(
name|hashp
argument_list|,
name|HASH_GET
argument_list|,
operator|(
name|DBT
operator|*
operator|)
name|key
argument_list|,
name|data
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hash_put
parameter_list|(
name|dbp
parameter_list|,
name|key
parameter_list|,
name|data
parameter_list|,
name|flag
parameter_list|)
specifier|const
name|DB
modifier|*
name|dbp
decl_stmt|;
name|DBT
modifier|*
name|key
decl_stmt|;
specifier|const
name|DBT
modifier|*
name|data
decl_stmt|;
name|u_int32_t
name|flag
decl_stmt|;
block|{
name|HTAB
modifier|*
name|hashp
decl_stmt|;
name|hashp
operator|=
operator|(
name|HTAB
operator|*
operator|)
name|dbp
operator|->
name|internal
expr_stmt|;
if|if
condition|(
name|flag
operator|&&
name|flag
operator|!=
name|R_NOOVERWRITE
condition|)
block|{
name|hashp
operator|->
name|errno
operator|=
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|hashp
operator|->
name|flags
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_RDONLY
condition|)
block|{
name|hashp
operator|->
name|errno
operator|=
name|errno
operator|=
name|EPERM
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
return|return
operator|(
name|hash_access
argument_list|(
name|hashp
argument_list|,
name|flag
operator|==
name|R_NOOVERWRITE
condition|?
name|HASH_PUTNEW
else|:
name|HASH_PUT
argument_list|,
operator|(
name|DBT
operator|*
operator|)
name|key
argument_list|,
operator|(
name|DBT
operator|*
operator|)
name|data
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hash_delete
parameter_list|(
name|dbp
parameter_list|,
name|key
parameter_list|,
name|flag
parameter_list|)
specifier|const
name|DB
modifier|*
name|dbp
decl_stmt|;
specifier|const
name|DBT
modifier|*
name|key
decl_stmt|;
name|u_int32_t
name|flag
decl_stmt|;
comment|/* Ignored */
block|{
name|HTAB
modifier|*
name|hashp
decl_stmt|;
name|hashp
operator|=
operator|(
name|HTAB
operator|*
operator|)
name|dbp
operator|->
name|internal
expr_stmt|;
if|if
condition|(
name|flag
operator|&&
name|flag
operator|!=
name|R_CURSOR
condition|)
block|{
name|hashp
operator|->
name|errno
operator|=
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|hashp
operator|->
name|flags
operator|&
name|O_ACCMODE
operator|)
operator|==
name|O_RDONLY
condition|)
block|{
name|hashp
operator|->
name|errno
operator|=
name|errno
operator|=
name|EPERM
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
return|return
operator|(
name|hash_access
argument_list|(
name|hashp
argument_list|,
name|HASH_DELETE
argument_list|,
operator|(
name|DBT
operator|*
operator|)
name|key
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Assume that hashp has been set in wrapper routine.  */
end_comment

begin_function
specifier|static
name|int
name|hash_access
parameter_list|(
name|hashp
parameter_list|,
name|action
parameter_list|,
name|key
parameter_list|,
name|val
parameter_list|)
name|HTAB
modifier|*
name|hashp
decl_stmt|;
name|ACTION
name|action
decl_stmt|;
name|DBT
modifier|*
name|key
decl_stmt|,
decl|*
name|val
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|BUFHEAD
modifier|*
name|rbufp
decl_stmt|;
name|BUFHEAD
modifier|*
name|bufp
decl_stmt|,
modifier|*
name|save_bufp
decl_stmt|;
specifier|register
name|u_int16_t
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|,
name|ndx
decl_stmt|,
name|off
decl_stmt|,
name|size
decl_stmt|;
specifier|register
name|char
modifier|*
name|kp
decl_stmt|;
name|u_int16_t
name|pageno
decl_stmt|;
ifdef|#
directive|ifdef
name|HASH_STATISTICS
name|hash_accesses
operator|++
expr_stmt|;
endif|#
directive|endif
name|off
operator|=
name|hashp
operator|->
name|BSIZE
expr_stmt|;
name|size
operator|=
name|key
operator|->
name|size
expr_stmt|;
name|kp
operator|=
operator|(
name|char
operator|*
operator|)
name|key
operator|->
name|data
expr_stmt|;
name|rbufp
operator|=
name|__get_buf
argument_list|(
name|hashp
argument_list|,
name|__call_hash
argument_list|(
name|hashp
argument_list|,
name|kp
argument_list|,
name|size
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rbufp
condition|)
return|return
operator|(
name|ERROR
operator|)
return|;
name|save_bufp
operator|=
name|rbufp
expr_stmt|;
comment|/* Pin the bucket chain */
name|rbufp
operator|->
name|flags
operator||=
name|BUF_PIN
expr_stmt|;
for|for
control|(
name|bp
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|rbufp
operator|->
name|page
operator|,
name|n
operator|=
operator|*
name|bp
operator|++
operator|,
name|ndx
operator|=
literal|1
init|;
name|ndx
operator|<
name|n
condition|;
control|)
if|if
condition|(
name|bp
index|[
literal|1
index|]
operator|>=
name|REAL_KEY
condition|)
block|{
comment|/* Real key/data pair */
if|if
condition|(
name|size
operator|==
name|off
operator|-
operator|*
name|bp
operator|&&
name|memcmp
argument_list|(
name|kp
argument_list|,
name|rbufp
operator|->
name|page
operator|+
operator|*
name|bp
argument_list|,
name|size
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|found
goto|;
name|off
operator|=
name|bp
index|[
literal|1
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|HASH_STATISTICS
name|hash_collisions
operator|++
expr_stmt|;
endif|#
directive|endif
name|bp
operator|+=
literal|2
expr_stmt|;
name|ndx
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bp
index|[
literal|1
index|]
operator|==
name|OVFLPAGE
condition|)
block|{
name|rbufp
operator|=
name|__get_buf
argument_list|(
name|hashp
argument_list|,
operator|*
name|bp
argument_list|,
name|rbufp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rbufp
condition|)
block|{
name|save_bufp
operator|->
name|flags
operator|&=
operator|~
name|BUF_PIN
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
comment|/* FOR LOOP INIT */
name|bp
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|rbufp
operator|->
name|page
expr_stmt|;
name|n
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|ndx
operator|=
literal|1
expr_stmt|;
name|off
operator|=
name|hashp
operator|->
name|BSIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|bp
index|[
literal|1
index|]
operator|<
name|REAL_KEY
condition|)
block|{
if|if
condition|(
operator|(
name|ndx
operator|=
name|__find_bigpair
argument_list|(
name|hashp
argument_list|,
name|rbufp
argument_list|,
name|ndx
argument_list|,
name|kp
argument_list|,
name|size
argument_list|)
operator|)
operator|>
literal|0
condition|)
goto|goto
name|found
goto|;
if|if
condition|(
name|ndx
operator|==
operator|-
literal|2
condition|)
block|{
name|bufp
operator|=
name|rbufp
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pageno
operator|=
name|__find_last_page
argument_list|(
name|hashp
argument_list|,
operator|&
name|bufp
argument_list|)
operator|)
condition|)
block|{
name|ndx
operator|=
literal|0
expr_stmt|;
name|rbufp
operator|=
name|bufp
expr_stmt|;
break|break;
comment|/* FOR */
block|}
name|rbufp
operator|=
name|__get_buf
argument_list|(
name|hashp
argument_list|,
name|pageno
argument_list|,
name|bufp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rbufp
condition|)
block|{
name|save_bufp
operator|->
name|flags
operator|&=
operator|~
name|BUF_PIN
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
comment|/* FOR LOOP INIT */
name|bp
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|rbufp
operator|->
name|page
expr_stmt|;
name|n
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
name|ndx
operator|=
literal|1
expr_stmt|;
name|off
operator|=
name|hashp
operator|->
name|BSIZE
expr_stmt|;
block|}
else|else
block|{
name|save_bufp
operator|->
name|flags
operator|&=
operator|~
name|BUF_PIN
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
block|}
comment|/* Not found */
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|HASH_PUT
case|:
case|case
name|HASH_PUTNEW
case|:
if|if
condition|(
name|__addel
argument_list|(
name|hashp
argument_list|,
name|rbufp
argument_list|,
name|key
argument_list|,
name|val
argument_list|)
condition|)
block|{
name|save_bufp
operator|->
name|flags
operator|&=
operator|~
name|BUF_PIN
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
else|else
block|{
name|save_bufp
operator|->
name|flags
operator|&=
operator|~
name|BUF_PIN
expr_stmt|;
return|return
operator|(
name|SUCCESS
operator|)
return|;
block|}
case|case
name|HASH_GET
case|:
case|case
name|HASH_DELETE
case|:
default|default:
name|save_bufp
operator|->
name|flags
operator|&=
operator|~
name|BUF_PIN
expr_stmt|;
return|return
operator|(
name|ABNORMAL
operator|)
return|;
block|}
name|found
label|:
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|HASH_PUTNEW
case|:
name|save_bufp
operator|->
name|flags
operator|&=
operator|~
name|BUF_PIN
expr_stmt|;
return|return
operator|(
name|ABNORMAL
operator|)
return|;
case|case
name|HASH_GET
case|:
name|bp
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|rbufp
operator|->
name|page
expr_stmt|;
if|if
condition|(
name|bp
index|[
name|ndx
operator|+
literal|1
index|]
operator|<
name|REAL_KEY
condition|)
block|{
if|if
condition|(
name|__big_return
argument_list|(
name|hashp
argument_list|,
name|rbufp
argument_list|,
name|ndx
argument_list|,
name|val
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
else|else
block|{
name|val
operator|->
name|data
operator|=
operator|(
name|u_char
operator|*
operator|)
name|rbufp
operator|->
name|page
operator|+
operator|(
name|int
operator|)
name|bp
index|[
name|ndx
operator|+
literal|1
index|]
expr_stmt|;
name|val
operator|->
name|size
operator|=
name|bp
index|[
name|ndx
index|]
operator|-
name|bp
index|[
name|ndx
operator|+
literal|1
index|]
expr_stmt|;
block|}
break|break;
case|case
name|HASH_PUT
case|:
if|if
condition|(
operator|(
name|__delpair
argument_list|(
name|hashp
argument_list|,
name|rbufp
argument_list|,
name|ndx
argument_list|)
operator|)
operator|||
operator|(
name|__addel
argument_list|(
name|hashp
argument_list|,
name|rbufp
argument_list|,
name|key
argument_list|,
name|val
argument_list|)
operator|)
condition|)
block|{
name|save_bufp
operator|->
name|flags
operator|&=
operator|~
name|BUF_PIN
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
break|break;
case|case
name|HASH_DELETE
case|:
if|if
condition|(
name|__delpair
argument_list|(
name|hashp
argument_list|,
name|rbufp
argument_list|,
name|ndx
argument_list|)
condition|)
return|return
operator|(
name|ERROR
operator|)
return|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
name|save_bufp
operator|->
name|flags
operator|&=
operator|~
name|BUF_PIN
expr_stmt|;
return|return
operator|(
name|SUCCESS
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|hash_seq
parameter_list|(
name|dbp
parameter_list|,
name|key
parameter_list|,
name|data
parameter_list|,
name|flag
parameter_list|)
specifier|const
name|DB
modifier|*
name|dbp
decl_stmt|;
name|DBT
modifier|*
name|key
decl_stmt|,
decl|*
name|data
decl_stmt|;
end_function

begin_decl_stmt
name|u_int32_t
name|flag
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|u_int32_t
name|bucket
decl_stmt|;
specifier|register
name|BUFHEAD
modifier|*
name|bufp
decl_stmt|;
name|HTAB
modifier|*
name|hashp
decl_stmt|;
name|u_int16_t
modifier|*
name|bp
decl_stmt|,
name|ndx
decl_stmt|;
name|hashp
operator|=
operator|(
name|HTAB
operator|*
operator|)
name|dbp
operator|->
name|internal
expr_stmt|;
if|if
condition|(
name|flag
operator|&&
name|flag
operator|!=
name|R_FIRST
operator|&&
name|flag
operator|!=
name|R_NEXT
condition|)
block|{
name|hashp
operator|->
name|errno
operator|=
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|HASH_STATISTICS
name|hash_accesses
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|hashp
operator|->
name|cbucket
operator|<
literal|0
operator|)
operator|||
operator|(
name|flag
operator|==
name|R_FIRST
operator|)
condition|)
block|{
name|hashp
operator|->
name|cbucket
operator|=
literal|0
expr_stmt|;
name|hashp
operator|->
name|cndx
operator|=
literal|1
expr_stmt|;
name|hashp
operator|->
name|cpage
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|bp
operator|=
name|NULL
init|;
operator|!
name|bp
operator|||
operator|!
name|bp
index|[
literal|0
index|]
condition|;
control|)
block|{
if|if
condition|(
operator|!
operator|(
name|bufp
operator|=
name|hashp
operator|->
name|cpage
operator|)
condition|)
block|{
for|for
control|(
name|bucket
operator|=
name|hashp
operator|->
name|cbucket
init|;
name|bucket
operator|<=
name|hashp
operator|->
name|MAX_BUCKET
condition|;
name|bucket
operator|++
operator|,
name|hashp
operator|->
name|cndx
operator|=
literal|1
control|)
block|{
name|bufp
operator|=
name|__get_buf
argument_list|(
name|hashp
argument_list|,
name|bucket
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bufp
condition|)
return|return
operator|(
name|ERROR
operator|)
return|;
name|hashp
operator|->
name|cpage
operator|=
name|bufp
expr_stmt|;
name|bp
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|bufp
operator|->
name|page
expr_stmt|;
if|if
condition|(
name|bp
index|[
literal|0
index|]
condition|)
break|break;
block|}
name|hashp
operator|->
name|cbucket
operator|=
name|bucket
expr_stmt|;
if|if
condition|(
name|hashp
operator|->
name|cbucket
operator|>
name|hashp
operator|->
name|MAX_BUCKET
condition|)
block|{
name|hashp
operator|->
name|cbucket
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|ABNORMAL
operator|)
return|;
block|}
block|}
else|else
name|bp
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
name|hashp
operator|->
name|cpage
operator|->
name|page
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|assert
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|bufp
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|bp
index|[
name|hashp
operator|->
name|cndx
operator|+
literal|1
index|]
operator|==
name|OVFLPAGE
condition|)
block|{
name|bufp
operator|=
name|hashp
operator|->
name|cpage
operator|=
name|__get_buf
argument_list|(
name|hashp
argument_list|,
name|bp
index|[
name|hashp
operator|->
name|cndx
index|]
argument_list|,
name|bufp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bufp
condition|)
return|return
operator|(
name|ERROR
operator|)
return|;
name|bp
operator|=
operator|(
name|u_int16_t
operator|*
operator|)
operator|(
name|bufp
operator|->
name|page
operator|)
expr_stmt|;
name|hashp
operator|->
name|cndx
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bp
index|[
literal|0
index|]
condition|)
block|{
name|hashp
operator|->
name|cpage
operator|=
name|NULL
expr_stmt|;
operator|++
name|hashp
operator|->
name|cbucket
expr_stmt|;
block|}
block|}
name|ndx
operator|=
name|hashp
operator|->
name|cndx
expr_stmt|;
if|if
condition|(
name|bp
index|[
name|ndx
operator|+
literal|1
index|]
operator|<
name|REAL_KEY
condition|)
block|{
if|if
condition|(
name|__big_keydata
argument_list|(
name|hashp
argument_list|,
name|bufp
argument_list|,
name|key
argument_list|,
name|data
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
else|else
block|{
name|key
operator|->
name|data
operator|=
operator|(
name|u_char
operator|*
operator|)
name|hashp
operator|->
name|cpage
operator|->
name|page
operator|+
name|bp
index|[
name|ndx
index|]
expr_stmt|;
name|key
operator|->
name|size
operator|=
operator|(
name|ndx
operator|>
literal|1
condition|?
name|bp
index|[
name|ndx
operator|-
literal|1
index|]
else|:
name|hashp
operator|->
name|BSIZE
operator|)
operator|-
name|bp
index|[
name|ndx
index|]
expr_stmt|;
name|data
operator|->
name|data
operator|=
operator|(
name|u_char
operator|*
operator|)
name|hashp
operator|->
name|cpage
operator|->
name|page
operator|+
name|bp
index|[
name|ndx
operator|+
literal|1
index|]
expr_stmt|;
name|data
operator|->
name|size
operator|=
name|bp
index|[
name|ndx
index|]
operator|-
name|bp
index|[
name|ndx
operator|+
literal|1
index|]
expr_stmt|;
name|ndx
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|ndx
operator|>
name|bp
index|[
literal|0
index|]
condition|)
block|{
name|hashp
operator|->
name|cpage
operator|=
name|NULL
expr_stmt|;
name|hashp
operator|->
name|cbucket
operator|++
expr_stmt|;
name|hashp
operator|->
name|cndx
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|hashp
operator|->
name|cndx
operator|=
name|ndx
expr_stmt|;
block|}
return|return
operator|(
name|SUCCESS
operator|)
return|;
block|}
end_block

begin_comment
comment|/********************************* UTILITIES ************************/
end_comment

begin_comment
comment|/*  * Returns:  *	 0 ==> OK  *	-1 ==> Error  */
end_comment

begin_function
specifier|extern
name|int
name|__expand_table
parameter_list|(
name|hashp
parameter_list|)
name|HTAB
modifier|*
name|hashp
decl_stmt|;
block|{
name|u_int32_t
name|old_bucket
decl_stmt|,
name|new_bucket
decl_stmt|;
name|int
name|dirsize
decl_stmt|,
name|new_segnum
decl_stmt|,
name|spare_ndx
decl_stmt|;
ifdef|#
directive|ifdef
name|HASH_STATISTICS
name|hash_expansions
operator|++
expr_stmt|;
endif|#
directive|endif
name|new_bucket
operator|=
operator|++
name|hashp
operator|->
name|MAX_BUCKET
expr_stmt|;
name|old_bucket
operator|=
operator|(
name|hashp
operator|->
name|MAX_BUCKET
operator|&
name|hashp
operator|->
name|LOW_MASK
operator|)
expr_stmt|;
name|new_segnum
operator|=
name|new_bucket
operator|>>
name|hashp
operator|->
name|SSHIFT
expr_stmt|;
comment|/* Check if we need a new segment */
if|if
condition|(
name|new_segnum
operator|>=
name|hashp
operator|->
name|nsegs
condition|)
block|{
comment|/* Check if we need to expand directory */
if|if
condition|(
name|new_segnum
operator|>=
name|hashp
operator|->
name|DSIZE
condition|)
block|{
comment|/* Reallocate directory */
name|dirsize
operator|=
name|hashp
operator|->
name|DSIZE
operator|*
sizeof|sizeof
argument_list|(
name|SEGMENT
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hash_realloc
argument_list|(
operator|&
name|hashp
operator|->
name|dir
argument_list|,
name|dirsize
argument_list|,
name|dirsize
operator|<<
literal|1
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|hashp
operator|->
name|DSIZE
operator|=
name|dirsize
operator|<<
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|hashp
operator|->
name|dir
index|[
name|new_segnum
index|]
operator|=
operator|(
name|SEGMENT
operator|)
name|calloc
argument_list|(
name|hashp
operator|->
name|SGSIZE
argument_list|,
sizeof|sizeof
argument_list|(
name|SEGMENT
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|hashp
operator|->
name|exsegs
operator|++
expr_stmt|;
name|hashp
operator|->
name|nsegs
operator|++
expr_stmt|;
block|}
comment|/* 	 * If the split point is increasing (MAX_BUCKET's log base 2 	 * * increases), we need to copy the current contents of the spare 	 * split bucket to the next bucket. 	 */
name|spare_ndx
operator|=
name|__log2
argument_list|(
name|hashp
operator|->
name|MAX_BUCKET
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|spare_ndx
operator|>
name|hashp
operator|->
name|OVFL_POINT
condition|)
block|{
name|hashp
operator|->
name|SPARES
index|[
name|spare_ndx
index|]
operator|=
name|hashp
operator|->
name|SPARES
index|[
name|hashp
operator|->
name|OVFL_POINT
index|]
expr_stmt|;
name|hashp
operator|->
name|OVFL_POINT
operator|=
name|spare_ndx
expr_stmt|;
block|}
if|if
condition|(
name|new_bucket
operator|>
name|hashp
operator|->
name|HIGH_MASK
condition|)
block|{
comment|/* Starting a new doubling */
name|hashp
operator|->
name|LOW_MASK
operator|=
name|hashp
operator|->
name|HIGH_MASK
expr_stmt|;
name|hashp
operator|->
name|HIGH_MASK
operator|=
name|new_bucket
operator||
name|hashp
operator|->
name|LOW_MASK
expr_stmt|;
block|}
comment|/* Relocate records to the new bucket */
return|return
operator|(
name|__split_page
argument_list|(
name|hashp
argument_list|,
name|old_bucket
argument_list|,
name|new_bucket
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If realloc guarantees that the pointer is not destroyed if the realloc  * fails, then this routine can go away.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|hash_realloc
parameter_list|(
name|p_ptr
parameter_list|,
name|oldsize
parameter_list|,
name|newsize
parameter_list|)
name|SEGMENT
modifier|*
modifier|*
name|p_ptr
decl_stmt|;
name|int
name|oldsize
decl_stmt|,
name|newsize
decl_stmt|;
block|{
specifier|register
name|void
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|p
operator|=
name|malloc
argument_list|(
name|newsize
argument_list|)
condition|)
block|{
name|memmove
argument_list|(
name|p
argument_list|,
operator|*
name|p_ptr
argument_list|,
name|oldsize
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
operator|+
name|oldsize
argument_list|,
literal|0
argument_list|,
name|newsize
operator|-
name|oldsize
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|*
name|p_ptr
argument_list|)
expr_stmt|;
operator|*
name|p_ptr
operator|=
name|p
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_function
specifier|extern
name|u_int32_t
name|__call_hash
parameter_list|(
name|hashp
parameter_list|,
name|k
parameter_list|,
name|len
parameter_list|)
name|HTAB
modifier|*
name|hashp
decl_stmt|;
name|char
modifier|*
name|k
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|int
name|n
decl_stmt|,
name|bucket
decl_stmt|;
name|n
operator|=
name|hashp
operator|->
name|hash
argument_list|(
name|k
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bucket
operator|=
name|n
operator|&
name|hashp
operator|->
name|HIGH_MASK
expr_stmt|;
if|if
condition|(
name|bucket
operator|>
name|hashp
operator|->
name|MAX_BUCKET
condition|)
name|bucket
operator|=
name|bucket
operator|&
name|hashp
operator|->
name|LOW_MASK
expr_stmt|;
return|return
operator|(
name|bucket
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate segment table.  On error, destroy the table and set errno.  *  * Returns 0 on success  */
end_comment

begin_function
specifier|static
name|int
name|alloc_segs
parameter_list|(
name|hashp
parameter_list|,
name|nsegs
parameter_list|)
name|HTAB
modifier|*
name|hashp
decl_stmt|;
name|int
name|nsegs
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|SEGMENT
name|store
decl_stmt|;
name|int
name|save_errno
decl_stmt|;
if|if
condition|(
operator|(
name|hashp
operator|->
name|dir
operator|=
operator|(
name|SEGMENT
operator|*
operator|)
name|calloc
argument_list|(
name|hashp
operator|->
name|DSIZE
argument_list|,
sizeof|sizeof
argument_list|(
name|SEGMENT
operator|*
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|save_errno
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|hdestroy
argument_list|(
name|hashp
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Allocate segments */
if|if
condition|(
operator|(
name|store
operator|=
operator|(
name|SEGMENT
operator|)
name|calloc
argument_list|(
name|nsegs
operator|<<
name|hashp
operator|->
name|SSHIFT
argument_list|,
sizeof|sizeof
argument_list|(
name|SEGMENT
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|save_errno
operator|=
name|errno
expr_stmt|;
operator|(
name|void
operator|)
name|hdestroy
argument_list|(
name|hashp
argument_list|)
expr_stmt|;
name|errno
operator|=
name|save_errno
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nsegs
condition|;
name|i
operator|++
operator|,
name|hashp
operator|->
name|nsegs
operator|++
control|)
name|hashp
operator|->
name|dir
index|[
name|i
index|]
operator|=
operator|&
name|store
index|[
name|i
operator|<<
name|hashp
operator|->
name|SSHIFT
index|]
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|BYTE_ORDER
operator|==
name|LITTLE_ENDIAN
end_if

begin_comment
comment|/*  * Hashp->hdr needs to be byteswapped.  */
end_comment

begin_function
specifier|static
name|void
name|swap_header_copy
parameter_list|(
name|srcp
parameter_list|,
name|destp
parameter_list|)
name|HASHHDR
modifier|*
name|srcp
decl_stmt|,
decl|*
name|destp
decl_stmt|;
end_function

begin_block
block|{
name|int
name|i
decl_stmt|;
name|P_32_COPY
argument_list|(
name|srcp
operator|->
name|magic
argument_list|,
name|destp
operator|->
name|magic
argument_list|)
expr_stmt|;
name|P_32_COPY
argument_list|(
name|srcp
operator|->
name|version
argument_list|,
name|destp
operator|->
name|version
argument_list|)
expr_stmt|;
name|P_32_COPY
argument_list|(
name|srcp
operator|->
name|lorder
argument_list|,
name|destp
operator|->
name|lorder
argument_list|)
expr_stmt|;
name|P_32_COPY
argument_list|(
name|srcp
operator|->
name|bsize
argument_list|,
name|destp
operator|->
name|bsize
argument_list|)
expr_stmt|;
name|P_32_COPY
argument_list|(
name|srcp
operator|->
name|bshift
argument_list|,
name|destp
operator|->
name|bshift
argument_list|)
expr_stmt|;
name|P_32_COPY
argument_list|(
name|srcp
operator|->
name|dsize
argument_list|,
name|destp
operator|->
name|dsize
argument_list|)
expr_stmt|;
name|P_32_COPY
argument_list|(
name|srcp
operator|->
name|ssize
argument_list|,
name|destp
operator|->
name|ssize
argument_list|)
expr_stmt|;
name|P_32_COPY
argument_list|(
name|srcp
operator|->
name|sshift
argument_list|,
name|destp
operator|->
name|sshift
argument_list|)
expr_stmt|;
name|P_32_COPY
argument_list|(
name|srcp
operator|->
name|ovfl_point
argument_list|,
name|destp
operator|->
name|ovfl_point
argument_list|)
expr_stmt|;
name|P_32_COPY
argument_list|(
name|srcp
operator|->
name|last_freed
argument_list|,
name|destp
operator|->
name|last_freed
argument_list|)
expr_stmt|;
name|P_32_COPY
argument_list|(
name|srcp
operator|->
name|max_bucket
argument_list|,
name|destp
operator|->
name|max_bucket
argument_list|)
expr_stmt|;
name|P_32_COPY
argument_list|(
name|srcp
operator|->
name|high_mask
argument_list|,
name|destp
operator|->
name|high_mask
argument_list|)
expr_stmt|;
name|P_32_COPY
argument_list|(
name|srcp
operator|->
name|low_mask
argument_list|,
name|destp
operator|->
name|low_mask
argument_list|)
expr_stmt|;
name|P_32_COPY
argument_list|(
name|srcp
operator|->
name|ffactor
argument_list|,
name|destp
operator|->
name|ffactor
argument_list|)
expr_stmt|;
name|P_32_COPY
argument_list|(
name|srcp
operator|->
name|nkeys
argument_list|,
name|destp
operator|->
name|nkeys
argument_list|)
expr_stmt|;
name|P_32_COPY
argument_list|(
name|srcp
operator|->
name|hdrpages
argument_list|,
name|destp
operator|->
name|hdrpages
argument_list|)
expr_stmt|;
name|P_32_COPY
argument_list|(
name|srcp
operator|->
name|h_charkey
argument_list|,
name|destp
operator|->
name|h_charkey
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCACHED
condition|;
name|i
operator|++
control|)
block|{
name|P_32_COPY
argument_list|(
name|srcp
operator|->
name|spares
index|[
name|i
index|]
argument_list|,
name|destp
operator|->
name|spares
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|P_16_COPY
argument_list|(
name|srcp
operator|->
name|bitmaps
index|[
name|i
index|]
argument_list|,
name|destp
operator|->
name|bitmaps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
specifier|static
name|void
name|swap_header
parameter_list|(
name|hashp
parameter_list|)
name|HTAB
modifier|*
name|hashp
decl_stmt|;
block|{
name|HASHHDR
modifier|*
name|hdrp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|hdrp
operator|=
operator|&
name|hashp
operator|->
name|hdr
expr_stmt|;
name|M_32_SWAP
argument_list|(
name|hdrp
operator|->
name|magic
argument_list|)
expr_stmt|;
name|M_32_SWAP
argument_list|(
name|hdrp
operator|->
name|version
argument_list|)
expr_stmt|;
name|M_32_SWAP
argument_list|(
name|hdrp
operator|->
name|lorder
argument_list|)
expr_stmt|;
name|M_32_SWAP
argument_list|(
name|hdrp
operator|->
name|bsize
argument_list|)
expr_stmt|;
name|M_32_SWAP
argument_list|(
name|hdrp
operator|->
name|bshift
argument_list|)
expr_stmt|;
name|M_32_SWAP
argument_list|(
name|hdrp
operator|->
name|dsize
argument_list|)
expr_stmt|;
name|M_32_SWAP
argument_list|(
name|hdrp
operator|->
name|ssize
argument_list|)
expr_stmt|;
name|M_32_SWAP
argument_list|(
name|hdrp
operator|->
name|sshift
argument_list|)
expr_stmt|;
name|M_32_SWAP
argument_list|(
name|hdrp
operator|->
name|ovfl_point
argument_list|)
expr_stmt|;
name|M_32_SWAP
argument_list|(
name|hdrp
operator|->
name|last_freed
argument_list|)
expr_stmt|;
name|M_32_SWAP
argument_list|(
name|hdrp
operator|->
name|max_bucket
argument_list|)
expr_stmt|;
name|M_32_SWAP
argument_list|(
name|hdrp
operator|->
name|high_mask
argument_list|)
expr_stmt|;
name|M_32_SWAP
argument_list|(
name|hdrp
operator|->
name|low_mask
argument_list|)
expr_stmt|;
name|M_32_SWAP
argument_list|(
name|hdrp
operator|->
name|ffactor
argument_list|)
expr_stmt|;
name|M_32_SWAP
argument_list|(
name|hdrp
operator|->
name|nkeys
argument_list|)
expr_stmt|;
name|M_32_SWAP
argument_list|(
name|hdrp
operator|->
name|hdrpages
argument_list|)
expr_stmt|;
name|M_32_SWAP
argument_list|(
name|hdrp
operator|->
name|h_charkey
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCACHED
condition|;
name|i
operator|++
control|)
block|{
name|M_32_SWAP
argument_list|(
name|hdrp
operator|->
name|spares
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|M_16_SWAP
argument_list|(
name|hdrp
operator|->
name|bitmaps
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

