begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Mike Olson.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)bt_split.c	8.9 (Berkeley) 7/26/94"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBC_SCCS and not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<db.h>
end_include

begin_include
include|#
directive|include
file|"btree.h"
end_include

begin_function_decl
specifier|static
name|int
name|bt_broot
parameter_list|(
name|BTREE
modifier|*
parameter_list|,
name|PAGE
modifier|*
parameter_list|,
name|PAGE
modifier|*
parameter_list|,
name|PAGE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|PAGE
modifier|*
name|bt_page
parameter_list|(
name|BTREE
modifier|*
parameter_list|,
name|PAGE
modifier|*
parameter_list|,
name|PAGE
modifier|*
modifier|*
parameter_list|,
name|PAGE
modifier|*
modifier|*
parameter_list|,
name|indx_t
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bt_preserve
parameter_list|(
name|BTREE
modifier|*
parameter_list|,
name|pgno_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|PAGE
modifier|*
name|bt_psplit
parameter_list|(
name|BTREE
modifier|*
parameter_list|,
name|PAGE
modifier|*
parameter_list|,
name|PAGE
modifier|*
parameter_list|,
name|PAGE
modifier|*
parameter_list|,
name|indx_t
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|PAGE
modifier|*
name|bt_root
parameter_list|(
name|BTREE
modifier|*
parameter_list|,
name|PAGE
modifier|*
parameter_list|,
name|PAGE
modifier|*
modifier|*
parameter_list|,
name|PAGE
modifier|*
modifier|*
parameter_list|,
name|indx_t
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|bt_rroot
parameter_list|(
name|BTREE
modifier|*
parameter_list|,
name|PAGE
modifier|*
parameter_list|,
name|PAGE
modifier|*
parameter_list|,
name|PAGE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|recno_t
name|rec_total
parameter_list|(
name|PAGE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|STATISTICS
end_ifdef

begin_decl_stmt
name|u_long
name|bt_rootsplit
decl_stmt|,
name|bt_split
decl_stmt|,
name|bt_sortsplit
decl_stmt|,
name|bt_pfxsaved
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * __BT_SPLIT -- Split the tree.  *  * Parameters:  *	t:	tree  *	sp:	page to split  *	key:	key to insert  *	data:	data to insert  *	flags:	BIGKEY/BIGDATA flags  *	ilen:	insert length  *	skip:	index to leave open  *  * Returns:  *	RET_ERROR, RET_SUCCESS  */
end_comment

begin_function
name|int
name|__bt_split
parameter_list|(
name|t
parameter_list|,
name|sp
parameter_list|,
name|key
parameter_list|,
name|data
parameter_list|,
name|flags
parameter_list|,
name|ilen
parameter_list|,
name|argskip
parameter_list|)
name|BTREE
modifier|*
name|t
decl_stmt|;
name|PAGE
modifier|*
name|sp
decl_stmt|;
specifier|const
name|DBT
modifier|*
name|key
decl_stmt|,
decl|*
name|data
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|flags
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|ilen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32_t
name|argskip
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|BINTERNAL
modifier|*
name|bi
decl_stmt|;
name|BLEAF
modifier|*
name|bl
decl_stmt|,
modifier|*
name|tbl
decl_stmt|;
name|DBT
name|a
decl_stmt|,
name|b
decl_stmt|;
name|EPGNO
modifier|*
name|parent
decl_stmt|;
name|PAGE
modifier|*
name|h
decl_stmt|,
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|,
modifier|*
name|lchild
decl_stmt|,
modifier|*
name|rchild
decl_stmt|;
name|indx_t
name|nxtindex
decl_stmt|;
name|u_int16_t
name|skip
decl_stmt|;
name|u_int32_t
name|n
decl_stmt|,
name|nbytes
decl_stmt|,
name|nksize
decl_stmt|;
name|int
name|parentsplit
decl_stmt|;
name|char
modifier|*
name|dest
decl_stmt|;
comment|/* 	 * Split the page into two pages, l and r.  The split routines return 	 * a pointer to the page into which the key should be inserted and with 	 * skip set to the offset which should be used.  Additionally, l and r 	 * are pinned. 	 */
name|skip
operator|=
name|argskip
expr_stmt|;
name|h
operator|=
name|sp
operator|->
name|pgno
operator|==
name|P_ROOT
condition|?
name|bt_root
argument_list|(
name|t
argument_list|,
name|sp
argument_list|,
operator|&
name|l
argument_list|,
operator|&
name|r
argument_list|,
operator|&
name|skip
argument_list|,
name|ilen
argument_list|)
else|:
name|bt_page
argument_list|(
name|t
argument_list|,
name|sp
argument_list|,
operator|&
name|l
argument_list|,
operator|&
name|r
argument_list|,
operator|&
name|skip
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
comment|/* 	 * Insert the new key/data pair into the leaf page.  (Key inserts 	 * always cause a leaf page to split first.) 	 */
name|h
operator|->
name|linp
index|[
name|skip
index|]
operator|=
name|h
operator|->
name|upper
operator|-=
name|ilen
expr_stmt|;
name|dest
operator|=
operator|(
name|char
operator|*
operator|)
name|h
operator|+
name|h
operator|->
name|upper
expr_stmt|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|t
argument_list|,
name|R_RECNO
argument_list|)
condition|)
name|WR_RLEAF
argument_list|(
argument|dest
argument_list|,
argument|data
argument_list|,
argument|flags
argument_list|)
else|else
name|WR_BLEAF
argument_list|(
argument|dest
argument_list|,
argument|key
argument_list|,
argument|data
argument_list|,
argument|flags
argument_list|)
comment|/* If the root page was split, make it look right. */
if|if
condition|(
name|sp
operator|->
name|pgno
operator|==
name|P_ROOT
operator|&&
operator|(
name|F_ISSET
argument_list|(
name|t
argument_list|,
name|R_RECNO
argument_list|)
condition|?
name|bt_rroot
argument_list|(
name|t
argument_list|,
name|sp
argument_list|,
name|l
argument_list|,
name|r
argument_list|)
else|:
name|bt_broot
argument_list|(
name|t
argument_list|,
name|sp
argument_list|,
name|l
argument_list|,
name|r
argument_list|)
operator|)
operator|==
name|RET_ERROR
condition|)
goto|goto
name|err2
goto|;
comment|/* 	 * Now we walk the parent page stack -- a LIFO stack of the pages that 	 * were traversed when we searched for the page that split.  Each stack 	 * entry is a page number and a page index offset.  The offset is for 	 * the page traversed on the search.  We've just split a page, so we 	 * have to insert a new key into the parent page. 	 * 	 * If the insert into the parent page causes it to split, may have to 	 * continue splitting all the way up the tree.  We stop if the root 	 * splits or the page inserted into didn't have to split to hold the 	 * new key.  Some algorithms replace the key for the old page as well 	 * as the new page.  We don't, as there's no reason to believe that the 	 * first key on the old page is any better than the key we have, and, 	 * in the case of a key being placed at index 0 causing the split, the 	 * key is unavailable. 	 * 	 * There are a maximum of 5 pages pinned at any time.  We keep the left 	 * and right pages pinned while working on the parent.   The 5 are the 	 * two children, left parent and right parent (when the parent splits) 	 * and the root page or the overflow key page when calling bt_preserve. 	 * This code must make sure that all pins are released other than the 	 * root page or overflow page which is unlocked elsewhere. 	 */
while|while
condition|(
operator|(
name|parent
operator|=
name|BT_POP
argument_list|(
name|t
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|lchild
operator|=
name|l
expr_stmt|;
name|rchild
operator|=
name|r
expr_stmt|;
comment|/* Get the parent page. */
if|if
condition|(
operator|(
name|h
operator|=
name|mpool_get
argument_list|(
name|t
operator|->
name|bt_mp
argument_list|,
name|parent
operator|->
name|pgno
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err2
goto|;
comment|/* 		 * The new key goes ONE AFTER the index, because the split 		 * was to the right. 		 */
name|skip
operator|=
name|parent
operator|->
name|index
operator|+
literal|1
expr_stmt|;
comment|/* 		 * Calculate the space needed on the parent page. 		 * 		 * Prefix trees: space hack when inserting into BINTERNAL 		 * pages.  Retain only what's needed to distinguish between 		 * the new entry and the LAST entry on the page to its left. 		 * If the keys compare equal, retain the entire key.  Note, 		 * we don't touch overflow keys, and the entire key must be 		 * retained for the next-to-left most key on the leftmost 		 * page of each level, or the search will fail.  Applicable 		 * ONLY to internal pages that have leaf pages as children. 		 * Further reduction of the key between pairs of internal 		 * pages loses too much information. 		 */
switch|switch
condition|(
name|rchild
operator|->
name|flags
operator|&
name|P_TYPE
condition|)
block|{
case|case
name|P_BINTERNAL
case|:
name|bi
operator|=
name|GETBINTERNAL
argument_list|(
name|rchild
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|NBINTERNAL
argument_list|(
name|bi
operator|->
name|ksize
argument_list|)
expr_stmt|;
break|break;
case|case
name|P_BLEAF
case|:
name|bl
operator|=
name|GETBLEAF
argument_list|(
name|rchild
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|NBINTERNAL
argument_list|(
name|bl
operator|->
name|ksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|->
name|bt_pfx
operator|&&
operator|!
operator|(
name|bl
operator|->
name|flags
operator|&
name|P_BIGKEY
operator|)
operator|&&
operator|(
name|h
operator|->
name|prevpg
operator|!=
name|P_INVALID
operator|||
name|skip
operator|>
literal|1
operator|)
condition|)
block|{
name|tbl
operator|=
name|GETBLEAF
argument_list|(
name|lchild
argument_list|,
name|NEXTINDEX
argument_list|(
name|lchild
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|a
operator|.
name|size
operator|=
name|tbl
operator|->
name|ksize
expr_stmt|;
name|a
operator|.
name|data
operator|=
name|tbl
operator|->
name|bytes
expr_stmt|;
name|b
operator|.
name|size
operator|=
name|bl
operator|->
name|ksize
expr_stmt|;
name|b
operator|.
name|data
operator|=
name|bl
operator|->
name|bytes
expr_stmt|;
name|nksize
operator|=
name|t
operator|->
name|bt_pfx
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|n
operator|=
name|NBINTERNAL
argument_list|(
name|nksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
name|nbytes
condition|)
block|{
ifdef|#
directive|ifdef
name|STATISTICS
name|bt_pfxsaved
operator|+=
name|nbytes
operator|-
name|n
expr_stmt|;
endif|#
directive|endif
name|nbytes
operator|=
name|n
expr_stmt|;
block|}
else|else
name|nksize
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|nksize
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|P_RINTERNAL
case|:
case|case
name|P_RLEAF
case|:
name|nbytes
operator|=
name|NRINTERNAL
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Split the parent page if necessary or shift the indices. */
if|if
condition|(
name|h
operator|->
name|upper
operator|-
name|h
operator|->
name|lower
operator|<
name|nbytes
operator|+
sizeof|sizeof
argument_list|(
name|indx_t
argument_list|)
condition|)
block|{
name|sp
operator|=
name|h
expr_stmt|;
name|h
operator|=
name|h
operator|->
name|pgno
operator|==
name|P_ROOT
condition|?
name|bt_root
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
operator|&
name|l
argument_list|,
operator|&
name|r
argument_list|,
operator|&
name|skip
argument_list|,
name|nbytes
argument_list|)
else|:
name|bt_page
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
operator|&
name|l
argument_list|,
operator|&
name|r
argument_list|,
operator|&
name|skip
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
goto|goto
name|err1
goto|;
name|parentsplit
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|skip
operator|<
operator|(
name|nxtindex
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
operator|)
condition|)
name|memmove
argument_list|(
name|h
operator|->
name|linp
operator|+
name|skip
operator|+
literal|1
argument_list|,
name|h
operator|->
name|linp
operator|+
name|skip
argument_list|,
operator|(
name|nxtindex
operator|-
name|skip
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|indx_t
argument_list|)
argument_list|)
expr_stmt|;
name|h
operator|->
name|lower
operator|+=
sizeof|sizeof
argument_list|(
name|indx_t
argument_list|)
expr_stmt|;
name|parentsplit
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Insert the key into the parent page. */
switch|switch
condition|(
name|rchild
operator|->
name|flags
operator|&
name|P_TYPE
condition|)
block|{
case|case
name|P_BINTERNAL
case|:
name|h
operator|->
name|linp
index|[
name|skip
index|]
operator|=
name|h
operator|->
name|upper
operator|-=
name|nbytes
expr_stmt|;
name|dest
operator|=
operator|(
name|char
operator|*
operator|)
name|h
operator|+
name|h
operator|->
name|linp
index|[
name|skip
index|]
expr_stmt|;
name|memmove
argument_list|(
name|dest
argument_list|,
name|bi
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
operator|(
operator|(
name|BINTERNAL
operator|*
operator|)
name|dest
operator|)
operator|->
name|pgno
operator|=
name|rchild
operator|->
name|pgno
expr_stmt|;
break|break;
case|case
name|P_BLEAF
case|:
name|h
operator|->
name|linp
index|[
name|skip
index|]
operator|=
name|h
operator|->
name|upper
operator|-=
name|nbytes
expr_stmt|;
name|dest
operator|=
operator|(
name|char
operator|*
operator|)
name|h
operator|+
name|h
operator|->
name|linp
index|[
name|skip
index|]
expr_stmt|;
name|WR_BINTERNAL
argument_list|(
name|dest
argument_list|,
name|nksize
condition|?
name|nksize
else|:
name|bl
operator|->
name|ksize
argument_list|,
name|rchild
operator|->
name|pgno
argument_list|,
name|bl
operator|->
name|flags
operator|&
name|P_BIGKEY
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|dest
argument_list|,
name|bl
operator|->
name|bytes
argument_list|,
name|nksize
condition|?
name|nksize
else|:
name|bl
operator|->
name|ksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|bl
operator|->
name|flags
operator|&
name|P_BIGKEY
operator|&&
name|bt_preserve
argument_list|(
name|t
argument_list|,
operator|*
operator|(
name|pgno_t
operator|*
operator|)
name|bl
operator|->
name|bytes
argument_list|)
operator|==
name|RET_ERROR
condition|)
goto|goto
name|err1
goto|;
break|break;
case|case
name|P_RINTERNAL
case|:
comment|/* 			 * Update the left page count.  If split 			 * added at index 0, fix the correct page. 			 */
if|if
condition|(
name|skip
operator|>
literal|0
condition|)
name|dest
operator|=
operator|(
name|char
operator|*
operator|)
name|h
operator|+
name|h
operator|->
name|linp
index|[
name|skip
operator|-
literal|1
index|]
expr_stmt|;
else|else
name|dest
operator|=
operator|(
name|char
operator|*
operator|)
name|l
operator|+
name|l
operator|->
name|linp
index|[
name|NEXTINDEX
argument_list|(
name|l
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
operator|(
operator|(
name|RINTERNAL
operator|*
operator|)
name|dest
operator|)
operator|->
name|nrecs
operator|=
name|rec_total
argument_list|(
name|lchild
argument_list|)
expr_stmt|;
operator|(
operator|(
name|RINTERNAL
operator|*
operator|)
name|dest
operator|)
operator|->
name|pgno
operator|=
name|lchild
operator|->
name|pgno
expr_stmt|;
comment|/* Update the right page count. */
name|h
operator|->
name|linp
index|[
name|skip
index|]
operator|=
name|h
operator|->
name|upper
operator|-=
name|nbytes
expr_stmt|;
name|dest
operator|=
operator|(
name|char
operator|*
operator|)
name|h
operator|+
name|h
operator|->
name|linp
index|[
name|skip
index|]
expr_stmt|;
operator|(
operator|(
name|RINTERNAL
operator|*
operator|)
name|dest
operator|)
operator|->
name|nrecs
operator|=
name|rec_total
argument_list|(
name|rchild
argument_list|)
expr_stmt|;
operator|(
operator|(
name|RINTERNAL
operator|*
operator|)
name|dest
operator|)
operator|->
name|pgno
operator|=
name|rchild
operator|->
name|pgno
expr_stmt|;
break|break;
case|case
name|P_RLEAF
case|:
comment|/* 			 * Update the left page count.  If split 			 * added at index 0, fix the correct page. 			 */
if|if
condition|(
name|skip
operator|>
literal|0
condition|)
name|dest
operator|=
operator|(
name|char
operator|*
operator|)
name|h
operator|+
name|h
operator|->
name|linp
index|[
name|skip
operator|-
literal|1
index|]
expr_stmt|;
else|else
name|dest
operator|=
operator|(
name|char
operator|*
operator|)
name|l
operator|+
name|l
operator|->
name|linp
index|[
name|NEXTINDEX
argument_list|(
name|l
argument_list|)
operator|-
literal|1
index|]
expr_stmt|;
operator|(
operator|(
name|RINTERNAL
operator|*
operator|)
name|dest
operator|)
operator|->
name|nrecs
operator|=
name|NEXTINDEX
argument_list|(
name|lchild
argument_list|)
expr_stmt|;
operator|(
operator|(
name|RINTERNAL
operator|*
operator|)
name|dest
operator|)
operator|->
name|pgno
operator|=
name|lchild
operator|->
name|pgno
expr_stmt|;
comment|/* Update the right page count. */
name|h
operator|->
name|linp
index|[
name|skip
index|]
operator|=
name|h
operator|->
name|upper
operator|-=
name|nbytes
expr_stmt|;
name|dest
operator|=
operator|(
name|char
operator|*
operator|)
name|h
operator|+
name|h
operator|->
name|linp
index|[
name|skip
index|]
expr_stmt|;
operator|(
operator|(
name|RINTERNAL
operator|*
operator|)
name|dest
operator|)
operator|->
name|nrecs
operator|=
name|NEXTINDEX
argument_list|(
name|rchild
argument_list|)
expr_stmt|;
operator|(
operator|(
name|RINTERNAL
operator|*
operator|)
name|dest
operator|)
operator|->
name|pgno
operator|=
name|rchild
operator|->
name|pgno
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* Unpin the held pages. */
if|if
condition|(
operator|!
name|parentsplit
condition|)
block|{
name|mpool_put
argument_list|(
name|t
operator|->
name|bt_mp
argument_list|,
name|h
argument_list|,
name|MPOOL_DIRTY
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If the root page was split, make it look right. */
if|if
condition|(
name|sp
operator|->
name|pgno
operator|==
name|P_ROOT
operator|&&
operator|(
name|F_ISSET
argument_list|(
name|t
argument_list|,
name|R_RECNO
argument_list|)
condition|?
name|bt_rroot
argument_list|(
name|t
argument_list|,
name|sp
argument_list|,
name|l
argument_list|,
name|r
argument_list|)
else|:
name|bt_broot
argument_list|(
name|t
argument_list|,
name|sp
argument_list|,
name|l
argument_list|,
name|r
argument_list|)
operator|)
operator|==
name|RET_ERROR
condition|)
goto|goto
name|err1
goto|;
name|mpool_put
argument_list|(
name|t
operator|->
name|bt_mp
argument_list|,
name|lchild
argument_list|,
name|MPOOL_DIRTY
argument_list|)
expr_stmt|;
name|mpool_put
argument_list|(
name|t
operator|->
name|bt_mp
argument_list|,
name|rchild
argument_list|,
name|MPOOL_DIRTY
argument_list|)
expr_stmt|;
block|}
comment|/* Unpin the held pages. */
name|mpool_put
argument_list|(
name|t
operator|->
name|bt_mp
argument_list|,
name|l
argument_list|,
name|MPOOL_DIRTY
argument_list|)
expr_stmt|;
name|mpool_put
argument_list|(
name|t
operator|->
name|bt_mp
argument_list|,
name|r
argument_list|,
name|MPOOL_DIRTY
argument_list|)
expr_stmt|;
comment|/* Clear any pages left on the stack. */
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
comment|/* 	 * If something fails in the above loop we were already walking back 	 * up the tree and the tree is now inconsistent.  Nothing much we can 	 * do about it but release any memory we're holding. 	 */
name|err1
label|:
name|mpool_put
argument_list|(
name|t
operator|->
name|bt_mp
argument_list|,
name|lchild
argument_list|,
name|MPOOL_DIRTY
argument_list|)
expr_stmt|;
name|mpool_put
argument_list|(
name|t
operator|->
name|bt_mp
argument_list|,
name|rchild
argument_list|,
name|MPOOL_DIRTY
argument_list|)
expr_stmt|;
name|err2
label|:
name|mpool_put
argument_list|(
name|t
operator|->
name|bt_mp
argument_list|,
name|l
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mpool_put
argument_list|(
name|t
operator|->
name|bt_mp
argument_list|,
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|__dbpanic
argument_list|(
name|t
operator|->
name|bt_dbp
argument_list|)
expr_stmt|;
return|return
operator|(
name|RET_ERROR
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * BT_PAGE -- Split a non-root page of a btree.  *  * Parameters:  *	t:	tree  *	h:	root page  *	lp:	pointer to left page pointer  *	rp:	pointer to right page pointer  *	skip:	pointer to index to leave open  *	ilen:	insert length  *  * Returns:  *	Pointer to page in which to insert or NULL on error.  */
end_comment

begin_function
specifier|static
name|PAGE
modifier|*
name|bt_page
parameter_list|(
name|t
parameter_list|,
name|h
parameter_list|,
name|lp
parameter_list|,
name|rp
parameter_list|,
name|skip
parameter_list|,
name|ilen
parameter_list|)
name|BTREE
modifier|*
name|t
decl_stmt|;
name|PAGE
modifier|*
name|h
decl_stmt|,
decl|*
modifier|*
name|lp
decl_stmt|,
modifier|*
modifier|*
name|rp
decl_stmt|;
end_function

begin_decl_stmt
name|indx_t
modifier|*
name|skip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|ilen
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|PAGE
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|pgno_t
name|npg
decl_stmt|;
ifdef|#
directive|ifdef
name|STATISTICS
operator|++
name|bt_split
expr_stmt|;
endif|#
directive|endif
comment|/* Put the new right page for the split into place. */
if|if
condition|(
operator|(
name|r
operator|=
name|__bt_new
argument_list|(
name|t
argument_list|,
operator|&
name|npg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|r
operator|->
name|pgno
operator|=
name|npg
expr_stmt|;
name|r
operator|->
name|lower
operator|=
name|BTDATAOFF
expr_stmt|;
name|r
operator|->
name|upper
operator|=
name|t
operator|->
name|bt_psize
expr_stmt|;
name|r
operator|->
name|nextpg
operator|=
name|h
operator|->
name|nextpg
expr_stmt|;
name|r
operator|->
name|prevpg
operator|=
name|h
operator|->
name|pgno
expr_stmt|;
name|r
operator|->
name|flags
operator|=
name|h
operator|->
name|flags
operator|&
name|P_TYPE
expr_stmt|;
comment|/* 	 * If we're splitting the last page on a level because we're appending 	 * a key to it (skip is NEXTINDEX()), it's likely that the data is 	 * sorted.  Adding an empty page on the side of the level is less work 	 * and can push the fill factor much higher than normal.  If we're 	 * wrong it's no big deal, we'll just do the split the right way next 	 * time.  It may look like it's equally easy to do a similar hack for 	 * reverse sorted data, that is, split the tree left, but it's not. 	 * Don't even try. 	 */
if|if
condition|(
name|h
operator|->
name|nextpg
operator|==
name|P_INVALID
operator|&&
operator|*
name|skip
operator|==
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|STATISTICS
operator|++
name|bt_sortsplit
expr_stmt|;
endif|#
directive|endif
name|h
operator|->
name|nextpg
operator|=
name|r
operator|->
name|pgno
expr_stmt|;
name|r
operator|->
name|lower
operator|=
name|BTDATAOFF
operator|+
sizeof|sizeof
argument_list|(
name|indx_t
argument_list|)
expr_stmt|;
operator|*
name|skip
operator|=
literal|0
expr_stmt|;
operator|*
name|lp
operator|=
name|h
expr_stmt|;
operator|*
name|rp
operator|=
name|r
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
comment|/* Put the new left page for the split into place. */
if|if
condition|(
operator|(
name|l
operator|=
operator|(
name|PAGE
operator|*
operator|)
name|malloc
argument_list|(
name|t
operator|->
name|bt_psize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mpool_put
argument_list|(
name|t
operator|->
name|bt_mp
argument_list|,
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|PURIFY
name|memset
argument_list|(
name|l
argument_list|,
literal|0xff
argument_list|,
name|t
operator|->
name|bt_psize
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|l
operator|->
name|pgno
operator|=
name|h
operator|->
name|pgno
expr_stmt|;
name|l
operator|->
name|nextpg
operator|=
name|r
operator|->
name|pgno
expr_stmt|;
name|l
operator|->
name|prevpg
operator|=
name|h
operator|->
name|prevpg
expr_stmt|;
name|l
operator|->
name|lower
operator|=
name|BTDATAOFF
expr_stmt|;
name|l
operator|->
name|upper
operator|=
name|t
operator|->
name|bt_psize
expr_stmt|;
name|l
operator|->
name|flags
operator|=
name|h
operator|->
name|flags
operator|&
name|P_TYPE
expr_stmt|;
comment|/* Fix up the previous pointer of the page after the split page. */
if|if
condition|(
name|h
operator|->
name|nextpg
operator|!=
name|P_INVALID
condition|)
block|{
if|if
condition|(
operator|(
name|tp
operator|=
name|mpool_get
argument_list|(
name|t
operator|->
name|bt_mp
argument_list|,
name|h
operator|->
name|nextpg
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|l
argument_list|)
expr_stmt|;
comment|/* XXX mpool_free(t->bt_mp, r->pgno); */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|tp
operator|->
name|prevpg
operator|=
name|r
operator|->
name|pgno
expr_stmt|;
name|mpool_put
argument_list|(
name|t
operator|->
name|bt_mp
argument_list|,
name|tp
argument_list|,
name|MPOOL_DIRTY
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Split right.  The key/data pairs aren't sorted in the btree page so 	 * it's simpler to copy the data from the split page onto two new pages 	 * instead of copying half the data to the right page and compacting 	 * the left page in place.  Since the left page can't change, we have 	 * to swap the original and the allocated left page after the split. 	 */
name|tp
operator|=
name|bt_psplit
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|l
argument_list|,
name|r
argument_list|,
name|skip
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
comment|/* Move the new left page onto the old left page. */
name|memmove
argument_list|(
name|h
argument_list|,
name|l
argument_list|,
name|t
operator|->
name|bt_psize
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|==
name|l
condition|)
name|tp
operator|=
name|h
expr_stmt|;
name|free
argument_list|(
name|l
argument_list|)
expr_stmt|;
operator|*
name|lp
operator|=
name|h
expr_stmt|;
operator|*
name|rp
operator|=
name|r
expr_stmt|;
return|return
operator|(
name|tp
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * BT_ROOT -- Split the root page of a btree.  *  * Parameters:  *	t:	tree  *	h:	root page  *	lp:	pointer to left page pointer  *	rp:	pointer to right page pointer  *	skip:	pointer to index to leave open  *	ilen:	insert length  *  * Returns:  *	Pointer to page in which to insert or NULL on error.  */
end_comment

begin_function
specifier|static
name|PAGE
modifier|*
name|bt_root
parameter_list|(
name|t
parameter_list|,
name|h
parameter_list|,
name|lp
parameter_list|,
name|rp
parameter_list|,
name|skip
parameter_list|,
name|ilen
parameter_list|)
name|BTREE
modifier|*
name|t
decl_stmt|;
name|PAGE
modifier|*
name|h
decl_stmt|,
decl|*
modifier|*
name|lp
decl_stmt|,
modifier|*
modifier|*
name|rp
decl_stmt|;
end_function

begin_decl_stmt
name|indx_t
modifier|*
name|skip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|ilen
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|PAGE
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|pgno_t
name|lnpg
decl_stmt|,
name|rnpg
decl_stmt|;
ifdef|#
directive|ifdef
name|STATISTICS
operator|++
name|bt_split
expr_stmt|;
operator|++
name|bt_rootsplit
expr_stmt|;
endif|#
directive|endif
comment|/* Put the new left and right pages for the split into place. */
if|if
condition|(
operator|(
name|l
operator|=
name|__bt_new
argument_list|(
name|t
argument_list|,
operator|&
name|lnpg
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|r
operator|=
name|__bt_new
argument_list|(
name|t
argument_list|,
operator|&
name|rnpg
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|l
operator|->
name|pgno
operator|=
name|lnpg
expr_stmt|;
name|r
operator|->
name|pgno
operator|=
name|rnpg
expr_stmt|;
name|l
operator|->
name|nextpg
operator|=
name|r
operator|->
name|pgno
expr_stmt|;
name|r
operator|->
name|prevpg
operator|=
name|l
operator|->
name|pgno
expr_stmt|;
name|l
operator|->
name|prevpg
operator|=
name|r
operator|->
name|nextpg
operator|=
name|P_INVALID
expr_stmt|;
name|l
operator|->
name|lower
operator|=
name|r
operator|->
name|lower
operator|=
name|BTDATAOFF
expr_stmt|;
name|l
operator|->
name|upper
operator|=
name|r
operator|->
name|upper
operator|=
name|t
operator|->
name|bt_psize
expr_stmt|;
name|l
operator|->
name|flags
operator|=
name|r
operator|->
name|flags
operator|=
name|h
operator|->
name|flags
operator|&
name|P_TYPE
expr_stmt|;
comment|/* Split the root page. */
name|tp
operator|=
name|bt_psplit
argument_list|(
name|t
argument_list|,
name|h
argument_list|,
name|l
argument_list|,
name|r
argument_list|,
name|skip
argument_list|,
name|ilen
argument_list|)
expr_stmt|;
operator|*
name|lp
operator|=
name|l
expr_stmt|;
operator|*
name|rp
operator|=
name|r
expr_stmt|;
return|return
operator|(
name|tp
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * BT_RROOT -- Fix up the recno root page after it has been split.  *  * Parameters:  *	t:	tree  *	h:	root page  *	l:	left page  *	r:	right page  *  * Returns:  *	RET_ERROR, RET_SUCCESS  */
end_comment

begin_function
specifier|static
name|int
name|bt_rroot
parameter_list|(
name|t
parameter_list|,
name|h
parameter_list|,
name|l
parameter_list|,
name|r
parameter_list|)
name|BTREE
modifier|*
name|t
decl_stmt|;
name|PAGE
modifier|*
name|h
decl_stmt|,
decl|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|dest
decl_stmt|;
comment|/* Insert the left and right keys, set the header information. */
name|h
operator|->
name|linp
index|[
literal|0
index|]
operator|=
name|h
operator|->
name|upper
operator|=
name|t
operator|->
name|bt_psize
operator|-
name|NRINTERNAL
expr_stmt|;
name|dest
operator|=
operator|(
name|char
operator|*
operator|)
name|h
operator|+
name|h
operator|->
name|upper
expr_stmt|;
name|WR_RINTERNAL
argument_list|(
name|dest
argument_list|,
name|l
operator|->
name|flags
operator|&
name|P_RLEAF
condition|?
name|NEXTINDEX
argument_list|(
name|l
argument_list|)
else|:
name|rec_total
argument_list|(
name|l
argument_list|)
argument_list|,
name|l
operator|->
name|pgno
argument_list|)
expr_stmt|;
name|h
operator|->
name|linp
index|[
literal|1
index|]
operator|=
name|h
operator|->
name|upper
operator|-=
name|NRINTERNAL
expr_stmt|;
name|dest
operator|=
operator|(
name|char
operator|*
operator|)
name|h
operator|+
name|h
operator|->
name|upper
expr_stmt|;
name|WR_RINTERNAL
argument_list|(
name|dest
argument_list|,
name|r
operator|->
name|flags
operator|&
name|P_RLEAF
condition|?
name|NEXTINDEX
argument_list|(
name|r
argument_list|)
else|:
name|rec_total
argument_list|(
name|r
argument_list|)
argument_list|,
name|r
operator|->
name|pgno
argument_list|)
expr_stmt|;
name|h
operator|->
name|lower
operator|=
name|BTDATAOFF
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|indx_t
argument_list|)
expr_stmt|;
comment|/* Unpin the root page, set to recno internal page. */
name|h
operator|->
name|flags
operator|&=
operator|~
name|P_TYPE
expr_stmt|;
name|h
operator|->
name|flags
operator||=
name|P_RINTERNAL
expr_stmt|;
name|mpool_put
argument_list|(
name|t
operator|->
name|bt_mp
argument_list|,
name|h
argument_list|,
name|MPOOL_DIRTY
argument_list|)
expr_stmt|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * BT_BROOT -- Fix up the btree root page after it has been split.  *  * Parameters:  *	t:	tree  *	h:	root page  *	l:	left page  *	r:	right page  *  * Returns:  *	RET_ERROR, RET_SUCCESS  */
end_comment

begin_function
specifier|static
name|int
name|bt_broot
parameter_list|(
name|t
parameter_list|,
name|h
parameter_list|,
name|l
parameter_list|,
name|r
parameter_list|)
name|BTREE
modifier|*
name|t
decl_stmt|;
name|PAGE
modifier|*
name|h
decl_stmt|,
decl|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
end_function

begin_block
block|{
name|BINTERNAL
modifier|*
name|bi
decl_stmt|;
name|BLEAF
modifier|*
name|bl
decl_stmt|;
name|u_int32_t
name|nbytes
decl_stmt|;
name|char
modifier|*
name|dest
decl_stmt|;
comment|/* 	 * If the root page was a leaf page, change it into an internal page. 	 * We copy the key we split on (but not the key's data, in the case of 	 * a leaf page) to the new root page. 	 * 	 * The btree comparison code guarantees that the left-most key on any 	 * level of the tree is never used, so it doesn't need to be filled in. 	 */
name|nbytes
operator|=
name|NBINTERNAL
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|h
operator|->
name|linp
index|[
literal|0
index|]
operator|=
name|h
operator|->
name|upper
operator|=
name|t
operator|->
name|bt_psize
operator|-
name|nbytes
expr_stmt|;
name|dest
operator|=
operator|(
name|char
operator|*
operator|)
name|h
operator|+
name|h
operator|->
name|upper
expr_stmt|;
name|WR_BINTERNAL
argument_list|(
name|dest
argument_list|,
literal|0
argument_list|,
name|l
operator|->
name|pgno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|h
operator|->
name|flags
operator|&
name|P_TYPE
condition|)
block|{
case|case
name|P_BLEAF
case|:
name|bl
operator|=
name|GETBLEAF
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|NBINTERNAL
argument_list|(
name|bl
operator|->
name|ksize
argument_list|)
expr_stmt|;
name|h
operator|->
name|linp
index|[
literal|1
index|]
operator|=
name|h
operator|->
name|upper
operator|-=
name|nbytes
expr_stmt|;
name|dest
operator|=
operator|(
name|char
operator|*
operator|)
name|h
operator|+
name|h
operator|->
name|upper
expr_stmt|;
name|WR_BINTERNAL
argument_list|(
name|dest
argument_list|,
name|bl
operator|->
name|ksize
argument_list|,
name|r
operator|->
name|pgno
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
name|dest
argument_list|,
name|bl
operator|->
name|bytes
argument_list|,
name|bl
operator|->
name|ksize
argument_list|)
expr_stmt|;
comment|/* 		 * If the key is on an overflow page, mark the overflow chain 		 * so it isn't deleted when the leaf copy of the key is deleted. 		 */
if|if
condition|(
name|bl
operator|->
name|flags
operator|&
name|P_BIGKEY
operator|&&
name|bt_preserve
argument_list|(
name|t
argument_list|,
operator|*
operator|(
name|pgno_t
operator|*
operator|)
name|bl
operator|->
name|bytes
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
break|break;
case|case
name|P_BINTERNAL
case|:
name|bi
operator|=
name|GETBINTERNAL
argument_list|(
name|r
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|NBINTERNAL
argument_list|(
name|bi
operator|->
name|ksize
argument_list|)
expr_stmt|;
name|h
operator|->
name|linp
index|[
literal|1
index|]
operator|=
name|h
operator|->
name|upper
operator|-=
name|nbytes
expr_stmt|;
name|dest
operator|=
operator|(
name|char
operator|*
operator|)
name|h
operator|+
name|h
operator|->
name|upper
expr_stmt|;
name|memmove
argument_list|(
name|dest
argument_list|,
name|bi
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
operator|(
operator|(
name|BINTERNAL
operator|*
operator|)
name|dest
operator|)
operator|->
name|pgno
operator|=
name|r
operator|->
name|pgno
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* There are two keys on the page. */
name|h
operator|->
name|lower
operator|=
name|BTDATAOFF
operator|+
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|indx_t
argument_list|)
expr_stmt|;
comment|/* Unpin the root page, set to btree internal page. */
name|h
operator|->
name|flags
operator|&=
operator|~
name|P_TYPE
expr_stmt|;
name|h
operator|->
name|flags
operator||=
name|P_BINTERNAL
expr_stmt|;
name|mpool_put
argument_list|(
name|t
operator|->
name|bt_mp
argument_list|,
name|h
argument_list|,
name|MPOOL_DIRTY
argument_list|)
expr_stmt|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * BT_PSPLIT -- Do the real work of splitting the page.  *  * Parameters:  *	t:	tree  *	h:	page to be split  *	l:	page to put lower half of data  *	r:	page to put upper half of data  *	pskip:	pointer to index to leave open  *	ilen:	insert length  *  * Returns:  *	Pointer to page in which to insert.  */
end_comment

begin_function
specifier|static
name|PAGE
modifier|*
name|bt_psplit
parameter_list|(
name|t
parameter_list|,
name|h
parameter_list|,
name|l
parameter_list|,
name|r
parameter_list|,
name|pskip
parameter_list|,
name|ilen
parameter_list|)
name|BTREE
modifier|*
name|t
decl_stmt|;
name|PAGE
modifier|*
name|h
decl_stmt|,
decl|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
end_function

begin_decl_stmt
name|indx_t
modifier|*
name|pskip
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|ilen
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|BINTERNAL
modifier|*
name|bi
decl_stmt|;
name|BLEAF
modifier|*
name|bl
decl_stmt|;
name|CURSOR
modifier|*
name|c
decl_stmt|;
name|RLEAF
modifier|*
name|rl
decl_stmt|;
name|PAGE
modifier|*
name|rval
decl_stmt|;
name|void
modifier|*
name|src
decl_stmt|;
name|indx_t
name|full
decl_stmt|,
name|half
decl_stmt|,
name|nxt
decl_stmt|,
name|off
decl_stmt|,
name|skip
decl_stmt|,
name|top
decl_stmt|,
name|used
decl_stmt|;
name|u_int32_t
name|nbytes
decl_stmt|;
name|int
name|bigkeycnt
decl_stmt|,
name|isbigkey
decl_stmt|;
comment|/* 	 * Split the data to the left and right pages.  Leave the skip index 	 * open.  Additionally, make some effort not to split on an overflow 	 * key.  This makes internal page processing faster and can save 	 * space as overflow keys used by internal pages are never deleted. 	 */
name|bigkeycnt
operator|=
literal|0
expr_stmt|;
name|skip
operator|=
operator|*
name|pskip
expr_stmt|;
name|full
operator|=
name|t
operator|->
name|bt_psize
operator|-
name|BTDATAOFF
expr_stmt|;
name|half
operator|=
name|full
operator|/
literal|2
expr_stmt|;
name|used
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|nxt
operator|=
name|off
operator|=
literal|0
operator|,
name|top
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
init|;
name|nxt
operator|<
name|top
condition|;
operator|++
name|off
control|)
block|{
if|if
condition|(
name|skip
operator|==
name|off
condition|)
block|{
name|nbytes
operator|=
name|ilen
expr_stmt|;
name|isbigkey
operator|=
literal|0
expr_stmt|;
comment|/* XXX: not really known. */
block|}
else|else
switch|switch
condition|(
name|h
operator|->
name|flags
operator|&
name|P_TYPE
condition|)
block|{
case|case
name|P_BINTERNAL
case|:
name|src
operator|=
name|bi
operator|=
name|GETBINTERNAL
argument_list|(
name|h
argument_list|,
name|nxt
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|NBINTERNAL
argument_list|(
name|bi
operator|->
name|ksize
argument_list|)
expr_stmt|;
name|isbigkey
operator|=
name|bi
operator|->
name|flags
operator|&
name|P_BIGKEY
expr_stmt|;
break|break;
case|case
name|P_BLEAF
case|:
name|src
operator|=
name|bl
operator|=
name|GETBLEAF
argument_list|(
name|h
argument_list|,
name|nxt
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|NBLEAF
argument_list|(
name|bl
argument_list|)
expr_stmt|;
name|isbigkey
operator|=
name|bl
operator|->
name|flags
operator|&
name|P_BIGKEY
expr_stmt|;
break|break;
case|case
name|P_RINTERNAL
case|:
name|src
operator|=
name|GETRINTERNAL
argument_list|(
name|h
argument_list|,
name|nxt
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|NRINTERNAL
expr_stmt|;
name|isbigkey
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|P_RLEAF
case|:
name|src
operator|=
name|rl
operator|=
name|GETRLEAF
argument_list|(
name|h
argument_list|,
name|nxt
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|NRLEAF
argument_list|(
name|rl
argument_list|)
expr_stmt|;
name|isbigkey
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* 		 * If the key/data pairs are substantial fractions of the max 		 * possible size for the page, it's possible to get situations 		 * where we decide to try and copy too much onto the left page. 		 * Make sure that doesn't happen. 		 */
if|if
condition|(
operator|(
name|skip
operator|<=
name|off
operator|&&
name|used
operator|+
name|nbytes
operator|+
sizeof|sizeof
argument_list|(
name|indx_t
argument_list|)
operator|>=
name|full
operator|)
operator|||
name|nxt
operator|==
name|top
operator|-
literal|1
condition|)
block|{
operator|--
name|off
expr_stmt|;
break|break;
block|}
comment|/* Copy the key/data pair, if not the skipped index. */
if|if
condition|(
name|skip
operator|!=
name|off
condition|)
block|{
operator|++
name|nxt
expr_stmt|;
name|l
operator|->
name|linp
index|[
name|off
index|]
operator|=
name|l
operator|->
name|upper
operator|-=
name|nbytes
expr_stmt|;
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|l
operator|+
name|l
operator|->
name|upper
argument_list|,
name|src
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
name|used
operator|+=
name|nbytes
operator|+
sizeof|sizeof
argument_list|(
name|indx_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|used
operator|>=
name|half
condition|)
block|{
if|if
condition|(
operator|!
name|isbigkey
operator|||
name|bigkeycnt
operator|==
literal|3
condition|)
break|break;
else|else
operator|++
name|bigkeycnt
expr_stmt|;
block|}
block|}
comment|/* 	 * Off is the last offset that's valid for the left page. 	 * Nxt is the first offset to be placed on the right page. 	 */
name|l
operator|->
name|lower
operator|+=
operator|(
name|off
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|indx_t
argument_list|)
expr_stmt|;
comment|/* 	 * If splitting the page that the cursor was on, the cursor has to be 	 * adjusted to point to the same record as before the split.  If the 	 * cursor is at or past the skipped slot, the cursor is incremented by 	 * one.  If the cursor is on the right page, it is decremented by the 	 * number of records split to the left page. 	 */
name|c
operator|=
operator|&
name|t
operator|->
name|bt_cursor
expr_stmt|;
if|if
condition|(
name|F_ISSET
argument_list|(
name|c
argument_list|,
name|CURS_INIT
argument_list|)
operator|&&
name|c
operator|->
name|pg
operator|.
name|pgno
operator|==
name|h
operator|->
name|pgno
condition|)
block|{
if|if
condition|(
name|c
operator|->
name|pg
operator|.
name|index
operator|>=
name|skip
condition|)
operator|++
name|c
operator|->
name|pg
operator|.
name|index
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|pg
operator|.
name|index
operator|<
name|nxt
condition|)
comment|/* Left page. */
name|c
operator|->
name|pg
operator|.
name|pgno
operator|=
name|l
operator|->
name|pgno
expr_stmt|;
else|else
block|{
comment|/* Right page. */
name|c
operator|->
name|pg
operator|.
name|pgno
operator|=
name|r
operator|->
name|pgno
expr_stmt|;
name|c
operator|->
name|pg
operator|.
name|index
operator|-=
name|nxt
expr_stmt|;
block|}
block|}
comment|/* 	 * If the skipped index was on the left page, just return that page. 	 * Otherwise, adjust the skip index to reflect the new position on 	 * the right page. 	 */
if|if
condition|(
name|skip
operator|<=
name|off
condition|)
block|{
name|skip
operator|=
name|MAX_PAGE_OFFSET
expr_stmt|;
name|rval
operator|=
name|l
expr_stmt|;
block|}
else|else
block|{
name|rval
operator|=
name|r
expr_stmt|;
operator|*
name|pskip
operator|-=
name|nxt
expr_stmt|;
block|}
for|for
control|(
name|off
operator|=
literal|0
init|;
name|nxt
operator|<
name|top
condition|;
operator|++
name|off
control|)
block|{
if|if
condition|(
name|skip
operator|==
name|nxt
condition|)
block|{
operator|++
name|off
expr_stmt|;
name|skip
operator|=
name|MAX_PAGE_OFFSET
expr_stmt|;
block|}
switch|switch
condition|(
name|h
operator|->
name|flags
operator|&
name|P_TYPE
condition|)
block|{
case|case
name|P_BINTERNAL
case|:
name|src
operator|=
name|bi
operator|=
name|GETBINTERNAL
argument_list|(
name|h
argument_list|,
name|nxt
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|NBINTERNAL
argument_list|(
name|bi
operator|->
name|ksize
argument_list|)
expr_stmt|;
break|break;
case|case
name|P_BLEAF
case|:
name|src
operator|=
name|bl
operator|=
name|GETBLEAF
argument_list|(
name|h
argument_list|,
name|nxt
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|NBLEAF
argument_list|(
name|bl
argument_list|)
expr_stmt|;
break|break;
case|case
name|P_RINTERNAL
case|:
name|src
operator|=
name|GETRINTERNAL
argument_list|(
name|h
argument_list|,
name|nxt
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|NRINTERNAL
expr_stmt|;
break|break;
case|case
name|P_RLEAF
case|:
name|src
operator|=
name|rl
operator|=
name|GETRLEAF
argument_list|(
name|h
argument_list|,
name|nxt
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|NRLEAF
argument_list|(
name|rl
argument_list|)
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
operator|++
name|nxt
expr_stmt|;
name|r
operator|->
name|linp
index|[
name|off
index|]
operator|=
name|r
operator|->
name|upper
operator|-=
name|nbytes
expr_stmt|;
name|memmove
argument_list|(
operator|(
name|char
operator|*
operator|)
name|r
operator|+
name|r
operator|->
name|upper
argument_list|,
name|src
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
name|r
operator|->
name|lower
operator|+=
name|off
operator|*
sizeof|sizeof
argument_list|(
name|indx_t
argument_list|)
expr_stmt|;
comment|/* If the key is being appended to the page, adjust the index. */
if|if
condition|(
name|skip
operator|==
name|top
condition|)
name|r
operator|->
name|lower
operator|+=
sizeof|sizeof
argument_list|(
name|indx_t
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * BT_PRESERVE -- Mark a chain of pages as used by an internal node.  *  * Chains of indirect blocks pointed to by leaf nodes get reclaimed when the  * record that references them gets deleted.  Chains pointed to by internal  * pages never get deleted.  This routine marks a chain as pointed to by an  * internal page.  *  * Parameters:  *	t:	tree  *	pg:	page number of first page in the chain.  *  * Returns:  *	RET_SUCCESS, RET_ERROR.  */
end_comment

begin_function
specifier|static
name|int
name|bt_preserve
parameter_list|(
name|t
parameter_list|,
name|pg
parameter_list|)
name|BTREE
modifier|*
name|t
decl_stmt|;
name|pgno_t
name|pg
decl_stmt|;
block|{
name|PAGE
modifier|*
name|h
decl_stmt|;
if|if
condition|(
operator|(
name|h
operator|=
name|mpool_get
argument_list|(
name|t
operator|->
name|bt_mp
argument_list|,
name|pg
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
name|h
operator|->
name|flags
operator||=
name|P_PRESERVE
expr_stmt|;
name|mpool_put
argument_list|(
name|t
operator|->
name|bt_mp
argument_list|,
name|h
argument_list|,
name|MPOOL_DIRTY
argument_list|)
expr_stmt|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * REC_TOTAL -- Return the number of recno entries below a page.  *  * Parameters:  *	h:	page  *  * Returns:  *	The number of recno entries below a page.  *  * XXX  * These values could be set by the bt_psplit routine.  The problem is that the  * entry has to be popped off of the stack etc. or the values have to be passed  * all the way back to bt_split/bt_rroot and it's not very clean.  */
end_comment

begin_function
specifier|static
name|recno_t
name|rec_total
parameter_list|(
name|h
parameter_list|)
name|PAGE
modifier|*
name|h
decl_stmt|;
block|{
name|recno_t
name|recs
decl_stmt|;
name|indx_t
name|nxt
decl_stmt|,
name|top
decl_stmt|;
for|for
control|(
name|recs
operator|=
literal|0
operator|,
name|nxt
operator|=
literal|0
operator|,
name|top
operator|=
name|NEXTINDEX
argument_list|(
name|h
argument_list|)
init|;
name|nxt
operator|<
name|top
condition|;
operator|++
name|nxt
control|)
name|recs
operator|+=
name|GETRINTERNAL
argument_list|(
name|h
argument_list|,
name|nxt
argument_list|)
operator|->
name|nrecs
expr_stmt|;
return|return
operator|(
name|recs
operator|)
return|;
block|}
end_function

end_unit

