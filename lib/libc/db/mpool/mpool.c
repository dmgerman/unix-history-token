begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * SPDX-License-Identifier: BSD-3-Clause  *  * Copyright (c) 1990, 1993, 1994  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)mpool.c	8.7 (Berkeley) 11/2/95"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBC_SCCS and not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"namespace.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"un-namespace.h"
end_include

begin_include
include|#
directive|include
file|<db.h>
end_include

begin_define
define|#
directive|define
name|__MPOOLINTERFACE_PRIVATE
end_define

begin_include
include|#
directive|include
file|<mpool.h>
end_include

begin_function_decl
specifier|static
name|BKT
modifier|*
name|mpool_bkt
parameter_list|(
name|MPOOL
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|BKT
modifier|*
name|mpool_look
parameter_list|(
name|MPOOL
modifier|*
parameter_list|,
name|pgno_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mpool_write
parameter_list|(
name|MPOOL
modifier|*
parameter_list|,
name|BKT
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * mpool_open --  *	Initialize a memory pool.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|MPOOL
modifier|*
name|mpool_open
parameter_list|(
name|void
modifier|*
name|key
parameter_list|,
name|int
name|fd
parameter_list|,
name|pgno_t
name|pagesize
parameter_list|,
name|pgno_t
name|maxcache
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|MPOOL
modifier|*
name|mp
decl_stmt|;
name|int
name|entry
decl_stmt|;
comment|/* 	 * Get information about the file. 	 * 	 * XXX 	 * We don't currently handle pipes, although we should. 	 */
if|if
condition|(
name|_fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
condition|)
block|{
name|errno
operator|=
name|ESPIPE
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Allocate and initialize the MPOOL cookie. */
if|if
condition|(
operator|(
name|mp
operator|=
operator|(
name|MPOOL
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|MPOOL
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|TAILQ_INIT
argument_list|(
operator|&
name|mp
operator|->
name|lqh
argument_list|)
expr_stmt|;
for|for
control|(
name|entry
operator|=
literal|0
init|;
name|entry
operator|<
name|HASHSIZE
condition|;
operator|++
name|entry
control|)
name|TAILQ_INIT
argument_list|(
operator|&
name|mp
operator|->
name|hqh
index|[
name|entry
index|]
argument_list|)
expr_stmt|;
name|mp
operator|->
name|maxcache
operator|=
name|maxcache
expr_stmt|;
name|mp
operator|->
name|npages
operator|=
name|sb
operator|.
name|st_size
operator|/
name|pagesize
expr_stmt|;
name|mp
operator|->
name|pagesize
operator|=
name|pagesize
expr_stmt|;
name|mp
operator|->
name|fd
operator|=
name|fd
expr_stmt|;
return|return
operator|(
name|mp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mpool_filter --  *	Initialize input/output filters.  */
end_comment

begin_function
name|void
name|mpool_filter
parameter_list|(
name|MPOOL
modifier|*
name|mp
parameter_list|,
name|void
function_decl|(
modifier|*
name|pgin
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|pgno_t
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
function_decl|(
modifier|*
name|pgout
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|pgno_t
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|pgcookie
parameter_list|)
block|{
name|mp
operator|->
name|pgin
operator|=
name|pgin
expr_stmt|;
name|mp
operator|->
name|pgout
operator|=
name|pgout
expr_stmt|;
name|mp
operator|->
name|pgcookie
operator|=
name|pgcookie
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * mpool_new --  *	Get a new page of memory.  */
end_comment

begin_function
name|void
modifier|*
name|mpool_new
parameter_list|(
name|MPOOL
modifier|*
name|mp
parameter_list|,
name|pgno_t
modifier|*
name|pgnoaddr
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|struct
name|_hqh
modifier|*
name|head
decl_stmt|;
name|BKT
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
name|mp
operator|->
name|npages
operator|==
name|MAX_PAGE_NUMBER
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mpool_new: page allocation overflow.\n"
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|STATISTICS
operator|++
name|mp
operator|->
name|pagenew
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Get a BKT from the cache.  Assign a new page number, attach 	 * it to the head of the hash chain, the tail of the lru chain, 	 * and return. 	 */
if|if
condition|(
operator|(
name|bp
operator|=
name|mpool_bkt
argument_list|(
name|mp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|flags
operator|==
name|MPOOL_PAGE_REQUEST
condition|)
block|{
name|mp
operator|->
name|npages
operator|++
expr_stmt|;
name|bp
operator|->
name|pgno
operator|=
operator|*
name|pgnoaddr
expr_stmt|;
block|}
else|else
name|bp
operator|->
name|pgno
operator|=
operator|*
name|pgnoaddr
operator|=
name|mp
operator|->
name|npages
operator|++
expr_stmt|;
name|bp
operator|->
name|flags
operator|=
name|MPOOL_PINNED
operator||
name|MPOOL_INUSE
expr_stmt|;
name|head
operator|=
operator|&
name|mp
operator|->
name|hqh
index|[
name|HASHKEY
argument_list|(
name|bp
operator|->
name|pgno
argument_list|)
index|]
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
name|head
argument_list|,
name|bp
argument_list|,
name|hq
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|mp
operator|->
name|lqh
argument_list|,
name|bp
argument_list|,
name|q
argument_list|)
expr_stmt|;
return|return
operator|(
name|bp
operator|->
name|page
operator|)
return|;
block|}
end_function

begin_function
name|int
name|mpool_delete
parameter_list|(
name|MPOOL
modifier|*
name|mp
parameter_list|,
name|void
modifier|*
name|page
parameter_list|)
block|{
name|struct
name|_hqh
modifier|*
name|head
decl_stmt|;
name|BKT
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
operator|(
name|BKT
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|page
operator|-
sizeof|sizeof
argument_list|(
name|BKT
argument_list|)
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|!
operator|(
name|bp
operator|->
name|flags
operator|&
name|MPOOL_PINNED
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mpool_delete: page %d not pinned\n"
argument_list|,
name|bp
operator|->
name|pgno
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Remove from the hash and lru queues. */
name|head
operator|=
operator|&
name|mp
operator|->
name|hqh
index|[
name|HASHKEY
argument_list|(
name|bp
operator|->
name|pgno
argument_list|)
index|]
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|head
argument_list|,
name|bp
argument_list|,
name|hq
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|mp
operator|->
name|lqh
argument_list|,
name|bp
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|curcache
operator|--
expr_stmt|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mpool_get  *	Get a page.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
modifier|*
name|mpool_get
parameter_list|(
name|MPOOL
modifier|*
name|mp
parameter_list|,
name|pgno_t
name|pgno
parameter_list|,
name|u_int
name|flags
parameter_list|)
comment|/* XXX not used? */
block|{
name|struct
name|_hqh
modifier|*
name|head
decl_stmt|;
name|BKT
modifier|*
name|bp
decl_stmt|;
name|off_t
name|off
decl_stmt|;
name|int
name|nr
decl_stmt|;
ifdef|#
directive|ifdef
name|STATISTICS
operator|++
name|mp
operator|->
name|pageget
expr_stmt|;
endif|#
directive|endif
comment|/* Check for a page that is cached. */
if|if
condition|(
operator|(
name|bp
operator|=
name|mpool_look
argument_list|(
name|mp
argument_list|,
name|pgno
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|MPOOL_IGNOREPIN
operator|)
operator|&&
name|bp
operator|->
name|flags
operator|&
name|MPOOL_PINNED
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mpool_get: page %d already pinned\n"
argument_list|,
name|bp
operator|->
name|pgno
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 		 * Move the page to the head of the hash chain and the tail 		 * of the lru chain. 		 */
name|head
operator|=
operator|&
name|mp
operator|->
name|hqh
index|[
name|HASHKEY
argument_list|(
name|bp
operator|->
name|pgno
argument_list|)
index|]
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|head
argument_list|,
name|bp
argument_list|,
name|hq
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
name|head
argument_list|,
name|bp
argument_list|,
name|hq
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|mp
operator|->
name|lqh
argument_list|,
name|bp
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|mp
operator|->
name|lqh
argument_list|,
name|bp
argument_list|,
name|q
argument_list|)
expr_stmt|;
comment|/* Return a pinned page. */
name|bp
operator|->
name|flags
operator||=
name|MPOOL_PINNED
expr_stmt|;
return|return
operator|(
name|bp
operator|->
name|page
operator|)
return|;
block|}
comment|/* Get a page from the cache. */
if|if
condition|(
operator|(
name|bp
operator|=
name|mpool_bkt
argument_list|(
name|mp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Read in the contents. */
name|off
operator|=
name|mp
operator|->
name|pagesize
operator|*
name|pgno
expr_stmt|;
if|if
condition|(
operator|(
name|nr
operator|=
name|pread
argument_list|(
name|mp
operator|->
name|fd
argument_list|,
name|bp
operator|->
name|page
argument_list|,
name|mp
operator|->
name|pagesize
argument_list|,
name|off
argument_list|)
operator|)
operator|!=
operator|(
name|ssize_t
operator|)
name|mp
operator|->
name|pagesize
condition|)
block|{
switch|switch
condition|(
name|nr
condition|)
block|{
case|case
operator|-
literal|1
case|:
comment|/* errno is set for us by pread(). */
name|free
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|curcache
operator|--
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
case|case
literal|0
case|:
comment|/* 			 * A zero-length read means you need to create a 			 * new page. 			 */
name|memset
argument_list|(
name|bp
operator|->
name|page
argument_list|,
literal|0
argument_list|,
name|mp
operator|->
name|pagesize
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* A partial read is definitely bad. */
name|free
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|mp
operator|->
name|curcache
operator|--
expr_stmt|;
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|STATISTICS
operator|++
name|mp
operator|->
name|pageread
expr_stmt|;
endif|#
directive|endif
comment|/* Set the page number, pin the page. */
name|bp
operator|->
name|pgno
operator|=
name|pgno
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|MPOOL_IGNOREPIN
operator|)
condition|)
name|bp
operator|->
name|flags
operator|=
name|MPOOL_PINNED
expr_stmt|;
name|bp
operator|->
name|flags
operator||=
name|MPOOL_INUSE
expr_stmt|;
comment|/* 	 * Add the page to the head of the hash chain and the tail 	 * of the lru chain. 	 */
name|head
operator|=
operator|&
name|mp
operator|->
name|hqh
index|[
name|HASHKEY
argument_list|(
name|bp
operator|->
name|pgno
argument_list|)
index|]
expr_stmt|;
name|TAILQ_INSERT_HEAD
argument_list|(
name|head
argument_list|,
name|bp
argument_list|,
name|hq
argument_list|)
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|mp
operator|->
name|lqh
argument_list|,
name|bp
argument_list|,
name|q
argument_list|)
expr_stmt|;
comment|/* Run through the user's filter. */
if|if
condition|(
name|mp
operator|->
name|pgin
operator|!=
name|NULL
condition|)
call|(
name|mp
operator|->
name|pgin
call|)
argument_list|(
name|mp
operator|->
name|pgcookie
argument_list|,
name|bp
operator|->
name|pgno
argument_list|,
name|bp
operator|->
name|page
argument_list|)
expr_stmt|;
return|return
operator|(
name|bp
operator|->
name|page
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mpool_put  *	Return a page.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|mpool_put
parameter_list|(
name|MPOOL
modifier|*
name|mp
parameter_list|,
name|void
modifier|*
name|page
parameter_list|,
name|u_int
name|flags
parameter_list|)
block|{
name|BKT
modifier|*
name|bp
decl_stmt|;
ifdef|#
directive|ifdef
name|STATISTICS
operator|++
name|mp
operator|->
name|pageput
expr_stmt|;
endif|#
directive|endif
name|bp
operator|=
operator|(
name|BKT
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|page
operator|-
sizeof|sizeof
argument_list|(
name|BKT
argument_list|)
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|!
operator|(
name|bp
operator|->
name|flags
operator|&
name|MPOOL_PINNED
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"mpool_put: page %d not pinned\n"
argument_list|,
name|bp
operator|->
name|pgno
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
name|bp
operator|->
name|flags
operator|&=
operator|~
name|MPOOL_PINNED
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MPOOL_DIRTY
condition|)
name|bp
operator|->
name|flags
operator||=
name|flags
operator|&
name|MPOOL_DIRTY
expr_stmt|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mpool_close  *	Close the buffer pool.  */
end_comment

begin_function
name|int
name|mpool_close
parameter_list|(
name|MPOOL
modifier|*
name|mp
parameter_list|)
block|{
name|BKT
modifier|*
name|bp
decl_stmt|;
comment|/* Free up any space allocated to the lru pages. */
while|while
condition|(
operator|!
name|TAILQ_EMPTY
argument_list|(
operator|&
name|mp
operator|->
name|lqh
argument_list|)
condition|)
block|{
name|bp
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|mp
operator|->
name|lqh
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|mp
operator|->
name|lqh
argument_list|,
name|bp
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
comment|/* Free the MPOOL cookie. */
name|free
argument_list|(
name|mp
argument_list|)
expr_stmt|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mpool_sync  *	Sync the pool to disk.  */
end_comment

begin_function
name|int
name|mpool_sync
parameter_list|(
name|MPOOL
modifier|*
name|mp
parameter_list|)
block|{
name|BKT
modifier|*
name|bp
decl_stmt|;
comment|/* Walk the lru chain, flushing any dirty pages to disk. */
name|TAILQ_FOREACH
argument_list|(
argument|bp
argument_list|,
argument|&mp->lqh
argument_list|,
argument|q
argument_list|)
if|if
condition|(
name|bp
operator|->
name|flags
operator|&
name|MPOOL_DIRTY
operator|&&
name|mpool_write
argument_list|(
name|mp
argument_list|,
name|bp
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
comment|/* Sync the file descriptor. */
return|return
operator|(
name|_fsync
argument_list|(
name|mp
operator|->
name|fd
argument_list|)
condition|?
name|RET_ERROR
else|:
name|RET_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mpool_bkt  *	Get a page from the cache (or create one).  */
end_comment

begin_function
specifier|static
name|BKT
modifier|*
name|mpool_bkt
parameter_list|(
name|MPOOL
modifier|*
name|mp
parameter_list|)
block|{
name|struct
name|_hqh
modifier|*
name|head
decl_stmt|;
name|BKT
modifier|*
name|bp
decl_stmt|;
comment|/* If under the max cached, always create a new page. */
if|if
condition|(
name|mp
operator|->
name|curcache
operator|<
name|mp
operator|->
name|maxcache
condition|)
goto|goto
name|new
goto|;
comment|/* 	 * If the cache is max'd out, walk the lru list for a buffer we 	 * can flush.  If we find one, write it (if necessary) and take it 	 * off any lists.  If we don't find anything we grow the cache anyway. 	 * The cache never shrinks. 	 */
name|TAILQ_FOREACH
argument_list|(
argument|bp
argument_list|,
argument|&mp->lqh
argument_list|,
argument|q
argument_list|)
if|if
condition|(
operator|!
operator|(
name|bp
operator|->
name|flags
operator|&
name|MPOOL_PINNED
operator|)
condition|)
block|{
comment|/* Flush if dirty. */
if|if
condition|(
name|bp
operator|->
name|flags
operator|&
name|MPOOL_DIRTY
operator|&&
name|mpool_write
argument_list|(
name|mp
argument_list|,
name|bp
argument_list|)
operator|==
name|RET_ERROR
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
ifdef|#
directive|ifdef
name|STATISTICS
operator|++
name|mp
operator|->
name|pageflush
expr_stmt|;
endif|#
directive|endif
comment|/* Remove from the hash and lru queues. */
name|head
operator|=
operator|&
name|mp
operator|->
name|hqh
index|[
name|HASHKEY
argument_list|(
name|bp
operator|->
name|pgno
argument_list|)
index|]
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
name|head
argument_list|,
name|bp
argument_list|,
name|hq
argument_list|)
expr_stmt|;
name|TAILQ_REMOVE
argument_list|(
operator|&
name|mp
operator|->
name|lqh
argument_list|,
name|bp
argument_list|,
name|q
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
block|{
name|void
modifier|*
name|spage
decl_stmt|;
name|spage
operator|=
name|bp
operator|->
name|page
expr_stmt|;
name|memset
argument_list|(
name|bp
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|BKT
argument_list|)
operator|+
name|mp
operator|->
name|pagesize
argument_list|)
expr_stmt|;
name|bp
operator|->
name|page
operator|=
name|spage
expr_stmt|;
block|}
endif|#
directive|endif
name|bp
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
name|new
label|:
if|if
condition|(
operator|(
name|bp
operator|=
operator|(
name|BKT
operator|*
operator|)
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|BKT
argument_list|)
operator|+
name|mp
operator|->
name|pagesize
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
ifdef|#
directive|ifdef
name|STATISTICS
operator|++
name|mp
operator|->
name|pagealloc
expr_stmt|;
endif|#
directive|endif
name|bp
operator|->
name|page
operator|=
operator|(
name|char
operator|*
operator|)
name|bp
operator|+
sizeof|sizeof
argument_list|(
name|BKT
argument_list|)
expr_stmt|;
name|bp
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
operator|++
name|mp
operator|->
name|curcache
expr_stmt|;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mpool_write  *	Write a page to disk.  */
end_comment

begin_function
specifier|static
name|int
name|mpool_write
parameter_list|(
name|MPOOL
modifier|*
name|mp
parameter_list|,
name|BKT
modifier|*
name|bp
parameter_list|)
block|{
name|off_t
name|off
decl_stmt|;
ifdef|#
directive|ifdef
name|STATISTICS
operator|++
name|mp
operator|->
name|pagewrite
expr_stmt|;
endif|#
directive|endif
comment|/* Run through the user's filter. */
if|if
condition|(
name|mp
operator|->
name|pgout
condition|)
call|(
name|mp
operator|->
name|pgout
call|)
argument_list|(
name|mp
operator|->
name|pgcookie
argument_list|,
name|bp
operator|->
name|pgno
argument_list|,
name|bp
operator|->
name|page
argument_list|)
expr_stmt|;
name|off
operator|=
name|mp
operator|->
name|pagesize
operator|*
name|bp
operator|->
name|pgno
expr_stmt|;
if|if
condition|(
name|pwrite
argument_list|(
name|mp
operator|->
name|fd
argument_list|,
name|bp
operator|->
name|page
argument_list|,
name|mp
operator|->
name|pagesize
argument_list|,
name|off
argument_list|)
operator|!=
operator|(
name|ssize_t
operator|)
name|mp
operator|->
name|pagesize
condition|)
return|return
operator|(
name|RET_ERROR
operator|)
return|;
comment|/* 	 * Re-run through the input filter since this page may soon be 	 * accessed via the cache, and whatever the user's output filter 	 * did may screw things up if we don't let the input filter 	 * restore the in-core copy. 	 */
if|if
condition|(
name|mp
operator|->
name|pgin
condition|)
call|(
name|mp
operator|->
name|pgin
call|)
argument_list|(
name|mp
operator|->
name|pgcookie
argument_list|,
name|bp
operator|->
name|pgno
argument_list|,
name|bp
operator|->
name|page
argument_list|)
expr_stmt|;
name|bp
operator|->
name|flags
operator|&=
operator|~
name|MPOOL_DIRTY
expr_stmt|;
return|return
operator|(
name|RET_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mpool_look  *	Lookup a page in the cache.  */
end_comment

begin_function
specifier|static
name|BKT
modifier|*
name|mpool_look
parameter_list|(
name|MPOOL
modifier|*
name|mp
parameter_list|,
name|pgno_t
name|pgno
parameter_list|)
block|{
name|struct
name|_hqh
modifier|*
name|head
decl_stmt|;
name|BKT
modifier|*
name|bp
decl_stmt|;
name|head
operator|=
operator|&
name|mp
operator|->
name|hqh
index|[
name|HASHKEY
argument_list|(
name|pgno
argument_list|)
index|]
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|bp
argument_list|,
argument|head
argument_list|,
argument|hq
argument_list|)
if|if
condition|(
operator|(
name|bp
operator|->
name|pgno
operator|==
name|pgno
operator|)
operator|&&
operator|(
operator|(
name|bp
operator|->
name|flags
operator|&
name|MPOOL_INUSE
operator|)
operator|==
name|MPOOL_INUSE
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|STATISTICS
operator|++
name|mp
operator|->
name|cachehit
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|bp
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|STATISTICS
operator|++
name|mp
operator|->
name|cachemiss
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|STATISTICS
end_ifdef

begin_comment
comment|/*  * mpool_stat  *	Print out cache statistics.  */
end_comment

begin_function
name|void
name|mpool_stat
parameter_list|(
name|MPOOL
modifier|*
name|mp
parameter_list|)
block|{
name|BKT
modifier|*
name|bp
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|char
modifier|*
name|sep
decl_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%lu pages in the file\n"
argument_list|,
name|mp
operator|->
name|npages
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"page size %lu, cacheing %lu pages of %lu page max cache\n"
argument_list|,
name|mp
operator|->
name|pagesize
argument_list|,
name|mp
operator|->
name|curcache
argument_list|,
name|mp
operator|->
name|maxcache
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%lu page puts, %lu page gets, %lu page new\n"
argument_list|,
name|mp
operator|->
name|pageput
argument_list|,
name|mp
operator|->
name|pageget
argument_list|,
name|mp
operator|->
name|pagenew
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%lu page allocs, %lu page flushes\n"
argument_list|,
name|mp
operator|->
name|pagealloc
argument_list|,
name|mp
operator|->
name|pageflush
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|->
name|cachehit
operator|+
name|mp
operator|->
name|cachemiss
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%.0f%% cache hit rate (%lu hits, %lu misses)\n"
argument_list|,
operator|(
operator|(
name|double
operator|)
name|mp
operator|->
name|cachehit
operator|/
operator|(
name|mp
operator|->
name|cachehit
operator|+
name|mp
operator|->
name|cachemiss
operator|)
operator|)
operator|*
literal|100
argument_list|,
name|mp
operator|->
name|cachehit
argument_list|,
name|mp
operator|->
name|cachemiss
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%lu page reads, %lu page writes\n"
argument_list|,
name|mp
operator|->
name|pageread
argument_list|,
name|mp
operator|->
name|pagewrite
argument_list|)
expr_stmt|;
name|sep
operator|=
literal|""
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|bp
argument_list|,
argument|&mp->lqh
argument_list|,
argument|q
argument_list|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s%d"
argument_list|,
name|sep
argument_list|,
name|bp
operator|->
name|pgno
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|flags
operator|&
name|MPOOL_DIRTY
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"d"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|flags
operator|&
name|MPOOL_PINNED
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"P"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|cnt
operator|==
literal|10
condition|)
block|{
name|sep
operator|=
literal|"\n"
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|sep
operator|=
literal|", "
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

