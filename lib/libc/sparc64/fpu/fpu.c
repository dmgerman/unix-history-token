begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This software was developed by the Computer Systems Engineering group  * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and  * contributed to Berkeley.  *  * All advertising materials mentioning features or use of this software  * must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Lawrence Berkeley Laboratory.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*-  * Copyright 2001 by Thomas Moestl<tmm@FreeBSD.org>.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,  * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES  * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,  * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE  * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *	@(#)fpu.c	8.1 (Berkeley) 6/11/93  *	$NetBSD: fpu.c,v 1.11 2000/12/06 01:47:50 mrg Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|"namespace.h"
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"un-namespace.h"
end_include

begin_include
include|#
directive|include
file|"libc_private.h"
end_include

begin_include
include|#
directive|include
file|<machine/fp.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<machine/fsr.h>
end_include

begin_include
include|#
directive|include
file|<machine/instr.h>
end_include

begin_include
include|#
directive|include
file|<machine/pcb.h>
end_include

begin_include
include|#
directive|include
file|<machine/tstate.h>
end_include

begin_include
include|#
directive|include
file|"__sparc_utrap_private.h"
end_include

begin_include
include|#
directive|include
file|"fpu_emu.h"
end_include

begin_include
include|#
directive|include
file|"fpu_extern.h"
end_include

begin_comment
comment|/*  * Translate current exceptions into `first' exception.  The  * bits go the wrong way for ffs() (0x10 is most important, etc).  * There are only 5, so do it the obvious way.  */
end_comment

begin_define
define|#
directive|define
name|X1
parameter_list|(
name|x
parameter_list|)
value|x
end_define

begin_define
define|#
directive|define
name|X2
parameter_list|(
name|x
parameter_list|)
value|x,x
end_define

begin_define
define|#
directive|define
name|X4
parameter_list|(
name|x
parameter_list|)
value|x,x,x,x
end_define

begin_define
define|#
directive|define
name|X8
parameter_list|(
name|x
parameter_list|)
value|X4(x),X4(x)
end_define

begin_define
define|#
directive|define
name|X16
parameter_list|(
name|x
parameter_list|)
value|X8(x),X8(x)
end_define

begin_decl_stmt
specifier|static
name|char
name|cx_to_trapx
index|[]
init|=
block|{
name|X1
argument_list|(
name|FSR_NX
argument_list|)
block|,
name|X2
argument_list|(
name|FSR_DZ
argument_list|)
block|,
name|X4
argument_list|(
name|FSR_UF
argument_list|)
block|,
name|X8
argument_list|(
name|FSR_OF
argument_list|)
block|,
name|X16
argument_list|(
argument|FSR_NV
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|FPU_DEBUG
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|FPU_DEBUG_MASK
end_ifdef

begin_decl_stmt
name|int
name|__fpe_debug
init|=
name|FPU_DEBUG_MASK
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|__fpe_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FPU_DEBUG */
end_comment

begin_function_decl
specifier|static
name|int
name|__fpu_execute
parameter_list|(
name|struct
name|utrapframe
modifier|*
parameter_list|,
name|struct
name|fpemu
modifier|*
parameter_list|,
name|u_int32_t
parameter_list|,
name|u_long
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Need to use an fpstate on the stack; we could switch, so we cannot safely  * modify the pcb one, it might get overwritten.  */
end_comment

begin_function
name|int
name|__fpu_exception
parameter_list|(
name|struct
name|utrapframe
modifier|*
name|uf
parameter_list|)
block|{
name|struct
name|fpemu
name|fe
decl_stmt|;
name|u_long
name|fsr
decl_stmt|,
name|tstate
decl_stmt|;
name|u_int
name|insn
decl_stmt|;
name|int
name|sig
decl_stmt|;
name|fsr
operator|=
name|uf
operator|->
name|uf_fsr
expr_stmt|;
switch|switch
condition|(
name|FSR_GET_FTT
argument_list|(
name|fsr
argument_list|)
condition|)
block|{
case|case
name|FSR_FTT_NONE
case|:
name|__utrap_write
argument_list|(
literal|"lost FPU trap type\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FSR_FTT_IEEE
case|:
return|return
operator|(
name|SIGFPE
operator|)
return|;
case|case
name|FSR_FTT_SEQERR
case|:
name|__utrap_write
argument_list|(
literal|"FPU sequence error\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|SIGFPE
operator|)
return|;
case|case
name|FSR_FTT_HWERR
case|:
name|__utrap_write
argument_list|(
literal|"FPU hardware error\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|SIGFPE
operator|)
return|;
case|case
name|FSR_FTT_UNFIN
case|:
case|case
name|FSR_FTT_UNIMP
case|:
break|break;
default|default:
name|__utrap_write
argument_list|(
literal|"unknown FPU error\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|SIGFPE
operator|)
return|;
block|}
name|fe
operator|.
name|fe_fsr
operator|=
name|fsr
operator|&
operator|~
name|FSR_FTT_MASK
expr_stmt|;
name|insn
operator|=
operator|*
operator|(
name|u_int32_t
operator|*
operator|)
name|uf
operator|->
name|uf_pc
expr_stmt|;
if|if
condition|(
name|IF_OP
argument_list|(
name|insn
argument_list|)
operator|!=
name|IOP_MISC
operator|||
operator|(
name|IF_F3_OP3
argument_list|(
name|insn
argument_list|)
operator|!=
name|INS2_FPop1
operator|&&
name|IF_F3_OP3
argument_list|(
name|insn
argument_list|)
operator|!=
name|INS2_FPop2
operator|)
condition|)
name|__utrap_panic
argument_list|(
literal|"bogus FP fault"
argument_list|)
expr_stmt|;
name|tstate
operator|=
name|uf
operator|->
name|uf_state
expr_stmt|;
name|sig
operator|=
name|__fpu_execute
argument_list|(
name|uf
argument_list|,
operator|&
name|fe
argument_list|,
name|insn
argument_list|,
name|tstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|sig
operator|!=
literal|0
condition|)
return|return
operator|(
name|sig
operator|)
return|;
asm|__asm __volatile("ldx %0, %%fsr" : : "m" (fe.fe_fsr));
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|FPU_DEBUG
end_ifdef

begin_comment
comment|/*  * Dump a `fpn' structure.  */
end_comment

begin_function
name|void
name|__fpu_dumpfpn
parameter_list|(
name|struct
name|fpn
modifier|*
name|fp
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|class
index|[]
init|=
block|{
literal|"SNAN"
block|,
literal|"QNAN"
block|,
literal|"ZERO"
block|,
literal|"NUM"
block|,
literal|"INF"
block|}
decl_stmt|;
name|printf
argument_list|(
literal|"%s %c.%x %x %x %xE%d"
argument_list|,
name|class
index|[
name|fp
operator|->
name|fp_class
operator|+
literal|2
index|]
argument_list|,
name|fp
operator|->
name|fp_sign
condition|?
literal|'-'
else|:
literal|' '
argument_list|,
name|fp
operator|->
name|fp_mant
index|[
literal|0
index|]
argument_list|,
name|fp
operator|->
name|fp_mant
index|[
literal|1
index|]
argument_list|,
name|fp
operator|->
name|fp_mant
index|[
literal|2
index|]
argument_list|,
name|fp
operator|->
name|fp_mant
index|[
literal|3
index|]
argument_list|,
name|fp
operator|->
name|fp_exp
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|opmask
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|3
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Decode 5 bit register field depending on the type. */
end_comment

begin_define
define|#
directive|define
name|RN_DECODE
parameter_list|(
name|tp
parameter_list|,
name|rn
parameter_list|)
define|\
value|((tp == FTYPE_DBL || tp == FTYPE_EXT ? INSFPdq_RN((rn)) : (rn))& \ 	    ~opmask[tp])
end_define

begin_comment
comment|/* Operand size in 32-bit registers. */
end_comment

begin_define
define|#
directive|define
name|OPSZ
parameter_list|(
name|tp
parameter_list|)
value|((tp) == FTYPE_LNG ? 2 : (1<< (tp)))
end_define

begin_comment
comment|/*  * Helper for forming the below case statements. Build only the op3 and opf  * field of the instruction, these are the only ones that need to match.  */
end_comment

begin_define
define|#
directive|define
name|FOP
parameter_list|(
name|op3
parameter_list|,
name|opf
parameter_list|)
define|\
value|((op3)<< IF_F3_OP3_SHIFT | (opf)<< IF_F3_OPF_SHIFT)
end_define

begin_comment
comment|/*  * Implement a move operation for all supported operand types. The additional  * nand and xor parameters will be applied to the upper 32 bit word of the  * source operand. This allows to implement fabs and fneg (for fp operands  * only!) using this functions, too, by passing (1<< 31) for one of the  * parameters, and 0 for the other.  */
end_comment

begin_function
specifier|static
name|void
name|__fpu_mov
parameter_list|(
name|struct
name|fpemu
modifier|*
name|fe
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rd
parameter_list|,
name|int
name|rs2
parameter_list|,
name|u_int32_t
name|nand
parameter_list|,
name|u_int32_t
name|xor
parameter_list|)
block|{
name|u_int64_t
name|tmp64
decl_stmt|;
name|u_int32_t
modifier|*
name|p32
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|type
operator|==
name|FTYPE_INT
operator|||
name|type
operator|==
name|FTYPE_SNG
condition|)
name|__fpu_setreg
argument_list|(
name|rd
argument_list|,
operator|(
name|__fpu_getreg
argument_list|(
name|rs2
argument_list|)
operator|&
operator|~
name|nand
operator|)
operator|^
name|xor
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 		 * Need to use the double versions to be able to access 		 * the upper 32 fp registers. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OPSZ
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|+=
literal|2
operator|,
name|rd
operator|+=
literal|2
operator|,
name|rs2
operator|+=
literal|2
control|)
block|{
name|tmp64
operator|=
name|__fpu_getreg64
argument_list|(
name|rs2
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|tmp64
operator|=
operator|(
name|tmp64
operator|&
operator|~
operator|(
operator|(
name|u_int64_t
operator|)
name|nand
operator|<<
literal|32
operator|)
operator|)
operator|^
operator|(
operator|(
name|u_int64_t
operator|)
name|xor
operator|<<
literal|32
operator|)
expr_stmt|;
name|__fpu_setreg64
argument_list|(
name|rd
argument_list|,
name|tmp64
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|__fpu_ccmov
parameter_list|(
name|struct
name|fpemu
modifier|*
name|fe
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|rd
parameter_list|,
name|int
name|rs2
parameter_list|,
name|u_int32_t
name|insn
parameter_list|,
name|int
name|fcc
parameter_list|)
block|{
if|if
condition|(
name|IF_F4_COND
argument_list|(
name|insn
argument_list|)
operator|==
name|fcc
condition|)
name|__fpu_mov
argument_list|(
name|fe
argument_list|,
name|type
argument_list|,
name|rd
argument_list|,
name|rs2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|__fpu_cmpck
parameter_list|(
name|struct
name|fpemu
modifier|*
name|fe
parameter_list|)
block|{
name|u_long
name|fsr
decl_stmt|;
name|int
name|cx
decl_stmt|;
comment|/* 	 * The only possible exception here is NV; catch it 	 * early and get out, as there is no result register. 	 */
name|cx
operator|=
name|fe
operator|->
name|fe_cx
expr_stmt|;
name|fsr
operator|=
name|fe
operator|->
name|fe_fsr
operator||
operator|(
name|cx
operator|<<
name|FSR_CEXC_SHIFT
operator|)
expr_stmt|;
if|if
condition|(
name|cx
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|fsr
operator|&
operator|(
name|FSR_NV
operator|<<
name|FSR_TEM_SHIFT
operator|)
condition|)
block|{
name|fe
operator|->
name|fe_fsr
operator|=
operator|(
name|fsr
operator|&
operator|~
name|FSR_FTT_MASK
operator|)
operator||
name|FSR_FTT
argument_list|(
name|FSR_FTT_IEEE
argument_list|)
expr_stmt|;
return|return
operator|(
name|SIGFPE
operator|)
return|;
block|}
name|fsr
operator||=
name|FSR_NV
operator|<<
name|FSR_AEXC_SHIFT
expr_stmt|;
block|}
name|fe
operator|->
name|fe_fsr
operator|=
name|fsr
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Execute an FPU instruction (one that runs entirely in the FPU; not  * FBfcc or STF, for instance).  On return, fe->fe_fs->fs_fsr will be  * modified to reflect the setting the hardware would have left.  *  * Note that we do not catch all illegal opcodes, so you can, for instance,  * multiply two integers this way.  */
end_comment

begin_function
specifier|static
name|int
name|__fpu_execute
parameter_list|(
name|struct
name|utrapframe
modifier|*
name|uf
parameter_list|,
name|struct
name|fpemu
modifier|*
name|fe
parameter_list|,
name|u_int32_t
name|insn
parameter_list|,
name|u_long
name|tstate
parameter_list|)
block|{
name|struct
name|fpn
modifier|*
name|fp
decl_stmt|;
name|int
name|opf
decl_stmt|,
name|rs1
decl_stmt|,
name|rs2
decl_stmt|,
name|rd
decl_stmt|,
name|type
decl_stmt|,
name|mask
decl_stmt|,
name|cx
decl_stmt|,
name|cond
decl_stmt|;
name|u_long
name|reg
decl_stmt|,
name|fsr
decl_stmt|;
name|u_int
name|space
index|[
literal|4
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * `Decode' and execute instruction.  Start with no exceptions. 	 * The type of any opf opcode is in the bottom two bits, so we 	 * squish them out here. 	 */
name|opf
operator|=
name|insn
operator|&
operator|(
name|IF_MASK
argument_list|(
name|IF_F3_OP3_SHIFT
argument_list|,
name|IF_F3_OP3_BITS
argument_list|)
operator||
name|IF_MASK
argument_list|(
name|IF_F3_OPF_SHIFT
operator|+
literal|2
argument_list|,
name|IF_F3_OPF_BITS
operator|-
literal|2
argument_list|)
operator|)
expr_stmt|;
name|type
operator|=
name|IF_F3_OPF
argument_list|(
name|insn
argument_list|)
operator|&
literal|3
expr_stmt|;
name|rs1
operator|=
name|RN_DECODE
argument_list|(
name|type
argument_list|,
name|IF_F3_RS1
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|rs2
operator|=
name|RN_DECODE
argument_list|(
name|type
argument_list|,
name|IF_F3_RS2
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|rd
operator|=
name|RN_DECODE
argument_list|(
name|type
argument_list|,
name|IF_F3_RD
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|cond
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
operator|(
name|rs1
operator||
name|rs2
operator||
name|rd
operator|)
operator|&
name|opmask
index|[
name|type
index|]
condition|)
return|return
operator|(
name|SIGILL
operator|)
return|;
endif|#
directive|endif
name|fsr
operator|=
name|fe
operator|->
name|fe_fsr
expr_stmt|;
name|fe
operator|->
name|fe_fsr
operator|&=
operator|~
name|FSR_CEXC_MASK
expr_stmt|;
name|fe
operator|->
name|fe_cx
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|opf
condition|)
block|{
case|case
name|FOP
argument_list|(
name|INS2_FPop2
argument_list|,
name|INSFP2_FMOV_CC
argument_list|(
name|IFCC_FCC
argument_list|(
literal|0
argument_list|)
argument_list|)
argument_list|)
case|:
name|__fpu_ccmov
argument_list|(
name|fe
argument_list|,
name|type
argument_list|,
name|rd
argument_list|,
name|rs2
argument_list|,
name|insn
argument_list|,
name|FSR_GET_FCC0
argument_list|(
name|fsr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FOP
argument_list|(
name|INS2_FPop2
argument_list|,
name|INSFP2_FMOV_CC
argument_list|(
name|IFCC_FCC
argument_list|(
literal|1
argument_list|)
argument_list|)
argument_list|)
case|:
name|__fpu_ccmov
argument_list|(
name|fe
argument_list|,
name|type
argument_list|,
name|rd
argument_list|,
name|rs2
argument_list|,
name|insn
argument_list|,
name|FSR_GET_FCC1
argument_list|(
name|fsr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FOP
argument_list|(
name|INS2_FPop2
argument_list|,
name|INSFP2_FMOV_CC
argument_list|(
name|IFCC_FCC
argument_list|(
literal|2
argument_list|)
argument_list|)
argument_list|)
case|:
name|__fpu_ccmov
argument_list|(
name|fe
argument_list|,
name|type
argument_list|,
name|rd
argument_list|,
name|rs2
argument_list|,
name|insn
argument_list|,
name|FSR_GET_FCC2
argument_list|(
name|fsr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FOP
argument_list|(
name|INS2_FPop2
argument_list|,
name|INSFP2_FMOV_CC
argument_list|(
name|IFCC_FCC
argument_list|(
literal|3
argument_list|)
argument_list|)
argument_list|)
case|:
name|__fpu_ccmov
argument_list|(
name|fe
argument_list|,
name|type
argument_list|,
name|rd
argument_list|,
name|rs2
argument_list|,
name|insn
argument_list|,
name|FSR_GET_FCC3
argument_list|(
name|fsr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FOP
argument_list|(
name|INS2_FPop2
argument_list|,
name|INSFP2_FMOV_CC
argument_list|(
name|IFCC_ICC
argument_list|)
argument_list|)
case|:
name|__fpu_ccmov
argument_list|(
name|fe
argument_list|,
name|type
argument_list|,
name|rd
argument_list|,
name|rs2
argument_list|,
name|insn
argument_list|,
operator|(
name|tstate
operator|&
name|TSTATE_ICC_MASK
operator|)
operator|>>
name|TSTATE_ICC_SHIFT
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FOP
argument_list|(
name|INS2_FPop2
argument_list|,
name|INSFP2_FMOV_CC
argument_list|(
name|IFCC_XCC
argument_list|)
argument_list|)
case|:
name|__fpu_ccmov
argument_list|(
name|fe
argument_list|,
name|type
argument_list|,
name|rd
argument_list|,
name|rs2
argument_list|,
name|insn
argument_list|,
operator|(
name|tstate
operator|&
name|TSTATE_XCC_MASK
operator|)
operator|>>
operator|(
name|TSTATE_XCC_SHIFT
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FOP
argument_list|(
name|INS2_FPop2
argument_list|,
name|INSFP2_FMOV_RC
argument_list|(
name|IRCOND_Z
argument_list|)
argument_list|)
case|:
name|reg
operator|=
name|__emul_fetch_reg
argument_list|(
name|uf
argument_list|,
name|IF_F4_RS1
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
literal|0
condition|)
name|__fpu_mov
argument_list|(
name|fe
argument_list|,
name|type
argument_list|,
name|rd
argument_list|,
name|rs2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FOP
argument_list|(
name|INS2_FPop2
argument_list|,
name|INSFP2_FMOV_RC
argument_list|(
name|IRCOND_LEZ
argument_list|)
argument_list|)
case|:
name|reg
operator|=
name|__emul_fetch_reg
argument_list|(
name|uf
argument_list|,
name|IF_F4_RS1
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|<=
literal|0
condition|)
name|__fpu_mov
argument_list|(
name|fe
argument_list|,
name|type
argument_list|,
name|rd
argument_list|,
name|rs2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FOP
argument_list|(
name|INS2_FPop2
argument_list|,
name|INSFP2_FMOV_RC
argument_list|(
name|IRCOND_LZ
argument_list|)
argument_list|)
case|:
name|reg
operator|=
name|__emul_fetch_reg
argument_list|(
name|uf
argument_list|,
name|IF_F4_RS1
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|<
literal|0
condition|)
name|__fpu_mov
argument_list|(
name|fe
argument_list|,
name|type
argument_list|,
name|rd
argument_list|,
name|rs2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FOP
argument_list|(
name|INS2_FPop2
argument_list|,
name|INSFP2_FMOV_RC
argument_list|(
name|IRCOND_NZ
argument_list|)
argument_list|)
case|:
name|reg
operator|=
name|__emul_fetch_reg
argument_list|(
name|uf
argument_list|,
name|IF_F4_RS1
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|!=
literal|0
condition|)
name|__fpu_mov
argument_list|(
name|fe
argument_list|,
name|type
argument_list|,
name|rd
argument_list|,
name|rs2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FOP
argument_list|(
name|INS2_FPop2
argument_list|,
name|INSFP2_FMOV_RC
argument_list|(
name|IRCOND_GZ
argument_list|)
argument_list|)
case|:
name|reg
operator|=
name|__emul_fetch_reg
argument_list|(
name|uf
argument_list|,
name|IF_F4_RS1
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|>
literal|0
condition|)
name|__fpu_mov
argument_list|(
name|fe
argument_list|,
name|type
argument_list|,
name|rd
argument_list|,
name|rs2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FOP
argument_list|(
name|INS2_FPop2
argument_list|,
name|INSFP2_FMOV_RC
argument_list|(
name|IRCOND_GEZ
argument_list|)
argument_list|)
case|:
name|reg
operator|=
name|__emul_fetch_reg
argument_list|(
name|uf
argument_list|,
name|IF_F4_RS1
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|>=
literal|0
condition|)
name|__fpu_mov
argument_list|(
name|fe
argument_list|,
name|type
argument_list|,
name|rd
argument_list|,
name|rs2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FOP
argument_list|(
name|INS2_FPop2
argument_list|,
name|INSFP2_FCMP
argument_list|)
case|:
name|__fpu_explode
argument_list|(
name|fe
argument_list|,
operator|&
name|fe
operator|->
name|fe_f1
argument_list|,
name|type
argument_list|,
name|rs1
argument_list|)
expr_stmt|;
name|__fpu_explode
argument_list|(
name|fe
argument_list|,
operator|&
name|fe
operator|->
name|fe_f2
argument_list|,
name|type
argument_list|,
name|rs2
argument_list|)
expr_stmt|;
name|__fpu_compare
argument_list|(
name|fe
argument_list|,
literal|0
argument_list|,
name|IF_F3_CC
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|__fpu_cmpck
argument_list|(
name|fe
argument_list|)
operator|)
return|;
case|case
name|FOP
argument_list|(
name|INS2_FPop2
argument_list|,
name|INSFP2_FCMPE
argument_list|)
case|:
name|__fpu_explode
argument_list|(
name|fe
argument_list|,
operator|&
name|fe
operator|->
name|fe_f1
argument_list|,
name|type
argument_list|,
name|rs1
argument_list|)
expr_stmt|;
name|__fpu_explode
argument_list|(
name|fe
argument_list|,
operator|&
name|fe
operator|->
name|fe_f2
argument_list|,
name|type
argument_list|,
name|rs2
argument_list|)
expr_stmt|;
name|__fpu_compare
argument_list|(
name|fe
argument_list|,
literal|1
argument_list|,
name|IF_F3_CC
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|__fpu_cmpck
argument_list|(
name|fe
argument_list|)
operator|)
return|;
case|case
name|FOP
argument_list|(
name|INS2_FPop1
argument_list|,
name|INSFP1_FMOV
argument_list|)
case|:
comment|/* these should all be pretty obvious */
name|__fpu_mov
argument_list|(
name|fe
argument_list|,
name|type
argument_list|,
name|rd
argument_list|,
name|rs2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FOP
argument_list|(
name|INS2_FPop1
argument_list|,
name|INSFP1_FNEG
argument_list|)
case|:
name|__fpu_mov
argument_list|(
name|fe
argument_list|,
name|type
argument_list|,
name|rd
argument_list|,
name|rs2
argument_list|,
literal|0
argument_list|,
operator|(
literal|1
operator|<<
literal|31
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FOP
argument_list|(
name|INS2_FPop1
argument_list|,
name|INSFP1_FABS
argument_list|)
case|:
name|__fpu_mov
argument_list|(
name|fe
argument_list|,
name|type
argument_list|,
name|rd
argument_list|,
name|rs2
argument_list|,
operator|(
literal|1
operator|<<
literal|31
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FOP
argument_list|(
name|INS2_FPop1
argument_list|,
name|INSFP1_FSQRT
argument_list|)
case|:
name|__fpu_explode
argument_list|(
name|fe
argument_list|,
operator|&
name|fe
operator|->
name|fe_f1
argument_list|,
name|type
argument_list|,
name|rs2
argument_list|)
expr_stmt|;
name|fp
operator|=
name|__fpu_sqrt
argument_list|(
name|fe
argument_list|)
expr_stmt|;
break|break;
case|case
name|FOP
argument_list|(
name|INS2_FPop1
argument_list|,
name|INSFP1_FADD
argument_list|)
case|:
name|__fpu_explode
argument_list|(
name|fe
argument_list|,
operator|&
name|fe
operator|->
name|fe_f1
argument_list|,
name|type
argument_list|,
name|rs1
argument_list|)
expr_stmt|;
name|__fpu_explode
argument_list|(
name|fe
argument_list|,
operator|&
name|fe
operator|->
name|fe_f2
argument_list|,
name|type
argument_list|,
name|rs2
argument_list|)
expr_stmt|;
name|fp
operator|=
name|__fpu_add
argument_list|(
name|fe
argument_list|)
expr_stmt|;
break|break;
case|case
name|FOP
argument_list|(
name|INS2_FPop1
argument_list|,
name|INSFP1_FSUB
argument_list|)
case|:
name|__fpu_explode
argument_list|(
name|fe
argument_list|,
operator|&
name|fe
operator|->
name|fe_f1
argument_list|,
name|type
argument_list|,
name|rs1
argument_list|)
expr_stmt|;
name|__fpu_explode
argument_list|(
name|fe
argument_list|,
operator|&
name|fe
operator|->
name|fe_f2
argument_list|,
name|type
argument_list|,
name|rs2
argument_list|)
expr_stmt|;
name|fp
operator|=
name|__fpu_sub
argument_list|(
name|fe
argument_list|)
expr_stmt|;
break|break;
case|case
name|FOP
argument_list|(
name|INS2_FPop1
argument_list|,
name|INSFP1_FMUL
argument_list|)
case|:
name|__fpu_explode
argument_list|(
name|fe
argument_list|,
operator|&
name|fe
operator|->
name|fe_f1
argument_list|,
name|type
argument_list|,
name|rs1
argument_list|)
expr_stmt|;
name|__fpu_explode
argument_list|(
name|fe
argument_list|,
operator|&
name|fe
operator|->
name|fe_f2
argument_list|,
name|type
argument_list|,
name|rs2
argument_list|)
expr_stmt|;
name|fp
operator|=
name|__fpu_mul
argument_list|(
name|fe
argument_list|)
expr_stmt|;
break|break;
case|case
name|FOP
argument_list|(
name|INS2_FPop1
argument_list|,
name|INSFP1_FDIV
argument_list|)
case|:
name|__fpu_explode
argument_list|(
name|fe
argument_list|,
operator|&
name|fe
operator|->
name|fe_f1
argument_list|,
name|type
argument_list|,
name|rs1
argument_list|)
expr_stmt|;
name|__fpu_explode
argument_list|(
name|fe
argument_list|,
operator|&
name|fe
operator|->
name|fe_f2
argument_list|,
name|type
argument_list|,
name|rs2
argument_list|)
expr_stmt|;
name|fp
operator|=
name|__fpu_div
argument_list|(
name|fe
argument_list|)
expr_stmt|;
break|break;
case|case
name|FOP
argument_list|(
name|INS2_FPop1
argument_list|,
name|INSFP1_FsMULd
argument_list|)
case|:
case|case
name|FOP
argument_list|(
name|INS2_FPop1
argument_list|,
name|INSFP1_FdMULq
argument_list|)
case|:
if|if
condition|(
name|type
operator|==
name|FTYPE_EXT
condition|)
return|return
operator|(
name|SIGILL
operator|)
return|;
name|__fpu_explode
argument_list|(
name|fe
argument_list|,
operator|&
name|fe
operator|->
name|fe_f1
argument_list|,
name|type
argument_list|,
name|rs1
argument_list|)
expr_stmt|;
name|__fpu_explode
argument_list|(
name|fe
argument_list|,
operator|&
name|fe
operator|->
name|fe_f2
argument_list|,
name|type
argument_list|,
name|rs2
argument_list|)
expr_stmt|;
name|type
operator|++
expr_stmt|;
comment|/* single to double, or double to quad */
comment|/* 		 * Recalculate rd (the old type applied for the source regs 		 * only, the target one has a different size). 		 */
name|rd
operator|=
name|RN_DECODE
argument_list|(
name|type
argument_list|,
name|IF_F3_RD
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|=
name|__fpu_mul
argument_list|(
name|fe
argument_list|)
expr_stmt|;
break|break;
case|case
name|FOP
argument_list|(
name|INS2_FPop1
argument_list|,
name|INSFP1_FxTOs
argument_list|)
case|:
case|case
name|FOP
argument_list|(
name|INS2_FPop1
argument_list|,
name|INSFP1_FxTOd
argument_list|)
case|:
case|case
name|FOP
argument_list|(
name|INS2_FPop1
argument_list|,
name|INSFP1_FxTOq
argument_list|)
case|:
name|type
operator|=
name|FTYPE_LNG
expr_stmt|;
name|__fpu_explode
argument_list|(
name|fe
argument_list|,
name|fp
operator|=
operator|&
name|fe
operator|->
name|fe_f1
argument_list|,
name|type
argument_list|,
name|rs2
argument_list|)
expr_stmt|;
comment|/* sneaky; depends on instruction encoding */
name|type
operator|=
operator|(
name|IF_F3_OPF
argument_list|(
name|insn
argument_list|)
operator|>>
literal|2
operator|)
operator|&
literal|3
expr_stmt|;
name|rd
operator|=
name|RN_DECODE
argument_list|(
name|type
argument_list|,
name|IF_F3_RD
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|FOP
argument_list|(
name|INS2_FPop1
argument_list|,
name|INSFP1_FTOx
argument_list|)
case|:
name|__fpu_explode
argument_list|(
name|fe
argument_list|,
name|fp
operator|=
operator|&
name|fe
operator|->
name|fe_f1
argument_list|,
name|type
argument_list|,
name|rs2
argument_list|)
expr_stmt|;
name|type
operator|=
name|FTYPE_LNG
expr_stmt|;
name|mask
operator|=
literal|1
expr_stmt|;
comment|/* needs 2 registers */
name|rd
operator|=
name|IF_F3_RD
argument_list|(
name|insn
argument_list|)
operator|&
operator|~
name|mask
expr_stmt|;
break|break;
case|case
name|FOP
argument_list|(
name|INS2_FPop1
argument_list|,
name|INSFP1_FTOs
argument_list|)
case|:
case|case
name|FOP
argument_list|(
name|INS2_FPop1
argument_list|,
name|INSFP1_FTOd
argument_list|)
case|:
case|case
name|FOP
argument_list|(
name|INS2_FPop1
argument_list|,
name|INSFP1_FTOq
argument_list|)
case|:
case|case
name|FOP
argument_list|(
name|INS2_FPop1
argument_list|,
name|INSFP1_FTOi
argument_list|)
case|:
name|__fpu_explode
argument_list|(
name|fe
argument_list|,
name|fp
operator|=
operator|&
name|fe
operator|->
name|fe_f1
argument_list|,
name|type
argument_list|,
name|rs2
argument_list|)
expr_stmt|;
comment|/* sneaky; depends on instruction encoding */
name|type
operator|=
operator|(
name|IF_F3_OPF
argument_list|(
name|insn
argument_list|)
operator|>>
literal|2
operator|)
operator|&
literal|3
expr_stmt|;
name|rd
operator|=
name|RN_DECODE
argument_list|(
name|type
argument_list|,
name|IF_F3_RD
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|SIGILL
operator|)
return|;
block|}
comment|/* 	 * ALU operation is complete.  Collapse the result and then check 	 * for exceptions.  If we got any, and they are enabled, do not 	 * alter the destination register, just stop with an exception. 	 * Otherwise set new current exceptions and accrue. 	 */
name|__fpu_implode
argument_list|(
name|fe
argument_list|,
name|fp
argument_list|,
name|type
argument_list|,
name|space
argument_list|)
expr_stmt|;
name|cx
operator|=
name|fe
operator|->
name|fe_cx
expr_stmt|;
if|if
condition|(
name|cx
operator|!=
literal|0
condition|)
block|{
name|mask
operator|=
operator|(
name|fsr
operator|>>
name|FSR_TEM_SHIFT
operator|)
operator|&
name|FSR_TEM_MASK
expr_stmt|;
if|if
condition|(
name|cx
operator|&
name|mask
condition|)
block|{
comment|/* not accrued??? */
name|fsr
operator|=
operator|(
name|fsr
operator|&
operator|~
name|FSR_FTT_MASK
operator|)
operator||
name|FSR_FTT
argument_list|(
name|FSR_FTT_IEEE
argument_list|)
operator||
name|FSR_CEXC
argument_list|(
name|cx_to_trapx
index|[
operator|(
name|cx
operator|&
name|mask
operator|)
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|SIGFPE
operator|)
return|;
block|}
name|fsr
operator||=
operator|(
name|cx
operator|<<
name|FSR_CEXC_SHIFT
operator|)
operator||
operator|(
name|cx
operator|<<
name|FSR_AEXC_SHIFT
operator|)
expr_stmt|;
block|}
name|fe
operator|->
name|fe_fsr
operator|=
name|fsr
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|FTYPE_INT
operator|||
name|type
operator|==
name|FTYPE_SNG
condition|)
name|__fpu_setreg
argument_list|(
name|rd
argument_list|,
name|space
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|OPSZ
argument_list|(
name|type
argument_list|)
condition|;
name|i
operator|+=
literal|2
control|)
block|{
name|__fpu_setreg64
argument_list|(
name|rd
operator|+
name|i
argument_list|,
operator|(
operator|(
name|u_int64_t
operator|)
name|space
index|[
name|i
index|]
operator|<<
literal|32
operator|)
operator||
name|space
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* success */
block|}
end_function

end_unit

