begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This software was developed by the Computer Systems Engineering group  * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and  * contributed to Berkeley.  *  * All advertising materials mentioning features or use of this software  * must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Lawrence Berkeley Laboratory.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)fpu_implode.c	8.1 (Berkeley) 6/11/93  *	$NetBSD: fpu_implode.c,v 1.8 2001/08/26 05:44:46 eeh Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * FPU subroutines: `implode' internal format numbers into the machine's  * `packed binary' format.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<machine/frame.h>
end_include

begin_include
include|#
directive|include
file|<machine/fp.h>
end_include

begin_include
include|#
directive|include
file|<machine/fsr.h>
end_include

begin_include
include|#
directive|include
file|<machine/ieee.h>
end_include

begin_include
include|#
directive|include
file|<machine/instr.h>
end_include

begin_include
include|#
directive|include
file|"fpu_arith.h"
end_include

begin_include
include|#
directive|include
file|"fpu_emu.h"
end_include

begin_include
include|#
directive|include
file|"fpu_extern.h"
end_include

begin_include
include|#
directive|include
file|"__sparc_utrap_private.h"
end_include

begin_function_decl
specifier|static
name|int
name|fpround
parameter_list|(
name|struct
name|fpemu
modifier|*
parameter_list|,
name|struct
name|fpn
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|toinf
parameter_list|(
name|struct
name|fpemu
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Round a number (algorithm from Motorola MC68882 manual, modified for  * our internal format).  Set inexact exception if rounding is required.  * Return true iff we rounded up.  *  * After rounding, we discard the guard and round bits by shifting right  * 2 bits (a la fpu_shr(), but we do not bother with fp->fp_sticky).  * This saves effort later.  *  * Note that we may leave the value 2.0 in fp->fp_mant; it is the caller's  * responsibility to fix this if necessary.  */
end_comment

begin_function
specifier|static
name|int
name|fpround
parameter_list|(
name|struct
name|fpemu
modifier|*
name|fe
parameter_list|,
name|struct
name|fpn
modifier|*
name|fp
parameter_list|)
block|{
name|u_int
name|m0
decl_stmt|,
name|m1
decl_stmt|,
name|m2
decl_stmt|,
name|m3
decl_stmt|;
name|int
name|gr
decl_stmt|,
name|s
decl_stmt|;
name|m0
operator|=
name|fp
operator|->
name|fp_mant
index|[
literal|0
index|]
expr_stmt|;
name|m1
operator|=
name|fp
operator|->
name|fp_mant
index|[
literal|1
index|]
expr_stmt|;
name|m2
operator|=
name|fp
operator|->
name|fp_mant
index|[
literal|2
index|]
expr_stmt|;
name|m3
operator|=
name|fp
operator|->
name|fp_mant
index|[
literal|3
index|]
expr_stmt|;
name|gr
operator|=
name|m3
operator|&
literal|3
expr_stmt|;
name|s
operator|=
name|fp
operator|->
name|fp_sticky
expr_stmt|;
comment|/* mant>>= FP_NG */
name|m3
operator|=
operator|(
name|m3
operator|>>
name|FP_NG
operator|)
operator||
operator|(
name|m2
operator|<<
operator|(
literal|32
operator|-
name|FP_NG
operator|)
operator|)
expr_stmt|;
name|m2
operator|=
operator|(
name|m2
operator|>>
name|FP_NG
operator|)
operator||
operator|(
name|m1
operator|<<
operator|(
literal|32
operator|-
name|FP_NG
operator|)
operator|)
expr_stmt|;
name|m1
operator|=
operator|(
name|m1
operator|>>
name|FP_NG
operator|)
operator||
operator|(
name|m0
operator|<<
operator|(
literal|32
operator|-
name|FP_NG
operator|)
operator|)
expr_stmt|;
name|m0
operator|>>=
name|FP_NG
expr_stmt|;
if|if
condition|(
operator|(
name|gr
operator||
name|s
operator|)
operator|==
literal|0
condition|)
comment|/* result is exact: no rounding needed */
goto|goto
name|rounddown
goto|;
name|fe
operator|->
name|fe_cx
operator||=
name|FSR_NX
expr_stmt|;
comment|/* inexact */
comment|/* Go to rounddown to round down; break to round up. */
switch|switch
condition|(
name|FSR_GET_RD
argument_list|(
name|fe
operator|->
name|fe_fsr
argument_list|)
condition|)
block|{
case|case
name|FSR_RD_N
case|:
default|default:
comment|/* 		 * Round only if guard is set (gr& 2).  If guard is set, 		 * but round& sticky both clear, then we want to round 		 * but have a tie, so round to even, i.e., add 1 iff odd. 		 */
if|if
condition|(
operator|(
name|gr
operator|&
literal|2
operator|)
operator|==
literal|0
condition|)
goto|goto
name|rounddown
goto|;
if|if
condition|(
operator|(
name|gr
operator|&
literal|1
operator|)
operator|||
name|fp
operator|->
name|fp_sticky
operator|||
operator|(
name|m3
operator|&
literal|1
operator|)
condition|)
break|break;
goto|goto
name|rounddown
goto|;
case|case
name|FSR_RD_Z
case|:
comment|/* Round towards zero, i.e., down. */
goto|goto
name|rounddown
goto|;
case|case
name|FSR_RD_NINF
case|:
comment|/* Round towards -Inf: up if negative, down if positive. */
if|if
condition|(
name|fp
operator|->
name|fp_sign
condition|)
break|break;
goto|goto
name|rounddown
goto|;
case|case
name|FSR_RD_PINF
case|:
comment|/* Round towards +Inf: up if positive, down otherwise. */
if|if
condition|(
operator|!
name|fp
operator|->
name|fp_sign
condition|)
break|break;
goto|goto
name|rounddown
goto|;
block|}
comment|/* Bump low bit of mantissa, with carry. */
name|FPU_ADDS
argument_list|(
name|m3
argument_list|,
name|m3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|FPU_ADDCS
argument_list|(
name|m2
argument_list|,
name|m2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FPU_ADDCS
argument_list|(
name|m1
argument_list|,
name|m1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|FPU_ADDC
argument_list|(
name|m0
argument_list|,
name|m0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fp_mant
index|[
literal|0
index|]
operator|=
name|m0
expr_stmt|;
name|fp
operator|->
name|fp_mant
index|[
literal|1
index|]
operator|=
name|m1
expr_stmt|;
name|fp
operator|->
name|fp_mant
index|[
literal|2
index|]
operator|=
name|m2
expr_stmt|;
name|fp
operator|->
name|fp_mant
index|[
literal|3
index|]
operator|=
name|m3
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
name|rounddown
label|:
name|fp
operator|->
name|fp_mant
index|[
literal|0
index|]
operator|=
name|m0
expr_stmt|;
name|fp
operator|->
name|fp_mant
index|[
literal|1
index|]
operator|=
name|m1
expr_stmt|;
name|fp
operator|->
name|fp_mant
index|[
literal|2
index|]
operator|=
name|m2
expr_stmt|;
name|fp
operator|->
name|fp_mant
index|[
literal|3
index|]
operator|=
name|m3
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * For overflow: return true if overflow is to go to +/-Inf, according  * to the sign of the overflowing result.  If false, overflow is to go  * to the largest magnitude value instead.  */
end_comment

begin_function
specifier|static
name|int
name|toinf
parameter_list|(
name|struct
name|fpemu
modifier|*
name|fe
parameter_list|,
name|int
name|sign
parameter_list|)
block|{
name|int
name|inf
decl_stmt|;
comment|/* look at rounding direction */
switch|switch
condition|(
name|FSR_GET_RD
argument_list|(
name|fe
operator|->
name|fe_fsr
argument_list|)
condition|)
block|{
default|default:
case|case
name|FSR_RD_N
case|:
comment|/* the nearest value is always Inf */
name|inf
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|FSR_RD_Z
case|:
comment|/* toward 0 => never towards Inf */
name|inf
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FSR_RD_PINF
case|:
comment|/* toward +Inf iff positive */
name|inf
operator|=
name|sign
operator|==
literal|0
expr_stmt|;
break|break;
case|case
name|FSR_RD_NINF
case|:
comment|/* toward -Inf iff negative */
name|inf
operator|=
name|sign
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|inf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * fpn -> int (int value returned as return value).  *  * N.B.: this conversion always rounds towards zero (this is a peculiarity  * of the SPARC instruction set).  */
end_comment

begin_function
name|u_int
name|__fpu_ftoi
parameter_list|(
name|fe
parameter_list|,
name|fp
parameter_list|)
name|struct
name|fpemu
modifier|*
name|fe
decl_stmt|;
name|struct
name|fpn
modifier|*
name|fp
decl_stmt|;
block|{
name|u_int
name|i
decl_stmt|;
name|int
name|sign
decl_stmt|,
name|exp
decl_stmt|;
name|sign
operator|=
name|fp
operator|->
name|fp_sign
expr_stmt|;
switch|switch
condition|(
name|fp
operator|->
name|fp_class
condition|)
block|{
case|case
name|FPC_ZERO
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FPC_NUM
case|:
comment|/* 		 * If exp>= 2^32, overflow.  Otherwise shift value right 		 * into last mantissa word (this will not exceed 0xffffffff), 		 * shifting any guard and round bits out into the sticky 		 * bit.  Then ``round'' towards zero, i.e., just set an 		 * inexact exception if sticky is set (see round()). 		 * If the result is> 0x80000000, or is positive and equals 		 * 0x80000000, overflow; otherwise the last fraction word 		 * is the result. 		 */
if|if
condition|(
operator|(
name|exp
operator|=
name|fp
operator|->
name|fp_exp
operator|)
operator|>=
literal|32
condition|)
break|break;
comment|/* NB: the following includes exp< 0 cases */
if|if
condition|(
name|__fpu_shr
argument_list|(
name|fp
argument_list|,
name|FP_NMANT
operator|-
literal|1
operator|-
name|exp
argument_list|)
operator|!=
literal|0
condition|)
name|fe
operator|->
name|fe_cx
operator||=
name|FSR_NX
expr_stmt|;
name|i
operator|=
name|fp
operator|->
name|fp_mant
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|>=
operator|(
operator|(
name|u_int
operator|)
literal|0x80000000
operator|+
name|sign
operator|)
condition|)
break|break;
return|return
operator|(
name|sign
condition|?
operator|-
name|i
else|:
name|i
operator|)
return|;
default|default:
comment|/* Inf, qNaN, sNaN */
break|break;
block|}
comment|/* overflow: replace any inexact exception with invalid */
name|fe
operator|->
name|fe_cx
operator|=
operator|(
name|fe
operator|->
name|fe_cx
operator|&
operator|~
name|FSR_NX
operator|)
operator||
name|FSR_NV
expr_stmt|;
return|return
operator|(
literal|0x7fffffff
operator|+
name|sign
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * fpn -> extended int (high bits of int value returned as return value).  *  * N.B.: this conversion always rounds towards zero (this is a peculiarity  * of the SPARC instruction set).  */
end_comment

begin_function
name|u_int
name|__fpu_ftox
parameter_list|(
name|fe
parameter_list|,
name|fp
parameter_list|,
name|res
parameter_list|)
name|struct
name|fpemu
modifier|*
name|fe
decl_stmt|;
name|struct
name|fpn
modifier|*
name|fp
decl_stmt|;
name|u_int
modifier|*
name|res
decl_stmt|;
block|{
name|u_int64_t
name|i
decl_stmt|;
name|int
name|sign
decl_stmt|,
name|exp
decl_stmt|;
name|sign
operator|=
name|fp
operator|->
name|fp_sign
expr_stmt|;
switch|switch
condition|(
name|fp
operator|->
name|fp_class
condition|)
block|{
case|case
name|FPC_ZERO
case|:
name|res
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FPC_NUM
case|:
comment|/* 		 * If exp>= 2^64, overflow.  Otherwise shift value 		 * right into last mantissa word (this will not exceed 		 * 0xffffffffffffffff), shifting any guard and round 		 * bits out into the sticky bit.  Then ``round'' towards 		 * zero, i.e., just set an inexact exception if sticky 		 * is set (see round()). 		 * If the result is> 0x8000000000000000, or is positive 		 * and equals 0x8000000000000000, overflow; otherwise 		 * the last fraction word is the result. 		 */
if|if
condition|(
operator|(
name|exp
operator|=
name|fp
operator|->
name|fp_exp
operator|)
operator|>=
literal|64
condition|)
break|break;
comment|/* NB: the following includes exp< 0 cases */
if|if
condition|(
name|__fpu_shr
argument_list|(
name|fp
argument_list|,
name|FP_NMANT
operator|-
literal|1
operator|-
name|exp
argument_list|)
operator|!=
literal|0
condition|)
name|fe
operator|->
name|fe_cx
operator||=
name|FSR_NX
expr_stmt|;
name|i
operator|=
operator|(
operator|(
name|u_int64_t
operator|)
name|fp
operator|->
name|fp_mant
index|[
literal|2
index|]
operator|<<
literal|32
operator|)
operator||
name|fp
operator|->
name|fp_mant
index|[
literal|3
index|]
expr_stmt|;
if|if
condition|(
name|i
operator|>=
operator|(
operator|(
name|u_int64_t
operator|)
literal|0x8000000000000000LL
operator|+
name|sign
operator|)
condition|)
break|break;
if|if
condition|(
name|sign
condition|)
name|i
operator|=
operator|-
name|i
expr_stmt|;
name|res
index|[
literal|1
index|]
operator|=
operator|(
name|int
operator|)
name|i
expr_stmt|;
return|return
operator|(
name|i
operator|>>
literal|32
operator|)
return|;
default|default:
comment|/* Inf, qNaN, sNaN */
break|break;
block|}
comment|/* overflow: replace any inexact exception with invalid */
name|fe
operator|->
name|fe_cx
operator|=
operator|(
name|fe
operator|->
name|fe_cx
operator|&
operator|~
name|FSR_NX
operator|)
operator||
name|FSR_NV
expr_stmt|;
return|return
operator|(
literal|0x7fffffffffffffffLL
operator|+
name|sign
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * fpn -> single (32 bit single returned as return value).  * We assume<= 29 bits in a single-precision fraction (1.f part).  */
end_comment

begin_function
name|u_int
name|__fpu_ftos
parameter_list|(
name|fe
parameter_list|,
name|fp
parameter_list|)
name|struct
name|fpemu
modifier|*
name|fe
decl_stmt|;
name|struct
name|fpn
modifier|*
name|fp
decl_stmt|;
block|{
name|u_int
name|sign
init|=
name|fp
operator|->
name|fp_sign
operator|<<
literal|31
decl_stmt|;
name|int
name|exp
decl_stmt|;
define|#
directive|define
name|SNG_EXP
parameter_list|(
name|e
parameter_list|)
value|((e)<< SNG_FRACBITS)
comment|/* makes e an exponent */
define|#
directive|define
name|SNG_MASK
value|(SNG_EXP(1) - 1)
comment|/* mask for fraction */
comment|/* Take care of non-numbers first. */
if|if
condition|(
name|ISNAN
argument_list|(
name|fp
argument_list|)
condition|)
block|{
comment|/* 		 * Preserve upper bits of NaN, per SPARC V8 appendix N. 		 * Note that fp->fp_mant[0] has the quiet bit set, 		 * even if it is classified as a signalling NaN. 		 */
operator|(
name|void
operator|)
name|__fpu_shr
argument_list|(
name|fp
argument_list|,
name|FP_NMANT
operator|-
literal|1
operator|-
name|SNG_FRACBITS
argument_list|)
expr_stmt|;
name|exp
operator|=
name|SNG_EXP_INFNAN
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|ISINF
argument_list|(
name|fp
argument_list|)
condition|)
return|return
operator|(
name|sign
operator||
name|SNG_EXP
argument_list|(
name|SNG_EXP_INFNAN
argument_list|)
operator|)
return|;
if|if
condition|(
name|ISZERO
argument_list|(
name|fp
argument_list|)
condition|)
return|return
operator|(
name|sign
operator|)
return|;
comment|/* 	 * Normals (including subnormals).  Drop all the fraction bits 	 * (including the explicit ``implied'' 1 bit) down into the 	 * single-precision range.  If the number is subnormal, move 	 * the ``implied'' 1 into the explicit range as well, and shift 	 * right to introduce leading zeroes.  Rounding then acts 	 * differently for normals and subnormals: the largest subnormal 	 * may round to the smallest normal (1.0 x 2^minexp), or may 	 * remain subnormal.  In the latter case, signal an underflow 	 * if the result was inexact or if underflow traps are enabled. 	 * 	 * Rounding a normal, on the other hand, always produces another 	 * normal (although either way the result might be too big for 	 * single precision, and cause an overflow).  If rounding a 	 * normal produces 2.0 in the fraction, we need not adjust that 	 * fraction at all, since both 1.0 and 2.0 are zero under the 	 * fraction mask. 	 * 	 * Note that the guard and round bits vanish from the number after 	 * rounding. 	 */
if|if
condition|(
operator|(
name|exp
operator|=
name|fp
operator|->
name|fp_exp
operator|+
name|SNG_EXP_BIAS
operator|)
operator|<=
literal|0
condition|)
block|{
comment|/* subnormal */
comment|/* -NG for g,r; -SNG_FRACBITS-exp for fraction */
operator|(
name|void
operator|)
name|__fpu_shr
argument_list|(
name|fp
argument_list|,
name|FP_NMANT
operator|-
name|FP_NG
operator|-
name|SNG_FRACBITS
operator|-
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fpround
argument_list|(
name|fe
argument_list|,
name|fp
argument_list|)
operator|&&
name|fp
operator|->
name|fp_mant
index|[
literal|3
index|]
operator|==
name|SNG_EXP
argument_list|(
literal|1
argument_list|)
condition|)
return|return
operator|(
name|sign
operator||
name|SNG_EXP
argument_list|(
literal|1
argument_list|)
operator||
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|fe
operator|->
name|fe_cx
operator|&
name|FSR_NX
operator|)
operator|||
operator|(
name|fe
operator|->
name|fe_fsr
operator|&
operator|(
name|FSR_UF
operator|<<
name|FSR_TEM_SHIFT
operator|)
operator|)
condition|)
name|fe
operator|->
name|fe_cx
operator||=
name|FSR_UF
expr_stmt|;
return|return
operator|(
name|sign
operator||
name|SNG_EXP
argument_list|(
literal|0
argument_list|)
operator||
name|fp
operator|->
name|fp_mant
index|[
literal|3
index|]
operator|)
return|;
block|}
comment|/* -FP_NG for g,r; -1 for implied 1; -SNG_FRACBITS for fraction */
operator|(
name|void
operator|)
name|__fpu_shr
argument_list|(
name|fp
argument_list|,
name|FP_NMANT
operator|-
name|FP_NG
operator|-
literal|1
operator|-
name|SNG_FRACBITS
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DIAGNOSTIC
if|if
condition|(
operator|(
name|fp
operator|->
name|fp_mant
index|[
literal|3
index|]
operator|&
name|SNG_EXP
argument_list|(
literal|1
operator|<<
name|FP_NG
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|__utrap_panic
argument_list|(
literal|"fpu_ftos"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fpround
argument_list|(
name|fe
argument_list|,
name|fp
argument_list|)
operator|&&
name|fp
operator|->
name|fp_mant
index|[
literal|3
index|]
operator|==
name|SNG_EXP
argument_list|(
literal|2
argument_list|)
condition|)
name|exp
operator|++
expr_stmt|;
if|if
condition|(
name|exp
operator|>=
name|SNG_EXP_INFNAN
condition|)
block|{
comment|/* overflow to inf or to max single */
name|fe
operator|->
name|fe_cx
operator||=
name|FSR_OF
operator||
name|FSR_NX
expr_stmt|;
if|if
condition|(
name|toinf
argument_list|(
name|fe
argument_list|,
name|sign
argument_list|)
condition|)
return|return
operator|(
name|sign
operator||
name|SNG_EXP
argument_list|(
name|SNG_EXP_INFNAN
argument_list|)
operator|)
return|;
return|return
operator|(
name|sign
operator||
name|SNG_EXP
argument_list|(
name|SNG_EXP_INFNAN
operator|-
literal|1
argument_list|)
operator||
name|SNG_MASK
operator|)
return|;
block|}
name|done
label|:
comment|/* phew, made it */
return|return
operator|(
name|sign
operator||
name|SNG_EXP
argument_list|(
name|exp
argument_list|)
operator||
operator|(
name|fp
operator|->
name|fp_mant
index|[
literal|3
index|]
operator|&
name|SNG_MASK
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * fpn -> double (32 bit high-order result returned; 32-bit low order result  * left in res[1]).  Assumes<= 61 bits in double precision fraction.  *  * This code mimics fpu_ftos; see it for comments.  */
end_comment

begin_function
name|u_int
name|__fpu_ftod
parameter_list|(
name|fe
parameter_list|,
name|fp
parameter_list|,
name|res
parameter_list|)
name|struct
name|fpemu
modifier|*
name|fe
decl_stmt|;
name|struct
name|fpn
modifier|*
name|fp
decl_stmt|;
name|u_int
modifier|*
name|res
decl_stmt|;
block|{
name|u_int
name|sign
init|=
name|fp
operator|->
name|fp_sign
operator|<<
literal|31
decl_stmt|;
name|int
name|exp
decl_stmt|;
define|#
directive|define
name|DBL_EXP
parameter_list|(
name|e
parameter_list|)
value|((e)<< (DBL_FRACBITS& 31))
define|#
directive|define
name|DBL_MASK
value|(DBL_EXP(1) - 1)
if|if
condition|(
name|ISNAN
argument_list|(
name|fp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|__fpu_shr
argument_list|(
name|fp
argument_list|,
name|FP_NMANT
operator|-
literal|1
operator|-
name|DBL_FRACBITS
argument_list|)
expr_stmt|;
name|exp
operator|=
name|DBL_EXP_INFNAN
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|ISINF
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|sign
operator||=
name|DBL_EXP
argument_list|(
name|DBL_EXP_INFNAN
argument_list|)
expr_stmt|;
goto|goto
name|zero
goto|;
block|}
if|if
condition|(
name|ISZERO
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|zero
label|:
name|res
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|sign
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|exp
operator|=
name|fp
operator|->
name|fp_exp
operator|+
name|DBL_EXP_BIAS
operator|)
operator|<=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|__fpu_shr
argument_list|(
name|fp
argument_list|,
name|FP_NMANT
operator|-
name|FP_NG
operator|-
name|DBL_FRACBITS
operator|-
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fpround
argument_list|(
name|fe
argument_list|,
name|fp
argument_list|)
operator|&&
name|fp
operator|->
name|fp_mant
index|[
literal|2
index|]
operator|==
name|DBL_EXP
argument_list|(
literal|1
argument_list|)
condition|)
block|{
name|res
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|sign
operator||
name|DBL_EXP
argument_list|(
literal|1
argument_list|)
operator||
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|fe
operator|->
name|fe_cx
operator|&
name|FSR_NX
operator|)
operator|||
operator|(
name|fe
operator|->
name|fe_fsr
operator|&
operator|(
name|FSR_UF
operator|<<
name|FSR_TEM_SHIFT
operator|)
operator|)
condition|)
name|fe
operator|->
name|fe_cx
operator||=
name|FSR_UF
expr_stmt|;
name|exp
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
operator|(
name|void
operator|)
name|__fpu_shr
argument_list|(
name|fp
argument_list|,
name|FP_NMANT
operator|-
name|FP_NG
operator|-
literal|1
operator|-
name|DBL_FRACBITS
argument_list|)
expr_stmt|;
if|if
condition|(
name|fpround
argument_list|(
name|fe
argument_list|,
name|fp
argument_list|)
operator|&&
name|fp
operator|->
name|fp_mant
index|[
literal|2
index|]
operator|==
name|DBL_EXP
argument_list|(
literal|2
argument_list|)
condition|)
name|exp
operator|++
expr_stmt|;
if|if
condition|(
name|exp
operator|>=
name|DBL_EXP_INFNAN
condition|)
block|{
name|fe
operator|->
name|fe_cx
operator||=
name|FSR_OF
operator||
name|FSR_NX
expr_stmt|;
if|if
condition|(
name|toinf
argument_list|(
name|fe
argument_list|,
name|sign
argument_list|)
condition|)
block|{
name|res
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|sign
operator||
name|DBL_EXP
argument_list|(
name|DBL_EXP_INFNAN
argument_list|)
operator||
literal|0
operator|)
return|;
block|}
name|res
index|[
literal|1
index|]
operator|=
operator|~
literal|0
expr_stmt|;
return|return
operator|(
name|sign
operator||
name|DBL_EXP
argument_list|(
name|DBL_EXP_INFNAN
argument_list|)
operator||
name|DBL_MASK
operator|)
return|;
block|}
name|done
label|:
name|res
index|[
literal|1
index|]
operator|=
name|fp
operator|->
name|fp_mant
index|[
literal|3
index|]
expr_stmt|;
return|return
operator|(
name|sign
operator||
name|DBL_EXP
argument_list|(
name|exp
argument_list|)
operator||
operator|(
name|fp
operator|->
name|fp_mant
index|[
literal|2
index|]
operator|&
name|DBL_MASK
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * fpn -> extended (32 bit high-order result returned; low-order fraction  * words left in res[1]..res[3]).  Like ftod, which is like ftos ... but  * our internal format *is* extended precision, plus 2 bits for guard/round,  * so we can avoid a small bit of work.  */
end_comment

begin_function
name|u_int
name|__fpu_ftoq
parameter_list|(
name|fe
parameter_list|,
name|fp
parameter_list|,
name|res
parameter_list|)
name|struct
name|fpemu
modifier|*
name|fe
decl_stmt|;
name|struct
name|fpn
modifier|*
name|fp
decl_stmt|;
name|u_int
modifier|*
name|res
decl_stmt|;
block|{
name|u_int
name|sign
init|=
name|fp
operator|->
name|fp_sign
operator|<<
literal|31
decl_stmt|;
name|int
name|exp
decl_stmt|;
define|#
directive|define
name|EXT_EXP
parameter_list|(
name|e
parameter_list|)
value|((e)<< (EXT_FRACBITS& 31))
define|#
directive|define
name|EXT_MASK
value|(EXT_EXP(1) - 1)
if|if
condition|(
name|ISNAN
argument_list|(
name|fp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|__fpu_shr
argument_list|(
name|fp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* since we are not rounding */
name|exp
operator|=
name|EXT_EXP_INFNAN
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|ISINF
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|sign
operator||=
name|EXT_EXP
argument_list|(
name|EXT_EXP_INFNAN
argument_list|)
expr_stmt|;
goto|goto
name|zero
goto|;
block|}
if|if
condition|(
name|ISZERO
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|zero
label|:
name|res
index|[
literal|1
index|]
operator|=
name|res
index|[
literal|2
index|]
operator|=
name|res
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|sign
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|exp
operator|=
name|fp
operator|->
name|fp_exp
operator|+
name|EXT_EXP_BIAS
operator|)
operator|<=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|__fpu_shr
argument_list|(
name|fp
argument_list|,
name|FP_NMANT
operator|-
name|FP_NG
operator|-
name|EXT_FRACBITS
operator|-
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fpround
argument_list|(
name|fe
argument_list|,
name|fp
argument_list|)
operator|&&
name|fp
operator|->
name|fp_mant
index|[
literal|0
index|]
operator|==
name|EXT_EXP
argument_list|(
literal|1
argument_list|)
condition|)
block|{
name|res
index|[
literal|1
index|]
operator|=
name|res
index|[
literal|2
index|]
operator|=
name|res
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|sign
operator||
name|EXT_EXP
argument_list|(
literal|1
argument_list|)
operator||
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|fe
operator|->
name|fe_cx
operator|&
name|FSR_NX
operator|)
operator|||
operator|(
name|fe
operator|->
name|fe_fsr
operator|&
operator|(
name|FSR_UF
operator|<<
name|FSR_TEM_SHIFT
operator|)
operator|)
condition|)
name|fe
operator|->
name|fe_cx
operator||=
name|FSR_UF
expr_stmt|;
name|exp
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* Since internal == extended, no need to shift here. */
if|if
condition|(
name|fpround
argument_list|(
name|fe
argument_list|,
name|fp
argument_list|)
operator|&&
name|fp
operator|->
name|fp_mant
index|[
literal|0
index|]
operator|==
name|EXT_EXP
argument_list|(
literal|2
argument_list|)
condition|)
name|exp
operator|++
expr_stmt|;
if|if
condition|(
name|exp
operator|>=
name|EXT_EXP_INFNAN
condition|)
block|{
name|fe
operator|->
name|fe_cx
operator||=
name|FSR_OF
operator||
name|FSR_NX
expr_stmt|;
if|if
condition|(
name|toinf
argument_list|(
name|fe
argument_list|,
name|sign
argument_list|)
condition|)
block|{
name|res
index|[
literal|1
index|]
operator|=
name|res
index|[
literal|2
index|]
operator|=
name|res
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|sign
operator||
name|EXT_EXP
argument_list|(
name|EXT_EXP_INFNAN
argument_list|)
operator||
literal|0
operator|)
return|;
block|}
name|res
index|[
literal|1
index|]
operator|=
name|res
index|[
literal|2
index|]
operator|=
name|res
index|[
literal|3
index|]
operator|=
operator|~
literal|0
expr_stmt|;
return|return
operator|(
name|sign
operator||
name|EXT_EXP
argument_list|(
name|EXT_EXP_INFNAN
argument_list|)
operator||
name|EXT_MASK
operator|)
return|;
block|}
name|done
label|:
name|res
index|[
literal|1
index|]
operator|=
name|fp
operator|->
name|fp_mant
index|[
literal|1
index|]
expr_stmt|;
name|res
index|[
literal|2
index|]
operator|=
name|fp
operator|->
name|fp_mant
index|[
literal|2
index|]
expr_stmt|;
name|res
index|[
literal|3
index|]
operator|=
name|fp
operator|->
name|fp_mant
index|[
literal|3
index|]
expr_stmt|;
return|return
operator|(
name|sign
operator||
name|EXT_EXP
argument_list|(
name|exp
argument_list|)
operator||
operator|(
name|fp
operator|->
name|fp_mant
index|[
literal|0
index|]
operator|&
name|EXT_MASK
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Implode an fpn, writing the result into the given space.  */
end_comment

begin_function
name|void
name|__fpu_implode
parameter_list|(
name|fe
parameter_list|,
name|fp
parameter_list|,
name|type
parameter_list|,
name|space
parameter_list|)
name|struct
name|fpemu
modifier|*
name|fe
decl_stmt|;
name|struct
name|fpn
modifier|*
name|fp
decl_stmt|;
name|int
name|type
decl_stmt|;
name|u_int
modifier|*
name|space
decl_stmt|;
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|FTYPE_LNG
case|:
name|space
index|[
literal|0
index|]
operator|=
name|__fpu_ftox
argument_list|(
name|fe
argument_list|,
name|fp
argument_list|,
name|space
argument_list|)
expr_stmt|;
break|break;
case|case
name|FTYPE_INT
case|:
name|space
index|[
literal|0
index|]
operator|=
name|__fpu_ftoi
argument_list|(
name|fe
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|FTYPE_SNG
case|:
name|space
index|[
literal|0
index|]
operator|=
name|__fpu_ftos
argument_list|(
name|fe
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|FTYPE_DBL
case|:
name|space
index|[
literal|0
index|]
operator|=
name|__fpu_ftod
argument_list|(
name|fe
argument_list|,
name|fp
argument_list|,
name|space
argument_list|)
expr_stmt|;
break|break;
case|case
name|FTYPE_EXT
case|:
comment|/* funky rounding precision options ?? */
name|space
index|[
literal|0
index|]
operator|=
name|__fpu_ftoq
argument_list|(
name|fe
argument_list|,
name|fp
argument_list|,
name|space
argument_list|)
expr_stmt|;
break|break;
default|default:
name|__utrap_panic
argument_list|(
literal|"fpu_implode"
argument_list|)
expr_stmt|;
block|}
name|DPRINTF
argument_list|(
name|FPE_REG
argument_list|,
operator|(
literal|"fpu_implode: %x %x %x %x\n"
operator|,
name|space
index|[
literal|0
index|]
operator|,
name|space
index|[
literal|1
index|]
operator|,
name|space
index|[
literal|2
index|]
operator|,
name|space
index|[
literal|3
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

