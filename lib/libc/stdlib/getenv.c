begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007 Sean C. Farley<scf@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer,  *    without modification, immediately at the beginning of the file.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Standard environ.  environ variable is exposed to entire process.  *  *	origEnviron:	Upon cleanup on unloading of library or failure, this  *			allows environ to return to as it was before.  *	environSize:	Number of variables environ can hold.  Can only  *			increase.  */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|origEnviron
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|environSize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Array of environment variables built from environ.  Each element records:  *	name:		Pointer to name=value string  *	name length:	Length of name not counting '=' character  *	value:		Pointer to value within same string as name  *	value size:	Size (not length) of space for value not counting the  *			nul character  *	active state:	true/false value to signify whether variable is active.  *			Useful since multiple variables with the same name can  *			co-exist.  At most, one variable can be active at any  *			one time.  *	putenv:		Created from putenv() call.  This memory must not be  *			reused.  */
end_comment

begin_struct
specifier|static
struct|struct
name|envVars
block|{
name|size_t
name|nameLen
decl_stmt|;
name|size_t
name|valueSize
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|bool
name|active
decl_stmt|;
name|bool
name|putenv
decl_stmt|;
block|}
modifier|*
name|envVars
init|=
name|NULL
struct|;
end_struct

begin_comment
comment|/*  * Environment array information.  *  *	envActive:	Number of active variables in array.  *	envVarsSize:	Size of array.  *	envVarsTotal:	Number of total variables in array (active or not).  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|envActive
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|envVarsSize
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|envVarsTotal
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Deinitialization of new environment. */
end_comment

begin_decl_stmt
specifier|static
name|void
name|__attribute__
argument_list|(
operator|(
name|destructor
operator|)
argument_list|)
name|__clean_env
argument_list|(
name|void
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Inline strlen() for performance.  Also, perform check for an equals sign.  * Cheaper here than peforming a strchr() later.  */
end_comment

begin_function
specifier|static
specifier|inline
name|size_t
name|__strleneq
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
for|for
control|(
name|s
operator|=
name|str
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
operator|++
name|s
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'='
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|s
operator|-
name|str
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Comparison of an environment name=value to a name.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|strncmpeq
parameter_list|(
specifier|const
name|char
modifier|*
name|nameValue
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|size_t
name|nameLen
parameter_list|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|nameValue
argument_list|,
name|name
argument_list|,
name|nameLen
argument_list|)
operator|==
literal|0
operator|&&
name|nameValue
index|[
name|nameLen
index|]
operator|==
literal|'='
condition|)
return|return
operator|(
name|true
operator|)
return|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Using environment, returns pointer to value associated with name, if any,  * else NULL.  If the onlyActive flag is set to true, only variables that are  * active are returned else all are.  */
end_comment

begin_function
specifier|static
specifier|inline
name|char
modifier|*
name|__findenv
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|size_t
name|nameLen
parameter_list|,
name|int
modifier|*
name|envNdx
parameter_list|,
name|bool
name|onlyActive
parameter_list|)
block|{
name|int
name|ndx
decl_stmt|;
comment|/* 	 * Find environment variable from end of array (more likely to be 	 * active).  A variable created by putenv is always active or it is not 	 * tracked in the array. 	 */
for|for
control|(
name|ndx
operator|=
operator|*
name|envNdx
init|;
name|ndx
operator|>=
literal|0
condition|;
name|ndx
operator|--
control|)
if|if
condition|(
name|envVars
index|[
name|ndx
index|]
operator|.
name|putenv
condition|)
block|{
if|if
condition|(
name|strncmpeq
argument_list|(
name|envVars
index|[
name|ndx
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|,
name|nameLen
argument_list|)
condition|)
block|{
operator|*
name|envNdx
operator|=
name|ndx
expr_stmt|;
return|return
operator|(
name|envVars
index|[
name|ndx
index|]
operator|.
name|name
operator|+
name|nameLen
operator|+
sizeof|sizeof
argument_list|(
literal|"="
argument_list|)
operator|-
literal|1
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
operator|!
name|onlyActive
operator|||
name|envVars
index|[
name|ndx
index|]
operator|.
name|active
operator|)
operator|&&
operator|(
name|envVars
index|[
name|ndx
index|]
operator|.
name|nameLen
operator|==
name|nameLen
operator|&&
name|strncmpeq
argument_list|(
name|envVars
index|[
name|ndx
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|,
name|nameLen
argument_list|)
operator|)
condition|)
block|{
operator|*
name|envNdx
operator|=
name|ndx
expr_stmt|;
return|return
operator|(
name|envVars
index|[
name|ndx
index|]
operator|.
name|value
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Using environ, returns pointer to value associated with name, if any, else  * NULL.  Used on the original environ passed into the program.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|__findenv_environ
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|size_t
name|nameLen
parameter_list|)
block|{
name|int
name|envNdx
decl_stmt|;
comment|/* Check for non-existant environment. */
if|if
condition|(
name|environ
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Find variable within environ. */
for|for
control|(
name|envNdx
operator|=
literal|0
init|;
name|environ
index|[
name|envNdx
index|]
operator|!=
name|NULL
condition|;
name|envNdx
operator|++
control|)
if|if
condition|(
name|strncmpeq
argument_list|(
name|environ
index|[
name|envNdx
index|]
argument_list|,
name|name
argument_list|,
name|nameLen
argument_list|)
condition|)
return|return
operator|(
operator|&
operator|(
name|environ
index|[
name|envNdx
index|]
index|[
name|nameLen
operator|+
sizeof|sizeof
argument_list|(
literal|"="
argument_list|)
operator|-
literal|1
index|]
operator|)
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Using the environment, rebuild the environ array for use by other C library  * calls that depend upon it.  */
end_comment

begin_function
specifier|static
name|int
name|__rebuild_environ
parameter_list|(
name|int
name|newEnvironSize
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|tmpEnviron
decl_stmt|;
name|int
name|envNdx
decl_stmt|;
name|int
name|environNdx
decl_stmt|;
name|int
name|tmpEnvironSize
decl_stmt|;
comment|/* Resize environ. */
if|if
condition|(
name|newEnvironSize
operator|>
name|environSize
condition|)
block|{
name|tmpEnvironSize
operator|=
name|newEnvironSize
operator|*
literal|2
expr_stmt|;
name|tmpEnviron
operator|=
name|realloc
argument_list|(
name|environ
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|environ
argument_list|)
operator|*
operator|(
name|tmpEnvironSize
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpEnviron
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|environSize
operator|=
name|tmpEnvironSize
expr_stmt|;
name|environ
operator|=
name|tmpEnviron
expr_stmt|;
block|}
name|envActive
operator|=
name|newEnvironSize
expr_stmt|;
comment|/* Assign active variables to environ. */
for|for
control|(
name|envNdx
operator|=
name|envVarsTotal
operator|-
literal|1
operator|,
name|environNdx
operator|=
literal|0
init|;
name|envNdx
operator|>=
literal|0
condition|;
name|envNdx
operator|--
control|)
if|if
condition|(
name|envVars
index|[
name|envNdx
index|]
operator|.
name|active
condition|)
name|environ
index|[
name|environNdx
operator|++
index|]
operator|=
name|envVars
index|[
name|envNdx
index|]
operator|.
name|name
expr_stmt|;
name|environ
index|[
name|environNdx
index|]
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Enlarge new environment.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|__enlarge_env
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|newEnvVarsSize
decl_stmt|;
name|struct
name|envVars
modifier|*
name|tmpEnvVars
decl_stmt|;
name|envVarsTotal
operator|++
expr_stmt|;
if|if
condition|(
name|envVarsTotal
operator|>
name|envVarsSize
condition|)
block|{
name|newEnvVarsSize
operator|=
name|envVarsTotal
operator|*
literal|2
expr_stmt|;
name|tmpEnvVars
operator|=
name|realloc
argument_list|(
name|envVars
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|envVars
argument_list|)
operator|*
name|newEnvVarsSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpEnvVars
operator|==
name|NULL
condition|)
block|{
name|envVarsTotal
operator|--
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
name|envVarsSize
operator|=
name|newEnvVarsSize
expr_stmt|;
name|envVars
operator|=
name|tmpEnvVars
expr_stmt|;
block|}
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Using environ, build an environment for use by standard C library calls.  */
end_comment

begin_function
specifier|static
name|int
name|__build_env
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|env
decl_stmt|;
name|int
name|activeNdx
decl_stmt|;
name|int
name|envNdx
decl_stmt|;
name|int
name|rtrnVal
decl_stmt|;
name|int
name|savedErrno
decl_stmt|;
name|size_t
name|nameLen
decl_stmt|;
comment|/* Check for non-existant environment. */
if|if
condition|(
name|environ
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|environ
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
goto|goto
name|SaveEnviron
goto|;
comment|/* Count environment variables. */
for|for
control|(
name|env
operator|=
name|environ
operator|,
name|envVarsTotal
operator|=
literal|0
init|;
operator|*
name|env
operator|!=
name|NULL
condition|;
name|env
operator|++
control|)
name|envVarsTotal
operator|++
expr_stmt|;
name|envVarsSize
operator|=
name|envVarsTotal
operator|*
literal|2
expr_stmt|;
comment|/* Create new environment. */
name|envVars
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|envVars
argument_list|)
operator|*
name|envVarsSize
argument_list|)
expr_stmt|;
if|if
condition|(
name|envVars
operator|==
name|NULL
condition|)
goto|goto
name|Failure
goto|;
comment|/* Copy environ values and keep track of them. */
for|for
control|(
name|envNdx
operator|=
name|envVarsTotal
operator|-
literal|1
init|;
name|envNdx
operator|>=
literal|0
condition|;
name|envNdx
operator|--
control|)
block|{
name|envVars
index|[
name|envNdx
index|]
operator|.
name|putenv
operator|=
name|false
expr_stmt|;
name|envVars
index|[
name|envNdx
index|]
operator|.
name|name
operator|=
name|strdup
argument_list|(
name|environ
index|[
name|envVarsTotal
operator|-
name|envNdx
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|envVars
index|[
name|envNdx
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
goto|goto
name|Failure
goto|;
name|envVars
index|[
name|envNdx
index|]
operator|.
name|value
operator|=
name|strchr
argument_list|(
name|envVars
index|[
name|envNdx
index|]
operator|.
name|name
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|envVars
index|[
name|envNdx
index|]
operator|.
name|value
operator|!=
name|NULL
condition|)
block|{
name|envVars
index|[
name|envNdx
index|]
operator|.
name|value
operator|++
expr_stmt|;
name|envVars
index|[
name|envNdx
index|]
operator|.
name|valueSize
operator|=
name|strlen
argument_list|(
name|envVars
index|[
name|envNdx
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"environment corrupt; missing value for %s"
argument_list|,
name|envVars
index|[
name|envNdx
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|Failure
goto|;
block|}
comment|/* 		 * Find most current version of variable to make active.  This 		 * will prevent multiple active variables from being created 		 * during this initialization phase. 		 */
name|nameLen
operator|=
name|envVars
index|[
name|envNdx
index|]
operator|.
name|value
operator|-
name|envVars
index|[
name|envNdx
index|]
operator|.
name|name
operator|-
literal|1
expr_stmt|;
name|envVars
index|[
name|envNdx
index|]
operator|.
name|nameLen
operator|=
name|nameLen
expr_stmt|;
name|activeNdx
operator|=
name|envVarsTotal
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|__findenv
argument_list|(
name|envVars
index|[
name|envNdx
index|]
operator|.
name|name
argument_list|,
name|nameLen
argument_list|,
operator|&
name|activeNdx
argument_list|,
name|false
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|warnx
argument_list|(
literal|"environment corrupt; unable to find %.*s"
argument_list|,
name|nameLen
argument_list|,
name|envVars
index|[
name|envNdx
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|errno
operator|=
name|EFAULT
expr_stmt|;
goto|goto
name|Failure
goto|;
block|}
name|envVars
index|[
name|activeNdx
index|]
operator|.
name|active
operator|=
name|true
expr_stmt|;
block|}
comment|/* Create a new environ. */
name|SaveEnviron
label|:
name|origEnviron
operator|=
name|environ
expr_stmt|;
name|environ
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|envVarsTotal
operator|>
literal|0
condition|)
block|{
name|rtrnVal
operator|=
name|__rebuild_environ
argument_list|(
name|envVarsTotal
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtrnVal
operator|==
operator|-
literal|1
condition|)
block|{
name|savedErrno
operator|=
name|errno
expr_stmt|;
name|__clean_env
argument_list|()
expr_stmt|;
name|errno
operator|=
name|savedErrno
expr_stmt|;
block|}
block|}
else|else
name|rtrnVal
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|rtrnVal
operator|)
return|;
name|Failure
label|:
name|savedErrno
operator|=
name|errno
expr_stmt|;
name|__clean_env
argument_list|()
expr_stmt|;
name|errno
operator|=
name|savedErrno
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove variable added by putenv() from variable tracking array.  */
end_comment

begin_function
specifier|static
name|void
name|__remove_putenv
parameter_list|(
name|int
name|envNdx
parameter_list|)
block|{
name|memmove
argument_list|(
operator|&
operator|(
name|envVars
index|[
name|envNdx
index|]
operator|)
argument_list|,
operator|&
operator|(
name|envVars
index|[
name|envNdx
operator|+
literal|1
index|]
operator|)
argument_list|,
operator|(
name|envVarsTotal
operator|-
name|envNdx
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|envVars
argument_list|)
argument_list|)
expr_stmt|;
name|envVarsTotal
operator|--
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * Deallocate the environment built from environ as well as environ then set  * both to NULL.  Eases debugging of memory leaks.  */
end_comment

begin_function
specifier|static
name|void
name|__clean_env
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|envNdx
decl_stmt|;
comment|/* Deallocate environment and environ if created by *env(). */
if|if
condition|(
name|envVars
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|envNdx
operator|=
literal|0
init|;
name|envNdx
operator|<
name|envVarsTotal
condition|;
name|envNdx
operator|++
control|)
if|if
condition|(
operator|!
name|envVars
index|[
name|envNdx
index|]
operator|.
name|putenv
condition|)
name|free
argument_list|(
name|envVars
index|[
name|envNdx
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|envVars
argument_list|)
expr_stmt|;
name|envVars
operator|=
name|NULL
expr_stmt|;
comment|/* Restore original environ. */
if|if
condition|(
name|origEnviron
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|environ
argument_list|)
expr_stmt|;
name|environ
operator|=
name|origEnviron
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * Returns the value of a variable or NULL if none are found.  */
end_comment

begin_function
name|char
modifier|*
name|getenv
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|envNdx
decl_stmt|;
name|size_t
name|nameLen
decl_stmt|;
comment|/* Check for malformed name. */
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
operator|(
name|nameLen
operator|=
name|__strleneq
argument_list|(
name|name
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Find environment variable via environ or rebuilt environment. */
if|if
condition|(
name|envVars
operator|==
name|NULL
condition|)
return|return
operator|(
name|__findenv_environ
argument_list|(
name|name
argument_list|,
name|nameLen
argument_list|)
operator|)
return|;
else|else
block|{
name|envNdx
operator|=
name|envVarsTotal
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|__findenv
argument_list|(
name|name
argument_list|,
name|nameLen
argument_list|,
operator|&
name|envNdx
argument_list|,
name|true
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Set the value of a variable.  Older settings are labeled as inactive.  If an  * older setting has enough room to store the new value, it will be reused.  No  * previous variables are ever freed here to avoid causing a segmentation fault  * in a user's code.  */
end_comment

begin_function
name|int
name|setenv
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|int
name|overwrite
parameter_list|)
block|{
name|bool
name|reuse
decl_stmt|;
name|char
modifier|*
name|env
decl_stmt|;
name|int
name|envNdx
decl_stmt|;
name|int
name|newEnvActive
decl_stmt|;
name|size_t
name|nameLen
decl_stmt|;
name|size_t
name|valueLen
decl_stmt|;
comment|/* Check for malformed name. */
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
operator|(
name|nameLen
operator|=
name|__strleneq
argument_list|(
name|name
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Initialize environment. */
if|if
condition|(
name|envVars
operator|==
name|NULL
operator|&&
name|__build_env
argument_list|()
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Find existing environment variable large enough to use. */
name|envNdx
operator|=
name|envVarsTotal
operator|-
literal|1
expr_stmt|;
name|newEnvActive
operator|=
name|envActive
expr_stmt|;
name|valueLen
operator|=
name|strlen
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|reuse
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|__findenv
argument_list|(
name|name
argument_list|,
name|nameLen
argument_list|,
operator|&
name|envNdx
argument_list|,
name|false
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Deactivate entry if overwrite is allowed. */
if|if
condition|(
name|envVars
index|[
name|envNdx
index|]
operator|.
name|active
condition|)
block|{
if|if
condition|(
name|overwrite
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|envVars
index|[
name|envNdx
index|]
operator|.
name|active
operator|=
name|false
expr_stmt|;
name|newEnvActive
operator|--
expr_stmt|;
block|}
comment|/* putenv() created variable cannot be reused. */
if|if
condition|(
name|envVars
index|[
name|envNdx
index|]
operator|.
name|putenv
condition|)
name|__remove_putenv
argument_list|(
name|envNdx
argument_list|)
expr_stmt|;
comment|/* Entry is large enough to reuse. */
elseif|else
if|if
condition|(
name|envVars
index|[
name|envNdx
index|]
operator|.
name|valueSize
operator|>=
name|valueLen
condition|)
name|reuse
operator|=
name|true
expr_stmt|;
block|}
comment|/* Create new variable if none was found of sufficient size. */
if|if
condition|(
operator|!
name|reuse
condition|)
block|{
comment|/* Enlarge environment. */
name|envNdx
operator|=
name|envVarsTotal
expr_stmt|;
if|if
condition|(
operator|!
name|__enlarge_env
argument_list|()
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Create environment entry. */
name|envVars
index|[
name|envNdx
index|]
operator|.
name|name
operator|=
name|malloc
argument_list|(
name|nameLen
operator|+
sizeof|sizeof
argument_list|(
literal|"="
argument_list|)
operator|+
name|valueLen
argument_list|)
expr_stmt|;
if|if
condition|(
name|envVars
index|[
name|envNdx
index|]
operator|.
name|name
operator|==
name|NULL
condition|)
block|{
name|envVarsTotal
operator|--
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|envVars
index|[
name|envNdx
index|]
operator|.
name|nameLen
operator|=
name|nameLen
expr_stmt|;
name|envVars
index|[
name|envNdx
index|]
operator|.
name|valueSize
operator|=
name|valueLen
expr_stmt|;
comment|/* Save name of name/value pair. */
name|env
operator|=
name|stpcpy
argument_list|(
name|envVars
index|[
name|envNdx
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|envVars
index|[
name|envNdx
index|]
operator|.
name|name
operator|)
index|[
name|nameLen
index|]
operator|!=
literal|'='
condition|)
name|env
operator|=
name|stpcpy
argument_list|(
name|env
argument_list|,
literal|"="
argument_list|)
expr_stmt|;
block|}
else|else
name|env
operator|=
name|envVars
index|[
name|envNdx
index|]
operator|.
name|value
expr_stmt|;
comment|/* Save value of name/value pair. */
name|strcpy
argument_list|(
name|env
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|envVars
index|[
name|envNdx
index|]
operator|.
name|value
operator|=
name|env
expr_stmt|;
name|envVars
index|[
name|envNdx
index|]
operator|.
name|active
operator|=
name|true
expr_stmt|;
name|newEnvActive
operator|++
expr_stmt|;
comment|/* No need to rebuild environ if the variable was reused. */
if|if
condition|(
name|reuse
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|__rebuild_environ
argument_list|(
name|newEnvActive
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Insert a "name=value" string into then environment.  Special settings must be  * made to keep setenv() from reusing this memory block and unsetenv() from  * allowing it to be tracked.  */
end_comment

begin_function
name|int
name|putenv
parameter_list|(
name|char
modifier|*
name|string
parameter_list|)
block|{
name|char
modifier|*
name|equals
decl_stmt|;
name|int
name|envNdx
decl_stmt|;
name|int
name|newEnvActive
decl_stmt|;
name|size_t
name|nameLen
decl_stmt|;
comment|/* Check for malformed argument. */
if|if
condition|(
name|string
operator|==
name|NULL
operator|||
operator|(
name|equals
operator|=
name|strchr
argument_list|(
name|string
argument_list|,
literal|'='
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|nameLen
operator|=
name|equals
operator|-
name|string
operator|)
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Initialize environment. */
if|if
condition|(
name|envVars
operator|==
name|NULL
operator|&&
name|__build_env
argument_list|()
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Deactivate previous environment variable. */
name|envNdx
operator|=
name|envVarsTotal
operator|-
literal|1
expr_stmt|;
name|newEnvActive
operator|=
name|envActive
expr_stmt|;
if|if
condition|(
name|__findenv
argument_list|(
name|string
argument_list|,
name|nameLen
argument_list|,
operator|&
name|envNdx
argument_list|,
name|true
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Reuse previous putenv slot. */
if|if
condition|(
name|envVars
index|[
name|envNdx
index|]
operator|.
name|putenv
condition|)
block|{
name|envVars
index|[
name|envNdx
index|]
operator|.
name|name
operator|=
name|string
expr_stmt|;
return|return
operator|(
name|__rebuild_environ
argument_list|(
name|envActive
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|newEnvActive
operator|--
expr_stmt|;
name|envVars
index|[
name|envNdx
index|]
operator|.
name|active
operator|=
name|false
expr_stmt|;
block|}
block|}
comment|/* Enlarge environment. */
name|envNdx
operator|=
name|envVarsTotal
expr_stmt|;
if|if
condition|(
operator|!
name|__enlarge_env
argument_list|()
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Create environment entry. */
name|envVars
index|[
name|envNdx
index|]
operator|.
name|name
operator|=
name|string
expr_stmt|;
name|envVars
index|[
name|envNdx
index|]
operator|.
name|nameLen
operator|=
operator|-
literal|1
expr_stmt|;
name|envVars
index|[
name|envNdx
index|]
operator|.
name|value
operator|=
name|NULL
expr_stmt|;
name|envVars
index|[
name|envNdx
index|]
operator|.
name|valueSize
operator|=
operator|-
literal|1
expr_stmt|;
name|envVars
index|[
name|envNdx
index|]
operator|.
name|putenv
operator|=
name|true
expr_stmt|;
name|envVars
index|[
name|envNdx
index|]
operator|.
name|active
operator|=
name|true
expr_stmt|;
name|newEnvActive
operator|++
expr_stmt|;
return|return
operator|(
name|__rebuild_environ
argument_list|(
name|newEnvActive
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unset variable with the same name by flagging it as inactive.  No variable is  * ever freed.  */
end_comment

begin_function
name|int
name|unsetenv
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|envNdx
decl_stmt|;
name|size_t
name|nameLen
decl_stmt|;
comment|/* Check for malformed name. */
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
operator|(
name|nameLen
operator|=
name|__strleneq
argument_list|(
name|name
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Initialize environment. */
if|if
condition|(
name|envVars
operator|==
name|NULL
operator|&&
name|__build_env
argument_list|()
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Deactivate specified variable. */
name|envNdx
operator|=
name|envVarsTotal
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|__findenv
argument_list|(
name|name
argument_list|,
name|nameLen
argument_list|,
operator|&
name|envNdx
argument_list|,
name|true
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|envVars
index|[
name|envNdx
index|]
operator|.
name|active
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|envVars
index|[
name|envNdx
index|]
operator|.
name|putenv
condition|)
name|__remove_putenv
argument_list|(
name|envNdx
argument_list|)
expr_stmt|;
name|__rebuild_environ
argument_list|(
name|envActive
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

