begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|rcsid
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *  *                      Copyright 1990  *               Terry Jones& Jordan Hubbard  *  *		  PCS Computer Systeme, GmbH.  *	             Munich, West Germany  *  *  *  All rights reserved.  *  *  This is unsupported software and is subject to change without notice.  *  the author makes no representations about the suitability of this software  *  for any purpose. It is supplied "as is" without express or implied  *  warranty.  *  *  Permission to use, copy, modify, and distribute this software and its  *  documentation for any purpose and without fee is hereby granted, provided  *  that the above copyright notice appear in all copies and that both that  *  copyright notice and this permission notice appear in supporting  *  documentation, and that the name of the author not be used in  *  advertising or publicity pertaining to distribution of the software  *  without specific, written prior permission.  *  */
end_comment

begin_comment
comment|/*  * This is a fairly simple open addressing hash scheme.  * Terry did all the code, I just did the spec.  * Thanks again, you crazy Aussie..  *  */
end_comment

begin_comment
comment|/*  * $Log: strhash.c,v $  * Revision 2.0  90/03/26  01:44:26  jkh  * pre-beta check-in  *  * Revision 1.8  90/03/09  19:22:35  jkh  * Fixed bogus comment.  *  * Revision 1.7  90/03/09  19:01:08  jkh  * Added comments, GPL.  *  * Revision 1.6  90/03/08  17:55:58  terry  * Rearranged hash_purge to be a tiny bit more efficient.  * Added verbose option to hash_stats.  *  * Revision 1.5  90/03/08  17:19:54  terry  * Added hash_purge. Added arg to hash_traverse. Changed all  * void * to Generic.  *  * Revision 1.4  90/03/08  12:02:35  terry  * Fixed problems with allocation that I screwed up last night.  * Changed bucket lists to be singly linked. Thanks to JKH, my hero.  *  * Revision 1.3  90/03/07  21:33:33  terry  * Cleaned up a few decls to keep gcc -Wall quiet.  *  * Revision 1.2  90/03/07  21:14:53  terry  * Comments. Added HASH_STATS define. Removed hash_find()  * and new_node().  *  * Revision 1.1  90/03/07  20:49:45  terry  * Initial revision  *  *  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<strhash.h>
end_include

begin_define
define|#
directive|define
name|HASH_NULL
value|(hash_table *)0
end_define

begin_define
define|#
directive|define
name|NODE_NULL
value|(hash_node *)0
end_define

begin_define
define|#
directive|define
name|GENERIC_NULL
value|(void *)0
end_define

begin_define
define|#
directive|define
name|HASH_SZ
value|97
end_define

begin_function_decl
specifier|static
name|int
name|_hash
parameter_list|(
name|int
name|size
parameter_list|,
name|char
modifier|*
name|key
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|hash_node
modifier|*
name|list_find
parameter_list|(
name|caddr_t
name|key
parameter_list|,
name|hash_node
modifier|*
name|head
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * hash_create()  *  * Malloc room for a new hash table and then room for its  * bucket pointers. Then set all the buckets to  * point to 0. Return the address of the new table.  */
end_comment

begin_function
name|hash_table
modifier|*
name|hash_create
parameter_list|(
name|int
name|size
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|hash_table
modifier|*
name|new
init|=
operator|(
name|hash_table
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|hash_table
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|new
operator|||
name|size
operator|<
literal|0
condition|)
block|{
return|return
name|HASH_NULL
return|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
name|size
operator|=
name|HASH_SZ
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|new
operator|->
name|buckets
operator|=
operator|(
name|hash_node
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|size
operator|*
sizeof|sizeof
argument_list|(
name|hash_node
operator|*
argument_list|)
argument_list|)
operator|)
condition|)
block|{
return|return
name|HASH_NULL
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|new
operator|->
name|buckets
index|[
name|i
index|]
operator|=
name|NODE_NULL
expr_stmt|;
block|}
name|new
operator|->
name|size
operator|=
name|size
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/*  * list_find()  *  * Find the key in the linked list pointed to by head.  */
end_comment

begin_function
specifier|static
name|hash_node
modifier|*
name|list_find
parameter_list|(
name|caddr_t
name|key
parameter_list|,
name|hash_node
modifier|*
name|head
parameter_list|)
block|{
while|while
condition|(
name|head
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|head
operator|->
name|key
argument_list|,
name|key
argument_list|)
condition|)
block|{
return|return
name|head
return|;
block|}
name|head
operator|=
name|head
operator|->
name|next
expr_stmt|;
block|}
return|return
name|NODE_NULL
return|;
block|}
end_function

begin_comment
comment|/*  * _hash()  *  * Compute the hash value for the given key.  */
end_comment

begin_function
specifier|static
name|int
name|_hash
parameter_list|(
name|int
name|size
parameter_list|,
name|char
modifier|*
name|key
parameter_list|)
block|{
name|unsigned
name|int
name|h
init|=
literal|0x0
decl_stmt|;
while|while
condition|(
operator|*
name|key
condition|)
block|{
name|h
operator|=
operator|(
name|h
operator|<<
literal|1
operator|)
operator|^
operator|(
name|h
operator|^
operator|(
name|unsigned
name|char
operator|)
operator|*
name|key
operator|++
operator|)
expr_stmt|;
block|}
name|h
operator|%=
name|size
expr_stmt|;
return|return
name|h
return|;
block|}
end_function

begin_comment
comment|/*  * hash_destroy()  *  * Find the key and (if it's there) remove it entirely.  * The function (*nukefunc)() is in charge of disposing  * of the storage help by the data associated with the node.  */
end_comment

begin_function
name|void
name|hash_destroy
parameter_list|(
name|hash_table
modifier|*
name|table
parameter_list|,
name|char
modifier|*
name|key
parameter_list|,
name|void
function_decl|(
modifier|*
name|nukefunc
function_decl|)
parameter_list|()
parameter_list|)
block|{
name|int
name|bucket
init|=
name|_hash
argument_list|(
name|table
operator|->
name|size
argument_list|,
name|key
argument_list|)
decl_stmt|;
name|hash_node
modifier|*
name|found
init|=
name|table
operator|->
name|buckets
index|[
name|bucket
index|]
decl_stmt|;
name|hash_node
modifier|*
name|to_free
init|=
name|NODE_NULL
decl_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
block|{
return|return;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|found
operator|->
name|key
argument_list|,
name|key
argument_list|)
condition|)
block|{
comment|/* 	 * It was the head of the list. 	 */
name|table
operator|->
name|buckets
index|[
name|bucket
index|]
operator|=
name|found
operator|->
name|next
expr_stmt|;
name|to_free
operator|=
name|found
expr_stmt|;
block|}
else|else
block|{
comment|/* 	 * Walk the list, looking one ahead. 	 */
while|while
condition|(
name|found
operator|->
name|next
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|found
operator|->
name|next
operator|->
name|key
argument_list|,
name|key
argument_list|)
condition|)
block|{
name|to_free
operator|=
name|found
operator|->
name|next
expr_stmt|;
name|found
operator|->
name|next
operator|=
name|found
operator|->
name|next
operator|->
name|next
expr_stmt|;
break|break;
block|}
name|found
operator|=
name|found
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|to_free
condition|)
block|{
return|return;
block|}
block|}
if|if
condition|(
name|nukefunc
condition|)
call|(
modifier|*
name|nukefunc
call|)
argument_list|(
name|to_free
operator|->
name|key
argument_list|,
name|to_free
operator|->
name|data
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|to_free
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * hash_search()  *  * Search the table for the given key. Then:  *  * 1) If you find it and there is no replacement function, just  *    return what you found. (This is a simple search).  * 2) If you find it and there is a replacement function, run  *    the function on the data you found, and replace the old  *    data with whatever is passed in datum. Return 0.  * 3) If you don't find it and there is some datum, insert a  *    new item into the table. Insertions go at the front of  *    the bucket. Return 0.  * 4) Otherwise just return 0.  *  */
end_comment

begin_function
name|void
modifier|*
name|hash_search
parameter_list|(
name|hash_table
modifier|*
name|table
parameter_list|,
name|caddr_t
name|key
parameter_list|,
name|void
modifier|*
name|datum
parameter_list|,
name|void
function_decl|(
modifier|*
name|replace_func
function_decl|)
parameter_list|()
parameter_list|)
block|{
name|int
name|bucket
init|=
name|_hash
argument_list|(
name|table
operator|->
name|size
argument_list|,
name|key
argument_list|)
decl_stmt|;
name|hash_node
modifier|*
name|found
init|=
name|list_find
argument_list|(
name|key
argument_list|,
name|table
operator|->
name|buckets
index|[
name|bucket
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|found
condition|)
block|{
if|if
condition|(
operator|!
name|replace_func
condition|)
block|{
return|return
name|found
operator|->
name|data
return|;
block|}
else|else
block|{
call|(
modifier|*
name|replace_func
call|)
argument_list|(
name|found
operator|->
name|data
argument_list|)
expr_stmt|;
name|found
operator|->
name|data
operator|=
name|datum
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|datum
condition|)
block|{
specifier|static
name|int
name|assign_key
parameter_list|()
function_decl|;
name|hash_node
modifier|*
name|new
init|=
operator|(
name|hash_node
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|hash_node
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|new
operator|||
operator|!
name|assign_key
argument_list|(
name|key
argument_list|,
name|new
argument_list|)
condition|)
block|{
return|return
name|GENERIC_NULL
return|;
block|}
name|new
operator|->
name|data
operator|=
name|datum
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|table
operator|->
name|buckets
index|[
name|bucket
index|]
expr_stmt|;
name|table
operator|->
name|buckets
index|[
name|bucket
index|]
operator|=
name|new
expr_stmt|;
return|return
name|new
return|;
block|}
block|}
return|return
name|GENERIC_NULL
return|;
block|}
end_function

begin_comment
comment|/*  * assign_key()  *  * Set the key value of a node to be 'key'. Get some space from  * malloc and copy it in etc. Return 1 if all is well, 0 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|assign_key
parameter_list|(
name|char
modifier|*
name|key
parameter_list|,
name|hash_node
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
operator|!
name|node
operator|||
operator|!
name|key
condition|)
block|{
return|return
literal|0
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|node
operator|->
name|key
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|key
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
condition|)
block|{
return|return
literal|0
return|;
block|}
name|node
operator|->
name|key
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcat
argument_list|(
name|node
operator|->
name|key
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * hash_traverse()  *  * Traverse the hash table and run the function func on the  * data found at each node and the argument we're passed for it.  */
end_comment

begin_function
name|void
name|hash_traverse
parameter_list|(
name|hash_table
modifier|*
name|table
parameter_list|,
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|size
init|=
name|table
operator|->
name|size
decl_stmt|;
if|if
condition|(
operator|!
name|func
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|hash_node
modifier|*
name|n
init|=
name|table
operator|->
name|buckets
index|[
name|i
index|]
decl_stmt|;
while|while
condition|(
name|n
condition|)
block|{
if|if
condition|(
call|(
modifier|*
name|func
call|)
argument_list|(
name|n
operator|->
name|key
argument_list|,
name|n
operator|->
name|data
argument_list|,
name|arg
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
block|}
block|}
return|return;
block|}
end_function

begin_comment
comment|/*  * hash_purge()  *  * Run through the entire hash table. Call purge_func  * on the data found at each node, and then free the node.  * Set all the bucket pointers to 0.  */
end_comment

begin_function
name|void
name|hash_purge
parameter_list|(
name|hash_table
modifier|*
name|table
parameter_list|,
name|void
function_decl|(
modifier|*
name|purge_func
function_decl|)
parameter_list|(
name|char
modifier|*
name|p1
parameter_list|,
name|void
modifier|*
name|p2
parameter_list|)
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|size
init|=
name|table
operator|->
name|size
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|hash_node
modifier|*
name|n
init|=
name|table
operator|->
name|buckets
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|n
condition|)
block|{
do|do
block|{
name|hash_node
modifier|*
name|to_free
init|=
name|n
decl_stmt|;
if|if
condition|(
name|purge_func
condition|)
block|{
call|(
modifier|*
name|purge_func
call|)
argument_list|(
name|n
operator|->
name|key
argument_list|,
name|n
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|to_free
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|n
condition|)
do|;
name|table
operator|->
name|buckets
index|[
name|i
index|]
operator|=
name|NODE_NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_undef
undef|#
directive|undef
name|min
end_undef

begin_define
define|#
directive|define
name|min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(a)< (b) ? (a) : (b)
end_define

begin_comment
comment|/*  * hash_stats()  *  * Print statistics about the current table allocation to stdout.  */
end_comment

begin_function
name|void
name|hash_stats
parameter_list|(
name|hash_table
modifier|*
name|table
parameter_list|,
name|int
name|verbose
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|total_elements
init|=
literal|0
decl_stmt|;
name|int
name|non_empty_buckets
init|=
literal|0
decl_stmt|;
name|int
name|max_count
init|=
literal|0
decl_stmt|;
name|int
name|max_repeats
init|=
literal|0
decl_stmt|;
name|int
modifier|*
name|counts
decl_stmt|;
name|int
name|size
init|=
name|table
operator|->
name|size
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|counts
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
name|size
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"malloc returns 0\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|int
name|x
init|=
literal|0
decl_stmt|;
name|hash_node
modifier|*
name|n
init|=
name|table
operator|->
name|buckets
index|[
name|i
index|]
decl_stmt|;
name|counts
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|n
condition|)
block|{
if|if
condition|(
operator|!
name|x
condition|)
block|{
name|x
operator|=
literal|1
expr_stmt|;
name|non_empty_buckets
operator|++
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|printf
argument_list|(
literal|"bucket %2d: "
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|verbose
condition|)
block|{
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|n
operator|->
name|key
argument_list|)
expr_stmt|;
block|}
name|counts
index|[
name|i
index|]
operator|++
expr_stmt|;
name|n
operator|=
name|n
operator|->
name|next
expr_stmt|;
block|}
name|total_elements
operator|+=
name|counts
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|counts
index|[
name|i
index|]
operator|>
name|max_count
condition|)
block|{
name|max_count
operator|=
name|counts
index|[
name|i
index|]
expr_stmt|;
name|max_repeats
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|counts
index|[
name|i
index|]
operator|==
name|max_count
condition|)
block|{
name|max_repeats
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|counts
index|[
name|i
index|]
operator|&&
name|verbose
condition|)
block|{
name|printf
argument_list|(
literal|" (%d)\n"
argument_list|,
name|counts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d element%s in storage.\n"
argument_list|,
name|total_elements
argument_list|,
name|total_elements
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_elements
condition|)
block|{
name|printf
argument_list|(
literal|"%d of %d (%.2f%%) buckets are in use\n"
argument_list|,
name|non_empty_buckets
argument_list|,
name|size
argument_list|,
operator|(
name|double
operator|)
literal|100
operator|*
operator|(
name|double
operator|)
name|non_empty_buckets
operator|/
call|(
name|double
call|)
argument_list|(
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"the maximum number of elements in a bucket is %d (%d times)\n"
argument_list|,
name|max_count
argument_list|,
name|max_repeats
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"average per bucket is %f\n"
argument_list|,
operator|(
name|double
operator|)
name|total_elements
operator|/
operator|(
name|double
operator|)
name|non_empty_buckets
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"optimal would be %f\n"
argument_list|,
operator|(
name|double
operator|)
name|total_elements
operator|/
call|(
name|double
call|)
argument_list|(
name|min
argument_list|(
name|size
argument_list|,
name|total_elements
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

end_unit

