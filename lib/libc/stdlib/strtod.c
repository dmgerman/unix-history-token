begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)strtod.c	8.1 (Berkeley) 6/4/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBC_SCCS and not lint */
end_comment

begin_comment
comment|/****************************************************************  *  * The author of this software is David M. Gay.  *  * Copyright (c) 1991 by AT&T.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose without fee is hereby granted, provided that this entire notice  * is included in all copies of any software which is or includes a copy  * or modification of this software and in all copies of the supporting  * documentation for such software.  *  * THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTY.  IN PARTICULAR, NEITHER THE AUTHOR NOR AT&T MAKES ANY  * REPRESENTATION OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY  * OF THIS SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.  *  ***************************************************************/
end_comment

begin_comment
comment|/* Please send bug reports to 	David M. Gay 	AT&T Bell Laboratories, Room 2C-463 	600 Mountain Avenue 	Murray Hill, NJ 07974-2070 	U.S.A. 	dmg@research.att.com or research!dmg  */
end_comment

begin_comment
comment|/* strtod for IEEE-, VAX-, and IBM-arithmetic machines.  *  * This strtod returns a nearest machine number to the input decimal  * string (or sets errno to ERANGE).  With IEEE arithmetic, ties are  * broken by the IEEE round-even rule.  Otherwise ties are broken by  * biased rounding (add half and chop).  *  * Inspired loosely by William D. Clinger's paper "How to Read Floating  * Point Numbers Accurately" [Proc. ACM SIGPLAN '90, pp. 92-101].  *  * Modifications:  *  *	1. We only require IEEE, IBM, or VAX double-precision  *		arithmetic (not IEEE double-extended).  *	2. We get by with floating-point arithmetic in a case that  *		Clinger missed -- when we're computing d * 10^n  *		for a small integer d and the integer n is not too  *		much larger than 22 (the maximum integer k for which  *		we can represent 10^k exactly), we may be able to  *		compute (d*10^k) * 10^(e-k) with just one roundoff.  *	3. Rather than a bit-at-a-time adjustment of the binary  *		result in the hard case, we use floating-point  *		arithmetic to determine the adjustment to within  *		one bit; only in really hard cases do we need to  *		compute a second residual.  *	4. Because of 3., we don't need a large table of powers of 10  *		for ten-to-e (just some small tables, e.g. of 10^k  *		for 0<= k<= 22).  */
end_comment

begin_comment
comment|/*  * #define IEEE_LITTLE_ENDIAN for IEEE-arithmetic machines where the least  *	significant byte has the lowest address.  * #define IEEE_BIG_ENDIAN for IEEE-arithmetic machines where the most  *	significant byte has the lowest address.  * #define Long int on machines with 32-bit ints and 64-bit longs.  * #define Sudden_Underflow for IEEE-format machines without gradual  *	underflow (i.e., that flush to zero on underflow).  * #define IBM for IBM mainframe-style floating-point arithmetic.  * #define VAX for VAX-style floating-point arithmetic.  * #define Unsigned_Shifts if>> does treats its left operand as unsigned.  * #define No_leftright to omit left-right logic in fast floating-point  *	computation of dtoa.  * #define Check_FLT_ROUNDS if FLT_ROUNDS can assume the values 2 or 3.  * #define RND_PRODQUOT to use rnd_prod and rnd_quot (assembly routines  *	that use extended-precision instructions to compute rounded  *	products and quotients) with IBM.  * #define ROUND_BIASED for IEEE-format with biased rounding.  * #define Inaccurate_Divide for IEEE-format with correctly rounded  *	products but inaccurate quotients, e.g., for Intel i860.  * #define Just_16 to store 16 bits per 32-bit Long when doing high-precision  *	integer arithmetic.  Whether this speeds things up or slows things  *	down depends on the machine and the number being converted.  * #define KR_headers for old-style C function headers.  * #define Bad_float_h if your system lacks a float.h or if it does not  *	define some or all of DBL_DIG, DBL_MAX_10_EXP, DBL_MAX_EXP,  *	FLT_RADIX, FLT_ROUNDS, and DBL_MAX.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|i386
argument_list|)
operator|||
operator|(
name|defined
argument_list|(
name|mips
argument_list|)
operator|&&
name|defined
argument_list|(
name|MIPSEL
argument_list|)
operator|)
operator|||
expr|\
name|defined
argument_list|(
name|__ia64__
argument_list|)
operator|||
name|defined
argument_list|(
name|__alpha__
argument_list|)
end_if

begin_if
if|#
directive|if
name|BYTE_ORDER
operator|==
name|BIG_ENDIAN
end_if

begin_define
define|#
directive|define
name|IEEE_BIG_ENDIAN
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|IEEE_LITTLE_ENDIAN
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(__i386__) ... */
end_comment

begin_typedef
typedef|typedef
name|int32_t
name|Long
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|u_int32_t
name|ULong
typedef|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_include
include|#
directive|include
file|"stdio.h"
end_include

begin_define
define|#
directive|define
name|Bug
parameter_list|(
name|x
parameter_list|)
value|{fprintf(stderr, "%s\n", x); exit(1);}
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"memory.h"
end_include

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|KR_headers
end_ifndef

begin_include
include|#
directive|include
file|"stdlib.h"
end_include

begin_include
include|#
directive|include
file|"string.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"malloc.h"
end_include

begin_include
include|#
directive|include
file|"memory.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|Bad_float_h
end_ifdef

begin_undef
undef|#
directive|undef
name|__STDC__
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE_BIG_ENDIAN
end_ifdef

begin_define
define|#
directive|define
name|IEEE_ARITHMETIC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE_LITTLE_ENDIAN
end_ifdef

begin_define
define|#
directive|define
name|IEEE_ARITHMETIC
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE_ARITHMETIC
end_ifdef

begin_define
define|#
directive|define
name|DBL_DIG
value|15
end_define

begin_define
define|#
directive|define
name|DBL_MAX_10_EXP
value|308
end_define

begin_define
define|#
directive|define
name|DBL_MAX_EXP
value|1024
end_define

begin_define
define|#
directive|define
name|FLT_RADIX
value|2
end_define

begin_define
define|#
directive|define
name|FLT_ROUNDS
value|1
end_define

begin_define
define|#
directive|define
name|DBL_MAX
value|1.7976931348623157e+308
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IBM
end_ifdef

begin_define
define|#
directive|define
name|DBL_DIG
value|16
end_define

begin_define
define|#
directive|define
name|DBL_MAX_10_EXP
value|75
end_define

begin_define
define|#
directive|define
name|DBL_MAX_EXP
value|63
end_define

begin_define
define|#
directive|define
name|FLT_RADIX
value|16
end_define

begin_define
define|#
directive|define
name|FLT_ROUNDS
value|0
end_define

begin_define
define|#
directive|define
name|DBL_MAX
value|7.2370055773322621e+75
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|VAX
end_ifdef

begin_define
define|#
directive|define
name|DBL_DIG
value|16
end_define

begin_define
define|#
directive|define
name|DBL_MAX_10_EXP
value|38
end_define

begin_define
define|#
directive|define
name|DBL_MAX_EXP
value|127
end_define

begin_define
define|#
directive|define
name|FLT_RADIX
value|2
end_define

begin_define
define|#
directive|define
name|FLT_ROUNDS
value|1
end_define

begin_define
define|#
directive|define
name|DBL_MAX
value|1.7014118346046923e+38
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|LONG_MAX
end_ifndef

begin_define
define|#
directive|define
name|LONG_MAX
value|2147483647
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"float.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|__MATH_H__
end_ifndef

begin_include
include|#
directive|include
file|"math.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
ifndef|#
directive|ifndef
name|CONST
ifdef|#
directive|ifdef
name|KR_headers
define|#
directive|define
name|CONST
comment|/* blank */
else|#
directive|else
define|#
directive|define
name|CONST
value|const
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Unsigned_Shifts
define|#
directive|define
name|Sign_Extend
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|if (b< 0) a |= 0xffff0000;
else|#
directive|else
define|#
directive|define
name|Sign_Extend
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
comment|/*no-op*/
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|IEEE_LITTLE_ENDIAN
argument_list|)
operator|+
name|defined
argument_list|(
name|IEEE_BIG_ENDIAN
argument_list|)
operator|+
name|defined
argument_list|(
name|VAX
argument_list|)
operator|+
expr|\
name|defined
argument_list|(
name|IBM
argument_list|)
operator|!=
literal|1
name|Only
name|one
name|of
name|IEEE_LITTLE_ENDIAN
decl_stmt|,
name|IEEE_BIG_ENDIAN
decl_stmt|,
name|VAX
decl_stmt|,
name|or
name|IBM
name|should
name|be
name|defined
operator|.
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IEEE_LITTLE_ENDIAN
define|#
directive|define
name|word0
parameter_list|(
name|x
parameter_list|)
value|((ULong *)&x)[1]
define|#
directive|define
name|word1
parameter_list|(
name|x
parameter_list|)
value|((ULong *)&x)[0]
else|#
directive|else
define|#
directive|define
name|word0
parameter_list|(
name|x
parameter_list|)
value|((ULong *)&x)[0]
define|#
directive|define
name|word1
parameter_list|(
name|x
parameter_list|)
value|((ULong *)&x)[1]
endif|#
directive|endif
comment|/* The following definition of Storeinc is appropriate for MIPS processors.  * An alternative that might be better on some machines is  * #define Storeinc(a,b,c) (*a++ = b<< 16 | c& 0xffff)  */
if|#
directive|if
name|defined
argument_list|(
name|IEEE_LITTLE_ENDIAN
argument_list|)
operator|+
name|defined
argument_list|(
name|VAX
argument_list|)
define|#
directive|define
name|Storeinc
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|(((unsigned short *)a)[1] = (unsigned short)b, \ ((unsigned short *)a)[0] = (unsigned short)c, a++)
else|#
directive|else
define|#
directive|define
name|Storeinc
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|(((unsigned short *)a)[0] = (unsigned short)b, \ ((unsigned short *)a)[1] = (unsigned short)c, a++)
endif|#
directive|endif
comment|/* #define P DBL_MANT_DIG */
comment|/* Ten_pmax = floor(P*log(2)/log(5)) */
comment|/* Bletch = (highest power of 2< DBL_MAX_10_EXP) / 16 */
comment|/* Quick_max = floor((P-1)*log(FLT_RADIX)/log(10) - 1) */
comment|/* Int_max = floor(P*log(FLT_RADIX)/log(10) - 1) */
if|#
directive|if
name|defined
argument_list|(
name|IEEE_LITTLE_ENDIAN
argument_list|)
operator|+
name|defined
argument_list|(
name|IEEE_BIG_ENDIAN
argument_list|)
define|#
directive|define
name|Exp_shift
value|20
define|#
directive|define
name|Exp_shift1
value|20
define|#
directive|define
name|Exp_msk1
value|0x100000
define|#
directive|define
name|Exp_msk11
value|0x100000
define|#
directive|define
name|Exp_mask
value|0x7ff00000
define|#
directive|define
name|P
value|53
define|#
directive|define
name|Bias
value|1023
define|#
directive|define
name|IEEE_Arith
define|#
directive|define
name|Emin
value|(-1022)
define|#
directive|define
name|Exp_1
value|0x3ff00000
define|#
directive|define
name|Exp_11
value|0x3ff00000
define|#
directive|define
name|Ebits
value|11
define|#
directive|define
name|Frac_mask
value|0xfffff
define|#
directive|define
name|Frac_mask1
value|0xfffff
define|#
directive|define
name|Ten_pmax
value|22
define|#
directive|define
name|Bletch
value|0x10
define|#
directive|define
name|Bndry_mask
value|0xfffff
define|#
directive|define
name|Bndry_mask1
value|0xfffff
define|#
directive|define
name|LSB
value|1
define|#
directive|define
name|Sign_bit
value|0x80000000
define|#
directive|define
name|Log2P
value|1
define|#
directive|define
name|Tiny0
value|0
define|#
directive|define
name|Tiny1
value|1
define|#
directive|define
name|Quick_max
value|14
define|#
directive|define
name|Int_max
value|14
define|#
directive|define
name|Infinite
parameter_list|(
name|x
parameter_list|)
value|(word0(x) == 0x7ff00000)
comment|/* sufficient test for here */
else|#
directive|else
undef|#
directive|undef
name|Sudden_Underflow
define|#
directive|define
name|Sudden_Underflow
ifdef|#
directive|ifdef
name|IBM
define|#
directive|define
name|Exp_shift
value|24
define|#
directive|define
name|Exp_shift1
value|24
define|#
directive|define
name|Exp_msk1
value|0x1000000
define|#
directive|define
name|Exp_msk11
value|0x1000000
define|#
directive|define
name|Exp_mask
value|0x7f000000
define|#
directive|define
name|P
value|14
define|#
directive|define
name|Bias
value|65
define|#
directive|define
name|Exp_1
value|0x41000000
define|#
directive|define
name|Exp_11
value|0x41000000
define|#
directive|define
name|Ebits
value|8
comment|/* exponent has 7 bits, but 8 is the right value in b2d */
define|#
directive|define
name|Frac_mask
value|0xffffff
define|#
directive|define
name|Frac_mask1
value|0xffffff
define|#
directive|define
name|Bletch
value|4
define|#
directive|define
name|Ten_pmax
value|22
define|#
directive|define
name|Bndry_mask
value|0xefffff
define|#
directive|define
name|Bndry_mask1
value|0xffffff
define|#
directive|define
name|LSB
value|1
define|#
directive|define
name|Sign_bit
value|0x80000000
define|#
directive|define
name|Log2P
value|4
define|#
directive|define
name|Tiny0
value|0x100000
define|#
directive|define
name|Tiny1
value|0
define|#
directive|define
name|Quick_max
value|14
define|#
directive|define
name|Int_max
value|15
else|#
directive|else
comment|/* VAX */
define|#
directive|define
name|Exp_shift
value|23
define|#
directive|define
name|Exp_shift1
value|7
define|#
directive|define
name|Exp_msk1
value|0x80
define|#
directive|define
name|Exp_msk11
value|0x800000
define|#
directive|define
name|Exp_mask
value|0x7f80
define|#
directive|define
name|P
value|56
define|#
directive|define
name|Bias
value|129
define|#
directive|define
name|Exp_1
value|0x40800000
define|#
directive|define
name|Exp_11
value|0x4080
define|#
directive|define
name|Ebits
value|8
define|#
directive|define
name|Frac_mask
value|0x7fffff
define|#
directive|define
name|Frac_mask1
value|0xffff007f
define|#
directive|define
name|Ten_pmax
value|24
define|#
directive|define
name|Bletch
value|2
define|#
directive|define
name|Bndry_mask
value|0xffff007f
define|#
directive|define
name|Bndry_mask1
value|0xffff007f
define|#
directive|define
name|LSB
value|0x10000
define|#
directive|define
name|Sign_bit
value|0x8000
define|#
directive|define
name|Log2P
value|1
define|#
directive|define
name|Tiny0
value|0x80
define|#
directive|define
name|Tiny1
value|0
define|#
directive|define
name|Quick_max
value|15
define|#
directive|define
name|Int_max
value|15
endif|#
directive|endif
endif|#
directive|endif
ifndef|#
directive|ifndef
name|IEEE_Arith
define|#
directive|define
name|ROUND_BIASED
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RND_PRODQUOT
define|#
directive|define
name|rounded_product
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|a = rnd_prod(a, b)
define|#
directive|define
name|rounded_quotient
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|a = rnd_quot(a, b)
ifdef|#
directive|ifdef
name|KR_headers
decl|extern
name|double
name|rnd_prod
argument_list|()
decl_stmt|,
name|rnd_quot
argument_list|()
decl_stmt|;
else|#
directive|else
specifier|extern
name|double
name|rnd_prod
argument_list|(
name|double
argument_list|,
name|double
argument_list|)
decl_stmt|,
name|rnd_quot
argument_list|(
name|double
argument_list|,
name|double
argument_list|)
decl_stmt|;
endif|#
directive|endif
else|#
directive|else
define|#
directive|define
name|rounded_product
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|a *= b
define|#
directive|define
name|rounded_quotient
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|a /= b
endif|#
directive|endif
define|#
directive|define
name|Big0
value|(Frac_mask1 | Exp_msk1*(DBL_MAX_EXP+Bias-1))
define|#
directive|define
name|Big1
value|0xffffffff
ifndef|#
directive|ifndef
name|Just_16
comment|/* When Pack_32 is not defined, we store 16 bits per 32-bit Long.  * This makes some inner loops simpler and sometimes saves work  * during multiplications, but it often seems to make things slightly  * slower.  Hence the default is now to store 32 bits per Long.  */
ifndef|#
directive|ifndef
name|Pack_32
define|#
directive|define
name|Pack_32
endif|#
directive|endif
endif|#
directive|endif
define|#
directive|define
name|Kmax
value|15
ifdef|#
directive|ifdef
name|__cplusplus
extern|extern
literal|"C"
name|double
name|strtod
parameter_list|(
specifier|const
name|char
modifier|*
name|s00
parameter_list|,
name|char
modifier|*
modifier|*
name|se
parameter_list|)
function_decl|;
extern|extern
literal|"C"
name|char
modifier|*
name|__dtoa
parameter_list|(
name|double
name|d
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|ndigits
parameter_list|,
name|int
modifier|*
name|decpt
parameter_list|,
name|int
modifier|*
name|sign
parameter_list|,
name|char
modifier|*
modifier|*
name|rve
parameter_list|,
name|char
modifier|*
modifier|*
name|resultp
parameter_list|)
function_decl|;
endif|#
directive|endif
struct|struct
name|Bigint
block|{
name|struct
name|Bigint
modifier|*
name|next
decl_stmt|;
name|int
name|k
decl_stmt|,
name|maxwds
decl_stmt|,
name|sign
decl_stmt|,
name|wds
decl_stmt|;
name|ULong
name|x
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
typedef|typedef
name|struct
name|Bigint
name|Bigint
typedef|;
specifier|static
name|Bigint
modifier|*
name|Balloc
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|k
argument_list|)
name|int
name|k
decl_stmt|;
else|#
directive|else
operator|(
name|int
name|k
operator|)
endif|#
directive|endif
block|{
name|int
name|x
block|;
name|Bigint
operator|*
name|rv
block|;
name|x
operator|=
literal|1
operator|<<
name|k
block|;
name|rv
operator|=
operator|(
name|Bigint
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|Bigint
argument_list|)
operator|+
operator|(
name|x
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|Long
argument_list|)
argument_list|)
block|;
name|rv
operator|->
name|k
operator|=
name|k
block|;
name|rv
operator|->
name|maxwds
operator|=
name|x
block|;
name|rv
operator|->
name|sign
operator|=
name|rv
operator|->
name|wds
operator|=
literal|0
block|;
return|return
name|rv
return|;
block|}
specifier|static
name|void
name|Bfree
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|v
argument_list|)
name|Bigint
modifier|*
name|v
decl_stmt|;
else|#
directive|else
operator|(
name|Bigint
operator|*
name|v
operator|)
endif|#
directive|endif
block|{
name|free
argument_list|(
name|v
argument_list|)
block|; }
define|#
directive|define
name|Bcopy
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|memcpy((char *)&x->sign, (char *)&y->sign, \ y->wds*sizeof(Long) + 2*sizeof(int))
specifier|static
name|Bigint
operator|*
name|multadd
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
argument|b
argument_list|,
argument|m
argument_list|,
argument|a
argument_list|)
name|Bigint
operator|*
name|b
expr_stmt|;
name|int
name|m
decl_stmt|,
name|a
decl_stmt|;
else|#
directive|else
operator|(
name|Bigint
operator|*
name|b
operator|,
name|int
name|m
operator|,
name|int
name|a
operator|)
comment|/* multiply by m and add a */
endif|#
directive|endif
block|{
name|int
name|i
block|,
name|wds
block|;
name|ULong
operator|*
name|x
block|,
name|y
block|;
ifdef|#
directive|ifdef
name|Pack_32
name|ULong
name|xi
block|,
name|z
block|;
endif|#
directive|endif
name|Bigint
operator|*
name|b1
block|;
name|wds
operator|=
name|b
operator|->
name|wds
block|;
name|x
operator|=
name|b
operator|->
name|x
block|;
name|i
operator|=
literal|0
block|;
do|do
block|{
ifdef|#
directive|ifdef
name|Pack_32
name|xi
operator|=
operator|*
name|x
expr_stmt|;
name|y
operator|=
operator|(
name|xi
operator|&
literal|0xffff
operator|)
operator|*
name|m
operator|+
name|a
expr_stmt|;
name|z
operator|=
operator|(
name|xi
operator|>>
literal|16
operator|)
operator|*
name|m
operator|+
operator|(
name|y
operator|>>
literal|16
operator|)
expr_stmt|;
name|a
operator|=
call|(
name|int
call|)
argument_list|(
name|z
operator|>>
literal|16
argument_list|)
expr_stmt|;
operator|*
name|x
operator|++
operator|=
operator|(
name|z
operator|<<
literal|16
operator|)
operator|+
operator|(
name|y
operator|&
literal|0xffff
operator|)
expr_stmt|;
else|#
directive|else
name|y
operator|=
operator|*
name|x
operator|*
name|m
operator|+
name|a
expr_stmt|;
name|a
operator|=
call|(
name|int
call|)
argument_list|(
name|y
operator|>>
literal|16
argument_list|)
expr_stmt|;
operator|*
name|x
operator|++
operator|=
name|y
operator|&
literal|0xffff
expr_stmt|;
endif|#
directive|endif
block|}
while|while
condition|(
operator|++
name|i
operator|<
name|wds
condition|)
empty_stmt|;
if|if
condition|(
name|a
condition|)
block|{
if|if
condition|(
name|wds
operator|>=
name|b
operator|->
name|maxwds
condition|)
block|{
name|b1
operator|=
name|Balloc
argument_list|(
name|b
operator|->
name|k
operator|+
literal|1
argument_list|)
expr_stmt|;
name|Bcopy
argument_list|(
name|b1
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|=
name|b1
expr_stmt|;
block|}
name|b
operator|->
name|x
index|[
name|wds
operator|++
index|]
operator|=
name|a
expr_stmt|;
name|b
operator|->
name|wds
operator|=
name|wds
expr_stmt|;
block|}
return|return
name|b
return|;
block|}
end_extern

begin_decl_stmt
specifier|static
name|Bigint
modifier|*
name|s2b
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|s
argument_list|,
name|nd0
argument_list|,
name|nd
argument_list|,
name|y9
argument_list|)
name|CONST
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nd0
decl_stmt|,
name|nd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ULong
name|y9
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|CONST
name|char
operator|*
name|s
operator|,
name|int
name|nd0
operator|,
name|int
name|nd
operator|,
name|ULong
name|y9
operator|)
endif|#
directive|endif
block|{
name|Bigint
operator|*
name|b
block|;
name|int
name|i
block|,
name|k
block|;
name|Long
name|x
block|,
name|y
block|;
name|x
operator|=
operator|(
name|nd
operator|+
literal|8
operator|)
operator|/
literal|9
block|;
for|for
control|(
name|k
operator|=
literal|0
operator|,
name|y
operator|=
literal|1
init|;
name|x
operator|>
name|y
condition|;
name|y
operator|<<=
literal|1
operator|,
name|k
operator|++
control|)
empty_stmt|;
ifdef|#
directive|ifdef
name|Pack_32
name|b
operator|=
name|Balloc
argument_list|(
name|k
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|b
operator|->
name|x
index|[
literal|0
index|]
operator|=
name|y9
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|b
operator|->
name|wds
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|b
operator|=
name|Balloc
argument_list|(
name|k
operator|+
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|b
operator|->
name|x
index|[
literal|0
index|]
operator|=
name|y9
operator|&
literal|0xffff
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|b
operator|->
name|wds
operator|=
operator|(
name|b
operator|->
name|x
index|[
literal|1
index|]
operator|=
name|y9
operator|>>
literal|16
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|i
operator|=
literal|9
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
literal|9
operator|<
name|nd0
condition|)
block|{
name|s
operator|+=
literal|9
expr_stmt|;
do|do
name|b
operator|=
name|multadd
argument_list|(
name|b
argument_list|,
literal|10
argument_list|,
operator|*
name|s
operator|++
operator|-
literal|'0'
argument_list|)
expr_stmt|;
do|while
condition|(
operator|++
name|i
operator|<
name|nd0
condition|)
do|;
name|s
operator|++
expr_stmt|;
block|}
else|else
name|s
operator|+=
literal|10
expr_stmt|;
end_if

begin_for
for|for
control|(
init|;
name|i
operator|<
name|nd
condition|;
name|i
operator|++
control|)
name|b
operator|=
name|multadd
argument_list|(
name|b
argument_list|,
literal|10
argument_list|,
operator|*
name|s
operator|++
operator|-
literal|'0'
argument_list|)
expr_stmt|;
end_for

begin_return
return|return
name|b
return|;
end_return

begin_decl_stmt
unit|}   static
name|int
name|hi0bits
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|x
argument_list|)
name|ULong
name|x
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|ULong
name|x
operator|)
endif|#
directive|endif
block|{
name|int
name|k
operator|=
literal|0
block|;
if|if
condition|(
operator|!
operator|(
name|x
operator|&
literal|0xffff0000
operator|)
condition|)
block|{
name|k
operator|=
literal|16
expr_stmt|;
name|x
operator|<<=
literal|16
expr_stmt|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
operator|!
operator|(
name|x
operator|&
literal|0xff000000
operator|)
condition|)
block|{
name|k
operator|+=
literal|8
expr_stmt|;
name|x
operator|<<=
literal|8
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
operator|(
name|x
operator|&
literal|0xf0000000
operator|)
condition|)
block|{
name|k
operator|+=
literal|4
expr_stmt|;
name|x
operator|<<=
literal|4
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
operator|(
name|x
operator|&
literal|0xc0000000
operator|)
condition|)
block|{
name|k
operator|+=
literal|2
expr_stmt|;
name|x
operator|<<=
literal|2
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
operator|(
name|x
operator|&
literal|0x80000000
operator|)
condition|)
block|{
name|k
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|x
operator|&
literal|0x40000000
operator|)
condition|)
return|return
literal|32
return|;
block|}
end_if

begin_return
return|return
name|k
return|;
end_return

begin_decl_stmt
unit|}   static
name|int
name|lo0bits
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|y
argument_list|)
name|ULong
modifier|*
name|y
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|ULong
operator|*
name|y
operator|)
endif|#
directive|endif
block|{
name|int
name|k
block|;
name|ULong
name|x
operator|=
operator|*
name|y
block|;
if|if
condition|(
name|x
operator|&
literal|7
condition|)
block|{
if|if
condition|(
name|x
operator|&
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|x
operator|&
literal|2
condition|)
block|{
operator|*
name|y
operator|=
name|x
operator|>>
literal|1
expr_stmt|;
return|return
literal|1
return|;
block|}
operator|*
name|y
operator|=
name|x
operator|>>
literal|2
expr_stmt|;
end_expr_stmt

begin_return
return|return
literal|2
return|;
end_return

begin_expr_stmt
unit|} 	k
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
operator|(
name|x
operator|&
literal|0xffff
operator|)
condition|)
block|{
name|k
operator|=
literal|16
expr_stmt|;
name|x
operator|>>=
literal|16
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
operator|(
name|x
operator|&
literal|0xff
operator|)
condition|)
block|{
name|k
operator|+=
literal|8
expr_stmt|;
name|x
operator|>>=
literal|8
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
operator|(
name|x
operator|&
literal|0xf
operator|)
condition|)
block|{
name|k
operator|+=
literal|4
expr_stmt|;
name|x
operator|>>=
literal|4
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
operator|(
name|x
operator|&
literal|0x3
operator|)
condition|)
block|{
name|k
operator|+=
literal|2
expr_stmt|;
name|x
operator|>>=
literal|2
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
operator|(
name|x
operator|&
literal|1
operator|)
condition|)
block|{
name|k
operator|++
expr_stmt|;
name|x
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|x
operator|&
literal|1
condition|)
return|return
literal|32
return|;
block|}
end_if

begin_expr_stmt
operator|*
name|y
operator|=
name|x
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|k
return|;
end_return

begin_decl_stmt
unit|}   static
name|Bigint
modifier|*
name|i2b
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|i
argument_list|)
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|int
name|i
operator|)
endif|#
directive|endif
block|{
name|Bigint
operator|*
name|b
block|;
name|b
operator|=
name|Balloc
argument_list|(
literal|1
argument_list|)
block|;
name|b
operator|->
name|x
index|[
literal|0
index|]
operator|=
name|i
block|;
name|b
operator|->
name|wds
operator|=
literal|1
block|;
return|return
name|b
return|;
block|}
end_expr_stmt

begin_decl_stmt
specifier|static
name|Bigint
modifier|*
name|mult
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
name|Bigint
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|Bigint
operator|*
name|a
operator|,
name|Bigint
operator|*
name|b
operator|)
endif|#
directive|endif
block|{
name|Bigint
operator|*
name|c
block|;
name|int
name|k
block|,
name|wa
block|,
name|wb
block|,
name|wc
block|;
name|ULong
name|carry
block|,
name|y
block|,
name|z
block|;
name|ULong
operator|*
name|x
block|,
operator|*
name|xa
block|,
operator|*
name|xae
block|,
operator|*
name|xb
block|,
operator|*
name|xbe
block|,
operator|*
name|xc
block|,
operator|*
name|xc0
block|;
ifdef|#
directive|ifdef
name|Pack_32
name|ULong
name|z2
block|;
endif|#
directive|endif
if|if
condition|(
name|a
operator|->
name|wds
operator|<
name|b
operator|->
name|wds
condition|)
block|{
name|c
operator|=
name|a
expr_stmt|;
name|a
operator|=
name|b
expr_stmt|;
name|b
operator|=
name|c
expr_stmt|;
block|}
name|k
operator|=
name|a
operator|->
name|k
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|wa
operator|=
name|a
operator|->
name|wds
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|wb
operator|=
name|b
operator|->
name|wds
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|wc
operator|=
name|wa
operator|+
name|wb
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|wc
operator|>
name|a
operator|->
name|maxwds
condition|)
name|k
operator|++
expr_stmt|;
end_if

begin_expr_stmt
name|c
operator|=
name|Balloc
argument_list|(
name|k
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|x
operator|=
name|c
operator|->
name|x
operator|,
name|xa
operator|=
name|x
operator|+
name|wc
init|;
name|x
operator|<
name|xa
condition|;
name|x
operator|++
control|)
operator|*
name|x
operator|=
literal|0
expr_stmt|;
end_for

begin_expr_stmt
name|xa
operator|=
name|a
operator|->
name|x
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|xae
operator|=
name|xa
operator|+
name|wa
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|xb
operator|=
name|b
operator|->
name|x
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|xbe
operator|=
name|xb
operator|+
name|wb
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|xc0
operator|=
name|c
operator|->
name|x
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|Pack_32
end_ifdef

begin_for
for|for
control|(
init|;
name|xb
operator|<
name|xbe
condition|;
name|xb
operator|++
operator|,
name|xc0
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|y
operator|=
operator|*
name|xb
operator|&
literal|0xffff
operator|)
condition|)
block|{
name|x
operator|=
name|xa
expr_stmt|;
name|xc
operator|=
name|xc0
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|z
operator|=
operator|(
operator|*
name|x
operator|&
literal|0xffff
operator|)
operator|*
name|y
operator|+
operator|(
operator|*
name|xc
operator|&
literal|0xffff
operator|)
operator|+
name|carry
expr_stmt|;
name|carry
operator|=
name|z
operator|>>
literal|16
expr_stmt|;
name|z2
operator|=
operator|(
operator|*
name|x
operator|++
operator|>>
literal|16
operator|)
operator|*
name|y
operator|+
operator|(
operator|*
name|xc
operator|>>
literal|16
operator|)
operator|+
name|carry
expr_stmt|;
name|carry
operator|=
name|z2
operator|>>
literal|16
expr_stmt|;
name|Storeinc
argument_list|(
name|xc
argument_list|,
name|z2
argument_list|,
name|z
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|x
operator|<
name|xae
condition|)
do|;
operator|*
name|xc
operator|=
name|carry
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|y
operator|=
operator|*
name|xb
operator|>>
literal|16
operator|)
condition|)
block|{
name|x
operator|=
name|xa
expr_stmt|;
name|xc
operator|=
name|xc0
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
name|z2
operator|=
operator|*
name|xc
expr_stmt|;
do|do
block|{
name|z
operator|=
operator|(
operator|*
name|x
operator|&
literal|0xffff
operator|)
operator|*
name|y
operator|+
operator|(
operator|*
name|xc
operator|>>
literal|16
operator|)
operator|+
name|carry
expr_stmt|;
name|carry
operator|=
name|z
operator|>>
literal|16
expr_stmt|;
name|Storeinc
argument_list|(
name|xc
argument_list|,
name|z
argument_list|,
name|z2
argument_list|)
expr_stmt|;
name|z2
operator|=
operator|(
operator|*
name|x
operator|++
operator|>>
literal|16
operator|)
operator|*
name|y
operator|+
operator|(
operator|*
name|xc
operator|&
literal|0xffff
operator|)
operator|+
name|carry
expr_stmt|;
name|carry
operator|=
name|z2
operator|>>
literal|16
expr_stmt|;
block|}
do|while
condition|(
name|x
operator|<
name|xae
condition|)
do|;
operator|*
name|xc
operator|=
name|z2
expr_stmt|;
block|}
block|}
end_for

begin_else
else|#
directive|else
end_else

begin_for
for|for
control|(
init|;
name|xb
operator|<
name|xbe
condition|;
name|xc0
operator|++
control|)
block|{
if|if
condition|(
name|y
operator|=
operator|*
name|xb
operator|++
condition|)
block|{
name|x
operator|=
name|xa
expr_stmt|;
name|xc
operator|=
name|xc0
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|z
operator|=
operator|*
name|x
operator|++
operator|*
name|y
operator|+
operator|*
name|xc
operator|+
name|carry
expr_stmt|;
name|carry
operator|=
name|z
operator|>>
literal|16
expr_stmt|;
operator|*
name|xc
operator|++
operator|=
name|z
operator|&
literal|0xffff
expr_stmt|;
block|}
do|while
condition|(
name|x
operator|<
name|xae
condition|)
do|;
operator|*
name|xc
operator|=
name|carry
expr_stmt|;
block|}
block|}
end_for

begin_endif
endif|#
directive|endif
end_endif

begin_for
for|for
control|(
name|xc0
operator|=
name|c
operator|->
name|x
operator|,
name|xc
operator|=
name|xc0
operator|+
name|wc
init|;
name|wc
operator|>
literal|0
operator|&&
operator|!
operator|*
operator|--
name|xc
condition|;
operator|--
name|wc
control|)
empty_stmt|;
end_for

begin_expr_stmt
name|c
operator|->
name|wds
operator|=
name|wc
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|c
return|;
end_return

begin_decl_stmt
unit|}   static
name|Bigint
modifier|*
name|p5s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Bigint
modifier|*
name|pow5mult
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|b
argument_list|,
name|k
argument_list|)
name|Bigint
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|k
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|Bigint
operator|*
name|b
operator|,
name|int
name|k
operator|)
endif|#
directive|endif
block|{
name|Bigint
operator|*
name|b1
block|,
operator|*
name|p5
block|,
operator|*
name|p51
block|;
name|int
name|i
block|;
specifier|static
name|int
name|p05
index|[
literal|3
index|]
operator|=
block|{
literal|5
block|,
literal|25
block|,
literal|125
block|}
block|;
if|if
condition|(
operator|(
name|i
operator|=
name|k
operator|&
literal|3
operator|)
condition|)
name|b
operator|=
name|multadd
argument_list|(
name|b
argument_list|,
name|p05
index|[
name|i
operator|-
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
operator|(
name|k
operator|>>=
literal|2
operator|)
condition|)
return|return
name|b
return|;
end_if

begin_if
if|if
condition|(
operator|!
operator|(
name|p5
operator|=
name|p5s
operator|)
condition|)
block|{
comment|/* first time */
name|p5
operator|=
name|p5s
operator|=
name|i2b
argument_list|(
literal|625
argument_list|)
expr_stmt|;
name|p5
operator|->
name|next
operator|=
literal|0
expr_stmt|;
block|}
end_if

begin_for
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|k
operator|&
literal|1
condition|)
block|{
name|b1
operator|=
name|mult
argument_list|(
name|b
argument_list|,
name|p5
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|=
name|b1
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|k
operator|>>=
literal|1
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
operator|(
name|p51
operator|=
name|p5
operator|->
name|next
operator|)
condition|)
block|{
name|p51
operator|=
name|p5
operator|->
name|next
operator|=
name|mult
argument_list|(
name|p5
argument_list|,
name|p5
argument_list|)
expr_stmt|;
name|p51
operator|->
name|next
operator|=
literal|0
expr_stmt|;
block|}
name|p5
operator|=
name|p51
expr_stmt|;
block|}
end_for

begin_return
return|return
name|b
return|;
end_return

begin_decl_stmt
unit|}   static
name|Bigint
modifier|*
name|lshift
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|b
argument_list|,
name|k
argument_list|)
name|Bigint
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|k
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|Bigint
operator|*
name|b
operator|,
name|int
name|k
operator|)
endif|#
directive|endif
block|{
name|int
name|i
block|,
name|k1
block|,
name|n
block|,
name|n1
block|;
name|Bigint
operator|*
name|b1
block|;
name|ULong
operator|*
name|x
block|,
operator|*
name|x1
block|,
operator|*
name|xe
block|,
name|z
block|;
ifdef|#
directive|ifdef
name|Pack_32
name|n
operator|=
name|k
operator|>>
literal|5
block|;
else|#
directive|else
name|n
operator|=
name|k
operator|>>
literal|4
block|;
endif|#
directive|endif
name|k1
operator|=
name|b
operator|->
name|k
block|;
name|n1
operator|=
name|n
operator|+
name|b
operator|->
name|wds
operator|+
literal|1
block|;
for|for
control|(
name|i
operator|=
name|b
operator|->
name|maxwds
init|;
name|n1
operator|>
name|i
condition|;
name|i
operator|<<=
literal|1
control|)
name|k1
operator|++
expr_stmt|;
name|b1
operator|=
name|Balloc
argument_list|(
name|k1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|x1
operator|=
name|b1
operator|->
name|x
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
operator|*
name|x1
operator|++
operator|=
literal|0
expr_stmt|;
end_for

begin_expr_stmt
name|x
operator|=
name|b
operator|->
name|x
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|xe
operator|=
name|x
operator|+
name|b
operator|->
name|wds
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|Pack_32
end_ifdef

begin_if
if|if
condition|(
name|k
operator|&=
literal|0x1f
condition|)
block|{
name|k1
operator|=
literal|32
operator|-
name|k
expr_stmt|;
name|z
operator|=
literal|0
expr_stmt|;
do|do
block|{
operator|*
name|x1
operator|++
operator|=
operator|*
name|x
operator|<<
name|k
operator||
name|z
expr_stmt|;
name|z
operator|=
operator|*
name|x
operator|++
operator|>>
name|k1
expr_stmt|;
block|}
do|while
condition|(
name|x
operator|<
name|xe
condition|)
do|;
if|if
condition|(
operator|(
operator|*
name|x1
operator|=
name|z
operator|)
condition|)
operator|++
name|n1
expr_stmt|;
block|}
end_if

begin_else
else|#
directive|else
end_else

begin_if
if|if
condition|(
name|k
operator|&=
literal|0xf
condition|)
block|{
name|k1
operator|=
literal|16
operator|-
name|k
expr_stmt|;
name|z
operator|=
literal|0
expr_stmt|;
do|do
block|{
operator|*
name|x1
operator|++
operator|=
operator|*
name|x
operator|<<
name|k
operator|&
literal|0xffff
operator||
name|z
expr_stmt|;
name|z
operator|=
operator|*
name|x
operator|++
operator|>>
name|k1
expr_stmt|;
block|}
do|while
condition|(
name|x
operator|<
name|xe
condition|)
do|;
if|if
condition|(
operator|*
name|x1
operator|=
name|z
condition|)
operator|++
name|n1
expr_stmt|;
block|}
endif|#
directive|endif
else|else
do|do
operator|*
name|x1
operator|++
operator|=
operator|*
name|x
operator|++
expr_stmt|;
do|while
condition|(
name|x
operator|<
name|xe
condition|)
do|;
end_if

begin_expr_stmt
name|b1
operator|->
name|wds
operator|=
name|n1
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Bfree
argument_list|(
name|b
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|b1
return|;
end_return

begin_decl_stmt
unit|}   static
name|int
name|cmp
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
name|Bigint
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|Bigint
operator|*
name|a
operator|,
name|Bigint
operator|*
name|b
operator|)
endif|#
directive|endif
block|{
name|ULong
operator|*
name|xa
block|,
operator|*
name|xa0
block|,
operator|*
name|xb
block|,
operator|*
name|xb0
block|;
name|int
name|i
block|,
name|j
block|;
name|i
operator|=
name|a
operator|->
name|wds
block|;
name|j
operator|=
name|b
operator|->
name|wds
block|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|i
operator|>
literal|1
operator|&&
operator|!
name|a
operator|->
name|x
index|[
name|i
operator|-
literal|1
index|]
condition|)
name|Bug
argument_list|(
literal|"cmp called with a->x[a->wds-1] == 0"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|j
operator|>
literal|1
operator|&&
operator|!
name|b
operator|->
name|x
index|[
name|j
operator|-
literal|1
index|]
condition|)
name|Bug
argument_list|(
literal|"cmp called with b->x[b->wds-1] == 0"
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
name|i
operator|-=
name|j
condition|)
return|return
name|i
return|;
end_if

begin_expr_stmt
name|xa0
operator|=
name|a
operator|->
name|x
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|xa
operator|=
name|xa0
operator|+
name|j
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|xb0
operator|=
name|b
operator|->
name|x
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|xb
operator|=
name|xb0
operator|+
name|j
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
operator|--
name|xa
operator|!=
operator|*
operator|--
name|xb
condition|)
return|return
operator|*
name|xa
operator|<
operator|*
name|xb
condition|?
operator|-
literal|1
else|:
literal|1
return|;
if|if
condition|(
name|xa
operator|<=
name|xa0
condition|)
break|break;
block|}
end_for

begin_return
return|return
literal|0
return|;
end_return

begin_decl_stmt
unit|}   static
name|Bigint
modifier|*
name|diff
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
name|Bigint
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|Bigint
operator|*
name|a
operator|,
name|Bigint
operator|*
name|b
operator|)
endif|#
directive|endif
block|{
name|Bigint
operator|*
name|c
block|;
name|int
name|i
block|,
name|wa
block|,
name|wb
block|;
name|Long
name|borrow
block|,
name|y
block|;
comment|/* We need signed shifts here. */
name|ULong
operator|*
name|xa
block|,
operator|*
name|xae
block|,
operator|*
name|xb
block|,
operator|*
name|xbe
block|,
operator|*
name|xc
block|;
ifdef|#
directive|ifdef
name|Pack_32
name|Long
name|z
block|;
endif|#
directive|endif
name|i
operator|=
name|cmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
block|;
if|if
condition|(
operator|!
name|i
condition|)
block|{
name|c
operator|=
name|Balloc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|c
operator|->
name|wds
operator|=
literal|1
expr_stmt|;
name|c
operator|->
name|x
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|c
return|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|c
operator|=
name|a
expr_stmt|;
name|a
operator|=
name|b
expr_stmt|;
name|b
operator|=
name|c
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|i
operator|=
literal|0
expr_stmt|;
end_if

begin_expr_stmt
name|c
operator|=
name|Balloc
argument_list|(
name|a
operator|->
name|k
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|c
operator|->
name|sign
operator|=
name|i
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|wa
operator|=
name|a
operator|->
name|wds
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|xa
operator|=
name|a
operator|->
name|x
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|xae
operator|=
name|xa
operator|+
name|wa
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|wb
operator|=
name|b
operator|->
name|wds
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|xb
operator|=
name|b
operator|->
name|x
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|xbe
operator|=
name|xb
operator|+
name|wb
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|xc
operator|=
name|c
operator|->
name|x
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|borrow
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|Pack_32
end_ifdef

begin_do
do|do
block|{
name|y
operator|=
operator|(
operator|*
name|xa
operator|&
literal|0xffff
operator|)
operator|-
operator|(
operator|*
name|xb
operator|&
literal|0xffff
operator|)
operator|+
name|borrow
expr_stmt|;
name|borrow
operator|=
name|y
operator|>>
literal|16
expr_stmt|;
name|Sign_Extend
argument_list|(
name|borrow
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|z
operator|=
operator|(
operator|*
name|xa
operator|++
operator|>>
literal|16
operator|)
operator|-
operator|(
operator|*
name|xb
operator|++
operator|>>
literal|16
operator|)
operator|+
name|borrow
expr_stmt|;
name|borrow
operator|=
name|z
operator|>>
literal|16
expr_stmt|;
name|Sign_Extend
argument_list|(
name|borrow
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|Storeinc
argument_list|(
name|xc
argument_list|,
name|z
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|xb
operator|<
name|xbe
condition|)
do|;
end_do

begin_while
while|while
condition|(
name|xa
operator|<
name|xae
condition|)
block|{
name|y
operator|=
operator|(
operator|*
name|xa
operator|&
literal|0xffff
operator|)
operator|+
name|borrow
expr_stmt|;
name|borrow
operator|=
name|y
operator|>>
literal|16
expr_stmt|;
name|Sign_Extend
argument_list|(
name|borrow
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|z
operator|=
operator|(
operator|*
name|xa
operator|++
operator|>>
literal|16
operator|)
operator|+
name|borrow
expr_stmt|;
name|borrow
operator|=
name|z
operator|>>
literal|16
expr_stmt|;
name|Sign_Extend
argument_list|(
name|borrow
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|Storeinc
argument_list|(
name|xc
argument_list|,
name|z
argument_list|,
name|y
argument_list|)
expr_stmt|;
block|}
end_while

begin_else
else|#
directive|else
end_else

begin_do
do|do
block|{
name|y
operator|=
operator|*
name|xa
operator|++
operator|-
operator|*
name|xb
operator|++
operator|+
name|borrow
expr_stmt|;
name|borrow
operator|=
name|y
operator|>>
literal|16
expr_stmt|;
name|Sign_Extend
argument_list|(
name|borrow
argument_list|,
name|y
argument_list|)
expr_stmt|;
operator|*
name|xc
operator|++
operator|=
name|y
operator|&
literal|0xffff
expr_stmt|;
block|}
do|while
condition|(
name|xb
operator|<
name|xbe
condition|)
do|;
end_do

begin_while
while|while
condition|(
name|xa
operator|<
name|xae
condition|)
block|{
name|y
operator|=
operator|*
name|xa
operator|++
operator|+
name|borrow
expr_stmt|;
name|borrow
operator|=
name|y
operator|>>
literal|16
expr_stmt|;
name|Sign_Extend
argument_list|(
name|borrow
argument_list|,
name|y
argument_list|)
expr_stmt|;
operator|*
name|xc
operator|++
operator|=
name|y
operator|&
literal|0xffff
expr_stmt|;
block|}
end_while

begin_endif
endif|#
directive|endif
end_endif

begin_while
while|while
condition|(
operator|!
operator|*
operator|--
name|xc
condition|)
name|wa
operator|--
expr_stmt|;
end_while

begin_expr_stmt
name|c
operator|->
name|wds
operator|=
name|wa
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|c
return|;
end_return

begin_decl_stmt
unit|}   static
name|double
name|ulp
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|x
argument_list|)
name|double
name|x
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|double
name|x
operator|)
endif|#
directive|endif
block|{
name|Long
name|L
block|;
name|double
name|a
block|;
name|L
operator|=
operator|(
name|word0
argument_list|(
name|x
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|-
operator|(
name|P
operator|-
literal|1
operator|)
operator|*
name|Exp_msk1
block|;
ifndef|#
directive|ifndef
name|Sudden_Underflow
if|if
condition|(
name|L
operator|>
literal|0
condition|)
block|{
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IBM
name|L
operator||=
name|Exp_msk1
operator|>>
literal|4
expr_stmt|;
endif|#
directive|endif
name|word0
argument_list|(
name|a
argument_list|)
operator|=
name|L
expr_stmt|;
name|word1
argument_list|(
name|a
argument_list|)
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|Sudden_Underflow
block|}
end_expr_stmt

begin_else
else|else
block|{
name|L
operator|=
operator|-
name|L
operator|>>
name|Exp_shift
expr_stmt|;
if|if
condition|(
name|L
operator|<
name|Exp_shift
condition|)
block|{
name|word0
argument_list|(
name|a
argument_list|)
operator|=
literal|0x80000
operator|>>
name|L
expr_stmt|;
name|word1
argument_list|(
name|a
argument_list|)
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|word0
argument_list|(
name|a
argument_list|)
operator|=
literal|0
expr_stmt|;
name|L
operator|-=
name|Exp_shift
expr_stmt|;
name|word1
argument_list|(
name|a
argument_list|)
operator|=
name|L
operator|>=
literal|31
condition|?
literal|1
else|:
literal|1
operator|<<
operator|(
literal|31
operator|-
name|L
operator|)
expr_stmt|;
block|}
block|}
end_else

begin_endif
endif|#
directive|endif
end_endif

begin_return
return|return
name|a
return|;
end_return

begin_decl_stmt
unit|}   static
name|double
name|b2d
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|a
argument_list|,
name|e
argument_list|)
name|Bigint
modifier|*
name|a
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|e
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|Bigint
operator|*
name|a
operator|,
name|int
operator|*
name|e
operator|)
endif|#
directive|endif
block|{
name|ULong
operator|*
name|xa
block|,
operator|*
name|xa0
block|,
name|w
block|,
name|y
block|,
name|z
block|;
name|int
name|k
block|;
name|double
name|d
block|;
ifdef|#
directive|ifdef
name|VAX
name|ULong
name|d0
block|,
name|d1
block|;
else|#
directive|else
define|#
directive|define
name|d0
value|word0(d)
define|#
directive|define
name|d1
value|word1(d)
endif|#
directive|endif
name|xa0
operator|=
name|a
operator|->
name|x
block|;
name|xa
operator|=
name|xa0
operator|+
name|a
operator|->
name|wds
block|;
name|y
operator|=
operator|*
operator|--
name|xa
block|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|!
name|y
condition|)
name|Bug
argument_list|(
literal|"zero y in b2d"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|k
operator|=
name|hi0bits
argument_list|(
name|y
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|e
operator|=
literal|32
operator|-
name|k
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|Pack_32
end_ifdef

begin_if
if|if
condition|(
name|k
operator|<
name|Ebits
condition|)
block|{
name|d0
operator|=
name|Exp_1
operator||
operator|(
name|y
operator|>>
operator|(
name|Ebits
operator|-
name|k
operator|)
operator|)
expr_stmt|;
name|w
operator|=
name|xa
operator|>
name|xa0
condition|?
operator|*
operator|--
name|xa
else|:
literal|0
expr_stmt|;
name|d1
operator|=
operator|(
name|y
operator|<<
operator|(
operator|(
literal|32
operator|-
name|Ebits
operator|)
operator|+
name|k
operator|)
operator|)
operator||
operator|(
name|w
operator|>>
operator|(
name|Ebits
operator|-
name|k
operator|)
operator|)
expr_stmt|;
goto|goto
name|ret_d
goto|;
block|}
end_if

begin_expr_stmt
name|z
operator|=
name|xa
operator|>
name|xa0
condition|?
operator|*
operator|--
name|xa
else|:
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|k
operator|-=
name|Ebits
condition|)
block|{
name|d0
operator|=
name|Exp_1
operator||
operator|(
name|y
operator|<<
name|k
operator|)
operator||
operator|(
name|z
operator|>>
operator|(
literal|32
operator|-
name|k
operator|)
operator|)
expr_stmt|;
name|y
operator|=
name|xa
operator|>
name|xa0
condition|?
operator|*
operator|--
name|xa
else|:
literal|0
expr_stmt|;
name|d1
operator|=
operator|(
name|z
operator|<<
name|k
operator|)
operator||
operator|(
name|y
operator|>>
operator|(
literal|32
operator|-
name|k
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|d0
operator|=
name|Exp_1
operator||
name|y
expr_stmt|;
name|d1
operator|=
name|z
expr_stmt|;
block|}
end_if

begin_else
else|#
directive|else
end_else

begin_if
if|if
condition|(
name|k
operator|<
name|Ebits
operator|+
literal|16
condition|)
block|{
name|z
operator|=
name|xa
operator|>
name|xa0
condition|?
operator|*
operator|--
name|xa
else|:
literal|0
expr_stmt|;
name|d0
operator|=
name|Exp_1
operator||
name|y
operator|<<
name|k
operator|-
name|Ebits
operator||
name|z
operator|>>
name|Ebits
operator|+
literal|16
operator|-
name|k
expr_stmt|;
name|w
operator|=
name|xa
operator|>
name|xa0
condition|?
operator|*
operator|--
name|xa
else|:
literal|0
expr_stmt|;
name|y
operator|=
name|xa
operator|>
name|xa0
condition|?
operator|*
operator|--
name|xa
else|:
literal|0
expr_stmt|;
name|d1
operator|=
name|z
operator|<<
name|k
operator|+
literal|16
operator|-
name|Ebits
operator||
name|w
operator|<<
name|k
operator|-
name|Ebits
operator||
name|y
operator|>>
literal|16
operator|+
name|Ebits
operator|-
name|k
expr_stmt|;
goto|goto
name|ret_d
goto|;
block|}
end_if

begin_expr_stmt
name|z
operator|=
name|xa
operator|>
name|xa0
condition|?
operator|*
operator|--
name|xa
else|:
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|w
operator|=
name|xa
operator|>
name|xa0
condition|?
operator|*
operator|--
name|xa
else|:
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|k
operator|-=
name|Ebits
operator|+
literal|16
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|d0
operator|=
name|Exp_1
operator||
name|y
operator|<<
name|k
operator|+
literal|16
operator||
name|z
operator|<<
name|k
operator||
name|w
operator|>>
literal|16
operator|-
name|k
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|y
operator|=
name|xa
operator|>
name|xa0
condition|?
operator|*
operator|--
name|xa
else|:
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|d1
operator|=
name|w
operator|<<
name|k
operator|+
literal|16
operator||
name|y
operator|<<
name|k
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_label
name|ret_d
label|:
end_label

begin_ifdef
ifdef|#
directive|ifdef
name|VAX
end_ifdef

begin_expr_stmt
name|word0
argument_list|(
name|d
argument_list|)
operator|=
name|d0
operator|>>
literal|16
operator||
name|d0
operator|<<
literal|16
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|word1
argument_list|(
name|d
argument_list|)
operator|=
name|d1
operator|>>
literal|16
operator||
name|d1
operator|<<
literal|16
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_undef
undef|#
directive|undef
name|d0
end_undef

begin_undef
undef|#
directive|undef
name|d1
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_return
return|return
name|d
return|;
end_return

begin_decl_stmt
unit|}   static
name|Bigint
modifier|*
name|d2b
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|d
argument_list|,
name|e
argument_list|,
name|bits
argument_list|)
name|double
name|d
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|e
decl_stmt|,
modifier|*
name|bits
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|double
name|d
operator|,
name|int
operator|*
name|e
operator|,
name|int
operator|*
name|bits
operator|)
endif|#
directive|endif
block|{
name|Bigint
operator|*
name|b
block|;
name|int
name|de
block|,
name|i
block|,
name|k
block|;
name|ULong
operator|*
name|x
block|,
name|y
block|,
name|z
block|;
ifdef|#
directive|ifdef
name|VAX
name|ULong
name|d0
block|,
name|d1
block|;
name|d0
operator|=
name|word0
argument_list|(
name|d
argument_list|)
operator|>>
literal|16
operator||
name|word0
argument_list|(
name|d
argument_list|)
operator|<<
literal|16
block|;
name|d1
operator|=
name|word1
argument_list|(
name|d
argument_list|)
operator|>>
literal|16
operator||
name|word1
argument_list|(
name|d
argument_list|)
operator|<<
literal|16
block|;
else|#
directive|else
define|#
directive|define
name|d0
value|word0(d)
define|#
directive|define
name|d1
value|word1(d)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|Pack_32
name|b
operator|=
name|Balloc
argument_list|(
literal|1
argument_list|)
block|;
else|#
directive|else
name|b
operator|=
name|Balloc
argument_list|(
literal|2
argument_list|)
block|;
endif|#
directive|endif
name|x
operator|=
name|b
operator|->
name|x
block|;
name|z
operator|=
name|d0
operator|&
name|Frac_mask
block|;
name|d0
operator|&=
literal|0x7fffffff
block|;
comment|/* clear sign bit, which we ignore */
ifdef|#
directive|ifdef
name|Sudden_Underflow
name|de
operator|=
call|(
name|int
call|)
argument_list|(
name|d0
operator|>>
name|Exp_shift
argument_list|)
block|;
ifndef|#
directive|ifndef
name|IBM
name|z
operator||=
name|Exp_msk11
block|;
endif|#
directive|endif
else|#
directive|else
if|if
condition|(
operator|(
name|de
operator|=
call|(
name|int
call|)
argument_list|(
name|d0
operator|>>
name|Exp_shift
argument_list|)
operator|)
condition|)
name|z
operator||=
name|Exp_msk1
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|Pack_32
end_ifdef

begin_if
if|if
condition|(
operator|(
name|y
operator|=
name|d1
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|k
operator|=
name|lo0bits
argument_list|(
operator|&
name|y
argument_list|)
operator|)
condition|)
block|{
name|x
index|[
literal|0
index|]
operator|=
name|y
operator||
operator|(
name|z
operator|<<
operator|(
literal|32
operator|-
name|k
operator|)
operator|)
expr_stmt|;
name|z
operator|>>=
name|k
expr_stmt|;
block|}
else|else
name|x
index|[
literal|0
index|]
operator|=
name|y
expr_stmt|;
name|i
operator|=
name|b
operator|->
name|wds
operator|=
operator|(
name|x
index|[
literal|1
index|]
operator|=
name|z
operator|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|!
name|z
condition|)
name|Bug
argument_list|(
literal|"Zero passed to d2b"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|k
operator|=
name|lo0bits
argument_list|(
operator|&
name|z
argument_list|)
expr_stmt|;
name|x
index|[
literal|0
index|]
operator|=
name|z
expr_stmt|;
name|i
operator|=
name|b
operator|->
name|wds
operator|=
literal|1
expr_stmt|;
name|k
operator|+=
literal|32
expr_stmt|;
block|}
end_if

begin_else
else|#
directive|else
end_else

begin_if
if|if
condition|(
name|y
operator|=
name|d1
condition|)
block|{
if|if
condition|(
name|k
operator|=
name|lo0bits
argument_list|(
operator|&
name|y
argument_list|)
condition|)
if|if
condition|(
name|k
operator|>=
literal|16
condition|)
block|{
name|x
index|[
literal|0
index|]
operator|=
name|y
operator||
name|z
operator|<<
literal|32
operator|-
name|k
operator|&
literal|0xffff
expr_stmt|;
name|x
index|[
literal|1
index|]
operator|=
name|z
operator|>>
name|k
operator|-
literal|16
operator|&
literal|0xffff
expr_stmt|;
name|x
index|[
literal|2
index|]
operator|=
name|z
operator|>>
name|k
expr_stmt|;
name|i
operator|=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|x
index|[
literal|0
index|]
operator|=
name|y
operator|&
literal|0xffff
expr_stmt|;
name|x
index|[
literal|1
index|]
operator|=
name|y
operator|>>
literal|16
operator||
name|z
operator|<<
literal|16
operator|-
name|k
operator|&
literal|0xffff
expr_stmt|;
name|x
index|[
literal|2
index|]
operator|=
name|z
operator|>>
name|k
operator|&
literal|0xffff
expr_stmt|;
name|x
index|[
literal|3
index|]
operator|=
name|z
operator|>>
name|k
operator|+
literal|16
expr_stmt|;
name|i
operator|=
literal|3
expr_stmt|;
block|}
else|else
block|{
name|x
index|[
literal|0
index|]
operator|=
name|y
operator|&
literal|0xffff
expr_stmt|;
name|x
index|[
literal|1
index|]
operator|=
name|y
operator|>>
literal|16
expr_stmt|;
name|x
index|[
literal|2
index|]
operator|=
name|z
operator|&
literal|0xffff
expr_stmt|;
name|x
index|[
literal|3
index|]
operator|=
name|z
operator|>>
literal|16
expr_stmt|;
name|i
operator|=
literal|3
expr_stmt|;
block|}
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|!
name|z
condition|)
name|Bug
argument_list|(
literal|"Zero passed to d2b"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|k
operator|=
name|lo0bits
argument_list|(
operator|&
name|z
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|>=
literal|16
condition|)
block|{
name|x
index|[
literal|0
index|]
operator|=
name|z
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|x
index|[
literal|0
index|]
operator|=
name|z
operator|&
literal|0xffff
expr_stmt|;
name|x
index|[
literal|1
index|]
operator|=
name|z
operator|>>
literal|16
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
name|k
operator|+=
literal|32
expr_stmt|;
block|}
end_if

begin_while
while|while
condition|(
operator|!
name|x
index|[
name|i
index|]
condition|)
operator|--
name|i
expr_stmt|;
end_while

begin_expr_stmt
name|b
operator|->
name|wds
operator|=
name|i
operator|+
literal|1
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|Sudden_Underflow
end_ifndef

begin_if
if|if
condition|(
name|de
condition|)
block|{
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IBM
operator|*
name|e
operator|=
operator|(
name|de
operator|-
name|Bias
operator|-
operator|(
name|P
operator|-
literal|1
operator|)
operator|<<
literal|2
operator|)
operator|+
name|k
expr_stmt|;
operator|*
name|bits
operator|=
literal|4
operator|*
name|P
operator|+
literal|8
operator|-
name|k
operator|-
name|hi0bits
argument_list|(
name|word0
argument_list|(
name|d
argument_list|)
operator|&
name|Frac_mask
argument_list|)
expr_stmt|;
else|#
directive|else
operator|*
name|e
operator|=
name|de
operator|-
name|Bias
operator|-
operator|(
name|P
operator|-
literal|1
operator|)
operator|+
name|k
expr_stmt|;
operator|*
name|bits
operator|=
name|P
operator|-
name|k
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|Sudden_Underflow
block|}
else|else
block|{
operator|*
name|e
operator|=
name|de
operator|-
name|Bias
operator|-
operator|(
name|P
operator|-
literal|1
operator|)
operator|+
literal|1
operator|+
name|k
expr_stmt|;
ifdef|#
directive|ifdef
name|Pack_32
operator|*
name|bits
operator|=
literal|32
operator|*
name|i
operator|-
name|hi0bits
argument_list|(
name|x
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
operator|*
name|bits
operator|=
operator|(
name|i
operator|+
literal|2
operator|)
operator|*
literal|16
operator|-
name|hi0bits
argument_list|(
name|x
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_return
return|return
name|b
return|;
end_return

begin_undef
unit|}
undef|#
directive|undef
name|d0
end_undef

begin_undef
undef|#
directive|undef
name|d1
end_undef

begin_decl_stmt
unit|static
name|double
name|ratio
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
name|Bigint
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|Bigint
operator|*
name|a
operator|,
name|Bigint
operator|*
name|b
operator|)
endif|#
directive|endif
block|{
name|double
name|da
block|,
name|db
block|;
name|int
name|k
block|,
name|ka
block|,
name|kb
block|;
name|da
operator|=
name|b2d
argument_list|(
name|a
argument_list|,
operator|&
name|ka
argument_list|)
block|;
name|db
operator|=
name|b2d
argument_list|(
name|b
argument_list|,
operator|&
name|kb
argument_list|)
block|;
ifdef|#
directive|ifdef
name|Pack_32
name|k
operator|=
name|ka
operator|-
name|kb
operator|+
literal|32
operator|*
operator|(
name|a
operator|->
name|wds
operator|-
name|b
operator|->
name|wds
operator|)
block|;
else|#
directive|else
name|k
operator|=
name|ka
operator|-
name|kb
operator|+
literal|16
operator|*
operator|(
name|a
operator|->
name|wds
operator|-
name|b
operator|->
name|wds
operator|)
block|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IBM
if|if
condition|(
name|k
operator|>
literal|0
condition|)
block|{
name|word0
argument_list|(
name|da
argument_list|)
operator|+=
operator|(
name|k
operator|>>
literal|2
operator|)
operator|*
name|Exp_msk1
expr_stmt|;
if|if
condition|(
name|k
operator|&=
literal|3
condition|)
name|da
operator|*=
literal|1
operator|<<
name|k
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|k
operator|=
operator|-
name|k
expr_stmt|;
name|word0
argument_list|(
name|db
argument_list|)
operator|+=
operator|(
name|k
operator|>>
literal|2
operator|)
operator|*
name|Exp_msk1
expr_stmt|;
if|if
condition|(
name|k
operator|&=
literal|3
condition|)
name|db
operator|*=
literal|1
operator|<<
name|k
expr_stmt|;
block|}
end_else

begin_else
else|#
directive|else
end_else

begin_if
if|if
condition|(
name|k
operator|>
literal|0
condition|)
name|word0
argument_list|(
name|da
argument_list|)
operator|+=
name|k
operator|*
name|Exp_msk1
expr_stmt|;
else|else
block|{
name|k
operator|=
operator|-
name|k
expr_stmt|;
name|word0
argument_list|(
name|db
argument_list|)
operator|+=
name|k
operator|*
name|Exp_msk1
expr_stmt|;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_return
return|return
name|da
operator|/
name|db
return|;
end_return

begin_decl_stmt
unit|}   static
name|double
name|tens
index|[]
init|=
block|{
literal|1e0
block|,
literal|1e1
block|,
literal|1e2
block|,
literal|1e3
block|,
literal|1e4
block|,
literal|1e5
block|,
literal|1e6
block|,
literal|1e7
block|,
literal|1e8
block|,
literal|1e9
block|,
literal|1e10
block|,
literal|1e11
block|,
literal|1e12
block|,
literal|1e13
block|,
literal|1e14
block|,
literal|1e15
block|,
literal|1e16
block|,
literal|1e17
block|,
literal|1e18
block|,
literal|1e19
block|,
literal|1e20
block|,
literal|1e21
block|,
literal|1e22
ifdef|#
directive|ifdef
name|VAX
block|,
literal|1e23
block|,
literal|1e24
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
ifdef|#
directive|ifdef
name|IEEE_Arith
name|bigtens
index|[]
init|=
block|{
literal|1e16
block|,
literal|1e32
block|,
literal|1e64
block|,
literal|1e128
block|,
literal|1e256
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|tinytens
index|[]
init|=
block|{
literal|1e-16
block|,
literal|1e-32
block|,
literal|1e-64
block|,
literal|1e-128
block|,
literal|1e-256
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|n_bigtens
value|5
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|IBM
end_ifdef

begin_expr_stmt
name|bigtens
index|[]
operator|=
block|{
literal|1e16
block|,
literal|1e32
block|,
literal|1e64
block|}
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|double
name|tinytens
index|[]
init|=
block|{
literal|1e-16
block|,
literal|1e-32
block|,
literal|1e-64
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|n_bigtens
value|3
end_define

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|bigtens
index|[]
operator|=
block|{
literal|1e16
block|,
literal|1e32
block|}
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|double
name|tinytens
index|[]
init|=
block|{
literal|1e-16
block|,
literal|1e-32
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|n_bigtens
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|double
name|strtod
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|s00
argument_list|,
name|se
argument_list|)
name|CONST
name|char
modifier|*
name|s00
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|se
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|CONST
name|char
operator|*
name|s00
operator|,
name|char
operator|*
operator|*
name|se
operator|)
endif|#
directive|endif
block|{
name|int
name|bb2
block|,
name|bb5
block|,
name|bbe
block|,
name|bd2
block|,
name|bd5
block|,
name|bbbits
block|,
name|bs2
block|,
name|c
block|,
name|dsign
block|,
name|e
block|,
name|e1
block|,
name|esign
block|,
name|i
block|,
name|j
block|,
name|k
block|,
name|nd
block|,
name|nd0
block|,
name|nf
block|,
name|nz
block|,
name|nz0
block|,
name|sign
block|;
name|CONST
name|char
operator|*
name|s
block|,
operator|*
name|s0
block|,
operator|*
name|s1
block|;
name|double
name|aadj
block|,
name|aadj1
block|,
name|adj
block|,
name|rv
block|,
name|rv0
block|;
name|Long
name|L
block|;
name|ULong
name|y
block|,
name|z
block|;
name|Bigint
operator|*
name|bb
block|,
operator|*
name|bb1
block|,
operator|*
name|bd
block|,
operator|*
name|bd0
block|,
operator|*
name|bs
block|,
operator|*
name|delta
block|;
name|char
name|decimal_point
operator|=
name|localeconv
argument_list|()
operator|->
name|decimal_point
index|[
literal|0
index|]
block|;
name|sign
operator|=
name|nz0
operator|=
name|nz
operator|=
literal|0
block|;
name|rv
operator|=
literal|0.
block|;
for|for
control|(
name|s
operator|=
name|s00
init|;
condition|;
name|s
operator|++
control|)
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'-'
case|:
name|sign
operator|=
literal|1
expr_stmt|;
comment|/* no break */
case|case
literal|'+'
case|:
if|if
condition|(
operator|*
operator|++
name|s
condition|)
goto|goto
name|break2
goto|;
comment|/* no break */
case|case
literal|0
case|:
name|s
operator|=
name|s00
expr_stmt|;
goto|goto
name|ret
goto|;
default|default:
if|if
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|)
continue|continue;
goto|goto
name|break2
goto|;
block|}
name|break2
operator|:
end_expr_stmt

begin_if
if|if
condition|(
operator|*
name|s
operator|==
literal|'0'
condition|)
block|{
name|nz0
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|s
operator|==
literal|'0'
condition|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
goto|goto
name|ret
goto|;
block|}
end_if

begin_expr_stmt
name|s0
operator|=
name|s
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|y
operator|=
name|z
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|nd
operator|=
name|nf
operator|=
literal|0
init|;
operator|(
name|c
operator|=
operator|*
name|s
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|;
name|nd
operator|++
operator|,
name|s
operator|++
control|)
if|if
condition|(
name|nd
operator|<
literal|9
condition|)
name|y
operator|=
literal|10
operator|*
name|y
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|nd
operator|<
literal|16
condition|)
name|z
operator|=
literal|10
operator|*
name|z
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
end_for

begin_expr_stmt
name|nd0
operator|=
name|nd
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|(
name|char
operator|)
name|c
operator|==
name|decimal_point
condition|)
block|{
name|c
operator|=
operator|*
operator|++
name|s
expr_stmt|;
if|if
condition|(
operator|!
name|nd
condition|)
block|{
for|for
control|(
init|;
name|c
operator|==
literal|'0'
condition|;
name|c
operator|=
operator|*
operator|++
name|s
control|)
name|nz
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|s0
operator|=
name|s
expr_stmt|;
name|nf
operator|+=
name|nz
expr_stmt|;
name|nz
operator|=
literal|0
expr_stmt|;
goto|goto
name|have_dig
goto|;
block|}
goto|goto
name|dig_done
goto|;
block|}
for|for
control|(
init|;
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|;
name|c
operator|=
operator|*
operator|++
name|s
control|)
block|{
name|have_dig
label|:
name|nz
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|-
literal|'0'
operator|>
literal|0
condition|)
block|{
name|nf
operator|+=
name|nz
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nz
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|nd
operator|++
operator|<
literal|9
condition|)
name|y
operator|*=
literal|10
expr_stmt|;
elseif|else
if|if
condition|(
name|nd
operator|<=
name|DBL_DIG
operator|+
literal|1
condition|)
name|z
operator|*=
literal|10
expr_stmt|;
if|if
condition|(
name|nd
operator|++
operator|<
literal|9
condition|)
name|y
operator|=
literal|10
operator|*
name|y
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
elseif|else
if|if
condition|(
name|nd
operator|<=
name|DBL_DIG
operator|+
literal|1
condition|)
name|z
operator|=
literal|10
operator|*
name|z
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
name|nz
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
end_if

begin_label
name|dig_done
label|:
end_label

begin_expr_stmt
name|e
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|c
operator|==
literal|'e'
operator|||
name|c
operator|==
literal|'E'
condition|)
block|{
if|if
condition|(
operator|!
name|nd
operator|&&
operator|!
name|nz
operator|&&
operator|!
name|nz0
condition|)
block|{
name|s
operator|=
name|s00
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|s00
operator|=
name|s
expr_stmt|;
name|esign
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|c
operator|=
operator|*
operator|++
name|s
condition|)
block|{
case|case
literal|'-'
case|:
name|esign
operator|=
literal|1
expr_stmt|;
case|case
literal|'+'
case|:
name|c
operator|=
operator|*
operator|++
name|s
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
while|while
condition|(
name|c
operator|==
literal|'0'
condition|)
name|c
operator|=
operator|*
operator|++
name|s
expr_stmt|;
if|if
condition|(
name|c
operator|>
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|L
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
name|s1
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
operator|++
name|s
operator|)
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
name|L
operator|=
literal|10
operator|*
name|L
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|s
operator|-
name|s1
operator|>
literal|8
operator|||
name|L
operator|>
literal|19999
condition|)
comment|/* Avoid confusion from exponents 					 * so large that e might overflow. 					 */
name|e
operator|=
literal|19999
expr_stmt|;
comment|/* safe for 16 bit ints */
else|else
name|e
operator|=
operator|(
name|int
operator|)
name|L
expr_stmt|;
if|if
condition|(
name|esign
condition|)
name|e
operator|=
operator|-
name|e
expr_stmt|;
block|}
else|else
name|e
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|s
operator|=
name|s00
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
name|nd
condition|)
block|{
if|if
condition|(
operator|!
name|nz
operator|&&
operator|!
name|nz0
condition|)
name|s
operator|=
name|s00
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
end_if

begin_expr_stmt
name|e1
operator|=
name|e
operator|-=
name|nf
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Now we have nd0 digits, starting at s0, followed by a 	 * decimal point, followed by nd-nd0 digits.  The number we're 	 * after is the integer represented by those digits times 	 * 10**e */
end_comment

begin_if
if|if
condition|(
operator|!
name|nd0
condition|)
name|nd0
operator|=
name|nd
expr_stmt|;
end_if

begin_expr_stmt
name|k
operator|=
name|nd
operator|<
name|DBL_DIG
operator|+
literal|1
condition|?
name|nd
else|:
name|DBL_DIG
operator|+
literal|1
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|rv
operator|=
name|y
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|k
operator|>
literal|9
condition|)
name|rv
operator|=
name|tens
index|[
name|k
operator|-
literal|9
index|]
operator|*
name|rv
operator|+
name|z
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|nd
operator|<=
name|DBL_DIG
ifndef|#
directive|ifndef
name|RND_PRODQUOT
operator|&&
name|FLT_ROUNDS
operator|==
literal|1
endif|#
directive|endif
condition|)
block|{
if|if
condition|(
operator|!
name|e
condition|)
goto|goto
name|ret
goto|;
if|if
condition|(
name|e
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|e
operator|<=
name|Ten_pmax
condition|)
block|{
ifdef|#
directive|ifdef
name|VAX
goto|goto
name|vax_ovfl_check
goto|;
else|#
directive|else
comment|/* rv = */
name|rounded_product
argument_list|(
name|rv
argument_list|,
name|tens
index|[
name|e
index|]
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
endif|#
directive|endif
block|}
name|i
operator|=
name|DBL_DIG
operator|-
name|nd
expr_stmt|;
if|if
condition|(
name|e
operator|<=
name|Ten_pmax
operator|+
name|i
condition|)
block|{
comment|/* A fancier test would sometimes let us do 				 * this for larger i values. 				 */
name|e
operator|-=
name|i
expr_stmt|;
name|rv
operator|*=
name|tens
index|[
name|i
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|VAX
comment|/* VAX exponent range is so narrow we must 				 * worry about overflow here... 				 */
name|vax_ovfl_check
label|:
name|word0
argument_list|(
name|rv
argument_list|)
operator|-=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
comment|/* rv = */
name|rounded_product
argument_list|(
name|rv
argument_list|,
name|tens
index|[
name|e
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|>
name|Exp_msk1
operator|*
operator|(
name|DBL_MAX_EXP
operator|+
name|Bias
operator|-
literal|1
operator|-
name|P
operator|)
condition|)
goto|goto
name|ovfl
goto|;
name|word0
argument_list|(
name|rv
argument_list|)
operator|+=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
else|#
directive|else
comment|/* rv = */
name|rounded_product
argument_list|(
name|rv
argument_list|,
name|tens
index|[
name|e
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|ret
goto|;
block|}
block|}
ifndef|#
directive|ifndef
name|Inaccurate_Divide
elseif|else
if|if
condition|(
name|e
operator|>=
operator|-
name|Ten_pmax
condition|)
block|{
comment|/* rv = */
name|rounded_quotient
argument_list|(
name|rv
argument_list|,
name|tens
index|[
operator|-
name|e
index|]
argument_list|)
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
endif|#
directive|endif
block|}
end_if

begin_expr_stmt
name|e1
operator|+=
name|nd
operator|-
name|k
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Get starting approximation = rv * 10**e1 */
end_comment

begin_if
if|if
condition|(
name|e1
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|e1
operator|&
literal|15
operator|)
condition|)
name|rv
operator|*=
name|tens
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|e1
operator|&=
operator|~
literal|15
operator|)
condition|)
block|{
if|if
condition|(
name|e1
operator|>
name|DBL_MAX_10_EXP
condition|)
block|{
name|ovfl
label|:
name|errno
operator|=
name|ERANGE
expr_stmt|;
ifdef|#
directive|ifdef
name|__STDC__
name|rv
operator|=
name|HUGE_VAL
expr_stmt|;
else|#
directive|else
comment|/* Can't trust HUGE_VAL */
ifdef|#
directive|ifdef
name|IEEE_Arith
name|word0
argument_list|(
name|rv
argument_list|)
operator|=
name|Exp_mask
expr_stmt|;
name|word1
argument_list|(
name|rv
argument_list|)
operator|=
literal|0
expr_stmt|;
else|#
directive|else
name|word0
argument_list|(
name|rv
argument_list|)
operator|=
name|Big0
expr_stmt|;
name|word1
argument_list|(
name|rv
argument_list|)
operator|=
name|Big1
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|e1
operator|>>=
literal|4
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|e1
operator|>
literal|1
condition|;
name|j
operator|++
operator|,
name|e1
operator|>>=
literal|1
control|)
if|if
condition|(
name|e1
operator|&
literal|1
condition|)
name|rv
operator|*=
name|bigtens
index|[
name|j
index|]
expr_stmt|;
comment|/* The last multiplication could overflow. */
name|word0
argument_list|(
name|rv
argument_list|)
operator|-=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
name|rv
operator|*=
name|bigtens
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|z
operator|=
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|>
name|Exp_msk1
operator|*
operator|(
name|DBL_MAX_EXP
operator|+
name|Bias
operator|-
name|P
operator|)
condition|)
goto|goto
name|ovfl
goto|;
if|if
condition|(
name|z
operator|>
name|Exp_msk1
operator|*
operator|(
name|DBL_MAX_EXP
operator|+
name|Bias
operator|-
literal|1
operator|-
name|P
operator|)
condition|)
block|{
comment|/* set to largest number */
comment|/* (Can't trust DBL_MAX) */
name|word0
argument_list|(
name|rv
argument_list|)
operator|=
name|Big0
expr_stmt|;
name|word1
argument_list|(
name|rv
argument_list|)
operator|=
name|Big1
expr_stmt|;
block|}
else|else
name|word0
argument_list|(
name|rv
argument_list|)
operator|+=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|e1
operator|<
literal|0
condition|)
block|{
name|e1
operator|=
operator|-
name|e1
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|e1
operator|&
literal|15
operator|)
condition|)
name|rv
operator|/=
name|tens
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|e1
operator|&=
operator|~
literal|15
operator|)
condition|)
block|{
name|e1
operator|>>=
literal|4
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|e1
operator|>
literal|1
condition|;
name|j
operator|++
operator|,
name|e1
operator|>>=
literal|1
control|)
if|if
condition|(
name|e1
operator|&
literal|1
condition|)
name|rv
operator|*=
name|tinytens
index|[
name|j
index|]
expr_stmt|;
comment|/* The last multiplication could underflow. */
name|rv0
operator|=
name|rv
expr_stmt|;
name|rv
operator|*=
name|tinytens
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|rv
condition|)
block|{
name|rv
operator|=
literal|2.
operator|*
name|rv0
expr_stmt|;
name|rv
operator|*=
name|tinytens
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|rv
condition|)
block|{
name|undfl
label|:
name|rv
operator|=
literal|0.
expr_stmt|;
name|errno
operator|=
name|ERANGE
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|word0
argument_list|(
name|rv
argument_list|)
operator|=
name|Tiny0
expr_stmt|;
name|word1
argument_list|(
name|rv
argument_list|)
operator|=
name|Tiny1
expr_stmt|;
comment|/* The refinement below will clean 				 * this approximation up. 				 */
block|}
block|}
block|}
end_if

begin_comment
comment|/* Now the hard part -- adjusting rv to the correct value.*/
end_comment

begin_comment
comment|/* Put digits into bd: true value = bd * 10^e */
end_comment

begin_expr_stmt
name|bd0
operator|=
name|s2b
argument_list|(
name|s0
argument_list|,
name|nd0
argument_list|,
name|nd
argument_list|,
name|y
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
init|;
condition|;
control|)
block|{
name|bd
operator|=
name|Balloc
argument_list|(
name|bd0
operator|->
name|k
argument_list|)
expr_stmt|;
name|Bcopy
argument_list|(
name|bd
argument_list|,
name|bd0
argument_list|)
expr_stmt|;
name|bb
operator|=
name|d2b
argument_list|(
name|rv
argument_list|,
operator|&
name|bbe
argument_list|,
operator|&
name|bbbits
argument_list|)
expr_stmt|;
comment|/* rv = bb * 2^bbe */
name|bs
operator|=
name|i2b
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|>=
literal|0
condition|)
block|{
name|bb2
operator|=
name|bb5
operator|=
literal|0
expr_stmt|;
name|bd2
operator|=
name|bd5
operator|=
name|e
expr_stmt|;
block|}
else|else
block|{
name|bb2
operator|=
name|bb5
operator|=
operator|-
name|e
expr_stmt|;
name|bd2
operator|=
name|bd5
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|bbe
operator|>=
literal|0
condition|)
name|bb2
operator|+=
name|bbe
expr_stmt|;
else|else
name|bd2
operator|-=
name|bbe
expr_stmt|;
name|bs2
operator|=
name|bb2
expr_stmt|;
ifdef|#
directive|ifdef
name|Sudden_Underflow
ifdef|#
directive|ifdef
name|IBM
name|j
operator|=
literal|1
operator|+
literal|4
operator|*
name|P
operator|-
literal|3
operator|-
name|bbbits
operator|+
operator|(
operator|(
name|bbe
operator|+
name|bbbits
operator|-
literal|1
operator|)
operator|&
literal|3
operator|)
expr_stmt|;
else|#
directive|else
name|j
operator|=
name|P
operator|+
literal|1
operator|-
name|bbbits
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
name|i
operator|=
name|bbe
operator|+
name|bbbits
operator|-
literal|1
expr_stmt|;
comment|/* logb(rv) */
if|if
condition|(
name|i
operator|<
name|Emin
condition|)
comment|/* denormal */
name|j
operator|=
name|bbe
operator|+
operator|(
name|P
operator|-
name|Emin
operator|)
expr_stmt|;
else|else
name|j
operator|=
name|P
operator|+
literal|1
operator|-
name|bbbits
expr_stmt|;
endif|#
directive|endif
name|bb2
operator|+=
name|j
expr_stmt|;
name|bd2
operator|+=
name|j
expr_stmt|;
name|i
operator|=
name|bb2
operator|<
name|bd2
condition|?
name|bb2
else|:
name|bd2
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|bs2
condition|)
name|i
operator|=
name|bs2
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|bb2
operator|-=
name|i
expr_stmt|;
name|bd2
operator|-=
name|i
expr_stmt|;
name|bs2
operator|-=
name|i
expr_stmt|;
block|}
if|if
condition|(
name|bb5
operator|>
literal|0
condition|)
block|{
name|bs
operator|=
name|pow5mult
argument_list|(
name|bs
argument_list|,
name|bb5
argument_list|)
expr_stmt|;
name|bb1
operator|=
name|mult
argument_list|(
name|bs
argument_list|,
name|bb
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|bb
operator|=
name|bb1
expr_stmt|;
block|}
if|if
condition|(
name|bb2
operator|>
literal|0
condition|)
name|bb
operator|=
name|lshift
argument_list|(
name|bb
argument_list|,
name|bb2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bd5
operator|>
literal|0
condition|)
name|bd
operator|=
name|pow5mult
argument_list|(
name|bd
argument_list|,
name|bd5
argument_list|)
expr_stmt|;
if|if
condition|(
name|bd2
operator|>
literal|0
condition|)
name|bd
operator|=
name|lshift
argument_list|(
name|bd
argument_list|,
name|bd2
argument_list|)
expr_stmt|;
if|if
condition|(
name|bs2
operator|>
literal|0
condition|)
name|bs
operator|=
name|lshift
argument_list|(
name|bs
argument_list|,
name|bs2
argument_list|)
expr_stmt|;
name|delta
operator|=
name|diff
argument_list|(
name|bb
argument_list|,
name|bd
argument_list|)
expr_stmt|;
name|dsign
operator|=
name|delta
operator|->
name|sign
expr_stmt|;
name|delta
operator|->
name|sign
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|cmp
argument_list|(
name|delta
argument_list|,
name|bs
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
comment|/* Error is less than half an ulp -- check for 			 * special case of mantissa a power of two. 			 */
if|if
condition|(
name|dsign
operator|||
name|word1
argument_list|(
name|rv
argument_list|)
operator|||
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Bndry_mask
condition|)
break|break;
name|delta
operator|=
name|lshift
argument_list|(
name|delta
argument_list|,
name|Log2P
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
argument_list|(
name|delta
argument_list|,
name|bs
argument_list|)
operator|>
literal|0
condition|)
goto|goto
name|drop_down
goto|;
break|break;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* exactly half-way between */
if|if
condition|(
name|dsign
condition|)
block|{
if|if
condition|(
operator|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Bndry_mask1
operator|)
operator|==
name|Bndry_mask1
operator|&&
name|word1
argument_list|(
name|rv
argument_list|)
operator|==
literal|0xffffffff
condition|)
block|{
comment|/*boundary case -- increment exponent*/
name|word0
argument_list|(
name|rv
argument_list|)
operator|=
operator|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|+
name|Exp_msk1
ifdef|#
directive|ifdef
name|IBM
operator||
name|Exp_msk1
operator|>>
literal|4
endif|#
directive|endif
expr_stmt|;
name|word1
argument_list|(
name|rv
argument_list|)
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Bndry_mask
operator|)
operator|&&
operator|!
name|word1
argument_list|(
name|rv
argument_list|)
condition|)
block|{
name|drop_down
label|:
comment|/* boundary case -- decrement exponent */
ifdef|#
directive|ifdef
name|Sudden_Underflow
name|L
operator|=
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
expr_stmt|;
ifdef|#
directive|ifdef
name|IBM
if|if
condition|(
name|L
operator|<
name|Exp_msk1
condition|)
else|#
directive|else
if|if
condition|(
name|L
operator|<=
name|Exp_msk1
condition|)
endif|#
directive|endif
goto|goto
name|undfl
goto|;
name|L
operator|-=
name|Exp_msk1
expr_stmt|;
else|#
directive|else
name|L
operator|=
operator|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|-
name|Exp_msk1
expr_stmt|;
endif|#
directive|endif
name|word0
argument_list|(
name|rv
argument_list|)
operator|=
name|L
operator||
name|Bndry_mask1
expr_stmt|;
name|word1
argument_list|(
name|rv
argument_list|)
operator|=
literal|0xffffffff
expr_stmt|;
ifdef|#
directive|ifdef
name|IBM
goto|goto
name|cont
goto|;
else|#
directive|else
break|break;
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|ROUND_BIASED
if|if
condition|(
operator|!
operator|(
name|word1
argument_list|(
name|rv
argument_list|)
operator|&
name|LSB
operator|)
condition|)
break|break;
endif|#
directive|endif
if|if
condition|(
name|dsign
condition|)
name|rv
operator|+=
name|ulp
argument_list|(
name|rv
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ROUND_BIASED
else|else
block|{
name|rv
operator|-=
name|ulp
argument_list|(
name|rv
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|Sudden_Underflow
if|if
condition|(
operator|!
name|rv
condition|)
goto|goto
name|undfl
goto|;
endif|#
directive|endif
block|}
endif|#
directive|endif
break|break;
block|}
if|if
condition|(
operator|(
name|aadj
operator|=
name|ratio
argument_list|(
name|delta
argument_list|,
name|bs
argument_list|)
operator|)
operator|<=
literal|2.
condition|)
block|{
if|if
condition|(
name|dsign
condition|)
name|aadj
operator|=
name|aadj1
operator|=
literal|1.
expr_stmt|;
elseif|else
if|if
condition|(
name|word1
argument_list|(
name|rv
argument_list|)
operator|||
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Bndry_mask
condition|)
block|{
ifndef|#
directive|ifndef
name|Sudden_Underflow
if|if
condition|(
name|word1
argument_list|(
name|rv
argument_list|)
operator|==
name|Tiny1
operator|&&
operator|!
name|word0
argument_list|(
name|rv
argument_list|)
condition|)
goto|goto
name|undfl
goto|;
endif|#
directive|endif
name|aadj
operator|=
literal|1.
expr_stmt|;
name|aadj1
operator|=
operator|-
literal|1.
expr_stmt|;
block|}
else|else
block|{
comment|/* special case -- power of FLT_RADIX to be */
comment|/* rounded down... */
if|if
condition|(
name|aadj
operator|<
literal|2.
operator|/
name|FLT_RADIX
condition|)
name|aadj
operator|=
literal|1.
operator|/
name|FLT_RADIX
expr_stmt|;
else|else
name|aadj
operator|*=
literal|0.5
expr_stmt|;
name|aadj1
operator|=
operator|-
name|aadj
expr_stmt|;
block|}
block|}
else|else
block|{
name|aadj
operator|*=
literal|0.5
expr_stmt|;
name|aadj1
operator|=
name|dsign
condition|?
name|aadj
else|:
operator|-
name|aadj
expr_stmt|;
ifdef|#
directive|ifdef
name|Check_FLT_ROUNDS
switch|switch
condition|(
name|FLT_ROUNDS
condition|)
block|{
case|case
literal|2
case|:
comment|/* towards +infinity */
name|aadj1
operator|-=
literal|0.5
expr_stmt|;
break|break;
case|case
literal|0
case|:
comment|/* towards 0 */
case|case
literal|3
case|:
comment|/* towards -infinity */
name|aadj1
operator|+=
literal|0.5
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|FLT_ROUNDS
operator|==
literal|0
condition|)
name|aadj1
operator|+=
literal|0.5
expr_stmt|;
endif|#
directive|endif
block|}
name|y
operator|=
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
expr_stmt|;
comment|/* Check for overflow */
if|if
condition|(
name|y
operator|==
name|Exp_msk1
operator|*
operator|(
name|DBL_MAX_EXP
operator|+
name|Bias
operator|-
literal|1
operator|)
condition|)
block|{
name|rv0
operator|=
name|rv
expr_stmt|;
name|word0
argument_list|(
name|rv
argument_list|)
operator|-=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
name|adj
operator|=
name|aadj1
operator|*
name|ulp
argument_list|(
name|rv
argument_list|)
expr_stmt|;
name|rv
operator|+=
name|adj
expr_stmt|;
if|if
condition|(
operator|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|>=
name|Exp_msk1
operator|*
operator|(
name|DBL_MAX_EXP
operator|+
name|Bias
operator|-
name|P
operator|)
condition|)
block|{
if|if
condition|(
name|word0
argument_list|(
name|rv0
argument_list|)
operator|==
name|Big0
operator|&&
name|word1
argument_list|(
name|rv0
argument_list|)
operator|==
name|Big1
condition|)
goto|goto
name|ovfl
goto|;
name|word0
argument_list|(
name|rv
argument_list|)
operator|=
name|Big0
expr_stmt|;
name|word1
argument_list|(
name|rv
argument_list|)
operator|=
name|Big1
expr_stmt|;
goto|goto
name|cont
goto|;
block|}
else|else
name|word0
argument_list|(
name|rv
argument_list|)
operator|+=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|Sudden_Underflow
if|if
condition|(
operator|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|<=
name|P
operator|*
name|Exp_msk1
condition|)
block|{
name|rv0
operator|=
name|rv
expr_stmt|;
name|word0
argument_list|(
name|rv
argument_list|)
operator|+=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
name|adj
operator|=
name|aadj1
operator|*
name|ulp
argument_list|(
name|rv
argument_list|)
expr_stmt|;
name|rv
operator|+=
name|adj
expr_stmt|;
ifdef|#
directive|ifdef
name|IBM
if|if
condition|(
operator|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|<
name|P
operator|*
name|Exp_msk1
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|<=
name|P
operator|*
name|Exp_msk1
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
name|word0
argument_list|(
name|rv0
argument_list|)
operator|==
name|Tiny0
operator|&&
name|word1
argument_list|(
name|rv0
argument_list|)
operator|==
name|Tiny1
condition|)
goto|goto
name|undfl
goto|;
name|word0
argument_list|(
name|rv
argument_list|)
operator|=
name|Tiny0
expr_stmt|;
name|word1
argument_list|(
name|rv
argument_list|)
operator|=
name|Tiny1
expr_stmt|;
goto|goto
name|cont
goto|;
block|}
else|else
name|word0
argument_list|(
name|rv
argument_list|)
operator|-=
name|P
operator|*
name|Exp_msk1
expr_stmt|;
block|}
else|else
block|{
name|adj
operator|=
name|aadj1
operator|*
name|ulp
argument_list|(
name|rv
argument_list|)
expr_stmt|;
name|rv
operator|+=
name|adj
expr_stmt|;
block|}
else|#
directive|else
comment|/* Compute adj so that the IEEE rounding rules will 			 * correctly round rv + adj in some half-way cases. 			 * If rv * ulp(rv) is denormalized (i.e., 			 * y<= (P-1)*Exp_msk1), we must adjust aadj to avoid 			 * trouble from bits lost to denormalization; 			 * example: 1.2e-307 . 			 */
if|if
condition|(
name|y
operator|<=
operator|(
name|P
operator|-
literal|1
operator|)
operator|*
name|Exp_msk1
operator|&&
name|aadj
operator|>=
literal|1.
condition|)
block|{
name|aadj1
operator|=
call|(
name|double
call|)
argument_list|(
name|int
argument_list|)
argument_list|(
name|aadj
operator|+
literal|0.5
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dsign
condition|)
name|aadj1
operator|=
operator|-
name|aadj1
expr_stmt|;
block|}
name|adj
operator|=
name|aadj1
operator|*
name|ulp
argument_list|(
name|rv
argument_list|)
expr_stmt|;
name|rv
operator|+=
name|adj
expr_stmt|;
endif|#
directive|endif
block|}
name|z
operator|=
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Exp_mask
expr_stmt|;
if|if
condition|(
name|y
operator|==
name|z
condition|)
block|{
comment|/* Can we stop now? */
name|L
operator|=
name|aadj
expr_stmt|;
name|aadj
operator|-=
name|L
expr_stmt|;
comment|/* The tolerances below are conservative. */
if|if
condition|(
name|dsign
operator|||
name|word1
argument_list|(
name|rv
argument_list|)
operator|||
name|word0
argument_list|(
name|rv
argument_list|)
operator|&
name|Bndry_mask
condition|)
block|{
if|if
condition|(
name|aadj
operator|<
literal|.4999999
operator|||
name|aadj
operator|>
literal|.5000001
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|aadj
operator|<
literal|.4999999
operator|/
name|FLT_RADIX
condition|)
break|break;
block|}
name|cont
label|:
name|Bfree
argument_list|(
name|bb
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|bd
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|bs
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|delta
argument_list|)
expr_stmt|;
block|}
end_for

begin_expr_stmt
name|Bfree
argument_list|(
name|bb
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Bfree
argument_list|(
name|bd
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Bfree
argument_list|(
name|bs
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Bfree
argument_list|(
name|bd0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|Bfree
argument_list|(
name|delta
argument_list|)
expr_stmt|;
end_expr_stmt

begin_label
name|ret
label|:
end_label

begin_if
if|if
condition|(
name|se
condition|)
operator|*
name|se
operator|=
operator|(
name|char
operator|*
operator|)
name|s
expr_stmt|;
end_if

begin_return
return|return
name|sign
condition|?
operator|-
name|rv
else|:
name|rv
return|;
end_return

begin_decl_stmt
unit|}   static
name|int
name|quorem
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
name|b
argument_list|,
name|S
argument_list|)
name|Bigint
modifier|*
name|b
decl_stmt|,
modifier|*
name|S
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|Bigint
operator|*
name|b
operator|,
name|Bigint
operator|*
name|S
operator|)
endif|#
directive|endif
block|{
name|int
name|n
block|;
name|Long
name|borrow
block|,
name|y
block|;
name|ULong
name|carry
block|,
name|q
block|,
name|ys
block|;
name|ULong
operator|*
name|bx
block|,
operator|*
name|bxe
block|,
operator|*
name|sx
block|,
operator|*
name|sxe
block|;
ifdef|#
directive|ifdef
name|Pack_32
name|Long
name|z
block|;
name|ULong
name|si
block|,
name|zs
block|;
endif|#
directive|endif
name|n
operator|=
name|S
operator|->
name|wds
block|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/*debug*/
if|if
condition|(
name|b
operator|->
name|wds
operator|>
name|n
condition|)
comment|/*debug*/
name|Bug
argument_list|(
literal|"oversize b in quorem"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
name|b
operator|->
name|wds
operator|<
name|n
condition|)
return|return
literal|0
return|;
end_if

begin_expr_stmt
name|sx
operator|=
name|S
operator|->
name|x
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|sxe
operator|=
name|sx
operator|+
operator|--
name|n
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bx
operator|=
name|b
operator|->
name|x
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|bxe
operator|=
name|bx
operator|+
name|n
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|q
operator|=
operator|*
name|bxe
operator|/
operator|(
operator|*
name|sxe
operator|+
literal|1
operator|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ensure q<= true quotient */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_comment
comment|/*debug*/
end_comment

begin_if
if|if
condition|(
name|q
operator|>
literal|9
condition|)
comment|/*debug*/
name|Bug
argument_list|(
literal|"oversized quotient in quorem"
argument_list|)
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
name|q
condition|)
block|{
name|borrow
operator|=
literal|0
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
do|do
block|{
ifdef|#
directive|ifdef
name|Pack_32
name|si
operator|=
operator|*
name|sx
operator|++
expr_stmt|;
name|ys
operator|=
operator|(
name|si
operator|&
literal|0xffff
operator|)
operator|*
name|q
operator|+
name|carry
expr_stmt|;
name|zs
operator|=
operator|(
name|si
operator|>>
literal|16
operator|)
operator|*
name|q
operator|+
operator|(
name|ys
operator|>>
literal|16
operator|)
expr_stmt|;
name|carry
operator|=
name|zs
operator|>>
literal|16
expr_stmt|;
name|y
operator|=
operator|(
operator|*
name|bx
operator|&
literal|0xffff
operator|)
operator|-
operator|(
name|ys
operator|&
literal|0xffff
operator|)
operator|+
name|borrow
expr_stmt|;
name|borrow
operator|=
name|y
operator|>>
literal|16
expr_stmt|;
name|Sign_Extend
argument_list|(
name|borrow
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|z
operator|=
operator|(
operator|*
name|bx
operator|>>
literal|16
operator|)
operator|-
operator|(
name|zs
operator|&
literal|0xffff
operator|)
operator|+
name|borrow
expr_stmt|;
name|borrow
operator|=
name|z
operator|>>
literal|16
expr_stmt|;
name|Sign_Extend
argument_list|(
name|borrow
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|Storeinc
argument_list|(
name|bx
argument_list|,
name|z
argument_list|,
name|y
argument_list|)
expr_stmt|;
else|#
directive|else
name|ys
operator|=
operator|*
name|sx
operator|++
operator|*
name|q
operator|+
name|carry
expr_stmt|;
name|carry
operator|=
name|ys
operator|>>
literal|16
expr_stmt|;
name|y
operator|=
operator|*
name|bx
operator|-
operator|(
name|ys
operator|&
literal|0xffff
operator|)
operator|+
name|borrow
expr_stmt|;
name|borrow
operator|=
name|y
operator|>>
literal|16
expr_stmt|;
name|Sign_Extend
argument_list|(
name|borrow
argument_list|,
name|y
argument_list|)
expr_stmt|;
operator|*
name|bx
operator|++
operator|=
name|y
operator|&
literal|0xffff
expr_stmt|;
endif|#
directive|endif
block|}
do|while
condition|(
name|sx
operator|<=
name|sxe
condition|)
do|;
if|if
condition|(
operator|!
operator|*
name|bxe
condition|)
block|{
name|bx
operator|=
name|b
operator|->
name|x
expr_stmt|;
while|while
condition|(
operator|--
name|bxe
operator|>
name|bx
operator|&&
operator|!
operator|*
name|bxe
condition|)
operator|--
name|n
expr_stmt|;
name|b
operator|->
name|wds
operator|=
name|n
expr_stmt|;
block|}
block|}
end_if

begin_if
if|if
condition|(
name|cmp
argument_list|(
name|b
argument_list|,
name|S
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|q
operator|++
expr_stmt|;
name|borrow
operator|=
literal|0
expr_stmt|;
name|carry
operator|=
literal|0
expr_stmt|;
name|bx
operator|=
name|b
operator|->
name|x
expr_stmt|;
name|sx
operator|=
name|S
operator|->
name|x
expr_stmt|;
do|do
block|{
ifdef|#
directive|ifdef
name|Pack_32
name|si
operator|=
operator|*
name|sx
operator|++
expr_stmt|;
name|ys
operator|=
operator|(
name|si
operator|&
literal|0xffff
operator|)
operator|+
name|carry
expr_stmt|;
name|zs
operator|=
operator|(
name|si
operator|>>
literal|16
operator|)
operator|+
operator|(
name|ys
operator|>>
literal|16
operator|)
expr_stmt|;
name|carry
operator|=
name|zs
operator|>>
literal|16
expr_stmt|;
name|y
operator|=
operator|(
operator|*
name|bx
operator|&
literal|0xffff
operator|)
operator|-
operator|(
name|ys
operator|&
literal|0xffff
operator|)
operator|+
name|borrow
expr_stmt|;
name|borrow
operator|=
name|y
operator|>>
literal|16
expr_stmt|;
name|Sign_Extend
argument_list|(
name|borrow
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|z
operator|=
operator|(
operator|*
name|bx
operator|>>
literal|16
operator|)
operator|-
operator|(
name|zs
operator|&
literal|0xffff
operator|)
operator|+
name|borrow
expr_stmt|;
name|borrow
operator|=
name|z
operator|>>
literal|16
expr_stmt|;
name|Sign_Extend
argument_list|(
name|borrow
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|Storeinc
argument_list|(
name|bx
argument_list|,
name|z
argument_list|,
name|y
argument_list|)
expr_stmt|;
else|#
directive|else
name|ys
operator|=
operator|*
name|sx
operator|++
operator|+
name|carry
expr_stmt|;
name|carry
operator|=
name|ys
operator|>>
literal|16
expr_stmt|;
name|y
operator|=
operator|*
name|bx
operator|-
operator|(
name|ys
operator|&
literal|0xffff
operator|)
operator|+
name|borrow
expr_stmt|;
name|borrow
operator|=
name|y
operator|>>
literal|16
expr_stmt|;
name|Sign_Extend
argument_list|(
name|borrow
argument_list|,
name|y
argument_list|)
expr_stmt|;
operator|*
name|bx
operator|++
operator|=
name|y
operator|&
literal|0xffff
expr_stmt|;
endif|#
directive|endif
block|}
do|while
condition|(
name|sx
operator|<=
name|sxe
condition|)
do|;
name|bx
operator|=
name|b
operator|->
name|x
expr_stmt|;
name|bxe
operator|=
name|bx
operator|+
name|n
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|bxe
condition|)
block|{
while|while
condition|(
operator|--
name|bxe
operator|>
name|bx
operator|&&
operator|!
operator|*
name|bxe
condition|)
operator|--
name|n
expr_stmt|;
name|b
operator|->
name|wds
operator|=
name|n
expr_stmt|;
block|}
block|}
end_if

begin_return
return|return
name|q
return|;
end_return

begin_comment
unit|}
comment|/* dtoa for IEEE arithmetic (dmg): convert double to ASCII string.  *  * Inspired by "How to Print Floating-Point Numbers Accurately" by  * Guy L. Steele, Jr. and Jon L. White [Proc. ACM SIGPLAN '90, pp. 92-101].  *  * Modifications:  *	1. Rather than iterating, we use a simple numeric overestimate  *	   to determine k = floor(log10(d)).  We scale relevant  *	   quantities using O(log2(k)) rather than O(k) multiplications.  *	2. For some modes> 2 (corresponding to ecvt and fcvt), we don't  *	   try to generate digits strictly left to right.  Instead, we  *	   compute with fewer bits and propagate the carry if necessary  *	   when rounding the final digit up.  This is often faster.  *	3. Under the assumption that input will be rounded nearest,  *	   mode 0 renders 1e23 as 1e23 rather than 9.999999999999999e22.  *	   That is, we allow equality in stopping tests when the  *	   round-nearest rule will give the same floating-point value  *	   as would satisfaction of the stopping test with strict  *	   inequality.  *	4. We remove common factors of powers of 2 from relevant  *	   quantities.  *	5. When converting floating-point integers less than 1e16,  *	   we use floating-point arithmetic rather than resorting  *	   to multiple-precision integers.  *	6. When asked to produce fewer than 15 digits, we first try  *	   to get by with floating-point arithmetic; we resort to  *	   multiple-precision integer arithmetic only if we cannot  *	   guarantee that the floating-point calculation has given  *	   the correctly rounded result.  For k requested digits and  *	   "uniformly" distributed input, the probability is  *	   something like 10^(k-15) that we must resort to the Long  *	   calculation.  */
end_comment

begin_expr_stmt
unit|char
operator|*
name|__dtoa
ifdef|#
directive|ifdef
name|KR_headers
argument_list|(
argument|d
argument_list|,
argument|mode
argument_list|,
argument|ndigits
argument_list|,
argument|decpt
argument_list|,
argument|sign
argument_list|,
argument|rve
argument_list|,
argument|resultp
argument_list|)
name|double
name|d
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|mode
decl_stmt|,
name|ndigits
decl_stmt|,
modifier|*
name|decpt
decl_stmt|,
modifier|*
name|sign
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|rve
decl_stmt|,
modifier|*
modifier|*
name|resultp
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
operator|(
name|double
name|d
operator|,
name|int
name|mode
operator|,
name|int
name|ndigits
operator|,
name|int
operator|*
name|decpt
operator|,
name|int
operator|*
name|sign
operator|,
name|char
operator|*
operator|*
name|rve
operator|,
name|char
operator|*
operator|*
name|resultp
operator|)
endif|#
directive|endif
block|{
comment|/*	Arguments ndigits, decpt, sign are similar to those 	of ecvt and fcvt; trailing zeros are suppressed from 	the returned string.  If not null, *rve is set to point 	to the end of the return value.  If d is +-Infinity or NaN, 	then *decpt is set to 9999.  	mode: 		0 ==> shortest string that yields d when read in 			and rounded to nearest. 		1 ==> like 0, but with Steele& White stopping rule; 			e.g. with IEEE P754 arithmetic , mode 0 gives 			1e23 whereas mode 1 gives 9.999999999999999e22. 		2 ==> max(1,ndigits) significant digits.  This gives a 			return value similar to that of ecvt, except 			that trailing zeros are suppressed. 		3 ==> through ndigits past the decimal point.  This 			gives a return value similar to that from fcvt, 			except that trailing zeros are suppressed, and 			ndigits can be negative. 		4-9 should give the same return values as 2-3, i.e., 			4<= mode<= 9 ==> same return as mode 			2 + (mode& 1).  These modes are mainly for 			debugging; often they run slower but sometimes 			faster than modes 2-3. 		4,5,8,9 ==> left-to-right digit generation. 		6-9 ==> don't try fast floating-point estimate 			(if applicable).  		Values of mode other than 0-9 are treated as mode 0.  		Sufficient space is allocated to the return value 		to hold the suppressed trailing zeros. 	*/
name|int
name|bbits
block|,
name|b2
block|,
name|b5
block|,
name|be
block|,
name|dig
block|,
name|i
block|,
name|ieps
block|,
name|ilim
block|,
name|ilim0
block|,
name|ilim1
block|,
name|j
block|,
name|j1
block|,
name|k
block|,
name|k0
block|,
name|k_check
block|,
name|leftright
block|,
name|m2
block|,
name|m5
block|,
name|s2
block|,
name|s5
block|,
name|spec_case
block|,
name|try_quick
block|;
name|Long
name|L
block|;
ifndef|#
directive|ifndef
name|Sudden_Underflow
name|int
name|denorm
block|;
name|ULong
name|x
block|;
endif|#
directive|endif
name|Bigint
operator|*
name|b
block|,
operator|*
name|b1
block|,
operator|*
name|delta
block|,
operator|*
name|mlo
block|,
operator|*
name|mhi
block|,
operator|*
name|S
block|;
name|double
name|d2
block|,
name|ds
block|,
name|eps
block|;
name|char
operator|*
name|s
block|,
operator|*
name|s0
block|;
if|if
condition|(
name|word0
argument_list|(
name|d
argument_list|)
operator|&
name|Sign_bit
condition|)
block|{
comment|/* set sign for everything, including 0's and NaNs */
operator|*
name|sign
operator|=
literal|1
expr_stmt|;
name|word0
argument_list|(
name|d
argument_list|)
operator|&=
operator|~
name|Sign_bit
expr_stmt|;
comment|/* clear sign bit */
block|}
end_expr_stmt

begin_else
else|else
operator|*
name|sign
operator|=
literal|0
expr_stmt|;
end_else

begin_if
if|#
directive|if
name|defined
argument_list|(
name|IEEE_Arith
argument_list|)
operator|+
name|defined
argument_list|(
name|VAX
argument_list|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|IEEE_Arith
end_ifdef

begin_if
if|if
condition|(
operator|(
name|word0
argument_list|(
name|d
argument_list|)
operator|&
name|Exp_mask
operator|)
operator|==
name|Exp_mask
condition|)
else|#
directive|else
if|if
condition|(
name|word0
argument_list|(
name|d
argument_list|)
operator|==
literal|0x8000
condition|)
endif|#
directive|endif
block|{
comment|/* Infinity or NaN */
operator|*
name|decpt
operator|=
literal|9999
expr_stmt|;
name|s
operator|=
ifdef|#
directive|ifdef
name|IEEE_Arith
operator|!
name|word1
argument_list|(
name|d
argument_list|)
operator|&&
operator|!
operator|(
name|word0
argument_list|(
name|d
argument_list|)
operator|&
literal|0xfffff
operator|)
condition|?
literal|"Infinity"
else|:
endif|#
directive|endif
literal|"NaN"
expr_stmt|;
if|if
condition|(
name|rve
condition|)
operator|*
name|rve
operator|=
ifdef|#
directive|ifdef
name|IEEE_Arith
name|s
index|[
literal|3
index|]
condition|?
name|s
operator|+
literal|8
else|:
endif|#
directive|endif
name|s
operator|+
literal|3
expr_stmt|;
return|return
name|s
return|;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|IBM
end_ifdef

begin_expr_stmt
name|d
operator|+=
literal|0
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* normalize */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
operator|!
name|d
condition|)
block|{
operator|*
name|decpt
operator|=
literal|1
expr_stmt|;
name|s
operator|=
literal|"0"
expr_stmt|;
if|if
condition|(
name|rve
condition|)
operator|*
name|rve
operator|=
name|s
operator|+
literal|1
expr_stmt|;
return|return
name|s
return|;
block|}
end_if

begin_expr_stmt
name|b
operator|=
name|d2b
argument_list|(
name|d
argument_list|,
operator|&
name|be
argument_list|,
operator|&
name|bbits
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|Sudden_Underflow
end_ifdef

begin_expr_stmt
name|i
operator|=
call|(
name|int
call|)
argument_list|(
name|word0
argument_list|(
name|d
argument_list|)
operator|>>
name|Exp_shift1
operator|&
operator|(
name|Exp_mask
operator|>>
name|Exp_shift1
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_if
if|if
condition|(
operator|(
name|i
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|word0
argument_list|(
name|d
argument_list|)
operator|>>
name|Exp_shift1
operator|)
operator|&
operator|(
name|Exp_mask
operator|>>
name|Exp_shift1
operator|)
argument_list|)
operator|)
condition|)
block|{
endif|#
directive|endif
name|d2
operator|=
name|d
expr_stmt|;
name|word0
argument_list|(
name|d2
argument_list|)
operator|&=
name|Frac_mask1
expr_stmt|;
name|word0
argument_list|(
name|d2
argument_list|)
operator||=
name|Exp_11
expr_stmt|;
ifdef|#
directive|ifdef
name|IBM
if|if
condition|(
operator|(
name|j
operator|=
literal|11
operator|-
name|hi0bits
argument_list|(
name|word0
argument_list|(
name|d2
argument_list|)
operator|&
name|Frac_mask
argument_list|)
operator|)
condition|)
name|d2
operator|/=
literal|1
operator|<<
name|j
expr_stmt|;
endif|#
directive|endif
comment|/* log(x)	~=~ log(1.5) + (x-1.5)/1.5 		 * log10(x)	 =  log(x) / log(10) 		 *		~=~ log(1.5)/log(10) + (x-1.5)/(1.5*log(10)) 		 * log10(d) = (i-Bias)*log(2)/log(10) + log10(d2) 		 * 		 * This suggests computing an approximation k to log10(d) by 		 * 		 * k = (i - Bias)*0.301029995663981 		 *	+ ( (d2-1.5)*0.289529654602168 + 0.176091259055681 ); 		 * 		 * We want k to be too large rather than too small. 		 * The error in the first-order Taylor series approximation 		 * is in our favor, so we just round up the constant enough 		 * to compensate for any error in the multiplication of 		 * (i - Bias) by 0.301029995663981; since |i - Bias|<= 1077, 		 * and 1077 * 0.30103 * 2^-52 ~=~ 7.2e-14, 		 * adding 1e-13 to the constant term more than suffices. 		 * Hence we adjust the constant term to 0.1760912590558. 		 * (We could get a more accurate k by invoking log10, 		 *  but this is probably not worthwhile.) 		 */
name|i
operator|-=
name|Bias
expr_stmt|;
ifdef|#
directive|ifdef
name|IBM
name|i
operator|<<=
literal|2
expr_stmt|;
name|i
operator|+=
name|j
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|Sudden_Underflow
name|denorm
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* d is denormalized */
name|i
operator|=
name|bbits
operator|+
name|be
operator|+
operator|(
name|Bias
operator|+
operator|(
name|P
operator|-
literal|1
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
name|x
operator|=
name|i
operator|>
literal|32
condition|?
operator|(
operator|(
name|word0
argument_list|(
name|d
argument_list|)
operator|<<
operator|(
literal|64
operator|-
name|i
operator|)
operator|)
operator||
operator|(
name|word1
argument_list|(
name|d
argument_list|)
operator|>>
operator|(
name|i
operator|-
literal|32
operator|)
operator|)
operator|)
else|:
operator|(
name|word1
argument_list|(
name|d
argument_list|)
operator|<<
operator|(
literal|32
operator|-
name|i
operator|)
operator|)
expr_stmt|;
name|d2
operator|=
name|x
expr_stmt|;
name|word0
argument_list|(
name|d2
argument_list|)
operator|-=
literal|31
operator|*
name|Exp_msk1
expr_stmt|;
comment|/* adjust exponent */
name|i
operator|-=
operator|(
name|Bias
operator|+
operator|(
name|P
operator|-
literal|1
operator|)
operator|-
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
name|denorm
operator|=
literal|1
expr_stmt|;
block|}
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|ds
operator|=
operator|(
name|d2
operator|-
literal|1.5
operator|)
operator|*
literal|0.289529654602168
operator|+
literal|0.1760912590558
operator|+
name|i
operator|*
literal|0.301029995663981
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|k
operator|=
operator|(
name|int
operator|)
name|ds
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|ds
operator|<
literal|0.
operator|&&
name|ds
operator|!=
name|k
condition|)
name|k
operator|--
expr_stmt|;
end_if

begin_comment
comment|/* want k = floor(ds) */
end_comment

begin_expr_stmt
name|k_check
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|k
operator|>=
literal|0
operator|&&
name|k
operator|<=
name|Ten_pmax
condition|)
block|{
if|if
condition|(
name|d
operator|<
name|tens
index|[
name|k
index|]
condition|)
name|k
operator|--
expr_stmt|;
name|k_check
operator|=
literal|0
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|j
operator|=
name|bbits
operator|-
name|i
operator|-
literal|1
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|j
operator|>=
literal|0
condition|)
block|{
name|b2
operator|=
literal|0
expr_stmt|;
name|s2
operator|=
name|j
expr_stmt|;
block|}
else|else
block|{
name|b2
operator|=
operator|-
name|j
expr_stmt|;
name|s2
operator|=
literal|0
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|k
operator|>=
literal|0
condition|)
block|{
name|b5
operator|=
literal|0
expr_stmt|;
name|s5
operator|=
name|k
expr_stmt|;
name|s2
operator|+=
name|k
expr_stmt|;
block|}
else|else
block|{
name|b2
operator|-=
name|k
expr_stmt|;
name|b5
operator|=
operator|-
name|k
expr_stmt|;
name|s5
operator|=
literal|0
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|mode
operator|<
literal|0
operator|||
name|mode
operator|>
literal|9
condition|)
name|mode
operator|=
literal|0
expr_stmt|;
end_if

begin_expr_stmt
name|try_quick
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|mode
operator|>
literal|5
condition|)
block|{
name|mode
operator|-=
literal|4
expr_stmt|;
name|try_quick
operator|=
literal|0
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|leftright
operator|=
literal|1
expr_stmt|;
end_expr_stmt

begin_switch
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
name|ilim
operator|=
name|ilim1
operator|=
operator|-
literal|1
expr_stmt|;
name|i
operator|=
literal|18
expr_stmt|;
name|ndigits
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|leftright
operator|=
literal|0
expr_stmt|;
comment|/* no break */
case|case
literal|4
case|:
if|if
condition|(
name|ndigits
operator|<=
literal|0
condition|)
name|ndigits
operator|=
literal|1
expr_stmt|;
name|ilim
operator|=
name|ilim1
operator|=
name|i
operator|=
name|ndigits
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|leftright
operator|=
literal|0
expr_stmt|;
comment|/* no break */
case|case
literal|5
case|:
name|i
operator|=
name|ndigits
operator|+
name|k
operator|+
literal|1
expr_stmt|;
name|ilim
operator|=
name|i
expr_stmt|;
name|ilim1
operator|=
name|i
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
name|i
operator|=
literal|1
expr_stmt|;
block|}
end_switch

begin_expr_stmt
operator|*
name|resultp
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|s
operator|=
name|s0
operator|=
operator|*
name|resultp
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|ilim
operator|>=
literal|0
operator|&&
name|ilim
operator|<=
name|Quick_max
operator|&&
name|try_quick
condition|)
block|{
comment|/* Try to get by with floating-point arithmetic. */
name|i
operator|=
literal|0
expr_stmt|;
name|d2
operator|=
name|d
expr_stmt|;
name|k0
operator|=
name|k
expr_stmt|;
name|ilim0
operator|=
name|ilim
expr_stmt|;
name|ieps
operator|=
literal|2
expr_stmt|;
comment|/* conservative */
if|if
condition|(
name|k
operator|>
literal|0
condition|)
block|{
name|ds
operator|=
name|tens
index|[
name|k
operator|&
literal|0xf
index|]
expr_stmt|;
name|j
operator|=
name|k
operator|>>
literal|4
expr_stmt|;
if|if
condition|(
name|j
operator|&
name|Bletch
condition|)
block|{
comment|/* prevent overflows */
name|j
operator|&=
name|Bletch
operator|-
literal|1
expr_stmt|;
name|d
operator|/=
name|bigtens
index|[
name|n_bigtens
operator|-
literal|1
index|]
expr_stmt|;
name|ieps
operator|++
expr_stmt|;
block|}
for|for
control|(
init|;
name|j
condition|;
name|j
operator|>>=
literal|1
operator|,
name|i
operator|++
control|)
if|if
condition|(
name|j
operator|&
literal|1
condition|)
block|{
name|ieps
operator|++
expr_stmt|;
name|ds
operator|*=
name|bigtens
index|[
name|i
index|]
expr_stmt|;
block|}
name|d
operator|/=
name|ds
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|j1
operator|=
operator|-
name|k
operator|)
condition|)
block|{
name|d
operator|*=
name|tens
index|[
name|j1
operator|&
literal|0xf
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
name|j1
operator|>>
literal|4
init|;
name|j
condition|;
name|j
operator|>>=
literal|1
operator|,
name|i
operator|++
control|)
if|if
condition|(
name|j
operator|&
literal|1
condition|)
block|{
name|ieps
operator|++
expr_stmt|;
name|d
operator|*=
name|bigtens
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|k_check
operator|&&
name|d
operator|<
literal|1.
operator|&&
name|ilim
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ilim1
operator|<=
literal|0
condition|)
goto|goto
name|fast_failed
goto|;
name|ilim
operator|=
name|ilim1
expr_stmt|;
name|k
operator|--
expr_stmt|;
name|d
operator|*=
literal|10.
expr_stmt|;
name|ieps
operator|++
expr_stmt|;
block|}
name|eps
operator|=
name|ieps
operator|*
name|d
operator|+
literal|7.
expr_stmt|;
name|word0
argument_list|(
name|eps
argument_list|)
operator|-=
operator|(
name|P
operator|-
literal|1
operator|)
operator|*
name|Exp_msk1
expr_stmt|;
if|if
condition|(
name|ilim
operator|==
literal|0
condition|)
block|{
name|S
operator|=
name|mhi
operator|=
literal|0
expr_stmt|;
name|d
operator|-=
literal|5.
expr_stmt|;
if|if
condition|(
name|d
operator|>
name|eps
condition|)
goto|goto
name|one_digit
goto|;
if|if
condition|(
name|d
operator|<
operator|-
name|eps
condition|)
goto|goto
name|no_digits
goto|;
goto|goto
name|fast_failed
goto|;
block|}
ifndef|#
directive|ifndef
name|No_leftright
if|if
condition|(
name|leftright
condition|)
block|{
comment|/* Use Steele& White method of only 			 * generating digits needed. 			 */
name|eps
operator|=
literal|0.5
operator|/
name|tens
index|[
name|ilim
operator|-
literal|1
index|]
operator|-
name|eps
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
control|)
block|{
name|L
operator|=
name|d
expr_stmt|;
name|d
operator|-=
name|L
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'0'
operator|+
operator|(
name|int
operator|)
name|L
expr_stmt|;
if|if
condition|(
name|d
operator|<
name|eps
condition|)
goto|goto
name|ret1
goto|;
if|if
condition|(
literal|1.
operator|-
name|d
operator|<
name|eps
condition|)
goto|goto
name|bump_up
goto|;
if|if
condition|(
operator|++
name|i
operator|>=
name|ilim
condition|)
break|break;
name|eps
operator|*=
literal|10.
expr_stmt|;
name|d
operator|*=
literal|10.
expr_stmt|;
block|}
block|}
else|else
block|{
endif|#
directive|endif
comment|/* Generate ilim digits, then fix them up. */
name|eps
operator|*=
name|tens
index|[
name|ilim
operator|-
literal|1
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
condition|;
name|i
operator|++
operator|,
name|d
operator|*=
literal|10.
control|)
block|{
name|L
operator|=
name|d
expr_stmt|;
name|d
operator|-=
name|L
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'0'
operator|+
operator|(
name|int
operator|)
name|L
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|ilim
condition|)
block|{
if|if
condition|(
name|d
operator|>
literal|0.5
operator|+
name|eps
condition|)
goto|goto
name|bump_up
goto|;
elseif|else
if|if
condition|(
name|d
operator|<
literal|0.5
operator|-
name|eps
condition|)
block|{
while|while
condition|(
operator|*
operator|--
name|s
operator|==
literal|'0'
condition|)
empty_stmt|;
name|s
operator|++
expr_stmt|;
goto|goto
name|ret1
goto|;
block|}
break|break;
block|}
block|}
ifndef|#
directive|ifndef
name|No_leftright
block|}
endif|#
directive|endif
name|fast_failed
label|:
name|s
operator|=
name|s0
expr_stmt|;
name|d
operator|=
name|d2
expr_stmt|;
name|k
operator|=
name|k0
expr_stmt|;
name|ilim
operator|=
name|ilim0
expr_stmt|;
block|}
end_if

begin_comment
comment|/* Do we have a "small" integer? */
end_comment

begin_if
if|if
condition|(
name|be
operator|>=
literal|0
operator|&&
name|k
operator|<=
name|Int_max
condition|)
block|{
comment|/* Yes. */
name|ds
operator|=
name|tens
index|[
name|k
index|]
expr_stmt|;
if|if
condition|(
name|ndigits
operator|<
literal|0
operator|&&
name|ilim
operator|<=
literal|0
condition|)
block|{
name|S
operator|=
name|mhi
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ilim
operator|<
literal|0
operator|||
name|d
operator|<=
literal|5
operator|*
name|ds
condition|)
goto|goto
name|no_digits
goto|;
goto|goto
name|one_digit
goto|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
condition|;
name|i
operator|++
control|)
block|{
name|L
operator|=
name|d
operator|/
name|ds
expr_stmt|;
name|d
operator|-=
name|L
operator|*
name|ds
expr_stmt|;
ifdef|#
directive|ifdef
name|Check_FLT_ROUNDS
comment|/* If FLT_ROUNDS == 2, L will usually be high by 1 */
if|if
condition|(
name|d
operator|<
literal|0
condition|)
block|{
name|L
operator|--
expr_stmt|;
name|d
operator|+=
name|ds
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
name|s
operator|++
operator|=
literal|'0'
operator|+
operator|(
name|int
operator|)
name|L
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|ilim
condition|)
block|{
name|d
operator|+=
name|d
expr_stmt|;
if|if
condition|(
name|d
operator|>
name|ds
operator|||
operator|(
name|d
operator|==
name|ds
operator|&&
name|L
operator|&
literal|1
operator|)
condition|)
block|{
name|bump_up
label|:
while|while
condition|(
operator|*
operator|--
name|s
operator|==
literal|'9'
condition|)
if|if
condition|(
name|s
operator|==
name|s0
condition|)
block|{
name|k
operator|++
expr_stmt|;
operator|*
name|s
operator|=
literal|'0'
expr_stmt|;
break|break;
block|}
operator|++
operator|*
name|s
operator|++
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|d
operator|*=
literal|10.
operator|)
condition|)
break|break;
block|}
goto|goto
name|ret1
goto|;
block|}
end_if

begin_expr_stmt
name|m2
operator|=
name|b2
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|m5
operator|=
name|b5
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|mhi
operator|=
name|mlo
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|leftright
condition|)
block|{
if|if
condition|(
name|mode
operator|<
literal|2
condition|)
block|{
name|i
operator|=
ifndef|#
directive|ifndef
name|Sudden_Underflow
name|denorm
condition|?
name|be
operator|+
operator|(
name|Bias
operator|+
operator|(
name|P
operator|-
literal|1
operator|)
operator|-
literal|1
operator|+
literal|1
operator|)
else|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IBM
literal|1
operator|+
literal|4
operator|*
name|P
operator|-
literal|3
operator|-
name|bbits
operator|+
operator|(
operator|(
name|bbits
operator|+
name|be
operator|-
literal|1
operator|)
operator|&
literal|3
operator|)
expr_stmt|;
else|#
directive|else
literal|1
operator|+
name|P
operator|-
name|bbits
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|j
operator|=
name|ilim
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|m5
operator|>=
name|j
condition|)
name|m5
operator|-=
name|j
expr_stmt|;
else|else
block|{
name|s5
operator|+=
name|j
operator|-=
name|m5
expr_stmt|;
name|b5
operator|+=
name|j
expr_stmt|;
name|m5
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|i
operator|=
name|ilim
operator|)
operator|<
literal|0
condition|)
block|{
name|m2
operator|-=
name|i
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|b2
operator|+=
name|i
expr_stmt|;
name|s2
operator|+=
name|i
expr_stmt|;
name|mhi
operator|=
name|i2b
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|m2
operator|>
literal|0
operator|&&
name|s2
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|m2
operator|<
name|s2
condition|?
name|m2
else|:
name|s2
expr_stmt|;
name|b2
operator|-=
name|i
expr_stmt|;
name|m2
operator|-=
name|i
expr_stmt|;
name|s2
operator|-=
name|i
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|b5
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|leftright
condition|)
block|{
if|if
condition|(
name|m5
operator|>
literal|0
condition|)
block|{
name|mhi
operator|=
name|pow5mult
argument_list|(
name|mhi
argument_list|,
name|m5
argument_list|)
expr_stmt|;
name|b1
operator|=
name|mult
argument_list|(
name|mhi
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|b
argument_list|)
expr_stmt|;
name|b
operator|=
name|b1
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|j
operator|=
name|b5
operator|-
name|m5
operator|)
condition|)
name|b
operator|=
name|pow5mult
argument_list|(
name|b
argument_list|,
name|j
argument_list|)
expr_stmt|;
block|}
else|else
name|b
operator|=
name|pow5mult
argument_list|(
name|b
argument_list|,
name|b5
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|S
operator|=
name|i2b
argument_list|(
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|s5
operator|>
literal|0
condition|)
name|S
operator|=
name|pow5mult
argument_list|(
name|S
argument_list|,
name|s5
argument_list|)
expr_stmt|;
end_if

begin_comment
comment|/* Check for special case that d is a normalized power of 2. */
end_comment

begin_if
if|if
condition|(
name|mode
operator|<
literal|2
condition|)
block|{
if|if
condition|(
operator|!
name|word1
argument_list|(
name|d
argument_list|)
operator|&&
operator|!
operator|(
name|word0
argument_list|(
name|d
argument_list|)
operator|&
name|Bndry_mask
operator|)
ifndef|#
directive|ifndef
name|Sudden_Underflow
operator|&&
name|word0
argument_list|(
name|d
argument_list|)
operator|&
name|Exp_mask
endif|#
directive|endif
condition|)
block|{
comment|/* The special case */
name|b2
operator|+=
name|Log2P
expr_stmt|;
name|s2
operator|+=
name|Log2P
expr_stmt|;
name|spec_case
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|spec_case
operator|=
literal|0
expr_stmt|;
block|}
end_if

begin_comment
comment|/* Arrange for convenient computation of quotients: 	 * shift left if necessary so divisor has 4 leading 0 bits. 	 * 	 * Perhaps we should just compute leading 28 bits of S once 	 * and for all and pass them and a shift to quorem, so it 	 * can do shifts and ors to compute the numerator for q. 	 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|Pack_32
end_ifdef

begin_if
if|if
condition|(
operator|(
name|i
operator|=
operator|(
operator|(
name|s5
condition|?
literal|32
operator|-
name|hi0bits
argument_list|(
name|S
operator|->
name|x
index|[
name|S
operator|->
name|wds
operator|-
literal|1
index|]
argument_list|)
else|:
literal|1
operator|)
operator|+
name|s2
operator|)
operator|&
literal|0x1f
operator|)
condition|)
name|i
operator|=
literal|32
operator|-
name|i
expr_stmt|;
end_if

begin_else
else|#
directive|else
end_else

begin_if
if|if
condition|(
operator|(
name|i
operator|=
operator|(
operator|(
name|s5
condition|?
literal|32
operator|-
name|hi0bits
argument_list|(
name|S
operator|->
name|x
index|[
name|S
operator|->
name|wds
operator|-
literal|1
index|]
argument_list|)
else|:
literal|1
operator|)
operator|+
name|s2
operator|)
operator|&
literal|0xf
operator|)
condition|)
name|i
operator|=
literal|16
operator|-
name|i
expr_stmt|;
end_if

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
name|i
operator|>
literal|4
condition|)
block|{
name|i
operator|-=
literal|4
expr_stmt|;
name|b2
operator|+=
name|i
expr_stmt|;
name|m2
operator|+=
name|i
expr_stmt|;
name|s2
operator|+=
name|i
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|<
literal|4
condition|)
block|{
name|i
operator|+=
literal|28
expr_stmt|;
name|b2
operator|+=
name|i
expr_stmt|;
name|m2
operator|+=
name|i
expr_stmt|;
name|s2
operator|+=
name|i
expr_stmt|;
block|}
end_if

begin_if
if|if
condition|(
name|b2
operator|>
literal|0
condition|)
name|b
operator|=
name|lshift
argument_list|(
name|b
argument_list|,
name|b2
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|s2
operator|>
literal|0
condition|)
name|S
operator|=
name|lshift
argument_list|(
name|S
argument_list|,
name|s2
argument_list|)
expr_stmt|;
end_if

begin_if
if|if
condition|(
name|k_check
condition|)
block|{
if|if
condition|(
name|cmp
argument_list|(
name|b
argument_list|,
name|S
argument_list|)
operator|<
literal|0
condition|)
block|{
name|k
operator|--
expr_stmt|;
name|b
operator|=
name|multadd
argument_list|(
name|b
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* we botched the k estimate */
if|if
condition|(
name|leftright
condition|)
name|mhi
operator|=
name|multadd
argument_list|(
name|mhi
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ilim
operator|=
name|ilim1
expr_stmt|;
block|}
block|}
end_if

begin_if
if|if
condition|(
name|ilim
operator|<=
literal|0
operator|&&
name|mode
operator|>
literal|2
condition|)
block|{
if|if
condition|(
name|ilim
operator|<
literal|0
operator|||
name|cmp
argument_list|(
name|b
argument_list|,
name|S
operator|=
name|multadd
argument_list|(
name|S
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<=
literal|0
condition|)
block|{
comment|/* no digits, fcvt style */
name|no_digits
label|:
name|k
operator|=
operator|-
literal|1
operator|-
name|ndigits
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
name|one_digit
label|:
operator|*
name|s
operator|++
operator|=
literal|'1'
expr_stmt|;
name|k
operator|++
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
end_if

begin_if
if|if
condition|(
name|leftright
condition|)
block|{
if|if
condition|(
name|m2
operator|>
literal|0
condition|)
name|mhi
operator|=
name|lshift
argument_list|(
name|mhi
argument_list|,
name|m2
argument_list|)
expr_stmt|;
comment|/* Compute mlo -- check for special case 		 * that d is a normalized power of 2. 		 */
name|mlo
operator|=
name|mhi
expr_stmt|;
if|if
condition|(
name|spec_case
condition|)
block|{
name|mhi
operator|=
name|Balloc
argument_list|(
name|mhi
operator|->
name|k
argument_list|)
expr_stmt|;
name|Bcopy
argument_list|(
name|mhi
argument_list|,
name|mlo
argument_list|)
expr_stmt|;
name|mhi
operator|=
name|lshift
argument_list|(
name|mhi
argument_list|,
name|Log2P
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
condition|;
name|i
operator|++
control|)
block|{
name|dig
operator|=
name|quorem
argument_list|(
name|b
argument_list|,
name|S
argument_list|)
operator|+
literal|'0'
expr_stmt|;
comment|/* Do we yet have the shortest decimal string 			 * that will round to d? 			 */
name|j
operator|=
name|cmp
argument_list|(
name|b
argument_list|,
name|mlo
argument_list|)
expr_stmt|;
name|delta
operator|=
name|diff
argument_list|(
name|S
argument_list|,
name|mhi
argument_list|)
expr_stmt|;
name|j1
operator|=
name|delta
operator|->
name|sign
condition|?
literal|1
else|:
name|cmp
argument_list|(
name|b
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|delta
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ROUND_BIASED
if|if
condition|(
name|j1
operator|==
literal|0
operator|&&
operator|!
name|mode
operator|&&
operator|!
operator|(
name|word1
argument_list|(
name|d
argument_list|)
operator|&
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|dig
operator|==
literal|'9'
condition|)
goto|goto
name|round_9_up
goto|;
if|if
condition|(
name|j
operator|>
literal|0
condition|)
name|dig
operator|++
expr_stmt|;
operator|*
name|s
operator|++
operator|=
name|dig
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
endif|#
directive|endif
if|if
condition|(
name|j
operator|<
literal|0
operator|||
operator|(
name|j
operator|==
literal|0
operator|&&
operator|!
name|mode
ifndef|#
directive|ifndef
name|ROUND_BIASED
operator|&&
operator|!
operator|(
name|word1
argument_list|(
name|d
argument_list|)
operator|&
literal|1
operator|)
endif|#
directive|endif
operator|)
condition|)
block|{
if|if
condition|(
name|j1
operator|>
literal|0
condition|)
block|{
name|b
operator|=
name|lshift
argument_list|(
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|j1
operator|=
name|cmp
argument_list|(
name|b
argument_list|,
name|S
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|j1
operator|>
literal|0
operator|||
operator|(
name|j1
operator|==
literal|0
operator|&&
name|dig
operator|&
literal|1
operator|)
operator|)
operator|&&
name|dig
operator|++
operator|==
literal|'9'
condition|)
goto|goto
name|round_9_up
goto|;
block|}
operator|*
name|s
operator|++
operator|=
name|dig
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
if|if
condition|(
name|j1
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|dig
operator|==
literal|'9'
condition|)
block|{
comment|/* possible if i == 1 */
name|round_9_up
label|:
operator|*
name|s
operator|++
operator|=
literal|'9'
expr_stmt|;
goto|goto
name|roundoff
goto|;
block|}
operator|*
name|s
operator|++
operator|=
name|dig
operator|+
literal|1
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
operator|*
name|s
operator|++
operator|=
name|dig
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|ilim
condition|)
break|break;
name|b
operator|=
name|multadd
argument_list|(
name|b
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mlo
operator|==
name|mhi
condition|)
name|mlo
operator|=
name|mhi
operator|=
name|multadd
argument_list|(
name|mhi
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|mlo
operator|=
name|multadd
argument_list|(
name|mlo
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mhi
operator|=
name|multadd
argument_list|(
name|mhi
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
for|for
control|(
name|i
operator|=
literal|1
init|;
condition|;
name|i
operator|++
control|)
block|{
operator|*
name|s
operator|++
operator|=
name|dig
operator|=
name|quorem
argument_list|(
name|b
argument_list|,
name|S
argument_list|)
operator|+
literal|'0'
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|ilim
condition|)
break|break;
name|b
operator|=
name|multadd
argument_list|(
name|b
argument_list|,
literal|10
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_if

begin_comment
comment|/* Round off last digit */
end_comment

begin_expr_stmt
name|b
operator|=
name|lshift
argument_list|(
name|b
argument_list|,
literal|1
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|j
operator|=
name|cmp
argument_list|(
name|b
argument_list|,
name|S
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|j
operator|>
literal|0
operator|||
operator|(
name|j
operator|==
literal|0
operator|&&
name|dig
operator|&
literal|1
operator|)
condition|)
block|{
name|roundoff
label|:
while|while
condition|(
operator|*
operator|--
name|s
operator|==
literal|'9'
condition|)
if|if
condition|(
name|s
operator|==
name|s0
condition|)
block|{
name|k
operator|++
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'1'
expr_stmt|;
goto|goto
name|ret
goto|;
block|}
operator|++
operator|*
name|s
operator|++
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|*
operator|--
name|s
operator|==
literal|'0'
condition|)
empty_stmt|;
name|s
operator|++
expr_stmt|;
block|}
end_if

begin_label
name|ret
label|:
end_label

begin_expr_stmt
name|Bfree
argument_list|(
name|S
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|mhi
condition|)
block|{
if|if
condition|(
name|mlo
operator|&&
name|mlo
operator|!=
name|mhi
condition|)
name|Bfree
argument_list|(
name|mlo
argument_list|)
expr_stmt|;
name|Bfree
argument_list|(
name|mhi
argument_list|)
expr_stmt|;
block|}
end_if

begin_label
name|ret1
label|:
end_label

begin_expr_stmt
name|Bfree
argument_list|(
name|b
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|s
operator|==
name|s0
condition|)
block|{
comment|/* don't return empty string */
operator|*
name|s
operator|++
operator|=
literal|'0'
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
block|}
end_if

begin_expr_stmt
operator|*
name|s
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|decpt
operator|=
name|k
operator|+
literal|1
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|rve
condition|)
operator|*
name|rve
operator|=
name|s
expr_stmt|;
end_if

begin_return
return|return
name|s0
return|;
end_return

begin_ifdef
unit|}
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_endif
unit|}
endif|#
directive|endif
end_endif

end_unit

