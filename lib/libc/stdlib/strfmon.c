begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2001 Alexey Zelkin<phantom@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_RCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* internal flags */
end_comment

begin_define
define|#
directive|define
name|NEED_GROUPING
value|0x01
end_define

begin_comment
comment|/* print digits grouped (default) */
end_comment

begin_define
define|#
directive|define
name|SIGN_POSN_USED
value|0x02
end_define

begin_comment
comment|/* '+' or '(' usage flag */
end_comment

begin_define
define|#
directive|define
name|LOCALE_POSN
value|0x04
end_define

begin_comment
comment|/* use locale defined +/- (default) */
end_comment

begin_define
define|#
directive|define
name|PARENTH_POSN
value|0x08
end_define

begin_comment
comment|/* enclose negative amount in () */
end_comment

begin_define
define|#
directive|define
name|SUPRESS_CURR_SYMBOL
value|0x10
end_define

begin_comment
comment|/* supress the currency from output */
end_comment

begin_define
define|#
directive|define
name|LEFT_JUSTIFY
value|0x20
end_define

begin_comment
comment|/* left justify */
end_comment

begin_define
define|#
directive|define
name|USE_INTL_CURRENCY
value|0x40
end_define

begin_comment
comment|/* use international currency symbol */
end_comment

begin_define
define|#
directive|define
name|IS_NEGATIVE
value|0x80
end_define

begin_comment
comment|/* is argument value negative ? */
end_comment

begin_comment
comment|/* internal macros */
end_comment

begin_define
define|#
directive|define
name|PRINT
parameter_list|(
name|CH
parameter_list|)
value|do {						\ 	if (dst>= s + maxsize) 				\ 		goto e2big_error;				\ 	*dst++ = CH;						\ } while (0)
end_define

begin_define
define|#
directive|define
name|PRINTS
parameter_list|(
name|STR
parameter_list|)
value|do {					\ 	char *tmps = STR;					\ 	while (*tmps != '\0')					\ 		PRINT(*tmps++);					\ } while (0)
end_define

begin_define
define|#
directive|define
name|GET_NUMBER
parameter_list|(
name|VAR
parameter_list|)
value|do {					\ 	VAR = 0;						\ 	while (isdigit((unsigned char)*fmt)) {			\ 		VAR *= 10;					\ 		VAR += *fmt - '0';				\ 		fmt++;						\ 	}							\ } while (0)
end_define

begin_define
define|#
directive|define
name|GRPCPY
parameter_list|(
name|howmany
parameter_list|)
value|do {					\ 	int i = howmany;					\ 	while (i--> 0) {					\ 		avalue_size--;					\ 		*--bufend = *(avalue+avalue_size+padded);	\ 	}							\ } while (0)
end_define

begin_define
define|#
directive|define
name|GRPSEP
value|do {						\ 	*--bufend = thousands_sep;				\ 	groups++;						\ } while (0)
end_define

begin_function_decl
specifier|static
name|void
name|__setup_vars
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|__calc_left_pad
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|__format_grouped_double
parameter_list|(
name|double
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
name|__STDC__
end_if

begin_function
name|ssize_t
name|strfmon
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|maxsize
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|ssize_t strfmon
parameter_list|(
name|s
parameter_list|,
name|maxsize
parameter_list|,
name|format
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|size_t
name|maxsize
decl_stmt|;
specifier|const
name|char
modifier|*
name|format
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
name|va_list
name|ap
decl_stmt|;
name|char
modifier|*
name|dst
decl_stmt|;
comment|/* output destination pointer */
specifier|const
name|char
modifier|*
name|fmt
decl_stmt|;
comment|/* current format poistion pointer */
name|struct
name|lconv
modifier|*
name|lc
decl_stmt|;
comment|/* pointer to lconv structure */
name|char
modifier|*
name|asciivalue
decl_stmt|;
comment|/* formatted double pointer */
name|int
name|flags
decl_stmt|;
comment|/* formatting options */
name|int
name|pad_char
decl_stmt|;
comment|/* padding character */
name|int
name|pad_size
decl_stmt|;
comment|/* pad size */
name|int
name|width
decl_stmt|;
comment|/* field width */
name|int
name|left_prec
decl_stmt|;
comment|/* left precision */
name|int
name|right_prec
decl_stmt|;
comment|/* right precision */
name|double
name|value
decl_stmt|;
comment|/* just value */
name|char
name|space_char
init|=
literal|' '
decl_stmt|;
comment|/* space after currency */
name|char
name|cs_precedes
decl_stmt|,
comment|/* values gathered from struct lconv */
name|sep_by_space
decl_stmt|,
name|sign_posn
decl_stmt|,
modifier|*
name|signstr
decl_stmt|,
modifier|*
name|currency_symbol
decl_stmt|;
name|char
modifier|*
name|tmpptr
decl_stmt|;
comment|/* temporary vars */
name|int
modifier|*
name|ntmp
decl_stmt|;
if|#
directive|if
name|__STDC__
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
else|#
directive|else
name|va_start
argument_list|(
name|ap
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|lc
operator|=
name|localeconv
argument_list|()
expr_stmt|;
name|dst
operator|=
name|s
expr_stmt|;
name|fmt
operator|=
name|format
expr_stmt|;
name|asciivalue
operator|=
name|NULL
expr_stmt|;
name|currency_symbol
operator|=
name|NULL
expr_stmt|;
name|pad_size
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|fmt
condition|)
block|{
comment|/* pass nonformating characters AS IS */
if|if
condition|(
operator|*
name|fmt
operator|!=
literal|'%'
condition|)
goto|goto
name|literal
goto|;
comment|/* '%' found ! */
comment|/* "%%" mean just '%' */
if|if
condition|(
operator|*
operator|(
name|fmt
operator|+
literal|1
operator|)
operator|==
literal|'%'
condition|)
block|{
name|fmt
operator|++
expr_stmt|;
name|literal
label|:
name|PRINT
argument_list|(
operator|*
name|fmt
operator|++
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* set up initial values */
name|flags
operator|=
operator|(
name|NEED_GROUPING
operator||
name|LOCALE_POSN
operator|)
expr_stmt|;
name|pad_char
operator|=
literal|' '
expr_stmt|;
comment|/* padding character is "space" */
name|left_prec
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* no left precision specified */
name|right_prec
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* no right precision specified */
name|width
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* no width specified */
name|value
operator|=
literal|0
expr_stmt|;
comment|/* we have no value to print now */
comment|/* Flags */
while|while
condition|(
literal|1
condition|)
block|{
switch|switch
condition|(
operator|*
operator|++
name|fmt
condition|)
block|{
case|case
literal|'='
case|:
comment|/* fill character */
name|pad_char
operator|=
operator|*
operator|++
name|fmt
expr_stmt|;
if|if
condition|(
name|pad_char
operator|==
literal|'\0'
condition|)
goto|goto
name|format_error
goto|;
continue|continue;
case|case
literal|'^'
case|:
comment|/* not group currency  */
name|flags
operator|&=
operator|~
operator|(
name|NEED_GROUPING
operator|)
expr_stmt|;
continue|continue;
case|case
literal|'+'
case|:
comment|/* use locale defined signs */
if|if
condition|(
name|flags
operator|&
name|SIGN_POSN_USED
condition|)
goto|goto
name|format_error
goto|;
name|flags
operator||=
operator|(
name|SIGN_POSN_USED
operator||
name|LOCALE_POSN
operator|)
expr_stmt|;
continue|continue;
case|case
literal|'('
case|:
comment|/* enclose negatives with () */
if|if
condition|(
name|flags
operator|&
name|SIGN_POSN_USED
condition|)
goto|goto
name|format_error
goto|;
name|flags
operator||=
operator|(
name|SIGN_POSN_USED
operator||
name|PARENTH_POSN
operator|)
expr_stmt|;
continue|continue;
case|case
literal|'!'
case|:
comment|/* suppress currency symbol */
name|flags
operator||=
name|SUPRESS_CURR_SYMBOL
expr_stmt|;
continue|continue;
case|case
literal|'-'
case|:
comment|/* alignment (left)  */
name|flags
operator||=
name|LEFT_JUSTIFY
expr_stmt|;
continue|continue;
case|case
literal|'#'
case|:
comment|/* left || right precision */
case|case
literal|'.'
case|:
if|if
condition|(
operator|*
name|fmt
operator|==
literal|'#'
condition|)
name|ntmp
operator|=
operator|&
name|left_prec
expr_stmt|;
else|else
name|ntmp
operator|=
operator|&
name|right_prec
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
operator|++
name|fmt
argument_list|)
condition|)
goto|goto
name|format_error
goto|;
name|GET_NUMBER
argument_list|(
operator|*
name|ntmp
argument_list|)
expr_stmt|;
name|fmt
operator|--
expr_stmt|;
continue|continue;
default|default:
break|break;
block|}
break|break;
block|}
comment|/* field Width */
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|fmt
argument_list|)
condition|)
block|{
name|GET_NUMBER
argument_list|(
name|width
argument_list|)
expr_stmt|;
comment|/* Do we have enough space to put number with 			 * required width ? 			 */
if|if
condition|(
name|dst
operator|+
name|width
operator|>=
name|s
operator|+
name|maxsize
condition|)
goto|goto
name|e2big_error
goto|;
block|}
comment|/* Conversion Characters */
switch|switch
condition|(
operator|*
name|fmt
operator|++
condition|)
block|{
case|case
literal|'i'
case|:
comment|/* use internaltion currency format */
name|flags
operator||=
name|USE_INTL_CURRENCY
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* use national currency format */
name|flags
operator|&=
operator|~
operator|(
name|USE_INTL_CURRENCY
operator|)
expr_stmt|;
break|break;
default|default:
comment|/* required character is missing or 					   premature EOS */
goto|goto
name|format_error
goto|;
block|}
if|if
condition|(
name|flags
operator|&
name|USE_INTL_CURRENCY
condition|)
block|{
name|currency_symbol
operator|=
name|strdup
argument_list|(
name|lc
operator|->
name|int_curr_symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|currency_symbol
operator|!=
name|NULL
condition|)
name|space_char
operator|=
operator|*
operator|(
name|currency_symbol
operator|+
literal|3
operator|)
expr_stmt|;
block|}
else|else
name|currency_symbol
operator|=
name|strdup
argument_list|(
name|lc
operator|->
name|currency_symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|currency_symbol
operator|==
name|NULL
condition|)
goto|goto
name|end_error
goto|;
comment|/* ENOMEM. */
comment|/* value itself */
name|value
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|double
argument_list|)
expr_stmt|;
comment|/* detect sign */
if|if
condition|(
name|value
operator|<
literal|0
condition|)
block|{
name|flags
operator||=
name|IS_NEGATIVE
expr_stmt|;
name|value
operator|=
operator|-
name|value
expr_stmt|;
block|}
comment|/* fill left_prec with amount of padding chars */
if|if
condition|(
name|left_prec
operator|>=
literal|0
condition|)
block|{
name|pad_size
operator|=
name|__calc_left_pad
argument_list|(
operator|(
name|flags
operator|^
name|IS_NEGATIVE
operator|)
argument_list|,
name|currency_symbol
argument_list|)
operator|-
name|__calc_left_pad
argument_list|(
name|flags
argument_list|,
name|currency_symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|pad_size
operator|<
literal|0
condition|)
name|pad_size
operator|=
literal|0
expr_stmt|;
block|}
name|asciivalue
operator|=
name|__format_grouped_double
argument_list|(
name|value
argument_list|,
operator|&
name|flags
argument_list|,
name|left_prec
argument_list|,
name|right_prec
argument_list|,
name|pad_char
argument_list|)
expr_stmt|;
if|if
condition|(
name|asciivalue
operator|==
name|NULL
condition|)
goto|goto
name|end_error
goto|;
comment|/* errno already set     */
comment|/* to ENOMEM by malloc() */
comment|/* set some variables for later use */
name|__setup_vars
argument_list|(
name|flags
argument_list|,
operator|&
name|cs_precedes
argument_list|,
operator|&
name|sep_by_space
argument_list|,
operator|&
name|sign_posn
argument_list|,
operator|&
name|signstr
argument_list|)
expr_stmt|;
comment|/* 		 * Description of some LC_MONETARY's values: 		 * 		 * p_cs_precedes& n_cs_precedes 		 * 		 * = 1 - $currency_symbol precedes the value 		 *       for a monetary quantity with a non-negative value 		 * = 0 - symbol succeeds the value 		 * 		 * p_sep_by_space& n_sep_by_space                  * 		 * = 0 - no space separates $currency_symbol 		 *       from the value for a monetary quantity with a 		 *	 non-negative value 		 * = 1 - space separates the symbol from the value 		 * = 2 - space separates the symbol and the sign string, 		 *       if adjacent.                  * 		 * p_sign_posn& n_sign_posn                  * 		 * = 0 - parentheses enclose the quantity and the 		 *	 $currency_symbol 		 * = 1 - the sign string precedes the quantity and the  		 *       $currency_symbol 		 * = 2 - the sign string succeeds the quantity and the  		 *       $currency_symbol 		 * = 3 - the sign string precedes the $currency_symbol 		 * = 4 - the sign string succeeds the $currency_symbol                  * 		 */
name|tmpptr
operator|=
name|dst
expr_stmt|;
while|while
condition|(
name|pad_size
operator|--
operator|>
literal|0
condition|)
name|PRINT
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|sign_posn
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|IS_NEGATIVE
condition|)
name|PRINT
argument_list|(
literal|'('
argument_list|)
expr_stmt|;
else|else
name|PRINT
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cs_precedes
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|sign_posn
operator|==
literal|1
operator|||
name|sign_posn
operator|==
literal|3
condition|)
block|{
name|PRINTS
argument_list|(
name|signstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep_by_space
operator|==
literal|2
condition|)
comment|/* XXX: ? */
name|PRINT
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SUPRESS_CURR_SYMBOL
operator|)
condition|)
block|{
name|PRINTS
argument_list|(
name|currency_symbol
argument_list|)
expr_stmt|;
if|if
condition|(
name|sign_posn
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|sep_by_space
operator|==
literal|2
condition|)
name|PRINT
argument_list|(
name|space_char
argument_list|)
expr_stmt|;
name|PRINTS
argument_list|(
name|signstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep_by_space
operator|==
literal|1
condition|)
name|PRINT
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sep_by_space
operator|==
literal|1
condition|)
name|PRINT
argument_list|(
name|space_char
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sign_posn
operator|==
literal|1
condition|)
name|PRINTS
argument_list|(
name|signstr
argument_list|)
expr_stmt|;
name|PRINTS
argument_list|(
name|asciivalue
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs_precedes
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|sign_posn
operator|==
literal|3
condition|)
block|{
if|if
condition|(
name|sep_by_space
operator|==
literal|1
condition|)
name|PRINT
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|PRINTS
argument_list|(
name|signstr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|SUPRESS_CURR_SYMBOL
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|sign_posn
operator|==
literal|3
operator|&&
name|sep_by_space
operator|==
literal|2
operator|)
operator|||
operator|(
name|sep_by_space
operator|==
literal|1
operator|&&
operator|(
name|sign_posn
operator|=
literal|0
operator|||
name|sign_posn
operator|==
literal|1
operator|||
name|sign_posn
operator|==
literal|2
operator|||
name|sign_posn
operator|==
literal|4
operator|)
operator|)
condition|)
name|PRINT
argument_list|(
name|space_char
argument_list|)
expr_stmt|;
name|PRINTS
argument_list|(
name|currency_symbol
argument_list|)
expr_stmt|;
comment|/* XXX: len */
if|if
condition|(
name|sign_posn
operator|==
literal|4
condition|)
block|{
if|if
condition|(
name|sep_by_space
operator|==
literal|2
condition|)
name|PRINT
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|PRINTS
argument_list|(
name|signstr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|sign_posn
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|sep_by_space
operator|==
literal|2
condition|)
name|PRINT
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|PRINTS
argument_list|(
name|signstr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sign_posn
operator|==
literal|0
operator|&&
operator|(
name|flags
operator|&
name|IS_NEGATIVE
operator|)
condition|)
name|PRINT
argument_list|(
literal|')'
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|-
name|tmpptr
operator|<
name|width
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|LEFT_JUSTIFY
condition|)
block|{
while|while
condition|(
name|dst
operator|-
name|tmpptr
operator|<=
name|width
condition|)
name|PRINT
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pad_size
operator|=
name|dst
operator|-
name|tmpptr
expr_stmt|;
name|memmove
argument_list|(
name|tmpptr
operator|+
name|width
operator|-
name|pad_size
argument_list|,
name|tmpptr
argument_list|,
name|pad_size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tmpptr
argument_list|,
literal|' '
argument_list|,
name|width
operator|-
name|pad_size
argument_list|)
expr_stmt|;
name|dst
operator|+=
name|width
operator|-
name|pad_size
expr_stmt|;
block|}
block|}
block|}
name|PRINT
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
name|dst
operator|-
name|s
operator|-
literal|1
operator|)
return|;
comment|/* return size of put data except trailing '\0' */
name|e2big_error
label|:
name|errno
operator|=
name|E2BIG
expr_stmt|;
goto|goto
name|end_error
goto|;
name|format_error
label|:
name|errno
operator|=
name|EINVAL
expr_stmt|;
name|end_error
label|:
if|if
condition|(
name|asciivalue
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|asciivalue
argument_list|)
expr_stmt|;
if|if
condition|(
name|currency_symbol
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|currency_symbol
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|__setup_vars
parameter_list|(
name|int
name|flags
parameter_list|,
name|char
modifier|*
name|cs_precedes
parameter_list|,
name|char
modifier|*
name|sep_by_space
parameter_list|,
name|char
modifier|*
name|sign_posn
parameter_list|,
name|char
modifier|*
modifier|*
name|signstr
parameter_list|)
block|{
name|struct
name|lconv
modifier|*
name|lc
init|=
name|localeconv
argument_list|()
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|IS_NEGATIVE
condition|)
block|{
operator|*
name|cs_precedes
operator|=
name|lc
operator|->
name|n_cs_precedes
expr_stmt|;
operator|*
name|sep_by_space
operator|=
name|lc
operator|->
name|n_sep_by_space
expr_stmt|;
operator|*
name|sign_posn
operator|=
operator|(
name|flags
operator|&
name|PARENTH_POSN
operator|)
condition|?
literal|0
else|:
name|lc
operator|->
name|n_sign_posn
expr_stmt|;
operator|*
name|signstr
operator|=
operator|(
name|lc
operator|->
name|negative_sign
operator|==
literal|'\0'
operator|)
condition|?
literal|"-"
else|:
name|lc
operator|->
name|negative_sign
expr_stmt|;
block|}
else|else
block|{
operator|*
name|cs_precedes
operator|=
name|lc
operator|->
name|p_cs_precedes
expr_stmt|;
operator|*
name|sep_by_space
operator|=
name|lc
operator|->
name|p_sep_by_space
expr_stmt|;
operator|*
name|sign_posn
operator|=
operator|(
name|flags
operator|&
name|PARENTH_POSN
operator|)
condition|?
literal|0
else|:
name|lc
operator|->
name|p_sign_posn
expr_stmt|;
operator|*
name|signstr
operator|=
name|lc
operator|->
name|positive_sign
expr_stmt|;
block|}
comment|/* Set defult values for unspecified information. */
if|if
condition|(
operator|*
name|cs_precedes
operator|!=
literal|0
condition|)
operator|*
name|cs_precedes
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|sep_by_space
operator|==
name|CHAR_MAX
condition|)
operator|*
name|sep_by_space
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|sign_posn
operator|==
name|CHAR_MAX
condition|)
operator|*
name|sign_posn
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|__calc_left_pad
parameter_list|(
name|int
name|flags
parameter_list|,
name|char
modifier|*
name|cur_symb
parameter_list|)
block|{
name|char
name|cs_precedes
decl_stmt|,
name|sep_by_space
decl_stmt|,
name|sign_posn
decl_stmt|,
modifier|*
name|signstr
decl_stmt|;
name|int
name|left_chars
init|=
literal|0
decl_stmt|;
name|__setup_vars
argument_list|(
name|flags
argument_list|,
operator|&
name|cs_precedes
argument_list|,
operator|&
name|sep_by_space
argument_list|,
operator|&
name|sign_posn
argument_list|,
operator|&
name|signstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|cs_precedes
operator|!=
literal|0
condition|)
block|{
name|left_chars
operator|+=
name|strlen
argument_list|(
name|cur_symb
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep_by_space
operator|!=
literal|0
condition|)
name|left_chars
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|sign_posn
condition|)
block|{
case|case
literal|1
case|:
name|left_chars
operator|+=
name|strlen
argument_list|(
name|signstr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
case|case
literal|4
case|:
if|if
condition|(
name|cs_precedes
operator|!=
literal|0
condition|)
name|left_chars
operator|+=
name|strlen
argument_list|(
name|signstr
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|left_chars
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_groups
parameter_list|(
name|int
name|size
parameter_list|,
name|char
modifier|*
name|grouping
parameter_list|)
block|{
name|int
name|chars
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|grouping
operator|==
name|CHAR_MAX
operator|||
operator|*
name|grouping
operator|<=
literal|0
condition|)
comment|/* no grouping ? */
return|return
operator|(
literal|0
operator|)
return|;
while|while
condition|(
name|size
operator|>
operator|(
name|int
operator|)
operator|*
name|grouping
condition|)
block|{
name|chars
operator|++
expr_stmt|;
name|size
operator|-=
operator|(
name|int
operator|)
operator|*
name|grouping
operator|++
expr_stmt|;
comment|/* no more grouping ? */
if|if
condition|(
operator|*
name|grouping
operator|==
name|CHAR_MAX
condition|)
break|break;
comment|/* rest grouping with same value ? */
if|if
condition|(
operator|*
name|grouping
operator|==
literal|0
condition|)
block|{
name|chars
operator|+=
operator|(
name|size
operator|-
literal|1
operator|)
operator|/
operator|*
operator|(
name|grouping
operator|-
literal|1
operator|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|chars
operator|)
return|;
block|}
end_function

begin_comment
comment|/* convert double to ASCII */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|__format_grouped_double
parameter_list|(
name|double
name|value
parameter_list|,
name|int
modifier|*
name|flags
parameter_list|,
name|int
name|left_prec
parameter_list|,
name|int
name|right_prec
parameter_list|,
name|int
name|pad_char
parameter_list|)
block|{
name|char
modifier|*
name|rslt
decl_stmt|;
name|char
modifier|*
name|avalue
decl_stmt|;
name|int
name|avalue_size
decl_stmt|;
name|char
name|fmt
index|[
literal|32
index|]
decl_stmt|;
name|size_t
name|bufsize
decl_stmt|;
name|char
modifier|*
name|bufend
decl_stmt|;
name|int
name|padded
decl_stmt|;
name|struct
name|lconv
modifier|*
name|lc
init|=
name|localeconv
argument_list|()
decl_stmt|;
name|char
modifier|*
name|grouping
decl_stmt|;
name|char
name|decimal_point
decl_stmt|;
name|char
name|thousands_sep
decl_stmt|;
name|int
name|groups
init|=
literal|0
decl_stmt|;
name|grouping
operator|=
name|lc
operator|->
name|mon_grouping
expr_stmt|;
name|decimal_point
operator|=
operator|*
name|lc
operator|->
name|mon_decimal_point
expr_stmt|;
if|if
condition|(
name|decimal_point
operator|==
literal|'\0'
condition|)
block|{
name|decimal_point
operator|=
operator|*
name|lc
operator|->
name|decimal_point
expr_stmt|;
if|if
condition|(
name|decimal_point
operator|==
literal|'\0'
condition|)
name|decimal_point
operator|=
literal|'.'
expr_stmt|;
block|}
name|thousands_sep
operator|=
operator|*
name|lc
operator|->
name|mon_thousands_sep
expr_stmt|;
if|if
condition|(
name|thousands_sep
operator|==
literal|'\0'
condition|)
name|thousands_sep
operator|=
operator|*
name|lc
operator|->
name|thousands_sep
expr_stmt|;
comment|/* fill left_prec with default value */
if|if
condition|(
name|left_prec
operator|==
operator|-
literal|1
condition|)
name|left_prec
operator|=
literal|0
expr_stmt|;
comment|/* fill right_prec with default value */
if|if
condition|(
name|right_prec
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|flags
operator|&
name|USE_INTL_CURRENCY
condition|)
name|right_prec
operator|=
name|lc
operator|->
name|int_frac_digits
expr_stmt|;
else|else
name|right_prec
operator|=
name|lc
operator|->
name|frac_digits
expr_stmt|;
if|if
condition|(
name|right_prec
operator|==
name|CHAR_MAX
condition|)
comment|/* POSIX locale ? */
name|right_prec
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|flags
operator|&
name|NEED_GROUPING
condition|)
name|left_prec
operator|+=
name|get_groups
argument_list|(
name|left_prec
argument_list|,
name|grouping
argument_list|)
expr_stmt|;
comment|/* convert to string */
name|snprintf
argument_list|(
name|fmt
argument_list|,
sizeof|sizeof
argument_list|(
name|fmt
argument_list|)
argument_list|,
literal|"%%%d.%df"
argument_list|,
name|left_prec
operator|+
name|right_prec
operator|+
literal|1
argument_list|,
name|right_prec
argument_list|)
expr_stmt|;
name|avalue_size
operator|=
name|asprintf
argument_list|(
operator|&
name|avalue
argument_list|,
name|fmt
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|avalue_size
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* make sure that we've enough space for result string */
name|bufsize
operator|=
name|strlen
argument_list|(
name|avalue
argument_list|)
operator|*
literal|2
operator|+
literal|1
expr_stmt|;
name|rslt
operator|=
name|malloc
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|rslt
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|avalue
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|memset
argument_list|(
name|rslt
argument_list|,
literal|0
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|bufend
operator|=
name|rslt
operator|+
name|bufsize
operator|-
literal|1
expr_stmt|;
comment|/* reserve space for trailing '\0' */
comment|/* skip spaces at beggining */
name|padded
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|avalue
index|[
name|padded
index|]
operator|==
literal|' '
condition|)
block|{
name|padded
operator|++
expr_stmt|;
name|avalue_size
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|right_prec
operator|>
literal|0
condition|)
block|{
name|bufend
operator|-=
name|right_prec
expr_stmt|;
name|memcpy
argument_list|(
name|bufend
argument_list|,
name|avalue
operator|+
name|avalue_size
operator|+
name|padded
operator|-
name|right_prec
argument_list|,
name|right_prec
argument_list|)
expr_stmt|;
operator|*
operator|--
name|bufend
operator|=
name|decimal_point
expr_stmt|;
name|avalue_size
operator|-=
operator|(
name|right_prec
operator|+
literal|1
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|*
name|flags
operator|&
name|NEED_GROUPING
operator|)
operator|&&
name|thousands_sep
operator|!=
literal|'\0'
operator|&&
comment|/* XXX: need investigation */
operator|*
name|grouping
operator|!=
name|CHAR_MAX
operator|&&
operator|*
name|grouping
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|avalue_size
operator|>
operator|(
name|int
operator|)
operator|*
name|grouping
condition|)
block|{
name|GRPCPY
argument_list|(
operator|*
name|grouping
argument_list|)
expr_stmt|;
name|GRPSEP
expr_stmt|;
name|grouping
operator|++
expr_stmt|;
comment|/* no more grouping ? */
if|if
condition|(
operator|*
name|grouping
operator|==
name|CHAR_MAX
condition|)
break|break;
comment|/* rest grouping with same value ? */
if|if
condition|(
operator|*
name|grouping
operator|==
literal|0
condition|)
block|{
name|grouping
operator|--
expr_stmt|;
while|while
condition|(
name|avalue_size
operator|>
operator|*
name|grouping
condition|)
block|{
name|GRPCPY
argument_list|(
operator|*
name|grouping
argument_list|)
expr_stmt|;
name|GRPSEP
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|avalue_size
operator|!=
literal|0
condition|)
name|GRPCPY
argument_list|(
name|avalue_size
argument_list|)
expr_stmt|;
name|padded
operator|-=
name|groups
expr_stmt|;
block|}
else|else
block|{
name|bufend
operator|-=
name|avalue_size
expr_stmt|;
name|memcpy
argument_list|(
name|bufend
argument_list|,
name|avalue
operator|+
name|padded
argument_list|,
name|avalue_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|right_prec
operator|==
literal|0
condition|)
name|padded
operator|--
expr_stmt|;
comment|/* decrease assumed $decimal_point */
block|}
comment|/* do padding with pad_char */
if|if
condition|(
name|padded
operator|>
literal|0
condition|)
block|{
name|bufend
operator|-=
name|padded
expr_stmt|;
name|memset
argument_list|(
name|bufend
argument_list|,
name|pad_char
argument_list|,
name|padded
argument_list|)
expr_stmt|;
block|}
name|bufsize
operator|=
name|bufsize
operator|-
operator|(
name|rslt
operator|-
name|bufend
operator|)
expr_stmt|;
name|memmove
argument_list|(
name|rslt
argument_list|,
name|bufend
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|avalue
argument_list|)
expr_stmt|;
return|return
operator|(
name|rslt
operator|)
return|;
block|}
end_function

end_unit

