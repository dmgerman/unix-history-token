begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (C) 2006 Jason Evans<jasone@FreeBSD.org>.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice(s), this list of conditions and the following disclaimer as  *    the first lines of this file unmodified other than the possible  *    addition of one or more copyright notices.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice(s), this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE  * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *******************************************************************************  *  * This allocator implementation is designed to provide scalable performance  * for multi-threaded programs on multi-processor systems.  The following  * features are included for this purpose:  *  *   + Multiple arenas are used if there are multiple CPUs, which reduces lock  *     contention and cache sloshing.  *  *   + Cache line sharing between arenas is avoided for internal data  *     structures.  *  *   + Memory is managed in chunks and runs (chunks can be split into runs using  *     a binary buddy scheme), rather than as individual pages.  This provides  *     a constant-time mechanism for associating allocations with particular  *     arenas.  *  * Allocation requests are rounded up to the nearest size class, and no record  * of the original request size is maintained.  Allocations are broken into  * categories according to size class.  Assuming runtime defaults, 4 kB pages  * and a 16 byte quantum, the size classes in each category are as follows:  *  *   |====================================|  *   | Category | Subcategory    |   Size |  *   |====================================|  *   | Small    | Tiny           |      2 |  *   |          |                |      4 |  *   |          |                |      8 |  *   |          |----------------+--------|  *   |          | Quantum-spaced |     16 |  *   |          |                |     32 |  *   |          |                |     48 |  *   |          |                |    ... |  *   |          |                |    480 |  *   |          |                |    496 |  *   |          |                |    512 |  *   |          |----------------+--------|  *   |          | Sub-page       |   1 kB |  *   |          |                |   2 kB |  *   |====================================|  *   | Large                     |   4 kB |  *   |                           |   8 kB |  *   |                           |  16 kB |  *   |                           |    ... |  *   |                           | 256 kB |  *   |                           | 512 kB |  *   |====================================|  *   | Huge                      |   1 MB |  *   |                           |   2 MB |  *   |                           |   3 MB |  *   |                           |    ... |  *   |====================================|  *  * A different mechanism is used for each category:  *  *   Small : Each size class is segregated into its own set of runs.  Each run  *           maintains a bitmap of which regions are free/allocated.  *  *   Large : Each allocation is backed by a dedicated run.  Metadata are stored  *           in the associated arena chunk header maps.  *  *   Huge : Each allocation is backed by a dedicated contiguous set of chunks.  *          Metadata are stored in a separate red-black tree.  *  *******************************************************************************  */
end_comment

begin_comment
comment|/*  *******************************************************************************  *  * Ring macros.  *  *******************************************************************************  */
end_comment

begin_comment
comment|/* Ring definitions. */
end_comment

begin_define
define|#
directive|define
name|qr
parameter_list|(
name|a_type
parameter_list|)
value|struct {						\ 	a_type *qre_next;						\ 	a_type *qre_prev;						\ }
end_define

begin_define
define|#
directive|define
name|qr_initializer
value|{NULL, NULL}
end_define

begin_comment
comment|/* Ring functions. */
end_comment

begin_define
define|#
directive|define
name|qr_new
parameter_list|(
name|a_qr
parameter_list|,
name|a_field
parameter_list|)
value|do {					\ 	(a_qr)->a_field.qre_next = (a_qr);				\ 	(a_qr)->a_field.qre_prev = (a_qr);				\ } while (0)
end_define

begin_define
define|#
directive|define
name|qr_next
parameter_list|(
name|a_qr
parameter_list|,
name|a_field
parameter_list|)
value|((a_qr)->a_field.qre_next)
end_define

begin_define
define|#
directive|define
name|qr_prev
parameter_list|(
name|a_qr
parameter_list|,
name|a_field
parameter_list|)
value|((a_qr)->a_field.qre_prev)
end_define

begin_define
define|#
directive|define
name|qr_before_insert
parameter_list|(
name|a_qrelm
parameter_list|,
name|a_qr
parameter_list|,
name|a_field
parameter_list|)
value|do {			\ 	(a_qr)->a_field.qre_prev = (a_qrelm)->a_field.qre_prev;		\ 	(a_qr)->a_field.qre_next = (a_qrelm);				\ 	(a_qr)->a_field.qre_prev->a_field.qre_next = (a_qr);		\ 	(a_qrelm)->a_field.qre_prev = (a_qr);				\ } while (0)
end_define

begin_define
define|#
directive|define
name|qr_after_insert
parameter_list|(
name|a_qrelm
parameter_list|,
name|a_qr
parameter_list|,
name|a_field
parameter_list|)
value|do {			\ 	(a_qr)->a_field.qre_next = (a_qrelm)->a_field.qre_next;		\ 	(a_qr)->a_field.qre_prev = (a_qrelm);				\ 	(a_qr)->a_field.qre_next->a_field.qre_prev = (a_qr);		\ 	(a_qrelm)->a_field.qre_next = (a_qr);				\ } while (0)
end_define

begin_define
define|#
directive|define
name|qr_meld
parameter_list|(
name|a_qr_a
parameter_list|,
name|a_qr_b
parameter_list|,
name|a_type
parameter_list|,
name|a_field
parameter_list|)
value|do {			\ 	a_type *t;							\ 	(a_qr_a)->a_field.qre_prev->a_field.qre_next = (a_qr_b);	\ 	(a_qr_b)->a_field.qre_prev->a_field.qre_next = (a_qr_a);	\ 	t = (a_qr_a)->a_field.qre_prev;					\ 	(a_qr_a)->a_field.qre_prev = (a_qr_b)->a_field.qre_prev;	\ 	(a_qr_b)->a_field.qre_prev = t;					\ } while (0)
end_define

begin_comment
comment|/*  * qr_meld() and qr_split() are functionally equivalent, so there's no need to  * have two copies of the code.  */
end_comment

begin_define
define|#
directive|define
name|qr_split
parameter_list|(
name|a_qr_a
parameter_list|,
name|a_qr_b
parameter_list|,
name|a_type
parameter_list|,
name|a_field
parameter_list|)
define|\
value|qr_meld((a_qr_a), (a_qr_b), a_type, a_field)
end_define

begin_define
define|#
directive|define
name|qr_remove
parameter_list|(
name|a_qr
parameter_list|,
name|a_field
parameter_list|)
value|do {					\ 	(a_qr)->a_field.qre_prev->a_field.qre_next			\ 	    = (a_qr)->a_field.qre_next;					\ 	(a_qr)->a_field.qre_next->a_field.qre_prev			\ 	    = (a_qr)->a_field.qre_prev;					\ 	(a_qr)->a_field.qre_next = (a_qr);				\ 	(a_qr)->a_field.qre_prev = (a_qr);				\ } while (0)
end_define

begin_define
define|#
directive|define
name|qr_foreach
parameter_list|(
name|var
parameter_list|,
name|a_qr
parameter_list|,
name|a_field
parameter_list|)
define|\
value|for ((var) = (a_qr);						\ 	    (var) != NULL;						\ 	    (var) = (((var)->a_field.qre_next != (a_qr))		\ 	    ? (var)->a_field.qre_next : NULL))
end_define

begin_define
define|#
directive|define
name|qr_reverse_foreach
parameter_list|(
name|var
parameter_list|,
name|a_qr
parameter_list|,
name|a_field
parameter_list|)
define|\
value|for ((var) = ((a_qr) != NULL) ? qr_prev(a_qr, a_field) : NULL;	\ 	    (var) != NULL;						\ 	    (var) = (((var) != (a_qr))					\ 	    ? (var)->a_field.qre_prev : NULL))
end_define

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * MALLOC_PRODUCTION disables assertions and statistics gathering.  It also  * defaults the A and J runtime options to off.  These settings are appropriate  * for production systems.  */
end_comment

begin_comment
comment|/* #define MALLOC_PRODUCTION */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MALLOC_PRODUCTION
end_ifndef

begin_define
define|#
directive|define
name|MALLOC_DEBUG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"libc_private.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|_LOCK_DEBUG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"spinlock.h"
end_include

begin_include
include|#
directive|include
file|"namespace.h"
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/tree.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktrace.h>
end_include

begin_comment
comment|/* Must come after several other sys/ includes. */
end_comment

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|<sched.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"un-namespace.h"
end_include

begin_comment
comment|/* MALLOC_STATS enables statistics calculation. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MALLOC_PRODUCTION
end_ifndef

begin_define
define|#
directive|define
name|MALLOC_STATS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MALLOC_DEBUG
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|NDEBUG
end_ifndef

begin_define
define|#
directive|define
name|NDEBUG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
end_ifdef

begin_comment
comment|/* Disable inlining to make debugging easier. */
end_comment

begin_define
define|#
directive|define
name|inline
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Size of stack-allocated buffer passed to strerror_r(). */
end_comment

begin_define
define|#
directive|define
name|STRERROR_BUF
value|64
end_define

begin_comment
comment|/* Minimum alignment of allocations is 2^QUANTUM_2POW_MIN bytes. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__i386__
end_ifdef

begin_define
define|#
directive|define
name|QUANTUM_2POW_MIN
value|4
end_define

begin_define
define|#
directive|define
name|SIZEOF_PTR_2POW
value|2
end_define

begin_define
define|#
directive|define
name|USE_BRK
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__ia64__
end_ifdef

begin_define
define|#
directive|define
name|QUANTUM_2POW_MIN
value|4
end_define

begin_define
define|#
directive|define
name|SIZEOF_PTR_2POW
value|3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__alpha__
end_ifdef

begin_define
define|#
directive|define
name|QUANTUM_2POW_MIN
value|4
end_define

begin_define
define|#
directive|define
name|SIZEOF_PTR_2POW
value|3
end_define

begin_define
define|#
directive|define
name|NO_TLS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__sparc64__
end_ifdef

begin_define
define|#
directive|define
name|QUANTUM_2POW_MIN
value|4
end_define

begin_define
define|#
directive|define
name|SIZEOF_PTR_2POW
value|3
end_define

begin_define
define|#
directive|define
name|NO_TLS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__amd64__
end_ifdef

begin_define
define|#
directive|define
name|QUANTUM_2POW_MIN
value|4
end_define

begin_define
define|#
directive|define
name|SIZEOF_PTR_2POW
value|3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__arm__
end_ifdef

begin_define
define|#
directive|define
name|QUANTUM_2POW_MIN
value|3
end_define

begin_define
define|#
directive|define
name|SIZEOF_PTR_2POW
value|2
end_define

begin_define
define|#
directive|define
name|USE_BRK
end_define

begin_define
define|#
directive|define
name|NO_TLS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__powerpc__
end_ifdef

begin_define
define|#
directive|define
name|QUANTUM_2POW_MIN
value|4
end_define

begin_define
define|#
directive|define
name|SIZEOF_PTR_2POW
value|2
end_define

begin_define
define|#
directive|define
name|USE_BRK
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SIZEOF_PTR
value|(1<< SIZEOF_PTR_2POW)
end_define

begin_comment
comment|/* sizeof(int) == (1<< SIZEOF_INT_2POW). */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIZEOF_INT_2POW
end_ifndef

begin_define
define|#
directive|define
name|SIZEOF_INT_2POW
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We can't use TLS in non-PIC programs, since TLS relies on loader magic. */
end_comment

begin_if
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|PIC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NO_TLS
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|NO_TLS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Size and alignment of memory chunks that are allocated by the OS's virtual  * memory system.  */
end_comment

begin_define
define|#
directive|define
name|CHUNK_2POW_DEFAULT
value|20
end_define

begin_comment
comment|/*  * Maximum size of L1 cache line.  This is used to avoid cache line aliasing,  * so over-estimates are okay (up to a point), but under-estimates will  * negatively affect performance.  */
end_comment

begin_define
define|#
directive|define
name|CACHELINE_2POW
value|6
end_define

begin_define
define|#
directive|define
name|CACHELINE
value|((size_t)(1<< CACHELINE_2POW))
end_define

begin_comment
comment|/* Smallest size class to support. */
end_comment

begin_define
define|#
directive|define
name|TINY_MIN_2POW
value|1
end_define

begin_comment
comment|/*  * Maximum size class that is a multiple of the quantum, but not (necessarily)  * a power of 2.  Above this size, allocations are rounded up to the nearest  * power of 2.  */
end_comment

begin_define
define|#
directive|define
name|SMALL_MAX_2POW_DEFAULT
value|9
end_define

begin_define
define|#
directive|define
name|SMALL_MAX_DEFAULT
value|(1<< SMALL_MAX_2POW_DEFAULT)
end_define

begin_comment
comment|/*  * Maximum desired run header overhead.  Runs are sized as small as possible  * such that this setting is still honored, without violating other constraints.  * The goal is to make runs as small as possible without exceeding a per run  * external fragmentation threshold.  *  * Note that it is possible to set this low enough that it cannot be honored  * for some/all object sizes, since there is one bit of header overhead per  * object (plus a constant).  In such cases, this constraint is relaxed.  *  * RUN_MAX_OVRHD_RELAX specifies the maximum number of bits per region of  * overhead for which RUN_MAX_OVRHD is relaxed.  */
end_comment

begin_define
define|#
directive|define
name|RUN_MAX_OVRHD
value|0.015
end_define

begin_define
define|#
directive|define
name|RUN_MAX_OVRHD_RELAX
value|1.5
end_define

begin_comment
comment|/* Put a cap on small object run size.  This overrides RUN_MAX_OVRHD. */
end_comment

begin_define
define|#
directive|define
name|RUN_MAX_SMALL_2POW
value|16
end_define

begin_define
define|#
directive|define
name|RUN_MAX_SMALL
value|(1<< RUN_MAX_SMALL_2POW)
end_define

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Mutexes based on spinlocks.  We can't use normal pthread mutexes, because  * they require malloc()ed memory.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|spinlock_t
name|lock
decl_stmt|;
block|}
name|malloc_mutex_t
typedef|;
end_typedef

begin_comment
comment|/* Set to true once the allocator has been initialized. */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|malloc_initialized
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to avoid initialization races. */
end_comment

begin_decl_stmt
specifier|static
name|malloc_mutex_t
name|init_lock
init|=
block|{
name|_SPINLOCK_INITIALIZER
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Statistics data structures.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_STATS
end_ifdef

begin_typedef
typedef|typedef
name|struct
name|malloc_bin_stats_s
name|malloc_bin_stats_t
typedef|;
end_typedef

begin_struct
struct|struct
name|malloc_bin_stats_s
block|{
comment|/* 	 * Number of allocation requests that corresponded to the size of this 	 * bin. 	 */
name|uint64_t
name|nrequests
decl_stmt|;
comment|/* Total number of runs created for this bin's size class. */
name|uint64_t
name|nruns
decl_stmt|;
comment|/* 	 * Total number of run promotions/demotions for this bin's size class. 	 */
name|uint64_t
name|npromote
decl_stmt|;
name|uint64_t
name|ndemote
decl_stmt|;
comment|/* High-water mark for this bin. */
name|unsigned
name|long
name|highruns
decl_stmt|;
comment|/* Current number of runs in this bin. */
name|unsigned
name|long
name|curruns
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|arena_stats_s
name|arena_stats_t
typedef|;
end_typedef

begin_struct
struct|struct
name|arena_stats_s
block|{
comment|/* Number of bytes currently mapped. */
name|size_t
name|mapped
decl_stmt|;
comment|/* Per-size-category statistics. */
name|size_t
name|allocated_small
decl_stmt|;
name|uint64_t
name|nmalloc_small
decl_stmt|;
name|uint64_t
name|ndalloc_small
decl_stmt|;
name|size_t
name|allocated_large
decl_stmt|;
name|uint64_t
name|nmalloc_large
decl_stmt|;
name|uint64_t
name|ndalloc_large
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|chunk_stats_s
name|chunk_stats_t
typedef|;
end_typedef

begin_struct
struct|struct
name|chunk_stats_s
block|{
comment|/* Number of chunks that were allocated. */
name|uint64_t
name|nchunks
decl_stmt|;
comment|/* High-water mark for number of chunks allocated. */
name|unsigned
name|long
name|highchunks
decl_stmt|;
comment|/* 	 * Current number of chunks allocated.  This value isn't maintained for 	 * any other purpose, so keep track of it in order to be able to set 	 * highchunks. 	 */
name|unsigned
name|long
name|curchunks
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* #ifdef MALLOC_STATS */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Chunk data structures.  */
end_comment

begin_comment
comment|/* Tree of chunks. */
end_comment

begin_typedef
typedef|typedef
name|struct
name|chunk_node_s
name|chunk_node_t
typedef|;
end_typedef

begin_struct
struct|struct
name|chunk_node_s
block|{
comment|/* Linkage for the chunk tree. */
name|RB_ENTRY
argument_list|(
argument|chunk_node_s
argument_list|)
name|link
expr_stmt|;
comment|/* 	 * Pointer to the chunk that this tree node is responsible for.  In some 	 * (but certainly not all) cases, this data structure is placed at the 	 * beginning of the corresponding chunk, so this field may point to this 	 * node. 	 */
name|void
modifier|*
name|chunk
decl_stmt|;
comment|/* Total chunk size. */
name|size_t
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|chunk_tree_s
name|chunk_tree_t
typedef|;
end_typedef

begin_expr_stmt
name|RB_HEAD
argument_list|(
name|chunk_tree_s
argument_list|,
name|chunk_node_s
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Arena data structures.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|arena_s
name|arena_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|arena_bin_s
name|arena_bin_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|arena_chunk_map_s
name|arena_chunk_map_t
typedef|;
end_typedef

begin_struct
struct|struct
name|arena_chunk_map_s
block|{
comment|/* Number of pages in run. */
name|uint32_t
name|npages
decl_stmt|;
comment|/* 	 * Position within run.  For a free run, this is POS_FREE for the first 	 * and last pages.  The POS_FREE special value makes it possible to 	 * quickly coalesce free runs. 	 * 	 * This is the limiting factor for chunk_size; there can be at most 2^31 	 * pages in a run. 	 */
define|#
directive|define
name|POS_FREE
value|0xffffffffU
name|uint32_t
name|pos
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Arena chunk header. */
end_comment

begin_typedef
typedef|typedef
name|struct
name|arena_chunk_s
name|arena_chunk_t
typedef|;
end_typedef

begin_struct
struct|struct
name|arena_chunk_s
block|{
comment|/* Arena that owns the chunk. */
name|arena_t
modifier|*
name|arena
decl_stmt|;
comment|/* Linkage for the arena's chunk tree. */
name|RB_ENTRY
argument_list|(
argument|arena_chunk_s
argument_list|)
name|link
expr_stmt|;
comment|/* 	 * Number of pages in use.  This is maintained in order to make 	 * detection of empty chunks fast. 	 */
name|uint32_t
name|pages_used
decl_stmt|;
comment|/* 	 * Every time a free run larger than this value is created/coalesced, 	 * this value is increased.  The only way that the value decreases is if 	 * arena_run_alloc() fails to find a free run as large as advertised by 	 * this value. 	 */
name|uint32_t
name|max_frun_npages
decl_stmt|;
comment|/* 	 * Every time a free run that starts at an earlier page than this value 	 * is created/coalesced, this value is decreased.  It is reset in a 	 * similar fashion to max_frun_npages. 	 */
name|uint32_t
name|min_frun_ind
decl_stmt|;
comment|/* 	 * Map of pages within chunk that keeps track of free/large/small.  For 	 * free runs, only the map entries for the first and last pages are 	 * kept up to date, so that free runs can be quickly coalesced. 	 */
name|arena_chunk_map_t
name|map
index|[
literal|1
index|]
decl_stmt|;
comment|/* Dynamically sized. */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|arena_chunk_tree_s
name|arena_chunk_tree_t
typedef|;
end_typedef

begin_expr_stmt
name|RB_HEAD
argument_list|(
name|arena_chunk_tree_s
argument_list|,
name|arena_chunk_s
argument_list|)
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|struct
name|arena_run_s
name|arena_run_t
typedef|;
end_typedef

begin_struct
struct|struct
name|arena_run_s
block|{
comment|/* Linkage for run rings. */
name|qr
argument_list|(
argument|arena_run_t
argument_list|)
name|link
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
name|uint32_t
name|magic
decl_stmt|;
define|#
directive|define
name|ARENA_RUN_MAGIC
value|0x384adf93
endif|#
directive|endif
comment|/* Bin this run is associated with. */
name|arena_bin_t
modifier|*
name|bin
decl_stmt|;
comment|/* Index of first element that might have a free region. */
name|unsigned
name|regs_minelm
decl_stmt|;
comment|/* Number of free regions in run. */
name|unsigned
name|nfree
decl_stmt|;
comment|/* 	 * Current quartile for this run, one of: {RUN_QINIT, RUN_Q0, RUN_25, 	 * RUN_Q50, RUN_Q75, RUN_Q100}. 	 */
define|#
directive|define
name|RUN_QINIT
value|0
define|#
directive|define
name|RUN_Q0
value|1
define|#
directive|define
name|RUN_Q25
value|2
define|#
directive|define
name|RUN_Q50
value|3
define|#
directive|define
name|RUN_Q75
value|4
define|#
directive|define
name|RUN_Q100
value|5
name|unsigned
name|quartile
decl_stmt|;
comment|/* 	 * Limits on the number of free regions for the fullness quartile this 	 * run is currently in.  If nfree goes outside these limits, the run 	 * is moved to a different fullness quartile. 	 */
name|unsigned
name|free_max
decl_stmt|;
name|unsigned
name|free_min
decl_stmt|;
comment|/* Bitmask of in-use regions (0: in use, 1: free). */
name|unsigned
name|regs_mask
index|[
literal|1
index|]
decl_stmt|;
comment|/* Dynamically sized. */
block|}
struct|;
end_struct

begin_comment
comment|/* Used for run ring headers, where the run isn't actually used. */
end_comment

begin_typedef
typedef|typedef
name|struct
name|arena_run_link_s
name|arena_run_link_t
typedef|;
end_typedef

begin_struct
struct|struct
name|arena_run_link_s
block|{
comment|/* Linkage for run rings. */
name|qr
argument_list|(
argument|arena_run_t
argument_list|)
name|link
expr_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Avoid pointer aliasing issues. */
end_comment

begin_function
specifier|static
specifier|inline
name|arena_run_t
modifier|*
name|arena_bin_link
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
return|return
operator|(
operator|(
name|arena_run_t
operator|*
operator|)
name|ptr
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|arena_bin_s
block|{
comment|/* 	 * Current run being used to service allocations of this bin's size 	 * class. 	 */
name|arena_run_t
modifier|*
name|runcur
decl_stmt|;
comment|/* 	 * Links into rings of runs, of various fullnesses (names indicate 	 * approximate lower bounds).  A new run conceptually starts off in 	 * runsinit, and it isn't inserted into the runs0 ring until it 	 * reaches 25% full (hysteresis mechanism).  For the run to be moved 	 * again, it must become either empty or 50% full.  Thus, each ring 	 * contains runs that are within 50% above the advertised fullness for 	 * the ring.  This provides a low-overhead mechanism for segregating 	 * runs into approximate fullness classes. 	 * 	 * Conceptually, there is a runs100 that contains completely full runs. 	 * Since we don't need to search for these runs though, no runs100 ring 	 * is actually maintained. 	 * 	 * These rings are useful when looking for an existing run to use when 	 * runcur is no longer usable.  We look for usable runs in the 	 * following order: 	 * 	 *   1) runs50 	 *   2) runs25 	 *   3) runs0 	 *   4) runs75 	 * 	 * runs75 isn't a good place to look, because it contains runs that may 	 * be nearly completely full.  Still, we look there as a last resort in 	 * order to avoid allocating a new run if at all possible. 	 */
comment|/* arena_run_link_t	runsinit;   0%<= fullness<   25% */
name|arena_run_link_t
name|runs0
decl_stmt|;
comment|/*  0%<  fullness<   50% */
name|arena_run_link_t
name|runs25
decl_stmt|;
comment|/* 25%<  fullness<   75% */
name|arena_run_link_t
name|runs50
decl_stmt|;
comment|/* 50%<  fullness<  100% */
name|arena_run_link_t
name|runs75
decl_stmt|;
comment|/* 75%<  fullness<  100% */
comment|/* arena_run_link_t	runs100;          fullness == 100% */
comment|/* Size of regions in a run for this bin's size class. */
name|size_t
name|reg_size
decl_stmt|;
comment|/* Total size of a run for this bin's size class. */
name|size_t
name|run_size
decl_stmt|;
comment|/* Total number of regions in a run for this bin's size class. */
name|uint32_t
name|nregs
decl_stmt|;
comment|/* Number of elements in a run's regs_mask for this bin's size class. */
name|uint32_t
name|regs_mask_nelms
decl_stmt|;
comment|/* Offset of first region in a run for this bin's size class. */
name|uint32_t
name|reg0_offset
decl_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
comment|/* Bin statistics. */
name|malloc_bin_stats_t
name|stats
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_struct
struct|struct
name|arena_s
block|{
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
name|uint32_t
name|magic
decl_stmt|;
define|#
directive|define
name|ARENA_MAGIC
value|0x947d3d24
endif|#
directive|endif
comment|/* All operations on this arena require that mtx be locked. */
name|malloc_mutex_t
name|mtx
decl_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena_stats_t
name|stats
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Tree of chunks this arena manages. 	 */
name|arena_chunk_tree_t
name|chunks
decl_stmt|;
comment|/* 	 * In order to avoid rapid chunk allocation/deallocation when an arena 	 * oscillates right on the cusp of needing a new chunk, cache the most 	 * recently freed chunk.  This caching is disabled by opt_hint. 	 * 	 * There is one spare chunk per arena, rather than one spare total, in 	 * order to avoid interactions between multiple threads that could make 	 * a single spare inadequate. 	 */
name|arena_chunk_t
modifier|*
name|spare
decl_stmt|;
comment|/* 	 * bins is used to store rings of free regions of the following sizes, 	 * assuming a 16-byte quantum, 4kB pagesize, and default MALLOC_OPTIONS. 	 * 	 *   bins[i] | size | 	 *   --------+------+ 	 *        0  |    2 | 	 *        1  |    4 | 	 *        2  |    8 | 	 *   --------+------+ 	 *        3  |   16 | 	 *        4  |   32 | 	 *        5  |   48 | 	 *        6  |   64 | 	 *           :      : 	 *           :      : 	 *       33  |  496 | 	 *       34  |  512 | 	 *   --------+------+ 	 *       35  | 1024 | 	 *       36  | 2048 | 	 *   --------+------+ 	 */
name|arena_bin_t
name|bins
index|[
literal|1
index|]
decl_stmt|;
comment|/* Dynamically sized. */
block|}
struct|;
end_struct

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Data.  */
end_comment

begin_comment
comment|/* Number of CPUs. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|ncpus
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VM page size. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|pagesize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|pagesize_mask
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|pagesize_2pow
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Various bin-related settings. */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|bin_maxclass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Max size class for bins. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|ntbins
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of (2^n)-spaced tiny bins. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|nqbins
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of quantum-spaced bins. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|nsbins
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of (2^n)-spaced sub-page bins. */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|small_min
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|small_max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Various quantum-related settings. */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|quantum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|quantum_mask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (quantum - 1). */
end_comment

begin_comment
comment|/* Various chunk-related settings. */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|chunk_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|chunk_size_mask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (chunk_size - 1). */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|chunk_npages
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|arena_chunk_header_npages
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|arena_maxclass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Max size class for arenas. */
end_comment

begin_comment
comment|/********/
end_comment

begin_comment
comment|/*  * Chunks.  */
end_comment

begin_comment
comment|/* Protects chunk-related data structures. */
end_comment

begin_decl_stmt
specifier|static
name|malloc_mutex_t
name|chunks_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tree of chunks that are stand-alone huge allocations. */
end_comment

begin_decl_stmt
specifier|static
name|chunk_tree_t
name|huge
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|USE_BRK
end_ifdef

begin_comment
comment|/*  * Try to use brk for chunk-size allocations, due to address space constraints.  */
end_comment

begin_comment
comment|/*  * Protects sbrk() calls.  This must be separate from chunks_mtx, since  * base_chunk_alloc() also uses sbrk(), but cannot lock chunks_mtx (doing so  * could cause recursive lock acquisition).  */
end_comment

begin_decl_stmt
specifier|static
name|malloc_mutex_t
name|brk_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Result of first sbrk(0) call. */
end_comment

begin_decl_stmt
specifier|static
name|void
modifier|*
name|brk_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current end of brk, or ((void *)-1) if brk is exhausted. */
end_comment

begin_decl_stmt
specifier|static
name|void
modifier|*
name|brk_prev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current upper limit on brk addresses. */
end_comment

begin_decl_stmt
specifier|static
name|void
modifier|*
name|brk_max
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_STATS
end_ifdef

begin_comment
comment|/*  * Byte counters for allocated/mapped space used by the chunks in the huge  * allocations tree.  */
end_comment

begin_decl_stmt
specifier|static
name|uint64_t
name|huge_nmalloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|huge_ndalloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|huge_allocated
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Tree of chunks that were previously allocated.  This is used when allocating  * chunks, in an attempt to re-use address space.  */
end_comment

begin_decl_stmt
specifier|static
name|chunk_tree_t
name|old_chunks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/****************************/
end_comment

begin_comment
comment|/*  * base (internal allocation).  */
end_comment

begin_comment
comment|/*  * Current chunk that is being used for internal memory allocations.  This  * chunk is carved up in cacheline-size quanta, so that there is no chance of  * false cache line sharing.  */
end_comment

begin_decl_stmt
specifier|static
name|void
modifier|*
name|base_chunk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|base_next_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|base_past_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Addr immediately past base_chunk. */
end_comment

begin_decl_stmt
specifier|static
name|chunk_node_t
modifier|*
name|base_chunk_nodes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* LIFO cache of chunk nodes. */
end_comment

begin_decl_stmt
specifier|static
name|malloc_mutex_t
name|base_mtx
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_STATS
end_ifdef

begin_decl_stmt
specifier|static
name|size_t
name|base_mapped
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/********/
end_comment

begin_comment
comment|/*  * Arenas.  */
end_comment

begin_comment
comment|/*  * Arenas that are used to service external requests.  Not all elements of the  * arenas array are necessarily used; arenas are created lazily as needed.  */
end_comment

begin_decl_stmt
specifier|static
name|arena_t
modifier|*
modifier|*
name|arenas
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|narenas
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NO_TLS
end_ifndef

begin_decl_stmt
specifier|static
name|unsigned
name|next_arena
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|malloc_mutex_t
name|arenas_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Protects arenas initialization. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_TLS
end_ifndef

begin_comment
comment|/*  * Map of pthread_self() --> arenas[???], used for selecting an arena to use  * for allocations.  */
end_comment

begin_decl_stmt
specifier|static
name|__thread
name|arena_t
modifier|*
name|arenas_map
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_STATS
end_ifdef

begin_comment
comment|/* Chunk statistics. */
end_comment

begin_decl_stmt
specifier|static
name|chunk_stats_t
name|stats_chunks
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*******************************/
end_comment

begin_comment
comment|/*  * Runtime configuration options.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|_malloc_options
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|MALLOC_PRODUCTION
end_ifndef

begin_decl_stmt
specifier|static
name|bool
name|opt_abort
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|opt_junk
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|bool
name|opt_abort
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|opt_junk
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|bool
name|opt_hint
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|opt_print_stats
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|opt_quantum_2pow
init|=
name|QUANTUM_2POW_MIN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|opt_small_max_2pow
init|=
name|SMALL_MAX_2POW_DEFAULT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|opt_chunk_2pow
init|=
name|CHUNK_2POW_DEFAULT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|opt_utrace
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|opt_sysv
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|opt_xmalloc
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|opt_zero
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int32_t
name|opt_narenas_lshift
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|size_t
name|s
decl_stmt|;
name|void
modifier|*
name|r
decl_stmt|;
block|}
name|malloc_utrace_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|UTRACE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
define|\
value|if (opt_utrace) {						\ 		malloc_utrace_t ut = {a, b, c};				\ 		utrace(&ut, sizeof(ut));				\ 	}
end_define

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin function prototypes for non-inline static functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|malloc_mutex_init
parameter_list|(
name|malloc_mutex_t
modifier|*
name|a_mutex
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wrtmessage
parameter_list|(
specifier|const
name|char
modifier|*
name|p1
parameter_list|,
specifier|const
name|char
modifier|*
name|p2
parameter_list|,
specifier|const
name|char
modifier|*
name|p3
parameter_list|,
specifier|const
name|char
modifier|*
name|p4
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_STATS
end_ifdef

begin_function_decl
specifier|static
name|void
name|malloc_printf
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|char
modifier|*
name|umax2s
parameter_list|(
name|uintmax_t
name|x
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|base_chunk_alloc
parameter_list|(
name|size_t
name|minsize
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|base_alloc
parameter_list|(
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|chunk_node_t
modifier|*
name|base_chunk_node_alloc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|base_chunk_node_dealloc
parameter_list|(
name|chunk_node_t
modifier|*
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_STATS
end_ifdef

begin_function_decl
specifier|static
name|void
name|stats_print
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
modifier|*
name|pages_map
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pages_unmap
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|chunk_alloc
parameter_list|(
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chunk_dealloc
parameter_list|(
name|void
modifier|*
name|chunk
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|NO_TLS
end_ifndef

begin_function_decl
specifier|static
name|arena_t
modifier|*
name|choose_arena_hard
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|arena_run_split
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|arena_chunk_t
modifier|*
name|arena_chunk_alloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arena_chunk_dealloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arena_bin_run_promote
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arena_bin_run_demote
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|arena_run_t
modifier|*
name|arena_run_alloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arena_run_dalloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|arena_run_t
modifier|*
name|arena_bin_nonfull_run_get
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|arena_bin_malloc_hard
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|arena_bin_run_size_calc
parameter_list|(
name|arena_bin_t
modifier|*
name|bin
parameter_list|,
name|size_t
name|min_run_size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|arena_malloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|arena_salloc
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|arena_ralloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|oldsize
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arena_dalloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arena_new
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|arena_t
modifier|*
name|arenas_extend
parameter_list|(
name|unsigned
name|ind
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|huge_malloc
parameter_list|(
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|huge_ralloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|oldsize
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|huge_dalloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|imalloc
parameter_list|(
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|ipalloc
parameter_list|(
name|size_t
name|alignment
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|icalloc
parameter_list|(
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|isalloc
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|iralloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|idalloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|malloc_print_stats
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|malloc_init_hard
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * End function prototypes.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin mutex.  */
end_comment

begin_function
specifier|static
name|void
name|malloc_mutex_init
parameter_list|(
name|malloc_mutex_t
modifier|*
name|a_mutex
parameter_list|)
block|{
specifier|static
specifier|const
name|spinlock_t
name|lock
init|=
name|_SPINLOCK_INITIALIZER
decl_stmt|;
name|a_mutex
operator|->
name|lock
operator|=
name|lock
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|malloc_mutex_lock
parameter_list|(
name|malloc_mutex_t
modifier|*
name|a_mutex
parameter_list|)
block|{
if|if
condition|(
name|__isthreaded
condition|)
name|_SPINLOCK
argument_list|(
operator|&
name|a_mutex
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|malloc_mutex_unlock
parameter_list|(
name|malloc_mutex_t
modifier|*
name|a_mutex
parameter_list|)
block|{
if|if
condition|(
name|__isthreaded
condition|)
name|_SPINUNLOCK
argument_list|(
operator|&
name|a_mutex
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * End mutex.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin Utility functions/macros.  */
end_comment

begin_comment
comment|/* Return the chunk address for allocation address a. */
end_comment

begin_define
define|#
directive|define
name|CHUNK_ADDR2BASE
parameter_list|(
name|a
parameter_list|)
define|\
value|((void *)((uintptr_t)(a)& ~chunk_size_mask))
end_define

begin_comment
comment|/* Return the chunk offset of address a. */
end_comment

begin_define
define|#
directive|define
name|CHUNK_ADDR2OFFSET
parameter_list|(
name|a
parameter_list|)
define|\
value|((size_t)((uintptr_t)(a)& chunk_size_mask))
end_define

begin_comment
comment|/* Return the smallest chunk multiple that is>= s. */
end_comment

begin_define
define|#
directive|define
name|CHUNK_CEILING
parameter_list|(
name|s
parameter_list|)
define|\
value|(((s) + chunk_size_mask)& ~chunk_size_mask)
end_define

begin_comment
comment|/* Return the smallest cacheline multiple that is>= s. */
end_comment

begin_define
define|#
directive|define
name|CACHELINE_CEILING
parameter_list|(
name|s
parameter_list|)
define|\
value|(((s) + (CACHELINE - 1))& ~(CACHELINE - 1))
end_define

begin_comment
comment|/* Return the smallest quantum multiple that is>= a. */
end_comment

begin_define
define|#
directive|define
name|QUANTUM_CEILING
parameter_list|(
name|a
parameter_list|)
define|\
value|(((a) + quantum_mask)& ~quantum_mask)
end_define

begin_comment
comment|/* Return the smallest pagesize multiple that is>= s. */
end_comment

begin_define
define|#
directive|define
name|PAGE_CEILING
parameter_list|(
name|s
parameter_list|)
define|\
value|(((s) + pagesize_mask)& ~pagesize_mask)
end_define

begin_comment
comment|/* Compute the smallest power of 2 that is>= x. */
end_comment

begin_function
specifier|static
specifier|inline
name|size_t
name|pow2_ceil
parameter_list|(
name|size_t
name|x
parameter_list|)
block|{
name|x
operator|--
expr_stmt|;
name|x
operator||=
name|x
operator|>>
literal|1
expr_stmt|;
name|x
operator||=
name|x
operator|>>
literal|2
expr_stmt|;
name|x
operator||=
name|x
operator|>>
literal|4
expr_stmt|;
name|x
operator||=
name|x
operator|>>
literal|8
expr_stmt|;
name|x
operator||=
name|x
operator|>>
literal|16
expr_stmt|;
if|#
directive|if
operator|(
name|SIZEOF_PTR
operator|==
literal|8
operator|)
name|x
operator||=
name|x
operator|>>
literal|32
expr_stmt|;
endif|#
directive|endif
name|x
operator|++
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wrtmessage
parameter_list|(
specifier|const
name|char
modifier|*
name|p1
parameter_list|,
specifier|const
name|char
modifier|*
name|p2
parameter_list|,
specifier|const
name|char
modifier|*
name|p3
parameter_list|,
specifier|const
name|char
modifier|*
name|p4
parameter_list|)
block|{
name|_write
argument_list|(
name|STDERR_FILENO
argument_list|,
name|p1
argument_list|,
name|strlen
argument_list|(
name|p1
argument_list|)
argument_list|)
expr_stmt|;
name|_write
argument_list|(
name|STDERR_FILENO
argument_list|,
name|p2
argument_list|,
name|strlen
argument_list|(
name|p2
argument_list|)
argument_list|)
expr_stmt|;
name|_write
argument_list|(
name|STDERR_FILENO
argument_list|,
name|p3
argument_list|,
name|strlen
argument_list|(
name|p3
argument_list|)
argument_list|)
expr_stmt|;
name|_write
argument_list|(
name|STDERR_FILENO
argument_list|,
name|p4
argument_list|,
name|strlen
argument_list|(
name|p4
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
name|void
function_decl|(
modifier|*
name|_malloc_message
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
name|p1
parameter_list|,
specifier|const
name|char
modifier|*
name|p2
parameter_list|,
specifier|const
name|char
modifier|*
name|p3
parameter_list|,
specifier|const
name|char
modifier|*
name|p4
parameter_list|)
init|=
name|wrtmessage
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_STATS
end_ifdef

begin_comment
comment|/*  * Print to stderr in such a way as to (hopefully) avoid memory allocation.  */
end_comment

begin_function
specifier|static
name|void
name|malloc_printf
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|buf
index|[
literal|4096
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|_malloc_message
argument_list|(
name|buf
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * We don't want to depend on vsnprintf() for production builds, since that can  * cause unnecessary bloat for static binaries.  umax2s() provides minimal  * integer printing functionality, so that malloc_printf() use can be limited to  * MALLOC_STATS code.  */
end_comment

begin_define
define|#
directive|define
name|UMAX2S_BUFSIZE
value|21
end_define

begin_function
specifier|static
name|char
modifier|*
name|umax2s
parameter_list|(
name|uintmax_t
name|x
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
comment|/* Make sure UMAX2S_BUFSIZE is large enough. */
name|assert
argument_list|(
sizeof|sizeof
argument_list|(
name|uintmax_t
argument_list|)
operator|<=
literal|8
argument_list|)
expr_stmt|;
name|i
operator|=
name|UMAX2S_BUFSIZE
operator|-
literal|1
expr_stmt|;
name|s
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
do|do
block|{
name|i
operator|--
expr_stmt|;
name|s
index|[
name|i
index|]
operator|=
literal|"0123456789"
index|[
name|x
operator|%
literal|10
index|]
expr_stmt|;
name|x
operator|/=
literal|10
expr_stmt|;
block|}
do|while
condition|(
name|x
operator|>
literal|0
condition|)
do|;
return|return
operator|(
operator|&
name|s
index|[
name|i
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_function
specifier|static
name|bool
name|base_chunk_alloc
parameter_list|(
name|size_t
name|minsize
parameter_list|)
block|{
name|assert
argument_list|(
name|minsize
operator|<=
name|chunk_size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_BRK
comment|/* 	 * Do special brk allocation here, since the base chunk doesn't really 	 * need to be chunk-aligned. 	 */
if|if
condition|(
name|brk_prev
operator|!=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
name|void
modifier|*
name|brk_cur
decl_stmt|;
name|intptr_t
name|incr
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|brk_mtx
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* Get the current end of brk. */
name|brk_cur
operator|=
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * Calculate how much padding is necessary to 			 * chunk-align the end of brk.  Don't worry about 			 * brk_cur not being chunk-aligned though. 			 */
name|incr
operator|=
operator|(
name|intptr_t
operator|)
name|chunk_size
operator|-
operator|(
name|intptr_t
operator|)
name|CHUNK_ADDR2OFFSET
argument_list|(
name|brk_cur
argument_list|)
expr_stmt|;
if|if
condition|(
name|incr
operator|<
name|minsize
condition|)
name|incr
operator|+=
name|chunk_size
expr_stmt|;
name|brk_prev
operator|=
name|sbrk
argument_list|(
name|incr
argument_list|)
expr_stmt|;
if|if
condition|(
name|brk_prev
operator|==
name|brk_cur
condition|)
block|{
comment|/* Success. */
name|malloc_mutex_unlock
argument_list|(
operator|&
name|brk_mtx
argument_list|)
expr_stmt|;
name|base_chunk
operator|=
name|brk_cur
expr_stmt|;
name|base_next_addr
operator|=
name|base_chunk
expr_stmt|;
name|base_past_addr
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|base_chunk
operator|+
name|incr
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|base_mapped
operator|+=
name|incr
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|false
operator|)
return|;
block|}
block|}
do|while
condition|(
name|brk_prev
operator|!=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
condition|)
do|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|brk_mtx
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Don't worry about chunk alignment here, since base_chunk doesn't 	 * really need to be aligned. 	 */
name|base_chunk
operator|=
name|pages_map
argument_list|(
name|NULL
argument_list|,
name|chunk_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_chunk
operator|==
name|NULL
condition|)
return|return
operator|(
name|true
operator|)
return|;
name|base_next_addr
operator|=
name|base_chunk
expr_stmt|;
name|base_past_addr
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|base_chunk
operator|+
name|chunk_size
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|base_mapped
operator|+=
name|chunk_size
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|base_alloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|size_t
name|csize
decl_stmt|;
comment|/* Round size up to nearest multiple of the cacheline size. */
name|csize
operator|=
name|CACHELINE_CEILING
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure there's enough space for the allocation. 	 * base_chunk_alloc() does not guarantee that a newly allocated chunk 	 * is>= size, so loop here, rather than only trying once. 	 */
while|while
condition|(
operator|(
name|uintptr_t
operator|)
name|base_next_addr
operator|+
name|csize
operator|>
operator|(
name|uintptr_t
operator|)
name|base_past_addr
condition|)
block|{
if|if
condition|(
name|base_chunk_alloc
argument_list|(
name|csize
argument_list|)
condition|)
block|{
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
block|}
comment|/* Allocate. */
name|ret
operator|=
name|base_next_addr
expr_stmt|;
name|base_next_addr
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|base_next_addr
operator|+
name|csize
operator|)
expr_stmt|;
name|RETURN
label|:
name|malloc_mutex_unlock
argument_list|(
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|chunk_node_t
modifier|*
name|base_chunk_node_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|chunk_node_t
modifier|*
name|ret
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_chunk_nodes
operator|!=
name|NULL
condition|)
block|{
name|ret
operator|=
name|base_chunk_nodes
expr_stmt|;
name|base_chunk_nodes
operator|=
operator|*
operator|(
name|chunk_node_t
operator|*
operator|*
operator|)
name|ret
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|malloc_mutex_unlock
argument_list|(
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|chunk_node_t
operator|*
operator|)
name|base_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|chunk_node_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|base_chunk_node_dealloc
parameter_list|(
name|chunk_node_t
modifier|*
name|node
parameter_list|)
block|{
name|malloc_mutex_lock
argument_list|(
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
operator|*
operator|(
name|chunk_node_t
operator|*
operator|*
operator|)
name|node
operator|=
name|base_chunk_nodes
expr_stmt|;
name|base_chunk_nodes
operator|=
name|node
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_STATS
end_ifdef

begin_function
specifier|static
name|void
name|stats_print
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|int
name|gap_start
decl_stmt|;
name|malloc_printf
argument_list|(
literal|"          allocated/mapped            nmalloc      ndalloc\n"
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"small: %12llu %-12s %12llu %12llu\n"
argument_list|,
name|arena
operator|->
name|stats
operator|.
name|allocated_small
argument_list|,
literal|""
argument_list|,
name|arena
operator|->
name|stats
operator|.
name|nmalloc_small
argument_list|,
name|arena
operator|->
name|stats
operator|.
name|ndalloc_small
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"large: %12llu %-12s %12llu %12llu\n"
argument_list|,
name|arena
operator|->
name|stats
operator|.
name|allocated_large
argument_list|,
literal|""
argument_list|,
name|arena
operator|->
name|stats
operator|.
name|nmalloc_large
argument_list|,
name|arena
operator|->
name|stats
operator|.
name|ndalloc_large
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"total: %12llu/%-12llu %12llu %12llu\n"
argument_list|,
name|arena
operator|->
name|stats
operator|.
name|allocated_small
operator|+
name|arena
operator|->
name|stats
operator|.
name|allocated_large
argument_list|,
name|arena
operator|->
name|stats
operator|.
name|mapped
argument_list|,
name|arena
operator|->
name|stats
operator|.
name|nmalloc_small
operator|+
name|arena
operator|->
name|stats
operator|.
name|nmalloc_large
argument_list|,
name|arena
operator|->
name|stats
operator|.
name|ndalloc_small
operator|+
name|arena
operator|->
name|stats
operator|.
name|ndalloc_large
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"bins:     bin   size regs pgs  requests newruns "
literal|"maxruns curruns promote  demote\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|gap_start
operator|=
operator|-
literal|1
init|;
name|i
operator|<
name|ntbins
operator|+
name|nqbins
operator|+
name|nsbins
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|arena
operator|->
name|bins
index|[
name|i
index|]
operator|.
name|stats
operator|.
name|nrequests
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|gap_start
operator|==
operator|-
literal|1
condition|)
name|gap_start
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|gap_start
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|i
operator|>
name|gap_start
operator|+
literal|1
condition|)
block|{
comment|/* Gap of more than one size class. */
name|malloc_printf
argument_list|(
literal|"[%u..%u]\n"
argument_list|,
name|gap_start
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Gap of one size class. */
name|malloc_printf
argument_list|(
literal|"[%u]\n"
argument_list|,
name|gap_start
argument_list|)
expr_stmt|;
block|}
name|gap_start
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|malloc_printf
argument_list|(
literal|"%13u %1s %4u %4u %3u %9llu %7llu"
literal|" %7lu %7lu %7llu %7llu\n"
argument_list|,
name|i
argument_list|,
name|i
operator|<
name|ntbins
condition|?
literal|"T"
else|:
name|i
operator|<
name|ntbins
operator|+
name|nqbins
condition|?
literal|"Q"
else|:
literal|"S"
argument_list|,
name|arena
operator|->
name|bins
index|[
name|i
index|]
operator|.
name|reg_size
argument_list|,
name|arena
operator|->
name|bins
index|[
name|i
index|]
operator|.
name|nregs
argument_list|,
name|arena
operator|->
name|bins
index|[
name|i
index|]
operator|.
name|run_size
operator|>>
name|pagesize_2pow
argument_list|,
name|arena
operator|->
name|bins
index|[
name|i
index|]
operator|.
name|stats
operator|.
name|nrequests
argument_list|,
name|arena
operator|->
name|bins
index|[
name|i
index|]
operator|.
name|stats
operator|.
name|nruns
argument_list|,
name|arena
operator|->
name|bins
index|[
name|i
index|]
operator|.
name|stats
operator|.
name|highruns
argument_list|,
name|arena
operator|->
name|bins
index|[
name|i
index|]
operator|.
name|stats
operator|.
name|curruns
argument_list|,
name|arena
operator|->
name|bins
index|[
name|i
index|]
operator|.
name|stats
operator|.
name|npromote
argument_list|,
name|arena
operator|->
name|bins
index|[
name|i
index|]
operator|.
name|stats
operator|.
name|ndemote
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gap_start
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|i
operator|>
name|gap_start
operator|+
literal|1
condition|)
block|{
comment|/* Gap of more than one size class. */
name|malloc_printf
argument_list|(
literal|"[%u..%u]\n"
argument_list|,
name|gap_start
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Gap of one size class. */
name|malloc_printf
argument_list|(
literal|"[%u]\n"
argument_list|,
name|gap_start
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * End Utility functions/macros.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin chunk management functions.  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|chunk_comp
parameter_list|(
name|chunk_node_t
modifier|*
name|a
parameter_list|,
name|chunk_node_t
modifier|*
name|b
parameter_list|)
block|{
name|assert
argument_list|(
name|a
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|b
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|a
operator|->
name|chunk
operator|<
operator|(
name|uintptr_t
operator|)
name|b
operator|->
name|chunk
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|a
operator|->
name|chunk
operator|==
name|b
operator|->
name|chunk
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Generate red-black tree code for chunks. */
end_comment

begin_expr_stmt
name|RB_GENERATE_STATIC
argument_list|(
name|chunk_tree_s
argument_list|,
name|chunk_node_s
argument_list|,
name|link
argument_list|,
name|chunk_comp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
modifier|*
name|pages_map
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
comment|/* 	 * We don't use MAP_FIXED here, because it can cause the *replacement* 	 * of existing mappings, and we only want to create new mappings. 	 */
name|ret
operator|=
name|mmap
argument_list|(
name|addr
argument_list|,
name|size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
operator||
name|MAP_ANON
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|MAP_FAILED
condition|)
name|ret
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|addr
operator|!=
name|NULL
operator|&&
name|ret
operator|!=
name|addr
condition|)
block|{
comment|/* 		 * We succeeded in mapping memory, but not in the right place. 		 */
if|if
condition|(
name|munmap
argument_list|(
name|ret
argument_list|,
name|size
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|char
name|buf
index|[
name|STRERROR_BUF
index|]
decl_stmt|;
name|strerror_r
argument_list|(
name|errno
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|_malloc_message
argument_list|(
name|_getprogname
argument_list|()
argument_list|,
literal|": (malloc) Error in munmap(): "
argument_list|,
name|buf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_abort
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|ret
operator|=
name|NULL
expr_stmt|;
block|}
name|assert
argument_list|(
name|ret
operator|==
name|NULL
operator|||
operator|(
name|addr
operator|==
name|NULL
operator|&&
name|ret
operator|!=
name|addr
operator|)
operator|||
operator|(
name|addr
operator|!=
name|NULL
operator|&&
name|ret
operator|==
name|addr
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pages_unmap
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
if|if
condition|(
name|munmap
argument_list|(
name|addr
argument_list|,
name|size
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|char
name|buf
index|[
name|STRERROR_BUF
index|]
decl_stmt|;
name|strerror_r
argument_list|(
name|errno
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|_malloc_message
argument_list|(
name|_getprogname
argument_list|()
argument_list|,
literal|": (malloc) Error in munmap(): "
argument_list|,
name|buf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_abort
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|chunk_alloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|,
modifier|*
name|chunk
decl_stmt|;
name|chunk_node_t
modifier|*
name|tchunk
decl_stmt|,
modifier|*
name|delchunk
decl_stmt|;
name|assert
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|%
name|chunk_size
operator|==
literal|0
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
name|chunk_size
condition|)
block|{
comment|/* 		 * Check for address ranges that were previously chunks and try 		 * to use them. 		 */
name|tchunk
operator|=
name|RB_MIN
argument_list|(
name|chunk_tree_s
argument_list|,
operator|&
name|old_chunks
argument_list|)
expr_stmt|;
while|while
condition|(
name|tchunk
operator|!=
name|NULL
condition|)
block|{
comment|/* Found an address range.  Try to recycle it. */
name|chunk
operator|=
name|tchunk
operator|->
name|chunk
expr_stmt|;
name|delchunk
operator|=
name|tchunk
expr_stmt|;
name|tchunk
operator|=
name|RB_NEXT
argument_list|(
name|chunk_tree_s
argument_list|,
operator|&
name|old_chunks
argument_list|,
name|delchunk
argument_list|)
expr_stmt|;
comment|/* Remove delchunk from the tree. */
name|RB_REMOVE
argument_list|(
name|chunk_tree_s
argument_list|,
operator|&
name|old_chunks
argument_list|,
name|delchunk
argument_list|)
expr_stmt|;
name|base_chunk_node_dealloc
argument_list|(
name|delchunk
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_BRK
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|>=
operator|(
name|uintptr_t
operator|)
name|brk_base
operator|&&
operator|(
name|uintptr_t
operator|)
name|chunk
operator|<
operator|(
name|uintptr_t
operator|)
name|brk_max
condition|)
block|{
comment|/* Re-use a previously freed brk chunk. */
name|ret
operator|=
name|chunk
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|ret
operator|=
name|pages_map
argument_list|(
name|chunk
argument_list|,
name|size
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Success. */
goto|goto
name|RETURN
goto|;
block|}
block|}
block|}
comment|/* 	 * Try to over-allocate, but allow the OS to place the allocation 	 * anywhere.  Beware of size_t wrap-around. 	 */
if|if
condition|(
name|size
operator|+
name|chunk_size
operator|>
name|size
condition|)
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|pages_map
argument_list|(
name|NULL
argument_list|,
name|size
operator|+
name|chunk_size
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|offset
init|=
name|CHUNK_ADDR2OFFSET
argument_list|(
name|ret
argument_list|)
decl_stmt|;
comment|/* 			 * Success.  Clean up unneeded leading/trailing space. 			 */
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
comment|/* Leading space. */
name|pages_unmap
argument_list|(
name|ret
argument_list|,
name|chunk_size
operator|-
name|offset
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ret
operator|+
operator|(
name|chunk_size
operator|-
name|offset
operator|)
operator|)
expr_stmt|;
comment|/* Trailing space. */
name|pages_unmap
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ret
operator|+
name|size
operator|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Trailing space only. */
name|pages_unmap
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ret
operator|+
name|size
operator|)
argument_list|,
name|chunk_size
argument_list|)
expr_stmt|;
block|}
goto|goto
name|RETURN
goto|;
block|}
block|}
ifdef|#
directive|ifdef
name|USE_BRK
comment|/* 	 * Try to create allocations in brk, in order to make full use of 	 * limited address space. 	 */
if|if
condition|(
name|brk_prev
operator|!=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
name|void
modifier|*
name|brk_cur
decl_stmt|;
name|intptr_t
name|incr
decl_stmt|;
comment|/* 		 * The loop is necessary to recover from races with other 		 * threads that are using brk for something other than malloc. 		 */
name|malloc_mutex_lock
argument_list|(
operator|&
name|brk_mtx
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* Get the current end of brk. */
name|brk_cur
operator|=
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * Calculate how much padding is necessary to 			 * chunk-align the end of brk. 			 */
name|incr
operator|=
operator|(
name|intptr_t
operator|)
name|size
operator|-
operator|(
name|intptr_t
operator|)
name|CHUNK_ADDR2OFFSET
argument_list|(
name|brk_cur
argument_list|)
expr_stmt|;
if|if
condition|(
name|incr
operator|==
name|size
condition|)
block|{
name|ret
operator|=
name|brk_cur
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|intptr_t
operator|)
name|brk_cur
operator|+
name|incr
operator|)
expr_stmt|;
name|incr
operator|+=
name|size
expr_stmt|;
block|}
name|brk_prev
operator|=
name|sbrk
argument_list|(
name|incr
argument_list|)
expr_stmt|;
if|if
condition|(
name|brk_prev
operator|==
name|brk_cur
condition|)
block|{
comment|/* Success. */
name|malloc_mutex_unlock
argument_list|(
operator|&
name|brk_mtx
argument_list|)
expr_stmt|;
name|brk_max
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|intptr_t
operator|)
name|ret
operator|+
name|size
operator|)
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
block|}
do|while
condition|(
name|brk_prev
operator|!=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
condition|)
do|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|brk_mtx
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* All strategies for allocation failed. */
name|ret
operator|=
name|NULL
expr_stmt|;
name|RETURN
label|:
ifdef|#
directive|ifdef
name|MALLOC_STATS
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
block|{
name|stats_chunks
operator|.
name|nchunks
operator|+=
operator|(
name|size
operator|/
name|chunk_size
operator|)
expr_stmt|;
name|stats_chunks
operator|.
name|curchunks
operator|+=
operator|(
name|size
operator|/
name|chunk_size
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|stats_chunks
operator|.
name|curchunks
operator|>
name|stats_chunks
operator|.
name|highchunks
condition|)
name|stats_chunks
operator|.
name|highchunks
operator|=
name|stats_chunks
operator|.
name|curchunks
expr_stmt|;
endif|#
directive|endif
name|malloc_mutex_unlock
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|CHUNK_ADDR2BASE
argument_list|(
name|ret
argument_list|)
operator|==
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|chunk_dealloc
parameter_list|(
name|void
modifier|*
name|chunk
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|offset
decl_stmt|;
name|chunk_node_t
name|key
decl_stmt|;
name|chunk_node_t
modifier|*
name|node
decl_stmt|;
name|assert
argument_list|(
name|chunk
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|CHUNK_ADDR2BASE
argument_list|(
name|chunk
argument_list|)
operator|==
name|chunk
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|%
name|chunk_size
operator|==
literal|0
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_BRK
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|>=
operator|(
name|uintptr_t
operator|)
name|brk_base
operator|&&
operator|(
name|uintptr_t
operator|)
name|chunk
operator|<
operator|(
name|uintptr_t
operator|)
name|brk_max
condition|)
block|{
name|void
modifier|*
name|brk_cur
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|brk_mtx
argument_list|)
expr_stmt|;
comment|/* Get the current end of brk. */
name|brk_cur
operator|=
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Try to shrink the data segment if this chunk is at the end 		 * of the data segment.  The sbrk() call here is subject to a 		 * race condition with threads that use brk(2) or sbrk(2) 		 * directly, but the alternative would be to leak memory for 		 * the sake of poorly designed multi-threaded programs. 		 */
if|if
condition|(
name|brk_cur
operator|==
name|brk_max
operator|&&
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|+
name|size
operator|)
operator|==
name|brk_max
operator|&&
name|sbrk
argument_list|(
operator|-
operator|(
name|intptr_t
operator|)
name|size
argument_list|)
operator|==
name|brk_max
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
operator|&
name|brk_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|brk_prev
operator|==
name|brk_max
condition|)
block|{
comment|/* Success. */
name|brk_prev
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|intptr_t
operator|)
name|brk_max
operator|-
operator|(
name|intptr_t
operator|)
name|size
operator|)
expr_stmt|;
name|brk_max
operator|=
name|brk_prev
expr_stmt|;
block|}
goto|goto
name|RETURN
goto|;
block|}
else|else
name|malloc_mutex_unlock
argument_list|(
operator|&
name|brk_mtx
argument_list|)
expr_stmt|;
name|madvise
argument_list|(
name|chunk
argument_list|,
name|size
argument_list|,
name|MADV_FREE
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|pages_unmap
argument_list|(
name|chunk
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* 	 * Iteratively create records of each chunk-sized memory region that 	 * 'chunk' is comprised of, so that the address range can be recycled 	 * if memory usage increases later on. 	 */
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|size
condition|;
name|offset
operator|+=
name|chunk_size
control|)
block|{
comment|/* 		 * It is possible for chunk to overlap existing entries in 		 * old_chunks if it is a huge allocation, so take care to not 		 * leak tree nodes. 		 */
name|key
operator|.
name|chunk
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|+
operator|(
name|uintptr_t
operator|)
name|offset
operator|)
expr_stmt|;
if|if
condition|(
name|RB_FIND
argument_list|(
name|chunk_tree_s
argument_list|,
operator|&
name|old_chunks
argument_list|,
operator|&
name|key
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|node
operator|=
name|base_chunk_node_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
break|break;
name|node
operator|->
name|chunk
operator|=
name|key
operator|.
name|chunk
expr_stmt|;
name|node
operator|->
name|size
operator|=
name|chunk_size
expr_stmt|;
name|RB_INSERT
argument_list|(
name|chunk_tree_s
argument_list|,
operator|&
name|old_chunks
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|USE_BRK
name|RETURN
label|:
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|stats_chunks
operator|.
name|curchunks
operator|-=
operator|(
name|size
operator|/
name|chunk_size
operator|)
expr_stmt|;
endif|#
directive|endif
name|malloc_mutex_unlock
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * End chunk management functions.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin arena.  */
end_comment

begin_comment
comment|/*  * Choose an arena based on a per-thread value (fast-path code, calls slow-path  * code if necessary.  */
end_comment

begin_function
specifier|static
specifier|inline
name|arena_t
modifier|*
name|choose_arena
parameter_list|(
name|void
parameter_list|)
block|{
name|arena_t
modifier|*
name|ret
decl_stmt|;
comment|/* 	 * We can only use TLS if this is a PIC library, since for the static 	 * library version, libc's malloc is used by TLS allocation, which 	 * introduces a bootstrapping issue. 	 */
ifndef|#
directive|ifndef
name|NO_TLS
if|if
condition|(
name|__isthreaded
operator|==
name|false
condition|)
block|{
comment|/* 	     * Avoid the overhead of TLS for single-threaded operation.  If the 	     * app switches to threaded mode, the initial thread may end up 	     * being assigned to some other arena, but this one-time switch 	     * shouldn't cause significant issues. 	     * */
return|return
operator|(
name|arenas
index|[
literal|0
index|]
operator|)
return|;
block|}
name|ret
operator|=
name|arenas_map
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|ret
operator|=
name|choose_arena_hard
argument_list|()
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|__isthreaded
condition|)
block|{
name|unsigned
name|long
name|ind
decl_stmt|;
comment|/* 		 * Hash _pthread_self() to one of the arenas.  There is a prime 		 * number of arenas, so this has a reasonable chance of 		 * working.  Even so, the hashing can be easily thwarted by 		 * inconvenient _pthread_self() values.  Without specific 		 * knowledge of how _pthread_self() calculates values, we can't 		 * easily do much better than this. 		 */
name|ind
operator|=
operator|(
name|unsigned
name|long
operator|)
name|_pthread_self
argument_list|()
operator|%
name|narenas
expr_stmt|;
comment|/* 		 * Optimistially assume that arenas[ind] has been initialized. 		 * At worst, we find out that some other thread has already 		 * done so, after acquiring the lock in preparation.  Note that 		 * this lazy locking also has the effect of lazily forcing 		 * cache coherency; without the lock acquisition, there's no 		 * guarantee that modification of arenas[ind] by another thread 		 * would be seen on this CPU for an arbitrary amount of time. 		 * 		 * In general, this approach to modifying a synchronized value 		 * isn't a good idea, but in this case we only ever modify the 		 * value once, so things work out well. 		 */
name|ret
operator|=
name|arenas
index|[
name|ind
index|]
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Avoid races with another thread that may have already 			 * initialized arenas[ind]. 			 */
name|malloc_mutex_lock
argument_list|(
operator|&
name|arenas_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|arenas
index|[
name|ind
index|]
operator|==
name|NULL
condition|)
name|ret
operator|=
name|arenas_extend
argument_list|(
operator|(
name|unsigned
operator|)
name|ind
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|arenas
index|[
name|ind
index|]
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arenas_mtx
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|ret
operator|=
name|arenas
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
name|assert
argument_list|(
name|ret
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_TLS
end_ifndef

begin_comment
comment|/*  * Choose an arena based on a per-thread value (slow-path code only, called  * only by choose_arena()).  */
end_comment

begin_function
specifier|static
name|arena_t
modifier|*
name|choose_arena_hard
parameter_list|(
name|void
parameter_list|)
block|{
name|arena_t
modifier|*
name|ret
decl_stmt|;
name|assert
argument_list|(
name|__isthreaded
argument_list|)
expr_stmt|;
comment|/* Assign one of the arenas to this thread, in a round-robin fashion. */
name|malloc_mutex_lock
argument_list|(
operator|&
name|arenas_mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
name|arenas
index|[
name|next_arena
index|]
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|ret
operator|=
name|arenas_extend
argument_list|(
name|next_arena
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Make sure that this function never returns NULL, so that 		 * choose_arena() doesn't have to check for a NULL return 		 * value. 		 */
name|ret
operator|=
name|arenas
index|[
literal|0
index|]
expr_stmt|;
block|}
name|next_arena
operator|=
operator|(
name|next_arena
operator|+
literal|1
operator|)
operator|%
name|narenas
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arenas_mtx
argument_list|)
expr_stmt|;
name|arenas_map
operator|=
name|ret
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|int
name|arena_chunk_comp
parameter_list|(
name|arena_chunk_t
modifier|*
name|a
parameter_list|,
name|arena_chunk_t
modifier|*
name|b
parameter_list|)
block|{
name|assert
argument_list|(
name|a
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|b
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|a
operator|<
operator|(
name|uintptr_t
operator|)
name|b
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|a
operator|==
name|b
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Generate red-black tree code for arena chunks. */
end_comment

begin_expr_stmt
name|RB_GENERATE_STATIC
argument_list|(
name|arena_chunk_tree_s
argument_list|,
name|arena_chunk_s
argument_list|,
name|link
argument_list|,
name|arena_chunk_comp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|arena_run_reg_alloc
parameter_list|(
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|mask
decl_stmt|,
name|bit
decl_stmt|,
name|regind
decl_stmt|;
name|assert
argument_list|(
name|run
operator|->
name|magic
operator|==
name|ARENA_RUN_MAGIC
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|run
operator|->
name|regs_minelm
init|;
name|i
operator|<
name|bin
operator|->
name|regs_mask_nelms
condition|;
name|i
operator|++
control|)
block|{
name|mask
operator|=
name|run
operator|->
name|regs_mask
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|mask
operator|!=
literal|0
condition|)
block|{
comment|/* Usable allocation found. */
name|bit
operator|=
name|ffs
argument_list|(
operator|(
name|int
operator|)
name|mask
argument_list|)
operator|-
literal|1
expr_stmt|;
name|regind
operator|=
operator|(
operator|(
name|i
operator|<<
operator|(
name|SIZEOF_INT_2POW
operator|+
literal|3
operator|)
operator|)
operator|+
name|bit
operator|)
expr_stmt|;
name|ret
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|run
operator|)
index|[
name|bin
operator|->
name|reg0_offset
operator|+
operator|(
name|bin
operator|->
name|reg_size
operator|*
name|regind
operator|)
index|]
expr_stmt|;
comment|/* Clear bit. */
name|mask
operator|^=
operator|(
literal|1
operator|<<
name|bit
operator|)
expr_stmt|;
name|run
operator|->
name|regs_mask
index|[
name|i
index|]
operator|=
name|mask
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
else|else
block|{
comment|/* 			 * Make a note that nothing before this element 			 * contains a free region. 			 */
name|run
operator|->
name|regs_minelm
operator|=
name|i
operator|+
literal|1
expr_stmt|;
block|}
block|}
comment|/* Not reached. */
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|arena_run_reg_dalloc
parameter_list|(
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
comment|/* 	 * To divide by a number D that is not a power of two we multiply 	 * by (2^21 / D) and then right shift by 21 positions. 	 * 	 *   X / D 	 * 	 * becomes 	 * 	 *   (X * size_invs[(D>> QUANTUM_2POW_MIN) - 3])>> SIZE_INV_SHIFT 	 */
define|#
directive|define
name|SIZE_INV_SHIFT
value|21
define|#
directive|define
name|SIZE_INV
parameter_list|(
name|s
parameter_list|)
value|(((1<< SIZE_INV_SHIFT) / (s<< QUANTUM_2POW_MIN)) + 1)
specifier|static
specifier|const
name|unsigned
name|size_invs
index|[]
init|=
block|{
name|SIZE_INV
argument_list|(
literal|3
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|4
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|5
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|6
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|7
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|8
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|9
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|10
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|11
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|12
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|13
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|14
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|15
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|16
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|17
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|18
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|19
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|20
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|21
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|22
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|23
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|24
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|25
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|26
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|27
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|28
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|29
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|30
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|31
argument_list|)
if|#
directive|if
operator|(
name|QUANTUM_2POW_MIN
operator|<
literal|4
operator|)
block|,
name|SIZE_INV
argument_list|(
literal|32
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|33
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|34
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|35
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|36
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|37
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|38
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|39
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|40
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|41
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|42
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|43
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|44
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|45
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|46
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|47
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|48
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|49
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|50
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|51
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|52
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|53
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|54
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|55
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|56
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|57
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|58
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|59
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|60
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|61
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|62
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|63
argument_list|)
endif|#
directive|endif
block|}
decl_stmt|;
name|unsigned
name|diff
decl_stmt|,
name|regind
decl_stmt|,
name|elm
decl_stmt|,
name|bit
decl_stmt|;
name|assert
argument_list|(
name|run
operator|->
name|magic
operator|==
name|ARENA_RUN_MAGIC
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|size_invs
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
operator|)
operator|+
literal|3
operator|>=
operator|(
name|SMALL_MAX_DEFAULT
operator|>>
name|QUANTUM_2POW_MIN
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Avoid doing division with a variable divisor if possible.  Using 	 * actual division here can reduce allocator throughput by over 20%! 	 */
name|diff
operator|=
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
operator|(
name|uintptr_t
operator|)
name|run
operator|-
name|bin
operator|->
name|reg0_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size
operator|&
operator|(
name|size
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * log2_table allows fast division of a power of two in the 		 * [1..128] range. 		 * 		 * (x / divisor) becomes (x>> log2_table[divisor - 1]). 		 */
specifier|static
specifier|const
name|unsigned
name|char
name|log2_table
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|2
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|5
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|6
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|7
block|}
decl_stmt|;
if|if
condition|(
name|size
operator|<=
literal|128
condition|)
name|regind
operator|=
operator|(
name|diff
operator|>>
name|log2_table
index|[
name|size
operator|-
literal|1
index|]
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|<=
literal|32768
condition|)
name|regind
operator|=
name|diff
operator|>>
operator|(
literal|8
operator|+
name|log2_table
index|[
operator|(
name|size
operator|>>
literal|8
operator|)
operator|-
literal|1
index|]
operator|)
expr_stmt|;
else|else
block|{
comment|/* 			 * The page size is too large for us to use the lookup 			 * table.  Use real division. 			 */
name|regind
operator|=
name|diff
operator|/
name|size
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|size
operator|<=
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|size_invs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
operator|)
operator|<<
name|QUANTUM_2POW_MIN
operator|)
operator|+
literal|2
condition|)
block|{
name|regind
operator|=
name|size_invs
index|[
operator|(
name|size
operator|>>
name|QUANTUM_2POW_MIN
operator|)
operator|-
literal|3
index|]
operator|*
name|diff
expr_stmt|;
name|regind
operator|>>=
name|SIZE_INV_SHIFT
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * size_invs isn't large enough to handle this size class, so 		 * calculate regind using actual division.  This only happens 		 * if the user increases small_max via the 'S' runtime 		 * configuration option. 		 */
name|regind
operator|=
name|diff
operator|/
name|size
expr_stmt|;
block|}
empty_stmt|;
name|assert
argument_list|(
name|diff
operator|==
name|regind
operator|*
name|size
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|regind
operator|<
name|bin
operator|->
name|nregs
argument_list|)
expr_stmt|;
name|elm
operator|=
name|regind
operator|>>
operator|(
name|SIZEOF_INT_2POW
operator|+
literal|3
operator|)
expr_stmt|;
if|if
condition|(
name|elm
operator|<
name|run
operator|->
name|regs_minelm
condition|)
name|run
operator|->
name|regs_minelm
operator|=
name|elm
expr_stmt|;
name|bit
operator|=
name|regind
operator|-
operator|(
name|elm
operator|<<
operator|(
name|SIZEOF_INT_2POW
operator|+
literal|3
operator|)
operator|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|run
operator|->
name|regs_mask
index|[
name|elm
index|]
operator|&
operator|(
literal|1
operator|<<
name|bit
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|run
operator|->
name|regs_mask
index|[
name|elm
index|]
operator||=
operator|(
literal|1
operator|<<
name|bit
operator|)
expr_stmt|;
undef|#
directive|undef
name|SIZE_INV
undef|#
directive|undef
name|SIZE_INV_SHIFT
block|}
end_function

begin_function
specifier|static
name|void
name|arena_run_split
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|unsigned
name|run_ind
decl_stmt|,
name|map_offset
decl_stmt|,
name|total_pages
decl_stmt|,
name|need_pages
decl_stmt|,
name|rem_pages
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|run
argument_list|)
expr_stmt|;
name|run_ind
operator|=
call|(
name|unsigned
call|)
argument_list|(
operator|(
operator|(
name|uintptr_t
operator|)
name|run
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|pagesize_2pow
argument_list|)
expr_stmt|;
name|total_pages
operator|=
name|chunk
operator|->
name|map
index|[
name|run_ind
index|]
operator|.
name|npages
expr_stmt|;
name|need_pages
operator|=
operator|(
name|size
operator|>>
name|pagesize_2pow
operator|)
expr_stmt|;
name|assert
argument_list|(
name|need_pages
operator|<=
name|total_pages
argument_list|)
expr_stmt|;
name|rem_pages
operator|=
name|total_pages
operator|-
name|need_pages
expr_stmt|;
comment|/* Split enough pages from the front of run to fit allocation size. */
name|map_offset
operator|=
name|run_ind
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|need_pages
condition|;
name|i
operator|++
control|)
block|{
name|chunk
operator|->
name|map
index|[
name|map_offset
operator|+
name|i
index|]
operator|.
name|npages
operator|=
name|need_pages
expr_stmt|;
name|chunk
operator|->
name|map
index|[
name|map_offset
operator|+
name|i
index|]
operator|.
name|pos
operator|=
name|i
expr_stmt|;
block|}
comment|/* Keep track of trailing unused pages for later use. */
if|if
condition|(
name|rem_pages
operator|>
literal|0
condition|)
block|{
comment|/* Update map for trailing pages. */
name|map_offset
operator|+=
name|need_pages
expr_stmt|;
name|chunk
operator|->
name|map
index|[
name|map_offset
index|]
operator|.
name|npages
operator|=
name|rem_pages
expr_stmt|;
name|chunk
operator|->
name|map
index|[
name|map_offset
index|]
operator|.
name|pos
operator|=
name|POS_FREE
expr_stmt|;
name|chunk
operator|->
name|map
index|[
name|map_offset
operator|+
name|rem_pages
operator|-
literal|1
index|]
operator|.
name|npages
operator|=
name|rem_pages
expr_stmt|;
name|chunk
operator|->
name|map
index|[
name|map_offset
operator|+
name|rem_pages
operator|-
literal|1
index|]
operator|.
name|pos
operator|=
name|POS_FREE
expr_stmt|;
block|}
name|chunk
operator|->
name|pages_used
operator|+=
name|need_pages
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|arena_chunk_t
modifier|*
name|arena_chunk_alloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
if|if
condition|(
name|arena
operator|->
name|spare
operator|!=
name|NULL
condition|)
block|{
name|chunk
operator|=
name|arena
operator|->
name|spare
expr_stmt|;
name|arena
operator|->
name|spare
operator|=
name|NULL
expr_stmt|;
name|RB_INSERT
argument_list|(
name|arena_chunk_tree_s
argument_list|,
operator|&
name|arena
operator|->
name|chunks
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|chunk_alloc
argument_list|(
name|chunk_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|mapped
operator|+=
name|chunk_size
expr_stmt|;
endif|#
directive|endif
name|chunk
operator|->
name|arena
operator|=
name|arena
expr_stmt|;
name|RB_INSERT
argument_list|(
name|arena_chunk_tree_s
argument_list|,
operator|&
name|arena
operator|->
name|chunks
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
comment|/* 		 * Claim that no pages are in use, since the header is merely 		 * overhead. 		 */
name|chunk
operator|->
name|pages_used
operator|=
literal|0
expr_stmt|;
name|chunk
operator|->
name|max_frun_npages
operator|=
name|chunk_npages
operator|-
name|arena_chunk_header_npages
expr_stmt|;
name|chunk
operator|->
name|min_frun_ind
operator|=
name|arena_chunk_header_npages
expr_stmt|;
comment|/* 		 * Initialize enough of the map to support one maximal free run. 		 */
name|chunk
operator|->
name|map
index|[
name|arena_chunk_header_npages
index|]
operator|.
name|npages
operator|=
name|chunk_npages
operator|-
name|arena_chunk_header_npages
expr_stmt|;
name|chunk
operator|->
name|map
index|[
name|arena_chunk_header_npages
index|]
operator|.
name|pos
operator|=
name|POS_FREE
expr_stmt|;
name|chunk
operator|->
name|map
index|[
name|chunk_npages
operator|-
literal|1
index|]
operator|.
name|npages
operator|=
name|chunk_npages
operator|-
name|arena_chunk_header_npages
expr_stmt|;
name|chunk
operator|->
name|map
index|[
name|chunk_npages
operator|-
literal|1
index|]
operator|.
name|pos
operator|=
name|POS_FREE
expr_stmt|;
block|}
return|return
operator|(
name|chunk
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_chunk_dealloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|)
block|{
comment|/* 	 * Remove chunk from the chunk tree, regardless of whether this chunk 	 * will be cached, so that the arena does not use it. 	 */
name|RB_REMOVE
argument_list|(
name|arena_chunk_tree_s
argument_list|,
operator|&
name|chunk
operator|->
name|arena
operator|->
name|chunks
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_hint
operator|==
name|false
condition|)
block|{
if|if
condition|(
name|arena
operator|->
name|spare
operator|!=
name|NULL
condition|)
block|{
name|chunk_dealloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|arena
operator|->
name|spare
argument_list|,
name|chunk_size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|mapped
operator|-=
name|chunk_size
expr_stmt|;
endif|#
directive|endif
block|}
name|arena
operator|->
name|spare
operator|=
name|chunk
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|arena
operator|->
name|spare
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|chunk_dealloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|chunk
argument_list|,
name|chunk_size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|mapped
operator|-=
name|chunk_size
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|arena_bin_run_promote
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|)
block|{
name|assert
argument_list|(
name|bin
operator|==
name|run
operator|->
name|bin
argument_list|)
expr_stmt|;
comment|/* Promote. */
name|assert
argument_list|(
name|run
operator|->
name|free_min
operator|>
name|run
operator|->
name|nfree
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|run
operator|->
name|quartile
operator|<
name|RUN_Q100
argument_list|)
expr_stmt|;
name|run
operator|->
name|quartile
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|bin
operator|->
name|stats
operator|.
name|npromote
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* Re-file run. */
switch|switch
condition|(
name|run
operator|->
name|quartile
condition|)
block|{
case|case
name|RUN_QINIT
case|:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|RUN_Q0
case|:
name|qr_before_insert
argument_list|(
name|arena_bin_link
argument_list|(
operator|&
name|bin
operator|->
name|runs0
argument_list|)
argument_list|,
name|run
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|run
operator|->
name|free_max
operator|=
name|bin
operator|->
name|nregs
operator|-
literal|1
expr_stmt|;
name|run
operator|->
name|free_min
operator|=
operator|(
name|bin
operator|->
name|nregs
operator|>>
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
name|assert
argument_list|(
name|run
operator|->
name|nfree
operator|<=
name|run
operator|->
name|free_max
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|run
operator|->
name|nfree
operator|>=
name|run
operator|->
name|free_min
argument_list|)
expr_stmt|;
break|break;
case|case
name|RUN_Q25
case|:
name|qr_remove
argument_list|(
name|run
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|qr_before_insert
argument_list|(
name|arena_bin_link
argument_list|(
operator|&
name|bin
operator|->
name|runs25
argument_list|)
argument_list|,
name|run
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|run
operator|->
name|free_max
operator|=
operator|(
operator|(
name|bin
operator|->
name|nregs
operator|>>
literal|2
operator|)
operator|*
literal|3
operator|)
operator|-
literal|1
expr_stmt|;
name|run
operator|->
name|free_min
operator|=
operator|(
name|bin
operator|->
name|nregs
operator|>>
literal|2
operator|)
operator|+
literal|1
expr_stmt|;
name|assert
argument_list|(
name|run
operator|->
name|nfree
operator|<=
name|run
operator|->
name|free_max
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|run
operator|->
name|nfree
operator|>=
name|run
operator|->
name|free_min
argument_list|)
expr_stmt|;
break|break;
case|case
name|RUN_Q50
case|:
name|qr_remove
argument_list|(
name|run
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|qr_before_insert
argument_list|(
name|arena_bin_link
argument_list|(
operator|&
name|bin
operator|->
name|runs50
argument_list|)
argument_list|,
name|run
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|run
operator|->
name|free_max
operator|=
operator|(
name|bin
operator|->
name|nregs
operator|>>
literal|1
operator|)
operator|-
literal|1
expr_stmt|;
name|run
operator|->
name|free_min
operator|=
literal|1
expr_stmt|;
name|assert
argument_list|(
name|run
operator|->
name|nfree
operator|<=
name|run
operator|->
name|free_max
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|run
operator|->
name|nfree
operator|>=
name|run
operator|->
name|free_min
argument_list|)
expr_stmt|;
break|break;
case|case
name|RUN_Q75
case|:
comment|/* 			 * Skip RUN_Q75 during promotion from RUN_Q50. 			 * Separate handling of RUN_Q75 and RUN_Q100 allows us 			 * to keep completely full runs in RUN_Q100, thus 			 * guaranteeing that runs in RUN_Q75 are only mostly 			 * full.  This provides a method for avoiding a linear 			 * search for non-full runs, which avoids some 			 * pathological edge cases. 			 */
name|run
operator|->
name|quartile
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
comment|/* 			 * Count as a double promotion, in order to keep 			 * promotions and demotions symmetric. 			 */
name|bin
operator|->
name|stats
operator|.
name|npromote
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* Fall through. */
case|case
name|RUN_Q100
case|:
name|qr_remove
argument_list|(
name|run
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|bin
operator|->
name|runcur
operator|==
name|run
argument_list|)
expr_stmt|;
name|bin
operator|->
name|runcur
operator|=
name|NULL
expr_stmt|;
name|run
operator|->
name|free_max
operator|=
literal|0
expr_stmt|;
name|run
operator|->
name|free_min
operator|=
literal|0
expr_stmt|;
name|assert
argument_list|(
name|run
operator|->
name|nfree
operator|<=
name|run
operator|->
name|free_max
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|run
operator|->
name|nfree
operator|>=
name|run
operator|->
name|free_min
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|arena_bin_run_demote
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|)
block|{
name|assert
argument_list|(
name|bin
operator|==
name|run
operator|->
name|bin
argument_list|)
expr_stmt|;
comment|/* Demote. */
name|assert
argument_list|(
name|run
operator|->
name|free_max
operator|<
name|run
operator|->
name|nfree
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|run
operator|->
name|quartile
operator|>
name|RUN_QINIT
argument_list|)
expr_stmt|;
name|run
operator|->
name|quartile
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|bin
operator|->
name|stats
operator|.
name|ndemote
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* Re-file run. */
switch|switch
condition|(
name|run
operator|->
name|quartile
condition|)
block|{
case|case
name|RUN_QINIT
case|:
name|qr_remove
argument_list|(
name|run
argument_list|,
name|link
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|bin
operator|->
name|stats
operator|.
name|curruns
operator|--
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bin
operator|->
name|runcur
operator|==
name|run
condition|)
name|bin
operator|->
name|runcur
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
name|run
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|arena_run_dalloc
argument_list|(
name|arena
argument_list|,
name|run
argument_list|,
name|bin
operator|->
name|run_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|RUN_Q0
case|:
name|qr_remove
argument_list|(
name|run
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|qr_before_insert
argument_list|(
name|arena_bin_link
argument_list|(
operator|&
name|bin
operator|->
name|runs0
argument_list|)
argument_list|,
name|run
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|run
operator|->
name|free_max
operator|=
name|bin
operator|->
name|nregs
operator|-
literal|1
expr_stmt|;
name|run
operator|->
name|free_min
operator|=
operator|(
name|bin
operator|->
name|nregs
operator|>>
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
name|assert
argument_list|(
name|run
operator|->
name|nfree
operator|<=
name|run
operator|->
name|free_max
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|run
operator|->
name|nfree
operator|>=
name|run
operator|->
name|free_min
argument_list|)
expr_stmt|;
break|break;
case|case
name|RUN_Q25
case|:
name|qr_remove
argument_list|(
name|run
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|qr_before_insert
argument_list|(
name|arena_bin_link
argument_list|(
operator|&
name|bin
operator|->
name|runs25
argument_list|)
argument_list|,
name|run
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|run
operator|->
name|free_max
operator|=
operator|(
operator|(
name|bin
operator|->
name|nregs
operator|>>
literal|2
operator|)
operator|*
literal|3
operator|)
operator|-
literal|1
expr_stmt|;
name|run
operator|->
name|free_min
operator|=
operator|(
name|bin
operator|->
name|nregs
operator|>>
literal|2
operator|)
operator|+
literal|1
expr_stmt|;
name|assert
argument_list|(
name|run
operator|->
name|nfree
operator|<=
name|run
operator|->
name|free_max
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|run
operator|->
name|nfree
operator|>=
name|run
operator|->
name|free_min
argument_list|)
expr_stmt|;
break|break;
case|case
name|RUN_Q50
case|:
name|qr_remove
argument_list|(
name|run
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|qr_before_insert
argument_list|(
name|arena_bin_link
argument_list|(
operator|&
name|bin
operator|->
name|runs50
argument_list|)
argument_list|,
name|run
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|run
operator|->
name|free_max
operator|=
operator|(
name|bin
operator|->
name|nregs
operator|>>
literal|1
operator|)
operator|-
literal|1
expr_stmt|;
name|run
operator|->
name|free_min
operator|=
literal|1
expr_stmt|;
name|assert
argument_list|(
name|run
operator|->
name|nfree
operator|<=
name|run
operator|->
name|free_max
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|run
operator|->
name|nfree
operator|>=
name|run
operator|->
name|free_min
argument_list|)
expr_stmt|;
break|break;
case|case
name|RUN_Q75
case|:
name|qr_before_insert
argument_list|(
name|arena_bin_link
argument_list|(
operator|&
name|bin
operator|->
name|runs75
argument_list|)
argument_list|,
name|run
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|run
operator|->
name|free_max
operator|=
operator|(
name|bin
operator|->
name|nregs
operator|>>
literal|2
operator|)
operator|-
literal|1
expr_stmt|;
name|run
operator|->
name|free_min
operator|=
literal|1
expr_stmt|;
name|assert
argument_list|(
name|run
operator|->
name|nfree
operator|<=
name|run
operator|->
name|free_max
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|run
operator|->
name|nfree
operator|>=
name|run
operator|->
name|free_min
argument_list|)
expr_stmt|;
break|break;
case|case
name|RUN_Q100
case|:
default|default:
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|arena_run_t
modifier|*
name|arena_run_alloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|arena_run_t
modifier|*
name|run
decl_stmt|;
name|unsigned
name|need_npages
decl_stmt|,
name|limit_pages
decl_stmt|,
name|compl_need_npages
decl_stmt|;
name|assert
argument_list|(
name|size
operator|<=
operator|(
name|chunk_size
operator|-
operator|(
name|arena_chunk_header_npages
operator|<<
name|pagesize_2pow
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Search through arena's chunks in address order for a free run that is 	 * large enough.  Look for the first fit. 	 */
name|need_npages
operator|=
operator|(
name|size
operator|>>
name|pagesize_2pow
operator|)
expr_stmt|;
name|limit_pages
operator|=
name|chunk_npages
operator|-
name|arena_chunk_header_npages
expr_stmt|;
name|compl_need_npages
operator|=
name|limit_pages
operator|-
name|need_npages
expr_stmt|;
name|RB_FOREACH
argument_list|(
argument|chunk
argument_list|,
argument|arena_chunk_tree_s
argument_list|,
argument|&arena->chunks
argument_list|)
block|{
comment|/* 		 * Avoid searching this chunk if there are not enough 		 * contiguous free pages for there to possibly be a large 		 * enough free run. 		 */
if|if
condition|(
name|chunk
operator|->
name|pages_used
operator|<=
name|compl_need_npages
operator|&&
name|need_npages
operator|<=
name|chunk
operator|->
name|max_frun_npages
condition|)
block|{
name|arena_chunk_map_t
modifier|*
name|mapelm
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|uint32_t
name|max_frun_npages
init|=
literal|0
decl_stmt|;
name|uint32_t
name|min_frun_ind
init|=
name|chunk_npages
decl_stmt|;
name|assert
argument_list|(
name|chunk
operator|->
name|min_frun_ind
operator|>=
name|arena_chunk_header_npages
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|chunk
operator|->
name|min_frun_ind
init|;
name|i
operator|<
name|chunk_npages
condition|;
control|)
block|{
name|mapelm
operator|=
operator|&
name|chunk
operator|->
name|map
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|mapelm
operator|->
name|pos
operator|==
name|POS_FREE
condition|)
block|{
if|if
condition|(
name|mapelm
operator|->
name|npages
operator|>=
name|need_npages
condition|)
block|{
name|run
operator|=
operator|(
name|arena_run_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|+
operator|(
name|i
operator|<<
name|pagesize_2pow
operator|)
operator|)
expr_stmt|;
comment|/* Update page map. */
name|arena_run_split
argument_list|(
name|arena
argument_list|,
name|run
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|run
operator|)
return|;
block|}
if|if
condition|(
name|mapelm
operator|->
name|npages
operator|>
name|max_frun_npages
condition|)
block|{
name|max_frun_npages
operator|=
name|mapelm
operator|->
name|npages
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|min_frun_ind
condition|)
block|{
name|min_frun_ind
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|chunk
operator|->
name|min_frun_ind
condition|)
name|chunk
operator|->
name|min_frun_ind
operator|=
name|i
expr_stmt|;
block|}
block|}
name|i
operator|+=
name|mapelm
operator|->
name|npages
expr_stmt|;
block|}
comment|/* 			 * Search failure.  Reset cached chunk->max_frun_npages. 			 * chunk->min_frun_ind was already reset above (if 			 * necessary). 			 */
name|chunk
operator|->
name|max_frun_npages
operator|=
name|max_frun_npages
expr_stmt|;
block|}
block|}
comment|/* No usable runs.  Allocate a new chunk, then try again. */
name|chunk
operator|=
name|arena_chunk_alloc
argument_list|(
name|arena
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|run
operator|=
operator|(
name|arena_run_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|+
operator|(
name|arena_chunk_header_npages
operator|<<
name|pagesize_2pow
operator|)
operator|)
expr_stmt|;
comment|/* Update page map. */
name|arena_run_split
argument_list|(
name|arena
argument_list|,
name|run
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|run
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_run_dalloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|unsigned
name|run_ind
decl_stmt|,
name|run_pages
decl_stmt|;
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|run
argument_list|)
expr_stmt|;
name|run_ind
operator|=
call|(
name|unsigned
call|)
argument_list|(
operator|(
operator|(
name|uintptr_t
operator|)
name|run
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|pagesize_2pow
argument_list|)
expr_stmt|;
name|run_pages
operator|=
operator|(
name|size
operator|>>
name|pagesize_2pow
operator|)
expr_stmt|;
name|assert
argument_list|(
name|run_pages
operator|==
name|chunk
operator|->
name|map
index|[
name|run_ind
index|]
operator|.
name|npages
argument_list|)
expr_stmt|;
comment|/* Subtract pages from count of pages used in chunk. */
name|chunk
operator|->
name|pages_used
operator|-=
name|run_pages
expr_stmt|;
comment|/* Mark run as deallocated. */
name|assert
argument_list|(
name|chunk
operator|->
name|map
index|[
name|run_ind
index|]
operator|.
name|npages
operator|==
name|run_pages
argument_list|)
expr_stmt|;
name|chunk
operator|->
name|map
index|[
name|run_ind
index|]
operator|.
name|pos
operator|=
name|POS_FREE
expr_stmt|;
name|assert
argument_list|(
name|chunk
operator|->
name|map
index|[
name|run_ind
operator|+
name|run_pages
operator|-
literal|1
index|]
operator|.
name|npages
operator|==
name|run_pages
argument_list|)
expr_stmt|;
name|chunk
operator|->
name|map
index|[
name|run_ind
operator|+
name|run_pages
operator|-
literal|1
index|]
operator|.
name|pos
operator|=
name|POS_FREE
expr_stmt|;
comment|/* 	 * Tell the kernel that we don't need the data in this run, but only if 	 * requested via runtime configuration. 	 */
if|if
condition|(
name|opt_hint
condition|)
name|madvise
argument_list|(
name|run
argument_list|,
name|size
argument_list|,
name|MADV_FREE
argument_list|)
expr_stmt|;
comment|/* Try to coalesce with neighboring runs. */
if|if
condition|(
name|run_ind
operator|>
name|arena_chunk_header_npages
operator|&&
name|chunk
operator|->
name|map
index|[
name|run_ind
operator|-
literal|1
index|]
operator|.
name|pos
operator|==
name|POS_FREE
condition|)
block|{
name|unsigned
name|prev_npages
decl_stmt|;
comment|/* Coalesce with previous run. */
name|prev_npages
operator|=
name|chunk
operator|->
name|map
index|[
name|run_ind
operator|-
literal|1
index|]
operator|.
name|npages
expr_stmt|;
name|run_ind
operator|-=
name|prev_npages
expr_stmt|;
name|assert
argument_list|(
name|chunk
operator|->
name|map
index|[
name|run_ind
index|]
operator|.
name|npages
operator|==
name|prev_npages
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|chunk
operator|->
name|map
index|[
name|run_ind
index|]
operator|.
name|pos
operator|==
name|POS_FREE
argument_list|)
expr_stmt|;
name|run_pages
operator|+=
name|prev_npages
expr_stmt|;
name|chunk
operator|->
name|map
index|[
name|run_ind
index|]
operator|.
name|npages
operator|=
name|run_pages
expr_stmt|;
name|assert
argument_list|(
name|chunk
operator|->
name|map
index|[
name|run_ind
index|]
operator|.
name|pos
operator|==
name|POS_FREE
argument_list|)
expr_stmt|;
name|chunk
operator|->
name|map
index|[
name|run_ind
operator|+
name|run_pages
operator|-
literal|1
index|]
operator|.
name|npages
operator|=
name|run_pages
expr_stmt|;
name|assert
argument_list|(
name|chunk
operator|->
name|map
index|[
name|run_ind
operator|+
name|run_pages
operator|-
literal|1
index|]
operator|.
name|pos
operator|==
name|POS_FREE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|run_ind
operator|+
name|run_pages
operator|<
name|chunk_npages
operator|&&
name|chunk
operator|->
name|map
index|[
name|run_ind
operator|+
name|run_pages
index|]
operator|.
name|pos
operator|==
name|POS_FREE
condition|)
block|{
name|unsigned
name|next_npages
decl_stmt|;
comment|/* Coalesce with next run. */
name|next_npages
operator|=
name|chunk
operator|->
name|map
index|[
name|run_ind
operator|+
name|run_pages
index|]
operator|.
name|npages
expr_stmt|;
name|run_pages
operator|+=
name|next_npages
expr_stmt|;
name|assert
argument_list|(
name|chunk
operator|->
name|map
index|[
name|run_ind
operator|+
name|run_pages
operator|-
literal|1
index|]
operator|.
name|npages
operator|==
name|next_npages
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|chunk
operator|->
name|map
index|[
name|run_ind
operator|+
name|run_pages
operator|-
literal|1
index|]
operator|.
name|pos
operator|==
name|POS_FREE
argument_list|)
expr_stmt|;
name|chunk
operator|->
name|map
index|[
name|run_ind
index|]
operator|.
name|npages
operator|=
name|run_pages
expr_stmt|;
name|chunk
operator|->
name|map
index|[
name|run_ind
index|]
operator|.
name|pos
operator|=
name|POS_FREE
expr_stmt|;
name|chunk
operator|->
name|map
index|[
name|run_ind
operator|+
name|run_pages
operator|-
literal|1
index|]
operator|.
name|npages
operator|=
name|run_pages
expr_stmt|;
name|assert
argument_list|(
name|chunk
operator|->
name|map
index|[
name|run_ind
operator|+
name|run_pages
operator|-
literal|1
index|]
operator|.
name|pos
operator|==
name|POS_FREE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chunk
operator|->
name|map
index|[
name|run_ind
index|]
operator|.
name|npages
operator|>
name|chunk
operator|->
name|max_frun_npages
condition|)
name|chunk
operator|->
name|max_frun_npages
operator|=
name|chunk
operator|->
name|map
index|[
name|run_ind
index|]
operator|.
name|npages
expr_stmt|;
if|if
condition|(
name|run_ind
operator|<
name|chunk
operator|->
name|min_frun_ind
condition|)
name|chunk
operator|->
name|min_frun_ind
operator|=
name|run_ind
expr_stmt|;
comment|/* Deallocate chunk if it is now completely unused. */
if|if
condition|(
name|chunk
operator|->
name|pages_used
operator|==
literal|0
condition|)
name|arena_chunk_dealloc
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|arena_run_t
modifier|*
name|arena_bin_nonfull_run_get
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
block|{
name|arena_run_t
modifier|*
name|run
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|remainder
decl_stmt|;
comment|/* Look for a usable run. */
if|if
condition|(
operator|(
name|run
operator|=
name|qr_next
argument_list|(
name|arena_bin_link
argument_list|(
operator|&
name|bin
operator|->
name|runs50
argument_list|)
argument_list|,
name|link
argument_list|)
operator|)
operator|!=
name|arena_bin_link
argument_list|(
operator|&
name|bin
operator|->
name|runs50
argument_list|)
operator|||
operator|(
name|run
operator|=
name|qr_next
argument_list|(
name|arena_bin_link
argument_list|(
operator|&
name|bin
operator|->
name|runs25
argument_list|)
argument_list|,
name|link
argument_list|)
operator|)
operator|!=
name|arena_bin_link
argument_list|(
operator|&
name|bin
operator|->
name|runs25
argument_list|)
operator|||
operator|(
name|run
operator|=
name|qr_next
argument_list|(
name|arena_bin_link
argument_list|(
operator|&
name|bin
operator|->
name|runs0
argument_list|)
argument_list|,
name|link
argument_list|)
operator|)
operator|!=
name|arena_bin_link
argument_list|(
operator|&
name|bin
operator|->
name|runs0
argument_list|)
operator|||
operator|(
name|run
operator|=
name|qr_next
argument_list|(
name|arena_bin_link
argument_list|(
operator|&
name|bin
operator|->
name|runs75
argument_list|)
argument_list|,
name|link
argument_list|)
operator|)
operator|!=
name|arena_bin_link
argument_list|(
operator|&
name|bin
operator|->
name|runs75
argument_list|)
condition|)
block|{
comment|/* run is guaranteed to have available space. */
name|qr_remove
argument_list|(
name|run
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
name|run
operator|)
return|;
block|}
comment|/* No existing runs have any space available. */
comment|/* Allocate a new run. */
name|run
operator|=
name|arena_run_alloc
argument_list|(
name|arena
argument_list|,
name|bin
operator|->
name|run_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|run
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Initialize run internals. */
name|qr_new
argument_list|(
name|run
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|run
operator|->
name|bin
operator|=
name|bin
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bin
operator|->
name|regs_mask_nelms
condition|;
name|i
operator|++
control|)
name|run
operator|->
name|regs_mask
index|[
name|i
index|]
operator|=
name|UINT_MAX
expr_stmt|;
name|remainder
operator|=
name|bin
operator|->
name|nregs
operator|%
operator|(
literal|1
operator|<<
operator|(
name|SIZEOF_INT_2POW
operator|+
literal|3
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|remainder
operator|!=
literal|0
condition|)
block|{
comment|/* The last element has spare bits that need to be unset. */
name|run
operator|->
name|regs_mask
index|[
name|i
index|]
operator|=
operator|(
name|UINT_MAX
operator|>>
operator|(
operator|(
literal|1
operator|<<
operator|(
name|SIZEOF_INT_2POW
operator|+
literal|3
operator|)
operator|)
operator|-
name|remainder
operator|)
operator|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|run
operator|->
name|regs_minelm
operator|=
literal|0
expr_stmt|;
name|run
operator|->
name|nfree
operator|=
name|bin
operator|->
name|nregs
expr_stmt|;
name|run
operator|->
name|quartile
operator|=
name|RUN_QINIT
expr_stmt|;
name|run
operator|->
name|free_max
operator|=
name|bin
operator|->
name|nregs
expr_stmt|;
name|run
operator|->
name|free_min
operator|=
operator|(
operator|(
name|bin
operator|->
name|nregs
operator|>>
literal|2
operator|)
operator|*
literal|3
operator|)
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
name|run
operator|->
name|magic
operator|=
name|ARENA_RUN_MAGIC
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|bin
operator|->
name|stats
operator|.
name|nruns
operator|++
expr_stmt|;
name|bin
operator|->
name|stats
operator|.
name|curruns
operator|++
expr_stmt|;
if|if
condition|(
name|bin
operator|->
name|stats
operator|.
name|curruns
operator|>
name|bin
operator|->
name|stats
operator|.
name|highruns
condition|)
name|bin
operator|->
name|stats
operator|.
name|highruns
operator|=
name|bin
operator|->
name|stats
operator|.
name|curruns
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|run
operator|)
return|;
block|}
end_function

begin_comment
comment|/* bin->runcur must have space available before this function is called. */
end_comment

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|arena_bin_malloc_easy
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|assert
argument_list|(
name|run
operator|->
name|magic
operator|==
name|ARENA_RUN_MAGIC
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|run
operator|->
name|nfree
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
name|arena_run_reg_alloc
argument_list|(
name|run
argument_list|,
name|bin
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|run
operator|->
name|nfree
operator|--
expr_stmt|;
if|if
condition|(
name|run
operator|->
name|nfree
operator|<
name|run
operator|->
name|free_min
condition|)
block|{
comment|/* Promote run to higher fullness quartile. */
name|arena_bin_run_promote
argument_list|(
name|arena
argument_list|,
name|bin
argument_list|,
name|run
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Re-fill bin->runcur, then call arena_bin_malloc_easy(). */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|arena_bin_malloc_hard
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
block|{
name|assert
argument_list|(
name|bin
operator|->
name|runcur
operator|==
name|NULL
operator|||
name|bin
operator|->
name|runcur
operator|->
name|quartile
operator|==
name|RUN_Q100
argument_list|)
expr_stmt|;
name|bin
operator|->
name|runcur
operator|=
name|arena_bin_nonfull_run_get
argument_list|(
name|arena
argument_list|,
name|bin
argument_list|)
expr_stmt|;
if|if
condition|(
name|bin
operator|->
name|runcur
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|assert
argument_list|(
name|bin
operator|->
name|runcur
operator|->
name|magic
operator|==
name|ARENA_RUN_MAGIC
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|bin
operator|->
name|runcur
operator|->
name|nfree
operator|>
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|arena_bin_malloc_easy
argument_list|(
name|arena
argument_list|,
name|bin
argument_list|,
name|bin
operator|->
name|runcur
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate bin->run_size such that it meets the following constraints:  *  *   *) bin->run_size>= min_run_size  *   *) bin->run_size<= arena_maxclass  *   *) bin->run_size<= RUN_MAX_SMALL  *   *) run header overhead<= RUN_MAX_OVRHD (or header overhead relaxed).  *  * bin->nregs, bin->regs_mask_nelms, and bin->reg0_offset are  * also calculated here, since these settings are all interdependent.  */
end_comment

begin_function
specifier|static
name|size_t
name|arena_bin_run_size_calc
parameter_list|(
name|arena_bin_t
modifier|*
name|bin
parameter_list|,
name|size_t
name|min_run_size
parameter_list|)
block|{
name|size_t
name|try_run_size
decl_stmt|,
name|good_run_size
decl_stmt|;
name|uint32_t
name|good_nregs
decl_stmt|,
name|good_mask_nelms
decl_stmt|,
name|good_reg0_offset
decl_stmt|;
name|uint32_t
name|try_nregs
decl_stmt|,
name|try_mask_nelms
decl_stmt|,
name|try_reg0_offset
decl_stmt|;
name|float
name|max_ovrhd
init|=
name|RUN_MAX_OVRHD
decl_stmt|;
name|assert
argument_list|(
name|min_run_size
operator|>=
name|pagesize
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|min_run_size
operator|<=
name|arena_maxclass
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|min_run_size
operator|<=
name|RUN_MAX_SMALL
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate known-valid settings before entering the run_size 	 * expansion loop, so that the first part of the loop always copies 	 * valid settings. 	 * 	 * The do..while loop iteratively reduces the number of regions until 	 * the run header and the regions no longer overlap.  A closed formula 	 * would be quite messy, since there is an interdependency between the 	 * header's mask length and the number of regions. 	 */
name|try_run_size
operator|=
name|min_run_size
expr_stmt|;
name|try_nregs
operator|=
operator|(
operator|(
name|try_run_size
operator|-
sizeof|sizeof
argument_list|(
name|arena_run_t
argument_list|)
operator|)
operator|/
name|bin
operator|->
name|reg_size
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* Counter-act the first line of the loop. */
do|do
block|{
name|try_nregs
operator|--
expr_stmt|;
name|try_mask_nelms
operator|=
operator|(
name|try_nregs
operator|>>
operator|(
name|SIZEOF_INT_2POW
operator|+
literal|3
operator|)
operator|)
operator|+
operator|(
operator|(
name|try_nregs
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|SIZEOF_INT_2POW
operator|+
literal|3
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|try_reg0_offset
operator|=
name|try_run_size
operator|-
operator|(
name|try_nregs
operator|*
name|bin
operator|->
name|reg_size
operator|)
expr_stmt|;
block|}
do|while
condition|(
sizeof|sizeof
argument_list|(
name|arena_run_t
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
operator|*
operator|(
name|try_mask_nelms
operator|-
literal|1
operator|)
operator|)
operator|>
name|try_reg0_offset
condition|)
do|;
comment|/* run_size expansion loop. */
do|do
block|{
comment|/* 		 * Copy valid settings before trying more aggressive settings. 		 */
name|good_run_size
operator|=
name|try_run_size
expr_stmt|;
name|good_nregs
operator|=
name|try_nregs
expr_stmt|;
name|good_mask_nelms
operator|=
name|try_mask_nelms
expr_stmt|;
name|good_reg0_offset
operator|=
name|try_reg0_offset
expr_stmt|;
comment|/* Try more aggressive settings. */
name|try_run_size
operator|+=
name|pagesize
expr_stmt|;
name|try_nregs
operator|=
operator|(
operator|(
name|try_run_size
operator|-
sizeof|sizeof
argument_list|(
name|arena_run_t
argument_list|)
operator|)
operator|/
name|bin
operator|->
name|reg_size
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* Counter-act try_nregs-- in loop. */
do|do
block|{
name|try_nregs
operator|--
expr_stmt|;
name|try_mask_nelms
operator|=
operator|(
name|try_nregs
operator|>>
operator|(
name|SIZEOF_INT_2POW
operator|+
literal|3
operator|)
operator|)
operator|+
operator|(
operator|(
name|try_nregs
operator|&
operator|(
operator|(
literal|1
operator|<<
operator|(
name|SIZEOF_INT_2POW
operator|+
literal|3
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|try_reg0_offset
operator|=
name|try_run_size
operator|-
operator|(
name|try_nregs
operator|*
name|bin
operator|->
name|reg_size
operator|)
expr_stmt|;
block|}
do|while
condition|(
sizeof|sizeof
argument_list|(
name|arena_run_t
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
operator|*
operator|(
name|try_mask_nelms
operator|-
literal|1
operator|)
operator|)
operator|>
name|try_reg0_offset
condition|)
do|;
block|}
do|while
condition|(
name|try_run_size
operator|<=
name|arena_maxclass
operator|&&
name|try_run_size
operator|<=
name|RUN_MAX_SMALL
operator|&&
name|max_ovrhd
operator|>
name|RUN_MAX_OVRHD_RELAX
operator|/
operator|(
call|(
name|float
call|)
argument_list|(
name|bin
operator|->
name|reg_size
operator|<<
literal|3
argument_list|)
operator|)
operator|&&
operator|(
call|(
name|float
call|)
argument_list|(
name|try_reg0_offset
argument_list|)
operator|)
operator|/
operator|(
call|(
name|float
call|)
argument_list|(
name|try_run_size
argument_list|)
operator|)
operator|>
name|max_ovrhd
condition|)
do|;
name|assert
argument_list|(
sizeof|sizeof
argument_list|(
name|arena_run_t
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
operator|*
operator|(
name|good_mask_nelms
operator|-
literal|1
operator|)
operator|)
operator|<=
name|good_reg0_offset
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|good_mask_nelms
operator|<<
operator|(
name|SIZEOF_INT_2POW
operator|+
literal|3
operator|)
operator|)
operator|>=
name|good_nregs
argument_list|)
expr_stmt|;
comment|/* Copy final settings. */
name|bin
operator|->
name|run_size
operator|=
name|good_run_size
expr_stmt|;
name|bin
operator|->
name|nregs
operator|=
name|good_nregs
expr_stmt|;
name|bin
operator|->
name|regs_mask_nelms
operator|=
name|good_mask_nelms
expr_stmt|;
name|bin
operator|->
name|reg0_offset
operator|=
name|good_reg0_offset
expr_stmt|;
return|return
operator|(
name|good_run_size
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|arena_malloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|assert
argument_list|(
name|arena
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena
operator|->
name|magic
operator|==
name|ARENA_MAGIC
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|QUANTUM_CEILING
argument_list|(
name|size
argument_list|)
operator|<=
name|arena_maxclass
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
name|bin_maxclass
condition|)
block|{
name|arena_bin_t
modifier|*
name|bin
decl_stmt|;
name|arena_run_t
modifier|*
name|run
decl_stmt|;
comment|/* Small allocation. */
if|if
condition|(
name|size
operator|<
name|small_min
condition|)
block|{
comment|/* Tiny. */
name|size
operator|=
name|pow2_ceil
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|bin
operator|=
operator|&
name|arena
operator|->
name|bins
index|[
name|ffs
argument_list|(
call|(
name|int
call|)
argument_list|(
name|size
operator|>>
operator|(
name|TINY_MIN_2POW
operator|+
literal|1
operator|)
argument_list|)
argument_list|)
index|]
expr_stmt|;
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|NDEBUG
argument_list|)
operator|||
name|defined
argument_list|(
name|MALLOC_STATS
argument_list|)
operator|)
comment|/* 			 * Bin calculation is always correct, but we may need 			 * to fix size for the purposes of assertions and/or 			 * stats accuracy. 			 */
if|if
condition|(
name|size
operator|<
operator|(
literal|1
operator|<<
name|TINY_MIN_2POW
operator|)
condition|)
name|size
operator|=
operator|(
literal|1
operator|<<
name|TINY_MIN_2POW
operator|)
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|size
operator|<=
name|small_max
condition|)
block|{
comment|/* Quantum-spaced. */
name|size
operator|=
name|QUANTUM_CEILING
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|bin
operator|=
operator|&
name|arena
operator|->
name|bins
index|[
name|ntbins
operator|+
operator|(
name|size
operator|>>
name|opt_quantum_2pow
operator|)
operator|-
literal|1
index|]
expr_stmt|;
block|}
else|else
block|{
comment|/* Sub-page. */
name|size
operator|=
name|pow2_ceil
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|bin
operator|=
operator|&
name|arena
operator|->
name|bins
index|[
name|ntbins
operator|+
name|nqbins
operator|+
operator|(
name|ffs
argument_list|(
call|(
name|int
call|)
argument_list|(
name|size
operator|>>
name|opt_small_max_2pow
argument_list|)
argument_list|)
operator|-
literal|2
operator|)
index|]
expr_stmt|;
block|}
name|assert
argument_list|(
name|size
operator|==
name|bin
operator|->
name|reg_size
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|arena
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|run
operator|=
name|bin
operator|->
name|runcur
operator|)
operator|!=
name|NULL
condition|)
name|ret
operator|=
name|arena_bin_malloc_easy
argument_list|(
name|arena
argument_list|,
name|bin
argument_list|,
name|run
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|arena_bin_malloc_hard
argument_list|(
name|arena
argument_list|,
name|bin
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|bin
operator|->
name|stats
operator|.
name|nrequests
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|nmalloc_small
operator|++
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
name|arena
operator|->
name|stats
operator|.
name|allocated_small
operator|+=
name|size
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* Large allocation. */
name|size
operator|=
name|PAGE_CEILING
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|arena
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|void
operator|*
operator|)
name|arena_run_alloc
argument_list|(
name|arena
argument_list|,
name|size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|nmalloc_large
operator|++
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
name|arena
operator|->
name|stats
operator|.
name|allocated_large
operator|+=
name|size
expr_stmt|;
endif|#
directive|endif
block|}
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_junk
operator|&&
name|ret
operator|!=
name|NULL
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0xa5
argument_list|,
name|size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opt_zero
operator|&&
name|ret
operator|!=
name|NULL
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the size of the allocation pointed to by ptr. */
end_comment

begin_function
specifier|static
name|size_t
name|arena_salloc
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|size_t
name|ret
decl_stmt|;
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|uint32_t
name|pageind
decl_stmt|;
name|arena_chunk_map_t
name|mapelm
decl_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
operator|!=
name|ptr
argument_list|)
expr_stmt|;
comment|/* 	 * No arena data structures that we query here can change in a way that 	 * affects this function, so we don't need to lock. 	 */
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|pageind
operator|=
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|pagesize_2pow
operator|)
expr_stmt|;
name|mapelm
operator|=
name|chunk
operator|->
name|map
index|[
name|pageind
index|]
expr_stmt|;
if|if
condition|(
name|mapelm
operator|.
name|pos
operator|!=
literal|0
operator|||
name|ptr
operator|!=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|+
operator|(
name|pageind
operator|<<
name|pagesize_2pow
operator|)
condition|)
block|{
name|arena_run_t
modifier|*
name|run
decl_stmt|;
name|pageind
operator|-=
name|mapelm
operator|.
name|pos
expr_stmt|;
name|run
operator|=
operator|(
name|arena_run_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|chunk
operator|)
index|[
name|pageind
operator|<<
name|pagesize_2pow
index|]
expr_stmt|;
name|assert
argument_list|(
name|run
operator|->
name|magic
operator|==
name|ARENA_RUN_MAGIC
argument_list|)
expr_stmt|;
name|ret
operator|=
name|run
operator|->
name|bin
operator|->
name|reg_size
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|mapelm
operator|.
name|npages
operator|<<
name|pagesize_2pow
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|arena_ralloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|oldsize
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
comment|/* Avoid moving the allocation if the size class would not change. */
if|if
condition|(
name|size
operator|<
name|small_min
condition|)
block|{
if|if
condition|(
name|oldsize
operator|<
name|small_min
operator|&&
name|ffs
argument_list|(
call|(
name|int
call|)
argument_list|(
name|pow2_ceil
argument_list|(
name|size
argument_list|)
operator|>>
operator|(
name|TINY_MIN_2POW
operator|+
literal|1
operator|)
argument_list|)
argument_list|)
operator|==
name|ffs
argument_list|(
call|(
name|int
call|)
argument_list|(
name|pow2_ceil
argument_list|(
name|oldsize
argument_list|)
operator|>>
operator|(
name|TINY_MIN_2POW
operator|+
literal|1
operator|)
argument_list|)
argument_list|)
condition|)
goto|goto
name|IN_PLACE
goto|;
block|}
elseif|else
if|if
condition|(
name|size
operator|<=
name|small_max
condition|)
block|{
if|if
condition|(
name|oldsize
operator|>=
name|small_min
operator|&&
name|oldsize
operator|<=
name|small_max
operator|&&
operator|(
name|QUANTUM_CEILING
argument_list|(
name|size
argument_list|)
operator|>>
name|opt_quantum_2pow
operator|)
operator|==
operator|(
name|QUANTUM_CEILING
argument_list|(
name|oldsize
argument_list|)
operator|>>
name|opt_quantum_2pow
operator|)
condition|)
goto|goto
name|IN_PLACE
goto|;
block|}
else|else
block|{
comment|/* 		 * We make no attempt to resize runs here, though it would be 		 * possible to do so. 		 */
if|if
condition|(
name|oldsize
operator|>
name|small_max
operator|&&
name|PAGE_CEILING
argument_list|(
name|size
argument_list|)
operator|==
name|oldsize
condition|)
goto|goto
name|IN_PLACE
goto|;
block|}
comment|/* 	 * If we get here, then size and oldsize are different enough that we 	 * need to use a different size class.  In that case, fall back to 	 * allocating new space and copying. 	 */
name|ret
operator|=
name|arena_malloc
argument_list|(
name|choose_arena
argument_list|()
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|size
operator|<
name|oldsize
condition|)
name|memcpy
argument_list|(
name|ret
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|ret
argument_list|,
name|ptr
argument_list|,
name|oldsize
argument_list|)
expr_stmt|;
name|idalloc
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
name|IN_PLACE
label|:
if|if
condition|(
name|opt_junk
operator|&&
name|size
operator|<
name|oldsize
condition|)
name|memset
argument_list|(
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|ptr
operator|)
index|[
name|size
index|]
argument_list|,
literal|0x5a
argument_list|,
name|oldsize
operator|-
name|size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opt_zero
operator|&&
name|size
operator|>
name|oldsize
condition|)
name|memset
argument_list|(
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|ptr
operator|)
index|[
name|size
index|]
argument_list|,
literal|0
argument_list|,
name|size
operator|-
name|oldsize
argument_list|)
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_dalloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|unsigned
name|pageind
decl_stmt|;
name|arena_chunk_map_t
name|mapelm
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|assert
argument_list|(
name|arena
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena
operator|->
name|magic
operator|==
name|ARENA_MAGIC
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|chunk
operator|->
name|arena
operator|==
name|arena
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
operator|!=
name|ptr
argument_list|)
expr_stmt|;
name|pageind
operator|=
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|pagesize_2pow
operator|)
expr_stmt|;
name|mapelm
operator|=
name|chunk
operator|->
name|map
index|[
name|pageind
index|]
expr_stmt|;
if|if
condition|(
name|mapelm
operator|.
name|pos
operator|!=
literal|0
operator|||
name|ptr
operator|!=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|+
operator|(
name|pageind
operator|<<
name|pagesize_2pow
operator|)
condition|)
block|{
name|arena_run_t
modifier|*
name|run
decl_stmt|;
name|arena_bin_t
modifier|*
name|bin
decl_stmt|;
comment|/* Small allocation. */
name|pageind
operator|-=
name|mapelm
operator|.
name|pos
expr_stmt|;
name|run
operator|=
operator|(
name|arena_run_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|chunk
operator|)
index|[
name|pageind
operator|<<
name|pagesize_2pow
index|]
expr_stmt|;
name|assert
argument_list|(
name|run
operator|->
name|magic
operator|==
name|ARENA_RUN_MAGIC
argument_list|)
expr_stmt|;
name|bin
operator|=
name|run
operator|->
name|bin
expr_stmt|;
name|size
operator|=
name|bin
operator|->
name|reg_size
expr_stmt|;
if|if
condition|(
name|opt_junk
condition|)
name|memset
argument_list|(
name|ptr
argument_list|,
literal|0x5a
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|arena
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|arena_run_reg_dalloc
argument_list|(
name|run
argument_list|,
name|bin
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|run
operator|->
name|nfree
operator|++
expr_stmt|;
if|if
condition|(
name|run
operator|->
name|nfree
operator|>
name|run
operator|->
name|free_max
condition|)
block|{
comment|/* Demote run to lower fullness quartile. */
name|arena_bin_run_demote
argument_list|(
name|arena
argument_list|,
name|bin
argument_list|,
name|run
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|allocated_small
operator|-=
name|size
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|ndalloc_small
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* Large allocation. */
name|size
operator|=
name|mapelm
operator|.
name|npages
operator|<<
name|pagesize_2pow
expr_stmt|;
name|assert
argument_list|(
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|)
operator|&
name|pagesize_mask
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_junk
condition|)
name|memset
argument_list|(
name|ptr
argument_list|,
literal|0x5a
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|arena
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|arena_run_dalloc
argument_list|(
name|arena
argument_list|,
operator|(
name|arena_run_t
operator|*
operator|)
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|allocated_large
operator|-=
name|size
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|ndalloc_large
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|arena_new
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|arena_bin_t
modifier|*
name|bin
decl_stmt|;
name|size_t
name|pow2_size
decl_stmt|,
name|prev_run_size
decl_stmt|;
name|malloc_mutex_init
argument_list|(
operator|&
name|arena
operator|->
name|mtx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|memset
argument_list|(
operator|&
name|arena
operator|->
name|stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|arena_stats_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize chunks. */
name|RB_INIT
argument_list|(
operator|&
name|arena
operator|->
name|chunks
argument_list|)
expr_stmt|;
name|arena
operator|->
name|spare
operator|=
name|NULL
expr_stmt|;
comment|/* Initialize bins. */
name|prev_run_size
operator|=
name|pagesize
expr_stmt|;
comment|/* (2^n)-spaced tiny bins. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ntbins
condition|;
name|i
operator|++
control|)
block|{
name|bin
operator|=
operator|&
name|arena
operator|->
name|bins
index|[
name|i
index|]
expr_stmt|;
name|bin
operator|->
name|runcur
operator|=
name|NULL
expr_stmt|;
name|qr_new
argument_list|(
name|arena_bin_link
argument_list|(
operator|&
name|bin
operator|->
name|runs0
argument_list|)
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|qr_new
argument_list|(
name|arena_bin_link
argument_list|(
operator|&
name|bin
operator|->
name|runs25
argument_list|)
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|qr_new
argument_list|(
name|arena_bin_link
argument_list|(
operator|&
name|bin
operator|->
name|runs50
argument_list|)
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|qr_new
argument_list|(
name|arena_bin_link
argument_list|(
operator|&
name|bin
operator|->
name|runs75
argument_list|)
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|bin
operator|->
name|reg_size
operator|=
operator|(
literal|1
operator|<<
operator|(
name|TINY_MIN_2POW
operator|+
name|i
operator|)
operator|)
expr_stmt|;
name|prev_run_size
operator|=
name|arena_bin_run_size_calc
argument_list|(
name|bin
argument_list|,
name|prev_run_size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|memset
argument_list|(
operator|&
name|bin
operator|->
name|stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|malloc_bin_stats_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Quantum-spaced bins. */
for|for
control|(
init|;
name|i
operator|<
name|ntbins
operator|+
name|nqbins
condition|;
name|i
operator|++
control|)
block|{
name|bin
operator|=
operator|&
name|arena
operator|->
name|bins
index|[
name|i
index|]
expr_stmt|;
name|bin
operator|->
name|runcur
operator|=
name|NULL
expr_stmt|;
name|qr_new
argument_list|(
name|arena_bin_link
argument_list|(
operator|&
name|bin
operator|->
name|runs0
argument_list|)
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|qr_new
argument_list|(
name|arena_bin_link
argument_list|(
operator|&
name|bin
operator|->
name|runs25
argument_list|)
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|qr_new
argument_list|(
name|arena_bin_link
argument_list|(
operator|&
name|bin
operator|->
name|runs50
argument_list|)
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|qr_new
argument_list|(
name|arena_bin_link
argument_list|(
operator|&
name|bin
operator|->
name|runs75
argument_list|)
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|bin
operator|->
name|reg_size
operator|=
name|quantum
operator|*
operator|(
name|i
operator|-
name|ntbins
operator|+
literal|1
operator|)
expr_stmt|;
name|pow2_size
operator|=
name|pow2_ceil
argument_list|(
name|quantum
operator|*
operator|(
name|i
operator|-
name|ntbins
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|prev_run_size
operator|=
name|arena_bin_run_size_calc
argument_list|(
name|bin
argument_list|,
name|prev_run_size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|memset
argument_list|(
operator|&
name|bin
operator|->
name|stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|malloc_bin_stats_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* (2^n)-spaced sub-page bins. */
for|for
control|(
init|;
name|i
operator|<
name|ntbins
operator|+
name|nqbins
operator|+
name|nsbins
condition|;
name|i
operator|++
control|)
block|{
name|bin
operator|=
operator|&
name|arena
operator|->
name|bins
index|[
name|i
index|]
expr_stmt|;
name|bin
operator|->
name|runcur
operator|=
name|NULL
expr_stmt|;
name|qr_new
argument_list|(
name|arena_bin_link
argument_list|(
operator|&
name|bin
operator|->
name|runs0
argument_list|)
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|qr_new
argument_list|(
name|arena_bin_link
argument_list|(
operator|&
name|bin
operator|->
name|runs25
argument_list|)
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|qr_new
argument_list|(
name|arena_bin_link
argument_list|(
operator|&
name|bin
operator|->
name|runs50
argument_list|)
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|qr_new
argument_list|(
name|arena_bin_link
argument_list|(
operator|&
name|bin
operator|->
name|runs75
argument_list|)
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|bin
operator|->
name|reg_size
operator|=
operator|(
name|small_max
operator|<<
operator|(
name|i
operator|-
operator|(
name|ntbins
operator|+
name|nqbins
operator|)
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
name|prev_run_size
operator|=
name|arena_bin_run_size_calc
argument_list|(
name|bin
argument_list|,
name|prev_run_size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|memset
argument_list|(
operator|&
name|bin
operator|->
name|stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|malloc_bin_stats_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
name|arena
operator|->
name|magic
operator|=
name|ARENA_MAGIC
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Create a new arena and insert it into the arenas array at index ind. */
end_comment

begin_function
specifier|static
name|arena_t
modifier|*
name|arenas_extend
parameter_list|(
name|unsigned
name|ind
parameter_list|)
block|{
name|arena_t
modifier|*
name|ret
decl_stmt|;
comment|/* Allocate enough space for trailing bins. */
name|ret
operator|=
operator|(
name|arena_t
operator|*
operator|)
name|base_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arena_t
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|arena_bin_t
argument_list|)
operator|*
operator|(
name|ntbins
operator|+
name|nqbins
operator|+
name|nsbins
operator|-
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
operator|&&
name|arena_new
argument_list|(
name|ret
argument_list|)
operator|==
name|false
condition|)
block|{
name|arenas
index|[
name|ind
index|]
operator|=
name|ret
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* Only reached if there is an OOM error. */
comment|/* 	 * OOM here is quite inconvenient to propagate, since dealing with it 	 * would require a check for failure in the fast path.  Instead, punt 	 * by using arenas[0].  In practice, this is an extremely unlikely 	 * failure. 	 */
name|_malloc_message
argument_list|(
name|_getprogname
argument_list|()
argument_list|,
literal|": (malloc) Error initializing arena\n"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_abort
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|arenas
index|[
literal|0
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * End arena.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin general internal functions.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|huge_malloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|size_t
name|csize
decl_stmt|;
name|chunk_node_t
modifier|*
name|node
decl_stmt|;
comment|/* Allocate one or more contiguous chunks for this request. */
name|csize
operator|=
name|CHUNK_CEILING
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|csize
operator|==
literal|0
condition|)
block|{
comment|/* size is large enough to cause size_t wrap-around. */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Allocate a chunk node with which to track the chunk. */
name|node
operator|=
name|base_chunk_node_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ret
operator|=
name|chunk_alloc
argument_list|(
name|csize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
name|base_chunk_node_dealloc
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Insert node into huge. */
name|node
operator|->
name|chunk
operator|=
name|ret
expr_stmt|;
name|node
operator|->
name|size
operator|=
name|csize
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
name|RB_INSERT
argument_list|(
name|chunk_tree_s
argument_list|,
operator|&
name|huge
argument_list|,
name|node
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|huge_nmalloc
operator|++
expr_stmt|;
name|huge_allocated
operator|+=
name|csize
expr_stmt|;
endif|#
directive|endif
name|malloc_mutex_unlock
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_junk
operator|&&
name|ret
operator|!=
name|NULL
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0xa5
argument_list|,
name|csize
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opt_zero
operator|&&
name|ret
operator|!=
name|NULL
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|csize
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|huge_ralloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|oldsize
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
comment|/* Avoid moving the allocation if the size class would not change. */
if|if
condition|(
name|oldsize
operator|>
name|arena_maxclass
operator|&&
name|CHUNK_CEILING
argument_list|(
name|size
argument_list|)
operator|==
name|CHUNK_CEILING
argument_list|(
name|oldsize
argument_list|)
condition|)
return|return
operator|(
name|ptr
operator|)
return|;
comment|/* 	 * If we get here, then size and oldsize are different enough that we 	 * need to use a different size class.  In that case, fall back to 	 * allocating new space and copying. 	 */
name|ret
operator|=
name|huge_malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
operator|==
name|ptr
condition|)
block|{
comment|/* The old allocation is a chunk. */
if|if
condition|(
name|size
operator|<
name|oldsize
condition|)
name|memcpy
argument_list|(
name|ret
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|ret
argument_list|,
name|ptr
argument_list|,
name|oldsize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The old allocation is a region. */
name|assert
argument_list|(
name|oldsize
operator|<
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|ptr
argument_list|,
name|oldsize
argument_list|)
expr_stmt|;
block|}
name|idalloc
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|huge_dalloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|chunk_node_t
name|key
decl_stmt|;
name|chunk_node_t
modifier|*
name|node
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
comment|/* Extract from tree of huge allocations. */
name|key
operator|.
name|chunk
operator|=
name|ptr
expr_stmt|;
name|node
operator|=
name|RB_FIND
argument_list|(
name|chunk_tree_s
argument_list|,
operator|&
name|huge
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|node
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|node
operator|->
name|chunk
operator|==
name|ptr
argument_list|)
expr_stmt|;
name|RB_REMOVE
argument_list|(
name|chunk_tree_s
argument_list|,
operator|&
name|huge
argument_list|,
name|node
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
comment|/* Update counters. */
name|huge_ndalloc
operator|++
expr_stmt|;
name|huge_allocated
operator|-=
name|node
operator|->
name|size
expr_stmt|;
endif|#
directive|endif
name|malloc_mutex_unlock
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
comment|/* Unmap chunk. */
ifdef|#
directive|ifdef
name|USE_BRK
if|if
condition|(
name|opt_junk
condition|)
name|memset
argument_list|(
name|node
operator|->
name|chunk
argument_list|,
literal|0x5a
argument_list|,
name|node
operator|->
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|chunk_dealloc
argument_list|(
name|node
operator|->
name|chunk
argument_list|,
name|node
operator|->
name|size
argument_list|)
expr_stmt|;
name|base_chunk_node_dealloc
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|imalloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|assert
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
name|arena_maxclass
condition|)
name|ret
operator|=
name|arena_malloc
argument_list|(
name|choose_arena
argument_list|()
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|huge_malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|ipalloc
parameter_list|(
name|size_t
name|alignment
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|size_t
name|alloc_size
decl_stmt|;
comment|/* 	 * Take advantage of the fact that for each size class, every object is 	 * aligned at the smallest power of two that is non-zero in the base 	 * two representation of the size.  For example: 	 * 	 *   Size |   Base 2 | Minimum alignment 	 *   -----+----------+------------------ 	 *     96 |  1100000 |  32 	 *    144 | 10100000 |  32 	 *    192 | 11000000 |  64 	 * 	 * Depending on runtime settings, it is possible that arena_malloc() 	 * will further round up to a power of two, but that never causes 	 * correctness issues. 	 */
name|alloc_size
operator|=
operator|(
name|size
operator|+
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|)
operator|&
operator|(
operator|-
name|alignment
operator|)
expr_stmt|;
if|if
condition|(
name|alloc_size
operator|<
name|size
condition|)
block|{
comment|/* size_t overflow. */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|alloc_size
operator|<=
name|arena_maxclass
condition|)
name|ret
operator|=
name|arena_malloc
argument_list|(
name|choose_arena
argument_list|()
argument_list|,
name|alloc_size
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|alignment
operator|<=
name|chunk_size
condition|)
name|ret
operator|=
name|huge_malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
else|else
block|{
name|size_t
name|chunksize
decl_stmt|,
name|offset
decl_stmt|;
name|chunk_node_t
modifier|*
name|node
decl_stmt|;
comment|/* 			 * This allocation requires alignment that is even 			 * larger than chunk alignment.  This means that 			 * huge_malloc() isn't good enough. 			 * 			 * Allocate almost twice as many chunks as are demanded 			 * by the size or alignment, in order to assure the 			 * alignment can be achieved, then unmap leading and 			 * trailing chunks. 			 */
name|chunksize
operator|=
name|CHUNK_CEILING
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>=
name|alignment
condition|)
name|alloc_size
operator|=
name|chunksize
operator|+
name|alignment
operator|-
name|chunk_size
expr_stmt|;
else|else
name|alloc_size
operator|=
operator|(
name|alignment
operator|<<
literal|1
operator|)
operator|-
name|chunk_size
expr_stmt|;
comment|/* 			 * Allocate a chunk node with which to track the chunk. 			 */
name|node
operator|=
name|base_chunk_node_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ret
operator|=
name|chunk_alloc
argument_list|(
name|alloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
name|base_chunk_node_dealloc
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|offset
operator|=
operator|(
name|uintptr_t
operator|)
name|ret
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
expr_stmt|;
name|assert
argument_list|(
name|offset
operator|%
name|chunk_size
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|offset
operator|<
name|alloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
block|{
comment|/* Trim trailing space. */
name|chunk_dealloc
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ret
operator|+
name|chunksize
operator|)
argument_list|,
name|alloc_size
operator|-
name|chunksize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|trailsize
decl_stmt|;
comment|/* Trim leading space. */
name|chunk_dealloc
argument_list|(
name|ret
argument_list|,
name|alignment
operator|-
name|offset
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ret
operator|+
operator|(
name|alignment
operator|-
name|offset
operator|)
operator|)
expr_stmt|;
name|trailsize
operator|=
name|alloc_size
operator|-
operator|(
name|alignment
operator|-
name|offset
operator|)
operator|-
name|chunksize
expr_stmt|;
if|if
condition|(
name|trailsize
operator|!=
literal|0
condition|)
block|{
comment|/* Trim trailing space. */
name|assert
argument_list|(
name|trailsize
operator|<
name|alloc_size
argument_list|)
expr_stmt|;
name|chunk_dealloc
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ret
operator|+
name|chunksize
operator|)
argument_list|,
name|trailsize
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Insert node into huge. */
name|node
operator|->
name|chunk
operator|=
name|ret
expr_stmt|;
name|node
operator|->
name|size
operator|=
name|chunksize
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
name|RB_INSERT
argument_list|(
name|chunk_tree_s
argument_list|,
operator|&
name|huge
argument_list|,
name|node
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|huge_allocated
operator|+=
name|size
expr_stmt|;
endif|#
directive|endif
name|malloc_mutex_unlock
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_junk
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0xa5
argument_list|,
name|chunksize
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opt_zero
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|chunksize
argument_list|)
expr_stmt|;
block|}
block|}
name|assert
argument_list|(
operator|(
operator|(
name|uintptr_t
operator|)
name|ret
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|icalloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|size
operator|<=
name|arena_maxclass
condition|)
block|{
name|ret
operator|=
name|arena_malloc
argument_list|(
name|choose_arena
argument_list|()
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The virtual memory system provides zero-filled pages, so 		 * there is no need to do so manually, unless opt_junk is 		 * enabled, in which case huge_malloc() fills huge allocations 		 * with junk. 		 */
name|ret
operator|=
name|huge_malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|opt_junk
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_BRK
elseif|else
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|ret
operator|>=
operator|(
name|uintptr_t
operator|)
name|brk_base
operator|&&
operator|(
name|uintptr_t
operator|)
name|ret
operator|<
operator|(
name|uintptr_t
operator|)
name|brk_max
condition|)
block|{
comment|/* 			 * This may be a re-used brk chunk.  Therefore, zero 			 * the memory. 			 */
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|isalloc
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|size_t
name|ret
decl_stmt|;
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk
operator|!=
name|ptr
condition|)
block|{
comment|/* Region. */
name|assert
argument_list|(
name|chunk
operator|->
name|arena
operator|->
name|magic
operator|==
name|ARENA_MAGIC
argument_list|)
expr_stmt|;
name|ret
operator|=
name|arena_salloc
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chunk_node_t
modifier|*
name|node
decl_stmt|,
name|key
decl_stmt|;
comment|/* Chunk (huge allocation). */
name|malloc_mutex_lock
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
comment|/* Extract from tree of huge allocations. */
name|key
operator|.
name|chunk
operator|=
name|__DECONST
argument_list|(
name|void
operator|*
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|node
operator|=
name|RB_FIND
argument_list|(
name|chunk_tree_s
argument_list|,
operator|&
name|huge
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|node
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ret
operator|=
name|node
operator|->
name|size
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|iralloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|size_t
name|oldsize
decl_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|oldsize
operator|=
name|isalloc
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
name|arena_maxclass
condition|)
name|ret
operator|=
name|arena_ralloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
name|oldsize
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|huge_ralloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
name|oldsize
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|idalloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk
operator|!=
name|ptr
condition|)
block|{
comment|/* Region. */
name|arena_dalloc
argument_list|(
name|chunk
operator|->
name|arena
argument_list|,
name|chunk
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
else|else
name|huge_dalloc
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|malloc_print_stats
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|opt_print_stats
condition|)
block|{
name|char
name|s
index|[
name|UMAX2S_BUFSIZE
index|]
decl_stmt|;
name|_malloc_message
argument_list|(
literal|"___ Begin malloc statistics ___\n"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|_malloc_message
argument_list|(
literal|"Assertions "
argument_list|,
ifdef|#
directive|ifdef
name|NDEBUG
literal|"disabled"
argument_list|,
else|#
directive|else
literal|"enabled"
argument_list|,
endif|#
directive|endif
literal|"\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|_malloc_message
argument_list|(
literal|"Boolean MALLOC_OPTIONS: "
argument_list|,
name|opt_abort
condition|?
literal|"A"
else|:
literal|"a"
argument_list|,
name|opt_junk
condition|?
literal|"J"
else|:
literal|"j"
argument_list|,
name|opt_hint
condition|?
literal|"H"
else|:
literal|"h"
argument_list|)
expr_stmt|;
name|_malloc_message
argument_list|(
name|opt_utrace
condition|?
literal|"PU"
else|:
literal|"Pu"
argument_list|,
name|opt_sysv
condition|?
literal|"V"
else|:
literal|"v"
argument_list|,
name|opt_xmalloc
condition|?
literal|"X"
else|:
literal|"x"
argument_list|,
name|opt_zero
condition|?
literal|"Z\n"
else|:
literal|"z\n"
argument_list|)
expr_stmt|;
name|_malloc_message
argument_list|(
literal|"CPUs: "
argument_list|,
name|umax2s
argument_list|(
name|ncpus
argument_list|,
name|s
argument_list|)
argument_list|,
literal|"\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|_malloc_message
argument_list|(
literal|"Max arenas: "
argument_list|,
name|umax2s
argument_list|(
name|narenas
argument_list|,
name|s
argument_list|)
argument_list|,
literal|"\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|_malloc_message
argument_list|(
literal|"Pointer size: "
argument_list|,
name|umax2s
argument_list|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|s
argument_list|)
argument_list|,
literal|"\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|_malloc_message
argument_list|(
literal|"Quantum size: "
argument_list|,
name|umax2s
argument_list|(
name|quantum
argument_list|,
name|s
argument_list|)
argument_list|,
literal|"\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|_malloc_message
argument_list|(
literal|"Max small size: "
argument_list|,
name|umax2s
argument_list|(
name|small_max
argument_list|,
name|s
argument_list|)
argument_list|,
literal|"\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|_malloc_message
argument_list|(
literal|"Chunk size: "
argument_list|,
name|umax2s
argument_list|(
name|chunk_size
argument_list|,
name|s
argument_list|)
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|_malloc_message
argument_list|(
literal|" (2^"
argument_list|,
name|umax2s
argument_list|(
name|opt_chunk_2pow
argument_list|,
name|s
argument_list|)
argument_list|,
literal|")\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
block|{
name|size_t
name|allocated
decl_stmt|,
name|mapped
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|arena_t
modifier|*
name|arena
decl_stmt|;
comment|/* Calculate and print allocated/mapped stats. */
comment|/* arenas. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|allocated
operator|=
literal|0
init|;
name|i
operator|<
name|narenas
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|arenas
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|malloc_mutex_lock
argument_list|(
operator|&
name|arenas
index|[
name|i
index|]
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|allocated
operator|+=
name|arenas
index|[
name|i
index|]
operator|->
name|stats
operator|.
name|allocated_small
expr_stmt|;
name|allocated
operator|+=
name|arenas
index|[
name|i
index|]
operator|->
name|stats
operator|.
name|allocated_large
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arenas
index|[
name|i
index|]
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* huge/base. */
name|malloc_mutex_lock
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
name|allocated
operator|+=
name|huge_allocated
expr_stmt|;
name|mapped
operator|=
name|stats_chunks
operator|.
name|curchunks
operator|*
name|chunk_size
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
name|mapped
operator|+=
name|base_mapped
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"Allocated: %zu, mapped: %zu\n"
argument_list|,
name|allocated
argument_list|,
name|mapped
argument_list|)
expr_stmt|;
comment|/* Print chunk stats. */
block|{
name|chunk_stats_t
name|chunks_stats
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
name|chunks_stats
operator|=
name|stats_chunks
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"chunks: nchunks   "
literal|"highchunks    curchunks\n"
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"  %13llu%13lu%13lu\n"
argument_list|,
name|chunks_stats
operator|.
name|nchunks
argument_list|,
name|chunks_stats
operator|.
name|highchunks
argument_list|,
name|chunks_stats
operator|.
name|curchunks
argument_list|)
expr_stmt|;
block|}
comment|/* Print chunk stats. */
name|malloc_printf
argument_list|(
literal|"huge: nmalloc      ndalloc    allocated\n"
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|" %12llu %12llu %12zu\n"
argument_list|,
name|huge_nmalloc
argument_list|,
name|huge_ndalloc
argument_list|,
name|huge_allocated
operator|*
name|chunk_size
argument_list|)
expr_stmt|;
comment|/* Print stats for each arena. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|narenas
condition|;
name|i
operator|++
control|)
block|{
name|arena
operator|=
name|arenas
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|arena
operator|!=
name|NULL
condition|)
block|{
name|malloc_printf
argument_list|(
literal|"\narenas[%u]:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|arena
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|stats_print
argument_list|(
name|arena
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* #ifdef MALLOC_STATS */
name|_malloc_message
argument_list|(
literal|"--- End malloc statistics ---\n"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * FreeBSD's pthreads implementation calls malloc(3), so the malloc  * implementation has to take pains to avoid infinite recursion during  * initialization.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|malloc_init
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|malloc_initialized
operator|==
name|false
condition|)
return|return
operator|(
name|malloc_init_hard
argument_list|()
operator|)
return|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|malloc_init_hard
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|linklen
decl_stmt|;
name|char
name|buf
index|[
name|PATH_MAX
operator|+
literal|1
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|opts
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|malloc_initialized
condition|)
block|{
comment|/* 		 * Another thread initialized the allocator before this one 		 * acquired init_lock. 		 */
name|malloc_mutex_unlock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
comment|/* Get number of CPUs. */
block|{
name|int
name|mib
index|[
literal|2
index|]
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|mib
index|[
literal|0
index|]
operator|=
name|CTL_HW
expr_stmt|;
name|mib
index|[
literal|1
index|]
operator|=
name|HW_NCPU
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|ncpus
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|2
argument_list|,
operator|&
name|ncpus
argument_list|,
operator|&
name|len
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Error. */
name|ncpus
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Get page size. */
block|{
name|long
name|result
decl_stmt|;
name|result
operator|=
name|sysconf
argument_list|(
name|_SC_PAGESIZE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|result
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pagesize
operator|=
operator|(
name|unsigned
operator|)
name|result
expr_stmt|;
comment|/* 		 * We assume that pagesize is a power of 2 when calculating 		 * pagesize_mask and pagesize_2pow. 		 */
name|assert
argument_list|(
operator|(
operator|(
name|result
operator|-
literal|1
operator|)
operator|&
name|result
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|pagesize_mask
operator|=
name|result
operator|-
literal|1
expr_stmt|;
name|pagesize_2pow
operator|=
name|ffs
argument_list|(
operator|(
name|int
operator|)
name|result
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
comment|/* Get runtime configuration. */
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
operator|(
name|linklen
operator|=
name|readlink
argument_list|(
literal|"/etc/malloc.conf"
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* 				 * Use the contents of the "/etc/malloc.conf" 				 * symbolic link's name. 				 */
name|buf
index|[
name|linklen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|opts
operator|=
name|buf
expr_stmt|;
block|}
else|else
block|{
comment|/* No configuration specified. */
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|opts
operator|=
name|buf
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|issetugid
argument_list|()
operator|==
literal|0
operator|&&
operator|(
name|opts
operator|=
name|getenv
argument_list|(
literal|"MALLOC_OPTIONS"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * Do nothing; opts is already initialized to 				 * the value of the MALLOC_OPTIONS environment 				 * variable. 				 */
block|}
else|else
block|{
comment|/* No configuration specified. */
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|opts
operator|=
name|buf
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|_malloc_options
operator|!=
name|NULL
condition|)
block|{
comment|/* 			     * Use options that were compiled into the program. 			     */
name|opts
operator|=
name|_malloc_options
expr_stmt|;
block|}
else|else
block|{
comment|/* No configuration specified. */
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|opts
operator|=
name|buf
expr_stmt|;
block|}
break|break;
default|default:
comment|/* NOTREACHED */
name|assert
argument_list|(
name|false
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|opts
index|[
name|j
index|]
operator|!=
literal|'\0'
condition|;
name|j
operator|++
control|)
block|{
switch|switch
condition|(
name|opts
index|[
name|j
index|]
condition|)
block|{
case|case
literal|'a'
case|:
name|opt_abort
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|opt_abort
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|opt_hint
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|opt_hint
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|opt_junk
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
name|opt_junk
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
comment|/* 				 * Run fullness quartile limits don't have 				 * enough resolution if there are too few 				 * regions for the largest bin size classes. 				 */
if|if
condition|(
name|opt_chunk_2pow
operator|>
name|pagesize_2pow
operator|+
literal|4
condition|)
name|opt_chunk_2pow
operator|--
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
comment|/* 				 * There must be fewer pages in a chunk than 				 * can be recorded by the pos field of 				 * arena_chunk_map_t, in order to make POS_FREE 				 * special. 				 */
if|if
condition|(
name|opt_chunk_2pow
operator|-
name|pagesize_2pow
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
operator|<<
literal|3
operator|)
operator|-
literal|1
condition|)
name|opt_chunk_2pow
operator|++
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|opt_narenas_lshift
operator|--
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|opt_narenas_lshift
operator|++
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|opt_print_stats
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|opt_print_stats
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
if|if
condition|(
name|opt_quantum_2pow
operator|>
name|QUANTUM_2POW_MIN
condition|)
name|opt_quantum_2pow
operator|--
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
if|if
condition|(
name|opt_quantum_2pow
operator|<
name|pagesize_2pow
operator|-
literal|1
condition|)
name|opt_quantum_2pow
operator|++
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|opt_small_max_2pow
operator|>
name|QUANTUM_2POW_MIN
condition|)
name|opt_small_max_2pow
operator|--
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
if|if
condition|(
name|opt_small_max_2pow
operator|<
name|pagesize_2pow
operator|-
literal|1
condition|)
name|opt_small_max_2pow
operator|++
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|opt_utrace
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|opt_utrace
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|opt_sysv
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|opt_sysv
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|opt_xmalloc
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|opt_xmalloc
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|opt_zero
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
name|opt_zero
operator|=
name|true
expr_stmt|;
break|break;
default|default:
block|{
name|char
name|cbuf
index|[
literal|2
index|]
decl_stmt|;
name|cbuf
index|[
literal|0
index|]
operator|=
name|opts
index|[
name|j
index|]
expr_stmt|;
name|cbuf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|_malloc_message
argument_list|(
name|_getprogname
argument_list|()
argument_list|,
literal|": (malloc) Unsupported character in "
literal|"malloc options: '"
argument_list|,
name|cbuf
argument_list|,
literal|"'\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Take care to call atexit() only once. */
if|if
condition|(
name|opt_print_stats
condition|)
block|{
comment|/* Print statistics at exit. */
name|atexit
argument_list|(
name|malloc_print_stats
argument_list|)
expr_stmt|;
block|}
comment|/* Set variables according to the value of opt_small_max_2pow. */
if|if
condition|(
name|opt_small_max_2pow
operator|<
name|opt_quantum_2pow
condition|)
name|opt_small_max_2pow
operator|=
name|opt_quantum_2pow
expr_stmt|;
name|small_max
operator|=
operator|(
literal|1
operator|<<
name|opt_small_max_2pow
operator|)
expr_stmt|;
comment|/* Set bin-related variables. */
name|bin_maxclass
operator|=
operator|(
name|pagesize
operator|>>
literal|1
operator|)
expr_stmt|;
name|assert
argument_list|(
name|opt_quantum_2pow
operator|>=
name|TINY_MIN_2POW
argument_list|)
expr_stmt|;
name|ntbins
operator|=
name|opt_quantum_2pow
operator|-
name|TINY_MIN_2POW
expr_stmt|;
name|assert
argument_list|(
name|ntbins
operator|<=
name|opt_quantum_2pow
argument_list|)
expr_stmt|;
name|nqbins
operator|=
operator|(
name|small_max
operator|>>
name|opt_quantum_2pow
operator|)
expr_stmt|;
name|nsbins
operator|=
name|pagesize_2pow
operator|-
name|opt_small_max_2pow
operator|-
literal|1
expr_stmt|;
comment|/* Set variables according to the value of opt_quantum_2pow. */
name|quantum
operator|=
operator|(
literal|1
operator|<<
name|opt_quantum_2pow
operator|)
expr_stmt|;
name|quantum_mask
operator|=
name|quantum
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|ntbins
operator|>
literal|0
condition|)
name|small_min
operator|=
operator|(
name|quantum
operator|>>
literal|1
operator|)
operator|+
literal|1
expr_stmt|;
else|else
name|small_min
operator|=
literal|1
expr_stmt|;
name|assert
argument_list|(
name|small_min
operator|<=
name|quantum
argument_list|)
expr_stmt|;
comment|/* Set variables according to the value of opt_chunk_2pow. */
name|chunk_size
operator|=
operator|(
literal|1LU
operator|<<
name|opt_chunk_2pow
operator|)
expr_stmt|;
name|chunk_size_mask
operator|=
name|chunk_size
operator|-
literal|1
expr_stmt|;
name|chunk_npages
operator|=
operator|(
name|chunk_size
operator|>>
name|pagesize_2pow
operator|)
expr_stmt|;
block|{
name|unsigned
name|header_size
decl_stmt|;
name|header_size
operator|=
sizeof|sizeof
argument_list|(
name|arena_chunk_t
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|arena_chunk_map_t
argument_list|)
operator|*
operator|(
name|chunk_npages
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|arena_chunk_header_npages
operator|=
operator|(
name|header_size
operator|>>
name|pagesize_2pow
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|header_size
operator|&
name|pagesize_mask
operator|)
operator|!=
literal|0
condition|)
name|arena_chunk_header_npages
operator|++
expr_stmt|;
block|}
name|arena_maxclass
operator|=
name|chunk_size
operator|-
operator|(
name|arena_chunk_header_npages
operator|<<
name|pagesize_2pow
operator|)
expr_stmt|;
name|UTRACE
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|memset
argument_list|(
operator|&
name|stats_chunks
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|chunk_stats_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Various sanity checks that regard configuration. */
name|assert
argument_list|(
name|quantum
operator|>=
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|quantum
operator|<=
name|pagesize
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|chunk_size
operator|>=
name|pagesize
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|quantum
operator|*
literal|4
operator|<=
name|chunk_size
argument_list|)
expr_stmt|;
comment|/* Initialize chunks data. */
name|malloc_mutex_init
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
name|RB_INIT
argument_list|(
operator|&
name|huge
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_BRK
name|malloc_mutex_init
argument_list|(
operator|&
name|brk_mtx
argument_list|)
expr_stmt|;
name|brk_base
operator|=
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|brk_prev
operator|=
name|brk_base
expr_stmt|;
name|brk_max
operator|=
name|brk_base
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|huge_nmalloc
operator|=
literal|0
expr_stmt|;
name|huge_ndalloc
operator|=
literal|0
expr_stmt|;
name|huge_allocated
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|RB_INIT
argument_list|(
operator|&
name|old_chunks
argument_list|)
expr_stmt|;
comment|/* Initialize base allocation data structures. */
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|base_mapped
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|USE_BRK
comment|/* 	 * Allocate a base chunk here, since it doesn't actually have to be 	 * chunk-aligned.  Doing this before allocating any other chunks allows 	 * the use of space that would otherwise be wasted. 	 */
name|base_chunk_alloc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|base_chunk_nodes
operator|=
name|NULL
expr_stmt|;
name|malloc_mutex_init
argument_list|(
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ncpus
operator|>
literal|1
condition|)
block|{
comment|/* 		 * For SMP systems, create four times as many arenas as there 		 * are CPUs by default. 		 */
name|opt_narenas_lshift
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* Determine how many arenas to use. */
name|narenas
operator|=
name|ncpus
expr_stmt|;
if|if
condition|(
name|opt_narenas_lshift
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|narenas
operator|<<
name|opt_narenas_lshift
operator|)
operator|>
name|narenas
condition|)
name|narenas
operator|<<=
name|opt_narenas_lshift
expr_stmt|;
comment|/* 		 * Make sure not to exceed the limits of what base_malloc() 		 * can handle. 		 */
if|if
condition|(
name|narenas
operator|*
sizeof|sizeof
argument_list|(
name|arena_t
operator|*
argument_list|)
operator|>
name|chunk_size
condition|)
name|narenas
operator|=
name|chunk_size
operator|/
sizeof|sizeof
argument_list|(
name|arena_t
operator|*
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opt_narenas_lshift
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|narenas
operator|<<
name|opt_narenas_lshift
operator|)
operator|<
name|narenas
condition|)
name|narenas
operator|<<=
name|opt_narenas_lshift
expr_stmt|;
comment|/* Make sure there is at least one arena. */
if|if
condition|(
name|narenas
operator|==
literal|0
condition|)
name|narenas
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|NO_TLS
if|if
condition|(
name|narenas
operator|>
literal|1
condition|)
block|{
specifier|static
specifier|const
name|unsigned
name|primes
index|[]
init|=
block|{
literal|1
block|,
literal|3
block|,
literal|5
block|,
literal|7
block|,
literal|11
block|,
literal|13
block|,
literal|17
block|,
literal|19
block|,
literal|23
block|,
literal|29
block|,
literal|31
block|,
literal|37
block|,
literal|41
block|,
literal|43
block|,
literal|47
block|,
literal|53
block|,
literal|59
block|,
literal|61
block|,
literal|67
block|,
literal|71
block|,
literal|73
block|,
literal|79
block|,
literal|83
block|,
literal|89
block|,
literal|97
block|,
literal|101
block|,
literal|103
block|,
literal|107
block|,
literal|109
block|,
literal|113
block|,
literal|127
block|,
literal|131
block|,
literal|137
block|,
literal|139
block|,
literal|149
block|,
literal|151
block|,
literal|157
block|,
literal|163
block|,
literal|167
block|,
literal|173
block|,
literal|179
block|,
literal|181
block|,
literal|191
block|,
literal|193
block|,
literal|197
block|,
literal|199
block|,
literal|211
block|,
literal|223
block|,
literal|227
block|,
literal|229
block|,
literal|233
block|,
literal|239
block|,
literal|241
block|,
literal|251
block|,
literal|257
block|,
literal|263
block|}
decl_stmt|;
name|unsigned
name|nprimes
decl_stmt|,
name|parenas
decl_stmt|;
comment|/* 		 * Pick a prime number of hash arenas that is more than narenas 		 * so that direct hashing of pthread_self() pointers tends to 		 * spread allocations evenly among the arenas. 		 */
name|assert
argument_list|(
operator|(
name|narenas
operator|&
literal|1
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* narenas must be even. */
name|nprimes
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|primes
argument_list|)
operator|>>
name|SIZEOF_INT_2POW
operator|)
expr_stmt|;
name|parenas
operator|=
name|primes
index|[
name|nprimes
operator|-
literal|1
index|]
expr_stmt|;
comment|/* In case not enough primes. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nprimes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|primes
index|[
name|i
index|]
operator|>
name|narenas
condition|)
block|{
name|parenas
operator|=
name|primes
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
name|narenas
operator|=
name|parenas
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_TLS
name|next_arena
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Allocate and initialize arenas. */
name|arenas
operator|=
operator|(
name|arena_t
operator|*
operator|*
operator|)
name|base_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arena_t
operator|*
argument_list|)
operator|*
name|narenas
argument_list|)
expr_stmt|;
if|if
condition|(
name|arenas
operator|==
name|NULL
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
comment|/* 	 * Zero the array.  In practice, this should always be pre-zeroed, 	 * since it was just mmap()ed, but let's be sure. 	 */
name|memset
argument_list|(
name|arenas
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|arena_t
operator|*
argument_list|)
operator|*
name|narenas
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize one arena here.  The rest are lazily created in 	 * arena_choose_hard(). 	 */
name|arenas_extend
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arenas
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
name|malloc_mutex_init
argument_list|(
operator|&
name|arenas_mtx
argument_list|)
expr_stmt|;
name|malloc_initialized
operator|=
name|true
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * End general internal functions.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin malloc(3)-compatible functions.  */
end_comment

begin_function
name|void
modifier|*
name|malloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|malloc_init
argument_list|()
condition|)
block|{
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|opt_sysv
operator|==
name|false
condition|)
name|size
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
block|}
name|ret
operator|=
name|imalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|RETURN
label|:
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|opt_xmalloc
condition|)
block|{
name|_malloc_message
argument_list|(
name|_getprogname
argument_list|()
argument_list|,
literal|": (malloc) Error in malloc(): out of memory\n"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|errno
operator|=
name|ENOMEM
expr_stmt|;
block|}
name|UTRACE
argument_list|(
literal|0
argument_list|,
name|size
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|posix_memalign
parameter_list|(
name|void
modifier|*
modifier|*
name|memptr
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|void
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|malloc_init
argument_list|()
condition|)
name|result
operator|=
name|NULL
expr_stmt|;
else|else
block|{
comment|/* Make sure that alignment is a large enough power of 2. */
if|if
condition|(
operator|(
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|&
name|alignment
operator|)
operator|!=
literal|0
operator|||
name|alignment
operator|<
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
condition|)
block|{
if|if
condition|(
name|opt_xmalloc
condition|)
block|{
name|_malloc_message
argument_list|(
name|_getprogname
argument_list|()
argument_list|,
literal|": (malloc) Error in posix_memalign(): "
literal|"invalid alignment\n"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|result
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
name|result
operator|=
name|ipalloc
argument_list|(
name|alignment
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|opt_xmalloc
condition|)
block|{
name|_malloc_message
argument_list|(
name|_getprogname
argument_list|()
argument_list|,
literal|": (malloc) Error in posix_memalign(): out of memory\n"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
operator|*
name|memptr
operator|=
name|result
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|RETURN
label|:
name|UTRACE
argument_list|(
literal|0
argument_list|,
name|size
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|calloc
parameter_list|(
name|size_t
name|num
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|size_t
name|num_size
decl_stmt|;
if|if
condition|(
name|malloc_init
argument_list|()
condition|)
block|{
name|num_size
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
name|num_size
operator|=
name|num
operator|*
name|size
expr_stmt|;
if|if
condition|(
name|num_size
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|opt_sysv
operator|==
name|false
operator|)
operator|&&
operator|(
operator|(
name|num
operator|==
literal|0
operator|)
operator|||
operator|(
name|size
operator|==
literal|0
operator|)
operator|)
condition|)
name|num_size
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
comment|/* 	 * Try to avoid division here.  We know that it isn't possible to 	 * overflow during multiplication if neither operand uses any of the 	 * most significant half of the bits in a size_t. 	 */
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|num
operator||
name|size
operator|)
operator|&
operator|(
name|SIZE_T_MAX
operator|<<
operator|(
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|<<
literal|2
operator|)
operator|)
operator|)
operator|&&
operator|(
name|num_size
operator|/
name|size
operator|!=
name|num
operator|)
condition|)
block|{
comment|/* size_t overflow. */
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
name|ret
operator|=
name|icalloc
argument_list|(
name|num_size
argument_list|)
expr_stmt|;
name|RETURN
label|:
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|opt_xmalloc
condition|)
block|{
name|_malloc_message
argument_list|(
name|_getprogname
argument_list|()
argument_list|,
literal|": (malloc) Error in calloc(): out of memory\n"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|errno
operator|=
name|ENOMEM
expr_stmt|;
block|}
name|UTRACE
argument_list|(
literal|0
argument_list|,
name|num_size
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|realloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|opt_sysv
operator|==
name|false
condition|)
name|size
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
name|idalloc
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
block|}
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|malloc_initialized
argument_list|)
expr_stmt|;
name|ret
operator|=
name|iralloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|opt_xmalloc
condition|)
block|{
name|_malloc_message
argument_list|(
name|_getprogname
argument_list|()
argument_list|,
literal|": (malloc) Error in realloc(): out of "
literal|"memory\n"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|errno
operator|=
name|ENOMEM
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|malloc_init
argument_list|()
condition|)
name|ret
operator|=
name|NULL
expr_stmt|;
else|else
name|ret
operator|=
name|imalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|opt_xmalloc
condition|)
block|{
name|_malloc_message
argument_list|(
name|_getprogname
argument_list|()
argument_list|,
literal|": (malloc) Error in realloc(): out of "
literal|"memory\n"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|errno
operator|=
name|ENOMEM
expr_stmt|;
block|}
block|}
name|RETURN
label|:
name|UTRACE
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|free
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|UTRACE
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|malloc_initialized
argument_list|)
expr_stmt|;
name|idalloc
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * End malloc(3)-compatible functions.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin non-standard functions.  */
end_comment

begin_function
name|size_t
name|malloc_usable_size
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|isalloc
argument_list|(
name|ptr
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * End non-standard functions.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin library-private functions, used by threading libraries for protection  * of malloc during fork().  These functions are only called if the program is  * running in threaded mode, so there is no need to check whether the program  * is threaded here.  */
end_comment

begin_function
name|void
name|_malloc_prefork
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
comment|/* Acquire all mutexes in a safe order. */
name|malloc_mutex_lock
argument_list|(
operator|&
name|arenas_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|narenas
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|arenas
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|malloc_mutex_lock
argument_list|(
operator|&
name|arenas
index|[
name|i
index|]
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arenas_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_malloc_postfork
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
comment|/* Release all mutexes, now that fork() has completed. */
name|malloc_mutex_unlock
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|arenas_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|narenas
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|arenas
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arenas
index|[
name|i
index|]
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arenas_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * End library-private functions.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

end_unit

