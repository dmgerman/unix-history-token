begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ----------------------------------------------------------------------------  * "THE BEER-WARE LICENSE" (Revision 42):  *<phk@FreeBSD.ORG> wrote this file.  As long as you retain this notice you  * can do whatever you want with this stuff. If we meet some day, and you think  * this stuff is worth it, you can buy me a beer in return.   Poul-Henning Kamp  * ----------------------------------------------------------------------------  *  * $Id: malloc.c,v 1.18.2.4 1998/04/23 08:21:49 tg Exp $  *  */
end_comment

begin_comment
comment|/*  * Defining EXTRA_SANITY will enable extra checks which are related  * to internal conditions and consistency in malloc.c. This has a  * noticeable runtime performance hit, and generally will not do you  * any good unless you fiddle with the internals of malloc or want  * to catch random pointer corruption as early as possible.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MALLOC_EXTRA_SANITY
end_ifndef

begin_undef
undef|#
directive|undef
name|MALLOC_EXTRA_SANITY
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * What to use for Junk.  This is the byte value we use to fill with  * when the 'J' option is enabled.  */
end_comment

begin_define
define|#
directive|define
name|SOME_JUNK
value|0xd0
end_define

begin_comment
comment|/* as in "Duh" :-) */
end_comment

begin_comment
comment|/*  * The basic parameters you can tweak.  *  * malloc_pageshift	pagesize = 1<< malloc_pageshift  *			It's probably best if this is the native  *			page size, but it doesn't have to be.  *  * malloc_minsize	minimum size of an allocation in bytes.  *			If this is too small it's too much work  *			to manage them.  This is also the smallest  *			unit of alignment used for the storage  *			returned by malloc/realloc.  *  */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FreeBSD__
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__i386__
argument_list|)
end_if

begin_define
define|#
directive|define
name|malloc_pageshift
value|12U
end_define

begin_define
define|#
directive|define
name|malloc_minsize
value|16U
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|HAS_UTRACE
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_THREAD_SAFE
argument_list|)
end_if

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|"pthread_private.h"
end_include

begin_define
define|#
directive|define
name|THREAD_STATUS
value|int thread_lock_status;
end_define

begin_define
define|#
directive|define
name|THREAD_LOCK
parameter_list|()
value|_thread_kern_sig_block(&thread_lock_status);
end_define

begin_define
define|#
directive|define
name|THREAD_UNLOCK
parameter_list|()
value|_thread_kern_sig_unblock(thread_lock_status);
end_define

begin_decl_stmt
specifier|static
name|struct
name|pthread_mutex
name|_malloc_lock
init|=
name|PTHREAD_MUTEX_STATIC_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pthread_mutex_t
name|malloc_lock
init|=
operator|&
name|_malloc_lock
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FreeBSD__ */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__sparc__
argument_list|)
operator|&&
name|defined
argument_list|(
name|sun
argument_list|)
end_if

begin_define
define|#
directive|define
name|malloc_pageshirt
value|12U
end_define

begin_define
define|#
directive|define
name|malloc_minsize
value|16U
end_define

begin_define
define|#
directive|define
name|MAP_ANON
value|(0)
end_define

begin_decl_stmt
specifier|static
name|int
name|fdzero
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MMAP_FD
value|fdzero
end_define

begin_define
define|#
directive|define
name|INIT_MMAP
parameter_list|()
define|\
value|{ if ((fdzero=open("/dev/zero", O_RDWR, 0000)) == -1) \ 	    wrterror("open of /dev/zero"); }
end_define

begin_define
define|#
directive|define
name|MADV_FREE
value|MADV_DONTNEED
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __sparc__ */
end_comment

begin_comment
comment|/* Insert your combination here... */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__FOOCPU__
argument_list|)
operator|&&
name|defined
argument_list|(
name|__BAROS__
argument_list|)
end_if

begin_define
define|#
directive|define
name|malloc_pageshift
value|12U
end_define

begin_define
define|#
directive|define
name|malloc_minsize
value|16U
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __FOOCPU__&& __BAROS__ */
end_comment

begin_comment
comment|/*  * No user serviceable parts behind this point.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/*  * This structure describes a page worth of chunks.  */
end_comment

begin_struct
struct|struct
name|pginfo
block|{
name|struct
name|pginfo
modifier|*
name|next
decl_stmt|;
comment|/* next on the free list */
name|void
modifier|*
name|page
decl_stmt|;
comment|/* Pointer to the page */
name|u_short
name|size
decl_stmt|;
comment|/* size of this page's chunks */
name|u_short
name|shift
decl_stmt|;
comment|/* How far to shift for this size chunks */
name|u_short
name|free
decl_stmt|;
comment|/* How many free chunks */
name|u_short
name|total
decl_stmt|;
comment|/* How many chunk */
name|u_int
name|bits
index|[
literal|1
index|]
decl_stmt|;
comment|/* Which chunks are free */
block|}
struct|;
end_struct

begin_comment
comment|/*  * This structure describes a number of free pages.  */
end_comment

begin_struct
struct|struct
name|pgfree
block|{
name|struct
name|pgfree
modifier|*
name|next
decl_stmt|;
comment|/* next run of free pages */
name|struct
name|pgfree
modifier|*
name|prev
decl_stmt|;
comment|/* prev run of free pages */
name|void
modifier|*
name|page
decl_stmt|;
comment|/* pointer to free pages */
name|void
modifier|*
name|end
decl_stmt|;
comment|/* pointer to end of free pages */
name|size_t
name|size
decl_stmt|;
comment|/* number of bytes free */
block|}
struct|;
end_struct

begin_comment
comment|/*  * How many bits per u_int in the bitmap.  * Change only if not 8 bits/byte  */
end_comment

begin_define
define|#
directive|define
name|MALLOC_BITS
value|(8*sizeof(u_int))
end_define

begin_comment
comment|/*  * Magic values to put in the page_directory  */
end_comment

begin_define
define|#
directive|define
name|MALLOC_NOT_MINE
value|((struct pginfo*) 0)
end_define

begin_define
define|#
directive|define
name|MALLOC_FREE
value|((struct pginfo*) 1)
end_define

begin_define
define|#
directive|define
name|MALLOC_FIRST
value|((struct pginfo*) 2)
end_define

begin_define
define|#
directive|define
name|MALLOC_FOLLOW
value|((struct pginfo*) 3)
end_define

begin_define
define|#
directive|define
name|MALLOC_MAGIC
value|((struct pginfo*) 4)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|malloc_pageshift
end_ifndef

begin_define
define|#
directive|define
name|malloc_pageshift
value|12U
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|malloc_minsize
end_ifndef

begin_define
define|#
directive|define
name|malloc_minsize
value|16U
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|malloc_pagesize
argument_list|)
end_if

begin_define
define|#
directive|define
name|malloc_pagesize
value|(1U<<malloc_pageshift)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|(
operator|(
literal|1
operator|<<
name|malloc_pageshift
operator|)
operator|!=
name|malloc_pagesize
operator|)
end_if

begin_error
error|#
directive|error
literal|"(1<<malloc_pageshift) != malloc_pagesize"
end_error

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|malloc_maxsize
end_ifndef

begin_define
define|#
directive|define
name|malloc_maxsize
value|((malloc_pagesize)>>1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* A mask for the offset inside a page.  */
end_comment

begin_define
define|#
directive|define
name|malloc_pagemask
value|((malloc_pagesize)-1)
end_define

begin_define
define|#
directive|define
name|pageround
parameter_list|(
name|foo
parameter_list|)
value|(((foo) + (malloc_pagemask))&(~(malloc_pagemask)))
end_define

begin_define
define|#
directive|define
name|ptr2index
parameter_list|(
name|foo
parameter_list|)
value|(((u_long)(foo)>> malloc_pageshift)-malloc_origo)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|THREAD_STATUS
end_ifndef

begin_define
define|#
directive|define
name|THREAD_STATUS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|THREAD_LOCK
end_ifndef

begin_define
define|#
directive|define
name|THREAD_LOCK
parameter_list|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|THREAD_UNLOCK
end_ifndef

begin_define
define|#
directive|define
name|THREAD_UNLOCK
parameter_list|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MMAP_FD
end_ifndef

begin_define
define|#
directive|define
name|MMAP_FD
value|(-1)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|INIT_MMAP
end_ifndef

begin_define
define|#
directive|define
name|INIT_MMAP
parameter_list|()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Set when initialization has been done */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|malloc_started
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Recusion flag for public interface. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|malloc_active
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of free pages we cache */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|malloc_cache
init|=
literal|16
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The offset from pagenumber to index into the page directory */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|malloc_origo
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The last index in the page directory we care about */
end_comment

begin_decl_stmt
specifier|static
name|u_long
name|last_index
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to page directory. Allocated "as if with" malloc */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pginfo
modifier|*
modifier|*
name|page_dir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How many slots in the page directory */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|malloc_ninfo
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Free pages line up here */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pgfree
name|free_list
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Abort(), user doesn't handle problems.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|malloc_abort
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Are we trying to die ?  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|suicide
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* always realloc ?  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|malloc_realloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pass the kernel a hint on free pages ?  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|malloc_hint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* xmalloc behaviour ?  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|malloc_xmalloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* sysv behaviour for malloc(0) ?  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|malloc_sysv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* zero fill ?  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|malloc_zero
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* junk fill ?  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|malloc_junk
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_UTRACE
end_ifdef

begin_comment
comment|/* utrace ?  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|malloc_utrace
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|ut
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|size_t
name|s
decl_stmt|;
name|void
modifier|*
name|r
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|void
name|utrace
name|__P
argument_list|(
operator|(
expr|struct
name|ut
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|UTRACE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
define|\
value|if (malloc_utrace) \ 		{struct ut u; u.p=a; u.s = b; u.r=c; utrace(&u, sizeof u);}
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !HAS_UTRACE */
end_comment

begin_define
define|#
directive|define
name|UTRACE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAS_UTRACE */
end_comment

begin_comment
comment|/* my last break. */
end_comment

begin_decl_stmt
specifier|static
name|void
modifier|*
name|malloc_brk
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* one location cache for free-list holders */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pgfree
modifier|*
name|px
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* compile-time options */
end_comment

begin_decl_stmt
name|char
modifier|*
name|malloc_options
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of the current public function */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|malloc_func
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Macro for mmap */
end_comment

begin_define
define|#
directive|define
name|MMAP
parameter_list|(
name|size
parameter_list|)
define|\
value|mmap((caddr_t)0, (size), PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE, \ 	    MMAP_FD, 0);
end_define

begin_comment
comment|/*  * Necessary function declarations  */
end_comment

begin_function_decl
specifier|static
name|int
name|extend_pgdir
parameter_list|(
name|u_long
name|index
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|imalloc
parameter_list|(
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ifree
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|irealloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|__progname
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|wrterror
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
block|{
name|char
modifier|*
name|q
init|=
literal|" error: "
decl_stmt|;
name|write
argument_list|(
name|STDERR_FILENO
argument_list|,
name|__progname
argument_list|,
name|strlen
argument_list|(
name|__progname
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|STDERR_FILENO
argument_list|,
name|malloc_func
argument_list|,
name|strlen
argument_list|(
name|malloc_func
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|STDERR_FILENO
argument_list|,
name|q
argument_list|,
name|strlen
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|STDERR_FILENO
argument_list|,
name|p
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|suicide
operator|=
literal|1
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|wrtwarning
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
block|{
name|char
modifier|*
name|q
init|=
literal|" warning: "
decl_stmt|;
if|if
condition|(
name|malloc_abort
condition|)
name|wrterror
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|STDERR_FILENO
argument_list|,
name|__progname
argument_list|,
name|strlen
argument_list|(
name|__progname
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|STDERR_FILENO
argument_list|,
name|malloc_func
argument_list|,
name|strlen
argument_list|(
name|malloc_func
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|STDERR_FILENO
argument_list|,
name|q
argument_list|,
name|strlen
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|STDERR_FILENO
argument_list|,
name|p
argument_list|,
name|strlen
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a number of pages from the OS  */
end_comment

begin_function
specifier|static
name|caddr_t
name|map_pages
parameter_list|(
name|int
name|pages
parameter_list|)
block|{
name|caddr_t
name|result
decl_stmt|,
name|tail
decl_stmt|;
name|result
operator|=
operator|(
name|caddr_t
operator|)
name|pageround
argument_list|(
operator|(
name|u_long
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|tail
operator|=
name|result
operator|+
operator|(
name|pages
operator|<<
name|malloc_pageshift
operator|)
expr_stmt|;
if|if
condition|(
name|brk
argument_list|(
name|tail
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|EXTRA_SANITY
name|wrterror
argument_list|(
literal|"(ES): map_pages fails\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* EXTRA_SANITY */
return|return
literal|0
return|;
block|}
name|last_index
operator|=
name|ptr2index
argument_list|(
name|tail
argument_list|)
operator|-
literal|1
expr_stmt|;
name|malloc_brk
operator|=
name|tail
expr_stmt|;
if|if
condition|(
operator|(
name|last_index
operator|+
literal|1
operator|)
operator|>=
name|malloc_ninfo
operator|&&
operator|!
name|extend_pgdir
argument_list|(
name|last_index
argument_list|)
condition|)
return|return
literal|0
return|;
empty_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Extend page directory  */
end_comment

begin_function
specifier|static
name|int
name|extend_pgdir
parameter_list|(
name|u_long
name|index
parameter_list|)
block|{
name|struct
name|pginfo
modifier|*
modifier|*
name|new
decl_stmt|,
modifier|*
modifier|*
name|old
decl_stmt|;
name|int
name|i
decl_stmt|,
name|oldlen
decl_stmt|;
comment|/* Make it this many pages */
name|i
operator|=
name|index
operator|*
sizeof|sizeof
expr|*
name|page_dir
expr_stmt|;
name|i
operator|/=
name|malloc_pagesize
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
comment|/* remember the old mapping size */
name|oldlen
operator|=
name|malloc_ninfo
operator|*
sizeof|sizeof
expr|*
name|page_dir
expr_stmt|;
comment|/*      * NOTE: we allocate new pages and copy the directory rather than tempt      * fate by trying to "grow" the region.. There is nothing to prevent      * us from accidently re-mapping space that's been allocated by our caller      * via dlopen() or other mmap().      *      * The copy problem is not too bad, as there is 4K of page index per      * 4MB of malloc arena.      *      * We can totally avoid the copy if we open a file descriptor to associate      * the anon mappings with.  Then, when we remap the pages at the new      * address, the old pages will be "magically" remapped..  But this means      * keeping open a "secret" file descriptor.....      */
comment|/* Get new pages */
name|new
operator|=
operator|(
expr|struct
name|pginfo
operator|*
operator|*
operator|)
name|MMAP
argument_list|(
name|i
operator|*
name|malloc_pagesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|==
operator|(
expr|struct
name|pginfo
operator|*
operator|*
operator|)
operator|-
literal|1
condition|)
return|return
literal|0
return|;
comment|/* Copy the old stuff */
name|memcpy
argument_list|(
name|new
argument_list|,
name|page_dir
argument_list|,
name|malloc_ninfo
operator|*
sizeof|sizeof
expr|*
name|page_dir
argument_list|)
expr_stmt|;
comment|/* register the new size */
name|malloc_ninfo
operator|=
name|i
operator|*
name|malloc_pagesize
operator|/
sizeof|sizeof
expr|*
name|page_dir
expr_stmt|;
comment|/* swap the pointers */
name|old
operator|=
name|page_dir
expr_stmt|;
name|page_dir
operator|=
name|new
expr_stmt|;
comment|/* Now free the old stuff */
name|munmap
argument_list|(
operator|(
name|caddr_t
operator|)
name|old
argument_list|,
name|oldlen
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize the world  */
end_comment

begin_function
specifier|static
name|void
name|malloc_init
parameter_list|()
block|{
name|char
modifier|*
name|p
decl_stmt|,
name|b
index|[
literal|64
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|INIT_MMAP
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|EXTRA_SANITY
name|malloc_junk
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* EXTRA_SANITY */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|j
operator|=
name|readlink
argument_list|(
literal|"/etc/malloc.conf"
argument_list|,
name|b
argument_list|,
sizeof|sizeof
name|b
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|<=
literal|0
condition|)
continue|continue;
name|b
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
name|p
operator|=
name|b
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
name|p
operator|=
name|getenv
argument_list|(
literal|"MALLOC_OPTIONS"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|malloc_options
expr_stmt|;
block|}
for|for
control|(
init|;
name|p
operator|&&
operator|*
name|p
condition|;
name|p
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|p
condition|)
block|{
case|case
literal|'>'
case|:
name|malloc_cache
operator|<<=
literal|1
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|malloc_cache
operator|>>=
literal|1
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|malloc_abort
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|malloc_abort
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|malloc_hint
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|malloc_hint
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|malloc_realloc
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|malloc_realloc
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|malloc_junk
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
name|malloc_junk
operator|=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|HAS_UTRACE
case|case
literal|'u'
case|:
name|malloc_utrace
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|malloc_utrace
operator|=
literal|1
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'v'
case|:
name|malloc_sysv
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|malloc_sysv
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|malloc_xmalloc
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|malloc_xmalloc
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|malloc_zero
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
name|malloc_zero
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|j
operator|=
name|malloc_abort
expr_stmt|;
name|malloc_abort
operator|=
literal|0
expr_stmt|;
name|wrtwarning
argument_list|(
literal|"unknown char in MALLOC_OPTIONS\n"
argument_list|)
expr_stmt|;
name|malloc_abort
operator|=
name|j
expr_stmt|;
break|break;
block|}
block|}
block|}
name|UTRACE
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/*      * We want junk in the entire allocation, and zero only in the part      * the user asked for.      */
if|if
condition|(
name|malloc_zero
condition|)
name|malloc_junk
operator|=
literal|1
expr_stmt|;
comment|/*      * If we run with junk (or implicitly from above: zero), we want to      * force realloc() to get new storage, so we can DTRT with it.      */
if|if
condition|(
name|malloc_junk
condition|)
name|malloc_realloc
operator|=
literal|1
expr_stmt|;
comment|/* Allocate one page for the page directory */
name|page_dir
operator|=
operator|(
expr|struct
name|pginfo
operator|*
operator|*
operator|)
name|MMAP
argument_list|(
name|malloc_pagesize
argument_list|)
expr_stmt|;
if|if
condition|(
name|page_dir
operator|==
operator|(
expr|struct
name|pginfo
operator|*
operator|*
operator|)
operator|-
literal|1
condition|)
name|wrterror
argument_list|(
literal|"mmap(2) failed, check limits.\n"
argument_list|)
expr_stmt|;
comment|/*      * We need a maximum of malloc_pageshift buckets, steal these from the      * front of the page_directory;      */
name|malloc_origo
operator|=
operator|(
operator|(
name|u_long
operator|)
name|pageround
argument_list|(
operator|(
name|u_long
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|)
operator|>>
name|malloc_pageshift
expr_stmt|;
name|malloc_origo
operator|-=
name|malloc_pageshift
expr_stmt|;
name|malloc_ninfo
operator|=
name|malloc_pagesize
operator|/
sizeof|sizeof
expr|*
name|page_dir
expr_stmt|;
comment|/* Recalculate the cache size in bytes, and make sure it's nonzero */
if|if
condition|(
operator|!
name|malloc_cache
condition|)
name|malloc_cache
operator|++
expr_stmt|;
name|malloc_cache
operator|<<=
name|malloc_pageshift
expr_stmt|;
comment|/*      * This is a nice hack from Kaleb Keithly (kaleb@x.org).      * We can sbrk(2) further back when we keep this on a low address.      */
name|px
operator|=
operator|(
expr|struct
name|pgfree
operator|*
operator|)
name|imalloc
argument_list|(
sizeof|sizeof
expr|*
name|px
argument_list|)
expr_stmt|;
comment|/* Been here, done that */
name|malloc_started
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allocate a number of complete pages  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|malloc_pages
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|,
modifier|*
name|delay_free
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|pgfree
modifier|*
name|pf
decl_stmt|;
name|u_long
name|index
decl_stmt|;
name|size
operator|=
name|pageround
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|p
operator|=
literal|0
expr_stmt|;
comment|/* Look for free pages before asking for more */
for|for
control|(
name|pf
operator|=
name|free_list
operator|.
name|next
init|;
name|pf
condition|;
name|pf
operator|=
name|pf
operator|->
name|next
control|)
block|{
ifdef|#
directive|ifdef
name|EXTRA_SANITY
if|if
condition|(
name|pf
operator|->
name|size
operator|&
name|malloc_pagemask
condition|)
name|wrterror
argument_list|(
literal|"(ES): junk length entry on free_list\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pf
operator|->
name|size
condition|)
name|wrterror
argument_list|(
literal|"(ES): zero length entry on free_list\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|page
operator|==
name|pf
operator|->
name|end
condition|)
name|wrterror
argument_list|(
literal|"(ES): zero entry on free_list\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|page
operator|>
name|pf
operator|->
name|end
condition|)
name|wrterror
argument_list|(
literal|"(ES): sick entry on free_list\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|void
operator|*
operator|)
name|pf
operator|->
name|page
operator|>=
operator|(
name|void
operator|*
operator|)
name|sbrk
argument_list|(
literal|0
argument_list|)
condition|)
name|wrterror
argument_list|(
literal|"(ES): entry on free_list past brk\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|page_dir
index|[
name|ptr2index
argument_list|(
name|pf
operator|->
name|page
argument_list|)
index|]
operator|!=
name|MALLOC_FREE
condition|)
name|wrterror
argument_list|(
literal|"(ES): non-free first page on free-list\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|page_dir
index|[
name|ptr2index
argument_list|(
name|pf
operator|->
name|end
argument_list|)
operator|-
literal|1
index|]
operator|!=
name|MALLOC_FREE
condition|)
name|wrterror
argument_list|(
literal|"(ES): non-free last page on free-list\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* EXTRA_SANITY */
if|if
condition|(
name|pf
operator|->
name|size
operator|<
name|size
condition|)
continue|continue;
if|if
condition|(
name|pf
operator|->
name|size
operator|==
name|size
condition|)
block|{
name|p
operator|=
name|pf
operator|->
name|page
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|next
condition|)
name|pf
operator|->
name|next
operator|->
name|prev
operator|=
name|pf
operator|->
name|prev
expr_stmt|;
name|pf
operator|->
name|prev
operator|->
name|next
operator|=
name|pf
operator|->
name|next
expr_stmt|;
name|delay_free
operator|=
name|pf
expr_stmt|;
break|break;
block|}
name|p
operator|=
name|pf
operator|->
name|page
expr_stmt|;
name|pf
operator|->
name|page
operator|=
operator|(
name|char
operator|*
operator|)
name|pf
operator|->
name|page
operator|+
name|size
expr_stmt|;
name|pf
operator|->
name|size
operator|-=
name|size
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|EXTRA_SANITY
if|if
condition|(
name|p
operator|&&
name|page_dir
index|[
name|ptr2index
argument_list|(
name|p
argument_list|)
index|]
operator|!=
name|MALLOC_FREE
condition|)
name|wrterror
argument_list|(
literal|"(ES): allocated non-free page on free-list\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* EXTRA_SANITY */
name|size
operator|>>=
name|malloc_pageshift
expr_stmt|;
comment|/* Map new pages */
if|if
condition|(
operator|!
name|p
condition|)
name|p
operator|=
name|map_pages
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|index
operator|=
name|ptr2index
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|page_dir
index|[
name|index
index|]
operator|=
name|MALLOC_FIRST
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|page_dir
index|[
name|index
operator|+
name|i
index|]
operator|=
name|MALLOC_FOLLOW
expr_stmt|;
if|if
condition|(
name|malloc_junk
condition|)
name|memset
argument_list|(
name|p
argument_list|,
name|SOME_JUNK
argument_list|,
name|size
operator|<<
name|malloc_pageshift
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|delay_free
condition|)
block|{
if|if
condition|(
operator|!
name|px
condition|)
name|px
operator|=
name|delay_free
expr_stmt|;
else|else
name|ifree
argument_list|(
name|delay_free
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a page of fragments  */
end_comment

begin_function
specifier|static
name|__inline__
name|int
name|malloc_make_chunks
parameter_list|(
name|int
name|bits
parameter_list|)
block|{
name|struct
name|pginfo
modifier|*
name|bp
decl_stmt|;
name|void
modifier|*
name|pp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|k
decl_stmt|,
name|l
decl_stmt|;
comment|/* Allocate a new bucket */
name|pp
operator|=
name|malloc_pages
argument_list|(
name|malloc_pagesize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pp
condition|)
return|return
literal|0
return|;
comment|/* Find length of admin structure */
name|l
operator|=
sizeof|sizeof
expr|*
name|bp
operator|-
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
name|l
operator|+=
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
operator|*
operator|(
operator|(
operator|(
name|malloc_pagesize
operator|>>
name|bits
operator|)
operator|+
name|MALLOC_BITS
operator|-
literal|1
operator|)
operator|/
name|MALLOC_BITS
operator|)
expr_stmt|;
comment|/* Don't waste more than two chunks on this */
if|if
condition|(
operator|(
literal|1
operator|<<
operator|(
name|bits
operator|)
operator|)
operator|<=
name|l
operator|+
name|l
condition|)
block|{
name|bp
operator|=
operator|(
expr|struct
name|pginfo
operator|*
operator|)
name|pp
expr_stmt|;
block|}
else|else
block|{
name|bp
operator|=
operator|(
expr|struct
name|pginfo
operator|*
operator|)
name|imalloc
argument_list|(
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bp
condition|)
block|{
name|ifree
argument_list|(
name|pp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
name|bp
operator|->
name|size
operator|=
operator|(
literal|1
operator|<<
name|bits
operator|)
expr_stmt|;
name|bp
operator|->
name|shift
operator|=
name|bits
expr_stmt|;
name|bp
operator|->
name|total
operator|=
name|bp
operator|->
name|free
operator|=
name|malloc_pagesize
operator|>>
name|bits
expr_stmt|;
name|bp
operator|->
name|page
operator|=
name|pp
expr_stmt|;
comment|/* set all valid bits in the bitmap */
name|k
operator|=
name|bp
operator|->
name|total
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/* Do a bunch at a time */
for|for
control|(
init|;
name|k
operator|-
name|i
operator|>=
name|MALLOC_BITS
condition|;
name|i
operator|+=
name|MALLOC_BITS
control|)
name|bp
operator|->
name|bits
index|[
name|i
operator|/
name|MALLOC_BITS
index|]
operator|=
operator|~
literal|0
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|k
condition|;
name|i
operator|++
control|)
name|bp
operator|->
name|bits
index|[
name|i
operator|/
name|MALLOC_BITS
index|]
operator||=
literal|1
operator|<<
operator|(
name|i
operator|%
name|MALLOC_BITS
operator|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|bp
operator|->
name|page
condition|)
block|{
comment|/* Mark the ones we stole for ourselves */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|l
operator|>
literal|0
condition|;
name|i
operator|++
control|)
block|{
name|bp
operator|->
name|bits
index|[
name|i
operator|/
name|MALLOC_BITS
index|]
operator|&=
operator|~
operator|(
literal|1
operator|<<
operator|(
name|i
operator|%
name|MALLOC_BITS
operator|)
operator|)
expr_stmt|;
name|bp
operator|->
name|free
operator|--
expr_stmt|;
name|bp
operator|->
name|total
operator|--
expr_stmt|;
name|l
operator|-=
operator|(
literal|1
operator|<<
name|bits
operator|)
expr_stmt|;
block|}
block|}
comment|/* MALLOC_LOCK */
name|page_dir
index|[
name|ptr2index
argument_list|(
name|pp
argument_list|)
index|]
operator|=
name|bp
expr_stmt|;
name|bp
operator|->
name|next
operator|=
name|page_dir
index|[
name|bits
index|]
expr_stmt|;
name|page_dir
index|[
name|bits
index|]
operator|=
name|bp
expr_stmt|;
comment|/* MALLOC_UNLOCK */
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a fragment  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|malloc_bytes
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|u_int
name|u
decl_stmt|;
name|struct
name|pginfo
modifier|*
name|bp
decl_stmt|;
name|int
name|k
decl_stmt|;
name|u_int
modifier|*
name|lp
decl_stmt|;
comment|/* Don't bother with anything less than this */
if|if
condition|(
name|size
operator|<
name|malloc_minsize
condition|)
name|size
operator|=
name|malloc_minsize
expr_stmt|;
comment|/* Find the right bucket */
name|j
operator|=
literal|1
expr_stmt|;
name|i
operator|=
name|size
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|i
operator|>>=
literal|1
condition|)
name|j
operator|++
expr_stmt|;
comment|/* If it's empty, make a page more of that size chunks */
if|if
condition|(
operator|!
name|page_dir
index|[
name|j
index|]
operator|&&
operator|!
name|malloc_make_chunks
argument_list|(
name|j
argument_list|)
condition|)
return|return
literal|0
return|;
name|bp
operator|=
name|page_dir
index|[
name|j
index|]
expr_stmt|;
comment|/* Find first word of bitmap which isn't empty */
for|for
control|(
name|lp
operator|=
name|bp
operator|->
name|bits
init|;
operator|!
operator|*
name|lp
condition|;
name|lp
operator|++
control|)
empty_stmt|;
comment|/* Find that bit, and tweak it */
name|u
operator|=
literal|1
expr_stmt|;
name|k
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
operator|(
operator|*
name|lp
operator|&
name|u
operator|)
condition|)
block|{
name|u
operator|+=
name|u
expr_stmt|;
name|k
operator|++
expr_stmt|;
block|}
operator|*
name|lp
operator|^=
name|u
expr_stmt|;
comment|/* If there are no more free, remove from free-list */
if|if
condition|(
operator|!
operator|--
name|bp
operator|->
name|free
condition|)
block|{
name|page_dir
index|[
name|j
index|]
operator|=
name|bp
operator|->
name|next
expr_stmt|;
name|bp
operator|->
name|next
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Adjust to the real offset of that chunk */
name|k
operator|+=
operator|(
name|lp
operator|-
name|bp
operator|->
name|bits
operator|)
operator|*
name|MALLOC_BITS
expr_stmt|;
name|k
operator|<<=
name|bp
operator|->
name|shift
expr_stmt|;
if|if
condition|(
name|malloc_junk
condition|)
name|memset
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|bp
operator|->
name|page
operator|+
name|k
argument_list|,
name|SOME_JUNK
argument_list|,
name|bp
operator|->
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|u_char
operator|*
operator|)
name|bp
operator|->
name|page
operator|+
name|k
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a piece of memory  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|imalloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|suicide
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|size
operator|+
name|malloc_pagesize
operator|)
operator|<
name|size
condition|)
comment|/* Check for overflow */
name|result
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|size
operator|<=
name|malloc_maxsize
condition|)
name|result
operator|=
name|malloc_bytes
argument_list|(
name|size
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|malloc_pages
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|malloc_abort
operator|&&
operator|!
name|result
condition|)
name|wrterror
argument_list|(
literal|"allocation failed.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|malloc_zero
operator|&&
name|result
condition|)
name|memset
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Change the size of an allocation.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|irealloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|u_long
name|osize
decl_stmt|,
name|index
decl_stmt|;
name|struct
name|pginfo
modifier|*
modifier|*
name|mp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|suicide
condition|)
name|abort
argument_list|()
expr_stmt|;
name|index
operator|=
name|ptr2index
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
name|malloc_pageshift
condition|)
block|{
name|wrtwarning
argument_list|(
literal|"junk pointer, too low to make sense.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|index
operator|>
name|last_index
condition|)
block|{
name|wrtwarning
argument_list|(
literal|"junk pointer, too high to make sense.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|mp
operator|=
operator|&
name|page_dir
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
operator|*
name|mp
operator|==
name|MALLOC_FIRST
condition|)
block|{
comment|/* Page allocation */
comment|/* Check the pointer */
if|if
condition|(
operator|(
name|u_long
operator|)
name|ptr
operator|&
name|malloc_pagemask
condition|)
block|{
name|wrtwarning
argument_list|(
literal|"modified (page-) pointer.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Find the size in bytes */
for|for
control|(
name|osize
operator|=
name|malloc_pagesize
init|;
operator|*
operator|++
name|mp
operator|==
name|MALLOC_FOLLOW
condition|;
control|)
name|osize
operator|+=
name|malloc_pagesize
expr_stmt|;
if|if
condition|(
operator|!
name|malloc_realloc
operator|&&
comment|/* unless we have to, */
name|size
operator|<=
name|osize
operator|&&
comment|/* .. or are too small, */
name|size
operator|>
operator|(
name|osize
operator|-
name|malloc_pagesize
operator|)
condition|)
block|{
comment|/* .. or can free a page, */
return|return
name|ptr
return|;
comment|/* don't do anything. */
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|mp
operator|>=
name|MALLOC_MAGIC
condition|)
block|{
comment|/* Chunk allocation */
comment|/* Check the pointer for sane values */
if|if
condition|(
operator|(
operator|(
name|u_long
operator|)
name|ptr
operator|&
operator|(
operator|(
operator|*
name|mp
operator|)
operator|->
name|size
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|wrtwarning
argument_list|(
literal|"modified (chunk-) pointer.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Find the chunk index in the page */
name|i
operator|=
operator|(
operator|(
name|u_long
operator|)
name|ptr
operator|&
name|malloc_pagemask
operator|)
operator|>>
operator|(
operator|*
name|mp
operator|)
operator|->
name|shift
expr_stmt|;
comment|/* Verify that it isn't a free chunk already */
if|if
condition|(
operator|(
operator|*
name|mp
operator|)
operator|->
name|bits
index|[
name|i
operator|/
name|MALLOC_BITS
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|i
operator|%
name|MALLOC_BITS
operator|)
operator|)
condition|)
block|{
name|wrtwarning
argument_list|(
literal|"chunk is already free.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|osize
operator|=
operator|(
operator|*
name|mp
operator|)
operator|->
name|size
expr_stmt|;
if|if
condition|(
operator|!
name|malloc_realloc
operator|&&
comment|/* Unless we have to, */
name|size
operator|<
name|osize
operator|&&
comment|/* ..or are too small, */
operator|(
name|size
operator|>
name|osize
operator|/
literal|2
operator|||
comment|/* ..or could use a smaller size, */
name|osize
operator|==
name|malloc_minsize
operator|)
condition|)
block|{
comment|/* ..(if there is one) */
return|return
name|ptr
return|;
comment|/* ..Don't do anything */
block|}
block|}
else|else
block|{
name|wrtwarning
argument_list|(
literal|"pointer to wrong page.\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|p
operator|=
name|imalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
comment|/* copy the lesser of the two sizes, and free the old one */
if|if
condition|(
operator|!
name|size
operator|||
operator|!
name|osize
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|osize
operator|<
name|size
condition|)
name|memcpy
argument_list|(
name|p
argument_list|,
name|ptr
argument_list|,
name|osize
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|p
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/*  * Free a sequence of pages  */
end_comment

begin_function
specifier|static
name|__inline__
name|void
name|free_pages
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|int
name|index
parameter_list|,
name|struct
name|pginfo
modifier|*
name|info
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|pgfree
modifier|*
name|pf
decl_stmt|,
modifier|*
name|pt
init|=
literal|0
decl_stmt|;
name|u_long
name|l
decl_stmt|;
name|void
modifier|*
name|tail
decl_stmt|;
if|if
condition|(
name|info
operator|==
name|MALLOC_FREE
condition|)
block|{
name|wrtwarning
argument_list|(
literal|"page is already free.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|info
operator|!=
name|MALLOC_FIRST
condition|)
block|{
name|wrtwarning
argument_list|(
literal|"pointer to wrong page.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|u_long
operator|)
name|ptr
operator|&
name|malloc_pagemask
condition|)
block|{
name|wrtwarning
argument_list|(
literal|"modified (page-) pointer.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Count how many pages and mark them free at the same time */
name|page_dir
index|[
name|index
index|]
operator|=
name|MALLOC_FREE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|page_dir
index|[
name|index
operator|+
name|i
index|]
operator|==
name|MALLOC_FOLLOW
condition|;
name|i
operator|++
control|)
name|page_dir
index|[
name|index
operator|+
name|i
index|]
operator|=
name|MALLOC_FREE
expr_stmt|;
name|l
operator|=
name|i
operator|<<
name|malloc_pageshift
expr_stmt|;
if|if
condition|(
name|malloc_junk
condition|)
name|memset
argument_list|(
name|ptr
argument_list|,
name|SOME_JUNK
argument_list|,
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|malloc_hint
condition|)
name|madvise
argument_list|(
name|ptr
argument_list|,
name|l
argument_list|,
name|MADV_FREE
argument_list|)
expr_stmt|;
name|tail
operator|=
operator|(
name|char
operator|*
operator|)
name|ptr
operator|+
name|l
expr_stmt|;
comment|/* add to free-list */
if|if
condition|(
operator|!
name|px
condition|)
name|px
operator|=
name|imalloc
argument_list|(
sizeof|sizeof
expr|*
name|pt
argument_list|)
expr_stmt|;
comment|/* This cannot fail... */
name|px
operator|->
name|page
operator|=
name|ptr
expr_stmt|;
name|px
operator|->
name|end
operator|=
name|tail
expr_stmt|;
name|px
operator|->
name|size
operator|=
name|l
expr_stmt|;
if|if
condition|(
operator|!
name|free_list
operator|.
name|next
condition|)
block|{
comment|/* Nothing on free list, put this at head */
name|px
operator|->
name|next
operator|=
name|free_list
operator|.
name|next
expr_stmt|;
name|px
operator|->
name|prev
operator|=
operator|&
name|free_list
expr_stmt|;
name|free_list
operator|.
name|next
operator|=
name|px
expr_stmt|;
name|pf
operator|=
name|px
expr_stmt|;
name|px
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Find the right spot, leave pf pointing to the modified entry. */
name|tail
operator|=
operator|(
name|char
operator|*
operator|)
name|ptr
operator|+
name|l
expr_stmt|;
for|for
control|(
name|pf
operator|=
name|free_list
operator|.
name|next
init|;
name|pf
operator|->
name|end
operator|<
name|ptr
operator|&&
name|pf
operator|->
name|next
condition|;
name|pf
operator|=
name|pf
operator|->
name|next
control|)
empty_stmt|;
comment|/* Race ahead here */
if|if
condition|(
name|pf
operator|->
name|page
operator|>
name|tail
condition|)
block|{
comment|/* Insert before entry */
name|px
operator|->
name|next
operator|=
name|pf
expr_stmt|;
name|px
operator|->
name|prev
operator|=
name|pf
operator|->
name|prev
expr_stmt|;
name|pf
operator|->
name|prev
operator|=
name|px
expr_stmt|;
name|px
operator|->
name|prev
operator|->
name|next
operator|=
name|px
expr_stmt|;
name|pf
operator|=
name|px
expr_stmt|;
name|px
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pf
operator|->
name|end
operator|==
name|ptr
condition|)
block|{
comment|/* Append to the previous entry */
name|pf
operator|->
name|end
operator|=
operator|(
name|char
operator|*
operator|)
name|pf
operator|->
name|end
operator|+
name|l
expr_stmt|;
name|pf
operator|->
name|size
operator|+=
name|l
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|next
operator|&&
name|pf
operator|->
name|end
operator|==
name|pf
operator|->
name|next
operator|->
name|page
condition|)
block|{
comment|/* And collapse the next too. */
name|pt
operator|=
name|pf
operator|->
name|next
expr_stmt|;
name|pf
operator|->
name|end
operator|=
name|pt
operator|->
name|end
expr_stmt|;
name|pf
operator|->
name|size
operator|+=
name|pt
operator|->
name|size
expr_stmt|;
name|pf
operator|->
name|next
operator|=
name|pt
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|pf
operator|->
name|next
condition|)
name|pf
operator|->
name|next
operator|->
name|prev
operator|=
name|pf
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|pf
operator|->
name|page
operator|==
name|tail
condition|)
block|{
comment|/* Prepend to entry */
name|pf
operator|->
name|size
operator|+=
name|l
expr_stmt|;
name|pf
operator|->
name|page
operator|=
name|ptr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|pf
operator|->
name|next
condition|)
block|{
comment|/* Append at tail of chain */
name|px
operator|->
name|next
operator|=
literal|0
expr_stmt|;
name|px
operator|->
name|prev
operator|=
name|pf
expr_stmt|;
name|pf
operator|->
name|next
operator|=
name|px
expr_stmt|;
name|pf
operator|=
name|px
expr_stmt|;
name|px
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|wrterror
argument_list|(
literal|"freelist is destroyed.\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Return something to OS ? */
if|if
condition|(
operator|!
name|pf
operator|->
name|next
operator|&&
comment|/* If we're the last one, */
name|pf
operator|->
name|size
operator|>
name|malloc_cache
operator|&&
comment|/* ..and the cache is full, */
name|pf
operator|->
name|end
operator|==
name|malloc_brk
operator|&&
comment|/* ..and none behind us, */
name|malloc_brk
operator|==
name|sbrk
argument_list|(
literal|0
argument_list|)
condition|)
block|{
comment|/* ..and it's OK to do... */
comment|/* 	 * Keep the cache intact.  Notice that the '>' above guarantees that 	 * the pf will always have at least one page afterwards. 	 */
name|pf
operator|->
name|end
operator|=
operator|(
name|char
operator|*
operator|)
name|pf
operator|->
name|page
operator|+
name|malloc_cache
expr_stmt|;
name|pf
operator|->
name|size
operator|=
name|malloc_cache
expr_stmt|;
name|brk
argument_list|(
name|pf
operator|->
name|end
argument_list|)
expr_stmt|;
name|malloc_brk
operator|=
name|pf
operator|->
name|end
expr_stmt|;
name|index
operator|=
name|ptr2index
argument_list|(
name|pf
operator|->
name|end
argument_list|)
expr_stmt|;
name|last_index
operator|=
name|index
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|index
init|;
name|i
operator|<=
name|last_index
condition|;
control|)
name|page_dir
index|[
name|i
operator|++
index|]
operator|=
name|MALLOC_NOT_MINE
expr_stmt|;
comment|/* XXX: We could realloc/shrink the pagedir here I guess. */
block|}
if|if
condition|(
name|pt
condition|)
name|ifree
argument_list|(
name|pt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Free a chunk, and possibly the page it's on, if the page becomes empty.  */
end_comment

begin_function
specifier|static
name|__inline__
name|void
name|free_bytes
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|int
name|index
parameter_list|,
name|struct
name|pginfo
modifier|*
name|info
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|pginfo
modifier|*
modifier|*
name|mp
decl_stmt|;
name|void
modifier|*
name|vp
decl_stmt|;
comment|/* Find the chunk number on the page */
name|i
operator|=
operator|(
operator|(
name|u_long
operator|)
name|ptr
operator|&
name|malloc_pagemask
operator|)
operator|>>
name|info
operator|->
name|shift
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|u_long
operator|)
name|ptr
operator|&
operator|(
name|info
operator|->
name|size
operator|-
literal|1
operator|)
operator|)
condition|)
block|{
name|wrtwarning
argument_list|(
literal|"modified (chunk-) pointer.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|info
operator|->
name|bits
index|[
name|i
operator|/
name|MALLOC_BITS
index|]
operator|&
operator|(
literal|1
operator|<<
operator|(
name|i
operator|%
name|MALLOC_BITS
operator|)
operator|)
condition|)
block|{
name|wrtwarning
argument_list|(
literal|"chunk is already free.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|malloc_junk
condition|)
name|memset
argument_list|(
name|ptr
argument_list|,
name|SOME_JUNK
argument_list|,
name|info
operator|->
name|size
argument_list|)
expr_stmt|;
name|info
operator|->
name|bits
index|[
name|i
operator|/
name|MALLOC_BITS
index|]
operator||=
literal|1
operator|<<
operator|(
name|i
operator|%
name|MALLOC_BITS
operator|)
expr_stmt|;
name|info
operator|->
name|free
operator|++
expr_stmt|;
name|mp
operator|=
name|page_dir
operator|+
name|info
operator|->
name|shift
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|free
operator|==
literal|1
condition|)
block|{
comment|/* Page became non-full */
name|mp
operator|=
name|page_dir
operator|+
name|info
operator|->
name|shift
expr_stmt|;
comment|/* Insert in address order */
while|while
condition|(
operator|*
name|mp
operator|&&
operator|(
operator|*
name|mp
operator|)
operator|->
name|next
operator|&&
operator|(
operator|*
name|mp
operator|)
operator|->
name|next
operator|->
name|page
operator|<
name|info
operator|->
name|page
condition|)
name|mp
operator|=
operator|&
operator|(
operator|*
name|mp
operator|)
operator|->
name|next
expr_stmt|;
name|info
operator|->
name|next
operator|=
operator|*
name|mp
expr_stmt|;
operator|*
name|mp
operator|=
name|info
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|info
operator|->
name|free
operator|!=
name|info
operator|->
name|total
condition|)
return|return;
comment|/* Find& remove this page in the queue */
while|while
condition|(
operator|*
name|mp
operator|!=
name|info
condition|)
block|{
name|mp
operator|=
operator|&
operator|(
operator|(
operator|*
name|mp
operator|)
operator|->
name|next
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|EXTRA_SANITY
if|if
condition|(
operator|!
operator|*
name|mp
condition|)
name|wrterror
argument_list|(
literal|"(ES): Not on queue\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* EXTRA_SANITY */
block|}
operator|*
name|mp
operator|=
name|info
operator|->
name|next
expr_stmt|;
comment|/* Free the page& the info structure if need be */
name|page_dir
index|[
name|ptr2index
argument_list|(
name|info
operator|->
name|page
argument_list|)
index|]
operator|=
name|MALLOC_FIRST
expr_stmt|;
name|vp
operator|=
name|info
operator|->
name|page
expr_stmt|;
comment|/* Order is important ! */
if|if
condition|(
name|vp
operator|!=
operator|(
name|void
operator|*
operator|)
name|info
condition|)
name|ifree
argument_list|(
name|info
argument_list|)
expr_stmt|;
name|ifree
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ifree
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|struct
name|pginfo
modifier|*
name|info
decl_stmt|;
name|int
name|index
decl_stmt|;
comment|/* This is legal */
if|if
condition|(
operator|!
name|ptr
condition|)
return|return;
if|if
condition|(
operator|!
name|malloc_started
condition|)
block|{
name|wrtwarning
argument_list|(
literal|"malloc() has never been called.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we're already sinking, don't make matters any worse. */
if|if
condition|(
name|suicide
condition|)
return|return;
name|index
operator|=
name|ptr2index
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|<
name|malloc_pageshift
condition|)
block|{
name|wrtwarning
argument_list|(
literal|"junk pointer, too low to make sense.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|index
operator|>
name|last_index
condition|)
block|{
name|wrtwarning
argument_list|(
literal|"junk pointer, too high to make sense.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|info
operator|=
name|page_dir
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|info
operator|<
name|MALLOC_MAGIC
condition|)
name|free_pages
argument_list|(
name|ptr
argument_list|,
name|index
argument_list|,
name|info
argument_list|)
expr_stmt|;
else|else
name|free_bytes
argument_list|(
name|ptr
argument_list|,
name|index
argument_list|,
name|info
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/*  * These are the public exported interface routines.  */
end_comment

begin_function
name|void
modifier|*
name|malloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
specifier|register
name|void
modifier|*
name|r
decl_stmt|;
name|THREAD_STATUS
name|malloc_func
init|=
literal|" in malloc():"
decl_stmt|;
name|THREAD_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|malloc_active
operator|++
condition|)
block|{
name|wrtwarning
argument_list|(
literal|"recursive call.\n"
argument_list|)
expr_stmt|;
name|malloc_active
operator|--
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|malloc_started
condition|)
name|malloc_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|malloc_sysv
operator|&&
operator|!
name|size
condition|)
name|r
operator|=
literal|0
expr_stmt|;
else|else
name|r
operator|=
name|imalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|UTRACE
argument_list|(
literal|0
argument_list|,
name|size
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|malloc_active
operator|--
expr_stmt|;
name|THREAD_UNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|malloc_xmalloc
operator|&&
operator|!
name|r
condition|)
name|wrterror
argument_list|(
literal|"out of memory.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
name|void
name|free
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|THREAD_STATUS
name|malloc_func
init|=
literal|" in free():"
decl_stmt|;
name|THREAD_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|malloc_active
operator|++
condition|)
block|{
name|wrtwarning
argument_list|(
literal|"recursive call.\n"
argument_list|)
expr_stmt|;
name|malloc_active
operator|--
expr_stmt|;
return|return;
block|}
name|ifree
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|UTRACE
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|malloc_active
operator|--
expr_stmt|;
name|THREAD_UNLOCK
argument_list|()
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
modifier|*
name|realloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|THREAD_STATUS
specifier|register
name|void
modifier|*
name|r
decl_stmt|;
name|malloc_func
operator|=
literal|" in realloc():"
expr_stmt|;
name|THREAD_LOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|malloc_active
operator|++
condition|)
block|{
name|wrtwarning
argument_list|(
literal|"recursive call.\n"
argument_list|)
expr_stmt|;
name|malloc_active
operator|--
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|ptr
operator|&&
operator|!
name|malloc_started
condition|)
block|{
name|wrtwarning
argument_list|(
literal|"malloc() has never been called.\n"
argument_list|)
expr_stmt|;
name|ptr
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|malloc_started
condition|)
name|malloc_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|malloc_sysv
operator|&&
operator|!
name|size
condition|)
block|{
name|ifree
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|r
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|ptr
condition|)
block|{
name|r
operator|=
name|imalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|irealloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|UTRACE
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|malloc_active
operator|--
expr_stmt|;
name|THREAD_UNLOCK
argument_list|()
expr_stmt|;
if|if
condition|(
name|malloc_xmalloc
operator|&&
operator|!
name|r
condition|)
name|wrterror
argument_list|(
literal|"out of memory.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

end_unit

