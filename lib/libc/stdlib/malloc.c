begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (C) 2006-2008 Jason Evans<jasone@FreeBSD.org>.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice(s), this list of conditions and the following disclaimer as  *    the first lines of this file unmodified other than the possible  *    addition of one or more copyright notices.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice(s), this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE  * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *******************************************************************************  *  * This allocator implementation is designed to provide scalable performance  * for multi-threaded programs on multi-processor systems.  The following  * features are included for this purpose:  *  *   + Multiple arenas are used if there are multiple CPUs, which reduces lock  *     contention and cache sloshing.  *  *   + Thread-specific caching is used if there are multiple threads, which  *     reduces the amount of locking.  *  *   + Cache line sharing between arenas is avoided for internal data  *     structures.  *  *   + Memory is managed in chunks and runs (chunks can be split into runs),  *     rather than as individual pages.  This provides a constant-time  *     mechanism for associating allocations with particular arenas.  *  * Allocation requests are rounded up to the nearest size class, and no record  * of the original request size is maintained.  Allocations are broken into  * categories according to size class.  Assuming runtime defaults, 4 kB pages  * and a 16 byte quantum on a 32-bit system, the size classes in each category  * are as follows:  *  *   |=======================================|  *   | Category | Subcategory      |    Size |  *   |=======================================|  *   | Small    | Tiny             |       2 |  *   |          |                  |       4 |  *   |          |                  |       8 |  *   |          |------------------+---------|  *   |          | Quantum-spaced   |      16 |  *   |          |                  |      32 |  *   |          |                  |      48 |  *   |          |                  |     ... |  *   |          |                  |      96 |  *   |          |                  |     112 |  *   |          |                  |     128 |  *   |          |------------------+---------|  *   |          | Cacheline-spaced |     192 |  *   |          |                  |     256 |  *   |          |                  |     320 |  *   |          |                  |     384 |  *   |          |                  |     448 |  *   |          |                  |     512 |  *   |          |------------------+---------|  *   |          | Sub-page         |     760 |  *   |          |                  |    1024 |  *   |          |                  |    1280 |  *   |          |                  |     ... |  *   |          |                  |    3328 |  *   |          |                  |    3584 |  *   |          |                  |    3840 |  *   |=======================================|  *   | Large                       |    4 kB |  *   |                             |    8 kB |  *   |                             |   12 kB |  *   |                             |     ... |  *   |                             | 1012 kB |  *   |                             | 1016 kB |  *   |                             | 1020 kB |  *   |=======================================|  *   | Huge                        |    1 MB |  *   |                             |    2 MB |  *   |                             |    3 MB |  *   |                             |     ... |  *   |=======================================|  *  * A different mechanism is used for each category:  *  *   Small : Each size class is segregated into its own set of runs.  Each run  *           maintains a bitmap of which regions are free/allocated.  *  *   Large : Each allocation is backed by a dedicated run.  Metadata are stored  *           in the associated arena chunk header maps.  *  *   Huge : Each allocation is backed by a dedicated contiguous set of chunks.  *          Metadata are stored in a separate red-black tree.  *  *******************************************************************************  */
end_comment

begin_comment
comment|/*  * MALLOC_PRODUCTION disables assertions and statistics gathering.  It also  * defaults the A and J runtime options to off.  These settings are appropriate  * for production systems.  */
end_comment

begin_comment
comment|/* #define	MALLOC_PRODUCTION */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MALLOC_PRODUCTION
end_ifndef

begin_comment
comment|/*     * MALLOC_DEBUG enables assertions and other sanity checks, and disables     * inline functions.     */
end_comment

begin_define
define|#
directive|define
name|MALLOC_DEBUG
end_define

begin_comment
comment|/* MALLOC_STATS enables statistics calculation. */
end_comment

begin_define
define|#
directive|define
name|MALLOC_STATS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * MALLOC_TINY enables support for tiny objects, which are smaller than one  * quantum.  */
end_comment

begin_define
define|#
directive|define
name|MALLOC_TINY
end_define

begin_comment
comment|/*  * MALLOC_MAG enables a magazine-based thread-specific caching layer for small  * objects.  This makes it possible to allocate/deallocate objects without any  * locking when the cache is in the steady state.  */
end_comment

begin_define
define|#
directive|define
name|MALLOC_MAG
end_define

begin_comment
comment|/*  * MALLOC_BALANCE enables monitoring of arena lock contention and dynamically  * re-balances arena load if exponentially averaged contention exceeds a  * certain threshold.  */
end_comment

begin_define
define|#
directive|define
name|MALLOC_BALANCE
end_define

begin_comment
comment|/*  * MALLOC_DSS enables use of sbrk(2) to allocate chunks from the data storage  * segment (DSS).  In an ideal world, this functionality would be completely  * unnecessary, but we are burdened by history and the lack of resource limits  * for anonymous mapped memory.  */
end_comment

begin_define
define|#
directive|define
name|MALLOC_DSS
end_define

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"libc_private.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|_LOCK_DEBUG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"spinlock.h"
end_include

begin_include
include|#
directive|include
file|"namespace.h"
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktrace.h>
end_include

begin_comment
comment|/* Must come after several other sys/ includes. */
end_comment

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/param.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|<sched.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"un-namespace.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|NDEBUG
end_ifdef

begin_undef
undef|#
directive|undef
name|NDEBUG
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_ifndef
ifndef|#
directive|ifndef
name|NDEBUG
end_ifndef

begin_define
define|#
directive|define
name|NDEBUG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"rb.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
end_ifdef

begin_comment
comment|/* Disable inlining to make debugging easier. */
end_comment

begin_define
define|#
directive|define
name|inline
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Size of stack-allocated buffer passed to strerror_r(). */
end_comment

begin_define
define|#
directive|define
name|STRERROR_BUF
value|64
end_define

begin_comment
comment|/*  * Minimum alignment of allocations is 2^QUANTUM_2POW bytes.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__i386__
end_ifdef

begin_define
define|#
directive|define
name|QUANTUM_2POW
value|4
end_define

begin_define
define|#
directive|define
name|SIZEOF_PTR_2POW
value|2
end_define

begin_define
define|#
directive|define
name|CPU_SPINWAIT
value|__asm__ volatile("pause")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__ia64__
end_ifdef

begin_define
define|#
directive|define
name|QUANTUM_2POW
value|4
end_define

begin_define
define|#
directive|define
name|SIZEOF_PTR_2POW
value|3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__alpha__
end_ifdef

begin_define
define|#
directive|define
name|QUANTUM_2POW
value|4
end_define

begin_define
define|#
directive|define
name|SIZEOF_PTR_2POW
value|3
end_define

begin_define
define|#
directive|define
name|NO_TLS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__sparc64__
end_ifdef

begin_define
define|#
directive|define
name|QUANTUM_2POW
value|4
end_define

begin_define
define|#
directive|define
name|SIZEOF_PTR_2POW
value|3
end_define

begin_define
define|#
directive|define
name|NO_TLS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__amd64__
end_ifdef

begin_define
define|#
directive|define
name|QUANTUM_2POW
value|4
end_define

begin_define
define|#
directive|define
name|SIZEOF_PTR_2POW
value|3
end_define

begin_define
define|#
directive|define
name|CPU_SPINWAIT
value|__asm__ volatile("pause")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__arm__
end_ifdef

begin_define
define|#
directive|define
name|QUANTUM_2POW
value|3
end_define

begin_define
define|#
directive|define
name|SIZEOF_PTR_2POW
value|2
end_define

begin_define
define|#
directive|define
name|NO_TLS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__mips__
end_ifdef

begin_define
define|#
directive|define
name|QUANTUM_2POW
value|3
end_define

begin_define
define|#
directive|define
name|SIZEOF_PTR_2POW
value|2
end_define

begin_define
define|#
directive|define
name|NO_TLS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__powerpc__
end_ifdef

begin_define
define|#
directive|define
name|QUANTUM_2POW
value|4
end_define

begin_define
define|#
directive|define
name|SIZEOF_PTR_2POW
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|QUANTUM
value|((size_t)(1U<< QUANTUM_2POW))
end_define

begin_define
define|#
directive|define
name|QUANTUM_MASK
value|(QUANTUM - 1)
end_define

begin_define
define|#
directive|define
name|SIZEOF_PTR
value|(1U<< SIZEOF_PTR_2POW)
end_define

begin_comment
comment|/* sizeof(int) == (1U<< SIZEOF_INT_2POW). */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SIZEOF_INT_2POW
end_ifndef

begin_define
define|#
directive|define
name|SIZEOF_INT_2POW
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We can't use TLS in non-PIC programs, since TLS relies on loader magic. */
end_comment

begin_if
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|PIC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NO_TLS
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|NO_TLS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NO_TLS
end_ifdef

begin_comment
comment|/* MALLOC_MAG requires TLS. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_MAG
end_ifdef

begin_undef
undef|#
directive|undef
name|MALLOC_MAG
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MALLOC_BALANCE requires TLS. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_BALANCE
end_ifdef

begin_undef
undef|#
directive|undef
name|MALLOC_BALANCE
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Size and alignment of memory chunks that are allocated by the OS's virtual  * memory system.  */
end_comment

begin_define
define|#
directive|define
name|CHUNK_2POW_DEFAULT
value|20
end_define

begin_comment
comment|/* Maximum number of dirty pages per arena. */
end_comment

begin_define
define|#
directive|define
name|DIRTY_MAX_DEFAULT
value|(1U<< 9)
end_define

begin_comment
comment|/*  * Maximum size of L1 cache line.  This is used to avoid cache line aliasing.  * In addition, this controls the spacing of cacheline-spaced size classes.  */
end_comment

begin_define
define|#
directive|define
name|CACHELINE_2POW
value|6
end_define

begin_define
define|#
directive|define
name|CACHELINE
value|((size_t)(1U<< CACHELINE_2POW))
end_define

begin_define
define|#
directive|define
name|CACHELINE_MASK
value|(CACHELINE - 1)
end_define

begin_comment
comment|/*  * Subpages are an artificially designated partitioning of pages.  Their only  * purpose is to support subpage-spaced size classes.  *  * There must be at least 4 subpages per page, due to the way size classes are  * handled.  */
end_comment

begin_define
define|#
directive|define
name|SUBPAGE_2POW
value|8
end_define

begin_define
define|#
directive|define
name|SUBPAGE
value|((size_t)(1U<< SUBPAGE_2POW))
end_define

begin_define
define|#
directive|define
name|SUBPAGE_MASK
value|(SUBPAGE - 1)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_TINY
end_ifdef

begin_comment
comment|/* Smallest size class to support. */
end_comment

begin_define
define|#
directive|define
name|TINY_MIN_2POW
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Maximum size class that is a multiple of the quantum, but not (necessarily)  * a power of 2.  Above this size, allocations are rounded up to the nearest  * power of 2.  */
end_comment

begin_define
define|#
directive|define
name|QSPACE_MAX_2POW_DEFAULT
value|7
end_define

begin_comment
comment|/*  * Maximum size class that is a multiple of the cacheline, but not (necessarily)  * a power of 2.  Above this size, allocations are rounded up to the nearest  * power of 2.  */
end_comment

begin_define
define|#
directive|define
name|CSPACE_MAX_2POW_DEFAULT
value|9
end_define

begin_comment
comment|/*  * RUN_MAX_OVRHD indicates maximum desired run header overhead.  Runs are sized  * as small as possible such that this setting is still honored, without  * violating other constraints.  The goal is to make runs as small as possible  * without exceeding a per run external fragmentation threshold.  *  * We use binary fixed point math for overhead computations, where the binary  * point is implicitly RUN_BFP bits to the left.  *  * Note that it is possible to set RUN_MAX_OVRHD low enough that it cannot be  * honored for some/all object sizes, since there is one bit of header overhead  * per object (plus a constant).  This constraint is relaxed (ignored) for runs  * that are so small that the per-region overhead is greater than:  *  *   (RUN_MAX_OVRHD / (reg_size<< (3+RUN_BFP))  */
end_comment

begin_define
define|#
directive|define
name|RUN_BFP
value|12
end_define

begin_comment
comment|/*                                    \/   Implicit binary fixed point. */
end_comment

begin_define
define|#
directive|define
name|RUN_MAX_OVRHD
value|0x0000003dU
end_define

begin_define
define|#
directive|define
name|RUN_MAX_OVRHD_RELAX
value|0x00001800U
end_define

begin_comment
comment|/* Put a cap on small object run size.  This overrides RUN_MAX_OVRHD. */
end_comment

begin_define
define|#
directive|define
name|RUN_MAX_SMALL
value|(12 * PAGE_SIZE)
end_define

begin_comment
comment|/*  * Hyper-threaded CPUs may need a special instruction inside spin loops in  * order to yield to another virtual CPU.  If no such instruction is defined  * above, make CPU_SPINWAIT a no-op.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CPU_SPINWAIT
end_ifndef

begin_define
define|#
directive|define
name|CPU_SPINWAIT
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Adaptive spinning must eventually switch to blocking, in order to avoid the  * potential for priority inversion deadlock.  Backing off past a certain point  * can actually waste time.  */
end_comment

begin_define
define|#
directive|define
name|SPIN_LIMIT_2POW
value|11
end_define

begin_comment
comment|/*  * Conversion from spinning to blocking is expensive; we use (1U<<  * BLOCK_COST_2POW) to estimate how many more times costly blocking is than  * worst-case spinning.  */
end_comment

begin_define
define|#
directive|define
name|BLOCK_COST_2POW
value|4
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_MAG
end_ifdef

begin_comment
comment|/*     * Default magazine size, in bytes.  max_rounds is calculated to make     * optimal use of the space, leaving just enough room for the magazine     * header.     */
end_comment

begin_define
define|#
directive|define
name|MAG_SIZE_2POW_DEFAULT
value|9
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_BALANCE
end_ifdef

begin_comment
comment|/*     * We use an exponential moving average to track recent lock contention,     * where the size of the history window is N, and alpha=2/(N+1).     *     * Due to integer math rounding, very small values here can cause     * substantial degradation in accuracy, thus making the moving average decay     * faster than it would with precise calculation.     */
end_comment

begin_define
define|#
directive|define
name|BALANCE_ALPHA_INV_2POW
value|9
end_define

begin_comment
comment|/*     * Threshold value for the exponential moving contention average at which to     * re-assign a thread.     */
end_comment

begin_define
define|#
directive|define
name|BALANCE_THRESHOLD_DEFAULT
value|(1U<< (SPIN_LIMIT_2POW-4))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Mutexes based on spinlocks.  We can't use normal pthread spinlocks in all  * places, because they require malloc()ed memory, which causes bootstrapping  * issues in some cases.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|spinlock_t
name|lock
decl_stmt|;
block|}
name|malloc_mutex_t
typedef|;
end_typedef

begin_comment
comment|/* Set to true once the allocator has been initialized. */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|malloc_initialized
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Used to avoid initialization races. */
end_comment

begin_decl_stmt
specifier|static
name|malloc_mutex_t
name|init_lock
init|=
block|{
name|_SPINLOCK_INITIALIZER
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Statistics data structures.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_STATS
end_ifdef

begin_typedef
typedef|typedef
name|struct
name|malloc_bin_stats_s
name|malloc_bin_stats_t
typedef|;
end_typedef

begin_struct
struct|struct
name|malloc_bin_stats_s
block|{
comment|/* 	 * Number of allocation requests that corresponded to the size of this 	 * bin. 	 */
name|uint64_t
name|nrequests
decl_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_MAG
comment|/* Number of magazine reloads from this bin. */
name|uint64_t
name|nmags
decl_stmt|;
endif|#
directive|endif
comment|/* Total number of runs created for this bin's size class. */
name|uint64_t
name|nruns
decl_stmt|;
comment|/* 	 * Total number of runs reused by extracting them from the runs tree for 	 * this bin's size class. 	 */
name|uint64_t
name|reruns
decl_stmt|;
comment|/* High-water mark for this bin. */
name|unsigned
name|long
name|highruns
decl_stmt|;
comment|/* Current number of runs in this bin. */
name|unsigned
name|long
name|curruns
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|arena_stats_s
name|arena_stats_t
typedef|;
end_typedef

begin_struct
struct|struct
name|arena_stats_s
block|{
comment|/* Number of bytes currently mapped. */
name|size_t
name|mapped
decl_stmt|;
comment|/* 	 * Total number of purge sweeps, total number of madvise calls made, 	 * and total pages purged in order to keep dirty unused memory under 	 * control. 	 */
name|uint64_t
name|npurge
decl_stmt|;
name|uint64_t
name|nmadvise
decl_stmt|;
name|uint64_t
name|purged
decl_stmt|;
comment|/* Per-size-category statistics. */
name|size_t
name|allocated_small
decl_stmt|;
name|uint64_t
name|nmalloc_small
decl_stmt|;
name|uint64_t
name|ndalloc_small
decl_stmt|;
name|size_t
name|allocated_large
decl_stmt|;
name|uint64_t
name|nmalloc_large
decl_stmt|;
name|uint64_t
name|ndalloc_large
decl_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_BALANCE
comment|/* Number of times this arena reassigned a thread due to contention. */
name|uint64_t
name|nbalance
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|chunk_stats_s
name|chunk_stats_t
typedef|;
end_typedef

begin_struct
struct|struct
name|chunk_stats_s
block|{
comment|/* Number of chunks that were allocated. */
name|uint64_t
name|nchunks
decl_stmt|;
comment|/* High-water mark for number of chunks allocated. */
name|unsigned
name|long
name|highchunks
decl_stmt|;
comment|/* 	 * Current number of chunks allocated.  This value isn't maintained for 	 * any other purpose, so keep track of it in order to be able to set 	 * highchunks. 	 */
name|unsigned
name|long
name|curchunks
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* #ifdef MALLOC_STATS */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Extent data structures.  */
end_comment

begin_comment
comment|/* Tree of extents. */
end_comment

begin_typedef
typedef|typedef
name|struct
name|extent_node_s
name|extent_node_t
typedef|;
end_typedef

begin_struct
struct|struct
name|extent_node_s
block|{
ifdef|#
directive|ifdef
name|MALLOC_DSS
comment|/* Linkage for the size/address-ordered tree. */
name|rb_node
argument_list|(
argument|extent_node_t
argument_list|)
name|link_szad
expr_stmt|;
endif|#
directive|endif
comment|/* Linkage for the address-ordered tree. */
name|rb_node
argument_list|(
argument|extent_node_t
argument_list|)
name|link_ad
expr_stmt|;
comment|/* Pointer to the extent that this tree node is responsible for. */
name|void
modifier|*
name|addr
decl_stmt|;
comment|/* Total region size. */
name|size_t
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|rb_tree
argument_list|(
argument|extent_node_t
argument_list|)
name|extent_tree_t
expr_stmt|;
end_typedef

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Arena data structures.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|arena_s
name|arena_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|arena_bin_s
name|arena_bin_t
typedef|;
end_typedef

begin_comment
comment|/* Each element of the chunk map corresponds to one page within the chunk. */
end_comment

begin_typedef
typedef|typedef
name|struct
name|arena_chunk_map_s
name|arena_chunk_map_t
typedef|;
end_typedef

begin_struct
struct|struct
name|arena_chunk_map_s
block|{
comment|/* 	 * Linkage for run trees.  There are two disjoint uses: 	 * 	 * 1) arena_t's runs_avail tree. 	 * 2) arena_run_t conceptually uses this linkage for in-use non-full 	 *    runs, rather than directly embedding linkage. 	 */
name|rb_node
argument_list|(
argument|arena_chunk_map_t
argument_list|)
name|link
expr_stmt|;
comment|/* 	 * Run address (or size) and various flags are stored together.  The bit 	 * layout looks like (assuming 32-bit system): 	 * 	 *   ???????? ???????? ????---- ---kdzla 	 * 	 * ? : Unallocated: Run address for first/last pages, unset for internal 	 *                  pages. 	 *     Small: Run address. 	 *     Large: Run size for first page, unset for trailing pages. 	 * - : Unused. 	 * k : key? 	 * d : dirty? 	 * z : zeroed? 	 * l : large? 	 * a : allocated? 	 * 	 * Following are example bit patterns for the three types of runs. 	 * 	 * r : run address 	 * s : run size 	 * x : don't care 	 * - : 0 	 * [dzla] : bit set 	 * 	 *   Unallocated: 	 *     ssssssss ssssssss ssss---- -------- 	 *     xxxxxxxx xxxxxxxx xxxx---- ----d--- 	 *     ssssssss ssssssss ssss---- -----z-- 	 * 	 *   Small: 	 *     rrrrrrrr rrrrrrrr rrrr---- -------a 	 *     rrrrrrrr rrrrrrrr rrrr---- -------a 	 *     rrrrrrrr rrrrrrrr rrrr---- -------a 	 * 	 *   Large: 	 *     ssssssss ssssssss ssss---- ------la 	 *     -------- -------- -------- ------la 	 *     -------- -------- -------- ------la 	 */
name|size_t
name|bits
decl_stmt|;
define|#
directive|define
name|CHUNK_MAP_KEY
value|((size_t)0x10U)
define|#
directive|define
name|CHUNK_MAP_DIRTY
value|((size_t)0x08U)
define|#
directive|define
name|CHUNK_MAP_ZEROED
value|((size_t)0x04U)
define|#
directive|define
name|CHUNK_MAP_LARGE
value|((size_t)0x02U)
define|#
directive|define
name|CHUNK_MAP_ALLOCATED
value|((size_t)0x01U)
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|rb_tree
argument_list|(
argument|arena_chunk_map_t
argument_list|)
name|arena_avail_tree_t
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|rb_tree
argument_list|(
argument|arena_chunk_map_t
argument_list|)
name|arena_run_tree_t
expr_stmt|;
end_typedef

begin_comment
comment|/* Arena chunk header. */
end_comment

begin_typedef
typedef|typedef
name|struct
name|arena_chunk_s
name|arena_chunk_t
typedef|;
end_typedef

begin_struct
struct|struct
name|arena_chunk_s
block|{
comment|/* Arena that owns the chunk. */
name|arena_t
modifier|*
name|arena
decl_stmt|;
comment|/* Linkage for the arena's chunks_dirty tree. */
name|rb_node
argument_list|(
argument|arena_chunk_t
argument_list|)
name|link_dirty
expr_stmt|;
comment|/* Number of dirty pages. */
name|size_t
name|ndirty
decl_stmt|;
comment|/* Map of pages within chunk that keeps track of free/large/small. */
name|arena_chunk_map_t
name|map
index|[
literal|1
index|]
decl_stmt|;
comment|/* Dynamically sized. */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|rb_tree
argument_list|(
argument|arena_chunk_t
argument_list|)
name|arena_chunk_tree_t
expr_stmt|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|arena_run_s
name|arena_run_t
typedef|;
end_typedef

begin_struct
struct|struct
name|arena_run_s
block|{
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
name|uint32_t
name|magic
decl_stmt|;
define|#
directive|define
name|ARENA_RUN_MAGIC
value|0x384adf93
endif|#
directive|endif
comment|/* Bin this run is associated with. */
name|arena_bin_t
modifier|*
name|bin
decl_stmt|;
comment|/* Index of first element that might have a free region. */
name|unsigned
name|regs_minelm
decl_stmt|;
comment|/* Number of free regions in run. */
name|unsigned
name|nfree
decl_stmt|;
comment|/* Bitmask of in-use regions (0: in use, 1: free). */
name|unsigned
name|regs_mask
index|[
literal|1
index|]
decl_stmt|;
comment|/* Dynamically sized. */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|arena_bin_s
block|{
comment|/* 	 * Current run being used to service allocations of this bin's size 	 * class. 	 */
name|arena_run_t
modifier|*
name|runcur
decl_stmt|;
comment|/* 	 * Tree of non-full runs.  This tree is used when looking for an 	 * existing run when runcur is no longer usable.  We choose the 	 * non-full run that is lowest in memory; this policy tends to keep 	 * objects packed well, and it can also help reduce the number of 	 * almost-empty chunks. 	 */
name|arena_run_tree_t
name|runs
decl_stmt|;
comment|/* Size of regions in a run for this bin's size class. */
name|size_t
name|reg_size
decl_stmt|;
comment|/* Total size of a run for this bin's size class. */
name|size_t
name|run_size
decl_stmt|;
comment|/* Total number of regions in a run for this bin's size class. */
name|uint32_t
name|nregs
decl_stmt|;
comment|/* Number of elements in a run's regs_mask for this bin's size class. */
name|uint32_t
name|regs_mask_nelms
decl_stmt|;
comment|/* Offset of first region in a run for this bin's size class. */
name|uint32_t
name|reg0_offset
decl_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
comment|/* Bin statistics. */
name|malloc_bin_stats_t
name|stats
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_struct
struct|struct
name|arena_s
block|{
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
name|uint32_t
name|magic
decl_stmt|;
define|#
directive|define
name|ARENA_MAGIC
value|0x947d3d24
endif|#
directive|endif
comment|/* All operations on this arena require that lock be locked. */
name|pthread_mutex_t
name|lock
decl_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena_stats_t
name|stats
decl_stmt|;
endif|#
directive|endif
comment|/* Tree of dirty-page-containing chunks this arena manages. */
name|arena_chunk_tree_t
name|chunks_dirty
decl_stmt|;
comment|/* 	 * In order to avoid rapid chunk allocation/deallocation when an arena 	 * oscillates right on the cusp of needing a new chunk, cache the most 	 * recently freed chunk.  The spare is left in the arena's chunk trees 	 * until it is deleted. 	 * 	 * There is one spare chunk per arena, rather than one spare total, in 	 * order to avoid interactions between multiple threads that could make 	 * a single spare inadequate. 	 */
name|arena_chunk_t
modifier|*
name|spare
decl_stmt|;
comment|/* 	 * Current count of pages within unused runs that are potentially 	 * dirty, and for which madvise(... MADV_FREE) has not been called.  By 	 * tracking this, we can institute a limit on how much dirty unused 	 * memory is mapped for each arena. 	 */
name|size_t
name|ndirty
decl_stmt|;
comment|/* 	 * Size/address-ordered tree of this arena's available runs.  This tree 	 * is used for first-best-fit run allocation. 	 */
name|arena_avail_tree_t
name|runs_avail
decl_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_BALANCE
comment|/* 	 * The arena load balancing machinery needs to keep track of how much 	 * lock contention there is.  This value is exponentially averaged. 	 */
name|uint32_t
name|contention
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * bins is used to store rings of free regions of the following sizes, 	 * assuming a 16-byte quantum, 4kB page size, and default 	 * MALLOC_OPTIONS. 	 * 	 *   bins[i] | size | 	 *   --------+------+ 	 *        0  |    2 | 	 *        1  |    4 | 	 *        2  |    8 | 	 *   --------+------+ 	 *        3  |   16 | 	 *        4  |   32 | 	 *        5  |   48 | 	 *        6  |   64 | 	 *           :      : 	 *           :      : 	 *       33  |  496 | 	 *       34  |  512 | 	 *   --------+------+ 	 *       35  | 1024 | 	 *       36  | 2048 | 	 *   --------+------+ 	 */
name|arena_bin_t
name|bins
index|[
literal|1
index|]
decl_stmt|;
comment|/* Dynamically sized. */
block|}
struct|;
end_struct

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Magazine data structures.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_MAG
end_ifdef

begin_typedef
typedef|typedef
name|struct
name|mag_s
name|mag_t
typedef|;
end_typedef

begin_struct
struct|struct
name|mag_s
block|{
name|size_t
name|binind
decl_stmt|;
comment|/* Index of associated bin. */
name|size_t
name|nrounds
decl_stmt|;
name|void
modifier|*
name|rounds
index|[
literal|1
index|]
decl_stmt|;
comment|/* Dynamically sized. */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Magazines are lazily allocated, but once created, they remain until the  * associated mag_rack is destroyed.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|bin_mags_s
name|bin_mags_t
typedef|;
end_typedef

begin_struct
struct|struct
name|bin_mags_s
block|{
name|mag_t
modifier|*
name|curmag
decl_stmt|;
name|mag_t
modifier|*
name|sparemag
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|mag_rack_s
name|mag_rack_t
typedef|;
end_typedef

begin_struct
struct|struct
name|mag_rack_s
block|{
name|bin_mags_t
name|bin_mags
index|[
literal|1
index|]
decl_stmt|;
comment|/* Dynamically sized. */
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Data.  */
end_comment

begin_comment
comment|/* Number of CPUs. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|ncpus
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Various bin-related settings. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_TINY
end_ifdef

begin_comment
comment|/* Number of (2^n)-spaced tiny bins. */
end_comment

begin_define
define|#
directive|define
name|ntbins
value|((unsigned)(QUANTUM_2POW - TINY_MIN_2POW))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ntbins
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|unsigned
name|nqbins
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of quantum-spaced bins. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|ncbins
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of cacheline-spaced bins. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|nsbins
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of subpage-spaced bins. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|nbins
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_TINY
end_ifdef

begin_define
define|#
directive|define
name|tspace_max
value|((size_t)(QUANTUM>> 1))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|qspace_min
value|QUANTUM
end_define

begin_decl_stmt
specifier|static
name|size_t
name|qspace_max
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|cspace_min
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|cspace_max
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|sspace_min
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|sspace_max
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|bin_maxclass
value|sspace_max
end_define

begin_decl_stmt
specifier|static
name|uint8_t
specifier|const
modifier|*
name|size2bin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * const_size2bin is a static constant lookup table that in the common case can  * be used as-is for size2bin.  For dynamically linked programs, this avoids  * a page of memory overhead per process.  */
end_comment

begin_define
define|#
directive|define
name|S2B_1
parameter_list|(
name|i
parameter_list|)
value|i,
end_define

begin_define
define|#
directive|define
name|S2B_2
parameter_list|(
name|i
parameter_list|)
value|S2B_1(i) S2B_1(i)
end_define

begin_define
define|#
directive|define
name|S2B_4
parameter_list|(
name|i
parameter_list|)
value|S2B_2(i) S2B_2(i)
end_define

begin_define
define|#
directive|define
name|S2B_8
parameter_list|(
name|i
parameter_list|)
value|S2B_4(i) S2B_4(i)
end_define

begin_define
define|#
directive|define
name|S2B_16
parameter_list|(
name|i
parameter_list|)
value|S2B_8(i) S2B_8(i)
end_define

begin_define
define|#
directive|define
name|S2B_32
parameter_list|(
name|i
parameter_list|)
value|S2B_16(i) S2B_16(i)
end_define

begin_define
define|#
directive|define
name|S2B_64
parameter_list|(
name|i
parameter_list|)
value|S2B_32(i) S2B_32(i)
end_define

begin_define
define|#
directive|define
name|S2B_128
parameter_list|(
name|i
parameter_list|)
value|S2B_64(i) S2B_64(i)
end_define

begin_define
define|#
directive|define
name|S2B_256
parameter_list|(
name|i
parameter_list|)
value|S2B_128(i) S2B_128(i)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|uint8_t
name|const_size2bin
index|[
name|PAGE_SIZE
operator|-
literal|255
index|]
init|=
block|{
name|S2B_1
argument_list|(
literal|0xffU
argument_list|)
comment|/*    0 */
if|#
directive|if
operator|(
name|QUANTUM_2POW
operator|==
literal|4
operator|)
comment|/* 64-bit system ************************/
ifdef|#
directive|ifdef
name|MALLOC_TINY
name|S2B_2
argument_list|(
literal|0
argument_list|)
comment|/*    2 */
name|S2B_2
argument_list|(
literal|1
argument_list|)
comment|/*    4 */
name|S2B_4
argument_list|(
literal|2
argument_list|)
comment|/*    8 */
name|S2B_8
argument_list|(
literal|3
argument_list|)
comment|/*   16 */
define|#
directive|define
name|S2B_QMIN
value|3
else|#
directive|else
name|S2B_16
argument_list|(
literal|0
argument_list|)
comment|/*   16 */
define|#
directive|define
name|S2B_QMIN
value|0
endif|#
directive|endif
name|S2B_16
argument_list|(
argument|S2B_QMIN +
literal|1
argument_list|)
comment|/*   32 */
name|S2B_16
argument_list|(
argument|S2B_QMIN +
literal|2
argument_list|)
comment|/*   48 */
name|S2B_16
argument_list|(
argument|S2B_QMIN +
literal|3
argument_list|)
comment|/*   64 */
name|S2B_16
argument_list|(
argument|S2B_QMIN +
literal|4
argument_list|)
comment|/*   80 */
name|S2B_16
argument_list|(
argument|S2B_QMIN +
literal|5
argument_list|)
comment|/*   96 */
name|S2B_16
argument_list|(
argument|S2B_QMIN +
literal|6
argument_list|)
comment|/*  112 */
name|S2B_16
argument_list|(
argument|S2B_QMIN +
literal|7
argument_list|)
comment|/*  128 */
define|#
directive|define
name|S2B_CMIN
value|(S2B_QMIN + 8)
else|#
directive|else
comment|/* 32-bit system ************************/
ifdef|#
directive|ifdef
name|MALLOC_TINY
name|S2B_2
argument_list|(
literal|0
argument_list|)
comment|/*    2 */
name|S2B_2
argument_list|(
literal|1
argument_list|)
comment|/*    4 */
name|S2B_4
argument_list|(
literal|2
argument_list|)
comment|/*    8 */
define|#
directive|define
name|S2B_QMIN
value|2
else|#
directive|else
name|S2B_8
argument_list|(
literal|0
argument_list|)
comment|/*    8 */
define|#
directive|define
name|S2B_QMIN
value|0
endif|#
directive|endif
name|S2B_8
argument_list|(
argument|S2B_QMIN +
literal|1
argument_list|)
comment|/*   16 */
name|S2B_8
argument_list|(
argument|S2B_QMIN +
literal|2
argument_list|)
comment|/*   24 */
name|S2B_8
argument_list|(
argument|S2B_QMIN +
literal|3
argument_list|)
comment|/*   32 */
name|S2B_8
argument_list|(
argument|S2B_QMIN +
literal|4
argument_list|)
comment|/*   40 */
name|S2B_8
argument_list|(
argument|S2B_QMIN +
literal|5
argument_list|)
comment|/*   48 */
name|S2B_8
argument_list|(
argument|S2B_QMIN +
literal|6
argument_list|)
comment|/*   56 */
name|S2B_8
argument_list|(
argument|S2B_QMIN +
literal|7
argument_list|)
comment|/*   64 */
name|S2B_8
argument_list|(
argument|S2B_QMIN +
literal|8
argument_list|)
comment|/*   72 */
name|S2B_8
argument_list|(
argument|S2B_QMIN +
literal|9
argument_list|)
comment|/*   80 */
name|S2B_8
argument_list|(
argument|S2B_QMIN +
literal|10
argument_list|)
comment|/*   88 */
name|S2B_8
argument_list|(
argument|S2B_QMIN +
literal|11
argument_list|)
comment|/*   96 */
name|S2B_8
argument_list|(
argument|S2B_QMIN +
literal|12
argument_list|)
comment|/*  104 */
name|S2B_8
argument_list|(
argument|S2B_QMIN +
literal|13
argument_list|)
comment|/*  112 */
name|S2B_8
argument_list|(
argument|S2B_QMIN +
literal|14
argument_list|)
comment|/*  120 */
name|S2B_8
argument_list|(
argument|S2B_QMIN +
literal|15
argument_list|)
comment|/*  128 */
define|#
directive|define
name|S2B_CMIN
value|(S2B_QMIN + 16)
endif|#
directive|endif
comment|/****************************************/
name|S2B_64
argument_list|(
argument|S2B_CMIN +
literal|0
argument_list|)
comment|/*  192 */
name|S2B_64
argument_list|(
argument|S2B_CMIN +
literal|1
argument_list|)
comment|/*  256 */
name|S2B_64
argument_list|(
argument|S2B_CMIN +
literal|2
argument_list|)
comment|/*  320 */
name|S2B_64
argument_list|(
argument|S2B_CMIN +
literal|3
argument_list|)
comment|/*  384 */
name|S2B_64
argument_list|(
argument|S2B_CMIN +
literal|4
argument_list|)
comment|/*  448 */
name|S2B_64
argument_list|(
argument|S2B_CMIN +
literal|5
argument_list|)
comment|/*  512 */
define|#
directive|define
name|S2B_SMIN
value|(S2B_CMIN + 6)
name|S2B_256
argument_list|(
argument|S2B_SMIN +
literal|0
argument_list|)
comment|/*  768 */
name|S2B_256
argument_list|(
argument|S2B_SMIN +
literal|1
argument_list|)
comment|/* 1024 */
name|S2B_256
argument_list|(
argument|S2B_SMIN +
literal|2
argument_list|)
comment|/* 1280 */
name|S2B_256
argument_list|(
argument|S2B_SMIN +
literal|3
argument_list|)
comment|/* 1536 */
name|S2B_256
argument_list|(
argument|S2B_SMIN +
literal|4
argument_list|)
comment|/* 1792 */
name|S2B_256
argument_list|(
argument|S2B_SMIN +
literal|5
argument_list|)
comment|/* 2048 */
name|S2B_256
argument_list|(
argument|S2B_SMIN +
literal|6
argument_list|)
comment|/* 2304 */
name|S2B_256
argument_list|(
argument|S2B_SMIN +
literal|7
argument_list|)
comment|/* 2560 */
name|S2B_256
argument_list|(
argument|S2B_SMIN +
literal|8
argument_list|)
comment|/* 2816 */
name|S2B_256
argument_list|(
argument|S2B_SMIN +
literal|9
argument_list|)
comment|/* 3072 */
name|S2B_256
argument_list|(
argument|S2B_SMIN +
literal|10
argument_list|)
comment|/* 3328 */
name|S2B_256
argument_list|(
argument|S2B_SMIN +
literal|11
argument_list|)
comment|/* 3584 */
name|S2B_256
argument_list|(
argument|S2B_SMIN +
literal|12
argument_list|)
comment|/* 3840 */
if|#
directive|if
operator|(
name|PAGE_SHIFT
operator|==
literal|13
operator|)
name|S2B_256
argument_list|(
argument|S2B_SMIN +
literal|13
argument_list|)
comment|/* 4096 */
name|S2B_256
argument_list|(
argument|S2B_SMIN +
literal|14
argument_list|)
comment|/* 4352 */
name|S2B_256
argument_list|(
argument|S2B_SMIN +
literal|15
argument_list|)
comment|/* 4608 */
name|S2B_256
argument_list|(
argument|S2B_SMIN +
literal|16
argument_list|)
comment|/* 4864 */
name|S2B_256
argument_list|(
argument|S2B_SMIN +
literal|17
argument_list|)
comment|/* 5120 */
name|S2B_256
argument_list|(
argument|S2B_SMIN +
literal|18
argument_list|)
comment|/* 5376 */
name|S2B_256
argument_list|(
argument|S2B_SMIN +
literal|19
argument_list|)
comment|/* 5632 */
name|S2B_256
argument_list|(
argument|S2B_SMIN +
literal|20
argument_list|)
comment|/* 5888 */
name|S2B_256
argument_list|(
argument|S2B_SMIN +
literal|21
argument_list|)
comment|/* 6144 */
name|S2B_256
argument_list|(
argument|S2B_SMIN +
literal|22
argument_list|)
comment|/* 6400 */
name|S2B_256
argument_list|(
argument|S2B_SMIN +
literal|23
argument_list|)
comment|/* 6656 */
name|S2B_256
argument_list|(
argument|S2B_SMIN +
literal|24
argument_list|)
comment|/* 6912 */
name|S2B_256
argument_list|(
argument|S2B_SMIN +
literal|25
argument_list|)
comment|/* 7168 */
name|S2B_256
argument_list|(
argument|S2B_SMIN +
literal|26
argument_list|)
comment|/* 7424 */
name|S2B_256
argument_list|(
argument|S2B_SMIN +
literal|27
argument_list|)
comment|/* 7680 */
name|S2B_256
argument_list|(
argument|S2B_SMIN +
literal|28
argument_list|)
comment|/* 7936 */
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|S2B_1
end_undef

begin_undef
undef|#
directive|undef
name|S2B_2
end_undef

begin_undef
undef|#
directive|undef
name|S2B_4
end_undef

begin_undef
undef|#
directive|undef
name|S2B_8
end_undef

begin_undef
undef|#
directive|undef
name|S2B_16
end_undef

begin_undef
undef|#
directive|undef
name|S2B_32
end_undef

begin_undef
undef|#
directive|undef
name|S2B_64
end_undef

begin_undef
undef|#
directive|undef
name|S2B_128
end_undef

begin_undef
undef|#
directive|undef
name|S2B_256
end_undef

begin_undef
undef|#
directive|undef
name|S2B_QMIN
end_undef

begin_undef
undef|#
directive|undef
name|S2B_CMIN
end_undef

begin_undef
undef|#
directive|undef
name|S2B_SMIN
end_undef

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_MAG
end_ifdef

begin_decl_stmt
specifier|static
name|size_t
name|max_rounds
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Various chunk-related settings. */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|chunksize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|chunksize_mask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (chunksize - 1). */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|chunk_npages
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|arena_chunk_header_npages
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|arena_maxclass
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Max size class for arenas. */
end_comment

begin_comment
comment|/********/
end_comment

begin_comment
comment|/*  * Chunks.  */
end_comment

begin_comment
comment|/* Protects chunk-related data structures. */
end_comment

begin_decl_stmt
specifier|static
name|malloc_mutex_t
name|huge_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tree of chunks that are stand-alone huge allocations. */
end_comment

begin_decl_stmt
specifier|static
name|extent_tree_t
name|huge
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_DSS
end_ifdef

begin_comment
comment|/*  * Protects sbrk() calls.  This avoids malloc races among threads, though it  * does not protect against races with threads that call sbrk() directly.  */
end_comment

begin_decl_stmt
specifier|static
name|malloc_mutex_t
name|dss_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Base address of the DSS. */
end_comment

begin_decl_stmt
specifier|static
name|void
modifier|*
name|dss_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current end of the DSS, or ((void *)-1) if the DSS is exhausted. */
end_comment

begin_decl_stmt
specifier|static
name|void
modifier|*
name|dss_prev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current upper limit on DSS addresses. */
end_comment

begin_decl_stmt
specifier|static
name|void
modifier|*
name|dss_max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Trees of chunks that were previously allocated (trees differ only in node  * ordering).  These are used when allocating chunks, in an attempt to re-use  * address space.  Depending on function, different tree orderings are needed,  * which is why there are two trees with the same contents.  */
end_comment

begin_decl_stmt
specifier|static
name|extent_tree_t
name|dss_chunks_szad
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|extent_tree_t
name|dss_chunks_ad
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_STATS
end_ifdef

begin_comment
comment|/* Huge allocation statistics. */
end_comment

begin_decl_stmt
specifier|static
name|uint64_t
name|huge_nmalloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|huge_ndalloc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|huge_allocated
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/****************************/
end_comment

begin_comment
comment|/*  * base (internal allocation).  */
end_comment

begin_comment
comment|/*  * Current pages that are being used for internal memory allocations.  These  * pages are carved up in cacheline-size quanta, so that there is no chance of  * false cache line sharing.  */
end_comment

begin_decl_stmt
specifier|static
name|void
modifier|*
name|base_pages
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|base_next_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|base_past_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Addr immediately past base_pages. */
end_comment

begin_decl_stmt
specifier|static
name|extent_node_t
modifier|*
name|base_nodes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|malloc_mutex_t
name|base_mtx
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_STATS
end_ifdef

begin_decl_stmt
specifier|static
name|size_t
name|base_mapped
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/********/
end_comment

begin_comment
comment|/*  * Arenas.  */
end_comment

begin_comment
comment|/*  * Arenas that are used to service external requests.  Not all elements of the  * arenas array are necessarily used; arenas are created lazily as needed.  */
end_comment

begin_decl_stmt
specifier|static
name|arena_t
modifier|*
modifier|*
name|arenas
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|narenas
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NO_TLS
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_BALANCE
end_ifdef

begin_decl_stmt
specifier|static
name|unsigned
name|narenas_2pow
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|unsigned
name|next_arena
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|pthread_mutex_t
name|arenas_lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Protects arenas initialization. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_TLS
end_ifndef

begin_comment
comment|/*  * Map of pthread_self() --> arenas[???], used for selecting an arena to use  * for allocations.  */
end_comment

begin_decl_stmt
specifier|static
name|__thread
name|arena_t
modifier|*
name|arenas_map
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_MAG
end_ifdef

begin_comment
comment|/*  * Map of thread-specific magazine racks, used for thread-specific object  * caching.  */
end_comment

begin_decl_stmt
specifier|static
name|__thread
name|mag_rack_t
modifier|*
name|mag_rack
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_STATS
end_ifdef

begin_comment
comment|/* Chunk statistics. */
end_comment

begin_decl_stmt
specifier|static
name|chunk_stats_t
name|stats_chunks
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*******************************/
end_comment

begin_comment
comment|/*  * Runtime configuration options.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|_malloc_options
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|MALLOC_PRODUCTION
end_ifndef

begin_decl_stmt
specifier|static
name|bool
name|opt_abort
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|opt_junk
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|bool
name|opt_abort
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|opt_junk
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_DSS
end_ifdef

begin_decl_stmt
specifier|static
name|bool
name|opt_dss
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|opt_mmap
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_MAG
end_ifdef

begin_decl_stmt
specifier|static
name|bool
name|opt_mag
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|opt_mag_size_2pow
init|=
name|MAG_SIZE_2POW_DEFAULT
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|size_t
name|opt_dirty_max
init|=
name|DIRTY_MAX_DEFAULT
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_BALANCE
end_ifdef

begin_decl_stmt
specifier|static
name|uint64_t
name|opt_balance_threshold
init|=
name|BALANCE_THRESHOLD_DEFAULT
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|bool
name|opt_print_stats
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|opt_qspace_max_2pow
init|=
name|QSPACE_MAX_2POW_DEFAULT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|opt_cspace_max_2pow
init|=
name|CSPACE_MAX_2POW_DEFAULT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|opt_chunk_2pow
init|=
name|CHUNK_2POW_DEFAULT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|opt_utrace
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|opt_sysv
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|opt_xmalloc
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|opt_zero
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|opt_narenas_lshift
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|size_t
name|s
decl_stmt|;
name|void
modifier|*
name|r
decl_stmt|;
block|}
name|malloc_utrace_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|UTRACE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
define|\
value|if (opt_utrace) {						\ 		malloc_utrace_t ut;					\ 		ut.p = (a);						\ 		ut.s = (b);						\ 		ut.r = (c);						\ 		utrace(&ut, sizeof(ut));				\ 	}
end_define

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin function prototypes for non-inline static functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|malloc_mutex_init
parameter_list|(
name|malloc_mutex_t
modifier|*
name|mutex
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|malloc_spin_init
parameter_list|(
name|pthread_mutex_t
modifier|*
name|lock
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wrtmessage
parameter_list|(
specifier|const
name|char
modifier|*
name|p1
parameter_list|,
specifier|const
name|char
modifier|*
name|p2
parameter_list|,
specifier|const
name|char
modifier|*
name|p3
parameter_list|,
specifier|const
name|char
modifier|*
name|p4
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_STATS
end_ifdef

begin_function_decl
specifier|static
name|void
name|malloc_printf
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|char
modifier|*
name|umax2s
parameter_list|(
name|uintmax_t
name|x
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_DSS
end_ifdef

begin_function_decl
specifier|static
name|bool
name|base_pages_alloc_dss
parameter_list|(
name|size_t
name|minsize
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|bool
name|base_pages_alloc_mmap
parameter_list|(
name|size_t
name|minsize
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|base_pages_alloc
parameter_list|(
name|size_t
name|minsize
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|base_alloc
parameter_list|(
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|base_calloc
parameter_list|(
name|size_t
name|number
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|extent_node_t
modifier|*
name|base_node_alloc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|base_node_dealloc
parameter_list|(
name|extent_node_t
modifier|*
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_STATS
end_ifdef

begin_function_decl
specifier|static
name|void
name|stats_print
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
modifier|*
name|pages_map
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pages_unmap
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_DSS
end_ifdef

begin_function_decl
specifier|static
name|void
modifier|*
name|chunk_alloc_dss
parameter_list|(
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|chunk_recycle_dss
parameter_list|(
name|size_t
name|size
parameter_list|,
name|bool
name|zero
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
modifier|*
name|chunk_alloc_mmap
parameter_list|(
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|chunk_alloc
parameter_list|(
name|size_t
name|size
parameter_list|,
name|bool
name|zero
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_DSS
end_ifdef

begin_function_decl
specifier|static
name|extent_node_t
modifier|*
name|chunk_dealloc_dss_record
parameter_list|(
name|void
modifier|*
name|chunk
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|chunk_dealloc_dss
parameter_list|(
name|void
modifier|*
name|chunk
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|chunk_dealloc_mmap
parameter_list|(
name|void
modifier|*
name|chunk
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chunk_dealloc
parameter_list|(
name|void
modifier|*
name|chunk
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|NO_TLS
end_ifndef

begin_function_decl
specifier|static
name|arena_t
modifier|*
name|choose_arena_hard
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|arena_run_split
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|large
parameter_list|,
name|bool
name|zero
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|arena_chunk_t
modifier|*
name|arena_chunk_alloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arena_chunk_dealloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|arena_run_t
modifier|*
name|arena_run_alloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|large
parameter_list|,
name|bool
name|zero
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arena_purge
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arena_run_dalloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|bool
name|dirty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arena_run_trim_head
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|size_t
name|oldsize
parameter_list|,
name|size_t
name|newsize
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arena_run_trim_tail
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|size_t
name|oldsize
parameter_list|,
name|size_t
name|newsize
parameter_list|,
name|bool
name|dirty
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|arena_run_t
modifier|*
name|arena_bin_nonfull_run_get
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|arena_bin_malloc_hard
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|arena_bin_run_size_calc
parameter_list|(
name|arena_bin_t
modifier|*
name|bin
parameter_list|,
name|size_t
name|min_run_size
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_BALANCE
end_ifdef

begin_function_decl
specifier|static
name|void
name|arena_lock_balance_hard
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_MAG
end_ifdef

begin_function_decl
specifier|static
name|void
name|mag_load
parameter_list|(
name|mag_t
modifier|*
name|mag
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
modifier|*
name|arena_malloc_large
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|zero
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|arena_palloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|alloc_size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|arena_salloc
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_MAG
end_ifdef

begin_function_decl
specifier|static
name|void
name|mag_unload
parameter_list|(
name|mag_t
modifier|*
name|mag
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|arena_dalloc_large
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arena_ralloc_large_shrink
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|oldsize
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arena_ralloc_large_grow
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|oldsize
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arena_ralloc_large
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|oldsize
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|arena_ralloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|oldsize
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arena_new
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|arena_t
modifier|*
name|arenas_extend
parameter_list|(
name|unsigned
name|ind
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_MAG
end_ifdef

begin_function_decl
specifier|static
name|mag_t
modifier|*
name|mag_create
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|binind
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mag_destroy
parameter_list|(
name|mag_t
modifier|*
name|mag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|mag_rack_t
modifier|*
name|mag_rack_create
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mag_rack_destroy
parameter_list|(
name|mag_rack_t
modifier|*
name|rack
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
modifier|*
name|huge_malloc
parameter_list|(
name|size_t
name|size
parameter_list|,
name|bool
name|zero
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|huge_palloc
parameter_list|(
name|size_t
name|alignment
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|huge_ralloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|oldsize
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|huge_dalloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|malloc_print_stats
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
end_ifdef

begin_function_decl
specifier|static
name|void
name|size2bin_validate
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|bool
name|size2bin_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|size2bin_init_hard
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|malloc_init_hard
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * End function prototypes.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin mutex.  We can't use normal pthread mutexes in all places, because  * they require malloc()ed memory, which causes bootstrapping issues in some  * cases.  */
end_comment

begin_function
specifier|static
name|void
name|malloc_mutex_init
parameter_list|(
name|malloc_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
specifier|static
specifier|const
name|spinlock_t
name|lock
init|=
name|_SPINLOCK_INITIALIZER
decl_stmt|;
name|mutex
operator|->
name|lock
operator|=
name|lock
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|malloc_mutex_lock
parameter_list|(
name|malloc_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
if|if
condition|(
name|__isthreaded
condition|)
name|_SPINLOCK
argument_list|(
operator|&
name|mutex
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|malloc_mutex_unlock
parameter_list|(
name|malloc_mutex_t
modifier|*
name|mutex
parameter_list|)
block|{
if|if
condition|(
name|__isthreaded
condition|)
name|_SPINUNLOCK
argument_list|(
operator|&
name|mutex
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * End mutex.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin spin lock.  Spin locks here are actually adaptive mutexes that block  * after a period of spinning, because unbounded spinning would allow for  * priority inversion.  */
end_comment

begin_comment
comment|/*  * We use an unpublished interface to initialize pthread mutexes with an  * allocation callback, in order to avoid infinite recursion.  */
end_comment

begin_function_decl
name|int
name|_pthread_mutex_init_calloc_cb
parameter_list|(
name|pthread_mutex_t
modifier|*
name|mutex
parameter_list|,
name|void
modifier|*
function_decl|(
name|calloc_cb
function_decl|)
parameter_list|(
name|size_t
parameter_list|,
name|size_t
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|__weak_reference
argument_list|(
name|_pthread_mutex_init_calloc_cb_stub
argument_list|,
name|_pthread_mutex_init_calloc_cb
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
name|int
name|_pthread_mutex_init_calloc_cb_stub
parameter_list|(
name|pthread_mutex_t
modifier|*
name|mutex
parameter_list|,
name|void
modifier|*
function_decl|(
name|calloc_cb
function_decl|)
parameter_list|(
name|size_t
parameter_list|,
name|size_t
parameter_list|)
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|malloc_spin_init
parameter_list|(
name|pthread_mutex_t
modifier|*
name|lock
parameter_list|)
block|{
if|if
condition|(
name|_pthread_mutex_init_calloc_cb
argument_list|(
name|lock
argument_list|,
name|base_calloc
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|true
operator|)
return|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|unsigned
name|malloc_spin_lock
parameter_list|(
name|pthread_mutex_t
modifier|*
name|lock
parameter_list|)
block|{
name|unsigned
name|ret
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|__isthreaded
condition|)
block|{
if|if
condition|(
name|_pthread_mutex_trylock
argument_list|(
name|lock
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Exponentially back off if there are multiple CPUs. */
if|if
condition|(
name|ncpus
operator|>
literal|1
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
specifier|volatile
name|unsigned
name|j
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|SPIN_LIMIT_2POW
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
operator|(
literal|1U
operator|<<
name|i
operator|)
condition|;
name|j
operator|++
control|)
block|{
name|ret
operator|++
expr_stmt|;
name|CPU_SPINWAIT
expr_stmt|;
block|}
if|if
condition|(
name|_pthread_mutex_trylock
argument_list|(
name|lock
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
comment|/* 			 * Spinning failed.  Block until the lock becomes 			 * available, in order to avoid indefinite priority 			 * inversion. 			 */
name|_pthread_mutex_lock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|ret
operator|<<
name|BLOCK_COST_2POW
operator|)
operator|!=
literal|0
operator|||
name|ncpus
operator|==
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|<<
name|BLOCK_COST_2POW
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|malloc_spin_unlock
parameter_list|(
name|pthread_mutex_t
modifier|*
name|lock
parameter_list|)
block|{
if|if
condition|(
name|__isthreaded
condition|)
name|_pthread_mutex_unlock
argument_list|(
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * End spin lock.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin Utility functions/macros.  */
end_comment

begin_comment
comment|/* Return the chunk address for allocation address a. */
end_comment

begin_define
define|#
directive|define
name|CHUNK_ADDR2BASE
parameter_list|(
name|a
parameter_list|)
define|\
value|((void *)((uintptr_t)(a)& ~chunksize_mask))
end_define

begin_comment
comment|/* Return the chunk offset of address a. */
end_comment

begin_define
define|#
directive|define
name|CHUNK_ADDR2OFFSET
parameter_list|(
name|a
parameter_list|)
define|\
value|((size_t)((uintptr_t)(a)& chunksize_mask))
end_define

begin_comment
comment|/* Return the smallest chunk multiple that is>= s. */
end_comment

begin_define
define|#
directive|define
name|CHUNK_CEILING
parameter_list|(
name|s
parameter_list|)
define|\
value|(((s) + chunksize_mask)& ~chunksize_mask)
end_define

begin_comment
comment|/* Return the smallest quantum multiple that is>= a. */
end_comment

begin_define
define|#
directive|define
name|QUANTUM_CEILING
parameter_list|(
name|a
parameter_list|)
define|\
value|(((a) + QUANTUM_MASK)& ~QUANTUM_MASK)
end_define

begin_comment
comment|/* Return the smallest cacheline multiple that is>= s. */
end_comment

begin_define
define|#
directive|define
name|CACHELINE_CEILING
parameter_list|(
name|s
parameter_list|)
define|\
value|(((s) + CACHELINE_MASK)& ~CACHELINE_MASK)
end_define

begin_comment
comment|/* Return the smallest subpage multiple that is>= s. */
end_comment

begin_define
define|#
directive|define
name|SUBPAGE_CEILING
parameter_list|(
name|s
parameter_list|)
define|\
value|(((s) + SUBPAGE_MASK)& ~SUBPAGE_MASK)
end_define

begin_comment
comment|/* Return the smallest PAGE_SIZE multiple that is>= s. */
end_comment

begin_define
define|#
directive|define
name|PAGE_CEILING
parameter_list|(
name|s
parameter_list|)
define|\
value|(((s) + PAGE_MASK)& ~PAGE_MASK)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_TINY
end_ifdef

begin_comment
comment|/* Compute the smallest power of 2 that is>= x. */
end_comment

begin_function
specifier|static
specifier|inline
name|size_t
name|pow2_ceil
parameter_list|(
name|size_t
name|x
parameter_list|)
block|{
name|x
operator|--
expr_stmt|;
name|x
operator||=
name|x
operator|>>
literal|1
expr_stmt|;
name|x
operator||=
name|x
operator|>>
literal|2
expr_stmt|;
name|x
operator||=
name|x
operator|>>
literal|4
expr_stmt|;
name|x
operator||=
name|x
operator|>>
literal|8
expr_stmt|;
name|x
operator||=
name|x
operator|>>
literal|16
expr_stmt|;
if|#
directive|if
operator|(
name|SIZEOF_PTR
operator|==
literal|8
operator|)
name|x
operator||=
name|x
operator|>>
literal|32
expr_stmt|;
endif|#
directive|endif
name|x
operator|++
expr_stmt|;
return|return
operator|(
name|x
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_BALANCE
end_ifdef

begin_comment
comment|/*  * Use a simple linear congruential pseudo-random number generator:  *  *   prn(y) = (a*x + c) % m  *  * where the following constants ensure maximal period:  *  *   a == Odd number (relatively prime to 2^n), and (a-1) is a multiple of 4.  *   c == Odd number (relatively prime to 2^n).  *   m == 2^32  *  * See Knuth's TAOCP 3rd Ed., Vol. 2, pg. 17 for details on these constraints.  *  * This choice of m has the disadvantage that the quality of the bits is  * proportional to bit position.  For example. the lowest bit has a cycle of 2,  * the next has a cycle of 4, etc.  For this reason, we prefer to use the upper  * bits.  */
end_comment

begin_define
define|#
directive|define
name|PRN_DEFINE
parameter_list|(
name|suffix
parameter_list|,
name|var
parameter_list|,
name|a
parameter_list|,
name|c
parameter_list|)
define|\
value|static inline void							\ sprn_##suffix(uint32_t seed)						\ {									\ 	var = seed;							\ }									\ 									\ static inline uint32_t							\ prn_##suffix(uint32_t lg_range)						\ {									\ 	uint32_t ret, x;						\ 									\ 	assert(lg_range> 0);						\ 	assert(lg_range<= 32);						\ 									\ 	x = (var * (a)) + (c);						\ 	var = x;							\ 	ret = x>> (32 - lg_range);					\ 									\ 	return (ret);							\ }
end_define

begin_define
define|#
directive|define
name|SPRN
parameter_list|(
name|suffix
parameter_list|,
name|seed
parameter_list|)
value|sprn_##suffix(seed)
end_define

begin_define
define|#
directive|define
name|PRN
parameter_list|(
name|suffix
parameter_list|,
name|lg_range
parameter_list|)
value|prn_##suffix(lg_range)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_BALANCE
end_ifdef

begin_comment
comment|/* Define the PRNG used for arena assignment. */
end_comment

begin_decl_stmt
specifier|static
name|__thread
name|uint32_t
name|balance_x
decl_stmt|;
end_decl_stmt

begin_macro
name|PRN_DEFINE
argument_list|(
argument|balance
argument_list|,
argument|balance_x
argument_list|,
literal|1297
argument_list|,
literal|1301
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|wrtmessage
parameter_list|(
specifier|const
name|char
modifier|*
name|p1
parameter_list|,
specifier|const
name|char
modifier|*
name|p2
parameter_list|,
specifier|const
name|char
modifier|*
name|p3
parameter_list|,
specifier|const
name|char
modifier|*
name|p4
parameter_list|)
block|{
name|_write
argument_list|(
name|STDERR_FILENO
argument_list|,
name|p1
argument_list|,
name|strlen
argument_list|(
name|p1
argument_list|)
argument_list|)
expr_stmt|;
name|_write
argument_list|(
name|STDERR_FILENO
argument_list|,
name|p2
argument_list|,
name|strlen
argument_list|(
name|p2
argument_list|)
argument_list|)
expr_stmt|;
name|_write
argument_list|(
name|STDERR_FILENO
argument_list|,
name|p3
argument_list|,
name|strlen
argument_list|(
name|p3
argument_list|)
argument_list|)
expr_stmt|;
name|_write
argument_list|(
name|STDERR_FILENO
argument_list|,
name|p4
argument_list|,
name|strlen
argument_list|(
name|p4
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
name|void
function_decl|(
modifier|*
name|_malloc_message
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
name|p1
parameter_list|,
specifier|const
name|char
modifier|*
name|p2
parameter_list|,
specifier|const
name|char
modifier|*
name|p3
parameter_list|,
specifier|const
name|char
modifier|*
name|p4
parameter_list|)
init|=
name|wrtmessage
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_STATS
end_ifdef

begin_comment
comment|/*  * Print to stderr in such a way as to (hopefully) avoid memory allocation.  */
end_comment

begin_function
specifier|static
name|void
name|malloc_printf
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|buf
index|[
literal|4096
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|_malloc_message
argument_list|(
name|buf
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * We don't want to depend on vsnprintf() for production builds, since that can  * cause unnecessary bloat for static binaries.  umax2s() provides minimal  * integer printing functionality, so that malloc_printf() use can be limited to  * MALLOC_STATS code.  */
end_comment

begin_define
define|#
directive|define
name|UMAX2S_BUFSIZE
value|21
end_define

begin_function
specifier|static
name|char
modifier|*
name|umax2s
parameter_list|(
name|uintmax_t
name|x
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
comment|/* Make sure UMAX2S_BUFSIZE is large enough. */
name|assert
argument_list|(
sizeof|sizeof
argument_list|(
name|uintmax_t
argument_list|)
operator|<=
literal|8
argument_list|)
expr_stmt|;
name|i
operator|=
name|UMAX2S_BUFSIZE
operator|-
literal|1
expr_stmt|;
name|s
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
do|do
block|{
name|i
operator|--
expr_stmt|;
name|s
index|[
name|i
index|]
operator|=
literal|"0123456789"
index|[
name|x
operator|%
literal|10
index|]
expr_stmt|;
name|x
operator|/=
literal|10
expr_stmt|;
block|}
do|while
condition|(
name|x
operator|>
literal|0
condition|)
do|;
return|return
operator|(
operator|&
name|s
index|[
name|i
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_DSS
end_ifdef

begin_function
specifier|static
name|bool
name|base_pages_alloc_dss
parameter_list|(
name|size_t
name|minsize
parameter_list|)
block|{
comment|/* 	 * Do special DSS allocation here, since base allocations don't need to 	 * be chunk-aligned. 	 */
name|malloc_mutex_lock
argument_list|(
operator|&
name|dss_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dss_prev
operator|!=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
name|intptr_t
name|incr
decl_stmt|;
name|size_t
name|csize
init|=
name|CHUNK_CEILING
argument_list|(
name|minsize
argument_list|)
decl_stmt|;
do|do
block|{
comment|/* Get the current end of the DSS. */
name|dss_max
operator|=
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * Calculate how much padding is necessary to 			 * chunk-align the end of the DSS.  Don't worry about 			 * dss_max not being chunk-aligned though. 			 */
name|incr
operator|=
operator|(
name|intptr_t
operator|)
name|chunksize
operator|-
operator|(
name|intptr_t
operator|)
name|CHUNK_ADDR2OFFSET
argument_list|(
name|dss_max
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|incr
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|incr
operator|<
name|minsize
condition|)
name|incr
operator|+=
name|csize
expr_stmt|;
name|dss_prev
operator|=
name|sbrk
argument_list|(
name|incr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dss_prev
operator|==
name|dss_max
condition|)
block|{
comment|/* Success. */
name|dss_max
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|intptr_t
operator|)
name|dss_prev
operator|+
name|incr
operator|)
expr_stmt|;
name|base_pages
operator|=
name|dss_prev
expr_stmt|;
name|base_next_addr
operator|=
name|base_pages
expr_stmt|;
name|base_past_addr
operator|=
name|dss_max
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|base_mapped
operator|+=
name|incr
expr_stmt|;
endif|#
directive|endif
name|malloc_mutex_unlock
argument_list|(
operator|&
name|dss_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
block|}
do|while
condition|(
name|dss_prev
operator|!=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
condition|)
do|;
block|}
name|malloc_mutex_unlock
argument_list|(
operator|&
name|dss_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|bool
name|base_pages_alloc_mmap
parameter_list|(
name|size_t
name|minsize
parameter_list|)
block|{
name|size_t
name|csize
decl_stmt|;
name|assert
argument_list|(
name|minsize
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|csize
operator|=
name|PAGE_CEILING
argument_list|(
name|minsize
argument_list|)
expr_stmt|;
name|base_pages
operator|=
name|pages_map
argument_list|(
name|NULL
argument_list|,
name|csize
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_pages
operator|==
name|NULL
condition|)
return|return
operator|(
name|true
operator|)
return|;
name|base_next_addr
operator|=
name|base_pages
expr_stmt|;
name|base_past_addr
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|base_pages
operator|+
name|csize
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|base_mapped
operator|+=
name|csize
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|base_pages_alloc
parameter_list|(
name|size_t
name|minsize
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|MALLOC_DSS
if|if
condition|(
name|opt_mmap
operator|&&
name|minsize
operator|!=
literal|0
condition|)
endif|#
directive|endif
block|{
if|if
condition|(
name|base_pages_alloc_mmap
argument_list|(
name|minsize
argument_list|)
operator|==
name|false
condition|)
return|return
operator|(
name|false
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|MALLOC_DSS
if|if
condition|(
name|opt_dss
condition|)
block|{
if|if
condition|(
name|base_pages_alloc_dss
argument_list|(
name|minsize
argument_list|)
operator|==
name|false
condition|)
return|return
operator|(
name|false
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|base_alloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|size_t
name|csize
decl_stmt|;
comment|/* Round size up to nearest multiple of the cacheline size. */
name|csize
operator|=
name|CACHELINE_CEILING
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
comment|/* Make sure there's enough space for the allocation. */
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|base_next_addr
operator|+
name|csize
operator|>
operator|(
name|uintptr_t
operator|)
name|base_past_addr
condition|)
block|{
if|if
condition|(
name|base_pages_alloc
argument_list|(
name|csize
argument_list|)
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
comment|/* Allocate. */
name|ret
operator|=
name|base_next_addr
expr_stmt|;
name|base_next_addr
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|base_next_addr
operator|+
name|csize
operator|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|base_calloc
parameter_list|(
name|size_t
name|number
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|base_alloc
argument_list|(
name|number
operator|*
name|size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|number
operator|*
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|extent_node_t
modifier|*
name|base_node_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|extent_node_t
modifier|*
name|ret
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_nodes
operator|!=
name|NULL
condition|)
block|{
name|ret
operator|=
name|base_nodes
expr_stmt|;
name|base_nodes
operator|=
operator|*
operator|(
name|extent_node_t
operator|*
operator|*
operator|)
name|ret
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|malloc_mutex_unlock
argument_list|(
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|extent_node_t
operator|*
operator|)
name|base_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|extent_node_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|base_node_dealloc
parameter_list|(
name|extent_node_t
modifier|*
name|node
parameter_list|)
block|{
name|malloc_mutex_lock
argument_list|(
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
operator|*
operator|(
name|extent_node_t
operator|*
operator|*
operator|)
name|node
operator|=
name|base_nodes
expr_stmt|;
name|base_nodes
operator|=
name|node
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_STATS
end_ifdef

begin_function
specifier|static
name|void
name|stats_print
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|gap_start
decl_stmt|;
name|malloc_printf
argument_list|(
literal|"dirty: %zu page%s dirty, %llu sweep%s,"
literal|" %llu madvise%s, %llu page%s purged\n"
argument_list|,
name|arena
operator|->
name|ndirty
argument_list|,
name|arena
operator|->
name|ndirty
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|arena
operator|->
name|stats
operator|.
name|npurge
argument_list|,
name|arena
operator|->
name|stats
operator|.
name|npurge
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|arena
operator|->
name|stats
operator|.
name|nmadvise
argument_list|,
name|arena
operator|->
name|stats
operator|.
name|nmadvise
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|arena
operator|->
name|stats
operator|.
name|purged
argument_list|,
name|arena
operator|->
name|stats
operator|.
name|purged
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"            allocated      nmalloc      ndalloc\n"
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"small:   %12zu %12llu %12llu\n"
argument_list|,
name|arena
operator|->
name|stats
operator|.
name|allocated_small
argument_list|,
name|arena
operator|->
name|stats
operator|.
name|nmalloc_small
argument_list|,
name|arena
operator|->
name|stats
operator|.
name|ndalloc_small
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"large:   %12zu %12llu %12llu\n"
argument_list|,
name|arena
operator|->
name|stats
operator|.
name|allocated_large
argument_list|,
name|arena
operator|->
name|stats
operator|.
name|nmalloc_large
argument_list|,
name|arena
operator|->
name|stats
operator|.
name|ndalloc_large
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"total:   %12zu %12llu %12llu\n"
argument_list|,
name|arena
operator|->
name|stats
operator|.
name|allocated_small
operator|+
name|arena
operator|->
name|stats
operator|.
name|allocated_large
argument_list|,
name|arena
operator|->
name|stats
operator|.
name|nmalloc_small
operator|+
name|arena
operator|->
name|stats
operator|.
name|nmalloc_large
argument_list|,
name|arena
operator|->
name|stats
operator|.
name|ndalloc_small
operator|+
name|arena
operator|->
name|stats
operator|.
name|ndalloc_large
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"mapped:  %12zu\n"
argument_list|,
name|arena
operator|->
name|stats
operator|.
name|mapped
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_MAG
if|if
condition|(
name|__isthreaded
operator|&&
name|opt_mag
condition|)
block|{
name|malloc_printf
argument_list|(
literal|"bins:     bin   size regs pgs      mags   "
literal|"newruns    reruns maxruns curruns\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
name|malloc_printf
argument_list|(
literal|"bins:     bin   size regs pgs  requests   "
literal|"newruns    reruns maxruns curruns\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_MAG
block|}
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|gap_start
operator|=
name|UINT_MAX
init|;
name|i
operator|<
name|nbins
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|arena
operator|->
name|bins
index|[
name|i
index|]
operator|.
name|stats
operator|.
name|nruns
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|gap_start
operator|==
name|UINT_MAX
condition|)
name|gap_start
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|gap_start
operator|!=
name|UINT_MAX
condition|)
block|{
if|if
condition|(
name|i
operator|>
name|gap_start
operator|+
literal|1
condition|)
block|{
comment|/* Gap of more than one size class. */
name|malloc_printf
argument_list|(
literal|"[%u..%u]\n"
argument_list|,
name|gap_start
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Gap of one size class. */
name|malloc_printf
argument_list|(
literal|"[%u]\n"
argument_list|,
name|gap_start
argument_list|)
expr_stmt|;
block|}
name|gap_start
operator|=
name|UINT_MAX
expr_stmt|;
block|}
name|malloc_printf
argument_list|(
literal|"%13u %1s %4u %4u %3u %9llu %9llu"
literal|" %9llu %7lu %7lu\n"
argument_list|,
name|i
argument_list|,
name|i
operator|<
name|ntbins
condition|?
literal|"T"
else|:
name|i
operator|<
name|ntbins
operator|+
name|nqbins
condition|?
literal|"Q"
else|:
name|i
operator|<
name|ntbins
operator|+
name|nqbins
operator|+
name|ncbins
condition|?
literal|"C"
else|:
literal|"S"
argument_list|,
name|arena
operator|->
name|bins
index|[
name|i
index|]
operator|.
name|reg_size
argument_list|,
name|arena
operator|->
name|bins
index|[
name|i
index|]
operator|.
name|nregs
argument_list|,
name|arena
operator|->
name|bins
index|[
name|i
index|]
operator|.
name|run_size
operator|>>
name|PAGE_SHIFT
argument_list|,
ifdef|#
directive|ifdef
name|MALLOC_MAG
operator|(
name|__isthreaded
operator|&&
name|opt_mag
operator|)
condition|?
name|arena
operator|->
name|bins
index|[
name|i
index|]
operator|.
name|stats
operator|.
name|nmags
else|:
endif|#
directive|endif
name|arena
operator|->
name|bins
index|[
name|i
index|]
operator|.
name|stats
operator|.
name|nrequests
argument_list|,
name|arena
operator|->
name|bins
index|[
name|i
index|]
operator|.
name|stats
operator|.
name|nruns
argument_list|,
name|arena
operator|->
name|bins
index|[
name|i
index|]
operator|.
name|stats
operator|.
name|reruns
argument_list|,
name|arena
operator|->
name|bins
index|[
name|i
index|]
operator|.
name|stats
operator|.
name|highruns
argument_list|,
name|arena
operator|->
name|bins
index|[
name|i
index|]
operator|.
name|stats
operator|.
name|curruns
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gap_start
operator|!=
name|UINT_MAX
condition|)
block|{
if|if
condition|(
name|i
operator|>
name|gap_start
operator|+
literal|1
condition|)
block|{
comment|/* Gap of more than one size class. */
name|malloc_printf
argument_list|(
literal|"[%u..%u]\n"
argument_list|,
name|gap_start
argument_list|,
name|i
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Gap of one size class. */
name|malloc_printf
argument_list|(
literal|"[%u]\n"
argument_list|,
name|gap_start
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * End Utility functions/macros.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin extent tree code.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_DSS
end_ifdef

begin_function
specifier|static
specifier|inline
name|int
name|extent_szad_comp
parameter_list|(
name|extent_node_t
modifier|*
name|a
parameter_list|,
name|extent_node_t
modifier|*
name|b
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|size_t
name|a_size
init|=
name|a
operator|->
name|size
decl_stmt|;
name|size_t
name|b_size
init|=
name|b
operator|->
name|size
decl_stmt|;
name|ret
operator|=
operator|(
name|a_size
operator|>
name|b_size
operator|)
operator|-
operator|(
name|a_size
operator|<
name|b_size
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|uintptr_t
name|a_addr
init|=
operator|(
name|uintptr_t
operator|)
name|a
operator|->
name|addr
decl_stmt|;
name|uintptr_t
name|b_addr
init|=
operator|(
name|uintptr_t
operator|)
name|b
operator|->
name|addr
decl_stmt|;
name|ret
operator|=
operator|(
name|a_addr
operator|>
name|b_addr
operator|)
operator|-
operator|(
name|a_addr
operator|<
name|b_addr
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Wrap red-black tree macros in functions. */
end_comment

begin_macro
name|rb_wrap
argument_list|(
argument|__unused static
argument_list|,
argument|extent_tree_szad_
argument_list|,
argument|extent_tree_t
argument_list|,
argument|extent_node_t
argument_list|,
argument|link_szad
argument_list|,
argument|extent_szad_comp
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|int
name|extent_ad_comp
parameter_list|(
name|extent_node_t
modifier|*
name|a
parameter_list|,
name|extent_node_t
modifier|*
name|b
parameter_list|)
block|{
name|uintptr_t
name|a_addr
init|=
operator|(
name|uintptr_t
operator|)
name|a
operator|->
name|addr
decl_stmt|;
name|uintptr_t
name|b_addr
init|=
operator|(
name|uintptr_t
operator|)
name|b
operator|->
name|addr
decl_stmt|;
return|return
operator|(
operator|(
name|a_addr
operator|>
name|b_addr
operator|)
operator|-
operator|(
name|a_addr
operator|<
name|b_addr
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Wrap red-black tree macros in functions. */
end_comment

begin_macro
name|rb_wrap
argument_list|(
argument|__unused static
argument_list|,
argument|extent_tree_ad_
argument_list|,
argument|extent_tree_t
argument_list|,
argument|extent_node_t
argument_list|,
argument|link_ad
argument_list|,
argument|extent_ad_comp
argument_list|)
end_macro

begin_comment
comment|/*  * End extent tree code.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin chunk management functions.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|pages_map
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
comment|/* 	 * We don't use MAP_FIXED here, because it can cause the *replacement* 	 * of existing mappings, and we only want to create new mappings. 	 */
name|ret
operator|=
name|mmap
argument_list|(
name|addr
argument_list|,
name|size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
operator||
name|MAP_ANON
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|MAP_FAILED
condition|)
name|ret
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|addr
operator|!=
name|NULL
operator|&&
name|ret
operator|!=
name|addr
condition|)
block|{
comment|/* 		 * We succeeded in mapping memory, but not in the right place. 		 */
if|if
condition|(
name|munmap
argument_list|(
name|ret
argument_list|,
name|size
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|char
name|buf
index|[
name|STRERROR_BUF
index|]
decl_stmt|;
name|strerror_r
argument_list|(
name|errno
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|_malloc_message
argument_list|(
name|_getprogname
argument_list|()
argument_list|,
literal|": (malloc) Error in munmap(): "
argument_list|,
name|buf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_abort
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|ret
operator|=
name|NULL
expr_stmt|;
block|}
name|assert
argument_list|(
name|ret
operator|==
name|NULL
operator|||
operator|(
name|addr
operator|==
name|NULL
operator|&&
name|ret
operator|!=
name|addr
operator|)
operator|||
operator|(
name|addr
operator|!=
name|NULL
operator|&&
name|ret
operator|==
name|addr
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pages_unmap
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
if|if
condition|(
name|munmap
argument_list|(
name|addr
argument_list|,
name|size
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|char
name|buf
index|[
name|STRERROR_BUF
index|]
decl_stmt|;
name|strerror_r
argument_list|(
name|errno
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|_malloc_message
argument_list|(
name|_getprogname
argument_list|()
argument_list|,
literal|": (malloc) Error in munmap(): "
argument_list|,
name|buf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_abort
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_DSS
end_ifdef

begin_function
specifier|static
name|void
modifier|*
name|chunk_alloc_dss
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
comment|/* 	 * sbrk() uses a signed increment argument, so take care not to 	 * interpret a huge allocation request as a negative increment. 	 */
if|if
condition|(
operator|(
name|intptr_t
operator|)
name|size
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|dss_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dss_prev
operator|!=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
name|intptr_t
name|incr
decl_stmt|;
comment|/* 		 * The loop is necessary to recover from races with other 		 * threads that are using the DSS for something other than 		 * malloc. 		 */
do|do
block|{
name|void
modifier|*
name|ret
decl_stmt|;
comment|/* Get the current end of the DSS. */
name|dss_max
operator|=
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * Calculate how much padding is necessary to 			 * chunk-align the end of the DSS. 			 */
name|incr
operator|=
operator|(
name|intptr_t
operator|)
name|size
operator|-
operator|(
name|intptr_t
operator|)
name|CHUNK_ADDR2OFFSET
argument_list|(
name|dss_max
argument_list|)
expr_stmt|;
if|if
condition|(
name|incr
operator|==
operator|(
name|intptr_t
operator|)
name|size
condition|)
name|ret
operator|=
name|dss_max
expr_stmt|;
else|else
block|{
name|ret
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|intptr_t
operator|)
name|dss_max
operator|+
name|incr
operator|)
expr_stmt|;
name|incr
operator|+=
name|size
expr_stmt|;
block|}
name|dss_prev
operator|=
name|sbrk
argument_list|(
name|incr
argument_list|)
expr_stmt|;
if|if
condition|(
name|dss_prev
operator|==
name|dss_max
condition|)
block|{
comment|/* Success. */
name|dss_max
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|intptr_t
operator|)
name|dss_prev
operator|+
name|incr
operator|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|dss_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
do|while
condition|(
name|dss_prev
operator|!=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
condition|)
do|;
block|}
name|malloc_mutex_unlock
argument_list|(
operator|&
name|dss_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|chunk_recycle_dss
parameter_list|(
name|size_t
name|size
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
name|extent_node_t
modifier|*
name|node
decl_stmt|,
name|key
decl_stmt|;
name|key
operator|.
name|addr
operator|=
name|NULL
expr_stmt|;
name|key
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|dss_mtx
argument_list|)
expr_stmt|;
name|node
operator|=
name|extent_tree_szad_nsearch
argument_list|(
operator|&
name|dss_chunks_szad
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
block|{
name|void
modifier|*
name|ret
init|=
name|node
operator|->
name|addr
decl_stmt|;
comment|/* Remove node from the tree. */
name|extent_tree_szad_remove
argument_list|(
operator|&
name|dss_chunks_szad
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|size
operator|==
name|size
condition|)
block|{
name|extent_tree_ad_remove
argument_list|(
operator|&
name|dss_chunks_ad
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|base_node_dealloc
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Insert the remainder of node's address range as a 			 * smaller chunk.  Its position within dss_chunks_ad 			 * does not change. 			 */
name|assert
argument_list|(
name|node
operator|->
name|size
operator|>
name|size
argument_list|)
expr_stmt|;
name|node
operator|->
name|addr
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|node
operator|->
name|addr
operator|+
name|size
operator|)
expr_stmt|;
name|node
operator|->
name|size
operator|-=
name|size
expr_stmt|;
name|extent_tree_szad_insert
argument_list|(
operator|&
name|dss_chunks_szad
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
operator|&
name|dss_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|zero
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|malloc_mutex_unlock
argument_list|(
operator|&
name|dss_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
modifier|*
name|chunk_alloc_mmap
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
comment|/* 	 * Ideally, there would be a way to specify alignment to mmap() (like 	 * NetBSD has), but in the absence of such a feature, we have to work 	 * hard to efficiently create aligned mappings.  The reliable, but 	 * expensive method is to create a mapping that is over-sized, then 	 * trim the excess.  However, that always results in at least one call 	 * to pages_unmap(). 	 * 	 * A more optimistic approach is to try mapping precisely the right 	 * amount, then try to append another mapping if alignment is off.  In 	 * practice, this works out well as long as the application is not 	 * interleaving mappings via direct mmap() calls.  If we do run into a 	 * situation where there is an interleaved mapping and we are unable to 	 * extend an unaligned mapping, our best option is to momentarily 	 * revert to the reliable-but-expensive method.  This will tend to 	 * leave a gap in the memory map that is too small to cause later 	 * problems for the optimistic method. 	 */
name|ret
operator|=
name|pages_map
argument_list|(
name|NULL
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|offset
operator|=
name|CHUNK_ADDR2OFFSET
argument_list|(
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
comment|/* Try to extend chunk boundary. */
if|if
condition|(
name|pages_map
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ret
operator|+
name|size
operator|)
argument_list|,
name|chunksize
operator|-
name|offset
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Extension failed.  Clean up, then revert to the 			 * reliable-but-expensive method. 			 */
name|pages_unmap
argument_list|(
name|ret
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* Beware size_t wrap-around. */
if|if
condition|(
name|size
operator|+
name|chunksize
operator|<=
name|size
condition|)
return|return
name|NULL
return|;
name|ret
operator|=
name|pages_map
argument_list|(
name|NULL
argument_list|,
name|size
operator|+
name|chunksize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Clean up unneeded leading/trailing space. */
name|offset
operator|=
name|CHUNK_ADDR2OFFSET
argument_list|(
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
comment|/* Leading space. */
name|pages_unmap
argument_list|(
name|ret
argument_list|,
name|chunksize
operator|-
name|offset
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ret
operator|+
operator|(
name|chunksize
operator|-
name|offset
operator|)
operator|)
expr_stmt|;
comment|/* Trailing space. */
name|pages_unmap
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ret
operator|+
name|size
operator|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Trailing space only. */
name|pages_unmap
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ret
operator|+
name|size
operator|)
argument_list|,
name|chunksize
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Clean up unneeded leading space. */
name|pages_unmap
argument_list|(
name|ret
argument_list|,
name|chunksize
operator|-
name|offset
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ret
operator|+
operator|(
name|chunksize
operator|-
name|offset
operator|)
operator|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|chunk_alloc
parameter_list|(
name|size_t
name|size
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|assert
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|size
operator|&
name|chunksize_mask
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_DSS
if|if
condition|(
name|opt_mmap
condition|)
endif|#
directive|endif
block|{
name|ret
operator|=
name|chunk_alloc_mmap
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
goto|goto
name|RETURN
goto|;
block|}
ifdef|#
directive|ifdef
name|MALLOC_DSS
if|if
condition|(
name|opt_dss
condition|)
block|{
name|ret
operator|=
name|chunk_recycle_dss
argument_list|(
name|size
argument_list|,
name|zero
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
block|{
goto|goto
name|RETURN
goto|;
block|}
name|ret
operator|=
name|chunk_alloc_dss
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
goto|goto
name|RETURN
goto|;
block|}
endif|#
directive|endif
comment|/* All strategies for allocation failed. */
name|ret
operator|=
name|NULL
expr_stmt|;
name|RETURN
label|:
ifdef|#
directive|ifdef
name|MALLOC_STATS
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
block|{
name|stats_chunks
operator|.
name|nchunks
operator|+=
operator|(
name|size
operator|/
name|chunksize
operator|)
expr_stmt|;
name|stats_chunks
operator|.
name|curchunks
operator|+=
operator|(
name|size
operator|/
name|chunksize
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|stats_chunks
operator|.
name|curchunks
operator|>
name|stats_chunks
operator|.
name|highchunks
condition|)
name|stats_chunks
operator|.
name|highchunks
operator|=
name|stats_chunks
operator|.
name|curchunks
expr_stmt|;
endif|#
directive|endif
name|assert
argument_list|(
name|CHUNK_ADDR2BASE
argument_list|(
name|ret
argument_list|)
operator|==
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_DSS
end_ifdef

begin_function
specifier|static
name|extent_node_t
modifier|*
name|chunk_dealloc_dss_record
parameter_list|(
name|void
modifier|*
name|chunk
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|extent_node_t
modifier|*
name|node
decl_stmt|,
modifier|*
name|prev
decl_stmt|,
name|key
decl_stmt|;
name|key
operator|.
name|addr
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|+
name|size
operator|)
expr_stmt|;
name|node
operator|=
name|extent_tree_ad_nsearch
argument_list|(
operator|&
name|dss_chunks_ad
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
comment|/* Try to coalesce forward. */
if|if
condition|(
name|node
operator|!=
name|NULL
operator|&&
name|node
operator|->
name|addr
operator|==
name|key
operator|.
name|addr
condition|)
block|{
comment|/* 		 * Coalesce chunk with the following address range.  This does 		 * not change the position within dss_chunks_ad, so only 		 * remove/insert from/into dss_chunks_szad. 		 */
name|extent_tree_szad_remove
argument_list|(
operator|&
name|dss_chunks_szad
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|node
operator|->
name|addr
operator|=
name|chunk
expr_stmt|;
name|node
operator|->
name|size
operator|+=
name|size
expr_stmt|;
name|extent_tree_szad_insert
argument_list|(
operator|&
name|dss_chunks_szad
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Coalescing forward failed, so insert a new node.  Drop 		 * dss_mtx during node allocation, since it is possible that a 		 * new base chunk will be allocated. 		 */
name|malloc_mutex_unlock
argument_list|(
operator|&
name|dss_mtx
argument_list|)
expr_stmt|;
name|node
operator|=
name|base_node_alloc
argument_list|()
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|dss_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|node
operator|->
name|addr
operator|=
name|chunk
expr_stmt|;
name|node
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|extent_tree_ad_insert
argument_list|(
operator|&
name|dss_chunks_ad
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|extent_tree_szad_insert
argument_list|(
operator|&
name|dss_chunks_szad
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
comment|/* Try to coalesce backward. */
name|prev
operator|=
name|extent_tree_ad_prev
argument_list|(
operator|&
name|dss_chunks_ad
argument_list|,
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
name|NULL
operator|&&
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|prev
operator|->
name|addr
operator|+
name|prev
operator|->
name|size
operator|)
operator|==
name|chunk
condition|)
block|{
comment|/* 		 * Coalesce chunk with the previous address range.  This does 		 * not change the position within dss_chunks_ad, so only 		 * remove/insert node from/into dss_chunks_szad. 		 */
name|extent_tree_szad_remove
argument_list|(
operator|&
name|dss_chunks_szad
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|extent_tree_ad_remove
argument_list|(
operator|&
name|dss_chunks_ad
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|extent_tree_szad_remove
argument_list|(
operator|&
name|dss_chunks_szad
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|node
operator|->
name|addr
operator|=
name|prev
operator|->
name|addr
expr_stmt|;
name|node
operator|->
name|size
operator|+=
name|prev
operator|->
name|size
expr_stmt|;
name|extent_tree_szad_insert
argument_list|(
operator|&
name|dss_chunks_szad
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|base_node_dealloc
argument_list|(
name|prev
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|node
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|chunk_dealloc_dss
parameter_list|(
name|void
modifier|*
name|chunk
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|malloc_mutex_lock
argument_list|(
operator|&
name|dss_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|>=
operator|(
name|uintptr_t
operator|)
name|dss_base
operator|&&
operator|(
name|uintptr_t
operator|)
name|chunk
operator|<
operator|(
name|uintptr_t
operator|)
name|dss_max
condition|)
block|{
name|extent_node_t
modifier|*
name|node
decl_stmt|;
comment|/* Try to coalesce with other unused chunks. */
name|node
operator|=
name|chunk_dealloc_dss_record
argument_list|(
name|chunk
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
block|{
name|chunk
operator|=
name|node
operator|->
name|addr
expr_stmt|;
name|size
operator|=
name|node
operator|->
name|size
expr_stmt|;
block|}
comment|/* Get the current end of the DSS. */
name|dss_max
operator|=
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Try to shrink the DSS if this chunk is at the end of the 		 * DSS.  The sbrk() call here is subject to a race condition 		 * with threads that use brk(2) or sbrk(2) directly, but the 		 * alternative would be to leak memory for the sake of poorly 		 * designed multi-threaded programs. 		 */
if|if
condition|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|+
name|size
operator|)
operator|==
name|dss_max
operator|&&
operator|(
name|dss_prev
operator|=
name|sbrk
argument_list|(
operator|-
operator|(
name|intptr_t
operator|)
name|size
argument_list|)
operator|)
operator|==
name|dss_max
condition|)
block|{
comment|/* Success. */
name|dss_max
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|intptr_t
operator|)
name|dss_prev
operator|-
operator|(
name|intptr_t
operator|)
name|size
operator|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
block|{
name|extent_tree_szad_remove
argument_list|(
operator|&
name|dss_chunks_szad
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|extent_tree_ad_remove
argument_list|(
operator|&
name|dss_chunks_ad
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|base_node_dealloc
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
operator|&
name|dss_mtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|malloc_mutex_unlock
argument_list|(
operator|&
name|dss_mtx
argument_list|)
expr_stmt|;
name|madvise
argument_list|(
name|chunk
argument_list|,
name|size
argument_list|,
name|MADV_FREE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
name|malloc_mutex_unlock
argument_list|(
operator|&
name|dss_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|chunk_dealloc_mmap
parameter_list|(
name|void
modifier|*
name|chunk
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|pages_unmap
argument_list|(
name|chunk
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|chunk_dealloc
parameter_list|(
name|void
modifier|*
name|chunk
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|assert
argument_list|(
name|chunk
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|CHUNK_ADDR2BASE
argument_list|(
name|chunk
argument_list|)
operator|==
name|chunk
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|size
operator|&
name|chunksize_mask
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|stats_chunks
operator|.
name|curchunks
operator|-=
operator|(
name|size
operator|/
name|chunksize
operator|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MALLOC_DSS
if|if
condition|(
name|opt_dss
condition|)
block|{
if|if
condition|(
name|chunk_dealloc_dss
argument_list|(
name|chunk
argument_list|,
name|size
argument_list|)
operator|==
name|false
condition|)
return|return;
block|}
if|if
condition|(
name|opt_mmap
condition|)
endif|#
directive|endif
name|chunk_dealloc_mmap
argument_list|(
name|chunk
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * End chunk management functions.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin arena.  */
end_comment

begin_comment
comment|/*  * Choose an arena based on a per-thread value (fast-path code, calls slow-path  * code if necessary).  */
end_comment

begin_function
specifier|static
specifier|inline
name|arena_t
modifier|*
name|choose_arena
parameter_list|(
name|void
parameter_list|)
block|{
name|arena_t
modifier|*
name|ret
decl_stmt|;
comment|/* 	 * We can only use TLS if this is a PIC library, since for the static 	 * library version, libc's malloc is used by TLS allocation, which 	 * introduces a bootstrapping issue. 	 */
ifndef|#
directive|ifndef
name|NO_TLS
if|if
condition|(
name|__isthreaded
operator|==
name|false
condition|)
block|{
comment|/* Avoid the overhead of TLS for single-threaded operation. */
return|return
operator|(
name|arenas
index|[
literal|0
index|]
operator|)
return|;
block|}
name|ret
operator|=
name|arenas_map
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|choose_arena_hard
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
name|__isthreaded
operator|&&
name|narenas
operator|>
literal|1
condition|)
block|{
name|unsigned
name|long
name|ind
decl_stmt|;
comment|/* 		 * Hash _pthread_self() to one of the arenas.  There is a prime 		 * number of arenas, so this has a reasonable chance of 		 * working.  Even so, the hashing can be easily thwarted by 		 * inconvenient _pthread_self() values.  Without specific 		 * knowledge of how _pthread_self() calculates values, we can't 		 * easily do much better than this. 		 */
name|ind
operator|=
operator|(
name|unsigned
name|long
operator|)
name|_pthread_self
argument_list|()
operator|%
name|narenas
expr_stmt|;
comment|/* 		 * Optimistially assume that arenas[ind] has been initialized. 		 * At worst, we find out that some other thread has already 		 * done so, after acquiring the lock in preparation.  Note that 		 * this lazy locking also has the effect of lazily forcing 		 * cache coherency; without the lock acquisition, there's no 		 * guarantee that modification of arenas[ind] by another thread 		 * would be seen on this CPU for an arbitrary amount of time. 		 * 		 * In general, this approach to modifying a synchronized value 		 * isn't a good idea, but in this case we only ever modify the 		 * value once, so things work out well. 		 */
name|ret
operator|=
name|arenas
index|[
name|ind
index|]
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Avoid races with another thread that may have already 			 * initialized arenas[ind]. 			 */
name|malloc_spin_lock
argument_list|(
operator|&
name|arenas_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|arenas
index|[
name|ind
index|]
operator|==
name|NULL
condition|)
name|ret
operator|=
name|arenas_extend
argument_list|(
operator|(
name|unsigned
operator|)
name|ind
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|arenas
index|[
name|ind
index|]
expr_stmt|;
name|malloc_spin_unlock
argument_list|(
operator|&
name|arenas_lock
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|ret
operator|=
name|arenas
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
name|assert
argument_list|(
name|ret
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_TLS
end_ifndef

begin_comment
comment|/*  * Choose an arena based on a per-thread value (slow-path code only, called  * only by choose_arena()).  */
end_comment

begin_function
specifier|static
name|arena_t
modifier|*
name|choose_arena_hard
parameter_list|(
name|void
parameter_list|)
block|{
name|arena_t
modifier|*
name|ret
decl_stmt|;
name|assert
argument_list|(
name|__isthreaded
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_BALANCE
comment|/* Seed the PRNG used for arena load balancing. */
name|SPRN
argument_list|(
name|balance
argument_list|,
call|(
name|uint32_t
call|)
argument_list|(
name|uintptr_t
argument_list|)
argument_list|(
name|_pthread_self
argument_list|()
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|narenas
operator|>
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|MALLOC_BALANCE
name|unsigned
name|ind
decl_stmt|;
name|ind
operator|=
name|PRN
argument_list|(
name|balance
argument_list|,
name|narenas_2pow
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|arenas
index|[
name|ind
index|]
operator|)
operator|==
name|NULL
condition|)
block|{
name|malloc_spin_lock
argument_list|(
operator|&
name|arenas_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|arenas
index|[
name|ind
index|]
operator|)
operator|==
name|NULL
condition|)
name|ret
operator|=
name|arenas_extend
argument_list|(
name|ind
argument_list|)
expr_stmt|;
name|malloc_spin_unlock
argument_list|(
operator|&
name|arenas_lock
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|malloc_spin_lock
argument_list|(
operator|&
name|arenas_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|arenas
index|[
name|next_arena
index|]
operator|)
operator|==
name|NULL
condition|)
name|ret
operator|=
name|arenas_extend
argument_list|(
name|next_arena
argument_list|)
expr_stmt|;
name|next_arena
operator|=
operator|(
name|next_arena
operator|+
literal|1
operator|)
operator|%
name|narenas
expr_stmt|;
name|malloc_spin_unlock
argument_list|(
operator|&
name|arenas_lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|ret
operator|=
name|arenas
index|[
literal|0
index|]
expr_stmt|;
name|arenas_map
operator|=
name|ret
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|int
name|arena_chunk_comp
parameter_list|(
name|arena_chunk_t
modifier|*
name|a
parameter_list|,
name|arena_chunk_t
modifier|*
name|b
parameter_list|)
block|{
name|uintptr_t
name|a_chunk
init|=
operator|(
name|uintptr_t
operator|)
name|a
decl_stmt|;
name|uintptr_t
name|b_chunk
init|=
operator|(
name|uintptr_t
operator|)
name|b
decl_stmt|;
name|assert
argument_list|(
name|a
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|b
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|a_chunk
operator|>
name|b_chunk
operator|)
operator|-
operator|(
name|a_chunk
operator|<
name|b_chunk
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Wrap red-black tree macros in functions. */
end_comment

begin_macro
name|rb_wrap
argument_list|(
argument|__unused static
argument_list|,
argument|arena_chunk_tree_dirty_
argument_list|,
argument|arena_chunk_tree_t
argument_list|,
argument|arena_chunk_t
argument_list|,
argument|link_dirty
argument_list|,
argument|arena_chunk_comp
argument_list|)
end_macro

begin_function
specifier|static
specifier|inline
name|int
name|arena_run_comp
parameter_list|(
name|arena_chunk_map_t
modifier|*
name|a
parameter_list|,
name|arena_chunk_map_t
modifier|*
name|b
parameter_list|)
block|{
name|uintptr_t
name|a_mapelm
init|=
operator|(
name|uintptr_t
operator|)
name|a
decl_stmt|;
name|uintptr_t
name|b_mapelm
init|=
operator|(
name|uintptr_t
operator|)
name|b
decl_stmt|;
name|assert
argument_list|(
name|a
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|b
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|a_mapelm
operator|>
name|b_mapelm
operator|)
operator|-
operator|(
name|a_mapelm
operator|<
name|b_mapelm
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Wrap red-black tree macros in functions. */
end_comment

begin_macro
name|rb_wrap
argument_list|(
argument|__unused static
argument_list|,
argument|arena_run_tree_
argument_list|,
argument|arena_run_tree_t
argument_list|,
argument|arena_chunk_map_t
argument_list|,
argument|link
argument_list|,
argument|arena_run_comp
argument_list|)
end_macro

begin_function
specifier|static
specifier|inline
name|int
name|arena_avail_comp
parameter_list|(
name|arena_chunk_map_t
modifier|*
name|a
parameter_list|,
name|arena_chunk_map_t
modifier|*
name|b
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|size_t
name|a_size
init|=
name|a
operator|->
name|bits
operator|&
operator|~
name|PAGE_MASK
decl_stmt|;
name|size_t
name|b_size
init|=
name|b
operator|->
name|bits
operator|&
operator|~
name|PAGE_MASK
decl_stmt|;
name|ret
operator|=
operator|(
name|a_size
operator|>
name|b_size
operator|)
operator|-
operator|(
name|a_size
operator|<
name|b_size
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
name|uintptr_t
name|a_mapelm
decl_stmt|,
name|b_mapelm
decl_stmt|;
if|if
condition|(
operator|(
name|a
operator|->
name|bits
operator|&
name|CHUNK_MAP_KEY
operator|)
operator|==
literal|0
condition|)
name|a_mapelm
operator|=
operator|(
name|uintptr_t
operator|)
name|a
expr_stmt|;
else|else
block|{
comment|/* 			 * Treat keys as though they are lower than anything 			 * else. 			 */
name|a_mapelm
operator|=
literal|0
expr_stmt|;
block|}
name|b_mapelm
operator|=
operator|(
name|uintptr_t
operator|)
name|b
expr_stmt|;
name|ret
operator|=
operator|(
name|a_mapelm
operator|>
name|b_mapelm
operator|)
operator|-
operator|(
name|a_mapelm
operator|<
name|b_mapelm
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Wrap red-black tree macros in functions. */
end_comment

begin_macro
name|rb_wrap
argument_list|(
argument|__unused static
argument_list|,
argument|arena_avail_tree_
argument_list|,
argument|arena_avail_tree_t
argument_list|,
argument|arena_chunk_map_t
argument_list|,
argument|link
argument_list|,
argument|arena_avail_comp
argument_list|)
end_macro

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|arena_run_reg_alloc
parameter_list|(
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|mask
decl_stmt|,
name|bit
decl_stmt|,
name|regind
decl_stmt|;
name|assert
argument_list|(
name|run
operator|->
name|magic
operator|==
name|ARENA_RUN_MAGIC
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|run
operator|->
name|regs_minelm
operator|<
name|bin
operator|->
name|regs_mask_nelms
argument_list|)
expr_stmt|;
comment|/* 	 * Move the first check outside the loop, so that run->regs_minelm can 	 * be updated unconditionally, without the possibility of updating it 	 * multiple times. 	 */
name|i
operator|=
name|run
operator|->
name|regs_minelm
expr_stmt|;
name|mask
operator|=
name|run
operator|->
name|regs_mask
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|mask
operator|!=
literal|0
condition|)
block|{
comment|/* Usable allocation found. */
name|bit
operator|=
name|ffs
argument_list|(
operator|(
name|int
operator|)
name|mask
argument_list|)
operator|-
literal|1
expr_stmt|;
name|regind
operator|=
operator|(
operator|(
name|i
operator|<<
operator|(
name|SIZEOF_INT_2POW
operator|+
literal|3
operator|)
operator|)
operator|+
name|bit
operator|)
expr_stmt|;
name|assert
argument_list|(
name|regind
operator|<
name|bin
operator|->
name|nregs
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
name|run
operator|)
operator|+
name|bin
operator|->
name|reg0_offset
operator|+
operator|(
name|bin
operator|->
name|reg_size
operator|*
name|regind
operator|)
operator|)
expr_stmt|;
comment|/* Clear bit. */
name|mask
operator|^=
operator|(
literal|1U
operator|<<
name|bit
operator|)
expr_stmt|;
name|run
operator|->
name|regs_mask
index|[
name|i
index|]
operator|=
name|mask
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
for|for
control|(
name|i
operator|++
init|;
name|i
operator|<
name|bin
operator|->
name|regs_mask_nelms
condition|;
name|i
operator|++
control|)
block|{
name|mask
operator|=
name|run
operator|->
name|regs_mask
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|mask
operator|!=
literal|0
condition|)
block|{
comment|/* Usable allocation found. */
name|bit
operator|=
name|ffs
argument_list|(
operator|(
name|int
operator|)
name|mask
argument_list|)
operator|-
literal|1
expr_stmt|;
name|regind
operator|=
operator|(
operator|(
name|i
operator|<<
operator|(
name|SIZEOF_INT_2POW
operator|+
literal|3
operator|)
operator|)
operator|+
name|bit
operator|)
expr_stmt|;
name|assert
argument_list|(
name|regind
operator|<
name|bin
operator|->
name|nregs
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
name|run
operator|)
operator|+
name|bin
operator|->
name|reg0_offset
operator|+
operator|(
name|bin
operator|->
name|reg_size
operator|*
name|regind
operator|)
operator|)
expr_stmt|;
comment|/* Clear bit. */
name|mask
operator|^=
operator|(
literal|1U
operator|<<
name|bit
operator|)
expr_stmt|;
name|run
operator|->
name|regs_mask
index|[
name|i
index|]
operator|=
name|mask
expr_stmt|;
comment|/* 			 * Make a note that nothing before this element 			 * contains a free region. 			 */
name|run
operator|->
name|regs_minelm
operator|=
name|i
expr_stmt|;
comment|/* Low payoff: + (mask == 0); */
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
comment|/* Not reached. */
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|arena_run_reg_dalloc
parameter_list|(
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|unsigned
name|shift
decl_stmt|,
name|diff
decl_stmt|,
name|regind
decl_stmt|,
name|elm
decl_stmt|,
name|bit
decl_stmt|;
name|assert
argument_list|(
name|run
operator|->
name|magic
operator|==
name|ARENA_RUN_MAGIC
argument_list|)
expr_stmt|;
comment|/* 	 * Avoid doing division with a variable divisor if possible.  Using 	 * actual division here can reduce allocator throughput by over 20%! 	 */
name|diff
operator|=
call|(
name|unsigned
call|)
argument_list|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
operator|(
name|uintptr_t
operator|)
name|run
operator|-
name|bin
operator|->
name|reg0_offset
argument_list|)
expr_stmt|;
comment|/* Rescale (factor powers of 2 out of the numerator and denominator). */
name|shift
operator|=
name|ffs
argument_list|(
name|size
argument_list|)
operator|-
literal|1
expr_stmt|;
name|diff
operator|>>=
name|shift
expr_stmt|;
name|size
operator|>>=
name|shift
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|1
condition|)
block|{
comment|/* The divisor was a power of 2. */
name|regind
operator|=
name|diff
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * To divide by a number D that is not a power of two we 		 * multiply by (2^21 / D) and then right shift by 21 positions. 		 * 		 *   X / D 		 * 		 * becomes 		 * 		 *   (X * size_invs[D - 3])>> SIZE_INV_SHIFT 		 * 		 * We can omit the first three elements, because we never 		 * divide by 0, and 1 and 2 are both powers of two, which are 		 * handled above. 		 */
define|#
directive|define
name|SIZE_INV_SHIFT
value|21
define|#
directive|define
name|SIZE_INV
parameter_list|(
name|s
parameter_list|)
value|(((1U<< SIZE_INV_SHIFT) / (s)) + 1)
specifier|static
specifier|const
name|unsigned
name|size_invs
index|[]
init|=
block|{
name|SIZE_INV
argument_list|(
literal|3
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|4
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|5
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|6
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|7
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|8
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|9
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|10
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|11
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|12
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|13
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|14
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|15
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|16
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|17
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|18
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|19
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|20
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|21
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|22
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|23
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|24
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|25
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|26
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|27
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|28
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|29
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|30
argument_list|)
block|,
name|SIZE_INV
argument_list|(
literal|31
argument_list|)
block|}
decl_stmt|;
if|if
condition|(
name|size
operator|<=
operator|(
operator|(
sizeof|sizeof
argument_list|(
name|size_invs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
operator|)
operator|+
literal|2
operator|)
condition|)
name|regind
operator|=
operator|(
name|diff
operator|*
name|size_invs
index|[
name|size
operator|-
literal|3
index|]
operator|)
operator|>>
name|SIZE_INV_SHIFT
expr_stmt|;
else|else
name|regind
operator|=
name|diff
operator|/
name|size
expr_stmt|;
undef|#
directive|undef
name|SIZE_INV
undef|#
directive|undef
name|SIZE_INV_SHIFT
block|}
name|assert
argument_list|(
name|diff
operator|==
name|regind
operator|*
name|size
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|regind
operator|<
name|bin
operator|->
name|nregs
argument_list|)
expr_stmt|;
name|elm
operator|=
name|regind
operator|>>
operator|(
name|SIZEOF_INT_2POW
operator|+
literal|3
operator|)
expr_stmt|;
if|if
condition|(
name|elm
operator|<
name|run
operator|->
name|regs_minelm
condition|)
name|run
operator|->
name|regs_minelm
operator|=
name|elm
expr_stmt|;
name|bit
operator|=
name|regind
operator|-
operator|(
name|elm
operator|<<
operator|(
name|SIZEOF_INT_2POW
operator|+
literal|3
operator|)
operator|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|run
operator|->
name|regs_mask
index|[
name|elm
index|]
operator|&
operator|(
literal|1U
operator|<<
name|bit
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|run
operator|->
name|regs_mask
index|[
name|elm
index|]
operator||=
operator|(
literal|1U
operator|<<
name|bit
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_run_split
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|large
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|size_t
name|old_ndirty
decl_stmt|,
name|run_ind
decl_stmt|,
name|total_pages
decl_stmt|,
name|need_pages
decl_stmt|,
name|rem_pages
decl_stmt|,
name|i
decl_stmt|;
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|run
argument_list|)
expr_stmt|;
name|old_ndirty
operator|=
name|chunk
operator|->
name|ndirty
expr_stmt|;
name|run_ind
operator|=
call|(
name|unsigned
call|)
argument_list|(
operator|(
operator|(
name|uintptr_t
operator|)
name|run
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|PAGE_SHIFT
argument_list|)
expr_stmt|;
name|total_pages
operator|=
operator|(
name|chunk
operator|->
name|map
index|[
name|run_ind
index|]
operator|.
name|bits
operator|&
operator|~
name|PAGE_MASK
operator|)
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|need_pages
operator|=
operator|(
name|size
operator|>>
name|PAGE_SHIFT
operator|)
expr_stmt|;
name|assert
argument_list|(
name|need_pages
operator|>
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|need_pages
operator|<=
name|total_pages
argument_list|)
expr_stmt|;
name|rem_pages
operator|=
name|total_pages
operator|-
name|need_pages
expr_stmt|;
name|arena_avail_tree_remove
argument_list|(
operator|&
name|arena
operator|->
name|runs_avail
argument_list|,
operator|&
name|chunk
operator|->
name|map
index|[
name|run_ind
index|]
argument_list|)
expr_stmt|;
comment|/* Keep track of trailing unused pages for later use. */
if|if
condition|(
name|rem_pages
operator|>
literal|0
condition|)
block|{
name|chunk
operator|->
name|map
index|[
name|run_ind
operator|+
name|need_pages
index|]
operator|.
name|bits
operator|=
operator|(
name|rem_pages
operator|<<
name|PAGE_SHIFT
operator|)
operator||
operator|(
name|chunk
operator|->
name|map
index|[
name|run_ind
operator|+
name|need_pages
index|]
operator|.
name|bits
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
name|chunk
operator|->
name|map
index|[
name|run_ind
operator|+
name|total_pages
operator|-
literal|1
index|]
operator|.
name|bits
operator|=
operator|(
name|rem_pages
operator|<<
name|PAGE_SHIFT
operator|)
operator||
operator|(
name|chunk
operator|->
name|map
index|[
name|run_ind
operator|+
name|total_pages
operator|-
literal|1
index|]
operator|.
name|bits
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
name|arena_avail_tree_insert
argument_list|(
operator|&
name|arena
operator|->
name|runs_avail
argument_list|,
operator|&
name|chunk
operator|->
name|map
index|[
name|run_ind
operator|+
name|need_pages
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|need_pages
condition|;
name|i
operator|++
control|)
block|{
comment|/* Zero if necessary. */
if|if
condition|(
name|zero
condition|)
block|{
if|if
condition|(
operator|(
name|chunk
operator|->
name|map
index|[
name|run_ind
operator|+
name|i
index|]
operator|.
name|bits
operator|&
name|CHUNK_MAP_ZEROED
operator|)
operator|==
literal|0
condition|)
block|{
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|+
operator|(
operator|(
name|run_ind
operator|+
name|i
operator|)
operator|<<
name|PAGE_SHIFT
operator|)
operator|)
argument_list|,
literal|0
argument_list|,
name|PAGE_SIZE
argument_list|)
expr_stmt|;
comment|/* CHUNK_MAP_ZEROED is cleared below. */
block|}
block|}
comment|/* Update dirty page accounting. */
if|if
condition|(
name|chunk
operator|->
name|map
index|[
name|run_ind
operator|+
name|i
index|]
operator|.
name|bits
operator|&
name|CHUNK_MAP_DIRTY
condition|)
block|{
name|chunk
operator|->
name|ndirty
operator|--
expr_stmt|;
name|arena
operator|->
name|ndirty
operator|--
expr_stmt|;
comment|/* CHUNK_MAP_DIRTY is cleared below. */
block|}
comment|/* Initialize the chunk map. */
if|if
condition|(
name|large
condition|)
block|{
name|chunk
operator|->
name|map
index|[
name|run_ind
operator|+
name|i
index|]
operator|.
name|bits
operator|=
name|CHUNK_MAP_LARGE
operator||
name|CHUNK_MAP_ALLOCATED
expr_stmt|;
block|}
else|else
block|{
name|chunk
operator|->
name|map
index|[
name|run_ind
operator|+
name|i
index|]
operator|.
name|bits
operator|=
operator|(
name|size_t
operator|)
name|run
operator||
name|CHUNK_MAP_ALLOCATED
expr_stmt|;
block|}
block|}
comment|/* 	 * Set the run size only in the first element for large runs.  This is 	 * primarily a debugging aid, since the lack of size info for trailing 	 * pages only matters if the application tries to operate on an 	 * interior pointer. 	 */
if|if
condition|(
name|large
condition|)
name|chunk
operator|->
name|map
index|[
name|run_ind
index|]
operator|.
name|bits
operator||=
name|size
expr_stmt|;
if|if
condition|(
name|chunk
operator|->
name|ndirty
operator|==
literal|0
operator|&&
name|old_ndirty
operator|>
literal|0
condition|)
name|arena_chunk_tree_dirty_remove
argument_list|(
operator|&
name|arena
operator|->
name|chunks_dirty
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|arena_chunk_t
modifier|*
name|arena_chunk_alloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|size_t
name|i
decl_stmt|;
if|if
condition|(
name|arena
operator|->
name|spare
operator|!=
name|NULL
condition|)
block|{
name|chunk
operator|=
name|arena
operator|->
name|spare
expr_stmt|;
name|arena
operator|->
name|spare
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|chunk_alloc
argument_list|(
name|chunksize
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|mapped
operator|+=
name|chunksize
expr_stmt|;
endif|#
directive|endif
name|chunk
operator|->
name|arena
operator|=
name|arena
expr_stmt|;
comment|/* 		 * Claim that no pages are in use, since the header is merely 		 * overhead. 		 */
name|chunk
operator|->
name|ndirty
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Initialize the map to contain one maximal free untouched run. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|arena_chunk_header_npages
condition|;
name|i
operator|++
control|)
name|chunk
operator|->
name|map
index|[
name|i
index|]
operator|.
name|bits
operator|=
literal|0
expr_stmt|;
name|chunk
operator|->
name|map
index|[
name|i
index|]
operator|.
name|bits
operator|=
name|arena_maxclass
operator||
name|CHUNK_MAP_ZEROED
expr_stmt|;
for|for
control|(
name|i
operator|++
init|;
name|i
operator|<
name|chunk_npages
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|chunk
operator|->
name|map
index|[
name|i
index|]
operator|.
name|bits
operator|=
name|CHUNK_MAP_ZEROED
expr_stmt|;
block|}
name|chunk
operator|->
name|map
index|[
name|chunk_npages
operator|-
literal|1
index|]
operator|.
name|bits
operator|=
name|arena_maxclass
operator||
name|CHUNK_MAP_ZEROED
expr_stmt|;
block|}
comment|/* Insert the run into the runs_avail tree. */
name|arena_avail_tree_insert
argument_list|(
operator|&
name|arena
operator|->
name|runs_avail
argument_list|,
operator|&
name|chunk
operator|->
name|map
index|[
name|arena_chunk_header_npages
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|chunk
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_chunk_dealloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|)
block|{
if|if
condition|(
name|arena
operator|->
name|spare
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|arena
operator|->
name|spare
operator|->
name|ndirty
operator|>
literal|0
condition|)
block|{
name|arena_chunk_tree_dirty_remove
argument_list|(
operator|&
name|chunk
operator|->
name|arena
operator|->
name|chunks_dirty
argument_list|,
name|arena
operator|->
name|spare
argument_list|)
expr_stmt|;
name|arena
operator|->
name|ndirty
operator|-=
name|arena
operator|->
name|spare
operator|->
name|ndirty
expr_stmt|;
block|}
name|chunk_dealloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|arena
operator|->
name|spare
argument_list|,
name|chunksize
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|mapped
operator|-=
name|chunksize
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Remove run from runs_avail, regardless of whether this chunk 	 * will be cached, so that the arena does not use it.  Dirty page 	 * flushing only uses the chunks_dirty tree, so leaving this chunk in 	 * the chunks_* trees is sufficient for that purpose. 	 */
name|arena_avail_tree_remove
argument_list|(
operator|&
name|arena
operator|->
name|runs_avail
argument_list|,
operator|&
name|chunk
operator|->
name|map
index|[
name|arena_chunk_header_npages
index|]
argument_list|)
expr_stmt|;
name|arena
operator|->
name|spare
operator|=
name|chunk
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|arena_run_t
modifier|*
name|arena_run_alloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|large
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|arena_run_t
modifier|*
name|run
decl_stmt|;
name|arena_chunk_map_t
modifier|*
name|mapelm
decl_stmt|,
name|key
decl_stmt|;
name|assert
argument_list|(
name|size
operator|<=
name|arena_maxclass
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|size
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Search the arena's chunks for the lowest best fit. */
name|key
operator|.
name|bits
operator|=
name|size
operator||
name|CHUNK_MAP_KEY
expr_stmt|;
name|mapelm
operator|=
name|arena_avail_tree_nsearch
argument_list|(
operator|&
name|arena
operator|->
name|runs_avail
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapelm
operator|!=
name|NULL
condition|)
block|{
name|arena_chunk_t
modifier|*
name|run_chunk
init|=
name|CHUNK_ADDR2BASE
argument_list|(
name|mapelm
argument_list|)
decl_stmt|;
name|size_t
name|pageind
init|=
operator|(
operator|(
name|uintptr_t
operator|)
name|mapelm
operator|-
operator|(
name|uintptr_t
operator|)
name|run_chunk
operator|->
name|map
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|arena_chunk_map_t
argument_list|)
decl_stmt|;
name|run
operator|=
operator|(
name|arena_run_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|run_chunk
operator|+
operator|(
name|pageind
operator|<<
name|PAGE_SHIFT
operator|)
operator|)
expr_stmt|;
name|arena_run_split
argument_list|(
name|arena
argument_list|,
name|run
argument_list|,
name|size
argument_list|,
name|large
argument_list|,
name|zero
argument_list|)
expr_stmt|;
return|return
operator|(
name|run
operator|)
return|;
block|}
comment|/* 	 * No usable runs.  Create a new chunk from which to allocate the run. 	 */
name|chunk
operator|=
name|arena_chunk_alloc
argument_list|(
name|arena
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|run
operator|=
operator|(
name|arena_run_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|+
operator|(
name|arena_chunk_header_npages
operator|<<
name|PAGE_SHIFT
operator|)
operator|)
expr_stmt|;
comment|/* Update page map. */
name|arena_run_split
argument_list|(
name|arena
argument_list|,
name|run
argument_list|,
name|size
argument_list|,
name|large
argument_list|,
name|zero
argument_list|)
expr_stmt|;
return|return
operator|(
name|run
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_purge
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|npages
decl_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
name|size_t
name|ndirty
init|=
literal|0
decl_stmt|;
name|rb_foreach_begin
argument_list|(
argument|arena_chunk_t
argument_list|,
argument|link_dirty
argument_list|,
argument|&arena->chunks_dirty
argument_list|,
argument|chunk
argument_list|)
block|{
name|ndirty
operator|+=
name|chunk
operator|->
name|ndirty
expr_stmt|;
block|}
name|rb_foreach_end
argument_list|(
argument|arena_chunk_t
argument_list|,
argument|link_dirty
argument_list|,
argument|&arena->chunks_dirty
argument_list|,
argument|chunk
argument_list|)
name|assert
argument_list|(
name|ndirty
operator|==
name|arena
operator|->
name|ndirty
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|assert
argument_list|(
name|arena
operator|->
name|ndirty
operator|>
name|opt_dirty_max
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|npurge
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Iterate downward through chunks until enough dirty memory has been 	 * purged.  Terminate as soon as possible in order to minimize the 	 * number of system calls, even if a chunk has only been partially 	 * purged. 	 */
while|while
condition|(
name|arena
operator|->
name|ndirty
operator|>
operator|(
name|opt_dirty_max
operator|>>
literal|1
operator|)
condition|)
block|{
name|chunk
operator|=
name|arena_chunk_tree_dirty_last
argument_list|(
operator|&
name|arena
operator|->
name|chunks_dirty
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|chunk
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|chunk_npages
operator|-
literal|1
init|;
name|chunk
operator|->
name|ndirty
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|assert
argument_list|(
name|i
operator|>=
name|arena_chunk_header_npages
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk
operator|->
name|map
index|[
name|i
index|]
operator|.
name|bits
operator|&
name|CHUNK_MAP_DIRTY
condition|)
block|{
name|chunk
operator|->
name|map
index|[
name|i
index|]
operator|.
name|bits
operator|^=
name|CHUNK_MAP_DIRTY
expr_stmt|;
comment|/* Find adjacent dirty run(s). */
for|for
control|(
name|npages
operator|=
literal|1
init|;
name|i
operator|>
name|arena_chunk_header_npages
operator|&&
operator|(
name|chunk
operator|->
name|map
index|[
name|i
operator|-
literal|1
index|]
operator|.
name|bits
operator|&
name|CHUNK_MAP_DIRTY
operator|)
condition|;
name|npages
operator|++
control|)
block|{
name|i
operator|--
expr_stmt|;
name|chunk
operator|->
name|map
index|[
name|i
index|]
operator|.
name|bits
operator|^=
name|CHUNK_MAP_DIRTY
expr_stmt|;
block|}
name|chunk
operator|->
name|ndirty
operator|-=
name|npages
expr_stmt|;
name|arena
operator|->
name|ndirty
operator|-=
name|npages
expr_stmt|;
name|madvise
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|+
operator|(
name|i
operator|<<
name|PAGE_SHIFT
operator|)
operator|)
argument_list|,
operator|(
name|npages
operator|<<
name|PAGE_SHIFT
operator|)
argument_list|,
name|MADV_FREE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|nmadvise
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|purged
operator|+=
name|npages
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|arena
operator|->
name|ndirty
operator|<=
operator|(
name|opt_dirty_max
operator|>>
literal|1
operator|)
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|chunk
operator|->
name|ndirty
operator|==
literal|0
condition|)
block|{
name|arena_chunk_tree_dirty_remove
argument_list|(
operator|&
name|arena
operator|->
name|chunks_dirty
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|arena_run_dalloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|bool
name|dirty
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|size_t
name|size
decl_stmt|,
name|run_ind
decl_stmt|,
name|run_pages
decl_stmt|;
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|run
argument_list|)
expr_stmt|;
name|run_ind
operator|=
call|(
name|size_t
call|)
argument_list|(
operator|(
operator|(
name|uintptr_t
operator|)
name|run
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|PAGE_SHIFT
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|run_ind
operator|>=
name|arena_chunk_header_npages
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|run_ind
operator|<
name|chunk_npages
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|chunk
operator|->
name|map
index|[
name|run_ind
index|]
operator|.
name|bits
operator|&
name|CHUNK_MAP_LARGE
operator|)
operator|!=
literal|0
condition|)
name|size
operator|=
name|chunk
operator|->
name|map
index|[
name|run_ind
index|]
operator|.
name|bits
operator|&
operator|~
name|PAGE_MASK
expr_stmt|;
else|else
name|size
operator|=
name|run
operator|->
name|bin
operator|->
name|run_size
expr_stmt|;
name|run_pages
operator|=
operator|(
name|size
operator|>>
name|PAGE_SHIFT
operator|)
expr_stmt|;
comment|/* Mark pages as unallocated in the chunk map. */
if|if
condition|(
name|dirty
condition|)
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|run_pages
condition|;
name|i
operator|++
control|)
block|{
name|assert
argument_list|(
operator|(
name|chunk
operator|->
name|map
index|[
name|run_ind
operator|+
name|i
index|]
operator|.
name|bits
operator|&
name|CHUNK_MAP_DIRTY
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|chunk
operator|->
name|map
index|[
name|run_ind
operator|+
name|i
index|]
operator|.
name|bits
operator|=
name|CHUNK_MAP_DIRTY
expr_stmt|;
block|}
if|if
condition|(
name|chunk
operator|->
name|ndirty
operator|==
literal|0
condition|)
block|{
name|arena_chunk_tree_dirty_insert
argument_list|(
operator|&
name|arena
operator|->
name|chunks_dirty
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
block|}
name|chunk
operator|->
name|ndirty
operator|+=
name|run_pages
expr_stmt|;
name|arena
operator|->
name|ndirty
operator|+=
name|run_pages
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|run_pages
condition|;
name|i
operator|++
control|)
block|{
name|chunk
operator|->
name|map
index|[
name|run_ind
operator|+
name|i
index|]
operator|.
name|bits
operator|&=
operator|~
operator|(
name|CHUNK_MAP_LARGE
operator||
name|CHUNK_MAP_ALLOCATED
operator|)
expr_stmt|;
block|}
block|}
name|chunk
operator|->
name|map
index|[
name|run_ind
index|]
operator|.
name|bits
operator|=
name|size
operator||
operator|(
name|chunk
operator|->
name|map
index|[
name|run_ind
index|]
operator|.
name|bits
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
name|chunk
operator|->
name|map
index|[
name|run_ind
operator|+
name|run_pages
operator|-
literal|1
index|]
operator|.
name|bits
operator|=
name|size
operator||
operator|(
name|chunk
operator|->
name|map
index|[
name|run_ind
operator|+
name|run_pages
operator|-
literal|1
index|]
operator|.
name|bits
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
comment|/* Try to coalesce forward. */
if|if
condition|(
name|run_ind
operator|+
name|run_pages
operator|<
name|chunk_npages
operator|&&
operator|(
name|chunk
operator|->
name|map
index|[
name|run_ind
operator|+
name|run_pages
index|]
operator|.
name|bits
operator|&
name|CHUNK_MAP_ALLOCATED
operator|)
operator|==
literal|0
condition|)
block|{
name|size_t
name|nrun_size
init|=
name|chunk
operator|->
name|map
index|[
name|run_ind
operator|+
name|run_pages
index|]
operator|.
name|bits
operator|&
operator|~
name|PAGE_MASK
decl_stmt|;
comment|/* 		 * Remove successor from runs_avail; the coalesced run is 		 * inserted later. 		 */
name|arena_avail_tree_remove
argument_list|(
operator|&
name|arena
operator|->
name|runs_avail
argument_list|,
operator|&
name|chunk
operator|->
name|map
index|[
name|run_ind
operator|+
name|run_pages
index|]
argument_list|)
expr_stmt|;
name|size
operator|+=
name|nrun_size
expr_stmt|;
name|run_pages
operator|=
name|size
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|assert
argument_list|(
operator|(
name|chunk
operator|->
name|map
index|[
name|run_ind
operator|+
name|run_pages
operator|-
literal|1
index|]
operator|.
name|bits
operator|&
operator|~
name|PAGE_MASK
operator|)
operator|==
name|nrun_size
argument_list|)
expr_stmt|;
name|chunk
operator|->
name|map
index|[
name|run_ind
index|]
operator|.
name|bits
operator|=
name|size
operator||
operator|(
name|chunk
operator|->
name|map
index|[
name|run_ind
index|]
operator|.
name|bits
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
name|chunk
operator|->
name|map
index|[
name|run_ind
operator|+
name|run_pages
operator|-
literal|1
index|]
operator|.
name|bits
operator|=
name|size
operator||
operator|(
name|chunk
operator|->
name|map
index|[
name|run_ind
operator|+
name|run_pages
operator|-
literal|1
index|]
operator|.
name|bits
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
block|}
comment|/* Try to coalesce backward. */
if|if
condition|(
name|run_ind
operator|>
name|arena_chunk_header_npages
operator|&&
operator|(
name|chunk
operator|->
name|map
index|[
name|run_ind
operator|-
literal|1
index|]
operator|.
name|bits
operator|&
name|CHUNK_MAP_ALLOCATED
operator|)
operator|==
literal|0
condition|)
block|{
name|size_t
name|prun_size
init|=
name|chunk
operator|->
name|map
index|[
name|run_ind
operator|-
literal|1
index|]
operator|.
name|bits
operator|&
operator|~
name|PAGE_MASK
decl_stmt|;
name|run_ind
operator|-=
name|prun_size
operator|>>
name|PAGE_SHIFT
expr_stmt|;
comment|/* 		 * Remove predecessor from runs_avail; the coalesced run is 		 * inserted later. 		 */
name|arena_avail_tree_remove
argument_list|(
operator|&
name|arena
operator|->
name|runs_avail
argument_list|,
operator|&
name|chunk
operator|->
name|map
index|[
name|run_ind
index|]
argument_list|)
expr_stmt|;
name|size
operator|+=
name|prun_size
expr_stmt|;
name|run_pages
operator|=
name|size
operator|>>
name|PAGE_SHIFT
expr_stmt|;
name|assert
argument_list|(
operator|(
name|chunk
operator|->
name|map
index|[
name|run_ind
index|]
operator|.
name|bits
operator|&
operator|~
name|PAGE_MASK
operator|)
operator|==
name|prun_size
argument_list|)
expr_stmt|;
name|chunk
operator|->
name|map
index|[
name|run_ind
index|]
operator|.
name|bits
operator|=
name|size
operator||
operator|(
name|chunk
operator|->
name|map
index|[
name|run_ind
index|]
operator|.
name|bits
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
name|chunk
operator|->
name|map
index|[
name|run_ind
operator|+
name|run_pages
operator|-
literal|1
index|]
operator|.
name|bits
operator|=
name|size
operator||
operator|(
name|chunk
operator|->
name|map
index|[
name|run_ind
operator|+
name|run_pages
operator|-
literal|1
index|]
operator|.
name|bits
operator|&
name|PAGE_MASK
operator|)
expr_stmt|;
block|}
comment|/* Insert into runs_avail, now that coalescing is complete. */
name|arena_avail_tree_insert
argument_list|(
operator|&
name|arena
operator|->
name|runs_avail
argument_list|,
operator|&
name|chunk
operator|->
name|map
index|[
name|run_ind
index|]
argument_list|)
expr_stmt|;
comment|/* Deallocate chunk if it is now completely unused. */
if|if
condition|(
operator|(
name|chunk
operator|->
name|map
index|[
name|arena_chunk_header_npages
index|]
operator|.
name|bits
operator|&
operator|(
operator|~
name|PAGE_MASK
operator||
name|CHUNK_MAP_ALLOCATED
operator|)
operator|)
operator|==
name|arena_maxclass
condition|)
name|arena_chunk_dealloc
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
comment|/* Enforce opt_dirty_max. */
if|if
condition|(
name|arena
operator|->
name|ndirty
operator|>
name|opt_dirty_max
condition|)
name|arena_purge
argument_list|(
name|arena
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_run_trim_head
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|size_t
name|oldsize
parameter_list|,
name|size_t
name|newsize
parameter_list|)
block|{
name|size_t
name|pageind
init|=
operator|(
operator|(
name|uintptr_t
operator|)
name|run
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|PAGE_SHIFT
decl_stmt|;
name|size_t
name|head_npages
init|=
operator|(
name|oldsize
operator|-
name|newsize
operator|)
operator|>>
name|PAGE_SHIFT
decl_stmt|;
name|assert
argument_list|(
name|oldsize
operator|>
name|newsize
argument_list|)
expr_stmt|;
comment|/* 	 * Update the chunk map so that arena_run_dalloc() can treat the 	 * leading run as separately allocated. 	 */
name|chunk
operator|->
name|map
index|[
name|pageind
index|]
operator|.
name|bits
operator|=
operator|(
name|oldsize
operator|-
name|newsize
operator|)
operator||
name|CHUNK_MAP_LARGE
operator||
name|CHUNK_MAP_ALLOCATED
expr_stmt|;
name|chunk
operator|->
name|map
index|[
name|pageind
operator|+
name|head_npages
index|]
operator|.
name|bits
operator|=
name|newsize
operator||
name|CHUNK_MAP_LARGE
operator||
name|CHUNK_MAP_ALLOCATED
expr_stmt|;
name|arena_run_dalloc
argument_list|(
name|arena
argument_list|,
name|run
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_run_trim_tail
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|,
name|size_t
name|oldsize
parameter_list|,
name|size_t
name|newsize
parameter_list|,
name|bool
name|dirty
parameter_list|)
block|{
name|size_t
name|pageind
init|=
operator|(
operator|(
name|uintptr_t
operator|)
name|run
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|PAGE_SHIFT
decl_stmt|;
name|size_t
name|npages
init|=
name|newsize
operator|>>
name|PAGE_SHIFT
decl_stmt|;
name|assert
argument_list|(
name|oldsize
operator|>
name|newsize
argument_list|)
expr_stmt|;
comment|/* 	 * Update the chunk map so that arena_run_dalloc() can treat the 	 * trailing run as separately allocated. 	 */
name|chunk
operator|->
name|map
index|[
name|pageind
index|]
operator|.
name|bits
operator|=
name|newsize
operator||
name|CHUNK_MAP_LARGE
operator||
name|CHUNK_MAP_ALLOCATED
expr_stmt|;
name|chunk
operator|->
name|map
index|[
name|pageind
operator|+
name|npages
index|]
operator|.
name|bits
operator|=
operator|(
name|oldsize
operator|-
name|newsize
operator|)
operator||
name|CHUNK_MAP_LARGE
operator||
name|CHUNK_MAP_ALLOCATED
expr_stmt|;
name|arena_run_dalloc
argument_list|(
name|arena
argument_list|,
operator|(
name|arena_run_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|run
operator|+
name|newsize
operator|)
argument_list|,
name|dirty
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|arena_run_t
modifier|*
name|arena_bin_nonfull_run_get
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
block|{
name|arena_chunk_map_t
modifier|*
name|mapelm
decl_stmt|;
name|arena_run_t
modifier|*
name|run
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|remainder
decl_stmt|;
comment|/* Look for a usable run. */
name|mapelm
operator|=
name|arena_run_tree_first
argument_list|(
operator|&
name|bin
operator|->
name|runs
argument_list|)
expr_stmt|;
if|if
condition|(
name|mapelm
operator|!=
name|NULL
condition|)
block|{
comment|/* run is guaranteed to have available space. */
name|arena_run_tree_remove
argument_list|(
operator|&
name|bin
operator|->
name|runs
argument_list|,
name|mapelm
argument_list|)
expr_stmt|;
name|run
operator|=
operator|(
name|arena_run_t
operator|*
operator|)
operator|(
name|mapelm
operator|->
name|bits
operator|&
operator|~
name|PAGE_MASK
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|bin
operator|->
name|stats
operator|.
name|reruns
operator|++
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|run
operator|)
return|;
block|}
comment|/* No existing runs have any space available. */
comment|/* Allocate a new run. */
name|run
operator|=
name|arena_run_alloc
argument_list|(
name|arena
argument_list|,
name|bin
operator|->
name|run_size
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|run
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Initialize run internals. */
name|run
operator|->
name|bin
operator|=
name|bin
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bin
operator|->
name|regs_mask_nelms
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|run
operator|->
name|regs_mask
index|[
name|i
index|]
operator|=
name|UINT_MAX
expr_stmt|;
name|remainder
operator|=
name|bin
operator|->
name|nregs
operator|&
operator|(
operator|(
literal|1U
operator|<<
operator|(
name|SIZEOF_INT_2POW
operator|+
literal|3
operator|)
operator|)
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|remainder
operator|==
literal|0
condition|)
name|run
operator|->
name|regs_mask
index|[
name|i
index|]
operator|=
name|UINT_MAX
expr_stmt|;
else|else
block|{
comment|/* The last element has spare bits that need to be unset. */
name|run
operator|->
name|regs_mask
index|[
name|i
index|]
operator|=
operator|(
name|UINT_MAX
operator|>>
operator|(
operator|(
literal|1U
operator|<<
operator|(
name|SIZEOF_INT_2POW
operator|+
literal|3
operator|)
operator|)
operator|-
name|remainder
operator|)
operator|)
expr_stmt|;
block|}
name|run
operator|->
name|regs_minelm
operator|=
literal|0
expr_stmt|;
name|run
operator|->
name|nfree
operator|=
name|bin
operator|->
name|nregs
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
name|run
operator|->
name|magic
operator|=
name|ARENA_RUN_MAGIC
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|bin
operator|->
name|stats
operator|.
name|nruns
operator|++
expr_stmt|;
name|bin
operator|->
name|stats
operator|.
name|curruns
operator|++
expr_stmt|;
if|if
condition|(
name|bin
operator|->
name|stats
operator|.
name|curruns
operator|>
name|bin
operator|->
name|stats
operator|.
name|highruns
condition|)
name|bin
operator|->
name|stats
operator|.
name|highruns
operator|=
name|bin
operator|->
name|stats
operator|.
name|curruns
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|run
operator|)
return|;
block|}
end_function

begin_comment
comment|/* bin->runcur must have space available before this function is called. */
end_comment

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|arena_bin_malloc_easy
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|,
name|arena_run_t
modifier|*
name|run
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|assert
argument_list|(
name|run
operator|->
name|magic
operator|==
name|ARENA_RUN_MAGIC
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|run
operator|->
name|nfree
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
name|arena_run_reg_alloc
argument_list|(
name|run
argument_list|,
name|bin
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|run
operator|->
name|nfree
operator|--
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Re-fill bin->runcur, then call arena_bin_malloc_easy(). */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|arena_bin_malloc_hard
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_bin_t
modifier|*
name|bin
parameter_list|)
block|{
name|bin
operator|->
name|runcur
operator|=
name|arena_bin_nonfull_run_get
argument_list|(
name|arena
argument_list|,
name|bin
argument_list|)
expr_stmt|;
if|if
condition|(
name|bin
operator|->
name|runcur
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|assert
argument_list|(
name|bin
operator|->
name|runcur
operator|->
name|magic
operator|==
name|ARENA_RUN_MAGIC
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|bin
operator|->
name|runcur
operator|->
name|nfree
operator|>
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|arena_bin_malloc_easy
argument_list|(
name|arena
argument_list|,
name|bin
argument_list|,
name|bin
operator|->
name|runcur
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Calculate bin->run_size such that it meets the following constraints:  *  *   *) bin->run_size>= min_run_size  *   *) bin->run_size<= arena_maxclass  *   *) bin->run_size<= RUN_MAX_SMALL  *   *) run header overhead<= RUN_MAX_OVRHD (or header overhead relaxed).  *  * bin->nregs, bin->regs_mask_nelms, and bin->reg0_offset are  * also calculated here, since these settings are all interdependent.  */
end_comment

begin_function
specifier|static
name|size_t
name|arena_bin_run_size_calc
parameter_list|(
name|arena_bin_t
modifier|*
name|bin
parameter_list|,
name|size_t
name|min_run_size
parameter_list|)
block|{
name|size_t
name|try_run_size
decl_stmt|,
name|good_run_size
decl_stmt|;
name|unsigned
name|good_nregs
decl_stmt|,
name|good_mask_nelms
decl_stmt|,
name|good_reg0_offset
decl_stmt|;
name|unsigned
name|try_nregs
decl_stmt|,
name|try_mask_nelms
decl_stmt|,
name|try_reg0_offset
decl_stmt|;
name|assert
argument_list|(
name|min_run_size
operator|>=
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|min_run_size
operator|<=
name|arena_maxclass
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|min_run_size
operator|<=
name|RUN_MAX_SMALL
argument_list|)
expr_stmt|;
comment|/* 	 * Calculate known-valid settings before entering the run_size 	 * expansion loop, so that the first part of the loop always copies 	 * valid settings. 	 * 	 * The do..while loop iteratively reduces the number of regions until 	 * the run header and the regions no longer overlap.  A closed formula 	 * would be quite messy, since there is an interdependency between the 	 * header's mask length and the number of regions. 	 */
name|try_run_size
operator|=
name|min_run_size
expr_stmt|;
name|try_nregs
operator|=
operator|(
operator|(
name|try_run_size
operator|-
sizeof|sizeof
argument_list|(
name|arena_run_t
argument_list|)
operator|)
operator|/
name|bin
operator|->
name|reg_size
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* Counter-act try_nregs-- in loop. */
do|do
block|{
name|try_nregs
operator|--
expr_stmt|;
name|try_mask_nelms
operator|=
operator|(
name|try_nregs
operator|>>
operator|(
name|SIZEOF_INT_2POW
operator|+
literal|3
operator|)
operator|)
operator|+
operator|(
operator|(
name|try_nregs
operator|&
operator|(
operator|(
literal|1U
operator|<<
operator|(
name|SIZEOF_INT_2POW
operator|+
literal|3
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|try_reg0_offset
operator|=
name|try_run_size
operator|-
operator|(
name|try_nregs
operator|*
name|bin
operator|->
name|reg_size
operator|)
expr_stmt|;
block|}
do|while
condition|(
sizeof|sizeof
argument_list|(
name|arena_run_t
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
operator|*
operator|(
name|try_mask_nelms
operator|-
literal|1
operator|)
operator|)
operator|>
name|try_reg0_offset
condition|)
do|;
comment|/* run_size expansion loop. */
do|do
block|{
comment|/* 		 * Copy valid settings before trying more aggressive settings. 		 */
name|good_run_size
operator|=
name|try_run_size
expr_stmt|;
name|good_nregs
operator|=
name|try_nregs
expr_stmt|;
name|good_mask_nelms
operator|=
name|try_mask_nelms
expr_stmt|;
name|good_reg0_offset
operator|=
name|try_reg0_offset
expr_stmt|;
comment|/* Try more aggressive settings. */
name|try_run_size
operator|+=
name|PAGE_SIZE
expr_stmt|;
name|try_nregs
operator|=
operator|(
operator|(
name|try_run_size
operator|-
sizeof|sizeof
argument_list|(
name|arena_run_t
argument_list|)
operator|)
operator|/
name|bin
operator|->
name|reg_size
operator|)
operator|+
literal|1
expr_stmt|;
comment|/* Counter-act try_nregs-- in loop. */
do|do
block|{
name|try_nregs
operator|--
expr_stmt|;
name|try_mask_nelms
operator|=
operator|(
name|try_nregs
operator|>>
operator|(
name|SIZEOF_INT_2POW
operator|+
literal|3
operator|)
operator|)
operator|+
operator|(
operator|(
name|try_nregs
operator|&
operator|(
operator|(
literal|1U
operator|<<
operator|(
name|SIZEOF_INT_2POW
operator|+
literal|3
operator|)
operator|)
operator|-
literal|1
operator|)
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|try_reg0_offset
operator|=
name|try_run_size
operator|-
operator|(
name|try_nregs
operator|*
name|bin
operator|->
name|reg_size
operator|)
expr_stmt|;
block|}
do|while
condition|(
sizeof|sizeof
argument_list|(
name|arena_run_t
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
operator|*
operator|(
name|try_mask_nelms
operator|-
literal|1
operator|)
operator|)
operator|>
name|try_reg0_offset
condition|)
do|;
block|}
do|while
condition|(
name|try_run_size
operator|<=
name|arena_maxclass
operator|&&
name|try_run_size
operator|<=
name|RUN_MAX_SMALL
operator|&&
name|RUN_MAX_OVRHD
operator|*
operator|(
name|bin
operator|->
name|reg_size
operator|<<
literal|3
operator|)
operator|>
name|RUN_MAX_OVRHD_RELAX
operator|&&
operator|(
name|try_reg0_offset
operator|<<
name|RUN_BFP
operator|)
operator|>
name|RUN_MAX_OVRHD
operator|*
name|try_run_size
condition|)
do|;
name|assert
argument_list|(
sizeof|sizeof
argument_list|(
name|arena_run_t
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
operator|*
operator|(
name|good_mask_nelms
operator|-
literal|1
operator|)
operator|)
operator|<=
name|good_reg0_offset
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|good_mask_nelms
operator|<<
operator|(
name|SIZEOF_INT_2POW
operator|+
literal|3
operator|)
operator|)
operator|>=
name|good_nregs
argument_list|)
expr_stmt|;
comment|/* Copy final settings. */
name|bin
operator|->
name|run_size
operator|=
name|good_run_size
expr_stmt|;
name|bin
operator|->
name|nregs
operator|=
name|good_nregs
expr_stmt|;
name|bin
operator|->
name|regs_mask_nelms
operator|=
name|good_mask_nelms
expr_stmt|;
name|bin
operator|->
name|reg0_offset
operator|=
name|good_reg0_offset
expr_stmt|;
return|return
operator|(
name|good_run_size
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_BALANCE
end_ifdef

begin_function
specifier|static
specifier|inline
name|void
name|arena_lock_balance
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|unsigned
name|contention
decl_stmt|;
name|contention
operator|=
name|malloc_spin_lock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|narenas
operator|>
literal|1
condition|)
block|{
comment|/* 		 * Calculate the exponentially averaged contention for this 		 * arena.  Due to integer math always rounding down, this value 		 * decays somewhat faster than normal. 		 */
name|arena
operator|->
name|contention
operator|=
operator|(
operator|(
operator|(
name|uint64_t
operator|)
name|arena
operator|->
name|contention
operator|*
call|(
name|uint64_t
call|)
argument_list|(
operator|(
literal|1U
operator|<<
name|BALANCE_ALPHA_INV_2POW
operator|)
operator|-
literal|1
argument_list|)
operator|)
operator|+
operator|(
name|uint64_t
operator|)
name|contention
operator|)
operator|>>
name|BALANCE_ALPHA_INV_2POW
expr_stmt|;
if|if
condition|(
name|arena
operator|->
name|contention
operator|>=
name|opt_balance_threshold
condition|)
name|arena_lock_balance_hard
argument_list|(
name|arena
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|arena_lock_balance_hard
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|uint32_t
name|ind
decl_stmt|;
name|arena
operator|->
name|contention
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|nbalance
operator|++
expr_stmt|;
endif|#
directive|endif
name|ind
operator|=
name|PRN
argument_list|(
name|balance
argument_list|,
name|narenas_2pow
argument_list|)
expr_stmt|;
if|if
condition|(
name|arenas
index|[
name|ind
index|]
operator|!=
name|NULL
condition|)
name|arenas_map
operator|=
name|arenas
index|[
name|ind
index|]
expr_stmt|;
else|else
block|{
name|malloc_spin_lock
argument_list|(
operator|&
name|arenas_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|arenas
index|[
name|ind
index|]
operator|!=
name|NULL
condition|)
name|arenas_map
operator|=
name|arenas
index|[
name|ind
index|]
expr_stmt|;
else|else
name|arenas_map
operator|=
name|arenas_extend
argument_list|(
name|ind
argument_list|)
expr_stmt|;
name|malloc_spin_unlock
argument_list|(
operator|&
name|arenas_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_MAG
end_ifdef

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|mag_alloc
parameter_list|(
name|mag_t
modifier|*
name|mag
parameter_list|)
block|{
if|if
condition|(
name|mag
operator|->
name|nrounds
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|mag
operator|->
name|nrounds
operator|--
expr_stmt|;
return|return
operator|(
name|mag
operator|->
name|rounds
index|[
name|mag
operator|->
name|nrounds
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mag_load
parameter_list|(
name|mag_t
modifier|*
name|mag
parameter_list|)
block|{
name|arena_t
modifier|*
name|arena
decl_stmt|;
name|arena_bin_t
modifier|*
name|bin
decl_stmt|;
name|arena_run_t
modifier|*
name|run
decl_stmt|;
name|void
modifier|*
name|round
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|arena
operator|=
name|choose_arena
argument_list|()
expr_stmt|;
name|bin
operator|=
operator|&
name|arena
operator|->
name|bins
index|[
name|mag
operator|->
name|binind
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_BALANCE
name|arena_lock_balance
argument_list|(
name|arena
argument_list|)
expr_stmt|;
else|#
directive|else
name|malloc_spin_lock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
name|mag
operator|->
name|nrounds
init|;
name|i
operator|<
name|max_rounds
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|run
operator|=
name|bin
operator|->
name|runcur
operator|)
operator|!=
name|NULL
operator|&&
name|run
operator|->
name|nfree
operator|>
literal|0
condition|)
name|round
operator|=
name|arena_bin_malloc_easy
argument_list|(
name|arena
argument_list|,
name|bin
argument_list|,
name|run
argument_list|)
expr_stmt|;
else|else
name|round
operator|=
name|arena_bin_malloc_hard
argument_list|(
name|arena
argument_list|,
name|bin
argument_list|)
expr_stmt|;
if|if
condition|(
name|round
operator|==
name|NULL
condition|)
break|break;
name|mag
operator|->
name|rounds
index|[
name|i
index|]
operator|=
name|round
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|bin
operator|->
name|stats
operator|.
name|nmags
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|nmalloc_small
operator|+=
operator|(
name|i
operator|-
name|mag
operator|->
name|nrounds
operator|)
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|allocated_small
operator|+=
operator|(
name|i
operator|-
name|mag
operator|->
name|nrounds
operator|)
operator|*
name|bin
operator|->
name|reg_size
expr_stmt|;
endif|#
directive|endif
name|malloc_spin_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
name|mag
operator|->
name|nrounds
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|mag_rack_alloc
parameter_list|(
name|mag_rack_t
modifier|*
name|rack
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|bin_mags_t
modifier|*
name|bin_mags
decl_stmt|;
name|mag_t
modifier|*
name|mag
decl_stmt|;
name|size_t
name|binind
decl_stmt|;
name|binind
operator|=
name|size2bin
index|[
name|size
index|]
expr_stmt|;
name|assert
argument_list|(
name|binind
operator|<
name|nbins
argument_list|)
expr_stmt|;
name|bin_mags
operator|=
operator|&
name|rack
operator|->
name|bin_mags
index|[
name|binind
index|]
expr_stmt|;
name|mag
operator|=
name|bin_mags
operator|->
name|curmag
expr_stmt|;
if|if
condition|(
name|mag
operator|==
name|NULL
condition|)
block|{
comment|/* Create an initial magazine for this size class. */
name|assert
argument_list|(
name|bin_mags
operator|->
name|sparemag
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|mag
operator|=
name|mag_create
argument_list|(
name|choose_arena
argument_list|()
argument_list|,
name|binind
argument_list|)
expr_stmt|;
if|if
condition|(
name|mag
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|bin_mags
operator|->
name|curmag
operator|=
name|mag
expr_stmt|;
name|mag_load
argument_list|(
name|mag
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|mag_alloc
argument_list|(
name|mag
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|bin_mags
operator|->
name|sparemag
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|bin_mags
operator|->
name|sparemag
operator|->
name|nrounds
operator|>
literal|0
condition|)
block|{
comment|/* Swap magazines. */
name|bin_mags
operator|->
name|curmag
operator|=
name|bin_mags
operator|->
name|sparemag
expr_stmt|;
name|bin_mags
operator|->
name|sparemag
operator|=
name|mag
expr_stmt|;
name|mag
operator|=
name|bin_mags
operator|->
name|curmag
expr_stmt|;
block|}
else|else
block|{
comment|/* Reload the current magazine. */
name|mag_load
argument_list|(
name|mag
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Create a second magazine. */
name|mag
operator|=
name|mag_create
argument_list|(
name|choose_arena
argument_list|()
argument_list|,
name|binind
argument_list|)
expr_stmt|;
if|if
condition|(
name|mag
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|mag_load
argument_list|(
name|mag
argument_list|)
expr_stmt|;
name|bin_mags
operator|->
name|sparemag
operator|=
name|bin_mags
operator|->
name|curmag
expr_stmt|;
name|bin_mags
operator|->
name|curmag
operator|=
name|mag
expr_stmt|;
block|}
name|ret
operator|=
name|mag_alloc
argument_list|(
name|mag
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|zero
operator|==
name|false
condition|)
block|{
if|if
condition|(
name|opt_junk
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0xa5
argument_list|,
name|size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opt_zero
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|arena_malloc_small
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|arena_bin_t
modifier|*
name|bin
decl_stmt|;
name|arena_run_t
modifier|*
name|run
decl_stmt|;
name|size_t
name|binind
decl_stmt|;
name|binind
operator|=
name|size2bin
index|[
name|size
index|]
expr_stmt|;
name|assert
argument_list|(
name|binind
operator|<
name|nbins
argument_list|)
expr_stmt|;
name|bin
operator|=
operator|&
name|arena
operator|->
name|bins
index|[
name|binind
index|]
expr_stmt|;
name|size
operator|=
name|bin
operator|->
name|reg_size
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_BALANCE
name|arena_lock_balance
argument_list|(
name|arena
argument_list|)
expr_stmt|;
else|#
directive|else
name|malloc_spin_lock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|run
operator|=
name|bin
operator|->
name|runcur
operator|)
operator|!=
name|NULL
operator|&&
name|run
operator|->
name|nfree
operator|>
literal|0
condition|)
name|ret
operator|=
name|arena_bin_malloc_easy
argument_list|(
name|arena
argument_list|,
name|bin
argument_list|,
name|run
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|arena_bin_malloc_hard
argument_list|(
name|arena
argument_list|,
name|bin
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
name|malloc_spin_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|bin
operator|->
name|stats
operator|.
name|nrequests
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|nmalloc_small
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|allocated_small
operator|+=
name|size
expr_stmt|;
endif|#
directive|endif
name|malloc_spin_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|zero
operator|==
name|false
condition|)
block|{
if|if
condition|(
name|opt_junk
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0xa5
argument_list|,
name|size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opt_zero
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|arena_malloc_large
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
comment|/* Large allocation. */
name|size
operator|=
name|PAGE_CEILING
argument_list|(
name|size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_BALANCE
name|arena_lock_balance
argument_list|(
name|arena
argument_list|)
expr_stmt|;
else|#
directive|else
name|malloc_spin_lock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ret
operator|=
operator|(
name|void
operator|*
operator|)
name|arena_run_alloc
argument_list|(
name|arena
argument_list|,
name|size
argument_list|,
name|true
argument_list|,
name|zero
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
name|malloc_spin_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|nmalloc_large
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|allocated_large
operator|+=
name|size
expr_stmt|;
endif|#
directive|endif
name|malloc_spin_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|zero
operator|==
name|false
condition|)
block|{
if|if
condition|(
name|opt_junk
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0xa5
argument_list|,
name|size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opt_zero
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|arena_malloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
name|assert
argument_list|(
name|arena
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena
operator|->
name|magic
operator|==
name|ARENA_MAGIC
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|QUANTUM_CEILING
argument_list|(
name|size
argument_list|)
operator|<=
name|arena_maxclass
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
name|bin_maxclass
condition|)
block|{
ifdef|#
directive|ifdef
name|MALLOC_MAG
if|if
condition|(
name|__isthreaded
operator|&&
name|opt_mag
condition|)
block|{
name|mag_rack_t
modifier|*
name|rack
init|=
name|mag_rack
decl_stmt|;
if|if
condition|(
name|rack
operator|==
name|NULL
condition|)
block|{
name|rack
operator|=
name|mag_rack_create
argument_list|(
name|arena
argument_list|)
expr_stmt|;
if|if
condition|(
name|rack
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|mag_rack
operator|=
name|rack
expr_stmt|;
block|}
return|return
operator|(
name|mag_rack_alloc
argument_list|(
name|rack
argument_list|,
name|size
argument_list|,
name|zero
argument_list|)
operator|)
return|;
block|}
else|else
endif|#
directive|endif
return|return
operator|(
name|arena_malloc_small
argument_list|(
name|arena
argument_list|,
name|size
argument_list|,
name|zero
argument_list|)
operator|)
return|;
block|}
else|else
return|return
operator|(
name|arena_malloc_large
argument_list|(
name|arena
argument_list|,
name|size
argument_list|,
name|zero
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|imalloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|assert
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
name|arena_maxclass
condition|)
return|return
operator|(
name|arena_malloc
argument_list|(
name|choose_arena
argument_list|()
argument_list|,
name|size
argument_list|,
name|false
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|huge_malloc
argument_list|(
name|size
argument_list|,
name|false
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|icalloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
if|if
condition|(
name|size
operator|<=
name|arena_maxclass
condition|)
return|return
operator|(
name|arena_malloc
argument_list|(
name|choose_arena
argument_list|()
argument_list|,
name|size
argument_list|,
name|true
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|huge_malloc
argument_list|(
name|size
argument_list|,
name|true
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Only handles large allocations that require more than page alignment. */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|arena_palloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|alloc_size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|assert
argument_list|(
operator|(
name|size
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|alignment
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_BALANCE
name|arena_lock_balance
argument_list|(
name|arena
argument_list|)
expr_stmt|;
else|#
directive|else
name|malloc_spin_lock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ret
operator|=
operator|(
name|void
operator|*
operator|)
name|arena_run_alloc
argument_list|(
name|arena
argument_list|,
name|alloc_size
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
name|malloc_spin_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|ret
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|(
name|uintptr_t
operator|)
name|ret
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|offset
operator|&
name|PAGE_MASK
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|offset
operator|<
name|alloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
name|arena_run_trim_tail
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|ret
argument_list|,
name|alloc_size
argument_list|,
name|size
argument_list|,
name|false
argument_list|)
expr_stmt|;
else|else
block|{
name|size_t
name|leadsize
decl_stmt|,
name|trailsize
decl_stmt|;
name|leadsize
operator|=
name|alignment
operator|-
name|offset
expr_stmt|;
if|if
condition|(
name|leadsize
operator|>
literal|0
condition|)
block|{
name|arena_run_trim_head
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|ret
argument_list|,
name|alloc_size
argument_list|,
name|alloc_size
operator|-
name|leadsize
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ret
operator|+
name|leadsize
operator|)
expr_stmt|;
block|}
name|trailsize
operator|=
name|alloc_size
operator|-
name|leadsize
operator|-
name|size
expr_stmt|;
if|if
condition|(
name|trailsize
operator|!=
literal|0
condition|)
block|{
comment|/* Trim trailing space. */
name|assert
argument_list|(
name|trailsize
operator|<
name|alloc_size
argument_list|)
expr_stmt|;
name|arena_run_trim_tail
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|ret
argument_list|,
name|size
operator|+
name|trailsize
argument_list|,
name|size
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|nmalloc_large
operator|++
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|allocated_large
operator|+=
name|size
expr_stmt|;
endif|#
directive|endif
name|malloc_spin_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_junk
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0xa5
argument_list|,
name|size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opt_zero
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|ipalloc
parameter_list|(
name|size_t
name|alignment
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|size_t
name|ceil_size
decl_stmt|;
comment|/* 	 * Round size up to the nearest multiple of alignment. 	 * 	 * This done, we can take advantage of the fact that for each small 	 * size class, every object is aligned at the smallest power of two 	 * that is non-zero in the base two representation of the size.  For 	 * example: 	 * 	 *   Size |   Base 2 | Minimum alignment 	 *   -----+----------+------------------ 	 *     96 |  1100000 |  32 	 *    144 | 10100000 |  32 	 *    192 | 11000000 |  64 	 * 	 * Depending on runtime settings, it is possible that arena_malloc() 	 * will further round up to a power of two, but that never causes 	 * correctness issues. 	 */
name|ceil_size
operator|=
operator|(
name|size
operator|+
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|)
operator|&
operator|(
operator|-
name|alignment
operator|)
expr_stmt|;
comment|/* 	 * (ceil_size< size) protects against the combination of maximal 	 * alignment and size greater than maximal alignment. 	 */
if|if
condition|(
name|ceil_size
operator|<
name|size
condition|)
block|{
comment|/* size_t overflow. */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|ceil_size
operator|<=
name|PAGE_SIZE
operator|||
operator|(
name|alignment
operator|<=
name|PAGE_SIZE
operator|&&
name|ceil_size
operator|<=
name|arena_maxclass
operator|)
condition|)
name|ret
operator|=
name|arena_malloc
argument_list|(
name|choose_arena
argument_list|()
argument_list|,
name|ceil_size
argument_list|,
name|false
argument_list|)
expr_stmt|;
else|else
block|{
name|size_t
name|run_size
decl_stmt|;
comment|/* 		 * We can't achieve subpage alignment, so round up alignment 		 * permanently; it makes later calculations simpler. 		 */
name|alignment
operator|=
name|PAGE_CEILING
argument_list|(
name|alignment
argument_list|)
expr_stmt|;
name|ceil_size
operator|=
name|PAGE_CEILING
argument_list|(
name|size
argument_list|)
expr_stmt|;
comment|/* 		 * (ceil_size< size) protects against very large sizes within 		 * PAGE_SIZE of SIZE_T_MAX. 		 * 		 * (ceil_size + alignment< ceil_size) protects against the 		 * combination of maximal alignment and ceil_size large enough 		 * to cause overflow.  This is similar to the first overflow 		 * check above, but it needs to be repeated due to the new 		 * ceil_size value, which may now be *equal* to maximal 		 * alignment, whereas before we only detected overflow if the 		 * original size was *greater* than maximal alignment. 		 */
if|if
condition|(
name|ceil_size
operator|<
name|size
operator|||
name|ceil_size
operator|+
name|alignment
operator|<
name|ceil_size
condition|)
block|{
comment|/* size_t overflow. */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 		 * Calculate the size of the over-size run that arena_palloc() 		 * would need to allocate in order to guarantee the alignment. 		 */
if|if
condition|(
name|ceil_size
operator|>=
name|alignment
condition|)
name|run_size
operator|=
name|ceil_size
operator|+
name|alignment
operator|-
name|PAGE_SIZE
expr_stmt|;
else|else
block|{
comment|/* 			 * It is possible that (alignment<< 1) will cause 			 * overflow, but it doesn't matter because we also 			 * subtract PAGE_SIZE, which in the case of overflow 			 * leaves us with a very large run_size.  That causes 			 * the first conditional below to fail, which means 			 * that the bogus run_size value never gets used for 			 * anything important. 			 */
name|run_size
operator|=
operator|(
name|alignment
operator|<<
literal|1
operator|)
operator|-
name|PAGE_SIZE
expr_stmt|;
block|}
if|if
condition|(
name|run_size
operator|<=
name|arena_maxclass
condition|)
block|{
name|ret
operator|=
name|arena_palloc
argument_list|(
name|choose_arena
argument_list|()
argument_list|,
name|alignment
argument_list|,
name|ceil_size
argument_list|,
name|run_size
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|alignment
operator|<=
name|chunksize
condition|)
name|ret
operator|=
name|huge_malloc
argument_list|(
name|ceil_size
argument_list|,
name|false
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|huge_palloc
argument_list|(
name|alignment
argument_list|,
name|ceil_size
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
operator|(
operator|(
name|uintptr_t
operator|)
name|ret
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return the size of the allocation pointed to by ptr. */
end_comment

begin_function
specifier|static
name|size_t
name|arena_salloc
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|size_t
name|ret
decl_stmt|;
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|size_t
name|pageind
decl_stmt|,
name|mapbits
decl_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
operator|!=
name|ptr
argument_list|)
expr_stmt|;
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|pageind
operator|=
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|PAGE_SHIFT
operator|)
expr_stmt|;
name|mapbits
operator|=
name|chunk
operator|->
name|map
index|[
name|pageind
index|]
operator|.
name|bits
expr_stmt|;
name|assert
argument_list|(
operator|(
name|mapbits
operator|&
name|CHUNK_MAP_ALLOCATED
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mapbits
operator|&
name|CHUNK_MAP_LARGE
operator|)
operator|==
literal|0
condition|)
block|{
name|arena_run_t
modifier|*
name|run
init|=
operator|(
name|arena_run_t
operator|*
operator|)
operator|(
name|mapbits
operator|&
operator|~
name|PAGE_MASK
operator|)
decl_stmt|;
name|assert
argument_list|(
name|run
operator|->
name|magic
operator|==
name|ARENA_RUN_MAGIC
argument_list|)
expr_stmt|;
name|ret
operator|=
name|run
operator|->
name|bin
operator|->
name|reg_size
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|mapbits
operator|&
operator|~
name|PAGE_MASK
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|size_t
name|isalloc
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|size_t
name|ret
decl_stmt|;
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk
operator|!=
name|ptr
condition|)
block|{
comment|/* Region. */
name|assert
argument_list|(
name|chunk
operator|->
name|arena
operator|->
name|magic
operator|==
name|ARENA_MAGIC
argument_list|)
expr_stmt|;
name|ret
operator|=
name|arena_salloc
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|extent_node_t
modifier|*
name|node
decl_stmt|,
name|key
decl_stmt|;
comment|/* Chunk (huge allocation). */
name|malloc_mutex_lock
argument_list|(
operator|&
name|huge_mtx
argument_list|)
expr_stmt|;
comment|/* Extract from tree of huge allocations. */
name|key
operator|.
name|addr
operator|=
name|__DECONST
argument_list|(
name|void
operator|*
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|node
operator|=
name|extent_tree_ad_search
argument_list|(
operator|&
name|huge
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|node
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ret
operator|=
name|node
operator|->
name|size
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|huge_mtx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|arena_dalloc_small
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|arena_chunk_map_t
modifier|*
name|mapelm
parameter_list|)
block|{
name|arena_run_t
modifier|*
name|run
decl_stmt|;
name|arena_bin_t
modifier|*
name|bin
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|run
operator|=
operator|(
name|arena_run_t
operator|*
operator|)
operator|(
name|mapelm
operator|->
name|bits
operator|&
operator|~
name|PAGE_MASK
operator|)
expr_stmt|;
name|assert
argument_list|(
name|run
operator|->
name|magic
operator|==
name|ARENA_RUN_MAGIC
argument_list|)
expr_stmt|;
name|bin
operator|=
name|run
operator|->
name|bin
expr_stmt|;
name|size
operator|=
name|bin
operator|->
name|reg_size
expr_stmt|;
if|if
condition|(
name|opt_junk
condition|)
name|memset
argument_list|(
name|ptr
argument_list|,
literal|0x5a
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|arena_run_reg_dalloc
argument_list|(
name|run
argument_list|,
name|bin
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|run
operator|->
name|nfree
operator|++
expr_stmt|;
if|if
condition|(
name|run
operator|->
name|nfree
operator|==
name|bin
operator|->
name|nregs
condition|)
block|{
comment|/* Deallocate run. */
if|if
condition|(
name|run
operator|==
name|bin
operator|->
name|runcur
condition|)
name|bin
operator|->
name|runcur
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|bin
operator|->
name|nregs
operator|!=
literal|1
condition|)
block|{
name|size_t
name|run_pageind
init|=
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
name|run
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|)
operator|>>
name|PAGE_SHIFT
decl_stmt|;
name|arena_chunk_map_t
modifier|*
name|run_mapelm
init|=
operator|&
name|chunk
operator|->
name|map
index|[
name|run_pageind
index|]
decl_stmt|;
comment|/* 			 * This block's conditional is necessary because if the 			 * run only contains one region, then it never gets 			 * inserted into the non-full runs tree. 			 */
name|arena_run_tree_remove
argument_list|(
operator|&
name|bin
operator|->
name|runs
argument_list|,
name|run_mapelm
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
name|run
operator|->
name|magic
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|arena_run_dalloc
argument_list|(
name|arena
argument_list|,
name|run
argument_list|,
name|true
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|bin
operator|->
name|stats
operator|.
name|curruns
operator|--
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|run
operator|->
name|nfree
operator|==
literal|1
operator|&&
name|run
operator|!=
name|bin
operator|->
name|runcur
condition|)
block|{
comment|/* 		 * Make sure that bin->runcur always refers to the lowest 		 * non-full run, if one exists. 		 */
if|if
condition|(
name|bin
operator|->
name|runcur
operator|==
name|NULL
condition|)
name|bin
operator|->
name|runcur
operator|=
name|run
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|run
operator|<
operator|(
name|uintptr_t
operator|)
name|bin
operator|->
name|runcur
condition|)
block|{
comment|/* Switch runcur. */
if|if
condition|(
name|bin
operator|->
name|runcur
operator|->
name|nfree
operator|>
literal|0
condition|)
block|{
name|arena_chunk_t
modifier|*
name|runcur_chunk
init|=
name|CHUNK_ADDR2BASE
argument_list|(
name|bin
operator|->
name|runcur
argument_list|)
decl_stmt|;
name|size_t
name|runcur_pageind
init|=
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
name|bin
operator|->
name|runcur
operator|-
operator|(
name|uintptr_t
operator|)
name|runcur_chunk
operator|)
operator|)
operator|>>
name|PAGE_SHIFT
decl_stmt|;
name|arena_chunk_map_t
modifier|*
name|runcur_mapelm
init|=
operator|&
name|runcur_chunk
operator|->
name|map
index|[
name|runcur_pageind
index|]
decl_stmt|;
comment|/* Insert runcur. */
name|arena_run_tree_insert
argument_list|(
operator|&
name|bin
operator|->
name|runs
argument_list|,
name|runcur_mapelm
argument_list|)
expr_stmt|;
block|}
name|bin
operator|->
name|runcur
operator|=
name|run
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|run_pageind
init|=
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
name|run
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|)
operator|>>
name|PAGE_SHIFT
decl_stmt|;
name|arena_chunk_map_t
modifier|*
name|run_mapelm
init|=
operator|&
name|chunk
operator|->
name|map
index|[
name|run_pageind
index|]
decl_stmt|;
name|assert
argument_list|(
name|arena_run_tree_search
argument_list|(
operator|&
name|bin
operator|->
name|runs
argument_list|,
name|run_mapelm
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|arena_run_tree_insert
argument_list|(
operator|&
name|bin
operator|->
name|runs
argument_list|,
name|run_mapelm
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|allocated_small
operator|-=
name|size
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|ndalloc_small
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_MAG
end_ifdef

begin_function
specifier|static
name|void
name|mag_unload
parameter_list|(
name|mag_t
modifier|*
name|mag
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|arena_t
modifier|*
name|arena
decl_stmt|;
name|void
modifier|*
name|round
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|ndeferred
decl_stmt|,
name|nrounds
decl_stmt|;
for|for
control|(
name|ndeferred
operator|=
name|mag
operator|->
name|nrounds
init|;
name|ndeferred
operator|>
literal|0
condition|;
control|)
block|{
name|nrounds
operator|=
name|ndeferred
expr_stmt|;
comment|/* Lock the arena associated with the first round. */
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|mag
operator|->
name|rounds
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|arena
operator|=
name|chunk
operator|->
name|arena
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_BALANCE
name|arena_lock_balance
argument_list|(
name|arena
argument_list|)
expr_stmt|;
else|#
directive|else
name|malloc_spin_lock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Deallocate every round that belongs to the locked arena. */
for|for
control|(
name|i
operator|=
name|ndeferred
operator|=
literal|0
init|;
name|i
operator|<
name|nrounds
condition|;
name|i
operator|++
control|)
block|{
name|round
operator|=
name|mag
operator|->
name|rounds
index|[
name|i
index|]
expr_stmt|;
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|round
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk
operator|->
name|arena
operator|==
name|arena
condition|)
block|{
name|size_t
name|pageind
init|=
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
name|round
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|PAGE_SHIFT
operator|)
decl_stmt|;
name|arena_chunk_map_t
modifier|*
name|mapelm
init|=
operator|&
name|chunk
operator|->
name|map
index|[
name|pageind
index|]
decl_stmt|;
name|arena_dalloc_small
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|round
argument_list|,
name|mapelm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * This round was allocated via a different 				 * arena than the one that is currently locked. 				 * Stash the round, so that it can be handled 				 * in a future pass. 				 */
name|mag
operator|->
name|rounds
index|[
name|ndeferred
index|]
operator|=
name|round
expr_stmt|;
name|ndeferred
operator|++
expr_stmt|;
block|}
block|}
name|malloc_spin_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
name|mag
operator|->
name|nrounds
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|mag_rack_dalloc
parameter_list|(
name|mag_rack_t
modifier|*
name|rack
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|arena_t
modifier|*
name|arena
decl_stmt|;
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|arena_run_t
modifier|*
name|run
decl_stmt|;
name|arena_bin_t
modifier|*
name|bin
decl_stmt|;
name|bin_mags_t
modifier|*
name|bin_mags
decl_stmt|;
name|mag_t
modifier|*
name|mag
decl_stmt|;
name|size_t
name|pageind
decl_stmt|,
name|binind
decl_stmt|;
name|arena_chunk_map_t
modifier|*
name|mapelm
decl_stmt|;
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|arena
operator|=
name|chunk
operator|->
name|arena
expr_stmt|;
name|pageind
operator|=
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|PAGE_SHIFT
operator|)
expr_stmt|;
name|mapelm
operator|=
operator|&
name|chunk
operator|->
name|map
index|[
name|pageind
index|]
expr_stmt|;
name|run
operator|=
operator|(
name|arena_run_t
operator|*
operator|)
operator|(
name|mapelm
operator|->
name|bits
operator|&
operator|~
name|PAGE_MASK
operator|)
expr_stmt|;
name|assert
argument_list|(
name|run
operator|->
name|magic
operator|==
name|ARENA_RUN_MAGIC
argument_list|)
expr_stmt|;
name|bin
operator|=
name|run
operator|->
name|bin
expr_stmt|;
name|binind
operator|=
operator|(
operator|(
name|uintptr_t
operator|)
name|bin
operator|-
operator|(
name|uintptr_t
operator|)
operator|&
name|arena
operator|->
name|bins
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|arena_bin_t
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|binind
operator|<
name|nbins
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_junk
condition|)
name|memset
argument_list|(
name|ptr
argument_list|,
literal|0x5a
argument_list|,
name|arena
operator|->
name|bins
index|[
name|binind
index|]
operator|.
name|reg_size
argument_list|)
expr_stmt|;
name|bin_mags
operator|=
operator|&
name|rack
operator|->
name|bin_mags
index|[
name|binind
index|]
expr_stmt|;
name|mag
operator|=
name|bin_mags
operator|->
name|curmag
expr_stmt|;
if|if
condition|(
name|mag
operator|==
name|NULL
condition|)
block|{
comment|/* Create an initial magazine for this size class. */
name|assert
argument_list|(
name|bin_mags
operator|->
name|sparemag
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|mag
operator|=
name|mag_create
argument_list|(
name|choose_arena
argument_list|()
argument_list|,
name|binind
argument_list|)
expr_stmt|;
if|if
condition|(
name|mag
operator|==
name|NULL
condition|)
block|{
name|malloc_spin_lock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
name|arena_dalloc_small
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|ptr
argument_list|,
name|mapelm
argument_list|)
expr_stmt|;
name|malloc_spin_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|bin_mags
operator|->
name|curmag
operator|=
name|mag
expr_stmt|;
block|}
if|if
condition|(
name|mag
operator|->
name|nrounds
operator|==
name|max_rounds
condition|)
block|{
if|if
condition|(
name|bin_mags
operator|->
name|sparemag
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|bin_mags
operator|->
name|sparemag
operator|->
name|nrounds
operator|<
name|max_rounds
condition|)
block|{
comment|/* Swap magazines. */
name|bin_mags
operator|->
name|curmag
operator|=
name|bin_mags
operator|->
name|sparemag
expr_stmt|;
name|bin_mags
operator|->
name|sparemag
operator|=
name|mag
expr_stmt|;
name|mag
operator|=
name|bin_mags
operator|->
name|curmag
expr_stmt|;
block|}
else|else
block|{
comment|/* Unload the current magazine. */
name|mag_unload
argument_list|(
name|mag
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Create a second magazine. */
name|mag
operator|=
name|mag_create
argument_list|(
name|choose_arena
argument_list|()
argument_list|,
name|binind
argument_list|)
expr_stmt|;
if|if
condition|(
name|mag
operator|==
name|NULL
condition|)
block|{
name|mag
operator|=
name|rack
operator|->
name|bin_mags
index|[
name|binind
index|]
operator|.
name|curmag
expr_stmt|;
name|mag_unload
argument_list|(
name|mag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bin_mags
operator|->
name|sparemag
operator|=
name|bin_mags
operator|->
name|curmag
expr_stmt|;
name|bin_mags
operator|->
name|curmag
operator|=
name|mag
expr_stmt|;
block|}
block|}
name|assert
argument_list|(
name|mag
operator|->
name|nrounds
operator|<
name|max_rounds
argument_list|)
expr_stmt|;
block|}
name|mag
operator|->
name|rounds
index|[
name|mag
operator|->
name|nrounds
index|]
operator|=
name|ptr
expr_stmt|;
name|mag
operator|->
name|nrounds
operator|++
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|arena_dalloc_large
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
comment|/* Large allocation. */
name|malloc_spin_lock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|MALLOC_STATS
if|if
condition|(
name|opt_junk
condition|)
endif|#
directive|endif
block|{
name|size_t
name|pageind
init|=
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|PAGE_SHIFT
decl_stmt|;
name|size_t
name|size
init|=
name|chunk
operator|->
name|map
index|[
name|pageind
index|]
operator|.
name|bits
operator|&
operator|~
name|PAGE_MASK
decl_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
if|if
condition|(
name|opt_junk
condition|)
endif|#
directive|endif
name|memset
argument_list|(
name|ptr
argument_list|,
literal|0x5a
argument_list|,
name|size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|allocated_large
operator|-=
name|size
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|ndalloc_large
operator|++
expr_stmt|;
endif|#
directive|endif
name|arena_run_dalloc
argument_list|(
name|arena
argument_list|,
operator|(
name|arena_run_t
operator|*
operator|)
name|ptr
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|malloc_spin_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|arena_dalloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|size_t
name|pageind
decl_stmt|;
name|arena_chunk_map_t
modifier|*
name|mapelm
decl_stmt|;
name|assert
argument_list|(
name|arena
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena
operator|->
name|magic
operator|==
name|ARENA_MAGIC
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|chunk
operator|->
name|arena
operator|==
name|arena
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
operator|!=
name|ptr
argument_list|)
expr_stmt|;
name|pageind
operator|=
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|PAGE_SHIFT
operator|)
expr_stmt|;
name|mapelm
operator|=
operator|&
name|chunk
operator|->
name|map
index|[
name|pageind
index|]
expr_stmt|;
name|assert
argument_list|(
operator|(
name|mapelm
operator|->
name|bits
operator|&
name|CHUNK_MAP_ALLOCATED
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mapelm
operator|->
name|bits
operator|&
name|CHUNK_MAP_LARGE
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Small allocation. */
ifdef|#
directive|ifdef
name|MALLOC_MAG
if|if
condition|(
name|__isthreaded
operator|&&
name|opt_mag
condition|)
block|{
name|mag_rack_t
modifier|*
name|rack
init|=
name|mag_rack
decl_stmt|;
if|if
condition|(
name|rack
operator|==
name|NULL
condition|)
block|{
name|rack
operator|=
name|mag_rack_create
argument_list|(
name|arena
argument_list|)
expr_stmt|;
if|if
condition|(
name|rack
operator|==
name|NULL
condition|)
block|{
name|malloc_spin_lock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
name|arena_dalloc_small
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|ptr
argument_list|,
name|mapelm
argument_list|)
expr_stmt|;
name|malloc_spin_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|mag_rack
operator|=
name|rack
expr_stmt|;
block|}
name|mag_rack_dalloc
argument_list|(
name|rack
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
name|malloc_spin_lock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
name|arena_dalloc_small
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|ptr
argument_list|,
name|mapelm
argument_list|)
expr_stmt|;
name|malloc_spin_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_MAG
block|}
endif|#
directive|endif
block|}
else|else
name|arena_dalloc_large
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|idalloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk
operator|!=
name|ptr
condition|)
name|arena_dalloc
argument_list|(
name|chunk
operator|->
name|arena
argument_list|,
name|chunk
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
else|else
name|huge_dalloc
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_ralloc_large_shrink
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|oldsize
parameter_list|)
block|{
name|assert
argument_list|(
name|size
operator|<
name|oldsize
argument_list|)
expr_stmt|;
comment|/* 	 * Shrink the run, and make trailing pages available for other 	 * allocations. 	 */
ifdef|#
directive|ifdef
name|MALLOC_BALANCE
name|arena_lock_balance
argument_list|(
name|arena
argument_list|)
expr_stmt|;
else|#
directive|else
name|malloc_spin_lock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|arena_run_trim_tail
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
operator|(
name|arena_run_t
operator|*
operator|)
name|ptr
argument_list|,
name|oldsize
argument_list|,
name|size
argument_list|,
name|true
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|allocated_large
operator|-=
name|oldsize
operator|-
name|size
expr_stmt|;
endif|#
directive|endif
name|malloc_spin_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|arena_ralloc_large_grow
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_chunk_t
modifier|*
name|chunk
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|oldsize
parameter_list|)
block|{
name|size_t
name|pageind
init|=
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|PAGE_SHIFT
decl_stmt|;
name|size_t
name|npages
init|=
name|oldsize
operator|>>
name|PAGE_SHIFT
decl_stmt|;
name|assert
argument_list|(
name|oldsize
operator|==
operator|(
name|chunk
operator|->
name|map
index|[
name|pageind
index|]
operator|.
name|bits
operator|&
operator|~
name|PAGE_MASK
operator|)
argument_list|)
expr_stmt|;
comment|/* Try to extend the run. */
name|assert
argument_list|(
name|size
operator|>
name|oldsize
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_BALANCE
name|arena_lock_balance
argument_list|(
name|arena
argument_list|)
expr_stmt|;
else|#
directive|else
name|malloc_spin_lock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pageind
operator|+
name|npages
operator|<
name|chunk_npages
operator|&&
operator|(
name|chunk
operator|->
name|map
index|[
name|pageind
operator|+
name|npages
index|]
operator|.
name|bits
operator|&
name|CHUNK_MAP_ALLOCATED
operator|)
operator|==
literal|0
operator|&&
operator|(
name|chunk
operator|->
name|map
index|[
name|pageind
operator|+
name|npages
index|]
operator|.
name|bits
operator|&
operator|~
name|PAGE_MASK
operator|)
operator|>=
name|size
operator|-
name|oldsize
condition|)
block|{
comment|/* 		 * The next run is available and sufficiently large.  Split the 		 * following run, then merge the first part with the existing 		 * allocation. 		 */
name|arena_run_split
argument_list|(
name|arena
argument_list|,
operator|(
name|arena_run_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|+
operator|(
operator|(
name|pageind
operator|+
name|npages
operator|)
operator|<<
name|PAGE_SHIFT
operator|)
operator|)
argument_list|,
name|size
operator|-
name|oldsize
argument_list|,
name|true
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|chunk
operator|->
name|map
index|[
name|pageind
index|]
operator|.
name|bits
operator|=
name|size
operator||
name|CHUNK_MAP_LARGE
operator||
name|CHUNK_MAP_ALLOCATED
expr_stmt|;
name|chunk
operator|->
name|map
index|[
name|pageind
operator|+
name|npages
index|]
operator|.
name|bits
operator|=
name|CHUNK_MAP_LARGE
operator||
name|CHUNK_MAP_ALLOCATED
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|allocated_large
operator|+=
name|size
operator|-
name|oldsize
expr_stmt|;
endif|#
directive|endif
name|malloc_spin_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
name|malloc_spin_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Try to resize a large allocation, in order to avoid copying.  This will  * always fail if growing an object, and the following run is already in use.  */
end_comment

begin_function
specifier|static
name|bool
name|arena_ralloc_large
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|oldsize
parameter_list|)
block|{
name|size_t
name|psize
decl_stmt|;
name|psize
operator|=
name|PAGE_CEILING
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|psize
operator|==
name|oldsize
condition|)
block|{
comment|/* Same size class. */
if|if
condition|(
name|opt_junk
operator|&&
name|size
operator|<
name|oldsize
condition|)
block|{
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|+
name|size
operator|)
argument_list|,
literal|0x5a
argument_list|,
name|oldsize
operator|-
name|size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
else|else
block|{
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|arena_t
modifier|*
name|arena
decl_stmt|;
name|chunk
operator|=
operator|(
name|arena_chunk_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|arena
operator|=
name|chunk
operator|->
name|arena
expr_stmt|;
name|assert
argument_list|(
name|arena
operator|->
name|magic
operator|==
name|ARENA_MAGIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|psize
operator|<
name|oldsize
condition|)
block|{
comment|/* Fill before shrinking in order avoid a race. */
if|if
condition|(
name|opt_junk
condition|)
block|{
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|+
name|size
operator|)
argument_list|,
literal|0x5a
argument_list|,
name|oldsize
operator|-
name|size
argument_list|)
expr_stmt|;
block|}
name|arena_ralloc_large_shrink
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|ptr
argument_list|,
name|psize
argument_list|,
name|oldsize
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
else|else
block|{
name|bool
name|ret
init|=
name|arena_ralloc_large_grow
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|ptr
argument_list|,
name|psize
argument_list|,
name|oldsize
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|==
name|false
operator|&&
name|opt_zero
condition|)
block|{
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|+
name|oldsize
operator|)
argument_list|,
literal|0
argument_list|,
name|size
operator|-
name|oldsize
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|arena_ralloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|oldsize
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|size_t
name|copysize
decl_stmt|;
comment|/* Try to avoid moving the allocation. */
if|if
condition|(
name|size
operator|<=
name|bin_maxclass
condition|)
block|{
if|if
condition|(
name|oldsize
operator|<=
name|bin_maxclass
operator|&&
name|size2bin
index|[
name|size
index|]
operator|==
name|size2bin
index|[
name|oldsize
index|]
condition|)
goto|goto
name|IN_PLACE
goto|;
block|}
else|else
block|{
if|if
condition|(
name|oldsize
operator|>
name|bin_maxclass
operator|&&
name|oldsize
operator|<=
name|arena_maxclass
condition|)
block|{
name|assert
argument_list|(
name|size
operator|>
name|bin_maxclass
argument_list|)
expr_stmt|;
if|if
condition|(
name|arena_ralloc_large
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
name|oldsize
argument_list|)
operator|==
name|false
condition|)
return|return
operator|(
name|ptr
operator|)
return|;
block|}
block|}
comment|/* 	 * If we get here, then size and oldsize are different enough that we 	 * need to move the object.  In that case, fall back to allocating new 	 * space and copying. 	 */
name|ret
operator|=
name|arena_malloc
argument_list|(
name|choose_arena
argument_list|()
argument_list|,
name|size
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Junk/zero-filling were already done by arena_malloc(). */
name|copysize
operator|=
operator|(
name|size
operator|<
name|oldsize
operator|)
condition|?
name|size
else|:
name|oldsize
expr_stmt|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|ptr
argument_list|,
name|copysize
argument_list|)
expr_stmt|;
name|idalloc
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
name|IN_PLACE
label|:
if|if
condition|(
name|opt_junk
operator|&&
name|size
operator|<
name|oldsize
condition|)
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|+
name|size
operator|)
argument_list|,
literal|0x5a
argument_list|,
name|oldsize
operator|-
name|size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opt_zero
operator|&&
name|size
operator|>
name|oldsize
condition|)
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|+
name|oldsize
operator|)
argument_list|,
literal|0
argument_list|,
name|size
operator|-
name|oldsize
argument_list|)
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
modifier|*
name|iralloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|oldsize
decl_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|oldsize
operator|=
name|isalloc
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
name|arena_maxclass
condition|)
return|return
operator|(
name|arena_ralloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
name|oldsize
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|huge_ralloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
name|oldsize
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|arena_new
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|arena_bin_t
modifier|*
name|bin
decl_stmt|;
name|size_t
name|prev_run_size
decl_stmt|;
if|if
condition|(
name|malloc_spin_init
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
condition|)
return|return
operator|(
name|true
operator|)
return|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|memset
argument_list|(
operator|&
name|arena
operator|->
name|stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|arena_stats_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize chunks. */
name|arena_chunk_tree_dirty_new
argument_list|(
operator|&
name|arena
operator|->
name|chunks_dirty
argument_list|)
expr_stmt|;
name|arena
operator|->
name|spare
operator|=
name|NULL
expr_stmt|;
name|arena
operator|->
name|ndirty
operator|=
literal|0
expr_stmt|;
name|arena_avail_tree_new
argument_list|(
operator|&
name|arena
operator|->
name|runs_avail
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_BALANCE
name|arena
operator|->
name|contention
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize bins. */
name|prev_run_size
operator|=
name|PAGE_SIZE
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_TINY
comment|/* (2^n)-spaced tiny bins. */
for|for
control|(
init|;
name|i
operator|<
name|ntbins
condition|;
name|i
operator|++
control|)
block|{
name|bin
operator|=
operator|&
name|arena
operator|->
name|bins
index|[
name|i
index|]
expr_stmt|;
name|bin
operator|->
name|runcur
operator|=
name|NULL
expr_stmt|;
name|arena_run_tree_new
argument_list|(
operator|&
name|bin
operator|->
name|runs
argument_list|)
expr_stmt|;
name|bin
operator|->
name|reg_size
operator|=
operator|(
literal|1U
operator|<<
operator|(
name|TINY_MIN_2POW
operator|+
name|i
operator|)
operator|)
expr_stmt|;
name|prev_run_size
operator|=
name|arena_bin_run_size_calc
argument_list|(
name|bin
argument_list|,
name|prev_run_size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|memset
argument_list|(
operator|&
name|bin
operator|->
name|stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|malloc_bin_stats_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* Quantum-spaced bins. */
for|for
control|(
init|;
name|i
operator|<
name|ntbins
operator|+
name|nqbins
condition|;
name|i
operator|++
control|)
block|{
name|bin
operator|=
operator|&
name|arena
operator|->
name|bins
index|[
name|i
index|]
expr_stmt|;
name|bin
operator|->
name|runcur
operator|=
name|NULL
expr_stmt|;
name|arena_run_tree_new
argument_list|(
operator|&
name|bin
operator|->
name|runs
argument_list|)
expr_stmt|;
name|bin
operator|->
name|reg_size
operator|=
operator|(
name|i
operator|-
name|ntbins
operator|+
literal|1
operator|)
operator|<<
name|QUANTUM_2POW
expr_stmt|;
name|prev_run_size
operator|=
name|arena_bin_run_size_calc
argument_list|(
name|bin
argument_list|,
name|prev_run_size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|memset
argument_list|(
operator|&
name|bin
operator|->
name|stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|malloc_bin_stats_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Cacheline-spaced bins. */
for|for
control|(
init|;
name|i
operator|<
name|ntbins
operator|+
name|nqbins
operator|+
name|ncbins
condition|;
name|i
operator|++
control|)
block|{
name|bin
operator|=
operator|&
name|arena
operator|->
name|bins
index|[
name|i
index|]
expr_stmt|;
name|bin
operator|->
name|runcur
operator|=
name|NULL
expr_stmt|;
name|arena_run_tree_new
argument_list|(
operator|&
name|bin
operator|->
name|runs
argument_list|)
expr_stmt|;
name|bin
operator|->
name|reg_size
operator|=
name|cspace_min
operator|+
operator|(
operator|(
name|i
operator|-
operator|(
name|ntbins
operator|+
name|nqbins
operator|)
operator|)
operator|<<
name|CACHELINE_2POW
operator|)
expr_stmt|;
name|prev_run_size
operator|=
name|arena_bin_run_size_calc
argument_list|(
name|bin
argument_list|,
name|prev_run_size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|memset
argument_list|(
operator|&
name|bin
operator|->
name|stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|malloc_bin_stats_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Subpage-spaced bins. */
for|for
control|(
init|;
name|i
operator|<
name|nbins
condition|;
name|i
operator|++
control|)
block|{
name|bin
operator|=
operator|&
name|arena
operator|->
name|bins
index|[
name|i
index|]
expr_stmt|;
name|bin
operator|->
name|runcur
operator|=
name|NULL
expr_stmt|;
name|arena_run_tree_new
argument_list|(
operator|&
name|bin
operator|->
name|runs
argument_list|)
expr_stmt|;
name|bin
operator|->
name|reg_size
operator|=
name|sspace_min
operator|+
operator|(
operator|(
name|i
operator|-
operator|(
name|ntbins
operator|+
name|nqbins
operator|+
name|ncbins
operator|)
operator|)
operator|<<
name|SUBPAGE_2POW
operator|)
expr_stmt|;
name|prev_run_size
operator|=
name|arena_bin_run_size_calc
argument_list|(
name|bin
argument_list|,
name|prev_run_size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|memset
argument_list|(
operator|&
name|bin
operator|->
name|stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|malloc_bin_stats_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
name|arena
operator|->
name|magic
operator|=
name|ARENA_MAGIC
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Create a new arena and insert it into the arenas array at index ind. */
end_comment

begin_function
specifier|static
name|arena_t
modifier|*
name|arenas_extend
parameter_list|(
name|unsigned
name|ind
parameter_list|)
block|{
name|arena_t
modifier|*
name|ret
decl_stmt|;
comment|/* Allocate enough space for trailing bins. */
name|ret
operator|=
operator|(
name|arena_t
operator|*
operator|)
name|base_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arena_t
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|arena_bin_t
argument_list|)
operator|*
operator|(
name|nbins
operator|-
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
operator|&&
name|arena_new
argument_list|(
name|ret
argument_list|)
operator|==
name|false
condition|)
block|{
name|arenas
index|[
name|ind
index|]
operator|=
name|ret
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* Only reached if there is an OOM error. */
comment|/* 	 * OOM here is quite inconvenient to propagate, since dealing with it 	 * would require a check for failure in the fast path.  Instead, punt 	 * by using arenas[0].  In practice, this is an extremely unlikely 	 * failure. 	 */
name|_malloc_message
argument_list|(
name|_getprogname
argument_list|()
argument_list|,
literal|": (malloc) Error initializing arena\n"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_abort
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|arenas
index|[
literal|0
index|]
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_MAG
end_ifdef

begin_function
specifier|static
name|mag_t
modifier|*
name|mag_create
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|binind
parameter_list|)
block|{
name|mag_t
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|mag_t
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
operator|(
name|max_rounds
operator|-
literal|1
operator|)
operator|)
operator|<=
name|bin_maxclass
condition|)
block|{
name|ret
operator|=
name|arena_malloc_small
argument_list|(
name|arena
argument_list|,
sizeof|sizeof
argument_list|(
name|mag_t
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
operator|(
name|max_rounds
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|imalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|mag_t
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
operator|(
name|max_rounds
operator|-
literal|1
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ret
operator|->
name|binind
operator|=
name|binind
expr_stmt|;
name|ret
operator|->
name|nrounds
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mag_destroy
parameter_list|(
name|mag_t
modifier|*
name|mag
parameter_list|)
block|{
name|arena_t
modifier|*
name|arena
decl_stmt|;
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|size_t
name|pageind
decl_stmt|;
name|arena_chunk_map_t
modifier|*
name|mapelm
decl_stmt|;
name|chunk
operator|=
name|CHUNK_ADDR2BASE
argument_list|(
name|mag
argument_list|)
expr_stmt|;
name|arena
operator|=
name|chunk
operator|->
name|arena
expr_stmt|;
name|pageind
operator|=
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
name|mag
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|PAGE_SHIFT
operator|)
expr_stmt|;
name|mapelm
operator|=
operator|&
name|chunk
operator|->
name|map
index|[
name|pageind
index|]
expr_stmt|;
name|assert
argument_list|(
name|mag
operator|->
name|nrounds
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
sizeof|sizeof
argument_list|(
name|mag_t
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
operator|(
name|max_rounds
operator|-
literal|1
operator|)
operator|)
operator|<=
name|bin_maxclass
condition|)
block|{
name|malloc_spin_lock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
name|arena_dalloc_small
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|mag
argument_list|,
name|mapelm
argument_list|)
expr_stmt|;
name|malloc_spin_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
else|else
name|idalloc
argument_list|(
name|mag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|mag_rack_t
modifier|*
name|mag_rack_create
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|assert
argument_list|(
sizeof|sizeof
argument_list|(
name|mag_rack_t
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|bin_mags_t
operator|*
argument_list|)
operator|*
operator|(
name|nbins
operator|-
literal|1
operator|)
operator|)
operator|<=
name|bin_maxclass
argument_list|)
expr_stmt|;
return|return
operator|(
name|arena_malloc_small
argument_list|(
name|arena
argument_list|,
sizeof|sizeof
argument_list|(
name|mag_rack_t
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|bin_mags_t
argument_list|)
operator|*
operator|(
name|nbins
operator|-
literal|1
operator|)
operator|)
argument_list|,
name|true
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mag_rack_destroy
parameter_list|(
name|mag_rack_t
modifier|*
name|rack
parameter_list|)
block|{
name|arena_t
modifier|*
name|arena
decl_stmt|;
name|arena_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|bin_mags_t
modifier|*
name|bin_mags
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|pageind
decl_stmt|;
name|arena_chunk_map_t
modifier|*
name|mapelm
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nbins
condition|;
name|i
operator|++
control|)
block|{
name|bin_mags
operator|=
operator|&
name|rack
operator|->
name|bin_mags
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|bin_mags
operator|->
name|curmag
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|bin_mags
operator|->
name|curmag
operator|->
name|binind
operator|==
name|i
argument_list|)
expr_stmt|;
name|mag_unload
argument_list|(
name|bin_mags
operator|->
name|curmag
argument_list|)
expr_stmt|;
name|mag_destroy
argument_list|(
name|bin_mags
operator|->
name|curmag
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bin_mags
operator|->
name|sparemag
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|bin_mags
operator|->
name|sparemag
operator|->
name|binind
operator|==
name|i
argument_list|)
expr_stmt|;
name|mag_unload
argument_list|(
name|bin_mags
operator|->
name|sparemag
argument_list|)
expr_stmt|;
name|mag_destroy
argument_list|(
name|bin_mags
operator|->
name|sparemag
argument_list|)
expr_stmt|;
block|}
block|}
name|chunk
operator|=
name|CHUNK_ADDR2BASE
argument_list|(
name|rack
argument_list|)
expr_stmt|;
name|arena
operator|=
name|chunk
operator|->
name|arena
expr_stmt|;
name|pageind
operator|=
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
name|rack
operator|-
operator|(
name|uintptr_t
operator|)
name|chunk
operator|)
operator|>>
name|PAGE_SHIFT
operator|)
expr_stmt|;
name|mapelm
operator|=
operator|&
name|chunk
operator|->
name|map
index|[
name|pageind
index|]
expr_stmt|;
name|malloc_spin_lock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
name|arena_dalloc_small
argument_list|(
name|arena
argument_list|,
name|chunk
argument_list|,
name|rack
argument_list|,
name|mapelm
argument_list|)
expr_stmt|;
name|malloc_spin_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * End arena.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin general internal functions.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|huge_malloc
parameter_list|(
name|size_t
name|size
parameter_list|,
name|bool
name|zero
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|size_t
name|csize
decl_stmt|;
name|extent_node_t
modifier|*
name|node
decl_stmt|;
comment|/* Allocate one or more contiguous chunks for this request. */
name|csize
operator|=
name|CHUNK_CEILING
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|csize
operator|==
literal|0
condition|)
block|{
comment|/* size is large enough to cause size_t wrap-around. */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Allocate an extent node with which to track the chunk. */
name|node
operator|=
name|base_node_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ret
operator|=
name|chunk_alloc
argument_list|(
name|csize
argument_list|,
name|zero
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
name|base_node_dealloc
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* Insert node into huge. */
name|node
operator|->
name|addr
operator|=
name|ret
expr_stmt|;
name|node
operator|->
name|size
operator|=
name|csize
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|huge_mtx
argument_list|)
expr_stmt|;
name|extent_tree_ad_insert
argument_list|(
operator|&
name|huge
argument_list|,
name|node
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|huge_nmalloc
operator|++
expr_stmt|;
name|huge_allocated
operator|+=
name|csize
expr_stmt|;
endif|#
directive|endif
name|malloc_mutex_unlock
argument_list|(
operator|&
name|huge_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|zero
operator|==
name|false
condition|)
block|{
if|if
condition|(
name|opt_junk
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0xa5
argument_list|,
name|csize
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opt_zero
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|csize
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Only handles large allocations that require more than chunk alignment. */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|huge_palloc
parameter_list|(
name|size_t
name|alignment
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|size_t
name|alloc_size
decl_stmt|,
name|chunk_size
decl_stmt|,
name|offset
decl_stmt|;
name|extent_node_t
modifier|*
name|node
decl_stmt|;
comment|/* 	 * This allocation requires alignment that is even larger than chunk 	 * alignment.  This means that huge_malloc() isn't good enough. 	 * 	 * Allocate almost twice as many chunks as are demanded by the size or 	 * alignment, in order to assure the alignment can be achieved, then 	 * unmap leading and trailing chunks. 	 */
name|assert
argument_list|(
name|alignment
operator|>=
name|chunksize
argument_list|)
expr_stmt|;
name|chunk_size
operator|=
name|CHUNK_CEILING
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>=
name|alignment
condition|)
name|alloc_size
operator|=
name|chunk_size
operator|+
name|alignment
operator|-
name|chunksize
expr_stmt|;
else|else
name|alloc_size
operator|=
operator|(
name|alignment
operator|<<
literal|1
operator|)
operator|-
name|chunksize
expr_stmt|;
comment|/* Allocate an extent node with which to track the chunk. */
name|node
operator|=
name|base_node_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ret
operator|=
name|chunk_alloc
argument_list|(
name|alloc_size
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
name|base_node_dealloc
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|offset
operator|=
operator|(
name|uintptr_t
operator|)
name|ret
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|offset
operator|&
name|chunksize_mask
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|offset
operator|<
name|alloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
block|{
comment|/* Trim trailing space. */
name|chunk_dealloc
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ret
operator|+
name|chunk_size
operator|)
argument_list|,
name|alloc_size
operator|-
name|chunk_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|trailsize
decl_stmt|;
comment|/* Trim leading space. */
name|chunk_dealloc
argument_list|(
name|ret
argument_list|,
name|alignment
operator|-
name|offset
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ret
operator|+
operator|(
name|alignment
operator|-
name|offset
operator|)
operator|)
expr_stmt|;
name|trailsize
operator|=
name|alloc_size
operator|-
operator|(
name|alignment
operator|-
name|offset
operator|)
operator|-
name|chunk_size
expr_stmt|;
if|if
condition|(
name|trailsize
operator|!=
literal|0
condition|)
block|{
comment|/* Trim trailing space. */
name|assert
argument_list|(
name|trailsize
operator|<
name|alloc_size
argument_list|)
expr_stmt|;
name|chunk_dealloc
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ret
operator|+
name|chunk_size
operator|)
argument_list|,
name|trailsize
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Insert node into huge. */
name|node
operator|->
name|addr
operator|=
name|ret
expr_stmt|;
name|node
operator|->
name|size
operator|=
name|chunk_size
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|huge_mtx
argument_list|)
expr_stmt|;
name|extent_tree_ad_insert
argument_list|(
operator|&
name|huge
argument_list|,
name|node
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|huge_nmalloc
operator|++
expr_stmt|;
name|huge_allocated
operator|+=
name|chunk_size
expr_stmt|;
endif|#
directive|endif
name|malloc_mutex_unlock
argument_list|(
operator|&
name|huge_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_junk
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0xa5
argument_list|,
name|chunk_size
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opt_zero
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|chunk_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|huge_ralloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|,
name|size_t
name|oldsize
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|size_t
name|copysize
decl_stmt|;
comment|/* Avoid moving the allocation if the size class would not change. */
if|if
condition|(
name|oldsize
operator|>
name|arena_maxclass
operator|&&
name|CHUNK_CEILING
argument_list|(
name|size
argument_list|)
operator|==
name|CHUNK_CEILING
argument_list|(
name|oldsize
argument_list|)
condition|)
block|{
if|if
condition|(
name|opt_junk
operator|&&
name|size
operator|<
name|oldsize
condition|)
block|{
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|+
name|size
operator|)
argument_list|,
literal|0x5a
argument_list|,
name|oldsize
operator|-
name|size
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opt_zero
operator|&&
name|size
operator|>
name|oldsize
condition|)
block|{
name|memset
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ptr
operator|+
name|oldsize
operator|)
argument_list|,
literal|0
argument_list|,
name|size
operator|-
name|oldsize
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ptr
operator|)
return|;
block|}
comment|/* 	 * If we get here, then size and oldsize are different enough that we 	 * need to use a different size class.  In that case, fall back to 	 * allocating new space and copying. 	 */
name|ret
operator|=
name|huge_malloc
argument_list|(
name|size
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|copysize
operator|=
operator|(
name|size
operator|<
name|oldsize
operator|)
condition|?
name|size
else|:
name|oldsize
expr_stmt|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|ptr
argument_list|,
name|copysize
argument_list|)
expr_stmt|;
name|idalloc
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|huge_dalloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|extent_node_t
modifier|*
name|node
decl_stmt|,
name|key
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|huge_mtx
argument_list|)
expr_stmt|;
comment|/* Extract from tree of huge allocations. */
name|key
operator|.
name|addr
operator|=
name|ptr
expr_stmt|;
name|node
operator|=
name|extent_tree_ad_search
argument_list|(
operator|&
name|huge
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|node
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|node
operator|->
name|addr
operator|==
name|ptr
argument_list|)
expr_stmt|;
name|extent_tree_ad_remove
argument_list|(
operator|&
name|huge
argument_list|,
name|node
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|huge_ndalloc
operator|++
expr_stmt|;
name|huge_allocated
operator|-=
name|node
operator|->
name|size
expr_stmt|;
endif|#
directive|endif
name|malloc_mutex_unlock
argument_list|(
operator|&
name|huge_mtx
argument_list|)
expr_stmt|;
comment|/* Unmap chunk. */
ifdef|#
directive|ifdef
name|MALLOC_DSS
if|if
condition|(
name|opt_dss
operator|&&
name|opt_junk
condition|)
name|memset
argument_list|(
name|node
operator|->
name|addr
argument_list|,
literal|0x5a
argument_list|,
name|node
operator|->
name|size
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|chunk_dealloc
argument_list|(
name|node
operator|->
name|addr
argument_list|,
name|node
operator|->
name|size
argument_list|)
expr_stmt|;
name|base_node_dealloc
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|malloc_print_stats
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|opt_print_stats
condition|)
block|{
name|char
name|s
index|[
name|UMAX2S_BUFSIZE
index|]
decl_stmt|;
name|_malloc_message
argument_list|(
literal|"___ Begin malloc statistics ___\n"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|_malloc_message
argument_list|(
literal|"Assertions "
argument_list|,
ifdef|#
directive|ifdef
name|NDEBUG
literal|"disabled"
argument_list|,
else|#
directive|else
literal|"enabled"
argument_list|,
endif|#
directive|endif
literal|"\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|_malloc_message
argument_list|(
literal|"Boolean MALLOC_OPTIONS: "
argument_list|,
name|opt_abort
condition|?
literal|"A"
else|:
literal|"a"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_DSS
name|_malloc_message
argument_list|(
name|opt_dss
condition|?
literal|"D"
else|:
literal|"d"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MALLOC_MAG
name|_malloc_message
argument_list|(
name|opt_mag
condition|?
literal|"G"
else|:
literal|"g"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_malloc_message
argument_list|(
name|opt_junk
condition|?
literal|"J"
else|:
literal|"j"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_DSS
name|_malloc_message
argument_list|(
name|opt_mmap
condition|?
literal|"M"
else|:
literal|"m"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_malloc_message
argument_list|(
name|opt_utrace
condition|?
literal|"PU"
else|:
literal|"Pu"
argument_list|,
name|opt_sysv
condition|?
literal|"V"
else|:
literal|"v"
argument_list|,
name|opt_xmalloc
condition|?
literal|"X"
else|:
literal|"x"
argument_list|,
name|opt_zero
condition|?
literal|"Z\n"
else|:
literal|"z\n"
argument_list|)
expr_stmt|;
name|_malloc_message
argument_list|(
literal|"CPUs: "
argument_list|,
name|umax2s
argument_list|(
name|ncpus
argument_list|,
name|s
argument_list|)
argument_list|,
literal|"\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|_malloc_message
argument_list|(
literal|"Max arenas: "
argument_list|,
name|umax2s
argument_list|(
name|narenas
argument_list|,
name|s
argument_list|)
argument_list|,
literal|"\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_BALANCE
name|_malloc_message
argument_list|(
literal|"Arena balance threshold: "
argument_list|,
name|umax2s
argument_list|(
name|opt_balance_threshold
argument_list|,
name|s
argument_list|)
argument_list|,
literal|"\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_malloc_message
argument_list|(
literal|"Pointer size: "
argument_list|,
name|umax2s
argument_list|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|s
argument_list|)
argument_list|,
literal|"\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|_malloc_message
argument_list|(
literal|"Quantum size: "
argument_list|,
name|umax2s
argument_list|(
name|QUANTUM
argument_list|,
name|s
argument_list|)
argument_list|,
literal|"\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|_malloc_message
argument_list|(
literal|"Cacheline size (assumed): "
argument_list|,
name|umax2s
argument_list|(
name|CACHELINE
argument_list|,
name|s
argument_list|)
argument_list|,
literal|"\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_TINY
name|_malloc_message
argument_list|(
literal|"Tiny 2^n-spaced sizes: ["
argument_list|,
name|umax2s
argument_list|(
operator|(
literal|1U
operator|<<
name|TINY_MIN_2POW
operator|)
argument_list|,
name|s
argument_list|)
argument_list|,
literal|".."
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|_malloc_message
argument_list|(
name|umax2s
argument_list|(
operator|(
name|qspace_min
operator|>>
literal|1
operator|)
argument_list|,
name|s
argument_list|)
argument_list|,
literal|"]\n"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_malloc_message
argument_list|(
literal|"Quantum-spaced sizes: ["
argument_list|,
name|umax2s
argument_list|(
name|qspace_min
argument_list|,
name|s
argument_list|)
argument_list|,
literal|".."
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|_malloc_message
argument_list|(
name|umax2s
argument_list|(
name|qspace_max
argument_list|,
name|s
argument_list|)
argument_list|,
literal|"]\n"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|_malloc_message
argument_list|(
literal|"Cacheline-spaced sizes: ["
argument_list|,
name|umax2s
argument_list|(
name|cspace_min
argument_list|,
name|s
argument_list|)
argument_list|,
literal|".."
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|_malloc_message
argument_list|(
name|umax2s
argument_list|(
name|cspace_max
argument_list|,
name|s
argument_list|)
argument_list|,
literal|"]\n"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|_malloc_message
argument_list|(
literal|"Subpage-spaced sizes: ["
argument_list|,
name|umax2s
argument_list|(
name|sspace_min
argument_list|,
name|s
argument_list|)
argument_list|,
literal|".."
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|_malloc_message
argument_list|(
name|umax2s
argument_list|(
name|sspace_max
argument_list|,
name|s
argument_list|)
argument_list|,
literal|"]\n"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_MAG
name|_malloc_message
argument_list|(
literal|"Rounds per magazine: "
argument_list|,
name|umax2s
argument_list|(
name|max_rounds
argument_list|,
name|s
argument_list|)
argument_list|,
literal|"\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_malloc_message
argument_list|(
literal|"Max dirty pages per arena: "
argument_list|,
name|umax2s
argument_list|(
name|opt_dirty_max
argument_list|,
name|s
argument_list|)
argument_list|,
literal|"\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|_malloc_message
argument_list|(
literal|"Chunk size: "
argument_list|,
name|umax2s
argument_list|(
name|chunksize
argument_list|,
name|s
argument_list|)
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|_malloc_message
argument_list|(
literal|" (2^"
argument_list|,
name|umax2s
argument_list|(
name|opt_chunk_2pow
argument_list|,
name|s
argument_list|)
argument_list|,
literal|")\n"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
block|{
name|size_t
name|allocated
decl_stmt|,
name|mapped
decl_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_BALANCE
name|uint64_t
name|nbalance
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|unsigned
name|i
decl_stmt|;
name|arena_t
modifier|*
name|arena
decl_stmt|;
comment|/* Calculate and print allocated/mapped stats. */
comment|/* arenas. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|allocated
operator|=
literal|0
init|;
name|i
operator|<
name|narenas
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|arenas
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|malloc_spin_lock
argument_list|(
operator|&
name|arenas
index|[
name|i
index|]
operator|->
name|lock
argument_list|)
expr_stmt|;
name|allocated
operator|+=
name|arenas
index|[
name|i
index|]
operator|->
name|stats
operator|.
name|allocated_small
expr_stmt|;
name|allocated
operator|+=
name|arenas
index|[
name|i
index|]
operator|->
name|stats
operator|.
name|allocated_large
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_BALANCE
name|nbalance
operator|+=
name|arenas
index|[
name|i
index|]
operator|->
name|stats
operator|.
name|nbalance
expr_stmt|;
endif|#
directive|endif
name|malloc_spin_unlock
argument_list|(
operator|&
name|arenas
index|[
name|i
index|]
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* huge/base. */
name|malloc_mutex_lock
argument_list|(
operator|&
name|huge_mtx
argument_list|)
expr_stmt|;
name|allocated
operator|+=
name|huge_allocated
expr_stmt|;
name|mapped
operator|=
name|stats_chunks
operator|.
name|curchunks
operator|*
name|chunksize
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|huge_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
name|mapped
operator|+=
name|base_mapped
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"Allocated: %zu, mapped: %zu\n"
argument_list|,
name|allocated
argument_list|,
name|mapped
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_BALANCE
name|malloc_printf
argument_list|(
literal|"Arena balance reassignments: %llu\n"
argument_list|,
name|nbalance
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Print chunk stats. */
block|{
name|chunk_stats_t
name|chunks_stats
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|huge_mtx
argument_list|)
expr_stmt|;
name|chunks_stats
operator|=
name|stats_chunks
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|huge_mtx
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"chunks: nchunks   "
literal|"highchunks    curchunks\n"
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"  %13llu%13lu%13lu\n"
argument_list|,
name|chunks_stats
operator|.
name|nchunks
argument_list|,
name|chunks_stats
operator|.
name|highchunks
argument_list|,
name|chunks_stats
operator|.
name|curchunks
argument_list|)
expr_stmt|;
block|}
comment|/* Print chunk stats. */
name|malloc_printf
argument_list|(
literal|"huge: nmalloc      ndalloc    allocated\n"
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|" %12llu %12llu %12zu\n"
argument_list|,
name|huge_nmalloc
argument_list|,
name|huge_ndalloc
argument_list|,
name|huge_allocated
argument_list|)
expr_stmt|;
comment|/* Print stats for each arena. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|narenas
condition|;
name|i
operator|++
control|)
block|{
name|arena
operator|=
name|arenas
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|arena
operator|!=
name|NULL
condition|)
block|{
name|malloc_printf
argument_list|(
literal|"\narenas[%u]:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|malloc_spin_lock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
name|stats_print
argument_list|(
name|arena
argument_list|)
expr_stmt|;
name|malloc_spin_unlock
argument_list|(
operator|&
name|arena
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* #ifdef MALLOC_STATS */
name|_malloc_message
argument_list|(
literal|"--- End malloc statistics ---\n"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|size2bin_validate
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|size
decl_stmt|,
name|binind
decl_stmt|;
name|assert
argument_list|(
name|size2bin
index|[
literal|0
index|]
operator|==
literal|0xffU
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_TINY
comment|/* Tiny. */
for|for
control|(
init|;
name|i
operator|<
operator|(
literal|1U
operator|<<
name|TINY_MIN_2POW
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|size
operator|=
name|pow2_ceil
argument_list|(
literal|1U
operator|<<
name|TINY_MIN_2POW
argument_list|)
expr_stmt|;
name|binind
operator|=
name|ffs
argument_list|(
call|(
name|int
call|)
argument_list|(
name|size
operator|>>
operator|(
name|TINY_MIN_2POW
operator|+
literal|1
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size2bin
index|[
name|i
index|]
operator|==
name|binind
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|qspace_min
condition|;
name|i
operator|++
control|)
block|{
name|size
operator|=
name|pow2_ceil
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|binind
operator|=
name|ffs
argument_list|(
call|(
name|int
call|)
argument_list|(
name|size
operator|>>
operator|(
name|TINY_MIN_2POW
operator|+
literal|1
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size2bin
index|[
name|i
index|]
operator|==
name|binind
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Quantum-spaced. */
for|for
control|(
init|;
name|i
operator|<=
name|qspace_max
condition|;
name|i
operator|++
control|)
block|{
name|size
operator|=
name|QUANTUM_CEILING
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|binind
operator|=
name|ntbins
operator|+
operator|(
name|size
operator|>>
name|QUANTUM_2POW
operator|)
operator|-
literal|1
expr_stmt|;
name|assert
argument_list|(
name|size2bin
index|[
name|i
index|]
operator|==
name|binind
argument_list|)
expr_stmt|;
block|}
comment|/* Cacheline-spaced. */
for|for
control|(
init|;
name|i
operator|<=
name|cspace_max
condition|;
name|i
operator|++
control|)
block|{
name|size
operator|=
name|CACHELINE_CEILING
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|binind
operator|=
name|ntbins
operator|+
name|nqbins
operator|+
operator|(
operator|(
name|size
operator|-
name|cspace_min
operator|)
operator|>>
name|CACHELINE_2POW
operator|)
expr_stmt|;
name|assert
argument_list|(
name|size2bin
index|[
name|i
index|]
operator|==
name|binind
argument_list|)
expr_stmt|;
block|}
comment|/* Sub-page. */
for|for
control|(
init|;
name|i
operator|<=
name|sspace_max
condition|;
name|i
operator|++
control|)
block|{
name|size
operator|=
name|SUBPAGE_CEILING
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|binind
operator|=
name|ntbins
operator|+
name|nqbins
operator|+
name|ncbins
operator|+
operator|(
operator|(
name|size
operator|-
name|sspace_min
operator|)
operator|>>
name|SUBPAGE_2POW
operator|)
expr_stmt|;
name|assert
argument_list|(
name|size2bin
index|[
name|i
index|]
operator|==
name|binind
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|bool
name|size2bin_init
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|opt_qspace_max_2pow
operator|!=
name|QSPACE_MAX_2POW_DEFAULT
operator|||
name|opt_cspace_max_2pow
operator|!=
name|CSPACE_MAX_2POW_DEFAULT
condition|)
return|return
operator|(
name|size2bin_init_hard
argument_list|()
operator|)
return|;
name|size2bin
operator|=
name|const_size2bin
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
name|assert
argument_list|(
sizeof|sizeof
argument_list|(
name|const_size2bin
argument_list|)
operator|==
name|bin_maxclass
operator|+
literal|1
argument_list|)
expr_stmt|;
name|size2bin_validate
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|size2bin_init_hard
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|size
decl_stmt|,
name|binind
decl_stmt|;
name|uint8_t
modifier|*
name|custom_size2bin
decl_stmt|;
name|assert
argument_list|(
name|opt_qspace_max_2pow
operator|!=
name|QSPACE_MAX_2POW_DEFAULT
operator|||
name|opt_cspace_max_2pow
operator|!=
name|CSPACE_MAX_2POW_DEFAULT
argument_list|)
expr_stmt|;
name|custom_size2bin
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|base_alloc
argument_list|(
name|bin_maxclass
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|custom_size2bin
operator|==
name|NULL
condition|)
return|return
operator|(
name|true
operator|)
return|;
name|custom_size2bin
index|[
literal|0
index|]
operator|=
literal|0xffU
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_TINY
comment|/* Tiny. */
for|for
control|(
init|;
name|i
operator|<
operator|(
literal|1U
operator|<<
name|TINY_MIN_2POW
operator|)
condition|;
name|i
operator|++
control|)
block|{
name|size
operator|=
name|pow2_ceil
argument_list|(
literal|1U
operator|<<
name|TINY_MIN_2POW
argument_list|)
expr_stmt|;
name|binind
operator|=
name|ffs
argument_list|(
call|(
name|int
call|)
argument_list|(
name|size
operator|>>
operator|(
name|TINY_MIN_2POW
operator|+
literal|1
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|custom_size2bin
index|[
name|i
index|]
operator|=
name|binind
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|qspace_min
condition|;
name|i
operator|++
control|)
block|{
name|size
operator|=
name|pow2_ceil
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|binind
operator|=
name|ffs
argument_list|(
call|(
name|int
call|)
argument_list|(
name|size
operator|>>
operator|(
name|TINY_MIN_2POW
operator|+
literal|1
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|custom_size2bin
index|[
name|i
index|]
operator|=
name|binind
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Quantum-spaced. */
for|for
control|(
init|;
name|i
operator|<=
name|qspace_max
condition|;
name|i
operator|++
control|)
block|{
name|size
operator|=
name|QUANTUM_CEILING
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|binind
operator|=
name|ntbins
operator|+
operator|(
name|size
operator|>>
name|QUANTUM_2POW
operator|)
operator|-
literal|1
expr_stmt|;
name|custom_size2bin
index|[
name|i
index|]
operator|=
name|binind
expr_stmt|;
block|}
comment|/* Cacheline-spaced. */
for|for
control|(
init|;
name|i
operator|<=
name|cspace_max
condition|;
name|i
operator|++
control|)
block|{
name|size
operator|=
name|CACHELINE_CEILING
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|binind
operator|=
name|ntbins
operator|+
name|nqbins
operator|+
operator|(
operator|(
name|size
operator|-
name|cspace_min
operator|)
operator|>>
name|CACHELINE_2POW
operator|)
expr_stmt|;
name|custom_size2bin
index|[
name|i
index|]
operator|=
name|binind
expr_stmt|;
block|}
comment|/* Sub-page. */
for|for
control|(
init|;
name|i
operator|<=
name|sspace_max
condition|;
name|i
operator|++
control|)
block|{
name|size
operator|=
name|SUBPAGE_CEILING
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|binind
operator|=
name|ntbins
operator|+
name|nqbins
operator|+
name|ncbins
operator|+
operator|(
operator|(
name|size
operator|-
name|sspace_min
operator|)
operator|>>
name|SUBPAGE_2POW
operator|)
expr_stmt|;
name|custom_size2bin
index|[
name|i
index|]
operator|=
name|binind
expr_stmt|;
block|}
name|size2bin
operator|=
name|custom_size2bin
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
name|size2bin_validate
argument_list|()
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * FreeBSD's pthreads implementation calls malloc(3), so the malloc  * implementation has to take pains to avoid infinite recursion during  * initialization.  */
end_comment

begin_function
specifier|static
specifier|inline
name|bool
name|malloc_init
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|malloc_initialized
operator|==
name|false
condition|)
return|return
operator|(
name|malloc_init_hard
argument_list|()
operator|)
return|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|malloc_init_hard
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|int
name|linklen
decl_stmt|;
name|char
name|buf
index|[
name|PATH_MAX
operator|+
literal|1
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|opts
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|malloc_initialized
condition|)
block|{
comment|/* 		 * Another thread initialized the allocator before this one 		 * acquired init_lock. 		 */
name|malloc_mutex_unlock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
comment|/* Get number of CPUs. */
block|{
name|int
name|mib
index|[
literal|2
index|]
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|mib
index|[
literal|0
index|]
operator|=
name|CTL_HW
expr_stmt|;
name|mib
index|[
literal|1
index|]
operator|=
name|HW_NCPU
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|ncpus
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|2
argument_list|,
operator|&
name|ncpus
argument_list|,
operator|&
name|len
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Error. */
name|ncpus
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * Increase the chunk size to the largest page size that is greater 	 * than the default chunk size and less than or equal to 4MB. 	 */
block|{
name|size_t
name|pagesizes
index|[
name|MAXPAGESIZES
index|]
decl_stmt|;
name|int
name|k
decl_stmt|,
name|nsizes
decl_stmt|;
name|nsizes
operator|=
name|getpagesizes
argument_list|(
name|pagesizes
argument_list|,
name|MAXPAGESIZES
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nsizes
condition|;
name|k
operator|++
control|)
if|if
condition|(
name|pagesizes
index|[
name|k
index|]
operator|<=
operator|(
literal|1LU
operator|<<
literal|22
operator|)
condition|)
while|while
condition|(
operator|(
literal|1LU
operator|<<
name|opt_chunk_2pow
operator|)
operator|<
name|pagesizes
index|[
name|k
index|]
condition|)
name|opt_chunk_2pow
operator|++
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
name|unsigned
name|j
decl_stmt|;
comment|/* Get runtime configuration. */
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
operator|(
name|linklen
operator|=
name|readlink
argument_list|(
literal|"/etc/malloc.conf"
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* 				 * Use the contents of the "/etc/malloc.conf" 				 * symbolic link's name. 				 */
name|buf
index|[
name|linklen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|opts
operator|=
name|buf
expr_stmt|;
block|}
else|else
block|{
comment|/* No configuration specified. */
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|opts
operator|=
name|buf
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|issetugid
argument_list|()
operator|==
literal|0
operator|&&
operator|(
name|opts
operator|=
name|getenv
argument_list|(
literal|"MALLOC_OPTIONS"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * Do nothing; opts is already initialized to 				 * the value of the MALLOC_OPTIONS environment 				 * variable. 				 */
block|}
else|else
block|{
comment|/* No configuration specified. */
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|opts
operator|=
name|buf
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|_malloc_options
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * Use options that were compiled into the 				 * program. 				 */
name|opts
operator|=
name|_malloc_options
expr_stmt|;
block|}
else|else
block|{
comment|/* No configuration specified. */
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|opts
operator|=
name|buf
expr_stmt|;
block|}
break|break;
default|default:
comment|/* NOTREACHED */
name|assert
argument_list|(
name|false
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|opts
index|[
name|j
index|]
operator|!=
literal|'\0'
condition|;
name|j
operator|++
control|)
block|{
name|unsigned
name|k
decl_stmt|,
name|nreps
decl_stmt|;
name|bool
name|nseen
decl_stmt|;
comment|/* Parse repetition count, if any. */
for|for
control|(
name|nreps
operator|=
literal|0
operator|,
name|nseen
operator|=
name|false
init|;
condition|;
name|j
operator|++
operator|,
name|nseen
operator|=
name|true
control|)
block|{
switch|switch
condition|(
name|opts
index|[
name|j
index|]
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|nreps
operator|*=
literal|10
expr_stmt|;
name|nreps
operator|+=
name|opts
index|[
name|j
index|]
operator|-
literal|'0'
expr_stmt|;
break|break;
default|default:
goto|goto
name|MALLOC_OUT
goto|;
block|}
block|}
name|MALLOC_OUT
label|:
if|if
condition|(
name|nseen
operator|==
name|false
condition|)
name|nreps
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|nreps
condition|;
name|k
operator|++
control|)
block|{
switch|switch
condition|(
name|opts
index|[
name|j
index|]
condition|)
block|{
case|case
literal|'a'
case|:
name|opt_abort
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|opt_abort
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
ifdef|#
directive|ifdef
name|MALLOC_BALANCE
name|opt_balance_threshold
operator|>>=
literal|1
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'B'
case|:
ifdef|#
directive|ifdef
name|MALLOC_BALANCE
if|if
condition|(
name|opt_balance_threshold
operator|==
literal|0
condition|)
name|opt_balance_threshold
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|opt_balance_threshold
operator|<<
literal|1
operator|)
operator|>
name|opt_balance_threshold
condition|)
name|opt_balance_threshold
operator|<<=
literal|1
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|opt_cspace_max_2pow
operator|-
literal|1
operator|>
name|opt_qspace_max_2pow
operator|&&
name|opt_cspace_max_2pow
operator|>
name|CACHELINE_2POW
condition|)
name|opt_cspace_max_2pow
operator|--
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
if|if
condition|(
name|opt_cspace_max_2pow
operator|<
name|PAGE_SHIFT
operator|-
literal|1
condition|)
name|opt_cspace_max_2pow
operator|++
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
ifdef|#
directive|ifdef
name|MALLOC_DSS
name|opt_dss
operator|=
name|false
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'D'
case|:
ifdef|#
directive|ifdef
name|MALLOC_DSS
name|opt_dss
operator|=
name|true
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'f'
case|:
name|opt_dirty_max
operator|>>=
literal|1
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
if|if
condition|(
name|opt_dirty_max
operator|==
literal|0
condition|)
name|opt_dirty_max
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|opt_dirty_max
operator|<<
literal|1
operator|)
operator|!=
literal|0
condition|)
name|opt_dirty_max
operator|<<=
literal|1
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|MALLOC_MAG
case|case
literal|'g'
case|:
name|opt_mag
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|opt_mag
operator|=
name|true
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'j'
case|:
name|opt_junk
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
name|opt_junk
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
comment|/* 					 * Chunks always require at least one 					 * header page, so chunks can never be 					 * smaller than two pages. 					 */
if|if
condition|(
name|opt_chunk_2pow
operator|>
name|PAGE_SHIFT
operator|+
literal|1
condition|)
name|opt_chunk_2pow
operator|--
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
if|if
condition|(
name|opt_chunk_2pow
operator|+
literal|1
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|<<
literal|3
operator|)
condition|)
name|opt_chunk_2pow
operator|++
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
ifdef|#
directive|ifdef
name|MALLOC_DSS
name|opt_mmap
operator|=
name|false
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'M'
case|:
ifdef|#
directive|ifdef
name|MALLOC_DSS
name|opt_mmap
operator|=
name|true
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'n'
case|:
name|opt_narenas_lshift
operator|--
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|opt_narenas_lshift
operator|++
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|opt_print_stats
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|opt_print_stats
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
if|if
condition|(
name|opt_qspace_max_2pow
operator|>
name|QUANTUM_2POW
condition|)
name|opt_qspace_max_2pow
operator|--
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
if|if
condition|(
name|opt_qspace_max_2pow
operator|+
literal|1
operator|<
name|opt_cspace_max_2pow
condition|)
name|opt_qspace_max_2pow
operator|++
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|MALLOC_MAG
case|case
literal|'R'
case|:
if|if
condition|(
name|opt_mag_size_2pow
operator|+
literal|1
operator|<
operator|(
literal|8U
operator|<<
name|SIZEOF_PTR_2POW
operator|)
condition|)
name|opt_mag_size_2pow
operator|++
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* 					 * Make sure there's always at least 					 * one round per magazine. 					 */
if|if
condition|(
operator|(
literal|1U
operator|<<
operator|(
name|opt_mag_size_2pow
operator|-
literal|1
operator|)
operator|)
operator|>=
sizeof|sizeof
argument_list|(
name|mag_t
argument_list|)
condition|)
name|opt_mag_size_2pow
operator|--
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'u'
case|:
name|opt_utrace
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|opt_utrace
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|opt_sysv
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|opt_sysv
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|opt_xmalloc
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|opt_xmalloc
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|opt_zero
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
name|opt_zero
operator|=
name|true
expr_stmt|;
break|break;
default|default:
block|{
name|char
name|cbuf
index|[
literal|2
index|]
decl_stmt|;
name|cbuf
index|[
literal|0
index|]
operator|=
name|opts
index|[
name|j
index|]
expr_stmt|;
name|cbuf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|_malloc_message
argument_list|(
name|_getprogname
argument_list|()
argument_list|,
literal|": (malloc) Unsupported character "
literal|"in malloc options: '"
argument_list|,
name|cbuf
argument_list|,
literal|"'\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|MALLOC_DSS
comment|/* Make sure that there is some method for acquiring memory. */
if|if
condition|(
name|opt_dss
operator|==
name|false
operator|&&
name|opt_mmap
operator|==
name|false
condition|)
name|opt_mmap
operator|=
name|true
expr_stmt|;
endif|#
directive|endif
comment|/* Take care to call atexit() only once. */
if|if
condition|(
name|opt_print_stats
condition|)
block|{
comment|/* Print statistics at exit. */
name|atexit
argument_list|(
name|malloc_print_stats
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MALLOC_MAG
comment|/* 	 * Calculate the actual number of rounds per magazine, taking into 	 * account header overhead. 	 */
name|max_rounds
operator|=
operator|(
literal|1LLU
operator|<<
operator|(
name|opt_mag_size_2pow
operator|-
name|SIZEOF_PTR_2POW
operator|)
operator|)
operator|-
operator|(
sizeof|sizeof
argument_list|(
name|mag_t
argument_list|)
operator|>>
name|SIZEOF_PTR_2POW
operator|)
operator|+
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* Set variables according to the value of opt_[qc]space_max_2pow. */
name|qspace_max
operator|=
operator|(
literal|1U
operator|<<
name|opt_qspace_max_2pow
operator|)
expr_stmt|;
name|cspace_min
operator|=
name|CACHELINE_CEILING
argument_list|(
name|qspace_max
argument_list|)
expr_stmt|;
if|if
condition|(
name|cspace_min
operator|==
name|qspace_max
condition|)
name|cspace_min
operator|+=
name|CACHELINE
expr_stmt|;
name|cspace_max
operator|=
operator|(
literal|1U
operator|<<
name|opt_cspace_max_2pow
operator|)
expr_stmt|;
name|sspace_min
operator|=
name|SUBPAGE_CEILING
argument_list|(
name|cspace_max
argument_list|)
expr_stmt|;
if|if
condition|(
name|sspace_min
operator|==
name|cspace_max
condition|)
name|sspace_min
operator|+=
name|SUBPAGE
expr_stmt|;
name|assert
argument_list|(
name|sspace_min
operator|<
name|PAGE_SIZE
argument_list|)
expr_stmt|;
name|sspace_max
operator|=
name|PAGE_SIZE
operator|-
name|SUBPAGE
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_TINY
name|assert
argument_list|(
name|QUANTUM_2POW
operator|>=
name|TINY_MIN_2POW
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|assert
argument_list|(
name|ntbins
operator|<=
name|QUANTUM_2POW
argument_list|)
expr_stmt|;
name|nqbins
operator|=
name|qspace_max
operator|>>
name|QUANTUM_2POW
expr_stmt|;
name|ncbins
operator|=
operator|(
operator|(
name|cspace_max
operator|-
name|cspace_min
operator|)
operator|>>
name|CACHELINE_2POW
operator|)
operator|+
literal|1
expr_stmt|;
name|nsbins
operator|=
operator|(
operator|(
name|sspace_max
operator|-
name|sspace_min
operator|)
operator|>>
name|SUBPAGE_2POW
operator|)
operator|+
literal|1
expr_stmt|;
name|nbins
operator|=
name|ntbins
operator|+
name|nqbins
operator|+
name|ncbins
operator|+
name|nsbins
expr_stmt|;
if|if
condition|(
name|size2bin_init
argument_list|()
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
comment|/* Set variables according to the value of opt_chunk_2pow. */
name|chunksize
operator|=
operator|(
literal|1LU
operator|<<
name|opt_chunk_2pow
operator|)
expr_stmt|;
name|chunksize_mask
operator|=
name|chunksize
operator|-
literal|1
expr_stmt|;
name|chunk_npages
operator|=
operator|(
name|chunksize
operator|>>
name|PAGE_SHIFT
operator|)
expr_stmt|;
block|{
name|size_t
name|header_size
decl_stmt|;
comment|/* 		 * Compute the header size such that it is large enough to 		 * contain the page map. 		 */
name|header_size
operator|=
sizeof|sizeof
argument_list|(
name|arena_chunk_t
argument_list|)
operator|+
operator|(
sizeof|sizeof
argument_list|(
name|arena_chunk_map_t
argument_list|)
operator|*
operator|(
name|chunk_npages
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|arena_chunk_header_npages
operator|=
operator|(
name|header_size
operator|>>
name|PAGE_SHIFT
operator|)
operator|+
operator|(
operator|(
name|header_size
operator|&
name|PAGE_MASK
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
name|arena_maxclass
operator|=
name|chunksize
operator|-
operator|(
name|arena_chunk_header_npages
operator|<<
name|PAGE_SHIFT
operator|)
expr_stmt|;
name|UTRACE
argument_list|(
operator|(
name|void
operator|*
operator|)
call|(
name|intptr_t
call|)
argument_list|(
operator|-
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|memset
argument_list|(
operator|&
name|stats_chunks
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|chunk_stats_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Various sanity checks that regard configuration. */
name|assert
argument_list|(
name|chunksize
operator|>=
name|PAGE_SIZE
argument_list|)
expr_stmt|;
comment|/* Initialize chunks data. */
name|malloc_mutex_init
argument_list|(
operator|&
name|huge_mtx
argument_list|)
expr_stmt|;
name|extent_tree_ad_new
argument_list|(
operator|&
name|huge
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_DSS
name|malloc_mutex_init
argument_list|(
operator|&
name|dss_mtx
argument_list|)
expr_stmt|;
name|dss_base
operator|=
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dss_prev
operator|=
name|dss_base
expr_stmt|;
name|dss_max
operator|=
name|dss_base
expr_stmt|;
name|extent_tree_szad_new
argument_list|(
operator|&
name|dss_chunks_szad
argument_list|)
expr_stmt|;
name|extent_tree_ad_new
argument_list|(
operator|&
name|dss_chunks_ad
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|huge_nmalloc
operator|=
literal|0
expr_stmt|;
name|huge_ndalloc
operator|=
literal|0
expr_stmt|;
name|huge_allocated
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Initialize base allocation data structures. */
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|base_mapped
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MALLOC_DSS
comment|/* 	 * Allocate a base chunk here, since it doesn't actually have to be 	 * chunk-aligned.  Doing this before allocating any other chunks allows 	 * the use of space that would otherwise be wasted. 	 */
if|if
condition|(
name|opt_dss
condition|)
name|base_pages_alloc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|base_nodes
operator|=
name|NULL
expr_stmt|;
name|malloc_mutex_init
argument_list|(
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ncpus
operator|>
literal|1
condition|)
block|{
comment|/* 		 * For SMP systems, create twice as many arenas as there are 		 * CPUs by default. 		 */
name|opt_narenas_lshift
operator|++
expr_stmt|;
block|}
comment|/* Determine how many arenas to use. */
name|narenas
operator|=
name|ncpus
expr_stmt|;
if|if
condition|(
name|opt_narenas_lshift
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|narenas
operator|<<
name|opt_narenas_lshift
operator|)
operator|>
name|narenas
condition|)
name|narenas
operator|<<=
name|opt_narenas_lshift
expr_stmt|;
comment|/* 		 * Make sure not to exceed the limits of what base_alloc() can 		 * handle. 		 */
if|if
condition|(
name|narenas
operator|*
sizeof|sizeof
argument_list|(
name|arena_t
operator|*
argument_list|)
operator|>
name|chunksize
condition|)
name|narenas
operator|=
name|chunksize
operator|/
sizeof|sizeof
argument_list|(
name|arena_t
operator|*
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opt_narenas_lshift
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|narenas
operator|>>
operator|-
name|opt_narenas_lshift
operator|)
operator|<
name|narenas
condition|)
name|narenas
operator|>>=
operator|-
name|opt_narenas_lshift
expr_stmt|;
comment|/* Make sure there is at least one arena. */
if|if
condition|(
name|narenas
operator|==
literal|0
condition|)
name|narenas
operator|=
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MALLOC_BALANCE
name|assert
argument_list|(
name|narenas
operator|!=
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|narenas_2pow
operator|=
literal|0
init|;
operator|(
name|narenas
operator|>>
operator|(
name|narenas_2pow
operator|+
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|;
name|narenas_2pow
operator|++
control|)
empty_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NO_TLS
if|if
condition|(
name|narenas
operator|>
literal|1
condition|)
block|{
specifier|static
specifier|const
name|unsigned
name|primes
index|[]
init|=
block|{
literal|1
block|,
literal|3
block|,
literal|5
block|,
literal|7
block|,
literal|11
block|,
literal|13
block|,
literal|17
block|,
literal|19
block|,
literal|23
block|,
literal|29
block|,
literal|31
block|,
literal|37
block|,
literal|41
block|,
literal|43
block|,
literal|47
block|,
literal|53
block|,
literal|59
block|,
literal|61
block|,
literal|67
block|,
literal|71
block|,
literal|73
block|,
literal|79
block|,
literal|83
block|,
literal|89
block|,
literal|97
block|,
literal|101
block|,
literal|103
block|,
literal|107
block|,
literal|109
block|,
literal|113
block|,
literal|127
block|,
literal|131
block|,
literal|137
block|,
literal|139
block|,
literal|149
block|,
literal|151
block|,
literal|157
block|,
literal|163
block|,
literal|167
block|,
literal|173
block|,
literal|179
block|,
literal|181
block|,
literal|191
block|,
literal|193
block|,
literal|197
block|,
literal|199
block|,
literal|211
block|,
literal|223
block|,
literal|227
block|,
literal|229
block|,
literal|233
block|,
literal|239
block|,
literal|241
block|,
literal|251
block|,
literal|257
block|,
literal|263
block|}
decl_stmt|;
name|unsigned
name|nprimes
decl_stmt|,
name|parenas
decl_stmt|;
comment|/* 		 * Pick a prime number of hash arenas that is more than narenas 		 * so that direct hashing of pthread_self() pointers tends to 		 * spread allocations evenly among the arenas. 		 */
name|assert
argument_list|(
operator|(
name|narenas
operator|&
literal|1
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* narenas must be even. */
name|nprimes
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|primes
argument_list|)
operator|>>
name|SIZEOF_INT_2POW
operator|)
expr_stmt|;
name|parenas
operator|=
name|primes
index|[
name|nprimes
operator|-
literal|1
index|]
expr_stmt|;
comment|/* In case not enough primes. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nprimes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|primes
index|[
name|i
index|]
operator|>
name|narenas
condition|)
block|{
name|parenas
operator|=
name|primes
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
name|narenas
operator|=
name|parenas
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_TLS
ifndef|#
directive|ifndef
name|MALLOC_BALANCE
name|next_arena
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* Allocate and initialize arenas. */
name|arenas
operator|=
operator|(
name|arena_t
operator|*
operator|*
operator|)
name|base_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arena_t
operator|*
argument_list|)
operator|*
name|narenas
argument_list|)
expr_stmt|;
if|if
condition|(
name|arenas
operator|==
name|NULL
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
comment|/* 	 * Zero the array.  In practice, this should always be pre-zeroed, 	 * since it was just mmap()ed, but let's be sure. 	 */
name|memset
argument_list|(
name|arenas
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|arena_t
operator|*
argument_list|)
operator|*
name|narenas
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize one arena here.  The rest are lazily created in 	 * choose_arena_hard(). 	 */
name|arenas_extend
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arenas
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
ifndef|#
directive|ifndef
name|NO_TLS
comment|/* 	 * Assign the initial arena to the initial thread, in order to avoid 	 * spurious creation of an extra arena if the application switches to 	 * threaded mode. 	 */
name|arenas_map
operator|=
name|arenas
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Seed here for the initial thread, since choose_arena_hard() is only 	 * called for other threads.  The seed value doesn't really matter. 	 */
ifdef|#
directive|ifdef
name|MALLOC_BALANCE
name|SPRN
argument_list|(
name|balance
argument_list|,
literal|42
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|malloc_spin_init
argument_list|(
operator|&
name|arenas_lock
argument_list|)
expr_stmt|;
name|malloc_initialized
operator|=
name|true
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|init_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * End general internal functions.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin malloc(3)-compatible functions.  */
end_comment

begin_function
name|void
modifier|*
name|malloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|malloc_init
argument_list|()
condition|)
block|{
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|opt_sysv
operator|==
name|false
condition|)
name|size
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
block|}
name|ret
operator|=
name|imalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|RETURN
label|:
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|opt_xmalloc
condition|)
block|{
name|_malloc_message
argument_list|(
name|_getprogname
argument_list|()
argument_list|,
literal|": (malloc) Error in malloc(): out of memory\n"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|errno
operator|=
name|ENOMEM
expr_stmt|;
block|}
name|UTRACE
argument_list|(
literal|0
argument_list|,
name|size
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|posix_memalign
parameter_list|(
name|void
modifier|*
modifier|*
name|memptr
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|void
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|malloc_init
argument_list|()
condition|)
name|result
operator|=
name|NULL
expr_stmt|;
else|else
block|{
comment|/* Make sure that alignment is a large enough power of 2. */
if|if
condition|(
operator|(
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|&
name|alignment
operator|)
operator|!=
literal|0
operator|||
name|alignment
operator|<
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
condition|)
block|{
if|if
condition|(
name|opt_xmalloc
condition|)
block|{
name|_malloc_message
argument_list|(
name|_getprogname
argument_list|()
argument_list|,
literal|": (malloc) Error in posix_memalign(): "
literal|"invalid alignment\n"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|result
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|opt_sysv
operator|==
name|false
condition|)
name|size
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|result
operator|=
name|NULL
expr_stmt|;
operator|*
name|memptr
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
block|}
name|result
operator|=
name|ipalloc
argument_list|(
name|alignment
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|opt_xmalloc
condition|)
block|{
name|_malloc_message
argument_list|(
name|_getprogname
argument_list|()
argument_list|,
literal|": (malloc) Error in posix_memalign(): out of memory\n"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
operator|*
name|memptr
operator|=
name|result
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|RETURN
label|:
name|UTRACE
argument_list|(
literal|0
argument_list|,
name|size
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|calloc
parameter_list|(
name|size_t
name|num
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|size_t
name|num_size
decl_stmt|;
if|if
condition|(
name|malloc_init
argument_list|()
condition|)
block|{
name|num_size
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
name|num_size
operator|=
name|num
operator|*
name|size
expr_stmt|;
if|if
condition|(
name|num_size
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|opt_sysv
operator|==
name|false
operator|)
operator|&&
operator|(
operator|(
name|num
operator|==
literal|0
operator|)
operator|||
operator|(
name|size
operator|==
literal|0
operator|)
operator|)
condition|)
name|num_size
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
comment|/* 	 * Try to avoid division here.  We know that it isn't possible to 	 * overflow during multiplication if neither operand uses any of the 	 * most significant half of the bits in a size_t. 	 */
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|num
operator||
name|size
operator|)
operator|&
operator|(
name|SIZE_T_MAX
operator|<<
operator|(
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
operator|<<
literal|2
operator|)
operator|)
operator|)
operator|&&
operator|(
name|num_size
operator|/
name|size
operator|!=
name|num
operator|)
condition|)
block|{
comment|/* size_t overflow. */
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
name|ret
operator|=
name|icalloc
argument_list|(
name|num_size
argument_list|)
expr_stmt|;
name|RETURN
label|:
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|opt_xmalloc
condition|)
block|{
name|_malloc_message
argument_list|(
name|_getprogname
argument_list|()
argument_list|,
literal|": (malloc) Error in calloc(): out of memory\n"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|errno
operator|=
name|ENOMEM
expr_stmt|;
block|}
name|UTRACE
argument_list|(
literal|0
argument_list|,
name|num_size
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|realloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|opt_sysv
operator|==
name|false
condition|)
name|size
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
name|idalloc
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
block|}
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|malloc_initialized
argument_list|)
expr_stmt|;
name|ret
operator|=
name|iralloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|opt_xmalloc
condition|)
block|{
name|_malloc_message
argument_list|(
name|_getprogname
argument_list|()
argument_list|,
literal|": (malloc) Error in realloc(): out of "
literal|"memory\n"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|errno
operator|=
name|ENOMEM
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|malloc_init
argument_list|()
condition|)
name|ret
operator|=
name|NULL
expr_stmt|;
else|else
name|ret
operator|=
name|imalloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|opt_xmalloc
condition|)
block|{
name|_malloc_message
argument_list|(
name|_getprogname
argument_list|()
argument_list|,
literal|": (malloc) Error in realloc(): out of "
literal|"memory\n"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|errno
operator|=
name|ENOMEM
expr_stmt|;
block|}
block|}
name|RETURN
label|:
name|UTRACE
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|free
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|UTRACE
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|malloc_initialized
argument_list|)
expr_stmt|;
name|idalloc
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * End malloc(3)-compatible functions.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin non-standard functions.  */
end_comment

begin_function
name|size_t
name|malloc_usable_size
parameter_list|(
specifier|const
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|isalloc
argument_list|(
name|ptr
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * End non-standard functions.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin library-private functions.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin thread cache.  */
end_comment

begin_comment
comment|/*  * We provide an unpublished interface in order to receive notifications from  * the pthreads library whenever a thread exits.  This allows us to clean up  * thread caches.  */
end_comment

begin_function
name|void
name|_malloc_thread_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|MALLOC_MAG
if|if
condition|(
name|mag_rack
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|mag_rack
operator|!=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|mag_rack_destroy
argument_list|(
name|mag_rack
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
name|mag_rack
operator|=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * The following functions are used by threading libraries for protection of  * malloc during fork().  These functions are only called if the program is  * running in threaded mode, so there is no need to check whether the program  * is threaded here.  */
end_comment

begin_function
name|void
name|_malloc_prefork
parameter_list|(
name|void
parameter_list|)
block|{
name|bool
name|again
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|j
decl_stmt|;
name|arena_t
modifier|*
name|larenas
index|[
name|narenas
index|]
decl_stmt|,
modifier|*
name|tarenas
index|[
name|narenas
index|]
decl_stmt|;
comment|/* Acquire all mutexes in a safe order. */
comment|/* 	 * arenas_lock must be acquired after all of the arena mutexes, in 	 * order to avoid potential deadlock with arena_lock_balance[_hard](). 	 * Since arenas_lock protects the arenas array, the following code has 	 * to race with arenas_extend() callers until it succeeds in locking 	 * all arenas before locking arenas_lock. 	 */
name|memset
argument_list|(
name|larenas
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|arena_t
operator|*
argument_list|)
operator|*
name|narenas
argument_list|)
expr_stmt|;
do|do
block|{
name|again
operator|=
name|false
expr_stmt|;
name|malloc_spin_lock
argument_list|(
operator|&
name|arenas_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|narenas
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|arenas
index|[
name|i
index|]
operator|!=
name|larenas
index|[
name|i
index|]
condition|)
block|{
name|memcpy
argument_list|(
name|tarenas
argument_list|,
name|arenas
argument_list|,
sizeof|sizeof
argument_list|(
name|arena_t
operator|*
argument_list|)
operator|*
name|narenas
argument_list|)
expr_stmt|;
name|malloc_spin_unlock
argument_list|(
operator|&
name|arenas_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|narenas
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|larenas
index|[
name|j
index|]
operator|!=
name|tarenas
index|[
name|j
index|]
condition|)
block|{
name|larenas
index|[
name|j
index|]
operator|=
name|tarenas
index|[
name|j
index|]
expr_stmt|;
name|malloc_spin_lock
argument_list|(
operator|&
name|larenas
index|[
name|j
index|]
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
name|again
operator|=
name|true
expr_stmt|;
break|break;
block|}
block|}
block|}
do|while
condition|(
name|again
condition|)
do|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|huge_mtx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_DSS
name|malloc_mutex_lock
argument_list|(
operator|&
name|dss_mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|_malloc_postfork
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|arena_t
modifier|*
name|larenas
index|[
name|narenas
index|]
decl_stmt|;
comment|/* Release all mutexes, now that fork() has completed. */
ifdef|#
directive|ifdef
name|MALLOC_DSS
name|malloc_mutex_unlock
argument_list|(
operator|&
name|dss_mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|malloc_mutex_unlock
argument_list|(
operator|&
name|huge_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|larenas
argument_list|,
name|arenas
argument_list|,
sizeof|sizeof
argument_list|(
name|arena_t
operator|*
argument_list|)
operator|*
name|narenas
argument_list|)
expr_stmt|;
name|malloc_spin_unlock
argument_list|(
operator|&
name|arenas_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|narenas
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|larenas
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|malloc_spin_unlock
argument_list|(
operator|&
name|larenas
index|[
name|i
index|]
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * End library-private functions.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

end_unit

