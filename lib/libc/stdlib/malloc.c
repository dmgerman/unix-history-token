begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (C) 2006 Jason Evans<jasone@FreeBSD.org>.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice(s), this list of conditions and the following disclaimer as  *    the first lines of this file unmodified other than the possible  *    addition of one or more copyright notices.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice(s), this list of conditions and the following disclaimer in  *    the documentation and/or other materials provided with the  *    distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDER(S) ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDER(S) BE  * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR  * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,  * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE  * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,  * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  *******************************************************************************  *  * Following is a brief list of features that distinguish this malloc  * implementation:  *  *   + Multiple arenas are used if there are multiple CPUs, which reduces lock  *     contention and cache sloshing.  *  *   + Cache line sharing between arenas is avoided for internal data  *     structures.  *  *   + Memory is managed in chunks, rather than as individual pages.  *  *   + Allocations are region-based; internal region size is a discrete  *     multiple of a quantum that is appropriate for alignment constraints.  *     This applies to allocations that are up to half the chunk size.  *  *   + Coalescence of regions is delayed in order to reduce overhead and  *     fragmentation.  *  *   + realloc() always moves data, in order to reduce fragmentation.  *  *   + Red-black trees are used to sort large regions.  *  *   + Data structures for huge allocations are stored separately from  *     allocations, which reduces thrashing during low memory conditions.  *  *******************************************************************************  */
end_comment

begin_comment
comment|/*  *******************************************************************************  *  * Ring macros.  *  *******************************************************************************  */
end_comment

begin_comment
comment|/* Ring definitions. */
end_comment

begin_define
define|#
directive|define
name|qr
parameter_list|(
name|a_type
parameter_list|)
value|struct {						\ 	a_type *qre_next;						\ 	a_type *qre_prev;						\ }
end_define

begin_define
define|#
directive|define
name|qr_initializer
value|{NULL, NULL}
end_define

begin_comment
comment|/* Ring functions. */
end_comment

begin_define
define|#
directive|define
name|qr_new
parameter_list|(
name|a_qr
parameter_list|,
name|a_field
parameter_list|)
value|do {					\ 	(a_qr)->a_field.qre_next = (a_qr);				\ 	(a_qr)->a_field.qre_prev = (a_qr);				\ } while (0)
end_define

begin_define
define|#
directive|define
name|qr_next
parameter_list|(
name|a_qr
parameter_list|,
name|a_field
parameter_list|)
value|((a_qr)->a_field.qre_next)
end_define

begin_define
define|#
directive|define
name|qr_prev
parameter_list|(
name|a_qr
parameter_list|,
name|a_field
parameter_list|)
value|((a_qr)->a_field.qre_prev)
end_define

begin_define
define|#
directive|define
name|qr_before_insert
parameter_list|(
name|a_qrelm
parameter_list|,
name|a_qr
parameter_list|,
name|a_field
parameter_list|)
value|do {			\ 	(a_qr)->a_field.qre_prev = (a_qrelm)->a_field.qre_prev;		\ 	(a_qr)->a_field.qre_next = (a_qrelm);				\ 	(a_qr)->a_field.qre_prev->a_field.qre_next = (a_qr);		\ 	(a_qrelm)->a_field.qre_prev = (a_qr);				\ } while (0)
end_define

begin_define
define|#
directive|define
name|qr_after_insert
parameter_list|(
name|a_qrelm
parameter_list|,
name|a_qr
parameter_list|,
name|a_field
parameter_list|)
value|do {			\ 	(a_qr)->a_field.qre_next = (a_qrelm)->a_field.qre_next;		\ 	(a_qr)->a_field.qre_prev = (a_qrelm);				\ 	(a_qr)->a_field.qre_next->a_field.qre_prev = (a_qr);		\ 	(a_qrelm)->a_field.qre_next = (a_qr);				\ } while (0)
end_define

begin_define
define|#
directive|define
name|qr_meld
parameter_list|(
name|a_qr_a
parameter_list|,
name|a_qr_b
parameter_list|,
name|a_type
parameter_list|,
name|a_field
parameter_list|)
value|do {			\ 	a_type *t;							\ 	(a_qr_a)->a_field.qre_prev->a_field.qre_next = (a_qr_b);	\ 	(a_qr_b)->a_field.qre_prev->a_field.qre_next = (a_qr_a);	\ 	t = (a_qr_a)->a_field.qre_prev;					\ 	(a_qr_a)->a_field.qre_prev = (a_qr_b)->a_field.qre_prev;	\ 	(a_qr_b)->a_field.qre_prev = t;					\ } while (0)
end_define

begin_comment
comment|/* qr_meld() and qr_split() are functionally equivalent, so there's no need to  * have two copies of the code. */
end_comment

begin_define
define|#
directive|define
name|qr_split
parameter_list|(
name|a_qr_a
parameter_list|,
name|a_qr_b
parameter_list|,
name|a_type
parameter_list|,
name|a_field
parameter_list|)
define|\
value|qr_meld((a_qr_a), (a_qr_b), a_type, a_field)
end_define

begin_define
define|#
directive|define
name|qr_remove
parameter_list|(
name|a_qr
parameter_list|,
name|a_field
parameter_list|)
value|do {					\ 	(a_qr)->a_field.qre_prev->a_field.qre_next			\ 	    = (a_qr)->a_field.qre_next;					\ 	(a_qr)->a_field.qre_next->a_field.qre_prev			\ 	    = (a_qr)->a_field.qre_prev;					\ 	(a_qr)->a_field.qre_next = (a_qr);				\ 	(a_qr)->a_field.qre_prev = (a_qr);				\ } while (0)
end_define

begin_define
define|#
directive|define
name|qr_foreach
parameter_list|(
name|var
parameter_list|,
name|a_qr
parameter_list|,
name|a_field
parameter_list|)
define|\
value|for ((var) = (a_qr);						\ 	    (var) != NULL;						\ 	    (var) = (((var)->a_field.qre_next != (a_qr))		\ 	    ? (var)->a_field.qre_next : NULL))
end_define

begin_define
define|#
directive|define
name|qr_reverse_foreach
parameter_list|(
name|var
parameter_list|,
name|a_qr
parameter_list|,
name|a_field
parameter_list|)
define|\
value|for ((var) = ((a_qr) != NULL) ? qr_prev(a_qr, a_field) : NULL;	\ 	    (var) != NULL;						\ 	    (var) = (((var) != (a_qr))					\ 	    ? (var)->a_field.qre_prev : NULL))
end_define

begin_comment
comment|/******************************************************************************/
end_comment

begin_define
define|#
directive|define
name|MALLOC_DEBUG
end_define

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|"libc_private.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|_LOCK_DEBUG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"spinlock.h"
end_include

begin_include
include|#
directive|include
file|"namespace.h"
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stddef.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/tree.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/ktrace.h>
end_include

begin_comment
comment|/* Must come after several other sys/ includes. */
end_comment

begin_include
include|#
directive|include
file|<machine/atomic.h>
end_include

begin_include
include|#
directive|include
file|<machine/cpufunc.h>
end_include

begin_include
include|#
directive|include
file|<machine/vmparam.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|<sched.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"un-namespace.h"
end_include

begin_comment
comment|/*  * Calculate statistics that can be used to get an idea of how well caching is  * working.  */
end_comment

begin_define
define|#
directive|define
name|MALLOC_STATS
end_define

begin_define
define|#
directive|define
name|MALLOC_STATS_ARENAS
end_define

begin_comment
comment|/*  * Include redzones before/after every region, and check for buffer overflows.  */
end_comment

begin_define
define|#
directive|define
name|MALLOC_REDZONES
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_REDZONES
end_ifdef

begin_define
define|#
directive|define
name|MALLOC_RED_2POW
value|4
end_define

begin_define
define|#
directive|define
name|MALLOC_RED
value|((size_t)(1<< MALLOC_RED_2POW))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MALLOC_DEBUG
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|NDEBUG
end_ifndef

begin_define
define|#
directive|define
name|NDEBUG
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
end_ifdef

begin_comment
comment|/* Disable inlining to make debugging easier. */
end_comment

begin_define
define|#
directive|define
name|__inline
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Size of stack-allocated buffer passed to strerror_r(). */
end_comment

begin_define
define|#
directive|define
name|STRERROR_BUF
value|64
end_define

begin_comment
comment|/* Number of quantum-spaced bins to store free regions in. */
end_comment

begin_define
define|#
directive|define
name|NBINS
value|128
end_define

begin_comment
comment|/* Minimum alignment of allocations is 2^QUANTUM_2POW_MIN bytes. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__i386__
end_ifdef

begin_define
define|#
directive|define
name|QUANTUM_2POW_MIN
value|4
end_define

begin_define
define|#
directive|define
name|SIZEOF_PTR
value|4
end_define

begin_define
define|#
directive|define
name|USE_BRK
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__ia64__
end_ifdef

begin_define
define|#
directive|define
name|QUANTUM_2POW_MIN
value|4
end_define

begin_define
define|#
directive|define
name|SIZEOF_PTR
value|8
end_define

begin_define
define|#
directive|define
name|NO_TLS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__alpha__
end_ifdef

begin_define
define|#
directive|define
name|QUANTUM_2POW_MIN
value|4
end_define

begin_define
define|#
directive|define
name|SIZEOF_PTR
value|8
end_define

begin_define
define|#
directive|define
name|NO_TLS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__sparc64__
end_ifdef

begin_define
define|#
directive|define
name|QUANTUM_2POW_MIN
value|4
end_define

begin_define
define|#
directive|define
name|SIZEOF_PTR
value|8
end_define

begin_define
define|#
directive|define
name|NO_TLS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__amd64__
end_ifdef

begin_define
define|#
directive|define
name|QUANTUM_2POW_MIN
value|4
end_define

begin_define
define|#
directive|define
name|SIZEOF_PTR
value|8
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__arm__
end_ifdef

begin_define
define|#
directive|define
name|QUANTUM_2POW_MIN
value|3
end_define

begin_define
define|#
directive|define
name|SIZEOF_PTR
value|4
end_define

begin_define
define|#
directive|define
name|USE_BRK
end_define

begin_define
define|#
directive|define
name|NO_TLS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__powerpc__
end_ifdef

begin_define
define|#
directive|define
name|QUANTUM_2POW_MIN
value|4
end_define

begin_define
define|#
directive|define
name|SIZEOF_PTR
value|4
end_define

begin_define
define|#
directive|define
name|USE_BRK
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We can't use TLS in non-PIC programs, since TLS relies on loader magic. */
end_comment

begin_if
if|#
directive|if
operator|(
operator|!
name|defined
argument_list|(
name|PIC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NO_TLS
argument_list|)
operator|)
end_if

begin_define
define|#
directive|define
name|NO_TLS
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Size and alignment of memory chunks that are allocated by the OS's virtual  * memory system.  *  * chunksize limits:  *  *   pagesize<= chunk_size<= 2^29  */
end_comment

begin_define
define|#
directive|define
name|CHUNK_2POW_DEFAULT
value|24
end_define

begin_define
define|#
directive|define
name|CHUNK_2POW_MAX
value|29
end_define

begin_comment
comment|/*  * Maximum size of L1 cache line.  This is used to avoid cache line aliasing,  * so over-estimates are okay (up to a point), but under-estimates will  * negatively affect performance.  */
end_comment

begin_define
define|#
directive|define
name|CACHELINE_2POW
value|6
end_define

begin_define
define|#
directive|define
name|CACHELINE
value|((size_t)(1<< CACHELINE_2POW))
end_define

begin_comment
comment|/* Default number of regions to delay coalescence for. */
end_comment

begin_define
define|#
directive|define
name|NDELAY
value|256
end_define

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Mutexes based on spinlocks.  We can't use normal pthread mutexes, because  * they require malloc()ed memory.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|spinlock_t
name|lock
decl_stmt|;
block|}
name|malloc_mutex_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|bool
name|malloc_initialized
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Statistics data structures.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_STATS
end_ifdef

begin_typedef
typedef|typedef
name|struct
name|malloc_bin_stats_s
name|malloc_bin_stats_t
typedef|;
end_typedef

begin_struct
struct|struct
name|malloc_bin_stats_s
block|{
comment|/* 	 * Number of allocation requests that corresponded to the size of this 	 * bin. 	 */
name|uint64_t
name|nrequests
decl_stmt|;
comment|/* 	 * Number of best-fit allocations that were successfully serviced by 	 * this bin. 	 */
name|uint64_t
name|nfit
decl_stmt|;
comment|/* High-water marks for this bin. */
name|unsigned
name|long
name|highcached
decl_stmt|;
comment|/* 	 * Current number of regions in this bin.  This number isn't needed 	 * during normal operation, so is maintained here in order to allow 	 * calculating the high water mark. 	 */
name|unsigned
name|nregions
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|arena_stats_s
name|arena_stats_t
typedef|;
end_typedef

begin_struct
struct|struct
name|arena_stats_s
block|{
comment|/* Number of times each function was called. */
name|uint64_t
name|nmalloc
decl_stmt|;
name|uint64_t
name|npalloc
decl_stmt|;
name|uint64_t
name|ncalloc
decl_stmt|;
name|uint64_t
name|ndalloc
decl_stmt|;
name|uint64_t
name|nralloc
decl_stmt|;
comment|/* Number of region splits. */
name|uint64_t
name|nsplit
decl_stmt|;
comment|/* Number of region coalescences. */
name|uint64_t
name|ncoalesce
decl_stmt|;
comment|/* Bin statistics. */
name|malloc_bin_stats_t
name|bins
index|[
name|NBINS
index|]
decl_stmt|;
comment|/* Split statistics. */
struct|struct
block|{
comment|/* 		 * Number of times a region is requested from the "split" field 		 * of the arena. 		 */
name|uint64_t
name|nrequests
decl_stmt|;
comment|/* 		 * Number of times the "split" field of the arena successfully 		 * services requests. 		 */
name|uint64_t
name|nserviced
decl_stmt|;
block|}
name|split
struct|;
comment|/* Frag statistics. */
struct|struct
block|{
comment|/* 		 * Number of times a region is cached in the "frag" field of 		 * the arena. 		 */
name|uint64_t
name|ncached
decl_stmt|;
comment|/* 		 * Number of times a region is requested from the "frag" field 		 * of the arena. 		 */
name|uint64_t
name|nrequests
decl_stmt|;
comment|/* 		 * Number of times the "frag" field of the arena successfully 		 * services requests. 		 */
name|uint64_t
name|nserviced
decl_stmt|;
block|}
name|frag
struct|;
comment|/* large and large_regions statistics. */
struct|struct
block|{
comment|/* 		 * Number of allocation requests that were too large for a bin, 		 * but not large enough for a hugh allocation. 		 */
name|uint64_t
name|nrequests
decl_stmt|;
comment|/* 		 * Number of best-fit allocations that were successfully 		 * serviced by large_regions. 		 */
name|uint64_t
name|nfit
decl_stmt|;
comment|/* 		 * Number of allocation requests that were successfully serviced 		 * large_regions, but that a bin could have serviced. 		 */
name|uint64_t
name|noverfit
decl_stmt|;
comment|/* 		 * High-water mark for large_regions (number of nodes in tree). 		 */
name|unsigned
name|long
name|highcached
decl_stmt|;
comment|/* 		 * Used only to store the current number of nodes, since this 		 * number isn't maintained anywhere else. 		 */
name|unsigned
name|long
name|curcached
decl_stmt|;
block|}
name|large
struct|;
comment|/* Huge allocation statistics. */
struct|struct
block|{
comment|/* Number of huge allocation requests. */
name|uint64_t
name|nrequests
decl_stmt|;
block|}
name|huge
struct|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|chunk_stats_s
name|chunk_stats_t
typedef|;
end_typedef

begin_struct
struct|struct
name|chunk_stats_s
block|{
comment|/* Number of chunks that were allocated. */
name|uint64_t
name|nchunks
decl_stmt|;
comment|/* High-water mark for number of chunks allocated. */
name|unsigned
name|long
name|highchunks
decl_stmt|;
comment|/* 	 * Current number of chunks allocated.  This value isn't maintained for 	 * any other purpose, so keep track of it in order to be able to set 	 * highchunks. 	 */
name|unsigned
name|long
name|curchunks
decl_stmt|;
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* #ifdef MALLOC_STATS */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Chunk data structures.  */
end_comment

begin_comment
comment|/* Needed by chunk data structures. */
end_comment

begin_typedef
typedef|typedef
name|struct
name|arena_s
name|arena_t
typedef|;
end_typedef

begin_comment
comment|/* Tree of chunks. */
end_comment

begin_typedef
typedef|typedef
name|struct
name|chunk_node_s
name|chunk_node_t
typedef|;
end_typedef

begin_struct
struct|struct
name|chunk_node_s
block|{
comment|/* 	 * For an active chunk that is currently carved into regions by an 	 * arena allocator, this points to the arena that owns the chunk.  We 	 * set this pointer even for huge allocations, so that it is possible 	 * to tell whether a huge allocation was done on behalf of a user 	 * allocation request, or on behalf of an internal allocation request. 	 */
name|arena_t
modifier|*
name|arena
decl_stmt|;
comment|/* Linkage for the chunk tree. */
name|RB_ENTRY
argument_list|(
argument|chunk_node_s
argument_list|)
name|link
expr_stmt|;
comment|/* 	 * Pointer to the chunk that this tree node is responsible for.  In some 	 * (but certainly not all) cases, this data structure is placed at the 	 * beginning of the corresponding chunk, so this field may point to this 	 * node. 	 */
name|void
modifier|*
name|chunk
decl_stmt|;
comment|/* Total chunk size. */
name|size_t
name|size
decl_stmt|;
comment|/* Number of trailing bytes that are not used. */
name|size_t
name|extra
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|chunk_tree_s
name|chunk_tree_t
typedef|;
end_typedef

begin_expr_stmt
name|RB_HEAD
argument_list|(
name|chunk_tree_s
argument_list|,
name|chunk_node_s
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Region data structures.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|region_s
name|region_t
typedef|;
end_typedef

begin_comment
comment|/*  * Tree of region headers, used for free regions that don't fit in the arena  * bins.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|region_node_s
name|region_node_t
typedef|;
end_typedef

begin_struct
struct|struct
name|region_node_s
block|{
name|RB_ENTRY
argument_list|(
argument|region_node_s
argument_list|)
name|link
expr_stmt|;
name|region_t
modifier|*
name|reg
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|region_tree_s
name|region_tree_t
typedef|;
end_typedef

begin_expr_stmt
name|RB_HEAD
argument_list|(
name|region_tree_s
argument_list|,
name|region_node_s
argument_list|)
expr_stmt|;
end_expr_stmt

begin_typedef
typedef|typedef
name|struct
name|region_prev_s
name|region_prev_t
typedef|;
end_typedef

begin_struct
struct|struct
name|region_prev_s
block|{
name|uint32_t
name|size
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|NEXT_SIZE_MASK
value|0x1fffffffU
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
ifdef|#
directive|ifdef
name|MALLOC_REDZONES
name|char
name|prev_red
index|[
name|MALLOC_RED
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* 	 * Typical bit pattern for bits: 	 * 	 *   pncsssss ssssssss ssssssss ssssssss 	 * 	 *   p : Previous free? 	 *   n : Next free? 	 *   c : Part of a range of contiguous allocations? 	 *   s : Next size (number of quanta). 	 * 	 * It's tempting to use structure bitfields here, but the compiler has 	 * to make assumptions that make the code slower than direct bit 	 * manipulations, and these fields are manipulated a lot. 	 */
name|uint32_t
name|bits
decl_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_REDZONES
name|size_t
name|next_exact_size
decl_stmt|;
name|char
name|next_red
index|[
name|MALLOC_RED
index|]
decl_stmt|;
endif|#
directive|endif
block|}
name|region_sep_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
name|struct
name|region_next_small_sizer_s
name|region_next_small_sizer_t
typedef|;
end_typedef

begin_struct
struct|struct
name|region_next_small_sizer_s
block|{
name|qr
argument_list|(
argument|region_t
argument_list|)
name|link
expr_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|region_next_small_s
name|region_next_small_t
typedef|;
end_typedef

begin_struct
struct|struct
name|region_next_small_s
block|{
name|qr
argument_list|(
argument|region_t
argument_list|)
name|link
expr_stmt|;
comment|/* Only accessed for delayed regions& footer invalid. */
name|uint32_t
name|slot
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|region_next_large_s
name|region_next_large_t
typedef|;
end_typedef

begin_struct
struct|struct
name|region_next_large_s
block|{
name|region_node_t
name|node
decl_stmt|;
comment|/* Use for LRU vs MRU tree ordering. */
name|bool
name|lru
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|region_next_s
name|region_next_t
typedef|;
end_typedef

begin_struct
struct|struct
name|region_next_s
block|{
union|union
block|{
name|region_next_small_t
name|s
decl_stmt|;
name|region_next_large_t
name|l
decl_stmt|;
block|}
name|u
union|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Region separator, including prev/next fields that are only accessible when  * the neighboring regions are free.  */
end_comment

begin_struct
struct|struct
name|region_s
block|{
comment|/* This field must only be accessed if sep.prev_free is true. */
name|region_prev_t
name|prev
decl_stmt|;
comment|/* Actual region separator that is always present between regions. */
name|region_sep_t
name|sep
decl_stmt|;
comment|/* 	 * These fields must only be accessed if sep.next_free or 	 * sep.next_contig is true.  	 */
name|region_next_t
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Small variant of region separator, only used for size calculations. */
end_comment

begin_typedef
typedef|typedef
name|struct
name|region_small_sizer_s
name|region_small_sizer_t
typedef|;
end_typedef

begin_struct
struct|struct
name|region_small_sizer_s
block|{
name|region_prev_t
name|prev
decl_stmt|;
name|region_sep_t
name|sep
decl_stmt|;
name|region_next_small_sizer_t
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Arena data structures.  */
end_comment

begin_typedef
typedef|typedef
name|struct
name|arena_bin_s
name|arena_bin_t
typedef|;
end_typedef

begin_struct
struct|struct
name|arena_bin_s
block|{
comment|/* 	 * Link into ring before the oldest free region and just after the 	 * newest free region. 	 */
name|region_t
name|regions
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|arena_s
block|{
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
name|uint32_t
name|magic
decl_stmt|;
define|#
directive|define
name|ARENA_MAGIC
value|0x947d3d24
endif|#
directive|endif
comment|/* All operations on this arena require that mtx be locked. */
name|malloc_mutex_t
name|mtx
decl_stmt|;
comment|/* 	 * bins is used to store rings of free regions of the following sizes, 	 * assuming a 16-byte quantum (sizes include region separators): 	 * 	 *   bins[i] | size | 	 *   --------+------+ 	 *        0  |   32 | 	 *        1  |   48 | 	 *        2  |   64 | 	 *           :      : 	 *           :      : 	 *   --------+------+ 	 */
name|arena_bin_t
name|bins
index|[
name|NBINS
index|]
decl_stmt|;
comment|/* 	 * A bitmask that corresponds to which bins have elements in them. 	 * This is used when searching for the first bin that contains a free 	 * region that is large enough to service an allocation request. 	 */
define|#
directive|define
name|BINMASK_NELMS
value|(NBINS / (sizeof(int)<< 3))
name|int
name|bins_mask
index|[
name|BINMASK_NELMS
index|]
decl_stmt|;
comment|/* 	 * Tree of free regions of the size range [bin_maxsize..~chunk).  These 	 * are sorted primarily by size, and secondarily by LRU. 	 */
name|region_tree_t
name|large_regions
decl_stmt|;
comment|/* 	 * If not NULL, a region that is not stored in bins or large_regions. 	 * If large enough, this region is used instead of any region stored in 	 * bins or large_regions, in order to reduce the number of insert/remove 	 * operations, and in order to increase locality of allocation in 	 * common cases. 	 */
name|region_t
modifier|*
name|split
decl_stmt|;
comment|/* 	 * If not NULL, a region that is not stored in bins or large_regions. 	 * If large enough, this region is preferentially used for small 	 * allocations over any region in large_regions, split, or over-fit 	 * small bins. 	 */
name|region_t
modifier|*
name|frag
decl_stmt|;
comment|/* Tree of chunks that this arena currenly owns. */
name|chunk_tree_t
name|chunks
decl_stmt|;
name|unsigned
name|nchunks
decl_stmt|;
comment|/* 	 * FIFO ring of free regions for which coalescence is delayed.  A slot 	 * that contains NULL is considered empty.  opt_ndelay stores how many 	 * elements there are in the FIFO. 	 */
name|region_t
modifier|*
modifier|*
name|delayed
decl_stmt|;
name|uint32_t
name|next_delayed
decl_stmt|;
comment|/* Next slot in delayed to use. */
ifdef|#
directive|ifdef
name|MALLOC_STATS
comment|/* Total byte count of allocated memory, not including overhead. */
name|size_t
name|allocated
decl_stmt|;
name|arena_stats_t
name|stats
decl_stmt|;
endif|#
directive|endif
block|}
struct|;
end_struct

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Data.  */
end_comment

begin_comment
comment|/* Used as a special "nil" return value for malloc(0). */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nil
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of CPUs. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|ncpus
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* VM page size. */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|pagesize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Various quantum-related settings. */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|quantum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|quantum_mask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (quantum - 1). */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|bin_shift
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|bin_maxsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Various chunk-related settings. */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|chunk_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|chunk_size_mask
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* (chunk_size - 1). */
end_comment

begin_comment
comment|/********/
end_comment

begin_comment
comment|/*  * Chunks.  */
end_comment

begin_comment
comment|/* Protects chunk-related data structures. */
end_comment

begin_decl_stmt
specifier|static
name|malloc_mutex_t
name|chunks_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tree of chunks that are stand-alone huge allocations. */
end_comment

begin_decl_stmt
specifier|static
name|chunk_tree_t
name|huge
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|USE_BRK
end_ifdef

begin_comment
comment|/*  * Try to use brk for chunk-size allocations, due to address space constraints.  */
end_comment

begin_comment
comment|/* Result of first sbrk(0) call. */
end_comment

begin_decl_stmt
specifier|static
name|void
modifier|*
name|brk_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current end of brk, or ((void *)-1) if brk is exhausted. */
end_comment

begin_decl_stmt
specifier|static
name|void
modifier|*
name|brk_prev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Upper limit on brk addresses (may be an over-estimate). */
end_comment

begin_decl_stmt
specifier|static
name|void
modifier|*
name|brk_max
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_STATS
end_ifdef

begin_comment
comment|/*  * Byte counters for allocated/total space used by the chunks in the huge  * allocations tree.  */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|huge_allocated
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|huge_total
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Tree of chunks that were previously allocated.  This is used when allocating  * chunks, in an attempt to re-use address space.  */
end_comment

begin_decl_stmt
specifier|static
name|chunk_tree_t
name|old_chunks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/****************************/
end_comment

begin_comment
comment|/*  * base (internal allocation).  */
end_comment

begin_comment
comment|/*  * Current chunk that is being used for internal memory allocations.  This  * chunk is carved up in cacheline-size quanta, so that there is no chance of  * false cach sharing.   * */
end_comment

begin_decl_stmt
specifier|static
name|void
modifier|*
name|base_chunk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|base_next_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
modifier|*
name|base_past_addr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Addr immediately past base_chunk. */
end_comment

begin_decl_stmt
specifier|static
name|chunk_node_t
modifier|*
name|base_chunk_nodes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* LIFO cache of chunk nodes. */
end_comment

begin_decl_stmt
specifier|static
name|malloc_mutex_t
name|base_mtx
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_STATS
end_ifdef

begin_decl_stmt
specifier|static
name|uint64_t
name|base_total
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/********/
end_comment

begin_comment
comment|/*  * Arenas.  */
end_comment

begin_comment
comment|/*   * Arenas that are used to service external requests.  Not all elements of the  * arenas array are necessarily used; arenas are created lazily as needed.  */
end_comment

begin_decl_stmt
specifier|static
name|arena_t
modifier|*
modifier|*
name|arenas
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|narenas
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NO_TLS
end_ifndef

begin_decl_stmt
specifier|static
name|unsigned
name|next_arena
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|malloc_mutex_t
name|arenas_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Protects arenas initialization. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_TLS
end_ifndef

begin_comment
comment|/*  * Map of pthread_self() --> arenas[???], used for selecting an arena to use  * for allocations.  */
end_comment

begin_decl_stmt
specifier|static
name|__thread
name|arena_t
modifier|*
name|arenas_map
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_STATS
end_ifdef

begin_comment
comment|/* Chunk statistics. */
end_comment

begin_decl_stmt
specifier|static
name|chunk_stats_t
name|stats_chunks
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*******************************/
end_comment

begin_comment
comment|/*  * Runtime configuration options.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|_malloc_options
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|opt_abort
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|opt_junk
init|=
name|true
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|opt_print_stats
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|opt_quantum_2pow
init|=
name|QUANTUM_2POW_MIN
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|opt_chunk_2pow
init|=
name|CHUNK_2POW_DEFAULT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|opt_utrace
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|opt_sysv
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|opt_xmalloc
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|opt_zero
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|opt_ndelay
init|=
name|NDELAY
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int32_t
name|opt_narenas_lshift
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|size_t
name|s
decl_stmt|;
name|void
modifier|*
name|r
decl_stmt|;
block|}
name|malloc_utrace_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|UTRACE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
define|\
value|if (opt_utrace) {						\ 		malloc_utrace_t ut = {a, b, c};				\ 		utrace(&ut, sizeof(ut));				\ 	}
end_define

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin function prototypes for non-inline static functions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|malloc_mutex_init
parameter_list|(
name|malloc_mutex_t
modifier|*
name|a_mutex
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|wrtmessage
parameter_list|(
specifier|const
name|char
modifier|*
name|p1
parameter_list|,
specifier|const
name|char
modifier|*
name|p2
parameter_list|,
specifier|const
name|char
modifier|*
name|p3
parameter_list|,
specifier|const
name|char
modifier|*
name|p4
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|malloc_printf
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|base_alloc
parameter_list|(
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|chunk_node_t
modifier|*
name|base_chunk_node_alloc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|base_chunk_node_dealloc
parameter_list|(
name|chunk_node_t
modifier|*
name|node
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_STATS
end_ifdef

begin_function_decl
specifier|static
name|void
name|stats_merge
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_stats_t
modifier|*
name|stats_arenas
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stats_print
parameter_list|(
name|arena_stats_t
modifier|*
name|stats_arenas
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
modifier|*
name|pages_map
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pages_unmap
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|chunk_alloc
parameter_list|(
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|chunk_dealloc
parameter_list|(
name|void
modifier|*
name|chunk
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|arena_bins_search
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|arena_coalesce
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|region_t
modifier|*
modifier|*
name|reg
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arena_coalesce_hard
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|region_t
modifier|*
name|reg
parameter_list|,
name|region_t
modifier|*
name|next
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|split_adjacent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arena_large_insert
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|region_t
modifier|*
name|reg
parameter_list|,
name|bool
name|lru
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arena_large_cache
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|region_t
modifier|*
name|reg
parameter_list|,
name|bool
name|lru
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arena_lru_cache
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|region_t
modifier|*
name|reg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arena_delay_cache
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|region_t
modifier|*
name|reg
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|region_t
modifier|*
name|arena_frag_reg_alloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|fit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|region_t
modifier|*
name|arena_split_reg_alloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|fit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|arena_reg_fit
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|,
name|region_t
modifier|*
name|reg
parameter_list|,
name|bool
name|restore_split
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|region_t
modifier|*
name|arena_large_reg_alloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|fit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|region_t
modifier|*
name|arena_chunk_reg_alloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|fit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|arena_malloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|arena_palloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|arena_calloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|num
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|arena_salloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_REDZONES
end_ifdef

begin_function_decl
specifier|static
name|void
name|redzone_check
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|arena_dalloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|NOT_YET
end_ifdef

begin_function_decl
specifier|static
name|void
modifier|*
name|arena_ralloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_STATS
end_ifdef

begin_function_decl
specifier|static
name|bool
name|arena_stats
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
modifier|*
name|allocated
parameter_list|,
name|size_t
modifier|*
name|total
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|bool
name|arena_new
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|arena_t
modifier|*
name|arenas_extend
parameter_list|(
name|unsigned
name|ind
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|NO_TLS
end_ifndef

begin_function_decl
specifier|static
name|arena_t
modifier|*
name|choose_arena_hard
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
modifier|*
name|huge_malloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|huge_dalloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|imalloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|ipalloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|icalloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|num
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|isalloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|idalloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|iralloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_STATS
end_ifdef

begin_function_decl
specifier|static
name|void
name|istats
parameter_list|(
name|size_t
modifier|*
name|allocated
parameter_list|,
name|size_t
modifier|*
name|total
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|malloc_print_stats
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|malloc_init_hard
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * End function prototypes.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin mutex.  */
end_comment

begin_function
specifier|static
name|void
name|malloc_mutex_init
parameter_list|(
name|malloc_mutex_t
modifier|*
name|a_mutex
parameter_list|)
block|{
specifier|static
specifier|const
name|spinlock_t
name|lock
init|=
name|_SPINLOCK_INITIALIZER
decl_stmt|;
name|a_mutex
operator|->
name|lock
operator|=
name|lock
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|malloc_mutex_lock
parameter_list|(
name|malloc_mutex_t
modifier|*
name|a_mutex
parameter_list|)
block|{
if|if
condition|(
name|__isthreaded
condition|)
name|_SPINLOCK
argument_list|(
operator|&
name|a_mutex
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|malloc_mutex_unlock
parameter_list|(
name|malloc_mutex_t
modifier|*
name|a_mutex
parameter_list|)
block|{
if|if
condition|(
name|__isthreaded
condition|)
name|_SPINUNLOCK
argument_list|(
operator|&
name|a_mutex
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * End mutex.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin Utility functions/macros.  */
end_comment

begin_comment
comment|/* Return the chunk address for allocation address a. */
end_comment

begin_define
define|#
directive|define
name|CHUNK_ADDR2BASE
parameter_list|(
name|a
parameter_list|)
define|\
value|((void *)((uintptr_t)(a)& ~chunk_size_mask))
end_define

begin_comment
comment|/* Return the chunk offset of address a. */
end_comment

begin_define
define|#
directive|define
name|CHUNK_ADDR2OFFSET
parameter_list|(
name|a
parameter_list|)
define|\
value|((size_t)((uintptr_t)(a)& chunk_size_mask))
end_define

begin_comment
comment|/* Return the smallest chunk multiple that is>= s. */
end_comment

begin_define
define|#
directive|define
name|CHUNK_CEILING
parameter_list|(
name|s
parameter_list|)
define|\
value|(((s) + chunk_size_mask)& ~chunk_size_mask)
end_define

begin_comment
comment|/* Return the smallest cacheline multiple that is>= s. */
end_comment

begin_define
define|#
directive|define
name|CACHELINE_CEILING
parameter_list|(
name|s
parameter_list|)
define|\
value|(((s) + (CACHELINE - 1))& ~(CACHELINE - 1))
end_define

begin_comment
comment|/* Return the smallest quantum multiple that is>= a. */
end_comment

begin_define
define|#
directive|define
name|QUANTUM_CEILING
parameter_list|(
name|a
parameter_list|)
define|\
value|(((a) + quantum_mask)& ~quantum_mask)
end_define

begin_comment
comment|/* Return the offset within a chunk to the first region separator. */
end_comment

begin_define
define|#
directive|define
name|CHUNK_REG_OFFSET
define|\
value|(QUANTUM_CEILING(sizeof(chunk_node_t) +				\ 	    sizeof(region_sep_t)) - offsetof(region_t, next))
end_define

begin_comment
comment|/*  * Return how many bytes of usable space are needed for an allocation of size  * bytes.  This value is not a multiple of quantum, since it doesn't include  * the region separator.  */
end_comment

begin_function
specifier|static
name|__inline
name|size_t
name|region_ceiling
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|quantum_size
decl_stmt|,
name|min_reg_quantum
decl_stmt|;
name|quantum_size
operator|=
name|QUANTUM_CEILING
argument_list|(
name|size
operator|+
sizeof|sizeof
argument_list|(
name|region_sep_t
argument_list|)
argument_list|)
expr_stmt|;
name|min_reg_quantum
operator|=
name|QUANTUM_CEILING
argument_list|(
sizeof|sizeof
argument_list|(
name|region_small_sizer_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|quantum_size
operator|>=
name|min_reg_quantum
condition|)
return|return
operator|(
name|quantum_size
operator|)
return|;
else|else
return|return
operator|(
name|min_reg_quantum
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|wrtmessage
parameter_list|(
specifier|const
name|char
modifier|*
name|p1
parameter_list|,
specifier|const
name|char
modifier|*
name|p2
parameter_list|,
specifier|const
name|char
modifier|*
name|p3
parameter_list|,
specifier|const
name|char
modifier|*
name|p4
parameter_list|)
block|{
name|_write
argument_list|(
name|STDERR_FILENO
argument_list|,
name|p1
argument_list|,
name|strlen
argument_list|(
name|p1
argument_list|)
argument_list|)
expr_stmt|;
name|_write
argument_list|(
name|STDERR_FILENO
argument_list|,
name|p2
argument_list|,
name|strlen
argument_list|(
name|p2
argument_list|)
argument_list|)
expr_stmt|;
name|_write
argument_list|(
name|STDERR_FILENO
argument_list|,
name|p3
argument_list|,
name|strlen
argument_list|(
name|p3
argument_list|)
argument_list|)
expr_stmt|;
name|_write
argument_list|(
name|STDERR_FILENO
argument_list|,
name|p4
argument_list|,
name|strlen
argument_list|(
name|p4
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function_decl
name|void
function_decl|(
modifier|*
name|_malloc_message
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
name|p1
parameter_list|,
specifier|const
name|char
modifier|*
name|p2
parameter_list|,
specifier|const
name|char
modifier|*
name|p3
parameter_list|,
specifier|const
name|char
modifier|*
name|p4
parameter_list|)
init|=
name|wrtmessage
function_decl|;
end_function_decl

begin_comment
comment|/*  * Print to stderr in such a way as to (hopefully) avoid memory allocation.  */
end_comment

begin_function
specifier|static
name|void
name|malloc_printf
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|buf
index|[
literal|4096
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vsnprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
name|_malloc_message
argument_list|(
name|buf
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_function
specifier|static
name|void
modifier|*
name|base_alloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|size_t
name|csize
decl_stmt|;
comment|/* Round size up to nearest multiple of the cacheline size. */
name|csize
operator|=
name|CACHELINE_CEILING
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
comment|/* Make sure there's enough space for the allocation. */
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|base_next_addr
operator|+
name|csize
operator|>
operator|(
name|uintptr_t
operator|)
name|base_past_addr
condition|)
block|{
name|void
modifier|*
name|tchunk
decl_stmt|;
name|size_t
name|alloc_size
decl_stmt|;
comment|/* 		 * If chunk_size and opt_ndelay are sufficiently small and 		 * large, respectively, it's possible for an allocation request 		 * to exceed a single chunk here.  Deal with this, but don't 		 * worry about internal fragmentation. 		 */
if|if
condition|(
name|csize
operator|<=
name|chunk_size
condition|)
name|alloc_size
operator|=
name|chunk_size
expr_stmt|;
else|else
name|alloc_size
operator|=
name|CHUNK_CEILING
argument_list|(
name|csize
argument_list|)
expr_stmt|;
name|tchunk
operator|=
name|chunk_alloc
argument_list|(
name|alloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|tchunk
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
name|base_chunk
operator|=
name|tchunk
expr_stmt|;
name|base_next_addr
operator|=
operator|(
name|void
operator|*
operator|)
name|base_chunk
expr_stmt|;
name|base_past_addr
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|base_chunk
operator|+
name|alloc_size
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|base_total
operator|+=
name|alloc_size
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* Allocate. */
name|ret
operator|=
name|base_next_addr
expr_stmt|;
name|base_next_addr
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|base_next_addr
operator|+
name|csize
operator|)
expr_stmt|;
name|RETURN
label|:
name|malloc_mutex_unlock
argument_list|(
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|chunk_node_t
modifier|*
name|base_chunk_node_alloc
parameter_list|(
name|void
parameter_list|)
block|{
name|chunk_node_t
modifier|*
name|ret
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_chunk_nodes
operator|!=
name|NULL
condition|)
block|{
name|ret
operator|=
name|base_chunk_nodes
expr_stmt|;
name|base_chunk_nodes
operator|=
operator|*
operator|(
name|chunk_node_t
operator|*
operator|*
operator|)
name|ret
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|malloc_mutex_unlock
argument_list|(
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|chunk_node_t
operator|*
operator|)
name|base_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|chunk_node_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|base_chunk_node_dealloc
parameter_list|(
name|chunk_node_t
modifier|*
name|node
parameter_list|)
block|{
name|malloc_mutex_lock
argument_list|(
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
operator|*
operator|(
name|chunk_node_t
operator|*
operator|*
operator|)
name|node
operator|=
name|base_chunk_nodes
expr_stmt|;
name|base_chunk_nodes
operator|=
name|node
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Note that no bitshifting is done for booleans in any of the bitmask-based  * flag manipulation functions that follow; test for non-zero versus zero.  */
end_comment

begin_comment
comment|/**********************/
end_comment

begin_function
specifier|static
name|__inline
name|uint32_t
name|region_prev_free_get
parameter_list|(
name|region_sep_t
modifier|*
name|sep
parameter_list|)
block|{
return|return
operator|(
operator|(
name|sep
operator|->
name|bits
operator|)
operator|&
literal|0x80000000U
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|region_prev_free_set
parameter_list|(
name|region_sep_t
modifier|*
name|sep
parameter_list|)
block|{
name|sep
operator|->
name|bits
operator|=
operator|(
operator|(
name|sep
operator|->
name|bits
operator|)
operator||
literal|0x80000000U
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|region_prev_free_unset
parameter_list|(
name|region_sep_t
modifier|*
name|sep
parameter_list|)
block|{
name|sep
operator|->
name|bits
operator|=
operator|(
operator|(
name|sep
operator|->
name|bits
operator|)
operator|&
literal|0x7fffffffU
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************/
end_comment

begin_function
specifier|static
name|__inline
name|uint32_t
name|region_next_free_get
parameter_list|(
name|region_sep_t
modifier|*
name|sep
parameter_list|)
block|{
return|return
operator|(
operator|(
name|sep
operator|->
name|bits
operator|)
operator|&
literal|0x40000000U
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|region_next_free_set
parameter_list|(
name|region_sep_t
modifier|*
name|sep
parameter_list|)
block|{
name|sep
operator|->
name|bits
operator|=
operator|(
operator|(
name|sep
operator|->
name|bits
operator|)
operator||
literal|0x40000000U
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|region_next_free_unset
parameter_list|(
name|region_sep_t
modifier|*
name|sep
parameter_list|)
block|{
name|sep
operator|->
name|bits
operator|=
operator|(
operator|(
name|sep
operator|->
name|bits
operator|)
operator|&
literal|0xbfffffffU
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**********************/
end_comment

begin_function
specifier|static
name|__inline
name|uint32_t
name|region_next_contig_get
parameter_list|(
name|region_sep_t
modifier|*
name|sep
parameter_list|)
block|{
return|return
operator|(
operator|(
name|sep
operator|->
name|bits
operator|)
operator|&
literal|0x20000000U
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|region_next_contig_set
parameter_list|(
name|region_sep_t
modifier|*
name|sep
parameter_list|)
block|{
name|sep
operator|->
name|bits
operator|=
operator|(
operator|(
name|sep
operator|->
name|bits
operator|)
operator||
literal|0x20000000U
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|region_next_contig_unset
parameter_list|(
name|region_sep_t
modifier|*
name|sep
parameter_list|)
block|{
name|sep
operator|->
name|bits
operator|=
operator|(
operator|(
name|sep
operator|->
name|bits
operator|)
operator|&
literal|0xdfffffffU
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/********************/
end_comment

begin_function
specifier|static
name|__inline
name|size_t
name|region_next_size_get
parameter_list|(
name|region_sep_t
modifier|*
name|sep
parameter_list|)
block|{
return|return
operator|(
call|(
name|size_t
call|)
argument_list|(
operator|(
operator|(
name|sep
operator|->
name|bits
operator|)
operator|&
name|NEXT_SIZE_MASK
operator|)
operator|<<
name|opt_quantum_2pow
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|region_next_size_set
parameter_list|(
name|region_sep_t
modifier|*
name|sep
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|uint32_t
name|bits
decl_stmt|;
name|assert
argument_list|(
name|size
operator|%
name|quantum
operator|==
literal|0
argument_list|)
expr_stmt|;
name|bits
operator|=
name|sep
operator|->
name|bits
expr_stmt|;
name|bits
operator|&=
operator|~
name|NEXT_SIZE_MASK
expr_stmt|;
name|bits
operator||=
operator|(
operator|(
operator|(
name|uint32_t
operator|)
name|size
operator|)
operator|>>
name|opt_quantum_2pow
operator|)
expr_stmt|;
name|sep
operator|->
name|bits
operator|=
name|bits
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_STATS
end_ifdef

begin_function
specifier|static
name|void
name|stats_merge
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|arena_stats_t
modifier|*
name|stats_arenas
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|stats_arenas
operator|->
name|nmalloc
operator|+=
name|arena
operator|->
name|stats
operator|.
name|nmalloc
expr_stmt|;
name|stats_arenas
operator|->
name|npalloc
operator|+=
name|arena
operator|->
name|stats
operator|.
name|npalloc
expr_stmt|;
name|stats_arenas
operator|->
name|ncalloc
operator|+=
name|arena
operator|->
name|stats
operator|.
name|ncalloc
expr_stmt|;
name|stats_arenas
operator|->
name|ndalloc
operator|+=
name|arena
operator|->
name|stats
operator|.
name|ndalloc
expr_stmt|;
name|stats_arenas
operator|->
name|nralloc
operator|+=
name|arena
operator|->
name|stats
operator|.
name|nralloc
expr_stmt|;
name|stats_arenas
operator|->
name|nsplit
operator|+=
name|arena
operator|->
name|stats
operator|.
name|nsplit
expr_stmt|;
name|stats_arenas
operator|->
name|ncoalesce
operator|+=
name|arena
operator|->
name|stats
operator|.
name|ncoalesce
expr_stmt|;
comment|/* Split. */
name|stats_arenas
operator|->
name|split
operator|.
name|nrequests
operator|+=
name|arena
operator|->
name|stats
operator|.
name|split
operator|.
name|nrequests
expr_stmt|;
name|stats_arenas
operator|->
name|split
operator|.
name|nserviced
operator|+=
name|arena
operator|->
name|stats
operator|.
name|split
operator|.
name|nserviced
expr_stmt|;
comment|/* Frag. */
name|stats_arenas
operator|->
name|frag
operator|.
name|ncached
operator|+=
name|arena
operator|->
name|stats
operator|.
name|frag
operator|.
name|ncached
expr_stmt|;
name|stats_arenas
operator|->
name|frag
operator|.
name|nrequests
operator|+=
name|arena
operator|->
name|stats
operator|.
name|frag
operator|.
name|nrequests
expr_stmt|;
name|stats_arenas
operator|->
name|frag
operator|.
name|nserviced
operator|+=
name|arena
operator|->
name|stats
operator|.
name|frag
operator|.
name|nserviced
expr_stmt|;
comment|/* Bins. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBINS
condition|;
name|i
operator|++
control|)
block|{
name|stats_arenas
operator|->
name|bins
index|[
name|i
index|]
operator|.
name|nrequests
operator|+=
name|arena
operator|->
name|stats
operator|.
name|bins
index|[
name|i
index|]
operator|.
name|nrequests
expr_stmt|;
name|stats_arenas
operator|->
name|bins
index|[
name|i
index|]
operator|.
name|nfit
operator|+=
name|arena
operator|->
name|stats
operator|.
name|bins
index|[
name|i
index|]
operator|.
name|nfit
expr_stmt|;
if|if
condition|(
name|arena
operator|->
name|stats
operator|.
name|bins
index|[
name|i
index|]
operator|.
name|highcached
operator|>
name|stats_arenas
operator|->
name|bins
index|[
name|i
index|]
operator|.
name|highcached
condition|)
block|{
name|stats_arenas
operator|->
name|bins
index|[
name|i
index|]
operator|.
name|highcached
operator|=
name|arena
operator|->
name|stats
operator|.
name|bins
index|[
name|i
index|]
operator|.
name|highcached
expr_stmt|;
block|}
block|}
comment|/* large and large_regions. */
name|stats_arenas
operator|->
name|large
operator|.
name|nrequests
operator|+=
name|arena
operator|->
name|stats
operator|.
name|large
operator|.
name|nrequests
expr_stmt|;
name|stats_arenas
operator|->
name|large
operator|.
name|nfit
operator|+=
name|arena
operator|->
name|stats
operator|.
name|large
operator|.
name|nfit
expr_stmt|;
name|stats_arenas
operator|->
name|large
operator|.
name|noverfit
operator|+=
name|arena
operator|->
name|stats
operator|.
name|large
operator|.
name|noverfit
expr_stmt|;
if|if
condition|(
name|arena
operator|->
name|stats
operator|.
name|large
operator|.
name|highcached
operator|>
name|stats_arenas
operator|->
name|large
operator|.
name|highcached
condition|)
name|stats_arenas
operator|->
name|large
operator|.
name|highcached
operator|=
name|arena
operator|->
name|stats
operator|.
name|large
operator|.
name|highcached
expr_stmt|;
name|stats_arenas
operator|->
name|large
operator|.
name|curcached
operator|+=
name|arena
operator|->
name|stats
operator|.
name|large
operator|.
name|curcached
expr_stmt|;
comment|/* Huge allocations. */
name|stats_arenas
operator|->
name|huge
operator|.
name|nrequests
operator|+=
name|arena
operator|->
name|stats
operator|.
name|huge
operator|.
name|nrequests
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|stats_print
parameter_list|(
name|arena_stats_t
modifier|*
name|stats_arenas
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|malloc_printf
argument_list|(
literal|"calls:\n"
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|" %13s%13s%13s%13s%13s\n"
argument_list|,
literal|"nmalloc"
argument_list|,
literal|"npalloc"
argument_list|,
literal|"ncalloc"
argument_list|,
literal|"ndalloc"
argument_list|,
literal|"nralloc"
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|" %13llu%13llu%13llu%13llu%13llu\n"
argument_list|,
name|stats_arenas
operator|->
name|nmalloc
argument_list|,
name|stats_arenas
operator|->
name|npalloc
argument_list|,
name|stats_arenas
operator|->
name|ncalloc
argument_list|,
name|stats_arenas
operator|->
name|ndalloc
argument_list|,
name|stats_arenas
operator|->
name|nralloc
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"region events:\n"
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|" %13s%13s\n"
argument_list|,
literal|"nsplit"
argument_list|,
literal|"ncoalesce"
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|" %13llu%13llu\n"
argument_list|,
name|stats_arenas
operator|->
name|nsplit
argument_list|,
name|stats_arenas
operator|->
name|ncoalesce
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"cached split usage:\n"
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|" %13s%13s\n"
argument_list|,
literal|"nrequests"
argument_list|,
literal|"nserviced"
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|" %13llu%13llu\n"
argument_list|,
name|stats_arenas
operator|->
name|split
operator|.
name|nrequests
argument_list|,
name|stats_arenas
operator|->
name|split
operator|.
name|nserviced
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"cached frag usage:\n"
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|" %13s%13s%13s\n"
argument_list|,
literal|"ncached"
argument_list|,
literal|"nrequests"
argument_list|,
literal|"nserviced"
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|" %13llu%13llu%13llu\n"
argument_list|,
name|stats_arenas
operator|->
name|frag
operator|.
name|ncached
argument_list|,
name|stats_arenas
operator|->
name|frag
operator|.
name|nrequests
argument_list|,
name|stats_arenas
operator|->
name|frag
operator|.
name|nserviced
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"bins:\n"
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|" %4s%7s%13s%13s%11s\n"
argument_list|,
literal|"bin"
argument_list|,
literal|"size"
argument_list|,
literal|"nrequests"
argument_list|,
literal|"nfit"
argument_list|,
literal|"highcached"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBINS
condition|;
name|i
operator|++
control|)
block|{
name|malloc_printf
argument_list|(
literal|" %4u%7u%13llu%13llu%11lu\n"
argument_list|,
name|i
argument_list|,
operator|(
operator|(
name|i
operator|+
name|bin_shift
operator|)
operator|<<
name|opt_quantum_2pow
operator|)
argument_list|,
name|stats_arenas
operator|->
name|bins
index|[
name|i
index|]
operator|.
name|nrequests
argument_list|,
name|stats_arenas
operator|->
name|bins
index|[
name|i
index|]
operator|.
name|nfit
argument_list|,
name|stats_arenas
operator|->
name|bins
index|[
name|i
index|]
operator|.
name|highcached
argument_list|)
expr_stmt|;
block|}
name|malloc_printf
argument_list|(
literal|"large:\n"
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|" %13s%13s%13s%13s%13s\n"
argument_list|,
literal|"nrequests"
argument_list|,
literal|"nfit"
argument_list|,
literal|"noverfit"
argument_list|,
literal|"highcached"
argument_list|,
literal|"curcached"
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|" %13llu%13llu%13llu%13lu%13lu\n"
argument_list|,
name|stats_arenas
operator|->
name|large
operator|.
name|nrequests
argument_list|,
name|stats_arenas
operator|->
name|large
operator|.
name|nfit
argument_list|,
name|stats_arenas
operator|->
name|large
operator|.
name|noverfit
argument_list|,
name|stats_arenas
operator|->
name|large
operator|.
name|highcached
argument_list|,
name|stats_arenas
operator|->
name|large
operator|.
name|curcached
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"huge\n"
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|" %13s\n"
argument_list|,
literal|"nrequests"
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|" %13llu\n"
argument_list|,
name|stats_arenas
operator|->
name|huge
operator|.
name|nrequests
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * End Utility functions/macros.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin Mem.  */
end_comment

begin_function
specifier|static
name|__inline
name|int
name|chunk_comp
parameter_list|(
name|chunk_node_t
modifier|*
name|a
parameter_list|,
name|chunk_node_t
modifier|*
name|b
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|assert
argument_list|(
name|a
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|b
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|a
operator|->
name|chunk
operator|<
operator|(
name|uintptr_t
operator|)
name|b
operator|->
name|chunk
condition|)
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|a
operator|->
name|chunk
operator|==
name|b
operator|->
name|chunk
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
else|else
name|ret
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Generate red-black tree code for chunks. */
end_comment

begin_expr_stmt
name|RB_GENERATE_STATIC
argument_list|(
name|chunk_tree_s
argument_list|,
name|chunk_node_s
argument_list|,
name|link
argument_list|,
name|chunk_comp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|__inline
name|int
name|region_comp
parameter_list|(
name|region_node_t
modifier|*
name|a
parameter_list|,
name|region_node_t
modifier|*
name|b
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|size_t
name|size_a
decl_stmt|,
name|size_b
decl_stmt|;
name|assert
argument_list|(
name|a
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|b
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|size_a
operator|=
name|region_next_size_get
argument_list|(
operator|&
name|a
operator|->
name|reg
operator|->
name|sep
argument_list|)
expr_stmt|;
name|size_b
operator|=
name|region_next_size_get
argument_list|(
operator|&
name|b
operator|->
name|reg
operator|->
name|sep
argument_list|)
expr_stmt|;
if|if
condition|(
name|size_a
operator|<
name|size_b
condition|)
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|size_a
operator|==
name|size_b
condition|)
block|{
if|if
condition|(
name|a
operator|==
name|b
condition|)
block|{
comment|/* Regions are equal with themselves. */
name|ret
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|a
operator|->
name|reg
operator|->
name|next
operator|.
name|u
operator|.
name|l
operator|.
name|lru
condition|)
block|{
comment|/* 				 * Oldest region comes first (secondary LRU 				 * ordering).  a is guaranteed to be the search 				 * key, which is how we can enforce this 				 * secondary ordering. 				 */
name|ret
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * Oldest region comes last (secondary MRU 				 * ordering).  a is guaranteed to be the search 				 * key, which is how we can enforce this 				 * secondary ordering. 				 */
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
else|else
name|ret
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Generate red-black tree code for regions. */
end_comment

begin_expr_stmt
name|RB_GENERATE_STATIC
argument_list|(
name|region_tree_s
argument_list|,
name|region_node_s
argument_list|,
name|link
argument_list|,
name|region_comp
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function
specifier|static
name|void
modifier|*
name|pages_map
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
ifdef|#
directive|ifdef
name|USE_BRK
name|AGAIN
label|:
endif|#
directive|endif
comment|/* 	 * We don't use MAP_FIXED here, because it can cause the *replacement* 	 * of existing mappings, and we only want to create new mappings. 	 */
name|ret
operator|=
name|mmap
argument_list|(
name|addr
argument_list|,
name|size
argument_list|,
name|PROT_READ
operator||
name|PROT_WRITE
argument_list|,
name|MAP_PRIVATE
operator||
name|MAP_ANON
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ret
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|MAP_FAILED
condition|)
name|ret
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|addr
operator|!=
name|NULL
operator|&&
name|ret
operator|!=
name|addr
condition|)
block|{
comment|/* 		 * We succeeded in mapping memory, but not in the right place. 		 */
if|if
condition|(
name|munmap
argument_list|(
name|ret
argument_list|,
name|size
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|char
name|buf
index|[
name|STRERROR_BUF
index|]
decl_stmt|;
name|strerror_r
argument_list|(
name|errno
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"%s: (malloc) Error in munmap(): %s\n"
argument_list|,
name|_getprogname
argument_list|()
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_abort
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|ret
operator|=
name|NULL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USE_BRK
elseif|else
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|ret
operator|>=
operator|(
name|uintptr_t
operator|)
name|brk_base
operator|&&
operator|(
name|uintptr_t
operator|)
name|ret
operator|<
operator|(
name|uintptr_t
operator|)
name|brk_max
condition|)
block|{
comment|/* 		 * We succeeded in mapping memory, but at a location that could 		 * be confused with brk.  Leave the mapping intact so that this 		 * won't ever happen again, then try again. 		 */
name|assert
argument_list|(
name|addr
operator|==
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|AGAIN
goto|;
block|}
endif|#
directive|endif
name|assert
argument_list|(
name|ret
operator|==
name|NULL
operator|||
operator|(
name|addr
operator|==
name|NULL
operator|&&
name|ret
operator|!=
name|addr
operator|)
operator|||
operator|(
name|addr
operator|!=
name|NULL
operator|&&
name|ret
operator|==
name|addr
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|pages_unmap
parameter_list|(
name|void
modifier|*
name|addr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
if|if
condition|(
name|munmap
argument_list|(
name|addr
argument_list|,
name|size
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|char
name|buf
index|[
name|STRERROR_BUF
index|]
decl_stmt|;
name|strerror_r
argument_list|(
name|errno
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"%s: (malloc) Error in munmap(): %s\n"
argument_list|,
name|_getprogname
argument_list|()
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_abort
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|chunk_alloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|,
modifier|*
name|chunk
decl_stmt|;
name|chunk_node_t
modifier|*
name|tchunk
decl_stmt|,
modifier|*
name|delchunk
decl_stmt|;
name|chunk_tree_t
name|delchunks
decl_stmt|;
name|assert
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|%
name|chunk_size
operator|==
literal|0
argument_list|)
expr_stmt|;
name|RB_INIT
argument_list|(
operator|&
name|delchunks
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
name|chunk_size
condition|)
block|{
comment|/* 		 * Check for address ranges that were previously chunks and try 		 * to use them. 		 */
name|tchunk
operator|=
name|RB_MIN
argument_list|(
name|chunk_tree_s
argument_list|,
operator|&
name|old_chunks
argument_list|)
expr_stmt|;
while|while
condition|(
name|tchunk
operator|!=
name|NULL
condition|)
block|{
comment|/* Found an address range.  Try to recycle it. */
name|chunk
operator|=
name|tchunk
operator|->
name|chunk
expr_stmt|;
name|delchunk
operator|=
name|tchunk
expr_stmt|;
name|tchunk
operator|=
name|RB_NEXT
argument_list|(
name|chunk_tree_s
argument_list|,
operator|&
name|old_chunks
argument_list|,
name|delchunk
argument_list|)
expr_stmt|;
comment|/* 			 * Remove delchunk from the tree, but keep track of the 			 * address. 			 */
name|RB_REMOVE
argument_list|(
name|chunk_tree_s
argument_list|,
operator|&
name|old_chunks
argument_list|,
name|delchunk
argument_list|)
expr_stmt|;
comment|/* 			 * Keep track of the node so that it can be deallocated 			 * after chunks_mtx is released. 			 */
name|RB_INSERT
argument_list|(
name|chunk_tree_s
argument_list|,
operator|&
name|delchunks
argument_list|,
name|delchunk
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_BRK
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|>=
operator|(
name|uintptr_t
operator|)
name|brk_base
operator|&&
operator|(
name|uintptr_t
operator|)
name|chunk
operator|<
operator|(
name|uintptr_t
operator|)
name|brk_max
condition|)
block|{
comment|/* Re-use a previously freed brk chunk. */
name|ret
operator|=
name|chunk
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|ret
operator|=
name|pages_map
argument_list|(
name|chunk
argument_list|,
name|size
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Success. */
goto|goto
name|RETURN
goto|;
block|}
block|}
ifdef|#
directive|ifdef
name|USE_BRK
comment|/* 		 * Try to create chunk-size allocations in brk, in order to 		 * make full use of limited address space. 		 */
if|if
condition|(
name|brk_prev
operator|!=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
name|void
modifier|*
name|brk_cur
decl_stmt|;
name|intptr_t
name|incr
decl_stmt|;
comment|/* 			 * The loop is necessary to recover from races with 			 * other threads that are using brk for something other 			 * than malloc. 			 */
do|do
block|{
comment|/* Get the current end of brk. */
name|brk_cur
operator|=
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 				 * Calculate how much padding is necessary to 				 * chunk-align the end of brk. 				 */
name|incr
operator|=
operator|(
name|char
operator|*
operator|)
name|chunk_size
operator|-
operator|(
name|char
operator|*
operator|)
name|CHUNK_ADDR2OFFSET
argument_list|(
name|brk_cur
argument_list|)
expr_stmt|;
if|if
condition|(
name|incr
operator|==
name|chunk_size
condition|)
block|{
name|ret
operator|=
name|brk_cur
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
operator|(
name|char
operator|*
operator|)
name|brk_cur
operator|+
name|incr
expr_stmt|;
name|incr
operator|+=
name|chunk_size
expr_stmt|;
block|}
name|brk_prev
operator|=
name|sbrk
argument_list|(
name|incr
argument_list|)
expr_stmt|;
if|if
condition|(
name|brk_prev
operator|==
name|brk_cur
condition|)
block|{
comment|/* Success. */
goto|goto
name|RETURN
goto|;
block|}
block|}
do|while
condition|(
name|brk_prev
operator|!=
operator|(
name|void
operator|*
operator|)
operator|-
literal|1
condition|)
do|;
block|}
endif|#
directive|endif
block|}
comment|/* 	 * Try to over-allocate, but allow the OS to place the allocation 	 * anywhere.  Beware of size_t wrap-around. 	 */
if|if
condition|(
name|size
operator|+
name|chunk_size
operator|>
name|size
condition|)
block|{
if|if
condition|(
operator|(
name|ret
operator|=
name|pages_map
argument_list|(
name|NULL
argument_list|,
name|size
operator|+
name|chunk_size
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|offset
init|=
name|CHUNK_ADDR2OFFSET
argument_list|(
name|ret
argument_list|)
decl_stmt|;
comment|/* 			 * Success.  Clean up unneeded leading/trailing space. 			 */
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
comment|/* Leading space. */
name|pages_unmap
argument_list|(
name|ret
argument_list|,
name|chunk_size
operator|-
name|offset
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ret
operator|+
operator|(
name|chunk_size
operator|-
name|offset
operator|)
operator|)
expr_stmt|;
comment|/* Trailing space. */
name|pages_unmap
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ret
operator|+
name|size
operator|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Trailing space only. */
name|pages_unmap
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ret
operator|+
name|size
operator|)
argument_list|,
name|chunk_size
argument_list|)
expr_stmt|;
block|}
goto|goto
name|RETURN
goto|;
block|}
block|}
comment|/* All strategies for allocation failed. */
name|ret
operator|=
name|NULL
expr_stmt|;
name|RETURN
label|:
ifdef|#
directive|ifdef
name|MALLOC_STATS
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
block|{
name|stats_chunks
operator|.
name|nchunks
operator|+=
operator|(
name|size
operator|/
name|chunk_size
operator|)
expr_stmt|;
name|stats_chunks
operator|.
name|curchunks
operator|+=
operator|(
name|size
operator|/
name|chunk_size
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|stats_chunks
operator|.
name|curchunks
operator|>
name|stats_chunks
operator|.
name|highchunks
condition|)
name|stats_chunks
operator|.
name|highchunks
operator|=
name|stats_chunks
operator|.
name|curchunks
expr_stmt|;
endif|#
directive|endif
name|malloc_mutex_unlock
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Deallocation of the chunk nodes must be done after releasing 	 * chunks_mtx, in case deallocation causes a chunk to be unmapped. 	 */
name|tchunk
operator|=
name|RB_MIN
argument_list|(
name|chunk_tree_s
argument_list|,
operator|&
name|delchunks
argument_list|)
expr_stmt|;
while|while
condition|(
name|tchunk
operator|!=
name|NULL
condition|)
block|{
name|delchunk
operator|=
name|tchunk
expr_stmt|;
name|tchunk
operator|=
name|RB_NEXT
argument_list|(
name|chunk_tree_s
argument_list|,
operator|&
name|delchunks
argument_list|,
name|delchunk
argument_list|)
expr_stmt|;
name|RB_REMOVE
argument_list|(
name|chunk_tree_s
argument_list|,
operator|&
name|delchunks
argument_list|,
name|delchunk
argument_list|)
expr_stmt|;
name|base_chunk_node_dealloc
argument_list|(
name|delchunk
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|CHUNK_ADDR2BASE
argument_list|(
name|ret
argument_list|)
operator|==
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|chunk_dealloc
parameter_list|(
name|void
modifier|*
name|chunk
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|assert
argument_list|(
name|chunk
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|CHUNK_ADDR2BASE
argument_list|(
name|chunk
argument_list|)
operator|==
name|chunk
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|%
name|chunk_size
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
name|chunk_size
condition|)
block|{
name|chunk_node_t
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|base_chunk_node_alloc
argument_list|()
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Create a record of this chunk before deallocating 			 * it, so that the address range can be recycled if 			 * memory usage increases later on. 			 */
name|node
operator|->
name|arena
operator|=
name|NULL
expr_stmt|;
name|node
operator|->
name|chunk
operator|=
name|chunk
expr_stmt|;
name|node
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|node
operator|->
name|extra
operator|=
literal|0
expr_stmt|;
name|RB_INSERT
argument_list|(
name|chunk_tree_s
argument_list|,
operator|&
name|old_chunks
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|USE_BRK
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|chunk
operator|>=
operator|(
name|uintptr_t
operator|)
name|brk_base
operator|&&
operator|(
name|uintptr_t
operator|)
name|chunk
operator|<
operator|(
name|uintptr_t
operator|)
name|brk_max
condition|)
name|madvise
argument_list|(
name|chunk
argument_list|,
name|size
argument_list|,
name|MADV_FREE
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|pages_unmap
argument_list|(
name|chunk
argument_list|,
name|size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|malloc_mutex_lock
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
name|stats_chunks
operator|.
name|curchunks
operator|-=
operator|(
name|size
operator|/
name|chunk_size
operator|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * arena.  */
end_comment

begin_function
specifier|static
name|__inline
name|void
name|arena_mask_set
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|unsigned
name|bin
parameter_list|)
block|{
name|unsigned
name|elm
decl_stmt|,
name|bit
decl_stmt|;
name|assert
argument_list|(
name|bin
operator|<
name|NBINS
argument_list|)
expr_stmt|;
name|elm
operator|=
name|bin
operator|/
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|<<
literal|3
operator|)
expr_stmt|;
name|bit
operator|=
name|bin
operator|-
operator|(
name|elm
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|<<
literal|3
operator|)
operator|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|arena
operator|->
name|bins_mask
index|[
name|elm
index|]
operator|&
operator|(
literal|1
operator|<<
name|bit
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|arena
operator|->
name|bins_mask
index|[
name|elm
index|]
operator||=
operator|(
literal|1
operator|<<
name|bit
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|arena_mask_unset
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|unsigned
name|bin
parameter_list|)
block|{
name|unsigned
name|elm
decl_stmt|,
name|bit
decl_stmt|;
name|assert
argument_list|(
name|bin
operator|<
name|NBINS
argument_list|)
expr_stmt|;
name|elm
operator|=
name|bin
operator|/
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|<<
literal|3
operator|)
expr_stmt|;
name|bit
operator|=
name|bin
operator|-
operator|(
name|elm
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|<<
literal|3
operator|)
operator|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|arena
operator|->
name|bins_mask
index|[
name|elm
index|]
operator|&
operator|(
literal|1
operator|<<
name|bit
operator|)
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|arena
operator|->
name|bins_mask
index|[
name|elm
index|]
operator|^=
operator|(
literal|1
operator|<<
name|bit
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|arena_bins_search
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|unsigned
name|ret
decl_stmt|,
name|minbin
decl_stmt|,
name|i
decl_stmt|;
name|int
name|bit
decl_stmt|;
name|assert
argument_list|(
name|QUANTUM_CEILING
argument_list|(
name|size
argument_list|)
operator|==
name|size
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|size
operator|>>
name|opt_quantum_2pow
operator|)
operator|>=
name|bin_shift
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|bin_maxsize
condition|)
block|{
name|ret
operator|=
name|UINT_MAX
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
name|minbin
operator|=
operator|(
name|size
operator|>>
name|opt_quantum_2pow
operator|)
operator|-
name|bin_shift
expr_stmt|;
name|assert
argument_list|(
name|minbin
operator|<
name|NBINS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|minbin
operator|/
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|<<
literal|3
operator|)
init|;
name|i
operator|<
name|BINMASK_NELMS
condition|;
name|i
operator|++
control|)
block|{
name|bit
operator|=
name|ffs
argument_list|(
name|arena
operator|->
name|bins_mask
index|[
name|i
index|]
operator|&
operator|(
name|UINT_MAX
operator|<<
operator|(
name|minbin
operator|%
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|<<
literal|3
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bit
operator|!=
literal|0
condition|)
block|{
comment|/* Usable allocation found. */
name|ret
operator|=
operator|(
name|i
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|<<
literal|3
operator|)
operator|)
operator|+
name|bit
operator|-
literal|1
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
block|}
name|ret
operator|=
name|UINT_MAX
expr_stmt|;
name|RETURN
label|:
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|arena_delayed_extract
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|region_t
modifier|*
name|reg
parameter_list|)
block|{
if|if
condition|(
name|region_next_contig_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
condition|)
block|{
name|uint32_t
name|slot
decl_stmt|;
comment|/* Extract this region from the delayed FIFO. */
name|assert
argument_list|(
name|region_next_free_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
operator|==
name|false
argument_list|)
expr_stmt|;
name|slot
operator|=
name|reg
operator|->
name|next
operator|.
name|u
operator|.
name|s
operator|.
name|slot
expr_stmt|;
name|assert
argument_list|(
name|arena
operator|->
name|delayed
index|[
name|slot
index|]
operator|==
name|reg
argument_list|)
expr_stmt|;
name|arena
operator|->
name|delayed
index|[
name|slot
index|]
operator|=
name|NULL
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
else|else
block|{
name|region_t
modifier|*
name|next
decl_stmt|;
name|assert
argument_list|(
name|region_next_free_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
argument_list|)
expr_stmt|;
name|next
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|reg
operator|)
index|[
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
index|]
expr_stmt|;
name|assert
argument_list|(
name|region_prev_free_get
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|arena_bin_extract
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|unsigned
name|bin
parameter_list|,
name|region_t
modifier|*
name|reg
parameter_list|)
block|{
name|arena_bin_t
modifier|*
name|tbin
decl_stmt|;
name|assert
argument_list|(
name|bin
operator|<
name|NBINS
argument_list|)
expr_stmt|;
name|tbin
operator|=
operator|&
name|arena
operator|->
name|bins
index|[
name|bin
index|]
expr_stmt|;
name|assert
argument_list|(
name|qr_next
argument_list|(
operator|&
name|tbin
operator|->
name|regions
argument_list|,
name|next
operator|.
name|u
operator|.
name|s
operator|.
name|link
argument_list|)
operator|!=
operator|&
name|tbin
operator|->
name|regions
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
block|{
name|region_t
modifier|*
name|next
decl_stmt|;
name|next
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|reg
operator|)
index|[
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
index|]
expr_stmt|;
if|if
condition|(
name|region_next_free_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|region_prev_free_get
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
operator|==
name|next
operator|->
name|prev
operator|.
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|assert
argument_list|(
name|region_prev_free_get
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
operator|==
name|false
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|assert
argument_list|(
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
operator|==
operator|(
operator|(
name|bin
operator|+
name|bin_shift
operator|)
operator|<<
name|opt_quantum_2pow
operator|)
argument_list|)
expr_stmt|;
name|qr_remove
argument_list|(
name|reg
argument_list|,
name|next
operator|.
name|u
operator|.
name|s
operator|.
name|link
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|bins
index|[
name|bin
index|]
operator|.
name|nregions
operator|--
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|qr_next
argument_list|(
operator|&
name|tbin
operator|->
name|regions
argument_list|,
name|next
operator|.
name|u
operator|.
name|s
operator|.
name|link
argument_list|)
operator|==
operator|&
name|tbin
operator|->
name|regions
condition|)
name|arena_mask_unset
argument_list|(
name|arena
argument_list|,
name|bin
argument_list|)
expr_stmt|;
name|arena_delayed_extract
argument_list|(
name|arena
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|arena_extract
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|region_t
modifier|*
name|reg
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
name|assert
argument_list|(
name|region_next_free_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
block|{
name|region_t
modifier|*
name|next
decl_stmt|;
name|next
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|reg
operator|)
index|[
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
index|]
expr_stmt|;
block|}
endif|#
directive|endif
name|assert
argument_list|(
name|reg
operator|!=
name|arena
operator|->
name|split
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|reg
operator|!=
name|arena
operator|->
name|frag
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size
operator|=
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
operator|)
operator|<=
name|bin_maxsize
condition|)
block|{
name|arena_bin_extract
argument_list|(
name|arena
argument_list|,
operator|(
name|size
operator|>>
name|opt_quantum_2pow
operator|)
operator|-
name|bin_shift
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RB_REMOVE
argument_list|(
name|region_tree_s
argument_list|,
operator|&
name|arena
operator|->
name|large_regions
argument_list|,
operator|&
name|reg
operator|->
name|next
operator|.
name|u
operator|.
name|l
operator|.
name|node
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|large
operator|.
name|curcached
operator|--
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Try to coalesce reg with its neighbors.  Return false if coalescing fails. */
end_comment

begin_function
specifier|static
name|bool
name|arena_coalesce
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|region_t
modifier|*
modifier|*
name|reg
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|bool
name|ret
decl_stmt|;
name|region_t
modifier|*
name|prev
decl_stmt|,
modifier|*
name|treg
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|nextnext
decl_stmt|;
name|size_t
name|tsize
decl_stmt|,
name|prev_size
decl_stmt|,
name|next_size
decl_stmt|;
name|ret
operator|=
name|false
expr_stmt|;
name|treg
operator|=
operator|*
name|reg
expr_stmt|;
comment|/* 	 * Keep track of the size while coalescing, then just set the size in 	 * the header/footer once at the end of coalescing. 	 */
name|assert
argument_list|(
name|size
operator|==
name|region_next_size_get
argument_list|(
operator|&
operator|(
operator|*
name|reg
operator|)
operator|->
name|sep
argument_list|)
argument_list|)
expr_stmt|;
name|tsize
operator|=
name|size
expr_stmt|;
name|next
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|treg
operator|)
index|[
name|tsize
index|]
expr_stmt|;
name|assert
argument_list|(
name|region_next_free_get
argument_list|(
operator|&
name|treg
operator|->
name|sep
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|region_prev_free_get
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|region_next_size_get
argument_list|(
operator|&
name|treg
operator|->
name|sep
argument_list|)
operator|==
name|next
operator|->
name|prev
operator|.
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|region_prev_free_get
argument_list|(
operator|&
name|treg
operator|->
name|sep
argument_list|)
condition|)
block|{
name|prev_size
operator|=
name|treg
operator|->
name|prev
operator|.
name|size
expr_stmt|;
name|prev
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|treg
operator|)
index|[
operator|-
name|prev_size
index|]
expr_stmt|;
name|assert
argument_list|(
name|region_next_free_get
argument_list|(
operator|&
name|prev
operator|->
name|sep
argument_list|)
argument_list|)
expr_stmt|;
name|arena_extract
argument_list|(
name|arena
argument_list|,
name|prev
argument_list|)
expr_stmt|;
name|tsize
operator|+=
name|prev_size
expr_stmt|;
name|treg
operator|=
name|prev
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|ncoalesce
operator|++
expr_stmt|;
endif|#
directive|endif
name|ret
operator|=
name|true
expr_stmt|;
block|}
name|assert
argument_list|(
name|region_prev_free_get
argument_list|(
operator|&
name|treg
operator|->
name|sep
argument_list|)
operator|==
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|region_next_free_get
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
condition|)
block|{
name|next_size
operator|=
name|region_next_size_get
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
expr_stmt|;
name|nextnext
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|next
operator|)
index|[
name|next_size
index|]
expr_stmt|;
name|assert
argument_list|(
name|region_prev_free_get
argument_list|(
operator|&
name|nextnext
operator|->
name|sep
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|region_next_size_get
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
operator|==
name|nextnext
operator|->
name|prev
operator|.
name|size
argument_list|)
expr_stmt|;
name|arena_extract
argument_list|(
name|arena
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|region_next_size_get
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
operator|==
name|nextnext
operator|->
name|prev
operator|.
name|size
argument_list|)
expr_stmt|;
name|tsize
operator|+=
name|next_size
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
if|if
condition|(
name|ret
operator|==
name|false
condition|)
name|arena
operator|->
name|stats
operator|.
name|ncoalesce
operator|++
expr_stmt|;
endif|#
directive|endif
name|ret
operator|=
name|true
expr_stmt|;
name|next
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|treg
operator|)
index|[
name|tsize
index|]
expr_stmt|;
block|}
name|assert
argument_list|(
name|region_next_free_get
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
operator|==
name|false
argument_list|)
expr_stmt|;
comment|/* Update header/footer. */
if|if
condition|(
name|ret
condition|)
block|{
name|region_next_size_set
argument_list|(
operator|&
name|treg
operator|->
name|sep
argument_list|,
name|tsize
argument_list|)
expr_stmt|;
name|next
operator|->
name|prev
operator|.
name|size
operator|=
name|tsize
expr_stmt|;
block|}
comment|/* 	 * Now that coalescing with adjacent free regions is done, we need to 	 * try to coalesce with "split" and "frag".  Those two regions are 	 * marked as allocated, which is why this takes special effort.  There 	 * are seven possible cases, but we want to make the (hopefully) common 	 * case of no coalescence fast, so the checks are optimized for that 	 * case.  The seven cases are: 	 * 	 *   /------\ 	 * 0 | treg | No coalescence needed.  Make this case fast. 	 *   \------/ 	 * 	 *   /------+------\ 	 * 1 | frag | treg | 	 *   \------+------/ 	 * 	 *   /------+------\ 	 * 2 | treg | frag | 	 *   \------+------/ 	 * 	 *   /-------+------\ 	 * 3 | split | treg | 	 *   \-------+------/ 	 * 	 *   /------+-------\ 	 * 4 | treg | split | 	 *   \------+-------/ 	 * 	 *   /------+------+-------\ 	 * 5 | frag | treg | split | 	 *   \------+------+-------/ 	 * 	 *   /-------+------+------\ 	 * 6 | split | treg | frag | 	 *   \-------+------+------/ 	 */
if|if
condition|(
name|arena
operator|->
name|split
operator|==
name|NULL
condition|)
block|{
comment|/* Cases 3-6 ruled out. */
block|}
elseif|else
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|next
operator|<
operator|(
name|uintptr_t
operator|)
name|arena
operator|->
name|split
condition|)
block|{
comment|/* Cases 3-6 ruled out. */
block|}
else|else
block|{
name|region_t
modifier|*
name|split_next
decl_stmt|;
name|size_t
name|split_size
decl_stmt|;
name|split_size
operator|=
name|region_next_size_get
argument_list|(
operator|&
name|arena
operator|->
name|split
operator|->
name|sep
argument_list|)
expr_stmt|;
name|split_next
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|arena
operator|->
name|split
operator|)
index|[
name|split_size
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|split_next
operator|<
operator|(
name|uintptr_t
operator|)
name|treg
condition|)
block|{
comment|/* Cases 3-6 ruled out. */
block|}
else|else
block|{
comment|/* 			 * Split is adjacent to treg.  Take the slow path and 			 * coalesce. 			 */
name|arena_coalesce_hard
argument_list|(
name|arena
argument_list|,
name|treg
argument_list|,
name|next
argument_list|,
name|tsize
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|treg
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
if|if
condition|(
name|ret
operator|==
name|false
condition|)
name|arena
operator|->
name|stats
operator|.
name|ncoalesce
operator|++
expr_stmt|;
endif|#
directive|endif
name|ret
operator|=
name|true
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
block|}
comment|/* If we get here, then cases 3-6 have been ruled out. */
if|if
condition|(
name|arena
operator|->
name|frag
operator|==
name|NULL
condition|)
block|{
comment|/* Cases 1-6 ruled out. */
block|}
elseif|else
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|next
operator|<
operator|(
name|uintptr_t
operator|)
name|arena
operator|->
name|frag
condition|)
block|{
comment|/* Cases 1-6 ruled out. */
block|}
else|else
block|{
name|region_t
modifier|*
name|frag_next
decl_stmt|;
name|size_t
name|frag_size
decl_stmt|;
name|frag_size
operator|=
name|region_next_size_get
argument_list|(
operator|&
name|arena
operator|->
name|frag
operator|->
name|sep
argument_list|)
expr_stmt|;
name|frag_next
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|arena
operator|->
name|frag
operator|)
index|[
name|frag_size
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|frag_next
operator|<
operator|(
name|uintptr_t
operator|)
name|treg
condition|)
block|{
comment|/* Cases 1-6 ruled out. */
block|}
else|else
block|{
comment|/* 			 * Frag is adjacent to treg.  Take the slow path and 			 * coalesce. 			 */
name|arena_coalesce_hard
argument_list|(
name|arena
argument_list|,
name|treg
argument_list|,
name|next
argument_list|,
name|tsize
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|treg
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
if|if
condition|(
name|ret
operator|==
name|false
condition|)
name|arena
operator|->
name|stats
operator|.
name|ncoalesce
operator|++
expr_stmt|;
endif|#
directive|endif
name|ret
operator|=
name|true
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
block|}
comment|/* If we get here, no coalescence with "split" or "frag" was needed. */
comment|/* Finish updating header. */
name|region_next_contig_unset
argument_list|(
operator|&
name|treg
operator|->
name|sep
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|region_next_free_get
argument_list|(
operator|&
name|treg
operator|->
name|sep
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|region_prev_free_get
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|region_prev_free_get
argument_list|(
operator|&
name|treg
operator|->
name|sep
argument_list|)
operator|==
name|false
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|region_next_free_get
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
operator|==
name|false
argument_list|)
expr_stmt|;
name|RETURN
label|:
if|if
condition|(
name|ret
condition|)
operator|*
name|reg
operator|=
name|treg
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * arena_coalesce() calls this function if it determines that a region needs to  * be coalesced with "split" and/or "frag".  */
end_comment

begin_function
specifier|static
name|void
name|arena_coalesce_hard
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|region_t
modifier|*
name|reg
parameter_list|,
name|region_t
modifier|*
name|next
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|split_adjacent
parameter_list|)
block|{
name|bool
name|frag_adjacent
decl_stmt|;
name|assert
argument_list|(
name|next
operator|==
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|reg
operator|)
index|[
name|size
index|]
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|region_next_free_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
operator|==
name|size
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|region_prev_free_get
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|next
operator|->
name|prev
operator|.
name|size
operator|==
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|split_adjacent
operator|==
name|false
condition|)
name|frag_adjacent
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|arena
operator|->
name|frag
operator|!=
name|NULL
condition|)
block|{
comment|/* Determine whether frag will be coalesced with. */
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|next
operator|<
operator|(
name|uintptr_t
operator|)
name|arena
operator|->
name|frag
condition|)
name|frag_adjacent
operator|=
name|false
expr_stmt|;
else|else
block|{
name|region_t
modifier|*
name|frag_next
decl_stmt|;
name|size_t
name|frag_size
decl_stmt|;
name|frag_size
operator|=
name|region_next_size_get
argument_list|(
operator|&
name|arena
operator|->
name|frag
operator|->
name|sep
argument_list|)
expr_stmt|;
name|frag_next
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|arena
operator|->
name|frag
operator|)
index|[
name|frag_size
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|frag_next
operator|<
operator|(
name|uintptr_t
operator|)
name|reg
condition|)
name|frag_adjacent
operator|=
name|false
expr_stmt|;
else|else
name|frag_adjacent
operator|=
name|true
expr_stmt|;
block|}
block|}
else|else
name|frag_adjacent
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|split_adjacent
operator|&&
name|frag_adjacent
condition|)
block|{
name|region_t
modifier|*
name|a
decl_stmt|;
name|size_t
name|a_size
decl_stmt|,
name|b_size
decl_stmt|;
comment|/* Coalesce all three regions. */
if|if
condition|(
name|arena
operator|->
name|frag
operator|==
name|next
condition|)
name|a
operator|=
name|arena
operator|->
name|split
expr_stmt|;
else|else
block|{
name|a
operator|=
name|arena
operator|->
name|frag
expr_stmt|;
name|arena
operator|->
name|split
operator|=
name|a
expr_stmt|;
block|}
name|arena
operator|->
name|frag
operator|=
name|NULL
expr_stmt|;
name|a_size
operator|=
name|region_next_size_get
argument_list|(
operator|&
name|a
operator|->
name|sep
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|a_size
operator|==
operator|(
name|uintptr_t
operator|)
name|reg
operator|-
operator|(
name|uintptr_t
operator|)
name|a
argument_list|)
expr_stmt|;
name|b_size
operator|=
name|region_next_size_get
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
expr_stmt|;
name|region_next_size_set
argument_list|(
operator|&
name|a
operator|->
name|sep
argument_list|,
name|a_size
operator|+
name|size
operator|+
name|b_size
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|region_next_free_get
argument_list|(
operator|&
name|a
operator|->
name|sep
argument_list|)
operator|==
name|false
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Coalesce two regions. */
if|if
condition|(
name|split_adjacent
condition|)
block|{
name|size
operator|+=
name|region_next_size_get
argument_list|(
operator|&
name|arena
operator|->
name|split
operator|->
name|sep
argument_list|)
expr_stmt|;
if|if
condition|(
name|arena
operator|->
name|split
operator|==
name|next
condition|)
block|{
comment|/* reg comes before split. */
name|region_next_size_set
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|region_next_free_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
argument_list|)
expr_stmt|;
name|region_next_free_unset
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
expr_stmt|;
name|arena
operator|->
name|split
operator|=
name|reg
expr_stmt|;
block|}
else|else
block|{
comment|/* reg comes after split. */
name|region_next_size_set
argument_list|(
operator|&
name|arena
operator|->
name|split
operator|->
name|sep
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|region_next_free_get
argument_list|(
operator|&
name|arena
operator|->
name|split
operator|->
name|sep
argument_list|)
operator|==
name|false
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|region_prev_free_get
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
argument_list|)
expr_stmt|;
name|region_prev_free_unset
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|assert
argument_list|(
name|frag_adjacent
argument_list|)
expr_stmt|;
name|size
operator|+=
name|region_next_size_get
argument_list|(
operator|&
name|arena
operator|->
name|frag
operator|->
name|sep
argument_list|)
expr_stmt|;
if|if
condition|(
name|arena
operator|->
name|frag
operator|==
name|next
condition|)
block|{
comment|/* reg comes before frag. */
name|region_next_size_set
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|region_next_free_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
argument_list|)
expr_stmt|;
name|region_next_free_unset
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
expr_stmt|;
name|arena
operator|->
name|frag
operator|=
name|reg
expr_stmt|;
block|}
else|else
block|{
comment|/* reg comes after frag. */
name|region_next_size_set
argument_list|(
operator|&
name|arena
operator|->
name|frag
operator|->
name|sep
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|region_next_free_get
argument_list|(
operator|&
name|arena
operator|->
name|frag
operator|->
name|sep
argument_list|)
operator|==
name|false
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|region_prev_free_get
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
argument_list|)
expr_stmt|;
name|region_prev_free_unset
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|arena_bin_append
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|unsigned
name|bin
parameter_list|,
name|region_t
modifier|*
name|reg
parameter_list|)
block|{
name|arena_bin_t
modifier|*
name|tbin
decl_stmt|;
name|assert
argument_list|(
name|bin
operator|<
name|NBINS
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
operator|>>
name|opt_quantum_2pow
operator|)
operator|>=
name|bin_shift
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
operator|==
operator|(
operator|(
name|bin
operator|+
name|bin_shift
operator|)
operator|<<
name|opt_quantum_2pow
operator|)
argument_list|)
expr_stmt|;
name|tbin
operator|=
operator|&
name|arena
operator|->
name|bins
index|[
name|bin
index|]
expr_stmt|;
if|if
condition|(
name|qr_next
argument_list|(
operator|&
name|tbin
operator|->
name|regions
argument_list|,
name|next
operator|.
name|u
operator|.
name|s
operator|.
name|link
argument_list|)
operator|==
operator|&
name|tbin
operator|->
name|regions
condition|)
name|arena_mask_set
argument_list|(
name|arena
argument_list|,
name|bin
argument_list|)
expr_stmt|;
name|qr_new
argument_list|(
name|reg
argument_list|,
name|next
operator|.
name|u
operator|.
name|s
operator|.
name|link
argument_list|)
expr_stmt|;
name|qr_before_insert
argument_list|(
operator|&
name|tbin
operator|->
name|regions
argument_list|,
name|reg
argument_list|,
name|next
operator|.
name|u
operator|.
name|s
operator|.
name|link
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|bins
index|[
name|bin
index|]
operator|.
name|nregions
operator|++
expr_stmt|;
if|if
condition|(
name|arena
operator|->
name|stats
operator|.
name|bins
index|[
name|bin
index|]
operator|.
name|nregions
operator|>
name|arena
operator|->
name|stats
operator|.
name|bins
index|[
name|bin
index|]
operator|.
name|highcached
condition|)
block|{
name|arena
operator|->
name|stats
operator|.
name|bins
index|[
name|bin
index|]
operator|.
name|highcached
operator|=
name|arena
operator|->
name|stats
operator|.
name|bins
index|[
name|bin
index|]
operator|.
name|nregions
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|arena_bin_push
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|unsigned
name|bin
parameter_list|,
name|region_t
modifier|*
name|reg
parameter_list|)
block|{
name|arena_bin_t
modifier|*
name|tbin
decl_stmt|;
name|assert
argument_list|(
name|bin
operator|<
name|NBINS
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
operator|>>
name|opt_quantum_2pow
operator|)
operator|>=
name|bin_shift
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
operator|==
operator|(
operator|(
name|bin
operator|+
name|bin_shift
operator|)
operator|<<
name|opt_quantum_2pow
operator|)
argument_list|)
expr_stmt|;
name|tbin
operator|=
operator|&
name|arena
operator|->
name|bins
index|[
name|bin
index|]
expr_stmt|;
if|if
condition|(
name|qr_next
argument_list|(
operator|&
name|tbin
operator|->
name|regions
argument_list|,
name|next
operator|.
name|u
operator|.
name|s
operator|.
name|link
argument_list|)
operator|==
operator|&
name|tbin
operator|->
name|regions
condition|)
name|arena_mask_set
argument_list|(
name|arena
argument_list|,
name|bin
argument_list|)
expr_stmt|;
name|region_next_contig_unset
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
expr_stmt|;
name|qr_new
argument_list|(
name|reg
argument_list|,
name|next
operator|.
name|u
operator|.
name|s
operator|.
name|link
argument_list|)
expr_stmt|;
name|qr_after_insert
argument_list|(
operator|&
name|tbin
operator|->
name|regions
argument_list|,
name|reg
argument_list|,
name|next
operator|.
name|u
operator|.
name|s
operator|.
name|link
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|bins
index|[
name|bin
index|]
operator|.
name|nregions
operator|++
expr_stmt|;
if|if
condition|(
name|arena
operator|->
name|stats
operator|.
name|bins
index|[
name|bin
index|]
operator|.
name|nregions
operator|>
name|arena
operator|->
name|stats
operator|.
name|bins
index|[
name|bin
index|]
operator|.
name|highcached
condition|)
block|{
name|arena
operator|->
name|stats
operator|.
name|bins
index|[
name|bin
index|]
operator|.
name|highcached
operator|=
name|arena
operator|->
name|stats
operator|.
name|bins
index|[
name|bin
index|]
operator|.
name|nregions
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|__inline
name|region_t
modifier|*
name|arena_bin_pop
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|unsigned
name|bin
parameter_list|)
block|{
name|region_t
modifier|*
name|ret
decl_stmt|;
name|arena_bin_t
modifier|*
name|tbin
decl_stmt|;
name|assert
argument_list|(
name|bin
operator|<
name|NBINS
argument_list|)
expr_stmt|;
name|tbin
operator|=
operator|&
name|arena
operator|->
name|bins
index|[
name|bin
index|]
expr_stmt|;
name|assert
argument_list|(
name|qr_next
argument_list|(
operator|&
name|tbin
operator|->
name|regions
argument_list|,
name|next
operator|.
name|u
operator|.
name|s
operator|.
name|link
argument_list|)
operator|!=
operator|&
name|tbin
operator|->
name|regions
argument_list|)
expr_stmt|;
name|ret
operator|=
name|qr_next
argument_list|(
operator|&
name|tbin
operator|->
name|regions
argument_list|,
name|next
operator|.
name|u
operator|.
name|s
operator|.
name|link
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|region_next_size_get
argument_list|(
operator|&
name|ret
operator|->
name|sep
argument_list|)
operator|==
operator|(
operator|(
name|bin
operator|+
name|bin_shift
operator|)
operator|<<
name|opt_quantum_2pow
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|region_next_free_get
argument_list|(
operator|&
name|ret
operator|->
name|sep
argument_list|)
operator|==
name|false
condition|)
block|{
comment|/* 		 * Use delayed regions in LIFO order, in order to increase 		 * locality of use, and thereby (hopefully) reduce 		 * fragmentation. 		 */
name|ret
operator|=
name|qr_prev
argument_list|(
operator|&
name|tbin
operator|->
name|regions
argument_list|,
name|next
operator|.
name|u
operator|.
name|s
operator|.
name|link
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|region_next_size_get
argument_list|(
operator|&
name|ret
operator|->
name|sep
argument_list|)
operator|==
operator|(
operator|(
name|bin
operator|+
name|bin_shift
operator|)
operator|<<
name|opt_quantum_2pow
operator|)
argument_list|)
expr_stmt|;
block|}
name|qr_remove
argument_list|(
name|ret
argument_list|,
name|next
operator|.
name|u
operator|.
name|s
operator|.
name|link
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|bins
index|[
name|bin
index|]
operator|.
name|nregions
operator|--
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|qr_next
argument_list|(
operator|&
name|tbin
operator|->
name|regions
argument_list|,
name|next
operator|.
name|u
operator|.
name|s
operator|.
name|link
argument_list|)
operator|==
operator|&
name|tbin
operator|->
name|regions
condition|)
name|arena_mask_unset
argument_list|(
name|arena
argument_list|,
name|bin
argument_list|)
expr_stmt|;
name|arena_delayed_extract
argument_list|(
name|arena
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|region_next_free_get
argument_list|(
operator|&
name|ret
operator|->
name|sep
argument_list|)
condition|)
block|{
name|region_t
modifier|*
name|next
decl_stmt|;
comment|/* Non-delayed region. */
name|region_next_free_unset
argument_list|(
operator|&
name|ret
operator|->
name|sep
argument_list|)
expr_stmt|;
name|next
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|ret
operator|)
index|[
operator|(
name|bin
operator|+
name|bin_shift
operator|)
operator|<<
name|opt_quantum_2pow
index|]
expr_stmt|;
name|assert
argument_list|(
name|next
operator|->
name|prev
operator|.
name|size
operator|==
name|region_next_size_get
argument_list|(
operator|&
name|ret
operator|->
name|sep
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|region_prev_free_get
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
argument_list|)
expr_stmt|;
name|region_prev_free_unset
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_large_insert
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|region_t
modifier|*
name|reg
parameter_list|,
name|bool
name|lru
parameter_list|)
block|{
name|assert
argument_list|(
name|region_next_free_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
block|{
name|region_t
modifier|*
name|next
decl_stmt|;
name|next
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|reg
operator|)
index|[
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
index|]
expr_stmt|;
name|assert
argument_list|(
name|region_prev_free_get
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|next
operator|->
name|prev
operator|.
name|size
operator|==
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Coalescing should have already been done. */
name|assert
argument_list|(
name|arena_coalesce
argument_list|(
name|arena
argument_list|,
operator|&
name|reg
argument_list|,
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
argument_list|)
operator|==
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
operator|<
name|chunk_size
operator|-
operator|(
name|CHUNK_REG_OFFSET
operator|+
name|offsetof
argument_list|(
name|region_t
argument_list|,
name|next
argument_list|)
operator|)
condition|)
block|{
comment|/* 		 * Make sure not to cache a large region with the nextContig 		 * flag set, in order to simplify the logic that determines 		 * whether a region needs to be extracted from "delayed". 		 */
name|region_next_contig_unset
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
expr_stmt|;
comment|/* Store the region in the large_regions tree. */
name|reg
operator|->
name|next
operator|.
name|u
operator|.
name|l
operator|.
name|node
operator|.
name|reg
operator|=
name|reg
expr_stmt|;
name|reg
operator|->
name|next
operator|.
name|u
operator|.
name|l
operator|.
name|lru
operator|=
name|lru
expr_stmt|;
name|RB_INSERT
argument_list|(
name|region_tree_s
argument_list|,
operator|&
name|arena
operator|->
name|large_regions
argument_list|,
operator|&
name|reg
operator|->
name|next
operator|.
name|u
operator|.
name|l
operator|.
name|node
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|large
operator|.
name|curcached
operator|++
expr_stmt|;
if|if
condition|(
name|arena
operator|->
name|stats
operator|.
name|large
operator|.
name|curcached
operator|>
name|arena
operator|->
name|stats
operator|.
name|large
operator|.
name|highcached
condition|)
block|{
name|arena
operator|->
name|stats
operator|.
name|large
operator|.
name|highcached
operator|=
name|arena
operator|->
name|stats
operator|.
name|large
operator|.
name|curcached
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
block|{
name|chunk_node_t
modifier|*
name|node
decl_stmt|;
comment|/* 		 * This region now spans an entire chunk. Deallocate the chunk. 		 * 		 * Note that it is possible for allocation of a large region 		 * from a pristine chunk, followed by deallocation of the 		 * region, can cause the chunk to immediately be unmapped. 		 * This isn't ideal, but 1) such scenarios seem unlikely, and 		 * 2) delaying coalescence for large regions could cause 		 * excessive fragmentation for common scenarios. 		 */
name|node
operator|=
operator|(
name|chunk_node_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|RB_REMOVE
argument_list|(
name|chunk_tree_s
argument_list|,
operator|&
name|arena
operator|->
name|chunks
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|arena
operator|->
name|nchunks
operator|--
expr_stmt|;
name|assert
argument_list|(
name|node
operator|->
name|chunk
operator|==
operator|(
name|chunk_node_t
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
name|chunk_dealloc
argument_list|(
name|node
operator|->
name|chunk
argument_list|,
name|chunk_size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|arena_large_cache
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|region_t
modifier|*
name|reg
parameter_list|,
name|bool
name|lru
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
comment|/* Try to coalesce before storing this region anywhere. */
name|size
operator|=
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
expr_stmt|;
if|if
condition|(
name|arena_coalesce
argument_list|(
name|arena
argument_list|,
operator|&
name|reg
argument_list|,
name|size
argument_list|)
condition|)
block|{
if|if
condition|(
name|reg
operator|==
name|NULL
condition|)
block|{
comment|/* Region no longer needs cached. */
return|return;
block|}
name|size
operator|=
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
expr_stmt|;
block|}
name|arena_large_insert
argument_list|(
name|arena
argument_list|,
name|reg
argument_list|,
name|lru
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|arena_lru_cache
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|region_t
modifier|*
name|reg
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
name|assert
argument_list|(
name|region_next_free_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
block|{
name|region_t
modifier|*
name|next
decl_stmt|;
name|next
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|reg
operator|)
index|[
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
index|]
expr_stmt|;
name|assert
argument_list|(
name|region_prev_free_get
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|next
operator|->
name|prev
operator|.
name|size
operator|==
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|assert
argument_list|(
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
operator|%
name|quantum
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
operator|>=
name|QUANTUM_CEILING
argument_list|(
sizeof|sizeof
argument_list|(
name|region_small_sizer_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_coalesce
argument_list|(
name|arena
argument_list|,
operator|&
name|reg
argument_list|,
name|size
argument_list|)
operator|==
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
name|bin_maxsize
condition|)
block|{
name|arena_bin_append
argument_list|(
name|arena
argument_list|,
operator|(
name|size
operator|>>
name|opt_quantum_2pow
operator|)
operator|-
name|bin_shift
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
name|arena_large_cache
argument_list|(
name|arena
argument_list|,
name|reg
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|arena_mru_cache
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|region_t
modifier|*
name|reg
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|assert
argument_list|(
name|region_next_free_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
block|{
name|region_t
modifier|*
name|next
decl_stmt|;
name|next
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|reg
operator|)
index|[
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
index|]
expr_stmt|;
name|assert
argument_list|(
name|region_prev_free_get
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|next
operator|->
name|prev
operator|.
name|size
operator|==
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|assert
argument_list|(
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
operator|%
name|quantum
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
operator|>=
name|QUANTUM_CEILING
argument_list|(
sizeof|sizeof
argument_list|(
name|region_small_sizer_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|==
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena_coalesce
argument_list|(
name|arena
argument_list|,
operator|&
name|reg
argument_list|,
name|size
argument_list|)
operator|==
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
name|bin_maxsize
condition|)
block|{
name|arena_bin_push
argument_list|(
name|arena
argument_list|,
operator|(
name|size
operator|>>
name|opt_quantum_2pow
operator|)
operator|-
name|bin_shift
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
name|arena_large_cache
argument_list|(
name|arena
argument_list|,
name|reg
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|arena_undelay
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|uint32_t
name|slot
parameter_list|)
block|{
name|region_t
modifier|*
name|reg
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|assert
argument_list|(
name|slot
operator|==
name|arena
operator|->
name|next_delayed
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena
operator|->
name|delayed
index|[
name|slot
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Try to coalesce reg. */
name|reg
operator|=
name|arena
operator|->
name|delayed
index|[
name|slot
index|]
expr_stmt|;
name|size
operator|=
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|region_next_contig_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|reg
operator|->
name|next
operator|.
name|u
operator|.
name|s
operator|.
name|slot
operator|==
name|slot
argument_list|)
expr_stmt|;
name|arena_bin_extract
argument_list|(
name|arena
argument_list|,
operator|(
name|size
operator|>>
name|opt_quantum_2pow
operator|)
operator|-
name|bin_shift
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|arena
operator|->
name|delayed
index|[
name|slot
index|]
operator|=
name|NULL
expr_stmt|;
name|next
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|reg
operator|)
index|[
name|size
index|]
expr_stmt|;
name|region_next_free_set
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
expr_stmt|;
name|region_prev_free_set
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
expr_stmt|;
name|next
operator|->
name|prev
operator|.
name|size
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|arena_coalesce
argument_list|(
name|arena
argument_list|,
operator|&
name|reg
argument_list|,
name|size
argument_list|)
operator|==
name|false
condition|)
block|{
comment|/* Coalescing failed.  Cache this region. */
name|arena_mru_cache
argument_list|(
name|arena
argument_list|,
name|reg
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Coalescing succeeded. */
if|if
condition|(
name|reg
operator|==
name|NULL
condition|)
block|{
comment|/* Region no longer needs undelayed. */
return|return;
block|}
if|if
condition|(
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
operator|<
name|chunk_size
operator|-
operator|(
name|CHUNK_REG_OFFSET
operator|+
name|offsetof
argument_list|(
name|region_t
argument_list|,
name|next
argument_list|)
operator|)
condition|)
block|{
comment|/* 			 * Insert coalesced region into appropriate bin (or 			 * largeRegions). 			 */
name|arena_lru_cache
argument_list|(
name|arena
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chunk_node_t
modifier|*
name|node
decl_stmt|;
comment|/* 			 * This region now spans an entire chunk.  Deallocate 			 * the chunk. 			 */
name|node
operator|=
operator|(
name|chunk_node_t
operator|*
operator|)
name|CHUNK_ADDR2BASE
argument_list|(
name|reg
argument_list|)
expr_stmt|;
name|RB_REMOVE
argument_list|(
name|chunk_tree_s
argument_list|,
operator|&
name|arena
operator|->
name|chunks
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|arena
operator|->
name|nchunks
operator|--
expr_stmt|;
name|assert
argument_list|(
name|node
operator|->
name|chunk
operator|==
operator|(
name|chunk_node_t
operator|*
operator|)
name|node
argument_list|)
expr_stmt|;
name|chunk_dealloc
argument_list|(
name|node
operator|->
name|chunk
argument_list|,
name|chunk_size
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|arena_delay_cache
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|region_t
modifier|*
name|reg
parameter_list|)
block|{
name|region_t
modifier|*
name|next
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|assert
argument_list|(
name|region_next_free_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
operator|==
name|false
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
operator|%
name|quantum
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
operator|>=
name|QUANTUM_CEILING
argument_list|(
sizeof|sizeof
argument_list|(
name|region_small_sizer_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
expr_stmt|;
name|next
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|reg
operator|)
index|[
name|size
index|]
expr_stmt|;
name|assert
argument_list|(
name|region_prev_free_get
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
operator|==
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
name|bin_maxsize
condition|)
block|{
if|if
condition|(
name|region_next_contig_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
condition|)
block|{
name|uint32_t
name|slot
decl_stmt|;
comment|/* Insert into delayed. */
comment|/* Clear a slot, then put reg in it. */
name|slot
operator|=
name|arena
operator|->
name|next_delayed
expr_stmt|;
if|if
condition|(
name|arena
operator|->
name|delayed
index|[
name|slot
index|]
operator|!=
name|NULL
condition|)
name|arena_undelay
argument_list|(
name|arena
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|slot
operator|==
name|arena
operator|->
name|next_delayed
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena
operator|->
name|delayed
index|[
name|slot
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|reg
operator|->
name|next
operator|.
name|u
operator|.
name|s
operator|.
name|slot
operator|=
name|slot
expr_stmt|;
name|arena
operator|->
name|delayed
index|[
name|slot
index|]
operator|=
name|reg
expr_stmt|;
comment|/* Update next_delayed. */
name|slot
operator|++
expr_stmt|;
name|slot
operator|&=
operator|(
name|opt_ndelay
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Handle wrap-around. */
name|arena
operator|->
name|next_delayed
operator|=
name|slot
expr_stmt|;
name|arena_bin_append
argument_list|(
name|arena
argument_list|,
operator|(
name|size
operator|>>
name|opt_quantum_2pow
operator|)
operator|-
name|bin_shift
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * This region was a fragment when it was allocated, so 			 * don't delay coalescence for it. 			 */
name|region_next_free_set
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
expr_stmt|;
name|region_prev_free_set
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
expr_stmt|;
name|next
operator|->
name|prev
operator|.
name|size
operator|=
name|size
expr_stmt|;
if|if
condition|(
name|arena_coalesce
argument_list|(
name|arena
argument_list|,
operator|&
name|reg
argument_list|,
name|size
argument_list|)
condition|)
block|{
comment|/* Coalescing succeeded. */
if|if
condition|(
name|reg
operator|==
name|NULL
condition|)
block|{
comment|/* Region no longer needs cached. */
return|return;
block|}
name|size
operator|=
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
expr_stmt|;
block|}
name|arena_mru_cache
argument_list|(
name|arena
argument_list|,
name|reg
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|region_next_free_set
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
expr_stmt|;
name|region_prev_free_set
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
expr_stmt|;
name|region_next_contig_unset
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
expr_stmt|;
name|next
operator|->
name|prev
operator|.
name|size
operator|=
name|size
expr_stmt|;
name|arena_large_cache
argument_list|(
name|arena
argument_list|,
name|reg
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|region_t
modifier|*
name|arena_frag_reg_alloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|fit
parameter_list|)
block|{
name|region_t
modifier|*
name|ret
decl_stmt|;
name|size_t
name|total_size
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
init|=
literal|0
comment|/* for assert() below. */
endif|#
directive|endif
decl_stmt|;
name|bool
name|refill
decl_stmt|;
comment|/*  	 * Clear frag if it is too small to carve a maximally sized small 	 * region from.  	 */
if|if
condition|(
name|arena
operator|->
name|frag
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|total_size
operator|=
name|region_next_size_get
argument_list|(
operator|&
name|arena
operator|->
name|frag
operator|->
name|sep
argument_list|)
operator|)
operator|<
name|size
operator|&&
name|size
operator|<=
name|bin_maxsize
condition|)
block|{
name|region_t
modifier|*
name|reg
decl_stmt|;
name|reg
operator|=
name|arena
operator|->
name|frag
expr_stmt|;
name|region_next_contig_set
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
expr_stmt|;
name|arena
operator|->
name|frag
operator|=
name|NULL
expr_stmt|;
name|arena_delay_cache
argument_list|(
name|arena
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|refill
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * No need to refill.  Note that total_size was set 			 * above. 			 */
name|refill
operator|=
name|false
expr_stmt|;
block|}
block|}
else|else
name|refill
operator|=
name|true
expr_stmt|;
comment|/* 	 * Try to fill frag if it's empty.  Frag needs to be marked as 	 * allocated. 	 */
if|if
condition|(
name|refill
condition|)
block|{
name|region_node_t
modifier|*
name|node
decl_stmt|;
name|node
operator|=
name|RB_MIN
argument_list|(
name|region_tree_s
argument_list|,
operator|&
name|arena
operator|->
name|large_regions
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
block|{
name|region_t
modifier|*
name|frag
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|RB_REMOVE
argument_list|(
name|region_tree_s
argument_list|,
operator|&
name|arena
operator|->
name|large_regions
argument_list|,
name|node
argument_list|)
expr_stmt|;
name|frag
operator|=
name|node
operator|->
name|reg
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|frag
operator|.
name|ncached
operator|++
expr_stmt|;
endif|#
directive|endif
name|assert
argument_list|(
name|region_next_free_get
argument_list|(
operator|&
name|frag
operator|->
name|sep
argument_list|)
argument_list|)
expr_stmt|;
name|region_next_free_unset
argument_list|(
operator|&
name|frag
operator|->
name|sep
argument_list|)
expr_stmt|;
name|total_size
operator|=
name|region_next_size_get
argument_list|(
operator|&
name|frag
operator|->
name|sep
argument_list|)
expr_stmt|;
name|next
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|frag
operator|)
index|[
name|total_size
index|]
expr_stmt|;
name|assert
argument_list|(
name|region_prev_free_get
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
argument_list|)
expr_stmt|;
name|region_prev_free_unset
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
expr_stmt|;
name|arena
operator|->
name|frag
operator|=
name|frag
expr_stmt|;
block|}
else|else
block|{
name|unsigned
name|bin
decl_stmt|;
comment|/* Look in bins for a large enough region.  */
if|if
condition|(
operator|(
name|bin
operator|=
name|arena_bins_search
argument_list|(
name|arena
argument_list|,
name|size
argument_list|)
operator|)
operator|!=
name|UINT_MAX
condition|)
block|{
comment|/* Use the smallest available region. */
name|arena
operator|->
name|frag
operator|=
name|arena_bin_pop
argument_list|(
name|arena
argument_list|,
name|bin
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|frag
operator|.
name|ncached
operator|++
expr_stmt|;
endif|#
directive|endif
name|total_size
operator|=
name|region_next_size_get
argument_list|(
operator|&
name|arena
operator|->
name|frag
operator|->
name|sep
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|total_size
operator|>=
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Unable to fill frag. */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
block|}
name|assert
argument_list|(
name|arena
operator|->
name|frag
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* total_size has been set in all possible paths that lead to here. */
name|assert
argument_list|(
name|total_size
operator|!=
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|frag
operator|.
name|nrequests
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|total_size
operator|<
name|size
condition|)
block|{
comment|/*  		 * Frag isn't large enough to service this request.  Note that 		 * this is only possible for a large request, since the refill 		 * code always makes sure to refill frag if it's too small to 		 * service a current small request. 		 */
name|assert
argument_list|(
name|size
operator|>
name|bin_maxsize
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|fit
condition|)
block|{
comment|/* 		 * Use frag, but try to use the beginning for smaller regions, 		 * and the end for larger regions.  This reduces fragmentation 		 * in some pathological use cases.  It tends to group 		 * short-lived (smaller) regions, which increases the 		 * effectiveness of coalescing. 		 */
name|assert
argument_list|(
name|size
operator|%
name|quantum
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_size
operator|-
name|size
operator|>=
name|QUANTUM_CEILING
argument_list|(
sizeof|sizeof
argument_list|(
name|region_small_sizer_t
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|size
operator|<=
name|bin_maxsize
condition|)
block|{
name|region_t
modifier|*
name|next
decl_stmt|;
comment|/* Carve space from the beginning of frag. */
comment|/* ret. */
name|ret
operator|=
name|arena
operator|->
name|frag
expr_stmt|;
name|region_next_size_set
argument_list|(
operator|&
name|ret
operator|->
name|sep
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|region_next_free_get
argument_list|(
operator|&
name|ret
operator|->
name|sep
argument_list|)
operator|==
name|false
argument_list|)
expr_stmt|;
comment|/* next. */
name|next
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|ret
operator|)
index|[
name|size
index|]
expr_stmt|;
name|region_next_size_set
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|,
name|total_size
operator|-
name|size
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|>=
name|QUANTUM_CEILING
argument_list|(
sizeof|sizeof
argument_list|(
name|region_small_sizer_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|region_prev_free_unset
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
expr_stmt|;
name|region_next_free_unset
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
expr_stmt|;
comment|/* Update frag. */
name|arena
operator|->
name|frag
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
name|region_t
modifier|*
name|prev
decl_stmt|;
name|size_t
name|prev_size
decl_stmt|;
comment|/* Carve space from the end of frag. */
comment|/* prev. */
name|prev_size
operator|=
name|total_size
operator|-
name|size
expr_stmt|;
name|prev
operator|=
name|arena
operator|->
name|frag
expr_stmt|;
name|region_next_size_set
argument_list|(
operator|&
name|prev
operator|->
name|sep
argument_list|,
name|prev_size
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|prev_size
operator|>=
name|QUANTUM_CEILING
argument_list|(
sizeof|sizeof
argument_list|(
name|region_small_sizer_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|region_next_free_get
argument_list|(
operator|&
name|prev
operator|->
name|sep
argument_list|)
operator|==
name|false
argument_list|)
expr_stmt|;
comment|/* ret. */
name|ret
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|prev
operator|)
index|[
name|prev_size
index|]
expr_stmt|;
name|region_next_size_set
argument_list|(
operator|&
name|ret
operator|->
name|sep
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|region_prev_free_unset
argument_list|(
operator|&
name|ret
operator|->
name|sep
argument_list|)
expr_stmt|;
name|region_next_free_unset
argument_list|(
operator|&
name|ret
operator|->
name|sep
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
block|{
name|region_t
modifier|*
name|next
decl_stmt|;
comment|/* next. */
name|next
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|ret
operator|)
index|[
name|region_next_size_get
argument_list|(
operator|&
name|ret
operator|->
name|sep
argument_list|)
index|]
expr_stmt|;
name|assert
argument_list|(
name|region_prev_free_get
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
operator|==
name|false
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|nsplit
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* 			 * Frag is close enough to the right size that there 			 * isn't enough room to create a neighboring region. 			 */
comment|/* ret. */
name|ret
operator|=
name|arena
operator|->
name|frag
expr_stmt|;
name|arena
operator|->
name|frag
operator|=
name|NULL
expr_stmt|;
name|assert
argument_list|(
name|region_next_free_get
argument_list|(
operator|&
name|ret
operator|->
name|sep
argument_list|)
operator|==
name|false
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
block|{
name|region_t
modifier|*
name|next
decl_stmt|;
comment|/* next. */
name|next
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|ret
operator|)
index|[
name|total_size
index|]
expr_stmt|;
name|assert
argument_list|(
name|region_prev_free_get
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
operator|==
name|false
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|frag
operator|.
name|nserviced
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* Don't fit to the allocation size. */
comment|/* ret. */
name|ret
operator|=
name|arena
operator|->
name|frag
expr_stmt|;
name|arena
operator|->
name|frag
operator|=
name|NULL
expr_stmt|;
name|assert
argument_list|(
name|region_next_free_get
argument_list|(
operator|&
name|ret
operator|->
name|sep
argument_list|)
operator|==
name|false
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
block|{
name|region_t
modifier|*
name|next
decl_stmt|;
comment|/* next. */
name|next
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|ret
operator|)
index|[
name|total_size
index|]
expr_stmt|;
name|assert
argument_list|(
name|region_prev_free_get
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
operator|==
name|false
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|region_next_contig_set
argument_list|(
operator|&
name|ret
operator|->
name|sep
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|region_t
modifier|*
name|arena_split_reg_alloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|fit
parameter_list|)
block|{
name|region_t
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|arena
operator|->
name|split
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|split
operator|.
name|nrequests
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|region_next_size_get
argument_list|(
operator|&
name|arena
operator|->
name|split
operator|->
name|sep
argument_list|)
operator|>=
name|size
condition|)
block|{
if|if
condition|(
name|fit
condition|)
block|{
name|size_t
name|total_size
decl_stmt|;
comment|/* 				 * Use split, but try to use the beginning for 				 * smaller regions, and the end for larger 				 * regions.  This reduces fragmentation in some 				 * pathological use cases.  It tends to group 				 * short-lived (smaller) regions, which 				 * increases the effectiveness of coalescing. 				 */
name|total_size
operator|=
name|region_next_size_get
argument_list|(
operator|&
name|arena
operator|->
name|split
operator|->
name|sep
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|%
name|quantum
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|total_size
operator|-
name|size
operator|>=
name|QUANTUM_CEILING
argument_list|(
sizeof|sizeof
argument_list|(
name|region_small_sizer_t
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|size
operator|<=
name|bin_maxsize
condition|)
block|{
name|region_t
modifier|*
name|next
decl_stmt|;
comment|/* 						 * Carve space from the 						 * beginning of split. 						 */
comment|/* ret. */
name|ret
operator|=
name|arena
operator|->
name|split
expr_stmt|;
name|region_next_size_set
argument_list|(
operator|&
name|ret
operator|->
name|sep
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|region_next_free_get
argument_list|(
operator|&
name|ret
operator|->
name|sep
argument_list|)
operator|==
name|false
argument_list|)
expr_stmt|;
comment|/* next. */
name|next
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|ret
operator|)
index|[
name|size
index|]
expr_stmt|;
name|region_next_size_set
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|,
name|total_size
operator|-
name|size
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|>=
name|QUANTUM_CEILING
argument_list|(
sizeof|sizeof
argument_list|(
name|region_small_sizer_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|region_prev_free_unset
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
expr_stmt|;
name|region_next_free_unset
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
expr_stmt|;
comment|/* Update split. */
name|arena
operator|->
name|split
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
name|region_t
modifier|*
name|prev
decl_stmt|;
name|size_t
name|prev_size
decl_stmt|;
comment|/* 						 * Carve space from the end of 						 * split. 						 */
comment|/* prev. */
name|prev_size
operator|=
name|total_size
operator|-
name|size
expr_stmt|;
name|prev
operator|=
name|arena
operator|->
name|split
expr_stmt|;
name|region_next_size_set
argument_list|(
operator|&
name|prev
operator|->
name|sep
argument_list|,
name|prev_size
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|prev_size
operator|>=
name|QUANTUM_CEILING
argument_list|(
sizeof|sizeof
argument_list|(
name|region_small_sizer_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|region_next_free_get
argument_list|(
operator|&
name|prev
operator|->
name|sep
argument_list|)
operator|==
name|false
argument_list|)
expr_stmt|;
comment|/* ret. */
name|ret
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|prev
operator|)
index|[
name|prev_size
index|]
expr_stmt|;
name|region_next_size_set
argument_list|(
operator|&
name|ret
operator|->
name|sep
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|region_prev_free_unset
argument_list|(
operator|&
name|ret
operator|->
name|sep
argument_list|)
expr_stmt|;
name|region_next_free_unset
argument_list|(
operator|&
name|ret
operator|->
name|sep
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
block|{
name|region_t
modifier|*
name|next
decl_stmt|;
comment|/* next. */
name|next
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|ret
operator|)
index|[
name|region_next_size_get
argument_list|(
operator|&
name|ret
operator|->
name|sep
argument_list|)
index|]
expr_stmt|;
name|assert
argument_list|(
name|region_prev_free_get
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
operator|==
name|false
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|nsplit
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* 					 * split is close enough to the right 					 * size that there isn't enough room to 					 * create a neighboring region. 					 */
comment|/* ret. */
name|ret
operator|=
name|arena
operator|->
name|split
expr_stmt|;
name|arena
operator|->
name|split
operator|=
name|NULL
expr_stmt|;
name|assert
argument_list|(
name|region_next_free_get
argument_list|(
operator|&
name|ret
operator|->
name|sep
argument_list|)
operator|==
name|false
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
block|{
name|region_t
modifier|*
name|next
decl_stmt|;
comment|/* next. */
name|next
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|ret
operator|)
index|[
name|region_next_size_get
argument_list|(
operator|&
name|ret
operator|->
name|sep
argument_list|)
index|]
expr_stmt|;
name|assert
argument_list|(
name|region_prev_free_get
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
operator|==
name|false
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|split
operator|.
name|nserviced
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* Don't fit to the allocation size. */
comment|/* ret. */
name|ret
operator|=
name|arena
operator|->
name|split
expr_stmt|;
name|arena
operator|->
name|split
operator|=
name|NULL
expr_stmt|;
name|assert
argument_list|(
name|region_next_free_get
argument_list|(
operator|&
name|ret
operator|->
name|sep
argument_list|)
operator|==
name|false
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
block|{
name|region_t
modifier|*
name|next
decl_stmt|;
comment|/* next. */
name|next
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|ret
operator|)
index|[
name|region_next_size_get
argument_list|(
operator|&
name|ret
operator|->
name|sep
argument_list|)
index|]
expr_stmt|;
name|assert
argument_list|(
name|region_prev_free_get
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
operator|==
name|false
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|region_next_contig_set
argument_list|(
operator|&
name|ret
operator|->
name|sep
argument_list|)
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
elseif|else
if|if
condition|(
name|size
operator|<=
name|bin_maxsize
condition|)
block|{
name|region_t
modifier|*
name|reg
decl_stmt|;
comment|/* 			 * The split region is too small to service a small 			 * request.  Clear split. 			 */
name|reg
operator|=
name|arena
operator|->
name|split
expr_stmt|;
name|region_next_contig_set
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
expr_stmt|;
name|arena
operator|->
name|split
operator|=
name|NULL
expr_stmt|;
name|arena_delay_cache
argument_list|(
name|arena
argument_list|,
name|reg
argument_list|)
expr_stmt|;
block|}
block|}
name|ret
operator|=
name|NULL
expr_stmt|;
name|RETURN
label|:
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Split reg if necessary.  The region must be overly large enough to be able  * to contain a trailing region.  */
end_comment

begin_function
specifier|static
name|void
name|arena_reg_fit
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|,
name|region_t
modifier|*
name|reg
parameter_list|,
name|bool
name|restore_split
parameter_list|)
block|{
name|assert
argument_list|(
name|QUANTUM_CEILING
argument_list|(
name|size
argument_list|)
operator|==
name|size
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|region_next_free_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
operator|>=
name|size
operator|+
name|QUANTUM_CEILING
argument_list|(
sizeof|sizeof
argument_list|(
name|region_small_sizer_t
argument_list|)
argument_list|)
condition|)
block|{
name|size_t
name|total_size
decl_stmt|;
name|region_t
modifier|*
name|next
decl_stmt|;
name|total_size
operator|=
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
expr_stmt|;
name|region_next_size_set
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|next
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|reg
operator|)
index|[
name|size
index|]
expr_stmt|;
name|region_next_size_set
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|,
name|total_size
operator|-
name|size
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|region_next_size_get
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
operator|>=
name|QUANTUM_CEILING
argument_list|(
sizeof|sizeof
argument_list|(
name|region_small_sizer_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|region_prev_free_unset
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
expr_stmt|;
if|if
condition|(
name|restore_split
condition|)
block|{
comment|/* Restore what's left to "split". */
name|region_next_free_unset
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
expr_stmt|;
name|arena
operator|->
name|split
operator|=
name|next
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|arena
operator|->
name|frag
operator|==
name|NULL
operator|&&
name|total_size
operator|-
name|size
operator|>
name|bin_maxsize
condition|)
block|{
comment|/* This region is large enough to use for "frag". */
name|region_next_free_unset
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
expr_stmt|;
name|arena
operator|->
name|frag
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
name|region_t
modifier|*
name|nextnext
decl_stmt|;
name|size_t
name|next_size
decl_stmt|;
name|region_next_free_set
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|region_next_size_get
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
operator|==
name|total_size
operator|-
name|size
argument_list|)
expr_stmt|;
name|next_size
operator|=
name|total_size
operator|-
name|size
expr_stmt|;
name|nextnext
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|next
operator|)
index|[
name|next_size
index|]
expr_stmt|;
name|nextnext
operator|->
name|prev
operator|.
name|size
operator|=
name|next_size
expr_stmt|;
name|assert
argument_list|(
name|region_prev_free_get
argument_list|(
operator|&
name|nextnext
operator|->
name|sep
argument_list|)
operator|==
name|false
argument_list|)
expr_stmt|;
name|region_prev_free_set
argument_list|(
operator|&
name|nextnext
operator|->
name|sep
argument_list|)
expr_stmt|;
if|if
condition|(
name|arena_coalesce
argument_list|(
name|arena
argument_list|,
operator|&
name|next
argument_list|,
name|next_size
argument_list|)
condition|)
block|{
if|if
condition|(
name|next
operator|!=
name|NULL
condition|)
block|{
name|next_size
operator|=
name|region_next_size_get
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
expr_stmt|;
name|arena_mru_cache
argument_list|(
name|arena
argument_list|,
name|next
argument_list|,
name|next_size
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|arena_mru_cache
argument_list|(
name|arena
argument_list|,
name|next
argument_list|,
name|next_size
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|nsplit
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|region_t
modifier|*
name|arena_bin_reg_alloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|fit
parameter_list|)
block|{
name|region_t
modifier|*
name|ret
decl_stmt|,
modifier|*
name|header
decl_stmt|;
name|unsigned
name|bin
decl_stmt|;
comment|/* 	 * Look for an exact fit in bins (region cached in smallest possible 	 * bin). 	 */
name|bin
operator|=
operator|(
name|size
operator|>>
name|opt_quantum_2pow
operator|)
operator|-
name|bin_shift
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|bins
index|[
name|bin
index|]
operator|.
name|nrequests
operator|++
expr_stmt|;
endif|#
directive|endif
name|header
operator|=
operator|&
name|arena
operator|->
name|bins
index|[
name|bin
index|]
operator|.
name|regions
expr_stmt|;
if|if
condition|(
name|qr_next
argument_list|(
name|header
argument_list|,
name|next
operator|.
name|u
operator|.
name|s
operator|.
name|link
argument_list|)
operator|!=
name|header
condition|)
block|{
comment|/* Exact fit. */
name|ret
operator|=
name|arena_bin_pop
argument_list|(
name|arena
argument_list|,
name|bin
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|region_next_size_get
argument_list|(
operator|&
name|ret
operator|->
name|sep
argument_list|)
operator|>=
name|size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|bins
index|[
name|bin
index|]
operator|.
name|nfit
operator|++
expr_stmt|;
endif|#
directive|endif
goto|goto
name|RETURN
goto|;
block|}
comment|/* Look at frag to see whether it's large enough. */
name|ret
operator|=
name|arena_frag_reg_alloc
argument_list|(
name|arena
argument_list|,
name|size
argument_list|,
name|fit
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
goto|goto
name|RETURN
goto|;
name|ret
operator|=
name|NULL
expr_stmt|;
name|RETURN
label|:
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Look in large_regions for a large enough region. */
end_comment

begin_function
specifier|static
name|region_t
modifier|*
name|arena_large_reg_alloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|fit
parameter_list|)
block|{
name|region_t
modifier|*
name|ret
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|region_node_t
modifier|*
name|node
decl_stmt|;
name|region_t
name|key
decl_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|large
operator|.
name|nrequests
operator|++
expr_stmt|;
endif|#
directive|endif
name|key
operator|.
name|next
operator|.
name|u
operator|.
name|l
operator|.
name|node
operator|.
name|reg
operator|=
operator|&
name|key
expr_stmt|;
name|key
operator|.
name|next
operator|.
name|u
operator|.
name|l
operator|.
name|lru
operator|=
name|true
expr_stmt|;
name|region_next_size_set
argument_list|(
operator|&
name|key
operator|.
name|sep
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|node
operator|=
name|RB_NFIND
argument_list|(
name|region_tree_s
argument_list|,
operator|&
name|arena
operator|->
name|large_regions
argument_list|,
operator|&
name|key
operator|.
name|next
operator|.
name|u
operator|.
name|l
operator|.
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
comment|/* Cached large region found. */
name|ret
operator|=
name|node
operator|->
name|reg
expr_stmt|;
name|assert
argument_list|(
name|region_next_free_get
argument_list|(
operator|&
name|ret
operator|->
name|sep
argument_list|)
argument_list|)
expr_stmt|;
name|RB_REMOVE
argument_list|(
name|region_tree_s
argument_list|,
operator|&
name|arena
operator|->
name|large_regions
argument_list|,
name|node
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|large
operator|.
name|curcached
operator|--
expr_stmt|;
endif|#
directive|endif
name|region_next_free_unset
argument_list|(
operator|&
name|ret
operator|->
name|sep
argument_list|)
expr_stmt|;
name|next
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|ret
operator|)
index|[
name|region_next_size_get
argument_list|(
operator|&
name|ret
operator|->
name|sep
argument_list|)
index|]
expr_stmt|;
name|assert
argument_list|(
name|region_prev_free_get
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
argument_list|)
expr_stmt|;
name|region_prev_free_unset
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
expr_stmt|;
if|if
condition|(
name|fit
condition|)
name|arena_reg_fit
argument_list|(
name|arena
argument_list|,
name|size
argument_list|,
name|ret
argument_list|,
name|false
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
if|if
condition|(
name|size
operator|>
name|bin_maxsize
condition|)
name|arena
operator|->
name|stats
operator|.
name|large
operator|.
name|nfit
operator|++
expr_stmt|;
else|else
name|arena
operator|->
name|stats
operator|.
name|large
operator|.
name|noverfit
operator|++
expr_stmt|;
endif|#
directive|endif
name|RETURN
label|:
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Allocate a new chunk and create a single region from it. */
end_comment

begin_function
specifier|static
name|region_t
modifier|*
name|arena_chunk_reg_alloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|fit
parameter_list|)
block|{
name|region_t
modifier|*
name|ret
decl_stmt|;
name|chunk_node_t
modifier|*
name|chunk
decl_stmt|;
name|chunk
operator|=
name|chunk_alloc
argument_list|(
name|chunk_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
block|{
name|chunk_node_t
modifier|*
name|tchunk
decl_stmt|;
name|chunk_node_t
name|key
decl_stmt|;
name|key
operator|.
name|chunk
operator|=
name|chunk
expr_stmt|;
name|tchunk
operator|=
name|RB_FIND
argument_list|(
name|chunk_tree_s
argument_list|,
operator|&
name|arena
operator|->
name|chunks
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|tchunk
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|chunk
operator|->
name|arena
operator|=
name|arena
expr_stmt|;
name|chunk
operator|->
name|chunk
operator|=
name|chunk
expr_stmt|;
name|chunk
operator|->
name|size
operator|=
name|chunk_size
expr_stmt|;
name|chunk
operator|->
name|extra
operator|=
literal|0
expr_stmt|;
name|RB_INSERT
argument_list|(
name|chunk_tree_s
argument_list|,
operator|&
name|arena
operator|->
name|chunks
argument_list|,
name|chunk
argument_list|)
expr_stmt|;
name|arena
operator|->
name|nchunks
operator|++
expr_stmt|;
comment|/* Carve a region from the new chunk. */
name|ret
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|chunk
operator|)
index|[
name|CHUNK_REG_OFFSET
index|]
expr_stmt|;
name|region_next_size_set
argument_list|(
operator|&
name|ret
operator|->
name|sep
argument_list|,
name|chunk_size
operator|-
operator|(
name|CHUNK_REG_OFFSET
operator|+
name|offsetof
argument_list|(
name|region_t
argument_list|,
name|next
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|region_prev_free_unset
argument_list|(
operator|&
name|ret
operator|->
name|sep
argument_list|)
expr_stmt|;
name|region_next_free_unset
argument_list|(
operator|&
name|ret
operator|->
name|sep
argument_list|)
expr_stmt|;
comment|/* 	 * Avoiding the following when possible is worthwhile, because it 	 * avoids touching a page that for many applications would never be 	 * touched otherwise. 	 */
ifdef|#
directive|ifdef
name|USE_BRK
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|ret
operator|>=
operator|(
name|uintptr_t
operator|)
name|brk_base
operator|&&
operator|(
name|uintptr_t
operator|)
name|ret
operator|<
operator|(
name|uintptr_t
operator|)
name|brk_max
condition|)
block|{
name|region_t
modifier|*
name|next
decl_stmt|;
comment|/* 		 * This may be a re-used brk chunk, so we have no guarantee 		 * that the memory is zero-filled.  Therefore manually create a 		 * separator at the end of this new region (all zero bits). 		 */
name|next
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|ret
operator|)
index|[
name|region_next_size_get
argument_list|(
operator|&
name|ret
operator|->
name|sep
argument_list|)
index|]
expr_stmt|;
name|region_next_size_set
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|region_prev_free_unset
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
expr_stmt|;
name|region_next_free_unset
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
expr_stmt|;
name|region_next_contig_unset
argument_list|(
operator|&
name|next
operator|->
name|sep
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|fit
condition|)
name|arena_reg_fit
argument_list|(
name|arena
argument_list|,
name|size
argument_list|,
name|ret
argument_list|,
operator|(
name|arena
operator|->
name|split
operator|==
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|RETURN
label|:
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find a region that is at least as large as aSize, and return a pointer to  * the separator that precedes the region.  The return value is ready for use,  * though it may be larger than is necessary if fit is false.  */
end_comment

begin_function
specifier|static
name|__inline
name|region_t
modifier|*
name|arena_reg_alloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|,
name|bool
name|fit
parameter_list|)
block|{
name|region_t
modifier|*
name|ret
decl_stmt|;
name|assert
argument_list|(
name|QUANTUM_CEILING
argument_list|(
name|size
argument_list|)
operator|==
name|size
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|>=
name|QUANTUM_CEILING
argument_list|(
sizeof|sizeof
argument_list|(
name|region_small_sizer_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|<=
operator|(
name|chunk_size
operator|>>
literal|1
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
name|bin_maxsize
condition|)
block|{
name|ret
operator|=
name|arena_bin_reg_alloc
argument_list|(
name|arena
argument_list|,
name|size
argument_list|,
name|fit
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
goto|goto
name|RETURN
goto|;
block|}
name|ret
operator|=
name|arena_large_reg_alloc
argument_list|(
name|arena
argument_list|,
name|size
argument_list|,
name|fit
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
goto|goto
name|RETURN
goto|;
name|ret
operator|=
name|arena_split_reg_alloc
argument_list|(
name|arena
argument_list|,
name|size
argument_list|,
name|fit
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
goto|goto
name|RETURN
goto|;
comment|/* 	 * Only try allocating from frag here if size is large, since 	 * arena_bin_reg_alloc() already falls back to allocating from frag for 	 * small regions. 	 */
if|if
condition|(
name|size
operator|>
name|bin_maxsize
condition|)
block|{
name|ret
operator|=
name|arena_frag_reg_alloc
argument_list|(
name|arena
argument_list|,
name|size
argument_list|,
name|fit
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
goto|goto
name|RETURN
goto|;
block|}
name|ret
operator|=
name|arena_chunk_reg_alloc
argument_list|(
name|arena
argument_list|,
name|size
argument_list|,
name|fit
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
goto|goto
name|RETURN
goto|;
name|ret
operator|=
name|NULL
expr_stmt|;
name|RETURN
label|:
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|arena_malloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|region_t
modifier|*
name|reg
decl_stmt|;
name|size_t
name|quantum_size
decl_stmt|;
name|assert
argument_list|(
name|arena
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena
operator|->
name|magic
operator|==
name|ARENA_MAGIC
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|region_ceiling
argument_list|(
name|size
argument_list|)
operator|<=
operator|(
name|chunk_size
operator|>>
literal|1
operator|)
argument_list|)
expr_stmt|;
name|quantum_size
operator|=
name|region_ceiling
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|quantum_size
operator|<
name|size
condition|)
block|{
comment|/* size is large enough to cause size_t wrap-around. */
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
name|assert
argument_list|(
name|quantum_size
operator|>=
name|QUANTUM_CEILING
argument_list|(
sizeof|sizeof
argument_list|(
name|region_small_sizer_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|arena
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|reg
operator|=
name|arena_reg_alloc
argument_list|(
name|arena
argument_list|,
name|quantum_size
argument_list|,
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|NULL
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|allocated
operator|+=
name|quantum_size
expr_stmt|;
endif|#
directive|endif
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|reg
operator|->
name|next
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_REDZONES
block|{
name|region_t
modifier|*
name|next
decl_stmt|;
name|size_t
name|total_size
decl_stmt|;
name|memset
argument_list|(
name|reg
operator|->
name|sep
operator|.
name|next_red
argument_list|,
literal|0xa5
argument_list|,
name|MALLOC_RED
argument_list|)
expr_stmt|;
comment|/* 		 * Unused trailing space in the region is considered part of the 		 * trailing redzone. 		 */
name|total_size
operator|=
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|total_size
operator|>=
name|size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|ret
operator|)
index|[
name|size
index|]
argument_list|,
literal|0xa5
argument_list|,
name|total_size
operator|-
name|size
operator|-
sizeof|sizeof
argument_list|(
name|region_sep_t
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|->
name|sep
operator|.
name|next_exact_size
operator|=
name|size
expr_stmt|;
name|next
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|reg
operator|)
index|[
name|total_size
index|]
expr_stmt|;
name|memset
argument_list|(
name|next
operator|->
name|sep
operator|.
name|prev_red
argument_list|,
literal|0xa5
argument_list|,
name|MALLOC_RED
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|RETURN
label|:
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|arena_palloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|assert
argument_list|(
name|arena
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena
operator|->
name|magic
operator|==
name|ARENA_MAGIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|alignment
operator|<=
name|quantum
condition|)
block|{
comment|/* 		 * The requested alignment is always guaranteed, so use the 		 * normal allocation function. 		 */
name|ret
operator|=
name|arena_malloc
argument_list|(
name|arena
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|region_t
modifier|*
name|reg
decl_stmt|,
modifier|*
name|old_split
decl_stmt|;
name|size_t
name|quantum_size
decl_stmt|,
name|alloc_size
decl_stmt|,
name|offset
decl_stmt|,
name|total_size
decl_stmt|;
comment|/* 		 * Allocate more space than necessary, then carve an aligned 		 * region out of it.  The smallest allowable region is 		 * potentially a multiple of the quantum size, so care must be 		 * taken to carve things up such that all resulting regions are 		 * large enough. 		 */
name|quantum_size
operator|=
name|region_ceiling
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|quantum_size
operator|<
name|size
condition|)
block|{
comment|/* size is large enough to cause size_t wrap-around. */
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
comment|/* 		 * Calculate how large of a region to allocate.  There must be 		 * enough space to advance far enough to have at least 		 * sizeof(region_small_sizer_t) leading bytes, yet also land at 		 * an alignment boundary. 		 */
if|if
condition|(
name|alignment
operator|>=
sizeof|sizeof
argument_list|(
name|region_small_sizer_t
argument_list|)
condition|)
block|{
name|alloc_size
operator|=
name|QUANTUM_CEILING
argument_list|(
sizeof|sizeof
argument_list|(
name|region_small_sizer_t
argument_list|)
argument_list|)
operator|+
name|alignment
operator|+
name|quantum_size
expr_stmt|;
block|}
else|else
block|{
name|alloc_size
operator|=
operator|(
name|QUANTUM_CEILING
argument_list|(
sizeof|sizeof
argument_list|(
name|region_small_sizer_t
argument_list|)
argument_list|)
operator|<<
literal|1
operator|)
operator|+
name|quantum_size
expr_stmt|;
block|}
if|if
condition|(
name|alloc_size
operator|<
name|quantum_size
condition|)
block|{
comment|/* size_t wrap-around occurred. */
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
name|malloc_mutex_lock
argument_list|(
operator|&
name|arena
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|old_split
operator|=
name|arena
operator|->
name|split
expr_stmt|;
name|reg
operator|=
name|arena_reg_alloc
argument_list|(
name|arena
argument_list|,
name|alloc_size
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
operator|==
name|NULL
condition|)
block|{
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
if|if
condition|(
name|reg
operator|==
name|old_split
condition|)
block|{
comment|/* 			 * We requested a non-fit allocation that was serviced 			 * by split, which means that we need to take care to 			 * restore split in the arena_reg_fit() call later on. 			 * 			 * Do nothing; a non-NULL old_split will be used as the 			 * signal to restore split. 			 */
block|}
else|else
name|old_split
operator|=
name|NULL
expr_stmt|;
name|total_size
operator|=
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
expr_stmt|;
if|if
condition|(
name|alignment
operator|>
name|bin_maxsize
operator|||
name|size
operator|>
name|bin_maxsize
condition|)
block|{
name|size_t
name|split_size
decl_stmt|;
name|uintptr_t
name|p
decl_stmt|;
comment|/* 			 * Put this allocation toward the end of reg, since 			 * it is large, and we try to put all large regions at 			 * the end of split regions. 			 */
name|split_size
operator|=
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|uintptr_t
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
operator|&
name|reg
operator|->
name|next
operator|)
index|[
name|split_size
index|]
expr_stmt|;
name|p
operator|-=
name|offsetof
argument_list|(
name|region_t
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|p
operator|-=
name|size
expr_stmt|;
name|p
operator|&=
operator|~
operator|(
name|alignment
operator|-
literal|1
operator|)
expr_stmt|;
name|p
operator|-=
name|offsetof
argument_list|(
name|region_t
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|offset
operator|=
name|p
operator|-
operator|(
name|uintptr_t
operator|)
name|reg
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|(
operator|(
name|uintptr_t
operator|)
operator|&
name|reg
operator|->
name|next
operator|)
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|uintptr_t
name|p
decl_stmt|;
comment|/* 				 * reg is unaligned.  Calculate the offset into 				 * reg to actually base the allocation at. 				 */
name|p
operator|=
operator|(
operator|(
name|uintptr_t
operator|)
operator|&
name|reg
operator|->
name|next
operator|+
name|alignment
operator|)
operator|&
operator|~
operator|(
name|alignment
operator|-
literal|1
operator|)
expr_stmt|;
while|while
condition|(
name|p
operator|-
operator|(
name|uintptr_t
operator|)
operator|&
name|reg
operator|->
name|next
operator|<
name|QUANTUM_CEILING
argument_list|(
sizeof|sizeof
argument_list|(
name|region_small_sizer_t
argument_list|)
argument_list|)
condition|)
name|p
operator|+=
name|alignment
expr_stmt|;
name|p
operator|-=
name|offsetof
argument_list|(
name|region_t
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|offset
operator|=
name|p
operator|-
operator|(
name|uintptr_t
operator|)
name|reg
expr_stmt|;
block|}
else|else
name|offset
operator|=
literal|0
expr_stmt|;
block|}
name|assert
argument_list|(
name|offset
operator|%
name|quantum
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|offset
operator|<
name|total_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
block|{
name|region_t
modifier|*
name|prev
decl_stmt|;
comment|/* 			 * Move ret to an alignment boundary that is far enough 			 * past the beginning of the allocation to leave a 			 * leading free region, then trim the leading space. 			 */
name|assert
argument_list|(
name|offset
operator|>=
name|QUANTUM_CEILING
argument_list|(
sizeof|sizeof
argument_list|(
name|region_small_sizer_t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|offset
operator|+
name|size
operator|<=
name|total_size
argument_list|)
expr_stmt|;
name|prev
operator|=
name|reg
expr_stmt|;
name|reg
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|prev
operator|)
index|[
name|offset
index|]
expr_stmt|;
name|assert
argument_list|(
operator|(
operator|(
name|uintptr_t
operator|)
operator|&
name|reg
operator|->
name|next
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* prev. */
name|region_next_size_set
argument_list|(
operator|&
name|prev
operator|->
name|sep
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|reg
operator|->
name|prev
operator|.
name|size
operator|=
name|offset
expr_stmt|;
comment|/* reg. */
name|region_next_size_set
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|,
name|total_size
operator|-
name|offset
argument_list|)
expr_stmt|;
name|region_next_free_unset
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
expr_stmt|;
if|if
condition|(
name|region_next_contig_get
argument_list|(
operator|&
name|prev
operator|->
name|sep
argument_list|)
condition|)
name|region_next_contig_set
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
expr_stmt|;
else|else
name|region_next_contig_unset
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_split
operator|!=
name|NULL
operator|&&
operator|(
name|alignment
operator|>
name|bin_maxsize
operator|||
name|size
operator|>
name|bin_maxsize
operator|)
condition|)
block|{
comment|/* Restore to split. */
name|region_prev_free_unset
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
expr_stmt|;
name|arena
operator|->
name|split
operator|=
name|prev
expr_stmt|;
name|old_split
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|region_next_free_set
argument_list|(
operator|&
name|prev
operator|->
name|sep
argument_list|)
expr_stmt|;
name|region_prev_free_set
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
expr_stmt|;
if|if
condition|(
name|arena_coalesce
argument_list|(
name|arena
argument_list|,
operator|&
name|prev
argument_list|,
name|offset
argument_list|)
condition|)
block|{
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
block|{
name|offset
operator|=
name|region_next_size_get
argument_list|(
operator|&
name|prev
operator|->
name|sep
argument_list|)
expr_stmt|;
name|arena_mru_cache
argument_list|(
name|arena
argument_list|,
name|prev
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|arena_mru_cache
argument_list|(
name|arena
argument_list|,
name|prev
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|nsplit
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
name|arena_reg_fit
argument_list|(
name|arena
argument_list|,
name|quantum_size
argument_list|,
name|reg
argument_list|,
operator|(
name|old_split
operator|!=
name|NULL
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|allocated
operator|+=
name|quantum_size
expr_stmt|;
endif|#
directive|endif
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|void
operator|*
operator|)
operator|&
name|reg
operator|->
name|next
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_REDZONES
block|{
name|region_t
modifier|*
name|next
decl_stmt|;
name|size_t
name|total_size
decl_stmt|;
name|memset
argument_list|(
name|reg
operator|->
name|sep
operator|.
name|next_red
argument_list|,
literal|0xa5
argument_list|,
name|MALLOC_RED
argument_list|)
expr_stmt|;
comment|/* 			 * Unused trailing space in the region is considered 			 * part of the trailing redzone. 			 */
name|total_size
operator|=
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|total_size
operator|>=
name|size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|ret
operator|)
index|[
name|size
index|]
argument_list|,
literal|0xa5
argument_list|,
name|total_size
operator|-
name|size
operator|-
sizeof|sizeof
argument_list|(
name|region_sep_t
argument_list|)
argument_list|)
expr_stmt|;
name|reg
operator|->
name|sep
operator|.
name|next_exact_size
operator|=
name|size
expr_stmt|;
name|next
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|reg
operator|)
index|[
name|total_size
index|]
expr_stmt|;
name|memset
argument_list|(
name|next
operator|->
name|sep
operator|.
name|prev_red
argument_list|,
literal|0xa5
argument_list|,
name|MALLOC_RED
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|RETURN
label|:
name|assert
argument_list|(
operator|(
operator|(
name|uintptr_t
operator|)
name|ret
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|arena_calloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|num
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|assert
argument_list|(
name|arena
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena
operator|->
name|magic
operator|==
name|ARENA_MAGIC
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|num
operator|*
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
name|arena_malloc
argument_list|(
name|arena
argument_list|,
name|num
operator|*
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
goto|goto
name|RETURN
goto|;
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|num
operator|*
name|size
argument_list|)
expr_stmt|;
name|RETURN
label|:
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|arena_salloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|size_t
name|ret
decl_stmt|;
name|region_t
modifier|*
name|reg
decl_stmt|;
name|assert
argument_list|(
name|arena
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena
operator|->
name|magic
operator|==
name|ARENA_MAGIC
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
operator|&
name|nil
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
operator|!=
name|ptr
argument_list|)
expr_stmt|;
name|reg
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|ptr
operator|)
index|[
operator|-
name|offsetof
argument_list|(
name|region_t
argument_list|,
name|next
argument_list|)
index|]
expr_stmt|;
name|ret
operator|=
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_REDZONES
end_ifdef

begin_function
specifier|static
name|void
name|redzone_check
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|region_t
modifier|*
name|reg
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|ncorruptions
decl_stmt|;
name|ncorruptions
operator|=
literal|0
expr_stmt|;
name|reg
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|ptr
operator|)
index|[
operator|-
name|offsetof
argument_list|(
name|region_t
argument_list|,
name|next
argument_list|)
index|]
expr_stmt|;
name|size
operator|=
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
expr_stmt|;
name|next
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|reg
operator|)
index|[
name|size
index|]
expr_stmt|;
comment|/* Leading redzone. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MALLOC_RED
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|unsigned
name|char
operator|)
name|reg
operator|->
name|sep
operator|.
name|next_red
index|[
name|i
index|]
operator|!=
literal|0xa5
condition|)
block|{
name|size_t
name|offset
init|=
operator|(
name|size_t
operator|)
name|MALLOC_RED
operator|-
name|i
decl_stmt|;
name|ncorruptions
operator|++
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"%s: (malloc) Corrupted redzone %zu "
literal|"byte%s before %p (0x%x)\n"
argument_list|,
name|_getprogname
argument_list|()
argument_list|,
name|offset
argument_list|,
name|offset
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|ptr
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|reg
operator|->
name|sep
operator|.
name|next_red
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|memset
argument_list|(
operator|&
name|reg
operator|->
name|sep
operator|.
name|next_red
argument_list|,
literal|0x5a
argument_list|,
name|MALLOC_RED
argument_list|)
expr_stmt|;
comment|/* Bytes immediately trailing allocation. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
operator|-
name|reg
operator|->
name|sep
operator|.
name|next_exact_size
operator|-
sizeof|sizeof
argument_list|(
name|region_sep_t
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ptr
argument_list|)
index|[
name|reg
operator|->
name|sep
operator|.
name|next_exact_size
operator|+
name|i
index|]
operator|!=
literal|0xa5
condition|)
block|{
name|size_t
name|offset
init|=
call|(
name|size_t
call|)
argument_list|(
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
name|ncorruptions
operator|++
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"%s: (malloc) Corrupted redzone %zu "
literal|"byte%s after %p (size %zu) (0x%x)\n"
argument_list|,
name|_getprogname
argument_list|()
argument_list|,
name|offset
argument_list|,
name|offset
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|ptr
argument_list|,
name|reg
operator|->
name|sep
operator|.
name|next_exact_size
argument_list|,
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ptr
argument_list|)
index|[
name|reg
operator|->
name|sep
operator|.
name|next_exact_size
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|memset
argument_list|(
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|ptr
operator|)
index|[
name|reg
operator|->
name|sep
operator|.
name|next_exact_size
index|]
argument_list|,
literal|0x5a
argument_list|,
name|size
operator|-
name|reg
operator|->
name|sep
operator|.
name|next_exact_size
operator|-
sizeof|sizeof
argument_list|(
name|region_sep_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Trailing redzone. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MALLOC_RED
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|unsigned
name|char
operator|)
name|next
operator|->
name|sep
operator|.
name|prev_red
index|[
name|i
index|]
operator|!=
literal|0xa5
condition|)
block|{
name|size_t
name|offset
init|=
call|(
name|size_t
call|)
argument_list|(
name|size
operator|-
name|reg
operator|->
name|sep
operator|.
name|next_exact_size
operator|-
sizeof|sizeof
argument_list|(
name|region_sep_t
argument_list|)
operator|+
name|i
operator|+
literal|1
argument_list|)
decl_stmt|;
name|ncorruptions
operator|++
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"%s: (malloc) Corrupted redzone %zu "
literal|"byte%s after %p (size %zu) (0x%x)\n"
argument_list|,
name|_getprogname
argument_list|()
argument_list|,
name|offset
argument_list|,
name|offset
operator|>
literal|1
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|ptr
argument_list|,
name|reg
operator|->
name|sep
operator|.
name|next_exact_size
argument_list|,
operator|(
name|unsigned
name|char
operator|)
name|next
operator|->
name|sep
operator|.
name|prev_red
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|memset
argument_list|(
operator|&
name|next
operator|->
name|sep
operator|.
name|prev_red
argument_list|,
literal|0x5a
argument_list|,
name|MALLOC_RED
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_abort
operator|&&
name|ncorruptions
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|reg
operator|->
name|sep
operator|.
name|next_exact_size
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|arena_dalloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|region_t
modifier|*
name|reg
decl_stmt|;
name|assert
argument_list|(
name|arena
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
operator|&
name|nil
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena
operator|->
name|magic
operator|==
name|ARENA_MAGIC
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
operator|!=
name|ptr
argument_list|)
expr_stmt|;
name|reg
operator|=
operator|(
name|region_t
operator|*
operator|)
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|ptr
operator|)
index|[
operator|-
name|offsetof
argument_list|(
name|region_t
argument_list|,
name|next
argument_list|)
index|]
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|arena
operator|->
name|mtx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
block|{
name|chunk_node_t
modifier|*
name|chunk
decl_stmt|,
modifier|*
name|node
decl_stmt|;
name|chunk_node_t
name|key
decl_stmt|;
name|chunk
operator|=
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|chunk
operator|->
name|arena
operator|==
name|arena
argument_list|)
expr_stmt|;
name|key
operator|.
name|chunk
operator|=
name|chunk
expr_stmt|;
name|node
operator|=
name|RB_FIND
argument_list|(
name|chunk_tree_s
argument_list|,
operator|&
name|arena
operator|->
name|chunks
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|node
operator|==
name|chunk
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MALLOC_REDZONES
name|redzone_check
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|allocated
operator|-=
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|opt_junk
condition|)
block|{
name|memset
argument_list|(
operator|&
name|reg
operator|->
name|next
argument_list|,
literal|0x5a
argument_list|,
name|region_next_size_get
argument_list|(
operator|&
name|reg
operator|->
name|sep
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|region_sep_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|arena_delay_cache
argument_list|(
name|arena
argument_list|,
name|reg
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|NOT_YET
end_ifdef

begin_function
specifier|static
name|void
modifier|*
name|arena_ralloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
comment|/* 	 * Arenas don't need to support ralloc, since all reallocation is done 	 * by allocating new space and copying.  This function should never be 	 * called. 	 */
comment|/* NOTREACHED */
name|assert
argument_list|(
name|false
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_STATS
end_ifdef

begin_function
specifier|static
name|bool
name|arena_stats
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
modifier|*
name|allocated
parameter_list|,
name|size_t
modifier|*
name|total
parameter_list|)
block|{
name|assert
argument_list|(
name|arena
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena
operator|->
name|magic
operator|==
name|ARENA_MAGIC
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|allocated
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|total
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|arena
operator|->
name|mtx
argument_list|)
expr_stmt|;
operator|*
name|allocated
operator|=
name|arena
operator|->
name|allocated
expr_stmt|;
operator|*
name|total
operator|=
name|arena
operator|->
name|nchunks
operator|*
name|chunk_size
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|bool
name|arena_new
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|)
block|{
name|bool
name|ret
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|malloc_mutex_init
argument_list|(
operator|&
name|arena
operator|->
name|mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NBINS
condition|;
name|i
operator|++
control|)
name|qr_new
argument_list|(
operator|&
name|arena
operator|->
name|bins
index|[
name|i
index|]
operator|.
name|regions
argument_list|,
name|next
operator|.
name|u
operator|.
name|s
operator|.
name|link
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BINMASK_NELMS
condition|;
name|i
operator|++
control|)
name|arena
operator|->
name|bins_mask
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|arena
operator|->
name|split
operator|=
name|NULL
expr_stmt|;
name|arena
operator|->
name|frag
operator|=
name|NULL
expr_stmt|;
name|RB_INIT
argument_list|(
operator|&
name|arena
operator|->
name|large_regions
argument_list|)
expr_stmt|;
name|RB_INIT
argument_list|(
operator|&
name|arena
operator|->
name|chunks
argument_list|)
expr_stmt|;
name|arena
operator|->
name|nchunks
operator|=
literal|0
expr_stmt|;
name|assert
argument_list|(
name|opt_ndelay
operator|>
literal|0
argument_list|)
expr_stmt|;
name|arena
operator|->
name|delayed
operator|=
operator|(
name|region_t
operator|*
operator|*
operator|)
name|base_alloc
argument_list|(
name|opt_ndelay
operator|*
sizeof|sizeof
argument_list|(
name|region_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|arena
operator|->
name|delayed
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|true
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
name|memset
argument_list|(
name|arena
operator|->
name|delayed
argument_list|,
literal|0
argument_list|,
name|opt_ndelay
operator|*
sizeof|sizeof
argument_list|(
name|region_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|arena
operator|->
name|next_delayed
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|allocated
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|arena
operator|->
name|stats
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|arena_stats_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MALLOC_DEBUG
name|arena
operator|->
name|magic
operator|=
name|ARENA_MAGIC
expr_stmt|;
endif|#
directive|endif
name|ret
operator|=
name|false
expr_stmt|;
name|RETURN
label|:
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Create a new arena and insert it into the arenas array at index ind. */
end_comment

begin_function
specifier|static
name|arena_t
modifier|*
name|arenas_extend
parameter_list|(
name|unsigned
name|ind
parameter_list|)
block|{
name|arena_t
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
name|arena_t
operator|*
operator|)
name|base_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arena_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|NULL
operator|&&
name|arena_new
argument_list|(
name|ret
argument_list|)
operator|==
name|false
condition|)
block|{
name|arenas
index|[
name|ind
index|]
operator|=
name|ret
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* Only reached if there is an OOM error. */
comment|/* 	 * OOM here is quite inconvenient to propagate, since dealing with it 	 * would require a check for failure in the fast path.  Instead, punt 	 * by using arenas[0].  In practice, this is an extremely unlikely 	 * failure. 	 */
name|malloc_printf
argument_list|(
literal|"%s: (malloc) Error initializing arena\n"
argument_list|,
name|_getprogname
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_abort
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
operator|(
name|arenas
index|[
literal|0
index|]
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * End arena.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin  general internal functions.  */
end_comment

begin_comment
comment|/*  * Choose an arena based on a per-thread value (fast-path code, calls slow-path  * code if necessary.  */
end_comment

begin_function
specifier|static
name|__inline
name|arena_t
modifier|*
name|choose_arena
parameter_list|(
name|void
parameter_list|)
block|{
name|arena_t
modifier|*
name|ret
decl_stmt|;
comment|/* 	 * We can only use TLS if this is a PIC library, since for the static 	 * library version, libc's malloc is used by TLS allocation, which 	 * introduces a bootstrapping issue. 	 */
ifndef|#
directive|ifndef
name|NO_TLS
name|ret
operator|=
name|arenas_map
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|ret
operator|=
name|choose_arena_hard
argument_list|()
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|__isthreaded
condition|)
block|{
name|unsigned
name|long
name|ind
decl_stmt|;
comment|/* 		 * Hash _pthread_self() to one of the arenas.  There is a prime 		 * number of arenas, so this has a reasonable chance of 		 * working.  Even so, the hashing can be easily thwarted by 		 * inconvenient _pthread_self() values.  Without specific 		 * knowledge of how _pthread_self() calculates values, we can't 		 * do much better than this. 		 */
name|ind
operator|=
operator|(
name|unsigned
name|long
operator|)
name|_pthread_self
argument_list|()
operator|%
name|narenas
expr_stmt|;
comment|/* 		 * Optimistially assume that arenas[ind] has been initialized. 		 * At worst, we find out that some other thread has already 		 * done so, after acquiring the lock in preparation.  Note that 		 * this lazy locking also has the effect of lazily forcing 		 * cache coherency; without the lock acquisition, there's no 		 * guarantee that modification of arenas[ind] by another thread 		 * would be seen on this CPU for an arbitrary amount of time. 		 * 		 * In general, this approach to modifying a synchronized value 		 * isn't a good idea, but in this case we only ever modify the 		 * value once, so things work out well. 		 */
name|ret
operator|=
name|arenas
index|[
name|ind
index|]
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Avoid races with another thread that may have already 			 * initialized arenas[ind]. 			 */
name|malloc_mutex_lock
argument_list|(
operator|&
name|arenas_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|arenas
index|[
name|ind
index|]
operator|==
name|NULL
condition|)
name|ret
operator|=
name|arenas_extend
argument_list|(
operator|(
name|unsigned
operator|)
name|ind
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|arenas
index|[
name|ind
index|]
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arenas_mtx
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|ret
operator|=
name|arenas
index|[
literal|0
index|]
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_TLS
end_ifndef

begin_comment
comment|/*  * Choose an arena based on a per-thread value (slow-path code only, called  * only by choose_arena()).  */
end_comment

begin_function
specifier|static
name|arena_t
modifier|*
name|choose_arena_hard
parameter_list|(
name|void
parameter_list|)
block|{
name|arena_t
modifier|*
name|ret
decl_stmt|;
comment|/* Assign one of the arenas to this thread, in a round-robin fashion. */
if|if
condition|(
name|__isthreaded
condition|)
block|{
name|malloc_mutex_lock
argument_list|(
operator|&
name|arenas_mtx
argument_list|)
expr_stmt|;
name|ret
operator|=
name|arenas
index|[
name|next_arena
index|]
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
name|ret
operator|=
name|arenas_extend
argument_list|(
name|next_arena
argument_list|)
expr_stmt|;
name|next_arena
operator|=
operator|(
name|next_arena
operator|+
literal|1
operator|)
operator|%
name|narenas
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arenas_mtx
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|arenas
index|[
literal|0
index|]
expr_stmt|;
name|arenas_map
operator|=
name|ret
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
modifier|*
name|huge_malloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|size_t
name|chunk_size
decl_stmt|;
name|chunk_node_t
modifier|*
name|node
decl_stmt|;
comment|/* Allocate a chunk for this request. */
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|arena
operator|->
name|stats
operator|.
name|huge
operator|.
name|nrequests
operator|++
expr_stmt|;
endif|#
directive|endif
name|chunk_size
operator|=
name|CHUNK_CEILING
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|chunk_size
operator|==
literal|0
condition|)
block|{
comment|/* size is large enough to cause size_t wrap-around. */
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
comment|/* Allocate a chunk node with which to track the chunk. */
name|node
operator|=
name|base_chunk_node_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
name|ret
operator|=
name|chunk_alloc
argument_list|(
name|chunk_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
name|base_chunk_node_dealloc
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
comment|/* Insert node into chunks. */
name|node
operator|->
name|arena
operator|=
name|arena
expr_stmt|;
name|node
operator|->
name|chunk
operator|=
name|ret
expr_stmt|;
name|node
operator|->
name|size
operator|=
name|chunk_size
expr_stmt|;
name|node
operator|->
name|extra
operator|=
name|chunk_size
operator|-
name|size
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
name|RB_INSERT
argument_list|(
name|chunk_tree_s
argument_list|,
operator|&
name|huge
argument_list|,
name|node
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|huge_allocated
operator|+=
name|size
expr_stmt|;
name|huge_total
operator|+=
name|chunk_size
expr_stmt|;
endif|#
directive|endif
name|malloc_mutex_unlock
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
name|RETURN
label|:
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|huge_dalloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|chunk_node_t
name|key
decl_stmt|;
name|chunk_node_t
modifier|*
name|node
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
comment|/* Extract from tree of huge allocations. */
name|key
operator|.
name|chunk
operator|=
name|ptr
expr_stmt|;
name|node
operator|=
name|RB_FIND
argument_list|(
name|chunk_tree_s
argument_list|,
operator|&
name|huge
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|node
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|node
operator|->
name|chunk
operator|==
name|ptr
argument_list|)
expr_stmt|;
name|RB_REMOVE
argument_list|(
name|chunk_tree_s
argument_list|,
operator|&
name|huge
argument_list|,
name|node
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|malloc_mutex_lock
argument_list|(
operator|&
name|node
operator|->
name|arena
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|node
operator|->
name|arena
operator|->
name|stats
operator|.
name|ndalloc
operator|++
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|node
operator|->
name|arena
operator|->
name|mtx
argument_list|)
expr_stmt|;
comment|/* Update counters. */
name|huge_allocated
operator|-=
operator|(
name|node
operator|->
name|size
operator|-
name|node
operator|->
name|extra
operator|)
expr_stmt|;
name|huge_total
operator|-=
name|node
operator|->
name|size
expr_stmt|;
endif|#
directive|endif
name|malloc_mutex_unlock
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
comment|/* Unmap chunk. */
name|chunk_dealloc
argument_list|(
name|node
operator|->
name|chunk
argument_list|,
name|node
operator|->
name|size
argument_list|)
expr_stmt|;
name|base_chunk_node_dealloc
argument_list|(
name|node
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|imalloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|assert
argument_list|(
name|arena
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena
operator|->
name|magic
operator|==
name|ARENA_MAGIC
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|region_ceiling
argument_list|(
name|size
argument_list|)
operator|<=
operator|(
name|chunk_size
operator|>>
literal|1
operator|)
condition|)
name|ret
operator|=
name|arena_malloc
argument_list|(
name|arena
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|huge_malloc
argument_list|(
name|arena
argument_list|,
name|size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|malloc_mutex_lock
argument_list|(
operator|&
name|arena
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|nmalloc
operator|++
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|opt_junk
condition|)
block|{
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0xa5
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|ipalloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|assert
argument_list|(
name|arena
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena
operator|->
name|magic
operator|==
name|ARENA_MAGIC
argument_list|)
expr_stmt|;
comment|/* 	 * The conditions that disallow calling arena_palloc() are quite 	 * tricky. 	 * 	 * The first main clause of the conditional mirrors that in imalloc(), 	 * and is necesary because arena_palloc() may in turn call 	 * arena_malloc(). 	 * 	 * The second and third clauses are necessary because we want to be 	 * sure that it will not be necessary to allocate more than a 	 * half-chunk region at any point during the creation of the aligned 	 * allocation.  These checks closely mirror the calculation of 	 * alloc_size in arena_palloc(). 	 * 	 * Finally, the fourth clause makes explicit the constraint on what 	 * alignments will be attempted via regions.  At first glance, this 	 * appears unnecessary, but in actuality, it protects against otherwise 	 * difficult-to-detect size_t wrap-around cases. 	 */
if|if
condition|(
name|region_ceiling
argument_list|(
name|size
argument_list|)
operator|<=
operator|(
name|chunk_size
operator|>>
literal|1
operator|)
operator|&&
operator|(
name|alignment
operator|<
sizeof|sizeof
argument_list|(
name|region_small_sizer_t
argument_list|)
operator|||
operator|(
name|QUANTUM_CEILING
argument_list|(
sizeof|sizeof
argument_list|(
name|region_small_sizer_t
argument_list|)
argument_list|)
operator|+
name|alignment
operator|+
operator|(
name|region_ceiling
argument_list|(
name|size
argument_list|)
operator|)
operator|)
operator|<=
operator|(
name|chunk_size
operator|>>
literal|1
operator|)
operator|)
operator|&&
operator|(
name|alignment
operator|>=
sizeof|sizeof
argument_list|(
name|region_small_sizer_t
argument_list|)
operator|||
operator|(
operator|(
name|QUANTUM_CEILING
argument_list|(
sizeof|sizeof
argument_list|(
name|region_small_sizer_t
argument_list|)
argument_list|)
operator|<<
literal|1
operator|)
operator|+
operator|(
name|region_ceiling
argument_list|(
name|size
argument_list|)
operator|)
operator|)
operator|<=
operator|(
name|chunk_size
operator|>>
literal|1
operator|)
operator|)
operator|&&
name|alignment
operator|<=
operator|(
name|chunk_size
operator|>>
literal|2
operator|)
condition|)
name|ret
operator|=
name|arena_palloc
argument_list|(
name|arena
argument_list|,
name|alignment
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|alignment
operator|<=
name|chunk_size
condition|)
name|ret
operator|=
name|huge_malloc
argument_list|(
name|arena
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
block|{
name|size_t
name|chunksize
decl_stmt|,
name|alloc_size
decl_stmt|,
name|offset
decl_stmt|;
name|chunk_node_t
modifier|*
name|node
decl_stmt|;
comment|/* 			 * This allocation requires alignment that is even 			 * larger than chunk alignment.  This means that 			 * huge_malloc() isn't good enough. 			 * 			 * Allocate almost twice as many chunks as are demanded 			 * by the size or alignment, in order to assure the 			 * alignment can be achieved, then unmap leading and 			 * trailing chunks. 			 */
name|chunksize
operator|=
name|CHUNK_CEILING
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>=
name|alignment
condition|)
name|alloc_size
operator|=
name|chunksize
operator|+
name|alignment
operator|-
name|chunk_size
expr_stmt|;
else|else
name|alloc_size
operator|=
operator|(
name|alignment
operator|<<
literal|1
operator|)
operator|-
name|chunk_size
expr_stmt|;
comment|/* 			 * Allocate a chunk node with which to track the chunk. 			 */
name|node
operator|=
name|base_chunk_node_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
name|ret
operator|=
name|chunk_alloc
argument_list|(
name|alloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
name|base_chunk_node_dealloc
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
name|offset
operator|=
operator|(
name|uintptr_t
operator|)
name|ret
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
expr_stmt|;
name|assert
argument_list|(
name|offset
operator|%
name|chunk_size
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|offset
operator|<
name|alloc_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
block|{
comment|/* Trim trailing space. */
name|chunk_dealloc
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ret
operator|+
name|chunksize
operator|)
argument_list|,
name|alloc_size
operator|-
name|chunksize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size_t
name|trailsize
decl_stmt|;
comment|/* Trim leading space. */
name|chunk_dealloc
argument_list|(
name|ret
argument_list|,
name|alignment
operator|-
name|offset
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ret
operator|+
operator|(
name|alignment
operator|-
name|offset
operator|)
operator|)
expr_stmt|;
name|trailsize
operator|=
name|alloc_size
operator|-
operator|(
name|alignment
operator|-
name|offset
operator|)
operator|-
name|chunksize
expr_stmt|;
if|if
condition|(
name|trailsize
operator|!=
literal|0
condition|)
block|{
comment|/* Trim trailing space. */
name|assert
argument_list|(
name|trailsize
operator|<
name|alloc_size
argument_list|)
expr_stmt|;
name|chunk_dealloc
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|ret
operator|+
name|chunksize
operator|)
argument_list|,
name|trailsize
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Insert node into chunks. */
name|node
operator|->
name|arena
operator|=
name|arena
expr_stmt|;
name|node
operator|->
name|chunk
operator|=
name|ret
expr_stmt|;
name|node
operator|->
name|size
operator|=
name|chunksize
expr_stmt|;
name|node
operator|->
name|extra
operator|=
name|node
operator|->
name|size
operator|-
name|size
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
name|RB_INSERT
argument_list|(
name|chunk_tree_s
argument_list|,
operator|&
name|huge
argument_list|,
name|node
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|huge_allocated
operator|+=
name|size
expr_stmt|;
name|huge_total
operator|+=
name|chunksize
expr_stmt|;
endif|#
directive|endif
name|malloc_mutex_unlock
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
block|}
block|}
name|RETURN
label|:
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|malloc_mutex_lock
argument_list|(
operator|&
name|arena
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|npalloc
operator|++
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|opt_junk
condition|)
block|{
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0xa5
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
operator|(
operator|(
name|uintptr_t
operator|)
name|ret
operator|&
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|icalloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|size_t
name|num
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|assert
argument_list|(
name|arena
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena
operator|->
name|magic
operator|==
name|ARENA_MAGIC
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|num
operator|*
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|region_ceiling
argument_list|(
name|num
operator|*
name|size
argument_list|)
operator|<=
operator|(
name|chunk_size
operator|>>
literal|1
operator|)
condition|)
name|ret
operator|=
name|arena_calloc
argument_list|(
name|arena
argument_list|,
name|num
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* 		 * The virtual memory system provides zero-filled pages, so 		 * there is no need to do so manually. 		 */
name|ret
operator|=
name|huge_malloc
argument_list|(
name|arena
argument_list|,
name|num
operator|*
name|size
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_BRK
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|ret
operator|>=
operator|(
name|uintptr_t
operator|)
name|brk_base
operator|&&
operator|(
name|uintptr_t
operator|)
name|ret
operator|<
operator|(
name|uintptr_t
operator|)
name|brk_max
condition|)
block|{
comment|/*  			 * This may be a re-used brk chunk.  Therefore, zero 			 * the memory. 			 */
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|num
operator|*
name|size
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|malloc_mutex_lock
argument_list|(
operator|&
name|arena
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|ncalloc
operator|++
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|isalloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|size_t
name|ret
decl_stmt|;
name|chunk_node_t
modifier|*
name|node
decl_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
operator|&
name|nil
argument_list|)
expr_stmt|;
name|node
operator|=
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|ptr
condition|)
block|{
comment|/* Region. */
name|assert
argument_list|(
name|node
operator|->
name|arena
operator|->
name|magic
operator|==
name|ARENA_MAGIC
argument_list|)
expr_stmt|;
name|ret
operator|=
name|arena_salloc
argument_list|(
name|node
operator|->
name|arena
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|chunk_node_t
name|key
decl_stmt|;
comment|/* Chunk (huge allocation). */
name|malloc_mutex_lock
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
comment|/* Extract from tree of huge allocations. */
name|key
operator|.
name|chunk
operator|=
name|ptr
expr_stmt|;
name|node
operator|=
name|RB_FIND
argument_list|(
name|chunk_tree_s
argument_list|,
operator|&
name|huge
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|node
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ret
operator|=
name|node
operator|->
name|size
operator|-
name|node
operator|->
name|extra
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|idalloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|chunk_node_t
modifier|*
name|node
decl_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
operator|&
name|nil
argument_list|)
expr_stmt|;
name|node
operator|=
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|node
operator|!=
name|ptr
condition|)
block|{
comment|/* Region. */
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|malloc_mutex_lock
argument_list|(
operator|&
name|node
operator|->
name|arena
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|node
operator|->
name|arena
operator|->
name|stats
operator|.
name|ndalloc
operator|++
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|node
operator|->
name|arena
operator|->
name|mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|arena_dalloc
argument_list|(
name|node
operator|->
name|arena
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
else|else
name|huge_dalloc
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|iralloc
parameter_list|(
name|arena_t
modifier|*
name|arena
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|size_t
name|oldsize
decl_stmt|;
name|assert
argument_list|(
name|arena
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|arena
operator|->
name|magic
operator|==
name|ARENA_MAGIC
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
operator|&
name|nil
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|oldsize
operator|=
name|isalloc
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|region_ceiling
argument_list|(
name|size
argument_list|)
operator|<=
operator|(
name|chunk_size
operator|>>
literal|1
operator|)
condition|)
block|{
name|ret
operator|=
name|arena_malloc
argument_list|(
name|arena
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
goto|goto
name|RETURN
goto|;
if|if
condition|(
name|opt_junk
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0xa5
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
name|oldsize
condition|)
name|memcpy
argument_list|(
name|ret
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|ret
argument_list|,
name|ptr
argument_list|,
name|oldsize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
name|huge_malloc
argument_list|(
name|arena
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
goto|goto
name|RETURN
goto|;
if|if
condition|(
name|opt_junk
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0xa5
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|CHUNK_ADDR2BASE
argument_list|(
name|ptr
argument_list|)
operator|==
name|ptr
condition|)
block|{
comment|/* The old allocation is a chunk. */
if|if
condition|(
name|size
operator|<
name|oldsize
condition|)
name|memcpy
argument_list|(
name|ret
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|ret
argument_list|,
name|ptr
argument_list|,
name|oldsize
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The old allocation is a region. */
name|assert
argument_list|(
name|oldsize
operator|<
name|size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|ret
argument_list|,
name|ptr
argument_list|,
name|oldsize
argument_list|)
expr_stmt|;
block|}
block|}
name|idalloc
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|RETURN
label|:
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|malloc_mutex_lock
argument_list|(
operator|&
name|arena
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|arena
operator|->
name|stats
operator|.
name|nralloc
operator|++
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MALLOC_STATS
end_ifdef

begin_function
specifier|static
name|void
name|istats
parameter_list|(
name|size_t
modifier|*
name|allocated
parameter_list|,
name|size_t
modifier|*
name|total
parameter_list|)
block|{
name|size_t
name|tallocated
decl_stmt|,
name|ttotal
decl_stmt|;
name|size_t
name|rallocated
decl_stmt|,
name|rtotal
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|tallocated
operator|=
literal|0
expr_stmt|;
name|ttotal
operator|=
name|base_total
expr_stmt|;
comment|/* arenas. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|narenas
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|arenas
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|arena_stats
argument_list|(
name|arenas
index|[
name|i
index|]
argument_list|,
operator|&
name|rallocated
argument_list|,
operator|&
name|rtotal
argument_list|)
expr_stmt|;
name|tallocated
operator|+=
name|rallocated
expr_stmt|;
name|ttotal
operator|+=
name|rtotal
expr_stmt|;
block|}
block|}
comment|/* huge. */
name|malloc_mutex_lock
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
name|tallocated
operator|+=
name|huge_allocated
expr_stmt|;
name|ttotal
operator|+=
name|huge_total
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
comment|/* Return results. */
operator|*
name|allocated
operator|=
name|tallocated
expr_stmt|;
operator|*
name|total
operator|=
name|ttotal
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|malloc_print_stats
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|opt_print_stats
condition|)
block|{
name|malloc_printf
argument_list|(
literal|"___ Begin malloc statistics ___\n"
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"Number of CPUs: %u\n"
argument_list|,
name|ncpus
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"Number of arenas: %u\n"
argument_list|,
name|narenas
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"Cache slots: %u\n"
argument_list|,
name|opt_ndelay
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"Chunk size: %zu (2^%zu)\n"
argument_list|,
name|chunk_size
argument_list|,
name|opt_chunk_2pow
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"Quantum size: %zu (2^%zu)\n"
argument_list|,
name|quantum
argument_list|,
name|opt_quantum_2pow
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"Pointer size: %u\n"
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"Number of bins: %u\n"
argument_list|,
name|NBINS
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"Maximum bin size: %u\n"
argument_list|,
name|bin_maxsize
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"Assertions %s\n"
argument_list|,
ifdef|#
directive|ifdef
name|NDEBUG
literal|"disabled"
else|#
directive|else
literal|"enabled"
endif|#
directive|endif
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"Redzone size: %u\n"
argument_list|,
ifdef|#
directive|ifdef
name|MALLOC_REDZONES
name|MALLOC_RED
else|#
directive|else
literal|0
endif|#
directive|endif
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
block|{
name|size_t
name|a
decl_stmt|,
name|b
decl_stmt|;
name|istats
argument_list|(
operator|&
name|a
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"Allocated: %zu, space used: %zu\n"
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
block|}
block|{
name|arena_stats_t
name|stats_arenas
decl_stmt|;
name|arena_t
modifier|*
name|arena
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
comment|/* Print chunk stats. */
block|{
name|chunk_stats_t
name|chunks_stats
decl_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
name|chunks_stats
operator|=
name|stats_chunks
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|"\nchunks:\n"
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|" %13s%13s%13s\n"
argument_list|,
literal|"nchunks"
argument_list|,
literal|"highchunks"
argument_list|,
literal|"curchunks"
argument_list|)
expr_stmt|;
name|malloc_printf
argument_list|(
literal|" %13llu%13lu%13lu\n"
argument_list|,
name|chunks_stats
operator|.
name|nchunks
argument_list|,
name|chunks_stats
operator|.
name|highchunks
argument_list|,
name|chunks_stats
operator|.
name|curchunks
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MALLOC_STATS_ARENAS
comment|/* Print stats for each arena. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|narenas
condition|;
name|i
operator|++
control|)
block|{
name|arena
operator|=
name|arenas
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|arena
operator|!=
name|NULL
condition|)
block|{
name|malloc_printf
argument_list|(
literal|"\narenas[%u] statistics:\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|arena
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|stats_print
argument_list|(
operator|&
name|arena
operator|->
name|stats
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|malloc_printf
argument_list|(
literal|"\narenas[%u] statistics:"
literal|" unused arena\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Merge arena stats from arenas. */
name|memset
argument_list|(
operator|&
name|stats_arenas
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|arena_stats_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|narenas
condition|;
name|i
operator|++
control|)
block|{
name|arena
operator|=
name|arenas
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|arena
operator|!=
name|NULL
condition|)
block|{
name|malloc_mutex_lock
argument_list|(
operator|&
name|arena
operator|->
name|mtx
argument_list|)
expr_stmt|;
name|stats_merge
argument_list|(
name|arena
argument_list|,
operator|&
name|stats_arenas
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arena
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Print arena stats. */
name|malloc_printf
argument_list|(
literal|"\nMerged arena statistics:\n"
argument_list|)
expr_stmt|;
name|stats_print
argument_list|(
operator|&
name|stats_arenas
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* #ifdef MALLOC_STATS */
name|malloc_printf
argument_list|(
literal|"--- End malloc statistics ---\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * FreeBSD's pthreads implementation calls malloc(3), so the malloc  * implementation has to take pains to avoid infinite recursion during  * initialization.  *  * atomic_init_start() returns true if it started initializing.  In that case,  * the caller must also call atomic_init_finish(), just before returning  * to its caller.  This delayed finalization of initialization is critical,  * since otherwise choose_arena() has no way to know whether it's safe  * to call _pthread_self().  */
end_comment

begin_function
specifier|static
name|__inline
name|bool
name|malloc_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * We always initialize before threads are created, since any thread 	 * creation first triggers allocations. 	 */
name|assert
argument_list|(
name|__isthreaded
operator|==
literal|0
operator|||
name|malloc_initialized
argument_list|)
expr_stmt|;
if|if
condition|(
name|malloc_initialized
operator|==
name|false
condition|)
return|return
operator|(
name|malloc_init_hard
argument_list|()
operator|)
return|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|bool
name|malloc_init_hard
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|linklen
decl_stmt|;
name|char
name|buf
index|[
name|PATH_MAX
operator|+
literal|1
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|opts
decl_stmt|;
comment|/* Get number of CPUs. */
block|{
name|int
name|mib
index|[
literal|2
index|]
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|mib
index|[
literal|0
index|]
operator|=
name|CTL_HW
expr_stmt|;
name|mib
index|[
literal|1
index|]
operator|=
name|HW_NCPU
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|ncpus
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|2
argument_list|,
operator|&
name|ncpus
argument_list|,
operator|&
name|len
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* Error. */
name|ncpus
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* Get page size. */
block|{
name|long
name|result
decl_stmt|;
name|result
operator|=
name|sysconf
argument_list|(
name|_SC_PAGESIZE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|result
operator|!=
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pagesize
operator|=
operator|(
name|unsigned
operator|)
name|result
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
comment|/* Get runtime configuration. */
switch|switch
condition|(
name|i
condition|)
block|{
case|case
literal|0
case|:
if|if
condition|(
operator|(
name|linklen
operator|=
name|readlink
argument_list|(
literal|"/etc/malloc.conf"
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* 				 * Use the contents of the "/etc/malloc.conf" 				 * symbolic link's name. 				 */
name|buf
index|[
name|linklen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|opts
operator|=
name|buf
expr_stmt|;
block|}
else|else
block|{
comment|/* No configuration specified. */
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|opts
operator|=
name|buf
expr_stmt|;
block|}
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|issetugid
argument_list|()
operator|==
literal|0
operator|&&
operator|(
name|opts
operator|=
name|getenv
argument_list|(
literal|"MALLOC_OPTIONS"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * Do nothing; opts is already initialized to 				 * the value of the MALLOC_OPTIONS environment 				 * variable. 				 */
block|}
else|else
block|{
comment|/* No configuration specified. */
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|opts
operator|=
name|buf
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|_malloc_options
operator|!=
name|NULL
condition|)
block|{
comment|/* 			     * Use options that were compiled into the program. 			     */
name|opts
operator|=
name|_malloc_options
expr_stmt|;
block|}
else|else
block|{
comment|/* No configuration specified. */
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|opts
operator|=
name|buf
expr_stmt|;
block|}
break|break;
default|default:
comment|/* NOTREACHED */
name|assert
argument_list|(
name|false
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|opts
index|[
name|j
index|]
operator|!=
literal|'\0'
condition|;
name|j
operator|++
control|)
block|{
switch|switch
condition|(
name|opts
index|[
name|j
index|]
condition|)
block|{
case|case
literal|'a'
case|:
name|opt_abort
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|opt_abort
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|opt_ndelay
operator|>>=
literal|1
expr_stmt|;
if|if
condition|(
name|opt_ndelay
operator|==
literal|0
condition|)
name|opt_ndelay
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|opt_ndelay
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
name|opt_ndelay
operator|==
literal|0
condition|)
name|opt_ndelay
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|opt_junk
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
name|opt_junk
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
if|if
condition|(
operator|(
literal|1
operator|<<
name|opt_chunk_2pow
operator|)
operator|>
name|pagesize
condition|)
name|opt_chunk_2pow
operator|--
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
if|if
condition|(
name|opt_chunk_2pow
operator|<
name|CHUNK_2POW_MAX
condition|)
name|opt_chunk_2pow
operator|++
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|opt_narenas_lshift
operator|--
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|opt_narenas_lshift
operator|++
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|opt_print_stats
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|opt_print_stats
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
if|if
condition|(
name|opt_quantum_2pow
operator|>
name|QUANTUM_2POW_MIN
condition|)
name|opt_quantum_2pow
operator|--
expr_stmt|;
break|break;
case|case
literal|'Q'
case|:
if|if
condition|(
operator|(
literal|1
operator|<<
name|opt_quantum_2pow
operator|)
operator|<
name|pagesize
condition|)
name|opt_quantum_2pow
operator|++
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
name|opt_utrace
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|opt_utrace
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|opt_sysv
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|opt_sysv
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|opt_xmalloc
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|opt_xmalloc
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|opt_zero
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
name|opt_zero
operator|=
name|true
expr_stmt|;
break|break;
default|default:
name|malloc_printf
argument_list|(
literal|"%s: (malloc) Unsupported"
literal|" character in malloc options: '%c'\n"
argument_list|,
name|_getprogname
argument_list|()
argument_list|,
name|opts
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Take care to call atexit() only once. */
if|if
condition|(
name|opt_print_stats
condition|)
block|{
comment|/* Print statistics at exit. */
name|atexit
argument_list|(
name|malloc_print_stats
argument_list|)
expr_stmt|;
block|}
comment|/* Set variables according to the value of opt_quantum_2pow. */
name|quantum
operator|=
operator|(
literal|1
operator|<<
name|opt_quantum_2pow
operator|)
expr_stmt|;
name|quantum_mask
operator|=
name|quantum
operator|-
literal|1
expr_stmt|;
name|bin_shift
operator|=
operator|(
operator|(
name|QUANTUM_CEILING
argument_list|(
sizeof|sizeof
argument_list|(
name|region_small_sizer_t
argument_list|)
argument_list|)
operator|>>
name|opt_quantum_2pow
operator|)
operator|)
expr_stmt|;
name|bin_maxsize
operator|=
operator|(
operator|(
name|NBINS
operator|+
name|bin_shift
operator|-
literal|1
operator|)
operator|*
name|quantum
operator|)
expr_stmt|;
comment|/* Set variables according to the value of opt_chunk_2pow. */
name|chunk_size
operator|=
operator|(
literal|1
operator|<<
name|opt_chunk_2pow
operator|)
expr_stmt|;
name|chunk_size_mask
operator|=
name|chunk_size
operator|-
literal|1
expr_stmt|;
name|UTRACE
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|memset
argument_list|(
operator|&
name|stats_chunks
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|chunk_stats_t
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Various sanity checks that regard configuration. */
name|assert
argument_list|(
name|quantum
operator|>=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|quantum
operator|<=
name|pagesize
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|chunk_size
operator|>=
name|pagesize
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|quantum
operator|*
literal|4
operator|<=
name|chunk_size
argument_list|)
expr_stmt|;
comment|/* Initialize chunks data. */
name|malloc_mutex_init
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
name|RB_INIT
argument_list|(
operator|&
name|huge
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_BRK
name|brk_base
operator|=
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|brk_prev
operator|=
name|brk_base
expr_stmt|;
name|brk_max
operator|=
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|brk_base
operator|+
name|MAXDSIZ
operator|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|huge_allocated
operator|=
literal|0
expr_stmt|;
name|huge_total
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|RB_INIT
argument_list|(
operator|&
name|old_chunks
argument_list|)
expr_stmt|;
comment|/* Initialize base allocation data structures. */
name|base_chunk
operator|=
name|NULL
expr_stmt|;
name|base_next_addr
operator|=
name|NULL
expr_stmt|;
name|base_past_addr
operator|=
name|NULL
expr_stmt|;
name|base_chunk_nodes
operator|=
name|NULL
expr_stmt|;
name|malloc_mutex_init
argument_list|(
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MALLOC_STATS
name|base_total
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ncpus
operator|>
literal|1
condition|)
block|{
comment|/*  		 * For SMP systems, create twice as many arenas as there are 		 * CPUs by default. 		 */
name|opt_narenas_lshift
operator|++
expr_stmt|;
block|}
comment|/* Determine how many arenas to use. */
name|narenas
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|opt_narenas_lshift
operator|>
literal|0
condition|)
name|narenas
operator|<<=
name|opt_narenas_lshift
expr_stmt|;
ifdef|#
directive|ifdef
name|NO_TLS
if|if
condition|(
name|narenas
operator|>
literal|1
condition|)
block|{
specifier|static
specifier|const
name|unsigned
name|primes
index|[]
init|=
block|{
literal|1
block|,
literal|3
block|,
literal|5
block|,
literal|7
block|,
literal|11
block|,
literal|13
block|,
literal|17
block|,
literal|19
block|,
literal|23
block|,
literal|29
block|,
literal|31
block|,
literal|37
block|,
literal|41
block|,
literal|43
block|,
literal|47
block|,
literal|53
block|,
literal|59
block|,
literal|61
block|,
literal|67
block|,
literal|71
block|,
literal|73
block|,
literal|79
block|,
literal|83
block|,
literal|89
block|,
literal|97
block|,
literal|101
block|,
literal|103
block|,
literal|107
block|,
literal|109
block|,
literal|113
block|,
literal|127
block|,
literal|131
block|,
literal|137
block|,
literal|139
block|,
literal|149
block|,
literal|151
block|,
literal|157
block|,
literal|163
block|,
literal|167
block|,
literal|173
block|,
literal|179
block|,
literal|181
block|,
literal|191
block|,
literal|193
block|,
literal|197
block|,
literal|199
block|,
literal|211
block|,
literal|223
block|,
literal|227
block|,
literal|229
block|,
literal|233
block|,
literal|239
block|,
literal|241
block|,
literal|251
block|,
literal|257
block|,
literal|263
block|}
decl_stmt|;
name|unsigned
name|i
decl_stmt|,
name|nprimes
decl_stmt|,
name|parenas
decl_stmt|;
comment|/* 		 * Pick a prime number of hash arenas that is more than narenas 		 * so that direct hashing of pthread_self() pointers tends to 		 * spread allocations evenly among the arenas. 		 */
name|assert
argument_list|(
operator|(
name|narenas
operator|&
literal|1
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* narenas must be even. */
name|nprimes
operator|=
sizeof|sizeof
argument_list|(
name|primes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|unsigned
argument_list|)
expr_stmt|;
name|parenas
operator|=
name|primes
index|[
name|nprimes
operator|-
literal|1
index|]
expr_stmt|;
comment|/* In case not enough primes. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nprimes
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|primes
index|[
name|i
index|]
operator|>
name|narenas
condition|)
block|{
name|parenas
operator|=
name|primes
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
block|}
name|narenas
operator|=
name|parenas
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_TLS
name|next_arena
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* Allocate and initialize arenas. */
name|arenas
operator|=
operator|(
name|arena_t
operator|*
operator|*
operator|)
name|base_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|arena_t
operator|*
argument_list|)
operator|*
name|narenas
argument_list|)
expr_stmt|;
if|if
condition|(
name|arenas
operator|==
name|NULL
condition|)
return|return
operator|(
name|true
operator|)
return|;
comment|/* 	 * Zero the array.  In practice, this should always be pre-zeroed, 	 * since it was just mmap()ed, but let's be sure. 	 */
name|memset
argument_list|(
name|arenas
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|arena_t
operator|*
argument_list|)
operator|*
name|narenas
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize one arena here.  The rest are lazily created in 	 * arena_choose_hard(). 	 */
name|arenas_extend
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|arenas
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
return|return
operator|(
name|true
operator|)
return|;
name|malloc_mutex_init
argument_list|(
operator|&
name|arenas_mtx
argument_list|)
expr_stmt|;
name|malloc_initialized
operator|=
name|true
expr_stmt|;
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * End library-internal functions.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin malloc(3)-compatible functions.  */
end_comment

begin_function
name|void
modifier|*
name|malloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|arena_t
modifier|*
name|arena
decl_stmt|;
if|if
condition|(
name|malloc_init
argument_list|()
condition|)
block|{
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|opt_sysv
operator|==
name|false
condition|)
name|ret
operator|=
operator|&
name|nil
expr_stmt|;
else|else
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
name|arena
operator|=
name|choose_arena
argument_list|()
expr_stmt|;
if|if
condition|(
name|arena
operator|!=
name|NULL
condition|)
name|ret
operator|=
name|imalloc
argument_list|(
name|arena
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|NULL
expr_stmt|;
name|RETURN
label|:
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|opt_xmalloc
condition|)
block|{
name|malloc_printf
argument_list|(
literal|"%s: (malloc) Error in malloc(%zu):"
literal|" out of memory\n"
argument_list|,
name|_getprogname
argument_list|()
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|errno
operator|=
name|ENOMEM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opt_zero
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|UTRACE
argument_list|(
literal|0
argument_list|,
name|size
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|posix_memalign
parameter_list|(
name|void
modifier|*
modifier|*
name|memptr
parameter_list|,
name|size_t
name|alignment
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|arena_t
modifier|*
name|arena
decl_stmt|;
name|void
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|malloc_init
argument_list|()
condition|)
name|result
operator|=
name|NULL
expr_stmt|;
else|else
block|{
comment|/* Make sure that alignment is a large enough power of 2. */
if|if
condition|(
operator|(
operator|(
name|alignment
operator|-
literal|1
operator|)
operator|&
name|alignment
operator|)
operator|!=
literal|0
operator|||
name|alignment
operator|<
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
condition|)
block|{
if|if
condition|(
name|opt_xmalloc
condition|)
block|{
name|malloc_printf
argument_list|(
literal|"%s: (malloc) Error in"
literal|" posix_memalign(%zu, %zu):"
literal|" invalid alignment\n"
argument_list|,
name|_getprogname
argument_list|()
argument_list|,
name|alignment
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|result
operator|=
name|NULL
expr_stmt|;
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
name|arena
operator|=
name|choose_arena
argument_list|()
expr_stmt|;
if|if
condition|(
name|arena
operator|!=
name|NULL
condition|)
name|result
operator|=
name|ipalloc
argument_list|(
name|arena
argument_list|,
name|alignment
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|result
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|opt_xmalloc
condition|)
block|{
name|malloc_printf
argument_list|(
literal|"%s: (malloc) Error in"
literal|" posix_memalign(%zu, %zu): out of memory\n"
argument_list|,
name|_getprogname
argument_list|()
argument_list|,
name|alignment
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|ret
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
elseif|else
if|if
condition|(
name|opt_zero
condition|)
name|memset
argument_list|(
name|result
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
operator|*
name|memptr
operator|=
name|result
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
name|RETURN
label|:
name|UTRACE
argument_list|(
literal|0
argument_list|,
name|size
argument_list|,
name|result
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|calloc
parameter_list|(
name|size_t
name|num
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
name|arena_t
modifier|*
name|arena
decl_stmt|;
if|if
condition|(
name|malloc_init
argument_list|()
condition|)
block|{
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
if|if
condition|(
name|num
operator|*
name|size
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|opt_sysv
operator|==
name|false
condition|)
name|ret
operator|=
operator|&
name|nil
expr_stmt|;
else|else
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
elseif|else
if|if
condition|(
operator|(
name|num
operator|*
name|size
operator|)
operator|/
name|size
operator|!=
name|num
condition|)
block|{
comment|/* size_t overflow. */
name|ret
operator|=
name|NULL
expr_stmt|;
goto|goto
name|RETURN
goto|;
block|}
name|arena
operator|=
name|choose_arena
argument_list|()
expr_stmt|;
if|if
condition|(
name|arena
operator|!=
name|NULL
condition|)
name|ret
operator|=
name|icalloc
argument_list|(
name|arena
argument_list|,
name|num
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|NULL
expr_stmt|;
name|RETURN
label|:
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|opt_xmalloc
condition|)
block|{
name|malloc_printf
argument_list|(
literal|"%s: (malloc) Error in"
literal|" calloc(%zu, %zu): out of memory\n"
argument_list|,
name|_getprogname
argument_list|()
argument_list|,
name|num
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|errno
operator|=
name|ENOMEM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opt_zero
condition|)
block|{
comment|/* 		 * This has the side effect of faulting pages in, even if the 		 * pages are pre-zeroed by the kernel. 		 */
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|num
operator|*
name|size
argument_list|)
expr_stmt|;
block|}
name|UTRACE
argument_list|(
literal|0
argument_list|,
name|num
operator|*
name|size
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|realloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|void
modifier|*
name|ret
decl_stmt|;
if|if
condition|(
name|size
operator|!=
literal|0
condition|)
block|{
name|arena_t
modifier|*
name|arena
decl_stmt|;
if|if
condition|(
name|ptr
operator|!=
operator|&
name|nil
operator|&&
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|malloc_initialized
argument_list|)
expr_stmt|;
name|arena
operator|=
name|choose_arena
argument_list|()
expr_stmt|;
if|if
condition|(
name|arena
operator|!=
name|NULL
condition|)
name|ret
operator|=
name|iralloc
argument_list|(
name|arena
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|opt_xmalloc
condition|)
block|{
name|malloc_printf
argument_list|(
literal|"%s: (malloc) Error in"
literal|" ralloc(%p, %zu): out of memory\n"
argument_list|,
name|_getprogname
argument_list|()
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|errno
operator|=
name|ENOMEM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opt_zero
condition|)
block|{
name|size_t
name|old_size
decl_stmt|;
name|old_size
operator|=
name|isalloc
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_size
operator|<
name|size
condition|)
block|{
name|memset
argument_list|(
operator|&
operator|(
operator|(
name|char
operator|*
operator|)
name|ret
operator|)
index|[
name|old_size
index|]
argument_list|,
literal|0
argument_list|,
name|size
operator|-
name|old_size
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|malloc_init
argument_list|()
condition|)
name|ret
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|arena
operator|=
name|choose_arena
argument_list|()
expr_stmt|;
if|if
condition|(
name|arena
operator|!=
name|NULL
condition|)
name|ret
operator|=
name|imalloc
argument_list|(
name|arena
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|ret
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|opt_xmalloc
condition|)
block|{
name|malloc_printf
argument_list|(
literal|"%s: (malloc) Error in"
literal|" ralloc(%p, %zu): out of memory\n"
argument_list|,
name|_getprogname
argument_list|()
argument_list|,
name|ptr
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|errno
operator|=
name|ENOMEM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opt_zero
condition|)
name|memset
argument_list|(
name|ret
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ptr
operator|!=
operator|&
name|nil
operator|&&
name|ptr
operator|!=
name|NULL
condition|)
name|idalloc
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|&
name|nil
expr_stmt|;
block|}
name|UTRACE
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|free
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|UTRACE
argument_list|(
name|ptr
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
operator|&
name|nil
operator|&&
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|assert
argument_list|(
name|malloc_initialized
argument_list|)
expr_stmt|;
name|idalloc
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * End malloc(3)-compatible functions.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

begin_comment
comment|/*  * Begin library-private functions, used by threading libraries for protection  * of malloc during fork().  These functions are only called if the program is  * running in threaded mode, so there is no need to check whether the program  * is threaded here.  */
end_comment

begin_function
name|void
name|_malloc_prefork
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
comment|/* Acquire all mutexes in a safe order. */
name|malloc_mutex_lock
argument_list|(
operator|&
name|arenas_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|narenas
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|arenas
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|malloc_mutex_lock
argument_list|(
operator|&
name|arenas
index|[
name|i
index|]
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arenas_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|_malloc_postfork
parameter_list|(
name|void
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
comment|/* Release all mutexes, now that fork() has completed. */
name|malloc_mutex_unlock
argument_list|(
operator|&
name|chunks_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_unlock
argument_list|(
operator|&
name|base_mtx
argument_list|)
expr_stmt|;
name|malloc_mutex_lock
argument_list|(
operator|&
name|arenas_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|narenas
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|arenas
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arenas
index|[
name|i
index|]
operator|->
name|mtx
argument_list|)
expr_stmt|;
block|}
name|malloc_mutex_unlock
argument_list|(
operator|&
name|arenas_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * End library-private functions.  */
end_comment

begin_comment
comment|/******************************************************************************/
end_comment

end_unit

