begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * SPDX-License-Identifier: MIT  *  * Copyright (c) 2005-2014 Rich Felker, et al.  *  * Permission is hereby granted, free of charge, to any person obtaining  * a copy of this software and associated documentation files (the  * "Software"), to deal in the Software without restriction, including  * without limitation the rights to use, copy, modify, merge, publish,  * distribute, sublicense, and/or sell copies of the Software, and to  * permit persons to whom the Software is furnished to do so, subject to  * the following conditions:  *  * The above copyright notice and this permission notice shall be  * included in all copies or substantial portions of the Software.  *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF  * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY  * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,  * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE  * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_function
specifier|static
name|char
modifier|*
name|twobyte_memmem
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|h
parameter_list|,
name|size_t
name|k
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|n
parameter_list|)
block|{
name|uint16_t
name|nw
init|=
name|n
index|[
literal|0
index|]
operator|<<
literal|8
operator||
name|n
index|[
literal|1
index|]
decl_stmt|,
name|hw
init|=
name|h
index|[
literal|0
index|]
operator|<<
literal|8
operator||
name|h
index|[
literal|1
index|]
decl_stmt|;
for|for
control|(
name|h
operator|++
operator|,
name|k
operator|--
init|;
name|k
condition|;
name|k
operator|--
operator|,
name|hw
operator|=
name|hw
operator|<<
literal|8
operator||
operator|*
operator|++
name|h
control|)
if|if
condition|(
name|hw
operator|==
name|nw
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|h
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|threebyte_memmem
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|h
parameter_list|,
name|size_t
name|k
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|n
parameter_list|)
block|{
name|uint32_t
name|nw
init|=
name|n
index|[
literal|0
index|]
operator|<<
literal|24
operator||
name|n
index|[
literal|1
index|]
operator|<<
literal|16
operator||
name|n
index|[
literal|2
index|]
operator|<<
literal|8
decl_stmt|;
name|uint32_t
name|hw
init|=
name|h
index|[
literal|0
index|]
operator|<<
literal|24
operator||
name|h
index|[
literal|1
index|]
operator|<<
literal|16
operator||
name|h
index|[
literal|2
index|]
operator|<<
literal|8
decl_stmt|;
for|for
control|(
name|h
operator|+=
literal|2
operator|,
name|k
operator|-=
literal|2
init|;
name|k
condition|;
name|k
operator|--
operator|,
name|hw
operator|=
operator|(
name|hw
operator||
operator|*
operator|++
name|h
operator|)
operator|<<
literal|8
control|)
if|if
condition|(
name|hw
operator|==
name|nw
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|h
operator|-
literal|2
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|fourbyte_memmem
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|h
parameter_list|,
name|size_t
name|k
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|n
parameter_list|)
block|{
name|uint32_t
name|nw
init|=
name|n
index|[
literal|0
index|]
operator|<<
literal|24
operator||
name|n
index|[
literal|1
index|]
operator|<<
literal|16
operator||
name|n
index|[
literal|2
index|]
operator|<<
literal|8
operator||
name|n
index|[
literal|3
index|]
decl_stmt|;
name|uint32_t
name|hw
init|=
name|h
index|[
literal|0
index|]
operator|<<
literal|24
operator||
name|h
index|[
literal|1
index|]
operator|<<
literal|16
operator||
name|h
index|[
literal|2
index|]
operator|<<
literal|8
operator||
name|h
index|[
literal|3
index|]
decl_stmt|;
for|for
control|(
name|h
operator|+=
literal|3
operator|,
name|k
operator|-=
literal|3
init|;
name|k
condition|;
name|k
operator|--
operator|,
name|hw
operator|=
name|hw
operator|<<
literal|8
operator||
operator|*
operator|++
name|h
control|)
if|if
condition|(
name|hw
operator|==
name|nw
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|h
operator|-
literal|3
return|;
return|return
literal|0
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)>(b)?(a):(b))
end_define

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)<(b)?(a):(b))
end_define

begin_define
define|#
directive|define
name|BITOP
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|op
parameter_list|)
define|\
value|((a)[(size_t)(b)/(8*sizeof *(a))] op (size_t)1<<((size_t)(b)%(8*sizeof *(a))))
end_define

begin_comment
comment|/*  * Two Way string search algorithm, with a bad shift table applied to the last  * byte of the window. A bit array marks which entries in the shift table are  * initialized to avoid fully initializing a 1kb/2kb table.  *  * Reference: CROCHEMORE M., PERRIN D., 1991, Two-way string-matching,  * Journal of the ACM 38(3):651-675  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|twoway_memmem
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|h
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|z
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|n
parameter_list|,
name|size_t
name|l
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|ip
decl_stmt|,
name|jp
decl_stmt|,
name|k
decl_stmt|,
name|p
decl_stmt|,
name|ms
decl_stmt|,
name|p0
decl_stmt|,
name|mem
decl_stmt|,
name|mem0
decl_stmt|;
name|size_t
name|byteset
index|[
literal|32
operator|/
sizeof|sizeof
argument_list|(
name|size_t
argument_list|)
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|size_t
name|shift
index|[
literal|256
index|]
decl_stmt|;
comment|/* Computing length of needle and fill shift table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|l
condition|;
name|i
operator|++
control|)
name|BITOP
argument_list|(
name|byteset
argument_list|,
name|n
index|[
name|i
index|]
argument_list|,
operator||=
argument_list|)
operator|,
name|shift
index|[
name|n
index|[
name|i
index|]
index|]
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* Compute maximal suffix */
name|ip
operator|=
operator|-
literal|1
expr_stmt|;
name|jp
operator|=
literal|0
expr_stmt|;
name|k
operator|=
name|p
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|jp
operator|+
name|k
operator|<
name|l
condition|)
block|{
if|if
condition|(
name|n
index|[
name|ip
operator|+
name|k
index|]
operator|==
name|n
index|[
name|jp
operator|+
name|k
index|]
condition|)
block|{
if|if
condition|(
name|k
operator|==
name|p
condition|)
block|{
name|jp
operator|+=
name|p
expr_stmt|;
name|k
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|k
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
index|[
name|ip
operator|+
name|k
index|]
operator|>
name|n
index|[
name|jp
operator|+
name|k
index|]
condition|)
block|{
name|jp
operator|+=
name|k
expr_stmt|;
name|k
operator|=
literal|1
expr_stmt|;
name|p
operator|=
name|jp
operator|-
name|ip
expr_stmt|;
block|}
else|else
block|{
name|ip
operator|=
name|jp
operator|++
expr_stmt|;
name|k
operator|=
name|p
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|ms
operator|=
name|ip
expr_stmt|;
name|p0
operator|=
name|p
expr_stmt|;
comment|/* And with the opposite comparison */
name|ip
operator|=
operator|-
literal|1
expr_stmt|;
name|jp
operator|=
literal|0
expr_stmt|;
name|k
operator|=
name|p
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|jp
operator|+
name|k
operator|<
name|l
condition|)
block|{
if|if
condition|(
name|n
index|[
name|ip
operator|+
name|k
index|]
operator|==
name|n
index|[
name|jp
operator|+
name|k
index|]
condition|)
block|{
if|if
condition|(
name|k
operator|==
name|p
condition|)
block|{
name|jp
operator|+=
name|p
expr_stmt|;
name|k
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|k
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|n
index|[
name|ip
operator|+
name|k
index|]
operator|<
name|n
index|[
name|jp
operator|+
name|k
index|]
condition|)
block|{
name|jp
operator|+=
name|k
expr_stmt|;
name|k
operator|=
literal|1
expr_stmt|;
name|p
operator|=
name|jp
operator|-
name|ip
expr_stmt|;
block|}
else|else
block|{
name|ip
operator|=
name|jp
operator|++
expr_stmt|;
name|k
operator|=
name|p
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ip
operator|+
literal|1
operator|>
name|ms
operator|+
literal|1
condition|)
name|ms
operator|=
name|ip
expr_stmt|;
else|else
name|p
operator|=
name|p0
expr_stmt|;
comment|/* Periodic needle? */
if|if
condition|(
name|memcmp
argument_list|(
name|n
argument_list|,
name|n
operator|+
name|p
argument_list|,
name|ms
operator|+
literal|1
argument_list|)
condition|)
block|{
name|mem0
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|MAX
argument_list|(
name|ms
argument_list|,
name|l
operator|-
name|ms
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|mem0
operator|=
name|l
operator|-
name|p
expr_stmt|;
name|mem
operator|=
literal|0
expr_stmt|;
comment|/* Search loop */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* If remainder of haystack is shorter than needle, done */
if|if
condition|(
name|z
operator|-
name|h
operator|<
name|l
condition|)
return|return
literal|0
return|;
comment|/* Check last byte first; advance by shift on mismatch */
if|if
condition|(
name|BITOP
argument_list|(
name|byteset
argument_list|,
name|h
index|[
name|l
operator|-
literal|1
index|]
argument_list|,
operator|&
argument_list|)
condition|)
block|{
name|k
operator|=
name|l
operator|-
name|shift
index|[
name|h
index|[
name|l
operator|-
literal|1
index|]
index|]
expr_stmt|;
if|if
condition|(
name|k
condition|)
block|{
if|if
condition|(
name|mem0
operator|&&
name|mem
operator|&&
name|k
operator|<
name|p
condition|)
name|k
operator|=
name|l
operator|-
name|p
expr_stmt|;
name|h
operator|+=
name|k
expr_stmt|;
name|mem
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
name|h
operator|+=
name|l
expr_stmt|;
name|mem
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* Compare right half */
for|for
control|(
name|k
operator|=
name|MAX
argument_list|(
name|ms
operator|+
literal|1
argument_list|,
name|mem
argument_list|)
init|;
name|k
operator|<
name|l
operator|&&
name|n
index|[
name|k
index|]
operator|==
name|h
index|[
name|k
index|]
condition|;
name|k
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|k
operator|<
name|l
condition|)
block|{
name|h
operator|+=
name|k
operator|-
name|ms
expr_stmt|;
name|mem
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* Compare left half */
for|for
control|(
name|k
operator|=
name|ms
operator|+
literal|1
init|;
name|k
operator|>
name|mem
operator|&&
name|n
index|[
name|k
operator|-
literal|1
index|]
operator|==
name|h
index|[
name|k
operator|-
literal|1
index|]
condition|;
name|k
operator|--
control|)
empty_stmt|;
if|if
condition|(
name|k
operator|<=
name|mem
condition|)
return|return
operator|(
name|char
operator|*
operator|)
name|h
return|;
name|h
operator|+=
name|p
expr_stmt|;
name|mem
operator|=
name|mem0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
modifier|*
name|memmem
parameter_list|(
specifier|const
name|void
modifier|*
name|h0
parameter_list|,
name|size_t
name|k
parameter_list|,
specifier|const
name|void
modifier|*
name|n0
parameter_list|,
name|size_t
name|l
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|h
init|=
name|h0
decl_stmt|,
modifier|*
name|n
init|=
name|n0
decl_stmt|;
comment|/* Return immediately on empty needle */
if|if
condition|(
operator|!
name|l
condition|)
return|return
operator|(
name|void
operator|*
operator|)
name|h
return|;
comment|/* Return immediately when needle is longer than haystack */
if|if
condition|(
name|k
operator|<
name|l
condition|)
return|return
literal|0
return|;
comment|/* Use faster algorithms for short needles */
name|h
operator|=
name|memchr
argument_list|(
name|h0
argument_list|,
operator|*
name|n
argument_list|,
name|k
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|h
operator|||
name|l
operator|==
literal|1
condition|)
return|return
operator|(
name|void
operator|*
operator|)
name|h
return|;
name|k
operator|-=
name|h
operator|-
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|h0
expr_stmt|;
if|if
condition|(
name|k
operator|<
name|l
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|l
operator|==
literal|2
condition|)
return|return
name|twobyte_memmem
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|n
argument_list|)
return|;
if|if
condition|(
name|l
operator|==
literal|3
condition|)
return|return
name|threebyte_memmem
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|n
argument_list|)
return|;
if|if
condition|(
name|l
operator|==
literal|4
condition|)
return|return
name|fourbyte_memmem
argument_list|(
name|h
argument_list|,
name|k
argument_list|,
name|n
argument_list|)
return|;
return|return
name|twoway_memmem
argument_list|(
name|h
argument_list|,
name|h
operator|+
name|k
argument_list|,
name|n
argument_list|,
name|l
argument_list|)
return|;
block|}
end_function

end_unit

