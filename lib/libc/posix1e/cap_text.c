begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2000 Robert N. M. Watson  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_comment
comment|/*  * TrustedBSD Project - support for POSIX.1e process capabilities  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"namespace.h"
end_include

begin_include
include|#
directive|include
file|<sys/capability.h>
end_include

begin_include
include|#
directive|include
file|"un-namespace.h"
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/*  * this one is in sys/capability.h now:  * static const size_t CAP_MAX_BUF_LEN = 1024;  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|size_t
name|CAP_MAX_SMALL_BUF_LEN
init|=
literal|64
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|CAP_FLAGS
index|[
literal|8
index|]
init|=
block|{
literal|""
block|,
comment|/* 000 */
literal|"e"
block|,
comment|/* 001 */
literal|"i"
block|,
comment|/* 010 */
literal|"ei"
block|,
comment|/* 011 */
literal|"p"
block|,
comment|/* 100 */
literal|"ep"
block|,
comment|/* 101 */
literal|"ip"
block|,
comment|/* 110 */
literal|"eip"
block|,
comment|/* 111 */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|CAP_SEP
init|=
literal|": \t"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|CAP_OPERATION
init|=
literal|"=-+"
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|cap_info
block|{
name|char
modifier|*
name|ci_name
decl_stmt|;
name|cap_value_t
name|ci_cap
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|cap_info
name|cap_info_array
index|[]
init|=
block|{
block|{
literal|"CAP_CHOWN"
block|,
name|CAP_CHOWN
block|}
block|,
block|{
literal|"CAP_DAC_EXECUTE"
block|,
name|CAP_DAC_EXECUTE
block|}
block|,
block|{
literal|"CAP_DAC_WRITE"
block|,
name|CAP_DAC_WRITE
block|}
block|,
block|{
literal|"CAP_DAC_READ_SEARCH"
block|,
name|CAP_DAC_READ_SEARCH
block|}
block|,
block|{
literal|"CAP_FOWNER"
block|,
name|CAP_FOWNER
block|}
block|,
block|{
literal|"CAP_FSETID"
block|,
name|CAP_FSETID
block|}
block|,
block|{
literal|"CAP_KILL"
block|,
name|CAP_KILL
block|}
block|,
block|{
literal|"CAP_LINK_DIR"
block|,
name|CAP_LINK_DIR
block|}
block|,
block|{
literal|"CAP_SETFCAP"
block|,
name|CAP_SETFCAP
block|}
block|,
block|{
literal|"CAP_SETGID"
block|,
name|CAP_SETGID
block|}
block|,
block|{
literal|"CAP_SETUID"
block|,
name|CAP_SETUID
block|}
block|,
block|{
literal|"CAP_MAC_DOWNGRADE"
block|,
name|CAP_MAC_DOWNGRADE
block|}
block|,
block|{
literal|"CAP_MAC_READ"
block|,
name|CAP_MAC_READ
block|}
block|,
block|{
literal|"CAP_MAC_RELABEL_SUBJ"
block|,
name|CAP_MAC_RELABEL_SUBJ
block|}
block|,
block|{
literal|"CAP_MAC_UPGRADE"
block|,
name|CAP_MAC_UPGRADE
block|}
block|,
block|{
literal|"CAP_MAC_WRITE"
block|,
name|CAP_MAC_WRITE
block|}
block|,
block|{
literal|"CAP_INF_NOFLOAT_OBJ"
block|,
name|CAP_INF_NOFLOAT_OBJ
block|}
block|,
block|{
literal|"CAP_INF_NOFLOAT_SUBJ"
block|,
name|CAP_INF_NOFLOAT_SUBJ
block|}
block|,
block|{
literal|"CAP_INF_RELABEL_OBJ"
block|,
name|CAP_INF_RELABEL_OBJ
block|}
block|,
block|{
literal|"CAP_INF_RELABEL_SUBJ"
block|,
name|CAP_INF_RELABEL_SUBJ
block|}
block|,
block|{
literal|"CAP_AUDIT_CONTROL"
block|,
name|CAP_AUDIT_CONTROL
block|}
block|,
block|{
literal|"CAP_AUDIT_WRITE"
block|,
name|CAP_AUDIT_WRITE
block|}
block|,
block|{
literal|"CAP_SETPCAP"
block|,
name|CAP_SETPCAP
block|}
block|,
block|{
literal|"CAP_SYS_SETFFLAG"
block|,
name|CAP_SYS_SETFFLAG
block|}
block|,
block|{
literal|"CAP_LINUX_IMMUTABLE"
block|,
name|CAP_SYS_SETFFLAG
block|}
block|,
block|{
literal|"CAP_NET_BIND_SERVICE"
block|,
name|CAP_NET_BIND_SERVICE
block|}
block|,
block|{
literal|"CAP_NET_BROADCAST"
block|,
name|CAP_NET_BROADCAST
block|}
block|,
block|{
literal|"CAP_NET_ADMIN"
block|,
name|CAP_NET_ADMIN
block|}
block|,
block|{
literal|"CAP_NET_RAW"
block|,
name|CAP_NET_RAW
block|}
block|,
block|{
literal|"CAP_IPC_LOCK"
block|,
name|CAP_IPC_LOCK
block|}
block|,
block|{
literal|"CAP_IPC_OWNER"
block|,
name|CAP_IPC_OWNER
block|}
block|,
block|{
literal|"CAP_SYS_MODULE"
block|,
name|CAP_SYS_MODULE
block|}
block|,
block|{
literal|"CAP_SYS_RAWIO"
block|,
name|CAP_SYS_RAWIO
block|}
block|,
block|{
literal|"CAP_SYS_CHROOT"
block|,
name|CAP_SYS_CHROOT
block|}
block|,
block|{
literal|"CAP_SYS_PTRACE"
block|,
name|CAP_SYS_PTRACE
block|}
block|,
block|{
literal|"CAP_SYS_PACCT"
block|,
name|CAP_SYS_PACCT
block|}
block|,
block|{
literal|"CAP_SYS_ADMIN"
block|,
name|CAP_SYS_ADMIN
block|}
block|,
block|{
literal|"CAP_SYS_BOOT"
block|,
name|CAP_SYS_BOOT
block|}
block|,
block|{
literal|"CAP_SYS_NICE"
block|,
name|CAP_SYS_NICE
block|}
block|,
block|{
literal|"CAP_SYS_RESOURCE"
block|,
name|CAP_SYS_RESOURCE
block|}
block|,
block|{
literal|"CAP_SYS_TIME"
block|,
name|CAP_SYS_TIME
block|}
block|,
block|{
literal|"CAP_SYS_TTY_CONFIG"
block|,
name|CAP_SYS_TTY_CONFIG
block|}
block|,
block|{
literal|"CAP_MKNOD"
block|,
name|CAP_MKNOD
block|}
block|,
block|{
literal|""
block|,
name|CAP_ALL_OFF
block|}
block|,
block|{
literal|"all"
block|,
name|CAP_ALL_ON
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|cap_info_array_len
init|=
sizeof|sizeof
argument_list|(
name|cap_info_array
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|cap_info_array
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|cap_value_t
name|cap_list
index|[]
init|=
block|{
name|CAP_CHOWN
block|,
name|CAP_DAC_EXECUTE
block|,
name|CAP_DAC_WRITE
block|,
name|CAP_DAC_READ_SEARCH
block|,
name|CAP_FOWNER
block|,
name|CAP_FSETID
block|,
name|CAP_KILL
block|,
name|CAP_LINK_DIR
block|,
name|CAP_SETFCAP
block|,
name|CAP_SETGID
block|,
name|CAP_SETUID
block|,
name|CAP_MAC_DOWNGRADE
block|,
name|CAP_MAC_READ
block|,
name|CAP_MAC_RELABEL_SUBJ
block|,
name|CAP_MAC_UPGRADE
block|,
name|CAP_MAC_WRITE
block|,
name|CAP_INF_NOFLOAT_OBJ
block|,
name|CAP_INF_NOFLOAT_SUBJ
block|,
name|CAP_INF_RELABEL_OBJ
block|,
name|CAP_INF_RELABEL_SUBJ
block|,
name|CAP_AUDIT_CONTROL
block|,
name|CAP_AUDIT_WRITE
block|,
name|CAP_SETPCAP
block|,
name|CAP_SYS_SETFFLAG
block|,
name|CAP_NET_BIND_SERVICE
block|,
name|CAP_NET_BROADCAST
block|,
name|CAP_NET_ADMIN
block|,
name|CAP_NET_RAW
block|,
name|CAP_IPC_LOCK
block|,
name|CAP_IPC_OWNER
block|,
name|CAP_SYS_MODULE
block|,
name|CAP_SYS_RAWIO
block|,
name|CAP_SYS_CHROOT
block|,
name|CAP_SYS_PTRACE
block|,
name|CAP_SYS_PACCT
block|,
name|CAP_SYS_ADMIN
block|,
name|CAP_SYS_BOOT
block|,
name|CAP_SYS_NICE
block|,
name|CAP_SYS_RESOURCE
block|,
name|CAP_SYS_TIME
block|,
name|CAP_SYS_TTY_CONFIG
block|,
name|CAP_MKNOD
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|int
name|cap_list_len
init|=
sizeof|sizeof
argument_list|(
name|cap_list
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|cap_list
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|cap_set
parameter_list|(
name|cap_t
name|cap_p
parameter_list|,
name|cap_flag_t
name|flags
parameter_list|,
name|cap_flag_value_t
name|fvalue
parameter_list|,
name|cap_value_t
name|cap_value
parameter_list|)
block|{
if|if
condition|(
name|flags
operator|&
name|CAP_EFFECTIVE
condition|)
block|{
if|if
condition|(
name|fvalue
operator|==
name|CAP_SET
condition|)
name|cap_p
operator|->
name|c_effective
operator||=
name|cap_value
expr_stmt|;
else|else
name|cap_p
operator|->
name|c_effective
operator|&=
operator|~
name|cap_value
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|CAP_INHERITABLE
condition|)
block|{
if|if
condition|(
name|fvalue
operator|==
name|CAP_SET
condition|)
name|cap_p
operator|->
name|c_inheritable
operator||=
name|cap_value
expr_stmt|;
else|else
name|cap_p
operator|->
name|c_inheritable
operator|&=
operator|~
name|cap_value
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|CAP_PERMITTED
condition|)
block|{
if|if
condition|(
name|fvalue
operator|==
name|CAP_SET
condition|)
name|cap_p
operator|->
name|c_permitted
operator||=
name|cap_value
expr_stmt|;
else|else
name|cap_p
operator|->
name|c_permitted
operator|&=
operator|~
name|cap_value
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|cap_is_set
parameter_list|(
name|cap_t
name|cap_p
parameter_list|,
name|cap_flag_t
name|cap_flag
parameter_list|,
name|cap_value_t
name|cap_value
parameter_list|)
block|{
name|int
name|seen
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cap_flag
operator|&
name|CAP_EFFECTIVE
condition|)
name|seen
operator||=
operator|(
name|cap_p
operator|->
name|c_effective
operator|&
name|cap_value
operator|)
expr_stmt|;
if|if
condition|(
name|cap_flag
operator|&
name|CAP_INHERITABLE
condition|)
name|seen
operator||=
operator|(
name|cap_p
operator|->
name|c_inheritable
operator|&
name|cap_value
operator|)
expr_stmt|;
if|if
condition|(
name|cap_flag
operator|&
name|CAP_PERMITTED
condition|)
name|seen
operator||=
operator|(
name|cap_p
operator|->
name|c_permitted
operator|&
name|cap_value
operator|)
expr_stmt|;
return|return
operator|(
name|seen
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|cap_flag_value_t
name|cap_value_to_flags
parameter_list|(
name|cap_t
name|cap_p
parameter_list|,
name|cap_value_t
name|cap_value
parameter_list|)
block|{
name|cap_flag_t
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cap_p
operator|->
name|c_effective
operator|&
name|cap_value
condition|)
name|flags
operator||=
name|CAP_EFFECTIVE
expr_stmt|;
if|if
condition|(
name|cap_p
operator|->
name|c_inheritable
operator|&
name|cap_value
condition|)
name|flags
operator||=
name|CAP_INHERITABLE
expr_stmt|;
if|if
condition|(
name|cap_p
operator|->
name|c_permitted
operator|&
name|cap_value
condition|)
name|flags
operator||=
name|CAP_PERMITTED
expr_stmt|;
return|return
operator|(
name|flags
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|cap_flags_to_string
parameter_list|(
name|cap_flag_t
name|flags
parameter_list|)
block|{
return|return
operator|(
name|CAP_FLAGS
index|[
name|flags
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cap_string_to_flags
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|cap_flag_t
modifier|*
name|flags
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|c
init|=
name|string
decl_stmt|;
operator|*
name|flags
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|c
operator|!=
literal|'\0'
condition|)
block|{
switch|switch
condition|(
operator|*
name|c
condition|)
block|{
case|case
literal|'e'
case|:
operator|*
name|flags
operator||=
name|CAP_EFFECTIVE
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
operator|*
name|flags
operator||=
name|CAP_INHERITABLE
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
operator|*
name|flags
operator||=
name|CAP_PERMITTED
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|c
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|cap_to_string
parameter_list|(
name|cap_value_t
name|cap
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cap_info_array_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cap_info_array
index|[
name|i
index|]
operator|.
name|ci_cap
operator|==
name|cap
condition|)
return|return
operator|(
name|cap_info_array
index|[
name|i
index|]
operator|.
name|ci_name
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|cap_from_string
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|cap_value_t
modifier|*
name|cap
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cap_info_array_len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|cap_info_array
index|[
name|i
index|]
operator|.
name|ci_name
argument_list|,
name|string
argument_list|)
condition|)
block|{
operator|*
name|cap
operator|=
name|cap_info_array
index|[
name|i
index|]
operator|.
name|ci_cap
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|cap_to_text
parameter_list|(
name|cap_t
name|cap_p
parameter_list|,
name|ssize_t
modifier|*
name|len_p
parameter_list|)
block|{
name|cap_value_t
name|cap_value
decl_stmt|;
name|cap_flag_t
name|cap_flag
decl_stmt|,
name|most_flag
decl_stmt|;
specifier|const
name|char
modifier|*
name|flag_s
decl_stmt|,
modifier|*
name|value_s
decl_stmt|,
modifier|*
name|prefix_s
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
name|minibuf
index|[
name|CAP_MAX_SMALL_BUF_LEN
index|]
decl_stmt|,
name|operation
decl_stmt|;
name|int
name|num_effective
decl_stmt|,
name|num_inheritable
decl_stmt|,
name|num_permitted
decl_stmt|;
name|int
name|most_effective
decl_stmt|,
name|most_inheritable
decl_stmt|,
name|most_permitted
decl_stmt|;
name|int
name|count
decl_stmt|,
name|any_so_far
decl_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|CAP_MAX_BUF_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * For the sake of prettiness, first walk each flag to see if it's 	 * set for cap_list_len/2 or more.  If so, list it as a plus, and 	 * do the remainder as negative, as needed.  This will tend to 	 * collapse a lot of the common all= cases. 	 */
name|num_effective
operator|=
name|num_inheritable
operator|=
name|num_permitted
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|cap_list_len
condition|;
name|count
operator|++
control|)
block|{
name|cap_value
operator|=
name|cap_list
index|[
name|count
index|]
expr_stmt|;
if|if
condition|(
name|cap_is_set
argument_list|(
name|cap_p
argument_list|,
name|CAP_EFFECTIVE
argument_list|,
name|cap_value
argument_list|)
condition|)
name|num_effective
operator|++
expr_stmt|;
if|if
condition|(
name|cap_is_set
argument_list|(
name|cap_p
argument_list|,
name|CAP_INHERITABLE
argument_list|,
name|cap_value
argument_list|)
condition|)
name|num_inheritable
operator|++
expr_stmt|;
if|if
condition|(
name|cap_is_set
argument_list|(
name|cap_p
argument_list|,
name|CAP_PERMITTED
argument_list|,
name|cap_value
argument_list|)
condition|)
name|num_permitted
operator|++
expr_stmt|;
block|}
name|most_effective
operator|=
operator|(
name|num_effective
operator|>
name|cap_list_len
operator|/
literal|2
operator|)
expr_stmt|;
name|most_inheritable
operator|=
operator|(
name|num_inheritable
operator|>
name|cap_list_len
operator|/
literal|2
operator|)
expr_stmt|;
name|most_permitted
operator|=
operator|(
name|num_permitted
operator|>
name|cap_list_len
operator|/
literal|2
operator|)
expr_stmt|;
name|most_flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|most_effective
condition|)
name|most_flag
operator||=
name|CAP_EFFECTIVE
expr_stmt|;
if|if
condition|(
name|most_inheritable
condition|)
name|most_flag
operator||=
name|CAP_INHERITABLE
expr_stmt|;
if|if
condition|(
name|most_permitted
condition|)
name|most_flag
operator||=
name|CAP_PERMITTED
expr_stmt|;
name|any_so_far
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|most_flag
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|strlcat
argument_list|(
name|buf
argument_list|,
literal|"all="
argument_list|,
name|CAP_MAX_BUF_LEN
argument_list|)
operator|>=
name|CAP_MAX_BUF_LEN
operator|)
operator|||
operator|(
name|strlcat
argument_list|(
name|buf
argument_list|,
name|CAP_FLAGS
index|[
name|most_flag
index|]
argument_list|,
name|CAP_MAX_BUF_LEN
argument_list|)
operator|>=
name|CAP_MAX_BUF_LEN
operator|)
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|any_so_far
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * For each capability value, determine how that value relates 	 * to the most common case, and (depending on CAP_PRINT_RELATIVE) 	 * either print out the value's flag set relative to the most 	 * common, or its absolute flag set. 	 */
for|for
control|(
name|count
operator|=
literal|0
init|;
name|count
operator|<
name|cap_list_len
condition|;
name|count
operator|++
control|)
block|{
name|cap_value
operator|=
name|cap_list
index|[
name|count
index|]
expr_stmt|;
name|cap_flag
operator|=
name|cap_value_to_flags
argument_list|(
name|cap_p
argument_list|,
name|cap_value
argument_list|)
expr_stmt|;
comment|/* 		 * Determine which, if any, flags need to be printed 		 * for this capability.  First, if the flags on the 		 * capability are equal to the "most" flags, just skip 		 * it. 		 */
if|if
condition|(
name|cap_flag
operator|==
name|most_flag
condition|)
continue|continue;
if|#
directive|if
name|CAP_PRINT_RELATIVE
comment|/* 		 * If the flags are a strict superset of the "most" 		 * flags, print it as a "+" case.  If they're a 		 * strict subset, print as a "-" case.  Otherwise, 		 * specify as an "=" case. 		 */
if|if
condition|(
operator|(
name|cap_flag
operator||
name|most_flag
operator|)
operator|==
name|cap_flag
condition|)
block|{
comment|/* Strict superset, use "+". */
name|operation
operator|=
literal|'+'
expr_stmt|;
name|cap_flag
operator|=
name|cap_flag
operator|&
operator|~
name|most_flag
expr_stmt|;
name|flag_s
operator|=
name|cap_flags_to_string
argument_list|(
name|cap_flag
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cap_flag
operator||
name|most_flag
operator|)
operator|==
name|most_flag
condition|)
block|{
comment|/* Strict subset, use "-". */
name|operation
operator|=
literal|'-'
expr_stmt|;
name|cap_flag
operator|=
name|most_flag
operator|&
operator|~
name|cap_flag
expr_stmt|;
name|flag_s
operator|=
name|cap_flags_to_string
argument_list|(
name|cap_flag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
endif|#
directive|endif
comment|/* Mixed, use an "=" case */
name|operation
operator|=
literal|'='
expr_stmt|;
name|flag_s
operator|=
name|cap_flags_to_string
argument_list|(
name|cap_flag
argument_list|)
expr_stmt|;
if|#
directive|if
name|CAP_PRINT_RELATIVE
block|}
endif|#
directive|endif
comment|/* 		 * Now assemble clause, and append to the string being 		 * built. 		 */
if|if
condition|(
name|any_so_far
condition|)
name|prefix_s
operator|=
literal|":"
expr_stmt|;
else|else
name|prefix_s
operator|=
literal|""
expr_stmt|;
name|value_s
operator|=
name|cap_to_string
argument_list|(
name|cap_value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|snprintf
argument_list|(
name|minibuf
argument_list|,
sizeof|sizeof
argument_list|(
name|minibuf
argument_list|)
argument_list|,
literal|"%s%s%c%s"
argument_list|,
name|prefix_s
argument_list|,
name|value_s
argument_list|,
name|operation
argument_list|,
name|flag_s
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|minibuf
argument_list|)
operator|)
operator|||
operator|(
name|strlcat
argument_list|(
name|buf
argument_list|,
name|minibuf
argument_list|,
name|CAP_MAX_BUF_LEN
argument_list|)
operator|>=
name|CAP_MAX_BUF_LEN
operator|)
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|len_p
condition|)
operator|*
name|len_p
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
name|cap_t
name|cap_from_text
parameter_list|(
specifier|const
name|char
modifier|*
name|buf_p
parameter_list|)
block|{
name|cap_value_t
name|cap_value_v
decl_stmt|,
name|cap_value_set_v
decl_stmt|;
name|cap_flag_t
name|cap_action_v
decl_stmt|;
name|cap_t
name|cap
decl_stmt|;
name|char
modifier|*
name|mybuf
decl_stmt|,
modifier|*
name|cur
decl_stmt|;
name|char
modifier|*
name|clause_s
decl_stmt|,
modifier|*
name|cap_value_s
decl_stmt|,
modifier|*
name|cap_value_list_s
decl_stmt|;
name|char
modifier|*
name|cap_action_list_s
decl_stmt|,
modifier|*
name|cap_action_s
decl_stmt|;
name|char
modifier|*
name|next_operation_p
decl_stmt|,
name|operation
decl_stmt|,
name|next_operation
decl_stmt|;
name|cap
operator|=
name|cap_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|cap
operator|==
name|NULL
condition|)
return|return
operator|(
operator|(
name|cap_t
operator|)
name|NULL
operator|)
return|;
name|mybuf
operator|=
name|strdup
argument_list|(
name|buf_p
argument_list|)
expr_stmt|;
if|if
condition|(
name|mybuf
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
goto|goto
name|err1
goto|;
block|}
comment|/* 	 * clase [SEP clause [SEP clause ...]] 	 * Split into "clauses", which are separated by a : or whitespace. 	 * 	 * clause = [caplist]actionlist 	 * caplist = capabilityname[,capabilityname[, ...]] 	 * actionlist = op[flags][op[flags]] 	 * Split clauses into a (possibly null) capability name list, and a 	 * set of one or more {op,flags} pairs. 	 * 	 * Each assignment is then applied to a running "state" to 	 * produce an end-result in the internal representation. 	 * Parsing failure at any time releases resources and results 	 * in EINVAL. 	 */
name|cur
operator|=
name|mybuf
expr_stmt|;
while|while
condition|(
operator|(
name|clause_s
operator|=
name|strsep
argument_list|(
operator|&
name|cur
argument_list|,
name|CAP_SEP
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Identify and NULL the first operation so that we 		 * can parse the capability name list, but save 		 * for later when we iterate over the operation list. 		 */
name|cap_action_list_s
operator|=
name|clause_s
expr_stmt|;
name|next_operation_p
operator|=
name|strpbrk
argument_list|(
name|cap_action_list_s
argument_list|,
name|CAP_OPERATION
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_operation_p
operator|==
name|NULL
condition|)
goto|goto
name|err2
goto|;
name|operation
operator|=
operator|*
name|next_operation_p
expr_stmt|;
name|cap_value_list_s
operator|=
name|strsep
argument_list|(
operator|&
name|cap_action_list_s
argument_list|,
name|CAP_OPERATION
argument_list|)
expr_stmt|;
if|if
condition|(
name|cap_value_list_s
operator|==
name|NULL
operator|||
name|cap_action_list_s
operator|==
name|NULL
condition|)
goto|goto
name|err2
goto|;
comment|/* 		 * cap_value_list_s now points at the NULL-terminated list 		 * of capability values, if any. 		 * cap_action_list_s now points to the NULL-terminated list 		 * of actions. 		 * 		 * First, parse the value list to generate a value set 		 * refering to the combined contents of the value list. 		 */
name|cap_value_set_v
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|cap_value_s
operator|=
name|strsep
argument_list|(
operator|&
name|cap_value_list_s
argument_list|,
literal|","
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Convert value string into internal representation. 			 * Reject if not a valid capability identifier. 			 */
if|if
condition|(
name|cap_from_string
argument_list|(
name|cap_value_s
argument_list|,
operator|&
name|cap_value_v
argument_list|)
condition|)
goto|goto
name|err2
goto|;
name|cap_value_set_v
operator||=
name|cap_value_v
expr_stmt|;
block|}
comment|/* 		 * While the current operation is non-0, parse its flags, 		 * apply the actions, and then repeat.  The first set 		 * is assured above when the capability list is split off. 		 */
while|while
condition|(
name|operation
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * Identify and save the next operation, then NULL 			 * it to find the end of the current flags. 			 */
name|next_operation_p
operator|=
name|strpbrk
argument_list|(
name|cap_action_list_s
argument_list|,
name|CAP_OPERATION
argument_list|)
expr_stmt|;
if|if
condition|(
name|next_operation_p
condition|)
name|next_operation
operator|=
operator|*
name|next_operation_p
expr_stmt|;
else|else
name|next_operation
operator|=
literal|0
expr_stmt|;
name|cap_action_s
operator|=
name|strsep
argument_list|(
operator|&
name|cap_action_list_s
argument_list|,
name|CAP_OPERATION
argument_list|)
expr_stmt|;
comment|/* 			 * Convert string form of flags to internal 			 * representation, reject if not possible. 			 */
if|if
condition|(
name|cap_string_to_flags
argument_list|(
name|cap_action_s
argument_list|,
operator|&
name|cap_action_v
argument_list|)
condition|)
goto|goto
name|err2
goto|;
comment|/* 			 * Now, based on operation apply actionlist flags 			 * to the capability value set built earlier from 			 * the capability list. 			 */
switch|switch
condition|(
name|operation
condition|)
block|{
case|case
literal|'='
case|:
comment|/* 				 * Remove current flags for the value set, 				 * replace with new flags. 				 * 				 * Spec requires that an "=" operation with 				 * no value set be treated as an "=" operation 				 * with a value set equivilent to "all". 				 */
if|if
condition|(
name|cap_value_set_v
operator|==
name|CAP_ALL_OFF
condition|)
block|{
name|cap_set
argument_list|(
name|cap
argument_list|,
name|CAP_EFFECTIVE
operator||
name|CAP_INHERITABLE
operator||
name|CAP_PERMITTED
argument_list|,
name|CAP_CLEAR
argument_list|,
name|CAP_ALL_ON
argument_list|)
expr_stmt|;
name|cap_set
argument_list|(
name|cap
argument_list|,
name|cap_action_v
argument_list|,
name|CAP_SET
argument_list|,
name|CAP_ALL_ON
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cap_set
argument_list|(
name|cap
argument_list|,
name|CAP_EFFECTIVE
operator||
name|CAP_INHERITABLE
operator||
name|CAP_PERMITTED
argument_list|,
name|CAP_CLEAR
argument_list|,
name|cap_value_set_v
argument_list|)
expr_stmt|;
name|cap_set
argument_list|(
name|cap
argument_list|,
name|cap_action_v
argument_list|,
name|CAP_SET
argument_list|,
name|cap_value_set_v
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'+'
case|:
comment|/* 				 * Add current flags to value set. 				 * 				 * Spec requires that a "+" operation with 				 * no value set be rejected. 				 */
if|if
condition|(
name|cap_value_set_v
operator|==
name|CAP_ALL_OFF
condition|)
goto|goto
name|err2
goto|;
name|cap_set
argument_list|(
name|cap
argument_list|,
name|cap_action_v
argument_list|,
name|CAP_SET
argument_list|,
name|cap_value_set_v
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
comment|/* 				 * Subtract current flags from value set. 				 * 				 * Spec requires that a "-" operation with 				 * no value set be treated as a "-" operation 				 * with a value set equivilent to "all". 				 */
if|if
condition|(
name|cap_value_set_v
operator|==
name|CAP_ALL_OFF
condition|)
name|cap_set
argument_list|(
name|cap
argument_list|,
name|cap_action_v
argument_list|,
name|CAP_CLEAR
argument_list|,
name|CAP_ALL_ON
argument_list|)
expr_stmt|;
else|else
name|cap_set
argument_list|(
name|cap
argument_list|,
name|cap_action_v
argument_list|,
name|CAP_CLEAR
argument_list|,
name|cap_value_set_v
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|err2
goto|;
block|}
name|operation
operator|=
name|next_operation
expr_stmt|;
block|}
block|}
return|return
operator|(
name|cap
operator|)
return|;
name|err2
label|:
name|errno
operator|=
name|EINVAL
expr_stmt|;
name|free
argument_list|(
name|mybuf
argument_list|)
expr_stmt|;
name|err1
label|:
name|cap_free
argument_list|(
name|cap
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|cap_t
operator|)
name|NULL
operator|)
return|;
block|}
end_function

end_unit

