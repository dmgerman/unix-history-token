begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"f2c.h"
end_include

begin_include
include|#
directive|include
file|"fio.h"
end_include

begin_include
include|#
directive|include
file|"lio.h"
end_include

begin_define
define|#
directive|define
name|MAX_NL_CACHE
value|3
end_define

begin_comment
comment|/* maximum number of namelist hash tables to cache */
end_comment

begin_define
define|#
directive|define
name|MAXDIM
value|20
end_define

begin_comment
comment|/* maximum number of subscripts */
end_comment

begin_struct
struct|struct
name|dimen
block|{
name|ftnlen
name|extent
decl_stmt|;
name|ftnlen
name|curval
decl_stmt|;
name|ftnlen
name|delta
decl_stmt|;
name|ftnlen
name|stride
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|dimen
name|dimen
typedef|;
end_typedef

begin_struct
struct|struct
name|hashentry
block|{
name|struct
name|hashentry
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|Vardesc
modifier|*
name|vd
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|hashentry
name|hashentry
typedef|;
end_typedef

begin_struct
struct|struct
name|hashtab
block|{
name|struct
name|hashtab
modifier|*
name|next
decl_stmt|;
name|Namelist
modifier|*
name|nl
decl_stmt|;
name|int
name|htsize
decl_stmt|;
name|hashentry
modifier|*
name|tab
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|hashtab
name|hashtab
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|hashtab
modifier|*
name|nl_cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|n_nlcache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|hashentry
modifier|*
modifier|*
name|zot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|colonseen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|ftnlen
name|f__typesize
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|flag
name|f__lquit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|f__lcount
decl_stmt|,
name|nml_read
decl_stmt|;
end_decl_stmt

begin_extern
extern|extern t_getc(Void
end_extern

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|KR_headers
end_ifdef

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|malloc
argument_list|()
decl_stmt|,
modifier|*
name|memset
argument_list|()
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ungetc
end_ifdef

begin_function
specifier|static
name|int
name|un_getc
parameter_list|(
name|x
parameter_list|,
name|f__cf
parameter_list|)
name|int
name|x
decl_stmt|;
name|FILE
modifier|*
name|f__cf
decl_stmt|;
block|{
return|return
name|ungetc
argument_list|(
name|x
argument_list|,
name|f__cf
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|un_getc
value|ungetc
end_define

begin_function_decl
specifier|extern
name|int
name|ungetc
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_undef
undef|#
directive|undef
name|abs
end_undef

begin_undef
undef|#
directive|undef
name|min
end_undef

begin_undef
undef|#
directive|undef
name|max
end_undef

begin_include
include|#
directive|include
file|"stdlib.h"
end_include

begin_include
include|#
directive|include
file|"string.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ungetc
end_ifdef

begin_function
specifier|static
name|int
name|un_getc
parameter_list|(
name|int
name|x
parameter_list|,
name|FILE
modifier|*
name|f__cf
parameter_list|)
block|{
return|return
name|ungetc
argument_list|(
name|x
argument_list|,
name|f__cf
argument_list|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|un_getc
value|ungetc
end_define

begin_function_decl
specifier|extern
name|int
name|ungetc
parameter_list|(
name|int
parameter_list|,
name|FILE
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* for systems with a buggy stdio.h */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|Vardesc
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|hash
parameter_list|(
name|ht
parameter_list|,
name|s
parameter_list|)
name|hashtab
modifier|*
name|ht
decl_stmt|;
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
else|#
directive|else
function|hash
parameter_list|(
name|hashtab
modifier|*
name|ht
parameter_list|,
specifier|register
name|char
modifier|*
name|s
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|x
decl_stmt|;
specifier|register
name|hashentry
modifier|*
name|h
decl_stmt|;
name|char
modifier|*
name|s0
init|=
name|s
decl_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|c
operator|=
operator|*
name|s
operator|++
condition|;
name|x
operator|=
name|x
operator|&
literal|0x4000
condition|?
operator|(
operator|(
name|x
operator|<<
literal|1
operator|)
operator|&
literal|0x7fff
operator|)
operator|+
literal|1
else|:
name|x
operator|<<
literal|1
control|)
name|x
operator|+=
name|c
expr_stmt|;
for|for
control|(
name|h
operator|=
operator|*
operator|(
name|zot
operator|=
name|ht
operator|->
name|tab
operator|+
name|x
operator|%
name|ht
operator|->
name|htsize
operator|)
init|;
name|h
condition|;
name|h
operator|=
name|h
operator|->
name|next
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|s0
argument_list|,
name|h
operator|->
name|name
argument_list|)
condition|)
return|return
name|h
operator|->
name|vd
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|hashtab
modifier|*
ifdef|#
directive|ifdef
name|KR_headers
name|mk_hashtab
parameter_list|(
name|nl
parameter_list|)
name|Namelist
modifier|*
name|nl
decl_stmt|;
else|#
directive|else
function|mk_hashtab
parameter_list|(
name|Namelist
modifier|*
name|nl
parameter_list|)
endif|#
directive|endif
block|{
name|int
name|nht
decl_stmt|,
name|nv
decl_stmt|;
name|hashtab
modifier|*
name|ht
decl_stmt|;
name|Vardesc
modifier|*
name|v
decl_stmt|,
modifier|*
modifier|*
name|vd
decl_stmt|,
modifier|*
modifier|*
name|vde
decl_stmt|;
name|hashentry
modifier|*
name|he
decl_stmt|;
name|hashtab
modifier|*
modifier|*
name|x
decl_stmt|,
modifier|*
modifier|*
name|x0
decl_stmt|,
modifier|*
name|y
decl_stmt|;
for|for
control|(
name|x
operator|=
operator|&
name|nl_cache
init|;
name|y
operator|=
operator|*
name|x
condition|;
name|x0
operator|=
name|x
operator|,
name|x
operator|=
operator|&
name|y
operator|->
name|next
control|)
if|if
condition|(
name|nl
operator|==
name|y
operator|->
name|nl
condition|)
return|return
name|y
return|;
if|if
condition|(
name|n_nlcache
operator|>=
name|MAX_NL_CACHE
condition|)
block|{
comment|/* discard least recently used namelist hash table */
name|y
operator|=
operator|*
name|x0
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|y
operator|->
name|next
argument_list|)
expr_stmt|;
name|y
operator|->
name|next
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|n_nlcache
operator|++
expr_stmt|;
name|nv
operator|=
name|nl
operator|->
name|nvars
expr_stmt|;
if|if
condition|(
name|nv
operator|>=
literal|0x4000
condition|)
name|nht
operator|=
literal|0x7fff
expr_stmt|;
else|else
block|{
for|for
control|(
name|nht
operator|=
literal|1
init|;
name|nht
operator|<
name|nv
condition|;
name|nht
operator|<<=
literal|1
control|)
empty_stmt|;
name|nht
operator|+=
name|nht
operator|-
literal|1
expr_stmt|;
block|}
name|ht
operator|=
operator|(
name|hashtab
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|hashtab
argument_list|)
operator|+
operator|(
name|nht
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|hashentry
operator|*
argument_list|)
operator|+
name|nv
operator|*
sizeof|sizeof
argument_list|(
name|hashentry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ht
condition|)
return|return
literal|0
return|;
name|he
operator|=
operator|(
name|hashentry
operator|*
operator|)
operator|&
name|ht
operator|->
name|tab
index|[
name|nht
index|]
expr_stmt|;
name|ht
operator|->
name|nl
operator|=
name|nl
expr_stmt|;
name|ht
operator|->
name|htsize
operator|=
name|nht
expr_stmt|;
name|ht
operator|->
name|next
operator|=
name|nl_cache
expr_stmt|;
name|nl_cache
operator|=
name|ht
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ht
operator|->
name|tab
argument_list|,
literal|0
argument_list|,
name|nht
operator|*
sizeof|sizeof
argument_list|(
name|hashentry
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|vd
operator|=
name|nl
operator|->
name|vars
expr_stmt|;
name|vde
operator|=
name|vd
operator|+
name|nv
expr_stmt|;
while|while
condition|(
name|vd
operator|<
name|vde
condition|)
block|{
name|v
operator|=
operator|*
name|vd
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|hash
argument_list|(
name|ht
argument_list|,
name|v
operator|->
name|name
argument_list|)
condition|)
block|{
name|he
operator|->
name|next
operator|=
operator|*
name|zot
expr_stmt|;
operator|*
name|zot
operator|=
name|he
expr_stmt|;
name|he
operator|->
name|name
operator|=
name|v
operator|->
name|name
expr_stmt|;
name|he
operator|->
name|vd
operator|=
name|v
expr_stmt|;
name|he
operator|++
expr_stmt|;
block|}
block|}
return|return
name|ht
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|Alpha
index|[
literal|256
index|]
decl_stmt|,
name|Alphanum
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|VOID
name|nl_init
parameter_list|(
name|Void
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
operator|!
name|f__init
condition|)
name|f_init
argument_list|()
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|"ABCDEFGHIJKLMNOPQRSTUVWXYZ"
init|;
name|c
operator|=
operator|*
name|s
operator|++
condition|;
control|)
name|Alpha
index|[
name|c
index|]
operator|=
name|Alphanum
index|[
name|c
index|]
operator|=
name|Alpha
index|[
name|c
operator|+
literal|'a'
operator|-
literal|'A'
index|]
operator|=
name|Alphanum
index|[
name|c
operator|+
literal|'a'
operator|-
literal|'A'
index|]
operator|=
name|c
expr_stmt|;
for|for
control|(
name|s
operator|=
literal|"0123456789_"
init|;
name|c
operator|=
operator|*
name|s
operator|++
condition|;
control|)
name|Alphanum
index|[
name|c
index|]
operator|=
name|c
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|GETC
parameter_list|(
name|x
parameter_list|)
value|(x=(*l_getc)())
end_define

begin_define
define|#
directive|define
name|Ungetc
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|(*l_ungetc)(x,y)
end_define

begin_function
specifier|static
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|getname
parameter_list|(
name|s
parameter_list|,
name|slen
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|slen
decl_stmt|;
else|#
directive|else
function|getname
parameter_list|(
specifier|register
name|char
modifier|*
name|s
parameter_list|,
name|int
name|slen
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|char
modifier|*
name|se
init|=
name|s
operator|+
name|slen
operator|-
literal|1
decl_stmt|;
specifier|register
name|int
name|ch
decl_stmt|;
name|GETC
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|s
operator|++
operator|=
name|Alpha
index|[
name|ch
operator|&
literal|0xff
index|]
operator|)
condition|)
block|{
if|if
condition|(
name|ch
operator|!=
name|EOF
condition|)
name|ch
operator|=
literal|115
expr_stmt|;
name|errfl
argument_list|(
name|f__elist
operator|->
name|cierr
argument_list|,
name|ch
argument_list|,
literal|"namelist read"
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|s
operator|=
name|Alphanum
index|[
name|GETC
argument_list|(
name|ch
argument_list|)
operator|&
literal|0xff
index|]
condition|)
if|if
condition|(
name|s
operator|<
name|se
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
name|err
argument_list|(
name|f__elist
operator|->
name|cierr
argument_list|,
name|EOF
argument_list|,
literal|"namelist read"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|>
literal|' '
condition|)
name|Ungetc
argument_list|(
name|ch
argument_list|,
name|f__cf
argument_list|)
expr_stmt|;
return|return
operator|*
name|s
operator|=
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|getnum
parameter_list|(
name|chp
parameter_list|,
name|val
parameter_list|)
name|int
modifier|*
name|chp
decl_stmt|;
name|ftnlen
modifier|*
name|val
decl_stmt|;
else|#
directive|else
function|getnum
parameter_list|(
name|int
modifier|*
name|chp
parameter_list|,
name|ftnlen
modifier|*
name|val
parameter_list|)
endif|#
directive|endif
block|{
specifier|register
name|int
name|ch
decl_stmt|,
name|sign
decl_stmt|;
specifier|register
name|ftnlen
name|x
decl_stmt|;
while|while
condition|(
name|GETC
argument_list|(
name|ch
argument_list|)
operator|<=
literal|' '
operator|&&
name|ch
operator|>=
literal|0
condition|)
empty_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'-'
condition|)
block|{
name|sign
operator|=
literal|1
expr_stmt|;
name|GETC
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sign
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'+'
condition|)
name|GETC
argument_list|(
name|ch
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|ch
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
operator|||
name|x
operator|>
literal|9
condition|)
return|return
literal|115
return|;
while|while
condition|(
name|GETC
argument_list|(
name|ch
argument_list|)
operator|>=
literal|'0'
operator|&&
name|ch
operator|<=
literal|'9'
condition|)
name|x
operator|=
literal|10
operator|*
name|x
operator|+
name|ch
operator|-
literal|'0'
expr_stmt|;
while|while
condition|(
name|ch
operator|<=
literal|' '
operator|&&
name|ch
operator|>=
literal|0
condition|)
name|GETC
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
return|return
name|EOF
return|;
operator|*
name|val
operator|=
name|sign
condition|?
operator|-
name|x
else|:
name|x
expr_stmt|;
operator|*
name|chp
operator|=
name|ch
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
ifdef|#
directive|ifdef
name|KR_headers
name|getdimen
parameter_list|(
name|chp
parameter_list|,
name|d
parameter_list|,
name|delta
parameter_list|,
name|extent
parameter_list|,
name|x1
parameter_list|)
name|int
modifier|*
name|chp
decl_stmt|;
name|dimen
modifier|*
name|d
decl_stmt|;
name|ftnlen
name|delta
decl_stmt|,
name|extent
decl_stmt|,
decl|*
name|x1
decl_stmt|;
end_function

begin_else
else|#
directive|else
end_else

begin_macro
name|getdimen
argument_list|(
argument|int *chp
argument_list|,
argument|dimen *d
argument_list|,
argument|ftnlen delta
argument_list|,
argument|ftnlen extent
argument_list|,
argument|ftnlen *x1
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
specifier|register
name|int
name|k
decl_stmt|;
name|ftnlen
name|x2
decl_stmt|,
name|x3
decl_stmt|;
if|if
condition|(
name|k
operator|=
name|getnum
argument_list|(
name|chp
argument_list|,
name|x1
argument_list|)
condition|)
return|return
name|k
return|;
name|x3
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|chp
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|k
operator|=
name|getnum
argument_list|(
name|chp
argument_list|,
operator|&
name|x2
argument_list|)
condition|)
return|return
name|k
return|;
name|x2
operator|-=
operator|*
name|x1
expr_stmt|;
if|if
condition|(
operator|*
name|chp
operator|==
literal|':'
condition|)
block|{
if|if
condition|(
name|k
operator|=
name|getnum
argument_list|(
name|chp
argument_list|,
operator|&
name|x3
argument_list|)
condition|)
return|return
name|k
return|;
if|if
condition|(
operator|!
name|x3
condition|)
return|return
literal|123
return|;
name|x2
operator|/=
name|x3
expr_stmt|;
name|colonseen
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|x2
operator|<
literal|0
operator|||
name|x2
operator|>=
name|extent
condition|)
return|return
literal|123
return|;
name|d
operator|->
name|extent
operator|=
name|x2
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|d
operator|->
name|extent
operator|=
literal|1
expr_stmt|;
name|d
operator|->
name|curval
operator|=
literal|0
expr_stmt|;
name|d
operator|->
name|delta
operator|=
name|delta
expr_stmt|;
name|d
operator|->
name|stride
operator|=
name|x3
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|No_Namelist_Questions
end_ifndef

begin_function
specifier|static
name|Void
ifdef|#
directive|ifdef
name|KR_headers
name|print_ne
parameter_list|(
name|a
parameter_list|)
name|cilist
modifier|*
name|a
decl_stmt|;
else|#
directive|else
function|print_ne
parameter_list|(
name|cilist
modifier|*
name|a
parameter_list|)
endif|#
directive|endif
block|{
name|flag
name|intext
init|=
name|f__external
decl_stmt|;
name|int
name|rpsave
init|=
name|f__recpos
decl_stmt|;
name|FILE
modifier|*
name|cfsave
init|=
name|f__cf
decl_stmt|;
name|unit
modifier|*
name|usave
init|=
name|f__curunit
decl_stmt|;
name|cilist
name|t
decl_stmt|;
name|t
operator|=
operator|*
name|a
expr_stmt|;
name|t
operator|.
name|ciunit
operator|=
literal|6
expr_stmt|;
name|s_wsne
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|f__cf
argument_list|)
expr_stmt|;
name|f__external
operator|=
name|intext
expr_stmt|;
name|f__reading
operator|=
literal|1
expr_stmt|;
name|f__recpos
operator|=
name|rpsave
expr_stmt|;
name|f__cf
operator|=
name|cfsave
expr_stmt|;
name|f__curunit
operator|=
name|usave
expr_stmt|;
name|f__elist
operator|=
name|a
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
name|where0
index|[]
init|=
literal|"namelist read start "
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|KR_headers
end_ifdef

begin_macro
name|x_rsne
argument_list|(
argument|a
argument_list|)
end_macro

begin_decl_stmt
name|cilist
modifier|*
name|a
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_macro
name|x_rsne
argument_list|(
argument|cilist *a
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|int
name|ch
decl_stmt|,
name|got1
decl_stmt|,
name|k
decl_stmt|,
name|n
decl_stmt|,
name|nd
decl_stmt|,
name|quote
decl_stmt|,
name|readall
decl_stmt|;
name|Namelist
modifier|*
name|nl
decl_stmt|;
specifier|static
name|char
name|where
index|[]
init|=
literal|"namelist read"
decl_stmt|;
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|hashtab
modifier|*
name|ht
decl_stmt|;
name|Vardesc
modifier|*
name|v
decl_stmt|;
name|dimen
modifier|*
name|dn
decl_stmt|,
modifier|*
name|dn0
decl_stmt|,
modifier|*
name|dn1
decl_stmt|;
name|ftnlen
modifier|*
name|dims
decl_stmt|,
modifier|*
name|dims1
decl_stmt|;
name|ftnlen
name|b
decl_stmt|,
name|b0
decl_stmt|,
name|b1
decl_stmt|,
name|ex
decl_stmt|,
name|no
decl_stmt|,
name|no1
decl_stmt|,
name|nomax
decl_stmt|,
name|size
decl_stmt|,
name|span
decl_stmt|;
name|ftnint
name|type
decl_stmt|;
name|char
modifier|*
name|vaddr
decl_stmt|;
name|long
name|iva
decl_stmt|,
name|ivae
decl_stmt|;
name|dimen
name|dimens
index|[
name|MAXDIM
index|]
decl_stmt|,
name|substr
decl_stmt|;
if|if
condition|(
operator|!
name|Alpha
index|[
literal|'a'
index|]
condition|)
name|nl_init
argument_list|()
expr_stmt|;
name|f__reading
operator|=
literal|1
expr_stmt|;
name|f__formatted
operator|=
literal|1
expr_stmt|;
name|got1
operator|=
literal|0
expr_stmt|;
name|top
label|:
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
name|GETC
argument_list|(
name|ch
argument_list|)
condition|)
block|{
case|case
name|EOF
case|:
name|eof
label|:
name|err
argument_list|(
name|a
operator|->
name|ciend
argument_list|,
operator|(
name|EOF
operator|)
argument_list|,
name|where0
argument_list|)
expr_stmt|;
case|case
literal|'&'
case|:
case|case
literal|'$'
case|:
goto|goto
name|have_amp
goto|;
ifndef|#
directive|ifndef
name|No_Namelist_Questions
case|case
literal|'?'
case|:
name|print_ne
argument_list|(
name|a
argument_list|)
expr_stmt|;
continue|continue;
endif|#
directive|endif
default|default:
if|if
condition|(
name|ch
operator|<=
literal|' '
operator|&&
name|ch
operator|>=
literal|0
condition|)
continue|continue;
ifndef|#
directive|ifndef
name|No_Namelist_Comments
while|while
condition|(
name|GETC
argument_list|(
name|ch
argument_list|)
operator|!=
literal|'\n'
condition|)
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
goto|goto
name|eof
goto|;
else|#
directive|else
name|errfl
argument_list|(
name|a
operator|->
name|cierr
argument_list|,
literal|115
argument_list|,
name|where0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|have_amp
label|:
if|if
condition|(
name|ch
operator|=
name|getname
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
condition|)
return|return
name|ch
return|;
name|nl
operator|=
operator|(
name|Namelist
operator|*
operator|)
name|a
operator|->
name|cifmt
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
name|nl
operator|->
name|name
argument_list|)
condition|)
ifdef|#
directive|ifdef
name|No_Bad_Namelist_Skip
name|errfl
argument_list|(
name|a
operator|->
name|cierr
argument_list|,
literal|118
argument_list|,
name|where0
argument_list|)
expr_stmt|;
else|#
directive|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Skipping namelist \"%s\": seeking namelist \"%s\".\n"
argument_list|,
name|buf
argument_list|,
name|nl
operator|->
name|name
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
name|GETC
argument_list|(
name|ch
argument_list|)
condition|)
block|{
case|case
name|EOF
case|:
name|err
argument_list|(
name|a
operator|->
name|ciend
argument_list|,
name|EOF
argument_list|,
name|where0
argument_list|)
expr_stmt|;
case|case
literal|'/'
case|:
case|case
literal|'&'
case|:
case|case
literal|'$'
case|:
if|if
condition|(
name|f__external
condition|)
name|e_rsle
argument_list|()
expr_stmt|;
else|else
name|z_rnew
argument_list|()
expr_stmt|;
goto|goto
name|top
goto|;
case|case
literal|'"'
case|:
case|case
literal|'\''
case|:
name|quote
operator|=
name|ch
expr_stmt|;
name|more_quoted
label|:
while|while
condition|(
name|GETC
argument_list|(
name|ch
argument_list|)
operator|!=
name|quote
condition|)
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
name|err
argument_list|(
name|a
operator|->
name|ciend
argument_list|,
name|EOF
argument_list|,
name|where0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GETC
argument_list|(
name|ch
argument_list|)
operator|==
name|quote
condition|)
goto|goto
name|more_quoted
goto|;
name|Ungetc
argument_list|(
name|ch
argument_list|,
name|f__cf
argument_list|)
expr_stmt|;
default|default:
continue|continue;
block|}
block|}
endif|#
directive|endif
name|ht
operator|=
name|mk_hashtab
argument_list|(
name|nl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ht
condition|)
name|errfl
argument_list|(
name|f__elist
operator|->
name|cierr
argument_list|,
literal|113
argument_list|,
name|where0
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
for|for
control|(
init|;
condition|;
control|)
switch|switch
condition|(
name|GETC
argument_list|(
name|ch
argument_list|)
condition|)
block|{
case|case
name|EOF
case|:
if|if
condition|(
name|got1
condition|)
return|return
literal|0
return|;
name|err
argument_list|(
name|a
operator|->
name|ciend
argument_list|,
name|EOF
argument_list|,
name|where0
argument_list|)
expr_stmt|;
case|case
literal|'/'
case|:
case|case
literal|'$'
case|:
case|case
literal|'&'
case|:
return|return
literal|0
return|;
default|default:
if|if
condition|(
name|ch
operator|<=
literal|' '
operator|&&
name|ch
operator|>=
literal|0
operator|||
name|ch
operator|==
literal|','
condition|)
continue|continue;
name|Ungetc
argument_list|(
name|ch
argument_list|,
name|f__cf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|=
name|getname
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
condition|)
return|return
name|ch
return|;
goto|goto
name|havename
goto|;
block|}
name|havename
label|:
name|v
operator|=
name|hash
argument_list|(
name|ht
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|v
condition|)
name|errfl
argument_list|(
name|a
operator|->
name|cierr
argument_list|,
literal|119
argument_list|,
name|where
argument_list|)
expr_stmt|;
while|while
condition|(
name|GETC
argument_list|(
name|ch
argument_list|)
operator|<=
literal|' '
operator|&&
name|ch
operator|>=
literal|0
condition|)
empty_stmt|;
name|vaddr
operator|=
name|v
operator|->
name|addr
expr_stmt|;
name|type
operator|=
name|v
operator|->
name|type
expr_stmt|;
if|if
condition|(
name|type
operator|<
literal|0
condition|)
block|{
name|size
operator|=
operator|-
name|type
expr_stmt|;
name|type
operator|=
name|TYCHAR
expr_stmt|;
block|}
else|else
name|size
operator|=
name|f__typesize
index|[
name|type
index|]
expr_stmt|;
name|ivae
operator|=
name|size
expr_stmt|;
name|iva
operator|=
name|readall
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'('
comment|/*)*/
condition|)
block|{
name|dn
operator|=
name|dimens
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|dims
operator|=
name|v
operator|->
name|dims
operator|)
condition|)
block|{
if|if
condition|(
name|type
operator|!=
name|TYCHAR
condition|)
name|errfl
argument_list|(
name|a
operator|->
name|cierr
argument_list|,
literal|122
argument_list|,
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|=
name|getdimen
argument_list|(
operator|&
name|ch
argument_list|,
name|dn
argument_list|,
operator|(
name|ftnlen
operator|)
name|size
argument_list|,
operator|(
name|ftnlen
operator|)
name|size
argument_list|,
operator|&
name|b
argument_list|)
condition|)
name|errfl
argument_list|(
name|a
operator|->
name|cierr
argument_list|,
name|k
argument_list|,
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
literal|')'
condition|)
name|errfl
argument_list|(
name|a
operator|->
name|cierr
argument_list|,
literal|115
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|b1
operator|=
name|dn
operator|->
name|extent
expr_stmt|;
if|if
condition|(
operator|--
name|b
operator|<
literal|0
operator|||
name|b
operator|+
name|b1
operator|>
name|size
condition|)
return|return
literal|124
return|;
name|iva
operator|+=
name|b
expr_stmt|;
name|size
operator|=
name|b1
expr_stmt|;
while|while
condition|(
name|GETC
argument_list|(
name|ch
argument_list|)
operator|<=
literal|' '
operator|&&
name|ch
operator|>=
literal|0
condition|)
empty_stmt|;
goto|goto
name|scalar
goto|;
block|}
name|nd
operator|=
operator|(
name|int
operator|)
name|dims
index|[
literal|0
index|]
expr_stmt|;
name|nomax
operator|=
name|span
operator|=
name|dims
index|[
literal|1
index|]
expr_stmt|;
name|ivae
operator|=
name|iva
operator|+
name|size
operator|*
name|nomax
expr_stmt|;
name|colonseen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|k
operator|=
name|getdimen
argument_list|(
operator|&
name|ch
argument_list|,
name|dn
argument_list|,
name|size
argument_list|,
name|nomax
argument_list|,
operator|&
name|b
argument_list|)
condition|)
name|errfl
argument_list|(
name|a
operator|->
name|cierr
argument_list|,
name|k
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|no
operator|=
name|dn
operator|->
name|extent
expr_stmt|;
name|b0
operator|=
name|dims
index|[
literal|2
index|]
expr_stmt|;
name|dims1
operator|=
name|dims
operator|+=
literal|3
expr_stmt|;
name|ex
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|++
operator|<
name|nd
condition|;
name|dims
operator|++
control|)
block|{
if|if
condition|(
name|ch
operator|!=
literal|','
condition|)
name|errfl
argument_list|(
name|a
operator|->
name|cierr
argument_list|,
literal|115
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|dn1
operator|=
name|dn
operator|+
literal|1
expr_stmt|;
name|span
operator|/=
operator|*
name|dims
expr_stmt|;
if|if
condition|(
name|k
operator|=
name|getdimen
argument_list|(
operator|&
name|ch
argument_list|,
name|dn1
argument_list|,
name|dn
operator|->
name|delta
operator|*
operator|*
name|dims
argument_list|,
name|span
argument_list|,
operator|&
name|b1
argument_list|)
condition|)
name|errfl
argument_list|(
name|a
operator|->
name|cierr
argument_list|,
name|k
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|ex
operator|*=
operator|*
name|dims
expr_stmt|;
name|b
operator|+=
name|b1
operator|*
name|ex
expr_stmt|;
name|no
operator|*=
name|dn1
operator|->
name|extent
expr_stmt|;
name|dn
operator|=
name|dn1
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|!=
literal|')'
condition|)
name|errfl
argument_list|(
name|a
operator|->
name|cierr
argument_list|,
literal|115
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|readall
operator|=
literal|1
operator|-
name|colonseen
expr_stmt|;
name|b
operator|-=
name|b0
expr_stmt|;
if|if
condition|(
name|b
operator|<
literal|0
operator|||
name|b
operator|>=
name|nomax
condition|)
name|errfl
argument_list|(
name|a
operator|->
name|cierr
argument_list|,
literal|125
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|iva
operator|+=
name|size
operator|*
name|b
expr_stmt|;
name|dims
operator|=
name|dims1
expr_stmt|;
while|while
condition|(
name|GETC
argument_list|(
name|ch
argument_list|)
operator|<=
literal|' '
operator|&&
name|ch
operator|>=
literal|0
condition|)
empty_stmt|;
name|no1
operator|=
literal|1
expr_stmt|;
name|dn0
operator|=
name|dimens
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYCHAR
operator|&&
name|ch
operator|==
literal|'('
comment|/*)*/
condition|)
block|{
if|if
condition|(
name|k
operator|=
name|getdimen
argument_list|(
operator|&
name|ch
argument_list|,
operator|&
name|substr
argument_list|,
name|size
argument_list|,
name|size
argument_list|,
operator|&
name|b
argument_list|)
condition|)
name|errfl
argument_list|(
name|a
operator|->
name|cierr
argument_list|,
name|k
argument_list|,
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
literal|')'
condition|)
name|errfl
argument_list|(
name|a
operator|->
name|cierr
argument_list|,
literal|115
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|b1
operator|=
name|substr
operator|.
name|extent
expr_stmt|;
if|if
condition|(
operator|--
name|b
operator|<
literal|0
operator|||
name|b
operator|+
name|b1
operator|>
name|size
condition|)
return|return
literal|124
return|;
name|iva
operator|+=
name|b
expr_stmt|;
name|b0
operator|=
name|size
expr_stmt|;
name|size
operator|=
name|b1
expr_stmt|;
while|while
condition|(
name|GETC
argument_list|(
name|ch
argument_list|)
operator|<=
literal|' '
operator|&&
name|ch
operator|>=
literal|0
condition|)
empty_stmt|;
if|if
condition|(
name|b1
operator|<
name|b0
condition|)
goto|goto
name|delta_adj
goto|;
block|}
if|if
condition|(
name|readall
condition|)
goto|goto
name|delta_adj
goto|;
for|for
control|(
init|;
name|dn0
operator|<
name|dn
condition|;
name|dn0
operator|++
control|)
block|{
if|if
condition|(
name|dn0
operator|->
name|extent
operator|!=
operator|*
name|dims
operator|++
operator|||
name|dn0
operator|->
name|stride
operator|!=
literal|1
condition|)
break|break;
name|no1
operator|*=
name|dn0
operator|->
name|extent
expr_stmt|;
block|}
if|if
condition|(
name|dn0
operator|==
name|dimens
operator|&&
name|dimens
index|[
literal|0
index|]
operator|.
name|stride
operator|==
literal|1
condition|)
block|{
name|no1
operator|=
name|dimens
index|[
literal|0
index|]
operator|.
name|extent
expr_stmt|;
name|dn0
operator|++
expr_stmt|;
block|}
name|delta_adj
label|:
name|ex
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|dn1
operator|=
name|dn0
init|;
name|dn1
operator|<=
name|dn
condition|;
name|dn1
operator|++
control|)
name|ex
operator|+=
operator|(
name|dn1
operator|->
name|extent
operator|-
literal|1
operator|)
operator|*
operator|(
name|dn1
operator|->
name|delta
operator|*=
name|dn1
operator|->
name|stride
operator|)
expr_stmt|;
for|for
control|(
name|dn1
operator|=
name|dn
init|;
name|dn1
operator|>
name|dn0
condition|;
name|dn1
operator|--
control|)
block|{
name|ex
operator|-=
operator|(
name|dn1
operator|->
name|extent
operator|-
literal|1
operator|)
operator|*
name|dn1
operator|->
name|delta
expr_stmt|;
name|dn1
operator|->
name|delta
operator|-=
name|ex
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dims
operator|=
name|v
operator|->
name|dims
condition|)
block|{
name|no
operator|=
name|no1
operator|=
name|dims
index|[
literal|1
index|]
expr_stmt|;
name|ivae
operator|=
name|iva
operator|+
name|no
operator|*
name|size
expr_stmt|;
block|}
else|else
name|scalar
label|:
name|no
operator|=
name|no1
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ch
operator|!=
literal|'='
condition|)
name|errfl
argument_list|(
name|a
operator|->
name|cierr
argument_list|,
literal|115
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|got1
operator|=
name|nml_read
operator|=
literal|1
expr_stmt|;
name|f__lcount
operator|=
literal|0
expr_stmt|;
name|readloop
label|:
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|iva
operator|>=
name|ivae
operator|||
name|iva
operator|<
literal|0
condition|)
block|{
name|f__lquit
operator|=
literal|1
expr_stmt|;
goto|goto
name|mustend
goto|;
block|}
elseif|else
if|if
condition|(
name|iva
operator|+
name|no1
operator|*
name|size
operator|>
name|ivae
condition|)
name|no1
operator|=
operator|(
name|ivae
operator|-
name|iva
operator|)
operator|/
name|size
expr_stmt|;
name|f__lquit
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|k
operator|=
name|l_read
argument_list|(
operator|&
name|no1
argument_list|,
name|vaddr
operator|+
name|iva
argument_list|,
name|size
argument_list|,
name|type
argument_list|)
condition|)
return|return
name|k
return|;
if|if
condition|(
name|f__lquit
operator|==
literal|1
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|readall
condition|)
block|{
name|iva
operator|+=
name|dn0
operator|->
name|delta
expr_stmt|;
if|if
condition|(
name|f__lcount
operator|>
literal|0
condition|)
block|{
name|no1
operator|=
operator|(
name|ivae
operator|-
name|iva
operator|)
operator|/
name|size
expr_stmt|;
if|if
condition|(
name|no1
operator|>
name|f__lcount
condition|)
name|no1
operator|=
name|f__lcount
expr_stmt|;
name|iva
operator|+=
name|no1
operator|*
name|dn0
operator|->
name|delta
expr_stmt|;
if|if
condition|(
name|k
operator|=
name|l_read
argument_list|(
operator|&
name|no1
argument_list|,
name|vaddr
operator|+
name|iva
argument_list|,
name|size
argument_list|,
name|type
argument_list|)
condition|)
return|return
name|k
return|;
block|}
block|}
name|mustend
label|:
name|GETC
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|readall
condition|)
if|if
condition|(
name|iva
operator|>=
name|ivae
condition|)
name|readall
operator|=
literal|0
expr_stmt|;
else|else
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
name|GETC
argument_list|(
name|ch
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
if|if
condition|(
name|ch
operator|==
literal|'/'
operator|||
name|ch
operator|==
literal|'$'
operator|||
name|ch
operator|==
literal|'&'
condition|)
block|{
name|f__lquit
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|f__lquit
condition|)
block|{
while|while
condition|(
name|ch
operator|<=
literal|' '
operator|&&
name|ch
operator|>=
literal|0
condition|)
name|GETC
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|Ungetc
argument_list|(
name|ch
argument_list|,
name|f__cf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Alpha
index|[
name|ch
operator|&
literal|0xff
index|]
operator|&&
name|ch
operator|>=
literal|0
condition|)
name|errfl
argument_list|(
name|a
operator|->
name|cierr
argument_list|,
literal|125
argument_list|,
name|where
argument_list|)
expr_stmt|;
break|break;
block|}
name|Ungetc
argument_list|(
name|ch
argument_list|,
name|f__cf
argument_list|)
expr_stmt|;
if|if
condition|(
name|readall
operator|&&
operator|!
name|Alpha
index|[
name|ch
operator|&
literal|0xff
index|]
condition|)
goto|goto
name|readloop
goto|;
if|if
condition|(
operator|(
name|no
operator|-=
name|no1
operator|)
operator|<=
literal|0
condition|)
break|break;
for|for
control|(
name|dn1
operator|=
name|dn0
init|;
name|dn1
operator|<=
name|dn
condition|;
name|dn1
operator|++
control|)
block|{
if|if
condition|(
operator|++
name|dn1
operator|->
name|curval
operator|<
name|dn1
operator|->
name|extent
condition|)
block|{
name|iva
operator|+=
name|dn1
operator|->
name|delta
expr_stmt|;
goto|goto
name|readloop
goto|;
block|}
name|dn1
operator|->
name|curval
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
end_block

begin_function
name|integer
ifdef|#
directive|ifdef
name|KR_headers
name|s_rsne
parameter_list|(
name|a
parameter_list|)
name|cilist
modifier|*
name|a
decl_stmt|;
else|#
directive|else
function|s_rsne
parameter_list|(
name|cilist
modifier|*
name|a
parameter_list|)
endif|#
directive|endif
block|{
specifier|extern
name|int
name|l_eof
decl_stmt|;
name|int
name|n
decl_stmt|;
name|f__external
operator|=
literal|1
expr_stmt|;
name|l_eof
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|n
operator|=
name|c_le
argument_list|(
name|a
argument_list|)
condition|)
return|return
name|n
return|;
if|if
condition|(
name|f__curunit
operator|->
name|uwrt
operator|&&
name|f__nowreading
argument_list|(
name|f__curunit
argument_list|)
condition|)
name|err
argument_list|(
name|a
operator|->
name|cierr
argument_list|,
name|errno
argument_list|,
name|where0
argument_list|)
expr_stmt|;
name|l_getc
operator|=
name|t_getc
expr_stmt|;
name|l_ungetc
operator|=
name|un_getc
expr_stmt|;
name|f__doend
operator|=
name|xrd_SL
expr_stmt|;
name|n
operator|=
name|x_rsne
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|nml_read
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|n
condition|)
return|return
name|n
return|;
return|return
name|e_rsle
argument_list|()
return|;
block|}
end_function

end_unit

