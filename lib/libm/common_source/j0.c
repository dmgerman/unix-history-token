begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)j0.c	8.2 (Berkeley) 11/30/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * 16 December 1992  * Minor modifications by Peter McIlroy to adapt non-IEEE architecture.  */
end_comment

begin_comment
comment|/*  * ====================================================  * Copyright (C) 1992 by Sun Microsystems, Inc.  *  * Developed at SunPro, a Sun Microsystems, Inc. business.  * Permission to use, copy, modify, and distribute this  * software is freely granted, provided that this notice  * is preserved.  * ====================================================  *  * ******************* WARNING ********************  * This is an alpha version of SunPro's FDLIBM (Freely  * Distributable Math Library) for IEEE double precision  * arithmetic. FDLIBM is a basic math library written  * in C that runs on machines that conform to IEEE  * Standard 754/854. This alpha version is distributed  * for testing purpose. Those who use this software  * should report any bugs to  *  *		fdlibm-comments@sunpro.eng.sun.com  *  * -- K.C. Ng, Oct 12, 1992  * ************************************************  */
end_comment

begin_comment
comment|/* double j0(double x), y0(double x)  * Bessel function of the first and second kinds of order zero.  * Method -- j0(x):  *	1. For tiny x, we use j0(x) = 1 - x^2/4 + x^4/64 - ...  *	2. Reduce x to |x| since j0(x)=j0(-x),  and  *	   for x in (0,2)  *		j0(x) = 1-z/4+ z^2*R0/S0,  where z = x*x;  *	   (precision:  |j0-1+z/4-z^2R0/S0 |<2**-63.67 )  *	   for x in (2,inf)  * 		j0(x) = sqrt(2/(pi*x))*(p0(x)*cos(x0)-q0(x)*sin(x0))  * 	   where x0 = x-pi/4. It is better to compute sin(x0),cos(x0)  *	   as follow:  *		cos(x0) = cos(x)cos(pi/4)+sin(x)sin(pi/4)  *			= 1/sqrt(2) * (cos(x) + sin(x))  *		sin(x0) = sin(x)cos(pi/4)-cos(x)sin(pi/4)  *			= 1/sqrt(2) * (sin(x) - cos(x))  * 	   (To avoid cancellation, use  *		sin(x) +- cos(x) = -cos(2x)/(sin(x) -+ cos(x))  * 	    to compute the worse one.)  *  *	3 Special cases  *		j0(nan)= nan  *		j0(0) = 1  *		j0(inf) = 0  *  * Method -- y0(x):  *	1. For x<2.  *	   Since  *		y0(x) = 2/pi*(j0(x)*(ln(x/2)+Euler) + x^2/4 - ...)  *	   therefore y0(x)-2/pi*j0(x)*ln(x) is an even function.  *	   We use the following function to approximate y0,  *		y0(x) = U(z)/V(z) + (2/pi)*(j0(x)*ln(x)), z= x^2  *	   where  *		U(z) = u0 + u1*z + ... + u6*z^6  *		V(z) = 1  + v1*z + ... + v4*z^4  *	   with absolute approximation error bounded by 2**-72.  *	   Note: For tiny x, U/V = u0 and j0(x)~1, hence  *		y0(tiny) = u0 + (2/pi)*ln(tiny), (choose tiny<2**-27)  *	2. For x>=2.  * 		y0(x) = sqrt(2/(pi*x))*(p0(x)*cos(x0)+q0(x)*sin(x0))  * 	   where x0 = x-pi/4. It is better to compute sin(x0),cos(x0)  *	   by the method mentioned above.  *	3. Special cases: y0(0)=-inf, y0(x<0)=NaN, y0(inf)=0.  */
end_comment

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<float.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
operator|||
name|defined
argument_list|(
name|tahoe
argument_list|)
end_if

begin_define
define|#
directive|define
name|_IEEE
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|_IEEE
value|1
end_define

begin_define
define|#
directive|define
name|infnan
parameter_list|(
name|x
parameter_list|)
value|(0.0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|double
name|pzero
name|__P
argument_list|(
operator|(
name|double
operator|)
argument_list|)
decl_stmt|,
name|qzero
name|__P
argument_list|(
operator|(
name|double
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|huge
init|=
literal|1e300
decl_stmt|,
name|zero
init|=
literal|0.0
decl_stmt|,
name|one
init|=
literal|1.0
decl_stmt|,
name|invsqrtpi
init|=
literal|5.641895835477562869480794515607725858441e-0001
decl_stmt|,
name|tpi
init|=
literal|0.636619772367581343075535053490057448
decl_stmt|,
comment|/* R0/S0 on [0, 2.00] */
name|r02
init|=
literal|1.562499999999999408594634421055018003102e-0002
decl_stmt|,
name|r03
init|=
operator|-
literal|1.899792942388547334476601771991800712355e-0004
decl_stmt|,
name|r04
init|=
literal|1.829540495327006565964161150603950916854e-0006
decl_stmt|,
name|r05
init|=
operator|-
literal|4.618326885321032060803075217804816988758e-0009
decl_stmt|,
name|s01
init|=
literal|1.561910294648900170180789369288114642057e-0002
decl_stmt|,
name|s02
init|=
literal|1.169267846633374484918570613449245536323e-0004
decl_stmt|,
name|s03
init|=
literal|5.135465502073181376284426245689510134134e-0007
decl_stmt|,
name|s04
init|=
literal|1.166140033337900097836930825478674320464e-0009
decl_stmt|;
end_decl_stmt

begin_function
name|double
name|j0
parameter_list|(
name|x
parameter_list|)
name|double
name|x
decl_stmt|;
block|{
name|double
name|z
decl_stmt|,
name|s
decl_stmt|,
name|c
decl_stmt|,
name|ss
decl_stmt|,
name|cc
decl_stmt|,
name|r
decl_stmt|,
name|u
decl_stmt|,
name|v
decl_stmt|;
if|if
condition|(
operator|!
name|finite
argument_list|(
name|x
argument_list|)
condition|)
if|if
condition|(
name|_IEEE
condition|)
return|return
name|one
operator|/
operator|(
name|x
operator|*
name|x
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
name|x
operator|=
name|fabs
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|>=
literal|2.0
condition|)
block|{
comment|/* |x|>= 2.0 */
name|s
operator|=
name|sin
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|c
operator|=
name|cos
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|ss
operator|=
name|s
operator|-
name|c
expr_stmt|;
name|cc
operator|=
name|s
operator|+
name|c
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|.5
operator|*
name|DBL_MAX
condition|)
block|{
comment|/* make sure x+x not overflow */
name|z
operator|=
operator|-
name|cos
argument_list|(
name|x
operator|+
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|*
name|c
operator|)
operator|<
name|zero
condition|)
name|cc
operator|=
name|z
operator|/
name|ss
expr_stmt|;
else|else
name|ss
operator|=
name|z
operator|/
name|cc
expr_stmt|;
block|}
comment|/* 	 * j0(x) = 1/sqrt(pi) * (P(0,x)*cc - Q(0,x)*ss) / sqrt(x) 	 * y0(x) = 1/sqrt(pi) * (P(0,x)*ss + Q(0,x)*cc) / sqrt(x) 	 */
if|if
condition|(
name|_IEEE
operator|&&
name|x
operator|>
literal|6.80564733841876927e+38
condition|)
comment|/* 2^129 */
name|z
operator|=
operator|(
name|invsqrtpi
operator|*
name|cc
operator|)
operator|/
name|sqrt
argument_list|(
name|x
argument_list|)
expr_stmt|;
else|else
block|{
name|u
operator|=
name|pzero
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|v
operator|=
name|qzero
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|z
operator|=
name|invsqrtpi
operator|*
operator|(
name|u
operator|*
name|cc
operator|-
name|v
operator|*
name|ss
operator|)
operator|/
name|sqrt
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
return|return
name|z
return|;
block|}
if|if
condition|(
name|x
operator|<
literal|1.220703125e-004
condition|)
block|{
comment|/* |x|< 2**-13 */
if|if
condition|(
name|huge
operator|+
name|x
operator|>
name|one
condition|)
block|{
comment|/* raise inexact if x != 0 */
if|if
condition|(
name|x
operator|<
literal|7.450580596923828125e-009
condition|)
comment|/* |x|<2**-27 */
return|return
name|one
return|;
else|else
return|return
operator|(
name|one
operator|-
literal|0.25
operator|*
name|x
operator|*
name|x
operator|)
return|;
block|}
block|}
name|z
operator|=
name|x
operator|*
name|x
expr_stmt|;
name|r
operator|=
name|z
operator|*
operator|(
name|r02
operator|+
name|z
operator|*
operator|(
name|r03
operator|+
name|z
operator|*
operator|(
name|r04
operator|+
name|z
operator|*
name|r05
operator|)
operator|)
operator|)
expr_stmt|;
name|s
operator|=
name|one
operator|+
name|z
operator|*
operator|(
name|s01
operator|+
name|z
operator|*
operator|(
name|s02
operator|+
name|z
operator|*
operator|(
name|s03
operator|+
name|z
operator|*
name|s04
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
name|one
condition|)
block|{
comment|/* |x|< 1.00 */
return|return
operator|(
name|one
operator|+
name|z
operator|*
operator|(
operator|-
literal|0.25
operator|+
operator|(
name|r
operator|/
name|s
operator|)
operator|)
operator|)
return|;
block|}
else|else
block|{
name|u
operator|=
literal|0.5
operator|*
name|x
expr_stmt|;
return|return
operator|(
operator|(
name|one
operator|+
name|u
operator|)
operator|*
operator|(
name|one
operator|-
name|u
operator|)
operator|+
name|z
operator|*
operator|(
name|r
operator|/
name|s
operator|)
operator|)
return|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|double
name|u00
init|=
operator|-
literal|7.380429510868722527422411862872999615628e-0002
decl_stmt|,
name|u01
init|=
literal|1.766664525091811069896442906220827182707e-0001
decl_stmt|,
name|u02
init|=
operator|-
literal|1.381856719455968955440002438182885835344e-0002
decl_stmt|,
name|u03
init|=
literal|3.474534320936836562092566861515617053954e-0004
decl_stmt|,
name|u04
init|=
operator|-
literal|3.814070537243641752631729276103284491172e-0006
decl_stmt|,
name|u05
init|=
literal|1.955901370350229170025509706510038090009e-0008
decl_stmt|,
name|u06
init|=
operator|-
literal|3.982051941321034108350630097330144576337e-0011
decl_stmt|,
name|v01
init|=
literal|1.273048348341237002944554656529224780561e-0002
decl_stmt|,
name|v02
init|=
literal|7.600686273503532807462101309675806839635e-0005
decl_stmt|,
name|v03
init|=
literal|2.591508518404578033173189144579208685163e-0007
decl_stmt|,
name|v04
init|=
literal|4.411103113326754838596529339004302243157e-0010
decl_stmt|;
end_decl_stmt

begin_function
name|double
name|y0
parameter_list|(
name|x
parameter_list|)
name|double
name|x
decl_stmt|;
block|{
name|double
name|z
decl_stmt|,
name|s
decl_stmt|,
name|c
decl_stmt|,
name|ss
decl_stmt|,
name|cc
decl_stmt|,
name|u
decl_stmt|,
name|v
decl_stmt|;
comment|/* Y0(NaN) is NaN, y0(-inf) is Nan, y0(inf) is 0  */
if|if
condition|(
operator|!
name|finite
argument_list|(
name|x
argument_list|)
condition|)
if|if
condition|(
name|_IEEE
condition|)
return|return
operator|(
name|one
operator|/
operator|(
name|x
operator|+
name|x
operator|*
name|x
operator|)
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|x
operator|==
literal|0
condition|)
if|if
condition|(
name|_IEEE
condition|)
return|return
operator|(
operator|-
name|one
operator|/
name|zero
operator|)
return|;
else|else
return|return
operator|(
name|infnan
argument_list|(
operator|-
name|ERANGE
argument_list|)
operator|)
return|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
if|if
condition|(
name|_IEEE
condition|)
return|return
operator|(
name|zero
operator|/
name|zero
operator|)
return|;
else|else
return|return
operator|(
name|infnan
argument_list|(
name|EDOM
argument_list|)
operator|)
return|;
if|if
condition|(
name|x
operator|>=
literal|2.00
condition|)
block|{
comment|/* |x|>= 2.0 */
comment|/* y0(x) = sqrt(2/(pi*x))*(p0(x)*sin(x0)+q0(x)*cos(x0))          * where x0 = x-pi/4          *      Better formula:          *              cos(x0) = cos(x)cos(pi/4)+sin(x)sin(pi/4)          *                      =  1/sqrt(2) * (sin(x) + cos(x))          *              sin(x0) = sin(x)cos(3pi/4)-cos(x)sin(3pi/4)          *                      =  1/sqrt(2) * (sin(x) - cos(x))          * To avoid cancellation, use          *              sin(x) +- cos(x) = -cos(2x)/(sin(x) -+ cos(x))          * to compute the worse one.          */
name|s
operator|=
name|sin
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|c
operator|=
name|cos
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|ss
operator|=
name|s
operator|-
name|c
expr_stmt|;
name|cc
operator|=
name|s
operator|+
name|c
expr_stmt|;
comment|/* 	 * j0(x) = 1/sqrt(pi) * (P(0,x)*cc - Q(0,x)*ss) / sqrt(x) 	 * y0(x) = 1/sqrt(pi) * (P(0,x)*ss + Q(0,x)*cc) / sqrt(x) 	 */
if|if
condition|(
name|x
operator|<
literal|.5
operator|*
name|DBL_MAX
condition|)
block|{
comment|/* make sure x+x not overflow */
name|z
operator|=
operator|-
name|cos
argument_list|(
name|x
operator|+
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|*
name|c
operator|)
operator|<
name|zero
condition|)
name|cc
operator|=
name|z
operator|/
name|ss
expr_stmt|;
else|else
name|ss
operator|=
name|z
operator|/
name|cc
expr_stmt|;
block|}
if|if
condition|(
name|_IEEE
operator|&&
name|x
operator|>
literal|6.80564733841876927e+38
condition|)
comment|/*> 2^129 */
name|z
operator|=
operator|(
name|invsqrtpi
operator|*
name|ss
operator|)
operator|/
name|sqrt
argument_list|(
name|x
argument_list|)
expr_stmt|;
else|else
block|{
name|u
operator|=
name|pzero
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|v
operator|=
name|qzero
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|z
operator|=
name|invsqrtpi
operator|*
operator|(
name|u
operator|*
name|ss
operator|+
name|v
operator|*
name|cc
operator|)
operator|/
name|sqrt
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
return|return
name|z
return|;
block|}
if|if
condition|(
name|x
operator|<=
literal|7.450580596923828125e-009
condition|)
block|{
comment|/* x< 2**-27 */
return|return
operator|(
name|u00
operator|+
name|tpi
operator|*
name|log
argument_list|(
name|x
argument_list|)
operator|)
return|;
block|}
name|z
operator|=
name|x
operator|*
name|x
expr_stmt|;
name|u
operator|=
name|u00
operator|+
name|z
operator|*
operator|(
name|u01
operator|+
name|z
operator|*
operator|(
name|u02
operator|+
name|z
operator|*
operator|(
name|u03
operator|+
name|z
operator|*
operator|(
name|u04
operator|+
name|z
operator|*
operator|(
name|u05
operator|+
name|z
operator|*
name|u06
operator|)
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
name|v
operator|=
name|one
operator|+
name|z
operator|*
operator|(
name|v01
operator|+
name|z
operator|*
operator|(
name|v02
operator|+
name|z
operator|*
operator|(
name|v03
operator|+
name|z
operator|*
name|v04
operator|)
operator|)
operator|)
expr_stmt|;
return|return
operator|(
name|u
operator|/
name|v
operator|+
name|tpi
operator|*
operator|(
name|j0
argument_list|(
name|x
argument_list|)
operator|*
name|log
argument_list|(
name|x
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The asymptotic expansions of pzero is  *	1 - 9/128 s^2 + 11025/98304 s^4 - ...,	where s = 1/x.  * For x>= 2, We approximate pzero by  * 	pzero(x) = 1 + (R/S)  * where  R = pr0 + pr1*s^2 + pr2*s^4 + ... + pr5*s^10  * 	  S = 1 + ps0*s^2 + ... + ps4*s^10  * and  *	| pzero(x)-1-R/S |<= 2  ** ( -60.26)  */
end_comment

begin_decl_stmt
specifier|static
name|double
name|pr8
index|[
literal|6
index|]
init|=
block|{
comment|/* for x in [inf, 8]=1/[0,0.125] */
literal|0.0
block|,
operator|-
literal|7.031249999999003994151563066182798210142e-0002
block|,
operator|-
literal|8.081670412753498508883963849859423939871e+0000
block|,
operator|-
literal|2.570631056797048755890526455854482662510e+0002
block|,
operator|-
literal|2.485216410094288379417154382189125598962e+0003
block|,
operator|-
literal|5.253043804907295692946647153614119665649e+0003
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|ps8
index|[
literal|5
index|]
init|=
block|{
literal|1.165343646196681758075176077627332052048e+0002
block|,
literal|3.833744753641218451213253490882686307027e+0003
block|,
literal|4.059785726484725470626341023967186966531e+0004
block|,
literal|1.167529725643759169416844015694440325519e+0005
block|,
literal|4.762772841467309430100106254805711722972e+0004
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|pr5
index|[
literal|6
index|]
init|=
block|{
comment|/* for x in [8,4.5454]=1/[0.125,0.22001] */
operator|-
literal|1.141254646918944974922813501362824060117e-0011
block|,
operator|-
literal|7.031249408735992804117367183001996028304e-0002
block|,
operator|-
literal|4.159610644705877925119684455252125760478e+0000
block|,
operator|-
literal|6.767476522651671942610538094335912346253e+0001
block|,
operator|-
literal|3.312312996491729755731871867397057689078e+0002
block|,
operator|-
literal|3.464333883656048910814187305901796723256e+0002
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|ps5
index|[
literal|5
index|]
init|=
block|{
literal|6.075393826923003305967637195319271932944e+0001
block|,
literal|1.051252305957045869801410979087427910437e+0003
block|,
literal|5.978970943338558182743915287887408780344e+0003
block|,
literal|9.625445143577745335793221135208591603029e+0003
block|,
literal|2.406058159229391070820491174867406875471e+0003
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|pr3
index|[
literal|6
index|]
init|=
block|{
comment|/* for x in [4.547,2.8571]=1/[0.2199,0.35001] */
operator|-
literal|2.547046017719519317420607587742992297519e-0009
block|,
operator|-
literal|7.031196163814817199050629727406231152464e-0002
block|,
operator|-
literal|2.409032215495295917537157371488126555072e+0000
block|,
operator|-
literal|2.196597747348830936268718293366935843223e+0001
block|,
operator|-
literal|5.807917047017375458527187341817239891940e+0001
block|,
operator|-
literal|3.144794705948885090518775074177485744176e+0001
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|ps3
index|[
literal|5
index|]
init|=
block|{
literal|3.585603380552097167919946472266854507059e+0001
block|,
literal|3.615139830503038919981567245265266294189e+0002
block|,
literal|1.193607837921115243628631691509851364715e+0003
block|,
literal|1.127996798569074250675414186814529958010e+0003
block|,
literal|1.735809308133357510239737333055228118910e+0002
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|pr2
index|[
literal|6
index|]
init|=
block|{
comment|/* for x in [2.8570,2]=1/[0.3499,0.5] */
operator|-
literal|8.875343330325263874525704514800809730145e-0008
block|,
operator|-
literal|7.030309954836247756556445443331044338352e-0002
block|,
operator|-
literal|1.450738467809529910662233622603401167409e+0000
block|,
operator|-
literal|7.635696138235277739186371273434739292491e+0000
block|,
operator|-
literal|1.119316688603567398846655082201614524650e+0001
block|,
operator|-
literal|3.233645793513353260006821113608134669030e+0000
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|ps2
index|[
literal|5
index|]
init|=
block|{
literal|2.222029975320888079364901247548798910952e+0001
block|,
literal|1.362067942182152109590340823043813120940e+0002
block|,
literal|2.704702786580835044524562897256790293238e+0002
block|,
literal|1.538753942083203315263554770476850028583e+0002
block|,
literal|1.465761769482561965099880599279699314477e+0001
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|double
name|pzero
parameter_list|(
name|x
parameter_list|)
name|double
name|x
decl_stmt|;
block|{
name|double
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
name|z
decl_stmt|,
name|r
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
name|x
operator|>=
literal|8.00
condition|)
block|{
name|p
operator|=
name|pr8
expr_stmt|;
name|q
operator|=
name|ps8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|>=
literal|4.54545211791992188
condition|)
block|{
name|p
operator|=
name|pr5
expr_stmt|;
name|q
operator|=
name|ps5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|>=
literal|2.85714149475097656
condition|)
block|{
name|p
operator|=
name|pr3
expr_stmt|;
name|q
operator|=
name|ps3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|>=
literal|2.00
condition|)
block|{
name|p
operator|=
name|pr2
expr_stmt|;
name|q
operator|=
name|ps2
expr_stmt|;
block|}
name|z
operator|=
name|one
operator|/
operator|(
name|x
operator|*
name|x
operator|)
expr_stmt|;
name|r
operator|=
name|p
index|[
literal|0
index|]
operator|+
name|z
operator|*
operator|(
name|p
index|[
literal|1
index|]
operator|+
name|z
operator|*
operator|(
name|p
index|[
literal|2
index|]
operator|+
name|z
operator|*
operator|(
name|p
index|[
literal|3
index|]
operator|+
name|z
operator|*
operator|(
name|p
index|[
literal|4
index|]
operator|+
name|z
operator|*
name|p
index|[
literal|5
index|]
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
name|s
operator|=
name|one
operator|+
name|z
operator|*
operator|(
name|q
index|[
literal|0
index|]
operator|+
name|z
operator|*
operator|(
name|q
index|[
literal|1
index|]
operator|+
name|z
operator|*
operator|(
name|q
index|[
literal|2
index|]
operator|+
name|z
operator|*
operator|(
name|q
index|[
literal|3
index|]
operator|+
name|z
operator|*
name|q
index|[
literal|4
index|]
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
return|return
name|one
operator|+
name|r
operator|/
name|s
return|;
block|}
end_function

begin_comment
comment|/* For x>= 8, the asymptotic expansions of qzero is  *	-1/8 s + 75/1024 s^3 - ..., where s = 1/x.  * We approximate pzero by  * 	qzero(x) = s*(-1.25 + (R/S))  * where  R = qr0 + qr1*s^2 + qr2*s^4 + ... + qr5*s^10  * 	  S = 1 + qs0*s^2 + ... + qs5*s^12  * and  *	| qzero(x)/s +1.25-R/S |<= 2  ** ( -61.22)  */
end_comment

begin_decl_stmt
specifier|static
name|double
name|qr8
index|[
literal|6
index|]
init|=
block|{
comment|/* for x in [inf, 8]=1/[0,0.125] */
literal|0.0
block|,
literal|7.324218749999350414479738504551775297096e-0002
block|,
literal|1.176820646822526933903301695932765232456e+0001
block|,
literal|5.576733802564018422407734683549251364365e+0002
block|,
literal|8.859197207564685717547076568608235802317e+0003
block|,
literal|3.701462677768878501173055581933725704809e+0004
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|qs8
index|[
literal|6
index|]
init|=
block|{
literal|1.637760268956898345680262381842235272369e+0002
block|,
literal|8.098344946564498460163123708054674227492e+0003
block|,
literal|1.425382914191204905277585267143216379136e+0005
block|,
literal|8.033092571195144136565231198526081387047e+0005
block|,
literal|8.405015798190605130722042369969184811488e+0005
block|,
operator|-
literal|3.438992935378666373204500729736454421006e+0005
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|qr5
index|[
literal|6
index|]
init|=
block|{
comment|/* for x in [8,4.5454]=1/[0.125,0.22001] */
literal|1.840859635945155400568380711372759921179e-0011
block|,
literal|7.324217666126847411304688081129741939255e-0002
block|,
literal|5.835635089620569401157245917610984757296e+0000
block|,
literal|1.351115772864498375785526599119895942361e+0002
block|,
literal|1.027243765961641042977177679021711341529e+0003
block|,
literal|1.989977858646053872589042328678602481924e+0003
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|qs5
index|[
literal|6
index|]
init|=
block|{
literal|8.277661022365377058749454444343415524509e+0001
block|,
literal|2.077814164213929827140178285401017305309e+0003
block|,
literal|1.884728877857180787101956800212453218179e+0004
block|,
literal|5.675111228949473657576693406600265778689e+0004
block|,
literal|3.597675384251145011342454247417399490174e+0004
block|,
operator|-
literal|5.354342756019447546671440667961399442388e+0003
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|qr3
index|[
literal|6
index|]
init|=
block|{
comment|/* for x in [4.547,2.8571]=1/[0.2199,0.35001] */
literal|4.377410140897386263955149197672576223054e-0009
block|,
literal|7.324111800429115152536250525131924283018e-0002
block|,
literal|3.344231375161707158666412987337679317358e+0000
block|,
literal|4.262184407454126175974453269277100206290e+0001
block|,
literal|1.708080913405656078640701512007621675724e+0002
block|,
literal|1.667339486966511691019925923456050558293e+0002
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|qs3
index|[
literal|6
index|]
init|=
block|{
literal|4.875887297245871932865584382810260676713e+0001
block|,
literal|7.096892210566060535416958362640184894280e+0002
block|,
literal|3.704148226201113687434290319905207398682e+0003
block|,
literal|6.460425167525689088321109036469797462086e+0003
block|,
literal|2.516333689203689683999196167394889715078e+0003
block|,
operator|-
literal|1.492474518361563818275130131510339371048e+0002
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|qr2
index|[
literal|6
index|]
init|=
block|{
comment|/* for x in [2.8570,2]=1/[0.3499,0.5] */
literal|1.504444448869832780257436041633206366087e-0007
block|,
literal|7.322342659630792930894554535717104926902e-0002
block|,
literal|1.998191740938159956838594407540292600331e+0000
block|,
literal|1.449560293478857407645853071687125850962e+0001
block|,
literal|3.166623175047815297062638132537957315395e+0001
block|,
literal|1.625270757109292688799540258329430963726e+0001
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|qs2
index|[
literal|6
index|]
init|=
block|{
literal|3.036558483552191922522729838478169383969e+0001
block|,
literal|2.693481186080498724211751445725708524507e+0002
block|,
literal|8.447837575953201460013136756723746023736e+0002
block|,
literal|8.829358451124885811233995083187666981299e+0002
block|,
literal|2.126663885117988324180482985363624996652e+0002
block|,
operator|-
literal|5.310954938826669402431816125780738924463e+0000
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|double
name|qzero
parameter_list|(
name|x
parameter_list|)
name|double
name|x
decl_stmt|;
block|{
name|double
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
name|s
decl_stmt|,
name|r
decl_stmt|,
name|z
decl_stmt|;
if|if
condition|(
name|x
operator|>=
literal|8.00
condition|)
block|{
name|p
operator|=
name|qr8
expr_stmt|;
name|q
operator|=
name|qs8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|>=
literal|4.54545211791992188
condition|)
block|{
name|p
operator|=
name|qr5
expr_stmt|;
name|q
operator|=
name|qs5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|>=
literal|2.85714149475097656
condition|)
block|{
name|p
operator|=
name|qr3
expr_stmt|;
name|q
operator|=
name|qs3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|>=
literal|2.00
condition|)
block|{
name|p
operator|=
name|qr2
expr_stmt|;
name|q
operator|=
name|qs2
expr_stmt|;
block|}
name|z
operator|=
name|one
operator|/
operator|(
name|x
operator|*
name|x
operator|)
expr_stmt|;
name|r
operator|=
name|p
index|[
literal|0
index|]
operator|+
name|z
operator|*
operator|(
name|p
index|[
literal|1
index|]
operator|+
name|z
operator|*
operator|(
name|p
index|[
literal|2
index|]
operator|+
name|z
operator|*
operator|(
name|p
index|[
literal|3
index|]
operator|+
name|z
operator|*
operator|(
name|p
index|[
literal|4
index|]
operator|+
name|z
operator|*
name|p
index|[
literal|5
index|]
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
name|s
operator|=
name|one
operator|+
name|z
operator|*
operator|(
name|q
index|[
literal|0
index|]
operator|+
name|z
operator|*
operator|(
name|q
index|[
literal|1
index|]
operator|+
name|z
operator|*
operator|(
name|q
index|[
literal|2
index|]
operator|+
name|z
operator|*
operator|(
name|q
index|[
literal|3
index|]
operator|+
name|z
operator|*
operator|(
name|q
index|[
literal|4
index|]
operator|+
name|z
operator|*
name|q
index|[
literal|5
index|]
operator|)
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
return|return
operator|(
operator|-
literal|.125
operator|+
name|r
operator|/
name|s
operator|)
operator|/
name|x
return|;
block|}
end_function

end_unit

