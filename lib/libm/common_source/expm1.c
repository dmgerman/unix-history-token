begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1985, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)expm1.c	8.1 (Berkeley) 6/4/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* EXPM1(X)  * RETURN THE EXPONENTIAL OF X MINUS ONE  * DOUBLE PRECISION (IEEE 53 BITS, VAX D FORMAT 56 BITS)  * CODED IN C BY K.C. NG, 1/19/85;  * REVISED BY K.C. NG on 2/6/85, 3/7/85, 3/21/85, 4/16/85.  *  * Required system supported functions:  *	scalb(x,n)  *	copysign(x,y)  *	finite(x)  *  * Kernel function:  *	exp__E(x,c)  *  * Method:  *	1. Argument Reduction: given the input x, find r and integer k such  *	   that  *	                   x = k*ln2 + r,  |r|<= 0.5*ln2 .  *	   r will be represented as r := z+c for better accuracy.  *  *	2. Compute EXPM1(r)=exp(r)-1 by  *  *			EXPM1(r=z+c) := z + exp__E(z,c)  *  *	3. EXPM1(x) =  2^k * ( EXPM1(r) + 1-2^-k ).  *  * 	Remarks:  *	   1. When k=1 and z< -0.25, we use the following formula for  *	      better accuracy:  *			EXPM1(x) = 2 * ( (z+0.5) + exp__E(z,c) )  *	   2. To avoid rounding error in 1-2^-k where k is large, we use  *			EXPM1(x) = 2^k * { [z+(exp__E(z,c)-2^-k )] + 1 }  *	      when k>56.  *  * Special cases:  *	EXPM1(INF) is INF, EXPM1(NaN) is NaN;  *	EXPM1(-INF)= -1;  *	for finite argument, only EXPM1(0)=0 is exact.  *  * Accuracy:  *	EXPM1(x) returns the exact (exp(x)-1) nearly rounded. In a test run with  *	1,166,000 random arguments on a VAX, the maximum observed error was  *	.872 ulps (units of the last place).  *  * Constants:  * The hexadecimal values are the intended ones for the following constants.  * The decimal values may be used, provided that the compiler will convert  * from decimal to binary accurately enough to produce the hexadecimal values  * shown.  */
end_comment

begin_include
include|#
directive|include
file|"mathimpl.h"
end_include

begin_macro
name|vc
argument_list|(
argument|ln2hi
argument_list|,
literal|6.9314718055829871446E
argument|-
literal|1
argument_list|,
literal|7217
argument_list|,
literal|4031
argument_list|,
literal|0000
argument_list|,
argument|f7d0
argument_list|,
literal|0
argument_list|,
argument|.B17217F7D00000
argument_list|)
end_macro

begin_macro
name|vc
argument_list|(
argument|ln2lo
argument_list|,
literal|1.6465949582897081279E
argument|-
literal|12
argument_list|,
argument|bcd5
argument_list|,
literal|2ce7
argument_list|,
argument|d9cc
argument_list|,
argument|e4f1
argument_list|,
argument|-
literal|39
argument_list|,
argument|.E7BCD5E4F1D9CC
argument_list|)
end_macro

begin_macro
name|vc
argument_list|(
argument|lnhuge
argument_list|,
literal|9.4961163736712506989E1
argument_list|,
argument|ec1d
argument_list|,
literal|43bd
argument_list|,
literal|9010
argument_list|,
argument|a73e
argument_list|,
literal|7
argument_list|,
argument|.BDEC1DA73E9010
argument_list|)
end_macro

begin_macro
name|vc
argument_list|(
argument|invln2
argument_list|,
literal|1.4426950408889634148E0
argument_list|,
argument|aa3b
argument_list|,
literal|40b8
argument_list|,
literal|17f1
argument_list|,
literal|295c
argument_list|,
literal|1
argument_list|,
argument|.B8AA3B295C17F1
argument_list|)
end_macro

begin_macro
name|ic
argument_list|(
argument|ln2hi
argument_list|,
literal|6.9314718036912381649E
argument|-
literal|1
argument_list|,
argument|-
literal|1
argument_list|,
literal|1.62E42FEE00000
argument_list|)
end_macro

begin_macro
name|ic
argument_list|(
argument|ln2lo
argument_list|,
literal|1.9082149292705877000E
argument|-
literal|10
argument_list|,
argument|-
literal|33
argument_list|,
literal|1.A39EF35793C76
argument_list|)
end_macro

begin_macro
name|ic
argument_list|(
argument|lnhuge
argument_list|,
literal|7.1602103751842355450E2
argument_list|,
literal|9
argument_list|,
literal|1.6602B15B7ECF2
argument_list|)
end_macro

begin_macro
name|ic
argument_list|(
argument|invln2
argument_list|,
literal|1.4426950408889633870E0
argument_list|,
literal|0
argument_list|,
literal|1.71547652B82FE
argument_list|)
end_macro

begin_ifdef
ifdef|#
directive|ifdef
name|vccast
end_ifdef

begin_define
define|#
directive|define
name|ln2hi
value|vccast(ln2hi)
end_define

begin_define
define|#
directive|define
name|ln2lo
value|vccast(ln2lo)
end_define

begin_define
define|#
directive|define
name|lnhuge
value|vccast(lnhuge)
end_define

begin_define
define|#
directive|define
name|invln2
value|vccast(invln2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|double
name|expm1
parameter_list|(
name|x
parameter_list|)
name|double
name|x
decl_stmt|;
block|{
specifier|const
specifier|static
name|double
name|one
init|=
literal|1.0
decl_stmt|,
name|half
init|=
literal|1.0
operator|/
literal|2.0
decl_stmt|;
name|double
name|z
decl_stmt|,
name|hi
decl_stmt|,
name|lo
decl_stmt|,
name|c
decl_stmt|;
name|int
name|k
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
operator|||
name|defined
argument_list|(
name|tahoe
argument_list|)
specifier|static
name|prec
operator|=
literal|56
expr_stmt|;
else|#
directive|else
comment|/* defined(vax)||defined(tahoe) */
specifier|static
name|prec
operator|=
literal|53
expr_stmt|;
endif|#
directive|endif
comment|/* defined(vax)||defined(tahoe) */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|vax
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|tahoe
argument_list|)
if|if
condition|(
name|x
operator|!=
name|x
condition|)
return|return
operator|(
name|x
operator|)
return|;
comment|/* x is NaN */
endif|#
directive|endif
comment|/* !defined(vax)&&!defined(tahoe) */
if|if
condition|(
name|x
operator|<=
name|lnhuge
condition|)
block|{
if|if
condition|(
name|x
operator|>=
operator|-
literal|40.0
condition|)
block|{
comment|/* argument reduction : x - k*ln2 */
name|k
operator|=
name|invln2
operator|*
name|x
operator|+
name|copysign
argument_list|(
literal|0.5
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* k=NINT(x/ln2) */
name|hi
operator|=
name|x
operator|-
name|k
operator|*
name|ln2hi
expr_stmt|;
name|z
operator|=
name|hi
operator|-
operator|(
name|lo
operator|=
name|k
operator|*
name|ln2lo
operator|)
expr_stmt|;
name|c
operator|=
operator|(
name|hi
operator|-
name|z
operator|)
operator|-
name|lo
expr_stmt|;
if|if
condition|(
name|k
operator|==
literal|0
condition|)
return|return
operator|(
name|z
operator|+
name|__exp__E
argument_list|(
name|z
argument_list|,
name|c
argument_list|)
operator|)
return|;
if|if
condition|(
name|k
operator|==
literal|1
condition|)
if|if
condition|(
name|z
operator|<
operator|-
literal|0.25
condition|)
block|{
name|x
operator|=
name|z
operator|+
name|half
expr_stmt|;
name|x
operator|+=
name|__exp__E
argument_list|(
name|z
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|x
operator|+
name|x
operator|)
return|;
block|}
else|else
block|{
name|z
operator|+=
name|__exp__E
argument_list|(
name|z
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|x
operator|=
name|half
operator|+
name|z
expr_stmt|;
return|return
operator|(
name|x
operator|+
name|x
operator|)
return|;
block|}
comment|/* end of k=1 */
else|else
block|{
if|if
condition|(
name|k
operator|<=
name|prec
condition|)
block|{
name|x
operator|=
name|one
operator|-
name|scalb
argument_list|(
name|one
argument_list|,
operator|-
name|k
argument_list|)
expr_stmt|;
name|z
operator|+=
name|__exp__E
argument_list|(
name|z
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|k
operator|<
literal|100
condition|)
block|{
name|x
operator|=
name|__exp__E
argument_list|(
name|z
argument_list|,
name|c
argument_list|)
operator|-
name|scalb
argument_list|(
name|one
argument_list|,
operator|-
name|k
argument_list|)
expr_stmt|;
name|x
operator|+=
name|z
expr_stmt|;
name|z
operator|=
name|one
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
name|__exp__E
argument_list|(
name|z
argument_list|,
name|c
argument_list|)
operator|+
name|z
expr_stmt|;
name|z
operator|=
name|one
expr_stmt|;
block|}
return|return
operator|(
name|scalb
argument_list|(
name|x
operator|+
name|z
argument_list|,
name|k
argument_list|)
operator|)
return|;
block|}
block|}
comment|/* end of x> lnunfl */
elseif|else
comment|/* expm1(-big#) rounded to -1 (inexact) */
if|if
condition|(
name|finite
argument_list|(
name|x
argument_list|)
condition|)
block|{
name|ln2hi
operator|+
name|ln2lo
expr_stmt|;
return|return
operator|(
operator|-
name|one
operator|)
return|;
block|}
comment|/* expm1(-INF) is -1 */
else|else
return|return
operator|(
operator|-
name|one
operator|)
return|;
block|}
comment|/* end of x< lnhuge */
else|else
comment|/*  expm1(INF) is INF, expm1(+big#) overflows to INF */
return|return
operator|(
name|finite
argument_list|(
name|x
argument_list|)
condition|?
name|scalb
argument_list|(
name|one
argument_list|,
literal|5000
argument_list|)
else|:
name|x
operator|)
return|;
block|}
end_function

end_unit

