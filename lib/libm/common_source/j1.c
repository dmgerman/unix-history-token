begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)j1.c	8.2 (Berkeley) 11/30/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * 16 December 1992  * Minor modifications by Peter McIlroy to adapt non-IEEE architecture.  */
end_comment

begin_comment
comment|/*  * ====================================================  * Copyright (C) 1992 by Sun Microsystems, Inc.  *  * Developed at SunPro, a Sun Microsystems, Inc. business.  * Permission to use, copy, modify, and distribute this  * software is freely granted, provided that this notice  * is preserved.  * ====================================================  *  * ******************* WARNING ********************  * This is an alpha version of SunPro's FDLIBM (Freely  * Distributable Math Library) for IEEE double precision  * arithmetic. FDLIBM is a basic math library written  * in C that runs on machines that conform to IEEE  * Standard 754/854. This alpha version is distributed  * for testing purpose. Those who use this software  * should report any bugs to  *  *		fdlibm-comments@sunpro.eng.sun.com  *  * -- K.C. Ng, Oct 12, 1992  * ************************************************  */
end_comment

begin_comment
comment|/* double j1(double x), y1(double x)  * Bessel function of the first and second kinds of order zero.  * Method -- j1(x):  *	1. For tiny x, we use j1(x) = x/2 - x^3/16 + x^5/384 - ...  *	2. Reduce x to |x| since j1(x)=-j1(-x),  and  *	   for x in (0,2)  *		j1(x) = x/2 + x*z*R0/S0,  where z = x*x;  *	   (precision:  |j1/x - 1/2 - R0/S0 |<2**-61.51 )  *	   for x in (2,inf)  * 		j1(x) = sqrt(2/(pi*x))*(p1(x)*cos(x1)-q1(x)*sin(x1))  * 		y1(x) = sqrt(2/(pi*x))*(p1(x)*sin(x1)+q1(x)*cos(x1))  * 	   where x1 = x-3*pi/4. It is better to compute sin(x1),cos(x1)  *	   as follows:  *		cos(x1) =  cos(x)cos(3pi/4)+sin(x)sin(3pi/4)  *			=  1/sqrt(2) * (sin(x) - cos(x))  *		sin(x1) =  sin(x)cos(3pi/4)-cos(x)sin(3pi/4)  *			= -1/sqrt(2) * (sin(x) + cos(x))  * 	   (To avoid cancellation, use  *		sin(x) +- cos(x) = -cos(2x)/(sin(x) -+ cos(x))  * 	    to compute the worse one.)  *  *	3 Special cases  *		j1(nan)= nan  *		j1(0) = 0  *		j1(inf) = 0  *  * Method -- y1(x):  *	1. screen out x<=0 cases: y1(0)=-inf, y1(x<0)=NaN  *	2. For x<2.  *	   Since  *		y1(x) = 2/pi*(j1(x)*(ln(x/2)+Euler)-1/x-x/2+5/64*x^3-...)  *	   therefore y1(x)-2/pi*j1(x)*ln(x)-1/x is an odd function.  *	   We use the following function to approximate y1,  *		y1(x) = x*U(z)/V(z) + (2/pi)*(j1(x)*ln(x)-1/x), z= x^2  *	   where for x in [0,2] (abs err less than 2**-65.89)  *		U(z) = u0 + u1*z + ... + u4*z^4  *		V(z) = 1  + v1*z + ... + v5*z^5  *	   Note: For tiny x, 1/x dominate y1 and hence  *		y1(tiny) = -2/pi/tiny, (choose tiny<2**-54)  *	3. For x>=2.  * 		y1(x) = sqrt(2/(pi*x))*(p1(x)*sin(x1)+q1(x)*cos(x1))  * 	   where x1 = x-3*pi/4. It is better to compute sin(x1),cos(x1)  *	   by method mentioned above.  */
end_comment

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<float.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|vax
argument_list|)
operator|||
name|defined
argument_list|(
name|tahoe
argument_list|)
end_if

begin_define
define|#
directive|define
name|_IEEE
value|0
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|_IEEE
value|1
end_define

begin_define
define|#
directive|define
name|infnan
parameter_list|(
name|x
parameter_list|)
value|(0.0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|double
name|pone
argument_list|()
decl_stmt|,
name|qone
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|huge
init|=
literal|1e300
decl_stmt|,
name|zero
init|=
literal|0.0
decl_stmt|,
name|one
init|=
literal|1.0
decl_stmt|,
name|invsqrtpi
init|=
literal|5.641895835477562869480794515607725858441e-0001
decl_stmt|,
name|tpi
init|=
literal|0.636619772367581343075535053490057448
decl_stmt|,
comment|/* R0/S0 on [0,2] */
name|r00
init|=
operator|-
literal|6.250000000000000020842322918309200910191e-0002
decl_stmt|,
name|r01
init|=
literal|1.407056669551897148204830386691427791200e-0003
decl_stmt|,
name|r02
init|=
operator|-
literal|1.599556310840356073980727783817809847071e-0005
decl_stmt|,
name|r03
init|=
literal|4.967279996095844750387702652791615403527e-0008
decl_stmt|,
name|s01
init|=
literal|1.915375995383634614394860200531091839635e-0002
decl_stmt|,
name|s02
init|=
literal|1.859467855886309024045655476348872850396e-0004
decl_stmt|,
name|s03
init|=
literal|1.177184640426236767593432585906758230822e-0006
decl_stmt|,
name|s04
init|=
literal|5.046362570762170559046714468225101016915e-0009
decl_stmt|,
name|s05
init|=
literal|1.235422744261379203512624973117299248281e-0011
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|two_129
value|6.80564733841876926e+038
end_define

begin_comment
comment|/* 2^129 */
end_comment

begin_define
define|#
directive|define
name|two_m54
value|5.55111512312578270e-017
end_define

begin_comment
comment|/* 2^-54 */
end_comment

begin_function
name|double
name|j1
parameter_list|(
name|x
parameter_list|)
name|double
name|x
decl_stmt|;
block|{
name|double
name|z
decl_stmt|,
name|s
decl_stmt|,
name|c
decl_stmt|,
name|ss
decl_stmt|,
name|cc
decl_stmt|,
name|r
decl_stmt|,
name|u
decl_stmt|,
name|v
decl_stmt|,
name|y
decl_stmt|;
name|y
operator|=
name|fabs
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|finite
argument_list|(
name|x
argument_list|)
condition|)
comment|/* Inf or NaN */
if|if
condition|(
name|_IEEE
operator|&&
name|x
operator|!=
name|x
condition|)
return|return
operator|(
name|x
operator|)
return|;
else|else
return|return
operator|(
name|copysign
argument_list|(
name|x
argument_list|,
name|zero
argument_list|)
operator|)
return|;
name|y
operator|=
name|fabs
argument_list|(
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|>=
literal|2
condition|)
comment|/* |x|>= 2.0 */
block|{
name|s
operator|=
name|sin
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|c
operator|=
name|cos
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|ss
operator|=
operator|-
name|s
operator|-
name|c
expr_stmt|;
name|cc
operator|=
name|s
operator|-
name|c
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|.5
operator|*
name|DBL_MAX
condition|)
block|{
comment|/* make sure y+y not overflow */
name|z
operator|=
name|cos
argument_list|(
name|y
operator|+
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|*
name|c
operator|)
operator|<
name|zero
condition|)
name|cc
operator|=
name|z
operator|/
name|ss
expr_stmt|;
else|else
name|ss
operator|=
name|z
operator|/
name|cc
expr_stmt|;
block|}
comment|/* 	 * j1(x) = 1/sqrt(pi) * (P(1,x)*cc - Q(1,x)*ss) / sqrt(x) 	 * y1(x) = 1/sqrt(pi) * (P(1,x)*ss + Q(1,x)*cc) / sqrt(x) 	 */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|vax
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|tahoe
argument_list|)
if|if
condition|(
name|y
operator|>
name|two_129
condition|)
comment|/* x> 2^129 */
name|z
operator|=
operator|(
name|invsqrtpi
operator|*
name|cc
operator|)
operator|/
name|sqrt
argument_list|(
name|y
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
comment|/* defined(vax) || defined(tahoe) */
block|{
name|u
operator|=
name|pone
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|v
operator|=
name|qone
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|z
operator|=
name|invsqrtpi
operator|*
operator|(
name|u
operator|*
name|cc
operator|-
name|v
operator|*
name|ss
operator|)
operator|/
name|sqrt
argument_list|(
name|y
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|x
operator|<
literal|0
condition|)
return|return
operator|-
name|z
return|;
else|else
return|return
name|z
return|;
block|}
if|if
condition|(
name|y
operator|<
literal|7.450580596923828125e-009
condition|)
block|{
comment|/* |x|<2**-27 */
if|if
condition|(
name|huge
operator|+
name|x
operator|>
name|one
condition|)
return|return
literal|0.5
operator|*
name|x
return|;
comment|/* inexact if x!=0 necessary */
block|}
name|z
operator|=
name|x
operator|*
name|x
expr_stmt|;
name|r
operator|=
name|z
operator|*
operator|(
name|r00
operator|+
name|z
operator|*
operator|(
name|r01
operator|+
name|z
operator|*
operator|(
name|r02
operator|+
name|z
operator|*
name|r03
operator|)
operator|)
operator|)
expr_stmt|;
name|s
operator|=
name|one
operator|+
name|z
operator|*
operator|(
name|s01
operator|+
name|z
operator|*
operator|(
name|s02
operator|+
name|z
operator|*
operator|(
name|s03
operator|+
name|z
operator|*
operator|(
name|s04
operator|+
name|z
operator|*
name|s05
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
name|r
operator|*=
name|x
expr_stmt|;
return|return
operator|(
name|x
operator|*
literal|0.5
operator|+
name|r
operator|/
name|s
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|double
name|u0
index|[
literal|5
index|]
init|=
block|{
operator|-
literal|1.960570906462389484206891092512047539632e-0001
block|,
literal|5.044387166398112572026169863174882070274e-0002
block|,
operator|-
literal|1.912568958757635383926261729464141209569e-0003
block|,
literal|2.352526005616105109577368905595045204577e-0005
block|,
operator|-
literal|9.190991580398788465315411784276789663849e-0008
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|v0
index|[
literal|5
index|]
init|=
block|{
literal|1.991673182366499064031901734535479833387e-0002
block|,
literal|2.025525810251351806268483867032781294682e-0004
block|,
literal|1.356088010975162198085369545564475416398e-0006
block|,
literal|6.227414523646214811803898435084697863445e-0009
block|,
literal|1.665592462079920695971450872592458916421e-0011
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|double
name|y1
parameter_list|(
name|x
parameter_list|)
name|double
name|x
decl_stmt|;
block|{
name|double
name|z
decl_stmt|,
name|s
decl_stmt|,
name|c
decl_stmt|,
name|ss
decl_stmt|,
name|cc
decl_stmt|,
name|u
decl_stmt|,
name|v
decl_stmt|;
comment|/* if Y1(NaN) is NaN, Y1(-inf) is NaN, Y1(inf) is 0 */
if|if
condition|(
operator|!
name|finite
argument_list|(
name|x
argument_list|)
condition|)
if|if
condition|(
operator|!
name|_IEEE
condition|)
return|return
operator|(
name|infnan
argument_list|(
name|EDOM
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|x
operator|<
literal|0
condition|)
return|return
operator|(
name|zero
operator|/
name|zero
operator|)
return|;
elseif|else
if|if
condition|(
name|x
operator|>
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|x
operator|)
return|;
if|if
condition|(
name|x
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|_IEEE
operator|&&
name|x
operator|==
literal|0
condition|)
return|return
operator|-
name|one
operator|/
name|zero
return|;
elseif|else
if|if
condition|(
name|x
operator|==
literal|0
condition|)
return|return
operator|(
name|infnan
argument_list|(
operator|-
name|ERANGE
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
name|_IEEE
condition|)
return|return
operator|(
name|zero
operator|/
name|zero
operator|)
return|;
else|else
return|return
operator|(
name|infnan
argument_list|(
name|EDOM
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|x
operator|>=
literal|2
condition|)
comment|/* |x|>= 2.0 */
block|{
name|s
operator|=
name|sin
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|c
operator|=
name|cos
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|ss
operator|=
operator|-
name|s
operator|-
name|c
expr_stmt|;
name|cc
operator|=
name|s
operator|-
name|c
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|.5
operator|*
name|DBL_MAX
condition|)
comment|/* make sure x+x not overflow */
block|{
name|z
operator|=
name|cos
argument_list|(
name|x
operator|+
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|*
name|c
operator|)
operator|>
name|zero
condition|)
name|cc
operator|=
name|z
operator|/
name|ss
expr_stmt|;
else|else
name|ss
operator|=
name|z
operator|/
name|cc
expr_stmt|;
block|}
comment|/* y1(x) = sqrt(2/(pi*x))*(p1(x)*sin(x0)+q1(x)*cos(x0))          * where x0 = x-3pi/4          *      Better formula:          *              cos(x0) = cos(x)cos(3pi/4)+sin(x)sin(3pi/4)          *                      =  1/sqrt(2) * (sin(x) - cos(x))          *              sin(x0) = sin(x)cos(3pi/4)-cos(x)sin(3pi/4)          *                      = -1/sqrt(2) * (cos(x) + sin(x))          * To avoid cancellation, use          *              sin(x) +- cos(x) = -cos(2x)/(sin(x) -+ cos(x))          * to compute the worse one.          */
if|if
condition|(
name|_IEEE
operator|&&
name|x
operator|>
name|two_129
condition|)
name|z
operator|=
operator|(
name|invsqrtpi
operator|*
name|ss
operator|)
operator|/
name|sqrt
argument_list|(
name|x
argument_list|)
expr_stmt|;
else|else
block|{
name|u
operator|=
name|pone
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|v
operator|=
name|qone
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|z
operator|=
name|invsqrtpi
operator|*
operator|(
name|u
operator|*
name|ss
operator|+
name|v
operator|*
name|cc
operator|)
operator|/
name|sqrt
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
return|return
name|z
return|;
block|}
if|if
condition|(
name|x
operator|<=
name|two_m54
condition|)
block|{
comment|/* x< 2**-54 */
return|return
operator|(
operator|-
name|tpi
operator|/
name|x
operator|)
return|;
block|}
name|z
operator|=
name|x
operator|*
name|x
expr_stmt|;
name|u
operator|=
name|u0
index|[
literal|0
index|]
operator|+
name|z
operator|*
operator|(
name|u0
index|[
literal|1
index|]
operator|+
name|z
operator|*
operator|(
name|u0
index|[
literal|2
index|]
operator|+
name|z
operator|*
operator|(
name|u0
index|[
literal|3
index|]
operator|+
name|z
operator|*
name|u0
index|[
literal|4
index|]
operator|)
operator|)
operator|)
expr_stmt|;
name|v
operator|=
name|one
operator|+
name|z
operator|*
operator|(
name|v0
index|[
literal|0
index|]
operator|+
name|z
operator|*
operator|(
name|v0
index|[
literal|1
index|]
operator|+
name|z
operator|*
operator|(
name|v0
index|[
literal|2
index|]
operator|+
name|z
operator|*
operator|(
name|v0
index|[
literal|3
index|]
operator|+
name|z
operator|*
name|v0
index|[
literal|4
index|]
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
return|return
operator|(
name|x
operator|*
operator|(
name|u
operator|/
name|v
operator|)
operator|+
name|tpi
operator|*
operator|(
name|j1
argument_list|(
name|x
argument_list|)
operator|*
name|log
argument_list|(
name|x
argument_list|)
operator|-
name|one
operator|/
name|x
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* For x>= 8, the asymptotic expansions of pone is  *	1 + 15/128 s^2 - 4725/2^15 s^4 - ...,	where s = 1/x.  * We approximate pone by  * 	pone(x) = 1 + (R/S)  * where  R = pr0 + pr1*s^2 + pr2*s^4 + ... + pr5*s^10  * 	  S = 1 + ps0*s^2 + ... + ps4*s^10  * and  *	| pone(x)-1-R/S |<= 2  ** ( -60.06)  */
end_comment

begin_decl_stmt
specifier|static
name|double
name|pr8
index|[
literal|6
index|]
init|=
block|{
comment|/* for x in [inf, 8]=1/[0,0.125] */
literal|0.0
block|,
literal|1.171874999999886486643746274751925399540e-0001
block|,
literal|1.323948065930735690925827997575471527252e+0001
block|,
literal|4.120518543073785433325860184116512799375e+0002
block|,
literal|3.874745389139605254931106878336700275601e+0003
block|,
literal|7.914479540318917214253998253147871806507e+0003
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|ps8
index|[
literal|5
index|]
init|=
block|{
literal|1.142073703756784104235066368252692471887e+0002
block|,
literal|3.650930834208534511135396060708677099382e+0003
block|,
literal|3.695620602690334708579444954937638371808e+0004
block|,
literal|9.760279359349508334916300080109196824151e+0004
block|,
literal|3.080427206278887984185421142572315054499e+0004
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|pr5
index|[
literal|6
index|]
init|=
block|{
comment|/* for x in [8,4.5454]=1/[0.125,0.22001] */
literal|1.319905195562435287967533851581013807103e-0011
block|,
literal|1.171874931906140985709584817065144884218e-0001
block|,
literal|6.802751278684328781830052995333841452280e+0000
block|,
literal|1.083081829901891089952869437126160568246e+0002
block|,
literal|5.176361395331997166796512844100442096318e+0002
block|,
literal|5.287152013633375676874794230748055786553e+0002
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|ps5
index|[
literal|5
index|]
init|=
block|{
literal|5.928059872211313557747989128353699746120e+0001
block|,
literal|9.914014187336144114070148769222018425781e+0002
block|,
literal|5.353266952914879348427003712029704477451e+0003
block|,
literal|7.844690317495512717451367787640014588422e+0003
block|,
literal|1.504046888103610723953792002716816255382e+0003
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|pr3
index|[
literal|6
index|]
init|=
block|{
comment|/* for x in [4.547,2.8571]=1/[0.2199,0.35001] */
literal|3.025039161373736032825049903408701962756e-0009
block|,
literal|1.171868655672535980750284752227495879921e-0001
block|,
literal|3.932977500333156527232725812363183251138e+0000
block|,
literal|3.511940355916369600741054592597098912682e+0001
block|,
literal|9.105501107507812029367749771053045219094e+0001
block|,
literal|4.855906851973649494139275085628195457113e+0001
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|ps3
index|[
literal|5
index|]
init|=
block|{
literal|3.479130950012515114598605916318694946754e+0001
block|,
literal|3.367624587478257581844639171605788622549e+0002
block|,
literal|1.046871399757751279180649307467612538415e+0003
block|,
literal|8.908113463982564638443204408234739237639e+0002
block|,
literal|1.037879324396392739952487012284401031859e+0002
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|pr2
index|[
literal|6
index|]
init|=
block|{
comment|/* for x in [2.8570,2]=1/[0.3499,0.5] */
literal|1.077108301068737449490056513753865482831e-0007
block|,
literal|1.171762194626833490512746348050035171545e-0001
block|,
literal|2.368514966676087902251125130227221462134e+0000
block|,
literal|1.224261091482612280835153832574115951447e+0001
block|,
literal|1.769397112716877301904532320376586509782e+0001
block|,
literal|5.073523125888185399030700509321145995160e+0000
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|ps2
index|[
literal|5
index|]
init|=
block|{
literal|2.143648593638214170243114358933327983793e+0001
block|,
literal|1.252902271684027493309211410842525120355e+0002
block|,
literal|2.322764690571628159027850677565128301361e+0002
block|,
literal|1.176793732871470939654351793502076106651e+0002
block|,
literal|8.364638933716182492500902115164881195742e+0000
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|double
name|pone
parameter_list|(
name|x
parameter_list|)
name|double
name|x
decl_stmt|;
block|{
name|double
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
name|z
decl_stmt|,
name|r
decl_stmt|,
name|s
decl_stmt|;
if|if
condition|(
name|x
operator|>=
literal|8.0
condition|)
block|{
name|p
operator|=
name|pr8
expr_stmt|;
name|q
operator|=
name|ps8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|>=
literal|4.54545211791992188
condition|)
block|{
name|p
operator|=
name|pr5
expr_stmt|;
name|q
operator|=
name|ps5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|>=
literal|2.85714149475097656
condition|)
block|{
name|p
operator|=
name|pr3
expr_stmt|;
name|q
operator|=
name|ps3
expr_stmt|;
block|}
else|else
comment|/* if (x>= 2.0) */
block|{
name|p
operator|=
name|pr2
expr_stmt|;
name|q
operator|=
name|ps2
expr_stmt|;
block|}
name|z
operator|=
name|one
operator|/
operator|(
name|x
operator|*
name|x
operator|)
expr_stmt|;
name|r
operator|=
name|p
index|[
literal|0
index|]
operator|+
name|z
operator|*
operator|(
name|p
index|[
literal|1
index|]
operator|+
name|z
operator|*
operator|(
name|p
index|[
literal|2
index|]
operator|+
name|z
operator|*
operator|(
name|p
index|[
literal|3
index|]
operator|+
name|z
operator|*
operator|(
name|p
index|[
literal|4
index|]
operator|+
name|z
operator|*
name|p
index|[
literal|5
index|]
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
name|s
operator|=
name|one
operator|+
name|z
operator|*
operator|(
name|q
index|[
literal|0
index|]
operator|+
name|z
operator|*
operator|(
name|q
index|[
literal|1
index|]
operator|+
name|z
operator|*
operator|(
name|q
index|[
literal|2
index|]
operator|+
name|z
operator|*
operator|(
name|q
index|[
literal|3
index|]
operator|+
name|z
operator|*
name|q
index|[
literal|4
index|]
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
return|return
operator|(
name|one
operator|+
name|r
operator|/
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/* For x>= 8, the asymptotic expansions of qone is  *	3/8 s - 105/1024 s^3 - ..., where s = 1/x.  * We approximate pone by  * 	qone(x) = s*(0.375 + (R/S))  * where  R = qr1*s^2 + qr2*s^4 + ... + qr5*s^10  * 	  S = 1 + qs1*s^2 + ... + qs6*s^12  * and  *	| qone(x)/s -0.375-R/S |<= 2  ** ( -61.13)  */
end_comment

begin_decl_stmt
specifier|static
name|double
name|qr8
index|[
literal|6
index|]
init|=
block|{
comment|/* for x in [inf, 8]=1/[0,0.125] */
literal|0.0
block|,
operator|-
literal|1.025390624999927207385863635575804210817e-0001
block|,
operator|-
literal|1.627175345445899724355852152103771510209e+0001
block|,
operator|-
literal|7.596017225139501519843072766973047217159e+0002
block|,
operator|-
literal|1.184980667024295901645301570813228628541e+0004
block|,
operator|-
literal|4.843851242857503225866761992518949647041e+0004
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|qs8
index|[
literal|6
index|]
init|=
block|{
literal|1.613953697007229231029079421446916397904e+0002
block|,
literal|7.825385999233484705298782500926834217525e+0003
block|,
literal|1.338753362872495800748094112937868089032e+0005
block|,
literal|7.196577236832409151461363171617204036929e+0005
block|,
literal|6.666012326177764020898162762642290294625e+0005
block|,
operator|-
literal|2.944902643038346618211973470809456636830e+0005
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|qr5
index|[
literal|6
index|]
init|=
block|{
comment|/* for x in [8,4.5454]=1/[0.125,0.22001] */
operator|-
literal|2.089799311417640889742251585097264715678e-0011
block|,
operator|-
literal|1.025390502413754195402736294609692303708e-0001
block|,
operator|-
literal|8.056448281239359746193011295417408828404e+0000
block|,
operator|-
literal|1.836696074748883785606784430098756513222e+0002
block|,
operator|-
literal|1.373193760655081612991329358017247355921e+0003
block|,
operator|-
literal|2.612444404532156676659706427295870995743e+0003
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|qs5
index|[
literal|6
index|]
init|=
block|{
literal|8.127655013843357670881559763225310973118e+0001
block|,
literal|1.991798734604859732508048816860471197220e+0003
block|,
literal|1.746848519249089131627491835267411777366e+0004
block|,
literal|4.985142709103522808438758919150738000353e+0004
block|,
literal|2.794807516389181249227113445299675335543e+0004
block|,
operator|-
literal|4.719183547951285076111596613593553911065e+0003
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|qr3
index|[
literal|6
index|]
init|=
block|{
comment|/* for x in [4.547,2.8571]=1/[0.2199,0.35001] */
operator|-
literal|5.078312264617665927595954813341838734288e-0009
block|,
operator|-
literal|1.025378298208370901410560259001035577681e-0001
block|,
operator|-
literal|4.610115811394734131557983832055607679242e+0000
block|,
operator|-
literal|5.784722165627836421815348508816936196402e+0001
block|,
operator|-
literal|2.282445407376317023842545937526967035712e+0002
block|,
operator|-
literal|2.192101284789093123936441805496580237676e+0002
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|qs3
index|[
literal|6
index|]
init|=
block|{
literal|4.766515503237295155392317984171640809318e+0001
block|,
literal|6.738651126766996691330687210949984203167e+0002
block|,
literal|3.380152866795263466426219644231687474174e+0003
block|,
literal|5.547729097207227642358288160210745890345e+0003
block|,
literal|1.903119193388108072238947732674639066045e+0003
block|,
operator|-
literal|1.352011914443073322978097159157678748982e+0002
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|qr2
index|[
literal|6
index|]
init|=
block|{
comment|/* for x in [2.8570,2]=1/[0.3499,0.5] */
operator|-
literal|1.783817275109588656126772316921194887979e-0007
block|,
operator|-
literal|1.025170426079855506812435356168903694433e-0001
block|,
operator|-
literal|2.752205682781874520495702498875020485552e+0000
block|,
operator|-
literal|1.966361626437037351076756351268110418862e+0001
block|,
operator|-
literal|4.232531333728305108194363846333841480336e+0001
block|,
operator|-
literal|2.137192117037040574661406572497288723430e+0001
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|double
name|qs2
index|[
literal|6
index|]
init|=
block|{
literal|2.953336290605238495019307530224241335502e+0001
block|,
literal|2.529815499821905343698811319455305266409e+0002
block|,
literal|7.575028348686454070022561120722815892346e+0002
block|,
literal|7.393932053204672479746835719678434981599e+0002
block|,
literal|1.559490033366661142496448853793707126179e+0002
block|,
operator|-
literal|4.959498988226281813825263003231704397158e+0000
block|, }
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|double
name|qone
parameter_list|(
name|x
parameter_list|)
name|double
name|x
decl_stmt|;
block|{
name|double
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
name|s
decl_stmt|,
name|r
decl_stmt|,
name|z
decl_stmt|;
if|if
condition|(
name|x
operator|>=
literal|8.0
condition|)
block|{
name|p
operator|=
name|qr8
expr_stmt|;
name|q
operator|=
name|qs8
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|>=
literal|4.54545211791992188
condition|)
block|{
name|p
operator|=
name|qr5
expr_stmt|;
name|q
operator|=
name|qs5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|>=
literal|2.85714149475097656
condition|)
block|{
name|p
operator|=
name|qr3
expr_stmt|;
name|q
operator|=
name|qs3
expr_stmt|;
block|}
else|else
comment|/* if (x>= 2.0) */
block|{
name|p
operator|=
name|qr2
expr_stmt|;
name|q
operator|=
name|qs2
expr_stmt|;
block|}
name|z
operator|=
name|one
operator|/
operator|(
name|x
operator|*
name|x
operator|)
expr_stmt|;
name|r
operator|=
name|p
index|[
literal|0
index|]
operator|+
name|z
operator|*
operator|(
name|p
index|[
literal|1
index|]
operator|+
name|z
operator|*
operator|(
name|p
index|[
literal|2
index|]
operator|+
name|z
operator|*
operator|(
name|p
index|[
literal|3
index|]
operator|+
name|z
operator|*
operator|(
name|p
index|[
literal|4
index|]
operator|+
name|z
operator|*
name|p
index|[
literal|5
index|]
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
name|s
operator|=
name|one
operator|+
name|z
operator|*
operator|(
name|q
index|[
literal|0
index|]
operator|+
name|z
operator|*
operator|(
name|q
index|[
literal|1
index|]
operator|+
name|z
operator|*
operator|(
name|q
index|[
literal|2
index|]
operator|+
name|z
operator|*
operator|(
name|q
index|[
literal|3
index|]
operator|+
name|z
operator|*
operator|(
name|q
index|[
literal|4
index|]
operator|+
name|z
operator|*
name|q
index|[
literal|5
index|]
operator|)
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
return|return
operator|(
literal|.375
operator|+
name|r
operator|/
name|s
operator|)
operator|/
name|x
return|;
block|}
end_function

end_unit

