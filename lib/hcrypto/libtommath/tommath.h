begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* LibTomMath, multiple-precision integer library -- Tom St Denis  *  * LibTomMath is a library that provides multiple-precision  * integer arithmetic as well as number theoretic functionality.  *  * The library was designed directly after the MPI library by  * Michael Fromberger but has been written from scratch with  * additional optimizations in place.  *  * The library is free for all purposes without any express  * guarantee it works.  *  * Tom St Denis, tomstdenis@gmail.com, http://math.libtomcrypt.com  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BN_H_
end_ifndef

begin_define
define|#
directive|define
name|BN_H_
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<tommath_class.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|MIN
end_ifndef

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x)<(y)?(x):(y))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|MAX
end_ifndef

begin_define
define|#
directive|define
name|MAX
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|((x)>(y)?(x):(y))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
comment|/* C++ compilers don't like assigning void * to mp_digit * */
define|#
directive|define
name|OPT_CAST
parameter_list|(
name|x
parameter_list|)
value|(x *)
else|#
directive|else
comment|/* C on the other hand doesn't care */
define|#
directive|define
name|OPT_CAST
parameter_list|(
name|x
parameter_list|)
endif|#
directive|endif
comment|/* detect 64-bit mode if possible */
if|#
directive|if
name|defined
argument_list|(
name|__x86_64__
argument_list|)
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|MP_64BIT
argument_list|)
operator|&&
name|defined
argument_list|(
name|MP_16BIT
argument_list|)
operator|&&
name|defined
argument_list|(
name|MP_8BIT
argument_list|)
operator|)
define|#
directive|define
name|MP_64BIT
endif|#
directive|endif
endif|#
directive|endif
comment|/* some default configurations.  *  * A "mp_digit" must be able to hold DIGIT_BIT + 1 bits  * A "mp_word" must be able to hold 2*DIGIT_BIT + 1 bits  *  * At the very least a mp_digit must be able to hold 7 bits  * [any size beyond that is ok provided it doesn't overflow the data type]  */
ifdef|#
directive|ifdef
name|MP_8BIT
typedef|typedef
name|unsigned
name|char
name|mp_digit
typedef|;
typedef|typedef
name|unsigned
name|short
name|mp_word
typedef|;
elif|#
directive|elif
name|defined
argument_list|(
name|MP_16BIT
argument_list|)
typedef|typedef
name|unsigned
name|short
name|mp_digit
typedef|;
typedef|typedef
name|unsigned
name|long
name|mp_word
typedef|;
elif|#
directive|elif
name|defined
argument_list|(
name|MP_64BIT
argument_list|)
comment|/* for GCC only on supported platforms */
ifndef|#
directive|ifndef
name|CRYPT
typedef|typedef
name|unsigned
name|long
name|long
name|ulong64
typedef|;
typedef|typedef
name|signed
name|long
name|long
name|long64
typedef|;
endif|#
directive|endif
typedef|typedef
name|unsigned
name|long
name|mp_digit
typedef|;
typedef|typedef
name|unsigned
name|long
name|mp_word
name|__attribute__
typedef|((
name|mode
typedef|(
name|TI
typedef|)));
define|#
directive|define
name|DIGIT_BIT
value|60
else|#
directive|else
comment|/* this is the default case, 28-bit digits */
comment|/* this is to make porting into LibTomCrypt easier :-) */
ifndef|#
directive|ifndef
name|CRYPT
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|||
name|defined
argument_list|(
name|__BORLANDC__
argument_list|)
typedef|typedef
name|unsigned
name|__int64
name|ulong64
typedef|;
typedef|typedef
name|signed
name|__int64
name|long64
typedef|;
else|#
directive|else
typedef|typedef
name|unsigned
name|long
name|long
name|ulong64
typedef|;
typedef|typedef
name|signed
name|long
name|long
name|long64
typedef|;
endif|#
directive|endif
endif|#
directive|endif
typedef|typedef
name|unsigned
name|long
name|mp_digit
typedef|;
typedef|typedef
name|ulong64
name|mp_word
typedef|;
ifdef|#
directive|ifdef
name|MP_31BIT
comment|/* this is an extension that uses 31-bit digits */
define|#
directive|define
name|DIGIT_BIT
value|31
else|#
directive|else
comment|/* default case is 28-bit digits, defines MP_28BIT as a handy macro to test */
define|#
directive|define
name|DIGIT_BIT
value|28
define|#
directive|define
name|MP_28BIT
endif|#
directive|endif
endif|#
directive|endif
comment|/* define heap macros */
ifndef|#
directive|ifndef
name|CRYPT
comment|/* default to libc stuff */
ifndef|#
directive|ifndef
name|XMALLOC
define|#
directive|define
name|XMALLOC
value|malloc
define|#
directive|define
name|XFREE
value|free
define|#
directive|define
name|XREALLOC
value|realloc
define|#
directive|define
name|XCALLOC
value|calloc
else|#
directive|else
comment|/* prototypes for our heap functions */
specifier|extern
name|void
modifier|*
name|XMALLOC
parameter_list|(
name|size_t
name|n
parameter_list|)
function_decl|;
specifier|extern
name|void
modifier|*
name|XREALLOC
parameter_list|(
name|void
modifier|*
name|p
parameter_list|,
name|size_t
name|n
parameter_list|)
function_decl|;
specifier|extern
name|void
modifier|*
name|XCALLOC
parameter_list|(
name|size_t
name|n
parameter_list|,
name|size_t
name|s
parameter_list|)
function_decl|;
specifier|extern
name|void
name|XFREE
parameter_list|(
name|void
modifier|*
name|p
parameter_list|)
function_decl|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* otherwise the bits per digit is calculated automatically from the size of a mp_digit */
ifndef|#
directive|ifndef
name|DIGIT_BIT
define|#
directive|define
name|DIGIT_BIT
value|((int)((CHAR_BIT * sizeof(mp_digit) - 1)))
comment|/* bits per digit */
endif|#
directive|endif
define|#
directive|define
name|MP_DIGIT_BIT
value|DIGIT_BIT
define|#
directive|define
name|MP_MASK
value|((((mp_digit)1)<<((mp_digit)DIGIT_BIT))-((mp_digit)1))
define|#
directive|define
name|MP_DIGIT_MAX
value|MP_MASK
comment|/* equalities */
define|#
directive|define
name|MP_LT
value|-1
comment|/* less than */
define|#
directive|define
name|MP_EQ
value|0
comment|/* equal to */
define|#
directive|define
name|MP_GT
value|1
comment|/* greater than */
define|#
directive|define
name|MP_ZPOS
value|0
comment|/* positive integer */
define|#
directive|define
name|MP_NEG
value|1
comment|/* negative */
define|#
directive|define
name|MP_OKAY
value|0
comment|/* ok result */
define|#
directive|define
name|MP_MEM
value|-2
comment|/* out of mem */
define|#
directive|define
name|MP_VAL
value|-3
comment|/* invalid input */
define|#
directive|define
name|MP_RANGE
value|MP_VAL
define|#
directive|define
name|MP_YES
value|1
comment|/* yes response */
define|#
directive|define
name|MP_NO
value|0
comment|/* no response */
comment|/* Primality generation flags */
define|#
directive|define
name|LTM_PRIME_BBS
value|0x0001
comment|/* BBS style prime */
define|#
directive|define
name|LTM_PRIME_SAFE
value|0x0002
comment|/* Safe prime (p-1)/2 == prime */
define|#
directive|define
name|LTM_PRIME_2MSB_ON
value|0x0008
comment|/* force 2nd MSB to 1 */
typedef|typedef
name|int
name|mp_err
typedef|;
comment|/* you'll have to tune these... */
specifier|extern
name|int
name|KARATSUBA_MUL_CUTOFF
decl_stmt|,
name|KARATSUBA_SQR_CUTOFF
decl_stmt|,
name|TOOM_MUL_CUTOFF
decl_stmt|,
name|TOOM_SQR_CUTOFF
decl_stmt|;
comment|/* define this to use lower memory usage routines (exptmods mostly) */
comment|/* #define MP_LOW_MEM */
comment|/* default precision */
ifndef|#
directive|ifndef
name|MP_PREC
ifndef|#
directive|ifndef
name|MP_LOW_MEM
define|#
directive|define
name|MP_PREC
value|32
comment|/* default digits of precision */
else|#
directive|else
define|#
directive|define
name|MP_PREC
value|8
comment|/* default digits of precision */
endif|#
directive|endif
endif|#
directive|endif
comment|/* size of comba arrays, should be at least 2 * 2**(BITS_PER_WORD - BITS_PER_DIGIT*2) */
define|#
directive|define
name|MP_WARRAY
value|(1<< (sizeof(mp_word) * CHAR_BIT - 2 * DIGIT_BIT + 1))
comment|/* the infamous mp_int structure */
typedef|typedef
struct|struct
block|{
name|int
name|used
decl_stmt|,
name|alloc
decl_stmt|,
name|sign
decl_stmt|;
name|mp_digit
modifier|*
name|dp
decl_stmt|;
block|}
name|mp_int
typedef|;
comment|/* callback for mp_prime_random, should fill dst with random bytes and return how many read [upto len] */
typedef|typedef
name|int
name|ltm_prime_callback
parameter_list|(
name|unsigned
name|char
modifier|*
name|dst
parameter_list|,
name|int
name|len
parameter_list|,
name|void
modifier|*
name|dat
parameter_list|)
function_decl|;
define|#
directive|define
name|USED
parameter_list|(
name|m
parameter_list|)
value|((m)->used)
define|#
directive|define
name|DIGIT
parameter_list|(
name|m
parameter_list|,
name|k
parameter_list|)
value|((m)->dp[(k)])
define|#
directive|define
name|SIGN
parameter_list|(
name|m
parameter_list|)
value|((m)->sign)
comment|/* error code to char* string */
name|char
modifier|*
name|mp_error_to_string
parameter_list|(
name|int
name|code
parameter_list|)
function_decl|;
comment|/* ---> init and deinit bignum functions<--- */
comment|/* init a bignum */
name|int
name|mp_init
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|)
function_decl|;
comment|/* free a bignum */
name|void
name|mp_clear
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|)
function_decl|;
comment|/* init a null terminated series of arguments */
name|int
name|mp_init_multi
parameter_list|(
name|mp_int
modifier|*
name|mp
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
comment|/* clear a null terminated series of arguments */
name|void
name|mp_clear_multi
parameter_list|(
name|mp_int
modifier|*
name|mp
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
comment|/* exchange two ints */
name|void
name|mp_exch
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|)
function_decl|;
comment|/* shrink ram required for a bignum */
name|int
name|mp_shrink
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|)
function_decl|;
comment|/* grow an int to a given size */
name|int
name|mp_grow
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|;
comment|/* init to a given number of digits */
name|int
name|mp_init_size
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|;
comment|/* ---> Basic Manipulations<--- */
define|#
directive|define
name|mp_iszero
parameter_list|(
name|a
parameter_list|)
value|(((a)->used == 0) ? MP_YES : MP_NO)
define|#
directive|define
name|mp_iseven
parameter_list|(
name|a
parameter_list|)
value|(((a)->used> 0&& (((a)->dp[0]& 1) == 0)) ? MP_YES : MP_NO)
define|#
directive|define
name|mp_isodd
parameter_list|(
name|a
parameter_list|)
value|(((a)->used> 0&& (((a)->dp[0]& 1) == 1)) ? MP_YES : MP_NO)
define|#
directive|define
name|mp_isneg
parameter_list|(
name|a
parameter_list|)
value|(((a)->sign) ? MP_YES : MP_NO)
comment|/* set to zero */
name|void
name|mp_zero
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|)
function_decl|;
comment|/* set to zero, multi */
name|void
name|mp_zero_multi
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
comment|/* set to a digit */
name|void
name|mp_set
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_digit
name|b
parameter_list|)
function_decl|;
comment|/* set a 32-bit const */
name|int
name|mp_set_int
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|unsigned
name|long
name|b
parameter_list|)
function_decl|;
comment|/* get a 32-bit value */
name|unsigned
name|long
name|mp_get_int
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|)
function_decl|;
comment|/* initialize and set a digit */
name|int
name|mp_init_set
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_digit
name|b
parameter_list|)
function_decl|;
comment|/* initialize and set 32-bit value */
name|int
name|mp_init_set_int
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|unsigned
name|long
name|b
parameter_list|)
function_decl|;
comment|/* copy, b = a */
name|int
name|mp_copy
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|)
function_decl|;
comment|/* inits and copies, a = b */
name|int
name|mp_init_copy
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|)
function_decl|;
comment|/* trim unused digits */
name|void
name|mp_clamp
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|)
function_decl|;
comment|/* ---> digit manipulation<--- */
comment|/* right shift by "b" digits */
name|void
name|mp_rshd
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|int
name|b
parameter_list|)
function_decl|;
comment|/* left shift by "b" digits */
name|int
name|mp_lshd
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|int
name|b
parameter_list|)
function_decl|;
comment|/* c = a / 2**b */
name|int
name|mp_div_2d
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|int
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|,
name|mp_int
modifier|*
name|d
parameter_list|)
function_decl|;
comment|/* b = a/2 */
name|int
name|mp_div_2
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|)
function_decl|;
comment|/* c = a * 2**b */
name|int
name|mp_mul_2d
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|int
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
function_decl|;
comment|/* b = a*2 */
name|int
name|mp_mul_2
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|)
function_decl|;
comment|/* c = a mod 2**d */
name|int
name|mp_mod_2d
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|int
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
function_decl|;
comment|/* computes a = 2**b */
name|int
name|mp_2expt
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|int
name|b
parameter_list|)
function_decl|;
comment|/* Counts the number of lsbs which are zero before the first zero bit */
name|int
name|mp_cnt_lsb
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|)
function_decl|;
comment|/* I Love Earth! */
comment|/* makes a pseudo-random int of a given size */
name|int
name|mp_rand
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|int
name|digits
parameter_list|)
function_decl|;
comment|/* ---> binary operations<--- */
comment|/* c = a XOR b  */
name|int
name|mp_xor
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
function_decl|;
comment|/* c = a OR b */
name|int
name|mp_or
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
function_decl|;
comment|/* c = a AND b */
name|int
name|mp_and
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
function_decl|;
comment|/* ---> Basic arithmetic<--- */
comment|/* b = -a */
name|int
name|mp_neg
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|)
function_decl|;
comment|/* b = |a| */
name|int
name|mp_abs
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|)
function_decl|;
comment|/* compare a to b */
name|int
name|mp_cmp
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|)
function_decl|;
comment|/* compare |a| to |b| */
name|int
name|mp_cmp_mag
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|)
function_decl|;
comment|/* c = a + b */
name|int
name|mp_add
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
function_decl|;
comment|/* c = a - b */
name|int
name|mp_sub
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
function_decl|;
comment|/* c = a * b */
name|int
name|mp_mul
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
function_decl|;
comment|/* b = a*a  */
name|int
name|mp_sqr
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|)
function_decl|;
comment|/* a/b => cb + d == a */
name|int
name|mp_div
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|,
name|mp_int
modifier|*
name|d
parameter_list|)
function_decl|;
comment|/* c = a mod b, 0<= c< b  */
name|int
name|mp_mod
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
function_decl|;
comment|/* ---> single digit functions<--- */
comment|/* compare against a single digit */
name|int
name|mp_cmp_d
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_digit
name|b
parameter_list|)
function_decl|;
comment|/* c = a + b */
name|int
name|mp_add_d
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_digit
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
function_decl|;
comment|/* c = a - b */
name|int
name|mp_sub_d
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_digit
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
function_decl|;
comment|/* c = a * b */
name|int
name|mp_mul_d
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_digit
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
function_decl|;
comment|/* a/b => cb + d == a */
name|int
name|mp_div_d
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_digit
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|,
name|mp_digit
modifier|*
name|d
parameter_list|)
function_decl|;
comment|/* a/3 => 3c + d == a */
name|int
name|mp_div_3
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|,
name|mp_digit
modifier|*
name|d
parameter_list|)
function_decl|;
comment|/* c = a**b */
name|int
name|mp_expt_d
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_digit
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
function_decl|;
comment|/* c = a mod b, 0<= c< b  */
name|int
name|mp_mod_d
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_digit
name|b
parameter_list|,
name|mp_digit
modifier|*
name|c
parameter_list|)
function_decl|;
comment|/* ---> number theory<--- */
comment|/* d = a + b (mod c) */
name|int
name|mp_addmod
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|,
name|mp_int
modifier|*
name|d
parameter_list|)
function_decl|;
comment|/* d = a - b (mod c) */
name|int
name|mp_submod
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|,
name|mp_int
modifier|*
name|d
parameter_list|)
function_decl|;
comment|/* d = a * b (mod c) */
name|int
name|mp_mulmod
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|,
name|mp_int
modifier|*
name|d
parameter_list|)
function_decl|;
comment|/* c = a * a (mod b) */
name|int
name|mp_sqrmod
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
function_decl|;
comment|/* c = 1/a (mod b) */
name|int
name|mp_invmod
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
function_decl|;
comment|/* c = (a, b) */
name|int
name|mp_gcd
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
function_decl|;
comment|/* produces value such that U1*a + U2*b = U3 */
name|int
name|mp_exteuclid
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|U1
parameter_list|,
name|mp_int
modifier|*
name|U2
parameter_list|,
name|mp_int
modifier|*
name|U3
parameter_list|)
function_decl|;
comment|/* c = [a, b] or (a*b)/(a, b) */
name|int
name|mp_lcm
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
function_decl|;
comment|/* finds one of the b'th root of a, such that |c|**b<= |a|  *  * returns error if a< 0 and b is even  */
name|int
name|mp_n_root
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_digit
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
function_decl|;
comment|/* special sqrt algo */
name|int
name|mp_sqrt
parameter_list|(
name|mp_int
modifier|*
name|arg
parameter_list|,
name|mp_int
modifier|*
name|ret
parameter_list|)
function_decl|;
comment|/* is number a square? */
name|int
name|mp_is_square
parameter_list|(
name|mp_int
modifier|*
name|arg
parameter_list|,
name|int
modifier|*
name|ret
parameter_list|)
function_decl|;
comment|/* computes the jacobi c = (a | n) (or Legendre if b is prime)  */
name|int
name|mp_jacobi
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|n
parameter_list|,
name|int
modifier|*
name|c
parameter_list|)
function_decl|;
comment|/* used to setup the Barrett reduction for a given modulus b */
name|int
name|mp_reduce_setup
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|)
function_decl|;
comment|/* Barrett Reduction, computes a (mod b) with a precomputed value c  *  * Assumes that 0< a<= b*b, note if 0> a> -(b*b) then you can merely  * compute the reduction as -1 * mp_reduce(mp_abs(a)) [pseudo code].  */
name|int
name|mp_reduce
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
function_decl|;
comment|/* setups the montgomery reduction */
name|int
name|mp_montgomery_setup
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_digit
modifier|*
name|mp
parameter_list|)
function_decl|;
comment|/* computes a = B**n mod b without division or multiplication useful for  * normalizing numbers in a Montgomery system.  */
name|int
name|mp_montgomery_calc_normalization
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|)
function_decl|;
comment|/* computes x/R == x (mod N) via Montgomery Reduction */
name|int
name|mp_montgomery_reduce
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|m
parameter_list|,
name|mp_digit
name|mp
parameter_list|)
function_decl|;
comment|/* returns 1 if a is a valid DR modulus */
name|int
name|mp_dr_is_modulus
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|)
function_decl|;
comment|/* sets the value of "d" required for mp_dr_reduce */
name|void
name|mp_dr_setup
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_digit
modifier|*
name|d
parameter_list|)
function_decl|;
comment|/* reduces a modulo b using the Diminished Radix method */
name|int
name|mp_dr_reduce
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_digit
name|mp
parameter_list|)
function_decl|;
comment|/* returns true if a can be reduced with mp_reduce_2k */
name|int
name|mp_reduce_is_2k
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|)
function_decl|;
comment|/* determines k value for 2k reduction */
name|int
name|mp_reduce_2k_setup
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_digit
modifier|*
name|d
parameter_list|)
function_decl|;
comment|/* reduces a modulo b where b is of the form 2**p - k [0<= a] */
name|int
name|mp_reduce_2k
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|n
parameter_list|,
name|mp_digit
name|d
parameter_list|)
function_decl|;
comment|/* returns true if a can be reduced with mp_reduce_2k_l */
name|int
name|mp_reduce_is_2k_l
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|)
function_decl|;
comment|/* determines k value for 2k reduction */
name|int
name|mp_reduce_2k_setup_l
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|d
parameter_list|)
function_decl|;
comment|/* reduces a modulo b where b is of the form 2**p - k [0<= a] */
name|int
name|mp_reduce_2k_l
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|n
parameter_list|,
name|mp_int
modifier|*
name|d
parameter_list|)
function_decl|;
comment|/* d = a**b (mod c) */
name|int
name|mp_exptmod
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|,
name|mp_int
modifier|*
name|d
parameter_list|)
function_decl|;
comment|/* ---> Primes<--- */
comment|/* number of primes */
ifdef|#
directive|ifdef
name|MP_8BIT
define|#
directive|define
name|PRIME_SIZE
value|31
else|#
directive|else
define|#
directive|define
name|PRIME_SIZE
value|256
endif|#
directive|endif
comment|/* table of first PRIME_SIZE primes */
specifier|extern
specifier|const
name|mp_digit
name|ltm_prime_tab
index|[]
decl_stmt|;
comment|/* result=1 if a is divisible by one of the first PRIME_SIZE primes */
name|int
name|mp_prime_is_divisible
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|int
modifier|*
name|result
parameter_list|)
function_decl|;
comment|/* performs one Fermat test of "a" using base "b".  * Sets result to 0 if composite or 1 if probable prime  */
name|int
name|mp_prime_fermat
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|int
modifier|*
name|result
parameter_list|)
function_decl|;
comment|/* performs one Miller-Rabin test of "a" using base "b".  * Sets result to 0 if composite or 1 if probable prime  */
name|int
name|mp_prime_miller_rabin
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|int
modifier|*
name|result
parameter_list|)
function_decl|;
comment|/* This gives [for a given bit size] the number of trials required  * such that Miller-Rabin gives a prob of failure lower than 2^-96  */
name|int
name|mp_prime_rabin_miller_trials
parameter_list|(
name|int
name|size
parameter_list|)
function_decl|;
comment|/* performs t rounds of Miller-Rabin on "a" using the first  * t prime bases.  Also performs an initial sieve of trial  * division.  Determines if "a" is prime with probability  * of error no more than (1/4)**t.  *  * Sets result to 1 if probably prime, 0 otherwise  */
name|int
name|mp_prime_is_prime
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|int
name|t
parameter_list|,
name|int
modifier|*
name|result
parameter_list|)
function_decl|;
comment|/* finds the next prime after the number "a" using "t" trials  * of Miller-Rabin.  *  * bbs_style = 1 means the prime must be congruent to 3 mod 4  */
name|int
name|mp_prime_next_prime
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|int
name|t
parameter_list|,
name|int
name|bbs_style
parameter_list|)
function_decl|;
comment|/* makes a truly random prime of a given size (bytes),  * call with bbs = 1 if you want it to be congruent to 3 mod 4  *  * You have to supply a callback which fills in a buffer with random bytes.  "dat" is a parameter you can  * have passed to the callback (e.g. a state or something).  This function doesn't use "dat" itself  * so it can be NULL  *  * The prime generated will be larger than 2^(8*size).  */
define|#
directive|define
name|mp_prime_random
parameter_list|(
name|a
parameter_list|,
name|t
parameter_list|,
name|size
parameter_list|,
name|bbs
parameter_list|,
name|cb
parameter_list|,
name|dat
parameter_list|)
value|mp_prime_random_ex(a, t, ((size) * 8) + 1, (bbs==1)?LTM_PRIME_BBS:0, cb, dat)
comment|/* makes a truly random prime of a given size (bits),  *  * Flags are as follows:  *  *   LTM_PRIME_BBS      - make prime congruent to 3 mod 4  *   LTM_PRIME_SAFE     - make sure (p-1)/2 is prime as well (implies LTM_PRIME_BBS)  *   LTM_PRIME_2MSB_OFF - make the 2nd highest bit zero  *   LTM_PRIME_2MSB_ON  - make the 2nd highest bit one  *  * You have to supply a callback which fills in a buffer with random bytes.  "dat" is a parameter you can  * have passed to the callback (e.g. a state or something).  This function doesn't use "dat" itself  * so it can be NULL  *  */
name|int
name|mp_prime_random_ex
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|int
name|t
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|flags
parameter_list|,
name|ltm_prime_callback
name|cb
parameter_list|,
name|void
modifier|*
name|dat
parameter_list|)
function_decl|;
name|int
name|mp_find_prime
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|)
function_decl|;
name|int
name|mp_isprime
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|)
function_decl|;
comment|/* ---> radix conversion<--- */
name|int
name|mp_count_bits
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|)
function_decl|;
name|int
name|mp_unsigned_bin_size
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|)
function_decl|;
name|int
name|mp_read_unsigned_bin
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|b
parameter_list|,
name|int
name|c
parameter_list|)
function_decl|;
name|int
name|mp_to_unsigned_bin
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|unsigned
name|char
modifier|*
name|b
parameter_list|)
function_decl|;
name|int
name|mp_to_unsigned_bin_n
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|unsigned
name|char
modifier|*
name|b
parameter_list|,
name|unsigned
name|long
modifier|*
name|outlen
parameter_list|)
function_decl|;
name|int
name|mp_signed_bin_size
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|)
function_decl|;
name|int
name|mp_read_signed_bin
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|b
parameter_list|,
name|int
name|c
parameter_list|)
function_decl|;
name|int
name|mp_to_signed_bin
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|unsigned
name|char
modifier|*
name|b
parameter_list|)
function_decl|;
name|int
name|mp_to_signed_bin_n
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|unsigned
name|char
modifier|*
name|b
parameter_list|,
name|unsigned
name|long
modifier|*
name|outlen
parameter_list|)
function_decl|;
name|int
name|mp_read_radix
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|radix
parameter_list|)
function_decl|;
name|int
name|mp_toradix
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|int
name|radix
parameter_list|)
function_decl|;
name|int
name|mp_toradix_n
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|int
name|radix
parameter_list|,
name|int
name|maxlen
parameter_list|)
function_decl|;
name|int
name|mp_radix_size
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|int
name|radix
parameter_list|,
name|int
modifier|*
name|size
parameter_list|)
function_decl|;
name|int
name|mp_fread
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|int
name|radix
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|)
function_decl|;
name|int
name|mp_fwrite
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|int
name|radix
parameter_list|,
name|FILE
modifier|*
name|stream
parameter_list|)
function_decl|;
define|#
directive|define
name|mp_read_raw
parameter_list|(
name|mp
parameter_list|,
name|str
parameter_list|,
name|len
parameter_list|)
value|mp_read_signed_bin((mp), (str), (len))
define|#
directive|define
name|mp_raw_size
parameter_list|(
name|mp
parameter_list|)
value|mp_signed_bin_size(mp)
define|#
directive|define
name|mp_toraw
parameter_list|(
name|mp
parameter_list|,
name|str
parameter_list|)
value|mp_to_signed_bin((mp), (str))
define|#
directive|define
name|mp_read_mag
parameter_list|(
name|mp
parameter_list|,
name|str
parameter_list|,
name|len
parameter_list|)
value|mp_read_unsigned_bin((mp), (str), (len))
define|#
directive|define
name|mp_mag_size
parameter_list|(
name|mp
parameter_list|)
value|mp_unsigned_bin_size(mp)
define|#
directive|define
name|mp_tomag
parameter_list|(
name|mp
parameter_list|,
name|str
parameter_list|)
value|mp_to_unsigned_bin((mp), (str))
define|#
directive|define
name|mp_tobinary
parameter_list|(
name|M
parameter_list|,
name|S
parameter_list|)
value|mp_toradix((M), (S), 2)
define|#
directive|define
name|mp_tooctal
parameter_list|(
name|M
parameter_list|,
name|S
parameter_list|)
value|mp_toradix((M), (S), 8)
define|#
directive|define
name|mp_todecimal
parameter_list|(
name|M
parameter_list|,
name|S
parameter_list|)
value|mp_toradix((M), (S), 10)
define|#
directive|define
name|mp_tohex
parameter_list|(
name|M
parameter_list|,
name|S
parameter_list|)
value|mp_toradix((M), (S), 16)
comment|/* lowlevel functions, do not call! */
name|int
name|s_mp_add
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
function_decl|;
name|int
name|s_mp_sub
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
function_decl|;
define|#
directive|define
name|s_mp_mul
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|s_mp_mul_digs(a, b, c, (a)->used + (b)->used + 1)
name|int
name|fast_s_mp_mul_digs
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|,
name|int
name|digs
parameter_list|)
function_decl|;
name|int
name|s_mp_mul_digs
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|,
name|int
name|digs
parameter_list|)
function_decl|;
name|int
name|fast_s_mp_mul_high_digs
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|,
name|int
name|digs
parameter_list|)
function_decl|;
name|int
name|s_mp_mul_high_digs
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|,
name|int
name|digs
parameter_list|)
function_decl|;
name|int
name|fast_s_mp_sqr
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|)
function_decl|;
name|int
name|s_mp_sqr
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|)
function_decl|;
name|int
name|mp_karatsuba_mul
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
function_decl|;
name|int
name|mp_toom_mul
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
function_decl|;
name|int
name|mp_karatsuba_sqr
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|)
function_decl|;
name|int
name|mp_toom_sqr
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|)
function_decl|;
name|int
name|fast_mp_invmod
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
function_decl|;
name|int
name|mp_invmod_slow
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
function_decl|;
name|int
name|fast_mp_montgomery_reduce
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|m
parameter_list|,
name|mp_digit
name|mp
parameter_list|)
function_decl|;
name|int
name|mp_exptmod_fast
parameter_list|(
name|mp_int
modifier|*
name|G
parameter_list|,
name|mp_int
modifier|*
name|X
parameter_list|,
name|mp_int
modifier|*
name|P
parameter_list|,
name|mp_int
modifier|*
name|Y
parameter_list|,
name|int
name|mode
parameter_list|)
function_decl|;
name|int
name|s_mp_exptmod
parameter_list|(
name|mp_int
modifier|*
name|G
parameter_list|,
name|mp_int
modifier|*
name|X
parameter_list|,
name|mp_int
modifier|*
name|P
parameter_list|,
name|mp_int
modifier|*
name|Y
parameter_list|,
name|int
name|mode
parameter_list|)
function_decl|;
name|void
name|bn_reverse
parameter_list|(
name|unsigned
name|char
modifier|*
name|s
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
specifier|extern
specifier|const
name|char
modifier|*
name|mp_s_rmap
decl_stmt|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* $Source: /cvs/libtom/libtommath/tommath.h,v $ */
end_comment

begin_comment
comment|/* $Revision: 1.8 $ */
end_comment

begin_comment
comment|/* $Date: 2006/03/31 14:18:44 $ */
end_comment

end_unit

