begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<tommath.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BN_MP_EXPTMOD_FAST_C
end_ifdef

begin_comment
comment|/* LibTomMath, multiple-precision integer library -- Tom St Denis  *  * LibTomMath is a library that provides multiple-precision  * integer arithmetic as well as number theoretic functionality.  *  * The library was designed directly after the MPI library by  * Michael Fromberger but has been written from scratch with  * additional optimizations in place.  *  * The library is free for all purposes without any express  * guarantee it works.  *  * Tom St Denis, tomstdenis@gmail.com, http://libtom.org  */
end_comment

begin_comment
comment|/* computes Y == G**X mod P, HAC pp.616, Algorithm 14.85  *  * Uses a left-to-right k-ary sliding window to compute the modular exponentiation.  * The value of k changes based on the size of the exponent.  *  * Uses Montgomery or Diminished Radix reduction [whichever appropriate]  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MP_LOW_MEM
end_ifdef

begin_define
define|#
directive|define
name|TAB_SIZE
value|32
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TAB_SIZE
value|256
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|mp_exptmod_fast
parameter_list|(
name|mp_int
modifier|*
name|G
parameter_list|,
name|mp_int
modifier|*
name|X
parameter_list|,
name|mp_int
modifier|*
name|P
parameter_list|,
name|mp_int
modifier|*
name|Y
parameter_list|,
name|int
name|redmode
parameter_list|)
block|{
name|mp_int
name|M
index|[
name|TAB_SIZE
index|]
decl_stmt|,
name|res
decl_stmt|;
name|mp_digit
name|buf
decl_stmt|,
name|mp
decl_stmt|;
name|int
name|err
decl_stmt|,
name|bitbuf
decl_stmt|,
name|bitcpy
decl_stmt|,
name|bitcnt
decl_stmt|,
name|mode
decl_stmt|,
name|digidx
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|,
name|winsize
decl_stmt|;
comment|/* use a pointer to the reduction algorithm.  This allows us to use    * one of many reduction algorithms without modding the guts of    * the code with if statements everywhere.    */
name|int
function_decl|(
modifier|*
name|redux
function_decl|)
parameter_list|(
name|mp_int
modifier|*
parameter_list|,
name|mp_int
modifier|*
parameter_list|,
name|mp_digit
parameter_list|)
function_decl|;
comment|/* find window size */
name|x
operator|=
name|mp_count_bits
argument_list|(
name|X
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<=
literal|7
condition|)
block|{
name|winsize
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|<=
literal|36
condition|)
block|{
name|winsize
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|<=
literal|140
condition|)
block|{
name|winsize
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|<=
literal|450
condition|)
block|{
name|winsize
operator|=
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|<=
literal|1303
condition|)
block|{
name|winsize
operator|=
literal|6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|<=
literal|3529
condition|)
block|{
name|winsize
operator|=
literal|7
expr_stmt|;
block|}
else|else
block|{
name|winsize
operator|=
literal|8
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MP_LOW_MEM
if|if
condition|(
name|winsize
operator|>
literal|5
condition|)
block|{
name|winsize
operator|=
literal|5
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* init M array */
comment|/* init first cell */
if|if
condition|(
operator|(
name|err
operator|=
name|mp_init
argument_list|(
operator|&
name|M
index|[
literal|1
index|]
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
return|return
name|err
return|;
block|}
comment|/* now init the second half of the array */
for|for
control|(
name|x
operator|=
literal|1
operator|<<
operator|(
name|winsize
operator|-
literal|1
operator|)
init|;
name|x
operator|<
operator|(
literal|1
operator|<<
name|winsize
operator|)
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|mp_init
argument_list|(
operator|&
name|M
index|[
name|x
index|]
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
for|for
control|(
name|y
operator|=
literal|1
operator|<<
operator|(
name|winsize
operator|-
literal|1
operator|)
init|;
name|y
operator|<
name|x
condition|;
name|y
operator|++
control|)
block|{
name|mp_clear
argument_list|(
operator|&
name|M
index|[
name|y
index|]
argument_list|)
expr_stmt|;
block|}
name|mp_clear
argument_list|(
operator|&
name|M
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
block|}
comment|/* determine and setup reduction code */
if|if
condition|(
name|redmode
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|BN_MP_MONTGOMERY_SETUP_C
comment|/* now setup montgomery  */
if|if
condition|(
operator|(
name|err
operator|=
name|mp_montgomery_setup
argument_list|(
name|P
argument_list|,
operator|&
name|mp
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_M
goto|;
block|}
else|#
directive|else
name|err
operator|=
name|MP_VAL
expr_stmt|;
goto|goto
name|LBL_M
goto|;
endif|#
directive|endif
comment|/* automatically pick the comba one if available (saves quite a few calls/ifs) */
ifdef|#
directive|ifdef
name|BN_FAST_MP_MONTGOMERY_REDUCE_C
if|if
condition|(
operator|(
operator|(
name|P
operator|->
name|used
operator|*
literal|2
operator|+
literal|1
operator|)
operator|<
name|MP_WARRAY
operator|)
operator|&&
name|P
operator|->
name|used
operator|<
operator|(
literal|1
operator|<<
operator|(
operator|(
name|CHAR_BIT
operator|*
sizeof|sizeof
argument_list|(
name|mp_word
argument_list|)
operator|)
operator|-
operator|(
literal|2
operator|*
name|DIGIT_BIT
operator|)
operator|)
operator|)
condition|)
block|{
name|redux
operator|=
name|fast_mp_montgomery_reduce
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|BN_MP_MONTGOMERY_REDUCE_C
comment|/* use slower baseline Montgomery method */
name|redux
operator|=
name|mp_montgomery_reduce
expr_stmt|;
else|#
directive|else
name|err
operator|=
name|MP_VAL
expr_stmt|;
goto|goto
name|LBL_M
goto|;
endif|#
directive|endif
block|}
block|}
elseif|else
if|if
condition|(
name|redmode
operator|==
literal|1
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|BN_MP_DR_SETUP_C
argument_list|)
operator|&&
name|defined
argument_list|(
name|BN_MP_DR_REDUCE_C
argument_list|)
comment|/* setup DR reduction for moduli of the form B**k - b */
name|mp_dr_setup
argument_list|(
name|P
argument_list|,
operator|&
name|mp
argument_list|)
expr_stmt|;
name|redux
operator|=
name|mp_dr_reduce
expr_stmt|;
else|#
directive|else
name|err
operator|=
name|MP_VAL
expr_stmt|;
goto|goto
name|LBL_M
goto|;
endif|#
directive|endif
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|BN_MP_REDUCE_2K_SETUP_C
argument_list|)
operator|&&
name|defined
argument_list|(
name|BN_MP_REDUCE_2K_C
argument_list|)
comment|/* setup DR reduction for moduli of the form 2**k - b */
if|if
condition|(
operator|(
name|err
operator|=
name|mp_reduce_2k_setup
argument_list|(
name|P
argument_list|,
operator|&
name|mp
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_M
goto|;
block|}
name|redux
operator|=
name|mp_reduce_2k
expr_stmt|;
else|#
directive|else
name|err
operator|=
name|MP_VAL
expr_stmt|;
goto|goto
name|LBL_M
goto|;
endif|#
directive|endif
block|}
comment|/* setup result */
if|if
condition|(
operator|(
name|err
operator|=
name|mp_init
argument_list|(
operator|&
name|res
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_M
goto|;
block|}
comment|/* create M table    *     *    * The first half of the table is not computed though accept for M[0] and M[1]    */
if|if
condition|(
name|redmode
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|BN_MP_MONTGOMERY_CALC_NORMALIZATION_C
comment|/* now we need R mod m */
if|if
condition|(
operator|(
name|err
operator|=
name|mp_montgomery_calc_normalization
argument_list|(
operator|&
name|res
argument_list|,
name|P
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
else|#
directive|else
name|err
operator|=
name|MP_VAL
expr_stmt|;
goto|goto
name|LBL_RES
goto|;
endif|#
directive|endif
comment|/* now set M[1] to G * R mod m */
if|if
condition|(
operator|(
name|err
operator|=
name|mp_mulmod
argument_list|(
name|G
argument_list|,
operator|&
name|res
argument_list|,
name|P
argument_list|,
operator|&
name|M
index|[
literal|1
index|]
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
block|}
else|else
block|{
name|mp_set
argument_list|(
operator|&
name|res
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|mp_mod
argument_list|(
name|G
argument_list|,
name|P
argument_list|,
operator|&
name|M
index|[
literal|1
index|]
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
block|}
comment|/* compute the value at M[1<<(winsize-1)] by squaring M[1] (winsize-1) times */
if|if
condition|(
operator|(
name|err
operator|=
name|mp_copy
argument_list|(
operator|&
name|M
index|[
literal|1
index|]
argument_list|,
operator|&
name|M
index|[
literal|1
operator|<<
operator|(
name|winsize
operator|-
literal|1
operator|)
index|]
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
operator|(
name|winsize
operator|-
literal|1
operator|)
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|mp_sqr
argument_list|(
operator|&
name|M
index|[
literal|1
operator|<<
operator|(
name|winsize
operator|-
literal|1
operator|)
index|]
argument_list|,
operator|&
name|M
index|[
literal|1
operator|<<
operator|(
name|winsize
operator|-
literal|1
operator|)
index|]
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|redux
argument_list|(
operator|&
name|M
index|[
literal|1
operator|<<
operator|(
name|winsize
operator|-
literal|1
operator|)
index|]
argument_list|,
name|P
argument_list|,
name|mp
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
block|}
comment|/* create upper table */
for|for
control|(
name|x
operator|=
operator|(
literal|1
operator|<<
operator|(
name|winsize
operator|-
literal|1
operator|)
operator|)
operator|+
literal|1
init|;
name|x
operator|<
operator|(
literal|1
operator|<<
name|winsize
operator|)
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|mp_mul
argument_list|(
operator|&
name|M
index|[
name|x
operator|-
literal|1
index|]
argument_list|,
operator|&
name|M
index|[
literal|1
index|]
argument_list|,
operator|&
name|M
index|[
name|x
index|]
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|redux
argument_list|(
operator|&
name|M
index|[
name|x
index|]
argument_list|,
name|P
argument_list|,
name|mp
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
block|}
comment|/* set initial mode and bit cnt */
name|mode
operator|=
literal|0
expr_stmt|;
name|bitcnt
operator|=
literal|1
expr_stmt|;
name|buf
operator|=
literal|0
expr_stmt|;
name|digidx
operator|=
name|X
operator|->
name|used
operator|-
literal|1
expr_stmt|;
name|bitcpy
operator|=
literal|0
expr_stmt|;
name|bitbuf
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* grab next digit as required */
if|if
condition|(
operator|--
name|bitcnt
operator|==
literal|0
condition|)
block|{
comment|/* if digidx == -1 we are out of digits so break */
if|if
condition|(
name|digidx
operator|==
operator|-
literal|1
condition|)
block|{
break|break;
block|}
comment|/* read next digit and reset bitcnt */
name|buf
operator|=
name|X
operator|->
name|dp
index|[
name|digidx
operator|--
index|]
expr_stmt|;
name|bitcnt
operator|=
operator|(
name|int
operator|)
name|DIGIT_BIT
expr_stmt|;
block|}
comment|/* grab the next msb from the exponent */
name|y
operator|=
call|(
name|mp_digit
call|)
argument_list|(
name|buf
operator|>>
operator|(
name|DIGIT_BIT
operator|-
literal|1
operator|)
argument_list|)
operator|&
literal|1
expr_stmt|;
name|buf
operator|<<=
operator|(
name|mp_digit
operator|)
literal|1
expr_stmt|;
comment|/* if the bit is zero and mode == 0 then we ignore it      * These represent the leading zero bits before the first 1 bit      * in the exponent.  Technically this opt is not required but it      * does lower the # of trivial squaring/reductions used      */
if|if
condition|(
name|mode
operator|==
literal|0
operator|&&
name|y
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
comment|/* if the bit is zero and mode == 1 then we square */
if|if
condition|(
name|mode
operator|==
literal|1
operator|&&
name|y
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|mp_sqr
argument_list|(
operator|&
name|res
argument_list|,
operator|&
name|res
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|redux
argument_list|(
operator|&
name|res
argument_list|,
name|P
argument_list|,
name|mp
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
continue|continue;
block|}
comment|/* else we add it to the window */
name|bitbuf
operator||=
operator|(
name|y
operator|<<
operator|(
name|winsize
operator|-
operator|++
name|bitcpy
operator|)
operator|)
expr_stmt|;
name|mode
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|bitcpy
operator|==
name|winsize
condition|)
block|{
comment|/* ok window is filled so square as required and multiply  */
comment|/* square first */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|winsize
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|mp_sqr
argument_list|(
operator|&
name|res
argument_list|,
operator|&
name|res
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|redux
argument_list|(
operator|&
name|res
argument_list|,
name|P
argument_list|,
name|mp
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
block|}
comment|/* then multiply */
if|if
condition|(
operator|(
name|err
operator|=
name|mp_mul
argument_list|(
operator|&
name|res
argument_list|,
operator|&
name|M
index|[
name|bitbuf
index|]
argument_list|,
operator|&
name|res
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|redux
argument_list|(
operator|&
name|res
argument_list|,
name|P
argument_list|,
name|mp
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
comment|/* empty window and reset */
name|bitcpy
operator|=
literal|0
expr_stmt|;
name|bitbuf
operator|=
literal|0
expr_stmt|;
name|mode
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* if bits remain then square/multiply */
if|if
condition|(
name|mode
operator|==
literal|2
operator|&&
name|bitcpy
operator|>
literal|0
condition|)
block|{
comment|/* square then multiply if the bit is set */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|bitcpy
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|mp_sqr
argument_list|(
operator|&
name|res
argument_list|,
operator|&
name|res
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|redux
argument_list|(
operator|&
name|res
argument_list|,
name|P
argument_list|,
name|mp
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
comment|/* get next bit of the window */
name|bitbuf
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|bitbuf
operator|&
operator|(
literal|1
operator|<<
name|winsize
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* then multiply */
if|if
condition|(
operator|(
name|err
operator|=
name|mp_mul
argument_list|(
operator|&
name|res
argument_list|,
operator|&
name|M
index|[
literal|1
index|]
argument_list|,
operator|&
name|res
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|redux
argument_list|(
operator|&
name|res
argument_list|,
name|P
argument_list|,
name|mp
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|redmode
operator|==
literal|0
condition|)
block|{
comment|/* fixup result if Montgomery reduction is used       * recall that any value in a Montgomery system is       * actually multiplied by R mod n.  So we have       * to reduce one more time to cancel out the factor       * of R.       */
if|if
condition|(
operator|(
name|err
operator|=
name|redux
argument_list|(
operator|&
name|res
argument_list|,
name|P
argument_list|,
name|mp
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
block|}
comment|/* swap res with Y */
name|mp_exch
argument_list|(
operator|&
name|res
argument_list|,
name|Y
argument_list|)
expr_stmt|;
name|err
operator|=
name|MP_OKAY
expr_stmt|;
name|LBL_RES
label|:
name|mp_clear
argument_list|(
operator|&
name|res
argument_list|)
expr_stmt|;
name|LBL_M
label|:
name|mp_clear
argument_list|(
operator|&
name|M
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|1
operator|<<
operator|(
name|winsize
operator|-
literal|1
operator|)
init|;
name|x
operator|<
operator|(
literal|1
operator|<<
name|winsize
operator|)
condition|;
name|x
operator|++
control|)
block|{
name|mp_clear
argument_list|(
operator|&
name|M
index|[
name|x
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* $Source: /cvs/libtom/libtommath/bn_mp_exptmod_fast.c,v $ */
end_comment

begin_comment
comment|/* $Revision: 1.4 $ */
end_comment

begin_comment
comment|/* $Date: 2006/12/28 01:25:13 $ */
end_comment

end_unit

