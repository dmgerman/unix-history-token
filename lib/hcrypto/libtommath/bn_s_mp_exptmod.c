begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<tommath.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BN_S_MP_EXPTMOD_C
end_ifdef

begin_comment
comment|/* LibTomMath, multiple-precision integer library -- Tom St Denis  *  * LibTomMath is a library that provides multiple-precision  * integer arithmetic as well as number theoretic functionality.  *  * The library was designed directly after the MPI library by  * Michael Fromberger but has been written from scratch with  * additional optimizations in place.  *  * The library is free for all purposes without any express  * guarantee it works.  *  * Tom St Denis, tomstdenis@gmail.com, http://libtom.org  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MP_LOW_MEM
end_ifdef

begin_define
define|#
directive|define
name|TAB_SIZE
value|32
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TAB_SIZE
value|256
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|s_mp_exptmod
parameter_list|(
name|mp_int
modifier|*
name|G
parameter_list|,
name|mp_int
modifier|*
name|X
parameter_list|,
name|mp_int
modifier|*
name|P
parameter_list|,
name|mp_int
modifier|*
name|Y
parameter_list|,
name|int
name|redmode
parameter_list|)
block|{
name|mp_int
name|M
index|[
name|TAB_SIZE
index|]
decl_stmt|,
name|res
decl_stmt|,
name|mu
decl_stmt|;
name|mp_digit
name|buf
decl_stmt|;
name|int
name|err
decl_stmt|,
name|bitbuf
decl_stmt|,
name|bitcpy
decl_stmt|,
name|bitcnt
decl_stmt|,
name|mode
decl_stmt|,
name|digidx
decl_stmt|,
name|x
decl_stmt|,
name|y
decl_stmt|,
name|winsize
decl_stmt|;
name|int
function_decl|(
modifier|*
name|redux
function_decl|)
parameter_list|(
name|mp_int
modifier|*
parameter_list|,
name|mp_int
modifier|*
parameter_list|,
name|mp_int
modifier|*
parameter_list|)
function_decl|;
comment|/* find window size */
name|x
operator|=
name|mp_count_bits
argument_list|(
name|X
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|<=
literal|7
condition|)
block|{
name|winsize
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|<=
literal|36
condition|)
block|{
name|winsize
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|<=
literal|140
condition|)
block|{
name|winsize
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|<=
literal|450
condition|)
block|{
name|winsize
operator|=
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|<=
literal|1303
condition|)
block|{
name|winsize
operator|=
literal|6
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|<=
literal|3529
condition|)
block|{
name|winsize
operator|=
literal|7
expr_stmt|;
block|}
else|else
block|{
name|winsize
operator|=
literal|8
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MP_LOW_MEM
if|if
condition|(
name|winsize
operator|>
literal|5
condition|)
block|{
name|winsize
operator|=
literal|5
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* init M array */
comment|/* init first cell */
if|if
condition|(
operator|(
name|err
operator|=
name|mp_init
argument_list|(
operator|&
name|M
index|[
literal|1
index|]
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
return|return
name|err
return|;
block|}
comment|/* now init the second half of the array */
for|for
control|(
name|x
operator|=
literal|1
operator|<<
operator|(
name|winsize
operator|-
literal|1
operator|)
init|;
name|x
operator|<
operator|(
literal|1
operator|<<
name|winsize
operator|)
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|mp_init
argument_list|(
operator|&
name|M
index|[
name|x
index|]
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
for|for
control|(
name|y
operator|=
literal|1
operator|<<
operator|(
name|winsize
operator|-
literal|1
operator|)
init|;
name|y
operator|<
name|x
condition|;
name|y
operator|++
control|)
block|{
name|mp_clear
argument_list|(
operator|&
name|M
index|[
name|y
index|]
argument_list|)
expr_stmt|;
block|}
name|mp_clear
argument_list|(
operator|&
name|M
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
block|}
comment|/* create mu, used for Barrett reduction */
if|if
condition|(
operator|(
name|err
operator|=
name|mp_init
argument_list|(
operator|&
name|mu
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_M
goto|;
block|}
if|if
condition|(
name|redmode
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|mp_reduce_setup
argument_list|(
operator|&
name|mu
argument_list|,
name|P
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_MU
goto|;
block|}
name|redux
operator|=
name|mp_reduce
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|mp_reduce_2k_setup_l
argument_list|(
name|P
argument_list|,
operator|&
name|mu
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_MU
goto|;
block|}
name|redux
operator|=
name|mp_reduce_2k_l
expr_stmt|;
block|}
comment|/* create M table    *    * The M table contains powers of the base,    * e.g. M[x] = G**x mod P    *    * The first half of the table is not    * computed though accept for M[0] and M[1]    */
if|if
condition|(
operator|(
name|err
operator|=
name|mp_mod
argument_list|(
name|G
argument_list|,
name|P
argument_list|,
operator|&
name|M
index|[
literal|1
index|]
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_MU
goto|;
block|}
comment|/* compute the value at M[1<<(winsize-1)] by squaring    * M[1] (winsize-1) times    */
if|if
condition|(
operator|(
name|err
operator|=
name|mp_copy
argument_list|(
operator|&
name|M
index|[
literal|1
index|]
argument_list|,
operator|&
name|M
index|[
literal|1
operator|<<
operator|(
name|winsize
operator|-
literal|1
operator|)
index|]
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_MU
goto|;
block|}
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
operator|(
name|winsize
operator|-
literal|1
operator|)
condition|;
name|x
operator|++
control|)
block|{
comment|/* square it */
if|if
condition|(
operator|(
name|err
operator|=
name|mp_sqr
argument_list|(
operator|&
name|M
index|[
literal|1
operator|<<
operator|(
name|winsize
operator|-
literal|1
operator|)
index|]
argument_list|,
operator|&
name|M
index|[
literal|1
operator|<<
operator|(
name|winsize
operator|-
literal|1
operator|)
index|]
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_MU
goto|;
block|}
comment|/* reduce modulo P */
if|if
condition|(
operator|(
name|err
operator|=
name|redux
argument_list|(
operator|&
name|M
index|[
literal|1
operator|<<
operator|(
name|winsize
operator|-
literal|1
operator|)
index|]
argument_list|,
name|P
argument_list|,
operator|&
name|mu
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_MU
goto|;
block|}
block|}
comment|/* create upper table, that is M[x] = M[x-1] * M[1] (mod P)    * for x = (2**(winsize - 1) + 1) to (2**winsize - 1)    */
for|for
control|(
name|x
operator|=
operator|(
literal|1
operator|<<
operator|(
name|winsize
operator|-
literal|1
operator|)
operator|)
operator|+
literal|1
init|;
name|x
operator|<
operator|(
literal|1
operator|<<
name|winsize
operator|)
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|mp_mul
argument_list|(
operator|&
name|M
index|[
name|x
operator|-
literal|1
index|]
argument_list|,
operator|&
name|M
index|[
literal|1
index|]
argument_list|,
operator|&
name|M
index|[
name|x
index|]
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_MU
goto|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|redux
argument_list|(
operator|&
name|M
index|[
name|x
index|]
argument_list|,
name|P
argument_list|,
operator|&
name|mu
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_MU
goto|;
block|}
block|}
comment|/* setup result */
if|if
condition|(
operator|(
name|err
operator|=
name|mp_init
argument_list|(
operator|&
name|res
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_MU
goto|;
block|}
name|mp_set
argument_list|(
operator|&
name|res
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* set initial mode and bit cnt */
name|mode
operator|=
literal|0
expr_stmt|;
name|bitcnt
operator|=
literal|1
expr_stmt|;
name|buf
operator|=
literal|0
expr_stmt|;
name|digidx
operator|=
name|X
operator|->
name|used
operator|-
literal|1
expr_stmt|;
name|bitcpy
operator|=
literal|0
expr_stmt|;
name|bitbuf
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* grab next digit as required */
if|if
condition|(
operator|--
name|bitcnt
operator|==
literal|0
condition|)
block|{
comment|/* if digidx == -1 we are out of digits */
if|if
condition|(
name|digidx
operator|==
operator|-
literal|1
condition|)
block|{
break|break;
block|}
comment|/* read next digit and reset the bitcnt */
name|buf
operator|=
name|X
operator|->
name|dp
index|[
name|digidx
operator|--
index|]
expr_stmt|;
name|bitcnt
operator|=
operator|(
name|int
operator|)
name|DIGIT_BIT
expr_stmt|;
block|}
comment|/* grab the next msb from the exponent */
name|y
operator|=
operator|(
name|buf
operator|>>
call|(
name|mp_digit
call|)
argument_list|(
name|DIGIT_BIT
operator|-
literal|1
argument_list|)
operator|)
operator|&
literal|1
expr_stmt|;
name|buf
operator|<<=
operator|(
name|mp_digit
operator|)
literal|1
expr_stmt|;
comment|/* if the bit is zero and mode == 0 then we ignore it      * These represent the leading zero bits before the first 1 bit      * in the exponent.  Technically this opt is not required but it      * does lower the # of trivial squaring/reductions used      */
if|if
condition|(
name|mode
operator|==
literal|0
operator|&&
name|y
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
comment|/* if the bit is zero and mode == 1 then we square */
if|if
condition|(
name|mode
operator|==
literal|1
operator|&&
name|y
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|mp_sqr
argument_list|(
operator|&
name|res
argument_list|,
operator|&
name|res
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|redux
argument_list|(
operator|&
name|res
argument_list|,
name|P
argument_list|,
operator|&
name|mu
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
continue|continue;
block|}
comment|/* else we add it to the window */
name|bitbuf
operator||=
operator|(
name|y
operator|<<
operator|(
name|winsize
operator|-
operator|++
name|bitcpy
operator|)
operator|)
expr_stmt|;
name|mode
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|bitcpy
operator|==
name|winsize
condition|)
block|{
comment|/* ok window is filled so square as required and multiply  */
comment|/* square first */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|winsize
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|mp_sqr
argument_list|(
operator|&
name|res
argument_list|,
operator|&
name|res
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|redux
argument_list|(
operator|&
name|res
argument_list|,
name|P
argument_list|,
operator|&
name|mu
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
block|}
comment|/* then multiply */
if|if
condition|(
operator|(
name|err
operator|=
name|mp_mul
argument_list|(
operator|&
name|res
argument_list|,
operator|&
name|M
index|[
name|bitbuf
index|]
argument_list|,
operator|&
name|res
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|redux
argument_list|(
operator|&
name|res
argument_list|,
name|P
argument_list|,
operator|&
name|mu
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
comment|/* empty window and reset */
name|bitcpy
operator|=
literal|0
expr_stmt|;
name|bitbuf
operator|=
literal|0
expr_stmt|;
name|mode
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* if bits remain then square/multiply */
if|if
condition|(
name|mode
operator|==
literal|2
operator|&&
name|bitcpy
operator|>
literal|0
condition|)
block|{
comment|/* square then multiply if the bit is set */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|bitcpy
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|err
operator|=
name|mp_sqr
argument_list|(
operator|&
name|res
argument_list|,
operator|&
name|res
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|redux
argument_list|(
operator|&
name|res
argument_list|,
name|P
argument_list|,
operator|&
name|mu
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
name|bitbuf
operator|<<=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|bitbuf
operator|&
operator|(
literal|1
operator|<<
name|winsize
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* then multiply */
if|if
condition|(
operator|(
name|err
operator|=
name|mp_mul
argument_list|(
operator|&
name|res
argument_list|,
operator|&
name|M
index|[
literal|1
index|]
argument_list|,
operator|&
name|res
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|redux
argument_list|(
operator|&
name|res
argument_list|,
name|P
argument_list|,
operator|&
name|mu
argument_list|)
operator|)
operator|!=
name|MP_OKAY
condition|)
block|{
goto|goto
name|LBL_RES
goto|;
block|}
block|}
block|}
block|}
name|mp_exch
argument_list|(
operator|&
name|res
argument_list|,
name|Y
argument_list|)
expr_stmt|;
name|err
operator|=
name|MP_OKAY
expr_stmt|;
name|LBL_RES
label|:
name|mp_clear
argument_list|(
operator|&
name|res
argument_list|)
expr_stmt|;
name|LBL_MU
label|:
name|mp_clear
argument_list|(
operator|&
name|mu
argument_list|)
expr_stmt|;
name|LBL_M
label|:
name|mp_clear
argument_list|(
operator|&
name|M
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|1
operator|<<
operator|(
name|winsize
operator|-
literal|1
operator|)
init|;
name|x
operator|<
operator|(
literal|1
operator|<<
name|winsize
operator|)
condition|;
name|x
operator|++
control|)
block|{
name|mp_clear
argument_list|(
operator|&
name|M
index|[
name|x
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* $Source: /cvs/libtom/libtommath/bn_s_mp_exptmod.c,v $ */
end_comment

begin_comment
comment|/* $Revision: 1.5 $ */
end_comment

begin_comment
comment|/* $Date: 2006/12/28 01:25:13 $ */
end_comment

end_unit

