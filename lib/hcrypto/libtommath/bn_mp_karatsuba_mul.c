begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|<tommath.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BN_MP_KARATSUBA_MUL_C
end_ifdef

begin_comment
comment|/* LibTomMath, multiple-precision integer library -- Tom St Denis  *  * LibTomMath is a library that provides multiple-precision  * integer arithmetic as well as number theoretic functionality.  *  * The library was designed directly after the MPI library by  * Michael Fromberger but has been written from scratch with  * additional optimizations in place.  *  * The library is free for all purposes without any express  * guarantee it works.  *  * Tom St Denis, tomstdenis@gmail.com, http://libtom.org  */
end_comment

begin_comment
comment|/* c = |a| * |b| using Karatsuba Multiplication using  * three half size multiplications  *  * Let B represent the radix [e.g. 2**DIGIT_BIT] and  * let n represent half of the number of digits in  * the min(a,b)  *  * a = a1 * B**n + a0  * b = b1 * B**n + b0  *  * Then, a * b =>    a1b1 * B**2n + ((a1 + a0)(b1 + b0) - (a0b0 + a1b1)) * B + a0b0  *  * Note that a1b1 and a0b0 are used twice and only need to be  * computed once.  So in total three half size (half # of  * digit) multiplications are performed, a0b0, a1b1 and  * (a1+b1)(a0+b0)  *  * Note that a multiplication of half the digits requires  * 1/4th the number of single precision multiplications so in  * total after one call 25% of the single precision multiplications  * are saved.  Note also that the call to mp_mul can end up back  * in this function if the a0, a1, b0, or b1 are above the threshold.  * This is known as divide-and-conquer and leads to the famous  * O(N**lg(3)) or O(N**1.584) work which is asymptopically lower than  * the standard O(N**2) that the baseline/comba methods use.  * Generally though the overhead of this method doesn't pay off  * until a certain size (N ~ 80) is reached.  */
end_comment

begin_function
name|int
name|mp_karatsuba_mul
parameter_list|(
name|mp_int
modifier|*
name|a
parameter_list|,
name|mp_int
modifier|*
name|b
parameter_list|,
name|mp_int
modifier|*
name|c
parameter_list|)
block|{
name|mp_int
name|x0
decl_stmt|,
name|x1
decl_stmt|,
name|y0
decl_stmt|,
name|y1
decl_stmt|,
name|t1
decl_stmt|,
name|x0y0
decl_stmt|,
name|x1y1
decl_stmt|;
name|int
name|B
decl_stmt|,
name|err
decl_stmt|;
comment|/* default the return code to an error */
name|err
operator|=
name|MP_MEM
expr_stmt|;
comment|/* min # of digits */
name|B
operator|=
name|MIN
argument_list|(
name|a
operator|->
name|used
argument_list|,
name|b
operator|->
name|used
argument_list|)
expr_stmt|;
comment|/* now divide in two */
name|B
operator|=
name|B
operator|>>
literal|1
expr_stmt|;
comment|/* init copy all the temps */
if|if
condition|(
name|mp_init_size
argument_list|(
operator|&
name|x0
argument_list|,
name|B
argument_list|)
operator|!=
name|MP_OKAY
condition|)
goto|goto
name|ERR
goto|;
if|if
condition|(
name|mp_init_size
argument_list|(
operator|&
name|x1
argument_list|,
name|a
operator|->
name|used
operator|-
name|B
argument_list|)
operator|!=
name|MP_OKAY
condition|)
goto|goto
name|X0
goto|;
if|if
condition|(
name|mp_init_size
argument_list|(
operator|&
name|y0
argument_list|,
name|B
argument_list|)
operator|!=
name|MP_OKAY
condition|)
goto|goto
name|X1
goto|;
if|if
condition|(
name|mp_init_size
argument_list|(
operator|&
name|y1
argument_list|,
name|b
operator|->
name|used
operator|-
name|B
argument_list|)
operator|!=
name|MP_OKAY
condition|)
goto|goto
name|Y0
goto|;
comment|/* init temps */
if|if
condition|(
name|mp_init_size
argument_list|(
operator|&
name|t1
argument_list|,
name|B
operator|*
literal|2
argument_list|)
operator|!=
name|MP_OKAY
condition|)
goto|goto
name|Y1
goto|;
if|if
condition|(
name|mp_init_size
argument_list|(
operator|&
name|x0y0
argument_list|,
name|B
operator|*
literal|2
argument_list|)
operator|!=
name|MP_OKAY
condition|)
goto|goto
name|T1
goto|;
if|if
condition|(
name|mp_init_size
argument_list|(
operator|&
name|x1y1
argument_list|,
name|B
operator|*
literal|2
argument_list|)
operator|!=
name|MP_OKAY
condition|)
goto|goto
name|X0Y0
goto|;
comment|/* now shift the digits */
name|x0
operator|.
name|used
operator|=
name|y0
operator|.
name|used
operator|=
name|B
expr_stmt|;
name|x1
operator|.
name|used
operator|=
name|a
operator|->
name|used
operator|-
name|B
expr_stmt|;
name|y1
operator|.
name|used
operator|=
name|b
operator|->
name|used
operator|-
name|B
expr_stmt|;
block|{
specifier|register
name|int
name|x
decl_stmt|;
specifier|register
name|mp_digit
modifier|*
name|tmpa
decl_stmt|,
modifier|*
name|tmpb
decl_stmt|,
modifier|*
name|tmpx
decl_stmt|,
modifier|*
name|tmpy
decl_stmt|;
comment|/* we copy the digits directly instead of using higher level functions      * since we also need to shift the digits      */
name|tmpa
operator|=
name|a
operator|->
name|dp
expr_stmt|;
name|tmpb
operator|=
name|b
operator|->
name|dp
expr_stmt|;
name|tmpx
operator|=
name|x0
operator|.
name|dp
expr_stmt|;
name|tmpy
operator|=
name|y0
operator|.
name|dp
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|B
condition|;
name|x
operator|++
control|)
block|{
operator|*
name|tmpx
operator|++
operator|=
operator|*
name|tmpa
operator|++
expr_stmt|;
operator|*
name|tmpy
operator|++
operator|=
operator|*
name|tmpb
operator|++
expr_stmt|;
block|}
name|tmpx
operator|=
name|x1
operator|.
name|dp
expr_stmt|;
for|for
control|(
name|x
operator|=
name|B
init|;
name|x
operator|<
name|a
operator|->
name|used
condition|;
name|x
operator|++
control|)
block|{
operator|*
name|tmpx
operator|++
operator|=
operator|*
name|tmpa
operator|++
expr_stmt|;
block|}
name|tmpy
operator|=
name|y1
operator|.
name|dp
expr_stmt|;
for|for
control|(
name|x
operator|=
name|B
init|;
name|x
operator|<
name|b
operator|->
name|used
condition|;
name|x
operator|++
control|)
block|{
operator|*
name|tmpy
operator|++
operator|=
operator|*
name|tmpb
operator|++
expr_stmt|;
block|}
block|}
comment|/* only need to clamp the lower words since by definition the    * upper words x1/y1 must have a known number of digits    */
name|mp_clamp
argument_list|(
operator|&
name|x0
argument_list|)
expr_stmt|;
name|mp_clamp
argument_list|(
operator|&
name|y0
argument_list|)
expr_stmt|;
comment|/* now calc the products x0y0 and x1y1 */
comment|/* after this x0 is no longer required, free temp [x0==t2]! */
if|if
condition|(
name|mp_mul
argument_list|(
operator|&
name|x0
argument_list|,
operator|&
name|y0
argument_list|,
operator|&
name|x0y0
argument_list|)
operator|!=
name|MP_OKAY
condition|)
goto|goto
name|X1Y1
goto|;
comment|/* x0y0 = x0*y0 */
if|if
condition|(
name|mp_mul
argument_list|(
operator|&
name|x1
argument_list|,
operator|&
name|y1
argument_list|,
operator|&
name|x1y1
argument_list|)
operator|!=
name|MP_OKAY
condition|)
goto|goto
name|X1Y1
goto|;
comment|/* x1y1 = x1*y1 */
comment|/* now calc x1+x0 and y1+y0 */
if|if
condition|(
name|s_mp_add
argument_list|(
operator|&
name|x1
argument_list|,
operator|&
name|x0
argument_list|,
operator|&
name|t1
argument_list|)
operator|!=
name|MP_OKAY
condition|)
goto|goto
name|X1Y1
goto|;
comment|/* t1 = x1 - x0 */
if|if
condition|(
name|s_mp_add
argument_list|(
operator|&
name|y1
argument_list|,
operator|&
name|y0
argument_list|,
operator|&
name|x0
argument_list|)
operator|!=
name|MP_OKAY
condition|)
goto|goto
name|X1Y1
goto|;
comment|/* t2 = y1 - y0 */
if|if
condition|(
name|mp_mul
argument_list|(
operator|&
name|t1
argument_list|,
operator|&
name|x0
argument_list|,
operator|&
name|t1
argument_list|)
operator|!=
name|MP_OKAY
condition|)
goto|goto
name|X1Y1
goto|;
comment|/* t1 = (x1 + x0) * (y1 + y0) */
comment|/* add x0y0 */
if|if
condition|(
name|mp_add
argument_list|(
operator|&
name|x0y0
argument_list|,
operator|&
name|x1y1
argument_list|,
operator|&
name|x0
argument_list|)
operator|!=
name|MP_OKAY
condition|)
goto|goto
name|X1Y1
goto|;
comment|/* t2 = x0y0 + x1y1 */
if|if
condition|(
name|s_mp_sub
argument_list|(
operator|&
name|t1
argument_list|,
operator|&
name|x0
argument_list|,
operator|&
name|t1
argument_list|)
operator|!=
name|MP_OKAY
condition|)
goto|goto
name|X1Y1
goto|;
comment|/* t1 = (x1+x0)*(y1+y0) - (x1y1 + x0y0) */
comment|/* shift by B */
if|if
condition|(
name|mp_lshd
argument_list|(
operator|&
name|t1
argument_list|,
name|B
argument_list|)
operator|!=
name|MP_OKAY
condition|)
goto|goto
name|X1Y1
goto|;
comment|/* t1 = (x0y0 + x1y1 - (x1-x0)*(y1-y0))<<B */
if|if
condition|(
name|mp_lshd
argument_list|(
operator|&
name|x1y1
argument_list|,
name|B
operator|*
literal|2
argument_list|)
operator|!=
name|MP_OKAY
condition|)
goto|goto
name|X1Y1
goto|;
comment|/* x1y1 = x1y1<< 2*B */
if|if
condition|(
name|mp_add
argument_list|(
operator|&
name|x0y0
argument_list|,
operator|&
name|t1
argument_list|,
operator|&
name|t1
argument_list|)
operator|!=
name|MP_OKAY
condition|)
goto|goto
name|X1Y1
goto|;
comment|/* t1 = x0y0 + t1 */
if|if
condition|(
name|mp_add
argument_list|(
operator|&
name|t1
argument_list|,
operator|&
name|x1y1
argument_list|,
name|c
argument_list|)
operator|!=
name|MP_OKAY
condition|)
goto|goto
name|X1Y1
goto|;
comment|/* t1 = x0y0 + t1 + x1y1 */
comment|/* Algorithm succeeded set the return code to MP_OKAY */
name|err
operator|=
name|MP_OKAY
expr_stmt|;
name|X1Y1
label|:
name|mp_clear
argument_list|(
operator|&
name|x1y1
argument_list|)
expr_stmt|;
name|X0Y0
label|:
name|mp_clear
argument_list|(
operator|&
name|x0y0
argument_list|)
expr_stmt|;
name|T1
label|:
name|mp_clear
argument_list|(
operator|&
name|t1
argument_list|)
expr_stmt|;
name|Y1
label|:
name|mp_clear
argument_list|(
operator|&
name|y1
argument_list|)
expr_stmt|;
name|Y0
label|:
name|mp_clear
argument_list|(
operator|&
name|y0
argument_list|)
expr_stmt|;
name|X1
label|:
name|mp_clear
argument_list|(
operator|&
name|x1
argument_list|)
expr_stmt|;
name|X0
label|:
name|mp_clear
argument_list|(
operator|&
name|x0
argument_list|)
expr_stmt|;
name|ERR
label|:
return|return
name|err
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* $Source: /cvs/libtom/libtommath/bn_mp_karatsuba_mul.c,v $ */
end_comment

begin_comment
comment|/* $Revision: 1.6 $ */
end_comment

begin_comment
comment|/* $Date: 2006/12/28 01:25:13 $ */
end_comment

end_unit

