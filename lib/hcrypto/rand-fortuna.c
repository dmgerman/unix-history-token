begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * fortuna.c  *		Fortuna-like PRNG.  *  * Copyright (c) 2005 Marko Kreen  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *	  notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *	  notice, this list of conditions and the following disclaimer in the  *	  documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.	IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $PostgreSQL: pgsql/contrib/pgcrypto/fortuna.c,v 1.8 2006/10/04 00:29:46 momjian Exp $  */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<rand.h>
end_include

begin_include
include|#
directive|include
file|<heim_threads.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|KRB5
end_ifdef

begin_include
include|#
directive|include
file|<krb5-types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<roken.h>
end_include

begin_include
include|#
directive|include
file|"randi.h"
end_include

begin_include
include|#
directive|include
file|"aes.h"
end_include

begin_include
include|#
directive|include
file|"sha.h"
end_include

begin_comment
comment|/*  * Why Fortuna-like: There does not seem to be any definitive reference  * on Fortuna in the net.  Instead this implementation is based on  * following references:  *  * http://en.wikipedia.org/wiki/Fortuna_(PRNG)  *	 - Wikipedia article  * http://jlcooke.ca/random/  *	 - Jean-Luc Cooke Fortuna-based /dev/random driver for Linux.  */
end_comment

begin_comment
comment|/*  * There is some confusion about whether and how to carry forward  * the state of the pools.	Seems like original Fortuna does not  * do it, resetting hash after each request.  I guess expecting  * feeding to happen more often that requesting.   This is absolutely  * unsuitable for pgcrypto, as nothing asynchronous happens here.  *  * J.L. Cooke fixed this by feeding previous hash to new re-initialized  * hash context.  *  * Fortuna predecessor Yarrow requires ability to query intermediate  * 'final result' from hash, without affecting it.  *  * This implementation uses the Yarrow method - asking intermediate  * results, but continuing with old state.  */
end_comment

begin_comment
comment|/*  * Algorithm parameters  */
end_comment

begin_define
define|#
directive|define
name|NUM_POOLS
value|32
end_define

begin_comment
comment|/* in microseconds */
end_comment

begin_define
define|#
directive|define
name|RESEED_INTERVAL
value|100000
end_define

begin_comment
comment|/* 0.1 sec */
end_comment

begin_comment
comment|/* for one big request, reseed after this many bytes */
end_comment

begin_define
define|#
directive|define
name|RESEED_BYTES
value|(1024*1024)
end_define

begin_comment
comment|/*  * Skip reseed if pool 0 has less than this many  * bytes added since last reseed.  */
end_comment

begin_define
define|#
directive|define
name|POOL0_FILL
value|(256/8)
end_define

begin_comment
comment|/*  * Algorithm constants  */
end_comment

begin_comment
comment|/* Both cipher key size and hash result size */
end_comment

begin_define
define|#
directive|define
name|BLOCK
value|32
end_define

begin_comment
comment|/* cipher block size */
end_comment

begin_define
define|#
directive|define
name|CIPH_BLOCK
value|16
end_define

begin_comment
comment|/* for internal wrappers */
end_comment

begin_define
define|#
directive|define
name|MD_CTX
value|SHA256_CTX
end_define

begin_define
define|#
directive|define
name|CIPH_CTX
value|AES_KEY
end_define

begin_struct
struct|struct
name|fortuna_state
block|{
name|unsigned
name|char
name|counter
index|[
name|CIPH_BLOCK
index|]
decl_stmt|;
name|unsigned
name|char
name|result
index|[
name|CIPH_BLOCK
index|]
decl_stmt|;
name|unsigned
name|char
name|key
index|[
name|BLOCK
index|]
decl_stmt|;
name|MD_CTX
name|pool
index|[
name|NUM_POOLS
index|]
decl_stmt|;
name|CIPH_CTX
name|ciph
decl_stmt|;
name|unsigned
name|reseed_count
decl_stmt|;
name|struct
name|timeval
name|last_reseed_time
decl_stmt|;
name|unsigned
name|pool0_bytes
decl_stmt|;
name|unsigned
name|rnd_pos
decl_stmt|;
name|int
name|tricks_done
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|fortuna_state
name|FState
typedef|;
end_typedef

begin_comment
comment|/*  * Use our own wrappers here.  * - Need to get intermediate result from digest, without affecting it.  * - Need re-set key on a cipher context.  * - Algorithms are guaranteed to exist.  * - No memory allocations.  */
end_comment

begin_function
specifier|static
name|void
name|ciph_init
parameter_list|(
name|CIPH_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|key
parameter_list|,
name|int
name|klen
parameter_list|)
block|{
name|AES_set_encrypt_key
argument_list|(
name|key
argument_list|,
name|klen
operator|*
literal|8
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ciph_encrypt
parameter_list|(
name|CIPH_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|unsigned
name|char
modifier|*
name|out
parameter_list|)
block|{
name|AES_encrypt
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|md_init
parameter_list|(
name|MD_CTX
modifier|*
name|ctx
parameter_list|)
block|{
name|SHA256_Init
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|md_update
parameter_list|(
name|MD_CTX
modifier|*
name|ctx
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|SHA256_Update
argument_list|(
name|ctx
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|md_result
parameter_list|(
name|MD_CTX
modifier|*
name|ctx
parameter_list|,
name|unsigned
name|char
modifier|*
name|dst
parameter_list|)
block|{
name|SHA256_CTX
name|tmp
decl_stmt|;
name|memcpy
argument_list|(
operator|&
name|tmp
argument_list|,
name|ctx
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|SHA256_Final
argument_list|(
name|dst
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|tmp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * initialize state  */
end_comment

begin_function
specifier|static
name|void
name|init_state
parameter_list|(
name|FState
modifier|*
name|st
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|memset
argument_list|(
name|st
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|st
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_POOLS
condition|;
name|i
operator|++
control|)
name|md_init
argument_list|(
operator|&
name|st
operator|->
name|pool
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|st
operator|->
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Endianess does not matter.  * It just needs to change without repeating.  */
end_comment

begin_function
specifier|static
name|void
name|inc_counter
parameter_list|(
name|FState
modifier|*
name|st
parameter_list|)
block|{
name|uint32_t
modifier|*
name|val
init|=
operator|(
name|uint32_t
operator|*
operator|)
name|st
operator|->
name|counter
decl_stmt|;
if|if
condition|(
operator|++
name|val
index|[
literal|0
index|]
condition|)
return|return;
if|if
condition|(
operator|++
name|val
index|[
literal|1
index|]
condition|)
return|return;
if|if
condition|(
operator|++
name|val
index|[
literal|2
index|]
condition|)
return|return;
operator|++
name|val
index|[
literal|3
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is called 'cipher in counter mode'.  */
end_comment

begin_function
specifier|static
name|void
name|encrypt_counter
parameter_list|(
name|FState
modifier|*
name|st
parameter_list|,
name|unsigned
name|char
modifier|*
name|dst
parameter_list|)
block|{
name|ciph_encrypt
argument_list|(
operator|&
name|st
operator|->
name|ciph
argument_list|,
name|st
operator|->
name|counter
argument_list|,
name|dst
argument_list|)
expr_stmt|;
name|inc_counter
argument_list|(
name|st
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The time between reseed must be at least RESEED_INTERVAL  * microseconds.  */
end_comment

begin_function
specifier|static
name|int
name|enough_time_passed
parameter_list|(
name|FState
modifier|*
name|st
parameter_list|)
block|{
name|int
name|ok
decl_stmt|;
name|struct
name|timeval
name|tv
decl_stmt|;
name|struct
name|timeval
modifier|*
name|last
init|=
operator|&
name|st
operator|->
name|last_reseed_time
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* check how much time has passed */
name|ok
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tv
operator|.
name|tv_sec
operator|>
name|last
operator|->
name|tv_sec
operator|+
literal|1
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|tv
operator|.
name|tv_sec
operator|==
name|last
operator|->
name|tv_sec
operator|+
literal|1
condition|)
block|{
if|if
condition|(
literal|1000000
operator|+
name|tv
operator|.
name|tv_usec
operator|-
name|last
operator|->
name|tv_usec
operator|>=
name|RESEED_INTERVAL
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tv
operator|.
name|tv_usec
operator|-
name|last
operator|->
name|tv_usec
operator|>=
name|RESEED_INTERVAL
condition|)
name|ok
operator|=
literal|1
expr_stmt|;
comment|/* reseed will happen, update last_reseed_time */
if|if
condition|(
name|ok
condition|)
name|memcpy
argument_list|(
name|last
argument_list|,
operator|&
name|tv
argument_list|,
sizeof|sizeof
argument_list|(
name|tv
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|tv
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tv
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ok
return|;
block|}
end_function

begin_comment
comment|/*  * generate new key from all the pools  */
end_comment

begin_function
specifier|static
name|void
name|reseed
parameter_list|(
name|FState
modifier|*
name|st
parameter_list|)
block|{
name|unsigned
name|k
decl_stmt|;
name|unsigned
name|n
decl_stmt|;
name|MD_CTX
name|key_md
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
name|BLOCK
index|]
decl_stmt|;
comment|/* set pool as empty */
name|st
operator|->
name|pool0_bytes
operator|=
literal|0
expr_stmt|;
comment|/*      * Both #0 and #1 reseed would use only pool 0. Just skip #0 then.      */
name|n
operator|=
operator|++
name|st
operator|->
name|reseed_count
expr_stmt|;
comment|/*      * The goal: use k-th pool only 1/(2^k) of the time.      */
name|md_init
argument_list|(
operator|&
name|key_md
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|NUM_POOLS
condition|;
name|k
operator|++
control|)
block|{
name|md_result
argument_list|(
operator|&
name|st
operator|->
name|pool
index|[
name|k
index|]
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|md_update
argument_list|(
operator|&
name|key_md
argument_list|,
name|buf
argument_list|,
name|BLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|&
literal|1
operator|||
operator|!
name|n
condition|)
break|break;
name|n
operator|>>=
literal|1
expr_stmt|;
block|}
comment|/* add old key into mix too */
name|md_update
argument_list|(
operator|&
name|key_md
argument_list|,
name|st
operator|->
name|key
argument_list|,
name|BLOCK
argument_list|)
expr_stmt|;
comment|/* add pid to make output diverse after fork() */
name|md_update
argument_list|(
operator|&
name|key_md
argument_list|,
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
operator|&
name|st
operator|->
name|pid
argument_list|,
sizeof|sizeof
argument_list|(
name|st
operator|->
name|pid
argument_list|)
argument_list|)
expr_stmt|;
comment|/* now we have new key */
name|md_result
argument_list|(
operator|&
name|key_md
argument_list|,
name|st
operator|->
name|key
argument_list|)
expr_stmt|;
comment|/* use new key */
name|ciph_init
argument_list|(
operator|&
name|st
operator|->
name|ciph
argument_list|,
name|st
operator|->
name|key
argument_list|,
name|BLOCK
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|key_md
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|key_md
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|BLOCK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Pick a random pool.	This uses key bytes as random source.  */
end_comment

begin_function
specifier|static
name|unsigned
name|get_rand_pool
parameter_list|(
name|FState
modifier|*
name|st
parameter_list|)
block|{
name|unsigned
name|rnd
decl_stmt|;
comment|/*      * This slightly prefers lower pools - thats OK.      */
name|rnd
operator|=
name|st
operator|->
name|key
index|[
name|st
operator|->
name|rnd_pos
index|]
operator|%
name|NUM_POOLS
expr_stmt|;
name|st
operator|->
name|rnd_pos
operator|++
expr_stmt|;
if|if
condition|(
name|st
operator|->
name|rnd_pos
operator|>=
name|BLOCK
condition|)
name|st
operator|->
name|rnd_pos
operator|=
literal|0
expr_stmt|;
return|return
name|rnd
return|;
block|}
end_function

begin_comment
comment|/*  * update pools  */
end_comment

begin_function
specifier|static
name|void
name|add_entropy
parameter_list|(
name|FState
modifier|*
name|st
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|unsigned
name|len
parameter_list|)
block|{
name|unsigned
name|pos
decl_stmt|;
name|unsigned
name|char
name|hash
index|[
name|BLOCK
index|]
decl_stmt|;
name|MD_CTX
name|md
decl_stmt|;
comment|/* hash given data */
name|md_init
argument_list|(
operator|&
name|md
argument_list|)
expr_stmt|;
name|md_update
argument_list|(
operator|&
name|md
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|md_result
argument_list|(
operator|&
name|md
argument_list|,
name|hash
argument_list|)
expr_stmt|;
comment|/*      * Make sure the pool 0 is initialized, then update randomly.      */
if|if
condition|(
name|st
operator|->
name|reseed_count
operator|==
literal|0
condition|)
name|pos
operator|=
literal|0
expr_stmt|;
else|else
name|pos
operator|=
name|get_rand_pool
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|md_update
argument_list|(
operator|&
name|st
operator|->
name|pool
index|[
name|pos
index|]
argument_list|,
name|hash
argument_list|,
name|BLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|pos
operator|==
literal|0
condition|)
name|st
operator|->
name|pool0_bytes
operator|+=
name|len
expr_stmt|;
name|memset
argument_list|(
name|hash
argument_list|,
literal|0
argument_list|,
name|BLOCK
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|md
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|md
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Just take 2 next blocks as new key  */
end_comment

begin_function
specifier|static
name|void
name|rekey
parameter_list|(
name|FState
modifier|*
name|st
parameter_list|)
block|{
name|encrypt_counter
argument_list|(
name|st
argument_list|,
name|st
operator|->
name|key
argument_list|)
expr_stmt|;
name|encrypt_counter
argument_list|(
name|st
argument_list|,
name|st
operator|->
name|key
operator|+
name|CIPH_BLOCK
argument_list|)
expr_stmt|;
name|ciph_init
argument_list|(
operator|&
name|st
operator|->
name|ciph
argument_list|,
name|st
operator|->
name|key
argument_list|,
name|BLOCK
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Hide public constants. (counter, pools> 0)  *  * This can also be viewed as spreading the startup  * entropy over all of the components.  */
end_comment

begin_function
specifier|static
name|void
name|startup_tricks
parameter_list|(
name|FState
modifier|*
name|st
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
name|BLOCK
index|]
decl_stmt|;
comment|/* Use next block as counter. */
name|encrypt_counter
argument_list|(
name|st
argument_list|,
name|st
operator|->
name|counter
argument_list|)
expr_stmt|;
comment|/* Now shuffle pools, excluding #0 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|NUM_POOLS
condition|;
name|i
operator|++
control|)
block|{
name|encrypt_counter
argument_list|(
name|st
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|encrypt_counter
argument_list|(
name|st
argument_list|,
name|buf
operator|+
name|CIPH_BLOCK
argument_list|)
expr_stmt|;
name|md_update
argument_list|(
operator|&
name|st
operator|->
name|pool
index|[
name|i
index|]
argument_list|,
name|buf
argument_list|,
name|BLOCK
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|BLOCK
argument_list|)
expr_stmt|;
comment|/* Hide the key. */
name|rekey
argument_list|(
name|st
argument_list|)
expr_stmt|;
comment|/* This can be done only once. */
name|st
operator|->
name|tricks_done
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|extract_data
parameter_list|(
name|FState
modifier|*
name|st
parameter_list|,
name|unsigned
name|count
parameter_list|,
name|unsigned
name|char
modifier|*
name|dst
parameter_list|)
block|{
name|unsigned
name|n
decl_stmt|;
name|unsigned
name|block_nr
init|=
literal|0
decl_stmt|;
name|pid_t
name|pid
init|=
name|getpid
argument_list|()
decl_stmt|;
comment|/* Should we reseed? */
if|if
condition|(
name|st
operator|->
name|pool0_bytes
operator|>=
name|POOL0_FILL
operator|||
name|st
operator|->
name|reseed_count
operator|==
literal|0
condition|)
if|if
condition|(
name|enough_time_passed
argument_list|(
name|st
argument_list|)
condition|)
name|reseed
argument_list|(
name|st
argument_list|)
expr_stmt|;
comment|/* Do some randomization on first call */
if|if
condition|(
operator|!
name|st
operator|->
name|tricks_done
condition|)
name|startup_tricks
argument_list|(
name|st
argument_list|)
expr_stmt|;
comment|/* If we forked, force a reseed again */
if|if
condition|(
name|pid
operator|!=
name|st
operator|->
name|pid
condition|)
block|{
name|st
operator|->
name|pid
operator|=
name|pid
expr_stmt|;
name|reseed
argument_list|(
name|st
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|count
operator|>
literal|0
condition|)
block|{
comment|/* produce bytes */
name|encrypt_counter
argument_list|(
name|st
argument_list|,
name|st
operator|->
name|result
argument_list|)
expr_stmt|;
comment|/* copy result */
if|if
condition|(
name|count
operator|>
name|CIPH_BLOCK
condition|)
name|n
operator|=
name|CIPH_BLOCK
expr_stmt|;
else|else
name|n
operator|=
name|count
expr_stmt|;
name|memcpy
argument_list|(
name|dst
argument_list|,
name|st
operator|->
name|result
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|dst
operator|+=
name|n
expr_stmt|;
name|count
operator|-=
name|n
expr_stmt|;
comment|/* must not give out too many bytes with one key */
name|block_nr
operator|++
expr_stmt|;
if|if
condition|(
name|block_nr
operator|>
operator|(
name|RESEED_BYTES
operator|/
name|CIPH_BLOCK
operator|)
condition|)
block|{
name|rekey
argument_list|(
name|st
argument_list|)
expr_stmt|;
name|block_nr
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* Set new key for next request. */
name|rekey
argument_list|(
name|st
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * public interface  */
end_comment

begin_decl_stmt
specifier|static
name|FState
name|main_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|init_done
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|have_entropy
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FORTUNA_RESEED_BYTE
value|10000
end_define

begin_decl_stmt
specifier|static
name|unsigned
name|resend_bytes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This mutex protects all of the above static elements from concurrent  * access by multiple threads  */
end_comment

begin_decl_stmt
specifier|static
name|HEIMDAL_MUTEX
name|fortuna_mutex
init|=
name|HEIMDAL_MUTEX_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Try our best to do an inital seed  */
end_comment

begin_define
define|#
directive|define
name|INIT_BYTES
value|128
end_define

begin_comment
comment|/*  * fortuna_mutex must be held across calls to this function  */
end_comment

begin_function
specifier|static
name|int
name|fortuna_reseed
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|entropy_p
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|init_done
condition|)
name|abort
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_RAND_UNIX_METHOD
block|{
name|unsigned
name|char
name|buf
index|[
name|INIT_BYTES
index|]
decl_stmt|;
if|if
condition|(
call|(
modifier|*
name|hc_rand_unix_method
operator|.
name|bytes
call|)
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
block|{
name|add_entropy
argument_list|(
operator|&
name|main_state
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|entropy_p
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_ARC4RANDOM
block|{
name|uint32_t
name|buf
index|[
name|INIT_BYTES
operator|/
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
name|buf
index|[
name|i
index|]
operator|=
name|arc4random
argument_list|()
expr_stmt|;
name|add_entropy
argument_list|(
operator|&
name|main_state
argument_list|,
operator|(
name|void
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|entropy_p
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_RAND_EGD_METHOD
comment|/*      * Only to get egd entropy if /dev/random or arc4rand failed since      * it can be horribly slow to generate new bits.      */
if|if
condition|(
operator|!
name|entropy_p
condition|)
block|{
name|unsigned
name|char
name|buf
index|[
name|INIT_BYTES
index|]
decl_stmt|;
if|if
condition|(
call|(
modifier|*
name|hc_rand_egd_method
operator|.
name|bytes
call|)
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
block|{
name|add_entropy
argument_list|(
operator|&
name|main_state
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|entropy_p
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/*      * Fall back to gattering data from timer and secret files, this      * is really the last resort.      */
if|if
condition|(
operator|!
name|entropy_p
condition|)
block|{
comment|/* to save stackspace */
union|union
block|{
name|unsigned
name|char
name|buf
index|[
name|INIT_BYTES
index|]
decl_stmt|;
name|unsigned
name|char
name|shad
index|[
literal|1001
index|]
decl_stmt|;
block|}
name|u
union|;
name|int
name|fd
decl_stmt|;
comment|/* add timer info */
if|if
condition|(
call|(
modifier|*
name|hc_rand_timer_method
operator|.
name|bytes
call|)
argument_list|(
name|u
operator|.
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|u
operator|.
name|buf
argument_list|)
argument_list|)
operator|==
literal|1
condition|)
name|add_entropy
argument_list|(
operator|&
name|main_state
argument_list|,
name|u
operator|.
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|u
operator|.
name|buf
argument_list|)
argument_list|)
expr_stmt|;
comment|/* add /etc/shadow */
name|fd
operator|=
name|open
argument_list|(
literal|"/etc/shadow"
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
name|ssize_t
name|n
decl_stmt|;
name|rk_cloexec
argument_list|(
name|fd
argument_list|)
expr_stmt|;
comment|/* add_entropy will hash the buf */
while|while
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|fd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|u
operator|.
name|shad
argument_list|,
sizeof|sizeof
argument_list|(
name|u
operator|.
name|shad
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|add_entropy
argument_list|(
operator|&
name|main_state
argument_list|,
name|u
operator|.
name|shad
argument_list|,
sizeof|sizeof
argument_list|(
name|u
operator|.
name|shad
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|u
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|u
argument_list|)
argument_list|)
expr_stmt|;
name|entropy_p
operator|=
literal|1
expr_stmt|;
comment|/* sure about this ? */
block|}
block|{
name|pid_t
name|pid
init|=
name|getpid
argument_list|()
decl_stmt|;
name|add_entropy
argument_list|(
operator|&
name|main_state
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|pid
argument_list|,
sizeof|sizeof
argument_list|(
name|pid
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|{
name|struct
name|timeval
name|tv
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|add_entropy
argument_list|(
operator|&
name|main_state
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|tv
argument_list|,
sizeof|sizeof
argument_list|(
name|tv
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_GETUID
block|{
name|uid_t
name|u
init|=
name|getuid
argument_list|()
decl_stmt|;
name|add_entropy
argument_list|(
operator|&
name|main_state
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|u
argument_list|,
sizeof|sizeof
argument_list|(
name|u
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|entropy_p
return|;
block|}
end_function

begin_comment
comment|/*  * fortuna_mutex must be held by callers of this function  */
end_comment

begin_function
specifier|static
name|int
name|fortuna_init
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|init_done
condition|)
block|{
name|init_state
argument_list|(
operator|&
name|main_state
argument_list|)
expr_stmt|;
name|init_done
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|have_entropy
condition|)
name|have_entropy
operator|=
name|fortuna_reseed
argument_list|()
expr_stmt|;
return|return
operator|(
name|init_done
operator|&&
name|have_entropy
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fortuna_seed
parameter_list|(
specifier|const
name|void
modifier|*
name|indata
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|HEIMDAL_MUTEX_lock
argument_list|(
operator|&
name|fortuna_mutex
argument_list|)
expr_stmt|;
name|fortuna_init
argument_list|()
expr_stmt|;
name|add_entropy
argument_list|(
operator|&
name|main_state
argument_list|,
name|indata
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|>=
name|INIT_BYTES
condition|)
name|have_entropy
operator|=
literal|1
expr_stmt|;
name|HEIMDAL_MUTEX_unlock
argument_list|(
operator|&
name|fortuna_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fortuna_bytes
parameter_list|(
name|unsigned
name|char
modifier|*
name|outdata
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|HEIMDAL_MUTEX_lock
argument_list|(
operator|&
name|fortuna_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fortuna_init
argument_list|()
condition|)
goto|goto
name|out
goto|;
name|resend_bytes
operator|+=
name|size
expr_stmt|;
if|if
condition|(
name|resend_bytes
operator|>
name|FORTUNA_RESEED_BYTE
operator|||
name|resend_bytes
operator|<
name|size
condition|)
block|{
name|resend_bytes
operator|=
literal|0
expr_stmt|;
name|fortuna_reseed
argument_list|()
expr_stmt|;
block|}
name|extract_data
argument_list|(
operator|&
name|main_state
argument_list|,
name|size
argument_list|,
name|outdata
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
name|out
label|:
name|HEIMDAL_MUTEX_unlock
argument_list|(
operator|&
name|fortuna_mutex
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fortuna_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
name|HEIMDAL_MUTEX_lock
argument_list|(
operator|&
name|fortuna_mutex
argument_list|)
expr_stmt|;
name|init_done
operator|=
literal|0
expr_stmt|;
name|have_entropy
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|main_state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|main_state
argument_list|)
argument_list|)
expr_stmt|;
name|HEIMDAL_MUTEX_unlock
argument_list|(
operator|&
name|fortuna_mutex
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fortuna_add
parameter_list|(
specifier|const
name|void
modifier|*
name|indata
parameter_list|,
name|int
name|size
parameter_list|,
name|double
name|entropi
parameter_list|)
block|{
name|fortuna_seed
argument_list|(
name|indata
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fortuna_pseudorand
parameter_list|(
name|unsigned
name|char
modifier|*
name|outdata
parameter_list|,
name|int
name|size
parameter_list|)
block|{
return|return
name|fortuna_bytes
argument_list|(
name|outdata
argument_list|,
name|size
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fortuna_status
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
name|HEIMDAL_MUTEX_lock
argument_list|(
operator|&
name|fortuna_mutex
argument_list|)
expr_stmt|;
name|result
operator|=
name|fortuna_init
argument_list|()
expr_stmt|;
name|HEIMDAL_MUTEX_unlock
argument_list|(
operator|&
name|fortuna_mutex
argument_list|)
expr_stmt|;
return|return
name|result
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|const
name|RAND_METHOD
name|hc_rand_fortuna_method
init|=
block|{
name|fortuna_seed
block|,
name|fortuna_bytes
block|,
name|fortuna_cleanup
block|,
name|fortuna_add
block|,
name|fortuna_pseudorand
block|,
name|fortuna_status
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|RAND_METHOD
modifier|*
name|RAND_fortuna_method
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|&
name|hc_rand_fortuna_method
return|;
block|}
end_function

end_unit

