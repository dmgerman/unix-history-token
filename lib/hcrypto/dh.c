begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2006 - 2007 Kungliga Tekniska HÃ¶gskolan  * (Royal Institute of Technology, Stockholm, Sweden).  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * 3. Neither the name of the Institute nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CONFIG_H
end_ifdef

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<krb5-types.h>
end_include

begin_include
include|#
directive|include
file|<rfc2459_asn1.h>
end_include

begin_include
include|#
directive|include
file|<dh.h>
end_include

begin_include
include|#
directive|include
file|<roken.h>
end_include

begin_comment
comment|/**  * @page page_dh DH - Diffie-Hellman key exchange  *  * Diffie-Hellman key exchange is a protocol that allows two parties  * to establish a shared secret key.  *  * Include and example how to use DH_new() and friends here.  *  * See the library functions here: @ref hcrypto_dh  */
end_comment

begin_comment
comment|/**  * Create a new DH object using DH_new_method(NULL), see DH_new_method().  *  * @return a newly allocated DH object.  *  * @ingroup hcrypto_dh  */
end_comment

begin_function
name|DH
modifier|*
name|DH_new
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|DH_new_method
argument_list|(
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Create a new DH object from the given engine, if the NULL is used,  * the default engine is used. Free the DH object with DH_free().  *  * @param engine The engine to use to allocate the DH object.  *  * @return a newly allocated DH object.  *  * @ingroup hcrypto_dh  */
end_comment

begin_function
name|DH
modifier|*
name|DH_new_method
parameter_list|(
name|ENGINE
modifier|*
name|engine
parameter_list|)
block|{
name|DH
modifier|*
name|dh
decl_stmt|;
name|dh
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dh
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dh
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|dh
operator|->
name|references
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|engine
condition|)
block|{
name|ENGINE_up_ref
argument_list|(
name|engine
argument_list|)
expr_stmt|;
name|dh
operator|->
name|engine
operator|=
name|engine
expr_stmt|;
block|}
else|else
block|{
name|dh
operator|->
name|engine
operator|=
name|ENGINE_get_default_DH
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dh
operator|->
name|engine
condition|)
block|{
name|dh
operator|->
name|meth
operator|=
name|ENGINE_get_DH
argument_list|(
name|dh
operator|->
name|engine
argument_list|)
expr_stmt|;
if|if
condition|(
name|dh
operator|->
name|meth
operator|==
name|NULL
condition|)
block|{
name|ENGINE_finish
argument_list|(
name|engine
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dh
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
if|if
condition|(
name|dh
operator|->
name|meth
operator|==
name|NULL
condition|)
name|dh
operator|->
name|meth
operator|=
name|DH_get_default_method
argument_list|()
expr_stmt|;
call|(
modifier|*
name|dh
operator|->
name|meth
operator|->
name|init
call|)
argument_list|(
name|dh
argument_list|)
expr_stmt|;
return|return
name|dh
return|;
block|}
end_function

begin_comment
comment|/**  * Free a DH object and release related resources, like ENGINE, that  * the object was using.  *  * @param dh object to be freed.  *  * @ingroup hcrypto_dh  */
end_comment

begin_function
name|void
name|DH_free
parameter_list|(
name|DH
modifier|*
name|dh
parameter_list|)
block|{
if|if
condition|(
name|dh
operator|->
name|references
operator|<=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
operator|--
name|dh
operator|->
name|references
operator|>
literal|0
condition|)
return|return;
call|(
modifier|*
name|dh
operator|->
name|meth
operator|->
name|finish
call|)
argument_list|(
name|dh
argument_list|)
expr_stmt|;
if|if
condition|(
name|dh
operator|->
name|engine
condition|)
name|ENGINE_finish
argument_list|(
name|dh
operator|->
name|engine
argument_list|)
expr_stmt|;
define|#
directive|define
name|free_if
parameter_list|(
name|f
parameter_list|)
value|if (f) { BN_free(f); }
name|free_if
argument_list|(
name|dh
operator|->
name|p
argument_list|)
expr_stmt|;
name|free_if
argument_list|(
name|dh
operator|->
name|g
argument_list|)
expr_stmt|;
name|free_if
argument_list|(
name|dh
operator|->
name|pub_key
argument_list|)
expr_stmt|;
name|free_if
argument_list|(
name|dh
operator|->
name|priv_key
argument_list|)
expr_stmt|;
name|free_if
argument_list|(
name|dh
operator|->
name|q
argument_list|)
expr_stmt|;
name|free_if
argument_list|(
name|dh
operator|->
name|j
argument_list|)
expr_stmt|;
name|free_if
argument_list|(
name|dh
operator|->
name|counter
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|free_if
name|memset
argument_list|(
name|dh
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dh
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|dh
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Add a reference to the DH object. The object should be free with  * DH_free() to drop the reference.  *  * @param dh the object to increase the reference count too.  *  * @return the updated reference count, can't safely be used except  * for debug printing.  *  * @ingroup hcrypto_dh  */
end_comment

begin_function
name|int
name|DH_up_ref
parameter_list|(
name|DH
modifier|*
name|dh
parameter_list|)
block|{
return|return
operator|++
name|dh
operator|->
name|references
return|;
block|}
end_function

begin_comment
comment|/**  * The maximum output size of the DH_compute_key() function.  *  * @param dh The DH object to get the size from.  *  * @return the maximum size in bytes of the out data.  *  * @ingroup hcrypto_dh  */
end_comment

begin_function
name|int
name|DH_size
parameter_list|(
specifier|const
name|DH
modifier|*
name|dh
parameter_list|)
block|{
return|return
name|BN_num_bytes
argument_list|(
name|dh
operator|->
name|p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Set the data index idx in the DH object to data.  *  * @param dh DH object.  * @param idx index to set the data for.  * @param data data to store for the index idx.  *  * @return 1 on success.  *  * @ingroup hcrypto_dh  */
end_comment

begin_function
name|int
name|DH_set_ex_data
parameter_list|(
name|DH
modifier|*
name|dh
parameter_list|,
name|int
name|idx
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|dh
operator|->
name|ex_data
operator|.
name|sk
operator|=
name|data
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Get the data for index idx in the DH object.  *  * @param dh DH object.  * @param idx index to get the data for.  *  * @return the object store in index idx  *  * @ingroup hcrypto_dh  */
end_comment

begin_function
name|void
modifier|*
name|DH_get_ex_data
parameter_list|(
name|DH
modifier|*
name|dh
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
return|return
name|dh
operator|->
name|ex_data
operator|.
name|sk
return|;
block|}
end_function

begin_comment
comment|/**  * Generate DH parameters for the DH object give parameters.  *  * @param dh The DH object to generate parameters for.  * @param prime_len length of the prime  * @param generator generator, g  * @param cb Callback parameters to show progress, can be NULL.  *  * @return the maximum size in bytes of the out data.  *  * @ingroup hcrypto_dh  */
end_comment

begin_function
name|int
name|DH_generate_parameters_ex
parameter_list|(
name|DH
modifier|*
name|dh
parameter_list|,
name|int
name|prime_len
parameter_list|,
name|int
name|generator
parameter_list|,
name|BN_GENCB
modifier|*
name|cb
parameter_list|)
block|{
if|if
condition|(
name|dh
operator|->
name|meth
operator|->
name|generate_params
condition|)
return|return
name|dh
operator|->
name|meth
operator|->
name|generate_params
argument_list|(
name|dh
argument_list|,
name|prime_len
argument_list|,
name|generator
argument_list|,
name|cb
argument_list|)
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Check that the public key is sane.  *  * @param dh the local peer DH parameters.  * @param pub_key the remote peer public key parameters.  * @param codes return that the failures of the pub_key are.  *  * @return 1 on success, 0 on failure and *codes is set the the  * combined fail check for the public key  *  * @ingroup hcrypto_dh  */
end_comment

begin_function
name|int
name|DH_check_pubkey
parameter_list|(
specifier|const
name|DH
modifier|*
name|dh
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|pub_key
parameter_list|,
name|int
modifier|*
name|codes
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|bn
init|=
name|NULL
decl_stmt|,
modifier|*
name|sum
init|=
name|NULL
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
operator|*
name|codes
operator|=
literal|0
expr_stmt|;
comment|/**      * Checks that the function performs are:      * - pub_key is not negative      */
if|if
condition|(
name|BN_is_negative
argument_list|(
name|pub_key
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/**      * - pub_key> 1    and    pub_key< p - 1,      *    to avoid small subgroups attack.      */
name|bn
operator|=
name|BN_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|bn
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|BN_set_word
argument_list|(
name|bn
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|BN_cmp
argument_list|(
name|bn
argument_list|,
name|pub_key
argument_list|)
operator|>=
literal|0
condition|)
operator|*
name|codes
operator||=
name|DH_CHECK_PUBKEY_TOO_SMALL
expr_stmt|;
name|sum
operator|=
name|BN_new
argument_list|()
expr_stmt|;
if|if
condition|(
name|sum
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|BN_uadd
argument_list|(
name|sum
argument_list|,
name|pub_key
argument_list|,
name|bn
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_cmp
argument_list|(
name|sum
argument_list|,
name|dh
operator|->
name|p
argument_list|)
operator|>=
literal|0
condition|)
operator|*
name|codes
operator||=
name|DH_CHECK_PUBKEY_TOO_LARGE
expr_stmt|;
comment|/**      * - if g == 2, pub_key have more then one bit set,      *   if bits set is 1, log_2(pub_key) is trival      */
if|if
condition|(
operator|!
name|BN_set_word
argument_list|(
name|bn
argument_list|,
literal|2
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|BN_cmp
argument_list|(
name|bn
argument_list|,
name|dh
operator|->
name|g
argument_list|)
operator|==
literal|0
condition|)
block|{
name|unsigned
name|i
decl_stmt|,
name|n
init|=
name|BN_num_bits
argument_list|(
name|pub_key
argument_list|)
decl_stmt|;
name|unsigned
name|bits
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|n
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|BN_is_bit_set
argument_list|(
name|pub_key
argument_list|,
name|i
argument_list|)
condition|)
name|bits
operator|++
expr_stmt|;
if|if
condition|(
name|bits
operator|<
literal|2
condition|)
block|{
operator|*
name|codes
operator||=
name|DH_CHECK_PUBKEY_TOO_SMALL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|ret
operator|=
literal|1
expr_stmt|;
name|out
label|:
if|if
condition|(
name|bn
condition|)
name|BN_free
argument_list|(
name|bn
argument_list|)
expr_stmt|;
if|if
condition|(
name|sum
condition|)
name|BN_free
argument_list|(
name|sum
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/**  * Generate a new DH private-public key pair. The dh parameter must be  * allocted first with DH_new(). dh->p and dp->g must be set.  *  * @param dh dh parameter.  *  * @return 1 on success.  *  * @ingroup hcrypto_dh  */
end_comment

begin_function
name|int
name|DH_generate_key
parameter_list|(
name|DH
modifier|*
name|dh
parameter_list|)
block|{
return|return
name|dh
operator|->
name|meth
operator|->
name|generate_key
argument_list|(
name|dh
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Complute the shared secret key.  *  * @param shared_key the resulting shared key, need to be at least  * DH_size() large.  * @param peer_pub_key the peer's public key.  * @param dh the dh key pair.  *  * @return 1 on success.  *  * @ingroup hcrypto_dh  */
end_comment

begin_function
name|int
name|DH_compute_key
parameter_list|(
name|unsigned
name|char
modifier|*
name|shared_key
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|peer_pub_key
parameter_list|,
name|DH
modifier|*
name|dh
parameter_list|)
block|{
name|int
name|codes
decl_stmt|;
comment|/**      * Checks that the pubkey passed in is valid using      * DH_check_pubkey().      */
if|if
condition|(
operator|!
name|DH_check_pubkey
argument_list|(
name|dh
argument_list|,
name|peer_pub_key
argument_list|,
operator|&
name|codes
argument_list|)
operator|||
name|codes
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|dh
operator|->
name|meth
operator|->
name|compute_key
argument_list|(
name|shared_key
argument_list|,
name|peer_pub_key
argument_list|,
name|dh
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Set a new method for the DH keypair.  *  * @param dh dh parameter.  * @param method the new method for the DH parameter.  *  * @return 1 on success.  *  * @ingroup hcrypto_dh  */
end_comment

begin_function
name|int
name|DH_set_method
parameter_list|(
name|DH
modifier|*
name|dh
parameter_list|,
specifier|const
name|DH_METHOD
modifier|*
name|method
parameter_list|)
block|{
call|(
modifier|*
name|dh
operator|->
name|meth
operator|->
name|finish
call|)
argument_list|(
name|dh
argument_list|)
expr_stmt|;
if|if
condition|(
name|dh
operator|->
name|engine
condition|)
block|{
name|ENGINE_finish
argument_list|(
name|dh
operator|->
name|engine
argument_list|)
expr_stmt|;
name|dh
operator|->
name|engine
operator|=
name|NULL
expr_stmt|;
block|}
name|dh
operator|->
name|meth
operator|=
name|method
expr_stmt|;
call|(
modifier|*
name|dh
operator|->
name|meth
operator|->
name|init
call|)
argument_list|(
name|dh
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|int
name|dh_null_generate_key
parameter_list|(
name|DH
modifier|*
name|dh
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dh_null_compute_key
parameter_list|(
name|unsigned
name|char
modifier|*
name|shared
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|pub
parameter_list|,
name|DH
modifier|*
name|dh
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dh_null_init
parameter_list|(
name|DH
modifier|*
name|dh
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dh_null_finish
parameter_list|(
name|DH
modifier|*
name|dh
parameter_list|)
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dh_null_generate_params
parameter_list|(
name|DH
modifier|*
name|dh
parameter_list|,
name|int
name|prime_num
parameter_list|,
name|int
name|len
parameter_list|,
name|BN_GENCB
modifier|*
name|cb
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|DH_METHOD
name|dh_null_method
init|=
block|{
literal|"hcrypto null DH"
block|,
name|dh_null_generate_key
block|,
name|dh_null_compute_key
block|,
name|NULL
block|,
name|dh_null_init
block|,
name|dh_null_finish
block|,
literal|0
block|,
name|NULL
block|,
name|dh_null_generate_params
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
specifier|const
name|DH_METHOD
name|_hc_dh_ltm_method
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|DH_METHOD
modifier|*
name|dh_default_method
init|=
operator|&
name|_hc_dh_ltm_method
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * Return the dummy DH implementation.  *  * @return pointer to a DH_METHOD.  *  * @ingroup hcrypto_dh  */
end_comment

begin_function
specifier|const
name|DH_METHOD
modifier|*
name|DH_null_method
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|&
name|dh_null_method
return|;
block|}
end_function

begin_comment
comment|/**  * Set the default DH implementation.  *  * @param meth pointer to a DH_METHOD.  *  * @ingroup hcrypto_dh  */
end_comment

begin_function
name|void
name|DH_set_default_method
parameter_list|(
specifier|const
name|DH_METHOD
modifier|*
name|meth
parameter_list|)
block|{
name|dh_default_method
operator|=
name|meth
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Return the default DH implementation.  *  * @return pointer to a DH_METHOD.  *  * @ingroup hcrypto_dh  */
end_comment

begin_function
specifier|const
name|DH_METHOD
modifier|*
name|DH_get_default_method
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|dh_default_method
return|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|int
name|bn2heim_int
parameter_list|(
name|BIGNUM
modifier|*
name|bn
parameter_list|,
name|heim_integer
modifier|*
name|integer
parameter_list|)
block|{
name|integer
operator|->
name|length
operator|=
name|BN_num_bytes
argument_list|(
name|bn
argument_list|)
expr_stmt|;
name|integer
operator|->
name|data
operator|=
name|malloc
argument_list|(
name|integer
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|integer
operator|->
name|data
operator|==
name|NULL
condition|)
block|{
name|integer
operator|->
name|length
operator|=
literal|0
expr_stmt|;
return|return
name|ENOMEM
return|;
block|}
name|BN_bn2bin
argument_list|(
name|bn
argument_list|,
name|integer
operator|->
name|data
argument_list|)
expr_stmt|;
name|integer
operator|->
name|negative
operator|=
name|BN_is_negative
argument_list|(
name|bn
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  *  */
end_comment

begin_function
name|int
name|i2d_DHparams
parameter_list|(
name|DH
modifier|*
name|dh
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|pp
parameter_list|)
block|{
name|DHParameter
name|data
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|memset
argument_list|(
operator|&
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bn2heim_int
argument_list|(
name|dh
operator|->
name|p
argument_list|,
operator|&
name|data
operator|.
name|prime
argument_list|)
operator|||
name|bn2heim_int
argument_list|(
name|dh
operator|->
name|g
argument_list|,
operator|&
name|data
operator|.
name|base
argument_list|)
condition|)
block|{
name|free_DHParameter
argument_list|(
operator|&
name|data
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|pp
operator|==
name|NULL
condition|)
block|{
name|size
operator|=
name|length_DHParameter
argument_list|(
operator|&
name|data
argument_list|)
expr_stmt|;
name|free_DHParameter
argument_list|(
operator|&
name|data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|void
modifier|*
name|p
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|ASN1_MALLOC_ENCODE
argument_list|(
name|DHParameter
argument_list|,
name|p
argument_list|,
name|len
argument_list|,
operator|&
name|data
argument_list|,
operator|&
name|size
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|free_DHParameter
argument_list|(
operator|&
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|len
operator|!=
name|size
condition|)
block|{
name|abort
argument_list|()
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|memcpy
argument_list|(
operator|*
name|pp
argument_list|,
name|p
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|pp
operator|+=
name|size
expr_stmt|;
block|}
return|return
name|size
return|;
block|}
end_function

end_unit

