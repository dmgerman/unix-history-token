begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2005 Kungliga Tekniska HÃ¶gskolan  * (Royal Institute of Technology, Stockholm, Sweden).  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  *  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * 3. Neither the name of the Institute nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/**  * @page page_des DES - Data Encryption Standard crypto interface  *  * See the library functions here: @ref hcrypto_des  *  * DES was created by IBM, modififed by NSA and then adopted by NBS  * (now NIST) and published ad FIPS PUB 46 (updated by FIPS 46-1).  *  * Since the 19th May 2005 DES was withdrawn by NIST and should no  * longer be used. See @ref page_evp for replacement encryption  * algorithms and interfaces.  *  * Read more the iteresting history of DES on Wikipedia  * http://www.wikipedia.org/wiki/Data_Encryption_Standard .  *  * @section des_keygen DES key generation  *  * To generate a DES key safely you have to use the code-snippet  * below. This is because the DES_random_key() can fail with an  * abort() in case of and failure to start the random generator.  *  * There is a replacement function DES_new_random_key(), however that  * function does not exists in OpenSSL.  *  * @code  * DES_cblock key;  * do {  *     if (RAND_rand(&key, sizeof(key)) != 1)  *          goto failure;  *     DES_set_odd_parity(key);  * } while (DES_is_weak_key(&key));  * @endcode  *  * @section des_impl DES implementation history  *  * There was no complete BSD licensed, fast, GPL compatible  * implementation of DES, so Love wrote the part that was missing,  * fast key schedule setup and adapted the interface to the orignal  * libdes.  *  * The document that got me started for real was "Efficient  * Implementation of the Data Encryption Standard" by Dag Arne Osvik.  * I never got to the PC1 transformation was working, instead I used  * table-lookup was used for all key schedule setup. The document was  * very useful since it de-mystified other implementations for me.  *  * The core DES function (SBOX + P transformation) is from Richard  * Outerbridge public domain DES implementation. My sanity is saved  * thanks to his work. Thank you Richard.  */
end_comment

begin_include
include|#
directive|include
file|<config.h>
end_include

begin_define
define|#
directive|define
name|HC_DEPRECATED
end_define

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<krb5-types.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<roken.h>
end_include

begin_include
include|#
directive|include
file|"des.h"
end_include

begin_include
include|#
directive|include
file|"ui.h"
end_include

begin_function_decl
specifier|static
name|void
name|desx
parameter_list|(
name|uint32_t
index|[
literal|2
index|]
parameter_list|,
name|DES_key_schedule
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|IP
parameter_list|(
name|uint32_t
index|[
literal|2
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|FP
parameter_list|(
name|uint32_t
index|[
literal|2
index|]
parameter_list|)
function_decl|;
end_function_decl

begin_include
include|#
directive|include
file|"des-tables.h"
end_include

begin_define
define|#
directive|define
name|ROTATE_LEFT28
parameter_list|(
name|x
parameter_list|,
name|one
parameter_list|)
define|\
value|if (one) {						\ 	x = ( ((x)<<(1))& 0xffffffe) | ((x)>> 27);	\     } else {						\ 	x = ( ((x)<<(2))& 0xffffffc) | ((x)>> 26);	\     }
end_define

begin_comment
comment|/**  * Set the parity of the key block, used to generate a des key from a  * random key. See @ref des_keygen.  *  * @param key key to fixup the parity for.  * @ingroup hcrypto_des  */
end_comment

begin_function
name|void
name|DES_set_odd_parity
parameter_list|(
name|DES_cblock
modifier|*
name|key
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DES_CBLOCK_LEN
condition|;
name|i
operator|++
control|)
operator|(
operator|*
name|key
operator|)
index|[
name|i
index|]
operator|=
name|odd_parity
index|[
operator|(
operator|*
name|key
operator|)
index|[
name|i
index|]
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Check if the key have correct parity.  *  * @param key key to check the parity.  * @return 1 on success, 0 on failure.  * @ingroup hcrypto_des  */
end_comment

begin_function
name|int
name|HC_DEPRECATED
name|DES_check_key_parity
parameter_list|(
name|DES_cblock
modifier|*
name|key
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|DES_CBLOCK_LEN
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
operator|*
name|key
operator|)
index|[
name|i
index|]
operator|!=
name|odd_parity
index|[
operator|(
operator|*
name|key
operator|)
index|[
name|i
index|]
index|]
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_comment
comment|/* FIPS 74 */
end_comment

begin_decl_stmt
specifier|static
name|DES_cblock
name|weak_keys
index|[]
init|=
block|{
block|{
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|,
literal|0x01
block|}
block|,
comment|/* weak keys */
block|{
literal|0xFE
block|,
literal|0xFE
block|,
literal|0xFE
block|,
literal|0xFE
block|,
literal|0xFE
block|,
literal|0xFE
block|,
literal|0xFE
block|,
literal|0xFE
block|}
block|,
block|{
literal|0x1F
block|,
literal|0x1F
block|,
literal|0x1F
block|,
literal|0x1F
block|,
literal|0x0E
block|,
literal|0x0E
block|,
literal|0x0E
block|,
literal|0x0E
block|}
block|,
block|{
literal|0xE0
block|,
literal|0xE0
block|,
literal|0xE0
block|,
literal|0xE0
block|,
literal|0xF1
block|,
literal|0xF1
block|,
literal|0xF1
block|,
literal|0xF1
block|}
block|,
block|{
literal|0x01
block|,
literal|0xFE
block|,
literal|0x01
block|,
literal|0xFE
block|,
literal|0x01
block|,
literal|0xFE
block|,
literal|0x01
block|,
literal|0xFE
block|}
block|,
comment|/* semi-weak keys */
block|{
literal|0xFE
block|,
literal|0x01
block|,
literal|0xFE
block|,
literal|0x01
block|,
literal|0xFE
block|,
literal|0x01
block|,
literal|0xFE
block|,
literal|0x01
block|}
block|,
block|{
literal|0x1F
block|,
literal|0xE0
block|,
literal|0x1F
block|,
literal|0xE0
block|,
literal|0x0E
block|,
literal|0xF1
block|,
literal|0x0E
block|,
literal|0xF1
block|}
block|,
block|{
literal|0xE0
block|,
literal|0x1F
block|,
literal|0xE0
block|,
literal|0x1F
block|,
literal|0xF1
block|,
literal|0x0E
block|,
literal|0xF1
block|,
literal|0x0E
block|}
block|,
block|{
literal|0x01
block|,
literal|0xE0
block|,
literal|0x01
block|,
literal|0xE0
block|,
literal|0x01
block|,
literal|0xF1
block|,
literal|0x01
block|,
literal|0xF1
block|}
block|,
block|{
literal|0xE0
block|,
literal|0x01
block|,
literal|0xE0
block|,
literal|0x01
block|,
literal|0xF1
block|,
literal|0x01
block|,
literal|0xF1
block|,
literal|0x01
block|}
block|,
block|{
literal|0x1F
block|,
literal|0xFE
block|,
literal|0x1F
block|,
literal|0xFE
block|,
literal|0x0E
block|,
literal|0xFE
block|,
literal|0x0E
block|,
literal|0xFE
block|}
block|,
block|{
literal|0xFE
block|,
literal|0x1F
block|,
literal|0xFE
block|,
literal|0x1F
block|,
literal|0xFE
block|,
literal|0x0E
block|,
literal|0xFE
block|,
literal|0x0E
block|}
block|,
block|{
literal|0x01
block|,
literal|0x1F
block|,
literal|0x01
block|,
literal|0x1F
block|,
literal|0x01
block|,
literal|0x0E
block|,
literal|0x01
block|,
literal|0x0E
block|}
block|,
block|{
literal|0x1F
block|,
literal|0x01
block|,
literal|0x1F
block|,
literal|0x01
block|,
literal|0x0E
block|,
literal|0x01
block|,
literal|0x0E
block|,
literal|0x01
block|}
block|,
block|{
literal|0xE0
block|,
literal|0xFE
block|,
literal|0xE0
block|,
literal|0xFE
block|,
literal|0xF1
block|,
literal|0xFE
block|,
literal|0xF1
block|,
literal|0xFE
block|}
block|,
block|{
literal|0xFE
block|,
literal|0xE0
block|,
literal|0xFE
block|,
literal|0xE0
block|,
literal|0xFE
block|,
literal|0xF1
block|,
literal|0xFE
block|,
literal|0xF1
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * Checks if the key is any of the weaks keys that makes DES attacks  * trival.  *  * @param key key to check.  *  * @return 1 if the key is weak, 0 otherwise.  * @ingroup hcrypto_des  */
end_comment

begin_function
name|int
name|DES_is_weak_key
parameter_list|(
name|DES_cblock
modifier|*
name|key
parameter_list|)
block|{
name|int
name|weak
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|weak_keys
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|weak_keys
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
name|weak
operator|^=
operator|(
name|ct_memcmp
argument_list|(
name|weak_keys
index|[
name|i
index|]
argument_list|,
name|key
argument_list|,
name|DES_CBLOCK_LEN
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
return|return
operator|!
operator|!
name|weak
return|;
block|}
end_function

begin_comment
comment|/**  * Setup a des key schedule from a key. Deprecated function, use  * DES_set_key_unchecked() or DES_set_key_checked() instead.  *  * @param key a key to initialize the key schedule with.  * @param ks a key schedule to initialize.  *  * @return 0 on success  * @ingroup hcrypto_des  */
end_comment

begin_function
name|int
name|HC_DEPRECATED
name|DES_set_key
parameter_list|(
name|DES_cblock
modifier|*
name|key
parameter_list|,
name|DES_key_schedule
modifier|*
name|ks
parameter_list|)
block|{
return|return
name|DES_set_key_checked
argument_list|(
name|key
argument_list|,
name|ks
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Setup a des key schedule from a key. The key is no longer needed  * after this transaction and can cleared.  *  * Does NOT check that the key is weak for or have wrong parity.  *  * @param key a key to initialize the key schedule with.  * @param ks a key schedule to initialize.  *  * @return 0 on success  * @ingroup hcrypto_des  */
end_comment

begin_function
name|int
name|DES_set_key_unchecked
parameter_list|(
name|DES_cblock
modifier|*
name|key
parameter_list|,
name|DES_key_schedule
modifier|*
name|ks
parameter_list|)
block|{
name|uint32_t
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|uint32_t
name|c
decl_stmt|,
name|d
decl_stmt|;
name|int
name|shifts
index|[
literal|16
index|]
init|=
block|{
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
decl_stmt|;
name|uint32_t
modifier|*
name|k
init|=
operator|&
name|ks
operator|->
name|ks
index|[
literal|0
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|t1
operator|=
operator|(
operator|*
name|key
operator|)
index|[
literal|0
index|]
operator|<<
literal|24
operator||
operator|(
operator|*
name|key
operator|)
index|[
literal|1
index|]
operator|<<
literal|16
operator||
operator|(
operator|*
name|key
operator|)
index|[
literal|2
index|]
operator|<<
literal|8
operator||
operator|(
operator|*
name|key
operator|)
index|[
literal|3
index|]
expr_stmt|;
name|t2
operator|=
operator|(
operator|*
name|key
operator|)
index|[
literal|4
index|]
operator|<<
literal|24
operator||
operator|(
operator|*
name|key
operator|)
index|[
literal|5
index|]
operator|<<
literal|16
operator||
operator|(
operator|*
name|key
operator|)
index|[
literal|6
index|]
operator|<<
literal|8
operator||
operator|(
operator|*
name|key
operator|)
index|[
literal|7
index|]
expr_stmt|;
name|c
operator|=
operator|(
name|pc1_c_3
index|[
operator|(
name|t1
operator|>>
operator|(
literal|5
operator|)
operator|)
operator|&
literal|0x7
index|]
operator|<<
literal|3
operator|)
operator||
operator|(
name|pc1_c_3
index|[
operator|(
name|t1
operator|>>
operator|(
literal|5
operator|+
literal|8
operator|)
operator|)
operator|&
literal|0x7
index|]
operator|<<
literal|2
operator|)
operator||
operator|(
name|pc1_c_3
index|[
operator|(
name|t1
operator|>>
operator|(
literal|5
operator|+
literal|8
operator|+
literal|8
operator|)
operator|)
operator|&
literal|0x7
index|]
operator|<<
literal|1
operator|)
operator||
operator|(
name|pc1_c_3
index|[
operator|(
name|t1
operator|>>
operator|(
literal|5
operator|+
literal|8
operator|+
literal|8
operator|+
literal|8
operator|)
operator|)
operator|&
literal|0x7
index|]
operator|<<
literal|0
operator|)
operator||
operator|(
name|pc1_c_4
index|[
operator|(
name|t2
operator|>>
operator|(
literal|4
operator|)
operator|)
operator|&
literal|0xf
index|]
operator|<<
literal|3
operator|)
operator||
operator|(
name|pc1_c_4
index|[
operator|(
name|t2
operator|>>
operator|(
literal|4
operator|+
literal|8
operator|)
operator|)
operator|&
literal|0xf
index|]
operator|<<
literal|2
operator|)
operator||
operator|(
name|pc1_c_4
index|[
operator|(
name|t2
operator|>>
operator|(
literal|4
operator|+
literal|8
operator|+
literal|8
operator|)
operator|)
operator|&
literal|0xf
index|]
operator|<<
literal|1
operator|)
operator||
operator|(
name|pc1_c_4
index|[
operator|(
name|t2
operator|>>
operator|(
literal|4
operator|+
literal|8
operator|+
literal|8
operator|+
literal|8
operator|)
operator|)
operator|&
literal|0xf
index|]
operator|<<
literal|0
operator|)
expr_stmt|;
name|d
operator|=
operator|(
name|pc1_d_3
index|[
operator|(
name|t2
operator|>>
operator|(
literal|1
operator|)
operator|)
operator|&
literal|0x7
index|]
operator|<<
literal|3
operator|)
operator||
operator|(
name|pc1_d_3
index|[
operator|(
name|t2
operator|>>
operator|(
literal|1
operator|+
literal|8
operator|)
operator|)
operator|&
literal|0x7
index|]
operator|<<
literal|2
operator|)
operator||
operator|(
name|pc1_d_3
index|[
operator|(
name|t2
operator|>>
operator|(
literal|1
operator|+
literal|8
operator|+
literal|8
operator|)
operator|)
operator|&
literal|0x7
index|]
operator|<<
literal|1
operator|)
operator||
operator|(
name|pc1_d_3
index|[
operator|(
name|t2
operator|>>
operator|(
literal|1
operator|+
literal|8
operator|+
literal|8
operator|+
literal|8
operator|)
operator|)
operator|&
literal|0x7
index|]
operator|<<
literal|0
operator|)
operator||
operator|(
name|pc1_d_4
index|[
operator|(
name|t1
operator|>>
operator|(
literal|1
operator|)
operator|)
operator|&
literal|0xf
index|]
operator|<<
literal|3
operator|)
operator||
operator|(
name|pc1_d_4
index|[
operator|(
name|t1
operator|>>
operator|(
literal|1
operator|+
literal|8
operator|)
operator|)
operator|&
literal|0xf
index|]
operator|<<
literal|2
operator|)
operator||
operator|(
name|pc1_d_4
index|[
operator|(
name|t1
operator|>>
operator|(
literal|1
operator|+
literal|8
operator|+
literal|8
operator|)
operator|)
operator|&
literal|0xf
index|]
operator|<<
literal|1
operator|)
operator||
operator|(
name|pc1_d_4
index|[
operator|(
name|t1
operator|>>
operator|(
literal|1
operator|+
literal|8
operator|+
literal|8
operator|+
literal|8
operator|)
operator|)
operator|&
literal|0xf
index|]
operator|<<
literal|0
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
name|uint32_t
name|kc
decl_stmt|,
name|kd
decl_stmt|;
name|ROTATE_LEFT28
argument_list|(
name|c
argument_list|,
name|shifts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ROTATE_LEFT28
argument_list|(
name|d
argument_list|,
name|shifts
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|kc
operator|=
name|pc2_c_1
index|[
operator|(
name|c
operator|>>
literal|22
operator|)
operator|&
literal|0x3f
index|]
operator||
name|pc2_c_2
index|[
operator|(
operator|(
name|c
operator|>>
literal|16
operator|)
operator|&
literal|0x30
operator|)
operator||
operator|(
operator|(
name|c
operator|>>
literal|15
operator|)
operator|&
literal|0xf
operator|)
index|]
operator||
name|pc2_c_3
index|[
operator|(
operator|(
name|c
operator|>>
literal|9
operator|)
operator|&
literal|0x3c
operator|)
operator||
operator|(
operator|(
name|c
operator|>>
literal|8
operator|)
operator|&
literal|0x3
operator|)
index|]
operator||
name|pc2_c_4
index|[
operator|(
operator|(
name|c
operator|>>
literal|2
operator|)
operator|&
literal|0x20
operator|)
operator||
operator|(
operator|(
name|c
operator|>>
literal|1
operator|)
operator|&
literal|0x18
operator|)
operator||
operator|(
name|c
operator|&
literal|0x7
operator|)
index|]
expr_stmt|;
name|kd
operator|=
name|pc2_d_1
index|[
operator|(
name|d
operator|>>
literal|22
operator|)
operator|&
literal|0x3f
index|]
operator||
name|pc2_d_2
index|[
operator|(
operator|(
name|d
operator|>>
literal|15
operator|)
operator|&
literal|0x30
operator|)
operator||
operator|(
operator|(
name|d
operator|>>
literal|14
operator|)
operator|&
literal|0xf
operator|)
index|]
operator||
name|pc2_d_3
index|[
operator|(
name|d
operator|>>
literal|7
operator|)
operator|&
literal|0x3f
index|]
operator||
name|pc2_d_4
index|[
operator|(
operator|(
name|d
operator|>>
literal|1
operator|)
operator|&
literal|0x3c
operator|)
operator||
operator|(
operator|(
name|d
operator|)
operator|&
literal|0x3
operator|)
index|]
expr_stmt|;
comment|/* Change to byte order used by the S boxes */
operator|*
name|k
operator|=
operator|(
name|kc
operator|&
literal|0x00fc0000L
operator|)
operator|<<
literal|6
expr_stmt|;
operator|*
name|k
operator||=
operator|(
name|kc
operator|&
literal|0x00000fc0L
operator|)
operator|<<
literal|10
expr_stmt|;
operator|*
name|k
operator||=
operator|(
name|kd
operator|&
literal|0x00fc0000L
operator|)
operator|>>
literal|10
expr_stmt|;
operator|*
name|k
operator|++
operator||=
operator|(
name|kd
operator|&
literal|0x00000fc0L
operator|)
operator|>>
literal|6
expr_stmt|;
operator|*
name|k
operator|=
operator|(
name|kc
operator|&
literal|0x0003f000L
operator|)
operator|<<
literal|12
expr_stmt|;
operator|*
name|k
operator||=
operator|(
name|kc
operator|&
literal|0x0000003fL
operator|)
operator|<<
literal|16
expr_stmt|;
operator|*
name|k
operator||=
operator|(
name|kd
operator|&
literal|0x0003f000L
operator|)
operator|>>
literal|4
expr_stmt|;
operator|*
name|k
operator|++
operator||=
operator|(
name|kd
operator|&
literal|0x0000003fL
operator|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Just like DES_set_key_unchecked() except checking that the key is  * not weak for or have correct parity.  *  * @param key a key to initialize the key schedule with.  * @param ks a key schedule to initialize.  *  * @return 0 on success, -1 on invalid parity, -2 on weak key.  * @ingroup hcrypto_des  */
end_comment

begin_function
name|int
name|DES_set_key_checked
parameter_list|(
name|DES_cblock
modifier|*
name|key
parameter_list|,
name|DES_key_schedule
modifier|*
name|ks
parameter_list|)
block|{
if|if
condition|(
operator|!
name|DES_check_key_parity
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|memset
argument_list|(
name|ks
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ks
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|DES_is_weak_key
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|memset
argument_list|(
name|ks
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ks
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|2
return|;
block|}
return|return
name|DES_set_key_unchecked
argument_list|(
name|key
argument_list|,
name|ks
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/**  * Compatibility function for eay libdes, works just like  * DES_set_key_checked().  *  * @param key a key to initialize the key schedule with.  * @param ks a key schedule to initialize.  *  * @return 0 on success, -1 on invalid parity, -2 on weak key.  * @ingroup hcrypto_des  */
end_comment

begin_function
name|int
name|DES_key_sched
parameter_list|(
name|DES_cblock
modifier|*
name|key
parameter_list|,
name|DES_key_schedule
modifier|*
name|ks
parameter_list|)
block|{
return|return
name|DES_set_key_checked
argument_list|(
name|key
argument_list|,
name|ks
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|void
name|load
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|b
parameter_list|,
name|uint32_t
name|v
index|[
literal|2
index|]
parameter_list|)
block|{
name|v
index|[
literal|0
index|]
operator|=
name|b
index|[
literal|0
index|]
operator|<<
literal|24
expr_stmt|;
name|v
index|[
literal|0
index|]
operator||=
name|b
index|[
literal|1
index|]
operator|<<
literal|16
expr_stmt|;
name|v
index|[
literal|0
index|]
operator||=
name|b
index|[
literal|2
index|]
operator|<<
literal|8
expr_stmt|;
name|v
index|[
literal|0
index|]
operator||=
name|b
index|[
literal|3
index|]
operator|<<
literal|0
expr_stmt|;
name|v
index|[
literal|1
index|]
operator|=
name|b
index|[
literal|4
index|]
operator|<<
literal|24
expr_stmt|;
name|v
index|[
literal|1
index|]
operator||=
name|b
index|[
literal|5
index|]
operator|<<
literal|16
expr_stmt|;
name|v
index|[
literal|1
index|]
operator||=
name|b
index|[
literal|6
index|]
operator|<<
literal|8
expr_stmt|;
name|v
index|[
literal|1
index|]
operator||=
name|b
index|[
literal|7
index|]
operator|<<
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|store
parameter_list|(
specifier|const
name|uint32_t
name|v
index|[
literal|2
index|]
parameter_list|,
name|unsigned
name|char
modifier|*
name|b
parameter_list|)
block|{
name|b
index|[
literal|0
index|]
operator|=
operator|(
name|v
index|[
literal|0
index|]
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|b
index|[
literal|1
index|]
operator|=
operator|(
name|v
index|[
literal|0
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|b
index|[
literal|2
index|]
operator|=
operator|(
name|v
index|[
literal|0
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|b
index|[
literal|3
index|]
operator|=
operator|(
name|v
index|[
literal|0
index|]
operator|>>
literal|0
operator|)
operator|&
literal|0xff
expr_stmt|;
name|b
index|[
literal|4
index|]
operator|=
operator|(
name|v
index|[
literal|1
index|]
operator|>>
literal|24
operator|)
operator|&
literal|0xff
expr_stmt|;
name|b
index|[
literal|5
index|]
operator|=
operator|(
name|v
index|[
literal|1
index|]
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
name|b
index|[
literal|6
index|]
operator|=
operator|(
name|v
index|[
literal|1
index|]
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
name|b
index|[
literal|7
index|]
operator|=
operator|(
name|v
index|[
literal|1
index|]
operator|>>
literal|0
operator|)
operator|&
literal|0xff
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Encrypt/decrypt a block using DES. Also called ECB mode  *  * @param u data to encrypt  * @param ks key schedule to use  * @param encp if non zero, encrypt. if zero, decrypt.  *  * @ingroup hcrypto_des  */
end_comment

begin_function
name|void
name|DES_encrypt
parameter_list|(
name|uint32_t
name|u
index|[
literal|2
index|]
parameter_list|,
name|DES_key_schedule
modifier|*
name|ks
parameter_list|,
name|int
name|encp
parameter_list|)
block|{
name|IP
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|desx
argument_list|(
name|u
argument_list|,
name|ks
argument_list|,
name|encp
argument_list|)
expr_stmt|;
name|FP
argument_list|(
name|u
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Encrypt/decrypt a block using DES.  *  * @param input data to encrypt  * @param output data to encrypt  * @param ks key schedule to use  * @param encp if non zero, encrypt. if zero, decrypt.  *  * @ingroup hcrypto_des  */
end_comment

begin_function
name|void
name|DES_ecb_encrypt
parameter_list|(
name|DES_cblock
modifier|*
name|input
parameter_list|,
name|DES_cblock
modifier|*
name|output
parameter_list|,
name|DES_key_schedule
modifier|*
name|ks
parameter_list|,
name|int
name|encp
parameter_list|)
block|{
name|uint32_t
name|u
index|[
literal|2
index|]
decl_stmt|;
name|load
argument_list|(
operator|*
name|input
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|DES_encrypt
argument_list|(
name|u
argument_list|,
name|ks
argument_list|,
name|encp
argument_list|)
expr_stmt|;
name|store
argument_list|(
name|u
argument_list|,
operator|*
name|output
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Encrypt/decrypt a block using DES in Chain Block Cipher mode (cbc).  *  * The IV must always be diffrent for diffrent input data blocks.  *  * @param in data to encrypt  * @param out data to encrypt  * @param length length of data  * @param ks key schedule to use  * @param iv initial vector to use  * @param encp if non zero, encrypt. if zero, decrypt.  *  * @ingroup hcrypto_des  */
end_comment

begin_function
name|void
name|DES_cbc_encrypt
parameter_list|(
specifier|const
name|void
modifier|*
name|in
parameter_list|,
name|void
modifier|*
name|out
parameter_list|,
name|long
name|length
parameter_list|,
name|DES_key_schedule
modifier|*
name|ks
parameter_list|,
name|DES_cblock
modifier|*
name|iv
parameter_list|,
name|int
name|encp
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|input
init|=
name|in
decl_stmt|;
name|unsigned
name|char
modifier|*
name|output
init|=
name|out
decl_stmt|;
name|uint32_t
name|u
index|[
literal|2
index|]
decl_stmt|;
name|uint32_t
name|uiv
index|[
literal|2
index|]
decl_stmt|;
name|load
argument_list|(
operator|*
name|iv
argument_list|,
name|uiv
argument_list|)
expr_stmt|;
if|if
condition|(
name|encp
condition|)
block|{
while|while
condition|(
name|length
operator|>=
name|DES_CBLOCK_LEN
condition|)
block|{
name|load
argument_list|(
name|input
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|u
index|[
literal|0
index|]
operator|^=
name|uiv
index|[
literal|0
index|]
expr_stmt|;
name|u
index|[
literal|1
index|]
operator|^=
name|uiv
index|[
literal|1
index|]
expr_stmt|;
name|DES_encrypt
argument_list|(
name|u
argument_list|,
name|ks
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|uiv
index|[
literal|0
index|]
operator|=
name|u
index|[
literal|0
index|]
expr_stmt|;
name|uiv
index|[
literal|1
index|]
operator|=
name|u
index|[
literal|1
index|]
expr_stmt|;
name|store
argument_list|(
name|u
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|length
operator|-=
name|DES_CBLOCK_LEN
expr_stmt|;
name|input
operator|+=
name|DES_CBLOCK_LEN
expr_stmt|;
name|output
operator|+=
name|DES_CBLOCK_LEN
expr_stmt|;
block|}
if|if
condition|(
name|length
condition|)
block|{
name|unsigned
name|char
name|tmp
index|[
name|DES_CBLOCK_LEN
index|]
decl_stmt|;
name|memcpy
argument_list|(
name|tmp
argument_list|,
name|input
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tmp
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|DES_CBLOCK_LEN
operator|-
name|length
argument_list|)
expr_stmt|;
name|load
argument_list|(
name|tmp
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|u
index|[
literal|0
index|]
operator|^=
name|uiv
index|[
literal|0
index|]
expr_stmt|;
name|u
index|[
literal|1
index|]
operator|^=
name|uiv
index|[
literal|1
index|]
expr_stmt|;
name|DES_encrypt
argument_list|(
name|u
argument_list|,
name|ks
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|store
argument_list|(
name|u
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|uint32_t
name|t
index|[
literal|2
index|]
decl_stmt|;
while|while
condition|(
name|length
operator|>=
name|DES_CBLOCK_LEN
condition|)
block|{
name|load
argument_list|(
name|input
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|t
index|[
literal|0
index|]
operator|=
name|u
index|[
literal|0
index|]
expr_stmt|;
name|t
index|[
literal|1
index|]
operator|=
name|u
index|[
literal|1
index|]
expr_stmt|;
name|DES_encrypt
argument_list|(
name|u
argument_list|,
name|ks
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|u
index|[
literal|0
index|]
operator|^=
name|uiv
index|[
literal|0
index|]
expr_stmt|;
name|u
index|[
literal|1
index|]
operator|^=
name|uiv
index|[
literal|1
index|]
expr_stmt|;
name|store
argument_list|(
name|u
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|uiv
index|[
literal|0
index|]
operator|=
name|t
index|[
literal|0
index|]
expr_stmt|;
name|uiv
index|[
literal|1
index|]
operator|=
name|t
index|[
literal|1
index|]
expr_stmt|;
name|length
operator|-=
name|DES_CBLOCK_LEN
expr_stmt|;
name|input
operator|+=
name|DES_CBLOCK_LEN
expr_stmt|;
name|output
operator|+=
name|DES_CBLOCK_LEN
expr_stmt|;
block|}
if|if
condition|(
name|length
condition|)
block|{
name|unsigned
name|char
name|tmp
index|[
name|DES_CBLOCK_LEN
index|]
decl_stmt|;
name|memcpy
argument_list|(
name|tmp
argument_list|,
name|input
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tmp
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|DES_CBLOCK_LEN
operator|-
name|length
argument_list|)
expr_stmt|;
name|load
argument_list|(
name|tmp
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|DES_encrypt
argument_list|(
name|u
argument_list|,
name|ks
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|u
index|[
literal|0
index|]
operator|^=
name|uiv
index|[
literal|0
index|]
expr_stmt|;
name|u
index|[
literal|1
index|]
operator|^=
name|uiv
index|[
literal|1
index|]
expr_stmt|;
name|store
argument_list|(
name|u
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
block|}
name|uiv
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|u
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|uiv
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|u
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Encrypt/decrypt a block using DES in Propagating Cipher Block  * Chaining mode. This mode is only used for Kerberos 4, and it should  * stay that way.  *  * The IV must always be diffrent for diffrent input data blocks.  *  * @param in data to encrypt  * @param out data to encrypt  * @param length length of data  * @param ks key schedule to use  * @param iv initial vector to use  * @param encp if non zero, encrypt. if zero, decrypt.  *  * @ingroup hcrypto_des  */
end_comment

begin_function
name|void
name|DES_pcbc_encrypt
parameter_list|(
specifier|const
name|void
modifier|*
name|in
parameter_list|,
name|void
modifier|*
name|out
parameter_list|,
name|long
name|length
parameter_list|,
name|DES_key_schedule
modifier|*
name|ks
parameter_list|,
name|DES_cblock
modifier|*
name|iv
parameter_list|,
name|int
name|encp
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|input
init|=
name|in
decl_stmt|;
name|unsigned
name|char
modifier|*
name|output
init|=
name|out
decl_stmt|;
name|uint32_t
name|u
index|[
literal|2
index|]
decl_stmt|;
name|uint32_t
name|uiv
index|[
literal|2
index|]
decl_stmt|;
name|load
argument_list|(
operator|*
name|iv
argument_list|,
name|uiv
argument_list|)
expr_stmt|;
if|if
condition|(
name|encp
condition|)
block|{
name|uint32_t
name|t
index|[
literal|2
index|]
decl_stmt|;
while|while
condition|(
name|length
operator|>=
name|DES_CBLOCK_LEN
condition|)
block|{
name|load
argument_list|(
name|input
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|t
index|[
literal|0
index|]
operator|=
name|u
index|[
literal|0
index|]
expr_stmt|;
name|t
index|[
literal|1
index|]
operator|=
name|u
index|[
literal|1
index|]
expr_stmt|;
name|u
index|[
literal|0
index|]
operator|^=
name|uiv
index|[
literal|0
index|]
expr_stmt|;
name|u
index|[
literal|1
index|]
operator|^=
name|uiv
index|[
literal|1
index|]
expr_stmt|;
name|DES_encrypt
argument_list|(
name|u
argument_list|,
name|ks
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|uiv
index|[
literal|0
index|]
operator|=
name|u
index|[
literal|0
index|]
operator|^
name|t
index|[
literal|0
index|]
expr_stmt|;
name|uiv
index|[
literal|1
index|]
operator|=
name|u
index|[
literal|1
index|]
operator|^
name|t
index|[
literal|1
index|]
expr_stmt|;
name|store
argument_list|(
name|u
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|length
operator|-=
name|DES_CBLOCK_LEN
expr_stmt|;
name|input
operator|+=
name|DES_CBLOCK_LEN
expr_stmt|;
name|output
operator|+=
name|DES_CBLOCK_LEN
expr_stmt|;
block|}
if|if
condition|(
name|length
condition|)
block|{
name|unsigned
name|char
name|tmp
index|[
name|DES_CBLOCK_LEN
index|]
decl_stmt|;
name|memcpy
argument_list|(
name|tmp
argument_list|,
name|input
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tmp
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|DES_CBLOCK_LEN
operator|-
name|length
argument_list|)
expr_stmt|;
name|load
argument_list|(
name|tmp
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|u
index|[
literal|0
index|]
operator|^=
name|uiv
index|[
literal|0
index|]
expr_stmt|;
name|u
index|[
literal|1
index|]
operator|^=
name|uiv
index|[
literal|1
index|]
expr_stmt|;
name|DES_encrypt
argument_list|(
name|u
argument_list|,
name|ks
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|store
argument_list|(
name|u
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|uint32_t
name|t
index|[
literal|2
index|]
decl_stmt|;
while|while
condition|(
name|length
operator|>=
name|DES_CBLOCK_LEN
condition|)
block|{
name|load
argument_list|(
name|input
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|t
index|[
literal|0
index|]
operator|=
name|u
index|[
literal|0
index|]
expr_stmt|;
name|t
index|[
literal|1
index|]
operator|=
name|u
index|[
literal|1
index|]
expr_stmt|;
name|DES_encrypt
argument_list|(
name|u
argument_list|,
name|ks
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|u
index|[
literal|0
index|]
operator|^=
name|uiv
index|[
literal|0
index|]
expr_stmt|;
name|u
index|[
literal|1
index|]
operator|^=
name|uiv
index|[
literal|1
index|]
expr_stmt|;
name|store
argument_list|(
name|u
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|uiv
index|[
literal|0
index|]
operator|=
name|t
index|[
literal|0
index|]
operator|^
name|u
index|[
literal|0
index|]
expr_stmt|;
name|uiv
index|[
literal|1
index|]
operator|=
name|t
index|[
literal|1
index|]
operator|^
name|u
index|[
literal|1
index|]
expr_stmt|;
name|length
operator|-=
name|DES_CBLOCK_LEN
expr_stmt|;
name|input
operator|+=
name|DES_CBLOCK_LEN
expr_stmt|;
name|output
operator|+=
name|DES_CBLOCK_LEN
expr_stmt|;
block|}
if|if
condition|(
name|length
condition|)
block|{
name|unsigned
name|char
name|tmp
index|[
name|DES_CBLOCK_LEN
index|]
decl_stmt|;
name|memcpy
argument_list|(
name|tmp
argument_list|,
name|input
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tmp
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|DES_CBLOCK_LEN
operator|-
name|length
argument_list|)
expr_stmt|;
name|load
argument_list|(
name|tmp
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|DES_encrypt
argument_list|(
name|u
argument_list|,
name|ks
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|u
index|[
literal|0
index|]
operator|^=
name|uiv
index|[
literal|0
index|]
expr_stmt|;
name|u
index|[
literal|1
index|]
operator|^=
name|uiv
index|[
literal|1
index|]
expr_stmt|;
block|}
block|}
name|uiv
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|u
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|uiv
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|u
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|void
name|_des3_encrypt
parameter_list|(
name|uint32_t
name|u
index|[
literal|2
index|]
parameter_list|,
name|DES_key_schedule
modifier|*
name|ks1
parameter_list|,
name|DES_key_schedule
modifier|*
name|ks2
parameter_list|,
name|DES_key_schedule
modifier|*
name|ks3
parameter_list|,
name|int
name|encp
parameter_list|)
block|{
name|IP
argument_list|(
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|encp
condition|)
block|{
name|desx
argument_list|(
name|u
argument_list|,
name|ks1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* IP + FP cancel out each other */
name|desx
argument_list|(
name|u
argument_list|,
name|ks2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|desx
argument_list|(
name|u
argument_list|,
name|ks3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|desx
argument_list|(
name|u
argument_list|,
name|ks3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|desx
argument_list|(
name|u
argument_list|,
name|ks2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|desx
argument_list|(
name|u
argument_list|,
name|ks1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|FP
argument_list|(
name|u
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Encrypt/decrypt a block using triple DES using EDE mode,  * encrypt/decrypt/encrypt.  *  * @param input data to encrypt  * @param output data to encrypt  * @param ks1 key schedule to use  * @param ks2 key schedule to use  * @param ks3 key schedule to use  * @param encp if non zero, encrypt. if zero, decrypt.  *  * @ingroup hcrypto_des  */
end_comment

begin_function
name|void
name|DES_ecb3_encrypt
parameter_list|(
name|DES_cblock
modifier|*
name|input
parameter_list|,
name|DES_cblock
modifier|*
name|output
parameter_list|,
name|DES_key_schedule
modifier|*
name|ks1
parameter_list|,
name|DES_key_schedule
modifier|*
name|ks2
parameter_list|,
name|DES_key_schedule
modifier|*
name|ks3
parameter_list|,
name|int
name|encp
parameter_list|)
block|{
name|uint32_t
name|u
index|[
literal|2
index|]
decl_stmt|;
name|load
argument_list|(
operator|*
name|input
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|_des3_encrypt
argument_list|(
name|u
argument_list|,
name|ks1
argument_list|,
name|ks2
argument_list|,
name|ks3
argument_list|,
name|encp
argument_list|)
expr_stmt|;
name|store
argument_list|(
name|u
argument_list|,
operator|*
name|output
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/**  * Encrypt/decrypt using Triple DES in Chain Block Cipher mode (cbc).  *  * The IV must always be diffrent for diffrent input data blocks.  *  * @param in data to encrypt  * @param out data to encrypt  * @param length length of data  * @param ks1 key schedule to use  * @param ks2 key schedule to use  * @param ks3 key schedule to use  * @param iv initial vector to use  * @param encp if non zero, encrypt. if zero, decrypt.  *  * @ingroup hcrypto_des  */
end_comment

begin_function
name|void
name|DES_ede3_cbc_encrypt
parameter_list|(
specifier|const
name|void
modifier|*
name|in
parameter_list|,
name|void
modifier|*
name|out
parameter_list|,
name|long
name|length
parameter_list|,
name|DES_key_schedule
modifier|*
name|ks1
parameter_list|,
name|DES_key_schedule
modifier|*
name|ks2
parameter_list|,
name|DES_key_schedule
modifier|*
name|ks3
parameter_list|,
name|DES_cblock
modifier|*
name|iv
parameter_list|,
name|int
name|encp
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|input
init|=
name|in
decl_stmt|;
name|unsigned
name|char
modifier|*
name|output
init|=
name|out
decl_stmt|;
name|uint32_t
name|u
index|[
literal|2
index|]
decl_stmt|;
name|uint32_t
name|uiv
index|[
literal|2
index|]
decl_stmt|;
name|load
argument_list|(
operator|*
name|iv
argument_list|,
name|uiv
argument_list|)
expr_stmt|;
if|if
condition|(
name|encp
condition|)
block|{
while|while
condition|(
name|length
operator|>=
name|DES_CBLOCK_LEN
condition|)
block|{
name|load
argument_list|(
name|input
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|u
index|[
literal|0
index|]
operator|^=
name|uiv
index|[
literal|0
index|]
expr_stmt|;
name|u
index|[
literal|1
index|]
operator|^=
name|uiv
index|[
literal|1
index|]
expr_stmt|;
name|_des3_encrypt
argument_list|(
name|u
argument_list|,
name|ks1
argument_list|,
name|ks2
argument_list|,
name|ks3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|uiv
index|[
literal|0
index|]
operator|=
name|u
index|[
literal|0
index|]
expr_stmt|;
name|uiv
index|[
literal|1
index|]
operator|=
name|u
index|[
literal|1
index|]
expr_stmt|;
name|store
argument_list|(
name|u
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|length
operator|-=
name|DES_CBLOCK_LEN
expr_stmt|;
name|input
operator|+=
name|DES_CBLOCK_LEN
expr_stmt|;
name|output
operator|+=
name|DES_CBLOCK_LEN
expr_stmt|;
block|}
if|if
condition|(
name|length
condition|)
block|{
name|unsigned
name|char
name|tmp
index|[
name|DES_CBLOCK_LEN
index|]
decl_stmt|;
name|memcpy
argument_list|(
name|tmp
argument_list|,
name|input
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tmp
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|DES_CBLOCK_LEN
operator|-
name|length
argument_list|)
expr_stmt|;
name|load
argument_list|(
name|tmp
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|u
index|[
literal|0
index|]
operator|^=
name|uiv
index|[
literal|0
index|]
expr_stmt|;
name|u
index|[
literal|1
index|]
operator|^=
name|uiv
index|[
literal|1
index|]
expr_stmt|;
name|_des3_encrypt
argument_list|(
name|u
argument_list|,
name|ks1
argument_list|,
name|ks2
argument_list|,
name|ks3
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|store
argument_list|(
name|u
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|uint32_t
name|t
index|[
literal|2
index|]
decl_stmt|;
while|while
condition|(
name|length
operator|>=
name|DES_CBLOCK_LEN
condition|)
block|{
name|load
argument_list|(
name|input
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|t
index|[
literal|0
index|]
operator|=
name|u
index|[
literal|0
index|]
expr_stmt|;
name|t
index|[
literal|1
index|]
operator|=
name|u
index|[
literal|1
index|]
expr_stmt|;
name|_des3_encrypt
argument_list|(
name|u
argument_list|,
name|ks1
argument_list|,
name|ks2
argument_list|,
name|ks3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|u
index|[
literal|0
index|]
operator|^=
name|uiv
index|[
literal|0
index|]
expr_stmt|;
name|u
index|[
literal|1
index|]
operator|^=
name|uiv
index|[
literal|1
index|]
expr_stmt|;
name|store
argument_list|(
name|u
argument_list|,
name|output
argument_list|)
expr_stmt|;
name|uiv
index|[
literal|0
index|]
operator|=
name|t
index|[
literal|0
index|]
expr_stmt|;
name|uiv
index|[
literal|1
index|]
operator|=
name|t
index|[
literal|1
index|]
expr_stmt|;
name|length
operator|-=
name|DES_CBLOCK_LEN
expr_stmt|;
name|input
operator|+=
name|DES_CBLOCK_LEN
expr_stmt|;
name|output
operator|+=
name|DES_CBLOCK_LEN
expr_stmt|;
block|}
if|if
condition|(
name|length
condition|)
block|{
name|unsigned
name|char
name|tmp
index|[
name|DES_CBLOCK_LEN
index|]
decl_stmt|;
name|memcpy
argument_list|(
name|tmp
argument_list|,
name|input
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tmp
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|DES_CBLOCK_LEN
operator|-
name|length
argument_list|)
expr_stmt|;
name|load
argument_list|(
name|tmp
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|_des3_encrypt
argument_list|(
name|u
argument_list|,
name|ks1
argument_list|,
name|ks2
argument_list|,
name|ks3
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|u
index|[
literal|0
index|]
operator|^=
name|uiv
index|[
literal|0
index|]
expr_stmt|;
name|u
index|[
literal|1
index|]
operator|^=
name|uiv
index|[
literal|1
index|]
expr_stmt|;
name|store
argument_list|(
name|u
argument_list|,
name|output
argument_list|)
expr_stmt|;
block|}
block|}
name|store
argument_list|(
name|uiv
argument_list|,
operator|*
name|iv
argument_list|)
expr_stmt|;
name|uiv
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|u
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|uiv
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|u
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Encrypt/decrypt using DES in cipher feedback mode with 64 bit  * feedback.  *  * The IV must always be diffrent for diffrent input data blocks.  *  * @param in data to encrypt  * @param out data to encrypt  * @param length length of data  * @param ks key schedule to use  * @param iv initial vector to use  * @param num offset into in cipher block encryption/decryption stop last time.  * @param encp if non zero, encrypt. if zero, decrypt.  *  * @ingroup hcrypto_des  */
end_comment

begin_function
name|void
name|DES_cfb64_encrypt
parameter_list|(
specifier|const
name|void
modifier|*
name|in
parameter_list|,
name|void
modifier|*
name|out
parameter_list|,
name|long
name|length
parameter_list|,
name|DES_key_schedule
modifier|*
name|ks
parameter_list|,
name|DES_cblock
modifier|*
name|iv
parameter_list|,
name|int
modifier|*
name|num
parameter_list|,
name|int
name|encp
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|input
init|=
name|in
decl_stmt|;
name|unsigned
name|char
modifier|*
name|output
init|=
name|out
decl_stmt|;
name|unsigned
name|char
name|tmp
index|[
name|DES_CBLOCK_LEN
index|]
decl_stmt|;
name|uint32_t
name|uiv
index|[
literal|2
index|]
decl_stmt|;
name|load
argument_list|(
operator|*
name|iv
argument_list|,
name|uiv
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|*
name|num
operator|>=
literal|0
operator|&&
operator|*
name|num
operator|<
name|DES_CBLOCK_LEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|encp
condition|)
block|{
name|int
name|i
init|=
operator|*
name|num
decl_stmt|;
while|while
condition|(
name|length
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|DES_encrypt
argument_list|(
name|uiv
argument_list|,
name|ks
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|store
argument_list|(
name|uiv
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
name|DES_CBLOCK_LEN
operator|&&
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|output
index|[
name|i
index|]
operator|=
name|tmp
index|[
name|i
index|]
operator|^
name|input
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|DES_CBLOCK_LEN
condition|)
name|load
argument_list|(
name|output
argument_list|,
name|uiv
argument_list|)
expr_stmt|;
name|output
operator|+=
name|i
expr_stmt|;
name|input
operator|+=
name|i
expr_stmt|;
name|length
operator|-=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|DES_CBLOCK_LEN
condition|)
name|i
operator|=
literal|0
expr_stmt|;
block|}
name|store
argument_list|(
name|uiv
argument_list|,
operator|*
name|iv
argument_list|)
expr_stmt|;
operator|*
name|num
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
init|=
operator|*
name|num
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
while|while
condition|(
name|length
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|DES_encrypt
argument_list|(
name|uiv
argument_list|,
name|ks
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|store
argument_list|(
name|uiv
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|DES_CBLOCK_LEN
operator|&&
name|i
operator|<
name|length
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|input
index|[
name|i
index|]
expr_stmt|;
name|output
index|[
name|i
index|]
operator|=
name|tmp
index|[
name|i
index|]
operator|^
name|input
index|[
name|i
index|]
expr_stmt|;
operator|(
operator|*
name|iv
operator|)
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
block|}
name|output
operator|+=
name|i
expr_stmt|;
name|input
operator|+=
name|i
expr_stmt|;
name|length
operator|-=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|DES_CBLOCK_LEN
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|load
argument_list|(
operator|*
name|iv
argument_list|,
name|uiv
argument_list|)
expr_stmt|;
block|}
block|}
name|store
argument_list|(
name|uiv
argument_list|,
operator|*
name|iv
argument_list|)
expr_stmt|;
operator|*
name|num
operator|=
name|i
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/**  * Crete a checksum using DES in CBC encryption mode. This mode is  * only used for Kerberos 4, and it should stay that way.  *  * The IV must always be diffrent for diffrent input data blocks.  *  * @param in data to checksum  * @param output the checksum  * @param length length of data  * @param ks key schedule to use  * @param iv initial vector to use  *  * @ingroup hcrypto_des  */
end_comment

begin_function
name|uint32_t
name|DES_cbc_cksum
parameter_list|(
specifier|const
name|void
modifier|*
name|in
parameter_list|,
name|DES_cblock
modifier|*
name|output
parameter_list|,
name|long
name|length
parameter_list|,
name|DES_key_schedule
modifier|*
name|ks
parameter_list|,
name|DES_cblock
modifier|*
name|iv
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|input
init|=
name|in
decl_stmt|;
name|uint32_t
name|uiv
index|[
literal|2
index|]
decl_stmt|;
name|uint32_t
name|u
index|[
literal|2
index|]
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|load
argument_list|(
operator|*
name|iv
argument_list|,
name|uiv
argument_list|)
expr_stmt|;
while|while
condition|(
name|length
operator|>=
name|DES_CBLOCK_LEN
condition|)
block|{
name|load
argument_list|(
name|input
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|u
index|[
literal|0
index|]
operator|^=
name|uiv
index|[
literal|0
index|]
expr_stmt|;
name|u
index|[
literal|1
index|]
operator|^=
name|uiv
index|[
literal|1
index|]
expr_stmt|;
name|DES_encrypt
argument_list|(
name|u
argument_list|,
name|ks
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|uiv
index|[
literal|0
index|]
operator|=
name|u
index|[
literal|0
index|]
expr_stmt|;
name|uiv
index|[
literal|1
index|]
operator|=
name|u
index|[
literal|1
index|]
expr_stmt|;
name|length
operator|-=
name|DES_CBLOCK_LEN
expr_stmt|;
name|input
operator|+=
name|DES_CBLOCK_LEN
expr_stmt|;
block|}
if|if
condition|(
name|length
condition|)
block|{
name|unsigned
name|char
name|tmp
index|[
name|DES_CBLOCK_LEN
index|]
decl_stmt|;
name|memcpy
argument_list|(
name|tmp
argument_list|,
name|input
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|tmp
operator|+
name|length
argument_list|,
literal|0
argument_list|,
name|DES_CBLOCK_LEN
operator|-
name|length
argument_list|)
expr_stmt|;
name|load
argument_list|(
name|tmp
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|u
index|[
literal|0
index|]
operator|^=
name|uiv
index|[
literal|0
index|]
expr_stmt|;
name|u
index|[
literal|1
index|]
operator|^=
name|uiv
index|[
literal|1
index|]
expr_stmt|;
name|DES_encrypt
argument_list|(
name|u
argument_list|,
name|ks
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|output
condition|)
name|store
argument_list|(
name|u
argument_list|,
operator|*
name|output
argument_list|)
expr_stmt|;
name|uiv
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|u
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|uiv
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|u
index|[
literal|1
index|]
return|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
specifier|static
name|unsigned
name|char
name|bitswap8
parameter_list|(
name|unsigned
name|char
name|b
parameter_list|)
block|{
name|unsigned
name|char
name|r
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|r
operator|=
name|r
operator|<<
literal|1
operator||
operator|(
name|b
operator|&
literal|1
operator|)
expr_stmt|;
name|b
operator|=
name|b
operator|>>
literal|1
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/**  * Convert a string to a DES key. Use something like  * PKCS5_PBKDF2_HMAC_SHA1() to create key from passwords.  *  * @param str The string to convert to a key  * @param key the resulting key  *  * @ingroup hcrypto_des  */
end_comment

begin_function
name|void
name|DES_string_to_key
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|DES_cblock
modifier|*
name|key
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|s
decl_stmt|;
name|unsigned
name|char
modifier|*
name|k
decl_stmt|;
name|DES_key_schedule
name|ks
decl_stmt|;
name|size_t
name|i
decl_stmt|,
name|len
decl_stmt|;
name|memset
argument_list|(
name|key
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|k
operator|=
operator|*
name|key
expr_stmt|;
name|s
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|str
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|i
operator|%
literal|16
operator|)
operator|<
literal|8
condition|)
name|k
index|[
name|i
operator|%
literal|8
index|]
operator|^=
name|s
index|[
name|i
index|]
operator|<<
literal|1
expr_stmt|;
else|else
name|k
index|[
literal|7
operator|-
operator|(
name|i
operator|%
literal|8
operator|)
index|]
operator|^=
name|bitswap8
argument_list|(
name|s
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|DES_set_odd_parity
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|DES_is_weak_key
argument_list|(
name|key
argument_list|)
condition|)
name|k
index|[
literal|7
index|]
operator|^=
literal|0xF0
expr_stmt|;
name|DES_set_key
argument_list|(
name|key
argument_list|,
operator|&
name|ks
argument_list|)
expr_stmt|;
name|DES_cbc_cksum
argument_list|(
name|s
argument_list|,
name|key
argument_list|,
name|len
argument_list|,
operator|&
name|ks
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|ks
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|ks
argument_list|)
argument_list|)
expr_stmt|;
name|DES_set_odd_parity
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|DES_is_weak_key
argument_list|(
name|key
argument_list|)
condition|)
name|k
index|[
literal|7
index|]
operator|^=
literal|0xF0
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Read password from prompt and create a DES key. Internal uses  * DES_string_to_key(). Really, go use a really string2key function  * like PKCS5_PBKDF2_HMAC_SHA1().  *  * @param key key to convert to  * @param prompt prompt to display user  * @param verify prompt twice.  *  * @return 1 on success, non 1 on failure.  */
end_comment

begin_function
name|int
name|DES_read_password
parameter_list|(
name|DES_cblock
modifier|*
name|key
parameter_list|,
name|char
modifier|*
name|prompt
parameter_list|,
name|int
name|verify
parameter_list|)
block|{
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|UI_UTIL_read_pw_string
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
argument_list|,
name|prompt
argument_list|,
name|verify
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|1
condition|)
name|DES_string_to_key
argument_list|(
name|buf
argument_list|,
name|key
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  *  */
end_comment

begin_function
name|void
name|_DES_ipfp_test
parameter_list|(
name|void
parameter_list|)
block|{
name|DES_cblock
name|k
init|=
literal|"\x01\x02\x04\x08\x10\x20\x40\x80"
decl_stmt|,
name|k2
decl_stmt|;
name|uint32_t
name|u
index|[
literal|2
index|]
init|=
block|{
literal|1
block|,
literal|0
block|}
decl_stmt|;
name|IP
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|FP
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|IP
argument_list|(
name|u
argument_list|)
expr_stmt|;
name|FP
argument_list|(
name|u
argument_list|)
expr_stmt|;
if|if
condition|(
name|u
index|[
literal|0
index|]
operator|!=
literal|1
operator|||
name|u
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
name|load
argument_list|(
name|k
argument_list|,
name|u
argument_list|)
expr_stmt|;
name|store
argument_list|(
name|u
argument_list|,
name|k2
argument_list|)
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|k
argument_list|,
name|k2
argument_list|,
literal|8
argument_list|)
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* D3DES (V5.09) -  *  * A portable, public domain, version of the Data Encryption Standard.  *  * Written with Symantec's THINK (Lightspeed) C by Richard Outerbridge.  * Thanks to: Dan Hoey for his excellent Initial and Inverse permutation  * code;  Jim Gillogly& Phil Karn for the DES key schedule code; Dennis  * Ferguson, Eric Young and Dana How for comparing notes; and Ray Lau,  * for humouring me on.  *  * Copyright (c) 1988,1989,1990,1991,1992 by Richard Outerbridge.  * (GEnie : OUTER; CIS : [71755,204]) Graven Imagery, 1992.  */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|SP1
index|[
literal|64
index|]
init|=
block|{
literal|0x01010400L
block|,
literal|0x00000000L
block|,
literal|0x00010000L
block|,
literal|0x01010404L
block|,
literal|0x01010004L
block|,
literal|0x00010404L
block|,
literal|0x00000004L
block|,
literal|0x00010000L
block|,
literal|0x00000400L
block|,
literal|0x01010400L
block|,
literal|0x01010404L
block|,
literal|0x00000400L
block|,
literal|0x01000404L
block|,
literal|0x01010004L
block|,
literal|0x01000000L
block|,
literal|0x00000004L
block|,
literal|0x00000404L
block|,
literal|0x01000400L
block|,
literal|0x01000400L
block|,
literal|0x00010400L
block|,
literal|0x00010400L
block|,
literal|0x01010000L
block|,
literal|0x01010000L
block|,
literal|0x01000404L
block|,
literal|0x00010004L
block|,
literal|0x01000004L
block|,
literal|0x01000004L
block|,
literal|0x00010004L
block|,
literal|0x00000000L
block|,
literal|0x00000404L
block|,
literal|0x00010404L
block|,
literal|0x01000000L
block|,
literal|0x00010000L
block|,
literal|0x01010404L
block|,
literal|0x00000004L
block|,
literal|0x01010000L
block|,
literal|0x01010400L
block|,
literal|0x01000000L
block|,
literal|0x01000000L
block|,
literal|0x00000400L
block|,
literal|0x01010004L
block|,
literal|0x00010000L
block|,
literal|0x00010400L
block|,
literal|0x01000004L
block|,
literal|0x00000400L
block|,
literal|0x00000004L
block|,
literal|0x01000404L
block|,
literal|0x00010404L
block|,
literal|0x01010404L
block|,
literal|0x00010004L
block|,
literal|0x01010000L
block|,
literal|0x01000404L
block|,
literal|0x01000004L
block|,
literal|0x00000404L
block|,
literal|0x00010404L
block|,
literal|0x01010400L
block|,
literal|0x00000404L
block|,
literal|0x01000400L
block|,
literal|0x01000400L
block|,
literal|0x00000000L
block|,
literal|0x00010004L
block|,
literal|0x00010400L
block|,
literal|0x00000000L
block|,
literal|0x01010004L
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|SP2
index|[
literal|64
index|]
init|=
block|{
literal|0x80108020L
block|,
literal|0x80008000L
block|,
literal|0x00008000L
block|,
literal|0x00108020L
block|,
literal|0x00100000L
block|,
literal|0x00000020L
block|,
literal|0x80100020L
block|,
literal|0x80008020L
block|,
literal|0x80000020L
block|,
literal|0x80108020L
block|,
literal|0x80108000L
block|,
literal|0x80000000L
block|,
literal|0x80008000L
block|,
literal|0x00100000L
block|,
literal|0x00000020L
block|,
literal|0x80100020L
block|,
literal|0x00108000L
block|,
literal|0x00100020L
block|,
literal|0x80008020L
block|,
literal|0x00000000L
block|,
literal|0x80000000L
block|,
literal|0x00008000L
block|,
literal|0x00108020L
block|,
literal|0x80100000L
block|,
literal|0x00100020L
block|,
literal|0x80000020L
block|,
literal|0x00000000L
block|,
literal|0x00108000L
block|,
literal|0x00008020L
block|,
literal|0x80108000L
block|,
literal|0x80100000L
block|,
literal|0x00008020L
block|,
literal|0x00000000L
block|,
literal|0x00108020L
block|,
literal|0x80100020L
block|,
literal|0x00100000L
block|,
literal|0x80008020L
block|,
literal|0x80100000L
block|,
literal|0x80108000L
block|,
literal|0x00008000L
block|,
literal|0x80100000L
block|,
literal|0x80008000L
block|,
literal|0x00000020L
block|,
literal|0x80108020L
block|,
literal|0x00108020L
block|,
literal|0x00000020L
block|,
literal|0x00008000L
block|,
literal|0x80000000L
block|,
literal|0x00008020L
block|,
literal|0x80108000L
block|,
literal|0x00100000L
block|,
literal|0x80000020L
block|,
literal|0x00100020L
block|,
literal|0x80008020L
block|,
literal|0x80000020L
block|,
literal|0x00100020L
block|,
literal|0x00108000L
block|,
literal|0x00000000L
block|,
literal|0x80008000L
block|,
literal|0x00008020L
block|,
literal|0x80000000L
block|,
literal|0x80100020L
block|,
literal|0x80108020L
block|,
literal|0x00108000L
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|SP3
index|[
literal|64
index|]
init|=
block|{
literal|0x00000208L
block|,
literal|0x08020200L
block|,
literal|0x00000000L
block|,
literal|0x08020008L
block|,
literal|0x08000200L
block|,
literal|0x00000000L
block|,
literal|0x00020208L
block|,
literal|0x08000200L
block|,
literal|0x00020008L
block|,
literal|0x08000008L
block|,
literal|0x08000008L
block|,
literal|0x00020000L
block|,
literal|0x08020208L
block|,
literal|0x00020008L
block|,
literal|0x08020000L
block|,
literal|0x00000208L
block|,
literal|0x08000000L
block|,
literal|0x00000008L
block|,
literal|0x08020200L
block|,
literal|0x00000200L
block|,
literal|0x00020200L
block|,
literal|0x08020000L
block|,
literal|0x08020008L
block|,
literal|0x00020208L
block|,
literal|0x08000208L
block|,
literal|0x00020200L
block|,
literal|0x00020000L
block|,
literal|0x08000208L
block|,
literal|0x00000008L
block|,
literal|0x08020208L
block|,
literal|0x00000200L
block|,
literal|0x08000000L
block|,
literal|0x08020200L
block|,
literal|0x08000000L
block|,
literal|0x00020008L
block|,
literal|0x00000208L
block|,
literal|0x00020000L
block|,
literal|0x08020200L
block|,
literal|0x08000200L
block|,
literal|0x00000000L
block|,
literal|0x00000200L
block|,
literal|0x00020008L
block|,
literal|0x08020208L
block|,
literal|0x08000200L
block|,
literal|0x08000008L
block|,
literal|0x00000200L
block|,
literal|0x00000000L
block|,
literal|0x08020008L
block|,
literal|0x08000208L
block|,
literal|0x00020000L
block|,
literal|0x08000000L
block|,
literal|0x08020208L
block|,
literal|0x00000008L
block|,
literal|0x00020208L
block|,
literal|0x00020200L
block|,
literal|0x08000008L
block|,
literal|0x08020000L
block|,
literal|0x08000208L
block|,
literal|0x00000208L
block|,
literal|0x08020000L
block|,
literal|0x00020208L
block|,
literal|0x00000008L
block|,
literal|0x08020008L
block|,
literal|0x00020200L
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|SP4
index|[
literal|64
index|]
init|=
block|{
literal|0x00802001L
block|,
literal|0x00002081L
block|,
literal|0x00002081L
block|,
literal|0x00000080L
block|,
literal|0x00802080L
block|,
literal|0x00800081L
block|,
literal|0x00800001L
block|,
literal|0x00002001L
block|,
literal|0x00000000L
block|,
literal|0x00802000L
block|,
literal|0x00802000L
block|,
literal|0x00802081L
block|,
literal|0x00000081L
block|,
literal|0x00000000L
block|,
literal|0x00800080L
block|,
literal|0x00800001L
block|,
literal|0x00000001L
block|,
literal|0x00002000L
block|,
literal|0x00800000L
block|,
literal|0x00802001L
block|,
literal|0x00000080L
block|,
literal|0x00800000L
block|,
literal|0x00002001L
block|,
literal|0x00002080L
block|,
literal|0x00800081L
block|,
literal|0x00000001L
block|,
literal|0x00002080L
block|,
literal|0x00800080L
block|,
literal|0x00002000L
block|,
literal|0x00802080L
block|,
literal|0x00802081L
block|,
literal|0x00000081L
block|,
literal|0x00800080L
block|,
literal|0x00800001L
block|,
literal|0x00802000L
block|,
literal|0x00802081L
block|,
literal|0x00000081L
block|,
literal|0x00000000L
block|,
literal|0x00000000L
block|,
literal|0x00802000L
block|,
literal|0x00002080L
block|,
literal|0x00800080L
block|,
literal|0x00800081L
block|,
literal|0x00000001L
block|,
literal|0x00802001L
block|,
literal|0x00002081L
block|,
literal|0x00002081L
block|,
literal|0x00000080L
block|,
literal|0x00802081L
block|,
literal|0x00000081L
block|,
literal|0x00000001L
block|,
literal|0x00002000L
block|,
literal|0x00800001L
block|,
literal|0x00002001L
block|,
literal|0x00802080L
block|,
literal|0x00800081L
block|,
literal|0x00002001L
block|,
literal|0x00002080L
block|,
literal|0x00800000L
block|,
literal|0x00802001L
block|,
literal|0x00000080L
block|,
literal|0x00800000L
block|,
literal|0x00002000L
block|,
literal|0x00802080L
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|SP5
index|[
literal|64
index|]
init|=
block|{
literal|0x00000100L
block|,
literal|0x02080100L
block|,
literal|0x02080000L
block|,
literal|0x42000100L
block|,
literal|0x00080000L
block|,
literal|0x00000100L
block|,
literal|0x40000000L
block|,
literal|0x02080000L
block|,
literal|0x40080100L
block|,
literal|0x00080000L
block|,
literal|0x02000100L
block|,
literal|0x40080100L
block|,
literal|0x42000100L
block|,
literal|0x42080000L
block|,
literal|0x00080100L
block|,
literal|0x40000000L
block|,
literal|0x02000000L
block|,
literal|0x40080000L
block|,
literal|0x40080000L
block|,
literal|0x00000000L
block|,
literal|0x40000100L
block|,
literal|0x42080100L
block|,
literal|0x42080100L
block|,
literal|0x02000100L
block|,
literal|0x42080000L
block|,
literal|0x40000100L
block|,
literal|0x00000000L
block|,
literal|0x42000000L
block|,
literal|0x02080100L
block|,
literal|0x02000000L
block|,
literal|0x42000000L
block|,
literal|0x00080100L
block|,
literal|0x00080000L
block|,
literal|0x42000100L
block|,
literal|0x00000100L
block|,
literal|0x02000000L
block|,
literal|0x40000000L
block|,
literal|0x02080000L
block|,
literal|0x42000100L
block|,
literal|0x40080100L
block|,
literal|0x02000100L
block|,
literal|0x40000000L
block|,
literal|0x42080000L
block|,
literal|0x02080100L
block|,
literal|0x40080100L
block|,
literal|0x00000100L
block|,
literal|0x02000000L
block|,
literal|0x42080000L
block|,
literal|0x42080100L
block|,
literal|0x00080100L
block|,
literal|0x42000000L
block|,
literal|0x42080100L
block|,
literal|0x02080000L
block|,
literal|0x00000000L
block|,
literal|0x40080000L
block|,
literal|0x42000000L
block|,
literal|0x00080100L
block|,
literal|0x02000100L
block|,
literal|0x40000100L
block|,
literal|0x00080000L
block|,
literal|0x00000000L
block|,
literal|0x40080000L
block|,
literal|0x02080100L
block|,
literal|0x40000100L
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|SP6
index|[
literal|64
index|]
init|=
block|{
literal|0x20000010L
block|,
literal|0x20400000L
block|,
literal|0x00004000L
block|,
literal|0x20404010L
block|,
literal|0x20400000L
block|,
literal|0x00000010L
block|,
literal|0x20404010L
block|,
literal|0x00400000L
block|,
literal|0x20004000L
block|,
literal|0x00404010L
block|,
literal|0x00400000L
block|,
literal|0x20000010L
block|,
literal|0x00400010L
block|,
literal|0x20004000L
block|,
literal|0x20000000L
block|,
literal|0x00004010L
block|,
literal|0x00000000L
block|,
literal|0x00400010L
block|,
literal|0x20004010L
block|,
literal|0x00004000L
block|,
literal|0x00404000L
block|,
literal|0x20004010L
block|,
literal|0x00000010L
block|,
literal|0x20400010L
block|,
literal|0x20400010L
block|,
literal|0x00000000L
block|,
literal|0x00404010L
block|,
literal|0x20404000L
block|,
literal|0x00004010L
block|,
literal|0x00404000L
block|,
literal|0x20404000L
block|,
literal|0x20000000L
block|,
literal|0x20004000L
block|,
literal|0x00000010L
block|,
literal|0x20400010L
block|,
literal|0x00404000L
block|,
literal|0x20404010L
block|,
literal|0x00400000L
block|,
literal|0x00004010L
block|,
literal|0x20000010L
block|,
literal|0x00400000L
block|,
literal|0x20004000L
block|,
literal|0x20000000L
block|,
literal|0x00004010L
block|,
literal|0x20000010L
block|,
literal|0x20404010L
block|,
literal|0x00404000L
block|,
literal|0x20400000L
block|,
literal|0x00404010L
block|,
literal|0x20404000L
block|,
literal|0x00000000L
block|,
literal|0x20400010L
block|,
literal|0x00000010L
block|,
literal|0x00004000L
block|,
literal|0x20400000L
block|,
literal|0x00404010L
block|,
literal|0x00004000L
block|,
literal|0x00400010L
block|,
literal|0x20004010L
block|,
literal|0x00000000L
block|,
literal|0x20404000L
block|,
literal|0x20000000L
block|,
literal|0x00400010L
block|,
literal|0x20004010L
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|SP7
index|[
literal|64
index|]
init|=
block|{
literal|0x00200000L
block|,
literal|0x04200002L
block|,
literal|0x04000802L
block|,
literal|0x00000000L
block|,
literal|0x00000800L
block|,
literal|0x04000802L
block|,
literal|0x00200802L
block|,
literal|0x04200800L
block|,
literal|0x04200802L
block|,
literal|0x00200000L
block|,
literal|0x00000000L
block|,
literal|0x04000002L
block|,
literal|0x00000002L
block|,
literal|0x04000000L
block|,
literal|0x04200002L
block|,
literal|0x00000802L
block|,
literal|0x04000800L
block|,
literal|0x00200802L
block|,
literal|0x00200002L
block|,
literal|0x04000800L
block|,
literal|0x04000002L
block|,
literal|0x04200000L
block|,
literal|0x04200800L
block|,
literal|0x00200002L
block|,
literal|0x04200000L
block|,
literal|0x00000800L
block|,
literal|0x00000802L
block|,
literal|0x04200802L
block|,
literal|0x00200800L
block|,
literal|0x00000002L
block|,
literal|0x04000000L
block|,
literal|0x00200800L
block|,
literal|0x04000000L
block|,
literal|0x00200800L
block|,
literal|0x00200000L
block|,
literal|0x04000802L
block|,
literal|0x04000802L
block|,
literal|0x04200002L
block|,
literal|0x04200002L
block|,
literal|0x00000002L
block|,
literal|0x00200002L
block|,
literal|0x04000000L
block|,
literal|0x04000800L
block|,
literal|0x00200000L
block|,
literal|0x04200800L
block|,
literal|0x00000802L
block|,
literal|0x00200802L
block|,
literal|0x04200800L
block|,
literal|0x00000802L
block|,
literal|0x04000002L
block|,
literal|0x04200802L
block|,
literal|0x04200000L
block|,
literal|0x00200800L
block|,
literal|0x00000000L
block|,
literal|0x00000002L
block|,
literal|0x04200802L
block|,
literal|0x00000000L
block|,
literal|0x00200802L
block|,
literal|0x04200000L
block|,
literal|0x00000800L
block|,
literal|0x04000002L
block|,
literal|0x04000800L
block|,
literal|0x00000800L
block|,
literal|0x00200002L
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|SP8
index|[
literal|64
index|]
init|=
block|{
literal|0x10001040L
block|,
literal|0x00001000L
block|,
literal|0x00040000L
block|,
literal|0x10041040L
block|,
literal|0x10000000L
block|,
literal|0x10001040L
block|,
literal|0x00000040L
block|,
literal|0x10000000L
block|,
literal|0x00040040L
block|,
literal|0x10040000L
block|,
literal|0x10041040L
block|,
literal|0x00041000L
block|,
literal|0x10041000L
block|,
literal|0x00041040L
block|,
literal|0x00001000L
block|,
literal|0x00000040L
block|,
literal|0x10040000L
block|,
literal|0x10000040L
block|,
literal|0x10001000L
block|,
literal|0x00001040L
block|,
literal|0x00041000L
block|,
literal|0x00040040L
block|,
literal|0x10040040L
block|,
literal|0x10041000L
block|,
literal|0x00001040L
block|,
literal|0x00000000L
block|,
literal|0x00000000L
block|,
literal|0x10040040L
block|,
literal|0x10000040L
block|,
literal|0x10001000L
block|,
literal|0x00041040L
block|,
literal|0x00040000L
block|,
literal|0x00041040L
block|,
literal|0x00040000L
block|,
literal|0x10041000L
block|,
literal|0x00001000L
block|,
literal|0x00000040L
block|,
literal|0x10040040L
block|,
literal|0x00001000L
block|,
literal|0x00041040L
block|,
literal|0x10001000L
block|,
literal|0x00000040L
block|,
literal|0x10000040L
block|,
literal|0x10040000L
block|,
literal|0x10040040L
block|,
literal|0x10000000L
block|,
literal|0x00040000L
block|,
literal|0x10001040L
block|,
literal|0x00000000L
block|,
literal|0x10041040L
block|,
literal|0x00040040L
block|,
literal|0x10000040L
block|,
literal|0x10040000L
block|,
literal|0x10001000L
block|,
literal|0x10001040L
block|,
literal|0x00000000L
block|,
literal|0x10041040L
block|,
literal|0x00041000L
block|,
literal|0x00041000L
block|,
literal|0x00001040L
block|,
literal|0x00001040L
block|,
literal|0x00040040L
block|,
literal|0x10000000L
block|,
literal|0x10041000L
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|IP
parameter_list|(
name|uint32_t
name|v
index|[
literal|2
index|]
parameter_list|)
block|{
name|uint32_t
name|work
decl_stmt|;
name|work
operator|=
operator|(
operator|(
name|v
index|[
literal|0
index|]
operator|>>
literal|4
operator|)
operator|^
name|v
index|[
literal|1
index|]
operator|)
operator|&
literal|0x0f0f0f0fL
expr_stmt|;
name|v
index|[
literal|1
index|]
operator|^=
name|work
expr_stmt|;
name|v
index|[
literal|0
index|]
operator|^=
operator|(
name|work
operator|<<
literal|4
operator|)
expr_stmt|;
name|work
operator|=
operator|(
operator|(
name|v
index|[
literal|0
index|]
operator|>>
literal|16
operator|)
operator|^
name|v
index|[
literal|1
index|]
operator|)
operator|&
literal|0x0000ffffL
expr_stmt|;
name|v
index|[
literal|1
index|]
operator|^=
name|work
expr_stmt|;
name|v
index|[
literal|0
index|]
operator|^=
operator|(
name|work
operator|<<
literal|16
operator|)
expr_stmt|;
name|work
operator|=
operator|(
operator|(
name|v
index|[
literal|1
index|]
operator|>>
literal|2
operator|)
operator|^
name|v
index|[
literal|0
index|]
operator|)
operator|&
literal|0x33333333L
expr_stmt|;
name|v
index|[
literal|0
index|]
operator|^=
name|work
expr_stmt|;
name|v
index|[
literal|1
index|]
operator|^=
operator|(
name|work
operator|<<
literal|2
operator|)
expr_stmt|;
name|work
operator|=
operator|(
operator|(
name|v
index|[
literal|1
index|]
operator|>>
literal|8
operator|)
operator|^
name|v
index|[
literal|0
index|]
operator|)
operator|&
literal|0x00ff00ffL
expr_stmt|;
name|v
index|[
literal|0
index|]
operator|^=
name|work
expr_stmt|;
name|v
index|[
literal|1
index|]
operator|^=
operator|(
name|work
operator|<<
literal|8
operator|)
expr_stmt|;
name|v
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|v
index|[
literal|1
index|]
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|v
index|[
literal|1
index|]
operator|>>
literal|31
operator|)
operator|&
literal|1L
operator|)
operator|)
operator|&
literal|0xffffffffL
expr_stmt|;
name|work
operator|=
operator|(
name|v
index|[
literal|0
index|]
operator|^
name|v
index|[
literal|1
index|]
operator|)
operator|&
literal|0xaaaaaaaaL
expr_stmt|;
name|v
index|[
literal|0
index|]
operator|^=
name|work
expr_stmt|;
name|v
index|[
literal|1
index|]
operator|^=
name|work
expr_stmt|;
name|v
index|[
literal|0
index|]
operator|=
operator|(
operator|(
name|v
index|[
literal|0
index|]
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|v
index|[
literal|0
index|]
operator|>>
literal|31
operator|)
operator|&
literal|1L
operator|)
operator|)
operator|&
literal|0xffffffffL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|FP
parameter_list|(
name|uint32_t
name|v
index|[
literal|2
index|]
parameter_list|)
block|{
name|uint32_t
name|work
decl_stmt|;
name|v
index|[
literal|0
index|]
operator|=
operator|(
name|v
index|[
literal|0
index|]
operator|<<
literal|31
operator|)
operator||
operator|(
name|v
index|[
literal|0
index|]
operator|>>
literal|1
operator|)
expr_stmt|;
name|work
operator|=
operator|(
name|v
index|[
literal|1
index|]
operator|^
name|v
index|[
literal|0
index|]
operator|)
operator|&
literal|0xaaaaaaaaL
expr_stmt|;
name|v
index|[
literal|1
index|]
operator|^=
name|work
expr_stmt|;
name|v
index|[
literal|0
index|]
operator|^=
name|work
expr_stmt|;
name|v
index|[
literal|1
index|]
operator|=
operator|(
name|v
index|[
literal|1
index|]
operator|<<
literal|31
operator|)
operator||
operator|(
name|v
index|[
literal|1
index|]
operator|>>
literal|1
operator|)
expr_stmt|;
name|work
operator|=
operator|(
operator|(
name|v
index|[
literal|1
index|]
operator|>>
literal|8
operator|)
operator|^
name|v
index|[
literal|0
index|]
operator|)
operator|&
literal|0x00ff00ffL
expr_stmt|;
name|v
index|[
literal|0
index|]
operator|^=
name|work
expr_stmt|;
name|v
index|[
literal|1
index|]
operator|^=
operator|(
name|work
operator|<<
literal|8
operator|)
expr_stmt|;
name|work
operator|=
operator|(
operator|(
name|v
index|[
literal|1
index|]
operator|>>
literal|2
operator|)
operator|^
name|v
index|[
literal|0
index|]
operator|)
operator|&
literal|0x33333333L
expr_stmt|;
name|v
index|[
literal|0
index|]
operator|^=
name|work
expr_stmt|;
name|v
index|[
literal|1
index|]
operator|^=
operator|(
name|work
operator|<<
literal|2
operator|)
expr_stmt|;
name|work
operator|=
operator|(
operator|(
name|v
index|[
literal|0
index|]
operator|>>
literal|16
operator|)
operator|^
name|v
index|[
literal|1
index|]
operator|)
operator|&
literal|0x0000ffffL
expr_stmt|;
name|v
index|[
literal|1
index|]
operator|^=
name|work
expr_stmt|;
name|v
index|[
literal|0
index|]
operator|^=
operator|(
name|work
operator|<<
literal|16
operator|)
expr_stmt|;
name|work
operator|=
operator|(
operator|(
name|v
index|[
literal|0
index|]
operator|>>
literal|4
operator|)
operator|^
name|v
index|[
literal|1
index|]
operator|)
operator|&
literal|0x0f0f0f0fL
expr_stmt|;
name|v
index|[
literal|1
index|]
operator|^=
name|work
expr_stmt|;
name|v
index|[
literal|0
index|]
operator|^=
operator|(
name|work
operator|<<
literal|4
operator|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|desx
parameter_list|(
name|uint32_t
name|block
index|[
literal|2
index|]
parameter_list|,
name|DES_key_schedule
modifier|*
name|ks
parameter_list|,
name|int
name|encp
parameter_list|)
block|{
name|uint32_t
modifier|*
name|keys
decl_stmt|;
name|uint32_t
name|fval
decl_stmt|,
name|work
decl_stmt|,
name|right
decl_stmt|,
name|left
decl_stmt|;
name|int
name|round
decl_stmt|;
name|left
operator|=
name|block
index|[
literal|0
index|]
expr_stmt|;
name|right
operator|=
name|block
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|encp
condition|)
block|{
name|keys
operator|=
operator|&
name|ks
operator|->
name|ks
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|round
operator|=
literal|0
init|;
name|round
operator|<
literal|8
condition|;
name|round
operator|++
control|)
block|{
name|work
operator|=
operator|(
name|right
operator|<<
literal|28
operator|)
operator||
operator|(
name|right
operator|>>
literal|4
operator|)
expr_stmt|;
name|work
operator|^=
operator|*
name|keys
operator|++
expr_stmt|;
name|fval
operator|=
name|SP7
index|[
name|work
operator|&
literal|0x3fL
index|]
expr_stmt|;
name|fval
operator||=
name|SP5
index|[
operator|(
name|work
operator|>>
literal|8
operator|)
operator|&
literal|0x3fL
index|]
expr_stmt|;
name|fval
operator||=
name|SP3
index|[
operator|(
name|work
operator|>>
literal|16
operator|)
operator|&
literal|0x3fL
index|]
expr_stmt|;
name|fval
operator||=
name|SP1
index|[
operator|(
name|work
operator|>>
literal|24
operator|)
operator|&
literal|0x3fL
index|]
expr_stmt|;
name|work
operator|=
name|right
operator|^
operator|*
name|keys
operator|++
expr_stmt|;
name|fval
operator||=
name|SP8
index|[
name|work
operator|&
literal|0x3fL
index|]
expr_stmt|;
name|fval
operator||=
name|SP6
index|[
operator|(
name|work
operator|>>
literal|8
operator|)
operator|&
literal|0x3fL
index|]
expr_stmt|;
name|fval
operator||=
name|SP4
index|[
operator|(
name|work
operator|>>
literal|16
operator|)
operator|&
literal|0x3fL
index|]
expr_stmt|;
name|fval
operator||=
name|SP2
index|[
operator|(
name|work
operator|>>
literal|24
operator|)
operator|&
literal|0x3fL
index|]
expr_stmt|;
name|left
operator|^=
name|fval
expr_stmt|;
name|work
operator|=
operator|(
name|left
operator|<<
literal|28
operator|)
operator||
operator|(
name|left
operator|>>
literal|4
operator|)
expr_stmt|;
name|work
operator|^=
operator|*
name|keys
operator|++
expr_stmt|;
name|fval
operator|=
name|SP7
index|[
name|work
operator|&
literal|0x3fL
index|]
expr_stmt|;
name|fval
operator||=
name|SP5
index|[
operator|(
name|work
operator|>>
literal|8
operator|)
operator|&
literal|0x3fL
index|]
expr_stmt|;
name|fval
operator||=
name|SP3
index|[
operator|(
name|work
operator|>>
literal|16
operator|)
operator|&
literal|0x3fL
index|]
expr_stmt|;
name|fval
operator||=
name|SP1
index|[
operator|(
name|work
operator|>>
literal|24
operator|)
operator|&
literal|0x3fL
index|]
expr_stmt|;
name|work
operator|=
name|left
operator|^
operator|*
name|keys
operator|++
expr_stmt|;
name|fval
operator||=
name|SP8
index|[
name|work
operator|&
literal|0x3fL
index|]
expr_stmt|;
name|fval
operator||=
name|SP6
index|[
operator|(
name|work
operator|>>
literal|8
operator|)
operator|&
literal|0x3fL
index|]
expr_stmt|;
name|fval
operator||=
name|SP4
index|[
operator|(
name|work
operator|>>
literal|16
operator|)
operator|&
literal|0x3fL
index|]
expr_stmt|;
name|fval
operator||=
name|SP2
index|[
operator|(
name|work
operator|>>
literal|24
operator|)
operator|&
literal|0x3fL
index|]
expr_stmt|;
name|right
operator|^=
name|fval
expr_stmt|;
block|}
block|}
else|else
block|{
name|keys
operator|=
operator|&
name|ks
operator|->
name|ks
index|[
literal|30
index|]
expr_stmt|;
for|for
control|(
name|round
operator|=
literal|0
init|;
name|round
operator|<
literal|8
condition|;
name|round
operator|++
control|)
block|{
name|work
operator|=
operator|(
name|right
operator|<<
literal|28
operator|)
operator||
operator|(
name|right
operator|>>
literal|4
operator|)
expr_stmt|;
name|work
operator|^=
operator|*
name|keys
operator|++
expr_stmt|;
name|fval
operator|=
name|SP7
index|[
name|work
operator|&
literal|0x3fL
index|]
expr_stmt|;
name|fval
operator||=
name|SP5
index|[
operator|(
name|work
operator|>>
literal|8
operator|)
operator|&
literal|0x3fL
index|]
expr_stmt|;
name|fval
operator||=
name|SP3
index|[
operator|(
name|work
operator|>>
literal|16
operator|)
operator|&
literal|0x3fL
index|]
expr_stmt|;
name|fval
operator||=
name|SP1
index|[
operator|(
name|work
operator|>>
literal|24
operator|)
operator|&
literal|0x3fL
index|]
expr_stmt|;
name|work
operator|=
name|right
operator|^
operator|*
name|keys
operator|++
expr_stmt|;
name|fval
operator||=
name|SP8
index|[
name|work
operator|&
literal|0x3fL
index|]
expr_stmt|;
name|fval
operator||=
name|SP6
index|[
operator|(
name|work
operator|>>
literal|8
operator|)
operator|&
literal|0x3fL
index|]
expr_stmt|;
name|fval
operator||=
name|SP4
index|[
operator|(
name|work
operator|>>
literal|16
operator|)
operator|&
literal|0x3fL
index|]
expr_stmt|;
name|fval
operator||=
name|SP2
index|[
operator|(
name|work
operator|>>
literal|24
operator|)
operator|&
literal|0x3fL
index|]
expr_stmt|;
name|left
operator|^=
name|fval
expr_stmt|;
name|work
operator|=
operator|(
name|left
operator|<<
literal|28
operator|)
operator||
operator|(
name|left
operator|>>
literal|4
operator|)
expr_stmt|;
name|keys
operator|-=
literal|4
expr_stmt|;
name|work
operator|^=
operator|*
name|keys
operator|++
expr_stmt|;
name|fval
operator|=
name|SP7
index|[
name|work
operator|&
literal|0x3fL
index|]
expr_stmt|;
name|fval
operator||=
name|SP5
index|[
operator|(
name|work
operator|>>
literal|8
operator|)
operator|&
literal|0x3fL
index|]
expr_stmt|;
name|fval
operator||=
name|SP3
index|[
operator|(
name|work
operator|>>
literal|16
operator|)
operator|&
literal|0x3fL
index|]
expr_stmt|;
name|fval
operator||=
name|SP1
index|[
operator|(
name|work
operator|>>
literal|24
operator|)
operator|&
literal|0x3fL
index|]
expr_stmt|;
name|work
operator|=
name|left
operator|^
operator|*
name|keys
operator|++
expr_stmt|;
name|fval
operator||=
name|SP8
index|[
name|work
operator|&
literal|0x3fL
index|]
expr_stmt|;
name|fval
operator||=
name|SP6
index|[
operator|(
name|work
operator|>>
literal|8
operator|)
operator|&
literal|0x3fL
index|]
expr_stmt|;
name|fval
operator||=
name|SP4
index|[
operator|(
name|work
operator|>>
literal|16
operator|)
operator|&
literal|0x3fL
index|]
expr_stmt|;
name|fval
operator||=
name|SP2
index|[
operator|(
name|work
operator|>>
literal|24
operator|)
operator|&
literal|0x3fL
index|]
expr_stmt|;
name|right
operator|^=
name|fval
expr_stmt|;
name|keys
operator|-=
literal|4
expr_stmt|;
block|}
block|}
name|block
index|[
literal|0
index|]
operator|=
name|right
expr_stmt|;
name|block
index|[
literal|1
index|]
operator|=
name|left
expr_stmt|;
block|}
end_function

end_unit

