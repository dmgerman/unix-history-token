begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * support.c  *  * Support functions for pam_krb5  *  * $FreeBSD$  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: support.c,v 1.8 2000/01/04 09:50:03 fcusack Exp $"
decl_stmt|;
end_decl_stmt

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* BUFSIZ */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* malloc */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* strncpy */
end_comment

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_comment
comment|/* syslog */
end_comment

begin_include
include|#
directive|include
file|<security/pam_appl.h>
end_include

begin_include
include|#
directive|include
file|<security/pam_modules.h>
end_include

begin_include
include|#
directive|include
file|<krb5.h>
end_include

begin_include
include|#
directive|include
file|<com_err.h>
end_include

begin_include
include|#
directive|include
file|"pam_krb5.h"
end_include

begin_comment
comment|/*  * Get info from the user. Disallow null responses (regardless of flags).  * response gets allocated and filled in on successful return. Caller  * is responsible for freeing it.  */
end_comment

begin_function
name|int
name|get_user_info
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|char
modifier|*
name|prompt
parameter_list|,
name|int
name|type
parameter_list|,
name|char
modifier|*
modifier|*
name|response
parameter_list|)
block|{
name|int
name|pamret
decl_stmt|;
name|struct
name|pam_message
name|msg
decl_stmt|;
specifier|const
name|struct
name|pam_message
modifier|*
name|pmsg
decl_stmt|;
name|struct
name|pam_response
modifier|*
name|resp
init|=
name|NULL
decl_stmt|;
name|struct
name|pam_conv
modifier|*
name|conv
decl_stmt|;
if|if
condition|(
operator|(
name|pamret
operator|=
name|pam_get_item
argument_list|(
name|pamh
argument_list|,
name|PAM_CONV
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
operator|&
name|conv
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|pamret
return|;
comment|/* set up conversation call */
name|pmsg
operator|=
operator|&
name|msg
expr_stmt|;
name|msg
operator|.
name|msg_style
operator|=
name|type
expr_stmt|;
name|msg
operator|.
name|msg
operator|=
name|prompt
expr_stmt|;
if|if
condition|(
operator|(
name|pamret
operator|=
name|conv
operator|->
name|conv
argument_list|(
literal|1
argument_list|,
operator|&
name|pmsg
argument_list|,
operator|&
name|resp
argument_list|,
name|conv
operator|->
name|appdata_ptr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
name|pamret
return|;
comment|/* Caller should ignore errors for non-response conversations */
if|if
condition|(
operator|!
name|resp
condition|)
return|return
name|PAM_CONV_ERR
return|;
if|if
condition|(
operator|!
operator|(
name|resp
operator|->
name|resp
operator|&&
name|resp
operator|->
name|resp
index|[
literal|0
index|]
operator|)
condition|)
block|{
name|free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
return|return
name|PAM_AUTH_ERR
return|;
block|}
operator|*
name|response
operator|=
name|resp
operator|->
name|resp
expr_stmt|;
name|free
argument_list|(
name|resp
argument_list|)
expr_stmt|;
return|return
name|pamret
return|;
block|}
end_function

begin_comment
comment|/*  * This routine with some modification is from the MIT V5B6 appl/bsd/login.c  * Modified by Sam Hartman<hartmans@mit.edu> to support PAM services  * for Debian.  *  * Verify the Kerberos ticket-granting ticket just retrieved for the  * user.  If the Kerberos server doesn't respond, assume the user is  * trying to fake us out (since we DID just get a TGT from what is  * supposedly our KDC).  If the host/<host> service is unknown (i.e.,  * the local keytab doesn't have it), and we cannot find another  * service we do have, let her in.  *  * Returns 1 for confirmation, -1 for failure, 0 for uncertainty.  */
end_comment

begin_function
name|int
name|verify_krb_v5_tgt
parameter_list|(
name|krb5_context
name|context
parameter_list|,
name|krb5_ccache
name|ccache
parameter_list|,
name|char
modifier|*
name|pam_service
parameter_list|,
name|int
name|debug
parameter_list|)
block|{
name|char
name|phost
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|services
index|[
literal|3
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|service
decl_stmt|;
name|krb5_error_code
name|retval
init|=
operator|-
literal|1
decl_stmt|;
name|krb5_principal
name|princ
decl_stmt|;
name|krb5_keyblock
modifier|*
name|keyblock
init|=
literal|0
decl_stmt|;
name|krb5_data
name|packet
decl_stmt|;
name|krb5_auth_context
name|auth_context
init|=
name|NULL
decl_stmt|;
name|packet
operator|.
name|data
operator|=
literal|0
expr_stmt|;
comment|/*     * If possible we want to try and verify the ticket we have     * received against a keytab.  We will try multiple service     * principals, including at least the host principal and the PAM     * service principal.  The host principal is preferred because access     * to that key is generally sufficient to compromise root, while the     *     service key for this PAM service may be less carefully guarded.     * It is important to check the keytab first before the KDC so we do     * not get spoofed by a fake  KDC.*/
name|services
index|[
literal|0
index|]
operator|=
literal|"host"
expr_stmt|;
name|services
index|[
literal|1
index|]
operator|=
name|pam_service
expr_stmt|;
name|services
index|[
literal|2
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|service
operator|=
operator|&
name|services
index|[
literal|0
index|]
init|;
operator|*
name|service
operator|!=
name|NULL
condition|;
name|service
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|retval
operator|=
name|krb5_sname_to_principal
argument_list|(
name|context
argument_list|,
name|NULL
argument_list|,
operator|*
name|service
argument_list|,
name|KRB5_NT_SRV_HST
argument_list|,
operator|&
name|princ
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"pam_krb5: verify_krb_v5_tgt(): %s: %s"
argument_list|,
literal|"krb5_sname_to_principal()"
argument_list|,
name|error_message
argument_list|(
name|retval
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Extract the name directly. */
name|strncpy
argument_list|(
name|phost
argument_list|,
name|compat_princ_component
argument_list|(
name|context
argument_list|,
name|princ
argument_list|,
literal|1
argument_list|)
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
name|phost
index|[
name|BUFSIZ
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/*        * Do we have service/<host> keys?        * (use default/configured keytab, kvno IGNORE_VNO to get the        * first match, and ignore enctype.)        */
if|if
condition|(
operator|(
name|retval
operator|=
name|krb5_kt_read_service_key
argument_list|(
name|context
argument_list|,
name|NULL
argument_list|,
name|princ
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
operator|&
name|keyblock
argument_list|)
operator|)
operator|!=
literal|0
condition|)
continue|continue;
break|break;
block|}
if|if
condition|(
name|retval
operator|!=
literal|0
condition|)
block|{
comment|/* failed to find key */
comment|/* Keytab or service key does not exist */
if|if
condition|(
name|debug
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"pam_krb5: verify_krb_v5_tgt(): %s: %s"
argument_list|,
literal|"krb5_kt_read_service_key()"
argument_list|,
name|error_message
argument_list|(
name|retval
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|keyblock
condition|)
name|krb5_free_keyblock
argument_list|(
name|context
argument_list|,
name|keyblock
argument_list|)
expr_stmt|;
comment|/* Talk to the kdc and construct the ticket. */
name|retval
operator|=
name|krb5_mk_req
argument_list|(
name|context
argument_list|,
operator|&
name|auth_context
argument_list|,
literal|0
argument_list|,
operator|*
name|service
argument_list|,
name|phost
argument_list|,
name|NULL
argument_list|,
name|ccache
argument_list|,
operator|&
name|packet
argument_list|)
expr_stmt|;
if|if
condition|(
name|auth_context
condition|)
block|{
name|krb5_auth_con_free
argument_list|(
name|context
argument_list|,
name|auth_context
argument_list|)
expr_stmt|;
name|auth_context
operator|=
name|NULL
expr_stmt|;
comment|/* setup for rd_req */
block|}
if|if
condition|(
name|retval
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"pam_krb5: verify_krb_v5_tgt(): %s: %s"
argument_list|,
literal|"krb5_mk_req()"
argument_list|,
name|error_message
argument_list|(
name|retval
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* Try to use the ticket. */
name|retval
operator|=
name|krb5_rd_req
argument_list|(
name|context
argument_list|,
operator|&
name|auth_context
argument_list|,
operator|&
name|packet
argument_list|,
name|princ
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
condition|)
block|{
if|if
condition|(
name|debug
condition|)
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"pam_krb5: verify_krb_v5_tgt(): %s: %s"
argument_list|,
literal|"krb5_rd_req()"
argument_list|,
name|error_message
argument_list|(
name|retval
argument_list|)
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|retval
operator|=
literal|1
expr_stmt|;
block|}
name|cleanup
label|:
if|if
condition|(
name|packet
operator|.
name|data
condition|)
name|compat_free_data_contents
argument_list|(
name|context
argument_list|,
operator|&
name|packet
argument_list|)
expr_stmt|;
name|krb5_free_principal
argument_list|(
name|context
argument_list|,
name|princ
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/* Free the memory for cache_name. Called by pam_end() */
end_comment

begin_function
name|void
name|cleanup_cache
parameter_list|(
name|pam_handle_t
modifier|*
name|pamh
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|pam_end_status
parameter_list|)
block|{
name|krb5_context
name|pam_context
decl_stmt|;
name|krb5_ccache
name|ccache
decl_stmt|;
if|if
condition|(
name|krb5_init_context
argument_list|(
operator|&
name|pam_context
argument_list|)
condition|)
return|return;
name|ccache
operator|=
operator|(
name|krb5_ccache
operator|)
name|data
expr_stmt|;
operator|(
name|void
operator|)
name|krb5_cc_destroy
argument_list|(
name|pam_context
argument_list|,
name|ccache
argument_list|)
expr_stmt|;
name|krb5_free_context
argument_list|(
name|pam_context
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

