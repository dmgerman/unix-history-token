begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- LLVMContextImpl.h - The LLVMContextImpl opaque class --------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file declares LLVMContextImpl, the opaque implementation
end_comment

begin_comment
comment|//  of LLVMContext.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_LLVMCONTEXT_IMPL_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_LLVMCONTEXT_IMPL_H
end_define

begin_include
include|#
directive|include
file|"ConstantsContext.h"
end_include

begin_include
include|#
directive|include
file|"LeaksContext.h"
end_include

begin_include
include|#
directive|include
file|"TypesContext.h"
end_include

begin_include
include|#
directive|include
file|"llvm/LLVMContext.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Metadata.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Constants.h"
end_include

begin_include
include|#
directive|include
file|"llvm/DerivedTypes.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Assembly/Writer.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/ValueHandle.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/APFloat.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/APInt.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/FoldingSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallPtrSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/StringMap.h"
end_include

begin_include
include|#
directive|include
file|<vector>
end_include

begin_decl_stmt
name|namespace
name|llvm
block|{
name|class
name|ConstantInt
decl_stmt|;
name|class
name|ConstantFP
decl_stmt|;
name|class
name|MDString
decl_stmt|;
name|class
name|MDNode
decl_stmt|;
name|class
name|LLVMContext
decl_stmt|;
name|class
name|Type
decl_stmt|;
name|class
name|Value
decl_stmt|;
struct|struct
name|DenseMapAPIntKeyInfo
block|{
struct|struct
name|KeyTy
block|{
name|APInt
name|val
decl_stmt|;
specifier|const
name|Type
modifier|*
name|type
decl_stmt|;
name|KeyTy
argument_list|(
specifier|const
name|APInt
operator|&
name|V
argument_list|,
specifier|const
name|Type
operator|*
name|Ty
argument_list|)
operator|:
name|val
argument_list|(
name|V
argument_list|)
operator|,
name|type
argument_list|(
argument|Ty
argument_list|)
block|{}
name|KeyTy
argument_list|(
specifier|const
name|KeyTy
operator|&
name|that
argument_list|)
operator|:
name|val
argument_list|(
name|that
operator|.
name|val
argument_list|)
operator|,
name|type
argument_list|(
argument|that.type
argument_list|)
block|{}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|KeyTy
operator|&
name|that
operator|)
specifier|const
block|{
return|return
name|type
operator|==
name|that
operator|.
name|type
operator|&&
name|this
operator|->
name|val
operator|==
name|that
operator|.
name|val
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|KeyTy
operator|&
name|that
operator|)
specifier|const
block|{
return|return
operator|!
name|this
operator|->
name|operator
operator|==
operator|(
name|that
operator|)
return|;
block|}
block|}
struct|;
specifier|static
specifier|inline
name|KeyTy
name|getEmptyKey
parameter_list|()
block|{
return|return
name|KeyTy
argument_list|(
name|APInt
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|KeyTy
name|getTombstoneKey
parameter_list|()
block|{
return|return
name|KeyTy
argument_list|(
name|APInt
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
argument_list|,
literal|0
argument_list|)
return|;
block|}
specifier|static
name|unsigned
name|getHashValue
parameter_list|(
specifier|const
name|KeyTy
modifier|&
name|Key
parameter_list|)
block|{
return|return
name|DenseMapInfo
operator|<
name|void
operator|*
operator|>
operator|::
name|getHashValue
argument_list|(
name|Key
operator|.
name|type
argument_list|)
operator|^
name|Key
operator|.
name|val
operator|.
name|getHashValue
argument_list|()
return|;
block|}
specifier|static
name|bool
name|isEqual
parameter_list|(
specifier|const
name|KeyTy
modifier|&
name|LHS
parameter_list|,
specifier|const
name|KeyTy
modifier|&
name|RHS
parameter_list|)
block|{
return|return
name|LHS
operator|==
name|RHS
return|;
block|}
block|}
struct|;
struct|struct
name|DenseMapAPFloatKeyInfo
block|{
struct|struct
name|KeyTy
block|{
name|APFloat
name|val
decl_stmt|;
name|KeyTy
argument_list|(
specifier|const
name|APFloat
operator|&
name|V
argument_list|)
operator|:
name|val
argument_list|(
argument|V
argument_list|)
block|{}
name|KeyTy
argument_list|(
specifier|const
name|KeyTy
operator|&
name|that
argument_list|)
operator|:
name|val
argument_list|(
argument|that.val
argument_list|)
block|{}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|KeyTy
operator|&
name|that
operator|)
specifier|const
block|{
return|return
name|this
operator|->
name|val
operator|.
name|bitwiseIsEqual
argument_list|(
name|that
operator|.
name|val
argument_list|)
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|KeyTy
operator|&
name|that
operator|)
specifier|const
block|{
return|return
operator|!
name|this
operator|->
name|operator
operator|==
operator|(
name|that
operator|)
return|;
block|}
block|}
struct|;
specifier|static
specifier|inline
name|KeyTy
name|getEmptyKey
parameter_list|()
block|{
return|return
name|KeyTy
argument_list|(
name|APFloat
argument_list|(
name|APFloat
operator|::
name|Bogus
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
specifier|static
specifier|inline
name|KeyTy
name|getTombstoneKey
parameter_list|()
block|{
return|return
name|KeyTy
argument_list|(
name|APFloat
argument_list|(
name|APFloat
operator|::
name|Bogus
argument_list|,
literal|2
argument_list|)
argument_list|)
return|;
block|}
specifier|static
name|unsigned
name|getHashValue
parameter_list|(
specifier|const
name|KeyTy
modifier|&
name|Key
parameter_list|)
block|{
return|return
name|Key
operator|.
name|val
operator|.
name|getHashValue
argument_list|()
return|;
block|}
specifier|static
name|bool
name|isEqual
parameter_list|(
specifier|const
name|KeyTy
modifier|&
name|LHS
parameter_list|,
specifier|const
name|KeyTy
modifier|&
name|RHS
parameter_list|)
block|{
return|return
name|LHS
operator|==
name|RHS
return|;
block|}
block|}
struct|;
name|class
name|LLVMContextImpl
block|{
name|public
label|:
typedef|typedef
name|DenseMap
operator|<
name|DenseMapAPIntKeyInfo
operator|::
name|KeyTy
operator|,
name|ConstantInt
operator|*
operator|,
name|DenseMapAPIntKeyInfo
operator|>
name|IntMapTy
expr_stmt|;
name|IntMapTy
name|IntConstants
decl_stmt|;
typedef|typedef
name|DenseMap
operator|<
name|DenseMapAPFloatKeyInfo
operator|::
name|KeyTy
operator|,
name|ConstantFP
operator|*
operator|,
name|DenseMapAPFloatKeyInfo
operator|>
name|FPMapTy
expr_stmt|;
name|FPMapTy
name|FPConstants
decl_stmt|;
name|StringMap
operator|<
name|MDString
operator|*
operator|>
name|MDStringCache
expr_stmt|;
name|FoldingSet
operator|<
name|MDNode
operator|>
name|MDNodeSet
expr_stmt|;
name|ConstantUniqueMap
operator|<
name|char
operator|,
name|Type
operator|,
name|ConstantAggregateZero
operator|>
name|AggZeroConstants
expr_stmt|;
typedef|typedef
name|ConstantUniqueMap
operator|<
name|std
operator|::
name|vector
operator|<
name|Constant
operator|*
operator|>
operator|,
name|ArrayType
operator|,
name|ConstantArray
operator|,
name|true
comment|/*largekey*/
operator|>
name|ArrayConstantsTy
expr_stmt|;
name|ArrayConstantsTy
name|ArrayConstants
decl_stmt|;
typedef|typedef
name|ConstantUniqueMap
operator|<
name|std
operator|::
name|vector
operator|<
name|Constant
operator|*
operator|>
operator|,
name|StructType
operator|,
name|ConstantStruct
operator|,
name|true
comment|/*largekey*/
operator|>
name|StructConstantsTy
expr_stmt|;
name|StructConstantsTy
name|StructConstants
decl_stmt|;
typedef|typedef
name|ConstantUniqueMap
operator|<
name|Constant
operator|*
operator|,
name|UnionType
operator|,
name|ConstantUnion
operator|>
name|UnionConstantsTy
expr_stmt|;
name|UnionConstantsTy
name|UnionConstants
decl_stmt|;
typedef|typedef
name|ConstantUniqueMap
operator|<
name|std
operator|::
name|vector
operator|<
name|Constant
operator|*
operator|>
operator|,
name|VectorType
operator|,
name|ConstantVector
operator|>
name|VectorConstantsTy
expr_stmt|;
name|VectorConstantsTy
name|VectorConstants
decl_stmt|;
name|ConstantUniqueMap
operator|<
name|char
operator|,
name|PointerType
operator|,
name|ConstantPointerNull
operator|>
name|NullPtrConstants
expr_stmt|;
name|ConstantUniqueMap
operator|<
name|char
operator|,
name|Type
operator|,
name|UndefValue
operator|>
name|UndefValueConstants
expr_stmt|;
name|DenseMap
operator|<
name|std
operator|::
name|pair
operator|<
name|Function
operator|*
operator|,
name|BasicBlock
operator|*
operator|>
operator|,
name|BlockAddress
operator|*
operator|>
name|BlockAddresses
expr_stmt|;
name|ConstantUniqueMap
operator|<
name|ExprMapKeyType
operator|,
name|Type
operator|,
name|ConstantExpr
operator|>
name|ExprConstants
expr_stmt|;
name|ConstantInt
modifier|*
name|TheTrueVal
decl_stmt|;
name|ConstantInt
modifier|*
name|TheFalseVal
decl_stmt|;
name|LeakDetectorImpl
operator|<
name|Value
operator|>
name|LLVMObjects
expr_stmt|;
comment|// Basic type instances.
specifier|const
name|Type
name|VoidTy
decl_stmt|;
specifier|const
name|Type
name|LabelTy
decl_stmt|;
specifier|const
name|Type
name|FloatTy
decl_stmt|;
specifier|const
name|Type
name|DoubleTy
decl_stmt|;
specifier|const
name|Type
name|MetadataTy
decl_stmt|;
specifier|const
name|Type
name|X86_FP80Ty
decl_stmt|;
specifier|const
name|Type
name|FP128Ty
decl_stmt|;
specifier|const
name|Type
name|PPC_FP128Ty
decl_stmt|;
specifier|const
name|IntegerType
name|Int1Ty
decl_stmt|;
specifier|const
name|IntegerType
name|Int8Ty
decl_stmt|;
specifier|const
name|IntegerType
name|Int16Ty
decl_stmt|;
specifier|const
name|IntegerType
name|Int32Ty
decl_stmt|;
specifier|const
name|IntegerType
name|Int64Ty
decl_stmt|;
comment|// Concrete/Abstract TypeDescriptions - We lazily calculate type descriptions
comment|// for types as they are needed.  Because resolution of types must invalidate
comment|// all of the abstract type descriptions, we keep them in a seperate map to
comment|// make this easy.
name|TypePrinting
name|ConcreteTypeDescriptions
decl_stmt|;
name|TypePrinting
name|AbstractTypeDescriptions
decl_stmt|;
name|TypeMap
operator|<
name|ArrayValType
operator|,
name|ArrayType
operator|>
name|ArrayTypes
expr_stmt|;
name|TypeMap
operator|<
name|VectorValType
operator|,
name|VectorType
operator|>
name|VectorTypes
expr_stmt|;
name|TypeMap
operator|<
name|PointerValType
operator|,
name|PointerType
operator|>
name|PointerTypes
expr_stmt|;
name|TypeMap
operator|<
name|FunctionValType
operator|,
name|FunctionType
operator|>
name|FunctionTypes
expr_stmt|;
name|TypeMap
operator|<
name|StructValType
operator|,
name|StructType
operator|>
name|StructTypes
expr_stmt|;
name|TypeMap
operator|<
name|UnionValType
operator|,
name|UnionType
operator|>
name|UnionTypes
expr_stmt|;
name|TypeMap
operator|<
name|IntegerValType
operator|,
name|IntegerType
operator|>
name|IntegerTypes
expr_stmt|;
comment|// Opaque types are not structurally uniqued, so don't use TypeMap.
typedef|typedef
name|SmallPtrSet
operator|<
specifier|const
name|OpaqueType
operator|*
operator|,
literal|8
operator|>
name|OpaqueTypesTy
expr_stmt|;
name|OpaqueTypesTy
name|OpaqueTypes
decl_stmt|;
comment|/// Used as an abstract type that will never be resolved.
name|OpaqueType
modifier|*
specifier|const
name|AlwaysOpaqueTy
decl_stmt|;
comment|/// ValueHandles - This map keeps track of all of the value handles that are
comment|/// watching a Value*.  The Value::HasValueHandle bit is used to know
comment|// whether or not a value has an entry in this map.
typedef|typedef
name|DenseMap
operator|<
name|Value
operator|*
operator|,
name|ValueHandleBase
operator|*
operator|>
name|ValueHandlesTy
expr_stmt|;
name|ValueHandlesTy
name|ValueHandles
decl_stmt|;
comment|/// CustomMDKindNames - Map to hold the metadata string to ID mapping.
name|StringMap
operator|<
name|unsigned
operator|>
name|CustomMDKindNames
expr_stmt|;
typedef|typedef
name|std
operator|::
name|pair
operator|<
name|unsigned
operator|,
name|TrackingVH
operator|<
name|MDNode
operator|>
expr|>
name|MDPairTy
expr_stmt|;
typedef|typedef
name|SmallVector
operator|<
name|MDPairTy
operator|,
literal|2
operator|>
name|MDMapTy
expr_stmt|;
comment|/// MetadataStore - Collection of per-instruction metadata used in this
comment|/// context.
name|DenseMap
operator|<
specifier|const
name|Instruction
operator|*
operator|,
name|MDMapTy
operator|>
name|MetadataStore
expr_stmt|;
name|LLVMContextImpl
argument_list|(
name|LLVMContext
operator|&
name|C
argument_list|)
operator|:
name|TheTrueVal
argument_list|(
literal|0
argument_list|)
operator|,
name|TheFalseVal
argument_list|(
literal|0
argument_list|)
operator|,
name|VoidTy
argument_list|(
name|C
argument_list|,
name|Type
operator|::
name|VoidTyID
argument_list|)
operator|,
name|LabelTy
argument_list|(
name|C
argument_list|,
name|Type
operator|::
name|LabelTyID
argument_list|)
operator|,
name|FloatTy
argument_list|(
name|C
argument_list|,
name|Type
operator|::
name|FloatTyID
argument_list|)
operator|,
name|DoubleTy
argument_list|(
name|C
argument_list|,
name|Type
operator|::
name|DoubleTyID
argument_list|)
operator|,
name|MetadataTy
argument_list|(
name|C
argument_list|,
name|Type
operator|::
name|MetadataTyID
argument_list|)
operator|,
name|X86_FP80Ty
argument_list|(
name|C
argument_list|,
name|Type
operator|::
name|X86_FP80TyID
argument_list|)
operator|,
name|FP128Ty
argument_list|(
name|C
argument_list|,
name|Type
operator|::
name|FP128TyID
argument_list|)
operator|,
name|PPC_FP128Ty
argument_list|(
name|C
argument_list|,
name|Type
operator|::
name|PPC_FP128TyID
argument_list|)
operator|,
name|Int1Ty
argument_list|(
name|C
argument_list|,
literal|1
argument_list|)
operator|,
name|Int8Ty
argument_list|(
name|C
argument_list|,
literal|8
argument_list|)
operator|,
name|Int16Ty
argument_list|(
name|C
argument_list|,
literal|16
argument_list|)
operator|,
name|Int32Ty
argument_list|(
name|C
argument_list|,
literal|32
argument_list|)
operator|,
name|Int64Ty
argument_list|(
name|C
argument_list|,
literal|64
argument_list|)
operator|,
name|AlwaysOpaqueTy
argument_list|(
argument|new OpaqueType(C)
argument_list|)
block|{
comment|// Make sure the AlwaysOpaqueTy stays alive as long as the Context.
name|AlwaysOpaqueTy
operator|->
name|addRef
argument_list|()
block|;
name|OpaqueTypes
operator|.
name|insert
argument_list|(
name|AlwaysOpaqueTy
argument_list|)
block|;   }
operator|~
name|LLVMContextImpl
argument_list|()
block|{
name|ExprConstants
operator|.
name|freeConstants
argument_list|()
block|;
name|ArrayConstants
operator|.
name|freeConstants
argument_list|()
block|;
name|StructConstants
operator|.
name|freeConstants
argument_list|()
block|;
name|VectorConstants
operator|.
name|freeConstants
argument_list|()
block|;
name|AggZeroConstants
operator|.
name|freeConstants
argument_list|()
block|;
name|NullPtrConstants
operator|.
name|freeConstants
argument_list|()
block|;
name|UndefValueConstants
operator|.
name|freeConstants
argument_list|()
block|;
for|for
control|(
name|IntMapTy
operator|::
name|iterator
name|I
operator|=
name|IntConstants
operator|.
name|begin
argument_list|()
operator|,
name|E
operator|=
name|IntConstants
operator|.
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
if|if
condition|(
name|I
operator|->
name|second
operator|->
name|use_empty
argument_list|()
condition|)
name|delete
name|I
operator|->
name|second
decl_stmt|;
block|}
for|for
control|(
name|FPMapTy
operator|::
name|iterator
name|I
operator|=
name|FPConstants
operator|.
name|begin
argument_list|()
operator|,
name|E
operator|=
name|FPConstants
operator|.
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
if|if
condition|(
name|I
operator|->
name|second
operator|->
name|use_empty
argument_list|()
condition|)
name|delete
name|I
operator|->
name|second
decl_stmt|;
block|}
name|MDNodeSet
operator|.
name|clear
argument_list|()
expr_stmt|;
name|AlwaysOpaqueTy
operator|->
name|dropRef
argument_list|()
expr_stmt|;
for|for
control|(
name|OpaqueTypesTy
operator|::
name|iterator
name|I
operator|=
name|OpaqueTypes
operator|.
name|begin
argument_list|()
operator|,
name|E
operator|=
name|OpaqueTypes
operator|.
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
operator|(
operator|*
name|I
operator|)
operator|->
name|AbstractTypeUsers
operator|.
name|clear
argument_list|()
expr_stmt|;
name|delete
modifier|*
name|I
decl_stmt|;
block|}
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_endif
unit|}
endif|#
directive|endif
end_endif

end_unit

