begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===-- TypesContext.h - Types-related Context Internals ------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file defines various helper methods and classes used by
end_comment

begin_comment
comment|// LLVMContextImpl for creating and managing types.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_TYPESCONTEXT_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_TYPESCONTEXT_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/STLExtras.h"
end_include

begin_include
include|#
directive|include
file|<map>
end_include

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//                       Derived Type Factory Functions
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_decl_stmt
name|namespace
name|llvm
block|{
comment|/// getSubElementHash - Generate a hash value for all of the SubType's of this
comment|/// type.  The hash value is guaranteed to be zero if any of the subtypes are
comment|/// an opaque type.  Otherwise we try to mix them in as well as possible, but do
comment|/// not look at the subtype's subtype's.
specifier|static
name|unsigned
name|getSubElementHash
parameter_list|(
specifier|const
name|Type
modifier|*
name|Ty
parameter_list|)
block|{
name|unsigned
name|HashVal
init|=
literal|0
decl_stmt|;
for|for
control|(
name|Type
operator|::
name|subtype_iterator
name|I
operator|=
name|Ty
operator|->
name|subtype_begin
argument_list|()
operator|,
name|E
operator|=
name|Ty
operator|->
name|subtype_end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|HashVal
operator|*=
literal|32
expr_stmt|;
specifier|const
name|Type
modifier|*
name|SubTy
init|=
name|I
operator|->
name|get
argument_list|()
decl_stmt|;
name|HashVal
operator|+=
name|SubTy
operator|->
name|getTypeID
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|SubTy
operator|->
name|getTypeID
argument_list|()
condition|)
block|{
default|default:
break|break;
case|case
name|Type
operator|::
name|OpaqueTyID
case|:
return|return
literal|0
return|;
comment|// Opaque -> hash = 0 no matter what.
case|case
name|Type
operator|::
name|IntegerTyID
case|:
name|HashVal
operator|^=
operator|(
name|cast
operator|<
name|IntegerType
operator|>
operator|(
name|SubTy
operator|)
operator|->
name|getBitWidth
argument_list|()
operator|<<
literal|3
operator|)
expr_stmt|;
break|break;
case|case
name|Type
operator|::
name|FunctionTyID
case|:
name|HashVal
operator|^=
name|cast
operator|<
name|FunctionType
operator|>
operator|(
name|SubTy
operator|)
operator|->
name|getNumParams
argument_list|()
operator|*
literal|2
operator|+
name|cast
operator|<
name|FunctionType
operator|>
operator|(
name|SubTy
operator|)
operator|->
name|isVarArg
argument_list|()
expr_stmt|;
break|break;
case|case
name|Type
operator|::
name|ArrayTyID
case|:
name|HashVal
operator|^=
name|cast
operator|<
name|ArrayType
operator|>
operator|(
name|SubTy
operator|)
operator|->
name|getNumElements
argument_list|()
expr_stmt|;
break|break;
case|case
name|Type
operator|::
name|VectorTyID
case|:
name|HashVal
operator|^=
name|cast
operator|<
name|VectorType
operator|>
operator|(
name|SubTy
operator|)
operator|->
name|getNumElements
argument_list|()
expr_stmt|;
break|break;
case|case
name|Type
operator|::
name|StructTyID
case|:
name|HashVal
operator|^=
name|cast
operator|<
name|StructType
operator|>
operator|(
name|SubTy
operator|)
operator|->
name|getNumElements
argument_list|()
expr_stmt|;
break|break;
case|case
name|Type
operator|::
name|PointerTyID
case|:
name|HashVal
operator|^=
name|cast
operator|<
name|PointerType
operator|>
operator|(
name|SubTy
operator|)
operator|->
name|getAddressSpace
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
return|return
name|HashVal
condition|?
name|HashVal
else|:
literal|1
return|;
comment|// Do not return zero unless opaque subty.
block|}
comment|//===----------------------------------------------------------------------===//
comment|// Integer Type Factory...
comment|//
name|class
name|IntegerValType
block|{
name|uint32_t
name|bits
decl_stmt|;
name|public
label|:
name|IntegerValType
argument_list|(
argument|uint16_t numbits
argument_list|)
block|:
name|bits
argument_list|(
argument|numbits
argument_list|)
block|{}
specifier|static
name|IntegerValType
name|get
parameter_list|(
specifier|const
name|IntegerType
modifier|*
name|Ty
parameter_list|)
block|{
return|return
name|IntegerValType
argument_list|(
name|Ty
operator|->
name|getBitWidth
argument_list|()
argument_list|)
return|;
block|}
specifier|static
name|unsigned
name|hashTypeStructure
parameter_list|(
specifier|const
name|IntegerType
modifier|*
name|Ty
parameter_list|)
block|{
return|return
operator|(
name|unsigned
operator|)
name|Ty
operator|->
name|getBitWidth
argument_list|()
return|;
block|}
specifier|inline
name|bool
name|operator
operator|<
operator|(
specifier|const
name|IntegerValType
operator|&
name|IVT
operator|)
specifier|const
block|{
return|return
name|bits
operator|<
name|IVT
operator|.
name|bits
return|;
block|}
block|}
empty_stmt|;
comment|// PointerValType - Define a class to hold the key that goes into the TypeMap
comment|//
name|class
name|PointerValType
block|{
specifier|const
name|Type
modifier|*
name|ValTy
decl_stmt|;
name|unsigned
name|AddressSpace
decl_stmt|;
name|public
label|:
name|PointerValType
argument_list|(
argument|const Type *val
argument_list|,
argument|unsigned as
argument_list|)
block|:
name|ValTy
argument_list|(
name|val
argument_list|)
operator|,
name|AddressSpace
argument_list|(
argument|as
argument_list|)
block|{}
specifier|static
name|PointerValType
name|get
argument_list|(
argument|const PointerType *PT
argument_list|)
block|{
return|return
name|PointerValType
argument_list|(
name|PT
operator|->
name|getElementType
argument_list|()
argument_list|,
name|PT
operator|->
name|getAddressSpace
argument_list|()
argument_list|)
return|;
block|}
specifier|static
name|unsigned
name|hashTypeStructure
parameter_list|(
specifier|const
name|PointerType
modifier|*
name|PT
parameter_list|)
block|{
return|return
name|getSubElementHash
argument_list|(
name|PT
argument_list|)
return|;
block|}
name|bool
name|operator
operator|<
operator|(
specifier|const
name|PointerValType
operator|&
name|MTV
operator|)
specifier|const
block|{
if|if
condition|(
name|AddressSpace
operator|<
name|MTV
operator|.
name|AddressSpace
condition|)
return|return
name|true
return|;
return|return
name|AddressSpace
operator|==
name|MTV
operator|.
name|AddressSpace
operator|&&
name|ValTy
operator|<
name|MTV
operator|.
name|ValTy
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// Array Type Factory...
end_comment

begin_comment
comment|//
end_comment

begin_decl_stmt
name|class
name|ArrayValType
block|{
specifier|const
name|Type
modifier|*
name|ValTy
decl_stmt|;
name|uint64_t
name|Size
decl_stmt|;
name|public
label|:
name|ArrayValType
argument_list|(
argument|const Type *val
argument_list|,
argument|uint64_t sz
argument_list|)
block|:
name|ValTy
argument_list|(
name|val
argument_list|)
operator|,
name|Size
argument_list|(
argument|sz
argument_list|)
block|{}
specifier|static
name|ArrayValType
name|get
argument_list|(
argument|const ArrayType *AT
argument_list|)
block|{
return|return
name|ArrayValType
argument_list|(
name|AT
operator|->
name|getElementType
argument_list|()
argument_list|,
name|AT
operator|->
name|getNumElements
argument_list|()
argument_list|)
return|;
block|}
specifier|static
name|unsigned
name|hashTypeStructure
parameter_list|(
specifier|const
name|ArrayType
modifier|*
name|AT
parameter_list|)
block|{
return|return
operator|(
name|unsigned
operator|)
name|AT
operator|->
name|getNumElements
argument_list|()
return|;
block|}
specifier|inline
name|bool
name|operator
operator|<
operator|(
specifier|const
name|ArrayValType
operator|&
name|MTV
operator|)
specifier|const
block|{
if|if
condition|(
name|Size
operator|<
name|MTV
operator|.
name|Size
condition|)
return|return
name|true
return|;
return|return
name|Size
operator|==
name|MTV
operator|.
name|Size
operator|&&
name|ValTy
operator|<
name|MTV
operator|.
name|ValTy
return|;
block|}
end_decl_stmt

begin_comment
unit|};
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// Vector Type Factory...
end_comment

begin_comment
comment|//
end_comment

begin_decl_stmt
name|class
name|VectorValType
block|{
specifier|const
name|Type
modifier|*
name|ValTy
decl_stmt|;
name|unsigned
name|Size
decl_stmt|;
name|public
label|:
name|VectorValType
argument_list|(
argument|const Type *val
argument_list|,
argument|int sz
argument_list|)
block|:
name|ValTy
argument_list|(
name|val
argument_list|)
operator|,
name|Size
argument_list|(
argument|sz
argument_list|)
block|{}
specifier|static
name|VectorValType
name|get
argument_list|(
argument|const VectorType *PT
argument_list|)
block|{
return|return
name|VectorValType
argument_list|(
name|PT
operator|->
name|getElementType
argument_list|()
argument_list|,
name|PT
operator|->
name|getNumElements
argument_list|()
argument_list|)
return|;
block|}
specifier|static
name|unsigned
name|hashTypeStructure
parameter_list|(
specifier|const
name|VectorType
modifier|*
name|PT
parameter_list|)
block|{
return|return
name|PT
operator|->
name|getNumElements
argument_list|()
return|;
block|}
specifier|inline
name|bool
name|operator
operator|<
operator|(
specifier|const
name|VectorValType
operator|&
name|MTV
operator|)
specifier|const
block|{
if|if
condition|(
name|Size
operator|<
name|MTV
operator|.
name|Size
condition|)
return|return
name|true
return|;
return|return
name|Size
operator|==
name|MTV
operator|.
name|Size
operator|&&
name|ValTy
operator|<
name|MTV
operator|.
name|ValTy
return|;
block|}
end_decl_stmt

begin_comment
unit|};
comment|// StructValType - Define a class to hold the key that goes into the TypeMap
end_comment

begin_comment
comment|//
end_comment

begin_decl_stmt
name|class
name|StructValType
block|{
name|std
operator|::
name|vector
operator|<
specifier|const
name|Type
operator|*
operator|>
name|ElTypes
expr_stmt|;
name|bool
name|packed
decl_stmt|;
name|public
label|:
name|StructValType
argument_list|(
argument|const std::vector<const Type*>&args
argument_list|,
argument|bool isPacked
argument_list|)
block|:
name|ElTypes
argument_list|(
name|args
argument_list|)
operator|,
name|packed
argument_list|(
argument|isPacked
argument_list|)
block|{}
specifier|static
name|StructValType
name|get
argument_list|(
argument|const StructType *ST
argument_list|)
block|{
name|std
operator|::
name|vector
operator|<
specifier|const
name|Type
operator|*
operator|>
name|ElTypes
block|;
name|ElTypes
operator|.
name|reserve
argument_list|(
name|ST
operator|->
name|getNumElements
argument_list|()
argument_list|)
block|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|ST
operator|->
name|getNumElements
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
name|ElTypes
operator|.
name|push_back
argument_list|(
name|ST
operator|->
name|getElementType
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|StructValType
argument_list|(
name|ElTypes
argument_list|,
name|ST
operator|->
name|isPacked
argument_list|()
argument_list|)
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|unsigned
name|hashTypeStructure
parameter_list|(
specifier|const
name|StructType
modifier|*
name|ST
parameter_list|)
block|{
return|return
name|ST
operator|->
name|getNumElements
argument_list|()
return|;
block|}
end_function

begin_expr_stmt
specifier|inline
name|bool
name|operator
operator|<
operator|(
specifier|const
name|StructValType
operator|&
name|STV
operator|)
specifier|const
block|{
if|if
condition|(
name|ElTypes
operator|<
name|STV
operator|.
name|ElTypes
condition|)
return|return
name|true
return|;
elseif|else
if|if
condition|(
name|ElTypes
operator|>
name|STV
operator|.
name|ElTypes
condition|)
return|return
name|false
return|;
else|else
return|return
operator|(
name|int
operator|)
name|packed
operator|<
operator|(
name|int
operator|)
name|STV
operator|.
name|packed
return|;
block|}
end_expr_stmt

begin_comment
unit|};
comment|// FunctionValType - Define a class to hold the key that goes into the TypeMap
end_comment

begin_comment
comment|//
end_comment

begin_decl_stmt
name|class
name|FunctionValType
block|{
specifier|const
name|Type
modifier|*
name|RetTy
decl_stmt|;
name|std
operator|::
name|vector
operator|<
specifier|const
name|Type
operator|*
operator|>
name|ArgTypes
expr_stmt|;
name|bool
name|isVarArg
decl_stmt|;
name|public
label|:
name|FunctionValType
argument_list|(
argument|const Type *ret
argument_list|,
argument|const std::vector<const Type*>&args
argument_list|,
argument|bool isVA
argument_list|)
block|:
name|RetTy
argument_list|(
name|ret
argument_list|)
operator|,
name|ArgTypes
argument_list|(
name|args
argument_list|)
operator|,
name|isVarArg
argument_list|(
argument|isVA
argument_list|)
block|{}
specifier|static
name|FunctionValType
name|get
argument_list|(
specifier|const
name|FunctionType
operator|*
name|FT
argument_list|)
expr_stmt|;
specifier|static
name|unsigned
name|hashTypeStructure
parameter_list|(
specifier|const
name|FunctionType
modifier|*
name|FT
parameter_list|)
block|{
name|unsigned
name|Result
init|=
name|FT
operator|->
name|getNumParams
argument_list|()
operator|*
literal|2
operator|+
name|FT
operator|->
name|isVarArg
argument_list|()
decl_stmt|;
return|return
name|Result
return|;
block|}
specifier|inline
name|bool
name|operator
operator|<
operator|(
specifier|const
name|FunctionValType
operator|&
name|MTV
operator|)
specifier|const
block|{
if|if
condition|(
name|RetTy
operator|<
name|MTV
operator|.
name|RetTy
condition|)
return|return
name|true
return|;
if|if
condition|(
name|RetTy
operator|>
name|MTV
operator|.
name|RetTy
condition|)
return|return
name|false
return|;
if|if
condition|(
name|isVarArg
operator|<
name|MTV
operator|.
name|isVarArg
condition|)
return|return
name|true
return|;
if|if
condition|(
name|isVarArg
operator|>
name|MTV
operator|.
name|isVarArg
condition|)
return|return
name|false
return|;
if|if
condition|(
name|ArgTypes
operator|<
name|MTV
operator|.
name|ArgTypes
condition|)
return|return
name|true
return|;
if|if
condition|(
name|ArgTypes
operator|>
name|MTV
operator|.
name|ArgTypes
condition|)
return|return
name|false
return|;
return|return
name|false
return|;
block|}
end_decl_stmt

begin_decl_stmt
unit|};
name|class
name|TypeMapBase
block|{
name|protected
label|:
comment|/// TypesByHash - Keep track of types by their structure hash value.  Note
comment|/// that we only keep track of types that have cycles through themselves in
comment|/// this map.
comment|///
name|std
operator|::
name|multimap
operator|<
name|unsigned
operator|,
name|PATypeHolder
operator|>
name|TypesByHash
expr_stmt|;
name|public
label|:
operator|~
name|TypeMapBase
argument_list|()
block|{
comment|// PATypeHolder won't destroy non-abstract types.
comment|// We can't destroy them by simply iterating, because
comment|// they may contain references to each-other.
for|for
control|(
name|std
operator|::
name|multimap
operator|<
name|unsigned
operator|,
name|PATypeHolder
operator|>
operator|::
name|iterator
name|I
operator|=
name|TypesByHash
operator|.
name|begin
argument_list|()
operator|,
name|E
operator|=
name|TypesByHash
operator|.
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
name|Type
modifier|*
name|Ty
init|=
name|const_cast
operator|<
name|Type
operator|*
operator|>
operator|(
name|I
operator|->
name|second
operator|.
name|Ty
operator|)
decl_stmt|;
name|I
operator|->
name|second
operator|.
name|destroy
argument_list|()
expr_stmt|;
comment|// We can't invoke destroy or delete, because the type may
comment|// contain references to already freed types.
comment|// So we have to destruct the object the ugly way.
if|if
condition|(
name|Ty
condition|)
block|{
name|Ty
operator|->
name|AbstractTypeUsers
operator|.
name|clear
argument_list|()
expr_stmt|;
name|static_cast
operator|<
specifier|const
name|Type
operator|*
operator|>
operator|(
name|Ty
operator|)
operator|->
name|Type
operator|::
operator|~
name|Type
argument_list|()
expr_stmt|;
name|operator
name|delete
parameter_list|(
name|Ty
parameter_list|)
function_decl|;
block|}
block|}
block|}
name|void
name|RemoveFromTypesByHash
argument_list|(
argument|unsigned Hash
argument_list|,
argument|const Type *Ty
argument_list|)
block|{
name|std
operator|::
name|multimap
operator|<
name|unsigned
block|,
name|PATypeHolder
operator|>
operator|::
name|iterator
name|I
operator|=
name|TypesByHash
operator|.
name|lower_bound
argument_list|(
name|Hash
argument_list|)
block|;
for|for
control|(
init|;
name|I
operator|!=
name|TypesByHash
operator|.
name|end
argument_list|()
operator|&&
name|I
operator|->
name|first
operator|==
name|Hash
condition|;
operator|++
name|I
control|)
block|{
if|if
condition|(
name|I
operator|->
name|second
operator|==
name|Ty
condition|)
block|{
name|TypesByHash
operator|.
name|erase
argument_list|(
name|I
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|// This must be do to an opaque type that was resolved.  Switch down to hash
comment|// code of zero.
name|assert
argument_list|(
name|Hash
operator|&&
literal|"Didn't find type entry!"
argument_list|)
expr_stmt|;
name|RemoveFromTypesByHash
argument_list|(
literal|0
argument_list|,
name|Ty
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/// TypeBecameConcrete - When Ty gets a notification that TheType just became
end_comment

begin_comment
comment|/// concrete, drop uses and make Ty non-abstract if we should.
end_comment

begin_function
name|void
name|TypeBecameConcrete
parameter_list|(
name|DerivedType
modifier|*
name|Ty
parameter_list|,
specifier|const
name|DerivedType
modifier|*
name|TheType
parameter_list|)
block|{
comment|// If the element just became concrete, remove 'ty' from the abstract
comment|// type user list for the type.  Do this for as many times as Ty uses
comment|// OldType.
for|for
control|(
name|Type
operator|::
name|subtype_iterator
name|I
operator|=
name|Ty
operator|->
name|subtype_begin
argument_list|()
operator|,
name|E
operator|=
name|Ty
operator|->
name|subtype_end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
if|if
condition|(
name|I
operator|->
name|get
argument_list|()
operator|==
name|TheType
condition|)
name|TheType
operator|->
name|removeAbstractTypeUser
argument_list|(
name|Ty
argument_list|)
expr_stmt|;
comment|// If the type is currently thought to be abstract, rescan all of our
comment|// subtypes to see if the type has just become concrete!  Note that this
comment|// may send out notifications to AbstractTypeUsers that types become
comment|// concrete.
if|if
condition|(
name|Ty
operator|->
name|isAbstract
argument_list|()
condition|)
name|Ty
operator|->
name|PromoteAbstractToConcrete
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
unit|};
comment|// TypeMap - Make sure that only one instance of a particular type may be
end_comment

begin_comment
comment|// created on any given run of the compiler... note that this involves updating
end_comment

begin_comment
comment|// our map if an abstract type gets refined somehow.
end_comment

begin_comment
comment|//
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|ValType
operator|,
name|class
name|TypeClass
operator|>
name|class
name|TypeMap
operator|:
name|public
name|TypeMapBase
block|{
name|std
operator|::
name|map
operator|<
name|ValType
block|,
name|PATypeHolder
operator|>
name|Map
block|;
name|public
operator|:
typedef|typedef
name|typename
name|std
operator|::
name|map
operator|<
name|ValType
operator|,
name|PATypeHolder
operator|>
operator|::
name|iterator
name|iterator
expr_stmt|;
operator|~
name|TypeMap
argument_list|()
block|{
name|print
argument_list|(
literal|"ON EXIT"
argument_list|)
block|; }
specifier|inline
name|TypeClass
operator|*
name|get
argument_list|(
argument|const ValType&V
argument_list|)
block|{
name|iterator
name|I
operator|=
name|Map
operator|.
name|find
argument_list|(
name|V
argument_list|)
block|;
return|return
name|I
operator|!=
name|Map
operator|.
name|end
argument_list|()
condition|?
name|cast
operator|<
name|TypeClass
operator|>
operator|(
operator|(
name|Type
operator|*
operator|)
name|I
operator|->
name|second
operator|.
name|get
argument_list|()
operator|)
else|:
literal|0
return|;
block|}
end_expr_stmt

begin_function
specifier|inline
name|void
name|add
parameter_list|(
specifier|const
name|ValType
modifier|&
name|V
parameter_list|,
name|TypeClass
modifier|*
name|Ty
parameter_list|)
block|{
name|Map
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|V
argument_list|,
name|Ty
argument_list|)
argument_list|)
expr_stmt|;
comment|// If this type has a cycle, remember it.
name|TypesByHash
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|ValType
operator|::
name|hashTypeStructure
argument_list|(
name|Ty
argument_list|)
argument_list|,
name|Ty
argument_list|)
argument_list|)
expr_stmt|;
name|print
argument_list|(
literal|"add"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/// RefineAbstractType - This method is called after we have merged a type
end_comment

begin_comment
comment|/// with another one.  We must now either merge the type away with
end_comment

begin_comment
comment|/// some other type or reinstall it in the map with it's new configuration.
end_comment

begin_function
name|void
name|RefineAbstractType
parameter_list|(
name|TypeClass
modifier|*
name|Ty
parameter_list|,
specifier|const
name|DerivedType
modifier|*
name|OldType
parameter_list|,
specifier|const
name|Type
modifier|*
name|NewType
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_MERGE_TYPES
name|DEBUG
argument_list|(
name|errs
argument_list|()
operator|<<
literal|"RefineAbstractType("
operator|<<
operator|(
name|void
operator|*
operator|)
name|OldType
operator|<<
literal|"["
operator|<<
operator|*
name|OldType
operator|<<
literal|"], "
operator|<<
operator|(
name|void
operator|*
operator|)
name|NewType
operator|<<
literal|" ["
operator|<<
operator|*
name|NewType
operator|<<
literal|"])\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|// Otherwise, we are changing one subelement type into another.  Clearly the
comment|// OldType must have been abstract, making us abstract.
name|assert
argument_list|(
name|Ty
operator|->
name|isAbstract
argument_list|()
operator|&&
literal|"Refining a non-abstract type!"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|OldType
operator|!=
name|NewType
argument_list|)
expr_stmt|;
comment|// Make a temporary type holder for the type so that it doesn't disappear on
comment|// us when we erase the entry from the map.
name|PATypeHolder
name|TyHolder
init|=
name|Ty
decl_stmt|;
comment|// The old record is now out-of-date, because one of the children has been
comment|// updated.  Remove the obsolete entry from the map.
name|unsigned
name|NumErased
init|=
name|Map
operator|.
name|erase
argument_list|(
name|ValType
operator|::
name|get
argument_list|(
name|Ty
argument_list|)
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|NumErased
operator|&&
literal|"Element not found!"
argument_list|)
expr_stmt|;
name|NumErased
operator|=
name|NumErased
expr_stmt|;
comment|// Remember the structural hash for the type before we start hacking on it,
comment|// in case we need it later.
name|unsigned
name|OldTypeHash
init|=
name|ValType
operator|::
name|hashTypeStructure
argument_list|(
name|Ty
argument_list|)
decl_stmt|;
comment|// Find the type element we are refining... and change it now!
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|,
name|e
init|=
name|Ty
operator|->
name|getNumContainedTypes
argument_list|()
init|;
name|i
operator|!=
name|e
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|Ty
operator|->
name|ContainedTys
index|[
name|i
index|]
operator|==
name|OldType
condition|)
name|Ty
operator|->
name|ContainedTys
index|[
name|i
index|]
operator|=
name|NewType
expr_stmt|;
name|unsigned
name|NewTypeHash
init|=
name|ValType
operator|::
name|hashTypeStructure
argument_list|(
name|Ty
argument_list|)
decl_stmt|;
comment|// If there are no cycles going through this node, we can do a simple,
comment|// efficient lookup in the map, instead of an inefficient nasty linear
comment|// lookup.
if|if
condition|(
operator|!
name|TypeHasCycleThroughItself
argument_list|(
name|Ty
argument_list|)
condition|)
block|{
name|typename
name|std
operator|::
name|map
operator|<
name|ValType
operator|,
name|PATypeHolder
operator|>
operator|::
name|iterator
name|I
expr_stmt|;
name|bool
name|Inserted
decl_stmt|;
name|tie
argument_list|(
name|I
argument_list|,
name|Inserted
argument_list|)
operator|=
name|Map
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|ValType
operator|::
name|get
argument_list|(
name|Ty
argument_list|)
argument_list|,
name|Ty
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Inserted
condition|)
block|{
comment|// Refined to a different type altogether?
name|RemoveFromTypesByHash
argument_list|(
name|OldTypeHash
argument_list|,
name|Ty
argument_list|)
expr_stmt|;
comment|// We already have this type in the table.  Get rid of the newly refined
comment|// type.
name|TypeClass
modifier|*
name|NewTy
init|=
name|cast
operator|<
name|TypeClass
operator|>
operator|(
operator|(
name|Type
operator|*
operator|)
name|I
operator|->
name|second
operator|.
name|get
argument_list|()
operator|)
decl_stmt|;
name|Ty
operator|->
name|unlockedRefineAbstractTypeTo
argument_list|(
name|NewTy
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
comment|// Now we check to see if there is an existing entry in the table which is
comment|// structurally identical to the newly refined type.  If so, this type
comment|// gets refined to the pre-existing type.
comment|//
name|std
operator|::
name|multimap
operator|<
name|unsigned
operator|,
name|PATypeHolder
operator|>
operator|::
name|iterator
name|I
operator|,
name|E
operator|,
name|Entry
expr_stmt|;
name|tie
argument_list|(
name|I
argument_list|,
name|E
argument_list|)
operator|=
name|TypesByHash
operator|.
name|equal_range
argument_list|(
name|NewTypeHash
argument_list|)
expr_stmt|;
name|Entry
operator|=
name|E
expr_stmt|;
for|for
control|(
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
block|{
if|if
condition|(
name|I
operator|->
name|second
operator|==
name|Ty
condition|)
block|{
comment|// Remember the position of the old type if we see it in our scan.
name|Entry
operator|=
name|I
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|TypesEqual
argument_list|(
name|Ty
argument_list|,
name|I
operator|->
name|second
argument_list|)
condition|)
block|{
name|TypeClass
modifier|*
name|NewTy
init|=
name|cast
operator|<
name|TypeClass
operator|>
operator|(
operator|(
name|Type
operator|*
operator|)
name|I
operator|->
name|second
operator|.
name|get
argument_list|()
operator|)
decl_stmt|;
comment|// Remove the old entry form TypesByHash.  If the hash values differ
comment|// now, remove it from the old place.  Otherwise, continue scanning
comment|// withing this hashcode to reduce work.
if|if
condition|(
name|NewTypeHash
operator|!=
name|OldTypeHash
condition|)
block|{
name|RemoveFromTypesByHash
argument_list|(
name|OldTypeHash
argument_list|,
name|Ty
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|Entry
operator|==
name|E
condition|)
block|{
comment|// Find the location of Ty in the TypesByHash structure if we
comment|// haven't seen it already.
while|while
condition|(
name|I
operator|->
name|second
operator|!=
name|Ty
condition|)
block|{
operator|++
name|I
expr_stmt|;
name|assert
argument_list|(
name|I
operator|!=
name|E
operator|&&
literal|"Structure doesn't contain type??"
argument_list|)
expr_stmt|;
block|}
name|Entry
operator|=
name|I
expr_stmt|;
block|}
name|TypesByHash
operator|.
name|erase
argument_list|(
name|Entry
argument_list|)
expr_stmt|;
block|}
name|Ty
operator|->
name|unlockedRefineAbstractTypeTo
argument_list|(
name|NewTy
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
comment|// If there is no existing type of the same structure, we reinsert an
comment|// updated record into the map.
name|Map
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|ValType
operator|::
name|get
argument_list|(
name|Ty
argument_list|)
argument_list|,
name|Ty
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// If the hash codes differ, update TypesByHash
if|if
condition|(
name|NewTypeHash
operator|!=
name|OldTypeHash
condition|)
block|{
name|RemoveFromTypesByHash
argument_list|(
name|OldTypeHash
argument_list|,
name|Ty
argument_list|)
expr_stmt|;
name|TypesByHash
operator|.
name|insert
argument_list|(
name|std
operator|::
name|make_pair
argument_list|(
name|NewTypeHash
argument_list|,
name|Ty
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|// If the type is currently thought to be abstract, rescan all of our
comment|// subtypes to see if the type has just become concrete!  Note that this
comment|// may send out notifications to AbstractTypeUsers that types become
comment|// concrete.
if|if
condition|(
name|Ty
operator|->
name|isAbstract
argument_list|()
condition|)
name|Ty
operator|->
name|PromoteAbstractToConcrete
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
name|print
argument_list|(
specifier|const
name|char
operator|*
name|Arg
argument_list|)
decl|const
block|{
ifdef|#
directive|ifdef
name|DEBUG_MERGE_TYPES
name|DEBUG
argument_list|(
name|errs
argument_list|()
operator|<<
literal|"TypeMap<>::"
operator|<<
name|Arg
operator|<<
literal|" table contents:\n"
argument_list|)
expr_stmt|;
name|unsigned
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|typename
name|std
operator|::
name|map
operator|<
name|ValType
operator|,
name|PATypeHolder
operator|>
operator|::
name|const_iterator
name|I
operator|=
name|Map
operator|.
name|begin
argument_list|()
operator|,
name|E
operator|=
name|Map
operator|.
name|end
argument_list|()
init|;
name|I
operator|!=
name|E
condition|;
operator|++
name|I
control|)
name|DEBUG
argument_list|(
name|errs
argument_list|()
operator|<<
literal|" "
operator|<<
operator|(
operator|++
name|i
operator|)
operator|<<
literal|". "
operator|<<
operator|(
name|void
operator|*
operator|)
name|I
operator|->
name|second
operator|.
name|get
argument_list|()
operator|<<
literal|" "
operator|<<
operator|*
name|I
operator|->
name|second
operator|.
name|get
argument_list|()
operator|<<
literal|"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_decl_stmt

begin_expr_stmt
name|void
name|dump
argument_list|()
specifier|const
block|{
name|print
argument_list|(
literal|"dump output"
argument_list|)
block|; }
end_expr_stmt

begin_endif
unit|}; }
endif|#
directive|endif
end_endif

end_unit

