begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2002 Networks Associates Technology, Inc.  * All rights reserved.  *  * This software was developed for the FreeBSD Project by NAI Labs, the  * Security Research Division of Network Associates, Inc. under  * DARPA/SPAWAR contract N66001-01-C-8035 ("CBOSS"), as part of the DARPA  * CHATS research program.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. The names of the authors may not be used to endorse or promote  *    products derived from this software without specific prior written  *    permission.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<security/mac_bsdextended/mac_bsdextended.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"ugidfw.h"
end_include

begin_comment
comment|/*  * Text format for rules: rules contain subjectand object elements, mode.  * Each element takes the form "[not] [uid number] [gid number]".  * The total form is "subject [element] object [element] mode [mode]".  * At least * one of a uid or gid entry must be present; both may also be  * present.  */
end_comment

begin_define
define|#
directive|define
name|MIB
value|"security.mac.bsdextended"
end_define

begin_function
name|int
name|bsde_rule_to_string
parameter_list|(
name|struct
name|mac_bsdextended_rule
modifier|*
name|rule
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|struct
name|group
modifier|*
name|grp
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
name|char
modifier|*
name|cur
decl_stmt|;
name|size_t
name|left
decl_stmt|,
name|len
decl_stmt|;
name|int
name|anymode
decl_stmt|,
name|unknownmode
decl_stmt|,
name|truncated
decl_stmt|;
name|cur
operator|=
name|buf
expr_stmt|;
name|left
operator|=
name|buflen
expr_stmt|;
name|truncated
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|rule
operator|->
name|mbr_subject
operator|.
name|mbi_flags
operator|&
operator|(
name|MBI_UID_DEFINED
operator||
name|MBI_GID_DEFINED
operator|)
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|cur
argument_list|,
name|left
argument_list|,
literal|"subject "
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|len
operator|>
name|left
condition|)
goto|goto
name|truncated
goto|;
name|left
operator|-=
name|len
expr_stmt|;
name|cur
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|rule
operator|->
name|mbr_subject
operator|.
name|mbi_flags
operator|&
name|MBI_NEGATED
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|cur
argument_list|,
name|left
argument_list|,
literal|"not "
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|len
operator|>
name|left
condition|)
goto|goto
name|truncated
goto|;
name|left
operator|-=
name|len
expr_stmt|;
name|cur
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|rule
operator|->
name|mbr_subject
operator|.
name|mbi_flags
operator|&
name|MBI_UID_DEFINED
condition|)
block|{
name|pwd
operator|=
name|getpwuid
argument_list|(
name|rule
operator|->
name|mbr_subject
operator|.
name|mbi_uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|!=
name|NULL
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|cur
argument_list|,
name|left
argument_list|,
literal|"uid %s "
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|len
operator|>
name|left
condition|)
goto|goto
name|truncated
goto|;
name|left
operator|-=
name|len
expr_stmt|;
name|cur
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|cur
argument_list|,
name|left
argument_list|,
literal|"uid %u "
argument_list|,
name|rule
operator|->
name|mbr_subject
operator|.
name|mbi_uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|len
operator|>
name|left
condition|)
goto|goto
name|truncated
goto|;
name|left
operator|-=
name|len
expr_stmt|;
name|cur
operator|+=
name|len
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rule
operator|->
name|mbr_subject
operator|.
name|mbi_flags
operator|&
name|MBI_GID_DEFINED
condition|)
block|{
name|grp
operator|=
name|getgrgid
argument_list|(
name|rule
operator|->
name|mbr_subject
operator|.
name|mbi_gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|grp
operator|!=
name|NULL
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|cur
argument_list|,
name|left
argument_list|,
literal|"gid %s "
argument_list|,
name|grp
operator|->
name|gr_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|len
operator|>
name|left
condition|)
goto|goto
name|truncated
goto|;
name|left
operator|-=
name|len
expr_stmt|;
name|cur
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|cur
argument_list|,
name|left
argument_list|,
literal|"gid %u "
argument_list|,
name|rule
operator|->
name|mbr_subject
operator|.
name|mbi_gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|len
operator|>
name|left
condition|)
goto|goto
name|truncated
goto|;
name|left
operator|-=
name|len
expr_stmt|;
name|cur
operator|+=
name|len
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|rule
operator|->
name|mbr_object
operator|.
name|mbi_flags
operator|&
operator|(
name|MBI_UID_DEFINED
operator||
name|MBI_GID_DEFINED
operator|)
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|cur
argument_list|,
name|left
argument_list|,
literal|"object "
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|len
operator|>
name|left
condition|)
goto|goto
name|truncated
goto|;
name|left
operator|-=
name|len
expr_stmt|;
name|cur
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|rule
operator|->
name|mbr_object
operator|.
name|mbi_flags
operator|&
name|MBI_NEGATED
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|cur
argument_list|,
name|left
argument_list|,
literal|"not "
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|len
operator|>
name|left
condition|)
goto|goto
name|truncated
goto|;
name|left
operator|-=
name|len
expr_stmt|;
name|cur
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|rule
operator|->
name|mbr_object
operator|.
name|mbi_flags
operator|&
name|MBI_UID_DEFINED
condition|)
block|{
name|pwd
operator|=
name|getpwuid
argument_list|(
name|rule
operator|->
name|mbr_object
operator|.
name|mbi_uid
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|!=
name|NULL
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|cur
argument_list|,
name|left
argument_list|,
literal|"uid %s "
argument_list|,
name|pwd
operator|->
name|pw_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|len
operator|>
name|left
condition|)
goto|goto
name|truncated
goto|;
name|left
operator|-=
name|len
expr_stmt|;
name|cur
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|cur
argument_list|,
name|left
argument_list|,
literal|"uid %u "
argument_list|,
name|rule
operator|->
name|mbr_object
operator|.
name|mbi_uid
argument_list|)
expr_stmt|;
name|left
operator|-=
name|len
expr_stmt|;
name|cur
operator|+=
name|len
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rule
operator|->
name|mbr_object
operator|.
name|mbi_flags
operator|&
name|MBI_GID_DEFINED
condition|)
block|{
name|grp
operator|=
name|getgrgid
argument_list|(
name|rule
operator|->
name|mbr_object
operator|.
name|mbi_gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|grp
operator|!=
name|NULL
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|cur
argument_list|,
name|left
argument_list|,
literal|"gid %s "
argument_list|,
name|grp
operator|->
name|gr_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|len
operator|>
name|left
condition|)
goto|goto
name|truncated
goto|;
name|left
operator|-=
name|len
expr_stmt|;
name|cur
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|cur
argument_list|,
name|left
argument_list|,
literal|"gid %u "
argument_list|,
name|rule
operator|->
name|mbr_object
operator|.
name|mbi_gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|len
operator|>
name|left
condition|)
goto|goto
name|truncated
goto|;
name|left
operator|-=
name|len
expr_stmt|;
name|cur
operator|+=
name|len
expr_stmt|;
block|}
block|}
block|}
name|len
operator|=
name|snprintf
argument_list|(
name|cur
argument_list|,
name|left
argument_list|,
literal|"mode "
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|len
operator|>
name|left
condition|)
goto|goto
name|truncated
goto|;
name|left
operator|-=
name|len
expr_stmt|;
name|cur
operator|+=
name|len
expr_stmt|;
name|anymode
operator|=
operator|(
name|rule
operator|->
name|mbr_mode
operator|&
name|VALLPERM
operator|)
expr_stmt|;
name|unknownmode
operator|=
operator|(
name|rule
operator|->
name|mbr_mode
operator|&
operator|~
name|VALLPERM
operator|)
expr_stmt|;
if|if
condition|(
name|rule
operator|->
name|mbr_mode
operator|&
name|VADMIN
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|cur
argument_list|,
name|left
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|len
operator|>
name|left
condition|)
goto|goto
name|truncated
goto|;
name|left
operator|-=
name|len
expr_stmt|;
name|cur
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|rule
operator|->
name|mbr_mode
operator|&
name|VREAD
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|cur
argument_list|,
name|left
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|len
operator|>
name|left
condition|)
goto|goto
name|truncated
goto|;
name|left
operator|-=
name|len
expr_stmt|;
name|cur
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|rule
operator|->
name|mbr_mode
operator|&
name|VSTAT
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|cur
argument_list|,
name|left
argument_list|,
literal|"s"
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|len
operator|>
name|left
condition|)
goto|goto
name|truncated
goto|;
name|left
operator|-=
name|len
expr_stmt|;
name|cur
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|rule
operator|->
name|mbr_mode
operator|&
name|VWRITE
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|cur
argument_list|,
name|left
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|len
operator|>
name|left
condition|)
goto|goto
name|truncated
goto|;
name|left
operator|-=
name|len
expr_stmt|;
name|cur
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|rule
operator|->
name|mbr_mode
operator|&
name|VEXEC
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|cur
argument_list|,
name|left
argument_list|,
literal|"x"
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|len
operator|>
name|left
condition|)
goto|goto
name|truncated
goto|;
name|left
operator|-=
name|len
expr_stmt|;
name|cur
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|anymode
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|cur
argument_list|,
name|left
argument_list|,
literal|"n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|len
operator|>
name|left
condition|)
goto|goto
name|truncated
goto|;
name|left
operator|-=
name|len
expr_stmt|;
name|cur
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|unknownmode
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|cur
argument_list|,
name|left
argument_list|,
literal|"?"
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
operator|||
name|len
operator|>
name|left
condition|)
goto|goto
name|truncated
goto|;
name|left
operator|-=
name|len
expr_stmt|;
name|cur
operator|+=
name|len
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|truncated
label|:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bsde_parse_identity
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|struct
name|mac_bsdextended_identity
modifier|*
name|identity
parameter_list|,
name|size_t
name|buflen
parameter_list|,
name|char
modifier|*
name|errstr
parameter_list|)
block|{
name|struct
name|group
modifier|*
name|grp
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pwd
decl_stmt|;
name|int
name|uid_seen
decl_stmt|,
name|gid_seen
decl_stmt|,
name|not_seen
decl_stmt|;
name|int
name|current
decl_stmt|;
name|char
modifier|*
name|endp
decl_stmt|;
name|long
name|value
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|errstr
argument_list|,
name|buflen
argument_list|,
literal|"Identity must not be empty"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|current
operator|=
literal|0
expr_stmt|;
comment|/* First element might be "not". */
if|if
condition|(
name|strcmp
argument_list|(
literal|"not"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|not_seen
operator|=
literal|1
expr_stmt|;
name|current
operator|++
expr_stmt|;
block|}
else|else
name|not_seen
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|current
operator|>=
name|argc
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|errstr
argument_list|,
name|buflen
argument_list|,
literal|"Identity short"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|uid_seen
operator|=
literal|0
expr_stmt|;
name|uid
operator|=
literal|0
expr_stmt|;
name|gid_seen
operator|=
literal|0
expr_stmt|;
name|gid
operator|=
literal|0
expr_stmt|;
comment|/* First phrase: uid [uid] or gid[gid]. */
if|if
condition|(
name|strcmp
argument_list|(
literal|"uid"
argument_list|,
name|argv
index|[
name|current
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|current
operator|+
literal|2
operator|>
name|argc
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|errstr
argument_list|,
name|buflen
argument_list|,
literal|"uid short"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|pwd
operator|=
name|getpwnam
argument_list|(
name|argv
index|[
name|current
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwd
operator|!=
name|NULL
condition|)
name|uid
operator|=
name|pwd
operator|->
name|pw_uid
expr_stmt|;
else|else
block|{
name|value
operator|=
name|strtol
argument_list|(
name|argv
index|[
name|current
operator|+
literal|1
index|]
argument_list|,
operator|&
name|endp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endp
operator|!=
literal|'\0'
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|errstr
argument_list|,
name|buflen
argument_list|,
literal|"invalid uid: '%s'"
argument_list|,
name|argv
index|[
name|current
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|uid
operator|=
name|value
expr_stmt|;
block|}
name|uid_seen
operator|=
literal|1
expr_stmt|;
name|current
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"gid"
argument_list|,
name|argv
index|[
name|current
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|current
operator|+
literal|2
operator|>
name|argc
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|errstr
argument_list|,
name|buflen
argument_list|,
literal|"gid short"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|grp
operator|=
name|getgrnam
argument_list|(
name|argv
index|[
name|current
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|grp
operator|!=
name|NULL
condition|)
name|gid
operator|=
name|grp
operator|->
name|gr_gid
expr_stmt|;
else|else
block|{
name|value
operator|=
name|strtol
argument_list|(
name|argv
index|[
name|current
operator|+
literal|1
index|]
argument_list|,
operator|&
name|endp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endp
operator|!=
literal|'\0'
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|errstr
argument_list|,
name|buflen
argument_list|,
literal|"invalid gid: '%s'"
argument_list|,
name|argv
index|[
name|current
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|gid
operator|=
name|value
expr_stmt|;
block|}
name|gid_seen
operator|=
literal|1
expr_stmt|;
name|current
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|errstr
argument_list|,
name|buflen
argument_list|,
literal|"'%s' not expected"
argument_list|,
name|argv
index|[
name|current
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Onto optional second phrase. */
if|if
condition|(
name|current
operator|+
literal|1
operator|<
name|argc
condition|)
block|{
comment|/* Second phrase: uid [uid] or gid [gid], but not a repeat. */
if|if
condition|(
name|strcmp
argument_list|(
literal|"uid"
argument_list|,
name|argv
index|[
name|current
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|uid_seen
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|errstr
argument_list|,
name|buflen
argument_list|,
literal|"Only one uid permitted per identity clause"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|current
operator|+
literal|2
operator|>
name|argc
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|errstr
argument_list|,
name|buflen
argument_list|,
literal|"uid short"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|value
operator|=
name|strtol
argument_list|(
name|argv
index|[
name|current
operator|+
literal|1
index|]
argument_list|,
operator|&
name|endp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endp
operator|!=
literal|'\0'
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|errstr
argument_list|,
name|buflen
argument_list|,
literal|"invalid uid: '%s'"
argument_list|,
name|argv
index|[
name|current
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|uid
operator|=
name|value
expr_stmt|;
name|uid_seen
operator|=
literal|1
expr_stmt|;
name|current
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"gid"
argument_list|,
name|argv
index|[
name|current
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|gid_seen
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|errstr
argument_list|,
name|buflen
argument_list|,
literal|"Only one gid permitted per identity clause"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|current
operator|+
literal|2
operator|>
name|argc
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|errstr
argument_list|,
name|buflen
argument_list|,
literal|"gid short"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|value
operator|=
name|strtol
argument_list|(
name|argv
index|[
name|current
operator|+
literal|1
index|]
argument_list|,
operator|&
name|endp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|endp
operator|!=
literal|'\0'
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|errstr
argument_list|,
name|buflen
argument_list|,
literal|"invalid gid: '%s'"
argument_list|,
name|argv
index|[
name|current
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|gid
operator|=
name|value
expr_stmt|;
name|gid_seen
operator|=
literal|1
expr_stmt|;
name|current
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|errstr
argument_list|,
name|buflen
argument_list|,
literal|"'%s' not expected"
argument_list|,
name|argv
index|[
name|current
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|current
operator|+
literal|1
operator|<
name|argc
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|errstr
argument_list|,
name|buflen
argument_list|,
literal|"'%s' not expected"
argument_list|,
name|argv
index|[
name|current
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Fill out the identity. */
name|identity
operator|->
name|mbi_flags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|not_seen
condition|)
name|identity
operator|->
name|mbi_flags
operator||=
name|MBI_NEGATED
expr_stmt|;
if|if
condition|(
name|uid_seen
condition|)
block|{
name|identity
operator|->
name|mbi_flags
operator||=
name|MBI_UID_DEFINED
expr_stmt|;
name|identity
operator|->
name|mbi_uid
operator|=
name|uid
expr_stmt|;
block|}
else|else
name|identity
operator|->
name|mbi_uid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gid_seen
condition|)
block|{
name|identity
operator|->
name|mbi_flags
operator||=
name|MBI_GID_DEFINED
expr_stmt|;
name|identity
operator|->
name|mbi_gid
operator|=
name|gid
expr_stmt|;
block|}
else|else
name|identity
operator|->
name|mbi_gid
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bsde_parse_mode
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|mode_t
modifier|*
name|mode
parameter_list|,
name|size_t
name|buflen
parameter_list|,
name|char
modifier|*
name|errstr
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|errstr
argument_list|,
name|buflen
argument_list|,
literal|"mode expects mode value"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|argc
operator|!=
literal|1
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|errstr
argument_list|,
name|buflen
argument_list|,
literal|"'%s' unexpected"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|mode
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|strlen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|argv
index|[
literal|0
index|]
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'a'
case|:
operator|*
name|mode
operator||=
name|VADMIN
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|*
name|mode
operator||=
name|VREAD
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
operator|*
name|mode
operator||=
name|VSTAT
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
operator|*
name|mode
operator||=
name|VWRITE
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
operator|*
name|mode
operator||=
name|VEXEC
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* ignore */
break|break;
default|default:
name|len
operator|=
name|snprintf
argument_list|(
name|errstr
argument_list|,
name|buflen
argument_list|,
literal|"Unknown mode letter: %c"
argument_list|,
name|argv
index|[
literal|0
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bsde_parse_rule
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|struct
name|mac_bsdextended_rule
modifier|*
name|rule
parameter_list|,
name|size_t
name|buflen
parameter_list|,
name|char
modifier|*
name|errstr
parameter_list|)
block|{
name|int
name|subject
decl_stmt|,
name|subject_elements
decl_stmt|,
name|subject_elements_length
decl_stmt|;
name|int
name|object
decl_stmt|,
name|object_elements
decl_stmt|,
name|object_elements_length
decl_stmt|;
name|int
name|mode
decl_stmt|,
name|mode_elements
decl_stmt|,
name|mode_elements_length
decl_stmt|;
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|bzero
argument_list|(
name|rule
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rule
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|errstr
argument_list|,
name|buflen
argument_list|,
literal|"Rule must begin with subject"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"subject"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|errstr
argument_list|,
name|buflen
argument_list|,
literal|"Rule must begin with subject"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|subject
operator|=
literal|0
expr_stmt|;
name|subject_elements
operator|=
literal|1
expr_stmt|;
comment|/* Search forward for object. */
name|object
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"object"
argument_list|)
operator|==
literal|0
condition|)
name|object
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|object
operator|==
operator|-
literal|1
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|errstr
argument_list|,
name|buflen
argument_list|,
literal|"Rule must contain an object"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* Search forward for mode. */
name|mode
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|object
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"mode"
argument_list|)
operator|==
literal|0
condition|)
name|mode
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|mode
operator|==
operator|-
literal|1
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|errstr
argument_list|,
name|buflen
argument_list|,
literal|"Rule must contain mode"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|subject_elements_length
operator|=
name|object
operator|-
name|subject
operator|-
literal|1
expr_stmt|;
name|object_elements
operator|=
name|object
operator|+
literal|1
expr_stmt|;
name|object_elements_length
operator|=
name|mode
operator|-
name|object_elements
expr_stmt|;
name|mode_elements
operator|=
name|mode
operator|+
literal|1
expr_stmt|;
name|mode_elements_length
operator|=
name|argc
operator|-
name|mode_elements
expr_stmt|;
name|error
operator|=
name|bsde_parse_identity
argument_list|(
name|subject_elements_length
argument_list|,
name|argv
operator|+
name|subject_elements
argument_list|,
operator|&
name|rule
operator|->
name|mbr_subject
argument_list|,
name|buflen
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|error
operator|=
name|bsde_parse_identity
argument_list|(
name|object_elements_length
argument_list|,
name|argv
operator|+
name|object_elements
argument_list|,
operator|&
name|rule
operator|->
name|mbr_object
argument_list|,
name|buflen
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|error
operator|=
name|bsde_parse_mode
argument_list|(
name|mode_elements_length
argument_list|,
name|argv
operator|+
name|mode_elements
argument_list|,
operator|&
name|rule
operator|->
name|mbr_mode
argument_list|,
name|buflen
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bsde_parse_rule_string
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|struct
name|mac_bsdextended_rule
modifier|*
name|rule
parameter_list|,
name|size_t
name|buflen
parameter_list|,
name|char
modifier|*
name|errstr
parameter_list|)
block|{
name|char
modifier|*
name|stringdup
decl_stmt|,
modifier|*
name|stringp
decl_stmt|,
modifier|*
name|argv
index|[
literal|20
index|]
decl_stmt|,
modifier|*
modifier|*
name|ap
decl_stmt|;
name|int
name|argc
decl_stmt|,
name|error
decl_stmt|;
name|stringp
operator|=
name|stringdup
operator|=
name|strdup
argument_list|(
name|string
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|stringp
operator|==
literal|' '
operator|||
operator|*
name|stringp
operator|==
literal|'\t'
condition|)
name|stringp
operator|++
expr_stmt|;
name|argc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|argv
init|;
operator|(
operator|*
name|ap
operator|=
name|strsep
argument_list|(
operator|&
name|stringp
argument_list|,
literal|" \t"
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
name|argc
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|ap
operator|!=
literal|'\0'
condition|)
if|if
condition|(
operator|++
name|ap
operator|>=
operator|&
name|argv
index|[
literal|20
index|]
condition|)
break|break;
block|}
name|error
operator|=
name|bsde_parse_rule
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|rule
argument_list|,
name|buflen
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|stringdup
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bsde_get_mib
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|int
modifier|*
name|name
parameter_list|,
name|size_t
modifier|*
name|namelen
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|int
name|error
decl_stmt|;
name|len
operator|=
operator|*
name|namelen
expr_stmt|;
name|error
operator|=
name|sysctlnametomib
argument_list|(
name|string
argument_list|,
name|name
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|namelen
operator|=
name|len
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bsde_get_rule_count
parameter_list|(
name|size_t
name|buflen
parameter_list|,
name|char
modifier|*
name|errstr
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|rule_count
decl_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|rule_count
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctlbyname
argument_list|(
name|MIB
literal|".rule_count"
argument_list|,
operator|&
name|rule_count
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|errstr
argument_list|,
name|buflen
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
name|rule_count
argument_list|)
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|errstr
argument_list|,
name|buflen
argument_list|,
literal|"Data error in %s.rule_count"
argument_list|,
name|MIB
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|rule_count
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bsde_get_rule_slots
parameter_list|(
name|size_t
name|buflen
parameter_list|,
name|char
modifier|*
name|errstr
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|rule_slots
decl_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|rule_slots
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctlbyname
argument_list|(
name|MIB
literal|".rule_slots"
argument_list|,
operator|&
name|rule_slots
argument_list|,
operator|&
name|len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|errstr
argument_list|,
name|buflen
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
name|rule_slots
argument_list|)
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|errstr
argument_list|,
name|buflen
argument_list|,
literal|"Data error in %s.rule_slots"
argument_list|,
name|MIB
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|rule_slots
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns 0 for success;  * Returns -1 for failure;  * Returns -2 for not present  */
end_comment

begin_function
name|int
name|bsde_get_rule
parameter_list|(
name|int
name|rulenum
parameter_list|,
name|struct
name|mac_bsdextended_rule
modifier|*
name|rule
parameter_list|,
name|size_t
name|errlen
parameter_list|,
name|char
modifier|*
name|errstr
parameter_list|)
block|{
name|int
name|name
index|[
literal|10
index|]
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|size
decl_stmt|;
name|int
name|error
decl_stmt|;
name|len
operator|=
literal|10
expr_stmt|;
name|error
operator|=
name|bsde_get_mib
argument_list|(
name|MIB
literal|".rules"
argument_list|,
name|name
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|errstr
argument_list|,
name|errlen
argument_list|,
literal|"%s: %s"
argument_list|,
name|MIB
literal|".rules"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|rule
argument_list|)
expr_stmt|;
name|name
index|[
name|len
index|]
operator|=
name|rulenum
expr_stmt|;
name|len
operator|++
expr_stmt|;
name|error
operator|=
name|sysctl
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
name|rule
argument_list|,
operator|&
name|size
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
if|if
condition|(
name|error
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|errstr
argument_list|,
name|errlen
argument_list|,
literal|"%s.%d: %s"
argument_list|,
name|MIB
literal|".rules"
argument_list|,
name|rulenum
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|size
operator|!=
sizeof|sizeof
argument_list|(
operator|*
name|rule
argument_list|)
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|errstr
argument_list|,
name|errlen
argument_list|,
literal|"Data error in %s.%d: %s"
argument_list|,
name|MIB
literal|".rules"
argument_list|,
name|rulenum
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bsde_delete_rule
parameter_list|(
name|int
name|rulenum
parameter_list|,
name|size_t
name|buflen
parameter_list|,
name|char
modifier|*
name|errstr
parameter_list|)
block|{
name|struct
name|mac_bsdextended_rule
name|rule
decl_stmt|;
name|int
name|name
index|[
literal|10
index|]
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|size
decl_stmt|;
name|int
name|error
decl_stmt|;
name|len
operator|=
literal|10
expr_stmt|;
name|error
operator|=
name|bsde_get_mib
argument_list|(
name|MIB
literal|".rules"
argument_list|,
name|name
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|errstr
argument_list|,
name|buflen
argument_list|,
literal|"%s: %s"
argument_list|,
name|MIB
literal|".rules"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|name
index|[
name|len
index|]
operator|=
name|rulenum
expr_stmt|;
name|len
operator|++
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|rule
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|rule
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|errstr
argument_list|,
name|buflen
argument_list|,
literal|"%s.%d: %s"
argument_list|,
name|MIB
literal|".rules"
argument_list|,
name|rulenum
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bsde_set_rule
parameter_list|(
name|int
name|rulenum
parameter_list|,
name|struct
name|mac_bsdextended_rule
modifier|*
name|rule
parameter_list|,
name|size_t
name|buflen
parameter_list|,
name|char
modifier|*
name|errstr
parameter_list|)
block|{
name|int
name|name
index|[
literal|10
index|]
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|size
decl_stmt|;
name|int
name|error
decl_stmt|;
name|len
operator|=
literal|10
expr_stmt|;
name|error
operator|=
name|bsde_get_mib
argument_list|(
name|MIB
literal|".rules"
argument_list|,
name|name
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|errstr
argument_list|,
name|buflen
argument_list|,
literal|"%s: %s"
argument_list|,
name|MIB
literal|".rules"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|name
index|[
name|len
index|]
operator|=
name|rulenum
expr_stmt|;
name|len
operator|++
expr_stmt|;
name|size
operator|=
sizeof|sizeof
argument_list|(
operator|*
name|rule
argument_list|)
expr_stmt|;
name|error
operator|=
name|sysctl
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|rule
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|len
operator|=
name|snprintf
argument_list|(
name|errstr
argument_list|,
name|buflen
argument_list|,
literal|"%s.%d: %s"
argument_list|,
name|MIB
literal|".rules"
argument_list|,
name|rulenum
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

