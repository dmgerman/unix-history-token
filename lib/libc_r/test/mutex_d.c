begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1998 Daniel M. Eischen<eischen@vigrid.com>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by Daniel M. Eischen.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY DANIEL M. EISCHEN AND CONTRIBUTORS ``AS IS''  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"pthread.h"
end_include

begin_include
include|#
directive|include
file|<sched.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_LIBC_R_
argument_list|)
end_if

begin_include
include|#
directive|include
file|<pthread_np.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NELEMENTS
end_ifndef

begin_define
define|#
directive|define
name|NELEMENTS
parameter_list|(
name|arr
parameter_list|)
value|(sizeof (arr) / sizeof (arr[0]))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NUM_THREADS
end_ifndef

begin_define
define|#
directive|define
name|NUM_THREADS
value|10
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAX_THREAD_CMDS
value|10
end_define

begin_comment
comment|/*------------------------------------------------------------  * Types  *----------------------------------------------------------*/
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|STAT_INITIAL
block|,
comment|/* initial state */
name|STAT_WAITCONDVAR
block|,
comment|/* waiting for condition variable signal */
name|STAT_WAITMUTEX
comment|/* waiting for mutex lock */
block|}
name|thread_status_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|FLAGS_REPORT_WAITCONDMUTEX
init|=
literal|0x01
block|,
name|FLAGS_REPORT_WAITCONDVAR
init|=
literal|0x02
block|,
name|FLAGS_REPORT_WAITMUTEX
init|=
literal|0x04
block|,
name|FLAGS_REPORT_BUSY_LOOP
init|=
literal|0x08
block|,
name|FLAGS_IS_BUSY
init|=
literal|0x10
block|,
name|FLAGS_WAS_BUSY
init|=
literal|0x20
block|}
name|thread_flags_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|CMD_NONE
block|,
name|CMD_TAKE_MUTEX
block|,
name|CMD_RELEASE_MUTEX
block|,
name|CMD_WAIT_FOR_SIGNAL
block|,
name|CMD_BUSY_LOOP
block|,
name|CMD_PROTECTED_OP
block|,
name|CMD_RELEASE_ALL
block|}
name|thread_cmd_id_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|thread_cmd_id_t
name|cmd_id
decl_stmt|;
name|pthread_mutex_t
modifier|*
name|mutex
decl_stmt|;
name|pthread_cond_t
modifier|*
name|cond
decl_stmt|;
block|}
name|thread_cmd_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|pthread_cond_t
name|cond_var
decl_stmt|;
name|thread_status_t
name|status
decl_stmt|;
name|thread_cmd_t
name|cmd
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|int
name|priority
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|pthread_t
name|tid
decl_stmt|;
name|u_int8_t
name|id
decl_stmt|;
block|}
name|thread_state_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
enum|enum
block|{
name|M_POSIX
block|,
name|M_SS2_DEFAULT
block|,
name|M_SS2_ERRORCHECK
block|,
name|M_SS2_NORMAL
block|,
name|M_SS2_RECURSIVE
block|}
name|mutex_kind_t
typedef|;
end_typedef

begin_comment
comment|/*------------------------------------------------------------  * Constants  *----------------------------------------------------------*/
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|protocol_strs
index|[]
init|=
block|{
literal|"PTHREAD_PRIO_NONE"
block|,
literal|"PTHREAD_PRIO_INHERIT"
block|,
literal|"PTHREAD_PRIO_PROTECT"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|protocols
index|[]
init|=
block|{
name|PTHREAD_PRIO_NONE
block|,
name|PTHREAD_PRIO_INHERIT
block|,
name|PTHREAD_PRIO_PROTECT
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
name|mutextype_strs
index|[]
init|=
block|{
literal|"POSIX (type not specified)"
block|,
literal|"SS2 PTHREAD_MUTEX_DEFAULT"
block|,
literal|"SS2 PTHREAD_MUTEX_ERRORCHECK"
block|,
literal|"SS2 PTHREAD_MUTEX_NORMAL"
block|,
literal|"SS2 PTHREAD_MUTEX_RECURSIVE"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|int
name|mutex_types
index|[]
init|=
block|{
literal|0
block|,
comment|/* M_POSIX		*/
name|PTHREAD_MUTEX_DEFAULT
block|,
comment|/* M_SS2_DEFAULT	*/
name|PTHREAD_MUTEX_ERRORCHECK
block|,
comment|/* M_SS2_ERRORCHECK	*/
name|PTHREAD_MUTEX_NORMAL
block|,
comment|/* M_SS2_NORMAL		*/
name|PTHREAD_MUTEX_RECURSIVE
comment|/* M_SS2_RECURSIVE	*/
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*------------------------------------------------------------  * Objects  *----------------------------------------------------------*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|done
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|trace_enabled
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|use_global_condvar
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|thread_state_t
name|states
index|[
name|NUM_THREADS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pipefd
index|[
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pthread_mutex_t
name|waiter_mutex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pthread_mutex_t
name|cond_mutex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pthread_cond_t
name|cond_var
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|logfile
init|=
name|stdout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|error_count
init|=
literal|0
decl_stmt|,
name|pass_count
init|=
literal|0
decl_stmt|,
name|total
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*------------------------------------------------------------  * Prototypes  *----------------------------------------------------------*/
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|strtok_r
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|char
modifier|*
name|sep
parameter_list|,
name|char
modifier|*
modifier|*
name|last
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*------------------------------------------------------------  * Functions  *----------------------------------------------------------*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
specifier|static
name|void
name|kern_switch
parameter_list|(
name|pthread_t
name|pthread_out
parameter_list|,
name|pthread_t
name|pthread_in
parameter_list|)
block|{
if|if
condition|(
name|pthread_out
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"Swapping out thread 0x%x, "
argument_list|,
operator|(
name|int
operator|)
name|pthread_out
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Swapping out kernel thread, "
argument_list|)
expr_stmt|;
if|if
condition|(
name|pthread_in
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"swapping in thread 0x%x\n"
argument_list|,
operator|(
name|int
operator|)
name|pthread_in
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"swapping in kernel thread.\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|log_error
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|logfile
argument_list|,
literal|"FAIL: "
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|logfile
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|error_count
operator|=
name|error_count
operator|+
literal|1
expr_stmt|;
name|total
operator|=
name|total
operator|+
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|log_pass
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|logfile
argument_list|,
literal|"PASS\n"
argument_list|)
expr_stmt|;
name|pass_count
operator|=
name|pass_count
operator|+
literal|1
expr_stmt|;
name|total
operator|=
name|total
operator|+
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|log_trace
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
name|trace_enabled
condition|)
block|{
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|logfile
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|log
parameter_list|(
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|logfile
argument_list|,
name|fmt
argument_list|,
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|check_result
parameter_list|(
name|int
name|expected
parameter_list|,
name|int
name|actual
parameter_list|)
block|{
if|if
condition|(
name|expected
operator|!=
name|actual
condition|)
name|log_error
argument_list|(
literal|"expected %d, returned %d\n"
argument_list|,
name|expected
argument_list|,
name|actual
argument_list|)
expr_stmt|;
else|else
name|log_pass
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Check to see that the threads ran in the specified order.  */
end_comment

begin_function
specifier|static
name|void
name|check_run_order
parameter_list|(
name|char
modifier|*
name|order
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|sep
init|=
literal|":,"
decl_stmt|;
name|char
modifier|*
name|tok
decl_stmt|,
modifier|*
name|last
decl_stmt|,
modifier|*
name|idstr
decl_stmt|,
modifier|*
name|endptr
decl_stmt|;
name|int
name|expected_id
decl_stmt|,
name|bytes
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|,
name|errors
init|=
literal|0
decl_stmt|;
name|u_int8_t
name|id
decl_stmt|;
name|assert
argument_list|(
operator|(
name|tok
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|order
argument_list|)
operator|+
literal|1
argument_list|)
operator|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tok
argument_list|,
name|order
argument_list|)
expr_stmt|;
comment|/* tok has to be larger than order */
name|assert
argument_list|(
name|ioctl
argument_list|(
name|pipefd
index|[
literal|0
index|]
argument_list|,
name|FIONREAD
argument_list|,
operator|&
name|bytes
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|log_trace
argument_list|(
literal|"%d bytes read from FIFO.\n"
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
for|for
control|(
name|idstr
operator|=
name|strtok_r
argument_list|(
name|tok
argument_list|,
name|sep
argument_list|,
operator|&
name|last
argument_list|)
init|;
operator|(
name|idstr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|count
operator|<
name|bytes
operator|)
condition|;
name|idstr
operator|=
name|strtok_r
argument_list|(
name|NULL
argument_list|,
name|sep
argument_list|,
operator|&
name|last
argument_list|)
control|)
block|{
comment|/* Get the expected id: */
name|expected_id
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|idstr
argument_list|,
operator|&
name|endptr
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|endptr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|endptr
operator|==
literal|'\0'
operator|)
argument_list|)
expr_stmt|;
comment|/* Read the actual id from the pipe: */
name|assert
argument_list|(
name|read
argument_list|(
name|pipefd
index|[
literal|0
index|]
argument_list|,
operator|&
name|id
argument_list|,
sizeof|sizeof
argument_list|(
name|id
argument_list|)
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|=
name|count
operator|+
sizeof|sizeof
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|!=
name|expected_id
condition|)
block|{
name|log_trace
argument_list|(
literal|"Thread %d ran out of order.\n"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|errors
operator|=
name|errors
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|log_trace
argument_list|(
literal|"Thread %d at priority %d reporting.\n"
argument_list|,
operator|(
name|int
operator|)
name|id
argument_list|,
name|states
index|[
name|id
index|]
operator|.
name|priority
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|count
operator|<
name|bytes
condition|)
block|{
comment|/* Clear the pipe: */
while|while
condition|(
name|count
operator|<
name|bytes
condition|)
block|{
name|read
argument_list|(
name|pipefd
index|[
literal|0
index|]
argument_list|,
operator|&
name|id
argument_list|,
sizeof|sizeof
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|count
operator|=
name|count
operator|+
literal|1
expr_stmt|;
name|errors
operator|=
name|errors
operator|+
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|bytes
operator|<
name|count
condition|)
name|errors
operator|=
name|errors
operator|+
name|count
operator|-
name|bytes
expr_stmt|;
if|if
condition|(
name|errors
operator|==
literal|0
condition|)
name|log_pass
argument_list|()
expr_stmt|;
else|else
name|log_error
argument_list|(
literal|"%d threads ran out of order"
argument_list|,
name|errors
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|waiter
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|thread_state_t
modifier|*
name|statep
init|=
operator|(
name|thread_state_t
operator|*
operator|)
name|arg
decl_stmt|;
name|pthread_mutex_t
modifier|*
name|held_mutex
index|[
name|MAX_THREAD_CMDS
index|]
decl_stmt|;
name|int
name|held_mutex_owned
index|[
name|MAX_THREAD_CMDS
index|]
decl_stmt|;
name|sigset_t
name|mask
decl_stmt|;
name|struct
name|timeval
name|tv1
decl_stmt|,
name|tv2
decl_stmt|;
name|thread_cmd_t
name|cmd
decl_stmt|;
name|int
name|i
decl_stmt|,
name|mutex_count
init|=
literal|0
decl_stmt|;
name|statep
operator|->
name|status
operator|=
name|STAT_INITIAL
expr_stmt|;
comment|/* Block all signals except for interrupt.*/
name|sigfillset
argument_list|(
operator|&
name|mask
argument_list|)
expr_stmt|;
name|sigdelset
argument_list|(
operator|&
name|mask
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|mask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
name|done
operator|==
literal|0
condition|)
block|{
comment|/* Wait for signal from the main thread to continue. */
name|statep
operator|->
name|status
operator|=
name|STAT_WAITMUTEX
expr_stmt|;
name|log_trace
argument_list|(
literal|"Thread %d: locking cond_mutex.\n"
argument_list|,
operator|(
name|int
operator|)
name|statep
operator|->
name|id
argument_list|)
expr_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|cond_mutex
argument_list|)
expr_stmt|;
comment|/* Do we report our status. */
if|if
condition|(
name|statep
operator|->
name|flags
operator|&
name|FLAGS_REPORT_WAITCONDMUTEX
condition|)
name|write
argument_list|(
name|pipefd
index|[
literal|1
index|]
argument_list|,
operator|&
name|statep
operator|->
name|id
argument_list|,
sizeof|sizeof
argument_list|(
name|statep
operator|->
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|log_trace
argument_list|(
literal|"Thread %d: waiting for cond_var.\n"
argument_list|,
operator|(
name|int
operator|)
name|statep
operator|->
name|id
argument_list|)
expr_stmt|;
comment|/* Wait for a command. */
name|statep
operator|->
name|status
operator|=
name|STAT_WAITCONDVAR
expr_stmt|;
comment|/* 		 * The threads are allowed commanded to wait either on 		 * their own unique condition variable (so they may be 		 * separately signaled) or on one global condition variable 		 * (so they may be signaled together). 		 */
if|if
condition|(
name|use_global_condvar
operator|!=
literal|0
condition|)
name|pthread_cond_wait
argument_list|(
operator|&
name|cond_var
argument_list|,
operator|&
name|cond_mutex
argument_list|)
expr_stmt|;
else|else
name|pthread_cond_wait
argument_list|(
operator|&
name|statep
operator|->
name|cond_var
argument_list|,
operator|&
name|cond_mutex
argument_list|)
expr_stmt|;
comment|/* Do we report our status? */
if|if
condition|(
name|statep
operator|->
name|flags
operator|&
name|FLAGS_REPORT_WAITCONDVAR
condition|)
block|{
name|write
argument_list|(
name|pipefd
index|[
literal|1
index|]
argument_list|,
operator|&
name|statep
operator|->
name|id
argument_list|,
sizeof|sizeof
argument_list|(
name|statep
operator|->
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|log_trace
argument_list|(
literal|"Thread %d: wrote %d to pipe.\n"
argument_list|,
operator|(
name|int
operator|)
name|statep
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
name|log_trace
argument_list|(
literal|"Thread %d: received cond_var signal.\n"
argument_list|,
operator|(
name|int
operator|)
name|statep
operator|->
name|id
argument_list|)
expr_stmt|;
comment|/* Get a copy of the command before releasing the mutex. */
name|cmd
operator|=
name|statep
operator|->
name|cmd
expr_stmt|;
comment|/* Clear the command after copying it. */
name|statep
operator|->
name|cmd
operator|.
name|cmd_id
operator|=
name|CMD_NONE
expr_stmt|;
comment|/* Unlock the condition variable mutex. */
name|assert
argument_list|(
name|pthread_mutex_unlock
argument_list|(
operator|&
name|cond_mutex
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Peform the command.*/
switch|switch
condition|(
name|cmd
operator|.
name|cmd_id
condition|)
block|{
case|case
name|CMD_TAKE_MUTEX
case|:
name|statep
operator|->
name|ret
operator|=
name|pthread_mutex_lock
argument_list|(
name|cmd
operator|.
name|mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|statep
operator|->
name|ret
operator|==
literal|0
condition|)
block|{
name|assert
argument_list|(
name|mutex_count
operator|<
sizeof|sizeof
argument_list|(
name|held_mutex
argument_list|)
argument_list|)
expr_stmt|;
name|held_mutex
index|[
name|mutex_count
index|]
operator|=
name|cmd
operator|.
name|mutex
expr_stmt|;
name|held_mutex_owned
index|[
name|mutex_count
index|]
operator|=
literal|1
expr_stmt|;
name|mutex_count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|held_mutex_owned
index|[
name|mutex_count
index|]
operator|=
literal|0
expr_stmt|;
name|log_trace
argument_list|(
literal|"Thread id %d unable to lock mutex, "
literal|"error = %d\n"
argument_list|,
operator|(
name|int
operator|)
name|statep
operator|->
name|id
argument_list|,
name|statep
operator|->
name|ret
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|CMD_RELEASE_MUTEX
case|:
name|assert
argument_list|(
operator|(
name|mutex_count
operator|<=
sizeof|sizeof
argument_list|(
name|held_mutex
argument_list|)
operator|)
operator|&&
operator|(
name|mutex_count
operator|>
literal|0
operator|)
argument_list|)
expr_stmt|;
name|mutex_count
operator|--
expr_stmt|;
if|if
condition|(
name|held_mutex_owned
index|[
name|mutex_count
index|]
operator|!=
literal|0
condition|)
name|assert
argument_list|(
name|pthread_mutex_unlock
argument_list|(
name|held_mutex
index|[
name|mutex_count
index|]
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_WAIT_FOR_SIGNAL
case|:
name|assert
argument_list|(
name|pthread_mutex_lock
argument_list|(
name|cmd
operator|.
name|mutex
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_cond_wait
argument_list|(
name|cmd
operator|.
name|cond
argument_list|,
name|cmd
operator|.
name|mutex
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_mutex_unlock
argument_list|(
name|cmd
operator|.
name|mutex
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_BUSY_LOOP
case|:
name|log_trace
argument_list|(
literal|"Thread %d: Entering busy loop.\n"
argument_list|,
operator|(
name|int
operator|)
name|statep
operator|->
name|id
argument_list|)
expr_stmt|;
comment|/* Spin for 15 seconds. */
name|assert
argument_list|(
name|gettimeofday
argument_list|(
operator|&
name|tv2
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tv1
operator|.
name|tv_sec
operator|=
name|tv2
operator|.
name|tv_sec
operator|+
literal|5
expr_stmt|;
name|tv1
operator|.
name|tv_usec
operator|=
name|tv2
operator|.
name|tv_usec
expr_stmt|;
name|statep
operator|->
name|flags
operator||=
name|FLAGS_IS_BUSY
expr_stmt|;
while|while
condition|(
name|timercmp
argument_list|(
operator|&
name|tv2
argument_list|,
operator|&
name|tv1
argument_list|,
operator|<
argument_list|)
condition|)
block|{
name|assert
argument_list|(
name|gettimeofday
argument_list|(
operator|&
name|tv2
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|statep
operator|->
name|flags
operator|&=
operator|~
name|FLAGS_IS_BUSY
expr_stmt|;
name|statep
operator|->
name|flags
operator||=
name|FLAGS_WAS_BUSY
expr_stmt|;
comment|/* Do we report our status? */
if|if
condition|(
name|statep
operator|->
name|flags
operator|&
name|FLAGS_REPORT_BUSY_LOOP
condition|)
name|write
argument_list|(
name|pipefd
index|[
literal|1
index|]
argument_list|,
operator|&
name|statep
operator|->
name|id
argument_list|,
sizeof|sizeof
argument_list|(
name|statep
operator|->
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|log_trace
argument_list|(
literal|"Thread %d: Leaving busy loop.\n"
argument_list|,
operator|(
name|int
operator|)
name|statep
operator|->
name|id
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_PROTECTED_OP
case|:
name|assert
argument_list|(
name|pthread_mutex_lock
argument_list|(
name|cmd
operator|.
name|mutex
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|statep
operator|->
name|flags
operator||=
name|FLAGS_WAS_BUSY
expr_stmt|;
comment|/* Do we report our status? */
if|if
condition|(
name|statep
operator|->
name|flags
operator|&
name|FLAGS_REPORT_BUSY_LOOP
condition|)
name|write
argument_list|(
name|pipefd
index|[
literal|1
index|]
argument_list|,
operator|&
name|statep
operator|->
name|id
argument_list|,
sizeof|sizeof
argument_list|(
name|statep
operator|->
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_mutex_unlock
argument_list|(
name|cmd
operator|.
name|mutex
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_RELEASE_ALL
case|:
name|assert
argument_list|(
operator|(
name|mutex_count
operator|<=
sizeof|sizeof
argument_list|(
name|held_mutex
argument_list|)
operator|)
operator|&&
operator|(
name|mutex_count
operator|>
literal|0
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|mutex_count
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|held_mutex_owned
index|[
name|i
index|]
operator|!=
literal|0
condition|)
name|assert
argument_list|(
name|pthread_mutex_unlock
argument_list|(
name|held_mutex
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|mutex_count
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CMD_NONE
case|:
default|default:
break|break;
block|}
comment|/* Wait for the big giant waiter lock. */
name|statep
operator|->
name|status
operator|=
name|STAT_WAITMUTEX
expr_stmt|;
name|log_trace
argument_list|(
literal|"Thread %d: waiting for big giant lock.\n"
argument_list|,
operator|(
name|int
operator|)
name|statep
operator|->
name|id
argument_list|)
expr_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|waiter_mutex
argument_list|)
expr_stmt|;
if|if
condition|(
name|statep
operator|->
name|flags
operator|&
name|FLAGS_REPORT_WAITMUTEX
condition|)
name|write
argument_list|(
name|pipefd
index|[
literal|1
index|]
argument_list|,
operator|&
name|statep
operator|->
name|id
argument_list|,
sizeof|sizeof
argument_list|(
name|statep
operator|->
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|log_trace
argument_list|(
literal|"Thread %d: got big giant lock.\n"
argument_list|,
operator|(
name|int
operator|)
name|statep
operator|->
name|id
argument_list|)
expr_stmt|;
name|statep
operator|->
name|status
operator|=
name|STAT_INITIAL
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|waiter_mutex
argument_list|)
expr_stmt|;
block|}
name|log_trace
argument_list|(
literal|"Thread %d: Exiting thread 0x%x\n"
argument_list|,
operator|(
name|int
operator|)
name|statep
operator|->
name|id
argument_list|,
operator|(
name|int
operator|)
name|pthread_self
argument_list|()
argument_list|)
expr_stmt|;
name|pthread_exit
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|lock_twice
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|thread_state_t
modifier|*
name|statep
init|=
operator|(
name|thread_state_t
operator|*
operator|)
name|arg
decl_stmt|;
name|sigset_t
name|mask
decl_stmt|;
name|statep
operator|->
name|status
operator|=
name|STAT_INITIAL
expr_stmt|;
comment|/* Block all signals except for interrupt.*/
name|sigfillset
argument_list|(
operator|&
name|mask
argument_list|)
expr_stmt|;
name|sigdelset
argument_list|(
operator|&
name|mask
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|mask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Wait for a signal to continue. */
name|log_trace
argument_list|(
literal|"Thread %d: locking cond_mutex.\n"
argument_list|,
operator|(
name|int
operator|)
name|statep
operator|->
name|id
argument_list|)
expr_stmt|;
name|pthread_mutex_lock
argument_list|(
operator|&
name|cond_mutex
argument_list|)
expr_stmt|;
name|log_trace
argument_list|(
literal|"Thread %d: waiting for cond_var.\n"
argument_list|,
operator|(
name|int
operator|)
name|statep
operator|->
name|id
argument_list|)
expr_stmt|;
name|statep
operator|->
name|status
operator|=
name|STAT_WAITCONDVAR
expr_stmt|;
name|pthread_cond_wait
argument_list|(
operator|&
name|cond_var
argument_list|,
operator|&
name|cond_mutex
argument_list|)
expr_stmt|;
name|log_trace
argument_list|(
literal|"Thread %d: received cond_var signal.\n"
argument_list|,
operator|(
name|int
operator|)
name|statep
operator|->
name|id
argument_list|)
expr_stmt|;
comment|/* Unlock the condition variable mutex. */
name|assert
argument_list|(
name|pthread_mutex_unlock
argument_list|(
operator|&
name|cond_mutex
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|statep
operator|->
name|status
operator|=
name|STAT_WAITMUTEX
expr_stmt|;
comment|/* Lock the mutex once. */
name|assert
argument_list|(
name|pthread_mutex_lock
argument_list|(
name|statep
operator|->
name|cmd
operator|.
name|mutex
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Lock it again and capture the error. */
name|statep
operator|->
name|ret
operator|=
name|pthread_mutex_lock
argument_list|(
name|statep
operator|->
name|cmd
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|statep
operator|->
name|status
operator|=
literal|0
expr_stmt|;
name|assert
argument_list|(
name|pthread_mutex_unlock
argument_list|(
name|statep
operator|->
name|cmd
operator|.
name|mutex
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Unlock it again if it is locked recursively. */
if|if
condition|(
name|statep
operator|->
name|ret
operator|==
literal|0
condition|)
name|pthread_mutex_unlock
argument_list|(
name|statep
operator|->
name|cmd
operator|.
name|mutex
argument_list|)
expr_stmt|;
name|log_trace
argument_list|(
literal|"Thread %d: Exiting thread 0x%x\n"
argument_list|,
operator|(
name|int
operator|)
name|statep
operator|->
name|id
argument_list|,
operator|(
name|int
operator|)
name|pthread_self
argument_list|()
argument_list|)
expr_stmt|;
name|pthread_exit
argument_list|(
name|arg
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|sighandler
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
name|log
argument_list|(
literal|"Signal handler caught signal %d, thread id 0x%x\n"
argument_list|,
name|signo
argument_list|,
operator|(
name|int
operator|)
name|pthread_self
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|signo
operator|==
name|SIGINT
condition|)
name|done
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|send_cmd
parameter_list|(
name|int
name|id
parameter_list|,
name|thread_cmd_id_t
name|cmd
parameter_list|)
block|{
name|assert
argument_list|(
name|pthread_mutex_lock
argument_list|(
operator|&
name|cond_mutex
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|states
index|[
name|id
index|]
operator|.
name|status
operator|==
name|STAT_WAITCONDVAR
argument_list|)
expr_stmt|;
name|states
index|[
name|id
index|]
operator|.
name|cmd
operator|.
name|cmd_id
operator|=
name|cmd
expr_stmt|;
name|states
index|[
name|id
index|]
operator|.
name|cmd
operator|.
name|mutex
operator|=
name|NULL
expr_stmt|;
name|states
index|[
name|id
index|]
operator|.
name|cmd
operator|.
name|cond
operator|=
name|NULL
expr_stmt|;
comment|/* Clear the busy flags. */
name|states
index|[
name|id
index|]
operator|.
name|flags
operator|&=
operator|~
operator|(
name|FLAGS_WAS_BUSY
operator||
name|FLAGS_IS_BUSY
operator|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_cond_signal
argument_list|(
operator|&
name|states
index|[
name|id
index|]
operator|.
name|cond_var
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_mutex_unlock
argument_list|(
operator|&
name|cond_mutex
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|send_mutex_cmd
parameter_list|(
name|int
name|id
parameter_list|,
name|thread_cmd_id_t
name|cmd
parameter_list|,
name|pthread_mutex_t
modifier|*
name|m
parameter_list|)
block|{
name|assert
argument_list|(
name|pthread_mutex_lock
argument_list|(
operator|&
name|cond_mutex
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|states
index|[
name|id
index|]
operator|.
name|status
operator|==
name|STAT_WAITCONDVAR
argument_list|)
expr_stmt|;
name|states
index|[
name|id
index|]
operator|.
name|cmd
operator|.
name|cmd_id
operator|=
name|cmd
expr_stmt|;
name|states
index|[
name|id
index|]
operator|.
name|cmd
operator|.
name|mutex
operator|=
name|m
expr_stmt|;
name|states
index|[
name|id
index|]
operator|.
name|cmd
operator|.
name|cond
operator|=
name|NULL
expr_stmt|;
comment|/* Clear the busy flags. */
name|states
index|[
name|id
index|]
operator|.
name|flags
operator|&=
operator|~
operator|(
name|FLAGS_WAS_BUSY
operator||
name|FLAGS_IS_BUSY
operator|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_cond_signal
argument_list|(
operator|&
name|states
index|[
name|id
index|]
operator|.
name|cond_var
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_mutex_unlock
argument_list|(
operator|&
name|cond_mutex
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|send_mutex_cv_cmd
parameter_list|(
name|int
name|id
parameter_list|,
name|thread_cmd_id_t
name|cmd
parameter_list|,
name|pthread_mutex_t
modifier|*
name|m
parameter_list|,
name|pthread_cond_t
modifier|*
name|cv
parameter_list|)
block|{
name|assert
argument_list|(
name|pthread_mutex_lock
argument_list|(
operator|&
name|cond_mutex
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|states
index|[
name|id
index|]
operator|.
name|status
operator|==
name|STAT_WAITCONDVAR
argument_list|)
expr_stmt|;
name|states
index|[
name|id
index|]
operator|.
name|cmd
operator|.
name|cmd_id
operator|=
name|cmd
expr_stmt|;
name|states
index|[
name|id
index|]
operator|.
name|cmd
operator|.
name|mutex
operator|=
name|m
expr_stmt|;
name|states
index|[
name|id
index|]
operator|.
name|cmd
operator|.
name|cond
operator|=
name|cv
expr_stmt|;
comment|/* Clear the busy flags. */
name|states
index|[
name|id
index|]
operator|.
name|flags
operator|&=
operator|~
operator|(
name|FLAGS_WAS_BUSY
operator||
name|FLAGS_IS_BUSY
operator|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_cond_signal
argument_list|(
operator|&
name|states
index|[
name|id
index|]
operator|.
name|cond_var
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_mutex_unlock
argument_list|(
operator|&
name|cond_mutex
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mutex_init_test
parameter_list|(
name|void
parameter_list|)
block|{
name|pthread_mutexattr_t
name|mattr
decl_stmt|;
name|pthread_mutex_t
name|mutex
decl_stmt|;
name|mutex_kind_t
name|mkind
decl_stmt|;
name|int
name|mproto
decl_stmt|,
name|ret
decl_stmt|;
comment|/* 	 * Initialize a mutex attribute. 	 * 	 * pthread_mutexattr_init not tested for: ENOMEM 	 */
name|assert
argument_list|(
name|pthread_mutexattr_init
argument_list|(
operator|&
name|mattr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize a mutex. 	 * 	 * pthread_mutex_init not tested for: EAGAIN ENOMEM EPERM EBUSY 	 */
name|log
argument_list|(
literal|"Testing pthread_mutex_init\n"
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"--------------------------\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|mproto
operator|=
literal|0
init|;
name|mproto
operator|<
name|NELEMENTS
argument_list|(
name|protocols
argument_list|)
condition|;
name|mproto
operator|++
control|)
block|{
for|for
control|(
name|mkind
operator|=
name|M_POSIX
init|;
name|mkind
operator|<=
name|M_SS2_RECURSIVE
condition|;
name|mkind
operator|++
control|)
block|{
comment|/* Initialize the mutex attribute. */
name|assert
argument_list|(
name|pthread_mutexattr_init
argument_list|(
operator|&
name|mattr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_mutexattr_setprotocol
argument_list|(
operator|&
name|mattr
argument_list|,
name|protocols
index|[
name|mproto
index|]
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * Ensure that the first mutex type is a POSIX 			 * compliant mutex. 			 */
if|if
condition|(
name|mkind
operator|!=
name|M_POSIX
condition|)
block|{
name|assert
argument_list|(
name|pthread_mutexattr_settype
argument_list|(
operator|&
name|mattr
argument_list|,
name|mutex_types
index|[
name|mkind
index|]
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|log
argument_list|(
literal|"  Protocol %s, Type %s - "
argument_list|,
name|protocol_strs
index|[
name|mproto
index|]
argument_list|,
name|mutextype_strs
index|[
name|mkind
index|]
argument_list|)
expr_stmt|;
name|ret
operator|=
name|pthread_mutex_init
argument_list|(
operator|&
name|mutex
argument_list|,
operator|&
name|mattr
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
comment|/* expected */
literal|0
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_mutex_destroy
argument_list|(
operator|&
name|mutex
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * Destroy a mutex attribute. 			 * 			 * XXX - There should probably be a magic number 			 *       associated with a mutex attribute so that 			 *       destroy can be reasonably sure the attribute 			 *       is valid. 			 * 			 * pthread_mutexattr_destroy not tested for: EINVAL 			 */
name|assert
argument_list|(
name|pthread_mutexattr_destroy
argument_list|(
operator|&
name|mattr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mutex_destroy_test
parameter_list|(
name|void
parameter_list|)
block|{
name|pthread_mutexattr_t
name|mattr
decl_stmt|;
name|pthread_mutex_t
name|mutex
decl_stmt|;
name|pthread_condattr_t
name|cattr
decl_stmt|;
name|pthread_cond_t
name|cv
decl_stmt|;
name|pthread_attr_t
name|pattr
decl_stmt|;
name|int
name|mproto
decl_stmt|,
name|ret
decl_stmt|;
name|mutex_kind_t
name|mkind
decl_stmt|;
name|thread_state_t
name|state
decl_stmt|;
comment|/* 	 * Destroy a mutex. 	 * 	 * XXX - There should probably be a magic number associated 	 *       with a mutex so that destroy can be reasonably sure 	 *       the mutex is valid. 	 * 	 * pthread_mutex_destroy not tested for:  	 */
name|log
argument_list|(
literal|"Testing pthread_mutex_destroy\n"
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"-----------------------------\n"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_attr_init
argument_list|(
operator|&
name|pattr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_attr_setdetachstate
argument_list|(
operator|&
name|pattr
argument_list|,
name|PTHREAD_CREATE_DETACHED
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|state
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* No flags yet. */
for|for
control|(
name|mproto
operator|=
literal|0
init|;
name|mproto
operator|<
name|NELEMENTS
argument_list|(
name|protocols
argument_list|)
condition|;
name|mproto
operator|++
control|)
block|{
for|for
control|(
name|mkind
operator|=
name|M_POSIX
init|;
name|mkind
operator|<=
name|M_SS2_RECURSIVE
condition|;
name|mkind
operator|++
control|)
block|{
comment|/* Initialize the mutex attribute. */
name|assert
argument_list|(
name|pthread_mutexattr_init
argument_list|(
operator|&
name|mattr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_mutexattr_setprotocol
argument_list|(
operator|&
name|mattr
argument_list|,
name|protocols
index|[
name|mproto
index|]
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * Ensure that the first mutex type is a POSIX 			 * compliant mutex. 			 */
if|if
condition|(
name|mkind
operator|!=
name|M_POSIX
condition|)
block|{
name|assert
argument_list|(
name|pthread_mutexattr_settype
argument_list|(
operator|&
name|mattr
argument_list|,
name|mutex_types
index|[
name|mkind
index|]
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Create the mutex. */
name|assert
argument_list|(
name|pthread_mutex_init
argument_list|(
operator|&
name|mutex
argument_list|,
operator|&
name|mattr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"  Protocol %s, Type %s\n"
argument_list|,
name|protocol_strs
index|[
name|mproto
index|]
argument_list|,
name|mutextype_strs
index|[
name|mkind
index|]
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"    Destruction of unused mutex - "
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_mutex_init
argument_list|(
operator|&
name|mutex
argument_list|,
operator|&
name|mattr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
name|pthread_mutex_destroy
argument_list|(
operator|&
name|mutex
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
comment|/* expected */
literal|0
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"    Destruction of mutex locked by self - "
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_mutex_init
argument_list|(
operator|&
name|mutex
argument_list|,
operator|&
name|mattr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_mutex_lock
argument_list|(
operator|&
name|mutex
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
name|pthread_mutex_destroy
argument_list|(
operator|&
name|mutex
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
comment|/* expected */
name|EBUSY
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_mutex_unlock
argument_list|(
operator|&
name|mutex
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_mutex_destroy
argument_list|(
operator|&
name|mutex
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"    Destruction of mutex locked by another "
literal|"thread - "
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_mutex_init
argument_list|(
operator|&
name|mutex
argument_list|,
operator|&
name|mattr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|send_mutex_cmd
argument_list|(
literal|0
argument_list|,
name|CMD_TAKE_MUTEX
argument_list|,
operator|&
name|mutex
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|=
name|pthread_mutex_destroy
argument_list|(
operator|&
name|mutex
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
comment|/* expected */
name|EBUSY
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|send_cmd
argument_list|(
literal|0
argument_list|,
name|CMD_RELEASE_ALL
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_mutex_destroy
argument_list|(
operator|&
name|mutex
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"    Destruction of mutex while being used in "
literal|"cond_wait - "
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_mutex_init
argument_list|(
operator|&
name|mutex
argument_list|,
operator|&
name|mattr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_condattr_init
argument_list|(
operator|&
name|cattr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_cond_init
argument_list|(
operator|&
name|cv
argument_list|,
operator|&
name|cattr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|send_mutex_cv_cmd
argument_list|(
literal|0
argument_list|,
name|CMD_WAIT_FOR_SIGNAL
argument_list|,
operator|&
name|mutex
argument_list|,
operator|&
name|cv
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|=
name|pthread_mutex_destroy
argument_list|(
operator|&
name|mutex
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
comment|/* expected */
name|EBUSY
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|pthread_cond_signal
argument_list|(
operator|&
name|cv
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_mutex_destroy
argument_list|(
operator|&
name|mutex
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mutex_lock_test
parameter_list|(
name|void
parameter_list|)
block|{
name|pthread_mutexattr_t
name|mattr
decl_stmt|;
name|pthread_mutex_t
name|mutex
decl_stmt|;
name|pthread_attr_t
name|pattr
decl_stmt|;
name|int
name|mproto
decl_stmt|,
name|ret
decl_stmt|;
name|mutex_kind_t
name|mkind
decl_stmt|;
name|thread_state_t
name|state
decl_stmt|;
comment|/* 	 * Lock a mutex. 	 * 	 * pthread_lock not tested for:  	 */
name|log
argument_list|(
literal|"Testing pthread_mutex_lock\n"
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"--------------------------\n"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_attr_init
argument_list|(
operator|&
name|pattr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_attr_setdetachstate
argument_list|(
operator|&
name|pattr
argument_list|,
name|PTHREAD_CREATE_DETACHED
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|state
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* No flags yet. */
for|for
control|(
name|mproto
operator|=
literal|0
init|;
name|mproto
operator|<
name|NELEMENTS
argument_list|(
name|protocols
argument_list|)
condition|;
name|mproto
operator|++
control|)
block|{
for|for
control|(
name|mkind
operator|=
name|M_POSIX
init|;
name|mkind
operator|<=
name|M_SS2_RECURSIVE
condition|;
name|mkind
operator|++
control|)
block|{
comment|/* Initialize the mutex attribute. */
name|assert
argument_list|(
name|pthread_mutexattr_init
argument_list|(
operator|&
name|mattr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_mutexattr_setprotocol
argument_list|(
operator|&
name|mattr
argument_list|,
name|protocols
index|[
name|mproto
index|]
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * Ensure that the first mutex type is a POSIX 			 * compliant mutex. 			 */
if|if
condition|(
name|mkind
operator|!=
name|M_POSIX
condition|)
block|{
name|assert
argument_list|(
name|pthread_mutexattr_settype
argument_list|(
operator|&
name|mattr
argument_list|,
name|mutex_types
index|[
name|mkind
index|]
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Create the mutex. */
name|assert
argument_list|(
name|pthread_mutex_init
argument_list|(
operator|&
name|mutex
argument_list|,
operator|&
name|mattr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"  Protocol %s, Type %s\n"
argument_list|,
name|protocol_strs
index|[
name|mproto
index|]
argument_list|,
name|mutextype_strs
index|[
name|mkind
index|]
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"    Lock on unlocked mutex - "
argument_list|)
expr_stmt|;
name|ret
operator|=
name|pthread_mutex_lock
argument_list|(
operator|&
name|mutex
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
comment|/* expected */
literal|0
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|pthread_mutex_unlock
argument_list|(
operator|&
name|mutex
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"    Lock on invalid mutex - "
argument_list|)
expr_stmt|;
name|ret
operator|=
name|pthread_mutex_lock
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
comment|/* expected */
name|EINVAL
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"    Lock on mutex held by self - "
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_create
argument_list|(
operator|&
name|state
operator|.
name|tid
argument_list|,
operator|&
name|pattr
argument_list|,
name|lock_twice
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|state
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Let the thread start. */
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|state
operator|.
name|cmd
operator|.
name|mutex
operator|=
operator|&
name|mutex
expr_stmt|;
name|state
operator|.
name|ret
operator|=
literal|0xdeadbeef
expr_stmt|;
name|assert
argument_list|(
name|pthread_mutex_lock
argument_list|(
operator|&
name|cond_mutex
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_cond_signal
argument_list|(
operator|&
name|cond_var
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_mutex_unlock
argument_list|(
operator|&
name|cond_mutex
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Let the thread receive and process the command. */
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mkind
condition|)
block|{
case|case
name|M_POSIX
case|:
name|check_result
argument_list|(
comment|/* expected */
name|EDEADLK
argument_list|,
name|state
operator|.
name|ret
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_SS2_DEFAULT
case|:
name|check_result
argument_list|(
comment|/* expected */
name|EDEADLK
argument_list|,
name|state
operator|.
name|ret
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_SS2_ERRORCHECK
case|:
name|check_result
argument_list|(
comment|/* expected */
name|EDEADLK
argument_list|,
name|state
operator|.
name|ret
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_SS2_NORMAL
case|:
name|check_result
argument_list|(
comment|/* expected */
literal|0xdeadbeef
argument_list|,
name|state
operator|.
name|ret
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_SS2_RECURSIVE
case|:
name|check_result
argument_list|(
comment|/* expected */
literal|0
argument_list|,
name|state
operator|.
name|ret
argument_list|)
expr_stmt|;
break|break;
block|}
name|pthread_mutex_destroy
argument_list|(
operator|&
name|mutex
argument_list|)
expr_stmt|;
name|pthread_mutexattr_destroy
argument_list|(
operator|&
name|mattr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mutex_unlock_test
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|int
name|test_thread_id
init|=
literal|0
decl_stmt|;
comment|/* ID of test thread */
name|pthread_mutexattr_t
name|mattr
decl_stmt|;
name|pthread_mutex_t
name|mutex
decl_stmt|;
name|int
name|mproto
decl_stmt|,
name|ret
decl_stmt|;
name|mutex_kind_t
name|mkind
decl_stmt|;
comment|/* 	 * Unlock a mutex. 	 * 	 * pthread_unlock not tested for:  	 */
name|log
argument_list|(
literal|"Testing pthread_mutex_unlock\n"
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|mproto
operator|=
literal|0
init|;
name|mproto
operator|<
name|NELEMENTS
argument_list|(
name|protocols
argument_list|)
condition|;
name|mproto
operator|++
control|)
block|{
for|for
control|(
name|mkind
operator|=
name|M_POSIX
init|;
name|mkind
operator|<=
name|M_SS2_RECURSIVE
condition|;
name|mkind
operator|++
control|)
block|{
comment|/* Initialize the mutex attribute. */
name|assert
argument_list|(
name|pthread_mutexattr_init
argument_list|(
operator|&
name|mattr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_mutexattr_setprotocol
argument_list|(
operator|&
name|mattr
argument_list|,
name|protocols
index|[
name|mproto
index|]
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 			 * Ensure that the first mutex type is a POSIX 			 * compliant mutex. 			 */
if|if
condition|(
name|mkind
operator|!=
name|M_POSIX
condition|)
block|{
name|assert
argument_list|(
name|pthread_mutexattr_settype
argument_list|(
operator|&
name|mattr
argument_list|,
name|mutex_types
index|[
name|mkind
index|]
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Create the mutex. */
name|assert
argument_list|(
name|pthread_mutex_init
argument_list|(
operator|&
name|mutex
argument_list|,
operator|&
name|mattr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"  Protocol %s, Type %s\n"
argument_list|,
name|protocol_strs
index|[
name|mproto
index|]
argument_list|,
name|mutextype_strs
index|[
name|mkind
index|]
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"    Unlock on mutex held by self - "
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_mutex_lock
argument_list|(
operator|&
name|mutex
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ret
operator|=
name|pthread_mutex_unlock
argument_list|(
operator|&
name|mutex
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
comment|/* expected */
literal|0
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"    Unlock on invalid mutex - "
argument_list|)
expr_stmt|;
name|ret
operator|=
name|pthread_mutex_unlock
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
comment|/* expected */
name|EINVAL
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"    Unlock on mutex locked by another thread - "
argument_list|)
expr_stmt|;
name|send_mutex_cmd
argument_list|(
name|test_thread_id
argument_list|,
name|CMD_TAKE_MUTEX
argument_list|,
operator|&
name|mutex
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ret
operator|=
name|pthread_mutex_unlock
argument_list|(
operator|&
name|mutex
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mkind
condition|)
block|{
case|case
name|M_POSIX
case|:
name|check_result
argument_list|(
comment|/* expected */
name|EPERM
argument_list|,
name|ret
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_SS2_DEFAULT
case|:
name|check_result
argument_list|(
comment|/* expected */
name|EPERM
argument_list|,
name|ret
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_SS2_ERRORCHECK
case|:
name|check_result
argument_list|(
comment|/* expected */
name|EPERM
argument_list|,
name|ret
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_SS2_NORMAL
case|:
name|check_result
argument_list|(
comment|/* expected */
name|EPERM
argument_list|,
name|ret
argument_list|)
expr_stmt|;
break|break;
case|case
name|M_SS2_RECURSIVE
case|:
name|check_result
argument_list|(
comment|/* expected */
name|EPERM
argument_list|,
name|ret
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
comment|/* 				 * If for some reason we were able to unlock 				 * the mutex, relock it so that the test 				 * thread has no problems releasing the mutex. 				 */
name|pthread_mutex_lock
argument_list|(
operator|&
name|mutex
argument_list|)
expr_stmt|;
block|}
name|send_cmd
argument_list|(
name|test_thread_id
argument_list|,
name|CMD_RELEASE_ALL
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|pthread_mutex_destroy
argument_list|(
operator|&
name|mutex
argument_list|)
expr_stmt|;
name|pthread_mutexattr_destroy
argument_list|(
operator|&
name|mattr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|queueing_order_test
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|log
argument_list|(
literal|"Testing queueing order\n"
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"----------------------\n"
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_mutex_lock
argument_list|(
operator|&
name|waiter_mutex
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Tell the threads to report when they take the waiters mutex. 	 */
name|assert
argument_list|(
name|pthread_mutex_lock
argument_list|(
operator|&
name|cond_mutex
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_THREADS
condition|;
name|i
operator|++
control|)
block|{
name|states
index|[
name|i
index|]
operator|.
name|flags
operator|=
name|FLAGS_REPORT_WAITMUTEX
expr_stmt|;
name|assert
argument_list|(
name|pthread_cond_signal
argument_list|(
operator|&
name|states
index|[
name|i
index|]
operator|.
name|cond_var
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|pthread_mutex_unlock
argument_list|(
operator|&
name|cond_mutex
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Signal the threads to continue. */
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Use the global condition variable next time. */
name|use_global_condvar
operator|=
literal|1
expr_stmt|;
comment|/* Release the waiting threads and allow them to run again. */
name|assert
argument_list|(
name|pthread_mutex_unlock
argument_list|(
operator|&
name|waiter_mutex
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"  Queueing order on a mutex - "
argument_list|)
expr_stmt|;
name|check_run_order
argument_list|(
literal|"9,8,7,6,5,4,3,2,1,0"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_THREADS
condition|;
name|i
operator|=
name|i
operator|+
literal|1
control|)
block|{
comment|/* Tell the threads to report when they've been signaled. */
name|states
index|[
name|i
index|]
operator|.
name|flags
operator|=
name|FLAGS_REPORT_WAITCONDVAR
expr_stmt|;
block|}
comment|/* 	 * Prevent the threads from continuing their loop after we 	 * signal them. 	 */
name|assert
argument_list|(
name|pthread_mutex_lock
argument_list|(
operator|&
name|waiter_mutex
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"  Queueing order on a condition variable - "
argument_list|)
expr_stmt|;
comment|/* 	 * Signal one thread to run and see that the highest priority 	 * thread executes. 	 */
name|assert
argument_list|(
name|pthread_mutex_lock
argument_list|(
operator|&
name|cond_mutex
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_cond_signal
argument_list|(
operator|&
name|cond_var
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_mutex_unlock
argument_list|(
operator|&
name|cond_mutex
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|states
index|[
name|NUM_THREADS
operator|-
literal|1
index|]
operator|.
name|status
operator|!=
name|STAT_WAITMUTEX
condition|)
name|log_error
argument_list|(
literal|"highest priority thread does not run.\n"
argument_list|)
expr_stmt|;
comment|/* Signal the remaining threads. */
name|assert
argument_list|(
name|pthread_mutex_lock
argument_list|(
operator|&
name|cond_mutex
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_cond_broadcast
argument_list|(
operator|&
name|cond_var
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_mutex_unlock
argument_list|(
operator|&
name|cond_mutex
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|check_run_order
argument_list|(
literal|"9,8,7,6,5,4,3,2,1,0"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_THREADS
condition|;
name|i
operator|=
name|i
operator|+
literal|1
control|)
block|{
comment|/* Tell the threads not to report anything. */
name|states
index|[
name|i
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Use the thread unique condition variable next time. */
name|use_global_condvar
operator|=
literal|0
expr_stmt|;
comment|/* Allow the threads to continue their loop. */
name|assert
argument_list|(
name|pthread_mutex_unlock
argument_list|(
operator|&
name|waiter_mutex
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mutex_prioceiling_test
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|int
name|test_thread_id
init|=
literal|0
decl_stmt|;
comment|/* ID of test thread */
name|pthread_mutexattr_t
name|mattr
decl_stmt|;
name|struct
name|sched_param
name|param
decl_stmt|;
name|pthread_mutex_t
name|m
index|[
literal|3
index|]
decl_stmt|;
name|mutex_kind_t
name|mkind
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|,
name|policy
decl_stmt|,
name|my_prio
decl_stmt|,
name|old_ceiling
decl_stmt|;
name|log
argument_list|(
literal|"Testing priority ceilings\n"
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"-------------------------\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|mkind
operator|=
name|M_POSIX
init|;
name|mkind
operator|<=
name|M_SS2_RECURSIVE
condition|;
name|mkind
operator|++
control|)
block|{
name|log
argument_list|(
literal|"  Protype PTHREAD_PRIO_PROTECT, Type %s\n"
argument_list|,
name|mutextype_strs
index|[
name|mkind
index|]
argument_list|)
expr_stmt|;
comment|/* 		 * Initialize and create a mutex. 		 */
name|assert
argument_list|(
name|pthread_mutexattr_init
argument_list|(
operator|&
name|mattr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Get this threads current priority. */
name|assert
argument_list|(
name|pthread_getschedparam
argument_list|(
name|pthread_self
argument_list|()
argument_list|,
operator|&
name|policy
argument_list|,
operator|&
name|param
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|my_prio
operator|=
name|param
operator|.
name|sched_priority
expr_stmt|;
comment|/* save for later use */
name|log_trace
argument_list|(
literal|"Current scheduling policy %d, priority %d\n"
argument_list|,
name|policy
argument_list|,
name|my_prio
argument_list|)
expr_stmt|;
comment|/* 		 * Initialize and create 3 priority protection mutexes with 		 * default (max priority) ceilings. 		 */
name|assert
argument_list|(
name|pthread_mutexattr_setprotocol
argument_list|(
operator|&
name|mattr
argument_list|,
name|PTHREAD_PRIO_PROTECT
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Ensure that the first mutex type is a POSIX 		 * compliant mutex. 		 */
if|if
condition|(
name|mkind
operator|!=
name|M_POSIX
condition|)
block|{
name|assert
argument_list|(
name|pthread_mutexattr_settype
argument_list|(
operator|&
name|mattr
argument_list|,
name|mutex_types
index|[
name|mkind
index|]
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|assert
argument_list|(
name|pthread_mutex_init
argument_list|(
operator|&
name|m
index|[
name|i
index|]
argument_list|,
operator|&
name|mattr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Set the ceiling priorities for the 3 priority protection 		 * mutexes to, 5 less than, equal to, and 5 greater than, 		 * this threads current priority. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|assert
argument_list|(
name|pthread_mutex_setprioceiling
argument_list|(
operator|&
name|m
index|[
name|i
index|]
argument_list|,
name|my_prio
operator|-
literal|5
operator|+
literal|5
operator|*
name|i
argument_list|,
operator|&
name|old_ceiling
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Check that if we attempt to take a mutex whose priority 		 * ceiling is lower than our priority, we get an error. 		 */
name|log
argument_list|(
literal|"    Lock with ceiling priority< thread priority - "
argument_list|)
expr_stmt|;
name|ret
operator|=
name|pthread_mutex_lock
argument_list|(
operator|&
name|m
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
comment|/* expected */
name|EINVAL
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|pthread_mutex_unlock
argument_list|(
operator|&
name|m
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* 		 * Check that we can take a mutex whose priority ceiling 		 * is equal to our priority. 		 */
name|log
argument_list|(
literal|"    Lock with ceiling priority = thread priority - "
argument_list|)
expr_stmt|;
name|ret
operator|=
name|pthread_mutex_lock
argument_list|(
operator|&
name|m
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
comment|/* expected */
literal|0
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|pthread_mutex_unlock
argument_list|(
operator|&
name|m
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* 		 * Check that we can take a mutex whose priority ceiling 		 * is higher than our priority. 		 */
name|log
argument_list|(
literal|"    Lock with ceiling priority> thread priority - "
argument_list|)
expr_stmt|;
name|ret
operator|=
name|pthread_mutex_lock
argument_list|(
operator|&
name|m
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|check_result
argument_list|(
comment|/* expected */
literal|0
argument_list|,
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|pthread_mutex_unlock
argument_list|(
operator|&
name|m
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
comment|/* 		 * Have the test thread go into a busy loop for 5 seconds 		 * and see that it doesn't block this thread (since the 		 * priority ceiling of mutex 0 and the priority of the test 		 * thread are both less than the priority of this thread). 		 */
name|log
argument_list|(
literal|"    Preemption with ceiling priority< thread "
literal|"priority - "
argument_list|)
expr_stmt|;
comment|/* Have the test thread take mutex 0. */
name|send_mutex_cmd
argument_list|(
name|test_thread_id
argument_list|,
name|CMD_TAKE_MUTEX
argument_list|,
operator|&
name|m
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|log_trace
argument_list|(
literal|"Sending busy command.\n"
argument_list|)
expr_stmt|;
name|send_cmd
argument_list|(
name|test_thread_id
argument_list|,
name|CMD_BUSY_LOOP
argument_list|)
expr_stmt|;
name|log_trace
argument_list|(
literal|"Busy sent, yielding\n"
argument_list|)
expr_stmt|;
name|pthread_yield
argument_list|()
expr_stmt|;
name|log_trace
argument_list|(
literal|"Returned from yield.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|states
index|[
name|test_thread_id
index|]
operator|.
name|flags
operator|&
operator|(
name|FLAGS_IS_BUSY
operator||
name|FLAGS_WAS_BUSY
operator|)
condition|)
name|log_error
argument_list|(
literal|"test thread inproperly preempted us.\n"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Let the thread finish its busy loop. */
name|sleep
argument_list|(
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|states
index|[
name|test_thread_id
index|]
operator|.
name|flags
operator|&
name|FLAGS_WAS_BUSY
operator|)
operator|==
literal|0
condition|)
name|log_error
argument_list|(
literal|"test thread never finished.\n"
argument_list|)
expr_stmt|;
else|else
name|log_pass
argument_list|()
expr_stmt|;
block|}
name|states
index|[
name|test_thread_id
index|]
operator|.
name|flags
operator|&=
operator|~
name|FLAGS_WAS_BUSY
expr_stmt|;
comment|/* Have the test thread release mutex 0. */
name|send_cmd
argument_list|(
name|test_thread_id
argument_list|,
name|CMD_RELEASE_ALL
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * Have the test thread go into a busy loop for 5 seconds 		 * and see that it preempts this thread (since the priority 		 * ceiling of mutex 1 is the same as the priority of this 		 * thread).  The test thread should not run to completion 		 * as its time quantum should expire before the 5 seconds 		 * are up. 		 */
name|log
argument_list|(
literal|"    Preemption with ceiling priority = thread "
literal|"priority - "
argument_list|)
expr_stmt|;
comment|/* Have the test thread take mutex 1. */
name|send_mutex_cmd
argument_list|(
name|test_thread_id
argument_list|,
name|CMD_TAKE_MUTEX
argument_list|,
operator|&
name|m
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|log_trace
argument_list|(
literal|"Sending busy\n"
argument_list|)
expr_stmt|;
name|send_cmd
argument_list|(
name|test_thread_id
argument_list|,
name|CMD_BUSY_LOOP
argument_list|)
expr_stmt|;
name|log_trace
argument_list|(
literal|"Busy sent, yielding\n"
argument_list|)
expr_stmt|;
name|pthread_yield
argument_list|()
expr_stmt|;
name|log_trace
argument_list|(
literal|"Returned from yield.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|states
index|[
name|test_thread_id
index|]
operator|.
name|flags
operator|&
name|FLAGS_IS_BUSY
operator|)
operator|==
literal|0
condition|)
name|log_error
argument_list|(
literal|"test thread did not switch in on yield.\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|states
index|[
name|test_thread_id
index|]
operator|.
name|flags
operator|&
name|FLAGS_WAS_BUSY
condition|)
name|log_error
argument_list|(
literal|"test thread ran to completion.\n"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Let the thread finish its busy loop. */
name|sleep
argument_list|(
literal|6
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|states
index|[
name|test_thread_id
index|]
operator|.
name|flags
operator|&
name|FLAGS_WAS_BUSY
operator|)
operator|==
literal|0
condition|)
name|log_error
argument_list|(
literal|"test thread never finished.\n"
argument_list|)
expr_stmt|;
else|else
name|log_pass
argument_list|()
expr_stmt|;
block|}
name|states
index|[
name|test_thread_id
index|]
operator|.
name|flags
operator|&=
operator|~
name|FLAGS_WAS_BUSY
expr_stmt|;
comment|/* Have the test thread release mutex 1. */
name|send_cmd
argument_list|(
name|test_thread_id
argument_list|,
name|CMD_RELEASE_ALL
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * Set the scheduling policy of the test thread to SCHED_FIFO 		 * and have it go into a busy loop for 5 seconds.  This 		 * thread is SCHED_RR, and since the priority ceiling of 		 * mutex 1 is the same as the priority of this thread, the 		 * test thread should run to completion once it is switched 		 * in. 		 */
name|log
argument_list|(
literal|"    SCHED_FIFO scheduling and ceiling priority = "
literal|"thread priority - "
argument_list|)
expr_stmt|;
name|param
operator|.
name|sched_priority
operator|=
name|states
index|[
name|test_thread_id
index|]
operator|.
name|priority
expr_stmt|;
name|assert
argument_list|(
name|pthread_setschedparam
argument_list|(
name|states
index|[
name|test_thread_id
index|]
operator|.
name|tid
argument_list|,
name|SCHED_FIFO
argument_list|,
operator|&
name|param
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Have the test thread take mutex 1. */
name|send_mutex_cmd
argument_list|(
name|test_thread_id
argument_list|,
name|CMD_TAKE_MUTEX
argument_list|,
operator|&
name|m
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|log_trace
argument_list|(
literal|"Sending busy\n"
argument_list|)
expr_stmt|;
name|send_cmd
argument_list|(
name|test_thread_id
argument_list|,
name|CMD_BUSY_LOOP
argument_list|)
expr_stmt|;
name|log_trace
argument_list|(
literal|"Busy sent, yielding\n"
argument_list|)
expr_stmt|;
name|pthread_yield
argument_list|()
expr_stmt|;
name|log_trace
argument_list|(
literal|"Returned from yield.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|states
index|[
name|test_thread_id
index|]
operator|.
name|flags
operator|&
name|FLAGS_WAS_BUSY
operator|)
operator|==
literal|0
condition|)
block|{
name|log_error
argument_list|(
literal|"test thread did not run to completion.\n"
argument_list|)
expr_stmt|;
comment|/* Let the thread finish it's busy loop. */
name|sleep
argument_list|(
literal|6
argument_list|)
expr_stmt|;
block|}
else|else
name|log_pass
argument_list|()
expr_stmt|;
name|states
index|[
name|test_thread_id
index|]
operator|.
name|flags
operator|&=
operator|~
name|FLAGS_WAS_BUSY
expr_stmt|;
comment|/* Restore the test thread scheduling parameters. */
name|param
operator|.
name|sched_priority
operator|=
name|states
index|[
name|test_thread_id
index|]
operator|.
name|priority
expr_stmt|;
name|assert
argument_list|(
name|pthread_setschedparam
argument_list|(
name|states
index|[
name|test_thread_id
index|]
operator|.
name|tid
argument_list|,
name|SCHED_RR
argument_list|,
operator|&
name|param
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Have the test thread release mutex 1. */
name|send_cmd
argument_list|(
name|test_thread_id
argument_list|,
name|CMD_RELEASE_ALL
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * Have the test thread go into a busy loop for 5 seconds 		 * and see that it preempts this thread (since the priority 		 * ceiling of mutex 2 is the greater than the priority of 		 * this thread).  The test thread should run to completion 		 * and block this thread because its active priority is 		 * higher. 		 */
name|log
argument_list|(
literal|"    SCHED_FIFO scheduling and ceiling priority> "
literal|"thread priority - "
argument_list|)
expr_stmt|;
comment|/* Have the test thread take mutex 2. */
name|send_mutex_cmd
argument_list|(
name|test_thread_id
argument_list|,
name|CMD_TAKE_MUTEX
argument_list|,
operator|&
name|m
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|log_trace
argument_list|(
literal|"Sending busy\n"
argument_list|)
expr_stmt|;
name|send_cmd
argument_list|(
name|test_thread_id
argument_list|,
name|CMD_BUSY_LOOP
argument_list|)
expr_stmt|;
name|log_trace
argument_list|(
literal|"Busy sent, yielding\n"
argument_list|)
expr_stmt|;
name|pthread_yield
argument_list|()
expr_stmt|;
name|log_trace
argument_list|(
literal|"Returned from yield.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|states
index|[
name|test_thread_id
index|]
operator|.
name|flags
operator|&
name|FLAGS_IS_BUSY
operator|)
operator|!=
literal|0
condition|)
block|{
name|log_error
argument_list|(
literal|"test thread did not run to completion.\n"
argument_list|)
expr_stmt|;
comment|/* Let the thread finish it's busy loop. */
name|sleep
argument_list|(
literal|6
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|states
index|[
name|test_thread_id
index|]
operator|.
name|flags
operator|&
name|FLAGS_WAS_BUSY
operator|)
operator|==
literal|0
condition|)
name|log_error
argument_list|(
literal|"test thread never finished.\n"
argument_list|)
expr_stmt|;
else|else
name|log_pass
argument_list|()
expr_stmt|;
name|states
index|[
name|test_thread_id
index|]
operator|.
name|flags
operator|&=
operator|~
name|FLAGS_WAS_BUSY
expr_stmt|;
comment|/* Have the test thread release mutex 2. */
name|send_cmd
argument_list|(
name|test_thread_id
argument_list|,
name|CMD_RELEASE_ALL
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Destroy the mutexes. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|assert
argument_list|(
name|pthread_mutex_destroy
argument_list|(
operator|&
name|m
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mutex_prioinherit_test
parameter_list|(
name|void
parameter_list|)
block|{
name|pthread_mutexattr_t
name|mattr
decl_stmt|;
name|struct
name|sched_param
name|param
decl_stmt|;
name|pthread_mutex_t
name|m
index|[
literal|3
index|]
decl_stmt|;
name|mutex_kind_t
name|mkind
decl_stmt|;
name|int
name|i
decl_stmt|,
name|policy
decl_stmt|,
name|my_prio
decl_stmt|;
comment|/* Get this threads current priority. */
name|assert
argument_list|(
name|pthread_getschedparam
argument_list|(
name|pthread_self
argument_list|()
argument_list|,
operator|&
name|policy
argument_list|,
operator|&
name|param
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|my_prio
operator|=
name|param
operator|.
name|sched_priority
expr_stmt|;
comment|/* save for later use */
name|log_trace
argument_list|(
literal|"Current scheduling policy %d, priority %d\n"
argument_list|,
name|policy
argument_list|,
name|my_prio
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"Testing priority inheritence\n"
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"----------------------------\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|mkind
operator|=
name|M_POSIX
init|;
name|mkind
operator|<=
name|M_SS2_RECURSIVE
condition|;
name|mkind
operator|++
control|)
block|{
name|log
argument_list|(
literal|"  Protype PTHREAD_PRIO_INHERIT, Type %s\n"
argument_list|,
name|mutextype_strs
index|[
name|mkind
index|]
argument_list|)
expr_stmt|;
comment|/* 		 * Initialize and create a mutex. 		 */
name|assert
argument_list|(
name|pthread_mutexattr_init
argument_list|(
operator|&
name|mattr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Initialize and create 3 priority inheritence mutexes with 		 * default (max priority) ceilings. 		 */
name|assert
argument_list|(
name|pthread_mutexattr_setprotocol
argument_list|(
operator|&
name|mattr
argument_list|,
name|PTHREAD_PRIO_INHERIT
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Ensure that the first mutex type is a POSIX 		 * compliant mutex. 		 */
if|if
condition|(
name|mkind
operator|!=
name|M_POSIX
condition|)
block|{
name|assert
argument_list|(
name|pthread_mutexattr_settype
argument_list|(
operator|&
name|mattr
argument_list|,
name|mutex_types
index|[
name|mkind
index|]
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|assert
argument_list|(
name|pthread_mutex_init
argument_list|(
operator|&
name|m
index|[
name|i
index|]
argument_list|,
operator|&
name|mattr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Test setup: 		 *   Thread 4 - take mutex 0, 1 		 *   Thread 2 - enter protected busy loop with mutex 0 		 *   Thread 3 - enter protected busy loop with mutex 1 		 *   Thread 4 - enter protected busy loop with mutex 2 		 *   Thread 5 - enter busy loop 		 *   Thread 6 - enter protected busy loop with mutex 0 		 *   Thread 4 - releases mutexes 1 and 0. 		 * 		 * Expected results: 		 *   Threads complete in order 4, 6, 5, 3, 2 		 */
name|log
argument_list|(
literal|"    Simple inheritence test - "
argument_list|)
expr_stmt|;
comment|/* 		 * Command thread 4 to take mutexes 0 and 1. 		 */
name|send_mutex_cmd
argument_list|(
literal|4
argument_list|,
name|CMD_TAKE_MUTEX
argument_list|,
operator|&
name|m
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Allow command to be received. */
name|send_mutex_cmd
argument_list|(
literal|4
argument_list|,
name|CMD_TAKE_MUTEX
argument_list|,
operator|&
name|m
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * Tell the threads to report themselves when they are 		 * at the bottom of their loop (waiting on wait_mutex). 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_THREADS
condition|;
name|i
operator|++
control|)
name|states
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|FLAGS_REPORT_WAITMUTEX
expr_stmt|;
comment|/* 		 * Command thread 2 to take mutex 0 and thread 3 to take 		 * mutex 1, both via a protected operation command.  Since 		 * thread 4 owns mutexes 0 and 1, both threads 2 and 3 		 * will block until the mutexes are released by thread 4. 		 */
name|log_trace
argument_list|(
literal|"Commanding protected operation to thread 2.\n"
argument_list|)
expr_stmt|;
name|send_mutex_cmd
argument_list|(
literal|2
argument_list|,
name|CMD_PROTECTED_OP
argument_list|,
operator|&
name|m
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|log_trace
argument_list|(
literal|"Commanding protected operation to thread 3.\n"
argument_list|)
expr_stmt|;
name|send_mutex_cmd
argument_list|(
literal|3
argument_list|,
name|CMD_PROTECTED_OP
argument_list|,
operator|&
name|m
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * Command thread 4 to take mutex 2 via a protected operation 		 * and thread 5 to enter a busy loop for 5 seconds.  Since 		 * thread 5 has higher priority than thread 4, thread 5 will 		 * enter the busy loop before thread 4 is activated. 		 */
name|log_trace
argument_list|(
literal|"Commanding protected operation to thread 4.\n"
argument_list|)
expr_stmt|;
name|send_mutex_cmd
argument_list|(
literal|4
argument_list|,
name|CMD_PROTECTED_OP
argument_list|,
operator|&
name|m
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|log_trace
argument_list|(
literal|"Commanding busy loop to thread 5.\n"
argument_list|)
expr_stmt|;
name|send_cmd
argument_list|(
literal|5
argument_list|,
name|CMD_BUSY_LOOP
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|states
index|[
literal|5
index|]
operator|.
name|flags
operator|&
name|FLAGS_IS_BUSY
operator|)
operator|==
literal|0
condition|)
name|log_error
argument_list|(
literal|"thread 5 is not running.\n"
argument_list|)
expr_stmt|;
name|log_trace
argument_list|(
literal|"Commanding protected operation thread 6.\n"
argument_list|)
expr_stmt|;
name|send_mutex_cmd
argument_list|(
literal|6
argument_list|,
name|CMD_PROTECTED_OP
argument_list|,
operator|&
name|m
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|states
index|[
literal|4
index|]
operator|.
name|flags
operator|&
name|FLAGS_WAS_BUSY
operator|)
operator|==
literal|0
condition|)
name|log_error
argument_list|(
literal|"thread 4 failed to inherit priority.\n"
argument_list|)
expr_stmt|;
name|states
index|[
literal|4
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|send_cmd
argument_list|(
literal|4
argument_list|,
name|CMD_RELEASE_ALL
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|check_run_order
argument_list|(
literal|"4,6,5,3,2"
argument_list|)
expr_stmt|;
comment|/* 		 * Clear the flags. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_THREADS
condition|;
name|i
operator|++
control|)
name|states
index|[
name|i
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Test setup: 		 *   Thread 2 - enter busy loop (SCHED_FIFO) 		 *   Thread 4 - take mutex 0 		 *   Thread 4 - priority change to same priority as thread 2 		 *   Thread 4 - release mutex 0 		 * 		 * Expected results: 		 *   Since thread 4 owns a priority mutex, it should be 		 *   placed at the front of the run queue (for its new 		 *   priority slot) when its priority is lowered to the 		 *   same priority as thread 2.  If thread 4 did not own 		 *   a priority mutex, then it would have been added to 		 *   the end of the run queue and thread 2 would have 		 *   executed until it blocked (because it's scheduling 		 *   policy is SCHED_FIFO). 		 *    		 */
name|log
argument_list|(
literal|"    Inheritence test with change of priority - "
argument_list|)
expr_stmt|;
comment|/* 		 * Change threads 2 and 4 scheduling policies to be 		 * SCHED_FIFO. 		 */
name|param
operator|.
name|sched_priority
operator|=
name|states
index|[
literal|2
index|]
operator|.
name|priority
expr_stmt|;
name|assert
argument_list|(
name|pthread_setschedparam
argument_list|(
name|states
index|[
literal|2
index|]
operator|.
name|tid
argument_list|,
name|SCHED_FIFO
argument_list|,
operator|&
name|param
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|param
operator|.
name|sched_priority
operator|=
name|states
index|[
literal|4
index|]
operator|.
name|priority
expr_stmt|;
name|assert
argument_list|(
name|pthread_setschedparam
argument_list|(
name|states
index|[
literal|4
index|]
operator|.
name|tid
argument_list|,
name|SCHED_FIFO
argument_list|,
operator|&
name|param
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Command thread 4 to take mutex 0. 		 */
name|send_mutex_cmd
argument_list|(
literal|4
argument_list|,
name|CMD_TAKE_MUTEX
argument_list|,
operator|&
name|m
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * Command thread 2 to enter busy loop. 		 */
name|send_cmd
argument_list|(
literal|2
argument_list|,
name|CMD_BUSY_LOOP
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Allow command to be received. */
comment|/* 		 * Command thread 4 to enter busy loop. 		 */
name|send_cmd
argument_list|(
literal|4
argument_list|,
name|CMD_BUSY_LOOP
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Allow command to be received. */
comment|/* Have threads 2 and 4 report themselves. */
name|states
index|[
literal|2
index|]
operator|.
name|flags
operator|=
name|FLAGS_REPORT_WAITMUTEX
expr_stmt|;
name|states
index|[
literal|4
index|]
operator|.
name|flags
operator|=
name|FLAGS_REPORT_WAITMUTEX
expr_stmt|;
comment|/* Change the priority of thread 4. */
name|param
operator|.
name|sched_priority
operator|=
name|states
index|[
literal|2
index|]
operator|.
name|priority
expr_stmt|;
name|assert
argument_list|(
name|pthread_setschedparam
argument_list|(
name|states
index|[
literal|4
index|]
operator|.
name|tid
argument_list|,
name|SCHED_FIFO
argument_list|,
operator|&
name|param
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|5
argument_list|)
expr_stmt|;
name|check_run_order
argument_list|(
literal|"4,2"
argument_list|)
expr_stmt|;
comment|/* Clear the flags */
name|states
index|[
literal|2
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
name|states
index|[
literal|4
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* Reset the policies. */
name|param
operator|.
name|sched_priority
operator|=
name|states
index|[
literal|2
index|]
operator|.
name|priority
expr_stmt|;
name|assert
argument_list|(
name|pthread_setschedparam
argument_list|(
name|states
index|[
literal|2
index|]
operator|.
name|tid
argument_list|,
name|SCHED_RR
argument_list|,
operator|&
name|param
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|param
operator|.
name|sched_priority
operator|=
name|states
index|[
literal|4
index|]
operator|.
name|priority
expr_stmt|;
name|assert
argument_list|(
name|pthread_setschedparam
argument_list|(
name|states
index|[
literal|4
index|]
operator|.
name|tid
argument_list|,
name|SCHED_RR
argument_list|,
operator|&
name|param
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|send_cmd
argument_list|(
literal|4
argument_list|,
name|CMD_RELEASE_MUTEX
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Destroy the mutexes. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|assert
argument_list|(
name|pthread_mutex_destroy
argument_list|(
operator|&
name|m
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|pthread_mutexattr_t
name|mattr
decl_stmt|;
name|pthread_condattr_t
name|cattr
decl_stmt|;
name|pthread_attr_t
name|pattr
decl_stmt|;
name|int
name|i
decl_stmt|,
name|policy
decl_stmt|,
name|main_prio
decl_stmt|;
name|void
modifier|*
name|exit_status
decl_stmt|;
name|sigset_t
name|mask
decl_stmt|;
name|struct
name|sigaction
name|act
decl_stmt|;
name|struct
name|sched_param
name|param
decl_stmt|;
name|assert
argument_list|(
name|pthread_getschedparam
argument_list|(
name|pthread_self
argument_list|()
argument_list|,
operator|&
name|policy
argument_list|,
operator|&
name|param
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|main_prio
operator|=
name|param
operator|.
name|sched_priority
expr_stmt|;
comment|/* Setupt our signal mask. */
name|sigfillset
argument_list|(
operator|&
name|mask
argument_list|)
expr_stmt|;
name|sigdelset
argument_list|(
operator|&
name|mask
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|mask
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Install a signal handler for SIGINT */
name|sigemptyset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|sigaddset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_handler
operator|=
name|sighandler
expr_stmt|;
name|act
operator|.
name|sa_flags
operator|=
name|SA_RESTART
expr_stmt|;
name|sigaction
argument_list|(
name|SIGINT
argument_list|,
operator|&
name|act
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the thread attribute. 	 */
name|assert
argument_list|(
name|pthread_attr_init
argument_list|(
operator|&
name|pattr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_attr_setdetachstate
argument_list|(
operator|&
name|pattr
argument_list|,
name|PTHREAD_CREATE_JOINABLE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize and create the waiter and condvar mutexes. 	 */
name|assert
argument_list|(
name|pthread_mutexattr_init
argument_list|(
operator|&
name|mattr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_mutex_init
argument_list|(
operator|&
name|waiter_mutex
argument_list|,
operator|&
name|mattr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_mutex_init
argument_list|(
operator|&
name|cond_mutex
argument_list|,
operator|&
name|mattr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize and create a condition variable. 	 */
name|assert
argument_list|(
name|pthread_condattr_init
argument_list|(
operator|&
name|cattr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_cond_init
argument_list|(
operator|&
name|cond_var
argument_list|,
operator|&
name|cattr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* Create a pipe to catch the results of thread wakeups. */
name|assert
argument_list|(
name|pipe
argument_list|(
name|pipefd
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|assert
argument_list|(
name|pthread_switch_add_np
argument_list|(
name|kern_switch
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Create the waiting threads. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_THREADS
condition|;
name|i
operator|++
control|)
block|{
name|assert
argument_list|(
name|pthread_cond_init
argument_list|(
operator|&
name|states
index|[
name|i
index|]
operator|.
name|cond_var
argument_list|,
operator|&
name|cattr
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|states
index|[
name|i
index|]
operator|.
name|id
operator|=
operator|(
name|u_int8_t
operator|)
name|i
expr_stmt|;
comment|/* NUM_THREADS must be<= 256 */
name|states
index|[
name|i
index|]
operator|.
name|status
operator|=
literal|0
expr_stmt|;
name|states
index|[
name|i
index|]
operator|.
name|cmd
operator|.
name|cmd_id
operator|=
name|CMD_NONE
expr_stmt|;
name|states
index|[
name|i
index|]
operator|.
name|flags
operator|=
literal|0
expr_stmt|;
comment|/* No flags yet. */
name|assert
argument_list|(
name|pthread_create
argument_list|(
operator|&
name|states
index|[
name|i
index|]
operator|.
name|tid
argument_list|,
operator|&
name|pattr
argument_list|,
name|waiter
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|states
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|param
operator|.
name|sched_priority
operator|=
name|main_prio
operator|-
literal|10
operator|+
name|i
expr_stmt|;
name|states
index|[
name|i
index|]
operator|.
name|priority
operator|=
name|param
operator|.
name|sched_priority
expr_stmt|;
name|assert
argument_list|(
name|pthread_setschedparam
argument_list|(
name|states
index|[
name|i
index|]
operator|.
name|tid
argument_list|,
name|SCHED_OTHER
argument_list|,
operator|&
name|param
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_LIBC_R_
argument_list|)
block|{
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"waiter_%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|pthread_set_name_np
argument_list|(
name|states
index|[
name|i
index|]
operator|.
name|tid
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
comment|/* Allow the threads to start. */
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|log_trace
argument_list|(
literal|"Done creating threads.\n"
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|mutex_init_test
argument_list|()
expr_stmt|;
name|log
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|mutex_destroy_test
argument_list|()
expr_stmt|;
name|log
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|mutex_lock_test
argument_list|()
expr_stmt|;
name|log
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|mutex_unlock_test
argument_list|()
expr_stmt|;
name|log
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|queueing_order_test
argument_list|()
expr_stmt|;
name|log
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|mutex_prioinherit_test
argument_list|()
expr_stmt|;
name|log
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|mutex_prioceiling_test
argument_list|()
expr_stmt|;
name|log
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|log
argument_list|(
literal|"Total tests %d, passed %d, failed %d\n"
argument_list|,
name|total
argument_list|,
name|pass_count
argument_list|,
name|error_count
argument_list|)
expr_stmt|;
comment|/* Set the done flag and signal the threads to exit. */
name|log_trace
argument_list|(
literal|"Setting done flag.\n"
argument_list|)
expr_stmt|;
name|done
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Wait for the threads to finish. 	 */
name|log_trace
argument_list|(
literal|"Trying to join threads.\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_THREADS
condition|;
name|i
operator|++
control|)
block|{
name|send_cmd
argument_list|(
name|i
argument_list|,
name|CMD_NONE
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|pthread_join
argument_list|(
name|states
index|[
name|i
index|]
operator|.
name|tid
argument_list|,
operator|&
name|exit_status
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Clean up after ourselves. */
name|close
argument_list|(
name|pipefd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|pipefd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_count
operator|!=
literal|0
condition|)
name|exit
argument_list|(
name|EX_OSERR
argument_list|)
expr_stmt|;
comment|/* any better ideas??? */
else|else
name|exit
argument_list|(
name|EX_OK
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

