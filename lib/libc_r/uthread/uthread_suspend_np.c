begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1995-1998 John Birrell<jb@cimlogic.com.au>.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by John Birrell.  * 4. Neither the name of the author nor the names of any co-contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY JOHN BIRRELL AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|"pthread_private.h"
end_include

begin_function_decl
specifier|static
name|void
name|finish_suspension
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
end_function_decl

begin_pragma
pragma|#
directive|pragma
name|weak
name|pthread_suspend_np
name|=
name|_pthread_suspend_np
end_pragma

begin_comment
comment|/* Suspend a thread: */
end_comment

begin_function
name|int
name|_pthread_suspend_np
parameter_list|(
name|pthread_t
name|thread
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
comment|/* Find the thread in the list of active threads: */
if|if
condition|(
operator|(
name|ret
operator|=
name|_find_thread
argument_list|(
name|thread
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Defer signals to protect the scheduling queues from 		 * access by the signal handler: 		 */
name|_thread_kern_sig_defer
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|thread
operator|->
name|state
condition|)
block|{
case|case
name|PS_RUNNING
case|:
comment|/* 			 * Remove the thread from the priority queue and 			 * set the state to suspended: 			 */
name|PTHREAD_PRIOQ_REMOVE
argument_list|(
name|thread
argument_list|)
expr_stmt|;
name|PTHREAD_SET_STATE
argument_list|(
name|thread
argument_list|,
name|PS_SUSPENDED
argument_list|)
expr_stmt|;
break|break;
case|case
name|PS_SPINBLOCK
case|:
case|case
name|PS_FDR_WAIT
case|:
case|case
name|PS_FDW_WAIT
case|:
case|case
name|PS_POLL_WAIT
case|:
case|case
name|PS_SELECT_WAIT
case|:
comment|/* 			 * Remove these threads from the work queue 			 * and mark the operation as interrupted: 			 */
if|if
condition|(
operator|(
name|thread
operator|->
name|flags
operator|&
name|PTHREAD_FLAGS_IN_WORKQ
operator|)
operator|!=
literal|0
condition|)
name|PTHREAD_WORKQ_REMOVE
argument_list|(
name|thread
argument_list|)
expr_stmt|;
name|_thread_seterrno
argument_list|(
name|thread
argument_list|,
name|EINTR
argument_list|)
expr_stmt|;
name|thread
operator|->
name|interrupted
operator|=
literal|1
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|PS_SIGTHREAD
case|:
case|case
name|PS_SLEEP_WAIT
case|:
case|case
name|PS_WAIT_WAIT
case|:
case|case
name|PS_SIGSUSPEND
case|:
case|case
name|PS_SIGWAIT
case|:
comment|/* 			 * Remove these threads from the waiting queue and 			 * set their state to suspended: 			 */
name|PTHREAD_WAITQ_REMOVE
argument_list|(
name|thread
argument_list|)
expr_stmt|;
name|PTHREAD_SET_STATE
argument_list|(
name|thread
argument_list|,
name|PS_SUSPENDED
argument_list|)
expr_stmt|;
break|break;
case|case
name|PS_MUTEX_WAIT
case|:
comment|/* Mark the thread as suspended and still in a queue. */
name|thread
operator|->
name|suspended
operator|=
name|SUSP_MUTEX_WAIT
expr_stmt|;
name|PTHREAD_SET_STATE
argument_list|(
name|thread
argument_list|,
name|PS_SUSPENDED
argument_list|)
expr_stmt|;
break|break;
case|case
name|PS_COND_WAIT
case|:
comment|/* Mark the thread as suspended and still in a queue. */
name|thread
operator|->
name|suspended
operator|=
name|SUSP_COND_WAIT
expr_stmt|;
name|PTHREAD_SET_STATE
argument_list|(
name|thread
argument_list|,
name|PS_SUSPENDED
argument_list|)
expr_stmt|;
break|break;
case|case
name|PS_FDLR_WAIT
case|:
case|case
name|PS_FDLW_WAIT
case|:
case|case
name|PS_FILE_WAIT
case|:
case|case
name|PS_JOIN
case|:
comment|/* Mark the thread as suspended: */
name|thread
operator|->
name|suspended
operator|=
name|SUSP_YES
expr_stmt|;
comment|/* 			 * Threads in these states may be in queues. 			 * In order to preserve queue integrity, the 			 * cancelled thread must remove itself from the 			 * queue.  Mark the thread as interrupted and 			 * set the state to running.  When the thread 			 * resumes, it will remove itself from the queue 			 * and call the suspension completion routine. 			 */
name|thread
operator|->
name|interrupted
operator|=
literal|1
expr_stmt|;
name|_thread_seterrno
argument_list|(
name|thread
argument_list|,
name|EINTR
argument_list|)
expr_stmt|;
name|PTHREAD_NEW_STATE
argument_list|(
name|thread
argument_list|,
name|PS_RUNNING
argument_list|)
expr_stmt|;
name|thread
operator|->
name|continuation
operator|=
name|finish_suspension
expr_stmt|;
break|break;
case|case
name|PS_DEAD
case|:
case|case
name|PS_DEADLOCK
case|:
case|case
name|PS_STATE_MAX
case|:
case|case
name|PS_SUSPENDED
case|:
comment|/* Nothing needs to be done: */
break|break;
block|}
comment|/* 		 * Undefer and handle pending signals, yielding if 		 * necessary: 		 */
name|_thread_kern_sig_undefer
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|finish_suspension
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|pthread
modifier|*
name|curthread
init|=
name|_get_curthread
argument_list|()
decl_stmt|;
if|if
condition|(
name|curthread
operator|->
name|suspended
operator|!=
name|SUSP_NO
condition|)
name|_thread_kern_sched_state
argument_list|(
name|PS_SUSPENDED
argument_list|,
name|__FILE__
argument_list|,
name|__LINE__
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

