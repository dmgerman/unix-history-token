begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2004 David Xu<davidxu@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_include
include|#
directive|include
file|<thr_private.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/kse.h>
end_include

begin_include
include|#
directive|include
file|"pthread_dbg_md.h"
end_include

begin_include
include|#
directive|include
file|"pthread_dbg.h"
end_include

begin_include
include|#
directive|include
file|"pthread_dbg_int.h"
end_include

begin_function_decl
specifier|static
name|void
name|td_empty_thread_list
parameter_list|(
name|td_proc_t
modifier|*
name|proc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|td_refresh_thread_list
parameter_list|(
name|td_proc_t
modifier|*
name|proc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|td_get_thread
parameter_list|(
name|td_proc_t
modifier|*
name|proc
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|type
parameter_list|,
name|td_thread_t
modifier|*
modifier|*
name|threadp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|td_remove_map
parameter_list|(
name|td_proc_t
modifier|*
name|proc
parameter_list|,
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|td_open
parameter_list|(
name|td_proc_callbacks_t
modifier|*
name|cb
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|td_proc_t
modifier|*
modifier|*
name|procp
parameter_list|)
block|{
define|#
directive|define
name|LOOKUP_SYM
parameter_list|(
name|proc
parameter_list|,
name|sym
parameter_list|,
name|addr
parameter_list|)
define|\
value|ret = LOOKUP(proc, sym, addr);			\ 	if (ret != 0) {					\ 		if (ret == TD_ERR_NOSYM)		\ 			ret = TD_ERR_NOLIB;		\ 		goto error;				\ 	}
name|td_proc_t
modifier|*
name|proc
decl_stmt|;
name|int
name|dbg
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|td_md_init
argument_list|()
expr_stmt|;
name|proc
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|proc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|proc
operator|==
name|NULL
condition|)
return|return
operator|(
name|TD_ERR_NOMEM
operator|)
return|;
name|proc
operator|->
name|cb
operator|=
name|cb
expr_stmt|;
name|proc
operator|->
name|arg
operator|=
name|arg
expr_stmt|;
name|proc
operator|->
name|thread_activated
operator|=
literal|0
expr_stmt|;
name|proc
operator|->
name|thread_listgen
operator|=
operator|-
literal|1
expr_stmt|;
name|TAILQ_INIT
argument_list|(
operator|&
name|proc
operator|->
name|threads
argument_list|)
expr_stmt|;
name|LOOKUP_SYM
argument_list|(
name|proc
argument_list|,
literal|"_libkse_debug"
argument_list|,
operator|&
name|proc
operator|->
name|libkse_debug_addr
argument_list|)
expr_stmt|;
name|LOOKUP_SYM
argument_list|(
name|proc
argument_list|,
literal|"_thread_list"
argument_list|,
operator|&
name|proc
operator|->
name|thread_list_addr
argument_list|)
expr_stmt|;
name|LOOKUP_SYM
argument_list|(
name|proc
argument_list|,
literal|"_thread_listgen"
argument_list|,
operator|&
name|proc
operator|->
name|thread_listgen_addr
argument_list|)
expr_stmt|;
name|LOOKUP_SYM
argument_list|(
name|proc
argument_list|,
literal|"_thread_activated"
argument_list|,
operator|&
name|proc
operator|->
name|thread_activated_addr
argument_list|)
expr_stmt|;
comment|/*	LOOKUP_SYM(proc, "_thread_active_kseq",&proc->thread_active_kseq_addr);*/
name|dbg
operator|=
name|getpid
argument_list|()
expr_stmt|;
comment|/* 	 * If this fails it probably means we're debugging a core file and 	 * can't write to it. 	 * If it's something else we'll lose the next time we hit WRITE, 	 * but not before, and that's OK. 	 */
name|WRITE
argument_list|(
name|proc
argument_list|,
name|proc
operator|->
name|libkse_debug_addr
argument_list|,
operator|&
name|dbg
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|procp
operator|=
name|proc
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|error
label|:
name|free
argument_list|(
name|proc
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|td_close
parameter_list|(
name|td_proc_t
modifier|*
name|proc
parameter_list|)
block|{
name|int
name|dbg
decl_stmt|;
name|td_empty_thread_list
argument_list|(
name|proc
argument_list|)
expr_stmt|;
name|dbg
operator|=
literal|0
expr_stmt|;
comment|/*          * Error returns from this write are not really a problem;          * the process doesn't exist any more.          */
name|WRITE
argument_list|(
name|proc
argument_list|,
name|proc
operator|->
name|libkse_debug_addr
argument_list|,
operator|&
name|dbg
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|proc
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|td_thr_iter
parameter_list|(
name|td_proc_t
modifier|*
name|proc
parameter_list|,
name|int
function_decl|(
modifier|*
name|call
function_decl|)
parameter_list|(
name|td_thread_t
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|callarg
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|td_thread_t
modifier|*
name|thread
decl_stmt|;
name|td_refresh_thread_list
argument_list|(
name|proc
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|thread
argument_list|,
argument|&proc->threads
argument_list|,
argument|tle
argument_list|)
block|{
name|ret
operator|=
call|(
modifier|*
name|call
call|)
argument_list|(
name|thread
argument_list|,
name|callarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|td_thr_info
parameter_list|(
name|td_thread_t
modifier|*
name|thread
parameter_list|,
name|td_thread_info_t
modifier|*
name|info
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|struct
name|pthread
name|pt
decl_stmt|;
name|memset
argument_list|(
name|info
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|thread
operator|->
name|type
operator|==
name|TD_TYPE_UPCALL
condition|)
block|{
name|info
operator|->
name|thread_id
operator|=
operator|(
name|long
operator|)
name|thread
operator|->
name|kthread
expr_stmt|;
name|info
operator|->
name|thread_state
operator|=
name|TD_STATE_RUNNING
expr_stmt|;
name|info
operator|->
name|thread_type
operator|=
name|TD_TYPE_UPCALL
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* Handle normal thread */
name|ret
operator|=
name|READ
argument_list|(
name|thread
operator|->
name|proc
argument_list|,
name|thread
operator|->
name|addr
argument_list|,
operator|&
name|pt
argument_list|,
sizeof|sizeof
argument_list|(
name|pt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|pt
operator|.
name|magic
operator|!=
name|THR_MAGIC
condition|)
return|return
operator|(
name|TD_ERR_BADTHREAD
operator|)
return|;
name|info
operator|->
name|thread_id
operator|=
operator|(
name|long
operator|)
name|thread
operator|->
name|addr
expr_stmt|;
name|info
operator|->
name|thread_addr
operator|=
name|thread
operator|->
name|addr
expr_stmt|;
name|info
operator|->
name|thread_type
operator|=
name|TD_TYPE_NORMAL
expr_stmt|;
switch|switch
condition|(
name|pt
operator|.
name|state
condition|)
block|{
case|case
name|PS_RUNNING
case|:
name|info
operator|->
name|thread_state
operator|=
name|TD_STATE_RUNNING
expr_stmt|;
break|break;
case|case
name|PS_LOCKWAIT
case|:
name|info
operator|->
name|thread_state
operator|=
name|TD_STATE_LOCKWAIT
expr_stmt|;
break|break;
case|case
name|PS_MUTEX_WAIT
case|:
name|info
operator|->
name|thread_state
operator|=
name|TD_STATE_MUTEXWAIT
expr_stmt|;
break|break;
case|case
name|PS_COND_WAIT
case|:
name|info
operator|->
name|thread_state
operator|=
name|TD_STATE_SLEEPING
expr_stmt|;
break|break;
case|case
name|PS_SIGSUSPEND
case|:
name|info
operator|->
name|thread_state
operator|=
name|TD_STATE_SIGSUSPEND
expr_stmt|;
break|break;
case|case
name|PS_SIGWAIT
case|:
name|info
operator|->
name|thread_state
operator|=
name|TD_STATE_SIGWAIT
expr_stmt|;
break|break;
case|case
name|PS_JOIN
case|:
name|info
operator|->
name|thread_state
operator|=
name|TD_STATE_JOIN
expr_stmt|;
break|break;
case|case
name|PS_SUSPENDED
case|:
name|info
operator|->
name|thread_state
operator|=
name|TD_STATE_SUSPENDED
expr_stmt|;
break|break;
case|case
name|PS_DEAD
case|:
name|info
operator|->
name|thread_state
operator|=
name|TD_STATE_DEAD
expr_stmt|;
break|break;
case|case
name|PS_DEADLOCK
case|:
name|info
operator|->
name|thread_state
operator|=
name|TD_STATE_DEADLOCK
expr_stmt|;
break|break;
default|default:
name|info
operator|->
name|thread_state
operator|=
name|TD_STATE_UNKNOWN
expr_stmt|;
break|break;
block|}
name|info
operator|->
name|thread_scope
operator|=
operator|(
name|pt
operator|.
name|attr
operator|.
name|flags
operator|&
name|PTHREAD_SCOPE_SYSTEM
operator|)
condition|?
name|TD_SCOPE_SYSTEM
else|:
name|TD_SCOPE_PROCESS
expr_stmt|;
name|info
operator|->
name|thread_stack
operator|.
name|ss_sp
operator|=
name|pt
operator|.
name|attr
operator|.
name|stackaddr_attr
expr_stmt|;
name|info
operator|->
name|thread_stack
operator|.
name|ss_size
operator|=
name|pt
operator|.
name|attr
operator|.
name|stacksize_attr
expr_stmt|;
name|info
operator|->
name|thread_joiner
operator|=
operator|(
name|caddr_t
operator|)
name|pt
operator|.
name|joiner
expr_stmt|;
name|info
operator|->
name|thread_errno
operator|=
name|pt
operator|.
name|error
expr_stmt|;
name|info
operator|->
name|thread_sigmask
operator|=
name|pt
operator|.
name|sigmask
expr_stmt|;
name|info
operator|->
name|thread_sigpend
operator|=
name|pt
operator|.
name|sigpend
expr_stmt|;
name|info
operator|->
name|thread_sigstk
operator|=
name|pt
operator|.
name|sigstk
expr_stmt|;
name|info
operator|->
name|thread_base_priority
operator|=
name|pt
operator|.
name|base_priority
expr_stmt|;
name|info
operator|->
name|thread_inherited_priority
operator|=
name|pt
operator|.
name|inherited_priority
expr_stmt|;
name|info
operator|->
name|thread_active_priority
operator|=
name|pt
operator|.
name|active_priority
expr_stmt|;
name|info
operator|->
name|thread_cancelflags
operator|=
name|pt
operator|.
name|cancelflags
expr_stmt|;
name|info
operator|->
name|thread_retval
operator|=
name|pt
operator|.
name|join_status
operator|.
name|ret
expr_stmt|;
name|info
operator|->
name|thread_tls
operator|=
operator|(
name|caddr_t
operator|)
name|pt
operator|.
name|specific
expr_stmt|;
name|info
operator|->
name|thread_tlscount
operator|=
name|pt
operator|.
name|specific_data_count
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|td_thr_getregs
parameter_list|(
name|td_thread_t
modifier|*
name|thread
parameter_list|,
name|int
name|regset
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|td_proc_t
modifier|*
name|proc
init|=
name|thread
operator|->
name|proc
decl_stmt|;
name|caddr_t
name|tmbx_addr
decl_stmt|,
name|ptr
decl_stmt|;
name|struct
name|kse_thr_mailbox
name|tmbx
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|regset
operator|!=
literal|0
operator|&&
name|regset
operator|!=
literal|1
condition|)
return|return
operator|(
name|TD_ERR_INVAL
operator|)
return|;
if|if
condition|(
name|thread
operator|->
name|kthread
operator|!=
name|NULL
condition|)
return|return
name|GETREGS
argument_list|(
name|proc
argument_list|,
name|regset
argument_list|,
name|thread
operator|->
name|kthread
argument_list|,
name|buf
argument_list|)
return|;
name|tmbx_addr
operator|=
name|thread
operator|->
name|tcb_addr
operator|+
name|offsetof
argument_list|(
expr|struct
name|tcb
argument_list|,
name|tcb_tmbx
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|tmbx_addr
operator|+
name|offsetof
argument_list|(
expr|struct
name|kse_thr_mailbox
argument_list|,
name|tm_kthread
argument_list|)
expr_stmt|;
name|ret
operator|=
name|READ
argument_list|(
name|proc
argument_list|,
name|ptr
argument_list|,
operator|&
name|ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
return|return
name|GETREGS
argument_list|(
name|proc
argument_list|,
name|regset
argument_list|,
name|ptr
argument_list|,
name|buf
argument_list|)
return|;
name|ret
operator|=
name|READ
argument_list|(
name|proc
argument_list|,
name|tmbx_addr
argument_list|,
operator|&
name|tmbx
argument_list|,
sizeof|sizeof
argument_list|(
name|tmbx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|regset
operator|==
literal|0
condition|)
name|td_ucontext_to_reg
argument_list|(
operator|&
name|tmbx
operator|.
name|tm_context
argument_list|,
operator|(
expr|struct
name|reg
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
else|else
name|td_ucontext_to_fpreg
argument_list|(
operator|&
name|tmbx
operator|.
name|tm_context
argument_list|,
operator|(
expr|struct
name|fpreg
operator|*
operator|)
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|td_thr_setregs
parameter_list|(
name|td_thread_t
modifier|*
name|thread
parameter_list|,
name|int
name|regset
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|)
block|{
name|td_proc_t
modifier|*
name|proc
init|=
name|thread
operator|->
name|proc
decl_stmt|;
name|caddr_t
name|tmbx_addr
decl_stmt|,
name|ptr
decl_stmt|;
name|struct
name|kse_thr_mailbox
name|tmbx
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|regset
operator|!=
literal|0
operator|&&
name|regset
operator|!=
literal|1
condition|)
return|return
operator|(
name|TD_ERR_INVAL
operator|)
return|;
if|if
condition|(
name|thread
operator|->
name|kthread
operator|!=
name|NULL
condition|)
return|return
name|SETREGS
argument_list|(
name|proc
argument_list|,
name|regset
argument_list|,
name|thread
operator|->
name|kthread
argument_list|,
name|buf
argument_list|)
return|;
name|tmbx_addr
operator|=
name|thread
operator|->
name|tcb_addr
operator|+
name|offsetof
argument_list|(
expr|struct
name|tcb
argument_list|,
name|tcb_tmbx
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|tmbx_addr
operator|+
name|offsetof
argument_list|(
expr|struct
name|kse_thr_mailbox
argument_list|,
name|tm_kthread
argument_list|)
expr_stmt|;
name|ret
operator|=
name|READ
argument_list|(
name|proc
argument_list|,
name|ptr
argument_list|,
operator|&
name|ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
return|return
name|SETREGS
argument_list|(
name|proc
argument_list|,
name|regset
argument_list|,
name|ptr
argument_list|,
name|buf
argument_list|)
return|;
comment|/* 	 * Read a copy of context, this makes sure that registers 	 * not covered by structure reg won't be clobbered 	 */
name|ret
operator|=
name|READ
argument_list|(
name|proc
argument_list|,
name|tmbx_addr
argument_list|,
operator|&
name|tmbx
argument_list|,
sizeof|sizeof
argument_list|(
name|tmbx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|regset
operator|==
literal|0
condition|)
name|td_reg_to_ucontext
argument_list|(
operator|(
expr|struct
name|reg
operator|*
operator|)
name|buf
argument_list|,
operator|&
name|tmbx
operator|.
name|tm_context
argument_list|)
expr_stmt|;
else|else
name|td_fpreg_to_ucontext
argument_list|(
operator|(
expr|struct
name|fpreg
operator|*
operator|)
name|buf
argument_list|,
operator|&
name|tmbx
operator|.
name|tm_context
argument_list|)
expr_stmt|;
return|return
operator|(
name|WRITE
argument_list|(
name|proc
argument_list|,
name|tmbx_addr
argument_list|,
operator|&
name|tmbx
argument_list|,
sizeof|sizeof
argument_list|(
name|tmbx
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|td_thr_getname
parameter_list|(
name|td_thread_t
modifier|*
name|thread
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|caddr_t
name|nameaddr
decl_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|READ
argument_list|(
name|thread
operator|->
name|proc
argument_list|,
name|thread
operator|->
name|addr
operator|+
name|offsetof
argument_list|(
expr|struct
name|pthread
argument_list|,
name|name
argument_list|)
argument_list|,
operator|&
name|nameaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|nameaddr
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|nameaddr
operator|==
literal|0
condition|)
name|name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|ret
operator|=
name|READ_STRING
argument_list|(
name|thread
operator|->
name|proc
argument_list|,
name|nameaddr
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|td_activated
parameter_list|(
name|td_proc_t
modifier|*
name|proc
parameter_list|)
block|{
if|if
condition|(
name|proc
operator|->
name|thread_activated
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|READ
argument_list|(
name|proc
argument_list|,
name|proc
operator|->
name|thread_activated_addr
argument_list|,
operator|&
name|proc
operator|->
name|thread_activated
argument_list|,
sizeof|sizeof
argument_list|(
name|proc
operator|->
name|thread_activated
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|proc
operator|->
name|thread_activated
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|td_map_lwp2thr
parameter_list|(
name|td_proc_t
modifier|*
name|proc
parameter_list|,
name|void
modifier|*
name|lwp
parameter_list|,
name|td_thread_t
modifier|*
modifier|*
name|threadp
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|caddr_t
name|next
decl_stmt|,
name|ptr
decl_stmt|;
name|td_thread_t
modifier|*
name|thread
decl_stmt|;
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|pthread
argument_list|)
name|thread_list
expr_stmt|;
name|ret
operator|=
name|READ
argument_list|(
name|proc
argument_list|,
name|proc
operator|->
name|thread_list_addr
argument_list|,
operator|&
name|thread_list
argument_list|,
sizeof|sizeof
argument_list|(
name|thread_list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
comment|/* 	 * We have to iterate through thread list to find which 	 * userland thread is running on the kernel thread. 	 */
name|next
operator|=
operator|(
name|caddr_t
operator|)
name|thread_list
operator|.
name|tqh_first
expr_stmt|;
while|while
condition|(
name|next
operator|!=
name|NULL
condition|)
block|{
name|ret
operator|=
name|READ
argument_list|(
name|proc
argument_list|,
name|next
operator|+
name|offsetof
argument_list|(
expr|struct
name|pthread
argument_list|,
name|tcb
argument_list|)
argument_list|,
operator|&
name|ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|ptr
operator|+=
name|offsetof
argument_list|(
expr|struct
name|tcb
argument_list|,
name|tcb_tmbx
operator|.
name|tm_kthread
argument_list|)
expr_stmt|;
name|ret
operator|=
name|READ
argument_list|(
name|proc
argument_list|,
name|ptr
argument_list|,
operator|&
name|ptr
argument_list|,
sizeof|sizeof
argument_list|(
name|ptr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|ptr
operator|==
name|lwp
condition|)
block|{
name|ret
operator|=
name|td_get_thread
argument_list|(
name|proc
argument_list|,
name|next
argument_list|,
name|TD_TYPE_NORMAL
argument_list|,
operator|&
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
operator|*
name|threadp
operator|=
name|thread
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* get next thread */
name|ret
operator|=
name|READ
argument_list|(
name|proc
argument_list|,
name|next
operator|+
name|offsetof
argument_list|(
expr|struct
name|pthread
argument_list|,
name|tle
operator|.
name|tqe_next
argument_list|)
argument_list|,
operator|&
name|next
argument_list|,
sizeof|sizeof
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
return|return
operator|(
name|TD_ERR_NOOBJ
operator|)
return|;
block|}
end_function

begin_function
name|int
name|td_map_id2thr
parameter_list|(
name|td_proc_t
modifier|*
name|proc
parameter_list|,
name|long
name|threadid
parameter_list|,
name|td_thread_t
modifier|*
modifier|*
name|threadp
parameter_list|)
block|{
name|td_thread_t
modifier|*
name|thread
decl_stmt|;
name|td_refresh_thread_list
argument_list|(
name|proc
argument_list|)
expr_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|thread
argument_list|,
argument|&proc->threads
argument_list|,
argument|tle
argument_list|)
block|{
if|if
condition|(
name|thread
operator|->
name|type
operator|==
name|TD_TYPE_UPCALL
condition|)
block|{
if|if
condition|(
operator|(
name|long
operator|)
name|thread
operator|->
name|kthread
operator|==
name|threadid
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|long
operator|)
name|thread
operator|->
name|addr
operator|==
name|threadid
condition|)
break|break;
block|}
if|if
condition|(
name|thread
condition|)
block|{
operator|*
name|threadp
operator|=
name|thread
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|TD_ERR_NOOBJ
operator|)
return|;
block|}
end_function

begin_function
name|int
name|td_thr_sstep
parameter_list|(
name|td_thread_t
modifier|*
name|thread
parameter_list|,
name|int
name|step
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|uint32_t
name|tmp
decl_stmt|;
name|struct
name|reg
name|reg
decl_stmt|;
name|td_proc_t
modifier|*
name|proc
decl_stmt|;
name|caddr_t
name|kthread
decl_stmt|;
name|proc
operator|=
name|thread
operator|->
name|proc
expr_stmt|;
if|if
condition|(
operator|(
name|kthread
operator|=
name|thread
operator|->
name|kthread
operator|)
operator|!=
name|NULL
condition|)
return|return
name|SSTEP
argument_list|(
name|proc
argument_list|,
name|kthread
argument_list|,
name|step
argument_list|)
return|;
if|if
condition|(
name|thread
operator|->
name|step
operator|==
name|step
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Clear or set single step flag in thread mailbox */
name|tmp
operator|=
name|step
condition|?
name|TMDF_SSTEP
else|:
literal|0
expr_stmt|;
name|ret
operator|=
name|WRITE
argument_list|(
name|proc
argument_list|,
name|thread
operator|->
name|tcb_addr
operator|+
name|offsetof
argument_list|(
expr|struct
name|tcb
argument_list|,
name|tcb_tmbx
operator|.
name|tm_dflags
argument_list|)
argument_list|,
operator|&
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get kthread */
name|ret
operator|=
name|READ
argument_list|(
name|proc
argument_list|,
name|thread
operator|->
name|tcb_addr
operator|+
name|offsetof
argument_list|(
expr|struct
name|tcb
argument_list|,
name|tcb_tmbx
operator|.
name|tm_kthread
argument_list|)
argument_list|,
operator|&
name|kthread
argument_list|,
sizeof|sizeof
argument_list|(
name|kthread
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|thread
operator|->
name|step
operator|=
name|step
expr_stmt|;
if|if
condition|(
name|kthread
operator|!=
name|NULL
condition|)
return|return
name|SSTEP
argument_list|(
name|proc
argument_list|,
name|kthread
argument_list|,
name|step
argument_list|)
return|;
comment|/* 	 * context is in userland, some architectures store 	 * single step status in registers, we should change 	 * these registers. 	 */
name|ret
operator|=
name|td_thr_getregs
argument_list|(
name|thread
argument_list|,
literal|0
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
block|{
comment|/* only write out if it is really changed. */
if|if
condition|(
name|td_reg_sstep
argument_list|(
operator|&
name|reg
argument_list|,
name|step
argument_list|)
operator|!=
literal|0
condition|)
name|ret
operator|=
name|td_thr_setregs
argument_list|(
name|thread
argument_list|,
literal|0
argument_list|,
operator|&
name|reg
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|td_remove_lwp_map
parameter_list|(
name|td_proc_t
modifier|*
name|proc
parameter_list|)
block|{
name|td_remove_map
argument_list|(
name|proc
argument_list|,
name|TD_TYPE_UPCALL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|td_remove_map
parameter_list|(
name|td_proc_t
modifier|*
name|proc
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|td_thread_t
modifier|*
name|thread
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|thread
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|proc
operator|->
name|threads
argument_list|)
init|;
name|thread
condition|;
name|thread
operator|=
name|next
control|)
block|{
name|next
operator|=
name|TAILQ_NEXT
argument_list|(
name|thread
argument_list|,
name|tle
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|type
condition|)
name|TAILQ_REMOVE
argument_list|(
operator|&
name|proc
operator|->
name|threads
argument_list|,
name|thread
argument_list|,
name|tle
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|td_refresh_thread_list
parameter_list|(
name|td_proc_t
modifier|*
name|proc
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|gen
decl_stmt|;
name|caddr_t
name|next
decl_stmt|;
name|td_thread_t
modifier|*
name|thread
decl_stmt|;
name|TAILQ_HEAD
argument_list|(
argument_list|,
argument|pthread
argument_list|)
name|thread_list
expr_stmt|;
name|ret
operator|=
name|READ
argument_list|(
name|proc
argument_list|,
name|proc
operator|->
name|thread_listgen_addr
argument_list|,
operator|&
name|gen
argument_list|,
sizeof|sizeof
argument_list|(
name|gen
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|gen
operator|==
name|proc
operator|->
name|thread_listgen
condition|)
return|return
operator|(
name|TD_ERR_OK
operator|)
return|;
name|proc
operator|->
name|thread_listgen
operator|=
name|gen
expr_stmt|;
name|td_remove_map
argument_list|(
name|proc
argument_list|,
name|TD_TYPE_NORMAL
argument_list|)
expr_stmt|;
name|ret
operator|=
name|READ
argument_list|(
name|proc
argument_list|,
name|proc
operator|->
name|thread_list_addr
argument_list|,
operator|&
name|thread_list
argument_list|,
sizeof|sizeof
argument_list|(
name|thread_list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|next
operator|=
operator|(
name|caddr_t
operator|)
name|thread_list
operator|.
name|tqh_first
expr_stmt|;
while|while
condition|(
name|next
operator|!=
name|NULL
condition|)
block|{
name|ret
operator|=
name|td_get_thread
argument_list|(
name|proc
argument_list|,
name|next
argument_list|,
name|TD_TYPE_NORMAL
argument_list|,
operator|&
name|thread
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|ret
operator|=
name|READ
argument_list|(
name|proc
argument_list|,
name|next
operator|+
name|offsetof
argument_list|(
expr|struct
name|pthread
argument_list|,
name|tle
operator|.
name|tqe_next
argument_list|)
argument_list|,
operator|&
name|next
argument_list|,
sizeof|sizeof
argument_list|(
name|next
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|td_empty_thread_list
parameter_list|(
name|td_proc_t
modifier|*
name|proc
parameter_list|)
block|{
name|td_thread_t
modifier|*
name|thread
decl_stmt|;
while|while
condition|(
operator|(
name|thread
operator|=
name|TAILQ_FIRST
argument_list|(
operator|&
name|proc
operator|->
name|threads
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|TAILQ_REMOVE
argument_list|(
operator|&
name|proc
operator|->
name|threads
argument_list|,
name|thread
argument_list|,
name|tle
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|thread
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|td_get_thread
parameter_list|(
name|td_proc_t
modifier|*
name|proc
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|int
name|type
parameter_list|,
name|td_thread_t
modifier|*
modifier|*
name|threadp
parameter_list|)
block|{
name|td_thread_t
modifier|*
name|thread
decl_stmt|;
name|caddr_t
name|tcb_addr
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|TAILQ_FOREACH
argument_list|(
argument|thread
argument_list|,
argument|&proc->threads
argument_list|,
argument|tle
argument_list|)
block|{
if|if
condition|(
name|type
operator|==
name|TD_TYPE_UPCALL
condition|)
block|{
comment|/* match upcall thread */
if|if
condition|(
name|thread
operator|->
name|kthread
operator|==
name|addr
condition|)
break|break;
block|}
else|else
block|{
comment|/* match normal thread */
if|if
condition|(
name|thread
operator|->
name|addr
operator|==
name|addr
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|thread
operator|==
name|NULL
condition|)
block|{
name|tcb_addr
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|TD_TYPE_UPCALL
condition|)
block|{
name|ret
operator|=
name|READ
argument_list|(
name|proc
argument_list|,
name|addr
operator|+
name|offsetof
argument_list|(
expr|struct
name|pthread
argument_list|,
name|tcb
argument_list|)
argument_list|,
operator|&
name|tcb_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|tcb_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|thread
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|thread
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|thread
operator|==
name|NULL
condition|)
return|return
operator|(
name|TD_ERR_NOMEM
operator|)
return|;
name|thread
operator|->
name|proc
operator|=
name|proc
expr_stmt|;
name|thread
operator|->
name|step
operator|=
operator|-
literal|1
expr_stmt|;
name|thread
operator|->
name|tcb_addr
operator|=
name|tcb_addr
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TD_TYPE_NORMAL
condition|)
block|{
name|thread
operator|->
name|addr
operator|=
name|addr
expr_stmt|;
name|thread
operator|->
name|kthread
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|thread
operator|->
name|addr
operator|=
name|NULL
expr_stmt|;
name|thread
operator|->
name|kthread
operator|=
name|addr
expr_stmt|;
block|}
name|thread
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|TAILQ_INSERT_TAIL
argument_list|(
operator|&
name|proc
operator|->
name|threads
argument_list|,
name|thread
argument_list|,
name|tle
argument_list|)
expr_stmt|;
block|}
operator|*
name|threadp
operator|=
name|thread
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|string_map
block|{
name|int
name|num
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|char
modifier|*
name|td_err_string
parameter_list|(
name|int
name|errcode
parameter_list|)
block|{
specifier|static
name|struct
name|string_map
name|err_table
index|[]
init|=
block|{
block|{
name|TD_ERR_OK
block|,
literal|"generic \"call succeeded\""
block|}
block|,
block|{
name|TD_ERR_ERR
block|,
literal|"generic error."
block|}
block|,
block|{
name|TD_ERR_NOSYM
block|,
literal|"symbol not found"
block|}
block|,
block|{
name|TD_ERR_NOOBJ
block|,
literal|"no object can be found to satisfy query"
block|}
block|,
block|{
name|TD_ERR_BADTHREAD
block|,
literal|"thread can not answer request"
block|}
block|,
block|{
name|TD_ERR_INUSE
block|,
literal|"debugging interface already in use for this process"
block|}
block|,
block|{
name|TD_ERR_NOLIB
block|,
literal|"process is not using libpthread"
block|}
block|,
block|{
name|TD_ERR_NOMEM
block|,
literal|"out of memory"
block|}
block|,
block|{
name|TD_ERR_IO
block|,
literal|"process callback error"
block|}
block|,
block|{
name|TD_ERR_INVAL
block|,
literal|"invalid argument"
block|}
block|, 	}
decl_stmt|;
specifier|const
name|int
name|err_size
init|=
sizeof|sizeof
argument_list|(
name|err_table
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|string_map
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|90
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|err_size
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|err_table
index|[
name|i
index|]
operator|.
name|num
operator|==
name|errcode
condition|)
return|return
name|err_table
index|[
name|i
index|]
operator|.
name|str
return|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"Unknown thread library debug error code: %d"
argument_list|,
name|errcode
argument_list|)
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

end_unit

