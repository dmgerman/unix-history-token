begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: terminal.c,v 1.14 2012/05/30 18:21:14 christos Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Christos Zoulas of Cornell University.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCCSID
argument_list|)
end_if

begin_if
if|#
directive|if
literal|0
end_if

begin_else
unit|static char sccsid[] = "@(#)term.c	8.2 (Berkeley) 4/30/95";
else|#
directive|else
end_else

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$NetBSD: terminal.c,v 1.14 2012/05/30 18:21:14 christos Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint&& not SCCSID */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * terminal.c: Editor/termcap-curses interface  *	       We have to declare a static variable here, since the  *	       termcap putchar routine does not take an argument!  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_TERMCAP_H
end_ifdef

begin_include
include|#
directive|include
file|<termcap.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_CURSES_H
end_ifdef

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_elif
elif|#
directive|elif
name|HAVE_NCURSES_H
end_elif

begin_include
include|#
directive|include
file|<ncurses.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Solaris's term.h does horrid things. */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|HAVE_TERM_H
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__sun
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_TERMCAP_H
argument_list|)
end_if

begin_include
include|#
directive|include
file|<term.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_REENTRANT
end_ifdef

begin_include
include|#
directive|include
file|<pthread.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"el.h"
end_include

begin_comment
comment|/*  * IMPORTANT NOTE: these routines are allowed to look at the current screen  * and the current position assuming that it is correct.  If this is not  * true, then the update will be WRONG!  This is (should be) a valid  * assumption...  */
end_comment

begin_define
define|#
directive|define
name|TC_BUFSIZE
value|((size_t)2048)
end_define

begin_define
define|#
directive|define
name|GoodStr
parameter_list|(
name|a
parameter_list|)
value|(el->el_terminal.t_str[a] != NULL&& \ 			    el->el_terminal.t_str[a][0] != '\0')
end_define

begin_define
define|#
directive|define
name|Str
parameter_list|(
name|a
parameter_list|)
value|el->el_terminal.t_str[a]
end_define

begin_define
define|#
directive|define
name|Val
parameter_list|(
name|a
parameter_list|)
value|el->el_terminal.t_val[a]
end_define

begin_expr_stmt
name|private
specifier|const
expr|struct
name|termcapstr
block|{
specifier|const
name|char
operator|*
name|name
block|;
specifier|const
name|char
operator|*
name|long_name
block|; }
name|tstr
index|[]
operator|=
block|{
define|#
directive|define
name|T_al
value|0
block|{
literal|"al"
block|,
literal|"add new blank line"
block|}
block|,
define|#
directive|define
name|T_bl
value|1
block|{
literal|"bl"
block|,
literal|"audible bell"
block|}
block|,
define|#
directive|define
name|T_cd
value|2
block|{
literal|"cd"
block|,
literal|"clear to bottom"
block|}
block|,
define|#
directive|define
name|T_ce
value|3
block|{
literal|"ce"
block|,
literal|"clear to end of line"
block|}
block|,
define|#
directive|define
name|T_ch
value|4
block|{
literal|"ch"
block|,
literal|"cursor to horiz pos"
block|}
block|,
define|#
directive|define
name|T_cl
value|5
block|{
literal|"cl"
block|,
literal|"clear screen"
block|}
block|,
define|#
directive|define
name|T_dc
value|6
block|{
literal|"dc"
block|,
literal|"delete a character"
block|}
block|,
define|#
directive|define
name|T_dl
value|7
block|{
literal|"dl"
block|,
literal|"delete a line"
block|}
block|,
define|#
directive|define
name|T_dm
value|8
block|{
literal|"dm"
block|,
literal|"start delete mode"
block|}
block|,
define|#
directive|define
name|T_ed
value|9
block|{
literal|"ed"
block|,
literal|"end delete mode"
block|}
block|,
define|#
directive|define
name|T_ei
value|10
block|{
literal|"ei"
block|,
literal|"end insert mode"
block|}
block|,
define|#
directive|define
name|T_fs
value|11
block|{
literal|"fs"
block|,
literal|"cursor from status line"
block|}
block|,
define|#
directive|define
name|T_ho
value|12
block|{
literal|"ho"
block|,
literal|"home cursor"
block|}
block|,
define|#
directive|define
name|T_ic
value|13
block|{
literal|"ic"
block|,
literal|"insert character"
block|}
block|,
define|#
directive|define
name|T_im
value|14
block|{
literal|"im"
block|,
literal|"start insert mode"
block|}
block|,
define|#
directive|define
name|T_ip
value|15
block|{
literal|"ip"
block|,
literal|"insert padding"
block|}
block|,
define|#
directive|define
name|T_kd
value|16
block|{
literal|"kd"
block|,
literal|"sends cursor down"
block|}
block|,
define|#
directive|define
name|T_kl
value|17
block|{
literal|"kl"
block|,
literal|"sends cursor left"
block|}
block|,
define|#
directive|define
name|T_kr
value|18
block|{
literal|"kr"
block|,
literal|"sends cursor right"
block|}
block|,
define|#
directive|define
name|T_ku
value|19
block|{
literal|"ku"
block|,
literal|"sends cursor up"
block|}
block|,
define|#
directive|define
name|T_md
value|20
block|{
literal|"md"
block|,
literal|"begin bold"
block|}
block|,
define|#
directive|define
name|T_me
value|21
block|{
literal|"me"
block|,
literal|"end attributes"
block|}
block|,
define|#
directive|define
name|T_nd
value|22
block|{
literal|"nd"
block|,
literal|"non destructive space"
block|}
block|,
define|#
directive|define
name|T_se
value|23
block|{
literal|"se"
block|,
literal|"end standout"
block|}
block|,
define|#
directive|define
name|T_so
value|24
block|{
literal|"so"
block|,
literal|"begin standout"
block|}
block|,
define|#
directive|define
name|T_ts
value|25
block|{
literal|"ts"
block|,
literal|"cursor to status line"
block|}
block|,
define|#
directive|define
name|T_up
value|26
block|{
literal|"up"
block|,
literal|"cursor up one"
block|}
block|,
define|#
directive|define
name|T_us
value|27
block|{
literal|"us"
block|,
literal|"begin underline"
block|}
block|,
define|#
directive|define
name|T_ue
value|28
block|{
literal|"ue"
block|,
literal|"end underline"
block|}
block|,
define|#
directive|define
name|T_vb
value|29
block|{
literal|"vb"
block|,
literal|"visible bell"
block|}
block|,
define|#
directive|define
name|T_DC
value|30
block|{
literal|"DC"
block|,
literal|"delete multiple chars"
block|}
block|,
define|#
directive|define
name|T_DO
value|31
block|{
literal|"DO"
block|,
literal|"cursor down multiple"
block|}
block|,
define|#
directive|define
name|T_IC
value|32
block|{
literal|"IC"
block|,
literal|"insert multiple chars"
block|}
block|,
define|#
directive|define
name|T_LE
value|33
block|{
literal|"LE"
block|,
literal|"cursor left multiple"
block|}
block|,
define|#
directive|define
name|T_RI
value|34
block|{
literal|"RI"
block|,
literal|"cursor right multiple"
block|}
block|,
define|#
directive|define
name|T_UP
value|35
block|{
literal|"UP"
block|,
literal|"cursor up multiple"
block|}
block|,
define|#
directive|define
name|T_kh
value|36
block|{
literal|"kh"
block|,
literal|"send cursor home"
block|}
block|,
define|#
directive|define
name|T_at7
value|37
block|{
literal|"@7"
block|,
literal|"send cursor end"
block|}
block|,
define|#
directive|define
name|T_kD
value|38
block|{
literal|"kD"
block|,
literal|"send cursor delete"
block|}
block|,
define|#
directive|define
name|T_str
value|39
block|{
name|NULL
block|,
name|NULL
block|}
block|}
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|private
specifier|const
expr|struct
name|termcapval
block|{
specifier|const
name|char
operator|*
name|name
block|;
specifier|const
name|char
operator|*
name|long_name
block|; }
name|tval
index|[]
operator|=
block|{
define|#
directive|define
name|T_am
value|0
block|{
literal|"am"
block|,
literal|"has automatic margins"
block|}
block|,
define|#
directive|define
name|T_pt
value|1
block|{
literal|"pt"
block|,
literal|"has physical tabs"
block|}
block|,
define|#
directive|define
name|T_li
value|2
block|{
literal|"li"
block|,
literal|"Number of lines"
block|}
block|,
define|#
directive|define
name|T_co
value|3
block|{
literal|"co"
block|,
literal|"Number of columns"
block|}
block|,
define|#
directive|define
name|T_km
value|4
block|{
literal|"km"
block|,
literal|"Has meta key"
block|}
block|,
define|#
directive|define
name|T_xt
value|5
block|{
literal|"xt"
block|,
literal|"Tab chars destructive"
block|}
block|,
define|#
directive|define
name|T_xn
value|6
block|{
literal|"xn"
block|,
literal|"newline ignored at right margin"
block|}
block|,
define|#
directive|define
name|T_MT
value|7
block|{
literal|"MT"
block|,
literal|"Has meta key"
block|}
block|,
comment|/* XXX? */
define|#
directive|define
name|T_val
value|8
block|{
name|NULL
block|,
name|NULL
block|, }
block|}
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* do two or more of the attributes use me */
end_comment

begin_function_decl
name|private
name|void
name|terminal_setflags
parameter_list|(
name|EditLine
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|int
name|terminal_rebuffer_display
parameter_list|(
name|EditLine
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|void
name|terminal_free_display
parameter_list|(
name|EditLine
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|int
name|terminal_alloc_display
parameter_list|(
name|EditLine
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|void
name|terminal_alloc
parameter_list|(
name|EditLine
modifier|*
parameter_list|,
specifier|const
name|struct
name|termcapstr
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|void
name|terminal_init_arrow
parameter_list|(
name|EditLine
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|void
name|terminal_reset_arrow
parameter_list|(
name|EditLine
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|int
name|terminal_putc
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|void
name|terminal_tputs
parameter_list|(
name|EditLine
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|_REENTRANT
end_ifdef

begin_decl_stmt
name|private
name|pthread_mutex_t
name|terminal_mutex
init|=
name|PTHREAD_MUTEX_INITIALIZER
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|private
name|FILE
modifier|*
name|terminal_outfile
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* terminal_setflags():  *	Set the terminal capability flags  */
end_comment

begin_function
name|private
name|void
name|terminal_setflags
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|)
block|{
name|EL_FLAGS
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|el
operator|->
name|el_tty
operator|.
name|t_tabs
condition|)
name|EL_FLAGS
operator||=
operator|(
name|Val
argument_list|(
name|T_pt
argument_list|)
operator|&&
operator|!
name|Val
argument_list|(
name|T_xt
argument_list|)
operator|)
condition|?
name|TERM_CAN_TAB
else|:
literal|0
expr_stmt|;
name|EL_FLAGS
operator||=
operator|(
name|Val
argument_list|(
name|T_km
argument_list|)
operator|||
name|Val
argument_list|(
name|T_MT
argument_list|)
operator|)
condition|?
name|TERM_HAS_META
else|:
literal|0
expr_stmt|;
name|EL_FLAGS
operator||=
name|GoodStr
argument_list|(
name|T_ce
argument_list|)
condition|?
name|TERM_CAN_CEOL
else|:
literal|0
expr_stmt|;
name|EL_FLAGS
operator||=
operator|(
name|GoodStr
argument_list|(
name|T_dc
argument_list|)
operator|||
name|GoodStr
argument_list|(
name|T_DC
argument_list|)
operator|)
condition|?
name|TERM_CAN_DELETE
else|:
literal|0
expr_stmt|;
name|EL_FLAGS
operator||=
operator|(
name|GoodStr
argument_list|(
name|T_im
argument_list|)
operator|||
name|GoodStr
argument_list|(
name|T_ic
argument_list|)
operator|||
name|GoodStr
argument_list|(
name|T_IC
argument_list|)
operator|)
condition|?
name|TERM_CAN_INSERT
else|:
literal|0
expr_stmt|;
name|EL_FLAGS
operator||=
operator|(
name|GoodStr
argument_list|(
name|T_up
argument_list|)
operator|||
name|GoodStr
argument_list|(
name|T_UP
argument_list|)
operator|)
condition|?
name|TERM_CAN_UP
else|:
literal|0
expr_stmt|;
name|EL_FLAGS
operator||=
name|Val
argument_list|(
name|T_am
argument_list|)
condition|?
name|TERM_HAS_AUTO_MARGINS
else|:
literal|0
expr_stmt|;
name|EL_FLAGS
operator||=
name|Val
argument_list|(
name|T_xn
argument_list|)
condition|?
name|TERM_HAS_MAGIC_MARGINS
else|:
literal|0
expr_stmt|;
if|if
condition|(
name|GoodStr
argument_list|(
name|T_me
argument_list|)
operator|&&
name|GoodStr
argument_list|(
name|T_ue
argument_list|)
condition|)
name|EL_FLAGS
operator||=
operator|(
name|strcmp
argument_list|(
name|Str
argument_list|(
name|T_me
argument_list|)
argument_list|,
name|Str
argument_list|(
name|T_ue
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|?
name|TERM_CAN_ME
else|:
literal|0
expr_stmt|;
else|else
name|EL_FLAGS
operator|&=
operator|~
name|TERM_CAN_ME
expr_stmt|;
if|if
condition|(
name|GoodStr
argument_list|(
name|T_me
argument_list|)
operator|&&
name|GoodStr
argument_list|(
name|T_se
argument_list|)
condition|)
name|EL_FLAGS
operator||=
operator|(
name|strcmp
argument_list|(
name|Str
argument_list|(
name|T_me
argument_list|)
argument_list|,
name|Str
argument_list|(
name|T_se
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|?
name|TERM_CAN_ME
else|:
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_SCREEN
if|if
condition|(
operator|!
name|EL_CAN_UP
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_errfile
argument_list|,
literal|"WARNING: Your terminal cannot move up.\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_errfile
argument_list|,
literal|"Editing may be odd for long lines.\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|EL_CAN_CEOL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_errfile
argument_list|,
literal|"no clear EOL capability.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EL_CAN_DELETE
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_errfile
argument_list|,
literal|"no delete char capability.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EL_CAN_INSERT
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_errfile
argument_list|,
literal|"no insert char capability.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_SCREEN */
block|}
end_function

begin_comment
comment|/* terminal_init():  *	Initialize the terminal stuff  */
end_comment

begin_function
name|protected
name|int
name|terminal_init
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|)
block|{
name|el
operator|->
name|el_terminal
operator|.
name|t_buf
operator|=
name|el_malloc
argument_list|(
name|TC_BUFSIZE
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|el
operator|->
name|el_terminal
operator|.
name|t_buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|el
operator|->
name|el_terminal
operator|.
name|t_buf
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|el
operator|->
name|el_terminal
operator|.
name|t_cap
operator|=
name|el_malloc
argument_list|(
name|TC_BUFSIZE
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|el
operator|->
name|el_terminal
operator|.
name|t_cap
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|el
operator|->
name|el_terminal
operator|.
name|t_cap
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|el
operator|->
name|el_terminal
operator|.
name|t_fkey
operator|=
name|el_malloc
argument_list|(
name|A_K_NKEYS
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|el
operator|->
name|el_terminal
operator|.
name|t_fkey
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|el
operator|->
name|el_terminal
operator|.
name|t_fkey
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|el
operator|->
name|el_terminal
operator|.
name|t_loc
operator|=
literal|0
expr_stmt|;
name|el
operator|->
name|el_terminal
operator|.
name|t_str
operator|=
name|el_malloc
argument_list|(
name|T_str
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|el
operator|->
name|el_terminal
operator|.
name|t_str
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|el
operator|->
name|el_terminal
operator|.
name|t_str
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|el
operator|->
name|el_terminal
operator|.
name|t_str
argument_list|,
literal|0
argument_list|,
name|T_str
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|el
operator|->
name|el_terminal
operator|.
name|t_str
argument_list|)
argument_list|)
expr_stmt|;
name|el
operator|->
name|el_terminal
operator|.
name|t_val
operator|=
name|el_malloc
argument_list|(
name|T_val
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|el
operator|->
name|el_terminal
operator|.
name|t_val
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|el
operator|->
name|el_terminal
operator|.
name|t_val
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|el
operator|->
name|el_terminal
operator|.
name|t_val
argument_list|,
literal|0
argument_list|,
name|T_val
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|el
operator|->
name|el_terminal
operator|.
name|t_val
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|terminal_set
argument_list|(
name|el
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|terminal_init_arrow
argument_list|(
name|el
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* terminal_end():  *	Clean up the terminal stuff  */
end_comment

begin_function
name|protected
name|void
name|terminal_end
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|)
block|{
name|el_free
argument_list|(
name|el
operator|->
name|el_terminal
operator|.
name|t_buf
argument_list|)
expr_stmt|;
name|el
operator|->
name|el_terminal
operator|.
name|t_buf
operator|=
name|NULL
expr_stmt|;
name|el_free
argument_list|(
name|el
operator|->
name|el_terminal
operator|.
name|t_cap
argument_list|)
expr_stmt|;
name|el
operator|->
name|el_terminal
operator|.
name|t_cap
operator|=
name|NULL
expr_stmt|;
name|el
operator|->
name|el_terminal
operator|.
name|t_loc
operator|=
literal|0
expr_stmt|;
name|el_free
argument_list|(
name|el
operator|->
name|el_terminal
operator|.
name|t_str
argument_list|)
expr_stmt|;
name|el
operator|->
name|el_terminal
operator|.
name|t_str
operator|=
name|NULL
expr_stmt|;
name|el_free
argument_list|(
name|el
operator|->
name|el_terminal
operator|.
name|t_val
argument_list|)
expr_stmt|;
name|el
operator|->
name|el_terminal
operator|.
name|t_val
operator|=
name|NULL
expr_stmt|;
name|el_free
argument_list|(
name|el
operator|->
name|el_terminal
operator|.
name|t_fkey
argument_list|)
expr_stmt|;
name|el
operator|->
name|el_terminal
operator|.
name|t_fkey
operator|=
name|NULL
expr_stmt|;
name|terminal_free_display
argument_list|(
name|el
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* terminal_alloc():  *	Maintain a string pool for termcap strings  */
end_comment

begin_function
name|private
name|void
name|terminal_alloc
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|,
specifier|const
name|struct
name|termcapstr
modifier|*
name|t
parameter_list|,
specifier|const
name|char
modifier|*
name|cap
parameter_list|)
block|{
name|char
name|termbuf
index|[
name|TC_BUFSIZE
index|]
decl_stmt|;
name|size_t
name|tlen
decl_stmt|,
name|clen
decl_stmt|;
name|char
modifier|*
modifier|*
name|tlist
init|=
name|el
operator|->
name|el_terminal
operator|.
name|t_str
decl_stmt|;
name|char
modifier|*
modifier|*
name|tmp
decl_stmt|,
modifier|*
modifier|*
name|str
init|=
operator|&
name|tlist
index|[
name|t
operator|-
name|tstr
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|termbuf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|termbuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cap
operator|==
name|NULL
operator|||
operator|*
name|cap
operator|==
literal|'\0'
condition|)
block|{
operator|*
name|str
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
else|else
name|clen
operator|=
name|strlen
argument_list|(
name|cap
argument_list|)
expr_stmt|;
name|tlen
operator|=
operator|*
name|str
operator|==
name|NULL
condition|?
literal|0
else|:
name|strlen
argument_list|(
operator|*
name|str
argument_list|)
expr_stmt|;
comment|/*          * New string is shorter; no need to allocate space          */
if|if
condition|(
name|clen
operator|<=
name|tlen
condition|)
block|{
if|if
condition|(
operator|*
name|str
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|*
name|str
argument_list|,
name|cap
argument_list|)
expr_stmt|;
comment|/* XXX strcpy is safe */
return|return;
block|}
comment|/*          * New string is longer; see if we have enough space to append          */
if|if
condition|(
name|el
operator|->
name|el_terminal
operator|.
name|t_loc
operator|+
literal|3
operator|<
name|TC_BUFSIZE
condition|)
block|{
comment|/* XXX strcpy is safe */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|*
name|str
operator|=
operator|&
name|el
operator|->
name|el_terminal
operator|.
name|t_buf
index|[
name|el
operator|->
name|el_terminal
operator|.
name|t_loc
index|]
argument_list|,
name|cap
argument_list|)
expr_stmt|;
name|el
operator|->
name|el_terminal
operator|.
name|t_loc
operator|+=
name|clen
operator|+
literal|1
expr_stmt|;
comment|/* one for \0 */
return|return;
block|}
comment|/*          * Compact our buffer; no need to check compaction, cause we know it          * fits...          */
name|tlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tmp
operator|=
name|tlist
init|;
name|tmp
operator|<
operator|&
name|tlist
index|[
name|T_str
index|]
condition|;
name|tmp
operator|++
control|)
if|if
condition|(
operator|*
name|tmp
operator|!=
name|NULL
operator|&&
operator|*
name|tmp
operator|!=
literal|'\0'
operator|&&
operator|*
name|tmp
operator|!=
operator|*
name|str
condition|)
block|{
name|char
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|ptr
operator|=
operator|*
name|tmp
init|;
operator|*
name|ptr
operator|!=
literal|'\0'
condition|;
name|termbuf
index|[
name|tlen
operator|++
index|]
operator|=
operator|*
name|ptr
operator|++
control|)
continue|continue;
name|termbuf
index|[
name|tlen
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|el
operator|->
name|el_terminal
operator|.
name|t_buf
argument_list|,
name|termbuf
argument_list|,
name|TC_BUFSIZE
argument_list|)
expr_stmt|;
name|el
operator|->
name|el_terminal
operator|.
name|t_loc
operator|=
name|tlen
expr_stmt|;
if|if
condition|(
name|el
operator|->
name|el_terminal
operator|.
name|t_loc
operator|+
literal|3
operator|>=
name|TC_BUFSIZE
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_errfile
argument_list|,
literal|"Out of termcap string space.\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* XXX strcpy is safe */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|*
name|str
operator|=
operator|&
name|el
operator|->
name|el_terminal
operator|.
name|t_buf
index|[
name|el
operator|->
name|el_terminal
operator|.
name|t_loc
index|]
argument_list|,
name|cap
argument_list|)
expr_stmt|;
name|el
operator|->
name|el_terminal
operator|.
name|t_loc
operator|+=
operator|(
name|size_t
operator|)
name|clen
operator|+
literal|1
expr_stmt|;
comment|/* one for \0 */
return|return;
block|}
end_function

begin_comment
comment|/* terminal_rebuffer_display():  *	Rebuffer the display after the screen changed size  */
end_comment

begin_function
name|private
name|int
name|terminal_rebuffer_display
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|)
block|{
name|coord_t
modifier|*
name|c
init|=
operator|&
name|el
operator|->
name|el_terminal
operator|.
name|t_size
decl_stmt|;
name|terminal_free_display
argument_list|(
name|el
argument_list|)
expr_stmt|;
name|c
operator|->
name|h
operator|=
name|Val
argument_list|(
name|T_co
argument_list|)
expr_stmt|;
name|c
operator|->
name|v
operator|=
name|Val
argument_list|(
name|T_li
argument_list|)
expr_stmt|;
if|if
condition|(
name|terminal_alloc_display
argument_list|(
name|el
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* terminal_alloc_display():  *	Allocate a new display.  */
end_comment

begin_function
name|private
name|int
name|terminal_alloc_display
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|Char
modifier|*
modifier|*
name|b
decl_stmt|;
name|coord_t
modifier|*
name|c
init|=
operator|&
name|el
operator|->
name|el_terminal
operator|.
name|t_size
decl_stmt|;
name|b
operator|=
name|el_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|b
argument_list|)
operator|*
call|(
name|size_t
call|)
argument_list|(
name|c
operator|->
name|v
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
operator|->
name|v
condition|;
name|i
operator|++
control|)
block|{
name|b
index|[
name|i
index|]
operator|=
name|el_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|b
argument_list|)
operator|*
call|(
name|size_t
call|)
argument_list|(
name|c
operator|->
name|h
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|el_free
argument_list|(
name|b
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|el_free
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|b
index|[
name|c
operator|->
name|v
index|]
operator|=
name|NULL
expr_stmt|;
name|el
operator|->
name|el_display
operator|=
name|b
expr_stmt|;
name|b
operator|=
name|el_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|b
argument_list|)
operator|*
call|(
name|size_t
call|)
argument_list|(
name|c
operator|->
name|v
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
operator|->
name|v
condition|;
name|i
operator|++
control|)
block|{
name|b
index|[
name|i
index|]
operator|=
name|el_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|b
argument_list|)
operator|*
call|(
name|size_t
call|)
argument_list|(
name|c
operator|->
name|h
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
while|while
condition|(
operator|--
name|i
operator|>=
literal|0
condition|)
name|el_free
argument_list|(
name|b
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|el_free
argument_list|(
name|b
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|b
index|[
name|c
operator|->
name|v
index|]
operator|=
name|NULL
expr_stmt|;
name|el
operator|->
name|el_vdisplay
operator|=
name|b
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* terminal_free_display():  *	Free the display buffers  */
end_comment

begin_function
name|private
name|void
name|terminal_free_display
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|)
block|{
name|Char
modifier|*
modifier|*
name|b
decl_stmt|;
name|Char
modifier|*
modifier|*
name|bufp
decl_stmt|;
name|b
operator|=
name|el
operator|->
name|el_display
expr_stmt|;
name|el
operator|->
name|el_display
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|b
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|bufp
operator|=
name|b
init|;
operator|*
name|bufp
operator|!=
name|NULL
condition|;
name|bufp
operator|++
control|)
name|el_free
argument_list|(
operator|*
name|bufp
argument_list|)
expr_stmt|;
name|el_free
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
name|b
operator|=
name|el
operator|->
name|el_vdisplay
expr_stmt|;
name|el
operator|->
name|el_vdisplay
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|b
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|bufp
operator|=
name|b
init|;
operator|*
name|bufp
operator|!=
name|NULL
condition|;
name|bufp
operator|++
control|)
name|el_free
argument_list|(
operator|*
name|bufp
argument_list|)
expr_stmt|;
name|el_free
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* terminal_move_to_line():  *	move to line<where> (first line == 0)  * 	as efficiently as possible  */
end_comment

begin_function
name|protected
name|void
name|terminal_move_to_line
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|,
name|int
name|where
parameter_list|)
block|{
name|int
name|del
decl_stmt|;
if|if
condition|(
name|where
operator|==
name|el
operator|->
name|el_cursor
operator|.
name|v
condition|)
return|return;
if|if
condition|(
name|where
operator|>
name|el
operator|->
name|el_terminal
operator|.
name|t_size
operator|.
name|v
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_SCREEN
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_errfile
argument_list|,
literal|"terminal_move_to_line: where is ridiculous: %d\r\n"
argument_list|,
name|where
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_SCREEN */
return|return;
block|}
if|if
condition|(
operator|(
name|del
operator|=
name|where
operator|-
name|el
operator|->
name|el_cursor
operator|.
name|v
operator|)
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|del
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|EL_HAS_AUTO_MARGINS
operator|&&
name|el
operator|->
name|el_display
index|[
name|el
operator|->
name|el_cursor
operator|.
name|v
index|]
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|size_t
name|h
init|=
call|(
name|size_t
call|)
argument_list|(
name|el
operator|->
name|el_terminal
operator|.
name|t_size
operator|.
name|h
operator|-
literal|1
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|WIDECHAR
for|for
control|(
init|;
name|h
operator|>
literal|0
operator|&&
name|el
operator|->
name|el_display
index|[
name|el
operator|->
name|el_cursor
operator|.
name|v
index|]
index|[
name|h
index|]
operator|==
name|MB_FILL_CHAR
condition|;
name|h
operator|--
control|)
continue|continue;
endif|#
directive|endif
comment|/* move without newline */
name|terminal_move_to_char
argument_list|(
name|el
argument_list|,
operator|(
name|int
operator|)
name|h
argument_list|)
expr_stmt|;
name|terminal_overwrite
argument_list|(
name|el
argument_list|,
operator|&
name|el
operator|->
name|el_display
index|[
name|el
operator|->
name|el_cursor
operator|.
name|v
index|]
index|[
name|el
operator|->
name|el_cursor
operator|.
name|h
index|]
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|el
operator|->
name|el_terminal
operator|.
name|t_size
operator|.
name|h
operator|-
name|el
operator|->
name|el_cursor
operator|.
name|h
argument_list|)
argument_list|)
expr_stmt|;
comment|/* updates Cursor */
name|del
operator|--
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|del
operator|>
literal|1
operator|)
operator|&&
name|GoodStr
argument_list|(
name|T_DO
argument_list|)
condition|)
block|{
name|terminal_tputs
argument_list|(
name|el
argument_list|,
name|tgoto
argument_list|(
name|Str
argument_list|(
name|T_DO
argument_list|)
argument_list|,
name|del
argument_list|,
name|del
argument_list|)
argument_list|,
name|del
argument_list|)
expr_stmt|;
name|del
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
init|;
name|del
operator|>
literal|0
condition|;
name|del
operator|--
control|)
name|terminal__putc
argument_list|(
name|el
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* because the \n will become \r\n */
name|el
operator|->
name|el_cursor
operator|.
name|h
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
comment|/* del< 0 */
if|if
condition|(
name|GoodStr
argument_list|(
name|T_UP
argument_list|)
operator|&&
operator|(
operator|-
name|del
operator|>
literal|1
operator|||
operator|!
name|GoodStr
argument_list|(
name|T_up
argument_list|)
operator|)
condition|)
name|terminal_tputs
argument_list|(
name|el
argument_list|,
name|tgoto
argument_list|(
name|Str
argument_list|(
name|T_UP
argument_list|)
argument_list|,
operator|-
name|del
argument_list|,
operator|-
name|del
argument_list|)
argument_list|,
operator|-
name|del
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|GoodStr
argument_list|(
name|T_up
argument_list|)
condition|)
for|for
control|(
init|;
name|del
operator|<
literal|0
condition|;
name|del
operator|++
control|)
name|terminal_tputs
argument_list|(
name|el
argument_list|,
name|Str
argument_list|(
name|T_up
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|el
operator|->
name|el_cursor
operator|.
name|v
operator|=
name|where
expr_stmt|;
comment|/* now where is here */
block|}
end_function

begin_comment
comment|/* terminal_move_to_char():  *	Move to the character position specified  */
end_comment

begin_function
name|protected
name|void
name|terminal_move_to_char
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|,
name|int
name|where
parameter_list|)
block|{
name|int
name|del
decl_stmt|,
name|i
decl_stmt|;
name|mc_again
label|:
if|if
condition|(
name|where
operator|==
name|el
operator|->
name|el_cursor
operator|.
name|h
condition|)
return|return;
if|if
condition|(
name|where
operator|>
name|el
operator|->
name|el_terminal
operator|.
name|t_size
operator|.
name|h
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_SCREEN
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_errfile
argument_list|,
literal|"terminal_move_to_char: where is riduculous: %d\r\n"
argument_list|,
name|where
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_SCREEN */
return|return;
block|}
if|if
condition|(
operator|!
name|where
condition|)
block|{
comment|/* if where is first column */
name|terminal__putc
argument_list|(
name|el
argument_list|,
literal|'\r'
argument_list|)
expr_stmt|;
comment|/* do a CR */
name|el
operator|->
name|el_cursor
operator|.
name|h
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|del
operator|=
name|where
operator|-
name|el
operator|->
name|el_cursor
operator|.
name|h
expr_stmt|;
if|if
condition|(
operator|(
name|del
operator|<
operator|-
literal|4
operator|||
name|del
operator|>
literal|4
operator|)
operator|&&
name|GoodStr
argument_list|(
name|T_ch
argument_list|)
condition|)
comment|/* go there directly */
name|terminal_tputs
argument_list|(
name|el
argument_list|,
name|tgoto
argument_list|(
name|Str
argument_list|(
name|T_ch
argument_list|)
argument_list|,
name|where
argument_list|,
name|where
argument_list|)
argument_list|,
name|where
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|del
operator|>
literal|0
condition|)
block|{
comment|/* moving forward */
if|if
condition|(
operator|(
name|del
operator|>
literal|4
operator|)
operator|&&
name|GoodStr
argument_list|(
name|T_RI
argument_list|)
condition|)
name|terminal_tputs
argument_list|(
name|el
argument_list|,
name|tgoto
argument_list|(
name|Str
argument_list|(
name|T_RI
argument_list|)
argument_list|,
name|del
argument_list|,
name|del
argument_list|)
argument_list|,
name|del
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* if I can do tabs, use them */
if|if
condition|(
name|EL_CAN_TAB
condition|)
block|{
if|if
condition|(
operator|(
name|el
operator|->
name|el_cursor
operator|.
name|h
operator|&
literal|0370
operator|)
operator|!=
operator|(
name|where
operator|&
operator|~
literal|0x7
operator|)
ifdef|#
directive|ifdef
name|WIDECHAR
operator|&&
operator|(
name|el
operator|->
name|el_display
index|[
name|el
operator|->
name|el_cursor
operator|.
name|v
index|]
index|[
name|where
operator|&
literal|0370
index|]
operator|!=
name|MB_FILL_CHAR
operator|)
endif|#
directive|endif
condition|)
block|{
comment|/* if not within tab stop */
for|for
control|(
name|i
operator|=
operator|(
name|el
operator|->
name|el_cursor
operator|.
name|h
operator|&
literal|0370
operator|)
init|;
name|i
operator|<
operator|(
name|where
operator|&
operator|~
literal|0x7
operator|)
condition|;
name|i
operator|+=
literal|8
control|)
name|terminal__putc
argument_list|(
name|el
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
comment|/* then tab over */
name|el
operator|->
name|el_cursor
operator|.
name|h
operator|=
name|where
operator|&
operator|~
literal|0x7
expr_stmt|;
block|}
block|}
comment|/* 				 * it's usually cheaper to just write the 				 * chars, so we do. 				 */
comment|/* 				 * NOTE THAT terminal_overwrite() WILL CHANGE 				 * el->el_cursor.h!!! 				 */
name|terminal_overwrite
argument_list|(
name|el
argument_list|,
operator|&
name|el
operator|->
name|el_display
index|[
name|el
operator|->
name|el_cursor
operator|.
name|v
index|]
index|[
name|el
operator|->
name|el_cursor
operator|.
name|h
index|]
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|where
operator|-
name|el
operator|->
name|el_cursor
operator|.
name|h
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* del< 0 := moving backward */
if|if
condition|(
operator|(
operator|-
name|del
operator|>
literal|4
operator|)
operator|&&
name|GoodStr
argument_list|(
name|T_LE
argument_list|)
condition|)
name|terminal_tputs
argument_list|(
name|el
argument_list|,
name|tgoto
argument_list|(
name|Str
argument_list|(
name|T_LE
argument_list|)
argument_list|,
operator|-
name|del
argument_list|,
operator|-
name|del
argument_list|)
argument_list|,
operator|-
name|del
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* can't go directly there */
comment|/* 				 * if the "cost" is greater than the "cost" 				 * from col 0 				 */
if|if
condition|(
name|EL_CAN_TAB
condition|?
operator|(
operator|(
name|unsigned
name|int
operator|)
operator|-
name|del
operator|>
operator|(
operator|(
operator|(
name|unsigned
name|int
operator|)
name|where
operator|>>
literal|3
operator|)
operator|+
operator|(
name|where
operator|&
literal|07
operator|)
operator|)
operator|)
else|:
operator|(
operator|-
name|del
operator|>
name|where
operator|)
condition|)
block|{
name|terminal__putc
argument_list|(
name|el
argument_list|,
literal|'\r'
argument_list|)
expr_stmt|;
comment|/* do a CR */
name|el
operator|->
name|el_cursor
operator|.
name|h
operator|=
literal|0
expr_stmt|;
goto|goto
name|mc_again
goto|;
comment|/* and try again */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|-
name|del
condition|;
name|i
operator|++
control|)
name|terminal__putc
argument_list|(
name|el
argument_list|,
literal|'\b'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|el
operator|->
name|el_cursor
operator|.
name|h
operator|=
name|where
expr_stmt|;
comment|/* now where is here */
block|}
end_function

begin_comment
comment|/* terminal_overwrite():  *	Overstrike num characters  *	Assumes MB_FILL_CHARs are present to keep the column count correct  */
end_comment

begin_function
name|protected
name|void
name|terminal_overwrite
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|,
specifier|const
name|Char
modifier|*
name|cp
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|n
operator|>
operator|(
name|size_t
operator|)
name|el
operator|->
name|el_terminal
operator|.
name|t_size
operator|.
name|h
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_SCREEN
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_errfile
argument_list|,
literal|"terminal_overwrite: n is riduculous: %d\r\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_SCREEN */
return|return;
block|}
do|do
block|{
comment|/* terminal__putc() ignores any MB_FILL_CHARs */
name|terminal__putc
argument_list|(
name|el
argument_list|,
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
name|el
operator|->
name|el_cursor
operator|.
name|h
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|n
condition|)
do|;
if|if
condition|(
name|el
operator|->
name|el_cursor
operator|.
name|h
operator|>=
name|el
operator|->
name|el_terminal
operator|.
name|t_size
operator|.
name|h
condition|)
block|{
comment|/* wrap? */
if|if
condition|(
name|EL_HAS_AUTO_MARGINS
condition|)
block|{
comment|/* yes */
name|el
operator|->
name|el_cursor
operator|.
name|h
operator|=
literal|0
expr_stmt|;
name|el
operator|->
name|el_cursor
operator|.
name|v
operator|++
expr_stmt|;
if|if
condition|(
name|EL_HAS_MAGIC_MARGINS
condition|)
block|{
comment|/* force the wrap to avoid the "magic" 				 * situation */
name|Char
name|c
decl_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|el
operator|->
name|el_display
index|[
name|el
operator|->
name|el_cursor
operator|.
name|v
index|]
index|[
name|el
operator|->
name|el_cursor
operator|.
name|h
index|]
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|terminal_overwrite
argument_list|(
name|el
argument_list|,
operator|&
name|c
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WIDECHAR
while|while
condition|(
name|el
operator|->
name|el_display
index|[
name|el
operator|->
name|el_cursor
operator|.
name|v
index|]
index|[
name|el
operator|->
name|el_cursor
operator|.
name|h
index|]
operator|==
name|MB_FILL_CHAR
condition|)
name|el
operator|->
name|el_cursor
operator|.
name|h
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|terminal__putc
argument_list|(
name|el
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|el
operator|->
name|el_cursor
operator|.
name|h
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/* no wrap, but cursor stays on screen */
name|el
operator|->
name|el_cursor
operator|.
name|h
operator|=
name|el
operator|->
name|el_terminal
operator|.
name|t_size
operator|.
name|h
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* terminal_deletechars():  *	Delete num characters  */
end_comment

begin_function
name|protected
name|void
name|terminal_deletechars
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|,
name|int
name|num
parameter_list|)
block|{
if|if
condition|(
name|num
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|EL_CAN_DELETE
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_EDIT
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_errfile
argument_list|,
literal|"   ERROR: cannot delete   \n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_EDIT */
return|return;
block|}
if|if
condition|(
name|num
operator|>
name|el
operator|->
name|el_terminal
operator|.
name|t_size
operator|.
name|h
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_SCREEN
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_errfile
argument_list|,
literal|"terminal_deletechars: num is riduculous: %d\r\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_SCREEN */
return|return;
block|}
if|if
condition|(
name|GoodStr
argument_list|(
name|T_DC
argument_list|)
condition|)
comment|/* if I have multiple delete */
if|if
condition|(
operator|(
name|num
operator|>
literal|1
operator|)
operator|||
operator|!
name|GoodStr
argument_list|(
name|T_dc
argument_list|)
condition|)
block|{
comment|/* if dc would be more 							 * expen. */
name|terminal_tputs
argument_list|(
name|el
argument_list|,
name|tgoto
argument_list|(
name|Str
argument_list|(
name|T_DC
argument_list|)
argument_list|,
name|num
argument_list|,
name|num
argument_list|)
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|GoodStr
argument_list|(
name|T_dm
argument_list|)
condition|)
comment|/* if I have delete mode */
name|terminal_tputs
argument_list|(
name|el
argument_list|,
name|Str
argument_list|(
name|T_dm
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GoodStr
argument_list|(
name|T_dc
argument_list|)
condition|)
comment|/* else do one at a time */
while|while
condition|(
name|num
operator|--
condition|)
name|terminal_tputs
argument_list|(
name|el
argument_list|,
name|Str
argument_list|(
name|T_dc
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|GoodStr
argument_list|(
name|T_ed
argument_list|)
condition|)
comment|/* if I have delete mode */
name|terminal_tputs
argument_list|(
name|el
argument_list|,
name|Str
argument_list|(
name|T_ed
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* terminal_insertwrite():  *	Puts terminal in insert character mode or inserts num  *	characters in the line  *      Assumes MB_FILL_CHARs are present to keep column count correct  */
end_comment

begin_function
name|protected
name|void
name|terminal_insertwrite
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|,
name|Char
modifier|*
name|cp
parameter_list|,
name|int
name|num
parameter_list|)
block|{
if|if
condition|(
name|num
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|EL_CAN_INSERT
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_EDIT
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_errfile
argument_list|,
literal|"   ERROR: cannot insert   \n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_EDIT */
return|return;
block|}
if|if
condition|(
name|num
operator|>
name|el
operator|->
name|el_terminal
operator|.
name|t_size
operator|.
name|h
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG_SCREEN
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_errfile
argument_list|,
literal|"StartInsert: num is riduculous: %d\r\n"
argument_list|,
name|num
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_SCREEN */
return|return;
block|}
if|if
condition|(
name|GoodStr
argument_list|(
name|T_IC
argument_list|)
condition|)
comment|/* if I have multiple insert */
if|if
condition|(
operator|(
name|num
operator|>
literal|1
operator|)
operator|||
operator|!
name|GoodStr
argument_list|(
name|T_ic
argument_list|)
condition|)
block|{
comment|/* if ic would be more expensive */
name|terminal_tputs
argument_list|(
name|el
argument_list|,
name|tgoto
argument_list|(
name|Str
argument_list|(
name|T_IC
argument_list|)
argument_list|,
name|num
argument_list|,
name|num
argument_list|)
argument_list|,
name|num
argument_list|)
expr_stmt|;
name|terminal_overwrite
argument_list|(
name|el
argument_list|,
name|cp
argument_list|,
operator|(
name|size_t
operator|)
name|num
argument_list|)
expr_stmt|;
comment|/* this updates el_cursor.h */
return|return;
block|}
if|if
condition|(
name|GoodStr
argument_list|(
name|T_im
argument_list|)
operator|&&
name|GoodStr
argument_list|(
name|T_ei
argument_list|)
condition|)
block|{
comment|/* if I have insert mode */
name|terminal_tputs
argument_list|(
name|el
argument_list|,
name|Str
argument_list|(
name|T_im
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|el
operator|->
name|el_cursor
operator|.
name|h
operator|+=
name|num
expr_stmt|;
do|do
name|terminal__putc
argument_list|(
name|el
argument_list|,
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
do|while
condition|(
operator|--
name|num
condition|)
do|;
if|if
condition|(
name|GoodStr
argument_list|(
name|T_ip
argument_list|)
condition|)
comment|/* have to make num chars insert */
name|terminal_tputs
argument_list|(
name|el
argument_list|,
name|Str
argument_list|(
name|T_ip
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|terminal_tputs
argument_list|(
name|el
argument_list|,
name|Str
argument_list|(
name|T_ei
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
do|do
block|{
if|if
condition|(
name|GoodStr
argument_list|(
name|T_ic
argument_list|)
condition|)
comment|/* have to make num chars insert */
name|terminal_tputs
argument_list|(
name|el
argument_list|,
name|Str
argument_list|(
name|T_ic
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|terminal__putc
argument_list|(
name|el
argument_list|,
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
name|el
operator|->
name|el_cursor
operator|.
name|h
operator|++
expr_stmt|;
if|if
condition|(
name|GoodStr
argument_list|(
name|T_ip
argument_list|)
condition|)
comment|/* have to make num chars insert */
name|terminal_tputs
argument_list|(
name|el
argument_list|,
name|Str
argument_list|(
name|T_ip
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* pad the inserted char */
block|}
do|while
condition|(
operator|--
name|num
condition|)
do|;
block|}
end_function

begin_comment
comment|/* terminal_clear_EOL():  *	clear to end of line.  There are num characters to clear  */
end_comment

begin_function
name|protected
name|void
name|terminal_clear_EOL
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|EL_CAN_CEOL
operator|&&
name|GoodStr
argument_list|(
name|T_ce
argument_list|)
condition|)
name|terminal_tputs
argument_list|(
name|el
argument_list|,
name|Str
argument_list|(
name|T_ce
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
name|terminal__putc
argument_list|(
name|el
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|el
operator|->
name|el_cursor
operator|.
name|h
operator|+=
name|num
expr_stmt|;
comment|/* have written num spaces */
block|}
block|}
end_function

begin_comment
comment|/* terminal_clear_screen():  *	Clear the screen  */
end_comment

begin_function
name|protected
name|void
name|terminal_clear_screen
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|)
block|{
comment|/* clear the whole screen and home */
if|if
condition|(
name|GoodStr
argument_list|(
name|T_cl
argument_list|)
condition|)
comment|/* send the clear screen code */
name|terminal_tputs
argument_list|(
name|el
argument_list|,
name|Str
argument_list|(
name|T_cl
argument_list|)
argument_list|,
name|Val
argument_list|(
name|T_li
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GoodStr
argument_list|(
name|T_ho
argument_list|)
operator|&&
name|GoodStr
argument_list|(
name|T_cd
argument_list|)
condition|)
block|{
name|terminal_tputs
argument_list|(
name|el
argument_list|,
name|Str
argument_list|(
name|T_ho
argument_list|)
argument_list|,
name|Val
argument_list|(
name|T_li
argument_list|)
argument_list|)
expr_stmt|;
comment|/* home */
comment|/* clear to bottom of screen */
name|terminal_tputs
argument_list|(
name|el
argument_list|,
name|Str
argument_list|(
name|T_cd
argument_list|)
argument_list|,
name|Val
argument_list|(
name|T_li
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|terminal__putc
argument_list|(
name|el
argument_list|,
literal|'\r'
argument_list|)
expr_stmt|;
name|terminal__putc
argument_list|(
name|el
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* terminal_beep():  *	Beep the way the terminal wants us  */
end_comment

begin_function
name|protected
name|void
name|terminal_beep
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|)
block|{
if|if
condition|(
name|GoodStr
argument_list|(
name|T_bl
argument_list|)
condition|)
comment|/* what termcap says we should use */
name|terminal_tputs
argument_list|(
name|el
argument_list|,
name|Str
argument_list|(
name|T_bl
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|terminal__putc
argument_list|(
name|el
argument_list|,
literal|'\007'
argument_list|)
expr_stmt|;
comment|/* an ASCII bell; ^G */
block|}
end_function

begin_function
name|protected
name|void
name|terminal_get
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|term
parameter_list|)
block|{
operator|*
name|term
operator|=
name|el
operator|->
name|el_terminal
operator|.
name|t_name
expr_stmt|;
block|}
end_function

begin_comment
comment|/* terminal_set():  *	Read in the terminal capabilities from the requested terminal  */
end_comment

begin_function
name|protected
name|int
name|terminal_set
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|,
specifier|const
name|char
modifier|*
name|term
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
name|TC_BUFSIZE
index|]
decl_stmt|;
name|char
modifier|*
name|area
decl_stmt|;
specifier|const
name|struct
name|termcapstr
modifier|*
name|t
decl_stmt|;
name|sigset_t
name|oset
decl_stmt|,
name|nset
decl_stmt|;
name|int
name|lins
decl_stmt|,
name|cols
decl_stmt|;
operator|(
name|void
operator|)
name|sigemptyset
argument_list|(
operator|&
name|nset
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigaddset
argument_list|(
operator|&
name|nset
argument_list|,
name|SIGWINCH
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigprocmask
argument_list|(
name|SIG_BLOCK
argument_list|,
operator|&
name|nset
argument_list|,
operator|&
name|oset
argument_list|)
expr_stmt|;
name|area
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|term
operator|==
name|NULL
condition|)
name|term
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|term
operator|||
operator|!
name|term
index|[
literal|0
index|]
condition|)
name|term
operator|=
literal|"dumb"
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|term
argument_list|,
literal|"emacs"
argument_list|)
operator|==
literal|0
condition|)
name|el
operator|->
name|el_flags
operator||=
name|EDIT_DISABLED
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|el
operator|->
name|el_terminal
operator|.
name|t_cap
argument_list|,
literal|0
argument_list|,
name|TC_BUFSIZE
argument_list|)
expr_stmt|;
name|i
operator|=
name|tgetent
argument_list|(
name|el
operator|->
name|el_terminal
operator|.
name|t_cap
argument_list|,
name|term
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_errfile
argument_list|,
literal|"Cannot read termcap database;\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_errfile
argument_list|,
literal|"No entry for terminal type \"%s\";\n"
argument_list|,
name|term
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_errfile
argument_list|,
literal|"using dumb terminal settings.\n"
argument_list|)
expr_stmt|;
name|Val
argument_list|(
name|T_co
argument_list|)
operator|=
literal|80
expr_stmt|;
comment|/* do a dumb terminal */
name|Val
argument_list|(
name|T_pt
argument_list|)
operator|=
name|Val
argument_list|(
name|T_km
argument_list|)
operator|=
name|Val
argument_list|(
name|T_li
argument_list|)
operator|=
literal|0
expr_stmt|;
name|Val
argument_list|(
name|T_xt
argument_list|)
operator|=
name|Val
argument_list|(
name|T_MT
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|tstr
init|;
name|t
operator|->
name|name
operator|!=
name|NULL
condition|;
name|t
operator|++
control|)
name|terminal_alloc
argument_list|(
name|el
argument_list|,
name|t
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* auto/magic margins */
name|Val
argument_list|(
name|T_am
argument_list|)
operator|=
name|tgetflag
argument_list|(
literal|"am"
argument_list|)
expr_stmt|;
name|Val
argument_list|(
name|T_xn
argument_list|)
operator|=
name|tgetflag
argument_list|(
literal|"xn"
argument_list|)
expr_stmt|;
comment|/* Can we tab */
name|Val
argument_list|(
name|T_pt
argument_list|)
operator|=
name|tgetflag
argument_list|(
literal|"pt"
argument_list|)
expr_stmt|;
name|Val
argument_list|(
name|T_xt
argument_list|)
operator|=
name|tgetflag
argument_list|(
literal|"xt"
argument_list|)
expr_stmt|;
comment|/* do we have a meta? */
name|Val
argument_list|(
name|T_km
argument_list|)
operator|=
name|tgetflag
argument_list|(
literal|"km"
argument_list|)
expr_stmt|;
name|Val
argument_list|(
name|T_MT
argument_list|)
operator|=
name|tgetflag
argument_list|(
literal|"MT"
argument_list|)
expr_stmt|;
comment|/* Get the size */
name|Val
argument_list|(
name|T_co
argument_list|)
operator|=
name|tgetnum
argument_list|(
literal|"co"
argument_list|)
expr_stmt|;
name|Val
argument_list|(
name|T_li
argument_list|)
operator|=
name|tgetnum
argument_list|(
literal|"li"
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|tstr
init|;
name|t
operator|->
name|name
operator|!=
name|NULL
condition|;
name|t
operator|++
control|)
block|{
comment|/* XXX: some systems' tgetstr needs non const */
name|terminal_alloc
argument_list|(
name|el
argument_list|,
name|t
argument_list|,
name|tgetstr
argument_list|(
name|strchr
argument_list|(
name|t
operator|->
name|name
argument_list|,
operator|*
name|t
operator|->
name|name
argument_list|)
argument_list|,
operator|&
name|area
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|Val
argument_list|(
name|T_co
argument_list|)
operator|<
literal|2
condition|)
name|Val
argument_list|(
name|T_co
argument_list|)
operator|=
literal|80
expr_stmt|;
comment|/* just in case */
if|if
condition|(
name|Val
argument_list|(
name|T_li
argument_list|)
operator|<
literal|1
condition|)
name|Val
argument_list|(
name|T_li
argument_list|)
operator|=
literal|24
expr_stmt|;
name|el
operator|->
name|el_terminal
operator|.
name|t_size
operator|.
name|v
operator|=
name|Val
argument_list|(
name|T_co
argument_list|)
expr_stmt|;
name|el
operator|->
name|el_terminal
operator|.
name|t_size
operator|.
name|h
operator|=
name|Val
argument_list|(
name|T_li
argument_list|)
expr_stmt|;
name|terminal_setflags
argument_list|(
name|el
argument_list|)
expr_stmt|;
comment|/* get the correct window size */
operator|(
name|void
operator|)
name|terminal_get_size
argument_list|(
name|el
argument_list|,
operator|&
name|lins
argument_list|,
operator|&
name|cols
argument_list|)
expr_stmt|;
if|if
condition|(
name|terminal_change_size
argument_list|(
name|el
argument_list|,
name|lins
argument_list|,
name|cols
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
operator|(
name|void
operator|)
name|sigprocmask
argument_list|(
name|SIG_SETMASK
argument_list|,
operator|&
name|oset
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|terminal_bind_arrow
argument_list|(
name|el
argument_list|)
expr_stmt|;
name|el
operator|->
name|el_terminal
operator|.
name|t_name
operator|=
name|term
expr_stmt|;
return|return
name|i
operator|<=
literal|0
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* terminal_get_size():  *	Return the new window size in lines and cols, and  *	true if the size was changed.  */
end_comment

begin_function
name|protected
name|int
name|terminal_get_size
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|,
name|int
modifier|*
name|lins
parameter_list|,
name|int
modifier|*
name|cols
parameter_list|)
block|{
operator|*
name|cols
operator|=
name|Val
argument_list|(
name|T_co
argument_list|)
expr_stmt|;
operator|*
name|lins
operator|=
name|Val
argument_list|(
name|T_li
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCGWINSZ
block|{
name|struct
name|winsize
name|ws
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|el
operator|->
name|el_infd
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|ws
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|ws
operator|.
name|ws_col
condition|)
operator|*
name|cols
operator|=
name|ws
operator|.
name|ws_col
expr_stmt|;
if|if
condition|(
name|ws
operator|.
name|ws_row
condition|)
operator|*
name|lins
operator|=
name|ws
operator|.
name|ws_row
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TIOCGSIZE
block|{
name|struct
name|ttysize
name|ts
decl_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|el
operator|->
name|el_infd
argument_list|,
name|TIOCGSIZE
argument_list|,
operator|&
name|ts
argument_list|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|ts
operator|.
name|ts_cols
condition|)
operator|*
name|cols
operator|=
name|ts
operator|.
name|ts_cols
expr_stmt|;
if|if
condition|(
name|ts
operator|.
name|ts_lines
condition|)
operator|*
name|lins
operator|=
name|ts
operator|.
name|ts_lines
expr_stmt|;
block|}
block|}
endif|#
directive|endif
return|return
name|Val
argument_list|(
name|T_co
argument_list|)
operator|!=
operator|*
name|cols
operator|||
name|Val
argument_list|(
name|T_li
argument_list|)
operator|!=
operator|*
name|lins
return|;
block|}
end_function

begin_comment
comment|/* terminal_change_size():  *	Change the size of the terminal  */
end_comment

begin_function
name|protected
name|int
name|terminal_change_size
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|,
name|int
name|lins
parameter_list|,
name|int
name|cols
parameter_list|)
block|{
comment|/*          * Just in case          */
name|Val
argument_list|(
name|T_co
argument_list|)
operator|=
operator|(
name|cols
operator|<
literal|2
operator|)
condition|?
literal|80
else|:
name|cols
expr_stmt|;
name|Val
argument_list|(
name|T_li
argument_list|)
operator|=
operator|(
name|lins
operator|<
literal|1
operator|)
condition|?
literal|24
else|:
name|lins
expr_stmt|;
comment|/* re-make display buffers */
if|if
condition|(
name|terminal_rebuffer_display
argument_list|(
name|el
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
name|re_clear_display
argument_list|(
name|el
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* terminal_init_arrow():  *	Initialize the arrow key bindings from termcap  */
end_comment

begin_function
name|private
name|void
name|terminal_init_arrow
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|)
block|{
name|funckey_t
modifier|*
name|arrow
init|=
name|el
operator|->
name|el_terminal
operator|.
name|t_fkey
decl_stmt|;
name|arrow
index|[
name|A_K_DN
index|]
operator|.
name|name
operator|=
name|STR
argument_list|(
literal|"down"
argument_list|)
expr_stmt|;
name|arrow
index|[
name|A_K_DN
index|]
operator|.
name|key
operator|=
name|T_kd
expr_stmt|;
name|arrow
index|[
name|A_K_DN
index|]
operator|.
name|fun
operator|.
name|cmd
operator|=
name|ED_NEXT_HISTORY
expr_stmt|;
name|arrow
index|[
name|A_K_DN
index|]
operator|.
name|type
operator|=
name|XK_CMD
expr_stmt|;
name|arrow
index|[
name|A_K_UP
index|]
operator|.
name|name
operator|=
name|STR
argument_list|(
literal|"up"
argument_list|)
expr_stmt|;
name|arrow
index|[
name|A_K_UP
index|]
operator|.
name|key
operator|=
name|T_ku
expr_stmt|;
name|arrow
index|[
name|A_K_UP
index|]
operator|.
name|fun
operator|.
name|cmd
operator|=
name|ED_PREV_HISTORY
expr_stmt|;
name|arrow
index|[
name|A_K_UP
index|]
operator|.
name|type
operator|=
name|XK_CMD
expr_stmt|;
name|arrow
index|[
name|A_K_LT
index|]
operator|.
name|name
operator|=
name|STR
argument_list|(
literal|"left"
argument_list|)
expr_stmt|;
name|arrow
index|[
name|A_K_LT
index|]
operator|.
name|key
operator|=
name|T_kl
expr_stmt|;
name|arrow
index|[
name|A_K_LT
index|]
operator|.
name|fun
operator|.
name|cmd
operator|=
name|ED_PREV_CHAR
expr_stmt|;
name|arrow
index|[
name|A_K_LT
index|]
operator|.
name|type
operator|=
name|XK_CMD
expr_stmt|;
name|arrow
index|[
name|A_K_RT
index|]
operator|.
name|name
operator|=
name|STR
argument_list|(
literal|"right"
argument_list|)
expr_stmt|;
name|arrow
index|[
name|A_K_RT
index|]
operator|.
name|key
operator|=
name|T_kr
expr_stmt|;
name|arrow
index|[
name|A_K_RT
index|]
operator|.
name|fun
operator|.
name|cmd
operator|=
name|ED_NEXT_CHAR
expr_stmt|;
name|arrow
index|[
name|A_K_RT
index|]
operator|.
name|type
operator|=
name|XK_CMD
expr_stmt|;
name|arrow
index|[
name|A_K_HO
index|]
operator|.
name|name
operator|=
name|STR
argument_list|(
literal|"home"
argument_list|)
expr_stmt|;
name|arrow
index|[
name|A_K_HO
index|]
operator|.
name|key
operator|=
name|T_kh
expr_stmt|;
name|arrow
index|[
name|A_K_HO
index|]
operator|.
name|fun
operator|.
name|cmd
operator|=
name|ED_MOVE_TO_BEG
expr_stmt|;
name|arrow
index|[
name|A_K_HO
index|]
operator|.
name|type
operator|=
name|XK_CMD
expr_stmt|;
name|arrow
index|[
name|A_K_EN
index|]
operator|.
name|name
operator|=
name|STR
argument_list|(
literal|"end"
argument_list|)
expr_stmt|;
name|arrow
index|[
name|A_K_EN
index|]
operator|.
name|key
operator|=
name|T_at7
expr_stmt|;
name|arrow
index|[
name|A_K_EN
index|]
operator|.
name|fun
operator|.
name|cmd
operator|=
name|ED_MOVE_TO_END
expr_stmt|;
name|arrow
index|[
name|A_K_EN
index|]
operator|.
name|type
operator|=
name|XK_CMD
expr_stmt|;
name|arrow
index|[
name|A_K_DE
index|]
operator|.
name|name
operator|=
name|STR
argument_list|(
literal|"delete"
argument_list|)
expr_stmt|;
name|arrow
index|[
name|A_K_DE
index|]
operator|.
name|key
operator|=
name|T_kD
expr_stmt|;
name|arrow
index|[
name|A_K_DE
index|]
operator|.
name|fun
operator|.
name|cmd
operator|=
name|ED_DELETE_NEXT_CHAR
expr_stmt|;
name|arrow
index|[
name|A_K_DE
index|]
operator|.
name|type
operator|=
name|XK_CMD
expr_stmt|;
block|}
end_function

begin_comment
comment|/* terminal_reset_arrow():  *	Reset arrow key bindings  */
end_comment

begin_function
name|private
name|void
name|terminal_reset_arrow
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|)
block|{
name|funckey_t
modifier|*
name|arrow
init|=
name|el
operator|->
name|el_terminal
operator|.
name|t_fkey
decl_stmt|;
specifier|static
specifier|const
name|Char
name|strA
index|[]
init|=
block|{
literal|033
block|,
literal|'['
block|,
literal|'A'
block|,
literal|'\0'
block|}
decl_stmt|;
specifier|static
specifier|const
name|Char
name|strB
index|[]
init|=
block|{
literal|033
block|,
literal|'['
block|,
literal|'B'
block|,
literal|'\0'
block|}
decl_stmt|;
specifier|static
specifier|const
name|Char
name|strC
index|[]
init|=
block|{
literal|033
block|,
literal|'['
block|,
literal|'C'
block|,
literal|'\0'
block|}
decl_stmt|;
specifier|static
specifier|const
name|Char
name|strD
index|[]
init|=
block|{
literal|033
block|,
literal|'['
block|,
literal|'D'
block|,
literal|'\0'
block|}
decl_stmt|;
specifier|static
specifier|const
name|Char
name|strH
index|[]
init|=
block|{
literal|033
block|,
literal|'['
block|,
literal|'H'
block|,
literal|'\0'
block|}
decl_stmt|;
specifier|static
specifier|const
name|Char
name|strF
index|[]
init|=
block|{
literal|033
block|,
literal|'['
block|,
literal|'F'
block|,
literal|'\0'
block|}
decl_stmt|;
specifier|static
specifier|const
name|Char
name|stOA
index|[]
init|=
block|{
literal|033
block|,
literal|'O'
block|,
literal|'A'
block|,
literal|'\0'
block|}
decl_stmt|;
specifier|static
specifier|const
name|Char
name|stOB
index|[]
init|=
block|{
literal|033
block|,
literal|'O'
block|,
literal|'B'
block|,
literal|'\0'
block|}
decl_stmt|;
specifier|static
specifier|const
name|Char
name|stOC
index|[]
init|=
block|{
literal|033
block|,
literal|'O'
block|,
literal|'C'
block|,
literal|'\0'
block|}
decl_stmt|;
specifier|static
specifier|const
name|Char
name|stOD
index|[]
init|=
block|{
literal|033
block|,
literal|'O'
block|,
literal|'D'
block|,
literal|'\0'
block|}
decl_stmt|;
specifier|static
specifier|const
name|Char
name|stOH
index|[]
init|=
block|{
literal|033
block|,
literal|'O'
block|,
literal|'H'
block|,
literal|'\0'
block|}
decl_stmt|;
specifier|static
specifier|const
name|Char
name|stOF
index|[]
init|=
block|{
literal|033
block|,
literal|'O'
block|,
literal|'F'
block|,
literal|'\0'
block|}
decl_stmt|;
name|keymacro_add
argument_list|(
name|el
argument_list|,
name|strA
argument_list|,
operator|&
name|arrow
index|[
name|A_K_UP
index|]
operator|.
name|fun
argument_list|,
name|arrow
index|[
name|A_K_UP
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|keymacro_add
argument_list|(
name|el
argument_list|,
name|strB
argument_list|,
operator|&
name|arrow
index|[
name|A_K_DN
index|]
operator|.
name|fun
argument_list|,
name|arrow
index|[
name|A_K_DN
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|keymacro_add
argument_list|(
name|el
argument_list|,
name|strC
argument_list|,
operator|&
name|arrow
index|[
name|A_K_RT
index|]
operator|.
name|fun
argument_list|,
name|arrow
index|[
name|A_K_RT
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|keymacro_add
argument_list|(
name|el
argument_list|,
name|strD
argument_list|,
operator|&
name|arrow
index|[
name|A_K_LT
index|]
operator|.
name|fun
argument_list|,
name|arrow
index|[
name|A_K_LT
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|keymacro_add
argument_list|(
name|el
argument_list|,
name|strH
argument_list|,
operator|&
name|arrow
index|[
name|A_K_HO
index|]
operator|.
name|fun
argument_list|,
name|arrow
index|[
name|A_K_HO
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|keymacro_add
argument_list|(
name|el
argument_list|,
name|strF
argument_list|,
operator|&
name|arrow
index|[
name|A_K_EN
index|]
operator|.
name|fun
argument_list|,
name|arrow
index|[
name|A_K_EN
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|keymacro_add
argument_list|(
name|el
argument_list|,
name|stOA
argument_list|,
operator|&
name|arrow
index|[
name|A_K_UP
index|]
operator|.
name|fun
argument_list|,
name|arrow
index|[
name|A_K_UP
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|keymacro_add
argument_list|(
name|el
argument_list|,
name|stOB
argument_list|,
operator|&
name|arrow
index|[
name|A_K_DN
index|]
operator|.
name|fun
argument_list|,
name|arrow
index|[
name|A_K_DN
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|keymacro_add
argument_list|(
name|el
argument_list|,
name|stOC
argument_list|,
operator|&
name|arrow
index|[
name|A_K_RT
index|]
operator|.
name|fun
argument_list|,
name|arrow
index|[
name|A_K_RT
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|keymacro_add
argument_list|(
name|el
argument_list|,
name|stOD
argument_list|,
operator|&
name|arrow
index|[
name|A_K_LT
index|]
operator|.
name|fun
argument_list|,
name|arrow
index|[
name|A_K_LT
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|keymacro_add
argument_list|(
name|el
argument_list|,
name|stOH
argument_list|,
operator|&
name|arrow
index|[
name|A_K_HO
index|]
operator|.
name|fun
argument_list|,
name|arrow
index|[
name|A_K_HO
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|keymacro_add
argument_list|(
name|el
argument_list|,
name|stOF
argument_list|,
operator|&
name|arrow
index|[
name|A_K_EN
index|]
operator|.
name|fun
argument_list|,
name|arrow
index|[
name|A_K_EN
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|el
operator|->
name|el_map
operator|.
name|type
operator|!=
name|MAP_VI
condition|)
return|return;
name|keymacro_add
argument_list|(
name|el
argument_list|,
operator|&
name|strA
index|[
literal|1
index|]
argument_list|,
operator|&
name|arrow
index|[
name|A_K_UP
index|]
operator|.
name|fun
argument_list|,
name|arrow
index|[
name|A_K_UP
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|keymacro_add
argument_list|(
name|el
argument_list|,
operator|&
name|strB
index|[
literal|1
index|]
argument_list|,
operator|&
name|arrow
index|[
name|A_K_DN
index|]
operator|.
name|fun
argument_list|,
name|arrow
index|[
name|A_K_DN
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|keymacro_add
argument_list|(
name|el
argument_list|,
operator|&
name|strC
index|[
literal|1
index|]
argument_list|,
operator|&
name|arrow
index|[
name|A_K_RT
index|]
operator|.
name|fun
argument_list|,
name|arrow
index|[
name|A_K_RT
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|keymacro_add
argument_list|(
name|el
argument_list|,
operator|&
name|strD
index|[
literal|1
index|]
argument_list|,
operator|&
name|arrow
index|[
name|A_K_LT
index|]
operator|.
name|fun
argument_list|,
name|arrow
index|[
name|A_K_LT
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|keymacro_add
argument_list|(
name|el
argument_list|,
operator|&
name|strH
index|[
literal|1
index|]
argument_list|,
operator|&
name|arrow
index|[
name|A_K_HO
index|]
operator|.
name|fun
argument_list|,
name|arrow
index|[
name|A_K_HO
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|keymacro_add
argument_list|(
name|el
argument_list|,
operator|&
name|strF
index|[
literal|1
index|]
argument_list|,
operator|&
name|arrow
index|[
name|A_K_EN
index|]
operator|.
name|fun
argument_list|,
name|arrow
index|[
name|A_K_EN
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|keymacro_add
argument_list|(
name|el
argument_list|,
operator|&
name|stOA
index|[
literal|1
index|]
argument_list|,
operator|&
name|arrow
index|[
name|A_K_UP
index|]
operator|.
name|fun
argument_list|,
name|arrow
index|[
name|A_K_UP
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|keymacro_add
argument_list|(
name|el
argument_list|,
operator|&
name|stOB
index|[
literal|1
index|]
argument_list|,
operator|&
name|arrow
index|[
name|A_K_DN
index|]
operator|.
name|fun
argument_list|,
name|arrow
index|[
name|A_K_DN
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|keymacro_add
argument_list|(
name|el
argument_list|,
operator|&
name|stOC
index|[
literal|1
index|]
argument_list|,
operator|&
name|arrow
index|[
name|A_K_RT
index|]
operator|.
name|fun
argument_list|,
name|arrow
index|[
name|A_K_RT
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|keymacro_add
argument_list|(
name|el
argument_list|,
operator|&
name|stOD
index|[
literal|1
index|]
argument_list|,
operator|&
name|arrow
index|[
name|A_K_LT
index|]
operator|.
name|fun
argument_list|,
name|arrow
index|[
name|A_K_LT
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|keymacro_add
argument_list|(
name|el
argument_list|,
operator|&
name|stOH
index|[
literal|1
index|]
argument_list|,
operator|&
name|arrow
index|[
name|A_K_HO
index|]
operator|.
name|fun
argument_list|,
name|arrow
index|[
name|A_K_HO
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|keymacro_add
argument_list|(
name|el
argument_list|,
operator|&
name|stOF
index|[
literal|1
index|]
argument_list|,
operator|&
name|arrow
index|[
name|A_K_EN
index|]
operator|.
name|fun
argument_list|,
name|arrow
index|[
name|A_K_EN
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* terminal_set_arrow():  *	Set an arrow key binding  */
end_comment

begin_function
name|protected
name|int
name|terminal_set_arrow
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|,
specifier|const
name|Char
modifier|*
name|name
parameter_list|,
name|keymacro_value_t
modifier|*
name|fun
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|funckey_t
modifier|*
name|arrow
init|=
name|el
operator|->
name|el_terminal
operator|.
name|t_fkey
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|A_K_NKEYS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|Strcmp
argument_list|(
name|name
argument_list|,
name|arrow
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|arrow
index|[
name|i
index|]
operator|.
name|fun
operator|=
operator|*
name|fun
expr_stmt|;
name|arrow
index|[
name|i
index|]
operator|.
name|type
operator|=
name|type
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* terminal_clear_arrow():  *	Clear an arrow key binding  */
end_comment

begin_function
name|protected
name|int
name|terminal_clear_arrow
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|,
specifier|const
name|Char
modifier|*
name|name
parameter_list|)
block|{
name|funckey_t
modifier|*
name|arrow
init|=
name|el
operator|->
name|el_terminal
operator|.
name|t_fkey
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|A_K_NKEYS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|Strcmp
argument_list|(
name|name
argument_list|,
name|arrow
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|arrow
index|[
name|i
index|]
operator|.
name|type
operator|=
name|XK_NOD
expr_stmt|;
return|return
literal|0
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* terminal_print_arrow():  *	Print the arrow key bindings  */
end_comment

begin_function
name|protected
name|void
name|terminal_print_arrow
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|,
specifier|const
name|Char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|funckey_t
modifier|*
name|arrow
init|=
name|el
operator|->
name|el_terminal
operator|.
name|t_fkey
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|A_K_NKEYS
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
operator|||
name|Strcmp
argument_list|(
name|name
argument_list|,
name|arrow
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
name|arrow
index|[
name|i
index|]
operator|.
name|type
operator|!=
name|XK_NOD
condition|)
name|keymacro_kprint
argument_list|(
name|el
argument_list|,
name|arrow
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|&
name|arrow
index|[
name|i
index|]
operator|.
name|fun
argument_list|,
name|arrow
index|[
name|i
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* terminal_bind_arrow():  *	Bind the arrow keys  */
end_comment

begin_function
name|protected
name|void
name|terminal_bind_arrow
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|)
block|{
name|el_action_t
modifier|*
name|map
decl_stmt|;
specifier|const
name|el_action_t
modifier|*
name|dmap
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|funckey_t
modifier|*
name|arrow
init|=
name|el
operator|->
name|el_terminal
operator|.
name|t_fkey
decl_stmt|;
comment|/* Check if the components needed are initialized */
if|if
condition|(
name|el
operator|->
name|el_terminal
operator|.
name|t_buf
operator|==
name|NULL
operator|||
name|el
operator|->
name|el_map
operator|.
name|key
operator|==
name|NULL
condition|)
return|return;
name|map
operator|=
name|el
operator|->
name|el_map
operator|.
name|type
operator|==
name|MAP_VI
condition|?
name|el
operator|->
name|el_map
operator|.
name|alt
else|:
name|el
operator|->
name|el_map
operator|.
name|key
expr_stmt|;
name|dmap
operator|=
name|el
operator|->
name|el_map
operator|.
name|type
operator|==
name|MAP_VI
condition|?
name|el
operator|->
name|el_map
operator|.
name|vic
else|:
name|el
operator|->
name|el_map
operator|.
name|emacs
expr_stmt|;
name|terminal_reset_arrow
argument_list|(
name|el
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|A_K_NKEYS
condition|;
name|i
operator|++
control|)
block|{
name|Char
name|wt_str
index|[
name|VISUAL_WIDTH_MAX
index|]
decl_stmt|;
name|Char
modifier|*
name|px
decl_stmt|;
name|size_t
name|n
decl_stmt|;
name|p
operator|=
name|el
operator|->
name|el_terminal
operator|.
name|t_str
index|[
name|arrow
index|[
name|i
index|]
operator|.
name|key
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|p
operator|||
operator|!
operator|*
name|p
condition|)
continue|continue;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|VISUAL_WIDTH_MAX
operator|&&
name|p
index|[
name|n
index|]
condition|;
operator|++
name|n
control|)
name|wt_str
index|[
name|n
index|]
operator|=
name|p
index|[
name|n
index|]
expr_stmt|;
while|while
condition|(
name|n
operator|<
name|VISUAL_WIDTH_MAX
condition|)
name|wt_str
index|[
name|n
operator|++
index|]
operator|=
literal|'\0'
expr_stmt|;
name|px
operator|=
name|wt_str
expr_stmt|;
name|j
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
expr_stmt|;
comment|/* 		 * Assign the arrow keys only if: 		 * 		 * 1. They are multi-character arrow keys and the user 		 *    has not re-assigned the leading character, or 		 *    has re-assigned the leading character to be 		 *	  ED_SEQUENCE_LEAD_IN 		 * 2. They are single arrow keys pointing to an 		 *    unassigned key. 		 */
if|if
condition|(
name|arrow
index|[
name|i
index|]
operator|.
name|type
operator|==
name|XK_NOD
condition|)
name|keymacro_clear
argument_list|(
name|el
argument_list|,
name|map
argument_list|,
name|px
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|&&
operator|(
name|dmap
index|[
name|j
index|]
operator|==
name|map
index|[
name|j
index|]
operator|||
name|map
index|[
name|j
index|]
operator|==
name|ED_SEQUENCE_LEAD_IN
operator|)
condition|)
block|{
name|keymacro_add
argument_list|(
name|el
argument_list|,
name|px
argument_list|,
operator|&
name|arrow
index|[
name|i
index|]
operator|.
name|fun
argument_list|,
name|arrow
index|[
name|i
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
name|map
index|[
name|j
index|]
operator|=
name|ED_SEQUENCE_LEAD_IN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|map
index|[
name|j
index|]
operator|==
name|ED_UNASSIGNED
condition|)
block|{
name|keymacro_clear
argument_list|(
name|el
argument_list|,
name|map
argument_list|,
name|px
argument_list|)
expr_stmt|;
if|if
condition|(
name|arrow
index|[
name|i
index|]
operator|.
name|type
operator|==
name|XK_CMD
condition|)
name|map
index|[
name|j
index|]
operator|=
name|arrow
index|[
name|i
index|]
operator|.
name|fun
operator|.
name|cmd
expr_stmt|;
else|else
name|keymacro_add
argument_list|(
name|el
argument_list|,
name|px
argument_list|,
operator|&
name|arrow
index|[
name|i
index|]
operator|.
name|fun
argument_list|,
name|arrow
index|[
name|i
index|]
operator|.
name|type
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* terminal_putc():  *	Add a character  */
end_comment

begin_function
name|private
name|int
name|terminal_putc
parameter_list|(
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|terminal_outfile
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|fputc
argument_list|(
name|c
argument_list|,
name|terminal_outfile
argument_list|)
return|;
block|}
end_function

begin_function
name|private
name|void
name|terminal_tputs
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|,
specifier|const
name|char
modifier|*
name|cap
parameter_list|,
name|int
name|affcnt
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_REENTRANT
name|pthread_mutex_lock
argument_list|(
operator|&
name|terminal_mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|terminal_outfile
operator|=
name|el
operator|->
name|el_outfile
expr_stmt|;
operator|(
name|void
operator|)
name|tputs
argument_list|(
name|cap
argument_list|,
name|affcnt
argument_list|,
name|terminal_putc
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_REENTRANT
name|pthread_mutex_unlock
argument_list|(
operator|&
name|terminal_mutex
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* terminal__putc():  *	Add a character  */
end_comment

begin_function
name|protected
name|int
name|terminal__putc
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|,
name|Int
name|c
parameter_list|)
block|{
name|char
name|buf
index|[
name|MB_LEN_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|ssize_t
name|i
decl_stmt|;
if|if
condition|(
name|c
operator|==
operator|(
name|Int
operator|)
name|MB_FILL_CHAR
condition|)
return|return
literal|0
return|;
name|i
operator|=
name|ct_encode_char
argument_list|(
name|buf
argument_list|,
operator|(
name|size_t
operator|)
name|MB_LEN_MAX
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
return|return
operator|(
name|int
operator|)
name|i
return|;
name|buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|fputs
argument_list|(
name|buf
argument_list|,
name|el
operator|->
name|el_outfile
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* terminal__flush():  *	Flush output  */
end_comment

begin_function
name|protected
name|void
name|terminal__flush
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|el
operator|->
name|el_outfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* terminal_writec():  *	Write the given character out, in a human readable form  */
end_comment

begin_function
name|protected
name|void
name|terminal_writec
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|,
name|Int
name|c
parameter_list|)
block|{
name|Char
name|visbuf
index|[
name|VISUAL_WIDTH_MAX
operator|+
literal|1
index|]
decl_stmt|;
name|ssize_t
name|vcnt
init|=
name|ct_visual_char
argument_list|(
name|visbuf
argument_list|,
name|VISUAL_WIDTH_MAX
argument_list|,
name|c
argument_list|)
decl_stmt|;
if|if
condition|(
name|vcnt
operator|<
literal|0
condition|)
name|vcnt
operator|=
literal|0
expr_stmt|;
name|visbuf
index|[
name|vcnt
index|]
operator|=
literal|'\0'
expr_stmt|;
name|terminal_overwrite
argument_list|(
name|el
argument_list|,
name|visbuf
argument_list|,
operator|(
name|size_t
operator|)
name|vcnt
argument_list|)
expr_stmt|;
name|terminal__flush
argument_list|(
name|el
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* terminal_telltc():  *	Print the current termcap characteristics  */
end_comment

begin_decl_stmt
name|protected
name|int
comment|/*ARGSUSED*/
name|terminal_telltc
argument_list|(
name|EditLine
operator|*
name|el
argument_list|,
name|int
name|argc
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|,
specifier|const
name|Char
operator|*
operator|*
name|argv
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|)
block|{
specifier|const
name|struct
name|termcapstr
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
modifier|*
name|ts
decl_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_outfile
argument_list|,
literal|"\n\tYour terminal has the\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_outfile
argument_list|,
literal|"\tfollowing characteristics:\n\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_outfile
argument_list|,
literal|"\tIt has %d columns and %d lines\n"
argument_list|,
name|Val
argument_list|(
name|T_co
argument_list|)
argument_list|,
name|Val
argument_list|(
name|T_li
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_outfile
argument_list|,
literal|"\tIt has %s meta key\n"
argument_list|,
name|EL_HAS_META
condition|?
literal|"a"
else|:
literal|"no"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_outfile
argument_list|,
literal|"\tIt can%suse tabs\n"
argument_list|,
name|EL_CAN_TAB
condition|?
literal|" "
else|:
literal|"not "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_outfile
argument_list|,
literal|"\tIt %s automatic margins\n"
argument_list|,
name|EL_HAS_AUTO_MARGINS
condition|?
literal|"has"
else|:
literal|"does not have"
argument_list|)
expr_stmt|;
if|if
condition|(
name|EL_HAS_AUTO_MARGINS
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_outfile
argument_list|,
literal|"\tIt %s magic margins\n"
argument_list|,
name|EL_HAS_MAGIC_MARGINS
condition|?
literal|"has"
else|:
literal|"does not have"
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|tstr
operator|,
name|ts
operator|=
name|el
operator|->
name|el_terminal
operator|.
name|t_str
init|;
name|t
operator|->
name|name
operator|!=
name|NULL
condition|;
name|t
operator|++
operator|,
name|ts
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|ub
decl_stmt|;
if|if
condition|(
operator|*
name|ts
operator|&&
operator|*
operator|*
name|ts
condition|)
block|{
name|ub
operator|=
name|ct_encode_string
argument_list|(
name|ct_visual_string
argument_list|(
name|ct_decode_string
argument_list|(
operator|*
name|ts
argument_list|,
operator|&
name|el
operator|->
name|el_scratch
argument_list|)
argument_list|)
argument_list|,
operator|&
name|el
operator|->
name|el_scratch
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ub
operator|=
literal|"(empty)"
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_outfile
argument_list|,
literal|"\t%25s (%s) == %s\n"
argument_list|,
name|t
operator|->
name|long_name
argument_list|,
name|t
operator|->
name|name
argument_list|,
name|ub
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|el
operator|->
name|el_outfile
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_comment
comment|/* terminal_settc():  *	Change the current terminal characteristics  */
end_comment

begin_decl_stmt
name|protected
name|int
comment|/*ARGSUSED*/
name|terminal_settc
argument_list|(
name|EditLine
operator|*
name|el
argument_list|,
name|int
name|argc
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|,
specifier|const
name|Char
operator|*
operator|*
name|argv
argument_list|)
block|{
specifier|const
name|struct
name|termcapstr
modifier|*
name|ts
decl_stmt|;
specifier|const
name|struct
name|termcapval
modifier|*
name|tv
decl_stmt|;
name|char
name|what
index|[
literal|8
index|]
decl_stmt|,
name|how
index|[
literal|8
index|]
decl_stmt|;
if|if
condition|(
name|argv
operator|==
name|NULL
operator|||
name|argv
index|[
literal|1
index|]
operator|==
name|NULL
operator|||
name|argv
index|[
literal|2
index|]
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|strncpy
argument_list|(
name|what
argument_list|,
name|ct_encode_string
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|&
name|el
operator|->
name|el_scratch
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|what
argument_list|)
argument_list|)
expr_stmt|;
name|what
index|[
sizeof|sizeof
argument_list|(
name|what
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strncpy
argument_list|(
name|how
argument_list|,
name|ct_encode_string
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|,
operator|&
name|el
operator|->
name|el_scratch
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|how
argument_list|)
argument_list|)
expr_stmt|;
name|how
index|[
sizeof|sizeof
argument_list|(
name|how
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/*          * Do the strings first          */
for|for
control|(
name|ts
operator|=
name|tstr
init|;
name|ts
operator|->
name|name
operator|!=
name|NULL
condition|;
name|ts
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|ts
operator|->
name|name
argument_list|,
name|what
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|ts
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
name|terminal_alloc
argument_list|(
name|el
argument_list|,
name|ts
argument_list|,
name|how
argument_list|)
expr_stmt|;
name|terminal_setflags
argument_list|(
name|el
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*          * Do the numeric ones second          */
for|for
control|(
name|tv
operator|=
name|tval
init|;
name|tv
operator|->
name|name
operator|!=
name|NULL
condition|;
name|tv
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|tv
operator|->
name|name
argument_list|,
name|what
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|tv
operator|->
name|name
operator|!=
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|tv
operator|==
operator|&
name|tval
index|[
name|T_pt
index|]
operator|||
name|tv
operator|==
operator|&
name|tval
index|[
name|T_km
index|]
operator|||
name|tv
operator|==
operator|&
name|tval
index|[
name|T_am
index|]
operator|||
name|tv
operator|==
operator|&
name|tval
index|[
name|T_xn
index|]
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|how
argument_list|,
literal|"yes"
argument_list|)
operator|==
literal|0
condition|)
name|el
operator|->
name|el_terminal
operator|.
name|t_val
index|[
name|tv
operator|-
name|tval
index|]
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|how
argument_list|,
literal|"no"
argument_list|)
operator|==
literal|0
condition|)
name|el
operator|->
name|el_terminal
operator|.
name|t_val
index|[
name|tv
operator|-
name|tval
index|]
operator|=
literal|0
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_errfile
argument_list|,
literal|""
name|FSTR
literal|": Bad value `%s'.\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|how
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|terminal_setflags
argument_list|(
name|el
argument_list|)
expr_stmt|;
if|if
condition|(
name|terminal_change_size
argument_list|(
name|el
argument_list|,
name|Val
argument_list|(
name|T_li
argument_list|)
argument_list|,
name|Val
argument_list|(
name|T_co
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
else|else
block|{
name|long
name|i
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
name|i
operator|=
name|strtol
argument_list|(
name|how
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ep
operator|!=
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_errfile
argument_list|,
literal|""
name|FSTR
literal|": Bad value `%s'.\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|how
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|el
operator|->
name|el_terminal
operator|.
name|t_val
index|[
name|tv
operator|-
name|tval
index|]
operator|=
operator|(
name|int
operator|)
name|i
expr_stmt|;
name|el
operator|->
name|el_terminal
operator|.
name|t_size
operator|.
name|v
operator|=
name|Val
argument_list|(
name|T_co
argument_list|)
expr_stmt|;
name|el
operator|->
name|el_terminal
operator|.
name|t_size
operator|.
name|h
operator|=
name|Val
argument_list|(
name|T_li
argument_list|)
expr_stmt|;
if|if
condition|(
name|tv
operator|==
operator|&
name|tval
index|[
name|T_co
index|]
operator|||
name|tv
operator|==
operator|&
name|tval
index|[
name|T_li
index|]
condition|)
if|if
condition|(
name|terminal_change_size
argument_list|(
name|el
argument_list|,
name|Val
argument_list|(
name|T_li
argument_list|)
argument_list|,
name|Val
argument_list|(
name|T_co
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/* terminal_gettc():  *	Get the current terminal characteristics  */
end_comment

begin_decl_stmt
name|protected
name|int
comment|/*ARGSUSED*/
name|terminal_gettc
argument_list|(
name|EditLine
operator|*
name|el
argument_list|,
name|int
name|argc
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|,
name|char
operator|*
operator|*
name|argv
argument_list|)
block|{
specifier|const
name|struct
name|termcapstr
modifier|*
name|ts
decl_stmt|;
specifier|const
name|struct
name|termcapval
modifier|*
name|tv
decl_stmt|;
name|char
modifier|*
name|what
decl_stmt|;
name|void
modifier|*
name|how
decl_stmt|;
if|if
condition|(
name|argv
operator|==
name|NULL
operator|||
name|argv
index|[
literal|1
index|]
operator|==
name|NULL
operator|||
name|argv
index|[
literal|2
index|]
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|what
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|how
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
comment|/*          * Do the strings first          */
for|for
control|(
name|ts
operator|=
name|tstr
init|;
name|ts
operator|->
name|name
operator|!=
name|NULL
condition|;
name|ts
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|ts
operator|->
name|name
argument_list|,
name|what
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|ts
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
name|how
operator|=
name|el
operator|->
name|el_terminal
operator|.
name|t_str
index|[
name|ts
operator|-
name|tstr
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*          * Do the numeric ones second          */
for|for
control|(
name|tv
operator|=
name|tval
init|;
name|tv
operator|->
name|name
operator|!=
name|NULL
condition|;
name|tv
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|tv
operator|->
name|name
argument_list|,
name|what
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|tv
operator|->
name|name
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|tv
operator|==
operator|&
name|tval
index|[
name|T_pt
index|]
operator|||
name|tv
operator|==
operator|&
name|tval
index|[
name|T_km
index|]
operator|||
name|tv
operator|==
operator|&
name|tval
index|[
name|T_am
index|]
operator|||
name|tv
operator|==
operator|&
name|tval
index|[
name|T_xn
index|]
condition|)
block|{
specifier|static
name|char
name|yes
index|[]
init|=
literal|"yes"
decl_stmt|;
specifier|static
name|char
name|no
index|[]
init|=
literal|"no"
decl_stmt|;
if|if
condition|(
name|el
operator|->
name|el_terminal
operator|.
name|t_val
index|[
name|tv
operator|-
name|tval
index|]
condition|)
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
name|how
operator|=
name|yes
expr_stmt|;
else|else
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
name|how
operator|=
name|no
expr_stmt|;
return|return
literal|0
return|;
block|}
else|else
block|{
operator|*
operator|(
name|int
operator|*
operator|)
name|how
operator|=
name|el
operator|->
name|el_terminal
operator|.
name|t_val
index|[
name|tv
operator|-
name|tval
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_decl_stmt

begin_comment
comment|/* terminal_echotc():  *	Print the termcap string out with variable substitution  */
end_comment

begin_decl_stmt
name|protected
name|int
comment|/*ARGSUSED*/
name|terminal_echotc
argument_list|(
name|EditLine
operator|*
name|el
argument_list|,
name|int
name|argc
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|,
specifier|const
name|Char
operator|*
operator|*
name|argv
argument_list|)
block|{
name|char
modifier|*
name|cap
decl_stmt|,
modifier|*
name|scap
decl_stmt|;
name|Char
modifier|*
name|ep
decl_stmt|;
name|int
name|arg_need
decl_stmt|,
name|arg_cols
decl_stmt|,
name|arg_rows
decl_stmt|;
name|int
name|verbose
init|=
literal|0
decl_stmt|,
name|silent
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|area
decl_stmt|;
specifier|static
specifier|const
name|char
name|fmts
index|[]
init|=
literal|"%s\n"
decl_stmt|,
name|fmtd
index|[]
init|=
literal|"%d\n"
decl_stmt|;
specifier|const
name|struct
name|termcapstr
modifier|*
name|t
decl_stmt|;
name|char
name|buf
index|[
name|TC_BUFSIZE
index|]
decl_stmt|;
name|long
name|i
decl_stmt|;
name|area
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|argv
operator|==
name|NULL
operator|||
name|argv
index|[
literal|1
index|]
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|argv
operator|++
expr_stmt|;
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'v'
case|:
name|verbose
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|silent
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* stderror(ERR_NAME | ERR_TCUSAGE); */
break|break;
block|}
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|*
name|argv
operator|||
operator|*
name|argv
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|Strcmp
argument_list|(
operator|*
name|argv
argument_list|,
name|STR
argument_list|(
literal|"tabs"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_outfile
argument_list|,
name|fmts
argument_list|,
name|EL_CAN_TAB
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|Strcmp
argument_list|(
operator|*
name|argv
argument_list|,
name|STR
argument_list|(
literal|"meta"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_outfile
argument_list|,
name|fmts
argument_list|,
name|Val
argument_list|(
name|T_km
argument_list|)
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|Strcmp
argument_list|(
operator|*
name|argv
argument_list|,
name|STR
argument_list|(
literal|"xn"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_outfile
argument_list|,
name|fmts
argument_list|,
name|EL_HAS_MAGIC_MARGINS
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|Strcmp
argument_list|(
operator|*
name|argv
argument_list|,
name|STR
argument_list|(
literal|"am"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_outfile
argument_list|,
name|fmts
argument_list|,
name|EL_HAS_AUTO_MARGINS
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|Strcmp
argument_list|(
operator|*
name|argv
argument_list|,
name|STR
argument_list|(
literal|"baud"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_outfile
argument_list|,
name|fmtd
argument_list|,
operator|(
name|int
operator|)
name|el
operator|->
name|el_tty
operator|.
name|t_speed
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|Strcmp
argument_list|(
operator|*
name|argv
argument_list|,
name|STR
argument_list|(
literal|"rows"
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
name|Strcmp
argument_list|(
operator|*
name|argv
argument_list|,
name|STR
argument_list|(
literal|"lines"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_outfile
argument_list|,
name|fmtd
argument_list|,
name|Val
argument_list|(
name|T_li
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|Strcmp
argument_list|(
operator|*
name|argv
argument_list|,
name|STR
argument_list|(
literal|"cols"
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_outfile
argument_list|,
name|fmtd
argument_list|,
name|Val
argument_list|(
name|T_co
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/*          * Try to use our local definition first          */
name|scap
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|t
operator|=
name|tstr
init|;
name|t
operator|->
name|name
operator|!=
name|NULL
condition|;
name|t
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|t
operator|->
name|name
argument_list|,
name|ct_encode_string
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|el
operator|->
name|el_scratch
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|scap
operator|=
name|el
operator|->
name|el_terminal
operator|.
name|t_str
index|[
name|t
operator|-
name|tstr
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|t
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* XXX: some systems' tgetstr needs non const */
name|scap
operator|=
name|tgetstr
argument_list|(
name|ct_encode_string
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|el
operator|->
name|el_scratch
argument_list|)
argument_list|,
operator|&
name|area
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|scap
operator|||
name|scap
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
name|silent
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_errfile
argument_list|,
literal|"echotc: Termcap parameter `"
name|FSTR
literal|"' not found.\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/*          * Count home many values we need for this capability.          */
for|for
control|(
name|cap
operator|=
name|scap
operator|,
name|arg_need
operator|=
literal|0
init|;
operator|*
name|cap
condition|;
name|cap
operator|++
control|)
if|if
condition|(
operator|*
name|cap
operator|==
literal|'%'
condition|)
switch|switch
condition|(
operator|*
operator|++
name|cap
condition|)
block|{
case|case
literal|'d'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'.'
case|:
case|case
literal|'+'
case|:
name|arg_need
operator|++
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
case|case
literal|'>'
case|:
case|case
literal|'i'
case|:
case|case
literal|'r'
case|:
case|case
literal|'n'
case|:
case|case
literal|'B'
case|:
case|case
literal|'D'
case|:
break|break;
default|default:
comment|/* 				 * hpux has lot's of them... 				 */
if|if
condition|(
name|verbose
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_errfile
argument_list|,
literal|"echotc: Warning: unknown termcap %% `%c'.\n"
argument_list|,
operator|*
name|cap
argument_list|)
expr_stmt|;
comment|/* This is bad, but I won't complain */
break|break;
block|}
switch|switch
condition|(
name|arg_need
condition|)
block|{
case|case
literal|0
case|:
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|argv
operator|&&
operator|*
name|argv
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|silent
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_errfile
argument_list|,
literal|"echotc: Warning: Extra argument `"
name|FSTR
literal|"'.\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|terminal_tputs
argument_list|(
name|el
argument_list|,
name|scap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|argv
operator|||
operator|*
name|argv
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
name|silent
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_errfile
argument_list|,
literal|"echotc: Warning: Missing argument.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|arg_cols
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|Strtol
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ep
operator|!=
literal|'\0'
operator|||
name|i
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|silent
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_errfile
argument_list|,
literal|"echotc: Bad value `"
name|FSTR
literal|"' for rows.\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|arg_rows
operator|=
operator|(
name|int
operator|)
name|i
expr_stmt|;
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|argv
operator|&&
operator|*
name|argv
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|silent
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_errfile
argument_list|,
literal|"echotc: Warning: Extra argument `"
name|FSTR
literal|"'.\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|terminal_tputs
argument_list|(
name|el
argument_list|,
name|tgoto
argument_list|(
name|scap
argument_list|,
name|arg_cols
argument_list|,
name|arg_rows
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* This is wrong, but I will ignore it... */
if|if
condition|(
name|verbose
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_errfile
argument_list|,
literal|"echotc: Warning: Too many required arguments (%d).\n"
argument_list|,
name|arg_need
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|2
case|:
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|argv
operator|||
operator|*
name|argv
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
name|silent
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_errfile
argument_list|,
literal|"echotc: Warning: Missing argument.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|i
operator|=
name|Strtol
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ep
operator|!=
literal|'\0'
operator|||
name|i
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|silent
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_errfile
argument_list|,
literal|"echotc: Bad value `"
name|FSTR
literal|"' for cols.\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|arg_cols
operator|=
operator|(
name|int
operator|)
name|i
expr_stmt|;
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|argv
operator|||
operator|*
name|argv
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
name|silent
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_errfile
argument_list|,
literal|"echotc: Warning: Missing argument.\n"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|i
operator|=
name|Strtol
argument_list|(
operator|*
name|argv
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ep
operator|!=
literal|'\0'
operator|||
name|i
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|silent
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_errfile
argument_list|,
literal|"echotc: Bad value `"
name|FSTR
literal|"' for rows.\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|arg_rows
operator|=
operator|(
name|int
operator|)
name|i
expr_stmt|;
if|if
condition|(
operator|*
name|ep
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|!
name|silent
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_errfile
argument_list|,
literal|"echotc: Bad value `"
name|FSTR
literal|"'.\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|argv
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|argv
operator|&&
operator|*
name|argv
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
operator|!
name|silent
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|el
operator|->
name|el_errfile
argument_list|,
literal|"echotc: Warning: Extra argument `"
name|FSTR
literal|"'.\n"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|terminal_tputs
argument_list|(
name|el
argument_list|,
name|tgoto
argument_list|(
name|scap
argument_list|,
name|arg_cols
argument_list|,
name|arg_rows
argument_list|)
argument_list|,
name|arg_rows
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_decl_stmt

end_unit

