begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: unvis.c,v 1.32 2010/11/27 21:22:11 christos Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 1989, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LIBC_SCCS
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
end_if

begin_if
if|#
directive|if
literal|0
end_if

begin_else
unit|static char sccsid[] = "@(#)unvis.c	8.1 (Berkeley) 6/4/93";
else|#
directive|else
end_else

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$NetBSD: unvis.c,v 1.32 2010/11/27 21:22:11 christos Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBC_SCCS and not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<vis.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__weak_alias
end_ifdef

begin_macro
name|__weak_alias
argument_list|(
argument|strunvis
argument_list|,
argument|_strunvis
argument_list|)
end_macro

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
operator|!
name|HAVE_VIS
end_if

begin_comment
comment|/*  * decode driven by state machine  */
end_comment

begin_define
define|#
directive|define
name|S_GROUND
value|0
end_define

begin_comment
comment|/* haven't seen escape char */
end_comment

begin_define
define|#
directive|define
name|S_START
value|1
end_define

begin_comment
comment|/* start decoding special sequence */
end_comment

begin_define
define|#
directive|define
name|S_META
value|2
end_define

begin_comment
comment|/* metachar started (M) */
end_comment

begin_define
define|#
directive|define
name|S_META1
value|3
end_define

begin_comment
comment|/* metachar more, regular char (-) */
end_comment

begin_define
define|#
directive|define
name|S_CTRL
value|4
end_define

begin_comment
comment|/* control char started (^) */
end_comment

begin_define
define|#
directive|define
name|S_OCTAL2
value|5
end_define

begin_comment
comment|/* octal digit 2 */
end_comment

begin_define
define|#
directive|define
name|S_OCTAL3
value|6
end_define

begin_comment
comment|/* octal digit 3 */
end_comment

begin_define
define|#
directive|define
name|S_HEX1
value|7
end_define

begin_comment
comment|/* http hex digit */
end_comment

begin_define
define|#
directive|define
name|S_HEX2
value|8
end_define

begin_comment
comment|/* http hex digit 2 */
end_comment

begin_define
define|#
directive|define
name|S_MIME1
value|9
end_define

begin_comment
comment|/* mime hex digit 1 */
end_comment

begin_define
define|#
directive|define
name|S_MIME2
value|10
end_define

begin_comment
comment|/* mime hex digit 2 */
end_comment

begin_define
define|#
directive|define
name|S_EATCRNL
value|11
end_define

begin_comment
comment|/* mime eating CRNL */
end_comment

begin_define
define|#
directive|define
name|S_AMP
value|12
end_define

begin_comment
comment|/* seen& */
end_comment

begin_define
define|#
directive|define
name|S_NUMBER
value|13
end_define

begin_comment
comment|/* collecting number */
end_comment

begin_define
define|#
directive|define
name|S_STRING
value|14
end_define

begin_comment
comment|/* collecting string */
end_comment

begin_define
define|#
directive|define
name|isoctal
parameter_list|(
name|c
parameter_list|)
value|(((u_char)(c))>= '0'&& ((u_char)(c))<= '7')
end_define

begin_define
define|#
directive|define
name|xtod
parameter_list|(
name|c
parameter_list|)
value|(isdigit(c) ? (c - '0') : ((tolower(c) - 'a') + 10))
end_define

begin_define
define|#
directive|define
name|XTOD
parameter_list|(
name|c
parameter_list|)
value|(isdigit(c) ? (c - '0') : ((c - 'A') + 10))
end_define

begin_comment
comment|/*  * RFC 1866  */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
name|nv
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|uint8_t
name|value
decl_stmt|;
block|}
name|nv
index|[]
init|=
block|{
block|{
literal|"AElig"
block|,
literal|198
block|}
block|,
comment|/* capital AE diphthong (ligature)  */
block|{
literal|"Aacute"
block|,
literal|193
block|}
block|,
comment|/* capital A, acute accent  */
block|{
literal|"Acirc"
block|,
literal|194
block|}
block|,
comment|/* capital A, circumflex accent  */
block|{
literal|"Agrave"
block|,
literal|192
block|}
block|,
comment|/* capital A, grave accent  */
block|{
literal|"Aring"
block|,
literal|197
block|}
block|,
comment|/* capital A, ring  */
block|{
literal|"Atilde"
block|,
literal|195
block|}
block|,
comment|/* capital A, tilde  */
block|{
literal|"Auml"
block|,
literal|196
block|}
block|,
comment|/* capital A, dieresis or umlaut mark  */
block|{
literal|"Ccedil"
block|,
literal|199
block|}
block|,
comment|/* capital C, cedilla  */
block|{
literal|"ETH"
block|,
literal|208
block|}
block|,
comment|/* capital Eth, Icelandic  */
block|{
literal|"Eacute"
block|,
literal|201
block|}
block|,
comment|/* capital E, acute accent  */
block|{
literal|"Ecirc"
block|,
literal|202
block|}
block|,
comment|/* capital E, circumflex accent  */
block|{
literal|"Egrave"
block|,
literal|200
block|}
block|,
comment|/* capital E, grave accent  */
block|{
literal|"Euml"
block|,
literal|203
block|}
block|,
comment|/* capital E, dieresis or umlaut mark  */
block|{
literal|"Iacute"
block|,
literal|205
block|}
block|,
comment|/* capital I, acute accent  */
block|{
literal|"Icirc"
block|,
literal|206
block|}
block|,
comment|/* capital I, circumflex accent  */
block|{
literal|"Igrave"
block|,
literal|204
block|}
block|,
comment|/* capital I, grave accent  */
block|{
literal|"Iuml"
block|,
literal|207
block|}
block|,
comment|/* capital I, dieresis or umlaut mark  */
block|{
literal|"Ntilde"
block|,
literal|209
block|}
block|,
comment|/* capital N, tilde  */
block|{
literal|"Oacute"
block|,
literal|211
block|}
block|,
comment|/* capital O, acute accent  */
block|{
literal|"Ocirc"
block|,
literal|212
block|}
block|,
comment|/* capital O, circumflex accent  */
block|{
literal|"Ograve"
block|,
literal|210
block|}
block|,
comment|/* capital O, grave accent  */
block|{
literal|"Oslash"
block|,
literal|216
block|}
block|,
comment|/* capital O, slash  */
block|{
literal|"Otilde"
block|,
literal|213
block|}
block|,
comment|/* capital O, tilde  */
block|{
literal|"Ouml"
block|,
literal|214
block|}
block|,
comment|/* capital O, dieresis or umlaut mark  */
block|{
literal|"THORN"
block|,
literal|222
block|}
block|,
comment|/* capital THORN, Icelandic  */
block|{
literal|"Uacute"
block|,
literal|218
block|}
block|,
comment|/* capital U, acute accent  */
block|{
literal|"Ucirc"
block|,
literal|219
block|}
block|,
comment|/* capital U, circumflex accent  */
block|{
literal|"Ugrave"
block|,
literal|217
block|}
block|,
comment|/* capital U, grave accent  */
block|{
literal|"Uuml"
block|,
literal|220
block|}
block|,
comment|/* capital U, dieresis or umlaut mark  */
block|{
literal|"Yacute"
block|,
literal|221
block|}
block|,
comment|/* capital Y, acute accent  */
block|{
literal|"aacute"
block|,
literal|225
block|}
block|,
comment|/* small a, acute accent  */
block|{
literal|"acirc"
block|,
literal|226
block|}
block|,
comment|/* small a, circumflex accent  */
block|{
literal|"acute"
block|,
literal|180
block|}
block|,
comment|/* acute accent  */
block|{
literal|"aelig"
block|,
literal|230
block|}
block|,
comment|/* small ae diphthong (ligature)  */
block|{
literal|"agrave"
block|,
literal|224
block|}
block|,
comment|/* small a, grave accent  */
block|{
literal|"amp"
block|,
literal|38
block|}
block|,
comment|/* ampersand  */
block|{
literal|"aring"
block|,
literal|229
block|}
block|,
comment|/* small a, ring  */
block|{
literal|"atilde"
block|,
literal|227
block|}
block|,
comment|/* small a, tilde  */
block|{
literal|"auml"
block|,
literal|228
block|}
block|,
comment|/* small a, dieresis or umlaut mark  */
block|{
literal|"brvbar"
block|,
literal|166
block|}
block|,
comment|/* broken (vertical) bar  */
block|{
literal|"ccedil"
block|,
literal|231
block|}
block|,
comment|/* small c, cedilla  */
block|{
literal|"cedil"
block|,
literal|184
block|}
block|,
comment|/* cedilla  */
block|{
literal|"cent"
block|,
literal|162
block|}
block|,
comment|/* cent sign  */
block|{
literal|"copy"
block|,
literal|169
block|}
block|,
comment|/* copyright sign  */
block|{
literal|"curren"
block|,
literal|164
block|}
block|,
comment|/* general currency sign  */
block|{
literal|"deg"
block|,
literal|176
block|}
block|,
comment|/* degree sign  */
block|{
literal|"divide"
block|,
literal|247
block|}
block|,
comment|/* divide sign  */
block|{
literal|"eacute"
block|,
literal|233
block|}
block|,
comment|/* small e, acute accent  */
block|{
literal|"ecirc"
block|,
literal|234
block|}
block|,
comment|/* small e, circumflex accent  */
block|{
literal|"egrave"
block|,
literal|232
block|}
block|,
comment|/* small e, grave accent  */
block|{
literal|"eth"
block|,
literal|240
block|}
block|,
comment|/* small eth, Icelandic  */
block|{
literal|"euml"
block|,
literal|235
block|}
block|,
comment|/* small e, dieresis or umlaut mark  */
block|{
literal|"frac12"
block|,
literal|189
block|}
block|,
comment|/* fraction one-half  */
block|{
literal|"frac14"
block|,
literal|188
block|}
block|,
comment|/* fraction one-quarter  */
block|{
literal|"frac34"
block|,
literal|190
block|}
block|,
comment|/* fraction three-quarters  */
block|{
literal|"gt"
block|,
literal|62
block|}
block|,
comment|/* greater than  */
block|{
literal|"iacute"
block|,
literal|237
block|}
block|,
comment|/* small i, acute accent  */
block|{
literal|"icirc"
block|,
literal|238
block|}
block|,
comment|/* small i, circumflex accent  */
block|{
literal|"iexcl"
block|,
literal|161
block|}
block|,
comment|/* inverted exclamation mark  */
block|{
literal|"igrave"
block|,
literal|236
block|}
block|,
comment|/* small i, grave accent  */
block|{
literal|"iquest"
block|,
literal|191
block|}
block|,
comment|/* inverted question mark  */
block|{
literal|"iuml"
block|,
literal|239
block|}
block|,
comment|/* small i, dieresis or umlaut mark  */
block|{
literal|"laquo"
block|,
literal|171
block|}
block|,
comment|/* angle quotation mark, left  */
block|{
literal|"lt"
block|,
literal|60
block|}
block|,
comment|/* less than  */
block|{
literal|"macr"
block|,
literal|175
block|}
block|,
comment|/* macron  */
block|{
literal|"micro"
block|,
literal|181
block|}
block|,
comment|/* micro sign  */
block|{
literal|"middot"
block|,
literal|183
block|}
block|,
comment|/* middle dot  */
block|{
literal|"nbsp"
block|,
literal|160
block|}
block|,
comment|/* no-break space  */
block|{
literal|"not"
block|,
literal|172
block|}
block|,
comment|/* not sign  */
block|{
literal|"ntilde"
block|,
literal|241
block|}
block|,
comment|/* small n, tilde  */
block|{
literal|"oacute"
block|,
literal|243
block|}
block|,
comment|/* small o, acute accent  */
block|{
literal|"ocirc"
block|,
literal|244
block|}
block|,
comment|/* small o, circumflex accent  */
block|{
literal|"ograve"
block|,
literal|242
block|}
block|,
comment|/* small o, grave accent  */
block|{
literal|"ordf"
block|,
literal|170
block|}
block|,
comment|/* ordinal indicator, feminine  */
block|{
literal|"ordm"
block|,
literal|186
block|}
block|,
comment|/* ordinal indicator, masculine  */
block|{
literal|"oslash"
block|,
literal|248
block|}
block|,
comment|/* small o, slash  */
block|{
literal|"otilde"
block|,
literal|245
block|}
block|,
comment|/* small o, tilde  */
block|{
literal|"ouml"
block|,
literal|246
block|}
block|,
comment|/* small o, dieresis or umlaut mark  */
block|{
literal|"para"
block|,
literal|182
block|}
block|,
comment|/* pilcrow (paragraph sign)  */
block|{
literal|"plusmn"
block|,
literal|177
block|}
block|,
comment|/* plus-or-minus sign  */
block|{
literal|"pound"
block|,
literal|163
block|}
block|,
comment|/* pound sterling sign  */
block|{
literal|"quot"
block|,
literal|34
block|}
block|,
comment|/* double quote  */
block|{
literal|"raquo"
block|,
literal|187
block|}
block|,
comment|/* angle quotation mark, right  */
block|{
literal|"reg"
block|,
literal|174
block|}
block|,
comment|/* registered sign  */
block|{
literal|"sect"
block|,
literal|167
block|}
block|,
comment|/* section sign  */
block|{
literal|"shy"
block|,
literal|173
block|}
block|,
comment|/* soft hyphen  */
block|{
literal|"sup1"
block|,
literal|185
block|}
block|,
comment|/* superscript one  */
block|{
literal|"sup2"
block|,
literal|178
block|}
block|,
comment|/* superscript two  */
block|{
literal|"sup3"
block|,
literal|179
block|}
block|,
comment|/* superscript three  */
block|{
literal|"szlig"
block|,
literal|223
block|}
block|,
comment|/* small sharp s, German (sz ligature)  */
block|{
literal|"thorn"
block|,
literal|254
block|}
block|,
comment|/* small thorn, Icelandic  */
block|{
literal|"times"
block|,
literal|215
block|}
block|,
comment|/* multiply sign  */
block|{
literal|"uacute"
block|,
literal|250
block|}
block|,
comment|/* small u, acute accent  */
block|{
literal|"ucirc"
block|,
literal|251
block|}
block|,
comment|/* small u, circumflex accent  */
block|{
literal|"ugrave"
block|,
literal|249
block|}
block|,
comment|/* small u, grave accent  */
block|{
literal|"uml"
block|,
literal|168
block|}
block|,
comment|/* umlaut (dieresis)  */
block|{
literal|"uuml"
block|,
literal|252
block|}
block|,
comment|/* small u, dieresis or umlaut mark  */
block|{
literal|"yacute"
block|,
literal|253
block|}
block|,
comment|/* small y, acute accent  */
block|{
literal|"yen"
block|,
literal|165
block|}
block|,
comment|/* yen sign  */
block|{
literal|"yuml"
block|,
literal|255
block|}
block|,
comment|/* small y, dieresis or umlaut mark  */
block|}
struct|;
end_struct

begin_comment
comment|/*  * unvis - decode characters previously encoded by vis  */
end_comment

begin_function
name|int
name|unvis
parameter_list|(
name|char
modifier|*
name|cp
parameter_list|,
name|int
name|c
parameter_list|,
name|int
modifier|*
name|astate
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|unsigned
name|char
name|uc
init|=
operator|(
name|unsigned
name|char
operator|)
name|c
decl_stmt|;
name|unsigned
name|char
name|st
decl_stmt|,
name|ia
decl_stmt|,
name|is
decl_stmt|,
name|lc
decl_stmt|;
comment|/*  * Bottom 8 bits of astate hold the state machine state.  * Top 8 bits hold the current character in the http 1866 nv string decoding  */
define|#
directive|define
name|GS
parameter_list|(
name|a
parameter_list|)
value|((a)& 0xff)
define|#
directive|define
name|SS
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|(((uint32_t)(a)<< 24) | (b))
define|#
directive|define
name|GI
parameter_list|(
name|a
parameter_list|)
value|((uint32_t)(a)>> 24)
name|_DIAGASSERT
argument_list|(
name|cp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|_DIAGASSERT
argument_list|(
name|astate
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|st
operator|=
name|GS
argument_list|(
operator|*
name|astate
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|UNVIS_END
condition|)
block|{
switch|switch
condition|(
name|st
condition|)
block|{
case|case
name|S_OCTAL2
case|:
case|case
name|S_OCTAL3
case|:
case|case
name|S_HEX2
case|:
operator|*
name|astate
operator|=
name|SS
argument_list|(
literal|0
argument_list|,
name|S_GROUND
argument_list|)
expr_stmt|;
return|return
name|UNVIS_VALID
return|;
case|case
name|S_GROUND
case|:
return|return
name|UNVIS_NOCHAR
return|;
default|default:
return|return
name|UNVIS_SYNBAD
return|;
block|}
block|}
switch|switch
condition|(
name|st
condition|)
block|{
case|case
name|S_GROUND
case|:
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|flag
operator|&
name|VIS_NOESCAPE
operator|)
operator|==
literal|0
operator|&&
name|c
operator|==
literal|'\\'
condition|)
block|{
operator|*
name|astate
operator|=
name|SS
argument_list|(
literal|0
argument_list|,
name|S_START
argument_list|)
expr_stmt|;
return|return
name|UNVIS_NOCHAR
return|;
block|}
if|if
condition|(
operator|(
name|flag
operator|&
name|VIS_HTTP1808
operator|)
operator|&&
name|c
operator|==
literal|'%'
condition|)
block|{
operator|*
name|astate
operator|=
name|SS
argument_list|(
literal|0
argument_list|,
name|S_HEX1
argument_list|)
expr_stmt|;
return|return
name|UNVIS_NOCHAR
return|;
block|}
if|if
condition|(
operator|(
name|flag
operator|&
name|VIS_HTTP1866
operator|)
operator|&&
name|c
operator|==
literal|'&'
condition|)
block|{
operator|*
name|astate
operator|=
name|SS
argument_list|(
literal|0
argument_list|,
name|S_AMP
argument_list|)
expr_stmt|;
return|return
name|UNVIS_NOCHAR
return|;
block|}
if|if
condition|(
operator|(
name|flag
operator|&
name|VIS_MIMESTYLE
operator|)
operator|&&
name|c
operator|==
literal|'='
condition|)
block|{
operator|*
name|astate
operator|=
name|SS
argument_list|(
literal|0
argument_list|,
name|S_MIME1
argument_list|)
expr_stmt|;
return|return
name|UNVIS_NOCHAR
return|;
block|}
operator|*
name|cp
operator|=
name|c
expr_stmt|;
return|return
name|UNVIS_VALID
return|;
case|case
name|S_START
case|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
operator|*
name|cp
operator|=
name|c
expr_stmt|;
operator|*
name|astate
operator|=
name|SS
argument_list|(
literal|0
argument_list|,
name|S_GROUND
argument_list|)
expr_stmt|;
return|return
name|UNVIS_VALID
return|;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
operator|*
name|cp
operator|=
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
operator|*
name|astate
operator|=
name|SS
argument_list|(
literal|0
argument_list|,
name|S_OCTAL2
argument_list|)
expr_stmt|;
return|return
name|UNVIS_NOCHAR
return|;
case|case
literal|'M'
case|:
operator|*
name|cp
operator|=
operator|(
name|char
operator|)
literal|0200
expr_stmt|;
operator|*
name|astate
operator|=
name|SS
argument_list|(
literal|0
argument_list|,
name|S_META
argument_list|)
expr_stmt|;
return|return
name|UNVIS_NOCHAR
return|;
case|case
literal|'^'
case|:
operator|*
name|astate
operator|=
name|SS
argument_list|(
literal|0
argument_list|,
name|S_CTRL
argument_list|)
expr_stmt|;
return|return
name|UNVIS_NOCHAR
return|;
case|case
literal|'n'
case|:
operator|*
name|cp
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|astate
operator|=
name|SS
argument_list|(
literal|0
argument_list|,
name|S_GROUND
argument_list|)
expr_stmt|;
return|return
name|UNVIS_VALID
return|;
case|case
literal|'r'
case|:
operator|*
name|cp
operator|=
literal|'\r'
expr_stmt|;
operator|*
name|astate
operator|=
name|SS
argument_list|(
literal|0
argument_list|,
name|S_GROUND
argument_list|)
expr_stmt|;
return|return
name|UNVIS_VALID
return|;
case|case
literal|'b'
case|:
operator|*
name|cp
operator|=
literal|'\b'
expr_stmt|;
operator|*
name|astate
operator|=
name|SS
argument_list|(
literal|0
argument_list|,
name|S_GROUND
argument_list|)
expr_stmt|;
return|return
name|UNVIS_VALID
return|;
case|case
literal|'a'
case|:
operator|*
name|cp
operator|=
literal|'\007'
expr_stmt|;
operator|*
name|astate
operator|=
name|SS
argument_list|(
literal|0
argument_list|,
name|S_GROUND
argument_list|)
expr_stmt|;
return|return
name|UNVIS_VALID
return|;
case|case
literal|'v'
case|:
operator|*
name|cp
operator|=
literal|'\v'
expr_stmt|;
operator|*
name|astate
operator|=
name|SS
argument_list|(
literal|0
argument_list|,
name|S_GROUND
argument_list|)
expr_stmt|;
return|return
name|UNVIS_VALID
return|;
case|case
literal|'t'
case|:
operator|*
name|cp
operator|=
literal|'\t'
expr_stmt|;
operator|*
name|astate
operator|=
name|SS
argument_list|(
literal|0
argument_list|,
name|S_GROUND
argument_list|)
expr_stmt|;
return|return
name|UNVIS_VALID
return|;
case|case
literal|'f'
case|:
operator|*
name|cp
operator|=
literal|'\f'
expr_stmt|;
operator|*
name|astate
operator|=
name|SS
argument_list|(
literal|0
argument_list|,
name|S_GROUND
argument_list|)
expr_stmt|;
return|return
name|UNVIS_VALID
return|;
case|case
literal|'s'
case|:
operator|*
name|cp
operator|=
literal|' '
expr_stmt|;
operator|*
name|astate
operator|=
name|SS
argument_list|(
literal|0
argument_list|,
name|S_GROUND
argument_list|)
expr_stmt|;
return|return
name|UNVIS_VALID
return|;
case|case
literal|'E'
case|:
operator|*
name|cp
operator|=
literal|'\033'
expr_stmt|;
operator|*
name|astate
operator|=
name|SS
argument_list|(
literal|0
argument_list|,
name|S_GROUND
argument_list|)
expr_stmt|;
return|return
name|UNVIS_VALID
return|;
case|case
literal|'\n'
case|:
comment|/* 			 * hidden newline 			 */
operator|*
name|astate
operator|=
name|SS
argument_list|(
literal|0
argument_list|,
name|S_GROUND
argument_list|)
expr_stmt|;
return|return
name|UNVIS_NOCHAR
return|;
case|case
literal|'$'
case|:
comment|/* 			 * hidden marker 			 */
operator|*
name|astate
operator|=
name|SS
argument_list|(
literal|0
argument_list|,
name|S_GROUND
argument_list|)
expr_stmt|;
return|return
name|UNVIS_NOCHAR
return|;
block|}
goto|goto
name|bad
goto|;
case|case
name|S_META
case|:
if|if
condition|(
name|c
operator|==
literal|'-'
condition|)
operator|*
name|astate
operator|=
name|SS
argument_list|(
literal|0
argument_list|,
name|S_META1
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'^'
condition|)
operator|*
name|astate
operator|=
name|SS
argument_list|(
literal|0
argument_list|,
name|S_CTRL
argument_list|)
expr_stmt|;
else|else
goto|goto
name|bad
goto|;
return|return
name|UNVIS_NOCHAR
return|;
case|case
name|S_META1
case|:
operator|*
name|astate
operator|=
name|SS
argument_list|(
literal|0
argument_list|,
name|S_GROUND
argument_list|)
expr_stmt|;
operator|*
name|cp
operator||=
name|c
expr_stmt|;
return|return
name|UNVIS_VALID
return|;
case|case
name|S_CTRL
case|:
if|if
condition|(
name|c
operator|==
literal|'?'
condition|)
operator|*
name|cp
operator||=
literal|0177
expr_stmt|;
else|else
operator|*
name|cp
operator||=
name|c
operator|&
literal|037
expr_stmt|;
operator|*
name|astate
operator|=
name|SS
argument_list|(
literal|0
argument_list|,
name|S_GROUND
argument_list|)
expr_stmt|;
return|return
name|UNVIS_VALID
return|;
case|case
name|S_OCTAL2
case|:
comment|/* second possible octal digit */
if|if
condition|(
name|isoctal
argument_list|(
name|uc
argument_list|)
condition|)
block|{
comment|/* 			 * yes - and maybe a third 			 */
operator|*
name|cp
operator|=
operator|(
operator|*
name|cp
operator|<<
literal|3
operator|)
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
operator|*
name|astate
operator|=
name|SS
argument_list|(
literal|0
argument_list|,
name|S_OCTAL3
argument_list|)
expr_stmt|;
return|return
name|UNVIS_NOCHAR
return|;
block|}
comment|/* 		 * no - done with current sequence, push back passed char 		 */
operator|*
name|astate
operator|=
name|SS
argument_list|(
literal|0
argument_list|,
name|S_GROUND
argument_list|)
expr_stmt|;
return|return
name|UNVIS_VALIDPUSH
return|;
case|case
name|S_OCTAL3
case|:
comment|/* third possible octal digit */
operator|*
name|astate
operator|=
name|SS
argument_list|(
literal|0
argument_list|,
name|S_GROUND
argument_list|)
expr_stmt|;
if|if
condition|(
name|isoctal
argument_list|(
name|uc
argument_list|)
condition|)
block|{
operator|*
name|cp
operator|=
operator|(
operator|*
name|cp
operator|<<
literal|3
operator|)
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
return|return
name|UNVIS_VALID
return|;
block|}
comment|/* 		 * we were done, push back passed char 		 */
return|return
name|UNVIS_VALIDPUSH
return|;
case|case
name|S_HEX1
case|:
if|if
condition|(
name|isxdigit
argument_list|(
name|uc
argument_list|)
condition|)
block|{
operator|*
name|cp
operator|=
name|xtod
argument_list|(
name|uc
argument_list|)
expr_stmt|;
operator|*
name|astate
operator|=
name|SS
argument_list|(
literal|0
argument_list|,
name|S_HEX2
argument_list|)
expr_stmt|;
return|return
name|UNVIS_NOCHAR
return|;
block|}
comment|/* 		 * no - done with current sequence, push back passed char 		 */
operator|*
name|astate
operator|=
name|SS
argument_list|(
literal|0
argument_list|,
name|S_GROUND
argument_list|)
expr_stmt|;
return|return
name|UNVIS_VALIDPUSH
return|;
case|case
name|S_HEX2
case|:
operator|*
name|astate
operator|=
name|S_GROUND
expr_stmt|;
if|if
condition|(
name|isxdigit
argument_list|(
name|uc
argument_list|)
condition|)
block|{
operator|*
name|cp
operator|=
name|xtod
argument_list|(
name|uc
argument_list|)
operator||
operator|(
operator|*
name|cp
operator|<<
literal|4
operator|)
expr_stmt|;
return|return
name|UNVIS_VALID
return|;
block|}
return|return
name|UNVIS_VALIDPUSH
return|;
case|case
name|S_MIME1
case|:
if|if
condition|(
name|uc
operator|==
literal|'\n'
operator|||
name|uc
operator|==
literal|'\r'
condition|)
block|{
operator|*
name|astate
operator|=
name|SS
argument_list|(
literal|0
argument_list|,
name|S_EATCRNL
argument_list|)
expr_stmt|;
return|return
name|UNVIS_NOCHAR
return|;
block|}
if|if
condition|(
name|isxdigit
argument_list|(
name|uc
argument_list|)
operator|&&
operator|(
name|isdigit
argument_list|(
name|uc
argument_list|)
operator|||
name|isupper
argument_list|(
name|uc
argument_list|)
operator|)
condition|)
block|{
operator|*
name|cp
operator|=
name|XTOD
argument_list|(
name|uc
argument_list|)
expr_stmt|;
operator|*
name|astate
operator|=
name|SS
argument_list|(
literal|0
argument_list|,
name|S_MIME2
argument_list|)
expr_stmt|;
return|return
name|UNVIS_NOCHAR
return|;
block|}
goto|goto
name|bad
goto|;
case|case
name|S_MIME2
case|:
if|if
condition|(
name|isxdigit
argument_list|(
name|uc
argument_list|)
operator|&&
operator|(
name|isdigit
argument_list|(
name|uc
argument_list|)
operator|||
name|isupper
argument_list|(
name|uc
argument_list|)
operator|)
condition|)
block|{
operator|*
name|astate
operator|=
name|SS
argument_list|(
literal|0
argument_list|,
name|S_GROUND
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
name|XTOD
argument_list|(
name|uc
argument_list|)
operator||
operator|(
operator|*
name|cp
operator|<<
literal|4
operator|)
expr_stmt|;
return|return
name|UNVIS_VALID
return|;
block|}
goto|goto
name|bad
goto|;
case|case
name|S_EATCRNL
case|:
switch|switch
condition|(
name|uc
condition|)
block|{
case|case
literal|'\r'
case|:
case|case
literal|'\n'
case|:
return|return
name|UNVIS_NOCHAR
return|;
case|case
literal|'='
case|:
operator|*
name|astate
operator|=
name|SS
argument_list|(
literal|0
argument_list|,
name|S_MIME1
argument_list|)
expr_stmt|;
return|return
name|UNVIS_NOCHAR
return|;
default|default:
operator|*
name|cp
operator|=
name|uc
expr_stmt|;
operator|*
name|astate
operator|=
name|SS
argument_list|(
literal|0
argument_list|,
name|S_GROUND
argument_list|)
expr_stmt|;
return|return
name|UNVIS_VALID
return|;
block|}
case|case
name|S_AMP
case|:
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|uc
operator|==
literal|'#'
condition|)
block|{
operator|*
name|astate
operator|=
name|SS
argument_list|(
literal|0
argument_list|,
name|S_NUMBER
argument_list|)
expr_stmt|;
return|return
name|UNVIS_NOCHAR
return|;
block|}
operator|*
name|astate
operator|=
name|SS
argument_list|(
literal|0
argument_list|,
name|S_STRING
argument_list|)
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
name|S_STRING
case|:
name|ia
operator|=
operator|*
name|cp
expr_stmt|;
comment|/* index in the array */
name|is
operator|=
name|GI
argument_list|(
operator|*
name|astate
argument_list|)
expr_stmt|;
comment|/* index in the string */
name|lc
operator|=
name|is
operator|==
literal|0
condition|?
literal|0
else|:
name|nv
index|[
name|ia
index|]
operator|.
name|name
index|[
name|is
operator|-
literal|1
index|]
expr_stmt|;
comment|/* last character */
if|if
condition|(
name|uc
operator|==
literal|';'
condition|)
name|uc
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
init|;
name|ia
operator|<
name|__arraycount
argument_list|(
name|nv
argument_list|)
condition|;
name|ia
operator|++
control|)
block|{
if|if
condition|(
name|is
operator|!=
literal|0
operator|&&
name|nv
index|[
name|ia
index|]
operator|.
name|name
index|[
name|is
operator|-
literal|1
index|]
operator|!=
name|lc
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|nv
index|[
name|ia
index|]
operator|.
name|name
index|[
name|is
index|]
operator|==
name|uc
condition|)
break|break;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
name|__arraycount
argument_list|(
name|nv
argument_list|)
condition|)
goto|goto
name|bad
goto|;
if|if
condition|(
name|uc
operator|!=
literal|0
condition|)
block|{
operator|*
name|cp
operator|=
name|ia
expr_stmt|;
operator|*
name|astate
operator|=
name|SS
argument_list|(
name|is
operator|+
literal|1
argument_list|,
name|S_STRING
argument_list|)
expr_stmt|;
return|return
name|UNVIS_NOCHAR
return|;
block|}
operator|*
name|cp
operator|=
name|nv
index|[
name|ia
index|]
operator|.
name|value
expr_stmt|;
operator|*
name|astate
operator|=
name|SS
argument_list|(
literal|0
argument_list|,
name|S_GROUND
argument_list|)
expr_stmt|;
return|return
name|UNVIS_VALID
return|;
case|case
name|S_NUMBER
case|:
if|if
condition|(
name|uc
operator|==
literal|';'
condition|)
return|return
name|UNVIS_VALID
return|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|uc
argument_list|)
condition|)
goto|goto
name|bad
goto|;
operator|*
name|cp
operator|+=
operator|(
operator|*
name|cp
operator|*
literal|10
operator|)
operator|+
name|uc
operator|-
literal|'0'
expr_stmt|;
return|return
name|UNVIS_NOCHAR
return|;
default|default:
name|bad
label|:
comment|/* 		 * decoder in unknown state - (probably uninitialized) 		 */
operator|*
name|astate
operator|=
name|SS
argument_list|(
literal|0
argument_list|,
name|S_GROUND
argument_list|)
expr_stmt|;
return|return
name|UNVIS_SYNBAD
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * strunvis - decode src into dst  *  *	Number of chars decoded into dst is returned, -1 on error.  *	Dst is null terminated.  */
end_comment

begin_function
name|int
name|strunvisx
parameter_list|(
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|start
init|=
name|dst
decl_stmt|;
name|int
name|state
init|=
literal|0
decl_stmt|;
name|_DIAGASSERT
argument_list|(
name|src
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|_DIAGASSERT
argument_list|(
name|dst
operator|!=
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|src
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|again
label|:
switch|switch
condition|(
name|unvis
argument_list|(
name|dst
argument_list|,
name|c
argument_list|,
operator|&
name|state
argument_list|,
name|flag
argument_list|)
condition|)
block|{
case|case
name|UNVIS_VALID
case|:
name|dst
operator|++
expr_stmt|;
break|break;
case|case
name|UNVIS_VALIDPUSH
case|:
name|dst
operator|++
expr_stmt|;
goto|goto
name|again
goto|;
case|case
literal|0
case|:
case|case
name|UNVIS_NOCHAR
case|:
break|break;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|unvis
argument_list|(
name|dst
argument_list|,
name|c
argument_list|,
operator|&
name|state
argument_list|,
name|UNVIS_END
argument_list|)
operator|==
name|UNVIS_VALID
condition|)
name|dst
operator|++
expr_stmt|;
operator|*
name|dst
operator|=
literal|'\0'
expr_stmt|;
return|return
call|(
name|int
call|)
argument_list|(
name|dst
operator|-
name|start
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|strunvis
parameter_list|(
name|char
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
return|return
name|strunvisx
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

