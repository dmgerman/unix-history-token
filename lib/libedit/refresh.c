begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Christos Zoulas of Cornell University.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	$NetBSD: refresh.c,v 1.16 2001/01/10 07:45:42 jdolecek Exp $  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCCSID
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)refresh.c	8.1 (Berkeley) 6/4/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint&& not SCCSID */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * refresh.c: Lower level screen refreshing functions  */
end_comment

begin_include
include|#
directive|include
file|"sys.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"el.h"
end_include

begin_function_decl
name|private
name|void
name|re_addc
parameter_list|(
name|EditLine
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|void
name|re_update_line
parameter_list|(
name|EditLine
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|void
name|re_insert
parameter_list|(
name|EditLine
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|void
name|re_delete
parameter_list|(
name|EditLine
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|void
name|re_fastputc
parameter_list|(
name|EditLine
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|void
name|re__strncopy
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|private
name|void
name|re__copy_and_pad
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_REFRESH
end_ifdef

begin_function_decl
name|private
name|void
name|re_printstr
parameter_list|(
name|EditLine
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|__F
value|el->el_errfile
end_define

begin_define
define|#
directive|define
name|ELRE_ASSERT
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|do 				\ 				    if (a) {			\ 					(void) fprintf b;	\ 					c;			\ 				    }				\ 				while (0)
end_define

begin_define
define|#
directive|define
name|ELRE_DEBUG
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|ELRE_ASSERT(a,b,;)
end_define

begin_comment
comment|/* re_printstr():  *	Print a string on the debugging pty  */
end_comment

begin_function
name|private
name|void
name|re_printstr
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|,
name|char
modifier|*
name|str
parameter_list|,
name|char
modifier|*
name|f
parameter_list|,
name|char
modifier|*
name|t
parameter_list|)
block|{
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"%s:\""
operator|,
name|str
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|f
operator|<
name|t
condition|)
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"%c"
operator|,
operator|*
name|f
operator|++
operator|&
literal|0177
operator|)
argument_list|)
expr_stmt|;
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"\"\r\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ELRE_ASSERT
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
end_define

begin_define
define|#
directive|define
name|ELRE_DEBUG
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* re_addc():  *	Draw c, expanding tabs, control chars etc.  */
end_comment

begin_function
name|private
name|void
name|re_addc
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|c
operator|=
operator|(
name|unsigned
name|char
operator|)
name|c
expr_stmt|;
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|re_putc
argument_list|(
name|el
argument_list|,
name|c
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
comment|/* expand the newline */
name|int
name|oldv
init|=
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|v
decl_stmt|;
name|re_putc
argument_list|(
name|el
argument_list|,
literal|'\0'
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* assure end of line */
if|if
condition|(
name|oldv
operator|==
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|v
condition|)
block|{
comment|/* XXX */
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|h
operator|=
literal|0
expr_stmt|;
comment|/* reset cursor pos */
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|v
operator|++
expr_stmt|;
block|}
return|return;
block|}
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
comment|/* expand the tab */
for|for
control|(
init|;
condition|;
control|)
block|{
name|re_putc
argument_list|(
name|el
argument_list|,
literal|' '
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|h
operator|&
literal|07
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* go until tab stop */
block|}
block|}
elseif|else
if|if
condition|(
name|iscntrl
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|re_putc
argument_list|(
name|el
argument_list|,
literal|'^'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0177
condition|)
name|re_putc
argument_list|(
name|el
argument_list|,
literal|'?'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
comment|/* uncontrolify it; works only for iso8859-1 like sets */
name|re_putc
argument_list|(
name|el
argument_list|,
operator|(
name|toascii
argument_list|(
name|c
argument_list|)
operator||
literal|0100
operator|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|re_putc
argument_list|(
name|el
argument_list|,
literal|'\\'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|re_putc
argument_list|(
name|el
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
operator|(
name|unsigned
name|int
operator|)
name|c
operator|>>
literal|6
operator|)
operator|&
literal|07
operator|)
operator|+
literal|'0'
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|re_putc
argument_list|(
name|el
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
operator|(
name|unsigned
name|int
operator|)
name|c
operator|>>
literal|3
operator|)
operator|&
literal|07
operator|)
operator|+
literal|'0'
argument_list|)
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|re_putc
argument_list|(
name|el
argument_list|,
operator|(
name|c
operator|&
literal|07
operator|)
operator|+
literal|'0'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* re_putc():  *	Draw the character given  */
end_comment

begin_function
name|protected
name|void
name|re_putc
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|,
name|int
name|c
parameter_list|,
name|int
name|shift
parameter_list|)
block|{
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"printing %3.3o '%c'\r\n"
operator|,
name|c
operator|,
name|c
operator|)
argument_list|)
expr_stmt|;
name|el
operator|->
name|el_vdisplay
index|[
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|v
index|]
index|[
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|h
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|!
name|shift
condition|)
return|return;
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|h
operator|++
expr_stmt|;
comment|/* advance to next place */
if|if
condition|(
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|h
operator|>=
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|h
condition|)
block|{
name|el
operator|->
name|el_vdisplay
index|[
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|v
index|]
index|[
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|h
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* assure end of line */
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|h
operator|=
literal|0
expr_stmt|;
comment|/* reset it. */
comment|/* 		 * If we would overflow (input is longer than terminal size), 		 * emulate scroll by dropping first line and shuffling the rest. 		 * We do this via pointer shuffling - it's safe in this case 		 * and we avoid memcpy(). 		 */
if|if
condition|(
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|v
operator|+
literal|1
operator|>=
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|v
condition|)
block|{
name|int
name|i
decl_stmt|,
name|lins
init|=
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|v
decl_stmt|;
name|char
modifier|*
name|firstline
init|=
name|el
operator|->
name|el_vdisplay
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|lins
condition|;
name|i
operator|++
control|)
name|el
operator|->
name|el_vdisplay
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|el
operator|->
name|el_vdisplay
index|[
name|i
index|]
expr_stmt|;
name|firstline
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* empty the string */
name|el
operator|->
name|el_vdisplay
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|firstline
expr_stmt|;
block|}
else|else
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|v
operator|++
expr_stmt|;
name|ELRE_ASSERT
argument_list|(
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|v
operator|>=
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|v
argument_list|,
operator|(
name|__F
operator|,
literal|"\r\nre_putc: overflow! r_cursor.v == %d> %d\r\n"
operator|,
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|v
operator|,
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|v
operator|)
argument_list|,
name|abort
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* re_refresh():  *	draws the new virtual screen image from the current input  *  	line, then goes line-by-line changing the real image to the new  *	virtual image. The routine to re-draw a line can be replaced  *	easily in hopes of a smarter one being placed there.  */
end_comment

begin_function
name|protected
name|void
name|re_refresh
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|rhdiff
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|st
decl_stmt|;
name|coord_t
name|cur
decl_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|size_t
name|termsz
decl_stmt|;
endif|#
directive|endif
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"el->el_line.buffer = :%s:\r\n"
operator|,
name|el
operator|->
name|el_line
operator|.
name|buffer
operator|)
argument_list|)
expr_stmt|;
comment|/* reset the Drawing cursor */
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|h
operator|=
literal|0
expr_stmt|;
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|v
operator|=
literal|0
expr_stmt|;
comment|/* temporarily draw rprompt to calculate its size */
name|prompt_print
argument_list|(
name|el
argument_list|,
name|EL_RPROMPT
argument_list|)
expr_stmt|;
comment|/* reset the Drawing cursor */
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|h
operator|=
literal|0
expr_stmt|;
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|v
operator|=
literal|0
expr_stmt|;
name|cur
operator|.
name|h
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* set flag in case I'm not set */
name|cur
operator|.
name|v
operator|=
literal|0
expr_stmt|;
name|prompt_print
argument_list|(
name|el
argument_list|,
name|EL_PROMPT
argument_list|)
expr_stmt|;
comment|/* draw the current input buffer */
if|#
directive|if
name|notyet
name|termsz
operator|=
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|h
operator|*
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|v
expr_stmt|;
if|if
condition|(
name|el
operator|->
name|el_line
operator|.
name|lastchar
operator|-
name|el
operator|->
name|el_line
operator|.
name|buffer
operator|>
name|termsz
condition|)
block|{
comment|/* 		 * If line is longer than terminal, process only part 		 * of line which would influence display. 		 */
name|size_t
name|rem
init|=
operator|(
name|el
operator|->
name|el_line
operator|.
name|lastchar
operator|-
name|el
operator|->
name|el_line
operator|.
name|buffer
operator|)
operator|%
name|termsz
decl_stmt|;
name|st
operator|=
name|el
operator|->
name|el_line
operator|.
name|lastchar
operator|-
name|rem
operator|-
operator|(
name|termsz
operator|-
operator|(
operator|(
operator|(
name|rem
operator|/
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|v
operator|)
operator|-
literal|1
operator|)
operator|*
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|v
operator|)
operator|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|st
operator|=
name|el
operator|->
name|el_line
operator|.
name|buffer
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|st
init|;
name|cp
operator|<
name|el
operator|->
name|el_line
operator|.
name|lastchar
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
name|cp
operator|==
name|el
operator|->
name|el_line
operator|.
name|cursor
condition|)
block|{
comment|/* save for later */
name|cur
operator|.
name|h
operator|=
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|h
expr_stmt|;
name|cur
operator|.
name|v
operator|=
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|v
expr_stmt|;
block|}
name|re_addc
argument_list|(
name|el
argument_list|,
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cur
operator|.
name|h
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* if I haven't been set yet, I'm at the end */
name|cur
operator|.
name|h
operator|=
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|h
expr_stmt|;
name|cur
operator|.
name|v
operator|=
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|v
expr_stmt|;
block|}
name|rhdiff
operator|=
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|h
operator|-
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|h
operator|-
name|el
operator|->
name|el_rprompt
operator|.
name|p_pos
operator|.
name|h
expr_stmt|;
if|if
condition|(
name|el
operator|->
name|el_rprompt
operator|.
name|p_pos
operator|.
name|h
operator|&&
operator|!
name|el
operator|->
name|el_rprompt
operator|.
name|p_pos
operator|.
name|v
operator|&&
operator|!
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|v
operator|&&
name|rhdiff
operator|>
literal|1
condition|)
block|{
comment|/* 		 * have a right-hand side prompt that will fit 		 * on the end of the first line with at least 		 * one character gap to the input buffer. 		 */
while|while
condition|(
operator|--
name|rhdiff
operator|>
literal|0
condition|)
comment|/* pad out with spaces */
name|re_putc
argument_list|(
name|el
argument_list|,
literal|' '
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|prompt_print
argument_list|(
name|el
argument_list|,
name|EL_RPROMPT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|el
operator|->
name|el_rprompt
operator|.
name|p_pos
operator|.
name|h
operator|=
literal|0
expr_stmt|;
comment|/* flag "not using rprompt" */
name|el
operator|->
name|el_rprompt
operator|.
name|p_pos
operator|.
name|v
operator|=
literal|0
expr_stmt|;
block|}
name|re_putc
argument_list|(
name|el
argument_list|,
literal|'\0'
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* make line ended with NUL, no cursor shift */
name|el
operator|->
name|el_refresh
operator|.
name|r_newcv
operator|=
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|v
expr_stmt|;
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"term.h=%d vcur.h=%d vcur.v=%d vdisplay[0]=\r\n:%80.80s:\r\n"
operator|,
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|h
operator|,
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|h
operator|,
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|v
operator|,
name|el
operator|->
name|el_vdisplay
index|[
literal|0
index|]
operator|)
argument_list|)
expr_stmt|;
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"updating %d lines.\r\n"
operator|,
name|el
operator|->
name|el_refresh
operator|.
name|r_newcv
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|el
operator|->
name|el_refresh
operator|.
name|r_newcv
condition|;
name|i
operator|++
control|)
block|{
comment|/* NOTE THAT re_update_line MAY CHANGE el_display[i] */
name|re_update_line
argument_list|(
name|el
argument_list|,
name|el
operator|->
name|el_display
index|[
name|i
index|]
argument_list|,
name|el
operator|->
name|el_vdisplay
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 		 * Copy the new line to be the current one, and pad out with 		 * spaces to the full width of the terminal so that if we try 		 * moving the cursor by writing the character that is at the 		 * end of the screen line, it won't be a NUL or some old 		 * leftover stuff. 		 */
name|re__copy_and_pad
argument_list|(
name|el
operator|->
name|el_display
index|[
name|i
index|]
argument_list|,
name|el
operator|->
name|el_vdisplay
index|[
name|i
index|]
argument_list|,
operator|(
name|size_t
operator|)
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|h
argument_list|)
expr_stmt|;
block|}
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"\r\nel->el_refresh.r_cursor.v=%d,el->el_refresh.r_oldcv=%d i=%d\r\n"
operator|,
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|v
operator|,
name|el
operator|->
name|el_refresh
operator|.
name|r_oldcv
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|el
operator|->
name|el_refresh
operator|.
name|r_oldcv
operator|>
name|el
operator|->
name|el_refresh
operator|.
name|r_newcv
condition|)
for|for
control|(
init|;
name|i
operator|<=
name|el
operator|->
name|el_refresh
operator|.
name|r_oldcv
condition|;
name|i
operator|++
control|)
block|{
name|term_move_to_line
argument_list|(
name|el
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|term_move_to_char
argument_list|(
name|el
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|term_clear_EOL
argument_list|(
name|el
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|el
operator|->
name|el_display
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_REFRESH
name|term_overwrite
argument_list|(
name|el
argument_list|,
literal|"C\b"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_REFRESH */
name|el
operator|->
name|el_display
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|el
operator|->
name|el_refresh
operator|.
name|r_oldcv
operator|=
name|el
operator|->
name|el_refresh
operator|.
name|r_newcv
expr_stmt|;
comment|/* set for next time */
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"\r\ncursor.h = %d, cursor.v = %d, cur.h = %d, cur.v = %d\r\n"
operator|,
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|h
operator|,
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|v
operator|,
name|cur
operator|.
name|h
operator|,
name|cur
operator|.
name|v
operator|)
argument_list|)
expr_stmt|;
name|term_move_to_line
argument_list|(
name|el
argument_list|,
name|cur
operator|.
name|v
argument_list|)
expr_stmt|;
comment|/* go to where the cursor is */
name|term_move_to_char
argument_list|(
name|el
argument_list|,
name|cur
operator|.
name|h
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* re_goto_bottom():  *	 used to go to last used screen line  */
end_comment

begin_function
name|protected
name|void
name|re_goto_bottom
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|)
block|{
name|term_move_to_line
argument_list|(
name|el
argument_list|,
name|el
operator|->
name|el_refresh
operator|.
name|r_oldcv
argument_list|)
expr_stmt|;
name|term__putc
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|term__putc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|re_clear_display
argument_list|(
name|el
argument_list|)
expr_stmt|;
name|term__flush
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* re_insert():  *	insert num characters of s into d (in front of the character)  *	at dat, maximum length of d is dlen  */
end_comment

begin_function
name|private
name|void
comment|/*ARGSUSED*/
name|re_insert
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|,
name|char
modifier|*
name|d
parameter_list|,
name|int
name|dat
parameter_list|,
name|int
name|dlen
parameter_list|,
name|char
modifier|*
name|s
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|num
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
name|num
operator|>
name|dlen
operator|-
name|dat
condition|)
name|num
operator|=
name|dlen
operator|-
name|dat
expr_stmt|;
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"re_insert() starting: %d at %d max %d, d == \"%s\"\n"
operator|,
name|num
operator|,
name|dat
operator|,
name|dlen
operator|,
name|d
operator|)
argument_list|)
expr_stmt|;
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"s == \"%s\"n"
operator|,
name|s
operator|)
argument_list|)
expr_stmt|;
comment|/* open up the space for num chars */
if|if
condition|(
name|num
operator|>
literal|0
condition|)
block|{
name|b
operator|=
name|d
operator|+
name|dlen
operator|-
literal|1
expr_stmt|;
name|a
operator|=
name|b
operator|-
name|num
expr_stmt|;
while|while
condition|(
name|a
operator|>=
operator|&
name|d
index|[
name|dat
index|]
condition|)
operator|*
name|b
operator|--
operator|=
operator|*
name|a
operator|--
expr_stmt|;
name|d
index|[
name|dlen
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* just in case */
block|}
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"re_insert() after insert: %d at %d max %d, d == \"%s\"\n"
operator|,
name|num
operator|,
name|dat
operator|,
name|dlen
operator|,
name|d
operator|)
argument_list|)
expr_stmt|;
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"s == \"%s\"n"
operator|,
name|s
operator|)
argument_list|)
expr_stmt|;
comment|/* copy the characters */
for|for
control|(
name|a
operator|=
name|d
operator|+
name|dat
init|;
operator|(
name|a
operator|<
name|d
operator|+
name|dlen
operator|)
operator|&&
operator|(
name|num
operator|>
literal|0
operator|)
condition|;
name|num
operator|--
control|)
operator|*
name|a
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"re_insert() after copy: %d at %d max %d, %s == \"%s\"\n"
operator|,
name|num
operator|,
name|dat
operator|,
name|dlen
operator|,
name|d
operator|,
name|s
operator|)
argument_list|)
expr_stmt|;
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"s == \"%s\"n"
operator|,
name|s
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* re_delete():  *	delete num characters d at dat, maximum length of d is dlen  */
end_comment

begin_function
name|private
name|void
comment|/*ARGSUSED*/
name|re_delete
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|,
name|char
modifier|*
name|d
parameter_list|,
name|int
name|dat
parameter_list|,
name|int
name|dlen
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|num
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
name|dat
operator|+
name|num
operator|>=
name|dlen
condition|)
block|{
name|d
index|[
name|dat
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"re_delete() starting: %d at %d max %d, d == \"%s\"\n"
operator|,
name|num
operator|,
name|dat
operator|,
name|dlen
operator|,
name|d
operator|)
argument_list|)
expr_stmt|;
comment|/* open up the space for num chars */
if|if
condition|(
name|num
operator|>
literal|0
condition|)
block|{
name|b
operator|=
name|d
operator|+
name|dat
expr_stmt|;
name|a
operator|=
name|b
operator|+
name|num
expr_stmt|;
while|while
condition|(
name|a
operator|<
operator|&
name|d
index|[
name|dlen
index|]
condition|)
operator|*
name|b
operator|++
operator|=
operator|*
name|a
operator|++
expr_stmt|;
name|d
index|[
name|dlen
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* just in case */
block|}
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"re_delete() after delete: %d at %d max %d, d == \"%s\"\n"
operator|,
name|num
operator|,
name|dat
operator|,
name|dlen
operator|,
name|d
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* re__strncopy():  *	Like strncpy without padding.  */
end_comment

begin_function
name|private
name|void
name|re__strncopy
parameter_list|(
name|char
modifier|*
name|a
parameter_list|,
name|char
modifier|*
name|b
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
while|while
condition|(
name|n
operator|--
operator|&&
operator|*
name|b
condition|)
operator|*
name|a
operator|++
operator|=
operator|*
name|b
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*****************************************************************     re_update_line() is based on finding the middle difference of each line     on the screen; vis:  			     /old first difference 	/beginning of line   |              /old last same       /old EOL 	v		     v              v                    v old:	eddie> Oh, my little gruntle-buggy is to me, as lurgid as new:	eddie> Oh, my little buggy says to me, as lurgid as 	^		     ^        ^			   ^ 	\beginning of line   |        \new last same	   \new end of line 			     \new first difference      all are character pointers for the sake of speed.  Special cases for     no differences, as well as for end of line additions must be handled. **************************************************************** */
end_comment

begin_comment
comment|/* Minimum at which doing an insert it "worth it".  This should be about  * half the "cost" of going into insert mode, inserting a character, and  * going back out.  This should really be calculated from the termcap  * data...  For the moment, a good number for ANSI terminals.  */
end_comment

begin_define
define|#
directive|define
name|MIN_END_KEEP
value|4
end_define

begin_function
name|private
name|void
name|re_update_line
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|,
name|char
modifier|*
name|old
parameter_list|,
name|char
modifier|*
name|new
parameter_list|,
name|int
name|i
parameter_list|)
block|{
name|char
modifier|*
name|o
decl_stmt|,
modifier|*
name|n
decl_stmt|,
modifier|*
name|p
decl_stmt|,
name|c
decl_stmt|;
name|char
modifier|*
name|ofd
decl_stmt|,
modifier|*
name|ols
decl_stmt|,
modifier|*
name|oe
decl_stmt|,
modifier|*
name|nfd
decl_stmt|,
modifier|*
name|nls
decl_stmt|,
modifier|*
name|ne
decl_stmt|;
name|char
modifier|*
name|osb
decl_stmt|,
modifier|*
name|ose
decl_stmt|,
modifier|*
name|nsb
decl_stmt|,
modifier|*
name|nse
decl_stmt|;
name|int
name|fx
decl_stmt|,
name|sx
decl_stmt|;
comment|/*          * find first diff          */
for|for
control|(
name|o
operator|=
name|old
operator|,
name|n
operator|=
name|new
init|;
operator|*
name|o
operator|&&
operator|(
operator|*
name|o
operator|==
operator|*
name|n
operator|)
condition|;
name|o
operator|++
operator|,
name|n
operator|++
control|)
continue|continue;
name|ofd
operator|=
name|o
expr_stmt|;
name|nfd
operator|=
name|n
expr_stmt|;
comment|/*          * Find the end of both old and new          */
while|while
condition|(
operator|*
name|o
condition|)
name|o
operator|++
expr_stmt|;
comment|/*          * Remove any trailing blanks off of the end, being careful not to          * back up past the beginning.          */
while|while
condition|(
name|ofd
operator|<
name|o
condition|)
block|{
if|if
condition|(
name|o
index|[
operator|-
literal|1
index|]
operator|!=
literal|' '
condition|)
break|break;
name|o
operator|--
expr_stmt|;
block|}
name|oe
operator|=
name|o
expr_stmt|;
operator|*
name|oe
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|n
condition|)
name|n
operator|++
expr_stmt|;
comment|/* remove blanks from end of new */
while|while
condition|(
name|nfd
operator|<
name|n
condition|)
block|{
if|if
condition|(
name|n
index|[
operator|-
literal|1
index|]
operator|!=
literal|' '
condition|)
break|break;
name|n
operator|--
expr_stmt|;
block|}
name|ne
operator|=
name|n
expr_stmt|;
operator|*
name|ne
operator|=
literal|'\0'
expr_stmt|;
comment|/*          * if no diff, continue to next line of redraw          */
if|if
condition|(
operator|*
name|ofd
operator|==
literal|'\0'
operator|&&
operator|*
name|nfd
operator|==
literal|'\0'
condition|)
block|{
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"no difference.\r\n"
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/*          * find last same pointer          */
while|while
condition|(
operator|(
name|o
operator|>
name|ofd
operator|)
operator|&&
operator|(
name|n
operator|>
name|nfd
operator|)
operator|&&
operator|(
operator|*
operator|--
name|o
operator|==
operator|*
operator|--
name|n
operator|)
condition|)
continue|continue;
name|ols
operator|=
operator|++
name|o
expr_stmt|;
name|nls
operator|=
operator|++
name|n
expr_stmt|;
comment|/*          * find same begining and same end          */
name|osb
operator|=
name|ols
expr_stmt|;
name|nsb
operator|=
name|nls
expr_stmt|;
name|ose
operator|=
name|ols
expr_stmt|;
name|nse
operator|=
name|nls
expr_stmt|;
comment|/*          * case 1: insert: scan from nfd to nls looking for *ofd          */
if|if
condition|(
operator|*
name|ofd
condition|)
block|{
for|for
control|(
name|c
operator|=
operator|*
name|ofd
operator|,
name|n
operator|=
name|nfd
init|;
name|n
operator|<
name|nls
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
operator|*
name|n
condition|)
block|{
for|for
control|(
name|o
operator|=
name|ofd
operator|,
name|p
operator|=
name|n
init|;
name|p
operator|<
name|nls
operator|&&
name|o
operator|<
name|ols
operator|&&
operator|*
name|o
operator|==
operator|*
name|p
condition|;
name|o
operator|++
operator|,
name|p
operator|++
control|)
continue|continue;
comment|/* 				 * if the new match is longer and it's worth 				 * keeping, then we take it 				 */
if|if
condition|(
operator|(
operator|(
name|nse
operator|-
name|nsb
operator|)
operator|<
operator|(
name|p
operator|-
name|n
operator|)
operator|)
operator|&&
operator|(
literal|2
operator|*
operator|(
name|p
operator|-
name|n
operator|)
operator|>
name|n
operator|-
name|nfd
operator|)
condition|)
block|{
name|nsb
operator|=
name|n
expr_stmt|;
name|nse
operator|=
name|p
expr_stmt|;
name|osb
operator|=
name|ofd
expr_stmt|;
name|ose
operator|=
name|o
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/*          * case 2: delete: scan from ofd to ols looking for *nfd          */
if|if
condition|(
operator|*
name|nfd
condition|)
block|{
for|for
control|(
name|c
operator|=
operator|*
name|nfd
operator|,
name|o
operator|=
name|ofd
init|;
name|o
operator|<
name|ols
condition|;
name|o
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
operator|*
name|o
condition|)
block|{
for|for
control|(
name|n
operator|=
name|nfd
operator|,
name|p
operator|=
name|o
init|;
name|p
operator|<
name|ols
operator|&&
name|n
operator|<
name|nls
operator|&&
operator|*
name|p
operator|==
operator|*
name|n
condition|;
name|p
operator|++
operator|,
name|n
operator|++
control|)
continue|continue;
comment|/* 				 * if the new match is longer and it's worth 				 * keeping, then we take it 				 */
if|if
condition|(
operator|(
operator|(
name|ose
operator|-
name|osb
operator|)
operator|<
operator|(
name|p
operator|-
name|o
operator|)
operator|)
operator|&&
operator|(
literal|2
operator|*
operator|(
name|p
operator|-
name|o
operator|)
operator|>
name|o
operator|-
name|ofd
operator|)
condition|)
block|{
name|nsb
operator|=
name|nfd
expr_stmt|;
name|nse
operator|=
name|n
expr_stmt|;
name|osb
operator|=
name|o
expr_stmt|;
name|ose
operator|=
name|p
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/*          * Pragmatics I: If old trailing whitespace or not enough characters to          * save to be worth it, then don't save the last same info.          */
if|if
condition|(
operator|(
name|oe
operator|-
name|ols
operator|)
operator|<
name|MIN_END_KEEP
condition|)
block|{
name|ols
operator|=
name|oe
expr_stmt|;
name|nls
operator|=
name|ne
expr_stmt|;
block|}
comment|/*          * Pragmatics II: if the terminal isn't smart enough, make the data          * dumber so the smart update doesn't try anything fancy          */
comment|/*          * fx is the number of characters we need to insert/delete: in the          * beginning to bring the two same begins together          */
name|fx
operator|=
operator|(
name|nsb
operator|-
name|nfd
operator|)
operator|-
operator|(
name|osb
operator|-
name|ofd
operator|)
expr_stmt|;
comment|/*          * sx is the number of characters we need to insert/delete: in the          * end to bring the two same last parts together          */
name|sx
operator|=
operator|(
name|nls
operator|-
name|nse
operator|)
operator|-
operator|(
name|ols
operator|-
name|ose
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|EL_CAN_INSERT
condition|)
block|{
if|if
condition|(
name|fx
operator|>
literal|0
condition|)
block|{
name|osb
operator|=
name|ols
expr_stmt|;
name|ose
operator|=
name|ols
expr_stmt|;
name|nsb
operator|=
name|nls
expr_stmt|;
name|nse
operator|=
name|nls
expr_stmt|;
block|}
if|if
condition|(
name|sx
operator|>
literal|0
condition|)
block|{
name|ols
operator|=
name|oe
expr_stmt|;
name|nls
operator|=
name|ne
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ols
operator|-
name|ofd
operator|)
operator|<
operator|(
name|nls
operator|-
name|nfd
operator|)
condition|)
block|{
name|ols
operator|=
name|oe
expr_stmt|;
name|nls
operator|=
name|ne
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|EL_CAN_DELETE
condition|)
block|{
if|if
condition|(
name|fx
operator|<
literal|0
condition|)
block|{
name|osb
operator|=
name|ols
expr_stmt|;
name|ose
operator|=
name|ols
expr_stmt|;
name|nsb
operator|=
name|nls
expr_stmt|;
name|nse
operator|=
name|nls
expr_stmt|;
block|}
if|if
condition|(
name|sx
operator|<
literal|0
condition|)
block|{
name|ols
operator|=
name|oe
expr_stmt|;
name|nls
operator|=
name|ne
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ols
operator|-
name|ofd
operator|)
operator|>
operator|(
name|nls
operator|-
name|nfd
operator|)
condition|)
block|{
name|ols
operator|=
name|oe
expr_stmt|;
name|nls
operator|=
name|ne
expr_stmt|;
block|}
block|}
comment|/*          * Pragmatics III: make sure the middle shifted pointers are correct if          * they don't point to anything (we may have moved ols or nls).          */
comment|/* if the change isn't worth it, don't bother */
comment|/* was: if (osb == ose) */
if|if
condition|(
operator|(
name|ose
operator|-
name|osb
operator|)
operator|<
name|MIN_END_KEEP
condition|)
block|{
name|osb
operator|=
name|ols
expr_stmt|;
name|ose
operator|=
name|ols
expr_stmt|;
name|nsb
operator|=
name|nls
expr_stmt|;
name|nse
operator|=
name|nls
expr_stmt|;
block|}
comment|/*          * Now that we are done with pragmatics we recompute fx, sx          */
name|fx
operator|=
operator|(
name|nsb
operator|-
name|nfd
operator|)
operator|-
operator|(
name|osb
operator|-
name|ofd
operator|)
expr_stmt|;
name|sx
operator|=
operator|(
name|nls
operator|-
name|nse
operator|)
operator|-
operator|(
name|ols
operator|-
name|ose
operator|)
expr_stmt|;
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"\n"
operator|)
argument_list|)
expr_stmt|;
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"ofd %d, osb %d, ose %d, ols %d, oe %d\n"
operator|,
name|ofd
operator|-
name|old
operator|,
name|osb
operator|-
name|old
operator|,
name|ose
operator|-
name|old
operator|,
name|ols
operator|-
name|old
operator|,
name|oe
operator|-
name|old
operator|)
argument_list|)
expr_stmt|;
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"nfd %d, nsb %d, nse %d, nls %d, ne %d\n"
operator|,
name|nfd
operator|-
name|new
operator|,
name|nsb
operator|-
name|new
operator|,
name|nse
operator|-
name|new
operator|,
name|nls
operator|-
name|new
operator|,
name|ne
operator|-
name|new
operator|)
argument_list|)
expr_stmt|;
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"xxx-xxx:\"00000000001111111111222222222233333333334\"\r\n"
operator|)
argument_list|)
expr_stmt|;
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"xxx-xxx:\"01234567890123456789012345678901234567890\"\r\n"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_REFRESH
name|re_printstr
argument_list|(
name|el
argument_list|,
literal|"old- oe"
argument_list|,
name|old
argument_list|,
name|oe
argument_list|)
expr_stmt|;
name|re_printstr
argument_list|(
name|el
argument_list|,
literal|"new- ne"
argument_list|,
name|new
argument_list|,
name|ne
argument_list|)
expr_stmt|;
name|re_printstr
argument_list|(
name|el
argument_list|,
literal|"old-ofd"
argument_list|,
name|old
argument_list|,
name|ofd
argument_list|)
expr_stmt|;
name|re_printstr
argument_list|(
name|el
argument_list|,
literal|"new-nfd"
argument_list|,
name|new
argument_list|,
name|nfd
argument_list|)
expr_stmt|;
name|re_printstr
argument_list|(
name|el
argument_list|,
literal|"ofd-osb"
argument_list|,
name|ofd
argument_list|,
name|osb
argument_list|)
expr_stmt|;
name|re_printstr
argument_list|(
name|el
argument_list|,
literal|"nfd-nsb"
argument_list|,
name|nfd
argument_list|,
name|nsb
argument_list|)
expr_stmt|;
name|re_printstr
argument_list|(
name|el
argument_list|,
literal|"osb-ose"
argument_list|,
name|osb
argument_list|,
name|ose
argument_list|)
expr_stmt|;
name|re_printstr
argument_list|(
name|el
argument_list|,
literal|"nsb-nse"
argument_list|,
name|nsb
argument_list|,
name|nse
argument_list|)
expr_stmt|;
name|re_printstr
argument_list|(
name|el
argument_list|,
literal|"ose-ols"
argument_list|,
name|ose
argument_list|,
name|ols
argument_list|)
expr_stmt|;
name|re_printstr
argument_list|(
name|el
argument_list|,
literal|"nse-nls"
argument_list|,
name|nse
argument_list|,
name|nls
argument_list|)
expr_stmt|;
name|re_printstr
argument_list|(
name|el
argument_list|,
literal|"ols- oe"
argument_list|,
name|ols
argument_list|,
name|oe
argument_list|)
expr_stmt|;
name|re_printstr
argument_list|(
name|el
argument_list|,
literal|"nls- ne"
argument_list|,
name|nls
argument_list|,
name|ne
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_REFRESH */
comment|/*          * el_cursor.v to this line i MUST be in this routine so that if we          * don't have to change the line, we don't move to it. el_cursor.h to          * first diff char          */
name|term_move_to_line
argument_list|(
name|el
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/*          * at this point we have something like this:          *          * /old                  /ofd    /osb               /ose    /ols     /oe          * v.....................v       v..................v       v........v          * eddie> Oh, my fredded gruntle-buggy is to me, as foo var lurgid as          * eddie> Oh, my fredded quiux buggy is to me, as gruntle-lurgid as          * ^.....................^     ^..................^       ^........^          * \new                  \nfd  \nsb               \nse     \nls    \ne          *          * fx is the difference in length between the chars between nfd and          * nsb, and the chars between ofd and osb, and is thus the number of          * characters to delete if< 0 (new is shorter than old, as above),          * or insert (new is longer than short).          *          * sx is the same for the second differences.          */
comment|/*          * if we have a net insert on the first difference, AND inserting the          * net amount ((nsb-nfd) - (osb-ofd)) won't push the last useful          * character (which is ne if nls != ne, otherwise is nse) off the edge 	 * of the screen (el->el_term.t_size.h) else we do the deletes first 	 * so that we keep everything we need to.          */
comment|/*          * if the last same is the same like the end, there is no last same          * part, otherwise we want to keep the last same part set p to the          * last useful old character          */
name|p
operator|=
operator|(
name|ols
operator|!=
name|oe
operator|)
condition|?
name|oe
else|:
name|ose
expr_stmt|;
comment|/*          * if (There is a diffence in the beginning)&& (we need to insert          *   characters)&& (the number of characters to insert is less than          *   the term width) 	 *	We need to do an insert! 	 * else if (we need to delete characters) 	 *	We need to delete characters! 	 * else 	 *	No insert or delete          */
if|if
condition|(
operator|(
name|nsb
operator|!=
name|nfd
operator|)
operator|&&
name|fx
operator|>
literal|0
operator|&&
operator|(
operator|(
name|p
operator|-
name|old
operator|)
operator|+
name|fx
operator|<=
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|h
operator|)
condition|)
block|{
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"first diff insert at %d...\r\n"
operator|,
name|nfd
operator|-
name|new
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Move to the first char to insert, where the first diff is. 		 */
name|term_move_to_char
argument_list|(
name|el
argument_list|,
name|nfd
operator|-
name|new
argument_list|)
expr_stmt|;
comment|/* 		 * Check if we have stuff to keep at end 		 */
if|if
condition|(
name|nsb
operator|!=
name|ne
condition|)
block|{
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"with stuff to keep at end\r\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 		         * insert fx chars of new starting at nfd 		         */
if|if
condition|(
name|fx
operator|>
literal|0
condition|)
block|{
name|ELRE_DEBUG
argument_list|(
operator|!
name|EL_CAN_INSERT
argument_list|,
operator|(
name|__F
operator|,
literal|"ERROR: cannot insert in early first diff\n"
operator|)
argument_list|)
expr_stmt|;
name|term_insertwrite
argument_list|(
name|el
argument_list|,
name|nfd
argument_list|,
name|fx
argument_list|)
expr_stmt|;
name|re_insert
argument_list|(
name|el
argument_list|,
name|old
argument_list|,
name|ofd
operator|-
name|old
argument_list|,
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|h
argument_list|,
name|nfd
argument_list|,
name|fx
argument_list|)
expr_stmt|;
block|}
comment|/* 		         * write (nsb-nfd) - fx chars of new starting at 		         * (nfd + fx) 			 */
name|term_overwrite
argument_list|(
name|el
argument_list|,
name|nfd
operator|+
name|fx
argument_list|,
operator|(
name|nsb
operator|-
name|nfd
operator|)
operator|-
name|fx
argument_list|)
expr_stmt|;
name|re__strncopy
argument_list|(
name|ofd
operator|+
name|fx
argument_list|,
name|nfd
operator|+
name|fx
argument_list|,
call|(
name|size_t
call|)
argument_list|(
operator|(
name|nsb
operator|-
name|nfd
operator|)
operator|-
name|fx
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"without anything to save\r\n"
operator|)
argument_list|)
expr_stmt|;
name|term_overwrite
argument_list|(
name|el
argument_list|,
name|nfd
argument_list|,
operator|(
name|nsb
operator|-
name|nfd
operator|)
argument_list|)
expr_stmt|;
name|re__strncopy
argument_list|(
name|ofd
argument_list|,
name|nfd
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|nsb
operator|-
name|nfd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		         * Done 		         */
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|fx
operator|<
literal|0
condition|)
block|{
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"first diff delete at %d...\r\n"
operator|,
name|ofd
operator|-
name|old
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * move to the first char to delete where the first diff is 		 */
name|term_move_to_char
argument_list|(
name|el
argument_list|,
name|ofd
operator|-
name|old
argument_list|)
expr_stmt|;
comment|/* 		 * Check if we have stuff to save 		 */
if|if
condition|(
name|osb
operator|!=
name|oe
condition|)
block|{
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"with stuff to save at end\r\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 		         * fx is less than zero *always* here but we check 		         * for code symmetry 		         */
if|if
condition|(
name|fx
operator|<
literal|0
condition|)
block|{
name|ELRE_DEBUG
argument_list|(
operator|!
name|EL_CAN_DELETE
argument_list|,
operator|(
name|__F
operator|,
literal|"ERROR: cannot delete in first diff\n"
operator|)
argument_list|)
expr_stmt|;
name|term_deletechars
argument_list|(
name|el
argument_list|,
operator|-
name|fx
argument_list|)
expr_stmt|;
name|re_delete
argument_list|(
name|el
argument_list|,
name|old
argument_list|,
name|ofd
operator|-
name|old
argument_list|,
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|h
argument_list|,
operator|-
name|fx
argument_list|)
expr_stmt|;
block|}
comment|/* 		         * write (nsb-nfd) chars of new starting at nfd 		         */
name|term_overwrite
argument_list|(
name|el
argument_list|,
name|nfd
argument_list|,
operator|(
name|nsb
operator|-
name|nfd
operator|)
argument_list|)
expr_stmt|;
name|re__strncopy
argument_list|(
name|ofd
argument_list|,
name|nfd
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|nsb
operator|-
name|nfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"but with nothing left to save\r\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 		         * write (nsb-nfd) chars of new starting at nfd 		         */
name|term_overwrite
argument_list|(
name|el
argument_list|,
name|nfd
argument_list|,
operator|(
name|nsb
operator|-
name|nfd
operator|)
argument_list|)
expr_stmt|;
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"cleareol %d\n"
operator|,
operator|(
name|oe
operator|-
name|old
operator|)
operator|-
operator|(
name|ne
operator|-
name|new
operator|)
operator|)
argument_list|)
expr_stmt|;
name|term_clear_EOL
argument_list|(
name|el
argument_list|,
operator|(
name|oe
operator|-
name|old
operator|)
operator|-
operator|(
name|ne
operator|-
name|new
operator|)
argument_list|)
expr_stmt|;
comment|/* 		         * Done 		         */
return|return;
block|}
block|}
else|else
name|fx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sx
operator|<
literal|0
operator|&&
operator|(
name|ose
operator|-
name|old
operator|)
operator|+
name|fx
operator|<
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|h
condition|)
block|{
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"second diff delete at %d...\r\n"
operator|,
operator|(
name|ose
operator|-
name|old
operator|)
operator|+
name|fx
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Check if we have stuff to delete 		 */
comment|/* 		 * fx is the number of characters inserted (+) or deleted (-) 		 */
name|term_move_to_char
argument_list|(
name|el
argument_list|,
operator|(
name|ose
operator|-
name|old
operator|)
operator|+
name|fx
argument_list|)
expr_stmt|;
comment|/* 		 * Check if we have stuff to save 		 */
if|if
condition|(
name|ols
operator|!=
name|oe
condition|)
block|{
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"with stuff to save at end\r\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 		         * Again a duplicate test. 		         */
if|if
condition|(
name|sx
operator|<
literal|0
condition|)
block|{
name|ELRE_DEBUG
argument_list|(
operator|!
name|EL_CAN_DELETE
argument_list|,
operator|(
name|__F
operator|,
literal|"ERROR: cannot delete in second diff\n"
operator|)
argument_list|)
expr_stmt|;
name|term_deletechars
argument_list|(
name|el
argument_list|,
operator|-
name|sx
argument_list|)
expr_stmt|;
block|}
comment|/* 		         * write (nls-nse) chars of new starting at nse 		         */
name|term_overwrite
argument_list|(
name|el
argument_list|,
name|nse
argument_list|,
operator|(
name|nls
operator|-
name|nse
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"but with nothing left to save\r\n"
operator|)
argument_list|)
expr_stmt|;
name|term_overwrite
argument_list|(
name|el
argument_list|,
name|nse
argument_list|,
operator|(
name|nls
operator|-
name|nse
operator|)
argument_list|)
expr_stmt|;
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"cleareol %d\n"
operator|,
operator|(
name|oe
operator|-
name|old
operator|)
operator|-
operator|(
name|ne
operator|-
name|new
operator|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|oe
operator|-
name|old
operator|)
operator|-
operator|(
name|ne
operator|-
name|new
operator|)
operator|!=
literal|0
condition|)
name|term_clear_EOL
argument_list|(
name|el
argument_list|,
operator|(
name|oe
operator|-
name|old
operator|)
operator|-
operator|(
name|ne
operator|-
name|new
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*          * if we have a first insert AND WE HAVEN'T ALREADY DONE IT...          */
if|if
condition|(
operator|(
name|nsb
operator|!=
name|nfd
operator|)
operator|&&
operator|(
name|osb
operator|-
name|ofd
operator|)
operator|<=
operator|(
name|nsb
operator|-
name|nfd
operator|)
operator|&&
operator|(
name|fx
operator|==
literal|0
operator|)
condition|)
block|{
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"late first diff insert at %d...\r\n"
operator|,
name|nfd
operator|-
name|new
operator|)
argument_list|)
expr_stmt|;
name|term_move_to_char
argument_list|(
name|el
argument_list|,
name|nfd
operator|-
name|new
argument_list|)
expr_stmt|;
comment|/* 		 * Check if we have stuff to keep at the end 		 */
if|if
condition|(
name|nsb
operator|!=
name|ne
condition|)
block|{
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"with stuff to keep at end\r\n"
operator|)
argument_list|)
expr_stmt|;
comment|/* 		         * We have to recalculate fx here because we set it 		         * to zero above as a flag saying that we hadn't done 		         * an early first insert. 		         */
name|fx
operator|=
operator|(
name|nsb
operator|-
name|nfd
operator|)
operator|-
operator|(
name|osb
operator|-
name|ofd
operator|)
expr_stmt|;
if|if
condition|(
name|fx
operator|>
literal|0
condition|)
block|{
comment|/* 				 * insert fx chars of new starting at nfd 				 */
name|ELRE_DEBUG
argument_list|(
operator|!
name|EL_CAN_INSERT
argument_list|,
operator|(
name|__F
operator|,
literal|"ERROR: cannot insert in late first diff\n"
operator|)
argument_list|)
expr_stmt|;
name|term_insertwrite
argument_list|(
name|el
argument_list|,
name|nfd
argument_list|,
name|fx
argument_list|)
expr_stmt|;
name|re_insert
argument_list|(
name|el
argument_list|,
name|old
argument_list|,
name|ofd
operator|-
name|old
argument_list|,
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|h
argument_list|,
name|nfd
argument_list|,
name|fx
argument_list|)
expr_stmt|;
block|}
comment|/* 		         * write (nsb-nfd) - fx chars of new starting at 		         * (nfd + fx) 			 */
name|term_overwrite
argument_list|(
name|el
argument_list|,
name|nfd
operator|+
name|fx
argument_list|,
operator|(
name|nsb
operator|-
name|nfd
operator|)
operator|-
name|fx
argument_list|)
expr_stmt|;
name|re__strncopy
argument_list|(
name|ofd
operator|+
name|fx
argument_list|,
name|nfd
operator|+
name|fx
argument_list|,
call|(
name|size_t
call|)
argument_list|(
operator|(
name|nsb
operator|-
name|nfd
operator|)
operator|-
name|fx
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"without anything to save\r\n"
operator|)
argument_list|)
expr_stmt|;
name|term_overwrite
argument_list|(
name|el
argument_list|,
name|nfd
argument_list|,
operator|(
name|nsb
operator|-
name|nfd
operator|)
argument_list|)
expr_stmt|;
name|re__strncopy
argument_list|(
name|ofd
argument_list|,
name|nfd
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|nsb
operator|-
name|nfd
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*          * line is now NEW up to nse          */
if|if
condition|(
name|sx
operator|>=
literal|0
condition|)
block|{
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"second diff insert at %d...\r\n"
operator|,
name|nse
operator|-
name|new
operator|)
argument_list|)
expr_stmt|;
name|term_move_to_char
argument_list|(
name|el
argument_list|,
name|nse
operator|-
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|ols
operator|!=
name|oe
condition|)
block|{
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"with stuff to keep at end\r\n"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sx
operator|>
literal|0
condition|)
block|{
comment|/* insert sx chars of new starting at nse */
name|ELRE_DEBUG
argument_list|(
operator|!
name|EL_CAN_INSERT
argument_list|,
operator|(
name|__F
operator|,
literal|"ERROR: cannot insert in second diff\n"
operator|)
argument_list|)
expr_stmt|;
name|term_insertwrite
argument_list|(
name|el
argument_list|,
name|nse
argument_list|,
name|sx
argument_list|)
expr_stmt|;
block|}
comment|/* 		         * write (nls-nse) - sx chars of new starting at 			 * (nse + sx) 		         */
name|term_overwrite
argument_list|(
name|el
argument_list|,
name|nse
operator|+
name|sx
argument_list|,
operator|(
name|nls
operator|-
name|nse
operator|)
operator|-
name|sx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"without anything to save\r\n"
operator|)
argument_list|)
expr_stmt|;
name|term_overwrite
argument_list|(
name|el
argument_list|,
name|nse
argument_list|,
operator|(
name|nls
operator|-
name|nse
operator|)
argument_list|)
expr_stmt|;
comment|/* 	                 * No need to do a clear-to-end here because we were 	                 * doing a second insert, so we will have over 	                 * written all of the old string. 		         */
block|}
block|}
name|ELRE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"done.\r\n"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* re__copy_and_pad():  *	Copy string and pad with spaces  */
end_comment

begin_function
name|private
name|void
name|re__copy_and_pad
parameter_list|(
name|char
modifier|*
name|dst
parameter_list|,
name|char
modifier|*
name|src
parameter_list|,
name|size_t
name|width
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|width
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|src
operator|==
literal|'\0'
condition|)
break|break;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|width
condition|;
name|i
operator|++
control|)
operator|*
name|dst
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|dst
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/* re_refresh_cursor():  *	Move to the new cursor position  */
end_comment

begin_function
name|protected
name|void
name|re_refresh_cursor
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
name|c
decl_stmt|;
name|int
name|h
decl_stmt|,
name|v
decl_stmt|,
name|th
decl_stmt|;
comment|/* first we must find where the cursor is... */
name|h
operator|=
name|el
operator|->
name|el_prompt
operator|.
name|p_pos
operator|.
name|h
expr_stmt|;
name|v
operator|=
name|el
operator|->
name|el_prompt
operator|.
name|p_pos
operator|.
name|v
expr_stmt|;
name|th
operator|=
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|h
expr_stmt|;
comment|/* optimize for speed */
comment|/* do input buffer to el->el_line.cursor */
for|for
control|(
name|cp
operator|=
name|el
operator|->
name|el_line
operator|.
name|buffer
init|;
name|cp
operator|<
name|el
operator|->
name|el_line
operator|.
name|cursor
condition|;
name|cp
operator|++
control|)
block|{
name|c
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
expr_stmt|;
name|h
operator|++
expr_stmt|;
comment|/* all chars at least this long */
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
comment|/* handle newline in data part too */
name|h
operator|=
literal|0
expr_stmt|;
name|v
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
comment|/* if a tab, to next tab stop */
while|while
condition|(
name|h
operator|&
literal|07
condition|)
block|{
name|h
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|iscntrl
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|)
condition|)
block|{
comment|/* if control char */
name|h
operator|++
expr_stmt|;
if|if
condition|(
name|h
operator|>
name|th
condition|)
block|{
comment|/* if overflow, compensate */
name|h
operator|=
literal|1
expr_stmt|;
name|v
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|isprint
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|)
condition|)
block|{
name|h
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|h
operator|>
name|th
condition|)
block|{
comment|/* if overflow, compensate */
name|h
operator|=
name|h
operator|-
name|th
expr_stmt|;
name|v
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|h
operator|>=
name|th
condition|)
block|{
comment|/* check, extra long tabs picked up here also */
name|h
operator|=
literal|0
expr_stmt|;
name|v
operator|++
expr_stmt|;
block|}
block|}
comment|/* now go there */
name|term_move_to_line
argument_list|(
name|el
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|term_move_to_char
argument_list|(
name|el
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|term__flush
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* re_fastputc():  *	Add a character fast.  */
end_comment

begin_function
name|private
name|void
name|re_fastputc
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|term__putc
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|el
operator|->
name|el_display
index|[
name|el
operator|->
name|el_cursor
operator|.
name|v
index|]
index|[
name|el
operator|->
name|el_cursor
operator|.
name|h
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|el
operator|->
name|el_cursor
operator|.
name|h
operator|>=
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|h
condition|)
block|{
comment|/* if we must overflow */
name|el
operator|->
name|el_cursor
operator|.
name|h
operator|=
literal|0
expr_stmt|;
comment|/* 		 * If we would overflow (input is longer than terminal size), 		 * emulate scroll by dropping first line and shuffling the rest. 		 * We do this via pointer shuffling - it's safe in this case 		 * and we avoid memcpy(). 		 */
if|if
condition|(
name|el
operator|->
name|el_cursor
operator|.
name|v
operator|+
literal|1
operator|>=
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|v
condition|)
block|{
name|int
name|i
decl_stmt|,
name|lins
init|=
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|v
decl_stmt|;
name|char
modifier|*
name|firstline
init|=
name|el
operator|->
name|el_display
index|[
literal|0
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|lins
condition|;
name|i
operator|++
control|)
name|el
operator|->
name|el_display
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|el
operator|->
name|el_display
index|[
name|i
index|]
expr_stmt|;
name|re__copy_and_pad
argument_list|(
name|firstline
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|el
operator|->
name|el_display
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|firstline
expr_stmt|;
block|}
else|else
block|{
name|el
operator|->
name|el_cursor
operator|.
name|v
operator|++
expr_stmt|;
name|el
operator|->
name|el_refresh
operator|.
name|r_oldcv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|EL_HAS_AUTO_MARGINS
condition|)
block|{
if|if
condition|(
name|EL_HAS_MAGIC_MARGINS
condition|)
block|{
name|term__putc
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|term__putc
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|term__putc
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|term__putc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* re_fastaddc():  *	we added just one char, handle it fast.  *	Assumes that screen cursor == real cursor  */
end_comment

begin_function
name|protected
name|void
name|re_fastaddc
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
name|int
name|rhdiff
decl_stmt|;
name|c
operator|=
operator|(
name|unsigned
name|char
operator|)
name|el
operator|->
name|el_line
operator|.
name|cursor
index|[
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\t'
operator|||
name|el
operator|->
name|el_line
operator|.
name|cursor
operator|!=
name|el
operator|->
name|el_line
operator|.
name|lastchar
condition|)
block|{
name|re_refresh
argument_list|(
name|el
argument_list|)
expr_stmt|;
comment|/* too hard to handle */
return|return;
block|}
name|rhdiff
operator|=
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|h
operator|-
name|el
operator|->
name|el_cursor
operator|.
name|h
operator|-
name|el
operator|->
name|el_rprompt
operator|.
name|p_pos
operator|.
name|h
expr_stmt|;
if|if
condition|(
name|el
operator|->
name|el_rprompt
operator|.
name|p_pos
operator|.
name|h
operator|&&
name|rhdiff
operator|<
literal|3
condition|)
block|{
name|re_refresh
argument_list|(
name|el
argument_list|)
expr_stmt|;
comment|/* clear out rprompt if less than 1 char gap */
return|return;
block|}
comment|/* else (only do at end of line, no TAB) */
if|if
condition|(
name|iscntrl
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|)
condition|)
block|{
comment|/* if control char, do caret */
name|char
name|mc
init|=
operator|(
name|c
operator|==
literal|0177
operator|)
condition|?
literal|'?'
else|:
operator|(
name|toascii
argument_list|(
name|c
argument_list|)
operator||
literal|0100
operator|)
decl_stmt|;
name|re_fastputc
argument_list|(
name|el
argument_list|,
literal|'^'
argument_list|)
expr_stmt|;
name|re_fastputc
argument_list|(
name|el
argument_list|,
name|mc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isprint
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|c
argument_list|)
condition|)
block|{
comment|/* normal char */
name|re_fastputc
argument_list|(
name|el
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|re_fastputc
argument_list|(
name|el
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
name|re_fastputc
argument_list|(
name|el
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
operator|(
name|unsigned
name|int
operator|)
name|c
operator|>>
literal|6
operator|)
operator|&
literal|7
operator|)
operator|+
literal|'0'
argument_list|)
argument_list|)
expr_stmt|;
name|re_fastputc
argument_list|(
name|el
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
operator|(
name|unsigned
name|int
operator|)
name|c
operator|>>
literal|3
operator|)
operator|&
literal|7
operator|)
operator|+
literal|'0'
argument_list|)
argument_list|)
expr_stmt|;
name|re_fastputc
argument_list|(
name|el
argument_list|,
operator|(
name|c
operator|&
literal|7
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
block|}
name|term__flush
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* re_clear_display():  *	clear the screen buffers so that new new prompt starts fresh.  */
end_comment

begin_function
name|protected
name|void
name|re_clear_display
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|el
operator|->
name|el_cursor
operator|.
name|v
operator|=
literal|0
expr_stmt|;
name|el
operator|->
name|el_cursor
operator|.
name|h
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|v
condition|;
name|i
operator|++
control|)
name|el
operator|->
name|el_display
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|el
operator|->
name|el_refresh
operator|.
name|r_oldcv
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* re_clear_lines():  *	Make sure all lines are *really* blank  */
end_comment

begin_function
name|protected
name|void
name|re_clear_lines
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|)
block|{
if|if
condition|(
name|EL_CAN_CEOL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|term_move_to_char
argument_list|(
name|el
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|el
operator|->
name|el_refresh
operator|.
name|r_oldcv
condition|;
name|i
operator|++
control|)
block|{
comment|/* for each line on the screen */
name|term_move_to_line
argument_list|(
name|el
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|term_clear_EOL
argument_list|(
name|el
argument_list|,
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|h
argument_list|)
expr_stmt|;
block|}
name|term_move_to_line
argument_list|(
name|el
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|term_move_to_line
argument_list|(
name|el
argument_list|,
name|el
operator|->
name|el_refresh
operator|.
name|r_oldcv
argument_list|)
expr_stmt|;
comment|/* go to last line */
name|term__putc
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
comment|/* go to BOL */
name|term__putc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* go to new line */
block|}
block|}
end_function

end_unit

