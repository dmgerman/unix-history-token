begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Christos Zoulas of Cornell University.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCCSID
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)refresh.c	8.1 (Berkeley) 6/4/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint&& not SCCSID */
end_comment

begin_comment
comment|/*  * refresh.c: Lower level screen refreshing functions  */
end_comment

begin_include
include|#
directive|include
file|"sys.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"el.h"
end_include

begin_decl_stmt
name|private
name|void
name|re_addc
name|__P
argument_list|(
operator|(
name|EditLine
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|re_update_line
name|__P
argument_list|(
operator|(
name|EditLine
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|re_insert
name|__P
argument_list|(
operator|(
name|EditLine
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|re_delete
name|__P
argument_list|(
operator|(
name|EditLine
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|re_fastputc
name|__P
argument_list|(
operator|(
name|EditLine
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|re__strncopy
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|re__copy_and_pad
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|size_t
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG_REFRESH
end_ifdef

begin_decl_stmt
name|private
name|void
name|re_printstr
name|__P
argument_list|(
operator|(
name|EditLine
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|__F
value|el->el_errfile
end_define

begin_define
define|#
directive|define
name|RE_DEBUG
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
value|do 				\ 				    if (a) {			\ 					(void) fprintf b;	\ 					c;			\ 				    }				\ 				while (0)
end_define

begin_comment
comment|/* re_printstr():  *	Print a string on the debugging pty  */
end_comment

begin_function
name|private
name|void
name|re_printstr
parameter_list|(
name|el
parameter_list|,
name|str
parameter_list|,
name|f
parameter_list|,
name|t
parameter_list|)
name|EditLine
modifier|*
name|el
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|char
modifier|*
name|f
decl_stmt|,
decl|*
name|t
decl_stmt|;
end_function

begin_block
block|{
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"%s:\""
operator|,
name|str
operator|)
argument_list|,)
expr_stmt|;
while|while
condition|(
name|f
operator|<
name|t
condition|)
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"%c"
operator|,
operator|*
name|f
operator|++
operator|&
literal|0177
operator|)
argument_list|,)
expr_stmt|;
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"\"\r\n"
operator|)
argument_list|,)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RE_DEBUG
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|c
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* re_addc():  *	Draw c, expanding tabs, control chars etc.  */
end_comment

begin_function
name|private
name|void
name|re_addc
parameter_list|(
name|el
parameter_list|,
name|c
parameter_list|)
name|EditLine
modifier|*
name|el
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
name|c
operator|=
operator|(
name|unsigned
name|char
operator|)
name|c
expr_stmt|;
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|re_putc
argument_list|(
name|el
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
comment|/* expand the newline	 */
name|re_putc
argument_list|(
name|el
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
comment|/* assure end of line	 */
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|h
operator|=
literal|0
expr_stmt|;
comment|/* reset cursor pos	 */
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|v
operator|++
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
comment|/* expand the tab 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|re_putc
argument_list|(
name|el
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|h
operator|&
literal|07
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* go until tab stop	 */
block|}
block|}
elseif|else
if|if
condition|(
name|iscntrl
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|re_putc
argument_list|(
name|el
argument_list|,
literal|'^'
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0177
condition|)
name|re_putc
argument_list|(
name|el
argument_list|,
literal|'?'
argument_list|)
expr_stmt|;
else|else
comment|/* uncontrolify it; works only for iso8859-1 like sets */
name|re_putc
argument_list|(
name|el
argument_list|,
operator|(
name|toascii
argument_list|(
name|c
argument_list|)
operator||
literal|0100
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|re_putc
argument_list|(
name|el
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
name|re_putc
argument_list|(
name|el
argument_list|,
operator|(
operator|(
name|c
operator|>>
literal|6
operator|)
operator|&
literal|07
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|re_putc
argument_list|(
name|el
argument_list|,
operator|(
operator|(
name|c
operator|>>
literal|3
operator|)
operator|&
literal|07
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|re_putc
argument_list|(
name|el
argument_list|,
operator|(
name|c
operator|&
literal|07
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* end re_addc */
end_comment

begin_comment
comment|/* re_putc():  *	Draw the character given  */
end_comment

begin_function
name|protected
name|void
name|re_putc
parameter_list|(
name|el
parameter_list|,
name|c
parameter_list|)
name|EditLine
modifier|*
name|el
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"printing %3.3o '%c'\r\n"
operator|,
name|c
operator|,
name|c
operator|)
argument_list|,)
expr_stmt|;
name|el
operator|->
name|el_vdisplay
index|[
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|v
index|]
index|[
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|h
index|]
operator|=
name|c
expr_stmt|;
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|h
operator|++
expr_stmt|;
comment|/* advance to next place */
if|if
condition|(
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|h
operator|>=
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|h
condition|)
block|{
name|el
operator|->
name|el_vdisplay
index|[
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|v
index|]
index|[
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|h
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* assure end of line */
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|h
operator|=
literal|0
expr_stmt|;
comment|/* reset it. */
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|v
operator|++
expr_stmt|;
name|RE_DEBUG
argument_list|(
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|v
operator|>=
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|v
argument_list|,
operator|(
name|__F
operator|,
literal|"\r\nre_putc: overflow! r_cursor.v == %d> %d\r\n"
operator|,
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|v
operator|,
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|v
operator|)
argument_list|,
name|abort
argument_list|()
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* end re_putc */
end_comment

begin_comment
comment|/* re_refresh():  *	draws the new virtual screen image from the current input  *  	line, then goes line-by-line changing the real image to the new  *	virtual image. The routine to re-draw a line can be replaced  *	easily in hopes of a smarter one being placed there.  */
end_comment

begin_function
name|protected
name|void
name|re_refresh
parameter_list|(
name|el
parameter_list|)
name|EditLine
modifier|*
name|el
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|coord_t
name|cur
decl_stmt|;
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"el->el_line.buffer = :%s:\r\n"
operator|,
name|el
operator|->
name|el_line
operator|.
name|buffer
operator|)
argument_list|,)
expr_stmt|;
comment|/* reset the Drawing cursor */
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|h
operator|=
literal|0
expr_stmt|;
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|v
operator|=
literal|0
expr_stmt|;
name|cur
operator|.
name|h
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* set flag in case I'm not set */
name|cur
operator|.
name|v
operator|=
literal|0
expr_stmt|;
name|prompt_print
argument_list|(
name|el
argument_list|)
expr_stmt|;
comment|/* draw the current input buffer */
for|for
control|(
name|cp
operator|=
name|el
operator|->
name|el_line
operator|.
name|buffer
init|;
name|cp
operator|<
name|el
operator|->
name|el_line
operator|.
name|lastchar
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
name|cp
operator|==
name|el
operator|->
name|el_line
operator|.
name|cursor
condition|)
block|{
name|cur
operator|.
name|h
operator|=
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|h
expr_stmt|;
comment|/* save for later */
name|cur
operator|.
name|v
operator|=
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|v
expr_stmt|;
block|}
name|re_addc
argument_list|(
name|el
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cur
operator|.
name|h
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* if I haven't been set yet, I'm at the end */
name|cur
operator|.
name|h
operator|=
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|h
expr_stmt|;
name|cur
operator|.
name|v
operator|=
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|v
expr_stmt|;
block|}
comment|/* must be done BEFORE the NUL is written */
name|el
operator|->
name|el_refresh
operator|.
name|r_newcv
operator|=
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|v
expr_stmt|;
name|re_putc
argument_list|(
name|el
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
comment|/* put NUL on end */
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"term.h=%d vcur.h=%d vcur.v=%d vdisplay[0]=\r\n:%80.80s:\r\n"
operator|,
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|h
operator|,
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|h
operator|,
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|v
operator|,
name|el
operator|->
name|el_vdisplay
index|[
literal|0
index|]
operator|)
argument_list|,)
expr_stmt|;
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"updating %d lines.\r\n"
operator|,
name|el
operator|->
name|el_refresh
operator|.
name|r_newcv
operator|)
argument_list|,)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|el
operator|->
name|el_refresh
operator|.
name|r_newcv
condition|;
name|i
operator|++
control|)
block|{
comment|/* NOTE THAT re_update_line MAY CHANGE el_display[i] */
name|re_update_line
argument_list|(
name|el
argument_list|,
name|el
operator|->
name|el_display
index|[
name|i
index|]
argument_list|,
name|el
operator|->
name|el_vdisplay
index|[
name|i
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 	 * Copy the new line to be the current one, and pad out with spaces 	 * to the full width of the terminal so that if we try moving the 	 * cursor by writing the character that is at the end of the 	 * screen line, it won't be a NUL or some old leftover stuff. 	 */
name|re__copy_and_pad
argument_list|(
name|el
operator|->
name|el_display
index|[
name|i
index|]
argument_list|,
name|el
operator|->
name|el_vdisplay
index|[
name|i
index|]
argument_list|,
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|h
argument_list|)
expr_stmt|;
block|}
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"\r\nel->el_refresh.r_cursor.v=%d,el->el_refresh.r_oldcv=%d i=%d\r\n"
operator|,
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|v
operator|,
name|el
operator|->
name|el_refresh
operator|.
name|r_oldcv
operator|,
name|i
operator|)
argument_list|,)
expr_stmt|;
if|if
condition|(
name|el
operator|->
name|el_refresh
operator|.
name|r_oldcv
operator|>
name|el
operator|->
name|el_refresh
operator|.
name|r_newcv
condition|)
for|for
control|(
init|;
name|i
operator|<=
name|el
operator|->
name|el_refresh
operator|.
name|r_oldcv
condition|;
name|i
operator|++
control|)
block|{
name|term_move_to_line
argument_list|(
name|el
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|term_move_to_char
argument_list|(
name|el
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|term_clear_EOL
argument_list|(
name|el
argument_list|,
name|strlen
argument_list|(
name|el
operator|->
name|el_display
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_REFRESH
name|term_overwrite
argument_list|(
name|el
argument_list|,
literal|"C\b"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_REFRESH */
operator|*
name|el
operator|->
name|el_display
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|el
operator|->
name|el_refresh
operator|.
name|r_oldcv
operator|=
name|el
operator|->
name|el_refresh
operator|.
name|r_newcv
expr_stmt|;
comment|/* set for next time */
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"\r\ncursor.h = %d, cursor.v = %d, cur.h = %d, cur.v = %d\r\n"
operator|,
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|h
operator|,
name|el
operator|->
name|el_refresh
operator|.
name|r_cursor
operator|.
name|v
operator|,
name|cur
operator|.
name|h
operator|,
name|cur
operator|.
name|v
operator|)
argument_list|,)
expr_stmt|;
name|term_move_to_line
argument_list|(
name|el
argument_list|,
name|cur
operator|.
name|v
argument_list|)
expr_stmt|;
comment|/* go to where the cursor is */
name|term_move_to_char
argument_list|(
name|el
argument_list|,
name|cur
operator|.
name|h
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end re_refresh */
end_comment

begin_comment
comment|/* re_goto_bottom():  *	 used to go to last used screen line  */
end_comment

begin_function
name|protected
name|void
name|re_goto_bottom
parameter_list|(
name|el
parameter_list|)
name|EditLine
modifier|*
name|el
decl_stmt|;
block|{
name|term_move_to_line
argument_list|(
name|el
argument_list|,
name|el
operator|->
name|el_refresh
operator|.
name|r_oldcv
argument_list|)
expr_stmt|;
name|term__putc
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|term__putc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|re_clear_display
argument_list|(
name|el
argument_list|)
expr_stmt|;
name|term__flush
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end re_goto_bottom */
end_comment

begin_comment
comment|/* re_insert():  *	insert num characters of s into d (in front of the character)  *	at dat, maximum length of d is dlen  */
end_comment

begin_function
name|private
name|void
comment|/*ARGSUSED*/
name|re_insert
parameter_list|(
name|el
parameter_list|,
name|d
parameter_list|,
name|dat
parameter_list|,
name|dlen
parameter_list|,
name|s
parameter_list|,
name|num
parameter_list|)
name|EditLine
modifier|*
name|el
decl_stmt|;
name|char
modifier|*
name|d
decl_stmt|;
name|int
name|dat
decl_stmt|,
name|dlen
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|num
decl_stmt|;
block|{
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|num
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
name|num
operator|>
name|dlen
operator|-
name|dat
condition|)
name|num
operator|=
name|dlen
operator|-
name|dat
expr_stmt|;
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"re_insert() starting: %d at %d max %d, d == \"%s\"\n"
operator|,
name|num
operator|,
name|dat
operator|,
name|dlen
operator|,
name|d
operator|)
argument_list|,)
expr_stmt|;
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"s == \"%s\"n"
operator|,
name|s
operator|)
argument_list|,)
expr_stmt|;
comment|/* open up the space for num chars */
if|if
condition|(
name|num
operator|>
literal|0
condition|)
block|{
name|b
operator|=
name|d
operator|+
name|dlen
operator|-
literal|1
expr_stmt|;
name|a
operator|=
name|b
operator|-
name|num
expr_stmt|;
while|while
condition|(
name|a
operator|>=
operator|&
name|d
index|[
name|dat
index|]
condition|)
operator|*
name|b
operator|--
operator|=
operator|*
name|a
operator|--
expr_stmt|;
name|d
index|[
name|dlen
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* just in case */
block|}
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"re_insert() after insert: %d at %d max %d, d == \"%s\"\n"
operator|,
name|num
operator|,
name|dat
operator|,
name|dlen
operator|,
name|d
operator|)
argument_list|,)
expr_stmt|;
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"s == \"%s\"n"
operator|,
name|s
operator|)
argument_list|,)
expr_stmt|;
comment|/* copy the characters */
for|for
control|(
name|a
operator|=
name|d
operator|+
name|dat
init|;
operator|(
name|a
operator|<
name|d
operator|+
name|dlen
operator|)
operator|&&
operator|(
name|num
operator|>
literal|0
operator|)
condition|;
name|num
operator|--
control|)
operator|*
name|a
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"re_insert() after copy: %d at %d max %d, %s == \"%s\"\n"
operator|,
name|num
operator|,
name|dat
operator|,
name|dlen
operator|,
name|d
operator|,
name|s
operator|)
argument_list|,)
expr_stmt|;
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"s == \"%s\"n"
operator|,
name|s
operator|)
argument_list|,)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end re_insert */
end_comment

begin_comment
comment|/* re_delete():  *	delete num characters d at dat, maximum length of d is dlen  */
end_comment

begin_function
name|private
name|void
comment|/*ARGSUSED*/
name|re_delete
parameter_list|(
name|el
parameter_list|,
name|d
parameter_list|,
name|dat
parameter_list|,
name|dlen
parameter_list|,
name|num
parameter_list|)
name|EditLine
modifier|*
name|el
decl_stmt|;
name|char
modifier|*
name|d
decl_stmt|;
name|int
name|dat
decl_stmt|,
name|dlen
decl_stmt|,
name|num
decl_stmt|;
block|{
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|num
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
name|dat
operator|+
name|num
operator|>=
name|dlen
condition|)
block|{
name|d
index|[
name|dat
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"re_delete() starting: %d at %d max %d, d == \"%s\"\n"
operator|,
name|num
operator|,
name|dat
operator|,
name|dlen
operator|,
name|d
operator|)
argument_list|,)
expr_stmt|;
comment|/* open up the space for num chars */
if|if
condition|(
name|num
operator|>
literal|0
condition|)
block|{
name|b
operator|=
name|d
operator|+
name|dat
expr_stmt|;
name|a
operator|=
name|b
operator|+
name|num
expr_stmt|;
while|while
condition|(
name|a
operator|<
operator|&
name|d
index|[
name|dlen
index|]
condition|)
operator|*
name|b
operator|++
operator|=
operator|*
name|a
operator|++
expr_stmt|;
name|d
index|[
name|dlen
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* just in case */
block|}
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"re_delete() after delete: %d at %d max %d, d == \"%s\"\n"
operator|,
name|num
operator|,
name|dat
operator|,
name|dlen
operator|,
name|d
operator|)
argument_list|,)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end re_delete */
end_comment

begin_comment
comment|/* re__strncopy():  *	Like strncpy without padding.  */
end_comment

begin_function
name|private
name|void
name|re__strncopy
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|,
name|n
parameter_list|)
name|char
modifier|*
name|a
decl_stmt|,
decl|*
name|b
decl_stmt|;
end_function

begin_decl_stmt
name|size_t
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|n
operator|--
operator|&&
operator|*
name|b
condition|)
operator|*
name|a
operator|++
operator|=
operator|*
name|b
operator|++
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end re__strncopy */
end_comment

begin_comment
comment|/* ****************************************************************     re_update_line() is based on finding the middle difference of each line     on the screen; vis:  			     /old first difference 	/beginning of line   |              /old last same       /old EOL 	v		     v              v                    v old:	eddie> Oh, my little gruntle-buggy is to me, as lurgid as new:	eddie> Oh, my little buggy says to me, as lurgid as 	^		     ^        ^			   ^ 	\beginning of line   |        \new last same	   \new end of line 			     \new first difference      all are character pointers for the sake of speed.  Special cases for     no differences, as well as for end of line additions must be handled. **************************************************************** */
end_comment

begin_comment
comment|/* Minimum at which doing an insert it "worth it".  This should be about  * half the "cost" of going into insert mode, inserting a character, and  * going back out.  This should really be calculated from the termcap  * data...  For the moment, a good number for ANSI terminals.  */
end_comment

begin_define
define|#
directive|define
name|MIN_END_KEEP
value|4
end_define

begin_function
name|private
name|void
name|re_update_line
parameter_list|(
name|el
parameter_list|,
name|old
parameter_list|,
name|new
parameter_list|,
name|i
parameter_list|)
name|EditLine
modifier|*
name|el
decl_stmt|;
name|char
modifier|*
name|old
decl_stmt|,
decl|*
name|new
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|i
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|o
decl_stmt|,
modifier|*
name|n
decl_stmt|,
modifier|*
name|p
decl_stmt|,
name|c
decl_stmt|;
name|char
modifier|*
name|ofd
decl_stmt|,
modifier|*
name|ols
decl_stmt|,
modifier|*
name|oe
decl_stmt|,
modifier|*
name|nfd
decl_stmt|,
modifier|*
name|nls
decl_stmt|,
modifier|*
name|ne
decl_stmt|;
name|char
modifier|*
name|osb
decl_stmt|,
modifier|*
name|ose
decl_stmt|,
modifier|*
name|nsb
decl_stmt|,
modifier|*
name|nse
decl_stmt|;
name|int
name|fx
decl_stmt|,
name|sx
decl_stmt|;
comment|/*      * find first diff      */
for|for
control|(
name|o
operator|=
name|old
operator|,
name|n
operator|=
name|new
init|;
operator|*
name|o
operator|&&
operator|(
operator|*
name|o
operator|==
operator|*
name|n
operator|)
condition|;
name|o
operator|++
operator|,
name|n
operator|++
control|)
continue|continue;
name|ofd
operator|=
name|o
expr_stmt|;
name|nfd
operator|=
name|n
expr_stmt|;
comment|/*      * Find the end of both old and new      */
while|while
condition|(
operator|*
name|o
condition|)
name|o
operator|++
expr_stmt|;
comment|/*      * Remove any trailing blanks off of the end, being careful not to      * back up past the beginning.      */
while|while
condition|(
name|ofd
operator|<
name|o
condition|)
block|{
if|if
condition|(
name|o
index|[
operator|-
literal|1
index|]
operator|!=
literal|' '
condition|)
break|break;
name|o
operator|--
expr_stmt|;
block|}
name|oe
operator|=
name|o
expr_stmt|;
operator|*
name|oe
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|n
condition|)
name|n
operator|++
expr_stmt|;
comment|/* remove blanks from end of new */
while|while
condition|(
name|nfd
operator|<
name|n
condition|)
block|{
if|if
condition|(
name|n
index|[
operator|-
literal|1
index|]
operator|!=
literal|' '
condition|)
break|break;
name|n
operator|--
expr_stmt|;
block|}
name|ne
operator|=
name|n
expr_stmt|;
operator|*
name|ne
operator|=
literal|'\0'
expr_stmt|;
comment|/*      * if no diff, continue to next line of redraw      */
if|if
condition|(
operator|*
name|ofd
operator|==
literal|'\0'
operator|&&
operator|*
name|nfd
operator|==
literal|'\0'
condition|)
block|{
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"no difference.\r\n"
operator|)
argument_list|,)
expr_stmt|;
return|return;
block|}
comment|/*      * find last same pointer      */
while|while
condition|(
operator|(
name|o
operator|>
name|ofd
operator|)
operator|&&
operator|(
name|n
operator|>
name|nfd
operator|)
operator|&&
operator|(
operator|*
operator|--
name|o
operator|==
operator|*
operator|--
name|n
operator|)
condition|)
continue|continue;
name|ols
operator|=
operator|++
name|o
expr_stmt|;
name|nls
operator|=
operator|++
name|n
expr_stmt|;
comment|/*      * find same begining and same end      */
name|osb
operator|=
name|ols
expr_stmt|;
name|nsb
operator|=
name|nls
expr_stmt|;
name|ose
operator|=
name|ols
expr_stmt|;
name|nse
operator|=
name|nls
expr_stmt|;
comment|/*      * case 1: insert: scan from nfd to nls looking for *ofd      */
if|if
condition|(
operator|*
name|ofd
condition|)
block|{
for|for
control|(
name|c
operator|=
operator|*
name|ofd
operator|,
name|n
operator|=
name|nfd
init|;
name|n
operator|<
name|nls
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
operator|*
name|n
condition|)
block|{
for|for
control|(
name|o
operator|=
name|ofd
operator|,
name|p
operator|=
name|n
init|;
name|p
operator|<
name|nls
operator|&&
name|o
operator|<
name|ols
operator|&&
operator|*
name|o
operator|==
operator|*
name|p
condition|;
name|o
operator|++
operator|,
name|p
operator|++
control|)
continue|continue;
comment|/* 		 * if the new match is longer and it's worth keeping, then we 		 * take it 		 */
if|if
condition|(
operator|(
operator|(
name|nse
operator|-
name|nsb
operator|)
operator|<
operator|(
name|p
operator|-
name|n
operator|)
operator|)
operator|&&
operator|(
literal|2
operator|*
operator|(
name|p
operator|-
name|n
operator|)
operator|>
name|n
operator|-
name|nfd
operator|)
condition|)
block|{
name|nsb
operator|=
name|n
expr_stmt|;
name|nse
operator|=
name|p
expr_stmt|;
name|osb
operator|=
name|ofd
expr_stmt|;
name|ose
operator|=
name|o
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/*      * case 2: delete: scan from ofd to ols looking for *nfd      */
if|if
condition|(
operator|*
name|nfd
condition|)
block|{
for|for
control|(
name|c
operator|=
operator|*
name|nfd
operator|,
name|o
operator|=
name|ofd
init|;
name|o
operator|<
name|ols
condition|;
name|o
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
operator|*
name|o
condition|)
block|{
for|for
control|(
name|n
operator|=
name|nfd
operator|,
name|p
operator|=
name|o
init|;
name|p
operator|<
name|ols
operator|&&
name|n
operator|<
name|nls
operator|&&
operator|*
name|p
operator|==
operator|*
name|n
condition|;
name|p
operator|++
operator|,
name|n
operator|++
control|)
continue|continue;
comment|/* 		 * if the new match is longer and it's worth keeping, then we 		 * take it 		 */
if|if
condition|(
operator|(
operator|(
name|ose
operator|-
name|osb
operator|)
operator|<
operator|(
name|p
operator|-
name|o
operator|)
operator|)
operator|&&
operator|(
literal|2
operator|*
operator|(
name|p
operator|-
name|o
operator|)
operator|>
name|o
operator|-
name|ofd
operator|)
condition|)
block|{
name|nsb
operator|=
name|nfd
expr_stmt|;
name|nse
operator|=
name|n
expr_stmt|;
name|osb
operator|=
name|o
expr_stmt|;
name|ose
operator|=
name|p
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/*      * Pragmatics I: If old trailing whitespace or not enough characters to      * save to be worth it, then don't save the last same info.      */
if|if
condition|(
operator|(
name|oe
operator|-
name|ols
operator|)
operator|<
name|MIN_END_KEEP
condition|)
block|{
name|ols
operator|=
name|oe
expr_stmt|;
name|nls
operator|=
name|ne
expr_stmt|;
block|}
comment|/*      * Pragmatics II: if the terminal isn't smart enough, make the data dumber      * so the smart update doesn't try anything fancy      */
comment|/*      * fx is the number of characters we need to insert/delete: in the      * beginning to bring the two same begins together      */
name|fx
operator|=
operator|(
name|nsb
operator|-
name|nfd
operator|)
operator|-
operator|(
name|osb
operator|-
name|ofd
operator|)
expr_stmt|;
comment|/*      * sx is the number of characters we need to insert/delete: in the end to      * bring the two same last parts together      */
name|sx
operator|=
operator|(
name|nls
operator|-
name|nse
operator|)
operator|-
operator|(
name|ols
operator|-
name|ose
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|EL_CAN_INSERT
condition|)
block|{
if|if
condition|(
name|fx
operator|>
literal|0
condition|)
block|{
name|osb
operator|=
name|ols
expr_stmt|;
name|ose
operator|=
name|ols
expr_stmt|;
name|nsb
operator|=
name|nls
expr_stmt|;
name|nse
operator|=
name|nls
expr_stmt|;
block|}
if|if
condition|(
name|sx
operator|>
literal|0
condition|)
block|{
name|ols
operator|=
name|oe
expr_stmt|;
name|nls
operator|=
name|ne
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ols
operator|-
name|ofd
operator|)
operator|<
operator|(
name|nls
operator|-
name|nfd
operator|)
condition|)
block|{
name|ols
operator|=
name|oe
expr_stmt|;
name|nls
operator|=
name|ne
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|EL_CAN_DELETE
condition|)
block|{
if|if
condition|(
name|fx
operator|<
literal|0
condition|)
block|{
name|osb
operator|=
name|ols
expr_stmt|;
name|ose
operator|=
name|ols
expr_stmt|;
name|nsb
operator|=
name|nls
expr_stmt|;
name|nse
operator|=
name|nls
expr_stmt|;
block|}
if|if
condition|(
name|sx
operator|<
literal|0
condition|)
block|{
name|ols
operator|=
name|oe
expr_stmt|;
name|nls
operator|=
name|ne
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ols
operator|-
name|ofd
operator|)
operator|>
operator|(
name|nls
operator|-
name|nfd
operator|)
condition|)
block|{
name|ols
operator|=
name|oe
expr_stmt|;
name|nls
operator|=
name|ne
expr_stmt|;
block|}
block|}
comment|/*      * Pragmatics III: make sure the middle shifted pointers are correct if      * they don't point to anything (we may have moved ols or nls).      */
comment|/* if the change isn't worth it, don't bother */
comment|/* was: if (osb == ose) */
if|if
condition|(
operator|(
name|ose
operator|-
name|osb
operator|)
operator|<
name|MIN_END_KEEP
condition|)
block|{
name|osb
operator|=
name|ols
expr_stmt|;
name|ose
operator|=
name|ols
expr_stmt|;
name|nsb
operator|=
name|nls
expr_stmt|;
name|nse
operator|=
name|nls
expr_stmt|;
block|}
comment|/*      * Now that we are done with pragmatics we recompute fx, sx      */
name|fx
operator|=
operator|(
name|nsb
operator|-
name|nfd
operator|)
operator|-
operator|(
name|osb
operator|-
name|ofd
operator|)
expr_stmt|;
name|sx
operator|=
operator|(
name|nls
operator|-
name|nse
operator|)
operator|-
operator|(
name|ols
operator|-
name|ose
operator|)
expr_stmt|;
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"\n"
operator|)
argument_list|,)
expr_stmt|;
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"ofd %d, osb %d, ose %d, ols %d, oe %d\n"
operator|,
name|ofd
operator|-
name|old
operator|,
name|osb
operator|-
name|old
operator|,
name|ose
operator|-
name|old
operator|,
name|ols
operator|-
name|old
operator|,
name|oe
operator|-
name|old
operator|)
argument_list|,)
expr_stmt|;
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"nfd %d, nsb %d, nse %d, nls %d, ne %d\n"
operator|,
name|nfd
operator|-
name|new
operator|,
name|nsb
operator|-
name|new
operator|,
name|nse
operator|-
name|new
operator|,
name|nls
operator|-
name|new
operator|,
name|ne
operator|-
name|new
operator|)
argument_list|,)
expr_stmt|;
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"xxx-xxx:\"00000000001111111111222222222233333333334\"\r\n"
operator|)
argument_list|,)
expr_stmt|;
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"xxx-xxx:\"01234567890123456789012345678901234567890\"\r\n"
operator|)
argument_list|,)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG_REFRESH
name|re_printstr
argument_list|(
name|el
argument_list|,
literal|"old- oe"
argument_list|,
name|old
argument_list|,
name|oe
argument_list|)
expr_stmt|;
name|re_printstr
argument_list|(
name|el
argument_list|,
literal|"new- ne"
argument_list|,
name|new
argument_list|,
name|ne
argument_list|)
expr_stmt|;
name|re_printstr
argument_list|(
name|el
argument_list|,
literal|"old-ofd"
argument_list|,
name|old
argument_list|,
name|ofd
argument_list|)
expr_stmt|;
name|re_printstr
argument_list|(
name|el
argument_list|,
literal|"new-nfd"
argument_list|,
name|new
argument_list|,
name|nfd
argument_list|)
expr_stmt|;
name|re_printstr
argument_list|(
name|el
argument_list|,
literal|"ofd-osb"
argument_list|,
name|ofd
argument_list|,
name|osb
argument_list|)
expr_stmt|;
name|re_printstr
argument_list|(
name|el
argument_list|,
literal|"nfd-nsb"
argument_list|,
name|nfd
argument_list|,
name|nsb
argument_list|)
expr_stmt|;
name|re_printstr
argument_list|(
name|el
argument_list|,
literal|"osb-ose"
argument_list|,
name|osb
argument_list|,
name|ose
argument_list|)
expr_stmt|;
name|re_printstr
argument_list|(
name|el
argument_list|,
literal|"nsb-nse"
argument_list|,
name|nsb
argument_list|,
name|nse
argument_list|)
expr_stmt|;
name|re_printstr
argument_list|(
name|el
argument_list|,
literal|"ose-ols"
argument_list|,
name|ose
argument_list|,
name|ols
argument_list|)
expr_stmt|;
name|re_printstr
argument_list|(
name|el
argument_list|,
literal|"nse-nls"
argument_list|,
name|nse
argument_list|,
name|nls
argument_list|)
expr_stmt|;
name|re_printstr
argument_list|(
name|el
argument_list|,
literal|"ols- oe"
argument_list|,
name|ols
argument_list|,
name|oe
argument_list|)
expr_stmt|;
name|re_printstr
argument_list|(
name|el
argument_list|,
literal|"nls- ne"
argument_list|,
name|nls
argument_list|,
name|ne
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG_REFRESH */
comment|/*      * el_cursor.v to this line i MUST be in this routine so that if we      * don't have to change the line, we don't move to it. el_cursor.h to first      * diff char      */
name|term_move_to_line
argument_list|(
name|el
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/*      * at this point we have something like this:      *      * /old                  /ofd    /osb               /ose    /ols     /oe      * v.....................v       v..................v       v........v      * eddie> Oh, my fredded gruntle-buggy is to me, as foo var lurgid as      * eddie> Oh, my fredded quiux buggy is to me, as gruntle-lurgid as      * ^.....................^     ^..................^       ^........^      * \new                  \nfd  \nsb               \nse     \nls    \ne      *      * fx is the difference in length between the the chars between nfd and      * nsb, and the chars between ofd and osb, and is thus the number of      * characters to delete if< 0 (new is shorter than old, as above),      * or insert (new is longer than short).      *      * sx is the same for the second differences.      */
comment|/*      * if we have a net insert on the first difference, AND inserting the net      * amount ((nsb-nfd) - (osb-ofd)) won't push the last useful character      * (which is ne if nls != ne, otherwise is nse) off the edge of the screen      * (el->el_term.t_size.h) else we do the deletes first so that we keep everything we need      * to.      */
comment|/*      * if the last same is the same like the end, there is no last same part,      * otherwise we want to keep the last same part set p to the last useful      * old character      */
name|p
operator|=
operator|(
name|ols
operator|!=
name|oe
operator|)
condition|?
name|oe
else|:
name|ose
expr_stmt|;
comment|/*      * if (There is a diffence in the beginning)&& (we need to insert      * characters)&& (the number of characters to insert is less than the term      * width) We need to do an insert! else if (we need to delete characters)      * We need to delete characters! else No insert or delete      */
if|if
condition|(
operator|(
name|nsb
operator|!=
name|nfd
operator|)
operator|&&
name|fx
operator|>
literal|0
operator|&&
operator|(
operator|(
name|p
operator|-
name|old
operator|)
operator|+
name|fx
operator|<=
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|h
operator|)
condition|)
block|{
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"first diff insert at %d...\r\n"
operator|,
name|nfd
operator|-
name|new
operator|)
argument_list|,)
expr_stmt|;
comment|/* 	 * Move to the first char to insert, where the first diff is. 	 */
name|term_move_to_char
argument_list|(
name|el
argument_list|,
name|nfd
operator|-
name|new
argument_list|)
expr_stmt|;
comment|/* 	 * Check if we have stuff to keep at end 	 */
if|if
condition|(
name|nsb
operator|!=
name|ne
condition|)
block|{
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"with stuff to keep at end\r\n"
operator|)
argument_list|,)
expr_stmt|;
comment|/* 	     * insert fx chars of new starting at nfd 	     */
if|if
condition|(
name|fx
operator|>
literal|0
condition|)
block|{
name|RE_DEBUG
argument_list|(
operator|!
name|EL_CAN_INSERT
argument_list|,
operator|(
name|__F
operator|,
literal|"ERROR: cannot insert in early first diff\n"
operator|)
argument_list|,)
expr_stmt|;
name|term_insertwrite
argument_list|(
name|el
argument_list|,
name|nfd
argument_list|,
name|fx
argument_list|)
expr_stmt|;
name|re_insert
argument_list|(
name|el
argument_list|,
name|old
argument_list|,
name|ofd
operator|-
name|old
argument_list|,
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|h
argument_list|,
name|nfd
argument_list|,
name|fx
argument_list|)
expr_stmt|;
block|}
comment|/* 	     * write (nsb-nfd) - fx chars of new starting at (nfd + fx) 	     */
name|term_overwrite
argument_list|(
name|el
argument_list|,
name|nfd
operator|+
name|fx
argument_list|,
operator|(
name|nsb
operator|-
name|nfd
operator|)
operator|-
name|fx
argument_list|)
expr_stmt|;
name|re__strncopy
argument_list|(
name|ofd
operator|+
name|fx
argument_list|,
name|nfd
operator|+
name|fx
argument_list|,
operator|(
name|nsb
operator|-
name|nfd
operator|)
operator|-
name|fx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"without anything to save\r\n"
operator|)
argument_list|,)
expr_stmt|;
name|term_overwrite
argument_list|(
name|el
argument_list|,
name|nfd
argument_list|,
operator|(
name|nsb
operator|-
name|nfd
operator|)
argument_list|)
expr_stmt|;
name|re__strncopy
argument_list|(
name|ofd
argument_list|,
name|nfd
argument_list|,
operator|(
name|nsb
operator|-
name|nfd
operator|)
argument_list|)
expr_stmt|;
comment|/* 	     * Done 	     */
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|fx
operator|<
literal|0
condition|)
block|{
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"first diff delete at %d...\r\n"
operator|,
name|ofd
operator|-
name|old
operator|)
argument_list|,)
expr_stmt|;
comment|/* 	 * move to the first char to delete where the first diff is 	 */
name|term_move_to_char
argument_list|(
name|el
argument_list|,
name|ofd
operator|-
name|old
argument_list|)
expr_stmt|;
comment|/* 	 * Check if we have stuff to save 	 */
if|if
condition|(
name|osb
operator|!=
name|oe
condition|)
block|{
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"with stuff to save at end\r\n"
operator|)
argument_list|,)
expr_stmt|;
comment|/* 	     * fx is less than zero *always* here but we check for code 	     * symmetry 	     */
if|if
condition|(
name|fx
operator|<
literal|0
condition|)
block|{
name|RE_DEBUG
argument_list|(
operator|!
name|EL_CAN_DELETE
argument_list|,
operator|(
name|__F
operator|,
literal|"ERROR: cannot delete in first diff\n"
operator|)
argument_list|,)
expr_stmt|;
name|term_deletechars
argument_list|(
name|el
argument_list|,
operator|-
name|fx
argument_list|)
expr_stmt|;
name|re_delete
argument_list|(
name|el
argument_list|,
name|old
argument_list|,
name|ofd
operator|-
name|old
argument_list|,
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|h
argument_list|,
operator|-
name|fx
argument_list|)
expr_stmt|;
block|}
comment|/* 	     * write (nsb-nfd) chars of new starting at nfd 	     */
name|term_overwrite
argument_list|(
name|el
argument_list|,
name|nfd
argument_list|,
operator|(
name|nsb
operator|-
name|nfd
operator|)
argument_list|)
expr_stmt|;
name|re__strncopy
argument_list|(
name|ofd
argument_list|,
name|nfd
argument_list|,
operator|(
name|nsb
operator|-
name|nfd
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"but with nothing left to save\r\n"
operator|)
argument_list|,)
expr_stmt|;
comment|/* 	     * write (nsb-nfd) chars of new starting at nfd 	     */
name|term_overwrite
argument_list|(
name|el
argument_list|,
name|nfd
argument_list|,
operator|(
name|nsb
operator|-
name|nfd
operator|)
argument_list|)
expr_stmt|;
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"cleareol %d\n"
operator|,
operator|(
name|oe
operator|-
name|old
operator|)
operator|-
operator|(
name|ne
operator|-
name|new
operator|)
operator|)
argument_list|,)
expr_stmt|;
name|term_clear_EOL
argument_list|(
name|el
argument_list|,
operator|(
name|oe
operator|-
name|old
operator|)
operator|-
operator|(
name|ne
operator|-
name|new
operator|)
argument_list|)
expr_stmt|;
comment|/* 	     * Done 	     */
return|return;
block|}
block|}
else|else
name|fx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sx
operator|<
literal|0
condition|)
block|{
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"second diff delete at %d...\r\n"
operator|,
operator|(
name|ose
operator|-
name|old
operator|)
operator|+
name|fx
operator|)
argument_list|,)
expr_stmt|;
comment|/* 	 * Check if we have stuff to delete 	 */
comment|/* 	 * fx is the number of characters inserted (+) or deleted (-) 	 */
name|term_move_to_char
argument_list|(
name|el
argument_list|,
operator|(
name|ose
operator|-
name|old
operator|)
operator|+
name|fx
argument_list|)
expr_stmt|;
comment|/* 	 * Check if we have stuff to save 	 */
if|if
condition|(
name|ols
operator|!=
name|oe
condition|)
block|{
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"with stuff to save at end\r\n"
operator|)
argument_list|,)
expr_stmt|;
comment|/* 	     * Again a duplicate test. 	     */
if|if
condition|(
name|sx
operator|<
literal|0
condition|)
block|{
name|RE_DEBUG
argument_list|(
operator|!
name|EL_CAN_DELETE
argument_list|,
operator|(
name|__F
operator|,
literal|"ERROR: cannot delete in second diff\n"
operator|)
argument_list|,)
expr_stmt|;
name|term_deletechars
argument_list|(
name|el
argument_list|,
operator|-
name|sx
argument_list|)
expr_stmt|;
block|}
comment|/* 	     * write (nls-nse) chars of new starting at nse 	     */
name|term_overwrite
argument_list|(
name|el
argument_list|,
name|nse
argument_list|,
operator|(
name|nls
operator|-
name|nse
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"but with nothing left to save\r\n"
operator|)
argument_list|,)
expr_stmt|;
name|term_overwrite
argument_list|(
name|el
argument_list|,
name|nse
argument_list|,
operator|(
name|nls
operator|-
name|nse
operator|)
argument_list|)
expr_stmt|;
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"cleareol %d\n"
operator|,
operator|(
name|oe
operator|-
name|old
operator|)
operator|-
operator|(
name|ne
operator|-
name|new
operator|)
operator|)
argument_list|,)
expr_stmt|;
name|term_clear_EOL
argument_list|(
name|el
argument_list|,
operator|(
name|oe
operator|-
name|old
operator|)
operator|-
operator|(
name|ne
operator|-
name|new
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * if we have a first insert AND WE HAVEN'T ALREADY DONE IT...      */
if|if
condition|(
operator|(
name|nsb
operator|!=
name|nfd
operator|)
operator|&&
operator|(
name|osb
operator|-
name|ofd
operator|)
operator|<=
operator|(
name|nsb
operator|-
name|nfd
operator|)
operator|&&
operator|(
name|fx
operator|==
literal|0
operator|)
condition|)
block|{
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"late first diff insert at %d...\r\n"
operator|,
name|nfd
operator|-
name|new
operator|)
argument_list|,)
expr_stmt|;
name|term_move_to_char
argument_list|(
name|el
argument_list|,
name|nfd
operator|-
name|new
argument_list|)
expr_stmt|;
comment|/* 	 * Check if we have stuff to keep at the end 	 */
if|if
condition|(
name|nsb
operator|!=
name|ne
condition|)
block|{
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"with stuff to keep at end\r\n"
operator|)
argument_list|,)
expr_stmt|;
comment|/* 	     * We have to recalculate fx here because we set it 	     * to zero above as a flag saying that we hadn't done 	     * an early first insert. 	     */
name|fx
operator|=
operator|(
name|nsb
operator|-
name|nfd
operator|)
operator|-
operator|(
name|osb
operator|-
name|ofd
operator|)
expr_stmt|;
if|if
condition|(
name|fx
operator|>
literal|0
condition|)
block|{
comment|/* 		 * insert fx chars of new starting at nfd 		 */
name|RE_DEBUG
argument_list|(
operator|!
name|EL_CAN_INSERT
argument_list|,
operator|(
name|__F
operator|,
literal|"ERROR: cannot insert in late first diff\n"
operator|)
argument_list|,)
expr_stmt|;
name|term_insertwrite
argument_list|(
name|el
argument_list|,
name|nfd
argument_list|,
name|fx
argument_list|)
expr_stmt|;
name|re_insert
argument_list|(
name|el
argument_list|,
name|old
argument_list|,
name|ofd
operator|-
name|old
argument_list|,
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|h
argument_list|,
name|nfd
argument_list|,
name|fx
argument_list|)
expr_stmt|;
block|}
comment|/* 	     * write (nsb-nfd) - fx chars of new starting at (nfd + fx) 	     */
name|term_overwrite
argument_list|(
name|el
argument_list|,
name|nfd
operator|+
name|fx
argument_list|,
operator|(
name|nsb
operator|-
name|nfd
operator|)
operator|-
name|fx
argument_list|)
expr_stmt|;
name|re__strncopy
argument_list|(
name|ofd
operator|+
name|fx
argument_list|,
name|nfd
operator|+
name|fx
argument_list|,
operator|(
name|nsb
operator|-
name|nfd
operator|)
operator|-
name|fx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"without anything to save\r\n"
operator|)
argument_list|,)
expr_stmt|;
name|term_overwrite
argument_list|(
name|el
argument_list|,
name|nfd
argument_list|,
operator|(
name|nsb
operator|-
name|nfd
operator|)
argument_list|)
expr_stmt|;
name|re__strncopy
argument_list|(
name|ofd
argument_list|,
name|nfd
argument_list|,
operator|(
name|nsb
operator|-
name|nfd
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*      * line is now NEW up to nse      */
if|if
condition|(
name|sx
operator|>=
literal|0
condition|)
block|{
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"second diff insert at %d...\r\n"
operator|,
name|nse
operator|-
name|new
operator|)
argument_list|,)
expr_stmt|;
name|term_move_to_char
argument_list|(
name|el
argument_list|,
name|nse
operator|-
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|ols
operator|!=
name|oe
condition|)
block|{
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"with stuff to keep at end\r\n"
operator|)
argument_list|,)
expr_stmt|;
if|if
condition|(
name|sx
operator|>
literal|0
condition|)
block|{
comment|/* insert sx chars of new starting at nse */
name|RE_DEBUG
argument_list|(
operator|!
name|EL_CAN_INSERT
argument_list|,
operator|(
name|__F
operator|,
literal|"ERROR: cannot insert in second diff\n"
operator|)
argument_list|,)
expr_stmt|;
name|term_insertwrite
argument_list|(
name|el
argument_list|,
name|nse
argument_list|,
name|sx
argument_list|)
expr_stmt|;
block|}
comment|/* 	     * write (nls-nse) - sx chars of new starting at (nse + sx) 	     */
name|term_overwrite
argument_list|(
name|el
argument_list|,
name|nse
operator|+
name|sx
argument_list|,
operator|(
name|nls
operator|-
name|nse
operator|)
operator|-
name|sx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"without anything to save\r\n"
operator|)
argument_list|,)
expr_stmt|;
name|term_overwrite
argument_list|(
name|el
argument_list|,
name|nse
argument_list|,
operator|(
name|nls
operator|-
name|nse
operator|)
argument_list|)
expr_stmt|;
comment|/*              * No need to do a clear-to-end here because we were doing 	     * a second insert, so we will have over written all of the 	     * old string. 	     */
block|}
block|}
name|RE_DEBUG
argument_list|(
literal|1
argument_list|,
operator|(
name|__F
operator|,
literal|"done.\r\n"
operator|)
argument_list|,)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* re_update_line */
end_comment

begin_comment
comment|/* re__copy_and_pad():  *	Copy string and pad with spaces  */
end_comment

begin_function
name|private
name|void
name|re__copy_and_pad
parameter_list|(
name|dst
parameter_list|,
name|src
parameter_list|,
name|width
parameter_list|)
name|char
modifier|*
name|dst
decl_stmt|,
decl|*
name|src
decl_stmt|;
end_function

begin_decl_stmt
name|size_t
name|width
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|width
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|src
operator|==
literal|'\0'
condition|)
break|break;
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|<
name|width
condition|)
block|{
operator|*
name|dst
operator|++
operator|=
literal|' '
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
operator|*
name|dst
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_comment
comment|/* end re__copy_and_pad */
end_comment

begin_comment
comment|/* re_refresh_cursor():  *	Move to the new cursor position  */
end_comment

begin_function
name|protected
name|void
name|re_refresh_cursor
parameter_list|(
name|el
parameter_list|)
name|EditLine
modifier|*
name|el
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|h
decl_stmt|,
name|v
decl_stmt|,
name|th
decl_stmt|;
comment|/* first we must find where the cursor is... */
name|h
operator|=
name|el
operator|->
name|el_prompt
operator|.
name|p_pos
operator|.
name|h
expr_stmt|;
name|v
operator|=
name|el
operator|->
name|el_prompt
operator|.
name|p_pos
operator|.
name|v
expr_stmt|;
name|th
operator|=
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|h
expr_stmt|;
comment|/* optimize for speed 		*/
comment|/* do input buffer to el->el_line.cursor */
for|for
control|(
name|cp
operator|=
name|el
operator|->
name|el_line
operator|.
name|buffer
init|;
name|cp
operator|<
name|el
operator|->
name|el_line
operator|.
name|cursor
condition|;
name|cp
operator|++
control|)
block|{
name|c
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
expr_stmt|;
name|h
operator|++
expr_stmt|;
comment|/* all chars at least this long */
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
comment|/* handle newline in data part too */
name|h
operator|=
literal|0
expr_stmt|;
name|v
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
comment|/* if a tab, to next tab stop */
while|while
condition|(
name|h
operator|&
literal|07
condition|)
block|{
name|h
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|iscntrl
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* if control char */
name|h
operator|++
expr_stmt|;
if|if
condition|(
name|h
operator|>
name|th
condition|)
block|{
comment|/* if overflow, compensate */
name|h
operator|=
literal|1
expr_stmt|;
name|v
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|h
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|h
operator|>
name|th
condition|)
block|{
comment|/* if overflow, compensate */
name|h
operator|=
name|h
operator|-
name|th
expr_stmt|;
name|v
operator|++
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|h
operator|>=
name|th
condition|)
block|{
comment|/* check, extra long tabs picked up here also */
name|h
operator|=
literal|0
expr_stmt|;
name|v
operator|++
expr_stmt|;
block|}
block|}
comment|/* now go there */
name|term_move_to_line
argument_list|(
name|el
argument_list|,
name|v
argument_list|)
expr_stmt|;
name|term_move_to_char
argument_list|(
name|el
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|term__flush
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* re_refresh_cursor */
end_comment

begin_comment
comment|/* re_fastputc():  *	Add a character fast.  */
end_comment

begin_function
name|private
name|void
name|re_fastputc
parameter_list|(
name|el
parameter_list|,
name|c
parameter_list|)
name|EditLine
modifier|*
name|el
decl_stmt|;
name|int
name|c
decl_stmt|;
block|{
name|term__putc
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|el
operator|->
name|el_display
index|[
name|el
operator|->
name|el_cursor
operator|.
name|v
index|]
index|[
name|el
operator|->
name|el_cursor
operator|.
name|h
operator|++
index|]
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|el
operator|->
name|el_cursor
operator|.
name|h
operator|>=
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|h
condition|)
block|{
comment|/* if we must overflow */
name|el
operator|->
name|el_cursor
operator|.
name|h
operator|=
literal|0
expr_stmt|;
name|el
operator|->
name|el_cursor
operator|.
name|v
operator|++
expr_stmt|;
name|el
operator|->
name|el_refresh
operator|.
name|r_oldcv
operator|++
expr_stmt|;
name|term__putc
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|term__putc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* end re_fastputc */
end_comment

begin_comment
comment|/* re_fastaddc():  *	we added just one char, handle it fast.  *	Assumes that screen cursor == real cursor  */
end_comment

begin_function
name|protected
name|void
name|re_fastaddc
parameter_list|(
name|el
parameter_list|)
name|EditLine
modifier|*
name|el
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
operator|(
name|unsigned
name|char
operator|)
name|el
operator|->
name|el_line
operator|.
name|cursor
index|[
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\t'
operator|||
name|el
operator|->
name|el_line
operator|.
name|cursor
operator|!=
name|el
operator|->
name|el_line
operator|.
name|lastchar
condition|)
block|{
name|re_refresh
argument_list|(
name|el
argument_list|)
expr_stmt|;
comment|/* too hard to handle */
return|return;
block|}
comment|/* else (only do at end of line, no TAB) */
if|if
condition|(
name|iscntrl
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* if control char, do caret */
name|char
name|mc
init|=
operator|(
name|c
operator|==
literal|0177
operator|)
condition|?
literal|'?'
else|:
operator|(
name|toascii
argument_list|(
name|c
argument_list|)
operator||
literal|0100
operator|)
decl_stmt|;
name|re_fastputc
argument_list|(
name|el
argument_list|,
literal|'^'
argument_list|)
expr_stmt|;
name|re_fastputc
argument_list|(
name|el
argument_list|,
name|mc
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* normal char */
name|re_fastputc
argument_list|(
name|el
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|re_fastputc
argument_list|(
name|el
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
name|re_fastputc
argument_list|(
name|el
argument_list|,
operator|(
operator|(
name|c
operator|>>
literal|6
operator|)
operator|&
literal|7
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|re_fastputc
argument_list|(
name|el
argument_list|,
operator|(
operator|(
name|c
operator|>>
literal|3
operator|)
operator|&
literal|7
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
name|re_fastputc
argument_list|(
name|el
argument_list|,
operator|(
name|c
operator|&
literal|7
operator|)
operator|+
literal|'0'
argument_list|)
expr_stmt|;
block|}
name|term__flush
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end re_fastaddc */
end_comment

begin_comment
comment|/* re_clear_display():  *	clear the screen buffers so that new new prompt starts fresh.  */
end_comment

begin_function
name|protected
name|void
name|re_clear_display
parameter_list|(
name|el
parameter_list|)
name|EditLine
modifier|*
name|el
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|el
operator|->
name|el_cursor
operator|.
name|v
operator|=
literal|0
expr_stmt|;
name|el
operator|->
name|el_cursor
operator|.
name|h
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|v
condition|;
name|i
operator|++
control|)
name|el
operator|->
name|el_display
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|el
operator|->
name|el_refresh
operator|.
name|r_oldcv
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* end re_clear_display */
end_comment

begin_comment
comment|/* re_clear_lines():  *	Make sure all lines are *really* blank  */
end_comment

begin_function
name|protected
name|void
name|re_clear_lines
parameter_list|(
name|el
parameter_list|)
name|EditLine
modifier|*
name|el
decl_stmt|;
block|{
if|if
condition|(
name|EL_CAN_CEOL
condition|)
block|{
name|int
name|i
decl_stmt|;
name|term_move_to_char
argument_list|(
name|el
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|el
operator|->
name|el_refresh
operator|.
name|r_oldcv
condition|;
name|i
operator|++
control|)
block|{
comment|/* for each line on the screen */
name|term_move_to_line
argument_list|(
name|el
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|term_clear_EOL
argument_list|(
name|el
argument_list|,
name|el
operator|->
name|el_term
operator|.
name|t_size
operator|.
name|h
argument_list|)
expr_stmt|;
block|}
name|term_move_to_line
argument_list|(
name|el
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|term_move_to_line
argument_list|(
name|el
argument_list|,
name|el
operator|->
name|el_refresh
operator|.
name|r_oldcv
argument_list|)
expr_stmt|;
comment|/* go to last line */
name|term__putc
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
comment|/* go to BOL */
name|term__putc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* go to new line */
block|}
block|}
end_function

begin_comment
comment|/* end re_clear_lines */
end_comment

end_unit

