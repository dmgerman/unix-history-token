begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: readline.c,v 1.113 2014/10/18 08:33:23 snj Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 1997 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by Jaromir Dolecek.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS  * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SCCSID
argument_list|)
end_if

begin_expr_stmt
name|__RCSID
argument_list|(
literal|"$NetBSD: readline.c,v 1.113 2014/10/18 08:33:23 snj Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint&& not SCCSID */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<vis.h>
end_include

begin_include
include|#
directive|include
file|"readline/readline.h"
end_include

begin_include
include|#
directive|include
file|"el.h"
end_include

begin_include
include|#
directive|include
file|"fcns.h"
end_include

begin_comment
comment|/* for EL_NUM_FCNS */
end_comment

begin_include
include|#
directive|include
file|"histedit.h"
end_include

begin_include
include|#
directive|include
file|"filecomplete.h"
end_include

begin_function_decl
name|void
name|rl_prep_terminal
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|rl_deprep_terminal
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* for rl_complete() */
end_comment

begin_define
define|#
directive|define
name|TAB
value|'\r'
end_define

begin_comment
comment|/* see comment at the #ifdef for sense of this */
end_comment

begin_comment
comment|/* #define GDB_411_HACK */
end_comment

begin_comment
comment|/* readline compatibility stuff - look at readline sources/documentation */
end_comment

begin_comment
comment|/* to see what these variables mean */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|rl_library_version
init|=
literal|"EditLine wrapper"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rl_readline_version
init|=
name|RL_READLINE_VERSION
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|empty
index|[]
init|=
block|{
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|expand_chars
index|[]
init|=
block|{
literal|' '
block|,
literal|'\t'
block|,
literal|'\n'
block|,
literal|'='
block|,
literal|'('
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|break_chars
index|[]
init|=
block|{
literal|' '
block|,
literal|'\t'
block|,
literal|'\n'
block|,
literal|'"'
block|,
literal|'\\'
block|,
literal|'\''
block|,
literal|'`'
block|,
literal|'@'
block|,
literal|'$'
block|,
literal|'>'
block|,
literal|'<'
block|,
literal|'='
block|,
literal|';'
block|,
literal|'|'
block|,
literal|'&'
block|,
literal|'{'
block|,
literal|'('
block|,
literal|'\0'
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|rl_readline_name
init|=
name|empty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|rl_instream
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|rl_outstream
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rl_point
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rl_end
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|rl_line_buffer
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VCPFunction
modifier|*
name|rl_linefunc
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rl_done
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VFunction
modifier|*
name|rl_event_hook
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|KEYMAP_ENTRY_ARRAY
name|emacs_standard_keymap
decl_stmt|,
name|emacs_meta_keymap
decl_stmt|,
name|emacs_ctlx_keymap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The following is not implemented; we always catch signals in the  * libedit fashion: set handlers on entry to el_gets() and clear them  * on the way out. This simplistic approach works for most cases; if  * it does not work for your application, please let us know.  */
end_comment

begin_decl_stmt
name|int
name|rl_catch_signals
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rl_catch_sigwinch
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|history_base
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* probably never subject to change */
end_comment

begin_decl_stmt
name|int
name|history_length
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|max_input_history
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|history_expansion_char
init|=
literal|'!'
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|history_subst_char
init|=
literal|'^'
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|history_no_expand_chars
init|=
name|expand_chars
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Function
modifier|*
name|history_inhibit_expansion_function
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|history_arg_extract
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|rl_inhibit_completion
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rl_attempted_completion_over
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|rl_basic_word_break_characters
init|=
name|break_chars
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|rl_completer_word_break_characters
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|rl_completer_quote_characters
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Function
modifier|*
name|rl_completion_entry_function
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
function_decl|(
modifier|*
name|rl_completion_word_break_hook
function_decl|)
parameter_list|(
name|void
parameter_list|)
init|=
name|NULL
function_decl|;
end_function_decl

begin_decl_stmt
name|CPPFunction
modifier|*
name|rl_attempted_completion_function
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Function
modifier|*
name|rl_pre_input_hook
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Function
modifier|*
name|rl_startup1_hook
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|rl_getc_function
function_decl|)
parameter_list|(
name|FILE
modifier|*
parameter_list|)
init|=
name|NULL
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|rl_terminal_name
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rl_already_prompted
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rl_filename_completion_desired
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rl_ignore_completion_duplicates
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|readline_echoing_p
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|_rl_print_completions_horizontally
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VFunction
modifier|*
name|rl_redisplay_function
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Function
modifier|*
name|rl_startup_hook
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VFunction
modifier|*
name|rl_completion_display_matches_hook
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VFunction
modifier|*
name|rl_prep_term_function
init|=
operator|(
name|VFunction
operator|*
operator|)
name|rl_prep_terminal
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|VFunction
modifier|*
name|rl_deprep_term_function
init|=
operator|(
name|VFunction
operator|*
operator|)
name|rl_deprep_terminal
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|KEYMAP_ENTRY_ARRAY
name|emacs_meta_keymap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The current prompt string.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rl_prompt
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is set to character indicating type of completion being done by  * rl_complete_internal(); this is available for application completion  * functions.  */
end_comment

begin_decl_stmt
name|int
name|rl_completion_type
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * If more than this number of items results from query for possible  * completions, we ask user if they are sure to really display the list.  */
end_comment

begin_decl_stmt
name|int
name|rl_completion_query_items
init|=
literal|100
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * List of characters which are word break characters, but should be left  * in the parsed text when it is passed to the completion function.  * Shell uses this to help determine what kind of completing to do.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|rl_special_prefixes
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This is the character appended to the completed words if at the end of  * the line. Default is ' ' (a space).  */
end_comment

begin_decl_stmt
name|int
name|rl_completion_append_character
init|=
literal|' '
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stuff below is used internally by libedit for readline emulation */
end_comment

begin_decl_stmt
specifier|static
name|History
modifier|*
name|h
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|EditLine
modifier|*
name|e
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Function
modifier|*
name|map
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|jmp_buf
name|topbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* internal functions */
end_comment

begin_function_decl
specifier|static
name|unsigned
name|char
name|_el_rl_complete
parameter_list|(
name|EditLine
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|char
name|_el_rl_tstp
parameter_list|(
name|EditLine
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|_get_prompt
parameter_list|(
name|EditLine
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_getc_function
parameter_list|(
name|EditLine
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|HIST_ENTRY
modifier|*
name|_move_history
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_history_expand_command
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|size_t
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|_rl_compat_sub
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|_rl_event_read_char
parameter_list|(
name|EditLine
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|_rl_update_pos
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ARGSUSED */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|_get_prompt
argument_list|(
name|EditLine
operator|*
name|el
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|)
block|{
name|rl_already_prompted
operator|=
literal|1
expr_stmt|;
return|return
name|rl_prompt
return|;
block|}
end_decl_stmt

begin_comment
comment|/*  * generic function for moving around history  */
end_comment

begin_function
specifier|static
name|HIST_ENTRY
modifier|*
name|_move_history
parameter_list|(
name|int
name|op
parameter_list|)
block|{
name|HistEvent
name|ev
decl_stmt|;
specifier|static
name|HIST_ENTRY
name|rl_he
decl_stmt|;
if|if
condition|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|op
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
name|rl_he
operator|.
name|line
operator|=
name|ev
operator|.
name|str
expr_stmt|;
name|rl_he
operator|.
name|data
operator|=
name|NULL
expr_stmt|;
return|return
operator|&
name|rl_he
return|;
block|}
end_function

begin_comment
comment|/*  * read one key from user defined input function  */
end_comment

begin_decl_stmt
specifier|static
name|int
comment|/*ARGSUSED*/
name|_getc_function
argument_list|(
name|EditLine
operator|*
name|el
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|,
name|char
operator|*
name|c
argument_list|)
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
call|(
modifier|*
name|rl_getc_function
call|)
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
return|return
literal|0
return|;
operator|*
name|c
operator|=
operator|(
name|char
operator|)
name|i
expr_stmt|;
return|return
literal|1
return|;
block|}
end_decl_stmt

begin_function
specifier|static
name|void
name|_resize_fun
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|,
name|void
modifier|*
name|a
parameter_list|)
block|{
specifier|const
name|LineInfo
modifier|*
name|li
decl_stmt|;
name|char
modifier|*
modifier|*
name|ap
init|=
name|a
decl_stmt|;
name|li
operator|=
name|el_line
argument_list|(
name|el
argument_list|)
expr_stmt|;
comment|/* a cheesy way to get rid of const cast. */
operator|*
name|ap
operator|=
name|memchr
argument_list|(
name|li
operator|->
name|buffer
argument_list|,
operator|*
name|li
operator|->
name|buffer
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|_default_history_file
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|passwd
modifier|*
name|p
decl_stmt|;
specifier|static
name|char
modifier|*
name|path
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|path
condition|)
return|return
name|path
return|;
if|if
condition|(
operator|(
name|p
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|len
operator|=
name|strlen
argument_list|(
name|p
operator|->
name|pw_dir
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
literal|"/.history"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|path
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|path
argument_list|,
name|len
argument_list|,
literal|"%s/.history"
argument_list|,
name|p
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
return|return
name|path
return|;
block|}
end_function

begin_comment
comment|/*  * READLINE compatibility stuff  */
end_comment

begin_comment
comment|/*  * Set the prompt  */
end_comment

begin_function
name|int
name|rl_set_prompt
parameter_list|(
specifier|const
name|char
modifier|*
name|prompt
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|prompt
condition|)
name|prompt
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|rl_prompt
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|rl_prompt
argument_list|,
name|prompt
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|rl_prompt
condition|)
name|el_free
argument_list|(
name|rl_prompt
argument_list|)
expr_stmt|;
name|rl_prompt
operator|=
name|strdup
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl_prompt
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
while|while
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|rl_prompt
argument_list|,
name|RL_PROMPT_END_IGNORE
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
name|RL_PROMPT_START_IGNORE
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * initialize rl compat stuff  */
end_comment

begin_function
name|int
name|rl_initialize
parameter_list|(
name|void
parameter_list|)
block|{
name|HistEvent
name|ev
decl_stmt|;
name|int
name|editmode
init|=
literal|1
decl_stmt|;
name|struct
name|termios
name|t
decl_stmt|;
if|if
condition|(
name|e
operator|!=
name|NULL
condition|)
name|el_end
argument_list|(
name|e
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|history_end
argument_list|(
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rl_instream
condition|)
name|rl_instream
operator|=
name|stdin
expr_stmt|;
if|if
condition|(
operator|!
name|rl_outstream
condition|)
name|rl_outstream
operator|=
name|stdout
expr_stmt|;
comment|/* 	 * See if we don't really want to run the editor 	 */
if|if
condition|(
name|tcgetattr
argument_list|(
name|fileno
argument_list|(
name|rl_instream
argument_list|)
argument_list|,
operator|&
name|t
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|t
operator|.
name|c_lflag
operator|&
name|ECHO
operator|)
operator|==
literal|0
condition|)
name|editmode
operator|=
literal|0
expr_stmt|;
name|e
operator|=
name|el_init
argument_list|(
name|rl_readline_name
argument_list|,
name|rl_instream
argument_list|,
name|rl_outstream
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|editmode
condition|)
name|el_set
argument_list|(
name|e
argument_list|,
name|EL_EDITMODE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|h
operator|=
name|history_init
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|e
operator|||
operator|!
name|h
condition|)
return|return
operator|-
literal|1
return|;
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_SETSIZE
argument_list|,
name|INT_MAX
argument_list|)
expr_stmt|;
comment|/* unlimited */
name|history_length
operator|=
literal|0
expr_stmt|;
name|max_input_history
operator|=
name|INT_MAX
expr_stmt|;
name|el_set
argument_list|(
name|e
argument_list|,
name|EL_HIST
argument_list|,
name|history
argument_list|,
name|h
argument_list|)
expr_stmt|;
comment|/* Setup resize function */
name|el_set
argument_list|(
name|e
argument_list|,
name|EL_RESIZE
argument_list|,
name|_resize_fun
argument_list|,
operator|&
name|rl_line_buffer
argument_list|)
expr_stmt|;
comment|/* setup getc function if valid */
if|if
condition|(
name|rl_getc_function
condition|)
name|el_set
argument_list|(
name|e
argument_list|,
name|EL_GETCFN
argument_list|,
name|_getc_function
argument_list|)
expr_stmt|;
comment|/* for proper prompt printing in readline() */
if|if
condition|(
name|rl_set_prompt
argument_list|(
literal|""
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|history_end
argument_list|(
name|h
argument_list|)
expr_stmt|;
name|el_end
argument_list|(
name|e
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|el_set
argument_list|(
name|e
argument_list|,
name|EL_PROMPT
argument_list|,
name|_get_prompt
argument_list|,
name|RL_PROMPT_START_IGNORE
argument_list|)
expr_stmt|;
name|el_set
argument_list|(
name|e
argument_list|,
name|EL_SIGNAL
argument_list|,
name|rl_catch_signals
argument_list|)
expr_stmt|;
comment|/* set default mode to "emacs"-style and read setting afterwards */
comment|/* so this can be overridden */
name|el_set
argument_list|(
name|e
argument_list|,
name|EL_EDITOR
argument_list|,
literal|"emacs"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl_terminal_name
operator|!=
name|NULL
condition|)
name|el_set
argument_list|(
name|e
argument_list|,
name|EL_TERMINAL
argument_list|,
name|rl_terminal_name
argument_list|)
expr_stmt|;
else|else
name|el_get
argument_list|(
name|e
argument_list|,
name|EL_TERMINAL
argument_list|,
operator|&
name|rl_terminal_name
argument_list|)
expr_stmt|;
comment|/* 	 * Word completion - this has to go AFTER rebinding keys 	 * to emacs-style. 	 */
name|el_set
argument_list|(
name|e
argument_list|,
name|EL_ADDFN
argument_list|,
literal|"rl_complete"
argument_list|,
literal|"ReadLine compatible completion function"
argument_list|,
name|_el_rl_complete
argument_list|)
expr_stmt|;
name|el_set
argument_list|(
name|e
argument_list|,
name|EL_BIND
argument_list|,
literal|"^I"
argument_list|,
literal|"rl_complete"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Send TSTP when ^Z is pressed. 	 */
name|el_set
argument_list|(
name|e
argument_list|,
name|EL_ADDFN
argument_list|,
literal|"rl_tstp"
argument_list|,
literal|"ReadLine compatible suspend function"
argument_list|,
name|_el_rl_tstp
argument_list|)
expr_stmt|;
name|el_set
argument_list|(
name|e
argument_list|,
name|EL_BIND
argument_list|,
literal|"^Z"
argument_list|,
literal|"rl_tstp"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* read settings from configuration file */
name|el_source
argument_list|(
name|e
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Unfortunately, some applications really do use rl_point 	 * and rl_line_buffer directly. 	 */
name|_resize_fun
argument_list|(
name|e
argument_list|,
operator|&
name|rl_line_buffer
argument_list|)
expr_stmt|;
name|_rl_update_pos
argument_list|()
expr_stmt|;
if|if
condition|(
name|rl_startup_hook
condition|)
call|(
modifier|*
name|rl_startup_hook
call|)
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * read one line from input stream and return it, chomping  * trailing newline (if there is any)  */
end_comment

begin_function
name|char
modifier|*
name|readline
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
name|HistEvent
name|ev
decl_stmt|;
specifier|const
name|char
modifier|*
specifier|volatile
name|prompt
init|=
name|p
decl_stmt|;
name|int
name|count
decl_stmt|;
specifier|const
name|char
modifier|*
name|ret
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
specifier|static
name|int
name|used_event_hook
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
operator|||
name|h
operator|==
name|NULL
condition|)
name|rl_initialize
argument_list|()
expr_stmt|;
name|rl_done
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|setjmp
argument_list|(
name|topbuf
argument_list|)
expr_stmt|;
comment|/* update prompt accordingly to what has been passed */
if|if
condition|(
name|rl_set_prompt
argument_list|(
name|prompt
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|rl_pre_input_hook
condition|)
call|(
modifier|*
name|rl_pre_input_hook
call|)
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rl_event_hook
operator|&&
operator|!
operator|(
name|e
operator|->
name|el_flags
operator|&
name|NO_TTY
operator|)
condition|)
block|{
name|el_set
argument_list|(
name|e
argument_list|,
name|EL_GETCFN
argument_list|,
name|_rl_event_read_char
argument_list|)
expr_stmt|;
name|used_event_hook
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rl_event_hook
operator|&&
name|used_event_hook
condition|)
block|{
name|el_set
argument_list|(
name|e
argument_list|,
name|EL_GETCFN
argument_list|,
name|EL_BUILTIN_GETCFN
argument_list|)
expr_stmt|;
name|used_event_hook
operator|=
literal|0
expr_stmt|;
block|}
name|rl_already_prompted
operator|=
literal|0
expr_stmt|;
comment|/* get one line from input stream */
name|ret
operator|=
name|el_gets
argument_list|(
name|e
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|&&
name|count
operator|>
literal|0
condition|)
block|{
name|int
name|lastidx
decl_stmt|;
name|buf
operator|=
name|strdup
argument_list|(
name|ret
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|lastidx
operator|=
name|count
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|lastidx
index|]
operator|==
literal|'\n'
condition|)
name|buf
index|[
name|lastidx
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|buf
operator|=
name|NULL
expr_stmt|;
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_GETSIZE
argument_list|)
expr_stmt|;
name|history_length
operator|=
name|ev
operator|.
name|num
expr_stmt|;
return|return
name|buf
return|;
block|}
end_function

begin_comment
comment|/*  * history functions  */
end_comment

begin_comment
comment|/*  * is normally called before application starts to use  * history expansion functions  */
end_comment

begin_function
name|void
name|using_history
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|e
operator|==
name|NULL
condition|)
name|rl_initialize
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * substitute ``what'' with ``with'', returning resulting string; if  * globally == 1, substitutes all occurrences of what, otherwise only the  * first one  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|_rl_compat_sub
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|char
modifier|*
name|what
parameter_list|,
specifier|const
name|char
modifier|*
name|with
parameter_list|,
name|int
name|globally
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|r
decl_stmt|,
modifier|*
name|result
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|with_len
decl_stmt|,
name|what_len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|with_len
operator|=
name|strlen
argument_list|(
name|with
argument_list|)
expr_stmt|;
name|what_len
operator|=
name|strlen
argument_list|(
name|what
argument_list|)
expr_stmt|;
comment|/* calculate length we need for result */
name|s
operator|=
name|str
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
operator|*
name|what
operator|&&
operator|!
name|strncmp
argument_list|(
name|s
argument_list|,
name|what
argument_list|,
name|what_len
argument_list|)
condition|)
block|{
name|len
operator|+=
name|with_len
operator|-
name|what_len
expr_stmt|;
if|if
condition|(
operator|!
name|globally
condition|)
break|break;
name|s
operator|+=
name|what_len
expr_stmt|;
block|}
else|else
name|s
operator|++
expr_stmt|;
block|}
name|r
operator|=
name|result
operator|=
name|el_malloc
argument_list|(
operator|(
name|len
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|s
operator|=
name|str
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
operator|*
name|what
operator|&&
operator|!
name|strncmp
argument_list|(
name|s
argument_list|,
name|what
argument_list|,
name|what_len
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|r
argument_list|,
name|with
argument_list|,
name|with_len
argument_list|)
expr_stmt|;
name|r
operator|+=
name|with_len
expr_stmt|;
name|s
operator|+=
name|what_len
expr_stmt|;
if|if
condition|(
operator|!
name|globally
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|r
argument_list|,
name|s
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
else|else
operator|*
name|r
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
operator|*
name|r
operator|=
literal|'\0'
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_search_pat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last !?pat[?] search pattern */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|last_search_match
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last !?pat[?] that matched */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|get_history_event
parameter_list|(
specifier|const
name|char
modifier|*
name|cmd
parameter_list|,
name|int
modifier|*
name|cindex
parameter_list|,
name|int
name|qchar
parameter_list|)
block|{
name|int
name|idx
decl_stmt|,
name|sign
decl_stmt|,
name|sub
decl_stmt|,
name|num
decl_stmt|,
name|begin
decl_stmt|,
name|ret
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
name|pat
decl_stmt|;
specifier|const
name|char
modifier|*
name|rptr
decl_stmt|;
name|HistEvent
name|ev
decl_stmt|;
name|idx
operator|=
operator|*
name|cindex
expr_stmt|;
if|if
condition|(
name|cmd
index|[
name|idx
operator|++
index|]
operator|!=
name|history_expansion_char
condition|)
return|return
name|NULL
return|;
comment|/* find out which event to take */
if|if
condition|(
name|cmd
index|[
name|idx
index|]
operator|==
name|history_expansion_char
operator|||
name|cmd
index|[
name|idx
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_FIRST
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
operator|*
name|cindex
operator|=
name|cmd
index|[
name|idx
index|]
condition|?
operator|(
name|idx
operator|+
literal|1
operator|)
else|:
name|idx
expr_stmt|;
return|return
name|ev
operator|.
name|str
return|;
block|}
name|sign
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cmd
index|[
name|idx
index|]
operator|==
literal|'-'
condition|)
block|{
name|sign
operator|=
literal|1
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
if|if
condition|(
literal|'0'
operator|<=
name|cmd
index|[
name|idx
index|]
operator|&&
name|cmd
index|[
name|idx
index|]
operator|<=
literal|'9'
condition|)
block|{
name|HIST_ENTRY
modifier|*
name|rl_he
decl_stmt|;
name|num
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cmd
index|[
name|idx
index|]
operator|&&
literal|'0'
operator|<=
name|cmd
index|[
name|idx
index|]
operator|&&
name|cmd
index|[
name|idx
index|]
operator|<=
literal|'9'
condition|)
block|{
name|num
operator|=
name|num
operator|*
literal|10
operator|+
name|cmd
index|[
name|idx
index|]
operator|-
literal|'0'
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|sign
condition|)
name|num
operator|=
name|history_length
operator|-
name|num
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|rl_he
operator|=
name|history_get
argument_list|(
name|num
argument_list|)
operator|)
condition|)
return|return
name|NULL
return|;
operator|*
name|cindex
operator|=
name|idx
expr_stmt|;
return|return
name|rl_he
operator|->
name|line
return|;
block|}
name|sub
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cmd
index|[
name|idx
index|]
operator|==
literal|'?'
condition|)
block|{
name|sub
operator|=
literal|1
expr_stmt|;
name|idx
operator|++
expr_stmt|;
block|}
name|begin
operator|=
name|idx
expr_stmt|;
while|while
condition|(
name|cmd
index|[
name|idx
index|]
condition|)
block|{
if|if
condition|(
name|cmd
index|[
name|idx
index|]
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
name|sub
operator|&&
name|cmd
index|[
name|idx
index|]
operator|==
literal|'?'
condition|)
break|break;
if|if
condition|(
operator|!
name|sub
operator|&&
operator|(
name|cmd
index|[
name|idx
index|]
operator|==
literal|':'
operator|||
name|cmd
index|[
name|idx
index|]
operator|==
literal|' '
operator|||
name|cmd
index|[
name|idx
index|]
operator|==
literal|'\t'
operator|||
name|cmd
index|[
name|idx
index|]
operator|==
name|qchar
operator|)
condition|)
break|break;
name|idx
operator|++
expr_stmt|;
block|}
name|len
operator|=
operator|(
name|size_t
operator|)
name|idx
operator|-
operator|(
name|size_t
operator|)
name|begin
expr_stmt|;
if|if
condition|(
name|sub
operator|&&
name|cmd
index|[
name|idx
index|]
operator|==
literal|'?'
condition|)
name|idx
operator|++
expr_stmt|;
if|if
condition|(
name|sub
operator|&&
name|len
operator|==
literal|0
operator|&&
name|last_search_pat
operator|&&
operator|*
name|last_search_pat
condition|)
name|pat
operator|=
name|last_search_pat
expr_stmt|;
elseif|else
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
else|else
block|{
if|if
condition|(
operator|(
name|pat
operator|=
name|el_malloc
argument_list|(
operator|(
name|len
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|pat
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|pat
argument_list|,
name|cmd
operator|+
name|begin
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|pat
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|if
condition|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_CURR
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|pat
operator|!=
name|last_search_pat
condition|)
name|el_free
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|num
operator|=
name|ev
operator|.
name|num
expr_stmt|;
if|if
condition|(
name|sub
condition|)
block|{
if|if
condition|(
name|pat
operator|!=
name|last_search_pat
condition|)
block|{
if|if
condition|(
name|last_search_pat
condition|)
name|el_free
argument_list|(
name|last_search_pat
argument_list|)
expr_stmt|;
name|last_search_pat
operator|=
name|pat
expr_stmt|;
block|}
name|ret
operator|=
name|history_search
argument_list|(
name|pat
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|history_search_prefix
argument_list|(
name|pat
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
block|{
comment|/* restore to end of list on failed search */
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_FIRST
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"%s: Event not found\n"
argument_list|,
name|pat
argument_list|)
expr_stmt|;
if|if
condition|(
name|pat
operator|!=
name|last_search_pat
condition|)
name|el_free
argument_list|(
name|pat
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|sub
operator|&&
name|len
condition|)
block|{
if|if
condition|(
name|last_search_match
operator|&&
name|last_search_match
operator|!=
name|pat
condition|)
name|el_free
argument_list|(
name|last_search_match
argument_list|)
expr_stmt|;
name|last_search_match
operator|=
name|pat
expr_stmt|;
block|}
if|if
condition|(
name|pat
operator|!=
name|last_search_pat
condition|)
name|el_free
argument_list|(
name|pat
argument_list|)
expr_stmt|;
if|if
condition|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_CURR
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
operator|*
name|cindex
operator|=
name|idx
expr_stmt|;
name|rptr
operator|=
name|ev
operator|.
name|str
expr_stmt|;
comment|/* roll back to original position */
operator|(
name|void
operator|)
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_SET
argument_list|,
name|num
argument_list|)
expr_stmt|;
return|return
name|rptr
return|;
block|}
end_function

begin_comment
comment|/*  * the real function doing history expansion - takes as argument command  * to do and data upon which the command should be executed  * does expansion the way I've understood readline documentation  *  * returns 0 if data was not modified, 1 if it was and 2 if the string  * should be only printed and not executed; in case of error,  * returns -1 and *result points to NULL  * it's the caller's responsibility to free() the string returned in *result  */
end_comment

begin_function
specifier|static
name|int
name|_history_expand_command
parameter_list|(
specifier|const
name|char
modifier|*
name|command
parameter_list|,
name|size_t
name|offs
parameter_list|,
name|size_t
name|cmdlen
parameter_list|,
name|char
modifier|*
modifier|*
name|result
parameter_list|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|search
init|=
name|NULL
decl_stmt|,
modifier|*
name|aptr
decl_stmt|;
specifier|const
name|char
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|cmd
decl_stmt|;
specifier|static
name|char
modifier|*
name|from
init|=
name|NULL
decl_stmt|,
modifier|*
name|to
init|=
name|NULL
decl_stmt|;
name|int
name|start
decl_stmt|,
name|end
decl_stmt|,
name|idx
decl_stmt|,
name|has_mods
init|=
literal|0
decl_stmt|;
name|int
name|p_on
init|=
literal|0
decl_stmt|,
name|g_on
init|=
literal|0
decl_stmt|;
operator|*
name|result
operator|=
name|NULL
expr_stmt|;
name|aptr
operator|=
name|NULL
expr_stmt|;
name|ptr
operator|=
name|NULL
expr_stmt|;
comment|/* First get event specifier */
name|idx
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
literal|":^*$"
argument_list|,
name|command
index|[
name|offs
operator|+
literal|1
index|]
argument_list|)
condition|)
block|{
name|char
name|str
index|[
literal|4
index|]
decl_stmt|;
comment|/* 		* "!:" is shorthand for "!!:". 		* "!^", "!*" and "!$" are shorthand for 		* "!!:^", "!!:*" and "!!:$" respectively. 		*/
name|str
index|[
literal|0
index|]
operator|=
name|str
index|[
literal|1
index|]
operator|=
literal|'!'
expr_stmt|;
name|str
index|[
literal|2
index|]
operator|=
literal|'0'
expr_stmt|;
name|ptr
operator|=
name|get_history_event
argument_list|(
name|str
argument_list|,
operator|&
name|idx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|idx
operator|=
operator|(
name|command
index|[
name|offs
operator|+
literal|1
index|]
operator|==
literal|':'
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
name|has_mods
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|command
index|[
name|offs
operator|+
literal|1
index|]
operator|==
literal|'#'
condition|)
block|{
comment|/* use command so far */
if|if
condition|(
operator|(
name|aptr
operator|=
name|el_malloc
argument_list|(
operator|(
name|offs
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|aptr
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|aptr
argument_list|,
name|command
argument_list|,
name|offs
argument_list|)
expr_stmt|;
name|aptr
index|[
name|offs
index|]
operator|=
literal|'\0'
expr_stmt|;
name|idx
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|int
name|qchar
decl_stmt|;
name|qchar
operator|=
operator|(
name|offs
operator|>
literal|0
operator|&&
name|command
index|[
name|offs
operator|-
literal|1
index|]
operator|==
literal|'"'
operator|)
condition|?
literal|'"'
else|:
literal|0
expr_stmt|;
name|ptr
operator|=
name|get_history_event
argument_list|(
name|command
operator|+
name|offs
argument_list|,
operator|&
name|idx
argument_list|,
name|qchar
argument_list|)
expr_stmt|;
block|}
name|has_mods
operator|=
name|command
index|[
name|offs
operator|+
operator|(
name|size_t
operator|)
name|idx
index|]
operator|==
literal|':'
expr_stmt|;
block|}
if|if
condition|(
name|ptr
operator|==
name|NULL
operator|&&
name|aptr
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|!
name|has_mods
condition|)
block|{
operator|*
name|result
operator|=
name|strdup
argument_list|(
name|aptr
condition|?
name|aptr
else|:
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|aptr
condition|)
name|el_free
argument_list|(
name|aptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|result
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
return|return
literal|1
return|;
block|}
name|cmd
operator|=
name|command
operator|+
name|offs
operator|+
name|idx
operator|+
literal|1
expr_stmt|;
comment|/* Now parse any word designators */
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'%'
condition|)
comment|/* last word matched by ?pat? */
name|tmp
operator|=
name|strdup
argument_list|(
name|last_search_match
condition|?
name|last_search_match
else|:
literal|""
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strchr
argument_list|(
literal|"^*$-0123456789"
argument_list|,
operator|*
name|cmd
argument_list|)
condition|)
block|{
name|start
operator|=
name|end
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'^'
condition|)
name|start
operator|=
name|end
operator|=
literal|1
operator|,
name|cmd
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'$'
condition|)
name|start
operator|=
operator|-
literal|1
operator|,
name|cmd
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'*'
condition|)
name|start
operator|=
literal|1
operator|,
name|cmd
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'-'
operator|||
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cmd
argument_list|)
condition|)
block|{
name|start
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|cmd
operator|&&
literal|'0'
operator|<=
operator|*
name|cmd
operator|&&
operator|*
name|cmd
operator|<=
literal|'9'
condition|)
name|start
operator|=
name|start
operator|*
literal|10
operator|+
operator|*
name|cmd
operator|++
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|cmd
index|[
literal|1
index|]
argument_list|)
condition|)
block|{
name|cmd
operator|++
expr_stmt|;
name|end
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|cmd
operator|&&
literal|'0'
operator|<=
operator|*
name|cmd
operator|&&
operator|*
name|cmd
operator|<=
literal|'9'
condition|)
name|end
operator|=
name|end
operator|*
literal|10
operator|+
operator|*
name|cmd
operator|++
operator|-
literal|'0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
index|[
literal|1
index|]
operator|==
literal|'$'
condition|)
block|{
name|cmd
operator|+=
literal|2
expr_stmt|;
name|end
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|cmd
operator|++
expr_stmt|;
name|end
operator|=
operator|-
literal|2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'*'
condition|)
name|end
operator|=
operator|-
literal|1
operator|,
name|cmd
operator|++
expr_stmt|;
else|else
name|end
operator|=
name|start
expr_stmt|;
block|}
name|tmp
operator|=
name|history_arg_extract
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|aptr
condition|?
name|aptr
else|:
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|rl_outstream
argument_list|,
literal|"%s: Bad word specifier"
argument_list|,
name|command
operator|+
name|offs
operator|+
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|aptr
condition|)
name|el_free
argument_list|(
name|aptr
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
name|tmp
operator|=
name|strdup
argument_list|(
name|aptr
condition|?
name|aptr
else|:
name|ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|aptr
condition|)
name|el_free
argument_list|(
name|aptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'\0'
operator|||
operator|(
call|(
name|size_t
call|)
argument_list|(
name|cmd
operator|-
operator|(
name|command
operator|+
name|offs
operator|)
argument_list|)
operator|>=
name|cmdlen
operator|)
condition|)
block|{
operator|*
name|result
operator|=
name|tmp
expr_stmt|;
return|return
literal|1
return|;
block|}
for|for
control|(
init|;
operator|*
name|cmd
condition|;
name|cmd
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cmd
operator|==
literal|':'
condition|)
continue|continue;
elseif|else
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'h'
condition|)
block|{
comment|/* remove trailing path */
if|if
condition|(
operator|(
name|aptr
operator|=
name|strrchr
argument_list|(
name|tmp
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|aptr
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'t'
condition|)
block|{
comment|/* remove leading path */
if|if
condition|(
operator|(
name|aptr
operator|=
name|strrchr
argument_list|(
name|tmp
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|aptr
operator|=
name|strdup
argument_list|(
name|aptr
operator|+
literal|1
argument_list|)
expr_stmt|;
name|el_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|aptr
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'r'
condition|)
block|{
comment|/* remove trailing suffix */
if|if
condition|(
operator|(
name|aptr
operator|=
name|strrchr
argument_list|(
name|tmp
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|aptr
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'e'
condition|)
block|{
comment|/* remove all but suffix */
if|if
condition|(
operator|(
name|aptr
operator|=
name|strrchr
argument_list|(
name|tmp
argument_list|,
literal|'.'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|aptr
operator|=
name|strdup
argument_list|(
name|aptr
argument_list|)
expr_stmt|;
name|el_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|aptr
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'p'
condition|)
comment|/* print only */
name|p_on
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'g'
condition|)
name|g_on
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'s'
operator|||
operator|*
name|cmd
operator|==
literal|'&'
condition|)
block|{
name|char
modifier|*
name|what
decl_stmt|,
modifier|*
name|with
decl_stmt|,
name|delim
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|from_len
decl_stmt|;
name|size_t
name|size
decl_stmt|;
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'&'
operator|&&
operator|(
name|from
operator|==
name|NULL
operator|||
name|to
operator|==
name|NULL
operator|)
condition|)
continue|continue;
elseif|else
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'s'
condition|)
block|{
name|delim
operator|=
operator|*
operator|(
operator|++
name|cmd
operator|)
operator|,
name|cmd
operator|++
expr_stmt|;
name|size
operator|=
literal|16
expr_stmt|;
name|what
operator|=
name|el_realloc
argument_list|(
name|from
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|what
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|what
operator|==
name|NULL
condition|)
block|{
name|el_free
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|el_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
operator|*
name|cmd
operator|&&
operator|*
name|cmd
operator|!=
name|delim
condition|;
name|cmd
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'\\'
operator|&&
name|cmd
index|[
literal|1
index|]
operator|==
name|delim
condition|)
name|cmd
operator|++
expr_stmt|;
if|if
condition|(
name|len
operator|>=
name|size
condition|)
block|{
name|char
modifier|*
name|nwhat
decl_stmt|;
name|nwhat
operator|=
name|el_realloc
argument_list|(
name|what
argument_list|,
operator|(
name|size
operator|<<=
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|nwhat
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nwhat
operator|==
name|NULL
condition|)
block|{
name|el_free
argument_list|(
name|what
argument_list|)
expr_stmt|;
name|el_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|what
operator|=
name|nwhat
expr_stmt|;
block|}
name|what
index|[
name|len
operator|++
index|]
operator|=
operator|*
name|cmd
expr_stmt|;
block|}
name|what
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|from
operator|=
name|what
expr_stmt|;
if|if
condition|(
operator|*
name|what
operator|==
literal|'\0'
condition|)
block|{
name|el_free
argument_list|(
name|what
argument_list|)
expr_stmt|;
if|if
condition|(
name|search
condition|)
block|{
name|from
operator|=
name|strdup
argument_list|(
name|search
argument_list|)
expr_stmt|;
if|if
condition|(
name|from
operator|==
name|NULL
condition|)
block|{
name|el_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
else|else
block|{
name|from
operator|=
name|NULL
expr_stmt|;
name|el_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
name|cmd
operator|++
expr_stmt|;
comment|/* shift after delim */
if|if
condition|(
operator|!
operator|*
name|cmd
condition|)
continue|continue;
name|size
operator|=
literal|16
expr_stmt|;
name|with
operator|=
name|el_realloc
argument_list|(
name|to
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|with
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|with
operator|==
name|NULL
condition|)
block|{
name|el_free
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|el_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|len
operator|=
literal|0
expr_stmt|;
name|from_len
operator|=
name|strlen
argument_list|(
name|from
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|*
name|cmd
operator|&&
operator|*
name|cmd
operator|!=
name|delim
condition|;
name|cmd
operator|++
control|)
block|{
if|if
condition|(
name|len
operator|+
name|from_len
operator|+
literal|1
operator|>=
name|size
condition|)
block|{
name|char
modifier|*
name|nwith
decl_stmt|;
name|size
operator|+=
name|from_len
operator|+
literal|1
expr_stmt|;
name|nwith
operator|=
name|el_realloc
argument_list|(
name|with
argument_list|,
name|size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|nwith
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nwith
operator|==
name|NULL
condition|)
block|{
name|el_free
argument_list|(
name|with
argument_list|)
expr_stmt|;
name|el_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|with
operator|=
name|nwith
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'&'
condition|)
block|{
comment|/* safe */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|&
name|with
index|[
name|len
index|]
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|len
operator|+=
name|from_len
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|cmd
operator|==
literal|'\\'
operator|&&
operator|(
operator|*
operator|(
name|cmd
operator|+
literal|1
operator|)
operator|==
name|delim
operator|||
operator|*
operator|(
name|cmd
operator|+
literal|1
operator|)
operator|==
literal|'&'
operator|)
condition|)
name|cmd
operator|++
expr_stmt|;
name|with
index|[
name|len
operator|++
index|]
operator|=
operator|*
name|cmd
expr_stmt|;
block|}
name|with
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|to
operator|=
name|with
expr_stmt|;
block|}
name|aptr
operator|=
name|_rl_compat_sub
argument_list|(
name|tmp
argument_list|,
name|from
argument_list|,
name|to
argument_list|,
name|g_on
argument_list|)
expr_stmt|;
if|if
condition|(
name|aptr
condition|)
block|{
name|el_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|aptr
expr_stmt|;
block|}
name|g_on
operator|=
literal|0
expr_stmt|;
block|}
block|}
operator|*
name|result
operator|=
name|tmp
expr_stmt|;
return|return
name|p_on
condition|?
literal|2
else|:
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * csh-style history expansion  */
end_comment

begin_function
name|int
name|history_expand
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|char
modifier|*
modifier|*
name|output
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|size_t
name|idx
decl_stmt|,
name|i
decl_stmt|,
name|size
decl_stmt|;
name|char
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|result
decl_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|e
operator|==
name|NULL
condition|)
name|rl_initialize
argument_list|()
expr_stmt|;
if|if
condition|(
name|history_expansion_char
operator|==
literal|0
condition|)
block|{
operator|*
name|output
operator|=
name|strdup
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|output
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|==
name|history_subst_char
condition|)
block|{
comment|/* ^foo^foo2^ is equivalent to !!:s^foo^foo2^ */
operator|*
name|output
operator|=
name|el_malloc
argument_list|(
operator|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|4
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|output
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|output
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
operator|(
operator|*
name|output
operator|)
index|[
literal|0
index|]
operator|=
operator|(
operator|*
name|output
operator|)
index|[
literal|1
index|]
operator|=
name|history_expansion_char
expr_stmt|;
operator|(
operator|*
name|output
operator|)
index|[
literal|2
index|]
operator|=
literal|':'
expr_stmt|;
operator|(
operator|*
name|output
operator|)
index|[
literal|3
index|]
operator|=
literal|'s'
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
operator|*
name|output
operator|)
operator|+
literal|4
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|str
operator|=
operator|*
name|output
expr_stmt|;
block|}
else|else
block|{
operator|*
name|output
operator|=
name|strdup
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|output
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
block|}
define|#
directive|define
name|ADD_STRING
parameter_list|(
name|what
parameter_list|,
name|len
parameter_list|,
name|fr
parameter_list|)
define|\
value|{								\ 		if (idx + len + 1> size) {				\ 			char *nresult = el_realloc(result,		\ 			    (size += len + 1) * sizeof(*nresult));	\ 			if (nresult == NULL) {				\ 				el_free(*output);			\ 				if (
comment|/*CONSTCOND*/
value|fr)			\ 					el_free(tmp);			\ 				return 0;				\ 			}						\ 			result = nresult;				\ 		}							\ 		(void)strncpy(&result[idx], what, len);			\ 		idx += len;						\ 		result[idx] = '\0';					\ 	}
name|result
operator|=
name|NULL
expr_stmt|;
name|size
operator|=
name|idx
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|str
index|[
name|i
index|]
condition|;
control|)
block|{
name|int
name|qchar
decl_stmt|,
name|loop_again
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|start
decl_stmt|,
name|j
decl_stmt|;
name|qchar
operator|=
literal|0
expr_stmt|;
name|loop_again
operator|=
literal|1
expr_stmt|;
name|start
operator|=
name|j
operator|=
name|i
expr_stmt|;
name|loop
label|:
for|for
control|(
init|;
name|str
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|str
index|[
name|j
index|]
operator|==
literal|'\\'
operator|&&
name|str
index|[
name|j
operator|+
literal|1
index|]
operator|==
name|history_expansion_char
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|&
name|str
index|[
name|j
index|]
argument_list|,
operator|&
name|str
index|[
name|j
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|loop_again
condition|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|str
index|[
name|j
index|]
argument_list|)
operator|||
name|str
index|[
name|j
index|]
operator|==
name|qchar
condition|)
break|break;
block|}
if|if
condition|(
name|str
index|[
name|j
index|]
operator|==
name|history_expansion_char
operator|&&
operator|!
name|strchr
argument_list|(
name|history_no_expand_chars
argument_list|,
name|str
index|[
name|j
operator|+
literal|1
index|]
argument_list|)
operator|&&
operator|(
operator|!
name|history_inhibit_expansion_function
operator|||
call|(
modifier|*
name|history_inhibit_expansion_function
call|)
argument_list|(
name|str
argument_list|,
operator|(
name|int
operator|)
name|j
argument_list|)
operator|==
literal|0
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|str
index|[
name|j
index|]
operator|&&
name|loop_again
condition|)
block|{
name|i
operator|=
name|j
expr_stmt|;
name|qchar
operator|=
operator|(
name|j
operator|>
literal|0
operator|&&
name|str
index|[
name|j
operator|-
literal|1
index|]
operator|==
literal|'"'
operator|)
condition|?
literal|'"'
else|:
literal|0
expr_stmt|;
name|j
operator|++
expr_stmt|;
if|if
condition|(
name|str
index|[
name|j
index|]
operator|==
name|history_expansion_char
condition|)
name|j
operator|++
expr_stmt|;
name|loop_again
operator|=
literal|0
expr_stmt|;
goto|goto
name|loop
goto|;
block|}
name|len
operator|=
name|i
operator|-
name|start
expr_stmt|;
name|ADD_STRING
argument_list|(
operator|&
name|str
index|[
name|start
index|]
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
index|[
name|i
index|]
operator|==
literal|'\0'
operator|||
name|str
index|[
name|i
index|]
operator|!=
name|history_expansion_char
condition|)
block|{
name|len
operator|=
name|j
operator|-
name|i
expr_stmt|;
name|ADD_STRING
argument_list|(
operator|&
name|str
index|[
name|i
index|]
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|start
operator|==
literal|0
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
else|else
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|ret
operator|=
name|_history_expand_command
argument_list|(
name|str
argument_list|,
name|i
argument_list|,
operator|(
name|j
operator|-
name|i
operator|)
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
operator|&&
name|tmp
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|ADD_STRING
argument_list|(
name|tmp
argument_list|,
name|len
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmp
condition|)
block|{
name|el_free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|NULL
expr_stmt|;
block|}
name|i
operator|=
name|j
expr_stmt|;
block|}
comment|/* ret is 2 for "print only" option */
if|if
condition|(
name|ret
operator|==
literal|2
condition|)
block|{
name|add_history
argument_list|(
name|result
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GDB_411_HACK
comment|/* gdb 4.11 has been shipped with readline, where */
comment|/* history_expand() returned -1 when the line	  */
comment|/* should not be executed; in readline 2.1+	  */
comment|/* it should return 2 in such a case		  */
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
block|}
name|el_free
argument_list|(
operator|*
name|output
argument_list|)
expr_stmt|;
operator|*
name|output
operator|=
name|result
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/* * Return a string consisting of arguments of "str" from "start" to "end". */
end_comment

begin_function
name|char
modifier|*
name|history_arg_extract
parameter_list|(
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|size_t
name|i
decl_stmt|,
name|len
decl_stmt|,
name|max
decl_stmt|;
name|char
modifier|*
modifier|*
name|arr
decl_stmt|,
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|arr
operator|=
name|history_tokenize
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|arr
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|arr
operator|&&
operator|*
name|arr
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|max
operator|=
literal|0
init|;
name|arr
index|[
name|max
index|]
condition|;
name|max
operator|++
control|)
continue|continue;
name|max
operator|--
expr_stmt|;
if|if
condition|(
name|start
operator|==
literal|'$'
condition|)
name|start
operator|=
operator|(
name|int
operator|)
name|max
expr_stmt|;
if|if
condition|(
name|end
operator|==
literal|'$'
condition|)
name|end
operator|=
operator|(
name|int
operator|)
name|max
expr_stmt|;
if|if
condition|(
name|end
operator|<
literal|0
condition|)
name|end
operator|=
operator|(
name|int
operator|)
name|max
operator|+
name|end
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|start
operator|<
literal|0
condition|)
name|start
operator|=
name|end
expr_stmt|;
if|if
condition|(
name|start
operator|<
literal|0
operator|||
name|end
operator|<
literal|0
operator|||
operator|(
name|size_t
operator|)
name|start
operator|>
name|max
operator|||
operator|(
name|size_t
operator|)
name|end
operator|>
name|max
operator|||
name|start
operator|>
name|end
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|i
operator|=
operator|(
name|size_t
operator|)
name|start
operator|,
name|len
operator|=
literal|0
init|;
name|i
operator|<=
operator|(
name|size_t
operator|)
name|end
condition|;
name|i
operator|++
control|)
name|len
operator|+=
name|strlen
argument_list|(
name|arr
index|[
name|i
index|]
argument_list|)
operator|+
literal|1
expr_stmt|;
name|len
operator|++
expr_stmt|;
name|result
operator|=
name|el_malloc
argument_list|(
name|len
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|result
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|i
operator|=
operator|(
name|size_t
operator|)
name|start
operator|,
name|len
operator|=
literal|0
init|;
name|i
operator|<=
operator|(
name|size_t
operator|)
name|end
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|result
operator|+
name|len
argument_list|,
name|arr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|len
operator|+=
name|strlen
argument_list|(
name|arr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
operator|(
name|size_t
operator|)
name|end
condition|)
name|result
index|[
name|len
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
name|result
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|out
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|arr
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
name|el_free
argument_list|(
name|arr
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|el_free
argument_list|(
name|arr
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * Parse the string into individual tokens,  * similar to how shell would do it.  */
end_comment

begin_function
name|char
modifier|*
modifier|*
name|history_tokenize
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|int
name|size
init|=
literal|1
decl_stmt|,
name|idx
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|start
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|char
modifier|*
modifier|*
name|result
init|=
name|NULL
decl_stmt|,
modifier|*
name|temp
decl_stmt|,
name|delim
init|=
literal|'\0'
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|str
index|[
name|i
index|]
condition|;
control|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|str
index|[
name|i
index|]
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
name|start
operator|=
name|i
expr_stmt|;
for|for
control|(
init|;
name|str
index|[
name|i
index|]
condition|;
control|)
block|{
if|if
condition|(
name|str
index|[
name|i
index|]
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|str
index|[
name|i
operator|+
literal|1
index|]
operator|!=
literal|'\0'
condition|)
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|str
index|[
name|i
index|]
operator|==
name|delim
condition|)
name|delim
operator|=
literal|'\0'
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|delim
operator|&&
operator|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|str
index|[
name|i
index|]
argument_list|)
operator|||
name|strchr
argument_list|(
literal|"()<>;&|$"
argument_list|,
name|str
index|[
name|i
index|]
argument_list|)
operator|)
condition|)
break|break;
elseif|else
if|if
condition|(
operator|!
name|delim
operator|&&
name|strchr
argument_list|(
literal|"'`\""
argument_list|,
name|str
index|[
name|i
index|]
argument_list|)
condition|)
name|delim
operator|=
name|str
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|str
index|[
name|i
index|]
condition|)
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|idx
operator|+
literal|2
operator|>=
name|size
condition|)
block|{
name|char
modifier|*
modifier|*
name|nresult
decl_stmt|;
name|size
operator|<<=
literal|1
expr_stmt|;
name|nresult
operator|=
name|el_realloc
argument_list|(
name|result
argument_list|,
operator|(
name|size_t
operator|)
name|size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|nresult
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nresult
operator|==
name|NULL
condition|)
block|{
name|el_free
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|result
operator|=
name|nresult
expr_stmt|;
block|}
name|len
operator|=
operator|(
name|size_t
operator|)
name|i
operator|-
operator|(
name|size_t
operator|)
name|start
expr_stmt|;
name|temp
operator|=
name|el_malloc
argument_list|(
call|(
name|size_t
call|)
argument_list|(
name|len
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|temp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|idx
condition|;
name|i
operator|++
control|)
name|el_free
argument_list|(
name|result
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|el_free
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|temp
argument_list|,
operator|&
name|str
index|[
name|start
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|temp
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|result
index|[
name|idx
operator|++
index|]
operator|=
name|temp
expr_stmt|;
name|result
index|[
name|idx
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|str
index|[
name|i
index|]
condition|)
name|i
operator|++
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/*  * limit size of history record to ``max'' events  */
end_comment

begin_function
name|void
name|stifle_history
parameter_list|(
name|int
name|max
parameter_list|)
block|{
name|HistEvent
name|ev
decl_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|e
operator|==
name|NULL
condition|)
name|rl_initialize
argument_list|()
expr_stmt|;
if|if
condition|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_SETSIZE
argument_list|,
name|max
argument_list|)
operator|==
literal|0
condition|)
name|max_input_history
operator|=
name|max
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * "unlimit" size of history - set the limit to maximum allowed int value  */
end_comment

begin_function
name|int
name|unstifle_history
parameter_list|(
name|void
parameter_list|)
block|{
name|HistEvent
name|ev
decl_stmt|;
name|int
name|omax
decl_stmt|;
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_SETSIZE
argument_list|,
name|INT_MAX
argument_list|)
expr_stmt|;
name|omax
operator|=
name|max_input_history
expr_stmt|;
name|max_input_history
operator|=
name|INT_MAX
expr_stmt|;
return|return
name|omax
return|;
comment|/* some value _must_ be returned */
block|}
end_function

begin_function
name|int
name|history_is_stifled
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* cannot return true answer */
return|return
name|max_input_history
operator|!=
name|INT_MAX
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
name|_history_tmp_template
index|[]
init|=
literal|"/tmp/.historyXXXXXX"
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|history_truncate_file
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|nlines
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|char
name|template
index|[
sizeof|sizeof
argument_list|(
name|_history_tmp_template
argument_list|)
index|]
decl_stmt|;
name|char
name|buf
index|[
literal|4096
index|]
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|off_t
name|off
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|ssize_t
name|left
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
operator|&&
operator|(
name|filename
operator|=
name|_default_history_file
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
name|errno
return|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|errno
return|;
name|strcpy
argument_list|(
name|template
argument_list|,
name|_history_tmp_template
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|mkstemp
argument_list|(
name|template
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ret
operator|=
name|errno
expr_stmt|;
goto|goto
name|out1
goto|;
block|}
if|if
condition|(
operator|(
name|tp
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"r+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|ret
operator|=
name|errno
expr_stmt|;
goto|goto
name|out2
goto|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|fread
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|,
name|fp
argument_list|)
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|ret
operator|=
name|errno
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fseeko
argument_list|(
name|fp
argument_list|,
operator|(
name|off_t
operator|)
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|*
name|count
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|(
name|off_t
operator|)
operator|-
literal|1
condition|)
block|{
name|ret
operator|=
name|errno
expr_stmt|;
break|break;
block|}
name|left
operator|=
operator|(
name|ssize_t
operator|)
name|fread
argument_list|(
name|buf
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|ret
operator|=
name|errno
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|left
operator|==
literal|0
condition|)
block|{
name|count
operator|--
expr_stmt|;
name|left
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fwrite
argument_list|(
name|buf
argument_list|,
operator|(
name|size_t
operator|)
name|left
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|,
name|tp
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|ret
operator|=
name|errno
expr_stmt|;
break|break;
block|}
name|fflush
argument_list|(
name|tp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fwrite
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|,
name|tp
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|ret
operator|=
name|errno
expr_stmt|;
break|break;
block|}
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|ret
condition|)
goto|goto
name|out3
goto|;
name|cp
operator|=
name|buf
operator|+
name|left
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\n'
condition|)
name|cp
operator|++
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|--
name|cp
operator|>=
name|buf
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|--
name|nlines
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|++
name|cp
operator|>=
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
block|}
break|break;
block|}
block|}
block|}
if|if
condition|(
name|nlines
operator|<=
literal|0
operator|||
name|count
operator|==
literal|0
condition|)
break|break;
name|count
operator|--
expr_stmt|;
if|if
condition|(
name|fseeko
argument_list|(
name|tp
argument_list|,
operator|(
name|off_t
operator|)
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|*
name|count
argument_list|,
name|SEEK_SET
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ret
operator|=
name|errno
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fread
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|,
name|tp
argument_list|)
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|tp
argument_list|)
condition|)
block|{
name|ret
operator|=
name|errno
expr_stmt|;
break|break;
block|}
name|ret
operator|=
name|EAGAIN
expr_stmt|;
break|break;
block|}
name|cp
operator|=
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|||
name|nlines
operator|>
literal|0
condition|)
goto|goto
name|out3
goto|;
if|if
condition|(
name|fseeko
argument_list|(
name|fp
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|(
name|off_t
operator|)
operator|-
literal|1
condition|)
block|{
name|ret
operator|=
name|errno
expr_stmt|;
goto|goto
name|out3
goto|;
block|}
if|if
condition|(
name|fseeko
argument_list|(
name|tp
argument_list|,
operator|(
name|off_t
operator|)
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|*
name|count
operator|+
operator|(
name|cp
operator|-
name|buf
operator|)
argument_list|,
name|SEEK_SET
argument_list|)
operator|==
operator|(
name|off_t
operator|)
operator|-
literal|1
condition|)
block|{
name|ret
operator|=
name|errno
expr_stmt|;
goto|goto
name|out3
goto|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|left
operator|=
operator|(
name|ssize_t
operator|)
name|fread
argument_list|(
name|buf
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|tp
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
name|ret
operator|=
name|errno
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|fwrite
argument_list|(
name|buf
argument_list|,
operator|(
name|size_t
operator|)
name|left
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|,
name|fp
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|ret
operator|=
name|errno
expr_stmt|;
break|break;
block|}
block|}
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|off
operator|=
name|ftello
argument_list|(
name|fp
argument_list|)
operator|)
operator|>
literal|0
condition|)
operator|(
name|void
operator|)
name|ftruncate
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|out3
label|:
name|fclose
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|out2
label|:
name|unlink
argument_list|(
name|template
argument_list|)
expr_stmt|;
name|out1
label|:
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * read history from a file given  */
end_comment

begin_function
name|int
name|read_history
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|HistEvent
name|ev
decl_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|e
operator|==
name|NULL
condition|)
name|rl_initialize
argument_list|()
expr_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
operator|&&
operator|(
name|filename
operator|=
name|_default_history_file
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
name|errno
return|;
return|return
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_LOAD
argument_list|,
name|filename
argument_list|)
operator|==
operator|-
literal|1
condition|?
operator|(
name|errno
condition|?
name|errno
else|:
name|EINVAL
operator|)
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * write history to a file given  */
end_comment

begin_function
name|int
name|write_history
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|HistEvent
name|ev
decl_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|e
operator|==
name|NULL
condition|)
name|rl_initialize
argument_list|()
expr_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
operator|&&
operator|(
name|filename
operator|=
name|_default_history_file
argument_list|()
operator|)
operator|==
name|NULL
condition|)
return|return
name|errno
return|;
return|return
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_SAVE
argument_list|,
name|filename
argument_list|)
operator|==
operator|-
literal|1
condition|?
operator|(
name|errno
condition|?
name|errno
else|:
name|EINVAL
operator|)
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * returns history ``num''th event  *  * returned pointer points to static variable  */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|history_get
parameter_list|(
name|int
name|num
parameter_list|)
block|{
specifier|static
name|HIST_ENTRY
name|she
decl_stmt|;
name|HistEvent
name|ev
decl_stmt|;
name|int
name|curr_num
decl_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|e
operator|==
name|NULL
condition|)
name|rl_initialize
argument_list|()
expr_stmt|;
comment|/* save current position */
if|if
condition|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_CURR
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
name|curr_num
operator|=
name|ev
operator|.
name|num
expr_stmt|;
comment|/* start from the oldest */
if|if
condition|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_LAST
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
comment|/* error */
comment|/* look forwards for event matching specified offset */
if|if
condition|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_NEXT_EVDATA
argument_list|,
name|num
argument_list|,
operator|&
name|she
operator|.
name|data
argument_list|)
condition|)
return|return
name|NULL
return|;
name|she
operator|.
name|line
operator|=
name|ev
operator|.
name|str
expr_stmt|;
comment|/* restore pointer to where it was */
operator|(
name|void
operator|)
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_SET
argument_list|,
name|curr_num
argument_list|)
expr_stmt|;
return|return
operator|&
name|she
return|;
block|}
end_function

begin_comment
comment|/*  * add the line to history table  */
end_comment

begin_function
name|int
name|add_history
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|)
block|{
name|HistEvent
name|ev
decl_stmt|;
if|if
condition|(
name|line
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|e
operator|==
name|NULL
condition|)
name|rl_initialize
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_ENTER
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_GETSIZE
argument_list|)
operator|==
literal|0
condition|)
name|history_length
operator|=
name|ev
operator|.
name|num
expr_stmt|;
return|return
operator|!
operator|(
name|history_length
operator|>
literal|0
operator|)
return|;
comment|/* return 0 if all is okay */
block|}
end_function

begin_comment
comment|/*  * remove the specified entry from the history list and return it.  */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|remove_history
parameter_list|(
name|int
name|num
parameter_list|)
block|{
name|HIST_ENTRY
modifier|*
name|he
decl_stmt|;
name|HistEvent
name|ev
decl_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|e
operator|==
name|NULL
condition|)
name|rl_initialize
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|he
operator|=
name|el_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|he
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
if|if
condition|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_DELDATA
argument_list|,
name|num
argument_list|,
operator|&
name|he
operator|->
name|data
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|el_free
argument_list|(
name|he
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|he
operator|->
name|line
operator|=
name|ev
operator|.
name|str
expr_stmt|;
if|if
condition|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_GETSIZE
argument_list|)
operator|==
literal|0
condition|)
name|history_length
operator|=
name|ev
operator|.
name|num
expr_stmt|;
return|return
name|he
return|;
block|}
end_function

begin_comment
comment|/*  * replace the line and data of the num-th entry  */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|replace_history_entry
parameter_list|(
name|int
name|num
parameter_list|,
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|histdata_t
name|data
parameter_list|)
block|{
name|HIST_ENTRY
modifier|*
name|he
decl_stmt|;
name|HistEvent
name|ev
decl_stmt|;
name|int
name|curr_num
decl_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|e
operator|==
name|NULL
condition|)
name|rl_initialize
argument_list|()
expr_stmt|;
comment|/* save current position */
if|if
condition|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_CURR
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
name|curr_num
operator|=
name|ev
operator|.
name|num
expr_stmt|;
comment|/* start from the oldest */
if|if
condition|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_LAST
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|NULL
return|;
comment|/* error */
if|if
condition|(
operator|(
name|he
operator|=
name|el_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|he
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* look forwards for event matching specified offset */
if|if
condition|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_NEXT_EVDATA
argument_list|,
name|num
argument_list|,
operator|&
name|he
operator|->
name|data
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|he
operator|->
name|line
operator|=
name|strdup
argument_list|(
name|ev
operator|.
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|he
operator|->
name|line
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_REPLACE
argument_list|,
name|line
argument_list|,
name|data
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/* restore pointer to where it was */
if|if
condition|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_SET
argument_list|,
name|curr_num
argument_list|)
condition|)
goto|goto
name|out
goto|;
return|return
name|he
return|;
name|out
label|:
name|el_free
argument_list|(
name|he
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * clear the history list - delete all entries  */
end_comment

begin_function
name|void
name|clear_history
parameter_list|(
name|void
parameter_list|)
block|{
name|HistEvent
name|ev
decl_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|e
operator|==
name|NULL
condition|)
name|rl_initialize
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_CLEAR
argument_list|)
expr_stmt|;
name|history_length
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * returns offset of the current history event  */
end_comment

begin_function
name|int
name|where_history
parameter_list|(
name|void
parameter_list|)
block|{
name|HistEvent
name|ev
decl_stmt|;
name|int
name|curr_num
decl_stmt|,
name|off
decl_stmt|;
if|if
condition|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_CURR
argument_list|)
operator|!=
literal|0
condition|)
return|return
literal|0
return|;
name|curr_num
operator|=
name|ev
operator|.
name|num
expr_stmt|;
operator|(
name|void
operator|)
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_FIRST
argument_list|)
expr_stmt|;
name|off
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|ev
operator|.
name|num
operator|!=
name|curr_num
operator|&&
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_NEXT
argument_list|)
operator|==
literal|0
condition|)
name|off
operator|++
expr_stmt|;
return|return
name|off
return|;
block|}
end_function

begin_comment
comment|/*  * returns current history event or NULL if there is no such event  */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|current_history
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|_move_history
argument_list|(
name|H_CURR
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * returns total number of bytes history events' data are using  */
end_comment

begin_function
name|int
name|history_total_bytes
parameter_list|(
name|void
parameter_list|)
block|{
name|HistEvent
name|ev
decl_stmt|;
name|int
name|curr_num
decl_stmt|;
name|size_t
name|size
decl_stmt|;
if|if
condition|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_CURR
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|curr_num
operator|=
name|ev
operator|.
name|num
expr_stmt|;
operator|(
name|void
operator|)
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_FIRST
argument_list|)
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
do|do
name|size
operator|+=
name|strlen
argument_list|(
name|ev
operator|.
name|str
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ev
operator|.
name|str
argument_list|)
expr_stmt|;
do|while
condition|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_NEXT
argument_list|)
operator|==
literal|0
condition|)
do|;
comment|/* get to the same position as before */
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_PREV_EVENT
argument_list|,
name|curr_num
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|size
return|;
block|}
end_function

begin_comment
comment|/*  * sets the position in the history list to ``pos''  */
end_comment

begin_function
name|int
name|history_set_pos
parameter_list|(
name|int
name|pos
parameter_list|)
block|{
name|HistEvent
name|ev
decl_stmt|;
name|int
name|curr_num
decl_stmt|;
if|if
condition|(
name|pos
operator|>=
name|history_length
operator|||
name|pos
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
operator|(
name|void
operator|)
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_CURR
argument_list|)
expr_stmt|;
name|curr_num
operator|=
name|ev
operator|.
name|num
expr_stmt|;
comment|/* 	 * use H_DELDATA to set to nth history (without delete) by passing 	 * (void **)-1 	 */
if|if
condition|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_DELDATA
argument_list|,
name|pos
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|-
literal|1
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_SET
argument_list|,
name|curr_num
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * returns previous event in history and shifts pointer accordingly  */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|previous_history
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|_move_history
argument_list|(
name|H_PREV
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * returns next event in history and shifts pointer accordingly  */
end_comment

begin_function
name|HIST_ENTRY
modifier|*
name|next_history
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|_move_history
argument_list|(
name|H_NEXT
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * searches for first history event containing the str  */
end_comment

begin_function
name|int
name|history_search
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|direction
parameter_list|)
block|{
name|HistEvent
name|ev
decl_stmt|;
specifier|const
name|char
modifier|*
name|strp
decl_stmt|;
name|int
name|curr_num
decl_stmt|;
if|if
condition|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_CURR
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|curr_num
operator|=
name|ev
operator|.
name|num
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|strp
operator|=
name|strstr
argument_list|(
name|ev
operator|.
name|str
argument_list|,
name|str
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
call|(
name|int
call|)
argument_list|(
name|strp
operator|-
name|ev
operator|.
name|str
argument_list|)
return|;
if|if
condition|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|direction
operator|<
literal|0
condition|?
name|H_NEXT
else|:
name|H_PREV
argument_list|)
operator|!=
literal|0
condition|)
break|break;
block|}
operator|(
name|void
operator|)
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_SET
argument_list|,
name|curr_num
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/*  * searches for first history event beginning with str  */
end_comment

begin_function
name|int
name|history_search_prefix
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|int
name|direction
parameter_list|)
block|{
name|HistEvent
name|ev
decl_stmt|;
return|return
operator|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|direction
operator|<
literal|0
condition|?
name|H_PREV_STR
else|:
name|H_NEXT_STR
argument_list|,
name|str
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * search for event in history containing str, starting at offset  * abs(pos); continue backward, if pos<0, forward otherwise  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_decl_stmt
name|int
name|history_search_pos
argument_list|(
specifier|const
name|char
operator|*
name|str
argument_list|,
name|int
name|direction
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|,
name|int
name|pos
argument_list|)
block|{
name|HistEvent
name|ev
decl_stmt|;
name|int
name|curr_num
decl_stmt|,
name|off
decl_stmt|;
name|off
operator|=
operator|(
name|pos
operator|>
literal|0
operator|)
condition|?
name|pos
else|:
operator|-
name|pos
expr_stmt|;
name|pos
operator|=
operator|(
name|pos
operator|>
literal|0
operator|)
condition|?
literal|1
else|:
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_CURR
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|curr_num
operator|=
name|ev
operator|.
name|num
expr_stmt|;
if|if
condition|(
name|history_set_pos
argument_list|(
name|off
argument_list|)
operator|!=
literal|0
operator|||
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|H_CURR
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|strstr
argument_list|(
name|ev
operator|.
name|str
argument_list|,
name|str
argument_list|)
condition|)
return|return
name|off
return|;
if|if
condition|(
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
operator|(
name|pos
operator|<
literal|0
operator|)
condition|?
name|H_PREV
else|:
name|H_NEXT
argument_list|)
operator|!=
literal|0
condition|)
break|break;
block|}
comment|/* set "current" pointer back to previous state */
operator|(
name|void
operator|)
name|history
argument_list|(
name|h
argument_list|,
operator|&
name|ev
argument_list|,
name|pos
operator|<
literal|0
condition|?
name|H_NEXT_EVENT
else|:
name|H_PREV_EVENT
argument_list|,
name|curr_num
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
end_decl_stmt

begin_comment
comment|/********************************/
end_comment

begin_comment
comment|/* completion functions */
end_comment

begin_function
name|char
modifier|*
name|tilde_expand
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
name|fn_tilde_expand
argument_list|(
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|filename_completion_function
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|state
parameter_list|)
block|{
return|return
name|fn_filename_completion_function
argument_list|(
name|name
argument_list|,
name|state
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * a completion generator for usernames; returns _first_ username  * which starts with supplied text  * text contains a partial username preceded by random character  * (usually '~'); state resets search from start (??? should we do that anyway)  * it's the caller's responsibility to free the returned value  */
end_comment

begin_function
name|char
modifier|*
name|username_completion_function
parameter_list|(
specifier|const
name|char
modifier|*
name|text
parameter_list|,
name|int
name|state
parameter_list|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|HAVE_GETPW_R_POSIX
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_GETPW_R_DRAFT
argument_list|)
name|struct
name|passwd
name|pwres
decl_stmt|;
name|char
name|pwbuf
index|[
literal|1024
index|]
decl_stmt|;
endif|#
directive|endif
name|struct
name|passwd
modifier|*
name|pass
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|text
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
return|return
name|NULL
return|;
if|if
condition|(
operator|*
name|text
operator|==
literal|'~'
condition|)
name|text
operator|++
expr_stmt|;
if|if
condition|(
name|state
operator|==
literal|0
condition|)
name|setpwent
argument_list|()
expr_stmt|;
while|while
condition|(
if|#
directive|if
name|defined
argument_list|(
name|HAVE_GETPW_R_POSIX
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_GETPW_R_DRAFT
argument_list|)
name|getpwent_r
argument_list|(
operator|&
name|pwres
argument_list|,
name|pwbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|pwbuf
argument_list|)
argument_list|,
operator|&
name|pass
argument_list|)
operator|==
literal|0
operator|&&
name|pass
operator|!=
name|NULL
else|#
directive|else
argument_list|(
name|pass
operator|=
name|getpwent
argument_list|()
argument_list|)
operator|!=
name|NULL
endif|#
directive|endif
operator|&&
name|text
index|[
literal|0
index|]
operator|==
name|pass
operator|->
name|pw_name
index|[
literal|0
index|]
operator|&&
name|strcmp
argument_list|(
name|text
argument_list|,
name|pass
operator|->
name|pw_name
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|pass
operator|==
name|NULL
condition|)
block|{
name|endpwent
argument_list|()
expr_stmt|;
return|return
name|NULL
return|;
block|}
return|return
name|strdup
argument_list|(
name|pass
operator|->
name|pw_name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * el-compatible wrapper to send TSTP on ^Z  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|_el_rl_tstp
argument_list|(
name|EditLine
operator|*
name|el
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|,
name|int
name|ch
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|)
block|{
operator|(
name|void
operator|)
name|kill
argument_list|(
literal|0
argument_list|,
name|SIGTSTP
argument_list|)
expr_stmt|;
return|return
name|CC_NORM
return|;
block|}
end_decl_stmt

begin_comment
comment|/*  * Display list of strings in columnar format on readline's output stream.  * 'matches' is list of strings, 'len' is number of strings in 'matches',  * 'max' is maximum length of string in 'matches'.  */
end_comment

begin_function
name|void
name|rl_display_match_list
parameter_list|(
name|char
modifier|*
modifier|*
name|matches
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|max
parameter_list|)
block|{
name|fn_display_match_list
argument_list|(
name|e
argument_list|,
name|matches
argument_list|,
operator|(
name|size_t
operator|)
name|len
argument_list|,
operator|(
name|size_t
operator|)
name|max
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
comment|/*ARGSUSED*/
name|_rl_completion_append_character_function
argument_list|(
specifier|const
name|char
operator|*
name|dummy
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|)
block|{
specifier|static
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
name|rl_completion_append_character
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|buf
return|;
block|}
end_decl_stmt

begin_comment
comment|/*  * complete word at current point  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_decl_stmt
name|int
name|rl_complete
argument_list|(
name|int
name|ignore
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|,
name|int
name|invoking_key
argument_list|)
block|{
ifdef|#
directive|ifdef
name|WIDECHAR
specifier|static
name|ct_buffer_t
name|wbreak_conv
decl_stmt|,
name|sprefix_conv
decl_stmt|;
endif|#
directive|endif
name|char
modifier|*
name|breakchars
decl_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|e
operator|==
name|NULL
condition|)
name|rl_initialize
argument_list|()
expr_stmt|;
if|if
condition|(
name|rl_inhibit_completion
condition|)
block|{
name|char
name|arr
index|[
literal|2
index|]
decl_stmt|;
name|arr
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
name|invoking_key
expr_stmt|;
name|arr
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|el_insertstr
argument_list|(
name|e
argument_list|,
name|arr
argument_list|)
expr_stmt|;
return|return
name|CC_REFRESH
return|;
block|}
if|if
condition|(
name|rl_completion_word_break_hook
operator|!=
name|NULL
condition|)
name|breakchars
operator|=
call|(
modifier|*
name|rl_completion_word_break_hook
call|)
argument_list|()
expr_stmt|;
else|else
name|breakchars
operator|=
name|rl_basic_word_break_characters
expr_stmt|;
comment|/* Just look at how many global variables modify this operation! */
return|return
name|fn_complete
argument_list|(
name|e
argument_list|,
operator|(
name|CPFunction
operator|*
operator|)
name|rl_completion_entry_function
argument_list|,
name|rl_attempted_completion_function
argument_list|,
name|ct_decode_string
argument_list|(
name|rl_basic_word_break_characters
argument_list|,
operator|&
name|wbreak_conv
argument_list|)
argument_list|,
name|ct_decode_string
argument_list|(
name|breakchars
argument_list|,
operator|&
name|sprefix_conv
argument_list|)
argument_list|,
name|_rl_completion_append_character_function
argument_list|,
operator|(
name|size_t
operator|)
name|rl_completion_query_items
argument_list|,
operator|&
name|rl_completion_type
argument_list|,
operator|&
name|rl_attempted_completion_over
argument_list|,
operator|&
name|rl_point
argument_list|,
operator|&
name|rl_end
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/* ARGSUSED */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|_el_rl_complete
argument_list|(
name|EditLine
operator|*
name|el
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|,
name|int
name|ch
argument_list|)
block|{
return|return
operator|(
name|unsigned
name|char
operator|)
name|rl_complete
argument_list|(
literal|0
argument_list|,
name|ch
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/*  * misc other functions  */
end_comment

begin_comment
comment|/*  * bind key c to readline-type function func  */
end_comment

begin_function
name|int
name|rl_bind_key
parameter_list|(
name|int
name|c
parameter_list|,
name|rl_command_func_t
modifier|*
name|func
parameter_list|)
block|{
name|int
name|retval
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|e
operator|==
name|NULL
condition|)
name|rl_initialize
argument_list|()
expr_stmt|;
if|if
condition|(
name|func
operator|==
name|rl_insert
condition|)
block|{
comment|/* XXX notice there is no range checking of ``c'' */
name|e
operator|->
name|el_map
operator|.
name|key
index|[
name|c
index|]
operator|=
name|ED_INSERT
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * read one key from input - handles chars pushed back  * to input stream also  */
end_comment

begin_function
name|int
name|rl_read_key
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|fooarr
index|[
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
operator|||
name|h
operator|==
name|NULL
condition|)
name|rl_initialize
argument_list|()
expr_stmt|;
return|return
name|el_getc
argument_list|(
name|e
argument_list|,
name|fooarr
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * reset the terminal  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_decl_stmt
name|void
name|rl_reset_terminal
argument_list|(
specifier|const
name|char
operator|*
name|p
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|)
block|{
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|e
operator|==
name|NULL
condition|)
name|rl_initialize
argument_list|()
expr_stmt|;
name|el_reset
argument_list|(
name|e
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/*  * insert character ``c'' back into input stream, ``count'' times  */
end_comment

begin_function
name|int
name|rl_insert
parameter_list|(
name|int
name|count
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|char
name|arr
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|e
operator|==
name|NULL
condition|)
name|rl_initialize
argument_list|()
expr_stmt|;
comment|/* XXX - int -> char conversion can lose on multichars */
name|arr
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
name|arr
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
name|el_push
argument_list|(
name|e
argument_list|,
name|arr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|rl_insert_text
parameter_list|(
specifier|const
name|char
modifier|*
name|text
parameter_list|)
block|{
if|if
condition|(
operator|!
name|text
operator|||
operator|*
name|text
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|h
operator|==
name|NULL
operator|||
name|e
operator|==
name|NULL
condition|)
name|rl_initialize
argument_list|()
expr_stmt|;
if|if
condition|(
name|el_insertstr
argument_list|(
name|e
argument_list|,
name|text
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|text
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_decl_stmt
name|int
name|rl_newline
argument_list|(
name|int
name|count
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|,
name|int
name|c
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|)
block|{
comment|/* 	 * Readline-4.0 appears to ignore the args. 	 */
return|return
name|rl_insert
argument_list|(
literal|1
argument_list|,
literal|'\n'
argument_list|)
return|;
block|}
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|rl_bind_wrapper
argument_list|(
name|EditLine
operator|*
name|el
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|,
name|unsigned
name|char
name|c
argument_list|)
block|{
if|if
condition|(
name|map
index|[
name|c
index|]
operator|==
name|NULL
condition|)
return|return
name|CC_ERROR
return|;
name|_rl_update_pos
argument_list|()
expr_stmt|;
call|(
modifier|*
name|map
index|[
name|c
index|]
call|)
argument_list|(
name|NULL
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* If rl_done was set by the above call, deal with it here */
if|if
condition|(
name|rl_done
condition|)
return|return
name|CC_EOF
return|;
return|return
name|CC_NORM
return|;
block|}
end_decl_stmt

begin_function
name|int
name|rl_add_defun
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|Function
modifier|*
name|fun
parameter_list|,
name|int
name|c
parameter_list|)
block|{
name|char
name|dest
index|[
literal|8
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|size_t
operator|)
name|c
operator|>=
sizeof|sizeof
argument_list|(
name|map
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|map
index|[
literal|0
index|]
argument_list|)
operator|||
name|c
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|map
index|[
operator|(
name|unsigned
name|char
operator|)
name|c
index|]
operator|=
name|fun
expr_stmt|;
name|el_set
argument_list|(
name|e
argument_list|,
name|EL_ADDFN
argument_list|,
name|name
argument_list|,
name|name
argument_list|,
name|rl_bind_wrapper
argument_list|)
expr_stmt|;
name|vis
argument_list|(
name|dest
argument_list|,
name|c
argument_list|,
name|VIS_WHITE
operator||
name|VIS_NOSLASH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|el_set
argument_list|(
name|e
argument_list|,
name|EL_BIND
argument_list|,
name|dest
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|rl_callback_read_char
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|,
name|done
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|buf
init|=
name|el_gets
argument_list|(
name|e
argument_list|,
operator|&
name|count
argument_list|)
decl_stmt|;
name|char
modifier|*
name|wbuf
decl_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
operator|||
name|count
operator|--
operator|<=
literal|0
condition|)
return|return;
if|if
condition|(
name|count
operator|==
literal|0
operator|&&
name|buf
index|[
literal|0
index|]
operator|==
name|e
operator|->
name|el_tty
operator|.
name|t_c
index|[
name|TS_IO
index|]
index|[
name|C_EOF
index|]
condition|)
name|done
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|count
index|]
operator|==
literal|'\n'
operator|||
name|buf
index|[
name|count
index|]
operator|==
literal|'\r'
condition|)
name|done
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|done
operator|&&
name|rl_linefunc
operator|!=
name|NULL
condition|)
block|{
name|el_set
argument_list|(
name|e
argument_list|,
name|EL_UNBUFFERED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|done
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|wbuf
operator|=
name|strdup
argument_list|(
name|buf
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|wbuf
index|[
name|count
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|wbuf
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
operator|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
operator|)
name|rl_linefunc
operator|)
operator|(
name|wbuf
operator|)
expr_stmt|;
name|el_set
argument_list|(
name|e
argument_list|,
name|EL_UNBUFFERED
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|rl_callback_handler_install
parameter_list|(
specifier|const
name|char
modifier|*
name|prompt
parameter_list|,
name|VCPFunction
modifier|*
name|linefunc
parameter_list|)
block|{
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
block|{
name|rl_initialize
argument_list|()
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|rl_set_prompt
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
name|rl_linefunc
operator|=
name|linefunc
expr_stmt|;
name|el_set
argument_list|(
name|e
argument_list|,
name|EL_UNBUFFERED
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rl_callback_handler_remove
parameter_list|(
name|void
parameter_list|)
block|{
name|el_set
argument_list|(
name|e
argument_list|,
name|EL_UNBUFFERED
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rl_linefunc
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rl_redisplay
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|a
index|[
literal|2
index|]
decl_stmt|;
name|a
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
name|e
operator|->
name|el_tty
operator|.
name|t_c
index|[
name|TS_IO
index|]
index|[
name|C_REPRINT
index|]
expr_stmt|;
name|a
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|el_push
argument_list|(
name|e
argument_list|,
name|a
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|rl_get_previous_history
parameter_list|(
name|int
name|count
parameter_list|,
name|int
name|key
parameter_list|)
block|{
name|char
name|a
index|[
literal|2
index|]
decl_stmt|;
name|a
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
name|key
expr_stmt|;
name|a
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
name|el_push
argument_list|(
name|e
argument_list|,
name|a
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_decl_stmt
name|void
comment|/*ARGSUSED*/
name|rl_prep_terminal
argument_list|(
name|int
name|meta_flag
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|)
block|{
name|el_set
argument_list|(
name|e
argument_list|,
name|EL_PREP_TERM
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_function
name|void
name|rl_deprep_terminal
parameter_list|(
name|void
parameter_list|)
block|{
name|el_set
argument_list|(
name|e
argument_list|,
name|EL_PREP_TERM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|rl_read_init_file
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
return|return
name|el_source
argument_list|(
name|e
argument_list|,
name|s
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|rl_parse_and_bind
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|)
block|{
specifier|const
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
name|int
name|argc
decl_stmt|;
name|Tokenizer
modifier|*
name|tok
decl_stmt|;
name|tok
operator|=
name|tok_init
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|tok_str
argument_list|(
name|tok
argument_list|,
name|line
argument_list|,
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
name|argc
operator|=
name|el_parse
argument_list|(
name|e
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|tok_end
argument_list|(
name|tok
argument_list|)
expr_stmt|;
return|return
name|argc
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_function
name|int
name|rl_variable_bind
parameter_list|(
specifier|const
name|char
modifier|*
name|var
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
comment|/* 	 * The proper return value is undocument, but this is what the 	 * readline source seems to do. 	 */
return|return
name|el_set
argument_list|(
name|e
argument_list|,
name|EL_BIND
argument_list|,
literal|""
argument_list|,
name|var
argument_list|,
name|value
argument_list|,
name|NULL
argument_list|)
operator|==
operator|-
literal|1
condition|?
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_function
name|void
name|rl_stuff_char
parameter_list|(
name|int
name|c
parameter_list|)
block|{
name|char
name|buf
index|[
literal|2
index|]
decl_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|el_insertstr
argument_list|(
name|e
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|_rl_event_read_char
parameter_list|(
name|EditLine
modifier|*
name|el
parameter_list|,
name|char
modifier|*
name|cp
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|ssize_t
name|num_read
init|=
literal|0
decl_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|rl_event_hook
condition|)
block|{
call|(
modifier|*
name|rl_event_hook
call|)
argument_list|()
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|FIONREAD
argument_list|)
if|if
condition|(
name|ioctl
argument_list|(
name|el
operator|->
name|el_infd
argument_list|,
name|FIONREAD
argument_list|,
operator|&
name|n
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|n
condition|)
name|num_read
operator|=
name|read
argument_list|(
name|el
operator|->
name|el_infd
argument_list|,
name|cp
argument_list|,
operator|(
name|size_t
operator|)
literal|1
argument_list|)
expr_stmt|;
else|else
name|num_read
operator|=
literal|0
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|F_SETFL
argument_list|)
operator|&&
name|defined
argument_list|(
name|O_NDELAY
argument_list|)
if|if
condition|(
operator|(
name|n
operator|=
name|fcntl
argument_list|(
name|el
operator|->
name|el_infd
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|fcntl
argument_list|(
name|el
operator|->
name|el_infd
argument_list|,
name|F_SETFL
argument_list|,
name|n
operator||
name|O_NDELAY
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
name|num_read
operator|=
name|read
argument_list|(
name|el
operator|->
name|el_infd
argument_list|,
name|cp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fcntl
argument_list|(
name|el
operator|->
name|el_infd
argument_list|,
name|F_SETFL
argument_list|,
name|n
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
else|#
directive|else
comment|/* not non-blocking, but what you gonna do? */
name|num_read
operator|=
name|read
argument_list|(
name|el
operator|->
name|el_infd
argument_list|,
name|cp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
endif|#
directive|endif
if|if
condition|(
name|num_read
operator|<
literal|0
operator|&&
name|errno
operator|==
name|EAGAIN
condition|)
continue|continue;
if|if
condition|(
name|num_read
operator|==
literal|0
condition|)
continue|continue;
break|break;
block|}
if|if
condition|(
operator|!
name|rl_event_hook
condition|)
name|el_set
argument_list|(
name|el
argument_list|,
name|EL_GETCFN
argument_list|,
name|EL_BUILTIN_GETCFN
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|num_read
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|_rl_update_pos
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|LineInfo
modifier|*
name|li
init|=
name|el_line
argument_list|(
name|e
argument_list|)
decl_stmt|;
name|rl_point
operator|=
call|(
name|int
call|)
argument_list|(
name|li
operator|->
name|cursor
operator|-
name|li
operator|->
name|buffer
argument_list|)
expr_stmt|;
name|rl_end
operator|=
call|(
name|int
call|)
argument_list|(
name|li
operator|->
name|lastchar
operator|-
name|li
operator|->
name|buffer
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rl_get_screen_size
parameter_list|(
name|int
modifier|*
name|rows
parameter_list|,
name|int
modifier|*
name|cols
parameter_list|)
block|{
if|if
condition|(
name|rows
condition|)
name|el_get
argument_list|(
name|e
argument_list|,
name|EL_GETTC
argument_list|,
literal|"li"
argument_list|,
name|rows
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|cols
condition|)
name|el_get
argument_list|(
name|e
argument_list|,
name|EL_GETTC
argument_list|,
literal|"co"
argument_list|,
name|cols
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rl_set_screen_size
parameter_list|(
name|int
name|rows
parameter_list|,
name|int
name|cols
parameter_list|)
block|{
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|rows
argument_list|)
expr_stmt|;
name|el_set
argument_list|(
name|e
argument_list|,
name|EL_SETTC
argument_list|,
literal|"li"
argument_list|,
name|buf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|cols
argument_list|)
expr_stmt|;
name|el_set
argument_list|(
name|e
argument_list|,
name|EL_SETTC
argument_list|,
literal|"co"
argument_list|,
name|buf
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
modifier|*
name|rl_completion_matches
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|rl_compentry_func_t
modifier|*
name|fun
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|,
name|max
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|min
decl_stmt|;
name|char
modifier|*
modifier|*
name|list
decl_stmt|,
modifier|*
name|match
decl_stmt|,
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
name|max
operator|=
literal|10
expr_stmt|;
if|if
condition|(
operator|(
name|list
operator|=
name|el_malloc
argument_list|(
name|max
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|list
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
while|while
condition|(
operator|(
name|match
operator|=
call|(
modifier|*
name|fun
call|)
argument_list|(
name|str
argument_list|,
call|(
name|int
call|)
argument_list|(
name|len
operator|-
literal|1
argument_list|)
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|list
index|[
name|len
operator|++
index|]
operator|=
name|match
expr_stmt|;
if|if
condition|(
name|len
operator|==
name|max
condition|)
block|{
name|char
modifier|*
modifier|*
name|nl
decl_stmt|;
name|max
operator|+=
literal|10
expr_stmt|;
if|if
condition|(
operator|(
name|nl
operator|=
name|el_realloc
argument_list|(
name|list
argument_list|,
name|max
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|nl
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|list
operator|=
name|nl
expr_stmt|;
block|}
block|}
if|if
condition|(
name|len
operator|==
literal|1
condition|)
goto|goto
name|out
goto|;
name|list
index|[
name|len
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|2
condition|)
block|{
if|if
condition|(
operator|(
name|list
index|[
literal|0
index|]
operator|=
name|strdup
argument_list|(
name|list
index|[
literal|1
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
return|return
name|list
return|;
block|}
name|qsort
argument_list|(
operator|&
name|list
index|[
literal|1
index|]
argument_list|,
name|len
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|list
argument_list|)
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|strcmp
argument_list|)
expr_stmt|;
name|min
operator|=
name|SIZE_T_MAX
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
operator|,
name|a
operator|=
name|list
index|[
name|i
index|]
init|;
name|i
operator|<
name|len
operator|-
literal|1
condition|;
name|i
operator|++
operator|,
name|a
operator|=
name|b
control|)
block|{
name|b
operator|=
name|list
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|a
index|[
name|j
index|]
operator|&&
name|a
index|[
name|j
index|]
operator|==
name|b
index|[
name|j
index|]
condition|;
name|j
operator|++
control|)
continue|continue;
if|if
condition|(
name|min
operator|>
name|j
condition|)
name|min
operator|=
name|j
expr_stmt|;
block|}
if|if
condition|(
name|min
operator|==
literal|0
operator|&&
operator|*
name|str
condition|)
block|{
if|if
condition|(
operator|(
name|list
index|[
literal|0
index|]
operator|=
name|strdup
argument_list|(
name|str
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|list
index|[
literal|0
index|]
operator|=
name|el_malloc
argument_list|(
operator|(
name|min
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|list
index|[
literal|0
index|]
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|list
index|[
literal|0
index|]
argument_list|,
name|list
index|[
literal|1
index|]
argument_list|,
name|min
argument_list|)
expr_stmt|;
name|list
index|[
literal|0
index|]
index|[
name|min
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|list
return|;
name|out
label|:
name|el_free
argument_list|(
name|list
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|rl_filename_completion_function
parameter_list|(
specifier|const
name|char
modifier|*
name|text
parameter_list|,
name|int
name|state
parameter_list|)
block|{
return|return
name|fn_filename_completion_function
argument_list|(
name|text
argument_list|,
name|state
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|rl_forced_update_display
parameter_list|(
name|void
parameter_list|)
block|{
name|el_set
argument_list|(
name|e
argument_list|,
name|EL_REFRESH
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|_rl_abort_internal
parameter_list|(
name|void
parameter_list|)
block|{
name|el_beep
argument_list|(
name|e
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|topbuf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_function
name|int
name|_rl_qsort_string_compare
parameter_list|(
name|char
modifier|*
modifier|*
name|s1
parameter_list|,
name|char
modifier|*
modifier|*
name|s2
parameter_list|)
block|{
return|return
name|strcoll
argument_list|(
operator|*
name|s1
argument_list|,
operator|*
name|s2
argument_list|)
return|;
block|}
end_function

begin_function
name|HISTORY_STATE
modifier|*
name|history_get_history_state
parameter_list|(
name|void
parameter_list|)
block|{
name|HISTORY_STATE
modifier|*
name|hs
decl_stmt|;
if|if
condition|(
operator|(
name|hs
operator|=
name|el_malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|hs
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|hs
operator|->
name|length
operator|=
name|history_length
expr_stmt|;
return|return
name|hs
return|;
block|}
end_function

begin_decl_stmt
name|int
comment|/*ARGSUSED*/
name|rl_kill_text
argument_list|(
name|int
name|from
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|,
name|int
name|to
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|)
block|{
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_function
name|Keymap
name|rl_make_bare_keymap
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|Keymap
name|rl_get_keymap
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_decl_stmt
name|void
comment|/*ARGSUSED*/
name|rl_set_keymap
argument_list|(
name|Keymap
name|k
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|)
block|{ }
end_decl_stmt

begin_decl_stmt
name|int
comment|/*ARGSUSED*/
name|rl_generic_bind
argument_list|(
name|int
name|type
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|,
specifier|const
name|char
operator|*
name|keyseq
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|,
specifier|const
name|char
operator|*
name|data
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|,
name|Keymap
name|k
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|)
block|{
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_decl_stmt
name|int
comment|/*ARGSUSED*/
name|rl_bind_key_in_map
argument_list|(
name|int
name|key
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|,
name|rl_command_func_t
operator|*
name|fun
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|,
name|Keymap
name|k
name|__attribute__
argument_list|(
operator|(
name|__unused__
operator|)
argument_list|)
argument_list|)
block|{
return|return
literal|0
return|;
block|}
end_decl_stmt

begin_comment
comment|/* unsupported, but needed by python */
end_comment

begin_function
name|void
name|rl_cleanup_after_signal
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

begin_function
name|int
name|rl_on_new_line
parameter_list|(
name|void
parameter_list|)
block|{
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|rl_free_line_state
parameter_list|(
name|void
parameter_list|)
block|{ }
end_function

end_unit

