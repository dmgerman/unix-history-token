begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * regcomp and regexec -- regsub and regerror are elsewhere  *  *	Copyright (c) 1986 by University of Toronto.  *	Written by Henry Spencer.  Not derived from licensed software.  *  *	Permission is granted to anyone to use this software for any  *	purpose on any computer system, and to redistribute it freely,  *	subject to the following restrictions:  *  *	1. The author is not responsible for the consequences of use of  *		this software, no matter how awful, even if they arise  *		from defects in it.  *  *	2. The origin of this software must not be misrepresented, either  *		by explicit claim or by omission.  *  *	3. Altered versions must be plainly marked as such, and must not  *		be misrepresented as being the original software.  *** THIS IS AN ALTERED VERSION.  It was altered by John Gilmore,  *** hoptoad!gnu, on 27 Dec 1986, to add \n as an alternative to |  *** to assist in implementing egrep.  *** THIS IS AN ALTERED VERSION.  It was altered by John Gilmore,  *** hoptoad!gnu, on 27 Dec 1986, to add \< and \> for word-matching  *** as in BSD grep and ex.  *** THIS IS AN ALTERED VERSION.  It was altered by John Gilmore,  *** hoptoad!gnu, on 28 Dec 1986, to optimize characters quoted with \.  *** THIS IS AN ALTERED VERSION.  It was altered by James A. Woods,  *** ames!jaw, on 19 June 1987, to quash a regcomp() redundancy.  *  * Beware that some of this code is subtly aware of the way operator  * precedence is structured in regular expressions.  Serious changes in  * regular-expression syntax might require a total rethink.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<regexp.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"collate.h"
end_include

begin_include
include|#
directive|include
file|"regmagic.h"
end_include

begin_comment
comment|/*  * The "internal use only" fields in regexp.h are present to pass info from  * compile to execute that permits the execute phase to run lots faster on  * simple cases.  They are:  *  * regstart	char that must begin a match; '\0' if none obvious  * reganch	is the match anchored (at beginning-of-line only)?  * regmust	string (pointer into program) that match must include, or NULL  * regmlen	length of regmust string  *  * Regstart and reganch permit very fast decisions on suitable starting points  * for a match, cutting down the work a lot.  Regmust permits fast rejection  * of lines that cannot possibly match.  The regmust tests are costly enough  * that regcomp() supplies a regmust only if the r.e. contains something  * potentially expensive (at present, the only such thing detected is * or +  * at the start of the r.e., which can involve a lot of backup).  Regmlen is  * supplied because the test in regexec() needs it and regcomp() is computing  * it anyway.  */
end_comment

begin_comment
comment|/*  * Structure for regexp "program".  This is essentially a linear encoding  * of a nondeterministic finite-state machine (aka syntax charts or  * "railroad normal form" in parsing technology).  Each node is an opcode  * plus a "next" pointer, possibly plus an operand.  "Next" pointers of  * all nodes except BRANCH implement concatenation; a "next" pointer with  * a BRANCH on both ends of it is connecting two alternatives.  (Here we  * have one of the subtle syntax dependencies:  an individual BRANCH (as  * opposed to a collection of them) is never concatenated with anything  * because of operator precedence.)  The operand of some types of node is  * a literal string; for others, it is a node leading into a sub-FSM.  In  * particular, the operand of a BRANCH node is the first node of the branch.  * (NB this is *not* a tree structure:  the tail of the branch connects  * to the thing following the set of BRANCHes.)  The opcodes are:  */
end_comment

begin_comment
comment|/* definition	number	opnd?	meaning */
end_comment

begin_define
define|#
directive|define
name|END
value|0
end_define

begin_comment
comment|/* no	End of program. */
end_comment

begin_define
define|#
directive|define
name|BOL
value|1
end_define

begin_comment
comment|/* no	Match "" at beginning of line. */
end_comment

begin_define
define|#
directive|define
name|EOL
value|2
end_define

begin_comment
comment|/* no	Match "" at end of line. */
end_comment

begin_define
define|#
directive|define
name|ANY
value|3
end_define

begin_comment
comment|/* no	Match any one character. */
end_comment

begin_define
define|#
directive|define
name|ANYOF
value|4
end_define

begin_comment
comment|/* str	Match any character in this string. */
end_comment

begin_define
define|#
directive|define
name|ANYBUT
value|5
end_define

begin_comment
comment|/* str	Match any character not in this string. */
end_comment

begin_define
define|#
directive|define
name|BRANCH
value|6
end_define

begin_comment
comment|/* node	Match this alternative, or the next... */
end_comment

begin_define
define|#
directive|define
name|BACK
value|7
end_define

begin_comment
comment|/* no	Match "", "next" ptr points backward. */
end_comment

begin_define
define|#
directive|define
name|EXACTLY
value|8
end_define

begin_comment
comment|/* str	Match this string. */
end_comment

begin_define
define|#
directive|define
name|NOTHING
value|9
end_define

begin_comment
comment|/* no	Match empty string. */
end_comment

begin_define
define|#
directive|define
name|STAR
value|10
end_define

begin_comment
comment|/* node	Match this (simple) thing 0 or more times. */
end_comment

begin_define
define|#
directive|define
name|PLUS
value|11
end_define

begin_comment
comment|/* node	Match this (simple) thing 1 or more times. */
end_comment

begin_define
define|#
directive|define
name|WORDA
value|12
end_define

begin_comment
comment|/* no	Match "" at wordchar, where prev is nonword */
end_comment

begin_define
define|#
directive|define
name|WORDZ
value|13
end_define

begin_comment
comment|/* no	Match "" at nonwordchar, where prev is word */
end_comment

begin_define
define|#
directive|define
name|OPEN
value|20
end_define

begin_comment
comment|/* no	Mark this point in input as start of #n. */
end_comment

begin_comment
comment|/*	OPEN+1 is number 1, etc. */
end_comment

begin_define
define|#
directive|define
name|CLOSE
value|30
end_define

begin_comment
comment|/* no	Analogous to OPEN. */
end_comment

begin_comment
comment|/*  * Opcode notes:  *  * BRANCH	The set of branches constituting a single choice are hooked  *		together with their "next" pointers, since precedence prevents  *		anything being concatenated to any individual branch.  The  *		"next" pointer of the last BRANCH in a choice points to the  *		thing following the whole choice.  This is also where the  *		final "next" pointer of each individual branch points; each  *		branch starts with the operand node of a BRANCH node.  *  * BACK		Normal "next" pointers all implicitly point forward; BACK  *		exists to make loop structures possible.  *  * STAR,PLUS	'?', and complex '*' and '+', are implemented as circular  *		BRANCH structures using BACK.  Simple cases (one character  *		per match) are implemented with STAR and PLUS for speed  *		and to minimize recursive plunges.  *  * OPEN,CLOSE	...are numbered at compile time.  */
end_comment

begin_comment
comment|/*  * A node is one char of opcode followed by two chars of "next" pointer.  * "Next" pointers are stored as two 8-bit pieces, high order first.  The  * value is a positive offset from the opcode of the node containing it.  * An operand, if any, simply follows the node.  (Note that much of the  * code generation knows about this implicit relationship.)  *  * Using two bytes for the "next" pointer is vast overkill for most things,  * but allows patterns to get big without disasters.  */
end_comment

begin_define
define|#
directive|define
name|OP
parameter_list|(
name|p
parameter_list|)
value|(*(p))
end_define

begin_define
define|#
directive|define
name|NEXT
parameter_list|(
name|p
parameter_list|)
value|(((*((p)+1)&0377)<<8) + (*((p)+2)&0377))
end_define

begin_define
define|#
directive|define
name|OPERAND
parameter_list|(
name|p
parameter_list|)
value|((p) + 3)
end_define

begin_comment
comment|/*  * See regmagic.h for one further detail of program structure.  */
end_comment

begin_comment
comment|/*  * Utility definitions.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|CHARBITS
end_ifndef

begin_define
define|#
directive|define
name|UCHARAT
parameter_list|(
name|p
parameter_list|)
value|((int)*(unsigned char *)(p))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|UCHARAT
parameter_list|(
name|p
parameter_list|)
value|((int)*(p)&CHARBITS)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|FAIL
parameter_list|(
name|m
parameter_list|)
value|{ regerror(m); return(NULL); }
end_define

begin_define
define|#
directive|define
name|ISMULT
parameter_list|(
name|c
parameter_list|)
value|((c) == '*' || (c) == '+' || (c) == '?')
end_define

begin_comment
comment|/*  * Flags to be passed up and down.  */
end_comment

begin_define
define|#
directive|define
name|HASWIDTH
value|01
end_define

begin_comment
comment|/* Known never to match null string. */
end_comment

begin_define
define|#
directive|define
name|SIMPLE
value|02
end_define

begin_comment
comment|/* Simple enough to be STAR/PLUS operand. */
end_comment

begin_define
define|#
directive|define
name|SPSTART
value|04
end_define

begin_comment
comment|/* Starts with * or +. */
end_comment

begin_define
define|#
directive|define
name|WORST
value|0
end_define

begin_comment
comment|/* Worst case. */
end_comment

begin_comment
comment|/*  * Global work variables for regcomp().  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|regparse
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Input-scan pointer. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|regnpar
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* () count. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|regdummy
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|regcode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Code-emit pointer;&regdummy = don't. */
end_comment

begin_decl_stmt
specifier|static
name|long
name|regsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Code size. */
end_comment

begin_comment
comment|/*  * Forward declarations for regcomp()'s friends.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STATIC
end_ifndef

begin_define
define|#
directive|define
name|STATIC
value|static
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|STATIC
name|char
modifier|*
name|reg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|char
modifier|*
name|regbranch
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|char
modifier|*
name|regpiece
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|char
modifier|*
name|regatom
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|char
modifier|*
name|regnode
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|char
modifier|*
name|regnext
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|regc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|reginsert
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|regtail
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|void
name|regoptail
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|STRCSPN
end_ifdef

begin_function_decl
name|STATIC
name|int
name|strcspn
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  - regcomp - compile a regular expression into internal code  *  * We can't allocate space until we know how big the compiled form will be,  * but we can't compile it (and thus know how big it is) until we've got a  * place to put the code.  So we cheat:  we compile it twice, once with code  * generation turned off and size counting turned on, and once "for real".  * This also means that we don't allocate space until we are sure that the  * thing really will compile successfully, and we never have to move the  * code and thus invalidate pointers into it.  (Note that it has to be in  * one piece because free() must be able to free it all.)  *  * Beware that the optimization-preparation code in here knows about some  * of the structure of the compiled regexp.  */
end_comment

begin_function
name|regexp
modifier|*
name|regcomp
parameter_list|(
name|exp
parameter_list|)
specifier|const
name|char
modifier|*
name|exp
decl_stmt|;
block|{
name|regexp
modifier|*
name|r
decl_stmt|;
name|char
modifier|*
name|scan
decl_stmt|;
name|char
modifier|*
name|longest
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|flags
decl_stmt|;
if|if
condition|(
name|exp
operator|==
name|NULL
condition|)
name|FAIL
argument_list|(
literal|"NULL argument"
argument_list|)
expr_stmt|;
comment|/* First pass: determine size, legality. */
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|exp
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|exp
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
name|exp
operator|+=
literal|2
expr_stmt|;
comment|/* aid grep */
endif|#
directive|endif
name|regparse
operator|=
operator|(
name|char
operator|*
operator|)
name|exp
expr_stmt|;
name|regnpar
operator|=
literal|1
expr_stmt|;
name|regsize
operator|=
literal|0L
expr_stmt|;
name|regcode
operator|=
operator|&
name|regdummy
expr_stmt|;
name|regc
argument_list|(
name|MAGIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
argument_list|(
literal|0
argument_list|,
operator|&
name|flags
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Small enough for pointer-storage convention? */
if|if
condition|(
name|regsize
operator|>=
literal|32767L
condition|)
comment|/* Probably could be 65535L. */
name|FAIL
argument_list|(
literal|"regexp too big"
argument_list|)
expr_stmt|;
comment|/* Allocate space. */
name|r
operator|=
operator|(
name|regexp
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|regexp
argument_list|)
operator|+
operator|(
name|unsigned
operator|)
name|regsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
name|FAIL
argument_list|(
literal|"out of space"
argument_list|)
expr_stmt|;
comment|/* Second pass: emit code. */
name|regparse
operator|=
operator|(
name|char
operator|*
operator|)
name|exp
expr_stmt|;
name|regnpar
operator|=
literal|1
expr_stmt|;
name|regcode
operator|=
name|r
operator|->
name|program
expr_stmt|;
name|regc
argument_list|(
name|MAGIC
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg
argument_list|(
literal|0
argument_list|,
operator|&
name|flags
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Dig out information for optimizations. */
name|r
operator|->
name|regstart
operator|=
literal|'\0'
expr_stmt|;
comment|/* Worst-case defaults. */
name|r
operator|->
name|reganch
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|regmust
operator|=
name|NULL
expr_stmt|;
name|r
operator|->
name|regmlen
operator|=
literal|0
expr_stmt|;
name|scan
operator|=
name|r
operator|->
name|program
operator|+
literal|1
expr_stmt|;
comment|/* First BRANCH. */
if|if
condition|(
name|OP
argument_list|(
name|regnext
argument_list|(
name|scan
argument_list|)
argument_list|)
operator|==
name|END
condition|)
block|{
comment|/* Only one top-level choice. */
name|scan
operator|=
name|OPERAND
argument_list|(
name|scan
argument_list|)
expr_stmt|;
comment|/* Starting-point info. */
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|EXACTLY
condition|)
name|r
operator|->
name|regstart
operator|=
operator|*
name|OPERAND
argument_list|(
name|scan
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|BOL
condition|)
name|r
operator|->
name|reganch
operator|++
expr_stmt|;
comment|/* 		 * If there's something expensive in the r.e., find the 		 * longest literal string that must appear and make it the 		 * regmust.  Resolve ties in favor of later strings, since 		 * the regstart check works with the beginning of the r.e. 		 * and avoiding duplication strengthens checking.  Not a 		 * strong reason, but sufficient in the absence of others. 		 */
if|if
condition|(
name|flags
operator|&
name|SPSTART
condition|)
block|{
name|longest
operator|=
name|NULL
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
name|scan
operator|!=
name|NULL
condition|;
name|scan
operator|=
name|regnext
argument_list|(
name|scan
argument_list|)
control|)
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|EXACTLY
operator|&&
name|strlen
argument_list|(
name|OPERAND
argument_list|(
name|scan
argument_list|)
argument_list|)
operator|>=
name|len
condition|)
block|{
name|longest
operator|=
name|OPERAND
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|OPERAND
argument_list|(
name|scan
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|r
operator|->
name|regmust
operator|=
name|longest
expr_stmt|;
name|r
operator|->
name|regmlen
operator|=
name|len
expr_stmt|;
block|}
block|}
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - reg - regular expression, i.e. main body or parenthesized thing  *  * Caller must absorb opening parenthesis.  *  * Combining parenthesis handling with the base level of regular expression  * is a trifle forced, but the need to tie the tails of the branches to what  * follows makes it hard to avoid.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|reg
parameter_list|(
name|paren
parameter_list|,
name|flagp
parameter_list|)
name|int
name|paren
decl_stmt|;
comment|/* Parenthesized? */
name|int
modifier|*
name|flagp
decl_stmt|;
block|{
name|char
modifier|*
name|ret
decl_stmt|;
name|char
modifier|*
name|br
decl_stmt|;
name|char
modifier|*
name|ender
decl_stmt|;
name|int
name|parno
decl_stmt|;
name|int
name|flags
decl_stmt|;
operator|*
name|flagp
operator|=
name|HASWIDTH
expr_stmt|;
comment|/* Tentatively. */
comment|/* Make an OPEN node, if parenthesized. */
if|if
condition|(
name|paren
condition|)
block|{
if|if
condition|(
name|regnpar
operator|>=
name|NSUBEXP
condition|)
name|FAIL
argument_list|(
literal|"too many ()"
argument_list|)
expr_stmt|;
name|parno
operator|=
name|regnpar
expr_stmt|;
name|regnpar
operator|++
expr_stmt|;
name|ret
operator|=
name|regnode
argument_list|(
name|OPEN
operator|+
name|parno
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|NULL
expr_stmt|;
comment|/* Pick up the branches, linking them together. */
name|br
operator|=
name|regbranch
argument_list|(
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|br
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|ret
operator|!=
name|NULL
condition|)
name|regtail
argument_list|(
name|ret
argument_list|,
name|br
argument_list|)
expr_stmt|;
comment|/* OPEN -> first. */
else|else
name|ret
operator|=
name|br
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|HASWIDTH
operator|)
condition|)
operator|*
name|flagp
operator|&=
operator|~
name|HASWIDTH
expr_stmt|;
operator|*
name|flagp
operator||=
name|flags
operator|&
name|SPSTART
expr_stmt|;
while|while
condition|(
operator|*
name|regparse
operator|==
literal|'|'
operator|||
operator|*
name|regparse
operator|==
literal|'\n'
condition|)
block|{
name|regparse
operator|++
expr_stmt|;
name|br
operator|=
name|regbranch
argument_list|(
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|br
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|regtail
argument_list|(
name|ret
argument_list|,
name|br
argument_list|)
expr_stmt|;
comment|/* BRANCH -> BRANCH. */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|HASWIDTH
operator|)
condition|)
operator|*
name|flagp
operator|&=
operator|~
name|HASWIDTH
expr_stmt|;
operator|*
name|flagp
operator||=
name|flags
operator|&
name|SPSTART
expr_stmt|;
block|}
comment|/* Make a closing node, and hook it on the end. */
name|ender
operator|=
name|regnode
argument_list|(
operator|(
name|paren
operator|)
condition|?
name|CLOSE
operator|+
name|parno
else|:
name|END
argument_list|)
expr_stmt|;
name|regtail
argument_list|(
name|ret
argument_list|,
name|ender
argument_list|)
expr_stmt|;
comment|/* Hook the tails of the branches to the closing node. */
for|for
control|(
name|br
operator|=
name|ret
init|;
name|br
operator|!=
name|NULL
condition|;
name|br
operator|=
name|regnext
argument_list|(
name|br
argument_list|)
control|)
name|regoptail
argument_list|(
name|br
argument_list|,
name|ender
argument_list|)
expr_stmt|;
comment|/* Check for proper termination. */
if|if
condition|(
name|paren
operator|&&
operator|*
name|regparse
operator|++
operator|!=
literal|')'
condition|)
block|{
name|FAIL
argument_list|(
literal|"unmatched ()"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|paren
operator|&&
operator|*
name|regparse
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|regparse
operator|==
literal|')'
condition|)
block|{
name|FAIL
argument_list|(
literal|"unmatched ()"
argument_list|)
expr_stmt|;
block|}
else|else
name|FAIL
argument_list|(
literal|"junk on end"
argument_list|)
expr_stmt|;
comment|/* "Can't happen". */
comment|/* NOTREACHED */
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - regbranch - one alternative of an | operator  *  * Implements the concatenation operator.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|regbranch
parameter_list|(
name|flagp
parameter_list|)
name|int
modifier|*
name|flagp
decl_stmt|;
block|{
name|char
modifier|*
name|ret
decl_stmt|;
name|char
modifier|*
name|chain
decl_stmt|;
name|char
modifier|*
name|latest
decl_stmt|;
name|int
name|flags
decl_stmt|;
operator|*
name|flagp
operator|=
name|WORST
expr_stmt|;
comment|/* Tentatively. */
name|ret
operator|=
name|regnode
argument_list|(
name|BRANCH
argument_list|)
expr_stmt|;
name|chain
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|*
name|regparse
operator|!=
literal|'\0'
operator|&&
operator|*
name|regparse
operator|!=
literal|')'
operator|&&
operator|*
name|regparse
operator|!=
literal|'\n'
operator|&&
operator|*
name|regparse
operator|!=
literal|'|'
condition|)
block|{
name|latest
operator|=
name|regpiece
argument_list|(
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|latest
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
operator|*
name|flagp
operator||=
name|flags
operator|&
name|HASWIDTH
expr_stmt|;
if|if
condition|(
name|chain
operator|==
name|NULL
condition|)
comment|/* First piece. */
operator|*
name|flagp
operator||=
name|flags
operator|&
name|SPSTART
expr_stmt|;
else|else
name|regtail
argument_list|(
name|chain
argument_list|,
name|latest
argument_list|)
expr_stmt|;
name|chain
operator|=
name|latest
expr_stmt|;
block|}
if|if
condition|(
name|chain
operator|==
name|NULL
condition|)
comment|/* Loop ran zero times. */
operator|(
name|void
operator|)
name|regnode
argument_list|(
name|NOTHING
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - regpiece - something followed by possible [*+?]  *  * Note that the branching code sequences used for ? and the general cases  * of * and + are somewhat optimized:  they use the same NOTHING node as  * both the endmarker for their branch list and the body of the last branch.  * It might seem that this node could be dispensed with entirely, but the  * endmarker role is not redundant.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|regpiece
parameter_list|(
name|flagp
parameter_list|)
name|int
modifier|*
name|flagp
decl_stmt|;
block|{
name|char
modifier|*
name|ret
decl_stmt|;
name|char
name|op
decl_stmt|;
name|char
modifier|*
name|next
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|ret
operator|=
name|regatom
argument_list|(
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|op
operator|=
operator|*
name|regparse
expr_stmt|;
if|if
condition|(
operator|!
name|ISMULT
argument_list|(
name|op
argument_list|)
condition|)
block|{
operator|*
name|flagp
operator|=
name|flags
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|HASWIDTH
operator|)
operator|&&
name|op
operator|!=
literal|'?'
condition|)
name|FAIL
argument_list|(
literal|"*+ operand could be empty"
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator|=
operator|(
name|op
operator|!=
literal|'+'
operator|)
condition|?
operator|(
name|WORST
operator||
name|SPSTART
operator|)
else|:
operator|(
name|WORST
operator||
name|HASWIDTH
operator|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
literal|'*'
operator|&&
operator|(
name|flags
operator|&
name|SIMPLE
operator|)
condition|)
name|reginsert
argument_list|(
name|STAR
argument_list|,
name|ret
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|==
literal|'*'
condition|)
block|{
comment|/* Emit x* as (x&|), where& means "self". */
name|reginsert
argument_list|(
name|BRANCH
argument_list|,
name|ret
argument_list|)
expr_stmt|;
comment|/* Either x */
name|regoptail
argument_list|(
name|ret
argument_list|,
name|regnode
argument_list|(
name|BACK
argument_list|)
argument_list|)
expr_stmt|;
comment|/* and loop */
name|regoptail
argument_list|(
name|ret
argument_list|,
name|ret
argument_list|)
expr_stmt|;
comment|/* back */
name|regtail
argument_list|(
name|ret
argument_list|,
name|regnode
argument_list|(
name|BRANCH
argument_list|)
argument_list|)
expr_stmt|;
comment|/* or */
name|regtail
argument_list|(
name|ret
argument_list|,
name|regnode
argument_list|(
name|NOTHING
argument_list|)
argument_list|)
expr_stmt|;
comment|/* null. */
block|}
elseif|else
if|if
condition|(
name|op
operator|==
literal|'+'
operator|&&
operator|(
name|flags
operator|&
name|SIMPLE
operator|)
condition|)
name|reginsert
argument_list|(
name|PLUS
argument_list|,
name|ret
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|==
literal|'+'
condition|)
block|{
comment|/* Emit x+ as x(&|), where& means "self". */
name|next
operator|=
name|regnode
argument_list|(
name|BRANCH
argument_list|)
expr_stmt|;
comment|/* Either */
name|regtail
argument_list|(
name|ret
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|regtail
argument_list|(
name|regnode
argument_list|(
name|BACK
argument_list|)
argument_list|,
name|ret
argument_list|)
expr_stmt|;
comment|/* loop back */
name|regtail
argument_list|(
name|next
argument_list|,
name|regnode
argument_list|(
name|BRANCH
argument_list|)
argument_list|)
expr_stmt|;
comment|/* or */
name|regtail
argument_list|(
name|ret
argument_list|,
name|regnode
argument_list|(
name|NOTHING
argument_list|)
argument_list|)
expr_stmt|;
comment|/* null. */
block|}
elseif|else
if|if
condition|(
name|op
operator|==
literal|'?'
condition|)
block|{
comment|/* Emit x? as (x|) */
name|reginsert
argument_list|(
name|BRANCH
argument_list|,
name|ret
argument_list|)
expr_stmt|;
comment|/* Either x */
name|regtail
argument_list|(
name|ret
argument_list|,
name|regnode
argument_list|(
name|BRANCH
argument_list|)
argument_list|)
expr_stmt|;
comment|/* or */
name|next
operator|=
name|regnode
argument_list|(
name|NOTHING
argument_list|)
expr_stmt|;
comment|/* null. */
name|regtail
argument_list|(
name|ret
argument_list|,
name|next
argument_list|)
expr_stmt|;
name|regoptail
argument_list|(
name|ret
argument_list|,
name|next
argument_list|)
expr_stmt|;
block|}
name|regparse
operator|++
expr_stmt|;
if|if
condition|(
name|ISMULT
argument_list|(
operator|*
name|regparse
argument_list|)
condition|)
name|FAIL
argument_list|(
literal|"nested *?+"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - regatom - the lowest level  *  * Optimization:  gobbles an entire sequence of ordinary characters so that  * it can turn them into a single node, which is smaller to store and  * faster to run.  Backslashed characters are exceptions, each becoming a  * separate node; the code is simpler that way and it's not worth fixing.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|regatom
parameter_list|(
name|flagp
parameter_list|)
name|int
modifier|*
name|flagp
decl_stmt|;
block|{
name|char
modifier|*
name|ret
decl_stmt|;
name|int
name|flags
decl_stmt|;
operator|*
name|flagp
operator|=
name|WORST
expr_stmt|;
comment|/* Tentatively. */
switch|switch
condition|(
operator|*
name|regparse
operator|++
condition|)
block|{
comment|/* FIXME: these chars only have meaning at beg/end of pat? */
case|case
literal|'^'
case|:
name|ret
operator|=
name|regnode
argument_list|(
name|BOL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
name|ret
operator|=
name|regnode
argument_list|(
name|EOL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
name|ret
operator|=
name|regnode
argument_list|(
name|ANY
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|HASWIDTH
operator||
name|SIMPLE
expr_stmt|;
break|break;
case|case
literal|'['
case|:
block|{
name|int
name|class
decl_stmt|;
name|int
name|classend
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|*
name|regparse
operator|==
literal|'^'
condition|)
block|{
comment|/* Complement of range. */
name|ret
operator|=
name|regnode
argument_list|(
name|ANYBUT
argument_list|)
expr_stmt|;
name|regparse
operator|++
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|regnode
argument_list|(
name|ANYOF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|regparse
operator|==
literal|']'
operator|||
operator|*
name|regparse
operator|==
literal|'-'
condition|)
name|regc
argument_list|(
operator|*
name|regparse
operator|++
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|regparse
operator|!=
literal|'\0'
operator|&&
operator|*
name|regparse
operator|!=
literal|']'
condition|)
block|{
if|if
condition|(
operator|*
name|regparse
operator|==
literal|'-'
condition|)
block|{
name|regparse
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|regparse
operator|==
literal|']'
operator|||
operator|*
name|regparse
operator|==
literal|'\0'
condition|)
name|regc
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
else|else
block|{
name|class
operator|=
name|UCHARAT
argument_list|(
name|regparse
operator|-
literal|2
argument_list|)
expr_stmt|;
name|classend
operator|=
name|UCHARAT
argument_list|(
name|regparse
argument_list|)
expr_stmt|;
if|if
condition|(
name|__collate_load_error
condition|)
block|{
if|if
condition|(
name|class
operator|>
name|classend
condition|)
name|FAIL
argument_list|(
literal|"invalid [] range"
argument_list|)
expr_stmt|;
for|for
control|(
name|class
operator|++
init|;
name|class
operator|<=
name|classend
condition|;
name|class
operator|++
control|)
name|regc
argument_list|(
name|class
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|__collate_range_cmp
argument_list|(
name|class
argument_list|,
name|classend
argument_list|)
operator|>
literal|0
condition|)
name|FAIL
argument_list|(
literal|"invalid [] range"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|UCHAR_MAX
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|i
operator|!=
name|class
operator|&&
name|__collate_range_cmp
argument_list|(
name|class
argument_list|,
name|i
argument_list|)
operator|<=
literal|0
operator|&&
name|__collate_range_cmp
argument_list|(
name|i
argument_list|,
name|classend
argument_list|)
operator|<=
literal|0
condition|)
name|regc
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
name|regparse
operator|++
expr_stmt|;
block|}
block|}
else|else
name|regc
argument_list|(
operator|*
name|regparse
operator|++
argument_list|)
expr_stmt|;
block|}
name|regc
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|regparse
operator|!=
literal|']'
condition|)
name|FAIL
argument_list|(
literal|"unmatched []"
argument_list|)
expr_stmt|;
name|regparse
operator|++
expr_stmt|;
operator|*
name|flagp
operator||=
name|HASWIDTH
operator||
name|SIMPLE
expr_stmt|;
block|}
break|break;
case|case
literal|'('
case|:
name|ret
operator|=
name|reg
argument_list|(
literal|1
argument_list|,
operator|&
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
operator|*
name|flagp
operator||=
name|flags
operator|&
operator|(
name|HASWIDTH
operator||
name|SPSTART
operator|)
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
case|case
literal|'|'
case|:
case|case
literal|'\n'
case|:
case|case
literal|')'
case|:
name|FAIL
argument_list|(
literal|"internal urp"
argument_list|)
expr_stmt|;
comment|/* Supposed to be caught earlier. */
break|break;
case|case
literal|'?'
case|:
case|case
literal|'+'
case|:
case|case
literal|'*'
case|:
name|FAIL
argument_list|(
literal|"?+* follows nothing"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
switch|switch
condition|(
operator|*
name|regparse
operator|++
condition|)
block|{
case|case
literal|'\0'
case|:
name|FAIL
argument_list|(
literal|"trailing \\"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|ret
operator|=
name|regnode
argument_list|(
name|WORDA
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|ret
operator|=
name|regnode
argument_list|(
name|WORDZ
argument_list|)
expr_stmt|;
break|break;
comment|/* FIXME: Someday handle \1, \2, ... */
default|default:
comment|/* Handle general quoted chars in exact-match routine */
goto|goto
name|de_fault
goto|;
block|}
break|break;
name|de_fault
label|:
default|default:
comment|/* 		 * Encode a string of characters to be matched exactly. 		 * 		 * This is a bit tricky due to quoted chars and due to 		 * '*', '+', and '?' taking the SINGLE char previous 		 * as their operand. 		 * 		 * On entry, the char at regparse[-1] is going to go 		 * into the string, no matter what it is.  (It could be 		 * following a \ if we are entered from the '\' case.) 		 * 		 * Basic idea is to pick up a good char in  ch  and 		 * examine the next char.  If it's *+? then we twiddle. 		 * If it's \ then we frozzle.  If it's other magic char 		 * we push  ch  and terminate the string.  If none of the 		 * above, we push  ch  on the string and go around again. 		 * 		 *  regprev  is used to remember where "the current char" 		 * starts in the string, if due to a *+? we need to back 		 * up and put the current char in a separate, 1-char, string. 		 * When  regprev  is NULL,  ch  is the only char in the 		 * string; this is used in *+? handling, and in setting 		 * flags |= SIMPLE at the end. 		 */
block|{
name|char
modifier|*
name|regprev
decl_stmt|;
name|char
name|ch
decl_stmt|;
name|regparse
operator|--
expr_stmt|;
comment|/* Look at cur char */
name|ret
operator|=
name|regnode
argument_list|(
name|EXACTLY
argument_list|)
expr_stmt|;
for|for
control|(
name|regprev
operator|=
literal|0
init|;
condition|;
control|)
block|{
name|ch
operator|=
operator|*
name|regparse
operator|++
expr_stmt|;
comment|/* Get current char */
switch|switch
condition|(
operator|*
name|regparse
condition|)
block|{
comment|/* look at next one */
default|default:
name|regc
argument_list|(
name|ch
argument_list|)
expr_stmt|;
comment|/* Add cur to string */
break|break;
case|case
literal|'.'
case|:
case|case
literal|'['
case|:
case|case
literal|'('
case|:
case|case
literal|')'
case|:
case|case
literal|'|'
case|:
case|case
literal|'\n'
case|:
case|case
literal|'$'
case|:
case|case
literal|'^'
case|:
case|case
literal|'\0'
case|:
comment|/* FIXME, $ and ^ should not always be magic */
name|magic
label|:
name|regc
argument_list|(
name|ch
argument_list|)
expr_stmt|;
comment|/* dump cur char */
goto|goto
name|done
goto|;
comment|/* and we are done */
case|case
literal|'?'
case|:
case|case
literal|'+'
case|:
case|case
literal|'*'
case|:
if|if
condition|(
operator|!
name|regprev
condition|)
comment|/* If just ch in str, */
goto|goto
name|magic
goto|;
comment|/* use it */
comment|/* End mult-char string one early */
name|regparse
operator|=
name|regprev
expr_stmt|;
comment|/* Back up parse */
goto|goto
name|done
goto|;
case|case
literal|'\\'
case|:
name|regc
argument_list|(
name|ch
argument_list|)
expr_stmt|;
comment|/* Cur char OK */
switch|switch
condition|(
name|regparse
index|[
literal|1
index|]
condition|)
block|{
comment|/* Look after \ */
case|case
literal|'\0'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
comment|/* FIXME: Someday handle \1, \2, ... */
goto|goto
name|done
goto|;
comment|/* Not quoted */
default|default:
comment|/* Backup point is \, scan							 * point is after it. */
name|regprev
operator|=
name|regparse
expr_stmt|;
name|regparse
operator|++
expr_stmt|;
continue|continue;
comment|/* NOT break; */
block|}
block|}
name|regprev
operator|=
name|regparse
expr_stmt|;
comment|/* Set backup point */
block|}
name|done
label|:
name|regc
argument_list|(
literal|'\0'
argument_list|)
expr_stmt|;
operator|*
name|flagp
operator||=
name|HASWIDTH
expr_stmt|;
if|if
condition|(
operator|!
name|regprev
condition|)
comment|/* One char? */
operator|*
name|flagp
operator||=
name|SIMPLE
expr_stmt|;
block|}
break|break;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - regnode - emit a node  */
end_comment

begin_function
specifier|static
name|char
modifier|*
comment|/* Location. */
name|regnode
parameter_list|(
name|op
parameter_list|)
name|char
name|op
decl_stmt|;
block|{
name|char
modifier|*
name|ret
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|ret
operator|=
name|regcode
expr_stmt|;
if|if
condition|(
name|ret
operator|==
operator|&
name|regdummy
condition|)
block|{
name|regsize
operator|+=
literal|3
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|ptr
operator|=
name|ret
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
name|op
expr_stmt|;
operator|*
name|ptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
comment|/* Null "next" pointer. */
operator|*
name|ptr
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|regcode
operator|=
name|ptr
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - regc - emit (if appropriate) a byte of code  */
end_comment

begin_function
specifier|static
name|void
name|regc
parameter_list|(
name|b
parameter_list|)
name|char
name|b
decl_stmt|;
block|{
if|if
condition|(
name|regcode
operator|!=
operator|&
name|regdummy
condition|)
operator|*
name|regcode
operator|++
operator|=
name|b
expr_stmt|;
else|else
name|regsize
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - reginsert - insert an operator in front of already-emitted operand  *  * Means relocating the operand.  */
end_comment

begin_function
specifier|static
name|void
name|reginsert
parameter_list|(
name|op
parameter_list|,
name|opnd
parameter_list|)
name|char
name|op
decl_stmt|;
name|char
modifier|*
name|opnd
decl_stmt|;
block|{
name|char
modifier|*
name|src
decl_stmt|;
name|char
modifier|*
name|dst
decl_stmt|;
name|char
modifier|*
name|place
decl_stmt|;
if|if
condition|(
name|regcode
operator|==
operator|&
name|regdummy
condition|)
block|{
name|regsize
operator|+=
literal|3
expr_stmt|;
return|return;
block|}
name|src
operator|=
name|regcode
expr_stmt|;
name|regcode
operator|+=
literal|3
expr_stmt|;
name|dst
operator|=
name|regcode
expr_stmt|;
while|while
condition|(
name|src
operator|>
name|opnd
condition|)
operator|*
operator|--
name|dst
operator|=
operator|*
operator|--
name|src
expr_stmt|;
name|place
operator|=
name|opnd
expr_stmt|;
comment|/* Op node, where operand used to be. */
operator|*
name|place
operator|++
operator|=
name|op
expr_stmt|;
operator|*
name|place
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|place
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - regtail - set the next-pointer at the end of a node chain  */
end_comment

begin_function
specifier|static
name|void
name|regtail
parameter_list|(
name|p
parameter_list|,
name|val
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
block|{
name|char
modifier|*
name|scan
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|int
name|offset
decl_stmt|;
if|if
condition|(
name|p
operator|==
operator|&
name|regdummy
condition|)
return|return;
comment|/* Find last node. */
name|scan
operator|=
name|p
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|temp
operator|=
name|regnext
argument_list|(
name|scan
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|==
name|NULL
condition|)
break|break;
name|scan
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|BACK
condition|)
name|offset
operator|=
name|scan
operator|-
name|val
expr_stmt|;
else|else
name|offset
operator|=
name|val
operator|-
name|scan
expr_stmt|;
operator|*
operator|(
name|scan
operator|+
literal|1
operator|)
operator|=
operator|(
name|offset
operator|>>
literal|8
operator|)
operator|&
literal|0377
expr_stmt|;
operator|*
operator|(
name|scan
operator|+
literal|2
operator|)
operator|=
name|offset
operator|&
literal|0377
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - regoptail - regtail on operand of first argument; nop if operandless  */
end_comment

begin_function
specifier|static
name|void
name|regoptail
parameter_list|(
name|p
parameter_list|,
name|val
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
block|{
comment|/* "Operandless" and "op != BRANCH" are synonymous in practice. */
if|if
condition|(
name|p
operator|==
name|NULL
operator|||
name|p
operator|==
operator|&
name|regdummy
operator|||
name|OP
argument_list|(
name|p
argument_list|)
operator|!=
name|BRANCH
condition|)
return|return;
name|regtail
argument_list|(
name|OPERAND
argument_list|(
name|p
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * regexec and friends  */
end_comment

begin_comment
comment|/*  * Global work variables for regexec().  */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|reginput
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* String-input pointer. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|regbol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Beginning of input, for ^ check. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|regstartp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to startp array. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|regendp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ditto for endp. */
end_comment

begin_comment
comment|/*  * Forwards.  */
end_comment

begin_function_decl
name|STATIC
name|int
name|regtry
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|regmatch
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|int
name|regrepeat
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|int
name|regnarrate
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|regdump
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|STATIC
name|char
modifier|*
name|regprop
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  - regexec - match a regexp against a string  */
end_comment

begin_function
name|int
name|regexec
parameter_list|(
name|prog
parameter_list|,
name|string
parameter_list|)
specifier|const
name|regexp
modifier|*
name|prog
decl_stmt|;
specifier|const
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
specifier|extern
name|char
modifier|*
name|strchr
parameter_list|()
function_decl|;
comment|/* Be paranoid... */
if|if
condition|(
name|prog
operator|==
name|NULL
operator|||
name|string
operator|==
name|NULL
condition|)
block|{
name|regerror
argument_list|(
literal|"NULL parameter"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Check validity of program. */
if|if
condition|(
name|UCHARAT
argument_list|(
name|prog
operator|->
name|program
argument_list|)
operator|!=
name|MAGIC
condition|)
block|{
name|regerror
argument_list|(
literal|"corrupted program"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* If there is a "must appear" string, look for it. */
if|if
condition|(
name|prog
operator|->
name|regmust
operator|!=
name|NULL
condition|)
block|{
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|string
expr_stmt|;
while|while
condition|(
operator|(
name|s
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
name|prog
operator|->
name|regmust
index|[
literal|0
index|]
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|s
argument_list|,
name|prog
operator|->
name|regmust
argument_list|,
name|prog
operator|->
name|regmlen
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* Found it. */
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
comment|/* Not present. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Mark beginning of line for ^ . */
name|regbol
operator|=
operator|(
name|char
operator|*
operator|)
name|string
expr_stmt|;
comment|/* Simplest case:  anchored match need be tried only once. */
if|if
condition|(
name|prog
operator|->
name|reganch
condition|)
return|return
operator|(
name|regtry
argument_list|(
name|prog
argument_list|,
name|string
argument_list|)
operator|)
return|;
comment|/* Messy cases:  unanchored match. */
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|string
expr_stmt|;
if|if
condition|(
name|prog
operator|->
name|regstart
operator|!=
literal|'\0'
condition|)
comment|/* We know what char it must start with. */
while|while
condition|(
operator|(
name|s
operator|=
name|strchr
argument_list|(
name|s
argument_list|,
name|prog
operator|->
name|regstart
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|s
operator|++
expr_stmt|;
block|}
else|else
comment|/* We don't -- general case. */
do|do
block|{
if|if
condition|(
name|regtry
argument_list|(
name|prog
argument_list|,
name|s
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
do|while
condition|(
operator|*
name|s
operator|++
operator|!=
literal|'\0'
condition|)
do|;
comment|/* Failure. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - regtry - try match at specific point  */
end_comment

begin_function
specifier|static
name|int
comment|/* 0 failure, 1 success */
name|regtry
parameter_list|(
name|prog
parameter_list|,
name|string
parameter_list|)
name|regexp
modifier|*
name|prog
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
modifier|*
name|ep
decl_stmt|;
name|reginput
operator|=
name|string
expr_stmt|;
name|regstartp
operator|=
name|prog
operator|->
name|startp
expr_stmt|;
name|regendp
operator|=
name|prog
operator|->
name|endp
expr_stmt|;
name|sp
operator|=
name|prog
operator|->
name|startp
expr_stmt|;
name|ep
operator|=
name|prog
operator|->
name|endp
expr_stmt|;
for|for
control|(
name|i
operator|=
name|NSUBEXP
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
operator|*
name|sp
operator|++
operator|=
name|NULL
expr_stmt|;
operator|*
name|ep
operator|++
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|regmatch
argument_list|(
name|prog
operator|->
name|program
operator|+
literal|1
argument_list|)
condition|)
block|{
name|prog
operator|->
name|startp
index|[
literal|0
index|]
operator|=
name|string
expr_stmt|;
name|prog
operator|->
name|endp
index|[
literal|0
index|]
operator|=
name|reginput
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - regmatch - main matching routine  *  * Conceptually the strategy is simple:  check to see whether the current  * node matches, call self recursively to see whether the rest matches,  * and then act accordingly.  In practice we make some effort to avoid  * recursion, in particular by going through "ordinary" nodes (that don't  * need to know whether the rest of the match failed) by a loop instead of  * by recursion.  */
end_comment

begin_function
specifier|static
name|int
comment|/* 0 failure, 1 success */
name|regmatch
parameter_list|(
name|prog
parameter_list|)
name|char
modifier|*
name|prog
decl_stmt|;
block|{
name|char
modifier|*
name|scan
decl_stmt|;
comment|/* Current node. */
name|char
modifier|*
name|next
decl_stmt|;
comment|/* Next node. */
name|scan
operator|=
name|prog
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|scan
operator|!=
name|NULL
operator|&&
name|regnarrate
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s(\n"
argument_list|,
name|regprop
argument_list|(
name|scan
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
name|scan
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|regnarrate
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s...\n"
argument_list|,
name|regprop
argument_list|(
name|scan
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|next
operator|=
name|regnext
argument_list|(
name|scan
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|OP
argument_list|(
name|scan
argument_list|)
condition|)
block|{
case|case
name|BOL
case|:
if|if
condition|(
name|reginput
operator|!=
name|regbol
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|EOL
case|:
if|if
condition|(
operator|*
name|reginput
operator|!=
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|WORDA
case|:
comment|/* Must be looking at a letter, digit, or _ */
if|if
condition|(
operator|(
operator|!
name|isalnum
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|reginput
argument_list|)
operator|)
operator|&&
operator|*
name|reginput
operator|!=
literal|'_'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Prev must be BOL or nonword */
if|if
condition|(
name|reginput
operator|>
name|regbol
operator|&&
operator|(
name|isalnum
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|reginput
index|[
operator|-
literal|1
index|]
argument_list|)
operator|||
name|reginput
index|[
operator|-
literal|1
index|]
operator|==
literal|'_'
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|WORDZ
case|:
comment|/* Must be looking at non letter, digit, or _ */
if|if
condition|(
name|isalnum
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|reginput
argument_list|)
operator|||
operator|*
name|reginput
operator|==
literal|'_'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* We don't care what the previous char was */
break|break;
case|case
name|ANY
case|:
if|if
condition|(
operator|*
name|reginput
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|reginput
operator|++
expr_stmt|;
break|break;
case|case
name|EXACTLY
case|:
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|opnd
decl_stmt|;
name|opnd
operator|=
name|OPERAND
argument_list|(
name|scan
argument_list|)
expr_stmt|;
comment|/* Inline the first character, for speed. */
if|if
condition|(
operator|*
name|opnd
operator|!=
operator|*
name|reginput
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|len
operator|=
name|strlen
argument_list|(
name|opnd
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|1
operator|&&
name|strncmp
argument_list|(
name|opnd
argument_list|,
name|reginput
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|reginput
operator|+=
name|len
expr_stmt|;
block|}
break|break;
case|case
name|ANYOF
case|:
if|if
condition|(
operator|*
name|reginput
operator|==
literal|'\0'
operator|||
name|strchr
argument_list|(
name|OPERAND
argument_list|(
name|scan
argument_list|)
argument_list|,
operator|*
name|reginput
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|reginput
operator|++
expr_stmt|;
break|break;
case|case
name|ANYBUT
case|:
if|if
condition|(
operator|*
name|reginput
operator|==
literal|'\0'
operator|||
name|strchr
argument_list|(
name|OPERAND
argument_list|(
name|scan
argument_list|)
argument_list|,
operator|*
name|reginput
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|reginput
operator|++
expr_stmt|;
break|break;
case|case
name|NOTHING
case|:
break|break;
case|case
name|BACK
case|:
break|break;
case|case
name|OPEN
operator|+
literal|1
case|:
case|case
name|OPEN
operator|+
literal|2
case|:
case|case
name|OPEN
operator|+
literal|3
case|:
case|case
name|OPEN
operator|+
literal|4
case|:
case|case
name|OPEN
operator|+
literal|5
case|:
case|case
name|OPEN
operator|+
literal|6
case|:
case|case
name|OPEN
operator|+
literal|7
case|:
case|case
name|OPEN
operator|+
literal|8
case|:
case|case
name|OPEN
operator|+
literal|9
case|:
block|{
name|int
name|no
decl_stmt|;
name|char
modifier|*
name|save
decl_stmt|;
name|no
operator|=
name|OP
argument_list|(
name|scan
argument_list|)
operator|-
name|OPEN
expr_stmt|;
name|save
operator|=
name|reginput
expr_stmt|;
if|if
condition|(
name|regmatch
argument_list|(
name|next
argument_list|)
condition|)
block|{
comment|/* 					 * Don't set startp if some later 					 * invocation of the same parentheses 					 * already has. 					 */
if|if
condition|(
name|regstartp
index|[
name|no
index|]
operator|==
name|NULL
condition|)
name|regstartp
index|[
name|no
index|]
operator|=
name|save
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
case|case
name|CLOSE
operator|+
literal|1
case|:
case|case
name|CLOSE
operator|+
literal|2
case|:
case|case
name|CLOSE
operator|+
literal|3
case|:
case|case
name|CLOSE
operator|+
literal|4
case|:
case|case
name|CLOSE
operator|+
literal|5
case|:
case|case
name|CLOSE
operator|+
literal|6
case|:
case|case
name|CLOSE
operator|+
literal|7
case|:
case|case
name|CLOSE
operator|+
literal|8
case|:
case|case
name|CLOSE
operator|+
literal|9
case|:
block|{
name|int
name|no
decl_stmt|;
name|char
modifier|*
name|save
decl_stmt|;
name|no
operator|=
name|OP
argument_list|(
name|scan
argument_list|)
operator|-
name|CLOSE
expr_stmt|;
name|save
operator|=
name|reginput
expr_stmt|;
if|if
condition|(
name|regmatch
argument_list|(
name|next
argument_list|)
condition|)
block|{
comment|/* 					 * Don't set endp if some later 					 * invocation of the same parentheses 					 * already has. 					 */
if|if
condition|(
name|regendp
index|[
name|no
index|]
operator|==
name|NULL
condition|)
name|regendp
index|[
name|no
index|]
operator|=
name|save
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
case|case
name|BRANCH
case|:
block|{
name|char
modifier|*
name|save
decl_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|next
argument_list|)
operator|!=
name|BRANCH
condition|)
comment|/* No choice. */
name|next
operator|=
name|OPERAND
argument_list|(
name|scan
argument_list|)
expr_stmt|;
comment|/* Avoid recursion. */
else|else
block|{
do|do
block|{
name|save
operator|=
name|reginput
expr_stmt|;
if|if
condition|(
name|regmatch
argument_list|(
name|OPERAND
argument_list|(
name|scan
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|reginput
operator|=
name|save
expr_stmt|;
name|scan
operator|=
name|regnext
argument_list|(
name|scan
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|scan
operator|!=
name|NULL
operator|&&
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|BRANCH
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
comment|/* NOTREACHED */
block|}
block|}
break|break;
case|case
name|STAR
case|:
case|case
name|PLUS
case|:
block|{
name|char
name|nextch
decl_stmt|;
name|int
name|no
decl_stmt|;
name|char
modifier|*
name|save
decl_stmt|;
name|int
name|min
decl_stmt|;
comment|/* 				 * Lookahead to avoid useless match attempts 				 * when we know what character comes next. 				 */
name|nextch
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|OP
argument_list|(
name|next
argument_list|)
operator|==
name|EXACTLY
condition|)
name|nextch
operator|=
operator|*
name|OPERAND
argument_list|(
name|next
argument_list|)
expr_stmt|;
name|min
operator|=
operator|(
name|OP
argument_list|(
name|scan
argument_list|)
operator|==
name|STAR
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
name|save
operator|=
name|reginput
expr_stmt|;
name|no
operator|=
name|regrepeat
argument_list|(
name|OPERAND
argument_list|(
name|scan
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|no
operator|>=
name|min
condition|)
block|{
comment|/* If it could work, try it. */
if|if
condition|(
name|nextch
operator|==
literal|'\0'
operator|||
operator|*
name|reginput
operator|==
name|nextch
condition|)
if|if
condition|(
name|regmatch
argument_list|(
name|next
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Couldn't or didn't -- back up. */
name|no
operator|--
expr_stmt|;
name|reginput
operator|=
name|save
operator|+
name|no
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
break|break;
case|case
name|END
case|:
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Success! */
break|break;
default|default:
name|regerror
argument_list|(
literal|"memory corruption"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
break|break;
block|}
name|scan
operator|=
name|next
expr_stmt|;
block|}
comment|/* 	 * We get here only if there's trouble -- normally "case END" is 	 * the terminating point. 	 */
name|regerror
argument_list|(
literal|"corrupted pointers"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - regrepeat - repeatedly match something simple, report how many  */
end_comment

begin_function
specifier|static
name|int
name|regrepeat
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|scan
decl_stmt|;
name|char
modifier|*
name|opnd
decl_stmt|;
name|scan
operator|=
name|reginput
expr_stmt|;
name|opnd
operator|=
name|OPERAND
argument_list|(
name|p
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|OP
argument_list|(
name|p
argument_list|)
condition|)
block|{
case|case
name|ANY
case|:
name|count
operator|=
name|strlen
argument_list|(
name|scan
argument_list|)
expr_stmt|;
name|scan
operator|+=
name|count
expr_stmt|;
break|break;
case|case
name|EXACTLY
case|:
while|while
condition|(
operator|*
name|opnd
operator|==
operator|*
name|scan
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|scan
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|ANYOF
case|:
while|while
condition|(
operator|*
name|scan
operator|!=
literal|'\0'
operator|&&
name|strchr
argument_list|(
name|opnd
argument_list|,
operator|*
name|scan
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|scan
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|ANYBUT
case|:
while|while
condition|(
operator|*
name|scan
operator|!=
literal|'\0'
operator|&&
name|strchr
argument_list|(
name|opnd
argument_list|,
operator|*
name|scan
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|count
operator|++
expr_stmt|;
name|scan
operator|++
expr_stmt|;
block|}
break|break;
default|default:
comment|/* Oh dear.  Called inappropriately. */
name|regerror
argument_list|(
literal|"internal foulup"
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
comment|/* Best compromise. */
break|break;
block|}
name|reginput
operator|=
name|scan
expr_stmt|;
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  - regnext - dig the "next" pointer out of a node  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|regnext
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|offset
decl_stmt|;
if|if
condition|(
name|p
operator|==
operator|&
name|regdummy
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|offset
operator|=
name|NEXT
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|OP
argument_list|(
name|p
argument_list|)
operator|==
name|BACK
condition|)
return|return
operator|(
name|p
operator|-
name|offset
operator|)
return|;
else|else
return|return
operator|(
name|p
operator|+
name|offset
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function_decl
name|STATIC
name|char
modifier|*
name|regprop
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  - regdump - dump a regexp onto stdout in vaguely comprehensible form  */
end_comment

begin_function
name|void
name|regdump
parameter_list|(
name|r
parameter_list|)
name|regexp
modifier|*
name|r
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|op
init|=
name|EXACTLY
decl_stmt|;
comment|/* Arbitrary non-END op. */
name|char
modifier|*
name|next
decl_stmt|;
specifier|extern
name|char
modifier|*
name|strchr
parameter_list|()
function_decl|;
name|s
operator|=
name|r
operator|->
name|program
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|op
operator|!=
name|END
condition|)
block|{
comment|/* While that wasn't END last time... */
name|op
operator|=
name|OP
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%2d%s"
argument_list|,
name|s
operator|-
name|r
operator|->
name|program
argument_list|,
name|regprop
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Where, what. */
name|next
operator|=
name|regnext
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
operator|==
name|NULL
condition|)
comment|/* Next ptr. */
name|printf
argument_list|(
literal|"(0)"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"(%d)"
argument_list|,
operator|(
name|s
operator|-
name|r
operator|->
name|program
operator|)
operator|+
operator|(
name|next
operator|-
name|s
operator|)
argument_list|)
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|ANYOF
operator|||
name|op
operator|==
name|ANYBUT
operator|||
name|op
operator|==
name|EXACTLY
condition|)
block|{
comment|/* Literal string, where present. */
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
block|{
name|putchar
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
name|s
operator|++
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
comment|/* Header fields of interest. */
if|if
condition|(
name|r
operator|->
name|regstart
operator|!=
literal|'\0'
condition|)
name|printf
argument_list|(
literal|"start `%c' "
argument_list|,
name|r
operator|->
name|regstart
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|reganch
condition|)
name|printf
argument_list|(
literal|"anchored "
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|regmust
operator|!=
name|NULL
condition|)
name|printf
argument_list|(
literal|"must have \"%s\""
argument_list|,
name|r
operator|->
name|regmust
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  - regprop - printable representation of opcode  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|regprop
parameter_list|(
name|op
parameter_list|)
name|char
modifier|*
name|op
decl_stmt|;
block|{
name|char
modifier|*
name|p
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|":"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|OP
argument_list|(
name|op
argument_list|)
condition|)
block|{
case|case
name|BOL
case|:
name|p
operator|=
literal|"BOL"
expr_stmt|;
break|break;
case|case
name|EOL
case|:
name|p
operator|=
literal|"EOL"
expr_stmt|;
break|break;
case|case
name|ANY
case|:
name|p
operator|=
literal|"ANY"
expr_stmt|;
break|break;
case|case
name|ANYOF
case|:
name|p
operator|=
literal|"ANYOF"
expr_stmt|;
break|break;
case|case
name|ANYBUT
case|:
name|p
operator|=
literal|"ANYBUT"
expr_stmt|;
break|break;
case|case
name|BRANCH
case|:
name|p
operator|=
literal|"BRANCH"
expr_stmt|;
break|break;
case|case
name|EXACTLY
case|:
name|p
operator|=
literal|"EXACTLY"
expr_stmt|;
break|break;
case|case
name|NOTHING
case|:
name|p
operator|=
literal|"NOTHING"
expr_stmt|;
break|break;
case|case
name|BACK
case|:
name|p
operator|=
literal|"BACK"
expr_stmt|;
break|break;
case|case
name|END
case|:
name|p
operator|=
literal|"END"
expr_stmt|;
break|break;
case|case
name|OPEN
operator|+
literal|1
case|:
case|case
name|OPEN
operator|+
literal|2
case|:
case|case
name|OPEN
operator|+
literal|3
case|:
case|case
name|OPEN
operator|+
literal|4
case|:
case|case
name|OPEN
operator|+
literal|5
case|:
case|case
name|OPEN
operator|+
literal|6
case|:
case|case
name|OPEN
operator|+
literal|7
case|:
case|case
name|OPEN
operator|+
literal|8
case|:
case|case
name|OPEN
operator|+
literal|9
case|:
name|sprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"OPEN%d"
argument_list|,
name|OP
argument_list|(
name|op
argument_list|)
operator|-
name|OPEN
argument_list|)
expr_stmt|;
name|p
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|CLOSE
operator|+
literal|1
case|:
case|case
name|CLOSE
operator|+
literal|2
case|:
case|case
name|CLOSE
operator|+
literal|3
case|:
case|case
name|CLOSE
operator|+
literal|4
case|:
case|case
name|CLOSE
operator|+
literal|5
case|:
case|case
name|CLOSE
operator|+
literal|6
case|:
case|case
name|CLOSE
operator|+
literal|7
case|:
case|case
name|CLOSE
operator|+
literal|8
case|:
case|case
name|CLOSE
operator|+
literal|9
case|:
name|sprintf
argument_list|(
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"CLOSE%d"
argument_list|,
name|OP
argument_list|(
name|op
argument_list|)
operator|-
name|CLOSE
argument_list|)
expr_stmt|;
name|p
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|STAR
case|:
name|p
operator|=
literal|"STAR"
expr_stmt|;
break|break;
case|case
name|PLUS
case|:
name|p
operator|=
literal|"PLUS"
expr_stmt|;
break|break;
case|case
name|WORDA
case|:
name|p
operator|=
literal|"WORDA"
expr_stmt|;
break|break;
case|case
name|WORDZ
case|:
name|p
operator|=
literal|"WORDZ"
expr_stmt|;
break|break;
default|default:
name|regerror
argument_list|(
literal|"corrupted opcode"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|buf
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * The following is provided for those people who do not have strcspn() in  * their C libraries.  They should get off their butts and do something  * about it; at least one public-domain implementation of those (highly  * useful) string routines has been published on Usenet.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|STRCSPN
end_ifdef

begin_comment
comment|/*  * strcspn - find length of initial segment of s1 consisting entirely  * of characters not from s2  */
end_comment

begin_function
specifier|static
name|int
name|strcspn
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|;
name|char
modifier|*
name|s2
decl_stmt|;
block|{
name|char
modifier|*
name|scan1
decl_stmt|;
name|char
modifier|*
name|scan2
decl_stmt|;
name|int
name|count
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|scan1
operator|=
name|s1
init|;
operator|*
name|scan1
operator|!=
literal|'\0'
condition|;
name|scan1
operator|++
control|)
block|{
for|for
control|(
name|scan2
operator|=
name|s2
init|;
operator|*
name|scan2
operator|!=
literal|'\0'
condition|;
control|)
comment|/* ++ moved down. */
if|if
condition|(
operator|*
name|scan1
operator|==
operator|*
name|scan2
operator|++
condition|)
return|return
operator|(
name|count
operator|)
return|;
name|count
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

