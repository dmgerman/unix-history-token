begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2007 Tim Kientzle  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"archive_platform.h"
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_STAT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ERRNO_H
end_ifdef

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* #include<stdint.h> */
end_comment

begin_comment
comment|/* See archive_platform.h */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"archive.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry.h"
end_include

begin_include
include|#
directive|include
file|"archive_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_string.h"
end_include

begin_comment
comment|/*  * An overview of ISO 9660 format:  *  * Each disk is laid out as follows:  *   * 32k reserved for private use  *   * Volume descriptor table.  Each volume descriptor  *     is 2k and specifies basic format information.  *     The "Primary Volume Descriptor" (PVD) is defined by the  *     standard and should always be present; other volume  *     descriptors include various vendor-specific extensions.  *   * Files and directories.  Each file/dir is specified by  *     an "extent" (starting sector and length in bytes).  *     Dirs are just files with directory records packed one  *     after another.  The PVD contains a single dir entry  *     specifying the location of the root directory.  Everything  *     else follows from there.  *  * This module works by first reading the volume descriptors, then  * building a list of directory entries, sorted by starting  * sector.  At each step, I look for the earliest dir entry that  * hasn't yet been read, seek forward to that location and read  * that entry.  If it's a dir, I slurp in the new dir entries and  * add them to the heap; if it's a regular file, I return the  * corresponding archive_entry and wait for the client to request  * the file body.  This strategy allows us to read most compliant  * CDs with a single pass through the data, as required by libarchive.  */
end_comment

begin_comment
comment|/* Structure of on-disk primary volume descriptor. */
end_comment

begin_define
define|#
directive|define
name|PVD_type_offset
value|0
end_define

begin_define
define|#
directive|define
name|PVD_type_size
value|1
end_define

begin_define
define|#
directive|define
name|PVD_id_offset
value|(PVD_type_offset + PVD_type_size)
end_define

begin_define
define|#
directive|define
name|PVD_id_size
value|5
end_define

begin_define
define|#
directive|define
name|PVD_version_offset
value|(PVD_id_offset + PVD_id_size)
end_define

begin_define
define|#
directive|define
name|PVD_version_size
value|1
end_define

begin_define
define|#
directive|define
name|PVD_reserved1_offset
value|(PVD_version_offset + PVD_version_size)
end_define

begin_define
define|#
directive|define
name|PVD_reserved1_size
value|1
end_define

begin_define
define|#
directive|define
name|PVD_system_id_offset
value|(PVD_reserved1_offset + PVD_reserved1_size)
end_define

begin_define
define|#
directive|define
name|PVD_system_id_size
value|32
end_define

begin_define
define|#
directive|define
name|PVD_volume_id_offset
value|(PVD_system_id_offset + PVD_system_id_size)
end_define

begin_define
define|#
directive|define
name|PVD_volume_id_size
value|32
end_define

begin_define
define|#
directive|define
name|PVD_reserved2_offset
value|(PVD_volume_id_offset + PVD_volume_id_size)
end_define

begin_define
define|#
directive|define
name|PVD_reserved2_size
value|8
end_define

begin_define
define|#
directive|define
name|PVD_volume_space_size_offset
value|(PVD_reserved2_offset + PVD_reserved2_size)
end_define

begin_define
define|#
directive|define
name|PVD_volume_space_size_size
value|8
end_define

begin_define
define|#
directive|define
name|PVD_reserved3_offset
value|(PVD_volume_space_size_offset + PVD_volume_space_size_size)
end_define

begin_define
define|#
directive|define
name|PVD_reserved3_size
value|32
end_define

begin_define
define|#
directive|define
name|PVD_volume_set_size_offset
value|(PVD_reserved3_offset + PVD_reserved3_size)
end_define

begin_define
define|#
directive|define
name|PVD_volume_set_size_size
value|4
end_define

begin_define
define|#
directive|define
name|PVD_volume_sequence_number_offset
value|(PVD_volume_set_size_offset + PVD_volume_set_size_size)
end_define

begin_define
define|#
directive|define
name|PVD_volume_sequence_number_size
value|4
end_define

begin_define
define|#
directive|define
name|PVD_logical_block_size_offset
value|(PVD_volume_sequence_number_offset + PVD_volume_sequence_number_size)
end_define

begin_define
define|#
directive|define
name|PVD_logical_block_size_size
value|4
end_define

begin_define
define|#
directive|define
name|PVD_path_table_size_offset
value|(PVD_logical_block_size_offset + PVD_logical_block_size_size)
end_define

begin_define
define|#
directive|define
name|PVD_path_table_size_size
value|8
end_define

begin_define
define|#
directive|define
name|PVD_type_1_path_table_offset
value|(PVD_path_table_size_offset + PVD_path_table_size_size)
end_define

begin_define
define|#
directive|define
name|PVD_type_1_path_table_size
value|4
end_define

begin_define
define|#
directive|define
name|PVD_opt_type_1_path_table_offset
value|(PVD_type_1_path_table_offset + PVD_type_1_path_table_size)
end_define

begin_define
define|#
directive|define
name|PVD_opt_type_1_path_table_size
value|4
end_define

begin_define
define|#
directive|define
name|PVD_type_m_path_table_offset
value|(PVD_opt_type_1_path_table_offset + PVD_opt_type_1_path_table_size)
end_define

begin_define
define|#
directive|define
name|PVD_type_m_path_table_size
value|4
end_define

begin_define
define|#
directive|define
name|PVD_opt_type_m_path_table_offset
value|(PVD_type_m_path_table_offset + PVD_type_m_path_table_size)
end_define

begin_define
define|#
directive|define
name|PVD_opt_type_m_path_table_size
value|4
end_define

begin_define
define|#
directive|define
name|PVD_root_directory_record_offset
value|(PVD_opt_type_m_path_table_offset + PVD_opt_type_m_path_table_size)
end_define

begin_define
define|#
directive|define
name|PVD_root_directory_record_size
value|34
end_define

begin_define
define|#
directive|define
name|PVD_volume_set_id_offset
value|(PVD_root_directory_record_offset + PVD_root_directory_record_size)
end_define

begin_define
define|#
directive|define
name|PVD_volume_set_id_size
value|128
end_define

begin_define
define|#
directive|define
name|PVD_publisher_id_offset
value|(PVD_volume_set_id_offset + PVD_volume_set_id_size)
end_define

begin_define
define|#
directive|define
name|PVD_publisher_id_size
value|128
end_define

begin_define
define|#
directive|define
name|PVD_preparer_id_offset
value|(PVD_publisher_id_offset + PVD_publisher_id_size)
end_define

begin_define
define|#
directive|define
name|PVD_preparer_id_size
value|128
end_define

begin_define
define|#
directive|define
name|PVD_application_id_offset
value|(PVD_preparer_id_offset + PVD_preparer_id_size)
end_define

begin_define
define|#
directive|define
name|PVD_application_id_size
value|128
end_define

begin_define
define|#
directive|define
name|PVD_copyright_file_id_offset
value|(PVD_application_id_offset + PVD_application_id_size)
end_define

begin_define
define|#
directive|define
name|PVD_copyright_file_id_size
value|37
end_define

begin_define
define|#
directive|define
name|PVD_abstract_file_id_offset
value|(PVD_copyright_file_id_offset + PVD_copyright_file_id_size)
end_define

begin_define
define|#
directive|define
name|PVD_abstract_file_id_size
value|37
end_define

begin_define
define|#
directive|define
name|PVD_bibliographic_file_id_offset
value|(PVD_abstract_file_id_offset + PVD_abstract_file_id_size)
end_define

begin_define
define|#
directive|define
name|PVD_bibliographic_file_id_size
value|37
end_define

begin_define
define|#
directive|define
name|PVD_creation_date_offset
value|(PVD_bibliographic_file_id_offset + PVD_bibliographic_file_id_size)
end_define

begin_define
define|#
directive|define
name|PVD_creation_date_size
value|17
end_define

begin_define
define|#
directive|define
name|PVD_modification_date_offset
value|(PVD_creation_date_offset + PVD_creation_date_size)
end_define

begin_define
define|#
directive|define
name|PVD_modification_date_size
value|17
end_define

begin_define
define|#
directive|define
name|PVD_expiration_date_offset
value|(PVD_modification_date_offset + PVD_modification_date_size)
end_define

begin_define
define|#
directive|define
name|PVD_expiration_date_size
value|17
end_define

begin_define
define|#
directive|define
name|PVD_effective_date_offset
value|(PVD_expiration_date_offset + PVD_expiration_date_size)
end_define

begin_define
define|#
directive|define
name|PVD_effective_date_size
value|17
end_define

begin_define
define|#
directive|define
name|PVD_file_structure_version_offset
value|(PVD_effective_date_offset + PVD_effective_date_size)
end_define

begin_define
define|#
directive|define
name|PVD_file_structure_version_size
value|1
end_define

begin_define
define|#
directive|define
name|PVD_reserved4_offset
value|(PVD_file_structure_version_offset + PVD_file_structure_version_size)
end_define

begin_define
define|#
directive|define
name|PVD_reserved4_size
value|1
end_define

begin_define
define|#
directive|define
name|PVD_application_data_offset
value|(PVD_reserved4_offset + PVD_reserved4_size)
end_define

begin_define
define|#
directive|define
name|PVD_application_data_size
value|512
end_define

begin_comment
comment|/* Structure of an on-disk directory record. */
end_comment

begin_comment
comment|/* Note:  ISO9660 stores each multi-byte integer twice, once in  * each byte order.  The sizes here are the size of just one  * of the two integers.  (This is why the offset of a field isn't  * the same as the offset+size of the previous field.) */
end_comment

begin_define
define|#
directive|define
name|DR_length_offset
value|0
end_define

begin_define
define|#
directive|define
name|DR_length_size
value|1
end_define

begin_define
define|#
directive|define
name|DR_ext_attr_length_offset
value|1
end_define

begin_define
define|#
directive|define
name|DR_ext_attr_length_size
value|1
end_define

begin_define
define|#
directive|define
name|DR_extent_offset
value|2
end_define

begin_define
define|#
directive|define
name|DR_extent_size
value|4
end_define

begin_define
define|#
directive|define
name|DR_size_offset
value|10
end_define

begin_define
define|#
directive|define
name|DR_size_size
value|4
end_define

begin_define
define|#
directive|define
name|DR_date_offset
value|18
end_define

begin_define
define|#
directive|define
name|DR_date_size
value|7
end_define

begin_define
define|#
directive|define
name|DR_flags_offset
value|25
end_define

begin_define
define|#
directive|define
name|DR_flags_size
value|1
end_define

begin_define
define|#
directive|define
name|DR_file_unit_size_offset
value|26
end_define

begin_define
define|#
directive|define
name|DR_file_unit_size_size
value|1
end_define

begin_define
define|#
directive|define
name|DR_interleave_offset
value|27
end_define

begin_define
define|#
directive|define
name|DR_interleave_size
value|1
end_define

begin_define
define|#
directive|define
name|DR_volume_sequence_number_offset
value|28
end_define

begin_define
define|#
directive|define
name|DR_volume_sequence_number_size
value|2
end_define

begin_define
define|#
directive|define
name|DR_name_len_offset
value|32
end_define

begin_define
define|#
directive|define
name|DR_name_len_size
value|1
end_define

begin_define
define|#
directive|define
name|DR_name_offset
value|33
end_define

begin_comment
comment|/*  * Our private data.  */
end_comment

begin_comment
comment|/* In-memory storage for a directory record. */
end_comment

begin_struct
struct|struct
name|file_info
block|{
name|struct
name|file_info
modifier|*
name|parent
decl_stmt|;
name|int
name|refcount
decl_stmt|;
name|uint64_t
name|offset
decl_stmt|;
comment|/* Offset on disk. */
name|uint64_t
name|size
decl_stmt|;
comment|/* File size in bytes. */
name|uint64_t
name|ce_offset
decl_stmt|;
comment|/* Offset of CE */
name|uint64_t
name|ce_size
decl_stmt|;
comment|/* Size of CE */
name|time_t
name|mtime
decl_stmt|;
comment|/* File last modified time. */
name|time_t
name|atime
decl_stmt|;
comment|/* File last accessed time. */
name|time_t
name|ctime
decl_stmt|;
comment|/* File creation time. */
name|mode_t
name|mode
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
name|ino_t
name|inode
decl_stmt|;
name|int
name|nlinks
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Null-terminated filename. */
name|struct
name|archive_string
name|symlink
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|iso9660
block|{
name|int
name|magic
decl_stmt|;
define|#
directive|define
name|ISO9660_MAGIC
value|0x96609660
name|int
name|bid
decl_stmt|;
comment|/* If non-zero, return this as our bid. */
name|struct
name|archive_string
name|pathname
decl_stmt|;
name|char
name|seenRockridge
decl_stmt|;
comment|/* Set true if RR extensions are used. */
name|unsigned
name|char
name|suspOffset
decl_stmt|;
name|uint64_t
name|previous_offset
decl_stmt|;
name|uint64_t
name|previous_size
decl_stmt|;
name|struct
name|archive_string
name|previous_pathname
decl_stmt|;
comment|/* TODO: Make this a heap for fast inserts and deletions. */
name|struct
name|file_info
modifier|*
modifier|*
name|pending_files
decl_stmt|;
name|int
name|pending_files_allocated
decl_stmt|;
name|int
name|pending_files_used
decl_stmt|;
name|uint64_t
name|current_position
decl_stmt|;
name|ssize_t
name|logical_block_size
decl_stmt|;
name|off_t
name|entry_sparse_offset
decl_stmt|;
name|int64_t
name|entry_bytes_remaining
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|add_entry
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|,
name|struct
name|file_info
modifier|*
name|file
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_iso9660_bid
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_iso9660_cleanup
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_iso9660_read_data
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|off_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_iso9660_read_data_skip
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_iso9660_read_header
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|build_pathname
parameter_list|(
name|struct
name|archive_string
modifier|*
parameter_list|,
name|struct
name|file_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dump_isodirrec
parameter_list|(
name|FILE
modifier|*
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|isodirrec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|time_t
name|time_from_tm
parameter_list|(
name|struct
name|tm
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|time_t
name|isodate17
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|time_t
name|isodate7
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isPVD
parameter_list|(
name|struct
name|iso9660
modifier|*
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|file_info
modifier|*
name|next_entry
parameter_list|(
name|struct
name|iso9660
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|next_entry_seek
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|,
name|struct
name|file_info
modifier|*
modifier|*
name|pfile
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|file_info
modifier|*
name|parse_file_info
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|,
name|struct
name|file_info
modifier|*
name|parent
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|isodirrec
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_rockridge
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|,
name|struct
name|file_info
modifier|*
name|file
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|start
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|end
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|release_file
parameter_list|(
name|struct
name|iso9660
modifier|*
parameter_list|,
name|struct
name|file_info
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|toi
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|archive_read_support_format_iso9660
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
decl_stmt|;
name|int
name|r
decl_stmt|;
name|iso9660
operator|=
operator|(
expr|struct
name|iso9660
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|iso9660
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate iso9660 data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|memset
argument_list|(
name|iso9660
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|iso9660
argument_list|)
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|magic
operator|=
name|ISO9660_MAGIC
expr_stmt|;
name|iso9660
operator|->
name|bid
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* We haven't yet bid. */
name|r
operator|=
name|__archive_read_register_format
argument_list|(
name|a
argument_list|,
name|iso9660
argument_list|,
name|archive_read_format_iso9660_bid
argument_list|,
name|archive_read_format_iso9660_read_header
argument_list|,
name|archive_read_format_iso9660_read_data
argument_list|,
name|archive_read_format_iso9660_read_data_skip
argument_list|,
name|archive_read_format_iso9660_cleanup
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|free
argument_list|(
name|iso9660
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_iso9660_bid
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
decl_stmt|;
name|ssize_t
name|bytes_read
decl_stmt|;
specifier|const
name|void
modifier|*
name|h
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|iso9660
operator|=
operator|(
expr|struct
name|iso9660
operator|*
operator|)
operator|*
operator|(
name|a
operator|->
name|pformat_data
operator|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|bid
operator|>=
literal|0
condition|)
return|return
operator|(
name|iso9660
operator|->
name|bid
operator|)
return|;
comment|/* 	 * Skip the first 32k (reserved area) and get the first 	 * 8 sectors of the volume descriptor table.  Of course, 	 * if the I/O layer gives us more, we'll take it. 	 */
name|bytes_read
operator|=
call|(
name|a
operator|->
name|compression_read_ahead
call|)
argument_list|(
name|a
argument_list|,
operator|&
name|h
argument_list|,
literal|32768
operator|+
literal|8
operator|*
literal|2048
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|<
literal|32768
operator|+
literal|8
operator|*
literal|2048
condition|)
return|return
operator|(
name|iso9660
operator|->
name|bid
operator|=
operator|-
literal|1
operator|)
return|;
name|p
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|h
expr_stmt|;
comment|/* Skip the reserved area. */
name|bytes_read
operator|-=
literal|32768
expr_stmt|;
name|p
operator|+=
literal|32768
expr_stmt|;
comment|/* Check each volume descriptor to locate the PVD. */
for|for
control|(
init|;
name|bytes_read
operator|>
literal|2048
condition|;
name|bytes_read
operator|-=
literal|2048
operator|,
name|p
operator|+=
literal|2048
control|)
block|{
name|iso9660
operator|->
name|bid
operator|=
name|isPVD
argument_list|(
name|iso9660
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|bid
operator|>
literal|0
condition|)
return|return
operator|(
name|iso9660
operator|->
name|bid
operator|)
return|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\xff'
condition|)
comment|/* End-of-volume-descriptor marker. */
break|break;
block|}
comment|/* We didn't find a valid PVD; return a bid of zero. */
name|iso9660
operator|->
name|bid
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|iso9660
operator|->
name|bid
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isPVD
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|h
parameter_list|)
block|{
name|struct
name|file_info
modifier|*
name|file
decl_stmt|;
if|if
condition|(
name|h
index|[
literal|0
index|]
operator|!=
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|memcmp
argument_list|(
name|h
operator|+
literal|1
argument_list|,
literal|"CD001"
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|iso9660
operator|->
name|logical_block_size
operator|=
name|toi
argument_list|(
name|h
operator|+
name|PVD_logical_block_size_offset
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Store the root directory in the pending list. */
name|file
operator|=
name|parse_file_info
argument_list|(
name|iso9660
argument_list|,
name|NULL
argument_list|,
name|h
operator|+
name|PVD_root_directory_record_offset
argument_list|)
expr_stmt|;
name|add_entry
argument_list|(
name|iso9660
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
literal|48
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_iso9660_read_header
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|iso9660
modifier|*
name|iso9660
decl_stmt|;
name|struct
name|file_info
modifier|*
name|file
decl_stmt|;
name|ssize_t
name|bytes_read
decl_stmt|;
name|int
name|r
decl_stmt|;
name|iso9660
operator|=
operator|(
expr|struct
name|iso9660
operator|*
operator|)
operator|*
operator|(
name|a
operator|->
name|pformat_data
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|a
operator|->
name|archive_format
condition|)
block|{
name|a
operator|->
name|archive_format
operator|=
name|ARCHIVE_FORMAT_ISO9660
expr_stmt|;
name|a
operator|->
name|archive_format_name
operator|=
literal|"ISO9660"
expr_stmt|;
block|}
comment|/* Get the next entry that appears after the current offset. */
name|r
operator|=
name|next_entry_seek
argument_list|(
name|a
argument_list|,
name|iso9660
argument_list|,
operator|&
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
name|iso9660
operator|->
name|entry_bytes_remaining
operator|=
name|file
operator|->
name|size
expr_stmt|;
name|iso9660
operator|->
name|entry_sparse_offset
operator|=
literal|0
expr_stmt|;
comment|/* Offset for sparse-file-aware clients. */
comment|/* Set up the entry structure with information about this entry. */
name|memset
argument_list|(
operator|&
name|st
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|st
argument_list|)
argument_list|)
expr_stmt|;
name|st
operator|.
name|st_mode
operator|=
name|file
operator|->
name|mode
expr_stmt|;
name|st
operator|.
name|st_uid
operator|=
name|file
operator|->
name|uid
expr_stmt|;
name|st
operator|.
name|st_gid
operator|=
name|file
operator|->
name|gid
expr_stmt|;
name|st
operator|.
name|st_nlink
operator|=
name|file
operator|->
name|nlinks
expr_stmt|;
name|st
operator|.
name|st_ino
operator|=
name|file
operator|->
name|inode
expr_stmt|;
name|st
operator|.
name|st_mtime
operator|=
name|file
operator|->
name|mtime
expr_stmt|;
name|st
operator|.
name|st_ctime
operator|=
name|file
operator|->
name|ctime
expr_stmt|;
name|st
operator|.
name|st_atime
operator|=
name|file
operator|->
name|atime
expr_stmt|;
name|st
operator|.
name|st_size
operator|=
name|iso9660
operator|->
name|entry_bytes_remaining
expr_stmt|;
name|archive_entry_copy_stat
argument_list|(
name|entry
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
name|iso9660
operator|->
name|pathname
argument_list|)
expr_stmt|;
name|archive_entry_set_pathname
argument_list|(
name|entry
argument_list|,
name|build_pathname
argument_list|(
operator|&
name|iso9660
operator|->
name|pathname
argument_list|,
name|file
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|symlink
operator|.
name|s
operator|!=
name|NULL
condition|)
name|archive_entry_copy_symlink
argument_list|(
name|entry
argument_list|,
name|file
operator|->
name|symlink
operator|.
name|s
argument_list|)
expr_stmt|;
comment|/* If this entry points to the same data as the previous 	 * entry, convert this into a hardlink to that entry. 	 * But don't bother for zero-length files. */
if|if
condition|(
name|file
operator|->
name|offset
operator|==
name|iso9660
operator|->
name|previous_offset
operator|&&
name|file
operator|->
name|size
operator|==
name|iso9660
operator|->
name|previous_size
operator|&&
name|file
operator|->
name|size
operator|>
literal|0
condition|)
block|{
name|archive_entry_set_hardlink
argument_list|(
name|entry
argument_list|,
name|iso9660
operator|->
name|previous_pathname
operator|.
name|s
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|entry_bytes_remaining
operator|=
literal|0
expr_stmt|;
name|iso9660
operator|->
name|entry_sparse_offset
operator|=
literal|0
expr_stmt|;
name|release_file
argument_list|(
name|iso9660
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
comment|/* If the offset is before our current position, we can't 	 * seek backwards to extract it, so issue a warning. */
if|if
condition|(
name|file
operator|->
name|offset
operator|<
name|iso9660
operator|->
name|current_position
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Ignoring out-of-order file"
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|entry_bytes_remaining
operator|=
literal|0
expr_stmt|;
name|iso9660
operator|->
name|entry_sparse_offset
operator|=
literal|0
expr_stmt|;
name|release_file
argument_list|(
name|iso9660
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
name|iso9660
operator|->
name|previous_size
operator|=
name|file
operator|->
name|size
expr_stmt|;
name|iso9660
operator|->
name|previous_offset
operator|=
name|file
operator|->
name|offset
expr_stmt|;
name|archive_strcpy
argument_list|(
operator|&
name|iso9660
operator|->
name|previous_pathname
argument_list|,
name|iso9660
operator|->
name|pathname
operator|.
name|s
argument_list|)
expr_stmt|;
comment|/* If this is a directory, read in all of the entries right now. */
if|if
condition|(
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
while|while
condition|(
name|iso9660
operator|->
name|entry_bytes_remaining
operator|>
literal|0
condition|)
block|{
specifier|const
name|void
modifier|*
name|block
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|ssize_t
name|step
init|=
name|iso9660
operator|->
name|logical_block_size
decl_stmt|;
if|if
condition|(
name|step
operator|>
name|iso9660
operator|->
name|entry_bytes_remaining
condition|)
name|step
operator|=
name|iso9660
operator|->
name|entry_bytes_remaining
expr_stmt|;
name|bytes_read
operator|=
call|(
name|a
operator|->
name|compression_read_ahead
call|)
argument_list|(
name|a
argument_list|,
operator|&
name|block
argument_list|,
name|step
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|<
name|step
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Failed to read full block when scanning ISO9660 directory list"
argument_list|)
expr_stmt|;
name|release_file
argument_list|(
name|iso9660
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|bytes_read
operator|>
name|step
condition|)
name|bytes_read
operator|=
name|step
expr_stmt|;
call|(
name|a
operator|->
name|compression_read_consume
call|)
argument_list|(
name|a
argument_list|,
name|bytes_read
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|current_position
operator|+=
name|bytes_read
expr_stmt|;
name|iso9660
operator|->
name|entry_bytes_remaining
operator|-=
name|bytes_read
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|block
init|;
operator|*
name|p
operator|!=
literal|0
operator|&&
name|p
operator|<
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|block
operator|+
name|bytes_read
condition|;
name|p
operator|+=
operator|*
name|p
control|)
block|{
name|struct
name|file_info
modifier|*
name|child
decl_stmt|;
comment|/* Skip '.' entry. */
if|if
condition|(
operator|*
operator|(
name|p
operator|+
name|DR_name_len_offset
operator|)
operator|==
literal|1
operator|&&
operator|*
operator|(
name|p
operator|+
name|DR_name_offset
operator|)
operator|==
literal|'\0'
condition|)
continue|continue;
comment|/* Skip '..' entry. */
if|if
condition|(
operator|*
operator|(
name|p
operator|+
name|DR_name_len_offset
operator|)
operator|==
literal|1
operator|&&
operator|*
operator|(
name|p
operator|+
name|DR_name_offset
operator|)
operator|==
literal|'\001'
condition|)
continue|continue;
name|child
operator|=
name|parse_file_info
argument_list|(
name|iso9660
argument_list|,
name|file
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|add_entry
argument_list|(
name|iso9660
argument_list|,
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|seenRockridge
condition|)
block|{
name|a
operator|->
name|archive_format
operator|=
name|ARCHIVE_FORMAT_ISO9660_ROCKRIDGE
expr_stmt|;
name|a
operator|->
name|archive_format_name
operator|=
literal|"ISO9660 with Rockridge extensions"
expr_stmt|;
block|}
block|}
block|}
block|}
name|release_file
argument_list|(
name|iso9660
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_iso9660_read_data_skip
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|)
block|{
comment|/* Because read_next_header always does an explicit skip 	 * to the next entry, we don't need to do anything here. */
operator|(
name|void
operator|)
name|a
expr_stmt|;
comment|/* UNUSED */
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_iso9660_read_data
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|off_t
modifier|*
name|offset
parameter_list|)
block|{
name|ssize_t
name|bytes_read
decl_stmt|;
name|struct
name|iso9660
modifier|*
name|iso9660
decl_stmt|;
name|iso9660
operator|=
operator|(
expr|struct
name|iso9660
operator|*
operator|)
operator|*
operator|(
name|a
operator|->
name|pformat_data
operator|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|entry_bytes_remaining
operator|<=
literal|0
condition|)
block|{
operator|*
name|buff
operator|=
name|NULL
expr_stmt|;
operator|*
name|size
operator|=
literal|0
expr_stmt|;
operator|*
name|offset
operator|=
name|iso9660
operator|->
name|entry_sparse_offset
expr_stmt|;
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
block|}
name|bytes_read
operator|=
call|(
name|a
operator|->
name|compression_read_ahead
call|)
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|==
literal|0
condition|)
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Truncated input file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|<=
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
if|if
condition|(
name|bytes_read
operator|>
name|iso9660
operator|->
name|entry_bytes_remaining
condition|)
name|bytes_read
operator|=
name|iso9660
operator|->
name|entry_bytes_remaining
expr_stmt|;
operator|*
name|size
operator|=
name|bytes_read
expr_stmt|;
operator|*
name|offset
operator|=
name|iso9660
operator|->
name|entry_sparse_offset
expr_stmt|;
name|iso9660
operator|->
name|entry_sparse_offset
operator|+=
name|bytes_read
expr_stmt|;
name|iso9660
operator|->
name|entry_bytes_remaining
operator|-=
name|bytes_read
expr_stmt|;
name|iso9660
operator|->
name|current_position
operator|+=
name|bytes_read
expr_stmt|;
call|(
name|a
operator|->
name|compression_read_consume
call|)
argument_list|(
name|a
argument_list|,
name|bytes_read
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_iso9660_cleanup
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
decl_stmt|;
name|struct
name|file_info
modifier|*
name|file
decl_stmt|;
name|iso9660
operator|=
operator|(
expr|struct
name|iso9660
operator|*
operator|)
operator|*
operator|(
name|a
operator|->
name|pformat_data
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|file
operator|=
name|next_entry
argument_list|(
name|iso9660
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|release_file
argument_list|(
name|iso9660
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|iso9660
operator|->
name|pathname
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|iso9660
operator|->
name|previous_pathname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|iso9660
argument_list|)
expr_stmt|;
operator|*
operator|(
name|a
operator|->
name|pformat_data
operator|)
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This routine parses a single ISO directory record, makes sense  * of any extensions, and stores the result in memory.  */
end_comment

begin_function
specifier|static
name|struct
name|file_info
modifier|*
name|parse_file_info
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|,
name|struct
name|file_info
modifier|*
name|parent
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|isodirrec
parameter_list|)
block|{
name|struct
name|file_info
modifier|*
name|file
decl_stmt|;
name|size_t
name|name_len
decl_stmt|;
name|int
name|flags
decl_stmt|;
comment|/* TODO: Sanity check that name_len doesn't exceed length, etc. */
comment|/* Create a new file entry and copy data from the ISO dir record. */
name|file
operator|=
operator|(
expr|struct
name|file_info
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|file
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|memset
argument_list|(
name|file
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|file
argument_list|)
argument_list|)
expr_stmt|;
name|file
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
if|if
condition|(
name|parent
operator|!=
name|NULL
condition|)
name|parent
operator|->
name|refcount
operator|++
expr_stmt|;
name|file
operator|->
name|offset
operator|=
name|toi
argument_list|(
name|isodirrec
operator|+
name|DR_extent_offset
argument_list|,
name|DR_extent_size
argument_list|)
operator|*
name|iso9660
operator|->
name|logical_block_size
expr_stmt|;
name|file
operator|->
name|size
operator|=
name|toi
argument_list|(
name|isodirrec
operator|+
name|DR_size_offset
argument_list|,
name|DR_size_size
argument_list|)
expr_stmt|;
name|file
operator|->
name|mtime
operator|=
name|isodate7
argument_list|(
name|isodirrec
operator|+
name|DR_date_offset
argument_list|)
expr_stmt|;
name|file
operator|->
name|ctime
operator|=
name|file
operator|->
name|atime
operator|=
name|file
operator|->
name|mtime
expr_stmt|;
name|name_len
operator|=
operator|(
name|size_t
operator|)
operator|*
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
operator|(
name|isodirrec
operator|+
name|DR_name_len_offset
operator|)
expr_stmt|;
name|file
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|name_len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|memcpy
argument_list|(
name|file
operator|->
name|name
argument_list|,
name|isodirrec
operator|+
name|DR_name_offset
argument_list|,
name|name_len
argument_list|)
expr_stmt|;
name|file
operator|->
name|name
index|[
name|name_len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|flags
operator|=
operator|*
operator|(
name|isodirrec
operator|+
name|DR_flags_offset
operator|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
literal|0x02
condition|)
name|file
operator|->
name|mode
operator|=
name|S_IFDIR
operator||
literal|0700
expr_stmt|;
else|else
name|file
operator|->
name|mode
operator|=
name|S_IFREG
operator||
literal|0400
expr_stmt|;
comment|/* Rockridge extensions overwrite information from above. */
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|rr_start
decl_stmt|,
modifier|*
name|rr_end
decl_stmt|;
name|rr_end
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|isodirrec
operator|+
operator|*
operator|(
name|isodirrec
operator|+
name|DR_length_offset
operator|)
expr_stmt|;
name|rr_start
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
operator|(
name|isodirrec
operator|+
name|DR_name_offset
operator|+
name|name_len
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|name_len
operator|&
literal|1
operator|)
operator|==
literal|0
condition|)
name|rr_start
operator|++
expr_stmt|;
name|rr_start
operator|+=
name|iso9660
operator|->
name|suspOffset
expr_stmt|;
name|parse_rockridge
argument_list|(
name|iso9660
argument_list|,
name|file
argument_list|,
name|rr_start
argument_list|,
name|rr_end
argument_list|)
expr_stmt|;
block|}
comment|/* DEBUGGING: Warn about attributes I don't yet fully support. */
if|if
condition|(
operator|(
name|flags
operator|&
operator|~
literal|0x02
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n ** Unrecognized flag: "
argument_list|)
expr_stmt|;
name|dump_isodirrec
argument_list|(
name|stderr
argument_list|,
name|isodirrec
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|toi
argument_list|(
name|isodirrec
operator|+
name|DR_volume_sequence_number_offset
argument_list|,
literal|2
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n ** Unrecognized sequence number: "
argument_list|)
expr_stmt|;
name|dump_isodirrec
argument_list|(
name|stderr
argument_list|,
name|isodirrec
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|(
name|isodirrec
operator|+
name|DR_file_unit_size_offset
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n ** Unexpected file unit size: "
argument_list|)
expr_stmt|;
name|dump_isodirrec
argument_list|(
name|stderr
argument_list|,
name|isodirrec
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|(
name|isodirrec
operator|+
name|DR_interleave_offset
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n ** Unexpected interleave: "
argument_list|)
expr_stmt|;
name|dump_isodirrec
argument_list|(
name|stderr
argument_list|,
name|isodirrec
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
operator|(
name|isodirrec
operator|+
name|DR_ext_attr_length_offset
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n ** Unexpected extended attribute length: "
argument_list|)
expr_stmt|;
name|dump_isodirrec
argument_list|(
name|stderr
argument_list|,
name|isodirrec
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|file
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_entry
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|,
name|struct
name|file_info
modifier|*
name|file
parameter_list|)
block|{
comment|/* Expand our pending files list as necessary. */
if|if
condition|(
name|iso9660
operator|->
name|pending_files_used
operator|>=
name|iso9660
operator|->
name|pending_files_allocated
condition|)
block|{
name|struct
name|file_info
modifier|*
modifier|*
name|new_pending_files
decl_stmt|;
name|int
name|new_size
init|=
name|iso9660
operator|->
name|pending_files_allocated
operator|*
literal|2
decl_stmt|;
if|if
condition|(
name|new_size
operator|<
literal|1024
condition|)
name|new_size
operator|=
literal|1024
expr_stmt|;
name|new_pending_files
operator|=
operator|(
expr|struct
name|file_info
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|new_size
operator|*
sizeof|sizeof
argument_list|(
name|new_pending_files
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_pending_files
operator|==
name|NULL
condition|)
name|__archive_errx
argument_list|(
literal|1
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_pending_files
argument_list|,
name|iso9660
operator|->
name|pending_files
argument_list|,
name|iso9660
operator|->
name|pending_files_allocated
operator|*
sizeof|sizeof
argument_list|(
name|new_pending_files
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|pending_files
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|iso9660
operator|->
name|pending_files
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|pending_files
operator|=
name|new_pending_files
expr_stmt|;
name|iso9660
operator|->
name|pending_files_allocated
operator|=
name|new_size
expr_stmt|;
block|}
name|iso9660
operator|->
name|pending_files
index|[
name|iso9660
operator|->
name|pending_files_used
operator|++
index|]
operator|=
name|file
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|parse_rockridge
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|,
name|struct
name|file_info
modifier|*
name|file
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|end
parameter_list|)
block|{
operator|(
name|void
operator|)
name|iso9660
expr_stmt|;
comment|/* UNUSED */
while|while
condition|(
name|p
operator|+
literal|4
operator|<
name|end
comment|/* Enough space for another entry. */
operator|&&
name|p
index|[
literal|0
index|]
operator|>=
literal|'A'
operator|&&
name|p
index|[
literal|0
index|]
operator|<=
literal|'Z'
comment|/* Sanity-check 1st char of name. */
operator|&&
name|p
index|[
literal|1
index|]
operator|>=
literal|'A'
operator|&&
name|p
index|[
literal|1
index|]
operator|<=
literal|'Z'
comment|/* Sanity-check 2nd char of name. */
operator|&&
name|p
operator|+
name|p
index|[
literal|2
index|]
operator|<=
name|end
condition|)
block|{
comment|/* Sanity-check length. */
specifier|const
name|unsigned
name|char
modifier|*
name|data
init|=
name|p
operator|+
literal|4
decl_stmt|;
name|int
name|data_length
init|=
name|p
index|[
literal|2
index|]
operator|-
literal|4
decl_stmt|;
name|int
name|version
init|=
name|p
index|[
literal|3
index|]
decl_stmt|;
comment|/* 		 * Yes, each 'if' here does test p[0] again. 		 * Otherwise, the fall-through handling to catch 		 * unsupported extensions doesn't work. 		 */
switch|switch
condition|(
name|p
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'C'
case|:
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'C'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'E'
operator|&&
name|version
operator|==
literal|1
condition|)
block|{
comment|/* 				 * CE extension comprises: 				 *   8 byte sector containing extension 				 *   8 byte offset w/in above sector 				 *   8 byte length of continuation 				 */
name|file
operator|->
name|ce_offset
operator|=
name|toi
argument_list|(
name|data
argument_list|,
literal|4
argument_list|)
operator|*
name|iso9660
operator|->
name|logical_block_size
operator|+
name|toi
argument_list|(
name|data
operator|+
literal|8
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|file
operator|->
name|ce_size
operator|=
name|toi
argument_list|(
name|data
operator|+
literal|16
argument_list|,
literal|4
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
literal|'N'
case|:
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'N'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'M'
operator|&&
name|version
operator|==
literal|1
operator|&&
operator|*
name|data
operator|==
literal|0
condition|)
block|{
comment|/* NM extension with flag byte == 0 */
comment|/* 				 * NM extension comprises: 				 *   one byte flag 				 *   rest is long name 				 */
comment|/* TODO: Obey flags. */
name|char
modifier|*
name|old_name
init|=
name|file
operator|->
name|name
decl_stmt|;
name|data
operator|++
expr_stmt|;
comment|/* Skip flag byte. */
name|data_length
operator|--
expr_stmt|;
name|file
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|data_length
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|name
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|old_name
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|file
operator|->
name|name
argument_list|,
name|data
argument_list|,
name|data_length
argument_list|)
expr_stmt|;
name|file
operator|->
name|name
index|[
name|data_length
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|file
operator|->
name|name
operator|=
name|old_name
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
literal|'P'
case|:
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'P'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'D'
operator|&&
name|version
operator|==
literal|1
condition|)
block|{
comment|/* 				 * PD extension is padding; 				 * contents are always ignored. 				 */
break|break;
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'P'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'X'
operator|&&
name|version
operator|==
literal|1
condition|)
block|{
comment|/* 				 * PX extension comprises: 				 *   8 bytes for mode, 				 *   8 bytes for nlinks, 				 *   8 bytes for uid, 				 *   8 bytes for gid, 				 *   8 bytes for inode. 				 */
if|if
condition|(
name|data_length
operator|==
literal|32
condition|)
block|{
name|file
operator|->
name|mode
operator|=
name|toi
argument_list|(
name|data
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|file
operator|->
name|nlinks
operator|=
name|toi
argument_list|(
name|data
operator|+
literal|8
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|file
operator|->
name|uid
operator|=
name|toi
argument_list|(
name|data
operator|+
literal|16
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|file
operator|->
name|gid
operator|=
name|toi
argument_list|(
name|data
operator|+
literal|24
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|file
operator|->
name|inode
operator|=
name|toi
argument_list|(
name|data
operator|+
literal|32
argument_list|,
literal|4
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
literal|'R'
case|:
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'R'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'R'
operator|&&
name|version
operator|==
literal|1
condition|)
block|{
name|iso9660
operator|->
name|seenRockridge
operator|=
literal|1
expr_stmt|;
comment|/* 				 * RR extension comprises: 				 *    one byte flag value 				 */
comment|/* TODO: Handle RR extension. */
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
literal|'S'
case|:
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'S'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'L'
operator|&&
name|version
operator|==
literal|1
operator|&&
operator|*
name|data
operator|==
literal|0
condition|)
block|{
name|int
name|cont
init|=
literal|1
decl_stmt|;
comment|/* SL extension with flags == 0 */
comment|/* TODO: handle non-zero flag values. */
name|data
operator|++
expr_stmt|;
comment|/* Skip flag byte. */
name|data_length
operator|--
expr_stmt|;
while|while
condition|(
name|data_length
operator|>
literal|0
condition|)
block|{
name|unsigned
name|char
name|flag
init|=
operator|*
name|data
operator|++
decl_stmt|;
name|unsigned
name|char
name|nlen
init|=
operator|*
name|data
operator|++
decl_stmt|;
name|data_length
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|cont
operator|==
literal|0
condition|)
name|archive_strcat
argument_list|(
operator|&
name|file
operator|->
name|symlink
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|cont
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|flag
condition|)
block|{
case|case
literal|0x01
case|:
comment|/* Continue */
name|archive_strncat
argument_list|(
operator|&
name|file
operator|->
name|symlink
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|data
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
name|cont
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|0x02
case|:
comment|/* Current */
name|archive_strcat
argument_list|(
operator|&
name|file
operator|->
name|symlink
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x04
case|:
comment|/* Parent */
name|archive_strcat
argument_list|(
operator|&
name|file
operator|->
name|symlink
argument_list|,
literal|".."
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x08
case|:
comment|/* Root */
case|case
literal|0x10
case|:
comment|/* Volume root */
name|archive_string_empty
argument_list|(
operator|&
name|file
operator|->
name|symlink
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0x20
case|:
comment|/* Hostname */
name|archive_strcat
argument_list|(
operator|&
name|file
operator|->
name|symlink
argument_list|,
literal|"hostname"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|archive_strncat
argument_list|(
operator|&
name|file
operator|->
name|symlink
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|data
argument_list|,
name|nlen
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* TODO: issue a warning ? */
break|break;
block|}
name|data
operator|+=
name|nlen
expr_stmt|;
name|data_length
operator|-=
name|nlen
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'S'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'P'
operator|&&
name|version
operator|==
literal|1
operator|&&
name|data_length
operator|==
literal|7
operator|&&
name|data
index|[
literal|0
index|]
operator|==
operator|(
name|unsigned
name|char
operator|)
literal|'\xbe'
operator|&&
name|data
index|[
literal|1
index|]
operator|==
operator|(
name|unsigned
name|char
operator|)
literal|'\xef'
condition|)
block|{
comment|/* 				 * SP extension stores the suspOffset 				 * (Number of bytes to skip between 				 * filename and SUSP records.) 				 * It is mandatory by the SUSP standard 				 * (IEEE 1281). 				 * 				 * It allows SUSP to coexist with 				 * non-SUSP uses of the System 				 * Use Area by placing non-SUSP data 				 * before SUSP data. 				 * 				 * TODO: Add a check for 'SP' in 				 * first directory entry, disable all SUSP 				 * processing if not found. 				 */
name|iso9660
operator|->
name|suspOffset
operator|=
name|data
index|[
literal|2
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'S'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'T'
operator|&&
name|data_length
operator|==
literal|0
operator|&&
name|version
operator|==
literal|1
condition|)
block|{
comment|/* 				 * ST extension marks end of this 				 * block of SUSP entries. 				 * 				 * It allows SUSP to coexist with 				 * non-SUSP uses of the System 				 * Use Area by placing non-SUSP data 				 * after SUSP data. 				 */
return|return;
block|}
case|case
literal|'T'
case|:
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'T'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'F'
operator|&&
name|version
operator|==
literal|1
condition|)
block|{
name|char
name|flag
init|=
name|data
index|[
literal|0
index|]
decl_stmt|;
comment|/* 				 * TF extension comprises: 				 *   one byte flag 				 *   create time (optional) 				 *   modify time (optional) 				 *   access time (optional) 				 *   attribute time (optional) 				 *  Time format and presence of fields 				 *  is controlled by flag bits. 				 */
name|data
operator|++
expr_stmt|;
if|if
condition|(
name|flag
operator|&
literal|0x80
condition|)
block|{
comment|/* Use 17-byte time format. */
if|if
condition|(
name|flag
operator|&
literal|1
condition|)
comment|/* Create time. */
name|data
operator|+=
literal|17
expr_stmt|;
if|if
condition|(
name|flag
operator|&
literal|2
condition|)
block|{
comment|/* Modify time. */
name|file
operator|->
name|mtime
operator|=
name|isodate17
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|17
expr_stmt|;
block|}
if|if
condition|(
name|flag
operator|&
literal|4
condition|)
block|{
comment|/* Access time. */
name|file
operator|->
name|atime
operator|=
name|isodate17
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|17
expr_stmt|;
block|}
if|if
condition|(
name|flag
operator|&
literal|8
condition|)
block|{
comment|/* Attribute time. */
name|file
operator|->
name|ctime
operator|=
name|isodate17
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|17
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Use 7-byte time format. */
if|if
condition|(
name|flag
operator|&
literal|1
condition|)
comment|/* Create time. */
name|data
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
name|flag
operator|&
literal|2
condition|)
block|{
comment|/* Modify time. */
name|file
operator|->
name|mtime
operator|=
name|isodate7
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|7
expr_stmt|;
block|}
if|if
condition|(
name|flag
operator|&
literal|4
condition|)
block|{
comment|/* Access time. */
name|file
operator|->
name|atime
operator|=
name|isodate7
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|7
expr_stmt|;
block|}
if|if
condition|(
name|flag
operator|&
literal|8
condition|)
block|{
comment|/* Attribute time. */
name|file
operator|->
name|ctime
operator|=
name|isodate7
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|+=
literal|7
expr_stmt|;
block|}
block|}
break|break;
block|}
comment|/* FALLTHROUGH */
default|default:
comment|/* The FALLTHROUGHs above leave us here for 			 * any unsupported extension. */
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|t
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nUnsupported RRIP extension for %s\n"
argument_list|,
name|file
operator|->
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %c%c(%d):"
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|,
name|p
index|[
literal|1
index|]
argument_list|,
name|data_length
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|data
init|;
name|t
operator|<
name|data
operator|+
name|data_length
operator|&&
name|t
operator|<
name|data
operator|+
literal|16
condition|;
name|t
operator|++
control|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %02x"
argument_list|,
operator|*
name|t
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|p
operator|+=
name|p
index|[
literal|2
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|release_file
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|,
name|struct
name|file_info
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|file_info
modifier|*
name|parent
decl_stmt|;
if|if
condition|(
name|file
operator|->
name|refcount
operator|==
literal|0
condition|)
block|{
name|parent
operator|=
name|file
operator|->
name|parent
expr_stmt|;
if|if
condition|(
name|file
operator|->
name|name
condition|)
name|free
argument_list|(
name|file
operator|->
name|name
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|file
operator|->
name|symlink
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|file
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|!=
name|NULL
condition|)
block|{
name|parent
operator|->
name|refcount
operator|--
expr_stmt|;
name|release_file
argument_list|(
name|iso9660
argument_list|,
name|parent
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|next_entry_seek
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|,
name|struct
name|file_info
modifier|*
modifier|*
name|pfile
parameter_list|)
block|{
name|struct
name|file_info
modifier|*
name|file
decl_stmt|;
name|uint64_t
name|offset
decl_stmt|;
operator|*
name|pfile
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
operator|*
name|pfile
operator|=
name|file
operator|=
name|next_entry
argument_list|(
name|iso9660
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
comment|/* CE area precedes actual file data? Ignore it. */
if|if
condition|(
name|file
operator|->
name|ce_offset
operator|>
name|file
operator|->
name|offset
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" *** Discarding CE data.\n"
argument_list|)
expr_stmt|;
name|file
operator|->
name|ce_offset
operator|=
literal|0
expr_stmt|;
name|file
operator|->
name|ce_size
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If CE exists, find and read it now. */
if|if
condition|(
name|file
operator|->
name|ce_offset
operator|>
literal|0
condition|)
name|offset
operator|=
name|file
operator|->
name|ce_offset
expr_stmt|;
else|else
name|offset
operator|=
name|file
operator|->
name|offset
expr_stmt|;
comment|/* Seek forward to the start of the entry. */
comment|/* Use fast compression_skip if it's available. */
if|if
condition|(
name|iso9660
operator|->
name|current_position
operator|<
name|offset
operator|&&
name|a
operator|->
name|compression_skip
operator|!=
name|NULL
condition|)
block|{
name|off_t
name|step
init|=
name|offset
operator|-
name|iso9660
operator|->
name|current_position
decl_stmt|;
name|off_t
name|bytes_read
decl_stmt|;
name|bytes_read
operator|=
call|(
name|a
operator|->
name|compression_skip
call|)
argument_list|(
name|a
argument_list|,
name|step
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|current_position
operator|+=
name|bytes_read
expr_stmt|;
block|}
comment|/* Use a series of reads if compression_skip didn't 		 * get us all the way there. */
while|while
condition|(
name|iso9660
operator|->
name|current_position
operator|<
name|offset
condition|)
block|{
name|ssize_t
name|step
init|=
name|offset
operator|-
name|iso9660
operator|->
name|current_position
decl_stmt|;
name|ssize_t
name|bytes_read
decl_stmt|;
specifier|const
name|void
modifier|*
name|buff
decl_stmt|;
if|if
condition|(
name|step
operator|>
name|iso9660
operator|->
name|logical_block_size
condition|)
name|step
operator|=
name|iso9660
operator|->
name|logical_block_size
expr_stmt|;
name|bytes_read
operator|=
call|(
name|a
operator|->
name|compression_read_ahead
call|)
argument_list|(
name|a
argument_list|,
operator|&
name|buff
argument_list|,
name|step
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|<=
literal|0
condition|)
block|{
name|release_file
argument_list|(
name|iso9660
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|bytes_read
operator|>
name|step
condition|)
name|bytes_read
operator|=
name|step
expr_stmt|;
name|iso9660
operator|->
name|current_position
operator|+=
name|bytes_read
expr_stmt|;
call|(
name|a
operator|->
name|compression_read_consume
call|)
argument_list|(
name|a
argument_list|,
name|bytes_read
argument_list|)
expr_stmt|;
block|}
comment|/* We found body of file; handle it now. */
if|if
condition|(
name|offset
operator|==
name|file
operator|->
name|offset
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
comment|/* Found CE?  Process it and push the file back onto list. */
if|if
condition|(
name|offset
operator|==
name|file
operator|->
name|ce_offset
condition|)
block|{
specifier|const
name|void
modifier|*
name|p
decl_stmt|;
name|ssize_t
name|size
init|=
name|file
operator|->
name|ce_size
decl_stmt|;
name|ssize_t
name|bytes_read
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|rr_start
decl_stmt|;
name|file
operator|->
name|ce_offset
operator|=
literal|0
expr_stmt|;
name|file
operator|->
name|ce_size
operator|=
literal|0
expr_stmt|;
name|bytes_read
operator|=
call|(
name|a
operator|->
name|compression_read_ahead
call|)
argument_list|(
name|a
argument_list|,
operator|&
name|p
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|>
name|size
condition|)
name|bytes_read
operator|=
name|size
expr_stmt|;
name|rr_start
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|p
expr_stmt|;
name|parse_rockridge
argument_list|(
name|iso9660
argument_list|,
name|file
argument_list|,
name|rr_start
argument_list|,
name|rr_start
operator|+
name|bytes_read
argument_list|)
expr_stmt|;
call|(
name|a
operator|->
name|compression_read_consume
call|)
argument_list|(
name|a
argument_list|,
name|bytes_read
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|current_position
operator|+=
name|bytes_read
expr_stmt|;
name|add_entry
argument_list|(
name|iso9660
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|struct
name|file_info
modifier|*
name|next_entry
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|)
block|{
name|int
name|least_index
decl_stmt|;
name|uint64_t
name|least_end_offset
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|file_info
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|pending_files_used
operator|<
literal|1
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Assume the first file in the list is the earliest on disk. */
name|least_index
operator|=
literal|0
expr_stmt|;
name|least_end_offset
operator|=
name|iso9660
operator|->
name|pending_files
index|[
literal|0
index|]
operator|->
name|offset
operator|+
name|iso9660
operator|->
name|pending_files
index|[
literal|0
index|]
operator|->
name|size
expr_stmt|;
comment|/* Now, try to find an earlier one. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iso9660
operator|->
name|pending_files_used
condition|;
name|i
operator|++
control|)
block|{
comment|/* Use the position of the file *end* as our comparison. */
name|uint64_t
name|end_offset
init|=
name|iso9660
operator|->
name|pending_files
index|[
name|i
index|]
operator|->
name|offset
operator|+
name|iso9660
operator|->
name|pending_files
index|[
name|i
index|]
operator|->
name|size
decl_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|pending_files
index|[
name|i
index|]
operator|->
name|ce_offset
operator|>
literal|0
operator|&&
name|iso9660
operator|->
name|pending_files
index|[
name|i
index|]
operator|->
name|ce_offset
operator|<
name|iso9660
operator|->
name|pending_files
index|[
name|i
index|]
operator|->
name|offset
condition|)
name|end_offset
operator|=
name|iso9660
operator|->
name|pending_files
index|[
name|i
index|]
operator|->
name|ce_offset
operator|+
name|iso9660
operator|->
name|pending_files
index|[
name|i
index|]
operator|->
name|ce_size
expr_stmt|;
if|if
condition|(
name|least_end_offset
operator|>
name|end_offset
condition|)
block|{
name|least_index
operator|=
name|i
expr_stmt|;
name|least_end_offset
operator|=
name|end_offset
expr_stmt|;
block|}
block|}
name|r
operator|=
name|iso9660
operator|->
name|pending_files
index|[
name|least_index
index|]
expr_stmt|;
name|iso9660
operator|->
name|pending_files
index|[
name|least_index
index|]
operator|=
name|iso9660
operator|->
name|pending_files
index|[
operator|--
name|iso9660
operator|->
name|pending_files_used
index|]
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|unsigned
name|int
name|toi
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|,
name|int
name|n
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|v
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|p
decl_stmt|;
if|if
condition|(
name|n
operator|>
literal|1
condition|)
return|return
name|v
index|[
literal|0
index|]
operator|+
literal|256
operator|*
name|toi
argument_list|(
name|v
operator|+
literal|1
argument_list|,
name|n
operator|-
literal|1
argument_list|)
return|;
if|if
condition|(
name|n
operator|==
literal|1
condition|)
return|return
name|v
index|[
literal|0
index|]
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|time_t
name|isodate7
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|v
parameter_list|)
block|{
name|struct
name|tm
name|tm
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|memset
argument_list|(
operator|&
name|tm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tm
argument_list|)
argument_list|)
expr_stmt|;
name|tm
operator|.
name|tm_year
operator|=
name|v
index|[
literal|0
index|]
expr_stmt|;
name|tm
operator|.
name|tm_mon
operator|=
name|v
index|[
literal|1
index|]
operator|-
literal|1
expr_stmt|;
name|tm
operator|.
name|tm_mday
operator|=
name|v
index|[
literal|2
index|]
expr_stmt|;
name|tm
operator|.
name|tm_hour
operator|=
name|v
index|[
literal|3
index|]
expr_stmt|;
name|tm
operator|.
name|tm_min
operator|=
name|v
index|[
literal|4
index|]
expr_stmt|;
name|tm
operator|.
name|tm_sec
operator|=
name|v
index|[
literal|5
index|]
expr_stmt|;
comment|/* v[6] is the signed timezone offset, in 1/4-hour increments. */
name|offset
operator|=
operator|(
operator|(
specifier|const
name|signed
name|char
operator|*
operator|)
name|v
operator|)
index|[
literal|6
index|]
expr_stmt|;
if|if
condition|(
name|offset
operator|>
operator|-
literal|48
operator|&&
name|offset
operator|<
literal|52
condition|)
block|{
name|tm
operator|.
name|tm_hour
operator|-=
name|offset
operator|/
literal|4
expr_stmt|;
name|tm
operator|.
name|tm_min
operator|-=
operator|(
name|offset
operator|%
literal|4
operator|)
operator|*
literal|15
expr_stmt|;
block|}
return|return
operator|(
name|time_from_tm
argument_list|(
operator|&
name|tm
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|time_t
name|isodate17
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|v
parameter_list|)
block|{
name|struct
name|tm
name|tm
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|memset
argument_list|(
operator|&
name|tm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tm
argument_list|)
argument_list|)
expr_stmt|;
name|tm
operator|.
name|tm_year
operator|=
operator|(
name|v
index|[
literal|0
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|1000
operator|+
operator|(
name|v
index|[
literal|1
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|100
operator|+
operator|(
name|v
index|[
literal|2
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
operator|(
name|v
index|[
literal|3
index|]
operator|-
literal|'0'
operator|)
operator|-
literal|1900
expr_stmt|;
name|tm
operator|.
name|tm_mon
operator|=
operator|(
name|v
index|[
literal|4
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
operator|(
name|v
index|[
literal|5
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|tm
operator|.
name|tm_mday
operator|=
operator|(
name|v
index|[
literal|6
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
operator|(
name|v
index|[
literal|7
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|tm
operator|.
name|tm_hour
operator|=
operator|(
name|v
index|[
literal|8
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
operator|(
name|v
index|[
literal|9
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|tm
operator|.
name|tm_min
operator|=
operator|(
name|v
index|[
literal|10
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
operator|(
name|v
index|[
literal|11
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
name|tm
operator|.
name|tm_sec
operator|=
operator|(
name|v
index|[
literal|12
index|]
operator|-
literal|'0'
operator|)
operator|*
literal|10
operator|+
operator|(
name|v
index|[
literal|13
index|]
operator|-
literal|'0'
operator|)
expr_stmt|;
comment|/* v[16] is the signed timezone offset, in 1/4-hour increments. */
name|offset
operator|=
operator|(
operator|(
specifier|const
name|signed
name|char
operator|*
operator|)
name|v
operator|)
index|[
literal|16
index|]
expr_stmt|;
if|if
condition|(
name|offset
operator|>
operator|-
literal|48
operator|&&
name|offset
operator|<
literal|52
condition|)
block|{
name|tm
operator|.
name|tm_hour
operator|-=
name|offset
operator|/
literal|4
expr_stmt|;
name|tm
operator|.
name|tm_min
operator|-=
operator|(
name|offset
operator|%
literal|4
operator|)
operator|*
literal|15
expr_stmt|;
block|}
return|return
operator|(
name|time_from_tm
argument_list|(
operator|&
name|tm
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * timegm() converts a struct tm to a time_t, except it isn't standard,  * so I provide my own function here that (ideally) is just a wrapper  * for timegm().  */
end_comment

begin_function
specifier|static
name|time_t
name|time_from_tm
parameter_list|(
name|struct
name|tm
modifier|*
name|t
parameter_list|)
block|{
if|#
directive|if
name|HAVE_TIMEGM
return|return
operator|(
name|timegm
argument_list|(
name|t
argument_list|)
operator|)
return|;
else|#
directive|else
comment|/* 	 * Unfortunately, timegm() isn't standard.  The standard 	 * mktime() function is a close match, except that it uses 	 * local timezone instead of GMT.  Close enough for now. 	 * Note that it is not possible to emulate timegm() using 	 * completely standard interfaces: 	 *   * ANSI C90 does not even guarantee that time_t is 	 *     an arithmetic type, so time adjustments can only be 	 *     done by manipulating struct tm elements.  You cannot 	 *     portably calculate time_t values. 	 *   * POSIX does promise that time_t is an arithmetic type 	 *     measured in seconds, so you can do time_t calculations 	 *     while remaining POSIX-compliant. 	 *   * Neither ANSI nor POSIX provides an easy way to measure 	 *     the timezone offset, so you can't adjust mktime() to 	 *     work like timegm(). 	 *   * POSIX does not promise that the epoch begins in 1970, 	 *     so you can't write a portable timegm() function from 	 *     scratch. 	 * In practice, of course, mktime() is a reasonable approximation 	 * and most POSIX systems do use seconds since 1970, so you 	 * can roll your own and have it work on all but a few pretty 	 * whacky systems. 	 */
name|time_t
name|result
init|=
name|mktime
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* TODO: Find a way to improve this approximation to timegm(). */
return|return
name|result
return|;
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|build_pathname
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
name|struct
name|file_info
modifier|*
name|file
parameter_list|)
block|{
if|if
condition|(
name|file
operator|->
name|parent
operator|!=
name|NULL
operator|&&
name|file
operator|->
name|parent
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|build_pathname
argument_list|(
name|as
argument_list|,
name|file
operator|->
name|parent
argument_list|)
expr_stmt|;
name|archive_strcat
argument_list|(
name|as
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|file
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|archive_strcat
argument_list|(
name|as
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
else|else
name|archive_strcat
argument_list|(
name|as
argument_list|,
name|file
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|as
operator|->
name|s
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dump_isodirrec
parameter_list|(
name|FILE
modifier|*
name|out
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|isodirrec
parameter_list|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" l %d,"
argument_list|,
name|toi
argument_list|(
name|isodirrec
operator|+
name|DR_length_offset
argument_list|,
name|DR_length_size
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" a %d,"
argument_list|,
name|toi
argument_list|(
name|isodirrec
operator|+
name|DR_ext_attr_length_offset
argument_list|,
name|DR_ext_attr_length_size
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" ext 0x%x,"
argument_list|,
name|toi
argument_list|(
name|isodirrec
operator|+
name|DR_extent_offset
argument_list|,
name|DR_extent_size
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" s %d,"
argument_list|,
name|toi
argument_list|(
name|isodirrec
operator|+
name|DR_size_offset
argument_list|,
name|DR_extent_size
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" f 0x%02x,"
argument_list|,
name|toi
argument_list|(
name|isodirrec
operator|+
name|DR_flags_offset
argument_list|,
name|DR_flags_size
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" u %d,"
argument_list|,
name|toi
argument_list|(
name|isodirrec
operator|+
name|DR_file_unit_size_offset
argument_list|,
name|DR_file_unit_size_size
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" ilv %d,"
argument_list|,
name|toi
argument_list|(
name|isodirrec
operator|+
name|DR_interleave_offset
argument_list|,
name|DR_interleave_size
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" seq %d,"
argument_list|,
name|toi
argument_list|(
name|isodirrec
operator|+
name|DR_volume_sequence_number_offset
argument_list|,
name|DR_volume_sequence_number_size
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" nl %d:"
argument_list|,
name|toi
argument_list|(
name|isodirrec
operator|+
name|DR_name_len_offset
argument_list|,
name|DR_name_len_size
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" `%.*s'"
argument_list|,
name|toi
argument_list|(
name|isodirrec
operator|+
name|DR_name_len_offset
argument_list|,
name|DR_name_len_size
argument_list|)
argument_list|,
name|isodirrec
operator|+
name|DR_name_offset
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

