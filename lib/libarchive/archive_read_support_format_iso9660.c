begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2004 Tim Kientzle  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer  *    in this position and unchanged.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"archive_platform.h"
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* #include<stdint.h> */
end_comment

begin_comment
comment|/* See archive_platform.h */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"archive.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry.h"
end_include

begin_include
include|#
directive|include
file|"archive_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_string.h"
end_include

begin_comment
comment|/*  * An overview of ISO 9660 format:  *  * Each disk is laid out as follows:  *   * 32k reserved for private use  *   * Volume descriptor table.  Each volume descriptor  *     is 2k and specifies basic format information.  *     The "Primary Volume Descriptor" (PVD) is defined by the  *     standard and should always be present; other volume  *     descriptors include various vendor-specific extensions.  *   * Files and directories.  Each file/dir is specified by  *     an "extent" (starting sector and length in bytes).  *     Dirs are just files with directory records packed one  *     after another.  The PVD contains a single dir entry  *     specifying the location of the root directory.  Everything  *     else follows from there.  *  * This module works by first reading the volume descriptors, then  * building a heap of directory entries, sorted by starting  * sector.  At each step, I look for the earliest dir entry that  * hasn't yet been read, seek forward to that location and read  * that entry.  If it's a dir, I slurp in the new dir entries and  * add them to the heap; if it's a regular file, I return the  * corresponding archive_entry and wait for the client to request  * the file body.  This strategy allows us to read most compliant  * CDs with a single pass through the data, as required by libarchive.  */
end_comment

begin_comment
comment|/* Structure of on-disk PVD. */
end_comment

begin_struct
struct|struct
name|primary_volume_descriptor
block|{
name|unsigned
name|char
name|type
index|[
literal|1
index|]
decl_stmt|;
name|char
name|id
index|[
literal|5
index|]
decl_stmt|;
name|unsigned
name|char
name|version
index|[
literal|1
index|]
decl_stmt|;
name|char
name|reserved1
index|[
literal|1
index|]
decl_stmt|;
name|char
name|system_id
index|[
literal|32
index|]
decl_stmt|;
name|char
name|volume_id
index|[
literal|32
index|]
decl_stmt|;
name|char
name|reserved2
index|[
literal|8
index|]
decl_stmt|;
name|char
name|volume_space_size
index|[
literal|8
index|]
decl_stmt|;
name|char
name|reserved3
index|[
literal|32
index|]
decl_stmt|;
name|char
name|volume_set_size
index|[
literal|4
index|]
decl_stmt|;
name|char
name|volume_sequence_number
index|[
literal|4
index|]
decl_stmt|;
name|char
name|logical_block_size
index|[
literal|4
index|]
decl_stmt|;
name|char
name|path_table_size
index|[
literal|8
index|]
decl_stmt|;
name|char
name|type_1_path_table
index|[
literal|4
index|]
decl_stmt|;
name|char
name|opt_type_1_path_table
index|[
literal|4
index|]
decl_stmt|;
name|char
name|type_m_path_table
index|[
literal|4
index|]
decl_stmt|;
name|char
name|opt_type_m_path_table
index|[
literal|4
index|]
decl_stmt|;
name|char
name|root_directory_record
index|[
literal|34
index|]
decl_stmt|;
name|char
name|volume_set_id
index|[
literal|128
index|]
decl_stmt|;
name|char
name|publisher_id
index|[
literal|128
index|]
decl_stmt|;
name|char
name|preparer_id
index|[
literal|128
index|]
decl_stmt|;
name|char
name|application_id
index|[
literal|128
index|]
decl_stmt|;
name|char
name|copyright_file_id
index|[
literal|37
index|]
decl_stmt|;
name|char
name|abstract_file_id
index|[
literal|37
index|]
decl_stmt|;
name|char
name|bibliographic_file_id
index|[
literal|37
index|]
decl_stmt|;
name|char
name|creation_date
index|[
literal|17
index|]
decl_stmt|;
name|char
name|modification_date
index|[
literal|17
index|]
decl_stmt|;
name|char
name|expiration_date
index|[
literal|17
index|]
decl_stmt|;
name|char
name|effective_date
index|[
literal|17
index|]
decl_stmt|;
name|char
name|file_structure_version
index|[
literal|1
index|]
decl_stmt|;
name|char
name|reserved4
index|[
literal|1
index|]
decl_stmt|;
name|char
name|application_data
index|[
literal|512
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Structure of an on-disk directory record. */
end_comment

begin_struct
struct|struct
name|directory_record
block|{
name|unsigned
name|char
name|length
index|[
literal|1
index|]
decl_stmt|;
name|unsigned
name|char
name|ext_attr_length
index|[
literal|1
index|]
decl_stmt|;
name|unsigned
name|char
name|extent
index|[
literal|8
index|]
decl_stmt|;
name|unsigned
name|char
name|size
index|[
literal|8
index|]
decl_stmt|;
name|char
name|date
index|[
literal|7
index|]
decl_stmt|;
name|unsigned
name|char
name|flags
index|[
literal|1
index|]
decl_stmt|;
name|unsigned
name|char
name|file_unit_size
index|[
literal|1
index|]
decl_stmt|;
name|unsigned
name|char
name|interleave
index|[
literal|1
index|]
decl_stmt|;
name|unsigned
name|char
name|volume_sequence_number
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|char
name|name_len
index|[
literal|1
index|]
decl_stmt|;
name|char
name|name
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Our private data.  */
end_comment

begin_comment
comment|/* In-memory storage for a directory record. */
end_comment

begin_struct
struct|struct
name|dir_rec
block|{
name|struct
name|dir_rec
modifier|*
name|parent
decl_stmt|;
name|unsigned
name|char
name|flags
decl_stmt|;
name|uint64_t
name|offset
decl_stmt|;
comment|/* Offset on disk. */
name|uint64_t
name|size
decl_stmt|;
comment|/* File size in bytes. */
name|time_t
name|mtime
decl_stmt|;
comment|/* File last modified time. */
name|char
name|name
index|[
literal|1
index|]
decl_stmt|;
comment|/* Null-terminated filename. */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|iso9660
block|{
name|int
name|magic
decl_stmt|;
define|#
directive|define
name|ISO9660_MAGIC
value|0x96609660
name|int
name|bid
decl_stmt|;
comment|/* If non-zero, return this as our bid. */
name|struct
name|archive_string
name|pathname
decl_stmt|;
comment|/* TODO: Make this a heap for fast inserts and deletions. */
name|struct
name|dir_rec
modifier|*
modifier|*
name|pending_files
decl_stmt|;
name|int
name|pending_files_allocated
decl_stmt|;
name|int
name|pending_files_used
decl_stmt|;
name|uint64_t
name|current_position
decl_stmt|;
name|ssize_t
name|logical_block_size
decl_stmt|;
name|off_t
name|entry_offset
decl_stmt|;
name|ssize_t
name|entry_padding
decl_stmt|;
name|ssize_t
name|entry_bytes_remaining
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|archive_read_format_iso9660_bid
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_iso9660_cleanup
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_iso9660_read_data
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|,
name|off_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_iso9660_read_header
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|build_pathname
parameter_list|(
name|struct
name|archive_string
modifier|*
parameter_list|,
name|struct
name|dir_rec
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|time_t
name|isodate
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|isPVD
parameter_list|(
name|struct
name|iso9660
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|dir_rec
modifier|*
name|next_entry
parameter_list|(
name|struct
name|iso9660
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|store_pending
parameter_list|(
name|struct
name|iso9660
modifier|*
parameter_list|,
name|struct
name|dir_rec
modifier|*
name|parent
parameter_list|,
specifier|const
name|struct
name|directory_record
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|toi
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|,
name|int
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|archive_read_support_format_iso9660
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
decl_stmt|;
name|int
name|r
decl_stmt|;
name|iso9660
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|iso9660
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|iso9660
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|iso9660
argument_list|)
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|magic
operator|=
name|ISO9660_MAGIC
expr_stmt|;
name|iso9660
operator|->
name|bid
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* We haven't yet bid. */
name|r
operator|=
name|__archive_read_register_format
argument_list|(
name|a
argument_list|,
name|iso9660
argument_list|,
name|archive_read_format_iso9660_bid
argument_list|,
name|archive_read_format_iso9660_read_header
argument_list|,
name|archive_read_format_iso9660_read_data
argument_list|,
name|archive_read_format_iso9660_cleanup
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|free
argument_list|(
name|iso9660
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_iso9660_bid
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
decl_stmt|;
name|ssize_t
name|bytes_read
decl_stmt|;
specifier|const
name|void
modifier|*
name|h
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|iso9660
operator|=
operator|*
operator|(
name|a
operator|->
name|pformat_data
operator|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|bid
operator|>=
literal|0
condition|)
return|return
operator|(
name|iso9660
operator|->
name|bid
operator|)
return|;
comment|/* 	 * Skip the first 32k (reserved area) and get the first 	 * 8 sectors of the volume descriptor table.  Of course, 	 * if the I/O layer gives us more, we'll take it. 	 */
name|bytes_read
operator|=
call|(
name|a
operator|->
name|compression_read_ahead
call|)
argument_list|(
name|a
argument_list|,
operator|&
name|h
argument_list|,
literal|32768
operator|+
literal|8
operator|*
literal|2048
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|<
literal|32768
operator|+
literal|8
operator|*
literal|2048
condition|)
return|return
operator|(
name|iso9660
operator|->
name|bid
operator|=
operator|-
literal|1
operator|)
return|;
name|p
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|h
expr_stmt|;
comment|/* Skip the reserved area. */
name|bytes_read
operator|-=
literal|32768
expr_stmt|;
name|p
operator|+=
literal|32768
expr_stmt|;
comment|/* Check each volume descriptor to locate the PVD. */
for|for
control|(
init|;
name|bytes_read
operator|>
literal|2048
condition|;
name|bytes_read
operator|-=
literal|2048
operator|,
name|p
operator|+=
literal|2048
control|)
block|{
name|iso9660
operator|->
name|bid
operator|=
name|isPVD
argument_list|(
name|iso9660
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|bid
operator|>
literal|0
condition|)
return|return
operator|(
name|iso9660
operator|->
name|bid
operator|)
return|;
block|}
comment|/* We didn't find a valid PVD; return a bid of zero. */
name|iso9660
operator|->
name|bid
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|iso9660
operator|->
name|bid
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|isPVD
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|,
specifier|const
name|char
modifier|*
name|h
parameter_list|)
block|{
specifier|const
name|struct
name|primary_volume_descriptor
modifier|*
name|voldesc
decl_stmt|;
if|if
condition|(
name|h
index|[
literal|0
index|]
operator|!=
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|memcmp
argument_list|(
name|h
operator|+
literal|1
argument_list|,
literal|"CD001"
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|voldesc
operator|=
operator|(
specifier|const
expr|struct
name|primary_volume_descriptor
operator|*
operator|)
name|h
expr_stmt|;
name|iso9660
operator|->
name|logical_block_size
operator|=
name|toi
argument_list|(
operator|&
name|voldesc
operator|->
name|logical_block_size
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* Store the root directory in the pending list. */
name|store_pending
argument_list|(
name|iso9660
argument_list|,
name|NULL
argument_list|,
operator|(
expr|struct
name|directory_record
operator|*
operator|)
operator|&
name|voldesc
operator|->
name|root_directory_record
argument_list|)
expr_stmt|;
return|return
operator|(
literal|48
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_iso9660_read_header
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|iso9660
modifier|*
name|iso9660
decl_stmt|;
name|struct
name|dir_rec
modifier|*
name|dirrec
decl_stmt|;
name|ssize_t
name|bytes_read
decl_stmt|;
specifier|const
name|void
modifier|*
name|buff
decl_stmt|;
name|iso9660
operator|=
operator|*
operator|(
name|a
operator|->
name|pformat_data
operator|)
expr_stmt|;
comment|/* Get the next entry that appears after the current offset. */
name|dirrec
operator|=
name|next_entry
argument_list|(
name|iso9660
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirrec
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
while|while
condition|(
name|dirrec
operator|->
name|offset
operator|<
name|iso9660
operator|->
name|current_position
condition|)
block|{
name|archive_string_empty
argument_list|(
operator|&
name|iso9660
operator|->
name|pathname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n ** Ignoring out-of-order file `%s' (offset 0x%0x/size %d) current offset 0x%x\n"
argument_list|,
name|build_pathname
argument_list|(
operator|&
name|iso9660
operator|->
name|pathname
argument_list|,
name|dirrec
argument_list|)
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|dirrec
operator|->
name|offset
argument_list|,
operator|(
name|int
operator|)
name|dirrec
operator|->
name|size
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|iso9660
operator|->
name|current_position
argument_list|)
expr_stmt|;
name|dirrec
operator|=
name|next_entry
argument_list|(
name|iso9660
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirrec
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
block|}
comment|/* Seek forward to the start of that entry. */
while|while
condition|(
name|iso9660
operator|->
name|current_position
operator|<
name|dirrec
operator|->
name|offset
condition|)
block|{
name|ssize_t
name|step
init|=
name|dirrec
operator|->
name|offset
operator|-
name|iso9660
operator|->
name|current_position
decl_stmt|;
if|if
condition|(
name|step
operator|>
name|iso9660
operator|->
name|logical_block_size
condition|)
name|step
operator|=
name|iso9660
operator|->
name|logical_block_size
expr_stmt|;
name|bytes_read
operator|=
call|(
name|a
operator|->
name|compression_read_ahead
call|)
argument_list|(
name|a
argument_list|,
operator|&
name|buff
argument_list|,
name|step
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|<=
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
if|if
condition|(
name|bytes_read
operator|>
name|step
condition|)
name|bytes_read
operator|=
name|step
expr_stmt|;
name|iso9660
operator|->
name|current_position
operator|+=
name|bytes_read
expr_stmt|;
call|(
name|a
operator|->
name|compression_read_consume
call|)
argument_list|(
name|a
argument_list|,
name|bytes_read
argument_list|)
expr_stmt|;
block|}
comment|/* Set up the entry structure with information about this entry. */
name|memset
argument_list|(
operator|&
name|st
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|st
argument_list|)
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|entry_bytes_remaining
operator|=
name|dirrec
operator|->
name|size
expr_stmt|;
comment|/* The following assumes the logical block size is a power of 2. */
name|iso9660
operator|->
name|entry_padding
operator|=
operator|(
name|iso9660
operator|->
name|logical_block_size
operator|-
literal|1
operator|)
operator|&
operator|(
operator|-
name|iso9660
operator|->
name|entry_bytes_remaining
operator|)
expr_stmt|;
name|iso9660
operator|->
name|entry_offset
operator|=
literal|0
expr_stmt|;
name|st
operator|.
name|st_mode
operator|=
literal|0444
expr_stmt|;
if|if
condition|(
name|dirrec
operator|->
name|flags
operator|&
literal|0x02
condition|)
name|st
operator|.
name|st_mode
operator||=
name|S_IFDIR
expr_stmt|;
else|else
name|st
operator|.
name|st_mode
operator||=
name|S_IFREG
expr_stmt|;
name|st
operator|.
name|st_mtime
operator|=
name|dirrec
operator|->
name|mtime
expr_stmt|;
name|st
operator|.
name|st_size
operator|=
name|iso9660
operator|->
name|entry_bytes_remaining
expr_stmt|;
name|archive_entry_copy_stat
argument_list|(
name|entry
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
name|iso9660
operator|->
name|pathname
argument_list|)
expr_stmt|;
name|archive_entry_set_pathname
argument_list|(
name|entry
argument_list|,
name|build_pathname
argument_list|(
operator|&
name|iso9660
operator|->
name|pathname
argument_list|,
name|dirrec
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this is a directory, read in all of the entries right now. */
if|if
condition|(
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
block|{
while|while
condition|(
name|iso9660
operator|->
name|entry_bytes_remaining
operator|>
literal|0
condition|)
block|{
specifier|const
name|void
modifier|*
name|block
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|ssize_t
name|step
init|=
name|iso9660
operator|->
name|logical_block_size
decl_stmt|;
if|if
condition|(
name|step
operator|>
name|iso9660
operator|->
name|entry_bytes_remaining
condition|)
name|step
operator|=
name|iso9660
operator|->
name|entry_bytes_remaining
expr_stmt|;
name|bytes_read
operator|=
call|(
name|a
operator|->
name|compression_read_ahead
call|)
argument_list|(
name|a
argument_list|,
operator|&
name|block
argument_list|,
name|step
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|<
name|step
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
operator|-
literal|1
argument_list|,
literal|"Failed to read full block when scanning ISO9660 directory list"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|bytes_read
operator|>
name|step
condition|)
name|bytes_read
operator|=
name|step
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|>
name|iso9660
operator|->
name|entry_bytes_remaining
condition|)
name|bytes_read
operator|=
name|iso9660
operator|->
name|entry_bytes_remaining
expr_stmt|;
call|(
name|a
operator|->
name|compression_read_consume
call|)
argument_list|(
name|a
argument_list|,
name|bytes_read
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|current_position
operator|+=
name|bytes_read
expr_stmt|;
name|iso9660
operator|->
name|entry_bytes_remaining
operator|-=
name|bytes_read
expr_stmt|;
for|for
control|(
name|p
operator|=
name|block
init|;
operator|*
name|p
operator|!=
literal|0
condition|;
name|p
operator|+=
operator|*
name|p
control|)
block|{
specifier|const
name|struct
name|directory_record
modifier|*
name|dr
init|=
operator|(
specifier|const
expr|struct
name|directory_record
operator|*
operator|)
name|p
decl_stmt|;
comment|/* Skip '.' entry. */
if|if
condition|(
name|dr
operator|->
name|name_len
index|[
literal|0
index|]
operator|==
literal|1
operator|&&
name|dr
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
comment|/* Skip '..' entry. */
if|if
condition|(
name|dr
operator|->
name|name_len
index|[
literal|0
index|]
operator|==
literal|1
operator|&&
name|dr
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'\001'
condition|)
continue|continue;
name|store_pending
argument_list|(
name|iso9660
argument_list|,
name|dirrec
argument_list|,
name|dr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_iso9660_read_data
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|off_t
modifier|*
name|offset
parameter_list|)
block|{
name|ssize_t
name|bytes_read
decl_stmt|;
name|struct
name|iso9660
modifier|*
name|iso9660
decl_stmt|;
name|iso9660
operator|=
operator|*
operator|(
name|a
operator|->
name|pformat_data
operator|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|entry_bytes_remaining
operator|>
literal|0
condition|)
block|{
name|bytes_read
operator|=
call|(
name|a
operator|->
name|compression_read_ahead
call|)
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|<=
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
if|if
condition|(
name|bytes_read
operator|>
name|iso9660
operator|->
name|entry_bytes_remaining
condition|)
name|bytes_read
operator|=
name|iso9660
operator|->
name|entry_bytes_remaining
expr_stmt|;
operator|*
name|size
operator|=
name|bytes_read
expr_stmt|;
operator|*
name|offset
operator|=
name|iso9660
operator|->
name|entry_offset
expr_stmt|;
name|iso9660
operator|->
name|entry_offset
operator|+=
name|bytes_read
expr_stmt|;
name|iso9660
operator|->
name|entry_bytes_remaining
operator|-=
name|bytes_read
expr_stmt|;
name|iso9660
operator|->
name|current_position
operator|+=
name|bytes_read
expr_stmt|;
call|(
name|a
operator|->
name|compression_read_consume
call|)
argument_list|(
name|a
argument_list|,
name|bytes_read
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
else|else
block|{
while|while
condition|(
name|iso9660
operator|->
name|entry_padding
operator|>
literal|0
condition|)
block|{
name|bytes_read
operator|=
call|(
name|a
operator|->
name|compression_read_ahead
call|)
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|<=
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
if|if
condition|(
name|bytes_read
operator|>
name|iso9660
operator|->
name|entry_padding
condition|)
name|bytes_read
operator|=
name|iso9660
operator|->
name|entry_padding
expr_stmt|;
name|iso9660
operator|->
name|current_position
operator|+=
name|bytes_read
expr_stmt|;
call|(
name|a
operator|->
name|compression_read_consume
call|)
argument_list|(
name|a
argument_list|,
name|bytes_read
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|entry_padding
operator|-=
name|bytes_read
expr_stmt|;
block|}
operator|*
name|buff
operator|=
name|NULL
expr_stmt|;
operator|*
name|size
operator|=
literal|0
expr_stmt|;
operator|*
name|offset
operator|=
name|iso9660
operator|->
name|entry_offset
expr_stmt|;
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_iso9660_cleanup
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|iso9660
modifier|*
name|iso9660
decl_stmt|;
name|iso9660
operator|=
operator|*
operator|(
name|a
operator|->
name|pformat_data
operator|)
expr_stmt|;
name|free
argument_list|(
name|iso9660
argument_list|)
expr_stmt|;
operator|*
operator|(
name|a
operator|->
name|pformat_data
operator|)
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|store_pending
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|,
name|struct
name|dir_rec
modifier|*
name|parent
parameter_list|,
specifier|const
name|struct
name|directory_record
modifier|*
name|isodirent
parameter_list|)
block|{
name|struct
name|dir_rec
modifier|*
name|new_dirent
decl_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|pending_files_used
operator|>=
name|iso9660
operator|->
name|pending_files_allocated
condition|)
block|{
name|struct
name|dir_rec
modifier|*
modifier|*
name|new_pending_files
decl_stmt|;
name|int
name|new_size
init|=
name|iso9660
operator|->
name|pending_files_allocated
operator|*
literal|2
decl_stmt|;
if|if
condition|(
name|new_size
operator|<
literal|1024
condition|)
name|new_size
operator|=
literal|1024
expr_stmt|;
name|new_pending_files
operator|=
name|malloc
argument_list|(
name|new_size
operator|*
sizeof|sizeof
argument_list|(
name|new_pending_files
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_pending_files
argument_list|,
name|iso9660
operator|->
name|pending_files
argument_list|,
name|iso9660
operator|->
name|pending_files_allocated
operator|*
sizeof|sizeof
argument_list|(
name|new_pending_files
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|pending_files
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|iso9660
operator|->
name|pending_files
argument_list|)
expr_stmt|;
name|iso9660
operator|->
name|pending_files
operator|=
name|new_pending_files
expr_stmt|;
name|iso9660
operator|->
name|pending_files_allocated
operator|=
name|new_size
expr_stmt|;
block|}
name|new_dirent
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new_dirent
argument_list|)
operator|+
name|isodirent
operator|->
name|name_len
index|[
literal|0
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
name|new_dirent
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|new_dirent
operator|->
name|flags
operator|=
name|isodirent
operator|->
name|flags
index|[
literal|0
index|]
expr_stmt|;
name|new_dirent
operator|->
name|offset
operator|=
name|toi
argument_list|(
name|isodirent
operator|->
name|extent
argument_list|,
literal|4
argument_list|)
operator|*
name|iso9660
operator|->
name|logical_block_size
expr_stmt|;
name|new_dirent
operator|->
name|size
operator|=
name|toi
argument_list|(
name|isodirent
operator|->
name|size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|new_dirent
operator|->
name|mtime
operator|=
name|isodate
argument_list|(
name|isodirent
operator|->
name|date
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|new_dirent
operator|->
name|name
argument_list|,
name|isodirent
operator|->
name|name
argument_list|,
name|isodirent
operator|->
name|name_len
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|new_dirent
operator|->
name|name
index|[
operator|(
name|int
operator|)
name|isodirent
operator|->
name|name_len
index|[
literal|0
index|]
index|]
operator|=
literal|'\0'
expr_stmt|;
name|iso9660
operator|->
name|pending_files
index|[
name|iso9660
operator|->
name|pending_files_used
operator|++
index|]
operator|=
name|new_dirent
expr_stmt|;
comment|/* DEBUGGING */
if|if
condition|(
operator|(
name|isodirent
operator|->
name|flags
index|[
literal|0
index|]
operator|&
operator|~
literal|0x02
operator|)
operator|!=
literal|0
condition|)
block|{
name|archive_string_empty
argument_list|(
operator|&
name|iso9660
operator|->
name|pathname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n ** Unrecognized flag 0x%x in file %s\n"
argument_list|,
name|new_dirent
operator|->
name|flags
argument_list|,
name|build_pathname
argument_list|(
operator|&
name|iso9660
operator|->
name|pathname
argument_list|,
name|new_dirent
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|toi
argument_list|(
name|isodirent
operator|->
name|volume_sequence_number
argument_list|,
literal|2
argument_list|)
operator|!=
literal|1
operator|||
name|isodirent
operator|->
name|file_unit_size
index|[
literal|0
index|]
operator|!=
literal|0
operator|||
name|isodirent
operator|->
name|interleave
index|[
literal|0
index|]
operator|!=
literal|0
operator|||
name|isodirent
operator|->
name|ext_attr_length
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n ** Unhandled ISO9660 directory attribute:"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" l %d, a %d, ext 0x%x, s %d, f 0x%02x, unt %d, ilv %d, seq %d: `%.*s' (%d)\n"
argument_list|,
name|isodirent
operator|->
name|length
index|[
literal|0
index|]
argument_list|,
name|isodirent
operator|->
name|ext_attr_length
index|[
literal|0
index|]
argument_list|,
name|toi
argument_list|(
name|isodirent
operator|->
name|extent
argument_list|,
literal|4
argument_list|)
operator|*
literal|2048
argument_list|,
name|toi
argument_list|(
name|isodirent
operator|->
name|size
argument_list|,
literal|4
argument_list|)
argument_list|,
name|isodirent
operator|->
name|flags
index|[
literal|0
index|]
argument_list|,
name|isodirent
operator|->
name|file_unit_size
index|[
literal|0
index|]
argument_list|,
name|isodirent
operator|->
name|interleave
index|[
literal|0
index|]
argument_list|,
name|toi
argument_list|(
name|isodirent
operator|->
name|volume_sequence_number
argument_list|,
literal|2
argument_list|)
argument_list|,
name|isodirent
operator|->
name|name_len
index|[
literal|0
index|]
argument_list|,
name|isodirent
operator|->
name|name
argument_list|,
name|isodirent
operator|->
name|name_len
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|dir_rec
modifier|*
name|next_entry
parameter_list|(
name|struct
name|iso9660
modifier|*
name|iso9660
parameter_list|)
block|{
name|int
name|least_index
init|=
literal|0
decl_stmt|;
name|uint64_t
name|least_offset
init|=
name|iso9660
operator|->
name|pending_files
index|[
literal|0
index|]
operator|->
name|offset
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|dir_rec
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|iso9660
operator|->
name|pending_files_used
operator|<
literal|1
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iso9660
operator|->
name|pending_files_used
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|iso9660
operator|->
name|pending_files
index|[
name|i
index|]
operator|->
name|offset
operator|<
name|least_offset
condition|)
block|{
name|least_offset
operator|=
name|iso9660
operator|->
name|pending_files
index|[
name|i
index|]
operator|->
name|offset
expr_stmt|;
name|least_index
operator|=
name|i
expr_stmt|;
block|}
block|}
name|r
operator|=
name|iso9660
operator|->
name|pending_files
index|[
name|least_index
index|]
expr_stmt|;
name|iso9660
operator|->
name|pending_files
index|[
name|least_index
index|]
operator|=
name|iso9660
operator|->
name|pending_files
index|[
operator|--
name|iso9660
operator|->
name|pending_files_used
index|]
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|toi
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|,
name|int
name|n
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|v
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|p
decl_stmt|;
if|if
condition|(
name|n
operator|>
literal|1
condition|)
return|return
name|v
index|[
literal|0
index|]
operator|+
literal|256
operator|*
name|toi
argument_list|(
name|v
operator|+
literal|1
argument_list|,
name|n
operator|-
literal|1
argument_list|)
return|;
if|if
condition|(
name|n
operator|==
literal|1
condition|)
return|return
name|v
index|[
literal|0
index|]
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|time_t
name|isodate
parameter_list|(
specifier|const
name|void
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|tm
name|tm
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|v
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|p
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|tm
operator|.
name|tm_year
operator|=
name|v
index|[
literal|0
index|]
expr_stmt|;
name|tm
operator|.
name|tm_mon
operator|=
name|v
index|[
literal|1
index|]
operator|-
literal|1
expr_stmt|;
name|tm
operator|.
name|tm_mday
operator|=
name|v
index|[
literal|2
index|]
expr_stmt|;
name|tm
operator|.
name|tm_hour
operator|=
name|v
index|[
literal|3
index|]
expr_stmt|;
name|tm
operator|.
name|tm_min
operator|=
name|v
index|[
literal|4
index|]
expr_stmt|;
name|tm
operator|.
name|tm_sec
operator|=
name|v
index|[
literal|5
index|]
expr_stmt|;
comment|/* v[6] is the timezone offset, in 1/4-hour increments. */
name|offset
operator|=
operator|(
operator|(
specifier|const
name|signed
name|char
operator|*
operator|)
name|p
operator|)
index|[
literal|6
index|]
expr_stmt|;
name|tm
operator|.
name|tm_hour
operator|+=
name|offset
operator|/
literal|4
expr_stmt|;
name|tm
operator|.
name|tm_min
operator|+=
operator|(
name|offset
operator|%
literal|4
operator|)
operator|*
literal|15
expr_stmt|;
return|return
operator|(
name|timegm
argument_list|(
operator|&
name|tm
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|build_pathname
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
name|struct
name|dir_rec
modifier|*
name|dr
parameter_list|)
block|{
if|if
condition|(
name|dr
operator|->
name|parent
operator|!=
name|NULL
operator|&&
name|dr
operator|->
name|parent
operator|->
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|build_pathname
argument_list|(
name|as
argument_list|,
name|dr
operator|->
name|parent
argument_list|)
expr_stmt|;
name|archive_strcat
argument_list|(
name|as
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
block|}
name|archive_strcat
argument_list|(
name|as
argument_list|,
name|dr
operator|->
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|as
operator|->
name|s
operator|)
return|;
block|}
end_function

end_unit

