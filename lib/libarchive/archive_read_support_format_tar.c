begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2007 Tim Kientzle  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"archive_platform.h"
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ERRNO_H
end_ifdef

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_comment
comment|/* #include<stdint.h> */
end_comment

begin_comment
comment|/* See archive_platform.h */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Obtain suitable wide-character manipulation functions. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_WCHAR_H
end_ifdef

begin_include
include|#
directive|include
file|<wchar.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Good enough for equality testing, which is all we need. */
end_comment

begin_function
specifier|static
name|int
name|wcscmp
parameter_list|(
specifier|const
name|wchar_t
modifier|*
name|s1
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|s2
parameter_list|)
block|{
name|int
name|diff
init|=
operator|*
name|s1
operator|-
operator|*
name|s2
decl_stmt|;
while|while
condition|(
operator|*
name|s1
operator|&&
name|diff
operator|==
literal|0
condition|)
name|diff
operator|=
operator|(
name|int
operator|)
operator|*
operator|++
name|s1
operator|-
operator|(
name|int
operator|)
operator|*
operator|++
name|s2
expr_stmt|;
return|return
name|diff
return|;
block|}
end_function

begin_comment
comment|/* Good enough for equality testing, which is all we need. */
end_comment

begin_function
specifier|static
name|int
name|wcsncmp
parameter_list|(
specifier|const
name|wchar_t
modifier|*
name|s1
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|s2
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|int
name|diff
init|=
operator|*
name|s1
operator|-
operator|*
name|s2
decl_stmt|;
while|while
condition|(
operator|*
name|s1
operator|&&
name|diff
operator|==
literal|0
operator|&&
name|n
operator|--
operator|>
literal|0
condition|)
name|diff
operator|=
operator|(
name|int
operator|)
operator|*
operator|++
name|s1
operator|-
operator|(
name|int
operator|)
operator|*
operator|++
name|s2
expr_stmt|;
return|return
name|diff
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|wcslen
parameter_list|(
specifier|const
name|wchar_t
modifier|*
name|s
parameter_list|)
block|{
specifier|const
name|wchar_t
modifier|*
name|p
init|=
name|s
decl_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
name|p
operator|++
expr_stmt|;
return|return
name|p
operator|-
name|s
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"archive.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry.h"
end_include

begin_include
include|#
directive|include
file|"archive_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_read_private.h"
end_include

begin_comment
comment|/*  * Layout of POSIX 'ustar' tar header.  */
end_comment

begin_struct
struct|struct
name|archive_entry_header_ustar
block|{
name|char
name|name
index|[
literal|100
index|]
decl_stmt|;
name|char
name|mode
index|[
literal|8
index|]
decl_stmt|;
name|char
name|uid
index|[
literal|8
index|]
decl_stmt|;
name|char
name|gid
index|[
literal|8
index|]
decl_stmt|;
name|char
name|size
index|[
literal|12
index|]
decl_stmt|;
name|char
name|mtime
index|[
literal|12
index|]
decl_stmt|;
name|char
name|checksum
index|[
literal|8
index|]
decl_stmt|;
name|char
name|typeflag
index|[
literal|1
index|]
decl_stmt|;
name|char
name|linkname
index|[
literal|100
index|]
decl_stmt|;
comment|/* "old format" header ends here */
name|char
name|magic
index|[
literal|6
index|]
decl_stmt|;
comment|/* For POSIX: "ustar\0" */
name|char
name|version
index|[
literal|2
index|]
decl_stmt|;
comment|/* For POSIX: "00" */
name|char
name|uname
index|[
literal|32
index|]
decl_stmt|;
name|char
name|gname
index|[
literal|32
index|]
decl_stmt|;
name|char
name|rdevmajor
index|[
literal|8
index|]
decl_stmt|;
name|char
name|rdevminor
index|[
literal|8
index|]
decl_stmt|;
name|char
name|prefix
index|[
literal|155
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Structure of GNU tar header  */
end_comment

begin_struct
struct|struct
name|gnu_sparse
block|{
name|char
name|offset
index|[
literal|12
index|]
decl_stmt|;
name|char
name|numbytes
index|[
literal|12
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|archive_entry_header_gnutar
block|{
name|char
name|name
index|[
literal|100
index|]
decl_stmt|;
name|char
name|mode
index|[
literal|8
index|]
decl_stmt|;
name|char
name|uid
index|[
literal|8
index|]
decl_stmt|;
name|char
name|gid
index|[
literal|8
index|]
decl_stmt|;
name|char
name|size
index|[
literal|12
index|]
decl_stmt|;
name|char
name|mtime
index|[
literal|12
index|]
decl_stmt|;
name|char
name|checksum
index|[
literal|8
index|]
decl_stmt|;
name|char
name|typeflag
index|[
literal|1
index|]
decl_stmt|;
name|char
name|linkname
index|[
literal|100
index|]
decl_stmt|;
name|char
name|magic
index|[
literal|8
index|]
decl_stmt|;
comment|/* "ustar  \0" (note blank/blank/null at end) */
name|char
name|uname
index|[
literal|32
index|]
decl_stmt|;
name|char
name|gname
index|[
literal|32
index|]
decl_stmt|;
name|char
name|rdevmajor
index|[
literal|8
index|]
decl_stmt|;
name|char
name|rdevminor
index|[
literal|8
index|]
decl_stmt|;
name|char
name|atime
index|[
literal|12
index|]
decl_stmt|;
name|char
name|ctime
index|[
literal|12
index|]
decl_stmt|;
name|char
name|offset
index|[
literal|12
index|]
decl_stmt|;
name|char
name|longnames
index|[
literal|4
index|]
decl_stmt|;
name|char
name|unused
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|gnu_sparse
name|sparse
index|[
literal|4
index|]
decl_stmt|;
name|char
name|isextended
index|[
literal|1
index|]
decl_stmt|;
name|char
name|realsize
index|[
literal|12
index|]
decl_stmt|;
comment|/* 	 * GNU doesn't use POSIX 'prefix' field; they use the 'L' (longname) 	 * entry instead. 	 */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Data specific to this format.  */
end_comment

begin_struct
struct|struct
name|sparse_block
block|{
name|struct
name|sparse_block
modifier|*
name|next
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
name|off_t
name|remaining
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|tar
block|{
name|struct
name|archive_string
name|acl_text
decl_stmt|;
name|struct
name|archive_string
name|entry_name
decl_stmt|;
name|struct
name|archive_string
name|entry_linkname
decl_stmt|;
name|struct
name|archive_string
name|entry_uname
decl_stmt|;
name|struct
name|archive_string
name|entry_gname
decl_stmt|;
name|struct
name|archive_string
name|longlink
decl_stmt|;
name|struct
name|archive_string
name|longname
decl_stmt|;
name|struct
name|archive_string
name|pax_header
decl_stmt|;
name|struct
name|archive_string
name|pax_global
decl_stmt|;
name|struct
name|archive_string
name|line
decl_stmt|;
name|wchar_t
modifier|*
name|pax_entry
decl_stmt|;
name|size_t
name|pax_entry_length
decl_stmt|;
name|int
name|header_recursion_depth
decl_stmt|;
name|off_t
name|entry_bytes_remaining
decl_stmt|;
name|off_t
name|entry_offset
decl_stmt|;
name|off_t
name|entry_padding
decl_stmt|;
name|off_t
name|realsize
decl_stmt|;
name|struct
name|sparse_block
modifier|*
name|sparse_list
decl_stmt|;
name|struct
name|sparse_block
modifier|*
name|sparse_last
decl_stmt|;
name|int64_t
name|sparse_offset
decl_stmt|;
name|int64_t
name|sparse_numbytes
decl_stmt|;
name|int
name|sparse_gnu_major
decl_stmt|;
name|int
name|sparse_gnu_minor
decl_stmt|;
name|char
name|sparse_gnu_pending
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|size_t
name|UTF8_mbrtowc
parameter_list|(
name|wchar_t
modifier|*
name|pwc
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_block_is_null
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|base64_decode
parameter_list|(
specifier|const
name|wchar_t
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gnu_add_sparse_entry
parameter_list|(
name|struct
name|tar
modifier|*
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|off_t
name|remaining
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gnu_sparse_old_read
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|tar
modifier|*
parameter_list|,
specifier|const
name|struct
name|archive_entry_header_gnutar
modifier|*
name|header
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gnu_sparse_old_parse
parameter_list|(
name|struct
name|tar
modifier|*
parameter_list|,
specifier|const
name|struct
name|gnu_sparse
modifier|*
name|sparse
parameter_list|,
name|int
name|length
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gnu_sparse_01_parse
parameter_list|(
name|struct
name|tar
modifier|*
parameter_list|,
specifier|const
name|wchar_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ssize_t
name|gnu_sparse_10_read
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|tar
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|header_Solaris_ACL
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|tar
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|header_common
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|tar
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|header_old_tar
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|tar
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|header_pax_extensions
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|tar
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|header_pax_global
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|tar
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
name|h
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|header_longlink
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|tar
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
name|h
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|header_longname
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|tar
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
name|h
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|header_volume
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|tar
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
name|h
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|header_ustar
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|tar
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
name|h
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|header_gnutar
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|tar
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
name|h
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_tar_bid
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_tar_cleanup
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_tar_read_data
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|off_t
modifier|*
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_tar_skip
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_tar_read_header
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|checksum
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pax_attribute
parameter_list|(
name|struct
name|tar
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|wchar_t
modifier|*
name|key
parameter_list|,
name|wchar_t
modifier|*
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pax_header
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|tar
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|char
modifier|*
name|attr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pax_time
parameter_list|(
specifier|const
name|wchar_t
modifier|*
parameter_list|,
name|int64_t
modifier|*
name|sec
parameter_list|,
name|long
modifier|*
name|nanos
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ssize_t
name|readline
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|tar
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_body_to_string
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|tar
modifier|*
parameter_list|,
name|struct
name|archive_string
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
name|h
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int64_t
name|tar_atol
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int64_t
name|tar_atol10
parameter_list|(
specifier|const
name|wchar_t
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int64_t
name|tar_atol256
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int64_t
name|tar_atol8
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tar_read_header
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|tar
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tohex
parameter_list|(
name|int
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|url_decode
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|utf8_decode
parameter_list|(
name|wchar_t
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
name|length
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|wide_to_narrow
parameter_list|(
specifier|const
name|wchar_t
modifier|*
name|wval
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|archive_read_support_format_gnutar
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|)
block|{
return|return
operator|(
name|archive_read_support_format_tar
argument_list|(
name|a
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|archive_read_support_format_tar
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
name|struct
name|tar
modifier|*
name|tar
decl_stmt|;
name|int
name|r
decl_stmt|;
name|tar
operator|=
operator|(
expr|struct
name|tar
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|tar
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tar
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate tar data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|memset
argument_list|(
name|tar
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tar
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|__archive_read_register_format
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|archive_read_format_tar_bid
argument_list|,
name|archive_read_format_tar_read_header
argument_list|,
name|archive_read_format_tar_read_data
argument_list|,
name|archive_read_format_tar_skip
argument_list|,
name|archive_read_format_tar_cleanup
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|free
argument_list|(
name|tar
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_tar_cleanup
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|tar
modifier|*
name|tar
decl_stmt|;
name|struct
name|sparse_block
modifier|*
name|p
decl_stmt|;
name|tar
operator|=
operator|(
expr|struct
name|tar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
while|while
condition|(
name|tar
operator|->
name|sparse_list
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|tar
operator|->
name|sparse_list
expr_stmt|;
name|tar
operator|->
name|sparse_list
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|archive_string_free
argument_list|(
operator|&
name|tar
operator|->
name|acl_text
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|tar
operator|->
name|entry_name
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|tar
operator|->
name|entry_linkname
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|tar
operator|->
name|entry_uname
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|tar
operator|->
name|entry_gname
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|tar
operator|->
name|line
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|tar
operator|->
name|pax_global
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|tar
operator|->
name|pax_header
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tar
operator|->
name|pax_entry
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tar
argument_list|)
expr_stmt|;
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_tar_bid
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|int
name|bid
decl_stmt|;
name|ssize_t
name|bytes_read
decl_stmt|;
specifier|const
name|void
modifier|*
name|h
decl_stmt|;
specifier|const
name|struct
name|archive_entry_header_ustar
modifier|*
name|header
decl_stmt|;
comment|/* 	 * If we're already reading a non-tar file, don't 	 * bother to bid. 	 */
if|if
condition|(
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|!=
literal|0
operator|&&
operator|(
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|&
name|ARCHIVE_FORMAT_BASE_MASK
operator|)
operator|!=
name|ARCHIVE_FORMAT_TAR
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bid
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If we're already reading a tar format, start the bid at 1 as 	 * a failsafe. 	 */
if|if
condition|(
operator|(
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|&
name|ARCHIVE_FORMAT_BASE_MASK
operator|)
operator|==
name|ARCHIVE_FORMAT_TAR
condition|)
name|bid
operator|++
expr_stmt|;
comment|/* Now let's look at the actual header and see if it matches. */
if|if
condition|(
name|a
operator|->
name|decompressor
operator|->
name|read_ahead
operator|!=
name|NULL
condition|)
name|bytes_read
operator|=
call|(
name|a
operator|->
name|decompressor
operator|->
name|read_ahead
call|)
argument_list|(
name|a
argument_list|,
operator|&
name|h
argument_list|,
literal|512
argument_list|)
expr_stmt|;
else|else
name|bytes_read
operator|=
literal|0
expr_stmt|;
comment|/* Empty file. */
if|if
condition|(
name|bytes_read
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
if|if
condition|(
name|bytes_read
operator|==
literal|0
operator|&&
name|bid
operator|>
literal|0
condition|)
block|{
comment|/* An archive without a proper end-of-archive marker. */
comment|/* Hold our nose and bid 1 anyway. */
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|bytes_read
operator|<
literal|512
condition|)
block|{
comment|/* If it's a new archive, then just return a zero bid. */
if|if
condition|(
name|bid
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 		 * If we already know this is a tar archive, 		 * then we have a problem. 		 */
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated tar archive"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* If it's an end-of-archive mark, we can handle it. */
if|if
condition|(
operator|(
operator|*
operator|(
specifier|const
name|char
operator|*
operator|)
name|h
operator|)
operator|==
literal|0
operator|&&
name|archive_block_is_null
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|h
argument_list|)
condition|)
block|{
comment|/* If it's a known tar file, end-of-archive is definite. */
if|if
condition|(
operator|(
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|&
name|ARCHIVE_FORMAT_BASE_MASK
operator|)
operator|==
name|ARCHIVE_FORMAT_TAR
condition|)
return|return
operator|(
literal|512
operator|)
return|;
comment|/* Empty archive? */
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* If it's not an end-of-archive mark, it must have a valid checksum.*/
if|if
condition|(
operator|!
name|checksum
argument_list|(
name|a
argument_list|,
name|h
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bid
operator|+=
literal|48
expr_stmt|;
comment|/* Checksum is usually 6 octal digits. */
name|header
operator|=
operator|(
specifier|const
expr|struct
name|archive_entry_header_ustar
operator|*
operator|)
name|h
expr_stmt|;
comment|/* Recognize POSIX formats. */
if|if
condition|(
operator|(
name|memcmp
argument_list|(
name|header
operator|->
name|magic
argument_list|,
literal|"ustar\0"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|memcmp
argument_list|(
name|header
operator|->
name|version
argument_list|,
literal|"00"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|bid
operator|+=
literal|56
expr_stmt|;
comment|/* Recognize GNU tar format. */
if|if
condition|(
operator|(
name|memcmp
argument_list|(
name|header
operator|->
name|magic
argument_list|,
literal|"ustar "
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|memcmp
argument_list|(
name|header
operator|->
name|version
argument_list|,
literal|" \0"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|bid
operator|+=
literal|56
expr_stmt|;
comment|/* Type flag must be null, digit or A-Z, a-z. */
if|if
condition|(
name|header
operator|->
name|typeflag
index|[
literal|0
index|]
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|header
operator|->
name|typeflag
index|[
literal|0
index|]
operator|>=
literal|'0'
operator|&&
name|header
operator|->
name|typeflag
index|[
literal|0
index|]
operator|<=
literal|'9'
operator|)
operator|&&
operator|!
operator|(
name|header
operator|->
name|typeflag
index|[
literal|0
index|]
operator|>=
literal|'A'
operator|&&
name|header
operator|->
name|typeflag
index|[
literal|0
index|]
operator|<=
literal|'Z'
operator|)
operator|&&
operator|!
operator|(
name|header
operator|->
name|typeflag
index|[
literal|0
index|]
operator|>=
literal|'a'
operator|&&
name|header
operator|->
name|typeflag
index|[
literal|0
index|]
operator|<=
literal|'z'
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bid
operator|+=
literal|2
expr_stmt|;
comment|/* 6 bits of variation in an 8-bit field leaves 2 bits. */
comment|/* Sanity check: Look at first byte of mode field. */
switch|switch
condition|(
literal|255
operator|&
operator|(
name|unsigned
operator|)
name|header
operator|->
name|mode
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|255
case|:
comment|/* Base-256 value: No further verification possible! */
break|break;
case|case
literal|' '
case|:
comment|/* Not recommended, but not illegal, either. */
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
comment|/* Octal Value. */
comment|/* TODO: Check format of remainder of this field. */
break|break;
default|default:
comment|/* Not a valid mode; bail out here. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* TODO: Sanity test uid/gid/size/mtime/rdevmajor/rdevminor fields. */
return|return
operator|(
name|bid
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The function invoked by archive_read_header().  This  * just sets up a few things and then calls the internal  * tar_read_header() function below.  */
end_comment

begin_function
specifier|static
name|int
name|archive_read_format_tar_read_header
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
comment|/* 	 * When converting tar archives to cpio archives, it is 	 * essential that each distinct file have a distinct inode 	 * number.  To simplify this, we keep a static count here to 	 * assign fake dev/inode numbers to each tar entry.  Note that 	 * pax format archives may overwrite this with something more 	 * useful. 	 * 	 * Ideally, we would track every file read from the archive so 	 * that we could assign the same dev/ino pair to hardlinks, 	 * but the memory required to store a complete lookup table is 	 * probably not worthwhile just to support the relatively 	 * obscure tar->cpio conversion case. 	 */
specifier|static
name|int
name|default_inode
decl_stmt|;
specifier|static
name|int
name|default_dev
decl_stmt|;
name|struct
name|tar
modifier|*
name|tar
decl_stmt|;
name|struct
name|sparse_block
modifier|*
name|sp
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|r
decl_stmt|;
name|size_t
name|l
decl_stmt|;
name|ssize_t
name|size
decl_stmt|;
comment|/* Assign default device/inode values. */
name|archive_entry_set_dev
argument_list|(
name|entry
argument_list|,
literal|1
operator|+
name|default_dev
argument_list|)
expr_stmt|;
comment|/* Don't use zero. */
name|archive_entry_set_ino
argument_list|(
name|entry
argument_list|,
operator|++
name|default_inode
argument_list|)
expr_stmt|;
comment|/* Don't use zero. */
comment|/* Limit generated st_ino number to 16 bits. */
if|if
condition|(
name|default_inode
operator|>=
literal|0xffff
condition|)
block|{
operator|++
name|default_dev
expr_stmt|;
name|default_inode
operator|=
literal|0
expr_stmt|;
block|}
name|tar
operator|=
operator|(
expr|struct
name|tar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
name|tar
operator|->
name|entry_offset
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|tar
operator|->
name|sparse_list
operator|!=
name|NULL
condition|)
block|{
name|sp
operator|=
name|tar
operator|->
name|sparse_list
expr_stmt|;
name|tar
operator|->
name|sparse_list
operator|=
name|sp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
name|tar
operator|->
name|sparse_last
operator|=
name|NULL
expr_stmt|;
name|r
operator|=
name|tar_read_header
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|)
expr_stmt|;
comment|/* 	 * Yuck.  See comments for gnu_sparse_10_read for why this 	 * is here and not in _read_data where it "should" go. 	 */
if|if
condition|(
name|tar
operator|->
name|sparse_gnu_pending
operator|&&
name|tar
operator|->
name|sparse_gnu_major
operator|==
literal|1
operator|&&
name|tar
operator|->
name|sparse_gnu_minor
operator|==
literal|0
condition|)
block|{
name|tar
operator|->
name|sparse_gnu_pending
operator|=
literal|0
expr_stmt|;
comment|/* Read initial sparse map. */
name|size
operator|=
name|gnu_sparse_10_read
argument_list|(
name|a
argument_list|,
name|tar
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
return|return
operator|(
name|size
operator|)
return|;
name|tar
operator|->
name|entry_bytes_remaining
operator|-=
name|size
expr_stmt|;
name|tar
operator|->
name|entry_padding
operator|+=
name|size
expr_stmt|;
block|}
comment|/* 	 * "non-sparse" files are really just sparse files with 	 * a single block. 	 */
if|if
condition|(
name|tar
operator|->
name|sparse_list
operator|==
name|NULL
condition|)
name|gnu_add_sparse_entry
argument_list|(
name|tar
argument_list|,
literal|0
argument_list|,
name|tar
operator|->
name|entry_bytes_remaining
argument_list|)
expr_stmt|;
name|tar
operator|->
name|realsize
operator|=
name|archive_entry_size
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_OK
condition|)
block|{
comment|/* 		 * "Regular" entry with trailing '/' is really 		 * directory: This is needed for certain old tar 		 * variants and even for some broken newer ones. 		 */
name|p
operator|=
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_entry_filetype
argument_list|(
name|entry
argument_list|)
operator|==
name|AE_IFREG
operator|&&
name|p
index|[
name|l
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
name|archive_entry_set_filetype
argument_list|(
name|entry
argument_list|,
name|AE_IFDIR
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_tar_read_data
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|off_t
modifier|*
name|offset
parameter_list|)
block|{
name|ssize_t
name|bytes_read
decl_stmt|;
name|struct
name|tar
modifier|*
name|tar
decl_stmt|;
name|struct
name|sparse_block
modifier|*
name|p
decl_stmt|;
name|tar
operator|=
operator|(
expr|struct
name|tar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|tar
operator|->
name|sparse_gnu_pending
condition|)
block|{
if|if
condition|(
name|tar
operator|->
name|sparse_gnu_major
operator|==
literal|1
operator|&&
name|tar
operator|->
name|sparse_gnu_minor
operator|==
literal|0
condition|)
block|{
comment|/* 			 *<sigh> We should parse the sparse data 			 * here, but have to parse it as part of the 			 * header because of a bug in GNU tar 1.16.1. 			 */
block|}
else|else
block|{
operator|*
name|size
operator|=
literal|0
expr_stmt|;
operator|*
name|offset
operator|=
literal|0
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Unrecognized GNU sparse file format"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
name|tar
operator|->
name|sparse_gnu_pending
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Remove exhausted entries from sparse list. */
while|while
condition|(
name|tar
operator|->
name|sparse_list
operator|!=
name|NULL
operator|&&
name|tar
operator|->
name|sparse_list
operator|->
name|remaining
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|tar
operator|->
name|sparse_list
expr_stmt|;
name|tar
operator|->
name|sparse_list
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* If we're at end of file, return EOF. */
if|if
condition|(
name|tar
operator|->
name|sparse_list
operator|==
name|NULL
operator|||
name|tar
operator|->
name|entry_bytes_remaining
operator|==
literal|0
condition|)
block|{
if|if
condition|(
call|(
name|a
operator|->
name|decompressor
operator|->
name|skip
call|)
argument_list|(
name|a
argument_list|,
name|tar
operator|->
name|entry_padding
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|tar
operator|->
name|entry_padding
operator|=
literal|0
expr_stmt|;
operator|*
name|buff
operator|=
name|NULL
expr_stmt|;
operator|*
name|size
operator|=
literal|0
expr_stmt|;
operator|*
name|offset
operator|=
name|tar
operator|->
name|realsize
expr_stmt|;
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
block|}
name|bytes_read
operator|=
call|(
name|a
operator|->
name|decompressor
operator|->
name|read_ahead
call|)
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|==
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Truncated tar archive"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|bytes_read
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
if|if
condition|(
name|bytes_read
operator|>
name|tar
operator|->
name|entry_bytes_remaining
condition|)
name|bytes_read
operator|=
name|tar
operator|->
name|entry_bytes_remaining
expr_stmt|;
comment|/* Don't read more than is available in the 	 * current sparse block. */
if|if
condition|(
name|tar
operator|->
name|sparse_list
operator|->
name|remaining
operator|<
name|bytes_read
condition|)
name|bytes_read
operator|=
name|tar
operator|->
name|sparse_list
operator|->
name|remaining
expr_stmt|;
operator|*
name|size
operator|=
name|bytes_read
expr_stmt|;
operator|*
name|offset
operator|=
name|tar
operator|->
name|sparse_list
operator|->
name|offset
expr_stmt|;
name|tar
operator|->
name|sparse_list
operator|->
name|remaining
operator|-=
name|bytes_read
expr_stmt|;
name|tar
operator|->
name|sparse_list
operator|->
name|offset
operator|+=
name|bytes_read
expr_stmt|;
name|tar
operator|->
name|entry_bytes_remaining
operator|-=
name|bytes_read
expr_stmt|;
call|(
name|a
operator|->
name|decompressor
operator|->
name|consume
call|)
argument_list|(
name|a
argument_list|,
name|bytes_read
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_tar_skip
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|off_t
name|bytes_skipped
decl_stmt|;
name|struct
name|tar
modifier|*
name|tar
decl_stmt|;
name|struct
name|sparse_block
modifier|*
name|p
decl_stmt|;
name|tar
operator|=
operator|(
expr|struct
name|tar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
comment|/* 	 * Compression layer skip functions are required to either skip the 	 * length requested or fail, so we can rely upon the entire entry 	 * plus padding being skipped. 	 */
name|bytes_skipped
operator|=
call|(
name|a
operator|->
name|decompressor
operator|->
name|skip
call|)
argument_list|(
name|a
argument_list|,
name|tar
operator|->
name|entry_bytes_remaining
operator|+
name|tar
operator|->
name|entry_padding
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_skipped
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|tar
operator|->
name|entry_bytes_remaining
operator|=
literal|0
expr_stmt|;
name|tar
operator|->
name|entry_padding
operator|=
literal|0
expr_stmt|;
comment|/* Free the sparse list. */
while|while
condition|(
name|tar
operator|->
name|sparse_list
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|tar
operator|->
name|sparse_list
expr_stmt|;
name|tar
operator|->
name|sparse_list
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|tar
operator|->
name|sparse_last
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function recursively interprets all of the headers associated  * with a single entry.  */
end_comment

begin_function
specifier|static
name|int
name|tar_read_header
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
name|ssize_t
name|bytes
decl_stmt|;
name|int
name|err
decl_stmt|;
specifier|const
name|void
modifier|*
name|h
decl_stmt|;
specifier|const
name|struct
name|archive_entry_header_ustar
modifier|*
name|header
decl_stmt|;
comment|/* Read 512-byte header record */
name|bytes
operator|=
call|(
name|a
operator|->
name|decompressor
operator|->
name|read_ahead
call|)
argument_list|(
name|a
argument_list|,
operator|&
name|h
argument_list|,
literal|512
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|<
literal|512
condition|)
block|{
comment|/* 		 * If we're here, it's becase the _bid function accepted 		 * this file.  So just call a short read end-of-archive 		 * and be done with it. 		 */
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
block|}
call|(
name|a
operator|->
name|decompressor
operator|->
name|consume
call|)
argument_list|(
name|a
argument_list|,
literal|512
argument_list|)
expr_stmt|;
comment|/* Check for end-of-archive mark. */
if|if
condition|(
operator|(
operator|(
operator|*
operator|(
specifier|const
name|char
operator|*
operator|)
name|h
operator|)
operator|==
literal|0
operator|)
operator|&&
name|archive_block_is_null
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|h
argument_list|)
condition|)
block|{
comment|/* Try to consume a second all-null record, as well. */
name|bytes
operator|=
call|(
name|a
operator|->
name|decompressor
operator|->
name|read_ahead
call|)
argument_list|(
name|a
argument_list|,
operator|&
name|h
argument_list|,
literal|512
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|>
literal|0
condition|)
call|(
name|a
operator|->
name|decompressor
operator|->
name|consume
call|)
argument_list|(
name|a
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
block|}
comment|/* 	 * Note: If the checksum fails and we return ARCHIVE_RETRY, 	 * then the client is likely to just retry.  This is a very 	 * crude way to search for the next valid header! 	 * 	 * TODO: Improve this by implementing a real header scan. 	 */
if|if
condition|(
operator|!
name|checksum
argument_list|(
name|a
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|EINVAL
argument_list|,
literal|"Damaged tar archive"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_RETRY
operator|)
return|;
comment|/* Retryable: Invalid header */
block|}
if|if
condition|(
operator|++
name|tar
operator|->
name|header_recursion_depth
operator|>
literal|32
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|EINVAL
argument_list|,
literal|"Too many special headers"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
comment|/* Determine the format variant. */
name|header
operator|=
operator|(
specifier|const
expr|struct
name|archive_entry_header_ustar
operator|*
operator|)
name|h
expr_stmt|;
switch|switch
condition|(
name|header
operator|->
name|typeflag
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'A'
case|:
comment|/* Solaris tar ACL */
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|=
name|ARCHIVE_FORMAT_TAR_PAX_INTERCHANGE
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
literal|"Solaris tar"
expr_stmt|;
name|err
operator|=
name|header_Solaris_ACL
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|,
name|h
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/* POSIX-standard 'g' header. */
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|=
name|ARCHIVE_FORMAT_TAR_PAX_INTERCHANGE
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
literal|"POSIX pax interchange format"
expr_stmt|;
name|err
operator|=
name|header_pax_global
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|,
name|h
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
comment|/* Long link name (GNU tar, others) */
name|err
operator|=
name|header_longlink
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|,
name|h
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* Long filename (GNU tar, others) */
name|err
operator|=
name|header_longname
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|,
name|h
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
comment|/* GNU volume header */
name|err
operator|=
name|header_volume
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|,
name|h
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
comment|/* Used by SUN tar; same as 'x'. */
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|=
name|ARCHIVE_FORMAT_TAR_PAX_INTERCHANGE
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
literal|"POSIX pax interchange format (Sun variant)"
expr_stmt|;
name|err
operator|=
name|header_pax_extensions
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|,
name|h
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* POSIX-standard 'x' header. */
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|=
name|ARCHIVE_FORMAT_TAR_PAX_INTERCHANGE
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
literal|"POSIX pax interchange format"
expr_stmt|;
name|err
operator|=
name|header_pax_extensions
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|,
name|h
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|memcmp
argument_list|(
name|header
operator|->
name|magic
argument_list|,
literal|"ustar  \0"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|=
name|ARCHIVE_FORMAT_TAR_GNUTAR
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
literal|"GNU tar format"
expr_stmt|;
name|err
operator|=
name|header_gnutar
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|header
operator|->
name|magic
argument_list|,
literal|"ustar"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|!=
name|ARCHIVE_FORMAT_TAR_PAX_INTERCHANGE
condition|)
block|{
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|=
name|ARCHIVE_FORMAT_TAR_USTAR
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
literal|"POSIX ustar format"
expr_stmt|;
block|}
name|err
operator|=
name|header_ustar
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|=
name|ARCHIVE_FORMAT_TAR
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
literal|"tar (non-POSIX)"
expr_stmt|;
name|err
operator|=
name|header_old_tar
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
block|}
operator|--
name|tar
operator|->
name|header_recursion_depth
expr_stmt|;
comment|/* We return warnings or success as-is.  Anything else is fatal. */
if|if
condition|(
name|err
operator|==
name|ARCHIVE_WARN
operator|||
name|err
operator|==
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|err
operator|==
name|ARCHIVE_EOF
condition|)
comment|/* EOF when recursively reading a header is bad. */
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|EINVAL
argument_list|,
literal|"Damaged tar archive"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return true if block checksum is correct.  */
end_comment

begin_function
specifier|static
name|int
name|checksum
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|h
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|bytes
decl_stmt|;
specifier|const
name|struct
name|archive_entry_header_ustar
modifier|*
name|header
decl_stmt|;
name|int
name|check
decl_stmt|,
name|i
decl_stmt|,
name|sum
decl_stmt|;
operator|(
name|void
operator|)
name|a
expr_stmt|;
comment|/* UNUSED */
name|bytes
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|h
expr_stmt|;
name|header
operator|=
operator|(
specifier|const
expr|struct
name|archive_entry_header_ustar
operator|*
operator|)
name|h
expr_stmt|;
comment|/* 	 * Test the checksum.  Note that POSIX specifies _unsigned_ 	 * bytes for this calculation. 	 */
name|sum
operator|=
name|tar_atol
argument_list|(
name|header
operator|->
name|checksum
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|checksum
argument_list|)
argument_list|)
expr_stmt|;
name|check
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|148
condition|;
name|i
operator|++
control|)
name|check
operator|+=
operator|(
name|unsigned
name|char
operator|)
name|bytes
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
literal|156
condition|;
name|i
operator|++
control|)
name|check
operator|+=
literal|32
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
literal|512
condition|;
name|i
operator|++
control|)
name|check
operator|+=
operator|(
name|unsigned
name|char
operator|)
name|bytes
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sum
operator|==
name|check
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * Repeat test with _signed_ bytes, just in case this archive 	 * was created by an old BSD, Solaris, or HP-UX tar with a 	 * broken checksum calculation. 	 */
name|check
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|148
condition|;
name|i
operator|++
control|)
name|check
operator|+=
operator|(
name|signed
name|char
operator|)
name|bytes
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
literal|156
condition|;
name|i
operator|++
control|)
name|check
operator|+=
literal|32
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
literal|512
condition|;
name|i
operator|++
control|)
name|check
operator|+=
operator|(
name|signed
name|char
operator|)
name|bytes
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sum
operator|==
name|check
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return true if this block contains only nulls.  */
end_comment

begin_function
specifier|static
name|int
name|archive_block_is_null
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ARCHIVE_BYTES_PER_RECORD
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|++
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Interpret 'A' Solaris ACL header  */
end_comment

begin_function
specifier|static
name|int
name|header_Solaris_ACL
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
specifier|const
name|void
modifier|*
name|h
parameter_list|)
block|{
specifier|const
name|struct
name|archive_entry_header_ustar
modifier|*
name|header
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|err
decl_stmt|;
name|char
modifier|*
name|acl
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|wchar_t
modifier|*
name|wp
decl_stmt|;
comment|/* 	 * read_body_to_string adds a NUL terminator, but we need a little 	 * more to make sure that we don't overrun acl_text later. 	 */
name|header
operator|=
operator|(
specifier|const
expr|struct
name|archive_entry_header_ustar
operator|*
operator|)
name|h
expr_stmt|;
name|size
operator|=
name|tar_atol
argument_list|(
name|header
operator|->
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|read_body_to_string
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
operator|&
operator|(
name|tar
operator|->
name|acl_text
operator|)
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|tar_read_header
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|!=
name|ARCHIVE_OK
operator|)
operator|&&
operator|(
name|err
operator|!=
name|ARCHIVE_WARN
operator|)
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Skip leading octal number. */
comment|/* XXX TODO: Parse the octal number and sanity-check it. */
name|p
operator|=
name|acl
operator|=
name|tar
operator|->
name|acl_text
operator|.
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
name|p
operator|<
name|acl
operator|+
name|size
condition|)
name|p
operator|++
expr_stmt|;
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|acl
operator|+
name|size
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Malformed Solaris ACL attribute"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
comment|/* Skip leading octal number. */
name|size
operator|-=
operator|(
name|p
operator|-
name|acl
operator|)
expr_stmt|;
name|acl
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
name|p
operator|<
name|acl
operator|+
name|size
condition|)
name|p
operator|++
expr_stmt|;
name|wp
operator|=
operator|(
name|wchar_t
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|p
operator|-
name|acl
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wp
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate work buffer for ACL parsing"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|utf8_decode
argument_list|(
name|wp
argument_list|,
name|acl
argument_list|,
name|p
operator|-
name|acl
argument_list|)
expr_stmt|;
name|err
operator|=
name|__archive_entry_acl_parse_w
argument_list|(
name|entry
argument_list|,
name|wp
argument_list|,
name|ARCHIVE_ENTRY_ACL_TYPE_ACCESS
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wp
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Interpret 'K' long linkname header.  */
end_comment

begin_function
specifier|static
name|int
name|header_longlink
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
specifier|const
name|void
modifier|*
name|h
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
name|read_body_to_string
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
operator|&
operator|(
name|tar
operator|->
name|longlink
operator|)
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|tar_read_header
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|!=
name|ARCHIVE_OK
operator|)
operator|&&
operator|(
name|err
operator|!=
name|ARCHIVE_WARN
operator|)
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Set symlink if symlink already set, else hardlink. */
name|archive_entry_set_link
argument_list|(
name|entry
argument_list|,
name|tar
operator|->
name|longlink
operator|.
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Interpret 'L' long filename header.  */
end_comment

begin_function
specifier|static
name|int
name|header_longname
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
specifier|const
name|void
modifier|*
name|h
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
name|read_body_to_string
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
operator|&
operator|(
name|tar
operator|->
name|longname
operator|)
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Read and parse "real" header, then override name. */
name|err
operator|=
name|tar_read_header
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|!=
name|ARCHIVE_OK
operator|)
operator|&&
operator|(
name|err
operator|!=
name|ARCHIVE_WARN
operator|)
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|archive_entry_set_pathname
argument_list|(
name|entry
argument_list|,
name|tar
operator|->
name|longname
operator|.
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Interpret 'V' GNU tar volume header.  */
end_comment

begin_function
specifier|static
name|int
name|header_volume
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
specifier|const
name|void
modifier|*
name|h
parameter_list|)
block|{
operator|(
name|void
operator|)
name|h
expr_stmt|;
comment|/* Just skip this and read the next header. */
return|return
operator|(
name|tar_read_header
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read body of an archive entry into an archive_string object.  */
end_comment

begin_function
specifier|static
name|int
name|read_body_to_string
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|void
modifier|*
name|h
parameter_list|)
block|{
name|off_t
name|size
decl_stmt|,
name|padded_size
decl_stmt|;
name|ssize_t
name|bytes_read
decl_stmt|,
name|bytes_to_copy
decl_stmt|;
specifier|const
name|struct
name|archive_entry_header_ustar
modifier|*
name|header
decl_stmt|;
specifier|const
name|void
modifier|*
name|src
decl_stmt|;
name|char
modifier|*
name|dest
decl_stmt|;
operator|(
name|void
operator|)
name|tar
expr_stmt|;
comment|/* UNUSED */
name|header
operator|=
operator|(
specifier|const
expr|struct
name|archive_entry_header_ustar
operator|*
operator|)
name|h
expr_stmt|;
name|size
operator|=
name|tar_atol
argument_list|(
name|header
operator|->
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size
operator|>
literal|1048576
operator|)
operator|||
operator|(
name|size
operator|<
literal|0
operator|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|EINVAL
argument_list|,
literal|"Special header too large"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Read the body into the string. */
name|archive_string_ensure
argument_list|(
name|as
argument_list|,
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
name|padded_size
operator|=
operator|(
name|size
operator|+
literal|511
operator|)
operator|&
operator|~
literal|511
expr_stmt|;
name|dest
operator|=
name|as
operator|->
name|s
expr_stmt|;
while|while
condition|(
name|padded_size
operator|>
literal|0
condition|)
block|{
name|bytes_read
operator|=
call|(
name|a
operator|->
name|decompressor
operator|->
name|read_ahead
call|)
argument_list|(
name|a
argument_list|,
operator|&
name|src
argument_list|,
name|padded_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
if|if
condition|(
name|bytes_read
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
if|if
condition|(
name|bytes_read
operator|>
name|padded_size
condition|)
name|bytes_read
operator|=
name|padded_size
expr_stmt|;
call|(
name|a
operator|->
name|decompressor
operator|->
name|consume
call|)
argument_list|(
name|a
argument_list|,
name|bytes_read
argument_list|)
expr_stmt|;
name|bytes_to_copy
operator|=
name|bytes_read
expr_stmt|;
if|if
condition|(
operator|(
name|off_t
operator|)
name|bytes_to_copy
operator|>
name|size
condition|)
name|bytes_to_copy
operator|=
operator|(
name|ssize_t
operator|)
name|size
expr_stmt|;
name|memcpy
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|bytes_to_copy
argument_list|)
expr_stmt|;
name|dest
operator|+=
name|bytes_to_copy
expr_stmt|;
name|size
operator|-=
name|bytes_to_copy
expr_stmt|;
name|padded_size
operator|-=
name|bytes_read
expr_stmt|;
block|}
operator|*
name|dest
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse out common header elements.  *  * This would be the same as header_old_tar, except that the  * filename is handled slightly differently for old and POSIX  * entries  (POSIX entries support a 'prefix').  This factoring  * allows header_old_tar and header_ustar  * to handle filenames differently, while still putting most of the  * common parsing into one place.  */
end_comment

begin_function
specifier|static
name|int
name|header_common
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
specifier|const
name|void
modifier|*
name|h
parameter_list|)
block|{
specifier|const
name|struct
name|archive_entry_header_ustar
modifier|*
name|header
decl_stmt|;
name|char
name|tartype
decl_stmt|;
operator|(
name|void
operator|)
name|a
expr_stmt|;
comment|/* UNUSED */
name|header
operator|=
operator|(
specifier|const
expr|struct
name|archive_entry_header_ustar
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|linkname
index|[
literal|0
index|]
condition|)
name|archive_strncpy
argument_list|(
operator|&
operator|(
name|tar
operator|->
name|entry_linkname
operator|)
argument_list|,
name|header
operator|->
name|linkname
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|linkname
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|tar
operator|->
name|entry_linkname
operator|)
argument_list|)
expr_stmt|;
comment|/* Parse out the numeric fields (all are octal) */
name|archive_entry_set_mode
argument_list|(
name|entry
argument_list|,
name|tar_atol
argument_list|(
name|header
operator|->
name|mode
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|mode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_set_uid
argument_list|(
name|entry
argument_list|,
name|tar_atol
argument_list|(
name|header
operator|->
name|uid
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|uid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_set_gid
argument_list|(
name|entry
argument_list|,
name|tar_atol
argument_list|(
name|header
operator|->
name|gid
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|gid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tar
operator|->
name|entry_bytes_remaining
operator|=
name|tar_atol
argument_list|(
name|header
operator|->
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
name|tar
operator|->
name|entry_bytes_remaining
argument_list|)
expr_stmt|;
name|archive_entry_set_mtime
argument_list|(
name|entry
argument_list|,
name|tar_atol
argument_list|(
name|header
operator|->
name|mtime
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|mtime
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Handle the tar type flag appropriately. */
name|tartype
operator|=
name|header
operator|->
name|typeflag
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
name|tartype
condition|)
block|{
case|case
literal|'1'
case|:
comment|/* Hard link */
name|archive_entry_set_hardlink
argument_list|(
name|entry
argument_list|,
name|tar
operator|->
name|entry_linkname
operator|.
name|s
argument_list|)
expr_stmt|;
comment|/* 		 * The following may seem odd, but: Technically, tar 		 * does not store the file type for a "hard link" 		 * entry, only the fact that it is a hard link.  So, I 		 * leave the type zero normally.  But, pax interchange 		 * format allows hard links to have data, which 		 * implies that the underlying entry is a regular 		 * file. 		 */
if|if
condition|(
name|archive_entry_size
argument_list|(
name|entry
argument_list|)
operator|>
literal|0
condition|)
name|archive_entry_set_filetype
argument_list|(
name|entry
argument_list|,
name|AE_IFREG
argument_list|)
expr_stmt|;
comment|/* 		 * A tricky point: Traditionally, tar readers have 		 * ignored the size field when reading hardlink 		 * entries, and some writers put non-zero sizes even 		 * though the body is empty.  POSIX.1-2001 broke with 		 * this tradition by permitting hardlink entries to 		 * store valid bodies in pax interchange format, but 		 * not in ustar format.  Since there is no hard and 		 * fast way to distinguish pax interchange from 		 * earlier archives (the 'x' and 'g' entries are 		 * optional, after all), we need a heuristic.  Here, I 		 * use the bid function to test whether or not there's 		 * a valid header following.  Of course, if we know 		 * this is pax interchange format, then we must obey 		 * the size. 		 * 		 * This heuristic will only fail for a pax interchange 		 * archive that is storing hardlink bodies, no pax 		 * extended attribute entries have yet occurred, and 		 * we encounter a hardlink entry for a file that is 		 * itself an uncompressed tar archive. 		 */
if|if
condition|(
name|archive_entry_size
argument_list|(
name|entry
argument_list|)
operator|>
literal|0
operator|&&
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|!=
name|ARCHIVE_FORMAT_TAR_PAX_INTERCHANGE
operator|&&
name|archive_read_format_tar_bid
argument_list|(
name|a
argument_list|)
operator|>
literal|50
condition|)
block|{
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tar
operator|->
name|entry_bytes_remaining
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|'2'
case|:
comment|/* Symlink */
name|archive_entry_set_filetype
argument_list|(
name|entry
argument_list|,
name|AE_IFLNK
argument_list|)
expr_stmt|;
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tar
operator|->
name|entry_bytes_remaining
operator|=
literal|0
expr_stmt|;
name|archive_entry_set_symlink
argument_list|(
name|entry
argument_list|,
name|tar
operator|->
name|entry_linkname
operator|.
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
comment|/* Character device */
name|archive_entry_set_filetype
argument_list|(
name|entry
argument_list|,
name|AE_IFCHR
argument_list|)
expr_stmt|;
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tar
operator|->
name|entry_bytes_remaining
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'4'
case|:
comment|/* Block device */
name|archive_entry_set_filetype
argument_list|(
name|entry
argument_list|,
name|AE_IFBLK
argument_list|)
expr_stmt|;
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tar
operator|->
name|entry_bytes_remaining
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'5'
case|:
comment|/* Dir */
name|archive_entry_set_filetype
argument_list|(
name|entry
argument_list|,
name|AE_IFDIR
argument_list|)
expr_stmt|;
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tar
operator|->
name|entry_bytes_remaining
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'6'
case|:
comment|/* FIFO device */
name|archive_entry_set_filetype
argument_list|(
name|entry
argument_list|,
name|AE_IFIFO
argument_list|)
expr_stmt|;
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tar
operator|->
name|entry_bytes_remaining
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* GNU incremental directory type */
comment|/* 		 * No special handling is actually required here. 		 * It might be nice someday to preprocess the file list and 		 * provide it to the client, though. 		 */
name|archive_entry_set_filetype
argument_list|(
name|entry
argument_list|,
name|AE_IFDIR
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* GNU "Multi-volume" (remainder of file from last archive)*/
comment|/* 		 * As far as I can tell, this is just like a regular file 		 * entry, except that the contents should be _appended_ to 		 * the indicated file at the indicated offset.  This may 		 * require some API work to fully support. 		 */
break|break;
case|case
literal|'N'
case|:
comment|/* Old GNU "long filename" entry. */
comment|/* The body of this entry is a script for renaming 		 * previously-extracted entries.  Ugh.  It will never 		 * be supported by libarchive. */
name|archive_entry_set_filetype
argument_list|(
name|entry
argument_list|,
name|AE_IFREG
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* GNU sparse files */
comment|/* 		 * Sparse files are really just regular files with 		 * sparse information in the extended area. 		 */
comment|/* FALLTHROUGH */
default|default:
comment|/* Regular file  and non-standard types */
comment|/* 		 * Per POSIX: non-recognized types should always be 		 * treated as regular files. 		 */
name|archive_entry_set_filetype
argument_list|(
name|entry
argument_list|,
name|AE_IFREG
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse out header elements for "old-style" tar archives.  */
end_comment

begin_function
specifier|static
name|int
name|header_old_tar
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
specifier|const
name|void
modifier|*
name|h
parameter_list|)
block|{
specifier|const
name|struct
name|archive_entry_header_ustar
modifier|*
name|header
decl_stmt|;
comment|/* Copy filename over (to ensure null termination). */
name|header
operator|=
operator|(
specifier|const
expr|struct
name|archive_entry_header_ustar
operator|*
operator|)
name|h
expr_stmt|;
name|archive_strncpy
argument_list|(
operator|&
operator|(
name|tar
operator|->
name|entry_name
operator|)
argument_list|,
name|header
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_set_pathname
argument_list|(
name|entry
argument_list|,
name|tar
operator|->
name|entry_name
operator|.
name|s
argument_list|)
expr_stmt|;
comment|/* Grab rest of common fields */
name|header_common
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|tar
operator|->
name|entry_padding
operator|=
literal|0x1ff
operator|&
operator|(
operator|-
name|tar
operator|->
name|entry_bytes_remaining
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse a file header for a pax extended archive entry.  */
end_comment

begin_function
specifier|static
name|int
name|header_pax_global
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
specifier|const
name|void
modifier|*
name|h
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
name|read_body_to_string
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
operator|&
operator|(
name|tar
operator|->
name|pax_global
operator|)
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|tar_read_header
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|header_pax_extensions
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
specifier|const
name|void
modifier|*
name|h
parameter_list|)
block|{
name|int
name|err
decl_stmt|,
name|err2
decl_stmt|;
name|err
operator|=
name|read_body_to_string
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
operator|&
operator|(
name|tar
operator|->
name|pax_header
operator|)
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Parse the next header. */
name|err
operator|=
name|tar_read_header
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|!=
name|ARCHIVE_OK
operator|)
operator|&&
operator|(
name|err
operator|!=
name|ARCHIVE_WARN
operator|)
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* 	 * TODO: Parse global/default options into 'entry' struct here 	 * before handling file-specific options. 	 * 	 * This design (parse standard header, then overwrite with pax 	 * extended attribute data) usually works well, but isn't ideal; 	 * it would be better to parse the pax extended attributes first 	 * and then skip any fields in the standard header that were 	 * defined in the pax header. 	 */
name|err2
operator|=
name|pax_header
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|,
name|tar
operator|->
name|pax_header
operator|.
name|s
argument_list|)
expr_stmt|;
name|err
operator|=
name|err_combine
argument_list|(
name|err
argument_list|,
name|err2
argument_list|)
expr_stmt|;
name|tar
operator|->
name|entry_padding
operator|=
literal|0x1ff
operator|&
operator|(
operator|-
name|tar
operator|->
name|entry_bytes_remaining
operator|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse a file header for a Posix "ustar" archive entry.  This also  * handles "pax" or "extended ustar" entries.  */
end_comment

begin_function
specifier|static
name|int
name|header_ustar
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
specifier|const
name|void
modifier|*
name|h
parameter_list|)
block|{
specifier|const
name|struct
name|archive_entry_header_ustar
modifier|*
name|header
decl_stmt|;
name|struct
name|archive_string
modifier|*
name|as
decl_stmt|;
name|header
operator|=
operator|(
specifier|const
expr|struct
name|archive_entry_header_ustar
operator|*
operator|)
name|h
expr_stmt|;
comment|/* Copy name into an internal buffer to ensure null-termination. */
name|as
operator|=
operator|&
operator|(
name|tar
operator|->
name|entry_name
operator|)
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|prefix
index|[
literal|0
index|]
condition|)
block|{
name|archive_strncpy
argument_list|(
name|as
argument_list|,
name|header
operator|->
name|prefix
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|prefix
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|as
operator|->
name|s
index|[
name|archive_strlen
argument_list|(
name|as
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|archive_strappend_char
argument_list|(
name|as
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|archive_strncat
argument_list|(
name|as
argument_list|,
name|header
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|archive_strncpy
argument_list|(
name|as
argument_list|,
name|header
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_set_pathname
argument_list|(
name|entry
argument_list|,
name|as
operator|->
name|s
argument_list|)
expr_stmt|;
comment|/* Handle rest of common fields. */
name|header_common
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|,
name|h
argument_list|)
expr_stmt|;
comment|/* Handle POSIX ustar fields. */
name|archive_strncpy
argument_list|(
operator|&
operator|(
name|tar
operator|->
name|entry_uname
operator|)
argument_list|,
name|header
operator|->
name|uname
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|uname
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_set_uname
argument_list|(
name|entry
argument_list|,
name|tar
operator|->
name|entry_uname
operator|.
name|s
argument_list|)
expr_stmt|;
name|archive_strncpy
argument_list|(
operator|&
operator|(
name|tar
operator|->
name|entry_gname
operator|)
argument_list|,
name|header
operator|->
name|gname
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|gname
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_set_gname
argument_list|(
name|entry
argument_list|,
name|tar
operator|->
name|entry_gname
operator|.
name|s
argument_list|)
expr_stmt|;
comment|/* Parse out device numbers only for char and block specials. */
if|if
condition|(
name|header
operator|->
name|typeflag
index|[
literal|0
index|]
operator|==
literal|'3'
operator|||
name|header
operator|->
name|typeflag
index|[
literal|0
index|]
operator|==
literal|'4'
condition|)
block|{
name|archive_entry_set_rdevmajor
argument_list|(
name|entry
argument_list|,
name|tar_atol
argument_list|(
name|header
operator|->
name|rdevmajor
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|rdevmajor
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_set_rdevminor
argument_list|(
name|entry
argument_list|,
name|tar_atol
argument_list|(
name|header
operator|->
name|rdevminor
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|rdevminor
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tar
operator|->
name|entry_padding
operator|=
literal|0x1ff
operator|&
operator|(
operator|-
name|tar
operator|->
name|entry_bytes_remaining
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse the pax extended attributes record.  *  * Returns non-zero if there's an error in the data.  */
end_comment

begin_function
specifier|static
name|int
name|pax_header
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|char
modifier|*
name|attr
parameter_list|)
block|{
name|size_t
name|attr_length
decl_stmt|,
name|l
decl_stmt|,
name|line_length
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|wchar_t
modifier|*
name|key
decl_stmt|,
modifier|*
name|wp
decl_stmt|,
modifier|*
name|value
decl_stmt|;
name|int
name|err
decl_stmt|,
name|err2
decl_stmt|;
name|attr_length
operator|=
name|strlen
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|err
operator|=
name|ARCHIVE_OK
expr_stmt|;
while|while
condition|(
name|attr_length
operator|>
literal|0
condition|)
block|{
comment|/* Parse decimal length field at start of line. */
name|line_length
operator|=
literal|0
expr_stmt|;
name|l
operator|=
name|attr_length
expr_stmt|;
name|line
operator|=
name|p
operator|=
name|attr
expr_stmt|;
comment|/* Record start of line. */
while|while
condition|(
name|l
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|l
operator|--
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|p
operator|<
literal|'0'
operator|||
operator|*
name|p
operator|>
literal|'9'
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Ignoring malformed pax extended attributes"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
name|line_length
operator|*=
literal|10
expr_stmt|;
name|line_length
operator|+=
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|line_length
operator|>
literal|999999
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Rejecting pax extended attribute> 1MB"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
name|p
operator|++
expr_stmt|;
name|l
operator|--
expr_stmt|;
block|}
comment|/* 		 * Parsed length must be no bigger than available data, 		 * at least 1, and the last character of the line must 		 * be '\n'. 		 */
if|if
condition|(
name|line_length
operator|>
name|attr_length
operator|||
name|line_length
operator|<
literal|1
operator|||
name|attr
index|[
name|line_length
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Ignoring malformed pax extended attribute"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
comment|/* Ensure pax_entry buffer is big enough. */
if|if
condition|(
name|tar
operator|->
name|pax_entry_length
operator|<=
name|line_length
condition|)
block|{
name|wchar_t
modifier|*
name|old_entry
init|=
name|tar
operator|->
name|pax_entry
decl_stmt|;
if|if
condition|(
name|tar
operator|->
name|pax_entry_length
operator|<=
literal|0
condition|)
name|tar
operator|->
name|pax_entry_length
operator|=
literal|1024
expr_stmt|;
while|while
condition|(
name|tar
operator|->
name|pax_entry_length
operator|<=
name|line_length
operator|+
literal|1
condition|)
name|tar
operator|->
name|pax_entry_length
operator|*=
literal|2
expr_stmt|;
name|old_entry
operator|=
name|tar
operator|->
name|pax_entry
expr_stmt|;
name|tar
operator|->
name|pax_entry
operator|=
operator|(
name|wchar_t
operator|*
operator|)
name|realloc
argument_list|(
name|tar
operator|->
name|pax_entry
argument_list|,
name|tar
operator|->
name|pax_entry_length
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tar
operator|->
name|pax_entry
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|old_entry
argument_list|)
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"No memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
block|}
comment|/* Decode UTF-8 to wchar_t, null-terminate result. */
if|if
condition|(
name|utf8_decode
argument_list|(
name|tar
operator|->
name|pax_entry
argument_list|,
name|p
argument_list|,
name|line_length
operator|-
operator|(
name|p
operator|-
name|attr
operator|)
operator|-
literal|1
argument_list|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Invalid UTF8 character in pax extended attribute"
argument_list|)
expr_stmt|;
name|err
operator|=
name|err_combine
argument_list|(
name|err
argument_list|,
name|ARCHIVE_WARN
argument_list|)
expr_stmt|;
block|}
comment|/* Null-terminate 'key' value. */
name|wp
operator|=
name|key
operator|=
name|tar
operator|->
name|pax_entry
expr_stmt|;
if|if
condition|(
name|key
index|[
literal|0
index|]
operator|==
literal|L'
expr|='
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
while|while
condition|(
operator|*
name|wp
operator|&&
operator|*
name|wp
operator|!=
literal|L'
expr|='
condition|)
operator|++
name|wp
expr_stmt|;
if|if
condition|(
operator|*
name|wp
operator|==
literal|L'
expr|\0'
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Invalid pax extended attributes"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
operator|*
name|wp
operator|=
literal|0
expr_stmt|;
comment|/* Identify null-terminated 'value' portion. */
name|value
operator|=
name|wp
operator|+
literal|1
expr_stmt|;
comment|/* Identify this attribute and set it in the entry. */
name|err2
operator|=
name|pax_attribute
argument_list|(
name|tar
argument_list|,
name|entry
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|err
operator|=
name|err_combine
argument_list|(
name|err
argument_list|,
name|err2
argument_list|)
expr_stmt|;
comment|/* Skip to next line */
name|attr
operator|+=
name|line_length
expr_stmt|;
name|attr_length
operator|-=
name|line_length
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pax_attribute_xattr
parameter_list|(
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|wchar_t
modifier|*
name|name
parameter_list|,
name|wchar_t
modifier|*
name|value
parameter_list|)
block|{
name|char
modifier|*
name|name_decoded
decl_stmt|,
modifier|*
name|name_narrow
decl_stmt|;
name|void
modifier|*
name|value_decoded
decl_stmt|;
name|size_t
name|value_len
decl_stmt|;
if|if
condition|(
name|wcslen
argument_list|(
name|name
argument_list|)
operator|<
literal|18
operator|||
operator|(
name|wcsncmp
argument_list|(
name|name
argument_list|,
literal|L"LIBARCHIVE.xattr."
argument_list|,
literal|17
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
literal|3
return|;
name|name
operator|+=
literal|17
expr_stmt|;
comment|/* URL-decode name */
name|name_narrow
operator|=
name|wide_to_narrow
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_narrow
operator|==
name|NULL
condition|)
return|return
literal|2
return|;
name|name_decoded
operator|=
name|url_decode
argument_list|(
name|name_narrow
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name_narrow
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_decoded
operator|==
name|NULL
condition|)
return|return
literal|2
return|;
comment|/* Base-64 decode value */
name|value_decoded
operator|=
name|base64_decode
argument_list|(
name|value
argument_list|,
name|wcslen
argument_list|(
name|value
argument_list|)
argument_list|,
operator|&
name|value_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|value_decoded
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|name_decoded
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|archive_entry_xattr_add_entry
argument_list|(
name|entry
argument_list|,
name|name_decoded
argument_list|,
name|value_decoded
argument_list|,
name|value_len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name_decoded
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|value_decoded
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Parse a single key=value attribute.  key/value pointers are  * assumed to point into reasonably long-lived storage.  *  * Note that POSIX reserves all-lowercase keywords.  Vendor-specific  * extensions should always have keywords of the form "VENDOR.attribute"  * In particular, it's quite feasible to support many different  * vendor extensions here.  I'm using "LIBARCHIVE" for extensions  * unique to this library.  *  * Investigate other vendor-specific extensions and see if  * any of them look useful.  */
end_comment

begin_function
specifier|static
name|int
name|pax_attribute
parameter_list|(
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|wchar_t
modifier|*
name|key
parameter_list|,
name|wchar_t
modifier|*
name|value
parameter_list|)
block|{
name|int64_t
name|s
decl_stmt|;
name|long
name|n
decl_stmt|;
switch|switch
condition|(
name|key
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'G'
case|:
comment|/* GNU "0.0" sparse pax format. */
if|if
condition|(
name|wcscmp
argument_list|(
name|key
argument_list|,
literal|L"GNU.sparse.numblocks"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tar
operator|->
name|sparse_offset
operator|=
operator|-
literal|1
expr_stmt|;
name|tar
operator|->
name|sparse_numbytes
operator|=
operator|-
literal|1
expr_stmt|;
name|tar
operator|->
name|sparse_gnu_major
operator|=
literal|0
expr_stmt|;
name|tar
operator|->
name|sparse_gnu_minor
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|wcscmp
argument_list|(
name|key
argument_list|,
literal|L"GNU.sparse.offset"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tar
operator|->
name|sparse_offset
operator|=
name|tar_atol10
argument_list|(
name|value
argument_list|,
name|wcslen
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tar
operator|->
name|sparse_numbytes
operator|!=
operator|-
literal|1
condition|)
block|{
name|gnu_add_sparse_entry
argument_list|(
name|tar
argument_list|,
name|tar
operator|->
name|sparse_offset
argument_list|,
name|tar
operator|->
name|sparse_numbytes
argument_list|)
expr_stmt|;
name|tar
operator|->
name|sparse_offset
operator|=
operator|-
literal|1
expr_stmt|;
name|tar
operator|->
name|sparse_numbytes
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|wcscmp
argument_list|(
name|key
argument_list|,
literal|L"GNU.sparse.numbytes"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tar
operator|->
name|sparse_numbytes
operator|=
name|tar_atol10
argument_list|(
name|value
argument_list|,
name|wcslen
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tar
operator|->
name|sparse_numbytes
operator|!=
operator|-
literal|1
condition|)
block|{
name|gnu_add_sparse_entry
argument_list|(
name|tar
argument_list|,
name|tar
operator|->
name|sparse_offset
argument_list|,
name|tar
operator|->
name|sparse_numbytes
argument_list|)
expr_stmt|;
name|tar
operator|->
name|sparse_offset
operator|=
operator|-
literal|1
expr_stmt|;
name|tar
operator|->
name|sparse_numbytes
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|wcscmp
argument_list|(
name|key
argument_list|,
literal|L"GNU.sparse.size"
argument_list|)
operator|==
literal|0
condition|)
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
name|tar_atol10
argument_list|(
name|value
argument_list|,
name|wcslen
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* GNU "0.1" sparse pax format. */
if|if
condition|(
name|wcscmp
argument_list|(
name|key
argument_list|,
literal|L"GNU.sparse.map"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tar
operator|->
name|sparse_gnu_major
operator|=
literal|0
expr_stmt|;
name|tar
operator|->
name|sparse_gnu_minor
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|gnu_sparse_01_parse
argument_list|(
name|tar
argument_list|,
name|value
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
comment|/* GNU "1.0" sparse pax format */
if|if
condition|(
name|wcscmp
argument_list|(
name|key
argument_list|,
literal|L"GNU.sparse.major"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tar
operator|->
name|sparse_gnu_major
operator|=
name|tar_atol10
argument_list|(
name|value
argument_list|,
name|wcslen
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|tar
operator|->
name|sparse_gnu_pending
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|wcscmp
argument_list|(
name|key
argument_list|,
literal|L"GNU.sparse.minor"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tar
operator|->
name|sparse_gnu_minor
operator|=
name|tar_atol10
argument_list|(
name|value
argument_list|,
name|wcslen
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|tar
operator|->
name|sparse_gnu_pending
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|wcscmp
argument_list|(
name|key
argument_list|,
literal|L"GNU.sparse.name"
argument_list|)
operator|==
literal|0
condition|)
name|archive_entry_copy_pathname_w
argument_list|(
name|entry
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|wcscmp
argument_list|(
name|key
argument_list|,
literal|L"GNU.sparse.realsize"
argument_list|)
operator|==
literal|0
condition|)
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
name|tar_atol10
argument_list|(
name|value
argument_list|,
name|wcslen
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* Our extensions */
comment|/* TODO: Handle arbitrary extended attributes... */
comment|/* 		if (strcmp(key, "LIBARCHIVE.xxxxxxx")==0) 			archive_entry_set_xxxxxx(entry, value); */
if|if
condition|(
name|wcsncmp
argument_list|(
name|key
argument_list|,
literal|L"LIBARCHIVE.xattr."
argument_list|,
literal|17
argument_list|)
operator|==
literal|0
condition|)
name|pax_attribute_xattr
argument_list|(
name|entry
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* We support some keys used by the "star" archiver */
if|if
condition|(
name|wcscmp
argument_list|(
name|key
argument_list|,
literal|L"SCHILY.acl.access"
argument_list|)
operator|==
literal|0
condition|)
name|__archive_entry_acl_parse_w
argument_list|(
name|entry
argument_list|,
name|value
argument_list|,
name|ARCHIVE_ENTRY_ACL_TYPE_ACCESS
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|wcscmp
argument_list|(
name|key
argument_list|,
literal|L"SCHILY.acl.default"
argument_list|)
operator|==
literal|0
condition|)
name|__archive_entry_acl_parse_w
argument_list|(
name|entry
argument_list|,
name|value
argument_list|,
name|ARCHIVE_ENTRY_ACL_TYPE_DEFAULT
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|wcscmp
argument_list|(
name|key
argument_list|,
literal|L"SCHILY.devmajor"
argument_list|)
operator|==
literal|0
condition|)
name|archive_entry_set_rdevmajor
argument_list|(
name|entry
argument_list|,
name|tar_atol10
argument_list|(
name|value
argument_list|,
name|wcslen
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|wcscmp
argument_list|(
name|key
argument_list|,
literal|L"SCHILY.devminor"
argument_list|)
operator|==
literal|0
condition|)
name|archive_entry_set_rdevminor
argument_list|(
name|entry
argument_list|,
name|tar_atol10
argument_list|(
name|value
argument_list|,
name|wcslen
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|wcscmp
argument_list|(
name|key
argument_list|,
literal|L"SCHILY.fflags"
argument_list|)
operator|==
literal|0
condition|)
name|archive_entry_copy_fflags_text_w
argument_list|(
name|entry
argument_list|,
name|value
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|wcscmp
argument_list|(
name|key
argument_list|,
literal|L"SCHILY.dev"
argument_list|)
operator|==
literal|0
condition|)
name|archive_entry_set_dev
argument_list|(
name|entry
argument_list|,
name|tar_atol10
argument_list|(
name|value
argument_list|,
name|wcslen
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|wcscmp
argument_list|(
name|key
argument_list|,
literal|L"SCHILY.ino"
argument_list|)
operator|==
literal|0
condition|)
name|archive_entry_set_ino
argument_list|(
name|entry
argument_list|,
name|tar_atol10
argument_list|(
name|value
argument_list|,
name|wcslen
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|wcscmp
argument_list|(
name|key
argument_list|,
literal|L"SCHILY.nlink"
argument_list|)
operator|==
literal|0
condition|)
name|archive_entry_set_nlink
argument_list|(
name|entry
argument_list|,
name|tar_atol10
argument_list|(
name|value
argument_list|,
name|wcslen
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
if|if
condition|(
name|wcscmp
argument_list|(
name|key
argument_list|,
literal|L"atime"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pax_time
argument_list|(
name|value
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|archive_entry_set_atime
argument_list|(
name|entry
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|wcscmp
argument_list|(
name|key
argument_list|,
literal|L"ctime"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pax_time
argument_list|(
name|value
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|archive_entry_set_ctime
argument_list|(
name|entry
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wcscmp
argument_list|(
name|key
argument_list|,
literal|L"charset"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* TODO: Publish charset information in entry. */
block|}
elseif|else
if|if
condition|(
name|wcscmp
argument_list|(
name|key
argument_list|,
literal|L"comment"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* TODO: Publish comment in entry. */
block|}
break|break;
case|case
literal|'g'
case|:
if|if
condition|(
name|wcscmp
argument_list|(
name|key
argument_list|,
literal|L"gid"
argument_list|)
operator|==
literal|0
condition|)
name|archive_entry_set_gid
argument_list|(
name|entry
argument_list|,
name|tar_atol10
argument_list|(
name|value
argument_list|,
name|wcslen
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|wcscmp
argument_list|(
name|key
argument_list|,
literal|L"gname"
argument_list|)
operator|==
literal|0
condition|)
name|archive_entry_copy_gname_w
argument_list|(
name|entry
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* pax interchange doesn't distinguish hardlink vs. symlink. */
if|if
condition|(
name|wcscmp
argument_list|(
name|key
argument_list|,
literal|L"linkpath"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|archive_entry_hardlink
argument_list|(
name|entry
argument_list|)
condition|)
name|archive_entry_copy_hardlink_w
argument_list|(
name|entry
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
name|archive_entry_copy_symlink_w
argument_list|(
name|entry
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
name|wcscmp
argument_list|(
name|key
argument_list|,
literal|L"mtime"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pax_time
argument_list|(
name|value
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|archive_entry_set_mtime
argument_list|(
name|entry
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
name|wcscmp
argument_list|(
name|key
argument_list|,
literal|L"path"
argument_list|)
operator|==
literal|0
condition|)
name|archive_entry_copy_pathname_w
argument_list|(
name|entry
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* POSIX has reserved 'realtime.*' */
break|break;
case|case
literal|'s'
case|:
comment|/* POSIX has reserved 'security.*' */
comment|/* Someday: if (wcscmp(key, L"security.acl")==0) { ... } */
if|if
condition|(
name|wcscmp
argument_list|(
name|key
argument_list|,
literal|L"size"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tar
operator|->
name|entry_bytes_remaining
operator|=
name|tar_atol10
argument_list|(
name|value
argument_list|,
name|wcslen
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
name|tar
operator|->
name|entry_bytes_remaining
argument_list|)
expr_stmt|;
block|}
name|tar
operator|->
name|entry_bytes_remaining
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
if|if
condition|(
name|wcscmp
argument_list|(
name|key
argument_list|,
literal|L"uid"
argument_list|)
operator|==
literal|0
condition|)
name|archive_entry_set_uid
argument_list|(
name|entry
argument_list|,
name|tar_atol10
argument_list|(
name|value
argument_list|,
name|wcslen
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|wcscmp
argument_list|(
name|key
argument_list|,
literal|L"uname"
argument_list|)
operator|==
literal|0
condition|)
name|archive_entry_copy_uname_w
argument_list|(
name|entry
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * parse a decimal time value, which may include a fractional portion  */
end_comment

begin_function
specifier|static
name|void
name|pax_time
parameter_list|(
specifier|const
name|wchar_t
modifier|*
name|p
parameter_list|,
name|int64_t
modifier|*
name|ps
parameter_list|,
name|long
modifier|*
name|pn
parameter_list|)
block|{
name|char
name|digit
decl_stmt|;
name|int64_t
name|s
decl_stmt|;
name|unsigned
name|long
name|l
decl_stmt|;
name|int
name|sign
decl_stmt|;
name|int64_t
name|limit
decl_stmt|,
name|last_digit_limit
decl_stmt|;
name|limit
operator|=
name|INT64_MAX
operator|/
literal|10
expr_stmt|;
name|last_digit_limit
operator|=
name|INT64_MAX
operator|%
literal|10
expr_stmt|;
name|s
operator|=
literal|0
expr_stmt|;
name|sign
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
block|{
name|digit
operator|=
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|s
operator|>
name|limit
operator|||
operator|(
name|s
operator|==
name|limit
operator|&&
name|digit
operator|>
name|last_digit_limit
operator|)
condition|)
block|{
name|s
operator|=
name|UINT64_MAX
expr_stmt|;
break|break;
block|}
name|s
operator|=
operator|(
name|s
operator|*
literal|10
operator|)
operator|+
name|digit
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
operator|*
name|ps
operator|=
name|s
operator|*
name|sign
expr_stmt|;
comment|/* Calculate nanoseconds. */
operator|*
name|pn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'.'
condition|)
return|return;
name|l
operator|=
literal|100000000UL
expr_stmt|;
do|do
block|{
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
operator|*
name|pn
operator|+=
operator|(
operator|*
name|p
operator|-
literal|'0'
operator|)
operator|*
name|l
expr_stmt|;
else|else
break|break;
block|}
do|while
condition|(
name|l
operator|/=
literal|10
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Parse GNU tar header  */
end_comment

begin_function
specifier|static
name|int
name|header_gnutar
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
specifier|const
name|void
modifier|*
name|h
parameter_list|)
block|{
specifier|const
name|struct
name|archive_entry_header_gnutar
modifier|*
name|header
decl_stmt|;
operator|(
name|void
operator|)
name|a
expr_stmt|;
comment|/* 	 * GNU header is like POSIX ustar, except 'prefix' is 	 * replaced with some other fields. This also means the 	 * filename is stored as in old-style archives. 	 */
comment|/* Grab fields common to all tar variants. */
name|header_common
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|,
name|h
argument_list|)
expr_stmt|;
comment|/* Copy filename over (to ensure null termination). */
name|header
operator|=
operator|(
specifier|const
expr|struct
name|archive_entry_header_gnutar
operator|*
operator|)
name|h
expr_stmt|;
name|archive_strncpy
argument_list|(
operator|&
operator|(
name|tar
operator|->
name|entry_name
operator|)
argument_list|,
name|header
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_set_pathname
argument_list|(
name|entry
argument_list|,
name|tar
operator|->
name|entry_name
operator|.
name|s
argument_list|)
expr_stmt|;
comment|/* Fields common to ustar and GNU */
comment|/* XXX Can the following be factored out since it's common 	 * to ustar and gnu tar?  Is it okay to move it down into 	 * header_common, perhaps?  */
name|archive_strncpy
argument_list|(
operator|&
operator|(
name|tar
operator|->
name|entry_uname
operator|)
argument_list|,
name|header
operator|->
name|uname
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|uname
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_set_uname
argument_list|(
name|entry
argument_list|,
name|tar
operator|->
name|entry_uname
operator|.
name|s
argument_list|)
expr_stmt|;
name|archive_strncpy
argument_list|(
operator|&
operator|(
name|tar
operator|->
name|entry_gname
operator|)
argument_list|,
name|header
operator|->
name|gname
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|gname
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_set_gname
argument_list|(
name|entry
argument_list|,
name|tar
operator|->
name|entry_gname
operator|.
name|s
argument_list|)
expr_stmt|;
comment|/* Parse out device numbers only for char and block specials */
if|if
condition|(
name|header
operator|->
name|typeflag
index|[
literal|0
index|]
operator|==
literal|'3'
operator|||
name|header
operator|->
name|typeflag
index|[
literal|0
index|]
operator|==
literal|'4'
condition|)
block|{
name|archive_entry_set_rdevmajor
argument_list|(
name|entry
argument_list|,
name|tar_atol
argument_list|(
name|header
operator|->
name|rdevmajor
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|rdevmajor
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_set_rdevminor
argument_list|(
name|entry
argument_list|,
name|tar_atol
argument_list|(
name|header
operator|->
name|rdevminor
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|rdevminor
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|archive_entry_set_rdev
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tar
operator|->
name|entry_padding
operator|=
literal|0x1ff
operator|&
operator|(
operator|-
name|tar
operator|->
name|entry_bytes_remaining
operator|)
expr_stmt|;
comment|/* Grab GNU-specific fields. */
name|archive_entry_set_atime
argument_list|(
name|entry
argument_list|,
name|tar_atol
argument_list|(
name|header
operator|->
name|atime
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|atime
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|archive_entry_set_ctime
argument_list|(
name|entry
argument_list|,
name|tar_atol
argument_list|(
name|header
operator|->
name|ctime
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|ctime
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|realsize
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
name|tar_atol
argument_list|(
name|header
operator|->
name|realsize
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|realsize
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|header
operator|->
name|sparse
index|[
literal|0
index|]
operator|.
name|offset
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|gnu_sparse_old_read
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|header
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|header
operator|->
name|isextended
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* XXX WTF? XXX */
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gnu_add_sparse_entry
parameter_list|(
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|off_t
name|remaining
parameter_list|)
block|{
name|struct
name|sparse_block
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|sparse_block
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|__archive_errx
argument_list|(
literal|1
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tar
operator|->
name|sparse_last
operator|!=
name|NULL
condition|)
name|tar
operator|->
name|sparse_last
operator|->
name|next
operator|=
name|p
expr_stmt|;
else|else
name|tar
operator|->
name|sparse_list
operator|=
name|p
expr_stmt|;
name|tar
operator|->
name|sparse_last
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|p
operator|->
name|remaining
operator|=
name|remaining
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * GNU tar old-format sparse data.  *  * GNU old-format sparse data is stored in a fixed-field  * format.  Offset/size values are 11-byte octal fields (same  * format as 'size' field in ustart header).  These are  * stored in the header, allocating subsequent header blocks  * as needed.  Extending the header in this way is a pretty  * severe POSIX violation; this design has earned GNU tar a  * lot of criticism.  */
end_comment

begin_function
specifier|static
name|int
name|gnu_sparse_old_read
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
specifier|const
name|struct
name|archive_entry_header_gnutar
modifier|*
name|header
parameter_list|)
block|{
name|ssize_t
name|bytes_read
decl_stmt|;
specifier|const
name|void
modifier|*
name|data
decl_stmt|;
struct|struct
name|extended
block|{
name|struct
name|gnu_sparse
name|sparse
index|[
literal|21
index|]
decl_stmt|;
name|char
name|isextended
index|[
literal|1
index|]
decl_stmt|;
name|char
name|padding
index|[
literal|7
index|]
decl_stmt|;
block|}
struct|;
specifier|const
name|struct
name|extended
modifier|*
name|ext
decl_stmt|;
name|gnu_sparse_old_parse
argument_list|(
name|tar
argument_list|,
name|header
operator|->
name|sparse
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|isextended
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
do|do
block|{
name|bytes_read
operator|=
call|(
name|a
operator|->
name|decompressor
operator|->
name|read_ahead
call|)
argument_list|(
name|a
argument_list|,
operator|&
name|data
argument_list|,
literal|512
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
if|if
condition|(
name|bytes_read
operator|<
literal|512
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated tar archive "
literal|"detected while reading sparse file data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
call|(
name|a
operator|->
name|decompressor
operator|->
name|consume
call|)
argument_list|(
name|a
argument_list|,
literal|512
argument_list|)
expr_stmt|;
name|ext
operator|=
operator|(
specifier|const
expr|struct
name|extended
operator|*
operator|)
name|data
expr_stmt|;
name|gnu_sparse_old_parse
argument_list|(
name|tar
argument_list|,
name|ext
operator|->
name|sparse
argument_list|,
literal|21
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ext
operator|->
name|isextended
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|tar
operator|->
name|sparse_list
operator|!=
name|NULL
condition|)
name|tar
operator|->
name|entry_offset
operator|=
name|tar
operator|->
name|sparse_list
operator|->
name|offset
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gnu_sparse_old_parse
parameter_list|(
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
specifier|const
name|struct
name|gnu_sparse
modifier|*
name|sparse
parameter_list|,
name|int
name|length
parameter_list|)
block|{
while|while
condition|(
name|length
operator|>
literal|0
operator|&&
name|sparse
operator|->
name|offset
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|gnu_add_sparse_entry
argument_list|(
name|tar
argument_list|,
name|tar_atol
argument_list|(
name|sparse
operator|->
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
name|sparse
operator|->
name|offset
argument_list|)
argument_list|)
argument_list|,
name|tar_atol
argument_list|(
name|sparse
operator|->
name|numbytes
argument_list|,
sizeof|sizeof
argument_list|(
name|sparse
operator|->
name|numbytes
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sparse
operator|++
expr_stmt|;
name|length
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * GNU tar sparse format 0.0  *  * Beginning with GNU tar 1.15, sparse files are stored using  * information in the pax extended header.  The GNU tar maintainers  * have gone through a number of variations in the process of working  * out this scheme; furtunately, they're all numbered.  *  * Sparse format 0.0 uses attribute GNU.sparse.numblocks to store the  * number of blocks, and GNU.sparse.offset/GNU.sparse.numbytes to  * store offset/size for each block.  The repeated instances of these  * latter fields violate the pax specification (which frowns on  * duplicate keys), so this format was quickly replaced.  */
end_comment

begin_comment
comment|/*  * GNU tar sparse format 0.1  *  * This version replaced the offset/numbytes attributes with  * a single "map" attribute that stored a list of integers.  This  * format had two problems: First, the "map" attribute could be very  * long, which caused problems for some implementations.  More  * importantly, the sparse data was lost when extracted by archivers  * that didn't recognize this extension.  */
end_comment

begin_function
specifier|static
name|int
name|gnu_sparse_01_parse
parameter_list|(
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|wchar_t
modifier|*
name|e
decl_stmt|;
name|off_t
name|offset
init|=
operator|-
literal|1
decl_stmt|,
name|size
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|e
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|e
operator|!=
literal|'\0'
operator|&&
operator|*
name|e
operator|!=
literal|','
condition|)
block|{
if|if
condition|(
operator|*
name|e
operator|<
literal|'0'
operator|||
operator|*
name|e
operator|>
literal|'9'
condition|)
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
name|e
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
name|offset
operator|=
name|tar_atol10
argument_list|(
name|p
argument_list|,
name|e
operator|-
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
else|else
block|{
name|size
operator|=
name|tar_atol10
argument_list|(
name|p
argument_list|,
name|e
operator|-
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
name|gnu_add_sparse_entry
argument_list|(
name|tar
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|e
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
name|p
operator|=
name|e
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * GNU tar sparse format 1.0  *  * The idea: The offset/size data is stored as a series of base-10  * ASCII numbers prepended to the file data, so that dearchivers that  * don't support this format will extract the block map along with the  * data and a separate post-process can restore the sparseness.  *  * Unfortunately, GNU tar 1.16 adds bogus padding to the end of the  * entry that depends on the size of the map; this means we have to  * parse the sparse map when we read the header (otherwise, entry_skip  * will fail).  This is why sparse_10_read is called from read_header  * above, instead of at the beginning of read_data, where it "should"  * go.  *  * This variant also replaced GNU.sparse.size with GNU.sparse.realsize  * and introduced the GNU.sparse.major/GNU.sparse.minor attributes.  */
end_comment

begin_comment
comment|/*  * Read the next line from the input, and parse it as a decimal  * integer followed by '\n'.  Returns positive integer value or  * negative on error.  */
end_comment

begin_function
specifier|static
name|int64_t
name|gnu_sparse_10_atol
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
name|ssize_t
modifier|*
name|total_read
parameter_list|)
block|{
name|int64_t
name|l
decl_stmt|,
name|limit
decl_stmt|,
name|last_digit_limit
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|ssize_t
name|bytes_read
decl_stmt|;
name|int
name|base
decl_stmt|,
name|digit
decl_stmt|;
name|base
operator|=
literal|10
expr_stmt|;
name|limit
operator|=
name|INT64_MAX
operator|/
name|base
expr_stmt|;
name|last_digit_limit
operator|=
name|INT64_MAX
operator|%
name|base
expr_stmt|;
name|bytes_read
operator|=
name|readline
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
operator|&
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|<=
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
operator|*
name|total_read
operator|+=
name|bytes_read
expr_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|bytes_read
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
return|return
operator|(
name|l
operator|)
return|;
if|if
condition|(
operator|*
name|p
operator|<
literal|'0'
operator|||
operator|*
name|p
operator|>=
literal|'0'
operator|+
name|base
condition|)
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
name|digit
operator|=
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|l
operator|>
name|limit
operator|||
operator|(
name|l
operator|==
name|limit
operator|&&
name|digit
operator|>
name|last_digit_limit
operator|)
condition|)
name|l
operator|=
name|UINT64_MAX
expr_stmt|;
comment|/* Truncate on overflow. */
else|else
name|l
operator|=
operator|(
name|l
operator|*
name|base
operator|)
operator|+
name|digit
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|bytes_read
operator|--
expr_stmt|;
block|}
comment|/* TODO: Error message. */
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns number of bytes consumed to read the sparse block data.  */
end_comment

begin_function
specifier|static
name|ssize_t
name|gnu_sparse_10_read
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|tar
modifier|*
name|tar
parameter_list|)
block|{
name|ssize_t
name|bytes_read
init|=
literal|0
decl_stmt|;
name|int
name|entries
decl_stmt|;
name|off_t
name|offset
decl_stmt|,
name|size
decl_stmt|,
name|to_skip
decl_stmt|;
comment|/* Parse entries. */
name|entries
operator|=
name|gnu_sparse_10_atol
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|entries
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
comment|/* Parse the individual entries. */
while|while
condition|(
name|entries
operator|--
operator|>
literal|0
condition|)
block|{
comment|/* Parse offset/size */
name|offset
operator|=
name|gnu_sparse_10_atol
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|size
operator|=
name|gnu_sparse_10_atol
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
comment|/* Add a new sparse entry. */
name|gnu_add_sparse_entry
argument_list|(
name|tar
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
comment|/* Skip rest of block... */
name|to_skip
operator|=
literal|0x1ff
operator|&
operator|-
name|bytes_read
expr_stmt|;
if|if
condition|(
name|to_skip
operator|!=
call|(
name|a
operator|->
name|decompressor
operator|->
name|skip
call|)
argument_list|(
name|a
argument_list|,
name|to_skip
argument_list|)
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
return|return
operator|(
name|bytes_read
operator|+
name|to_skip
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * Convert text->integer.  *  * Traditional tar formats (including POSIX) specify base-8 for  * all of the standard numeric fields.  This is a significant limitation  * in practice:  *   = file size is limited to 8GB  *   = rdevmajor and rdevminor are limited to 21 bits  *   = uid/gid are limited to 21 bits  *  * There are two workarounds for this:  *   = pax extended headers, which use variable-length string fields  *   = GNU tar and STAR both allow either base-8 or base-256 in  *      most fields.  The high bit is set to indicate base-256.  *  * On read, this implementation supports both extensions.  */
end_comment

begin_function
specifier|static
name|int64_t
name|tar_atol
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|unsigned
name|char_cnt
parameter_list|)
block|{
comment|/* 	 * Technically, GNU tar considers a field to be in base-256 	 * only if the first byte is 0xff or 0x80. 	 */
if|if
condition|(
operator|*
name|p
operator|&
literal|0x80
condition|)
return|return
operator|(
name|tar_atol256
argument_list|(
name|p
argument_list|,
name|char_cnt
argument_list|)
operator|)
return|;
return|return
operator|(
name|tar_atol8
argument_list|(
name|p
argument_list|,
name|char_cnt
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Note that this implementation does not (and should not!) obey  * locale settings; you cannot simply substitute strtol here, since  * it does obey locale.  */
end_comment

begin_function
specifier|static
name|int64_t
name|tar_atol8
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|unsigned
name|char_cnt
parameter_list|)
block|{
name|int64_t
name|l
decl_stmt|,
name|limit
decl_stmt|,
name|last_digit_limit
decl_stmt|;
name|int
name|digit
decl_stmt|,
name|sign
decl_stmt|,
name|base
decl_stmt|;
name|base
operator|=
literal|8
expr_stmt|;
name|limit
operator|=
name|INT64_MAX
operator|/
name|base
expr_stmt|;
name|last_digit_limit
operator|=
name|INT64_MAX
operator|%
name|base
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
else|else
name|sign
operator|=
literal|1
expr_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
name|digit
operator|=
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
while|while
condition|(
name|digit
operator|>=
literal|0
operator|&&
name|digit
operator|<
name|base
operator|&&
name|char_cnt
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|l
operator|>
name|limit
operator|||
operator|(
name|l
operator|==
name|limit
operator|&&
name|digit
operator|>
name|last_digit_limit
operator|)
condition|)
block|{
name|l
operator|=
name|UINT64_MAX
expr_stmt|;
comment|/* Truncate on overflow. */
break|break;
block|}
name|l
operator|=
operator|(
name|l
operator|*
name|base
operator|)
operator|+
name|digit
expr_stmt|;
name|digit
operator|=
operator|*
operator|++
name|p
operator|-
literal|'0'
expr_stmt|;
block|}
return|return
operator|(
name|sign
operator|<
literal|0
operator|)
condition|?
operator|-
name|l
else|:
name|l
return|;
block|}
end_function

begin_comment
comment|/*  * Note that this implementation does not (and should not!) obey  * locale settings; you cannot simply substitute strtol here, since  * it does obey locale.  */
end_comment

begin_function
specifier|static
name|int64_t
name|tar_atol10
parameter_list|(
specifier|const
name|wchar_t
modifier|*
name|p
parameter_list|,
name|unsigned
name|char_cnt
parameter_list|)
block|{
name|int64_t
name|l
decl_stmt|,
name|limit
decl_stmt|,
name|last_digit_limit
decl_stmt|;
name|int
name|base
decl_stmt|,
name|digit
decl_stmt|,
name|sign
decl_stmt|;
name|base
operator|=
literal|10
expr_stmt|;
name|limit
operator|=
name|INT64_MAX
operator|/
name|base
expr_stmt|;
name|last_digit_limit
operator|=
name|INT64_MAX
operator|%
name|base
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
else|else
name|sign
operator|=
literal|1
expr_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
name|digit
operator|=
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
while|while
condition|(
name|digit
operator|>=
literal|0
operator|&&
name|digit
operator|<
name|base
operator|&&
name|char_cnt
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|l
operator|>
name|limit
operator|||
operator|(
name|l
operator|==
name|limit
operator|&&
name|digit
operator|>
name|last_digit_limit
operator|)
condition|)
block|{
name|l
operator|=
name|UINT64_MAX
expr_stmt|;
comment|/* Truncate on overflow. */
break|break;
block|}
name|l
operator|=
operator|(
name|l
operator|*
name|base
operator|)
operator|+
name|digit
expr_stmt|;
name|digit
operator|=
operator|*
operator|++
name|p
operator|-
literal|'0'
expr_stmt|;
block|}
return|return
operator|(
name|sign
operator|<
literal|0
operator|)
condition|?
operator|-
name|l
else|:
name|l
return|;
block|}
end_function

begin_comment
comment|/*  * Parse a base-256 integer.  This is just a straight signed binary  * value in big-endian order, except that the high-order bit is  * ignored.  Remember that "int64_t" may or may not be exactly 64  * bits; the implementation here tries to avoid making any assumptions  * about the actual size of an int64_t.  It does assume we're using  * twos-complement arithmetic, though.  */
end_comment

begin_function
specifier|static
name|int64_t
name|tar_atol256
parameter_list|(
specifier|const
name|char
modifier|*
name|_p
parameter_list|,
name|unsigned
name|char_cnt
parameter_list|)
block|{
name|int64_t
name|l
decl_stmt|,
name|upper_limit
decl_stmt|,
name|lower_limit
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|_p
decl_stmt|;
name|upper_limit
operator|=
name|INT64_MAX
operator|/
literal|256
expr_stmt|;
name|lower_limit
operator|=
name|INT64_MIN
operator|/
literal|256
expr_stmt|;
comment|/* Pad with 1 or 0 bits, depending on sign. */
if|if
condition|(
operator|(
literal|0x40
operator|&
operator|*
name|p
operator|)
operator|==
literal|0x40
condition|)
name|l
operator|=
operator|(
name|int64_t
operator|)
operator|-
literal|1
expr_stmt|;
else|else
name|l
operator|=
literal|0
expr_stmt|;
name|l
operator|=
operator|(
name|l
operator|<<
literal|6
operator|)
operator||
operator|(
literal|0x3f
operator|&
operator|*
name|p
operator|++
operator|)
expr_stmt|;
while|while
condition|(
operator|--
name|char_cnt
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|l
operator|>
name|upper_limit
condition|)
block|{
name|l
operator|=
name|INT64_MAX
expr_stmt|;
comment|/* Truncate on overflow */
break|break;
block|}
elseif|else
if|if
condition|(
name|l
operator|<
name|lower_limit
condition|)
block|{
name|l
operator|=
name|INT64_MIN
expr_stmt|;
break|break;
block|}
name|l
operator|=
operator|(
name|l
operator|<<
literal|8
operator|)
operator||
operator|(
literal|0xff
operator|&
operator|(
name|int64_t
operator|)
operator|*
name|p
operator|++
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|l
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns length of line (including trailing newline)  * or negative on error.  'start' argument is updated to  * point to first character of line.  This avoids copying  * when possible.  */
end_comment

begin_function
specifier|static
name|ssize_t
name|readline
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|start
parameter_list|)
block|{
name|ssize_t
name|bytes_read
decl_stmt|;
name|ssize_t
name|total_size
init|=
literal|0
decl_stmt|;
specifier|const
name|void
modifier|*
name|t
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
name|bytes_read
operator|=
call|(
name|a
operator|->
name|decompressor
operator|->
name|read_ahead
call|)
argument_list|(
name|a
argument_list|,
operator|&
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|<=
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|s
operator|=
name|t
expr_stmt|;
comment|/* Start of line? */
name|p
operator|=
name|memchr
argument_list|(
name|t
argument_list|,
literal|'\n'
argument_list|,
name|bytes_read
argument_list|)
expr_stmt|;
comment|/* If we found '\n' in the read buffer, return pointer to that. */
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|bytes_read
operator|=
literal|1
operator|+
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
operator|)
operator|-
name|s
expr_stmt|;
call|(
name|a
operator|->
name|decompressor
operator|->
name|consume
call|)
argument_list|(
name|a
argument_list|,
name|bytes_read
argument_list|)
expr_stmt|;
operator|*
name|start
operator|=
name|s
expr_stmt|;
return|return
operator|(
name|bytes_read
operator|)
return|;
block|}
comment|/* Otherwise, we need to accumulate in a line buffer. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|archive_string_ensure
argument_list|(
operator|&
name|tar
operator|->
name|line
argument_list|,
name|total_size
operator|+
name|bytes_read
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|tar
operator|->
name|line
operator|.
name|s
operator|+
name|total_size
argument_list|,
name|t
argument_list|,
name|bytes_read
argument_list|)
expr_stmt|;
call|(
name|a
operator|->
name|decompressor
operator|->
name|consume
call|)
argument_list|(
name|a
argument_list|,
name|bytes_read
argument_list|)
expr_stmt|;
name|total_size
operator|+=
name|bytes_read
expr_stmt|;
comment|/* If we found '\n', clean up and return. */
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
operator|*
name|start
operator|=
name|tar
operator|->
name|line
operator|.
name|s
expr_stmt|;
return|return
operator|(
name|total_size
operator|)
return|;
block|}
comment|/* Read some more. */
name|bytes_read
operator|=
call|(
name|a
operator|->
name|decompressor
operator|->
name|read_ahead
call|)
argument_list|(
name|a
argument_list|,
operator|&
name|t
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|<=
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|s
operator|=
name|t
expr_stmt|;
comment|/* Start of line? */
name|p
operator|=
name|memchr
argument_list|(
name|t
argument_list|,
literal|'\n'
argument_list|,
name|bytes_read
argument_list|)
expr_stmt|;
comment|/* If we found '\n', trim the read. */
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|bytes_read
operator|=
literal|1
operator|+
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
operator|)
operator|-
name|s
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|utf8_decode
parameter_list|(
name|wchar_t
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
name|size_t
name|n
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|n
operator|=
name|UTF8_mbrtowc
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
break|break;
name|dest
operator|++
expr_stmt|;
name|src
operator|+=
name|n
expr_stmt|;
name|length
operator|-=
name|n
expr_stmt|;
block|}
operator|*
name|dest
operator|++
operator|=
literal|L'
expr|\0'
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copied and simplified from FreeBSD libc/locale.  */
end_comment

begin_function
specifier|static
name|size_t
name|UTF8_mbrtowc
parameter_list|(
name|wchar_t
modifier|*
name|pwc
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|int
name|ch
decl_stmt|,
name|i
decl_stmt|,
name|len
decl_stmt|,
name|mask
decl_stmt|;
name|unsigned
name|long
name|wch
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
name|n
operator|==
literal|0
operator|||
name|pwc
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*          * Determine the number of octets that make up this character from          * the first octet, and a mask that extracts the interesting bits of          * the first octet.          */
name|ch
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
name|mask
operator|=
literal|0x7f
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ch
operator|&
literal|0xe0
operator|)
operator|==
literal|0xc0
condition|)
block|{
name|mask
operator|=
literal|0x1f
expr_stmt|;
name|len
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ch
operator|&
literal|0xf0
operator|)
operator|==
literal|0xe0
condition|)
block|{
name|mask
operator|=
literal|0x0f
expr_stmt|;
name|len
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ch
operator|&
literal|0xf8
operator|)
operator|==
literal|0xf0
condition|)
block|{
name|mask
operator|=
literal|0x07
expr_stmt|;
name|len
operator|=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ch
operator|&
literal|0xfc
operator|)
operator|==
literal|0xf8
condition|)
block|{
name|mask
operator|=
literal|0x03
expr_stmt|;
name|len
operator|=
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ch
operator|&
literal|0xfe
operator|)
operator|==
literal|0xfc
condition|)
block|{
name|mask
operator|=
literal|0x01
expr_stmt|;
name|len
operator|=
literal|6
expr_stmt|;
block|}
else|else
block|{
comment|/* Invalid first byte; convert to '?' */
operator|*
name|pwc
operator|=
literal|'?'
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|<
operator|(
name|size_t
operator|)
name|len
condition|)
block|{
comment|/* Invalid first byte; convert to '?' */
operator|*
name|pwc
operator|=
literal|'?'
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/*          * Decode the octet sequence representing the character in chunks          * of 6 bits, most significant first.          */
name|wch
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
operator|++
operator|&
name|mask
expr_stmt|;
name|i
operator|=
name|len
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|s
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
block|{
comment|/* Invalid intermediate byte; consume one byte and 			 * emit '?' */
operator|*
name|pwc
operator|=
literal|'?'
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|wch
operator|<<=
literal|6
expr_stmt|;
name|wch
operator||=
operator|*
name|s
operator|++
operator|&
literal|0x3f
expr_stmt|;
block|}
comment|/* Assign the value to the output; out-of-range values 	 * just get truncated. */
operator|*
name|pwc
operator|=
operator|(
name|wchar_t
operator|)
name|wch
expr_stmt|;
ifdef|#
directive|ifdef
name|WCHAR_MAX
comment|/* 	 * If platform has WCHAR_MAX, we can do something 	 * more sensible with out-of-range values. 	 */
if|if
condition|(
name|wch
operator|>=
name|WCHAR_MAX
condition|)
operator|*
name|pwc
operator|=
literal|'?'
expr_stmt|;
endif|#
directive|endif
comment|/* Return number of bytes input consumed: 0 for end-of-string. */
return|return
operator|(
name|wch
operator|==
literal|L'
expr|\0'
condition|?
literal|0
else|:
name|len
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * base64_decode - Base64 decode  *  * This accepts most variations of base-64 encoding, including:  *    * with or without line breaks  *    * with or without the final group padded with '=' or '_' characters  * (The most economical Base-64 variant does not pad the last group and  * omits line breaks; RFC1341 used for MIME requires both.)  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|base64_decode
parameter_list|(
specifier|const
name|wchar_t
modifier|*
name|src
parameter_list|,
name|size_t
name|len
parameter_list|,
name|size_t
modifier|*
name|out_len
parameter_list|)
block|{
specifier|static
specifier|const
name|unsigned
name|char
name|digits
index|[
literal|64
index|]
init|=
block|{
literal|'A'
block|,
literal|'B'
block|,
literal|'C'
block|,
literal|'D'
block|,
literal|'E'
block|,
literal|'F'
block|,
literal|'G'
block|,
literal|'H'
block|,
literal|'I'
block|,
literal|'J'
block|,
literal|'K'
block|,
literal|'L'
block|,
literal|'M'
block|,
literal|'N'
block|,
literal|'O'
block|,
literal|'P'
block|,
literal|'Q'
block|,
literal|'R'
block|,
literal|'S'
block|,
literal|'T'
block|,
literal|'U'
block|,
literal|'V'
block|,
literal|'W'
block|,
literal|'X'
block|,
literal|'Y'
block|,
literal|'Z'
block|,
literal|'a'
block|,
literal|'b'
block|,
literal|'c'
block|,
literal|'d'
block|,
literal|'e'
block|,
literal|'f'
block|,
literal|'g'
block|,
literal|'h'
block|,
literal|'i'
block|,
literal|'j'
block|,
literal|'k'
block|,
literal|'l'
block|,
literal|'m'
block|,
literal|'n'
block|,
literal|'o'
block|,
literal|'p'
block|,
literal|'q'
block|,
literal|'r'
block|,
literal|'s'
block|,
literal|'t'
block|,
literal|'u'
block|,
literal|'v'
block|,
literal|'w'
block|,
literal|'x'
block|,
literal|'y'
block|,
literal|'z'
block|,
literal|'0'
block|,
literal|'1'
block|,
literal|'2'
block|,
literal|'3'
block|,
literal|'4'
block|,
literal|'5'
block|,
literal|'6'
block|,
literal|'7'
block|,
literal|'8'
block|,
literal|'9'
block|,
literal|'+'
block|,
literal|'/'
block|}
decl_stmt|;
specifier|static
name|unsigned
name|char
name|decode_table
index|[
literal|128
index|]
decl_stmt|;
name|char
modifier|*
name|out
decl_stmt|,
modifier|*
name|d
decl_stmt|;
comment|/* If the decode table is not yet initialized, prepare it. */
if|if
condition|(
name|decode_table
index|[
name|digits
index|[
literal|1
index|]
index|]
operator|!=
literal|1
condition|)
block|{
name|size_t
name|i
decl_stmt|;
name|memset
argument_list|(
name|decode_table
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|decode_table
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|digits
argument_list|)
condition|;
name|i
operator|++
control|)
name|decode_table
index|[
name|digits
index|[
name|i
index|]
index|]
operator|=
name|i
expr_stmt|;
block|}
comment|/* Allocate enough space to hold the entire output. */
comment|/* Note that we may not use all of this... */
name|out
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|len
operator|*
literal|3
operator|+
literal|3
operator|)
operator|/
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
block|{
operator|*
name|out_len
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|d
operator|=
name|out
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* Collect the next group of (up to) four characters. */
name|int
name|v
init|=
literal|0
decl_stmt|;
name|int
name|group_size
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|group_size
operator|<
literal|4
operator|&&
name|len
operator|>
literal|0
condition|)
block|{
comment|/* '=' or '_' padding indicates final group. */
if|if
condition|(
operator|*
name|src
operator|==
literal|'='
operator|||
operator|*
name|src
operator|==
literal|'_'
condition|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* Skip illegal characters (including line breaks) */
if|if
condition|(
operator|*
name|src
operator|>
literal|127
operator|||
operator|*
name|src
operator|<
literal|32
operator|||
name|decode_table
index|[
operator|*
name|src
index|]
operator|==
literal|0xff
condition|)
block|{
name|len
operator|--
expr_stmt|;
name|src
operator|++
expr_stmt|;
continue|continue;
block|}
name|v
operator|<<=
literal|6
expr_stmt|;
name|v
operator||=
name|decode_table
index|[
operator|*
name|src
operator|++
index|]
expr_stmt|;
name|len
operator|--
expr_stmt|;
name|group_size
operator|++
expr_stmt|;
block|}
comment|/* Align a short group properly. */
name|v
operator|<<=
literal|6
operator|*
operator|(
literal|4
operator|-
name|group_size
operator|)
expr_stmt|;
comment|/* Unpack the group we just collected. */
switch|switch
condition|(
name|group_size
condition|)
block|{
case|case
literal|4
case|:
name|d
index|[
literal|2
index|]
operator|=
name|v
operator|&
literal|0xff
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|3
case|:
name|d
index|[
literal|1
index|]
operator|=
operator|(
name|v
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|2
case|:
name|d
index|[
literal|0
index|]
operator|=
operator|(
name|v
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* this is invalid! */
break|break;
block|}
name|d
operator|+=
name|group_size
operator|*
literal|3
operator|/
literal|4
expr_stmt|;
block|}
operator|*
name|out_len
operator|=
name|d
operator|-
name|out
expr_stmt|;
return|return
operator|(
name|out
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is a little tricky because the C99 standard wcstombs()  * function returns the number of bytes that were converted,  * not the number that should be converted.  As a result,  * we can never accurately size the output buffer (without  * doing a tedious output size calculation in advance).  * This approach (try a conversion, then try again if it fails)  * will almost always succeed on the first try, and is thus  * much faster, at the cost of sometimes requiring multiple  * passes while we expand the buffer.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|wide_to_narrow
parameter_list|(
specifier|const
name|wchar_t
modifier|*
name|wval
parameter_list|)
block|{
name|int
name|converted_length
decl_stmt|;
comment|/* Guess an output buffer size and try the conversion. */
name|int
name|alloc_length
init|=
name|wcslen
argument_list|(
name|wval
argument_list|)
operator|*
literal|3
decl_stmt|;
name|char
modifier|*
name|mbs_val
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|alloc_length
operator|+
literal|1
argument_list|)
decl_stmt|;
if|if
condition|(
name|mbs_val
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|converted_length
operator|=
name|wcstombs
argument_list|(
name|mbs_val
argument_list|,
name|wval
argument_list|,
name|alloc_length
argument_list|)
expr_stmt|;
comment|/* If we exhausted the buffer, resize and try again. */
while|while
condition|(
name|converted_length
operator|>=
name|alloc_length
condition|)
block|{
name|free
argument_list|(
name|mbs_val
argument_list|)
expr_stmt|;
name|alloc_length
operator|*=
literal|2
expr_stmt|;
name|mbs_val
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|alloc_length
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbs_val
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|converted_length
operator|=
name|wcstombs
argument_list|(
name|mbs_val
argument_list|,
name|wval
argument_list|,
name|alloc_length
argument_list|)
expr_stmt|;
block|}
comment|/* Ensure a trailing null and return the final string. */
name|mbs_val
index|[
name|alloc_length
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|mbs_val
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|url_decode
parameter_list|(
specifier|const
name|char
modifier|*
name|in
parameter_list|)
block|{
name|char
modifier|*
name|out
decl_stmt|,
modifier|*
name|d
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|out
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|in
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|s
operator|=
name|in
operator|,
name|d
operator|=
name|out
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'%'
condition|)
block|{
comment|/* Try to convert % escape */
name|int
name|digit1
init|=
name|tohex
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|int
name|digit2
init|=
name|tohex
argument_list|(
name|s
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|digit1
operator|>=
literal|0
operator|&&
name|digit2
operator|>=
literal|0
condition|)
block|{
comment|/* Looks good, consume three chars */
name|s
operator|+=
literal|3
expr_stmt|;
comment|/* Convert output */
operator|*
name|d
operator|++
operator|=
operator|(
operator|(
name|digit1
operator|<<
literal|4
operator|)
operator||
name|digit2
operator|)
expr_stmt|;
continue|continue;
block|}
comment|/* Else fall through and treat '%' as normal char */
block|}
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|out
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tohex
parameter_list|(
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
return|return
operator|(
name|c
operator|-
literal|'0'
operator|)
return|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'F'
condition|)
return|return
operator|(
name|c
operator|-
literal|'A'
operator|+
literal|10
operator|)
return|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
condition|)
return|return
operator|(
name|c
operator|-
literal|'a'
operator|+
literal|10
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

end_unit

