begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2007 Tim Kientzle  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"archive_platform.h"
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ERRNO_H
end_ifdef

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_comment
comment|/* #include<stdint.h> */
end_comment

begin_comment
comment|/* See archive_platform.h */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Obtain suitable wide-character manipulation functions. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_WCHAR_H
end_ifdef

begin_include
include|#
directive|include
file|<wchar.h>
end_include

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Good enough for equality testing, which is all we need. */
end_comment

begin_function
specifier|static
name|int
name|wcscmp
parameter_list|(
specifier|const
name|wchar_t
modifier|*
name|s1
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|s2
parameter_list|)
block|{
name|int
name|diff
init|=
operator|*
name|s1
operator|-
operator|*
name|s2
decl_stmt|;
while|while
condition|(
operator|*
name|s1
operator|&&
name|diff
operator|==
literal|0
condition|)
name|diff
operator|=
operator|(
name|int
operator|)
operator|*
operator|++
name|s1
operator|-
operator|(
name|int
operator|)
operator|*
operator|++
name|s2
expr_stmt|;
return|return
name|diff
return|;
block|}
end_function

begin_comment
comment|/* Good enough for equality testing, which is all we need. */
end_comment

begin_function
specifier|static
name|int
name|wcsncmp
parameter_list|(
specifier|const
name|wchar_t
modifier|*
name|s1
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|s2
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|int
name|diff
init|=
operator|*
name|s1
operator|-
operator|*
name|s2
decl_stmt|;
while|while
condition|(
operator|*
name|s1
operator|&&
name|diff
operator|==
literal|0
operator|&&
name|n
operator|--
operator|>
literal|0
condition|)
name|diff
operator|=
operator|(
name|int
operator|)
operator|*
operator|++
name|s1
operator|-
operator|(
name|int
operator|)
operator|*
operator|++
name|s2
expr_stmt|;
return|return
name|diff
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|wcslen
parameter_list|(
specifier|const
name|wchar_t
modifier|*
name|s
parameter_list|)
block|{
specifier|const
name|wchar_t
modifier|*
name|p
init|=
name|s
decl_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
name|p
operator|++
expr_stmt|;
return|return
name|p
operator|-
name|s
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"archive.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry.h"
end_include

begin_include
include|#
directive|include
file|"archive_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_read_private.h"
end_include

begin_define
define|#
directive|define
name|tar_min
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_comment
comment|/*  * Layout of POSIX 'ustar' tar header.  */
end_comment

begin_struct
struct|struct
name|archive_entry_header_ustar
block|{
name|char
name|name
index|[
literal|100
index|]
decl_stmt|;
name|char
name|mode
index|[
literal|8
index|]
decl_stmt|;
name|char
name|uid
index|[
literal|8
index|]
decl_stmt|;
name|char
name|gid
index|[
literal|8
index|]
decl_stmt|;
name|char
name|size
index|[
literal|12
index|]
decl_stmt|;
name|char
name|mtime
index|[
literal|12
index|]
decl_stmt|;
name|char
name|checksum
index|[
literal|8
index|]
decl_stmt|;
name|char
name|typeflag
index|[
literal|1
index|]
decl_stmt|;
name|char
name|linkname
index|[
literal|100
index|]
decl_stmt|;
comment|/* "old format" header ends here */
name|char
name|magic
index|[
literal|6
index|]
decl_stmt|;
comment|/* For POSIX: "ustar\0" */
name|char
name|version
index|[
literal|2
index|]
decl_stmt|;
comment|/* For POSIX: "00" */
name|char
name|uname
index|[
literal|32
index|]
decl_stmt|;
name|char
name|gname
index|[
literal|32
index|]
decl_stmt|;
name|char
name|rdevmajor
index|[
literal|8
index|]
decl_stmt|;
name|char
name|rdevminor
index|[
literal|8
index|]
decl_stmt|;
name|char
name|prefix
index|[
literal|155
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Structure of GNU tar header  */
end_comment

begin_struct
struct|struct
name|gnu_sparse
block|{
name|char
name|offset
index|[
literal|12
index|]
decl_stmt|;
name|char
name|numbytes
index|[
literal|12
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|archive_entry_header_gnutar
block|{
name|char
name|name
index|[
literal|100
index|]
decl_stmt|;
name|char
name|mode
index|[
literal|8
index|]
decl_stmt|;
name|char
name|uid
index|[
literal|8
index|]
decl_stmt|;
name|char
name|gid
index|[
literal|8
index|]
decl_stmt|;
name|char
name|size
index|[
literal|12
index|]
decl_stmt|;
name|char
name|mtime
index|[
literal|12
index|]
decl_stmt|;
name|char
name|checksum
index|[
literal|8
index|]
decl_stmt|;
name|char
name|typeflag
index|[
literal|1
index|]
decl_stmt|;
name|char
name|linkname
index|[
literal|100
index|]
decl_stmt|;
name|char
name|magic
index|[
literal|8
index|]
decl_stmt|;
comment|/* "ustar  \0" (note blank/blank/null at end) */
name|char
name|uname
index|[
literal|32
index|]
decl_stmt|;
name|char
name|gname
index|[
literal|32
index|]
decl_stmt|;
name|char
name|rdevmajor
index|[
literal|8
index|]
decl_stmt|;
name|char
name|rdevminor
index|[
literal|8
index|]
decl_stmt|;
name|char
name|atime
index|[
literal|12
index|]
decl_stmt|;
name|char
name|ctime
index|[
literal|12
index|]
decl_stmt|;
name|char
name|offset
index|[
literal|12
index|]
decl_stmt|;
name|char
name|longnames
index|[
literal|4
index|]
decl_stmt|;
name|char
name|unused
index|[
literal|1
index|]
decl_stmt|;
name|struct
name|gnu_sparse
name|sparse
index|[
literal|4
index|]
decl_stmt|;
name|char
name|isextended
index|[
literal|1
index|]
decl_stmt|;
name|char
name|realsize
index|[
literal|12
index|]
decl_stmt|;
comment|/* 	 * Old GNU format doesn't use POSIX 'prefix' field; they use 	 * the 'L' (longname) entry instead. 	 */
block|}
struct|;
end_struct

begin_comment
comment|/*  * Data specific to this format.  */
end_comment

begin_struct
struct|struct
name|sparse_block
block|{
name|struct
name|sparse_block
modifier|*
name|next
decl_stmt|;
name|off_t
name|offset
decl_stmt|;
name|off_t
name|remaining
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|tar
block|{
name|struct
name|archive_string
name|acl_text
decl_stmt|;
name|struct
name|archive_string
name|entry_pathname
decl_stmt|;
comment|/* For "GNU.sparse.name" and other similar path extensions. */
name|struct
name|archive_string
name|entry_pathname_override
decl_stmt|;
name|struct
name|archive_string
name|entry_linkpath
decl_stmt|;
name|struct
name|archive_string
name|entry_uname
decl_stmt|;
name|struct
name|archive_string
name|entry_gname
decl_stmt|;
name|struct
name|archive_string
name|longlink
decl_stmt|;
name|struct
name|archive_string
name|longname
decl_stmt|;
name|struct
name|archive_string
name|pax_header
decl_stmt|;
name|struct
name|archive_string
name|pax_global
decl_stmt|;
name|struct
name|archive_string
name|line
decl_stmt|;
name|int
name|pax_hdrcharset_binary
decl_stmt|;
name|wchar_t
modifier|*
name|pax_entry
decl_stmt|;
name|size_t
name|pax_entry_length
decl_stmt|;
name|int
name|header_recursion_depth
decl_stmt|;
name|int64_t
name|entry_bytes_remaining
decl_stmt|;
name|int64_t
name|entry_offset
decl_stmt|;
name|int64_t
name|entry_padding
decl_stmt|;
name|int64_t
name|realsize
decl_stmt|;
name|struct
name|sparse_block
modifier|*
name|sparse_list
decl_stmt|;
name|struct
name|sparse_block
modifier|*
name|sparse_last
decl_stmt|;
name|int64_t
name|sparse_offset
decl_stmt|;
name|int64_t
name|sparse_numbytes
decl_stmt|;
name|int
name|sparse_gnu_major
decl_stmt|;
name|int
name|sparse_gnu_minor
decl_stmt|;
name|char
name|sparse_gnu_pending
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|ssize_t
name|UTF8_mbrtowc
parameter_list|(
name|wchar_t
modifier|*
name|pwc
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|n
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_block_is_null
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|base64_decode
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gnu_add_sparse_entry
parameter_list|(
name|struct
name|tar
modifier|*
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|off_t
name|remaining
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gnu_clear_sparse_list
parameter_list|(
name|struct
name|tar
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gnu_sparse_old_read
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|tar
modifier|*
parameter_list|,
specifier|const
name|struct
name|archive_entry_header_gnutar
modifier|*
name|header
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|gnu_sparse_old_parse
parameter_list|(
name|struct
name|tar
modifier|*
parameter_list|,
specifier|const
name|struct
name|gnu_sparse
modifier|*
name|sparse
parameter_list|,
name|int
name|length
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gnu_sparse_01_parse
parameter_list|(
name|struct
name|tar
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ssize_t
name|gnu_sparse_10_read
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|tar
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|header_Solaris_ACL
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|tar
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|header_common
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|tar
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|header_old_tar
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|tar
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|header_pax_extensions
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|tar
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|header_pax_global
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|tar
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
name|h
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|header_longlink
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|tar
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
name|h
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|header_longname
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|tar
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
name|h
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|header_volume
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|tar
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
name|h
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|header_ustar
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|tar
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
name|h
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|header_gnutar
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|tar
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
name|h
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_tar_bid
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_tar_cleanup
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_tar_read_data
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|off_t
modifier|*
name|offset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_tar_skip
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_format_tar_read_header
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|checksum
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pax_attribute
parameter_list|(
name|struct
name|tar
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|char
modifier|*
name|key
parameter_list|,
name|char
modifier|*
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|pax_header
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|tar
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|char
modifier|*
name|attr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pax_time
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int64_t
modifier|*
name|sec
parameter_list|,
name|long
modifier|*
name|nanos
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ssize_t
name|readline
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|tar
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
name|ssize_t
name|limit
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|read_body_to_string
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|tar
modifier|*
parameter_list|,
name|struct
name|archive_string
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
name|h
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int64_t
name|tar_atol
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int64_t
name|tar_atol10
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int64_t
name|tar_atol256
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int64_t
name|tar_atol8
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|unsigned
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tar_read_header
parameter_list|(
name|struct
name|archive_read
modifier|*
parameter_list|,
name|struct
name|tar
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|tohex
parameter_list|(
name|int
name|c
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|url_decode
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|wchar_t
modifier|*
name|utf8_decode
parameter_list|(
name|struct
name|tar
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
name|length
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|archive_read_support_format_gnutar
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|)
block|{
return|return
operator|(
name|archive_read_support_format_tar
argument_list|(
name|a
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|archive_read_support_format_tar
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|archive_read
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_read
operator|*
operator|)
name|_a
decl_stmt|;
name|struct
name|tar
modifier|*
name|tar
decl_stmt|;
name|int
name|r
decl_stmt|;
name|tar
operator|=
operator|(
expr|struct
name|tar
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|tar
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tar
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate tar data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|memset
argument_list|(
name|tar
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tar
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|__archive_read_register_format
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
literal|"tar"
argument_list|,
name|archive_read_format_tar_bid
argument_list|,
name|NULL
argument_list|,
name|archive_read_format_tar_read_header
argument_list|,
name|archive_read_format_tar_read_data
argument_list|,
name|archive_read_format_tar_skip
argument_list|,
name|archive_read_format_tar_cleanup
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
name|free
argument_list|(
name|tar
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_tar_cleanup
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|tar
modifier|*
name|tar
decl_stmt|;
name|tar
operator|=
operator|(
expr|struct
name|tar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
name|gnu_clear_sparse_list
argument_list|(
name|tar
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|tar
operator|->
name|acl_text
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|tar
operator|->
name|entry_pathname
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|tar
operator|->
name|entry_pathname_override
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|tar
operator|->
name|entry_linkpath
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|tar
operator|->
name|entry_uname
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|tar
operator|->
name|entry_gname
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|tar
operator|->
name|line
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|tar
operator|->
name|pax_global
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|tar
operator|->
name|pax_header
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|tar
operator|->
name|longname
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|tar
operator|->
name|longlink
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tar
operator|->
name|pax_entry
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tar
argument_list|)
expr_stmt|;
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_tar_bid
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|int
name|bid
decl_stmt|;
specifier|const
name|void
modifier|*
name|h
decl_stmt|;
specifier|const
name|struct
name|archive_entry_header_ustar
modifier|*
name|header
decl_stmt|;
name|bid
operator|=
literal|0
expr_stmt|;
comment|/* Now let's look at the actual header and see if it matches. */
name|h
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|512
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* If it's an end-of-archive mark, we can handle it. */
if|if
condition|(
operator|(
operator|*
operator|(
specifier|const
name|char
operator|*
operator|)
name|h
operator|)
operator|==
literal|0
operator|&&
name|archive_block_is_null
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|h
argument_list|)
condition|)
block|{
comment|/* 		 * Usually, I bid the number of bits verified, but 		 * in this case, 4096 seems excessive so I picked 10 as 		 * an arbitrary but reasonable-seeming value. 		 */
return|return
operator|(
literal|10
operator|)
return|;
block|}
comment|/* If it's not an end-of-archive mark, it must have a valid checksum.*/
if|if
condition|(
operator|!
name|checksum
argument_list|(
name|a
argument_list|,
name|h
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bid
operator|+=
literal|48
expr_stmt|;
comment|/* Checksum is usually 6 octal digits. */
name|header
operator|=
operator|(
specifier|const
expr|struct
name|archive_entry_header_ustar
operator|*
operator|)
name|h
expr_stmt|;
comment|/* Recognize POSIX formats. */
if|if
condition|(
operator|(
name|memcmp
argument_list|(
name|header
operator|->
name|magic
argument_list|,
literal|"ustar\0"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|memcmp
argument_list|(
name|header
operator|->
name|version
argument_list|,
literal|"00"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|bid
operator|+=
literal|56
expr_stmt|;
comment|/* Recognize GNU tar format. */
if|if
condition|(
operator|(
name|memcmp
argument_list|(
name|header
operator|->
name|magic
argument_list|,
literal|"ustar "
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|memcmp
argument_list|(
name|header
operator|->
name|version
argument_list|,
literal|" \0"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|bid
operator|+=
literal|56
expr_stmt|;
comment|/* Type flag must be null, digit or A-Z, a-z. */
if|if
condition|(
name|header
operator|->
name|typeflag
index|[
literal|0
index|]
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|header
operator|->
name|typeflag
index|[
literal|0
index|]
operator|>=
literal|'0'
operator|&&
name|header
operator|->
name|typeflag
index|[
literal|0
index|]
operator|<=
literal|'9'
operator|)
operator|&&
operator|!
operator|(
name|header
operator|->
name|typeflag
index|[
literal|0
index|]
operator|>=
literal|'A'
operator|&&
name|header
operator|->
name|typeflag
index|[
literal|0
index|]
operator|<=
literal|'Z'
operator|)
operator|&&
operator|!
operator|(
name|header
operator|->
name|typeflag
index|[
literal|0
index|]
operator|>=
literal|'a'
operator|&&
name|header
operator|->
name|typeflag
index|[
literal|0
index|]
operator|<=
literal|'z'
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|bid
operator|+=
literal|2
expr_stmt|;
comment|/* 6 bits of variation in an 8-bit field leaves 2 bits. */
comment|/* Sanity check: Look at first byte of mode field. */
switch|switch
condition|(
literal|255
operator|&
operator|(
name|unsigned
operator|)
name|header
operator|->
name|mode
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|255
case|:
comment|/* Base-256 value: No further verification possible! */
break|break;
case|case
literal|' '
case|:
comment|/* Not recommended, but not illegal, either. */
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
comment|/* Octal Value. */
comment|/* TODO: Check format of remainder of this field. */
break|break;
default|default:
comment|/* Not a valid mode; bail out here. */
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* TODO: Sanity test uid/gid/size/mtime/rdevmajor/rdevminor fields. */
return|return
operator|(
name|bid
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The function invoked by archive_read_header().  This  * just sets up a few things and then calls the internal  * tar_read_header() function below.  */
end_comment

begin_function
specifier|static
name|int
name|archive_read_format_tar_read_header
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
comment|/* 	 * When converting tar archives to cpio archives, it is 	 * essential that each distinct file have a distinct inode 	 * number.  To simplify this, we keep a static count here to 	 * assign fake dev/inode numbers to each tar entry.  Note that 	 * pax format archives may overwrite this with something more 	 * useful. 	 * 	 * Ideally, we would track every file read from the archive so 	 * that we could assign the same dev/ino pair to hardlinks, 	 * but the memory required to store a complete lookup table is 	 * probably not worthwhile just to support the relatively 	 * obscure tar->cpio conversion case. 	 */
specifier|static
name|int
name|default_inode
decl_stmt|;
specifier|static
name|int
name|default_dev
decl_stmt|;
name|struct
name|tar
modifier|*
name|tar
decl_stmt|;
name|struct
name|sparse_block
modifier|*
name|sp
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|r
decl_stmt|;
name|size_t
name|l
decl_stmt|;
comment|/* Assign default device/inode values. */
name|archive_entry_set_dev
argument_list|(
name|entry
argument_list|,
literal|1
operator|+
name|default_dev
argument_list|)
expr_stmt|;
comment|/* Don't use zero. */
name|archive_entry_set_ino
argument_list|(
name|entry
argument_list|,
operator|++
name|default_inode
argument_list|)
expr_stmt|;
comment|/* Don't use zero. */
comment|/* Limit generated st_ino number to 16 bits. */
if|if
condition|(
name|default_inode
operator|>=
literal|0xffff
condition|)
block|{
operator|++
name|default_dev
expr_stmt|;
name|default_inode
operator|=
literal|0
expr_stmt|;
block|}
name|tar
operator|=
operator|(
expr|struct
name|tar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
name|tar
operator|->
name|entry_offset
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|tar
operator|->
name|sparse_list
operator|!=
name|NULL
condition|)
block|{
name|sp
operator|=
name|tar
operator|->
name|sparse_list
expr_stmt|;
name|tar
operator|->
name|sparse_list
operator|=
name|sp
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
name|tar
operator|->
name|sparse_last
operator|=
name|NULL
expr_stmt|;
name|tar
operator|->
name|realsize
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Mark this as "unset" */
name|r
operator|=
name|tar_read_header
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|)
expr_stmt|;
comment|/* 	 * "non-sparse" files are really just sparse files with 	 * a single block. 	 */
if|if
condition|(
name|tar
operator|->
name|sparse_list
operator|==
name|NULL
condition|)
name|gnu_add_sparse_entry
argument_list|(
name|tar
argument_list|,
literal|0
argument_list|,
name|tar
operator|->
name|entry_bytes_remaining
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|ARCHIVE_OK
condition|)
block|{
comment|/* 		 * "Regular" entry with trailing '/' is really 		 * directory: This is needed for certain old tar 		 * variants and even for some broken newer ones. 		 */
name|p
operator|=
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_entry_filetype
argument_list|(
name|entry
argument_list|)
operator|==
name|AE_IFREG
operator|&&
name|p
index|[
name|l
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
name|archive_entry_set_filetype
argument_list|(
name|entry
argument_list|,
name|AE_IFDIR
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_tar_read_data
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|buff
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|,
name|off_t
modifier|*
name|offset
parameter_list|)
block|{
name|ssize_t
name|bytes_read
decl_stmt|;
name|struct
name|tar
modifier|*
name|tar
decl_stmt|;
name|struct
name|sparse_block
modifier|*
name|p
decl_stmt|;
name|tar
operator|=
operator|(
expr|struct
name|tar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|tar
operator|->
name|sparse_gnu_pending
condition|)
block|{
if|if
condition|(
name|tar
operator|->
name|sparse_gnu_major
operator|==
literal|1
operator|&&
name|tar
operator|->
name|sparse_gnu_minor
operator|==
literal|0
condition|)
block|{
name|tar
operator|->
name|sparse_gnu_pending
operator|=
literal|0
expr_stmt|;
comment|/* Read initial sparse map. */
name|bytes_read
operator|=
name|gnu_sparse_10_read
argument_list|(
name|a
argument_list|,
name|tar
argument_list|)
expr_stmt|;
name|tar
operator|->
name|entry_bytes_remaining
operator|-=
name|bytes_read
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|<
literal|0
condition|)
return|return
operator|(
name|bytes_read
operator|)
return|;
block|}
else|else
block|{
operator|*
name|size
operator|=
literal|0
expr_stmt|;
operator|*
name|offset
operator|=
literal|0
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Unrecognized GNU sparse file format"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
name|tar
operator|->
name|sparse_gnu_pending
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Remove exhausted entries from sparse list. */
while|while
condition|(
name|tar
operator|->
name|sparse_list
operator|!=
name|NULL
operator|&&
name|tar
operator|->
name|sparse_list
operator|->
name|remaining
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|tar
operator|->
name|sparse_list
expr_stmt|;
name|tar
operator|->
name|sparse_list
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
comment|/* If we're at end of file, return EOF. */
if|if
condition|(
name|tar
operator|->
name|sparse_list
operator|==
name|NULL
operator|||
name|tar
operator|->
name|entry_bytes_remaining
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|__archive_read_skip
argument_list|(
name|a
argument_list|,
name|tar
operator|->
name|entry_padding
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|tar
operator|->
name|entry_padding
operator|=
literal|0
expr_stmt|;
operator|*
name|buff
operator|=
name|NULL
expr_stmt|;
operator|*
name|size
operator|=
literal|0
expr_stmt|;
operator|*
name|offset
operator|=
name|tar
operator|->
name|realsize
expr_stmt|;
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
block|}
operator|*
name|buff
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
if|if
condition|(
operator|*
name|buff
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Truncated tar archive"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|bytes_read
operator|>
name|tar
operator|->
name|entry_bytes_remaining
condition|)
name|bytes_read
operator|=
name|tar
operator|->
name|entry_bytes_remaining
expr_stmt|;
comment|/* Don't read more than is available in the 	 * current sparse block. */
if|if
condition|(
name|tar
operator|->
name|sparse_list
operator|->
name|remaining
operator|<
name|bytes_read
condition|)
name|bytes_read
operator|=
name|tar
operator|->
name|sparse_list
operator|->
name|remaining
expr_stmt|;
operator|*
name|size
operator|=
name|bytes_read
expr_stmt|;
operator|*
name|offset
operator|=
name|tar
operator|->
name|sparse_list
operator|->
name|offset
expr_stmt|;
name|tar
operator|->
name|sparse_list
operator|->
name|remaining
operator|-=
name|bytes_read
expr_stmt|;
name|tar
operator|->
name|sparse_list
operator|->
name|offset
operator|+=
name|bytes_read
expr_stmt|;
name|tar
operator|->
name|entry_bytes_remaining
operator|-=
name|bytes_read
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|bytes_read
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_format_tar_skip
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|)
block|{
name|int64_t
name|bytes_skipped
decl_stmt|;
name|struct
name|tar
modifier|*
name|tar
decl_stmt|;
name|tar
operator|=
operator|(
expr|struct
name|tar
operator|*
operator|)
operator|(
name|a
operator|->
name|format
operator|->
name|data
operator|)
expr_stmt|;
comment|/* 	 * Compression layer skip functions are required to either skip the 	 * length requested or fail, so we can rely upon the entire entry 	 * plus padding being skipped. 	 */
name|bytes_skipped
operator|=
name|__archive_read_skip
argument_list|(
name|a
argument_list|,
name|tar
operator|->
name|entry_bytes_remaining
operator|+
name|tar
operator|->
name|entry_padding
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_skipped
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|tar
operator|->
name|entry_bytes_remaining
operator|=
literal|0
expr_stmt|;
name|tar
operator|->
name|entry_padding
operator|=
literal|0
expr_stmt|;
comment|/* Free the sparse list. */
name|gnu_clear_sparse_list
argument_list|(
name|tar
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This function recursively interprets all of the headers associated  * with a single entry.  */
end_comment

begin_function
specifier|static
name|int
name|tar_read_header
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
name|ssize_t
name|bytes
decl_stmt|;
name|int
name|err
decl_stmt|;
specifier|const
name|void
modifier|*
name|h
decl_stmt|;
specifier|const
name|struct
name|archive_entry_header_ustar
modifier|*
name|header
decl_stmt|;
comment|/* Read 512-byte header record */
name|h
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|512
argument_list|,
operator|&
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|<
literal|0
condition|)
return|return
operator|(
name|bytes
operator|)
return|;
if|if
condition|(
name|bytes
operator|<
literal|512
condition|)
block|{
comment|/* Short read or EOF. */
comment|/* Try requesting just one byte and see what happens. */
operator|(
name|void
operator|)
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
operator|&
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes
operator|==
literal|0
condition|)
block|{
comment|/* 			 * The archive ends at a 512-byte boundary but 			 * without a proper end-of-archive marker. 			 * Yes, there are tar writers that do this; 			 * hold our nose and accept it. 			 */
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
block|}
comment|/* Archive ends with a partial block; this is bad. */
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated tar archive"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
literal|512
argument_list|)
expr_stmt|;
comment|/* Check for end-of-archive mark. */
if|if
condition|(
operator|(
operator|(
operator|*
operator|(
specifier|const
name|char
operator|*
operator|)
name|h
operator|)
operator|==
literal|0
operator|)
operator|&&
name|archive_block_is_null
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|h
argument_list|)
condition|)
block|{
comment|/* Try to consume a second all-null record, as well. */
name|h
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|512
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
literal|512
argument_list|)
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|==
name|NULL
condition|)
block|{
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|=
name|ARCHIVE_FORMAT_TAR
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
literal|"tar"
expr_stmt|;
block|}
return|return
operator|(
name|ARCHIVE_EOF
operator|)
return|;
block|}
comment|/* 	 * Note: If the checksum fails and we return ARCHIVE_RETRY, 	 * then the client is likely to just retry.  This is a very 	 * crude way to search for the next valid header! 	 * 	 * TODO: Improve this by implementing a real header scan. 	 */
if|if
condition|(
operator|!
name|checksum
argument_list|(
name|a
argument_list|,
name|h
argument_list|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|EINVAL
argument_list|,
literal|"Damaged tar archive"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_RETRY
operator|)
return|;
comment|/* Retryable: Invalid header */
block|}
if|if
condition|(
operator|++
name|tar
operator|->
name|header_recursion_depth
operator|>
literal|32
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|EINVAL
argument_list|,
literal|"Too many special headers"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
comment|/* Determine the format variant. */
name|header
operator|=
operator|(
specifier|const
expr|struct
name|archive_entry_header_ustar
operator|*
operator|)
name|h
expr_stmt|;
switch|switch
condition|(
name|header
operator|->
name|typeflag
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'A'
case|:
comment|/* Solaris tar ACL */
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|=
name|ARCHIVE_FORMAT_TAR_PAX_INTERCHANGE
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
literal|"Solaris tar"
expr_stmt|;
name|err
operator|=
name|header_Solaris_ACL
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|,
name|h
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/* POSIX-standard 'g' header. */
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|=
name|ARCHIVE_FORMAT_TAR_PAX_INTERCHANGE
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
literal|"POSIX pax interchange format"
expr_stmt|;
name|err
operator|=
name|header_pax_global
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|,
name|h
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
comment|/* Long link name (GNU tar, others) */
name|err
operator|=
name|header_longlink
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|,
name|h
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
comment|/* Long filename (GNU tar, others) */
name|err
operator|=
name|header_longname
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|,
name|h
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
comment|/* GNU volume header */
name|err
operator|=
name|header_volume
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|,
name|h
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
comment|/* Used by SUN tar; same as 'x'. */
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|=
name|ARCHIVE_FORMAT_TAR_PAX_INTERCHANGE
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
literal|"POSIX pax interchange format (Sun variant)"
expr_stmt|;
name|err
operator|=
name|header_pax_extensions
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|,
name|h
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* POSIX-standard 'x' header. */
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|=
name|ARCHIVE_FORMAT_TAR_PAX_INTERCHANGE
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
literal|"POSIX pax interchange format"
expr_stmt|;
name|err
operator|=
name|header_pax_extensions
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|,
name|h
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|memcmp
argument_list|(
name|header
operator|->
name|magic
argument_list|,
literal|"ustar  \0"
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|=
name|ARCHIVE_FORMAT_TAR_GNUTAR
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
literal|"GNU tar format"
expr_stmt|;
name|err
operator|=
name|header_gnutar
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|header
operator|->
name|magic
argument_list|,
literal|"ustar"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|!=
name|ARCHIVE_FORMAT_TAR_PAX_INTERCHANGE
condition|)
block|{
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|=
name|ARCHIVE_FORMAT_TAR_USTAR
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
literal|"POSIX ustar format"
expr_stmt|;
block|}
name|err
operator|=
name|header_ustar
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|=
name|ARCHIVE_FORMAT_TAR
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
literal|"tar (non-POSIX)"
expr_stmt|;
name|err
operator|=
name|header_old_tar
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|,
name|h
argument_list|)
expr_stmt|;
block|}
block|}
operator|--
name|tar
operator|->
name|header_recursion_depth
expr_stmt|;
comment|/* We return warnings or success as-is.  Anything else is fatal. */
if|if
condition|(
name|err
operator|==
name|ARCHIVE_WARN
operator|||
name|err
operator|==
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|err
operator|==
name|ARCHIVE_EOF
condition|)
comment|/* EOF when recursively reading a header is bad. */
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|EINVAL
argument_list|,
literal|"Damaged tar archive"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return true if block checksum is correct.  */
end_comment

begin_function
specifier|static
name|int
name|checksum
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|h
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|bytes
decl_stmt|;
specifier|const
name|struct
name|archive_entry_header_ustar
modifier|*
name|header
decl_stmt|;
name|int
name|check
decl_stmt|,
name|i
decl_stmt|,
name|sum
decl_stmt|;
operator|(
name|void
operator|)
name|a
expr_stmt|;
comment|/* UNUSED */
name|bytes
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|h
expr_stmt|;
name|header
operator|=
operator|(
specifier|const
expr|struct
name|archive_entry_header_ustar
operator|*
operator|)
name|h
expr_stmt|;
comment|/* 	 * Test the checksum.  Note that POSIX specifies _unsigned_ 	 * bytes for this calculation. 	 */
name|sum
operator|=
name|tar_atol
argument_list|(
name|header
operator|->
name|checksum
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|checksum
argument_list|)
argument_list|)
expr_stmt|;
name|check
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|148
condition|;
name|i
operator|++
control|)
name|check
operator|+=
operator|(
name|unsigned
name|char
operator|)
name|bytes
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
literal|156
condition|;
name|i
operator|++
control|)
name|check
operator|+=
literal|32
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
literal|512
condition|;
name|i
operator|++
control|)
name|check
operator|+=
operator|(
name|unsigned
name|char
operator|)
name|bytes
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sum
operator|==
name|check
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * Repeat test with _signed_ bytes, just in case this archive 	 * was created by an old BSD, Solaris, or HP-UX tar with a 	 * broken checksum calculation. 	 */
name|check
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|148
condition|;
name|i
operator|++
control|)
name|check
operator|+=
operator|(
name|signed
name|char
operator|)
name|bytes
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
literal|156
condition|;
name|i
operator|++
control|)
name|check
operator|+=
literal|32
expr_stmt|;
for|for
control|(
init|;
name|i
operator|<
literal|512
condition|;
name|i
operator|++
control|)
name|check
operator|+=
operator|(
name|signed
name|char
operator|)
name|bytes
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|sum
operator|==
name|check
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return true if this block contains only nulls.  */
end_comment

begin_function
specifier|static
name|int
name|archive_block_is_null
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|512
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|*
name|p
operator|++
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Interpret 'A' Solaris ACL header  */
end_comment

begin_function
specifier|static
name|int
name|header_Solaris_ACL
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
specifier|const
name|void
modifier|*
name|h
parameter_list|)
block|{
specifier|const
name|struct
name|archive_entry_header_ustar
modifier|*
name|header
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int64_t
name|type
decl_stmt|;
name|char
modifier|*
name|acl
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|wchar_t
modifier|*
name|wp
decl_stmt|;
comment|/* 	 * read_body_to_string adds a NUL terminator, but we need a little 	 * more to make sure that we don't overrun acl_text later. 	 */
name|header
operator|=
operator|(
specifier|const
expr|struct
name|archive_entry_header_ustar
operator|*
operator|)
name|h
expr_stmt|;
name|size
operator|=
name|tar_atol
argument_list|(
name|header
operator|->
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|read_body_to_string
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
operator|&
operator|(
name|tar
operator|->
name|acl_text
operator|)
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Recursively read next header */
name|err
operator|=
name|tar_read_header
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|!=
name|ARCHIVE_OK
operator|)
operator|&&
operator|(
name|err
operator|!=
name|ARCHIVE_WARN
operator|)
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* TODO: Examine the first characters to see if this 	 * is an AIX ACL descriptor.  We'll likely never support 	 * them, but it would be polite to recognize and warn when 	 * we do see them. */
comment|/* Leading octal number indicates ACL type and number of entries. */
name|p
operator|=
name|acl
operator|=
name|tar
operator|->
name|acl_text
operator|.
name|s
expr_stmt|;
name|type
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
name|p
operator|<
name|acl
operator|+
name|size
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|<
literal|'0'
operator|||
operator|*
name|p
operator|>
literal|'7'
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Malformed Solaris ACL attribute (invalid digit)"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
name|type
operator|<<=
literal|3
expr_stmt|;
name|type
operator|+=
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|type
operator|>
literal|077777777
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Malformed Solaris ACL attribute (count too large)"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
name|p
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
operator|(
name|int
operator|)
name|type
operator|&
operator|~
literal|0777777
condition|)
block|{
case|case
literal|01000000
case|:
comment|/* POSIX.1e ACL */
break|break;
case|case
literal|03000000
case|:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Solaris NFSv4 ACLs not supported"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
default|default:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Malformed Solaris ACL attribute (unsupported type %o)"
argument_list|,
operator|(
name|int
operator|)
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|acl
operator|+
name|size
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Malformed Solaris ACL attribute (body overflow)"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
comment|/* ACL text is null-terminated; find the end. */
name|size
operator|-=
operator|(
name|p
operator|-
name|acl
operator|)
expr_stmt|;
name|acl
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
operator|&&
name|p
operator|<
name|acl
operator|+
name|size
condition|)
name|p
operator|++
expr_stmt|;
name|wp
operator|=
name|utf8_decode
argument_list|(
name|tar
argument_list|,
name|acl
argument_list|,
name|p
operator|-
name|acl
argument_list|)
expr_stmt|;
name|err
operator|=
name|__archive_entry_acl_parse_w
argument_list|(
name|entry
argument_list|,
name|wp
argument_list|,
name|ARCHIVE_ENTRY_ACL_TYPE_ACCESS
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|ARCHIVE_OK
condition|)
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Malformed Solaris ACL attribute (unparsable)"
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Interpret 'K' long linkname header.  */
end_comment

begin_function
specifier|static
name|int
name|header_longlink
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
specifier|const
name|void
modifier|*
name|h
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
name|read_body_to_string
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
operator|&
operator|(
name|tar
operator|->
name|longlink
operator|)
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|tar_read_header
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|!=
name|ARCHIVE_OK
operator|)
operator|&&
operator|(
name|err
operator|!=
name|ARCHIVE_WARN
operator|)
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Set symlink if symlink already set, else hardlink. */
name|archive_entry_copy_link
argument_list|(
name|entry
argument_list|,
name|tar
operator|->
name|longlink
operator|.
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Interpret 'L' long filename header.  */
end_comment

begin_function
specifier|static
name|int
name|header_longname
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
specifier|const
name|void
modifier|*
name|h
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
name|read_body_to_string
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
operator|&
operator|(
name|tar
operator|->
name|longname
operator|)
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Read and parse "real" header, then override name. */
name|err
operator|=
name|tar_read_header
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|!=
name|ARCHIVE_OK
operator|)
operator|&&
operator|(
name|err
operator|!=
name|ARCHIVE_WARN
operator|)
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|archive_entry_copy_pathname
argument_list|(
name|entry
argument_list|,
name|tar
operator|->
name|longname
operator|.
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Interpret 'V' GNU tar volume header.  */
end_comment

begin_function
specifier|static
name|int
name|header_volume
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
specifier|const
name|void
modifier|*
name|h
parameter_list|)
block|{
operator|(
name|void
operator|)
name|h
expr_stmt|;
comment|/* Just skip this and read the next header. */
return|return
operator|(
name|tar_read_header
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read body of an archive entry into an archive_string object.  */
end_comment

begin_function
specifier|static
name|int
name|read_body_to_string
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|void
modifier|*
name|h
parameter_list|)
block|{
name|off_t
name|size
decl_stmt|,
name|padded_size
decl_stmt|;
specifier|const
name|struct
name|archive_entry_header_ustar
modifier|*
name|header
decl_stmt|;
specifier|const
name|void
modifier|*
name|src
decl_stmt|;
operator|(
name|void
operator|)
name|tar
expr_stmt|;
comment|/* UNUSED */
name|header
operator|=
operator|(
specifier|const
expr|struct
name|archive_entry_header_ustar
operator|*
operator|)
name|h
expr_stmt|;
name|size
operator|=
name|tar_atol
argument_list|(
name|header
operator|->
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|size
operator|>
literal|1048576
operator|)
operator|||
operator|(
name|size
operator|<
literal|0
operator|)
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|EINVAL
argument_list|,
literal|"Special header too large"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Fail if we can't make our buffer big enough. */
if|if
condition|(
name|archive_string_ensure
argument_list|(
name|as
argument_list|,
name|size
operator|+
literal|1
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"No memory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Read the body into the string. */
name|padded_size
operator|=
operator|(
name|size
operator|+
literal|511
operator|)
operator|&
operator|~
literal|511
expr_stmt|;
name|src
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
name|padded_size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|memcpy
argument_list|(
name|as
operator|->
name|s
argument_list|,
name|src
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|padded_size
argument_list|)
expr_stmt|;
name|as
operator|->
name|s
index|[
name|size
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse out common header elements.  *  * This would be the same as header_old_tar, except that the  * filename is handled slightly differently for old and POSIX  * entries  (POSIX entries support a 'prefix').  This factoring  * allows header_old_tar and header_ustar  * to handle filenames differently, while still putting most of the  * common parsing into one place.  */
end_comment

begin_function
specifier|static
name|int
name|header_common
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
specifier|const
name|void
modifier|*
name|h
parameter_list|)
block|{
specifier|const
name|struct
name|archive_entry_header_ustar
modifier|*
name|header
decl_stmt|;
name|char
name|tartype
decl_stmt|;
operator|(
name|void
operator|)
name|a
expr_stmt|;
comment|/* UNUSED */
name|header
operator|=
operator|(
specifier|const
expr|struct
name|archive_entry_header_ustar
operator|*
operator|)
name|h
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|linkname
index|[
literal|0
index|]
condition|)
name|archive_strncpy
argument_list|(
operator|&
operator|(
name|tar
operator|->
name|entry_linkpath
operator|)
argument_list|,
name|header
operator|->
name|linkname
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|linkname
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|tar
operator|->
name|entry_linkpath
operator|)
argument_list|)
expr_stmt|;
comment|/* Parse out the numeric fields (all are octal) */
name|archive_entry_set_mode
argument_list|(
name|entry
argument_list|,
name|tar_atol
argument_list|(
name|header
operator|->
name|mode
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|mode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_set_uid
argument_list|(
name|entry
argument_list|,
name|tar_atol
argument_list|(
name|header
operator|->
name|uid
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|uid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_set_gid
argument_list|(
name|entry
argument_list|,
name|tar_atol
argument_list|(
name|header
operator|->
name|gid
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|gid
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|tar
operator|->
name|entry_bytes_remaining
operator|=
name|tar_atol
argument_list|(
name|header
operator|->
name|size
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|tar
operator|->
name|realsize
operator|=
name|tar
operator|->
name|entry_bytes_remaining
expr_stmt|;
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
name|tar
operator|->
name|entry_bytes_remaining
argument_list|)
expr_stmt|;
name|archive_entry_set_mtime
argument_list|(
name|entry
argument_list|,
name|tar_atol
argument_list|(
name|header
operator|->
name|mtime
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|mtime
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Handle the tar type flag appropriately. */
name|tartype
operator|=
name|header
operator|->
name|typeflag
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
name|tartype
condition|)
block|{
case|case
literal|'1'
case|:
comment|/* Hard link */
name|archive_entry_copy_hardlink
argument_list|(
name|entry
argument_list|,
name|tar
operator|->
name|entry_linkpath
operator|.
name|s
argument_list|)
expr_stmt|;
comment|/* 		 * The following may seem odd, but: Technically, tar 		 * does not store the file type for a "hard link" 		 * entry, only the fact that it is a hard link.  So, I 		 * leave the type zero normally.  But, pax interchange 		 * format allows hard links to have data, which 		 * implies that the underlying entry is a regular 		 * file. 		 */
if|if
condition|(
name|archive_entry_size
argument_list|(
name|entry
argument_list|)
operator|>
literal|0
condition|)
name|archive_entry_set_filetype
argument_list|(
name|entry
argument_list|,
name|AE_IFREG
argument_list|)
expr_stmt|;
comment|/* 		 * A tricky point: Traditionally, tar readers have 		 * ignored the size field when reading hardlink 		 * entries, and some writers put non-zero sizes even 		 * though the body is empty.  POSIX blessed this 		 * convention in the 1988 standard, but broke with 		 * this tradition in 2001 by permitting hardlink 		 * entries to store valid bodies in pax interchange 		 * format, but not in ustar format.  Since there is no 		 * hard and fast way to distinguish pax interchange 		 * from earlier archives (the 'x' and 'g' entries are 		 * optional, after all), we need a heuristic. 		 */
if|if
condition|(
name|archive_entry_size
argument_list|(
name|entry
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* If the size is already zero, we're done. */
block|}
elseif|else
if|if
condition|(
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|==
name|ARCHIVE_FORMAT_TAR_PAX_INTERCHANGE
condition|)
block|{
comment|/* Definitely pax extended; must obey hardlink size. */
block|}
elseif|else
if|if
condition|(
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|==
name|ARCHIVE_FORMAT_TAR
operator|||
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|==
name|ARCHIVE_FORMAT_TAR_GNUTAR
condition|)
block|{
comment|/* Old-style or GNU tar: we must ignore the size. */
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tar
operator|->
name|entry_bytes_remaining
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|archive_read_format_tar_bid
argument_list|(
name|a
argument_list|)
operator|>
literal|50
condition|)
block|{
comment|/* 			 * We don't know if it's pax: If the bid 			 * function sees a valid ustar header 			 * immediately following, then let's ignore 			 * the hardlink size. 			 */
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tar
operator|->
name|entry_bytes_remaining
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * TODO: There are still two cases I'd like to handle: 		 *   = a ustar non-pax archive with a hardlink entry at 		 *     end-of-archive.  (Look for block of nulls following?) 		 *   = a pax archive that has not seen any pax headers 		 *     and has an entry which is a hardlink entry storing 		 *     a body containing an uncompressed tar archive. 		 * The first is worth addressing; I don't see any reliable 		 * way to deal with the second possibility. 		 */
break|break;
case|case
literal|'2'
case|:
comment|/* Symlink */
name|archive_entry_set_filetype
argument_list|(
name|entry
argument_list|,
name|AE_IFLNK
argument_list|)
expr_stmt|;
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tar
operator|->
name|entry_bytes_remaining
operator|=
literal|0
expr_stmt|;
name|archive_entry_copy_symlink
argument_list|(
name|entry
argument_list|,
name|tar
operator|->
name|entry_linkpath
operator|.
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'3'
case|:
comment|/* Character device */
name|archive_entry_set_filetype
argument_list|(
name|entry
argument_list|,
name|AE_IFCHR
argument_list|)
expr_stmt|;
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tar
operator|->
name|entry_bytes_remaining
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'4'
case|:
comment|/* Block device */
name|archive_entry_set_filetype
argument_list|(
name|entry
argument_list|,
name|AE_IFBLK
argument_list|)
expr_stmt|;
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tar
operator|->
name|entry_bytes_remaining
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'5'
case|:
comment|/* Dir */
name|archive_entry_set_filetype
argument_list|(
name|entry
argument_list|,
name|AE_IFDIR
argument_list|)
expr_stmt|;
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tar
operator|->
name|entry_bytes_remaining
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'6'
case|:
comment|/* FIFO device */
name|archive_entry_set_filetype
argument_list|(
name|entry
argument_list|,
name|AE_IFIFO
argument_list|)
expr_stmt|;
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tar
operator|->
name|entry_bytes_remaining
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* GNU incremental directory type */
comment|/* 		 * No special handling is actually required here. 		 * It might be nice someday to preprocess the file list and 		 * provide it to the client, though. 		 */
name|archive_entry_set_filetype
argument_list|(
name|entry
argument_list|,
name|AE_IFDIR
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* GNU "Multi-volume" (remainder of file from last archive)*/
comment|/* 		 * As far as I can tell, this is just like a regular file 		 * entry, except that the contents should be _appended_ to 		 * the indicated file at the indicated offset.  This may 		 * require some API work to fully support. 		 */
break|break;
case|case
literal|'N'
case|:
comment|/* Old GNU "long filename" entry. */
comment|/* The body of this entry is a script for renaming 		 * previously-extracted entries.  Ugh.  It will never 		 * be supported by libarchive. */
name|archive_entry_set_filetype
argument_list|(
name|entry
argument_list|,
name|AE_IFREG
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* GNU sparse files */
comment|/* 		 * Sparse files are really just regular files with 		 * sparse information in the extended area. 		 */
comment|/* FALLTHROUGH */
default|default:
comment|/* Regular file  and non-standard types */
comment|/* 		 * Per POSIX: non-recognized types should always be 		 * treated as regular files. 		 */
name|archive_entry_set_filetype
argument_list|(
name|entry
argument_list|,
name|AE_IFREG
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse out header elements for "old-style" tar archives.  */
end_comment

begin_function
specifier|static
name|int
name|header_old_tar
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
specifier|const
name|void
modifier|*
name|h
parameter_list|)
block|{
specifier|const
name|struct
name|archive_entry_header_ustar
modifier|*
name|header
decl_stmt|;
comment|/* Copy filename over (to ensure null termination). */
name|header
operator|=
operator|(
specifier|const
expr|struct
name|archive_entry_header_ustar
operator|*
operator|)
name|h
expr_stmt|;
name|archive_strncpy
argument_list|(
operator|&
operator|(
name|tar
operator|->
name|entry_pathname
operator|)
argument_list|,
name|header
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_copy_pathname
argument_list|(
name|entry
argument_list|,
name|tar
operator|->
name|entry_pathname
operator|.
name|s
argument_list|)
expr_stmt|;
comment|/* Grab rest of common fields */
name|header_common
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|,
name|h
argument_list|)
expr_stmt|;
name|tar
operator|->
name|entry_padding
operator|=
literal|0x1ff
operator|&
operator|(
operator|-
name|tar
operator|->
name|entry_bytes_remaining
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse a file header for a pax extended archive entry.  */
end_comment

begin_function
specifier|static
name|int
name|header_pax_global
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
specifier|const
name|void
modifier|*
name|h
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
name|read_body_to_string
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
operator|&
operator|(
name|tar
operator|->
name|pax_global
operator|)
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|tar_read_header
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|header_pax_extensions
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
specifier|const
name|void
modifier|*
name|h
parameter_list|)
block|{
name|int
name|err
decl_stmt|,
name|err2
decl_stmt|;
name|err
operator|=
name|read_body_to_string
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
operator|&
operator|(
name|tar
operator|->
name|pax_header
operator|)
argument_list|,
name|h
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Parse the next header. */
name|err
operator|=
name|tar_read_header
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|!=
name|ARCHIVE_OK
operator|)
operator|&&
operator|(
name|err
operator|!=
name|ARCHIVE_WARN
operator|)
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* 	 * TODO: Parse global/default options into 'entry' struct here 	 * before handling file-specific options. 	 * 	 * This design (parse standard header, then overwrite with pax 	 * extended attribute data) usually works well, but isn't ideal; 	 * it would be better to parse the pax extended attributes first 	 * and then skip any fields in the standard header that were 	 * defined in the pax header. 	 */
name|err2
operator|=
name|pax_header
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|,
name|tar
operator|->
name|pax_header
operator|.
name|s
argument_list|)
expr_stmt|;
name|err
operator|=
name|err_combine
argument_list|(
name|err
argument_list|,
name|err2
argument_list|)
expr_stmt|;
name|tar
operator|->
name|entry_padding
operator|=
literal|0x1ff
operator|&
operator|(
operator|-
name|tar
operator|->
name|entry_bytes_remaining
operator|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse a file header for a Posix "ustar" archive entry.  This also  * handles "pax" or "extended ustar" entries.  */
end_comment

begin_function
specifier|static
name|int
name|header_ustar
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
specifier|const
name|void
modifier|*
name|h
parameter_list|)
block|{
specifier|const
name|struct
name|archive_entry_header_ustar
modifier|*
name|header
decl_stmt|;
name|struct
name|archive_string
modifier|*
name|as
decl_stmt|;
name|header
operator|=
operator|(
specifier|const
expr|struct
name|archive_entry_header_ustar
operator|*
operator|)
name|h
expr_stmt|;
comment|/* Copy name into an internal buffer to ensure null-termination. */
name|as
operator|=
operator|&
operator|(
name|tar
operator|->
name|entry_pathname
operator|)
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|prefix
index|[
literal|0
index|]
condition|)
block|{
name|archive_strncpy
argument_list|(
name|as
argument_list|,
name|header
operator|->
name|prefix
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|prefix
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|as
operator|->
name|s
index|[
name|archive_strlen
argument_list|(
name|as
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|archive_strappend_char
argument_list|(
name|as
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|archive_strncat
argument_list|(
name|as
argument_list|,
name|header
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|archive_strncpy
argument_list|(
name|as
argument_list|,
name|header
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_copy_pathname
argument_list|(
name|entry
argument_list|,
name|as
operator|->
name|s
argument_list|)
expr_stmt|;
comment|/* Handle rest of common fields. */
name|header_common
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|,
name|h
argument_list|)
expr_stmt|;
comment|/* Handle POSIX ustar fields. */
name|archive_strncpy
argument_list|(
operator|&
operator|(
name|tar
operator|->
name|entry_uname
operator|)
argument_list|,
name|header
operator|->
name|uname
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|uname
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_copy_uname
argument_list|(
name|entry
argument_list|,
name|tar
operator|->
name|entry_uname
operator|.
name|s
argument_list|)
expr_stmt|;
name|archive_strncpy
argument_list|(
operator|&
operator|(
name|tar
operator|->
name|entry_gname
operator|)
argument_list|,
name|header
operator|->
name|gname
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|gname
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_copy_gname
argument_list|(
name|entry
argument_list|,
name|tar
operator|->
name|entry_gname
operator|.
name|s
argument_list|)
expr_stmt|;
comment|/* Parse out device numbers only for char and block specials. */
if|if
condition|(
name|header
operator|->
name|typeflag
index|[
literal|0
index|]
operator|==
literal|'3'
operator|||
name|header
operator|->
name|typeflag
index|[
literal|0
index|]
operator|==
literal|'4'
condition|)
block|{
name|archive_entry_set_rdevmajor
argument_list|(
name|entry
argument_list|,
name|tar_atol
argument_list|(
name|header
operator|->
name|rdevmajor
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|rdevmajor
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_set_rdevminor
argument_list|(
name|entry
argument_list|,
name|tar_atol
argument_list|(
name|header
operator|->
name|rdevminor
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|rdevminor
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|tar
operator|->
name|entry_padding
operator|=
literal|0x1ff
operator|&
operator|(
operator|-
name|tar
operator|->
name|entry_bytes_remaining
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse the pax extended attributes record.  *  * Returns non-zero if there's an error in the data.  */
end_comment

begin_function
specifier|static
name|int
name|pax_header
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|char
modifier|*
name|attr
parameter_list|)
block|{
name|size_t
name|attr_length
decl_stmt|,
name|l
decl_stmt|,
name|line_length
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|key
decl_stmt|,
modifier|*
name|value
decl_stmt|;
name|int
name|err
decl_stmt|,
name|err2
decl_stmt|;
name|attr_length
operator|=
name|strlen
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|tar
operator|->
name|pax_hdrcharset_binary
operator|=
literal|0
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|tar
operator|->
name|entry_gname
operator|)
argument_list|)
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|tar
operator|->
name|entry_linkpath
operator|)
argument_list|)
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|tar
operator|->
name|entry_pathname
operator|)
argument_list|)
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|tar
operator|->
name|entry_pathname_override
operator|)
argument_list|)
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|tar
operator|->
name|entry_uname
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|ARCHIVE_OK
expr_stmt|;
while|while
condition|(
name|attr_length
operator|>
literal|0
condition|)
block|{
comment|/* Parse decimal length field at start of line. */
name|line_length
operator|=
literal|0
expr_stmt|;
name|l
operator|=
name|attr_length
expr_stmt|;
name|p
operator|=
name|attr
expr_stmt|;
comment|/* Record start of line. */
while|while
condition|(
name|l
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
block|{
name|p
operator|++
expr_stmt|;
name|l
operator|--
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|p
operator|<
literal|'0'
operator|||
operator|*
name|p
operator|>
literal|'9'
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Ignoring malformed pax extended attributes"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
name|line_length
operator|*=
literal|10
expr_stmt|;
name|line_length
operator|+=
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|line_length
operator|>
literal|999999
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Rejecting pax extended attribute> 1MB"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
name|p
operator|++
expr_stmt|;
name|l
operator|--
expr_stmt|;
block|}
comment|/* 		 * Parsed length must be no bigger than available data, 		 * at least 1, and the last character of the line must 		 * be '\n'. 		 */
if|if
condition|(
name|line_length
operator|>
name|attr_length
operator|||
name|line_length
operator|<
literal|1
operator|||
name|attr
index|[
name|line_length
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Ignoring malformed pax extended attribute"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
comment|/* Null-terminate the line. */
name|attr
index|[
name|line_length
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Find end of key and null terminate it. */
name|key
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|key
index|[
literal|0
index|]
operator|==
literal|'='
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'='
condition|)
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Invalid pax extended attributes"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
comment|/* Identify null-terminated 'value' portion. */
name|value
operator|=
name|p
operator|+
literal|1
expr_stmt|;
comment|/* Identify this attribute and set it in the entry. */
name|err2
operator|=
name|pax_attribute
argument_list|(
name|tar
argument_list|,
name|entry
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|err
operator|=
name|err_combine
argument_list|(
name|err
argument_list|,
name|err2
argument_list|)
expr_stmt|;
comment|/* Skip to next line */
name|attr
operator|+=
name|line_length
expr_stmt|;
name|attr_length
operator|-=
name|line_length
expr_stmt|;
block|}
if|if
condition|(
name|archive_strlen
argument_list|(
operator|&
operator|(
name|tar
operator|->
name|entry_gname
operator|)
argument_list|)
operator|>
literal|0
condition|)
block|{
name|value
operator|=
name|tar
operator|->
name|entry_gname
operator|.
name|s
expr_stmt|;
if|if
condition|(
name|tar
operator|->
name|pax_hdrcharset_binary
condition|)
name|archive_entry_copy_gname
argument_list|(
name|entry
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|archive_entry_update_gname_utf8
argument_list|(
name|entry
argument_list|,
name|value
argument_list|)
condition|)
block|{
name|err
operator|=
name|ARCHIVE_WARN
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Gname in pax header can't "
literal|"be converted to current locale."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|archive_strlen
argument_list|(
operator|&
operator|(
name|tar
operator|->
name|entry_linkpath
operator|)
argument_list|)
operator|>
literal|0
condition|)
block|{
name|value
operator|=
name|tar
operator|->
name|entry_linkpath
operator|.
name|s
expr_stmt|;
if|if
condition|(
name|tar
operator|->
name|pax_hdrcharset_binary
condition|)
name|archive_entry_copy_link
argument_list|(
name|entry
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|archive_entry_update_link_utf8
argument_list|(
name|entry
argument_list|,
name|value
argument_list|)
condition|)
block|{
name|err
operator|=
name|ARCHIVE_WARN
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Linkname in pax header can't "
literal|"be converted to current locale."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Some extensions (such as the GNU sparse file extensions) 	 * deliberately store a synthetic name under the regular 'path' 	 * attribute and the real file name under a different attribute. 	 * Since we're supposed to not care about the order, we 	 * have no choice but to store all of the various filenames 	 * we find and figure it all out afterwards.  This is the 	 * figuring out part. 	 */
name|value
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|archive_strlen
argument_list|(
operator|&
operator|(
name|tar
operator|->
name|entry_pathname_override
operator|)
argument_list|)
operator|>
literal|0
condition|)
name|value
operator|=
name|tar
operator|->
name|entry_pathname_override
operator|.
name|s
expr_stmt|;
elseif|else
if|if
condition|(
name|archive_strlen
argument_list|(
operator|&
operator|(
name|tar
operator|->
name|entry_pathname
operator|)
argument_list|)
operator|>
literal|0
condition|)
name|value
operator|=
name|tar
operator|->
name|entry_pathname
operator|.
name|s
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|tar
operator|->
name|pax_hdrcharset_binary
condition|)
name|archive_entry_copy_pathname
argument_list|(
name|entry
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|archive_entry_update_pathname_utf8
argument_list|(
name|entry
argument_list|,
name|value
argument_list|)
condition|)
block|{
name|err
operator|=
name|ARCHIVE_WARN
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Pathname in pax header can't be "
literal|"converted to current locale."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|archive_strlen
argument_list|(
operator|&
operator|(
name|tar
operator|->
name|entry_uname
operator|)
argument_list|)
operator|>
literal|0
condition|)
block|{
name|value
operator|=
name|tar
operator|->
name|entry_uname
operator|.
name|s
expr_stmt|;
if|if
condition|(
name|tar
operator|->
name|pax_hdrcharset_binary
condition|)
name|archive_entry_copy_uname
argument_list|(
name|entry
argument_list|,
name|value
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|!
name|archive_entry_update_uname_utf8
argument_list|(
name|entry
argument_list|,
name|value
argument_list|)
condition|)
block|{
name|err
operator|=
name|ARCHIVE_WARN
expr_stmt|;
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Uname in pax header can't "
literal|"be converted to current locale."
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|pax_attribute_xattr
parameter_list|(
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|value
parameter_list|)
block|{
name|char
modifier|*
name|name_decoded
decl_stmt|;
name|void
modifier|*
name|value_decoded
decl_stmt|;
name|size_t
name|value_len
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|<
literal|18
operator|||
operator|(
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"LIBARCHIVE.xattr."
argument_list|,
literal|17
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
literal|3
return|;
name|name
operator|+=
literal|17
expr_stmt|;
comment|/* URL-decode name */
name|name_decoded
operator|=
name|url_decode
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name_decoded
operator|==
name|NULL
condition|)
return|return
literal|2
return|;
comment|/* Base-64 decode value */
name|value_decoded
operator|=
name|base64_decode
argument_list|(
name|value
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|,
operator|&
name|value_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|value_decoded
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|name_decoded
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
name|archive_entry_xattr_add_entry
argument_list|(
name|entry
argument_list|,
name|name_decoded
argument_list|,
name|value_decoded
argument_list|,
name|value_len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name_decoded
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|value_decoded
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * Parse a single key=value attribute.  key/value pointers are  * assumed to point into reasonably long-lived storage.  *  * Note that POSIX reserves all-lowercase keywords.  Vendor-specific  * extensions should always have keywords of the form "VENDOR.attribute"  * In particular, it's quite feasible to support many different  * vendor extensions here.  I'm using "LIBARCHIVE" for extensions  * unique to this library.  *  * Investigate other vendor-specific extensions and see if  * any of them look useful.  */
end_comment

begin_function
specifier|static
name|int
name|pax_attribute
parameter_list|(
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|char
modifier|*
name|key
parameter_list|,
name|char
modifier|*
name|value
parameter_list|)
block|{
name|int64_t
name|s
decl_stmt|;
name|long
name|n
decl_stmt|;
name|wchar_t
modifier|*
name|wp
decl_stmt|;
switch|switch
condition|(
name|key
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'G'
case|:
comment|/* GNU "0.0" sparse pax format. */
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"GNU.sparse.numblocks"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tar
operator|->
name|sparse_offset
operator|=
operator|-
literal|1
expr_stmt|;
name|tar
operator|->
name|sparse_numbytes
operator|=
operator|-
literal|1
expr_stmt|;
name|tar
operator|->
name|sparse_gnu_major
operator|=
literal|0
expr_stmt|;
name|tar
operator|->
name|sparse_gnu_minor
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"GNU.sparse.offset"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tar
operator|->
name|sparse_offset
operator|=
name|tar_atol10
argument_list|(
name|value
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tar
operator|->
name|sparse_numbytes
operator|!=
operator|-
literal|1
condition|)
block|{
name|gnu_add_sparse_entry
argument_list|(
name|tar
argument_list|,
name|tar
operator|->
name|sparse_offset
argument_list|,
name|tar
operator|->
name|sparse_numbytes
argument_list|)
expr_stmt|;
name|tar
operator|->
name|sparse_offset
operator|=
operator|-
literal|1
expr_stmt|;
name|tar
operator|->
name|sparse_numbytes
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"GNU.sparse.numbytes"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tar
operator|->
name|sparse_numbytes
operator|=
name|tar_atol10
argument_list|(
name|value
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tar
operator|->
name|sparse_numbytes
operator|!=
operator|-
literal|1
condition|)
block|{
name|gnu_add_sparse_entry
argument_list|(
name|tar
argument_list|,
name|tar
operator|->
name|sparse_offset
argument_list|,
name|tar
operator|->
name|sparse_numbytes
argument_list|)
expr_stmt|;
name|tar
operator|->
name|sparse_offset
operator|=
operator|-
literal|1
expr_stmt|;
name|tar
operator|->
name|sparse_numbytes
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"GNU.sparse.size"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tar
operator|->
name|realsize
operator|=
name|tar_atol10
argument_list|(
name|value
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
name|tar
operator|->
name|realsize
argument_list|)
expr_stmt|;
block|}
comment|/* GNU "0.1" sparse pax format. */
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"GNU.sparse.map"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tar
operator|->
name|sparse_gnu_major
operator|=
literal|0
expr_stmt|;
name|tar
operator|->
name|sparse_gnu_minor
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|gnu_sparse_01_parse
argument_list|(
name|tar
argument_list|,
name|value
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
comment|/* GNU "1.0" sparse pax format */
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"GNU.sparse.major"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tar
operator|->
name|sparse_gnu_major
operator|=
name|tar_atol10
argument_list|(
name|value
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|tar
operator|->
name|sparse_gnu_pending
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"GNU.sparse.minor"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tar
operator|->
name|sparse_gnu_minor
operator|=
name|tar_atol10
argument_list|(
name|value
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|tar
operator|->
name|sparse_gnu_pending
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"GNU.sparse.name"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * The real filename; when storing sparse 			 * files, GNU tar puts a synthesized name into 			 * the regular 'path' attribute in an attempt 			 * to limit confusion. ;-) 			 */
name|archive_strcpy
argument_list|(
operator|&
operator|(
name|tar
operator|->
name|entry_pathname_override
operator|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"GNU.sparse.realsize"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tar
operator|->
name|realsize
operator|=
name|tar_atol10
argument_list|(
name|value
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
name|tar
operator|->
name|realsize
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'L'
case|:
comment|/* Our extensions */
comment|/* TODO: Handle arbitrary extended attributes... */
comment|/* 		if (strcmp(key, "LIBARCHIVE.xxxxxxx")==0) 			archive_entry_set_xxxxxx(entry, value); */
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"LIBARCHIVE.creationtime"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pax_time
argument_list|(
name|value
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|archive_entry_set_birthtime
argument_list|(
name|entry
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|key
argument_list|,
literal|"LIBARCHIVE.xattr."
argument_list|,
literal|17
argument_list|)
operator|==
literal|0
condition|)
name|pax_attribute_xattr
argument_list|(
name|entry
argument_list|,
name|key
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* We support some keys used by the "star" archiver */
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"SCHILY.acl.access"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|wp
operator|=
name|utf8_decode
argument_list|(
name|tar
argument_list|,
name|value
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* TODO: if (wp == NULL) */
name|__archive_entry_acl_parse_w
argument_list|(
name|entry
argument_list|,
name|wp
argument_list|,
name|ARCHIVE_ENTRY_ACL_TYPE_ACCESS
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"SCHILY.acl.default"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|wp
operator|=
name|utf8_decode
argument_list|(
name|tar
argument_list|,
name|value
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* TODO: if (wp == NULL) */
name|__archive_entry_acl_parse_w
argument_list|(
name|entry
argument_list|,
name|wp
argument_list|,
name|ARCHIVE_ENTRY_ACL_TYPE_DEFAULT
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"SCHILY.devmajor"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|archive_entry_set_rdevmajor
argument_list|(
name|entry
argument_list|,
name|tar_atol10
argument_list|(
name|value
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"SCHILY.devminor"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|archive_entry_set_rdevminor
argument_list|(
name|entry
argument_list|,
name|tar_atol10
argument_list|(
name|value
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"SCHILY.fflags"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|archive_entry_copy_fflags_text
argument_list|(
name|entry
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"SCHILY.dev"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|archive_entry_set_dev
argument_list|(
name|entry
argument_list|,
name|tar_atol10
argument_list|(
name|value
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"SCHILY.ino"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|archive_entry_set_ino
argument_list|(
name|entry
argument_list|,
name|tar_atol10
argument_list|(
name|value
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"SCHILY.nlink"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|archive_entry_set_nlink
argument_list|(
name|entry
argument_list|,
name|tar_atol10
argument_list|(
name|value
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"SCHILY.realsize"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tar
operator|->
name|realsize
operator|=
name|tar_atol10
argument_list|(
name|value
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
name|tar
operator|->
name|realsize
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'a'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"atime"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pax_time
argument_list|(
name|value
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|archive_entry_set_atime
argument_list|(
name|entry
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"ctime"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pax_time
argument_list|(
name|value
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|archive_entry_set_ctime
argument_list|(
name|entry
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"charset"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* TODO: Publish charset information in entry. */
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"comment"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* TODO: Publish comment in entry. */
block|}
break|break;
case|case
literal|'g'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"gid"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|archive_entry_set_gid
argument_list|(
name|entry
argument_list|,
name|tar_atol10
argument_list|(
name|value
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"gname"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|archive_strcpy
argument_list|(
operator|&
operator|(
name|tar
operator|->
name|entry_gname
operator|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'h'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"hdrcharset"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"BINARY"
argument_list|)
operator|==
literal|0
condition|)
name|tar
operator|->
name|pax_hdrcharset_binary
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"ISO-IR 10646 2000 UTF-8"
argument_list|)
operator|==
literal|0
condition|)
name|tar
operator|->
name|pax_hdrcharset_binary
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* TODO: Warn about unsupported hdrcharset */
block|}
block|}
break|break;
case|case
literal|'l'
case|:
comment|/* pax interchange doesn't distinguish hardlink vs. symlink. */
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"linkpath"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|archive_strcpy
argument_list|(
operator|&
operator|(
name|tar
operator|->
name|entry_linkpath
operator|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"mtime"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pax_time
argument_list|(
name|value
argument_list|,
operator|&
name|s
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|archive_entry_set_mtime
argument_list|(
name|entry
argument_list|,
name|s
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"path"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|archive_strcpy
argument_list|(
operator|&
operator|(
name|tar
operator|->
name|entry_pathname
operator|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'r'
case|:
comment|/* POSIX has reserved 'realtime.*' */
break|break;
case|case
literal|'s'
case|:
comment|/* POSIX has reserved 'security.*' */
comment|/* Someday: if (strcmp(key, "security.acl")==0) { ... } */
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"size"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* "size" is the size of the data in the entry. */
name|tar
operator|->
name|entry_bytes_remaining
operator|=
name|tar_atol10
argument_list|(
name|value
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * But, "size" is not necessarily the size of 			 * the file on disk; if this is a sparse file, 			 * the disk size may have already been set from 			 * GNU.sparse.realsize or GNU.sparse.size or 			 * an old GNU header field or SCHILY.realsize 			 * or .... 			 */
if|if
condition|(
name|tar
operator|->
name|realsize
operator|<
literal|0
condition|)
block|{
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
name|tar
operator|->
name|entry_bytes_remaining
argument_list|)
expr_stmt|;
name|tar
operator|->
name|realsize
operator|=
name|tar
operator|->
name|entry_bytes_remaining
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'u'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"uid"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|archive_entry_set_uid
argument_list|(
name|entry
argument_list|,
name|tar_atol10
argument_list|(
name|value
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"uname"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|archive_strcpy
argument_list|(
operator|&
operator|(
name|tar
operator|->
name|entry_uname
operator|)
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * parse a decimal time value, which may include a fractional portion  */
end_comment

begin_function
specifier|static
name|void
name|pax_time
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|int64_t
modifier|*
name|ps
parameter_list|,
name|long
modifier|*
name|pn
parameter_list|)
block|{
name|char
name|digit
decl_stmt|;
name|int64_t
name|s
decl_stmt|;
name|unsigned
name|long
name|l
decl_stmt|;
name|int
name|sign
decl_stmt|;
name|int64_t
name|limit
decl_stmt|,
name|last_digit_limit
decl_stmt|;
name|limit
operator|=
name|INT64_MAX
operator|/
literal|10
expr_stmt|;
name|last_digit_limit
operator|=
name|INT64_MAX
operator|%
literal|10
expr_stmt|;
name|s
operator|=
literal|0
expr_stmt|;
name|sign
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
block|{
name|digit
operator|=
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|s
operator|>
name|limit
operator|||
operator|(
name|s
operator|==
name|limit
operator|&&
name|digit
operator|>
name|last_digit_limit
operator|)
condition|)
block|{
name|s
operator|=
name|INT64_MAX
expr_stmt|;
break|break;
block|}
name|s
operator|=
operator|(
name|s
operator|*
literal|10
operator|)
operator|+
name|digit
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
operator|*
name|ps
operator|=
name|s
operator|*
name|sign
expr_stmt|;
comment|/* Calculate nanoseconds. */
operator|*
name|pn
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|'.'
condition|)
return|return;
name|l
operator|=
literal|100000000UL
expr_stmt|;
do|do
block|{
operator|++
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|>=
literal|'0'
operator|&&
operator|*
name|p
operator|<=
literal|'9'
condition|)
operator|*
name|pn
operator|+=
operator|(
operator|*
name|p
operator|-
literal|'0'
operator|)
operator|*
name|l
expr_stmt|;
else|else
break|break;
block|}
do|while
condition|(
name|l
operator|/=
literal|10
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Parse GNU tar header  */
end_comment

begin_function
specifier|static
name|int
name|header_gnutar
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
specifier|const
name|void
modifier|*
name|h
parameter_list|)
block|{
specifier|const
name|struct
name|archive_entry_header_gnutar
modifier|*
name|header
decl_stmt|;
operator|(
name|void
operator|)
name|a
expr_stmt|;
comment|/* 	 * GNU header is like POSIX ustar, except 'prefix' is 	 * replaced with some other fields. This also means the 	 * filename is stored as in old-style archives. 	 */
comment|/* Grab fields common to all tar variants. */
name|header_common
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|entry
argument_list|,
name|h
argument_list|)
expr_stmt|;
comment|/* Copy filename over (to ensure null termination). */
name|header
operator|=
operator|(
specifier|const
expr|struct
name|archive_entry_header_gnutar
operator|*
operator|)
name|h
expr_stmt|;
name|archive_strncpy
argument_list|(
operator|&
operator|(
name|tar
operator|->
name|entry_pathname
operator|)
argument_list|,
name|header
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_copy_pathname
argument_list|(
name|entry
argument_list|,
name|tar
operator|->
name|entry_pathname
operator|.
name|s
argument_list|)
expr_stmt|;
comment|/* Fields common to ustar and GNU */
comment|/* XXX Can the following be factored out since it's common 	 * to ustar and gnu tar?  Is it okay to move it down into 	 * header_common, perhaps?  */
name|archive_strncpy
argument_list|(
operator|&
operator|(
name|tar
operator|->
name|entry_uname
operator|)
argument_list|,
name|header
operator|->
name|uname
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|uname
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_copy_uname
argument_list|(
name|entry
argument_list|,
name|tar
operator|->
name|entry_uname
operator|.
name|s
argument_list|)
expr_stmt|;
name|archive_strncpy
argument_list|(
operator|&
operator|(
name|tar
operator|->
name|entry_gname
operator|)
argument_list|,
name|header
operator|->
name|gname
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|gname
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_copy_gname
argument_list|(
name|entry
argument_list|,
name|tar
operator|->
name|entry_gname
operator|.
name|s
argument_list|)
expr_stmt|;
comment|/* Parse out device numbers only for char and block specials */
if|if
condition|(
name|header
operator|->
name|typeflag
index|[
literal|0
index|]
operator|==
literal|'3'
operator|||
name|header
operator|->
name|typeflag
index|[
literal|0
index|]
operator|==
literal|'4'
condition|)
block|{
name|archive_entry_set_rdevmajor
argument_list|(
name|entry
argument_list|,
name|tar_atol
argument_list|(
name|header
operator|->
name|rdevmajor
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|rdevmajor
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_set_rdevminor
argument_list|(
name|entry
argument_list|,
name|tar_atol
argument_list|(
name|header
operator|->
name|rdevminor
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|rdevminor
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|archive_entry_set_rdev
argument_list|(
name|entry
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tar
operator|->
name|entry_padding
operator|=
literal|0x1ff
operator|&
operator|(
operator|-
name|tar
operator|->
name|entry_bytes_remaining
operator|)
expr_stmt|;
comment|/* Grab GNU-specific fields. */
name|archive_entry_set_atime
argument_list|(
name|entry
argument_list|,
name|tar_atol
argument_list|(
name|header
operator|->
name|atime
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|atime
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|archive_entry_set_ctime
argument_list|(
name|entry
argument_list|,
name|tar_atol
argument_list|(
name|header
operator|->
name|ctime
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|ctime
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|realsize
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|tar
operator|->
name|realsize
operator|=
name|tar_atol
argument_list|(
name|header
operator|->
name|realsize
argument_list|,
sizeof|sizeof
argument_list|(
name|header
operator|->
name|realsize
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_set_size
argument_list|(
name|entry
argument_list|,
name|tar
operator|->
name|realsize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|header
operator|->
name|sparse
index|[
literal|0
index|]
operator|.
name|offset
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|gnu_sparse_old_read
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
name|header
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|header
operator|->
name|isextended
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* XXX WTF? XXX */
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gnu_add_sparse_entry
parameter_list|(
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
name|off_t
name|offset
parameter_list|,
name|off_t
name|remaining
parameter_list|)
block|{
name|struct
name|sparse_block
modifier|*
name|p
decl_stmt|;
name|p
operator|=
operator|(
expr|struct
name|sparse_block
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|__archive_errx
argument_list|(
literal|1
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tar
operator|->
name|sparse_last
operator|!=
name|NULL
condition|)
name|tar
operator|->
name|sparse_last
operator|->
name|next
operator|=
name|p
expr_stmt|;
else|else
name|tar
operator|->
name|sparse_list
operator|=
name|p
expr_stmt|;
name|tar
operator|->
name|sparse_last
operator|=
name|p
expr_stmt|;
name|p
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|p
operator|->
name|remaining
operator|=
name|remaining
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|gnu_clear_sparse_list
parameter_list|(
name|struct
name|tar
modifier|*
name|tar
parameter_list|)
block|{
name|struct
name|sparse_block
modifier|*
name|p
decl_stmt|;
while|while
condition|(
name|tar
operator|->
name|sparse_list
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
name|tar
operator|->
name|sparse_list
expr_stmt|;
name|tar
operator|->
name|sparse_list
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|tar
operator|->
name|sparse_last
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * GNU tar old-format sparse data.  *  * GNU old-format sparse data is stored in a fixed-field  * format.  Offset/size values are 11-byte octal fields (same  * format as 'size' field in ustart header).  These are  * stored in the header, allocating subsequent header blocks  * as needed.  Extending the header in this way is a pretty  * severe POSIX violation; this design has earned GNU tar a  * lot of criticism.  */
end_comment

begin_function
specifier|static
name|int
name|gnu_sparse_old_read
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
specifier|const
name|struct
name|archive_entry_header_gnutar
modifier|*
name|header
parameter_list|)
block|{
name|ssize_t
name|bytes_read
decl_stmt|;
specifier|const
name|void
modifier|*
name|data
decl_stmt|;
struct|struct
name|extended
block|{
name|struct
name|gnu_sparse
name|sparse
index|[
literal|21
index|]
decl_stmt|;
name|char
name|isextended
index|[
literal|1
index|]
decl_stmt|;
name|char
name|padding
index|[
literal|7
index|]
decl_stmt|;
block|}
struct|;
specifier|const
name|struct
name|extended
modifier|*
name|ext
decl_stmt|;
name|gnu_sparse_old_parse
argument_list|(
name|tar
argument_list|,
name|header
operator|->
name|sparse
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|isextended
index|[
literal|0
index|]
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
do|do
block|{
name|data
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|512
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
if|if
condition|(
name|bytes_read
operator|<
literal|512
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Truncated tar archive "
literal|"detected while reading sparse file data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
literal|512
argument_list|)
expr_stmt|;
name|ext
operator|=
operator|(
specifier|const
expr|struct
name|extended
operator|*
operator|)
name|data
expr_stmt|;
name|gnu_sparse_old_parse
argument_list|(
name|tar
argument_list|,
name|ext
operator|->
name|sparse
argument_list|,
literal|21
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|ext
operator|->
name|isextended
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
do|;
if|if
condition|(
name|tar
operator|->
name|sparse_list
operator|!=
name|NULL
condition|)
name|tar
operator|->
name|entry_offset
operator|=
name|tar
operator|->
name|sparse_list
operator|->
name|offset
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|gnu_sparse_old_parse
parameter_list|(
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
specifier|const
name|struct
name|gnu_sparse
modifier|*
name|sparse
parameter_list|,
name|int
name|length
parameter_list|)
block|{
while|while
condition|(
name|length
operator|>
literal|0
operator|&&
name|sparse
operator|->
name|offset
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
name|gnu_add_sparse_entry
argument_list|(
name|tar
argument_list|,
name|tar_atol
argument_list|(
name|sparse
operator|->
name|offset
argument_list|,
sizeof|sizeof
argument_list|(
name|sparse
operator|->
name|offset
argument_list|)
argument_list|)
argument_list|,
name|tar_atol
argument_list|(
name|sparse
operator|->
name|numbytes
argument_list|,
sizeof|sizeof
argument_list|(
name|sparse
operator|->
name|numbytes
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|sparse
operator|++
expr_stmt|;
name|length
operator|--
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * GNU tar sparse format 0.0  *  * Beginning with GNU tar 1.15, sparse files are stored using  * information in the pax extended header.  The GNU tar maintainers  * have gone through a number of variations in the process of working  * out this scheme; furtunately, they're all numbered.  *  * Sparse format 0.0 uses attribute GNU.sparse.numblocks to store the  * number of blocks, and GNU.sparse.offset/GNU.sparse.numbytes to  * store offset/size for each block.  The repeated instances of these  * latter fields violate the pax specification (which frowns on  * duplicate keys), so this format was quickly replaced.  */
end_comment

begin_comment
comment|/*  * GNU tar sparse format 0.1  *  * This version replaced the offset/numbytes attributes with  * a single "map" attribute that stored a list of integers.  This  * format had two problems: First, the "map" attribute could be very  * long, which caused problems for some implementations.  More  * importantly, the sparse data was lost when extracted by archivers  * that didn't recognize this extension.  */
end_comment

begin_function
specifier|static
name|int
name|gnu_sparse_01_parse
parameter_list|(
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|e
decl_stmt|;
name|off_t
name|offset
init|=
operator|-
literal|1
decl_stmt|,
name|size
init|=
operator|-
literal|1
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|e
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|e
operator|!=
literal|'\0'
operator|&&
operator|*
name|e
operator|!=
literal|','
condition|)
block|{
if|if
condition|(
operator|*
name|e
operator|<
literal|'0'
operator|||
operator|*
name|e
operator|>
literal|'9'
condition|)
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
name|e
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
block|{
name|offset
operator|=
name|tar_atol10
argument_list|(
name|p
argument_list|,
name|e
operator|-
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
else|else
block|{
name|size
operator|=
name|tar_atol10
argument_list|(
name|p
argument_list|,
name|e
operator|-
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
name|gnu_add_sparse_entry
argument_list|(
name|tar
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|offset
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|e
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
name|p
operator|=
name|e
operator|+
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * GNU tar sparse format 1.0  *  * The idea: The offset/size data is stored as a series of base-10  * ASCII numbers prepended to the file data, so that dearchivers that  * don't support this format will extract the block map along with the  * data and a separate post-process can restore the sparseness.  *  * Unfortunately, GNU tar 1.16 had a bug that added unnecessary  * padding to the body of the file when using this format.  GNU tar  * 1.17 corrected this bug without bumping the version number, so  * it's not possible to support both variants.  This code supports  * the later variant at the expense of not supporting the former.  *  * This variant also replaced GNU.sparse.size with GNU.sparse.realsize  * and introduced the GNU.sparse.major/GNU.sparse.minor attributes.  */
end_comment

begin_comment
comment|/*  * Read the next line from the input, and parse it as a decimal  * integer followed by '\n'.  Returns positive integer value or  * negative on error.  */
end_comment

begin_function
specifier|static
name|int64_t
name|gnu_sparse_10_atol
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
name|ssize_t
modifier|*
name|remaining
parameter_list|)
block|{
name|int64_t
name|l
decl_stmt|,
name|limit
decl_stmt|,
name|last_digit_limit
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|ssize_t
name|bytes_read
decl_stmt|;
name|int
name|base
decl_stmt|,
name|digit
decl_stmt|;
name|base
operator|=
literal|10
expr_stmt|;
name|limit
operator|=
name|INT64_MAX
operator|/
name|base
expr_stmt|;
name|last_digit_limit
operator|=
name|INT64_MAX
operator|%
name|base
expr_stmt|;
comment|/* 	 * Skip any lines starting with '#'; GNU tar specs 	 * don't require this, but they should. 	 */
do|do
block|{
name|bytes_read
operator|=
name|readline
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
operator|&
name|p
argument_list|,
name|tar_min
argument_list|(
operator|*
name|remaining
argument_list|,
literal|100
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|<=
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
operator|*
name|remaining
operator|-=
name|bytes_read
expr_stmt|;
block|}
do|while
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
do|;
name|l
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|bytes_read
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
return|return
operator|(
name|l
operator|)
return|;
if|if
condition|(
operator|*
name|p
operator|<
literal|'0'
operator|||
operator|*
name|p
operator|>=
literal|'0'
operator|+
name|base
condition|)
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
name|digit
operator|=
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
if|if
condition|(
name|l
operator|>
name|limit
operator|||
operator|(
name|l
operator|==
name|limit
operator|&&
name|digit
operator|>
name|last_digit_limit
operator|)
condition|)
name|l
operator|=
name|INT64_MAX
expr_stmt|;
comment|/* Truncate on overflow. */
else|else
name|l
operator|=
operator|(
name|l
operator|*
name|base
operator|)
operator|+
name|digit
expr_stmt|;
name|p
operator|++
expr_stmt|;
name|bytes_read
operator|--
expr_stmt|;
block|}
comment|/* TODO: Error message. */
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns length (in bytes) of the sparse data description  * that was read.  */
end_comment

begin_function
specifier|static
name|ssize_t
name|gnu_sparse_10_read
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|tar
modifier|*
name|tar
parameter_list|)
block|{
name|ssize_t
name|remaining
decl_stmt|,
name|bytes_read
decl_stmt|;
name|int
name|entries
decl_stmt|;
name|off_t
name|offset
decl_stmt|,
name|size
decl_stmt|,
name|to_skip
decl_stmt|;
comment|/* Clear out the existing sparse list. */
name|gnu_clear_sparse_list
argument_list|(
name|tar
argument_list|)
expr_stmt|;
name|remaining
operator|=
name|tar
operator|->
name|entry_bytes_remaining
expr_stmt|;
comment|/* Parse entries. */
name|entries
operator|=
name|gnu_sparse_10_atol
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
operator|&
name|remaining
argument_list|)
expr_stmt|;
if|if
condition|(
name|entries
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
comment|/* Parse the individual entries. */
while|while
condition|(
name|entries
operator|--
operator|>
literal|0
condition|)
block|{
comment|/* Parse offset/size */
name|offset
operator|=
name|gnu_sparse_10_atol
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
operator|&
name|remaining
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|size
operator|=
name|gnu_sparse_10_atol
argument_list|(
name|a
argument_list|,
name|tar
argument_list|,
operator|&
name|remaining
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
comment|/* Add a new sparse entry. */
name|gnu_add_sparse_entry
argument_list|(
name|tar
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
comment|/* Skip rest of block... */
name|bytes_read
operator|=
name|tar
operator|->
name|entry_bytes_remaining
operator|-
name|remaining
expr_stmt|;
name|to_skip
operator|=
literal|0x1ff
operator|&
operator|-
name|bytes_read
expr_stmt|;
if|if
condition|(
name|to_skip
operator|!=
name|__archive_read_skip
argument_list|(
name|a
argument_list|,
name|to_skip
argument_list|)
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
return|return
operator|(
name|bytes_read
operator|+
name|to_skip
operator|)
return|;
block|}
end_function

begin_comment
comment|/*-  * Convert text->integer.  *  * Traditional tar formats (including POSIX) specify base-8 for  * all of the standard numeric fields.  This is a significant limitation  * in practice:  *   = file size is limited to 8GB  *   = rdevmajor and rdevminor are limited to 21 bits  *   = uid/gid are limited to 21 bits  *  * There are two workarounds for this:  *   = pax extended headers, which use variable-length string fields  *   = GNU tar and STAR both allow either base-8 or base-256 in  *      most fields.  The high bit is set to indicate base-256.  *  * On read, this implementation supports both extensions.  */
end_comment

begin_function
specifier|static
name|int64_t
name|tar_atol
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|unsigned
name|char_cnt
parameter_list|)
block|{
comment|/* 	 * Technically, GNU tar considers a field to be in base-256 	 * only if the first byte is 0xff or 0x80. 	 */
if|if
condition|(
operator|*
name|p
operator|&
literal|0x80
condition|)
return|return
operator|(
name|tar_atol256
argument_list|(
name|p
argument_list|,
name|char_cnt
argument_list|)
operator|)
return|;
return|return
operator|(
name|tar_atol8
argument_list|(
name|p
argument_list|,
name|char_cnt
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Note that this implementation does not (and should not!) obey  * locale settings; you cannot simply substitute strtol here, since  * it does obey locale.  */
end_comment

begin_function
specifier|static
name|int64_t
name|tar_atol8
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|unsigned
name|char_cnt
parameter_list|)
block|{
name|int64_t
name|l
decl_stmt|,
name|limit
decl_stmt|,
name|last_digit_limit
decl_stmt|;
name|int
name|digit
decl_stmt|,
name|sign
decl_stmt|,
name|base
decl_stmt|;
name|base
operator|=
literal|8
expr_stmt|;
name|limit
operator|=
name|INT64_MAX
operator|/
name|base
expr_stmt|;
name|last_digit_limit
operator|=
name|INT64_MAX
operator|%
name|base
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
else|else
name|sign
operator|=
literal|1
expr_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
name|digit
operator|=
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
while|while
condition|(
name|digit
operator|>=
literal|0
operator|&&
name|digit
operator|<
name|base
operator|&&
name|char_cnt
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|l
operator|>
name|limit
operator|||
operator|(
name|l
operator|==
name|limit
operator|&&
name|digit
operator|>
name|last_digit_limit
operator|)
condition|)
block|{
name|l
operator|=
name|INT64_MAX
expr_stmt|;
comment|/* Truncate on overflow. */
break|break;
block|}
name|l
operator|=
operator|(
name|l
operator|*
name|base
operator|)
operator|+
name|digit
expr_stmt|;
name|digit
operator|=
operator|*
operator|++
name|p
operator|-
literal|'0'
expr_stmt|;
block|}
return|return
operator|(
name|sign
operator|<
literal|0
operator|)
condition|?
operator|-
name|l
else|:
name|l
return|;
block|}
end_function

begin_comment
comment|/*  * Note that this implementation does not (and should not!) obey  * locale settings; you cannot simply substitute strtol here, since  * it does obey locale.  */
end_comment

begin_function
specifier|static
name|int64_t
name|tar_atol10
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|,
name|unsigned
name|char_cnt
parameter_list|)
block|{
name|int64_t
name|l
decl_stmt|,
name|limit
decl_stmt|,
name|last_digit_limit
decl_stmt|;
name|int
name|base
decl_stmt|,
name|digit
decl_stmt|,
name|sign
decl_stmt|;
name|base
operator|=
literal|10
expr_stmt|;
name|limit
operator|=
name|INT64_MAX
operator|/
name|base
expr_stmt|;
name|last_digit_limit
operator|=
name|INT64_MAX
operator|%
name|base
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
else|else
name|sign
operator|=
literal|1
expr_stmt|;
name|l
operator|=
literal|0
expr_stmt|;
name|digit
operator|=
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
while|while
condition|(
name|digit
operator|>=
literal|0
operator|&&
name|digit
operator|<
name|base
operator|&&
name|char_cnt
operator|--
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|l
operator|>
name|limit
operator|||
operator|(
name|l
operator|==
name|limit
operator|&&
name|digit
operator|>
name|last_digit_limit
operator|)
condition|)
block|{
name|l
operator|=
name|INT64_MAX
expr_stmt|;
comment|/* Truncate on overflow. */
break|break;
block|}
name|l
operator|=
operator|(
name|l
operator|*
name|base
operator|)
operator|+
name|digit
expr_stmt|;
name|digit
operator|=
operator|*
operator|++
name|p
operator|-
literal|'0'
expr_stmt|;
block|}
return|return
operator|(
name|sign
operator|<
literal|0
operator|)
condition|?
operator|-
name|l
else|:
name|l
return|;
block|}
end_function

begin_comment
comment|/*  * Parse a base-256 integer.  This is just a straight signed binary  * value in big-endian order, except that the high-order bit is  * ignored.  */
end_comment

begin_function
specifier|static
name|int64_t
name|tar_atol256
parameter_list|(
specifier|const
name|char
modifier|*
name|_p
parameter_list|,
name|unsigned
name|char_cnt
parameter_list|)
block|{
name|int64_t
name|l
decl_stmt|,
name|upper_limit
decl_stmt|,
name|lower_limit
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|_p
decl_stmt|;
name|upper_limit
operator|=
name|INT64_MAX
operator|/
literal|256
expr_stmt|;
name|lower_limit
operator|=
name|INT64_MIN
operator|/
literal|256
expr_stmt|;
comment|/* Pad with 1 or 0 bits, depending on sign. */
if|if
condition|(
operator|(
literal|0x40
operator|&
operator|*
name|p
operator|)
operator|==
literal|0x40
condition|)
name|l
operator|=
operator|(
name|int64_t
operator|)
operator|-
literal|1
expr_stmt|;
else|else
name|l
operator|=
literal|0
expr_stmt|;
name|l
operator|=
operator|(
name|l
operator|<<
literal|6
operator|)
operator||
operator|(
literal|0x3f
operator|&
operator|*
name|p
operator|++
operator|)
expr_stmt|;
while|while
condition|(
operator|--
name|char_cnt
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|l
operator|>
name|upper_limit
condition|)
block|{
name|l
operator|=
name|INT64_MAX
expr_stmt|;
comment|/* Truncate on overflow */
break|break;
block|}
elseif|else
if|if
condition|(
name|l
operator|<
name|lower_limit
condition|)
block|{
name|l
operator|=
name|INT64_MIN
expr_stmt|;
break|break;
block|}
name|l
operator|=
operator|(
name|l
operator|<<
literal|8
operator|)
operator||
operator|(
literal|0xff
operator|&
operator|(
name|int64_t
operator|)
operator|*
name|p
operator|++
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|l
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns length of line (including trailing newline)  * or negative on error.  'start' argument is updated to  * point to first character of line.  This avoids copying  * when possible.  */
end_comment

begin_function
specifier|static
name|ssize_t
name|readline
parameter_list|(
name|struct
name|archive_read
modifier|*
name|a
parameter_list|,
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|start
parameter_list|,
name|ssize_t
name|limit
parameter_list|)
block|{
name|ssize_t
name|bytes_read
decl_stmt|;
name|ssize_t
name|total_size
init|=
literal|0
decl_stmt|;
specifier|const
name|void
modifier|*
name|t
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
name|t
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|<=
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|s
operator|=
name|t
expr_stmt|;
comment|/* Start of line? */
name|p
operator|=
name|memchr
argument_list|(
name|t
argument_list|,
literal|'\n'
argument_list|,
name|bytes_read
argument_list|)
expr_stmt|;
comment|/* If we found '\n' in the read buffer, return pointer to that. */
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|bytes_read
operator|=
literal|1
operator|+
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
operator|)
operator|-
name|s
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|>
name|limit
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Line too long"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|bytes_read
argument_list|)
expr_stmt|;
operator|*
name|start
operator|=
name|s
expr_stmt|;
return|return
operator|(
name|bytes_read
operator|)
return|;
block|}
comment|/* Otherwise, we need to accumulate in a line buffer. */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|total_size
operator|+
name|bytes_read
operator|>
name|limit
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Line too long"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
if|if
condition|(
name|archive_string_ensure
argument_list|(
operator|&
name|tar
operator|->
name|line
argument_list|,
name|total_size
operator|+
name|bytes_read
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate working buffer"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|memcpy
argument_list|(
name|tar
operator|->
name|line
operator|.
name|s
operator|+
name|total_size
argument_list|,
name|t
argument_list|,
name|bytes_read
argument_list|)
expr_stmt|;
name|__archive_read_consume
argument_list|(
name|a
argument_list|,
name|bytes_read
argument_list|)
expr_stmt|;
name|total_size
operator|+=
name|bytes_read
expr_stmt|;
comment|/* If we found '\n', clean up and return. */
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
operator|*
name|start
operator|=
name|tar
operator|->
name|line
operator|.
name|s
expr_stmt|;
return|return
operator|(
name|total_size
operator|)
return|;
block|}
comment|/* Read some more. */
name|t
operator|=
name|__archive_read_ahead
argument_list|(
name|a
argument_list|,
literal|1
argument_list|,
operator|&
name|bytes_read
argument_list|)
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|<=
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|s
operator|=
name|t
expr_stmt|;
comment|/* Start of line? */
name|p
operator|=
name|memchr
argument_list|(
name|t
argument_list|,
literal|'\n'
argument_list|,
name|bytes_read
argument_list|)
expr_stmt|;
comment|/* If we found '\n', trim the read. */
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|bytes_read
operator|=
literal|1
operator|+
operator|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
operator|)
operator|-
name|s
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|wchar_t
modifier|*
name|utf8_decode
parameter_list|(
name|struct
name|tar
modifier|*
name|tar
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
name|wchar_t
modifier|*
name|dest
decl_stmt|;
name|ssize_t
name|n
decl_stmt|;
comment|/* Ensure pax_entry buffer is big enough. */
if|if
condition|(
name|tar
operator|->
name|pax_entry_length
operator|<=
name|length
condition|)
block|{
name|wchar_t
modifier|*
name|old_entry
decl_stmt|;
if|if
condition|(
name|tar
operator|->
name|pax_entry_length
operator|<=
literal|0
condition|)
name|tar
operator|->
name|pax_entry_length
operator|=
literal|1024
expr_stmt|;
while|while
condition|(
name|tar
operator|->
name|pax_entry_length
operator|<=
name|length
operator|+
literal|1
condition|)
name|tar
operator|->
name|pax_entry_length
operator|*=
literal|2
expr_stmt|;
name|old_entry
operator|=
name|tar
operator|->
name|pax_entry
expr_stmt|;
name|tar
operator|->
name|pax_entry
operator|=
operator|(
name|wchar_t
operator|*
operator|)
name|realloc
argument_list|(
name|tar
operator|->
name|pax_entry
argument_list|,
name|tar
operator|->
name|pax_entry_length
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tar
operator|->
name|pax_entry
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|old_entry
argument_list|)
expr_stmt|;
comment|/* TODO: Handle this error. */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|dest
operator|=
name|tar
operator|->
name|pax_entry
expr_stmt|;
while|while
condition|(
name|length
operator|>
literal|0
condition|)
block|{
name|n
operator|=
name|UTF8_mbrtowc
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
break|break;
name|dest
operator|++
expr_stmt|;
name|src
operator|+=
name|n
expr_stmt|;
name|length
operator|-=
name|n
expr_stmt|;
block|}
operator|*
name|dest
operator|=
literal|L'
expr|\0'
expr_stmt|;
return|return
operator|(
name|tar
operator|->
name|pax_entry
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copied and simplified from FreeBSD libc/locale.  */
end_comment

begin_function
specifier|static
name|ssize_t
name|UTF8_mbrtowc
parameter_list|(
name|wchar_t
modifier|*
name|pwc
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|int
name|ch
decl_stmt|,
name|i
decl_stmt|,
name|len
decl_stmt|,
name|mask
decl_stmt|;
name|unsigned
name|long
name|wch
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
operator|||
name|n
operator|==
literal|0
operator|||
name|pwc
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*          * Determine the number of octets that make up this character from          * the first octet, and a mask that extracts the interesting bits of          * the first octet.          */
name|ch
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
expr_stmt|;
if|if
condition|(
operator|(
name|ch
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
name|mask
operator|=
literal|0x7f
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ch
operator|&
literal|0xe0
operator|)
operator|==
literal|0xc0
condition|)
block|{
name|mask
operator|=
literal|0x1f
expr_stmt|;
name|len
operator|=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ch
operator|&
literal|0xf0
operator|)
operator|==
literal|0xe0
condition|)
block|{
name|mask
operator|=
literal|0x0f
expr_stmt|;
name|len
operator|=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ch
operator|&
literal|0xf8
operator|)
operator|==
literal|0xf0
condition|)
block|{
name|mask
operator|=
literal|0x07
expr_stmt|;
name|len
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
comment|/* Invalid first byte. */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|<
operator|(
name|size_t
operator|)
name|len
condition|)
block|{
comment|/* Valid first byte but truncated. */
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
comment|/*          * Decode the octet sequence representing the character in chunks          * of 6 bits, most significant first.          */
name|wch
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
operator|++
operator|&
name|mask
expr_stmt|;
name|i
operator|=
name|len
expr_stmt|;
while|while
condition|(
operator|--
name|i
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|s
operator|&
literal|0xc0
operator|)
operator|!=
literal|0x80
condition|)
block|{
comment|/* Invalid intermediate byte; consume one byte and 			 * emit '?' */
operator|*
name|pwc
operator|=
literal|'?'
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|wch
operator|<<=
literal|6
expr_stmt|;
name|wch
operator||=
operator|*
name|s
operator|++
operator|&
literal|0x3f
expr_stmt|;
block|}
comment|/* Assign the value to the output; out-of-range values 	 * just get truncated. */
operator|*
name|pwc
operator|=
operator|(
name|wchar_t
operator|)
name|wch
expr_stmt|;
ifdef|#
directive|ifdef
name|WCHAR_MAX
comment|/* 	 * If platform has WCHAR_MAX, we can do something 	 * more sensible with out-of-range values. 	 */
if|if
condition|(
name|wch
operator|>=
name|WCHAR_MAX
condition|)
operator|*
name|pwc
operator|=
literal|'?'
expr_stmt|;
endif|#
directive|endif
comment|/* Return number of bytes input consumed: 0 for end-of-string. */
return|return
operator|(
name|wch
operator|==
literal|L'
expr|\0'
condition|?
literal|0
else|:
name|len
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * base64_decode - Base64 decode  *  * This accepts most variations of base-64 encoding, including:  *    * with or without line breaks  *    * with or without the final group padded with '=' or '_' characters  * (The most economical Base-64 variant does not pad the last group and  * omits line breaks; RFC1341 used for MIME requires both.)  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|base64_decode
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|len
parameter_list|,
name|size_t
modifier|*
name|out_len
parameter_list|)
block|{
specifier|static
specifier|const
name|unsigned
name|char
name|digits
index|[
literal|64
index|]
init|=
block|{
literal|'A'
block|,
literal|'B'
block|,
literal|'C'
block|,
literal|'D'
block|,
literal|'E'
block|,
literal|'F'
block|,
literal|'G'
block|,
literal|'H'
block|,
literal|'I'
block|,
literal|'J'
block|,
literal|'K'
block|,
literal|'L'
block|,
literal|'M'
block|,
literal|'N'
block|,
literal|'O'
block|,
literal|'P'
block|,
literal|'Q'
block|,
literal|'R'
block|,
literal|'S'
block|,
literal|'T'
block|,
literal|'U'
block|,
literal|'V'
block|,
literal|'W'
block|,
literal|'X'
block|,
literal|'Y'
block|,
literal|'Z'
block|,
literal|'a'
block|,
literal|'b'
block|,
literal|'c'
block|,
literal|'d'
block|,
literal|'e'
block|,
literal|'f'
block|,
literal|'g'
block|,
literal|'h'
block|,
literal|'i'
block|,
literal|'j'
block|,
literal|'k'
block|,
literal|'l'
block|,
literal|'m'
block|,
literal|'n'
block|,
literal|'o'
block|,
literal|'p'
block|,
literal|'q'
block|,
literal|'r'
block|,
literal|'s'
block|,
literal|'t'
block|,
literal|'u'
block|,
literal|'v'
block|,
literal|'w'
block|,
literal|'x'
block|,
literal|'y'
block|,
literal|'z'
block|,
literal|'0'
block|,
literal|'1'
block|,
literal|'2'
block|,
literal|'3'
block|,
literal|'4'
block|,
literal|'5'
block|,
literal|'6'
block|,
literal|'7'
block|,
literal|'8'
block|,
literal|'9'
block|,
literal|'+'
block|,
literal|'/'
block|}
decl_stmt|;
specifier|static
name|unsigned
name|char
name|decode_table
index|[
literal|128
index|]
decl_stmt|;
name|char
modifier|*
name|out
decl_stmt|,
modifier|*
name|d
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|src
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|s
decl_stmt|;
comment|/* If the decode table is not yet initialized, prepare it. */
if|if
condition|(
name|decode_table
index|[
name|digits
index|[
literal|1
index|]
index|]
operator|!=
literal|1
condition|)
block|{
name|unsigned
name|i
decl_stmt|;
name|memset
argument_list|(
name|decode_table
argument_list|,
literal|0xff
argument_list|,
sizeof|sizeof
argument_list|(
name|decode_table
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|digits
argument_list|)
condition|;
name|i
operator|++
control|)
name|decode_table
index|[
name|digits
index|[
name|i
index|]
index|]
operator|=
name|i
expr_stmt|;
block|}
comment|/* Allocate enough space to hold the entire output. */
comment|/* Note that we may not use all of this... */
name|out
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|len
operator|-
name|len
operator|/
literal|4
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
block|{
operator|*
name|out_len
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|d
operator|=
name|out
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* Collect the next group of (up to) four characters. */
name|int
name|v
init|=
literal|0
decl_stmt|;
name|int
name|group_size
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|group_size
operator|<
literal|4
operator|&&
name|len
operator|>
literal|0
condition|)
block|{
comment|/* '=' or '_' padding indicates final group. */
if|if
condition|(
operator|*
name|src
operator|==
literal|'='
operator|||
operator|*
name|src
operator|==
literal|'_'
condition|)
block|{
name|len
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* Skip illegal characters (including line breaks) */
if|if
condition|(
operator|*
name|src
operator|>
literal|127
operator|||
operator|*
name|src
operator|<
literal|32
operator|||
name|decode_table
index|[
operator|*
name|src
index|]
operator|==
literal|0xff
condition|)
block|{
name|len
operator|--
expr_stmt|;
name|src
operator|++
expr_stmt|;
continue|continue;
block|}
name|v
operator|<<=
literal|6
expr_stmt|;
name|v
operator||=
name|decode_table
index|[
operator|*
name|src
operator|++
index|]
expr_stmt|;
name|len
operator|--
expr_stmt|;
name|group_size
operator|++
expr_stmt|;
block|}
comment|/* Align a short group properly. */
name|v
operator|<<=
literal|6
operator|*
operator|(
literal|4
operator|-
name|group_size
operator|)
expr_stmt|;
comment|/* Unpack the group we just collected. */
switch|switch
condition|(
name|group_size
condition|)
block|{
case|case
literal|4
case|:
name|d
index|[
literal|2
index|]
operator|=
name|v
operator|&
literal|0xff
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|3
case|:
name|d
index|[
literal|1
index|]
operator|=
operator|(
name|v
operator|>>
literal|8
operator|)
operator|&
literal|0xff
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|2
case|:
name|d
index|[
literal|0
index|]
operator|=
operator|(
name|v
operator|>>
literal|16
operator|)
operator|&
literal|0xff
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* this is invalid! */
break|break;
block|}
name|d
operator|+=
name|group_size
operator|*
literal|3
operator|/
literal|4
expr_stmt|;
block|}
operator|*
name|out_len
operator|=
name|d
operator|-
name|out
expr_stmt|;
return|return
operator|(
name|out
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|url_decode
parameter_list|(
specifier|const
name|char
modifier|*
name|in
parameter_list|)
block|{
name|char
modifier|*
name|out
decl_stmt|,
modifier|*
name|d
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|out
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|in
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|s
operator|=
name|in
operator|,
name|d
operator|=
name|out
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
control|)
block|{
if|if
condition|(
name|s
index|[
literal|0
index|]
operator|==
literal|'%'
operator|&&
name|s
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|&&
name|s
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
block|{
comment|/* Try to convert % escape */
name|int
name|digit1
init|=
name|tohex
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
decl_stmt|;
name|int
name|digit2
init|=
name|tohex
argument_list|(
name|s
index|[
literal|2
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|digit1
operator|>=
literal|0
operator|&&
name|digit2
operator|>=
literal|0
condition|)
block|{
comment|/* Looks good, consume three chars */
name|s
operator|+=
literal|3
expr_stmt|;
comment|/* Convert output */
operator|*
name|d
operator|++
operator|=
operator|(
operator|(
name|digit1
operator|<<
literal|4
operator|)
operator||
name|digit2
operator|)
expr_stmt|;
continue|continue;
block|}
comment|/* Else fall through and treat '%' as normal char */
block|}
operator|*
name|d
operator|++
operator|=
operator|*
name|s
operator|++
expr_stmt|;
block|}
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|out
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|tohex
parameter_list|(
name|int
name|c
parameter_list|)
block|{
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
return|return
operator|(
name|c
operator|-
literal|'0'
operator|)
return|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'F'
condition|)
return|return
operator|(
name|c
operator|-
literal|'A'
operator|+
literal|10
operator|)
return|;
elseif|else
if|if
condition|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'f'
condition|)
return|return
operator|(
name|c
operator|-
literal|'a'
operator|+
literal|10
operator|)
return|;
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

end_unit

