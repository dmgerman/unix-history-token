begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2007 Tim Kientzle  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"archive_platform.h"
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ERRNO_H
end_ifdef

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"archive.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry.h"
end_include

begin_include
include|#
directive|include
file|"archive_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_write_private.h"
end_include

begin_struct
struct|struct
name|pax
block|{
name|uint64_t
name|entry_bytes_remaining
decl_stmt|;
name|uint64_t
name|entry_padding
decl_stmt|;
name|struct
name|archive_string
name|pax_header
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|add_pax_attr
parameter_list|(
name|struct
name|archive_string
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_pax_attr_int
parameter_list|(
name|struct
name|archive_string
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|int64_t
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_pax_attr_time
parameter_list|(
name|struct
name|archive_string
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|int64_t
name|sec
parameter_list|,
name|unsigned
name|long
name|nanos
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_pax_attr_w
parameter_list|(
name|struct
name|archive_string
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|wvalue
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|ssize_t
name|archive_write_pax_data
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_write_pax_finish
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_write_pax_destroy
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_write_pax_finish_entry
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_write_pax_header
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|base64_encode
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|build_pax_attribute_name
parameter_list|(
name|char
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|build_ustar_entry_name
parameter_list|(
name|char
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|size_t
name|src_length
parameter_list|,
specifier|const
name|char
modifier|*
name|insert
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|format_int
parameter_list|(
name|char
modifier|*
name|dest
parameter_list|,
name|int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|has_non_ASCII
parameter_list|(
specifier|const
name|wchar_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|url_encode
parameter_list|(
specifier|const
name|char
modifier|*
name|in
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|write_nulls
parameter_list|(
name|struct
name|archive_write
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Set output format to 'restricted pax' format.  *  * This is the same as normal 'pax', but tries to suppress  * the pax header whenever possible.  This is the default for  * bsdtar, for instance.  */
end_comment

begin_function
name|int
name|archive_write_set_format_pax_restricted
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|archive_write
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_write
operator|*
operator|)
name|_a
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
name|archive_write_set_format_pax
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|)
expr_stmt|;
name|a
operator|->
name|archive_format
operator|=
name|ARCHIVE_FORMAT_TAR_PAX_RESTRICTED
expr_stmt|;
name|a
operator|->
name|archive_format_name
operator|=
literal|"restricted POSIX pax interchange"
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set output format to 'pax' format.  */
end_comment

begin_function
name|int
name|archive_write_set_format_pax
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|archive_write
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_write
operator|*
operator|)
name|_a
decl_stmt|;
name|struct
name|pax
modifier|*
name|pax
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|format_destroy
operator|!=
name|NULL
condition|)
call|(
name|a
operator|->
name|format_destroy
call|)
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|pax
operator|=
operator|(
expr|struct
name|pax
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pax
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pax
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate pax data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|memset
argument_list|(
name|pax
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pax
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|->
name|format_data
operator|=
name|pax
expr_stmt|;
name|a
operator|->
name|pad_uncompressed
operator|=
literal|1
expr_stmt|;
name|a
operator|->
name|format_write_header
operator|=
name|archive_write_pax_header
expr_stmt|;
name|a
operator|->
name|format_write_data
operator|=
name|archive_write_pax_data
expr_stmt|;
name|a
operator|->
name|format_finish
operator|=
name|archive_write_pax_finish
expr_stmt|;
name|a
operator|->
name|format_destroy
operator|=
name|archive_write_pax_destroy
expr_stmt|;
name|a
operator|->
name|format_finish_entry
operator|=
name|archive_write_pax_finish_entry
expr_stmt|;
name|a
operator|->
name|archive_format
operator|=
name|ARCHIVE_FORMAT_TAR_PAX_INTERCHANGE
expr_stmt|;
name|a
operator|->
name|archive_format_name
operator|=
literal|"POSIX pax interchange"
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Note: This code assumes that 'nanos' has the same sign as 'sec',  * which implies that sec=-1, nanos=200000000 represents -1.2 seconds  * and not -0.8 seconds.  This is a pretty pedantic point, as we're  * unlikely to encounter many real files created before Jan 1, 1970,  * much less ones with timestamps recorded to sub-second resolution.  */
end_comment

begin_function
specifier|static
name|void
name|add_pax_attr_time
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|int64_t
name|sec
parameter_list|,
name|unsigned
name|long
name|nanos
parameter_list|)
block|{
name|int
name|digit
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
comment|/* 	 * Note that each byte contributes fewer than 3 base-10 	 * digits, so this will always be big enough. 	 */
name|char
name|tmp
index|[
literal|1
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|sec
argument_list|)
operator|+
literal|1
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|nanos
argument_list|)
index|]
decl_stmt|;
name|tmp
index|[
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|tmp
operator|+
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* Skip trailing zeros in the fractional part. */
for|for
control|(
name|digit
operator|=
literal|0
operator|,
name|i
operator|=
literal|10
init|;
name|i
operator|>
literal|0
operator|&&
name|digit
operator|==
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|digit
operator|=
name|nanos
operator|%
literal|10
expr_stmt|;
name|nanos
operator|/=
literal|10
expr_stmt|;
block|}
comment|/* Only format the fraction if it's non-zero. */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
operator|*
operator|--
name|t
operator|=
literal|"0123456789"
index|[
name|digit
index|]
expr_stmt|;
name|digit
operator|=
name|nanos
operator|%
literal|10
expr_stmt|;
name|nanos
operator|/=
literal|10
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
operator|*
operator|--
name|t
operator|=
literal|'.'
expr_stmt|;
block|}
name|t
operator|=
name|format_int
argument_list|(
name|t
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|add_pax_attr
argument_list|(
name|as
argument_list|,
name|key
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|format_int
parameter_list|(
name|char
modifier|*
name|t
parameter_list|,
name|int64_t
name|i
parameter_list|)
block|{
name|int
name|sign
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
name|i
operator|=
operator|-
name|i
expr_stmt|;
block|}
else|else
name|sign
operator|=
literal|1
expr_stmt|;
do|do
block|{
operator|*
operator|--
name|t
operator|=
literal|"0123456789"
index|[
name|i
operator|%
literal|10
index|]
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|/=
literal|10
condition|)
do|;
if|if
condition|(
name|sign
operator|<
literal|0
condition|)
operator|*
operator|--
name|t
operator|=
literal|'-'
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_pax_attr_int
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|int64_t
name|value
parameter_list|)
block|{
name|char
name|tmp
index|[
literal|1
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|value
argument_list|)
index|]
decl_stmt|;
name|tmp
index|[
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|add_pax_attr
argument_list|(
name|as
argument_list|,
name|key
argument_list|,
name|format_int
argument_list|(
name|tmp
operator|+
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
operator|-
literal|1
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|utf8_encode
parameter_list|(
specifier|const
name|wchar_t
modifier|*
name|wval
parameter_list|)
block|{
name|int
name|utf8len
decl_stmt|;
specifier|const
name|wchar_t
modifier|*
name|wp
decl_stmt|;
name|unsigned
name|long
name|wc
decl_stmt|;
name|char
modifier|*
name|utf8_value
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|utf8len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|wp
operator|=
name|wval
init|;
operator|*
name|wp
operator|!=
literal|L'
expr|\0'
condition|;
control|)
block|{
name|wc
operator|=
operator|*
name|wp
operator|++
expr_stmt|;
if|if
condition|(
name|wc
operator|<=
literal|0x7f
condition|)
name|utf8len
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|wc
operator|<=
literal|0x7ff
condition|)
name|utf8len
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|wc
operator|<=
literal|0xffff
condition|)
name|utf8len
operator|+=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|wc
operator|<=
literal|0x1fffff
condition|)
name|utf8len
operator|+=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|wc
operator|<=
literal|0x3ffffff
condition|)
name|utf8len
operator|+=
literal|5
expr_stmt|;
elseif|else
if|if
condition|(
name|wc
operator|<=
literal|0x7fffffff
condition|)
name|utf8len
operator|+=
literal|6
expr_stmt|;
comment|/* Ignore larger values; UTF-8 can't encode them. */
block|}
name|utf8_value
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|utf8len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|utf8_value
operator|==
name|NULL
condition|)
block|{
name|__archive_errx
argument_list|(
literal|1
argument_list|,
literal|"Not enough memory for attributes"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
for|for
control|(
name|wp
operator|=
name|wval
operator|,
name|p
operator|=
name|utf8_value
init|;
operator|*
name|wp
operator|!=
literal|L'
expr|\0'
condition|;
control|)
block|{
name|wc
operator|=
operator|*
name|wp
operator|++
expr_stmt|;
if|if
condition|(
name|wc
operator|<=
literal|0x7f
condition|)
block|{
operator|*
name|p
operator|++
operator|=
operator|(
name|char
operator|)
name|wc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wc
operator|<=
literal|0x7ff
condition|)
block|{
name|p
index|[
literal|0
index|]
operator|=
literal|0xc0
operator||
operator|(
operator|(
name|wc
operator|>>
literal|6
operator|)
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|0x80
operator||
operator|(
name|wc
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wc
operator|<=
literal|0xffff
condition|)
block|{
name|p
index|[
literal|0
index|]
operator|=
literal|0xe0
operator||
operator|(
operator|(
name|wc
operator|>>
literal|12
operator|)
operator|&
literal|0x0f
operator|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|0x80
operator||
operator|(
operator|(
name|wc
operator|>>
literal|6
operator|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
literal|0x80
operator||
operator|(
name|wc
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|p
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wc
operator|<=
literal|0x1fffff
condition|)
block|{
name|p
index|[
literal|0
index|]
operator|=
literal|0xf0
operator||
operator|(
operator|(
name|wc
operator|>>
literal|18
operator|)
operator|&
literal|0x07
operator|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|0x80
operator||
operator|(
operator|(
name|wc
operator|>>
literal|12
operator|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
literal|0x80
operator||
operator|(
operator|(
name|wc
operator|>>
literal|6
operator|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
literal|0x80
operator||
operator|(
name|wc
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wc
operator|<=
literal|0x3ffffff
condition|)
block|{
name|p
index|[
literal|0
index|]
operator|=
literal|0xf8
operator||
operator|(
operator|(
name|wc
operator|>>
literal|24
operator|)
operator|&
literal|0x03
operator|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|0x80
operator||
operator|(
operator|(
name|wc
operator|>>
literal|18
operator|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
literal|0x80
operator||
operator|(
operator|(
name|wc
operator|>>
literal|12
operator|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
literal|0x80
operator||
operator|(
operator|(
name|wc
operator|>>
literal|6
operator|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|p
index|[
literal|4
index|]
operator|=
literal|0x80
operator||
operator|(
name|wc
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|p
operator|+=
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wc
operator|<=
literal|0x7fffffff
condition|)
block|{
name|p
index|[
literal|0
index|]
operator|=
literal|0xfc
operator||
operator|(
operator|(
name|wc
operator|>>
literal|30
operator|)
operator|&
literal|0x01
operator|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|0x80
operator||
operator|(
operator|(
name|wc
operator|>>
literal|24
operator|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|0x80
operator||
operator|(
operator|(
name|wc
operator|>>
literal|18
operator|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
literal|0x80
operator||
operator|(
operator|(
name|wc
operator|>>
literal|12
operator|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
literal|0x80
operator||
operator|(
operator|(
name|wc
operator|>>
literal|6
operator|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|p
index|[
literal|4
index|]
operator|=
literal|0x80
operator||
operator|(
name|wc
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|p
operator|+=
literal|6
expr_stmt|;
block|}
comment|/* Ignore larger values; UTF-8 can't encode them. */
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|utf8_value
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_pax_attr_w
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|wval
parameter_list|)
block|{
name|char
modifier|*
name|utf8_value
init|=
name|utf8_encode
argument_list|(
name|wval
argument_list|)
decl_stmt|;
if|if
condition|(
name|utf8_value
operator|==
name|NULL
condition|)
return|return;
name|add_pax_attr
argument_list|(
name|as
argument_list|,
name|key
argument_list|,
name|utf8_value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|utf8_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a key/value attribute to the pax header.  This function handles  * the length field and various other syntactic requirements.  */
end_comment

begin_function
specifier|static
name|void
name|add_pax_attr
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|int
name|digits
decl_stmt|,
name|i
decl_stmt|,
name|len
decl_stmt|,
name|next_ten
decl_stmt|;
name|char
name|tmp
index|[
literal|1
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
index|]
decl_stmt|;
comment|/*< 3 base-10 digits per byte */
comment|/*- 	 * PAX attributes have the following layout: 	 *<len><space><key><=><value><nl> 	 */
name|len
operator|=
literal|1
operator|+
name|strlen
argument_list|(
name|key
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|value
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* 	 * The<len> field includes the length of the<len> field, so 	 * computing the correct length is tricky.  I start by 	 * counting the number of base-10 digits in 'len' and 	 * computing the next higher power of 10. 	 */
name|next_ten
operator|=
literal|1
expr_stmt|;
name|digits
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|i
operator|/
literal|10
expr_stmt|;
name|digits
operator|++
expr_stmt|;
name|next_ten
operator|=
name|next_ten
operator|*
literal|10
expr_stmt|;
block|}
comment|/* 	 * For example, if string without the length field is 99 	 * chars, then adding the 2 digit length "99" will force the 	 * total length past 100, requiring an extra digit.  The next 	 * statement adjusts for this effect. 	 */
if|if
condition|(
name|len
operator|+
name|digits
operator|>=
name|next_ten
condition|)
name|digits
operator|++
expr_stmt|;
comment|/* Now, we have the right length so we can build the line. */
name|tmp
index|[
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Null-terminate the work area. */
name|archive_strcat
argument_list|(
name|as
argument_list|,
name|format_int
argument_list|(
name|tmp
operator|+
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
operator|-
literal|1
argument_list|,
name|len
operator|+
name|digits
argument_list|)
argument_list|)
expr_stmt|;
name|archive_strappend_char
argument_list|(
name|as
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|archive_strcat
argument_list|(
name|as
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|archive_strappend_char
argument_list|(
name|as
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
name|archive_strcat
argument_list|(
name|as
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|archive_strappend_char
argument_list|(
name|as
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|archive_write_pax_header_xattrs
parameter_list|(
name|struct
name|pax
modifier|*
name|pax
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|archive_string
name|s
decl_stmt|;
name|int
name|i
init|=
name|archive_entry_xattr_reset
argument_list|(
name|entry
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|void
modifier|*
name|value
decl_stmt|;
name|char
modifier|*
name|encoded_value
decl_stmt|;
name|char
modifier|*
name|url_encoded_name
init|=
name|NULL
decl_stmt|,
modifier|*
name|encoded_name
init|=
name|NULL
decl_stmt|;
name|wchar_t
modifier|*
name|wcs_name
init|=
name|NULL
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|archive_entry_xattr_next
argument_list|(
name|entry
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|value
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
comment|/* Name is URL-encoded, then converted to wchar_t, 		 * then UTF-8 encoded. */
name|url_encoded_name
operator|=
name|url_encode
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|url_encoded_name
operator|!=
name|NULL
condition|)
block|{
comment|/* Convert narrow-character to wide-character. */
name|int
name|wcs_length
init|=
name|strlen
argument_list|(
name|url_encoded_name
argument_list|)
decl_stmt|;
name|wcs_name
operator|=
operator|(
name|wchar_t
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|wcs_length
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|wchar_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|wcs_name
operator|==
name|NULL
condition|)
name|__archive_errx
argument_list|(
literal|1
argument_list|,
literal|"No memory for xattr conversion"
argument_list|)
expr_stmt|;
name|mbstowcs
argument_list|(
name|wcs_name
argument_list|,
name|url_encoded_name
argument_list|,
name|wcs_length
argument_list|)
expr_stmt|;
name|wcs_name
index|[
name|wcs_length
index|]
operator|=
literal|0
expr_stmt|;
name|free
argument_list|(
name|url_encoded_name
argument_list|)
expr_stmt|;
comment|/* Done with this. */
block|}
if|if
condition|(
name|wcs_name
operator|!=
name|NULL
condition|)
block|{
name|encoded_name
operator|=
name|utf8_encode
argument_list|(
name|wcs_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wcs_name
argument_list|)
expr_stmt|;
comment|/* Done with wchar_t name. */
block|}
name|encoded_value
operator|=
name|base64_encode
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|value
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|encoded_name
operator|!=
name|NULL
operator|&&
name|encoded_value
operator|!=
name|NULL
condition|)
block|{
name|archive_string_init
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
name|archive_strcpy
argument_list|(
operator|&
name|s
argument_list|,
literal|"LIBARCHIVE.xattr."
argument_list|)
expr_stmt|;
name|archive_strcat
argument_list|(
operator|&
name|s
argument_list|,
name|encoded_name
argument_list|)
expr_stmt|;
name|add_pax_attr
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
name|s
operator|.
name|s
argument_list|,
name|encoded_value
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|s
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|encoded_name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|encoded_value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * TODO: Consider adding 'comment' and 'charset' fields to  * archive_entry so that clients can specify them.  Also, consider  * adding generic key/value tags so clients can add arbitrary  * key/value data.  */
end_comment

begin_function
specifier|static
name|int
name|archive_write_pax_header
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry_original
parameter_list|)
block|{
name|struct
name|archive_entry
modifier|*
name|entry_main
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
specifier|const
name|wchar_t
modifier|*
name|wp
decl_stmt|;
specifier|const
name|char
modifier|*
name|suffix_start
decl_stmt|;
name|int
name|need_extension
decl_stmt|,
name|r
decl_stmt|,
name|ret
decl_stmt|;
name|struct
name|pax
modifier|*
name|pax
decl_stmt|;
specifier|const
name|char
modifier|*
name|hdrcharset
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|hardlink
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|NULL
decl_stmt|,
modifier|*
name|linkpath
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|uname
init|=
name|NULL
decl_stmt|,
modifier|*
name|gname
init|=
name|NULL
decl_stmt|;
specifier|const
name|wchar_t
modifier|*
name|path_w
init|=
name|NULL
decl_stmt|,
modifier|*
name|linkpath_w
init|=
name|NULL
decl_stmt|;
specifier|const
name|wchar_t
modifier|*
name|uname_w
init|=
name|NULL
decl_stmt|,
modifier|*
name|gname_w
init|=
name|NULL
decl_stmt|;
name|char
name|paxbuff
index|[
literal|512
index|]
decl_stmt|;
name|char
name|ustarbuff
index|[
literal|512
index|]
decl_stmt|;
name|char
name|ustar_entry_name
index|[
literal|256
index|]
decl_stmt|;
name|char
name|pax_entry_name
index|[
literal|256
index|]
decl_stmt|;
name|ret
operator|=
name|ARCHIVE_OK
expr_stmt|;
name|need_extension
operator|=
literal|0
expr_stmt|;
name|pax
operator|=
operator|(
expr|struct
name|pax
operator|*
operator|)
name|a
operator|->
name|format_data
expr_stmt|;
name|hardlink
operator|=
name|archive_entry_hardlink
argument_list|(
name|entry_original
argument_list|)
expr_stmt|;
comment|/* Make sure this is a type of entry that we can handle here */
if|if
condition|(
name|hardlink
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
name|archive_entry_filetype
argument_list|(
name|entry_original
argument_list|)
condition|)
block|{
case|case
name|AE_IFBLK
case|:
case|case
name|AE_IFCHR
case|:
case|case
name|AE_IFIFO
case|:
case|case
name|AE_IFLNK
case|:
case|case
name|AE_IFREG
case|:
break|break;
case|case
name|AE_IFDIR
case|:
comment|/* 			 * Ensure a trailing '/'.  Modify the original 			 * entry so the client sees the change. 			 */
name|p
operator|=
name|archive_entry_pathname
argument_list|(
name|entry_original
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
name|strlen
argument_list|(
name|p
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
block|{
name|t
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate pax data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|t
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|t
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|archive_entry_copy_pathname
argument_list|(
name|entry_original
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"tar format cannot archive this (type=0%lo)"
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|archive_entry_filetype
argument_list|(
name|entry_original
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
block|}
comment|/* Copy entry so we can modify it as needed. */
name|entry_main
operator|=
name|archive_entry_clone
argument_list|(
name|entry_original
argument_list|)
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|)
expr_stmt|;
comment|/* Blank our work area. */
comment|/* 	 * First, check the name fields and see if any of them 	 * require binary coding.  If any of them does, then all of 	 * them do. 	 */
name|hdrcharset
operator|=
name|NULL
expr_stmt|;
name|path
operator|=
name|archive_entry_pathname
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
name|path_w
operator|=
name|archive_entry_pathname_w
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|!=
name|NULL
operator|&&
name|path_w
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|EILSEQ
argument_list|,
literal|"Can't translate pathname '%s' to UTF-8"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
name|hdrcharset
operator|=
literal|"BINARY"
expr_stmt|;
block|}
name|uname
operator|=
name|archive_entry_uname
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
name|uname_w
operator|=
name|archive_entry_uname_w
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
if|if
condition|(
name|uname
operator|!=
name|NULL
operator|&&
name|uname_w
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|EILSEQ
argument_list|,
literal|"Can't translate uname '%s' to UTF-8"
argument_list|,
name|uname
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
name|hdrcharset
operator|=
literal|"BINARY"
expr_stmt|;
block|}
name|gname
operator|=
name|archive_entry_gname
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
name|gname_w
operator|=
name|archive_entry_gname_w
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
if|if
condition|(
name|gname
operator|!=
name|NULL
operator|&&
name|gname_w
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|EILSEQ
argument_list|,
literal|"Can't translate gname '%s' to UTF-8"
argument_list|,
name|gname
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
name|hdrcharset
operator|=
literal|"BINARY"
expr_stmt|;
block|}
name|linkpath
operator|=
name|hardlink
expr_stmt|;
if|if
condition|(
name|linkpath
operator|!=
name|NULL
condition|)
block|{
name|linkpath_w
operator|=
name|archive_entry_hardlink_w
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|linkpath
operator|=
name|archive_entry_symlink
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
if|if
condition|(
name|linkpath
operator|!=
name|NULL
condition|)
name|linkpath_w
operator|=
name|archive_entry_symlink_w
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|linkpath
operator|!=
name|NULL
operator|&&
name|linkpath_w
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|EILSEQ
argument_list|,
literal|"Can't translate linkpath '%s' to UTF-8"
argument_list|,
name|linkpath
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
name|hdrcharset
operator|=
literal|"BINARY"
expr_stmt|;
block|}
comment|/* Store the header encoding first, to be nice to readers. */
if|if
condition|(
name|hdrcharset
operator|!=
name|NULL
condition|)
name|add_pax_attr
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"hdrcharset"
argument_list|,
name|hdrcharset
argument_list|)
expr_stmt|;
comment|/* 	 * Determining whether or not the name is too big is ugly 	 * because of the rules for dividing names between 'name' and 	 * 'prefix' fields.  Here, I pick out the longest possible 	 * suffix, then test whether the remaining prefix is too long. 	 */
if|if
condition|(
name|strlen
argument_list|(
name|path
argument_list|)
operator|<=
literal|100
condition|)
comment|/* Short enough for just 'name' field */
name|suffix_start
operator|=
name|path
expr_stmt|;
comment|/* Record a zero-length prefix */
else|else
comment|/* Find the largest suffix that fits in 'name' field. */
name|suffix_start
operator|=
name|strchr
argument_list|(
name|path
operator|+
name|strlen
argument_list|(
name|path
argument_list|)
operator|-
literal|100
operator|-
literal|1
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/* 	 * If name is too long, or has non-ASCII characters, add 	 * 'path' to pax extended attrs.  (Note that an unconvertible 	 * name must have non-ASCII characters.) 	 */
if|if
condition|(
name|suffix_start
operator|==
name|NULL
operator|||
name|suffix_start
operator|-
name|path
operator|>
literal|155
operator|||
name|path_w
operator|==
name|NULL
operator|||
name|has_non_ASCII
argument_list|(
name|path_w
argument_list|)
condition|)
block|{
if|if
condition|(
name|path_w
operator|==
name|NULL
operator|||
name|hdrcharset
operator|!=
name|NULL
condition|)
comment|/* Can't do UTF-8, so store it raw. */
name|add_pax_attr
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"path"
argument_list|,
name|path
argument_list|)
expr_stmt|;
else|else
name|add_pax_attr_w
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"path"
argument_list|,
name|path_w
argument_list|)
expr_stmt|;
name|archive_entry_set_pathname
argument_list|(
name|entry_main
argument_list|,
name|build_ustar_entry_name
argument_list|(
name|ustar_entry_name
argument_list|,
name|path
argument_list|,
name|strlen
argument_list|(
name|path
argument_list|)
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|need_extension
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|linkpath
operator|!=
name|NULL
condition|)
block|{
comment|/* If link name is too long or has non-ASCII characters, add 		 * 'linkpath' to pax extended attrs. */
if|if
condition|(
name|strlen
argument_list|(
name|linkpath
argument_list|)
operator|>
literal|100
operator|||
name|linkpath_w
operator|==
name|NULL
operator|||
name|linkpath_w
operator|==
name|NULL
operator|||
name|has_non_ASCII
argument_list|(
name|linkpath_w
argument_list|)
condition|)
block|{
if|if
condition|(
name|linkpath_w
operator|==
name|NULL
operator|||
name|hdrcharset
operator|!=
name|NULL
condition|)
comment|/* If the linkpath is not convertible 				 * to wide, or we're encoding in 				 * binary anyway, store it raw. */
name|add_pax_attr
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"linkpath"
argument_list|,
name|linkpath
argument_list|)
expr_stmt|;
else|else
comment|/* If the link is long or has a 				 * non-ASCII character, store it as a 				 * pax extended attribute. */
name|add_pax_attr_w
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"linkpath"
argument_list|,
name|linkpath_w
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|linkpath
argument_list|)
operator|>
literal|100
condition|)
block|{
if|if
condition|(
name|hardlink
operator|!=
name|NULL
condition|)
name|archive_entry_set_hardlink
argument_list|(
name|entry_main
argument_list|,
literal|"././@LongHardLink"
argument_list|)
expr_stmt|;
else|else
name|archive_entry_set_symlink
argument_list|(
name|entry_main
argument_list|,
literal|"././@LongSymLink"
argument_list|)
expr_stmt|;
block|}
name|need_extension
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* If file size is too large, add 'size' to pax extended attrs. */
if|if
condition|(
name|archive_entry_size
argument_list|(
name|entry_main
argument_list|)
operator|>=
operator|(
operator|(
operator|(
name|int64_t
operator|)
literal|1
operator|)
operator|<<
literal|33
operator|)
condition|)
block|{
name|add_pax_attr_int
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"size"
argument_list|,
name|archive_entry_size
argument_list|(
name|entry_main
argument_list|)
argument_list|)
expr_stmt|;
name|need_extension
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If numeric GID is too large, add 'gid' to pax extended attrs. */
if|if
condition|(
name|archive_entry_gid
argument_list|(
name|entry_main
argument_list|)
operator|>=
operator|(
literal|1
operator|<<
literal|18
operator|)
condition|)
block|{
name|add_pax_attr_int
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"gid"
argument_list|,
name|archive_entry_gid
argument_list|(
name|entry_main
argument_list|)
argument_list|)
expr_stmt|;
name|need_extension
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If group name is too large or has non-ASCII characters, add 	 * 'gname' to pax extended attrs. */
if|if
condition|(
name|gname
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|gname
argument_list|)
operator|>
literal|31
operator|||
name|gname_w
operator|==
name|NULL
operator|||
name|has_non_ASCII
argument_list|(
name|gname_w
argument_list|)
condition|)
block|{
if|if
condition|(
name|gname_w
operator|==
name|NULL
operator|||
name|hdrcharset
operator|!=
name|NULL
condition|)
block|{
name|add_pax_attr
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"gname"
argument_list|,
name|gname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|add_pax_attr_w
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"gname"
argument_list|,
name|gname_w
argument_list|)
expr_stmt|;
block|}
name|need_extension
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* If numeric UID is too large, add 'uid' to pax extended attrs. */
if|if
condition|(
name|archive_entry_uid
argument_list|(
name|entry_main
argument_list|)
operator|>=
operator|(
literal|1
operator|<<
literal|18
operator|)
condition|)
block|{
name|add_pax_attr_int
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"uid"
argument_list|,
name|archive_entry_uid
argument_list|(
name|entry_main
argument_list|)
argument_list|)
expr_stmt|;
name|need_extension
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Add 'uname' to pax extended attrs if necessary. */
if|if
condition|(
name|uname
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|uname
argument_list|)
operator|>
literal|31
operator|||
name|uname_w
operator|==
name|NULL
operator|||
name|has_non_ASCII
argument_list|(
name|uname_w
argument_list|)
condition|)
block|{
if|if
condition|(
name|uname_w
operator|==
name|NULL
operator|||
name|hdrcharset
operator|!=
name|NULL
condition|)
block|{
name|add_pax_attr
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"uname"
argument_list|,
name|uname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|add_pax_attr_w
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"uname"
argument_list|,
name|uname_w
argument_list|)
expr_stmt|;
block|}
name|need_extension
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * POSIX/SUSv3 doesn't provide a standard key for large device 	 * numbers.  I use the same keys here that Joerg Schilling 	 * used for 'star.'  (Which, somewhat confusingly, are called 	 * "devXXX" even though they code "rdev" values.)  No doubt, 	 * other implementations use other keys.  Note that there's no 	 * reason we can't write the same information into a number of 	 * different keys. 	 * 	 * Of course, this is only needed for block or char device entries. 	 */
if|if
condition|(
name|archive_entry_filetype
argument_list|(
name|entry_main
argument_list|)
operator|==
name|AE_IFBLK
operator|||
name|archive_entry_filetype
argument_list|(
name|entry_main
argument_list|)
operator|==
name|AE_IFCHR
condition|)
block|{
comment|/* 		 * If rdevmajor is too large, add 'SCHILY.devmajor' to 		 * extended attributes. 		 */
name|dev_t
name|rdevmajor
decl_stmt|,
name|rdevminor
decl_stmt|;
name|rdevmajor
operator|=
name|archive_entry_rdevmajor
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
name|rdevminor
operator|=
name|archive_entry_rdevminor
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
if|if
condition|(
name|rdevmajor
operator|>=
operator|(
literal|1
operator|<<
literal|18
operator|)
condition|)
block|{
name|add_pax_attr_int
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"SCHILY.devmajor"
argument_list|,
name|rdevmajor
argument_list|)
expr_stmt|;
comment|/* 			 * Non-strict formatting below means we don't 			 * have to truncate here.  Not truncating improves 			 * the chance that some more modern tar archivers 			 * (such as GNU tar 1.13) can restore the full 			 * value even if they don't understand the pax 			 * extended attributes.  See my rant below about 			 * file size fields for additional details. 			 */
comment|/* archive_entry_set_rdevmajor(entry_main, 			   rdevmajor& ((1<< 18) - 1)); */
name|need_extension
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 		 * If devminor is too large, add 'SCHILY.devminor' to 		 * extended attributes. 		 */
if|if
condition|(
name|rdevminor
operator|>=
operator|(
literal|1
operator|<<
literal|18
operator|)
condition|)
block|{
name|add_pax_attr_int
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"SCHILY.devminor"
argument_list|,
name|rdevminor
argument_list|)
expr_stmt|;
comment|/* Truncation is not necessary here, either. */
comment|/* archive_entry_set_rdevminor(entry_main, 			   rdevminor& ((1<< 18) - 1)); */
name|need_extension
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * Technically, the mtime field in the ustar header can 	 * support 33 bits, but many platforms use signed 32-bit time 	 * values.  The cutoff of 0x7fffffff here is a compromise. 	 * Yes, this check is duplicated just below; this helps to 	 * avoid writing an mtime attribute just to handle a 	 * high-resolution timestamp in "restricted pax" mode. 	 */
if|if
condition|(
operator|!
name|need_extension
operator|&&
operator|(
operator|(
name|archive_entry_mtime
argument_list|(
name|entry_main
argument_list|)
operator|<
literal|0
operator|)
operator|||
operator|(
name|archive_entry_mtime
argument_list|(
name|entry_main
argument_list|)
operator|>=
literal|0x7fffffff
operator|)
operator|)
condition|)
name|need_extension
operator|=
literal|1
expr_stmt|;
comment|/* I use a star-compatible file flag attribute. */
name|p
operator|=
name|archive_entry_fflags_text
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|need_extension
operator|&&
name|p
operator|!=
name|NULL
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
name|need_extension
operator|=
literal|1
expr_stmt|;
comment|/* If there are non-trivial ACL entries, we need an extension. */
if|if
condition|(
operator|!
name|need_extension
operator|&&
name|archive_entry_acl_count
argument_list|(
name|entry_original
argument_list|,
name|ARCHIVE_ENTRY_ACL_TYPE_ACCESS
argument_list|)
operator|>
literal|0
condition|)
name|need_extension
operator|=
literal|1
expr_stmt|;
comment|/* If there are non-trivial ACL entries, we need an extension. */
if|if
condition|(
operator|!
name|need_extension
operator|&&
name|archive_entry_acl_count
argument_list|(
name|entry_original
argument_list|,
name|ARCHIVE_ENTRY_ACL_TYPE_DEFAULT
argument_list|)
operator|>
literal|0
condition|)
name|need_extension
operator|=
literal|1
expr_stmt|;
comment|/* If there are extended attributes, we need an extension */
if|if
condition|(
operator|!
name|need_extension
operator|&&
name|archive_entry_xattr_count
argument_list|(
name|entry_original
argument_list|)
operator|>
literal|0
condition|)
name|need_extension
operator|=
literal|1
expr_stmt|;
comment|/* 	 * The following items are handled differently in "pax 	 * restricted" format.  In particular, in "pax restricted" 	 * format they won't be added unless need_extension is 	 * already set (we're already generating an extended header, so 	 * may as well include these). 	 */
if|if
condition|(
name|a
operator|->
name|archive_format
operator|!=
name|ARCHIVE_FORMAT_TAR_PAX_RESTRICTED
operator|||
name|need_extension
condition|)
block|{
if|if
condition|(
name|archive_entry_mtime
argument_list|(
name|entry_main
argument_list|)
operator|<
literal|0
operator|||
name|archive_entry_mtime
argument_list|(
name|entry_main
argument_list|)
operator|>=
literal|0x7fffffff
operator|||
name|archive_entry_mtime_nsec
argument_list|(
name|entry_main
argument_list|)
operator|!=
literal|0
condition|)
name|add_pax_attr_time
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"mtime"
argument_list|,
name|archive_entry_mtime
argument_list|(
name|entry_main
argument_list|)
argument_list|,
name|archive_entry_mtime_nsec
argument_list|(
name|entry_main
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_entry_ctime
argument_list|(
name|entry_main
argument_list|)
operator|!=
literal|0
operator|||
name|archive_entry_ctime_nsec
argument_list|(
name|entry_main
argument_list|)
operator|!=
literal|0
condition|)
name|add_pax_attr_time
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"ctime"
argument_list|,
name|archive_entry_ctime
argument_list|(
name|entry_main
argument_list|)
argument_list|,
name|archive_entry_ctime_nsec
argument_list|(
name|entry_main
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_entry_atime
argument_list|(
name|entry_main
argument_list|)
operator|!=
literal|0
operator|||
name|archive_entry_atime_nsec
argument_list|(
name|entry_main
argument_list|)
operator|!=
literal|0
condition|)
name|add_pax_attr_time
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"atime"
argument_list|,
name|archive_entry_atime
argument_list|(
name|entry_main
argument_list|)
argument_list|,
name|archive_entry_atime_nsec
argument_list|(
name|entry_main
argument_list|)
argument_list|)
expr_stmt|;
comment|/* I use a star-compatible file flag attribute. */
name|p
operator|=
name|archive_entry_fflags_text
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
name|add_pax_attr
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"SCHILY.fflags"
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* I use star-compatible ACL attributes. */
name|wp
operator|=
name|archive_entry_acl_text_w
argument_list|(
name|entry_original
argument_list|,
name|ARCHIVE_ENTRY_ACL_TYPE_ACCESS
operator||
name|ARCHIVE_ENTRY_ACL_STYLE_EXTRA_ID
argument_list|)
expr_stmt|;
if|if
condition|(
name|wp
operator|!=
name|NULL
operator|&&
operator|*
name|wp
operator|!=
literal|L'
expr|\0'
condition|)
name|add_pax_attr_w
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"SCHILY.acl.access"
argument_list|,
name|wp
argument_list|)
expr_stmt|;
name|wp
operator|=
name|archive_entry_acl_text_w
argument_list|(
name|entry_original
argument_list|,
name|ARCHIVE_ENTRY_ACL_TYPE_DEFAULT
operator||
name|ARCHIVE_ENTRY_ACL_STYLE_EXTRA_ID
argument_list|)
expr_stmt|;
if|if
condition|(
name|wp
operator|!=
name|NULL
operator|&&
operator|*
name|wp
operator|!=
literal|L'
expr|\0'
condition|)
name|add_pax_attr_w
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"SCHILY.acl.default"
argument_list|,
name|wp
argument_list|)
expr_stmt|;
comment|/* Include star-compatible metadata info. */
comment|/* Note: "SCHILY.dev{major,minor}" are NOT the 		 * major/minor portions of "SCHILY.dev". */
name|add_pax_attr_int
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"SCHILY.dev"
argument_list|,
name|archive_entry_dev
argument_list|(
name|entry_main
argument_list|)
argument_list|)
expr_stmt|;
name|add_pax_attr_int
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"SCHILY.ino"
argument_list|,
name|archive_entry_ino
argument_list|(
name|entry_main
argument_list|)
argument_list|)
expr_stmt|;
name|add_pax_attr_int
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"SCHILY.nlink"
argument_list|,
name|archive_entry_nlink
argument_list|(
name|entry_main
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store extended attributes */
name|archive_write_pax_header_xattrs
argument_list|(
name|pax
argument_list|,
name|entry_original
argument_list|)
expr_stmt|;
block|}
comment|/* Only regular files have data. */
if|if
condition|(
name|archive_entry_filetype
argument_list|(
name|entry_main
argument_list|)
operator|!=
name|AE_IFREG
condition|)
name|archive_entry_set_size
argument_list|(
name|entry_main
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Pax-restricted does not store data for hardlinks, in order 	 * to improve compatibility with ustar. 	 */
if|if
condition|(
name|a
operator|->
name|archive_format
operator|!=
name|ARCHIVE_FORMAT_TAR_PAX_INTERCHANGE
operator|&&
name|hardlink
operator|!=
name|NULL
condition|)
name|archive_entry_set_size
argument_list|(
name|entry_main
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * XXX Full pax interchange format does permit a hardlink 	 * entry to have data associated with it.  I'm not supporting 	 * that here because the client expects me to tell them whether 	 * or not this format expects data for hardlinks.  If I 	 * don't check here, then every pax archive will end up with 	 * duplicated data for hardlinks.  Someday, there may be 	 * need to select this behavior, in which case the following 	 * will need to be revisited. XXX 	 */
if|if
condition|(
name|hardlink
operator|!=
name|NULL
condition|)
name|archive_entry_set_size
argument_list|(
name|entry_main
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Format 'ustar' header for main entry. 	 * 	 * The trouble with file size: If the reader can't understand 	 * the file size, they may not be able to locate the next 	 * entry and the rest of the archive is toast.  Pax-compliant 	 * readers are supposed to ignore the file size in the main 	 * header, so the question becomes how to maximize portability 	 * for readers that don't support pax attribute extensions. 	 * For maximum compatibility, I permit numeric extensions in 	 * the main header so that the file size stored will always be 	 * correct, even if it's in a format that only some 	 * implementations understand.  The technique used here is: 	 * 	 *  a) If possible, follow the standard exactly.  This handles 	 *  files up to 8 gigabytes minus 1. 	 * 	 *  b) If that fails, try octal but omit the field terminator. 	 *  That handles files up to 64 gigabytes minus 1. 	 * 	 *  c) Otherwise, use base-256 extensions.  That handles files 	 *  up to 2^63 in this implementation, with the potential to 	 *  go up to 2^94.  That should hold us for a while. ;-) 	 * 	 * The non-strict formatter uses similar logic for other 	 * numeric fields, though they're less critical. 	 */
name|__archive_write_format_header_ustar
argument_list|(
name|a
argument_list|,
name|ustarbuff
argument_list|,
name|entry_main
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If we built any extended attributes, write that entry first. */
if|if
condition|(
name|archive_strlen
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|)
operator|>
literal|0
condition|)
block|{
name|struct
name|archive_entry
modifier|*
name|pax_attr_entry
decl_stmt|;
name|time_t
name|s
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
name|mode_t
name|mode
decl_stmt|;
name|long
name|ns
decl_stmt|;
name|pax_attr_entry
operator|=
name|archive_entry_new
argument_list|()
expr_stmt|;
name|p
operator|=
name|archive_entry_pathname
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
name|archive_entry_set_pathname
argument_list|(
name|pax_attr_entry
argument_list|,
name|build_pax_attribute_name
argument_list|(
name|pax_entry_name
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_set_size
argument_list|(
name|pax_attr_entry
argument_list|,
name|archive_strlen
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy uid/gid (but clip to ustar limits). */
name|uid
operator|=
name|archive_entry_uid
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
if|if
condition|(
name|uid
operator|>=
literal|1
operator|<<
literal|18
condition|)
name|uid
operator|=
operator|(
literal|1
operator|<<
literal|18
operator|)
operator|-
literal|1
expr_stmt|;
name|archive_entry_set_uid
argument_list|(
name|pax_attr_entry
argument_list|,
name|uid
argument_list|)
expr_stmt|;
name|gid
operator|=
name|archive_entry_gid
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
if|if
condition|(
name|gid
operator|>=
literal|1
operator|<<
literal|18
condition|)
name|gid
operator|=
operator|(
literal|1
operator|<<
literal|18
operator|)
operator|-
literal|1
expr_stmt|;
name|archive_entry_set_gid
argument_list|(
name|pax_attr_entry
argument_list|,
name|gid
argument_list|)
expr_stmt|;
comment|/* Copy mode over (but not setuid/setgid bits) */
name|mode
operator|=
name|archive_entry_mode
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|S_ISUID
name|mode
operator|&=
operator|~
name|S_ISUID
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_ISGID
name|mode
operator|&=
operator|~
name|S_ISGID
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|S_ISVTX
name|mode
operator|&=
operator|~
name|S_ISVTX
expr_stmt|;
endif|#
directive|endif
name|archive_entry_set_mode
argument_list|(
name|pax_attr_entry
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* Copy uname/gname. */
name|archive_entry_set_uname
argument_list|(
name|pax_attr_entry
argument_list|,
name|archive_entry_uname
argument_list|(
name|entry_main
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_set_gname
argument_list|(
name|pax_attr_entry
argument_list|,
name|archive_entry_gname
argument_list|(
name|entry_main
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy mtime, but clip to ustar limits. */
name|s
operator|=
name|archive_entry_mtime
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
name|ns
operator|=
name|archive_entry_mtime_nsec
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
name|s
operator|=
literal|0
expr_stmt|;
name|ns
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|>
literal|0x7fffffff
condition|)
block|{
name|s
operator|=
literal|0x7fffffff
expr_stmt|;
name|ns
operator|=
literal|0
expr_stmt|;
block|}
name|archive_entry_set_mtime
argument_list|(
name|pax_attr_entry
argument_list|,
name|s
argument_list|,
name|ns
argument_list|)
expr_stmt|;
comment|/* Ditto for atime. */
name|s
operator|=
name|archive_entry_atime
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
name|ns
operator|=
name|archive_entry_atime_nsec
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
name|s
operator|=
literal|0
expr_stmt|;
name|ns
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|s
operator|>
literal|0x7fffffff
condition|)
block|{
name|s
operator|=
literal|0x7fffffff
expr_stmt|;
name|ns
operator|=
literal|0
expr_stmt|;
block|}
name|archive_entry_set_atime
argument_list|(
name|pax_attr_entry
argument_list|,
name|s
argument_list|,
name|ns
argument_list|)
expr_stmt|;
comment|/* Standard ustar doesn't support ctime. */
name|archive_entry_set_ctime
argument_list|(
name|pax_attr_entry
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|r
operator|=
name|__archive_write_format_header_ustar
argument_list|(
name|a
argument_list|,
name|paxbuff
argument_list|,
name|pax_attr_entry
argument_list|,
literal|'x'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|archive_entry_free
argument_list|(
name|pax_attr_entry
argument_list|)
expr_stmt|;
comment|/* Note that the 'x' header shouldn't ever fail to format */
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
literal|"archive_write_pax_header: "
literal|"'x' header failed?!  This can't happen.\n"
decl_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
name|msg
argument_list|,
name|strlen
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
call|(
name|a
operator|->
name|compressor
operator|.
name|write
call|)
argument_list|(
name|a
argument_list|,
name|paxbuff
argument_list|,
literal|512
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
name|pax
operator|->
name|entry_bytes_remaining
operator|=
literal|0
expr_stmt|;
name|pax
operator|->
name|entry_padding
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|pax
operator|->
name|entry_bytes_remaining
operator|=
name|archive_strlen
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|)
expr_stmt|;
name|pax
operator|->
name|entry_padding
operator|=
literal|0x1ff
operator|&
operator|(
operator|-
operator|(
name|int64_t
operator|)
name|pax
operator|->
name|entry_bytes_remaining
operator|)
expr_stmt|;
name|r
operator|=
call|(
name|a
operator|->
name|compressor
operator|.
name|write
call|)
argument_list|(
name|a
argument_list|,
name|pax
operator|->
name|pax_header
operator|.
name|s
argument_list|,
name|archive_strlen
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
comment|/* If a write fails, we're pretty much toast. */
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
comment|/* Pad out the end of the entry. */
name|r
operator|=
name|write_nulls
argument_list|(
name|a
argument_list|,
name|pax
operator|->
name|entry_padding
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
block|{
comment|/* If a write fails, we're pretty much toast. */
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|pax
operator|->
name|entry_bytes_remaining
operator|=
name|pax
operator|->
name|entry_padding
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Write the header for main entry. */
name|r
operator|=
call|(
name|a
operator|->
name|compressor
operator|.
name|write
call|)
argument_list|(
name|a
argument_list|,
name|ustarbuff
argument_list|,
literal|512
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
comment|/* 	 * Inform the client of the on-disk size we're using, so 	 * they can avoid unnecessarily writing a body for something 	 * that we're just going to ignore. 	 */
name|archive_entry_set_size
argument_list|(
name|entry_original
argument_list|,
name|archive_entry_size
argument_list|(
name|entry_main
argument_list|)
argument_list|)
expr_stmt|;
name|pax
operator|->
name|entry_bytes_remaining
operator|=
name|archive_entry_size
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
name|pax
operator|->
name|entry_padding
operator|=
literal|0x1ff
operator|&
operator|(
operator|-
operator|(
name|int64_t
operator|)
name|pax
operator|->
name|entry_bytes_remaining
operator|)
expr_stmt|;
name|archive_entry_free
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We need a valid name for the regular 'ustar' entry.  This routine  * tries to hack something more-or-less reasonable.  *  * The approach here tries to preserve leading dir names.  We do so by  * working with four sections:  *   1) "prefix" directory names,  *   2) "suffix" directory names,  *   3) inserted dir name (optional),  *   4) filename.  *  * These sections must satisfy the following requirements:  *   * Parts 1& 2 together form an initial portion of the dir name.  *   * Part 3 is specified by the caller.  (It should not contain a leading  *     or trailing '/'.)  *   * Part 4 forms an initial portion of the base filename.  *   * The filename must be<= 99 chars to fit the ustar 'name' field.  *   * Parts 2, 3, 4 together must be<= 99 chars to fit the ustar 'name' fld.  *   * Part 1 must be<= 155 chars to fit the ustar 'prefix' field.  *   * If the original name ends in a '/', the new name must also end in a '/'  *   * Trailing '/.' sequences may be stripped.  *  * Note: Recall that the ustar format does not store the '/' separating  * parts 1& 2, but does store the '/' separating parts 2& 3.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|build_ustar_entry_name
parameter_list|(
name|char
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|size_t
name|src_length
parameter_list|,
specifier|const
name|char
modifier|*
name|insert
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|,
modifier|*
name|prefix_end
decl_stmt|;
specifier|const
name|char
modifier|*
name|suffix
decl_stmt|,
modifier|*
name|suffix_end
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|,
modifier|*
name|filename_end
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|need_slash
init|=
literal|0
decl_stmt|;
comment|/* Was there a trailing slash? */
name|size_t
name|suffix_length
init|=
literal|99
decl_stmt|;
name|int
name|insert_length
decl_stmt|;
comment|/* Length of additional dir element to be added. */
if|if
condition|(
name|insert
operator|==
name|NULL
condition|)
name|insert_length
operator|=
literal|0
expr_stmt|;
else|else
comment|/* +2 here allows for '/' before and after the insert. */
name|insert_length
operator|=
name|strlen
argument_list|(
name|insert
argument_list|)
operator|+
literal|2
expr_stmt|;
comment|/* Step 0: Quick bailout in a common case. */
if|if
condition|(
name|src_length
operator|<
literal|100
operator|&&
name|insert
operator|==
name|NULL
condition|)
block|{
name|strncpy
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|src_length
argument_list|)
expr_stmt|;
name|dest
index|[
name|src_length
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|dest
operator|)
return|;
block|}
comment|/* Step 1: Locate filename and enforce the length restriction. */
name|filename_end
operator|=
name|src
operator|+
name|src_length
expr_stmt|;
comment|/* Remove trailing '/' chars and '/.' pairs. */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|filename_end
operator|>
name|src
operator|&&
name|filename_end
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|filename_end
operator|--
expr_stmt|;
name|need_slash
operator|=
literal|1
expr_stmt|;
comment|/* Remember to restore trailing '/'. */
continue|continue;
block|}
if|if
condition|(
name|filename_end
operator|>
name|src
operator|+
literal|1
operator|&&
name|filename_end
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|filename_end
index|[
operator|-
literal|2
index|]
operator|==
literal|'/'
condition|)
block|{
name|filename_end
operator|-=
literal|2
expr_stmt|;
name|need_slash
operator|=
literal|1
expr_stmt|;
comment|/* "foo/." will become "foo/" */
continue|continue;
block|}
break|break;
block|}
if|if
condition|(
name|need_slash
condition|)
name|suffix_length
operator|--
expr_stmt|;
comment|/* Find start of filename. */
name|filename
operator|=
name|filename_end
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|filename
operator|>
name|src
operator|)
operator|&&
operator|(
operator|*
name|filename
operator|!=
literal|'/'
operator|)
condition|)
name|filename
operator|--
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|filename
operator|==
literal|'/'
operator|)
operator|&&
operator|(
name|filename
operator|<
name|filename_end
operator|-
literal|1
operator|)
condition|)
name|filename
operator|++
expr_stmt|;
comment|/* Adjust filename_end so that filename + insert fits in 99 chars. */
name|suffix_length
operator|-=
name|insert_length
expr_stmt|;
if|if
condition|(
name|filename_end
operator|>
name|filename
operator|+
name|suffix_length
condition|)
name|filename_end
operator|=
name|filename
operator|+
name|suffix_length
expr_stmt|;
comment|/* Calculate max size for "suffix" section (#3 above). */
name|suffix_length
operator|-=
name|filename_end
operator|-
name|filename
expr_stmt|;
comment|/* Step 2: Locate the "prefix" section of the dirname, including 	 * trailing '/'. */
name|prefix
operator|=
name|src
expr_stmt|;
name|prefix_end
operator|=
name|prefix
operator|+
literal|155
expr_stmt|;
if|if
condition|(
name|prefix_end
operator|>
name|filename
condition|)
name|prefix_end
operator|=
name|filename
expr_stmt|;
while|while
condition|(
name|prefix_end
operator|>
name|prefix
operator|&&
operator|*
name|prefix_end
operator|!=
literal|'/'
condition|)
name|prefix_end
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|prefix_end
operator|<
name|filename
operator|)
operator|&&
operator|(
operator|*
name|prefix_end
operator|==
literal|'/'
operator|)
condition|)
name|prefix_end
operator|++
expr_stmt|;
comment|/* Step 3: Locate the "suffix" section of the dirname, 	 * including trailing '/'. */
name|suffix
operator|=
name|prefix_end
expr_stmt|;
name|suffix_end
operator|=
name|suffix
operator|+
name|suffix_length
expr_stmt|;
comment|/* Enforce limit. */
if|if
condition|(
name|suffix_end
operator|>
name|filename
condition|)
name|suffix_end
operator|=
name|filename
expr_stmt|;
if|if
condition|(
name|suffix_end
operator|<
name|suffix
condition|)
name|suffix_end
operator|=
name|suffix
expr_stmt|;
while|while
condition|(
name|suffix_end
operator|>
name|suffix
operator|&&
operator|*
name|suffix_end
operator|!=
literal|'/'
condition|)
name|suffix_end
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|suffix_end
operator|<
name|filename
operator|)
operator|&&
operator|(
operator|*
name|suffix_end
operator|==
literal|'/'
operator|)
condition|)
name|suffix_end
operator|++
expr_stmt|;
comment|/* Step 4: Build the new name. */
comment|/* The OpenBSD strlcpy function is safer, but less portable. */
comment|/* Rather than maintain two versions, just use the strncpy version. */
name|p
operator|=
name|dest
expr_stmt|;
if|if
condition|(
name|prefix_end
operator|>
name|prefix
condition|)
block|{
name|strncpy
argument_list|(
name|p
argument_list|,
name|prefix
argument_list|,
name|prefix_end
operator|-
name|prefix
argument_list|)
expr_stmt|;
name|p
operator|+=
name|prefix_end
operator|-
name|prefix
expr_stmt|;
block|}
if|if
condition|(
name|suffix_end
operator|>
name|suffix
condition|)
block|{
name|strncpy
argument_list|(
name|p
argument_list|,
name|suffix
argument_list|,
name|suffix_end
operator|-
name|suffix
argument_list|)
expr_stmt|;
name|p
operator|+=
name|suffix_end
operator|-
name|suffix
expr_stmt|;
block|}
if|if
condition|(
name|insert
operator|!=
name|NULL
condition|)
block|{
comment|/* Note: assume insert does not have leading or trailing '/' */
name|strcpy
argument_list|(
name|p
argument_list|,
name|insert
argument_list|)
expr_stmt|;
name|p
operator|+=
name|strlen
argument_list|(
name|insert
argument_list|)
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'/'
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|p
argument_list|,
name|filename
argument_list|,
name|filename_end
operator|-
name|filename
argument_list|)
expr_stmt|;
name|p
operator|+=
name|filename_end
operator|-
name|filename
expr_stmt|;
if|if
condition|(
name|need_slash
condition|)
operator|*
name|p
operator|++
operator|=
literal|'/'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|dest
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The ustar header for the pax extended attributes must have a  * reasonable name:  SUSv3 requires 'dirname'/PaxHeader.'pid'/'filename'  * where 'pid' is the PID of the archiving process.  Unfortunately,  * that makes testing a pain since the output varies for each run,  * so I'm sticking with the simpler 'dirname'/PaxHeader/'filename'  * for now.  (Someday, I'll make this settable.  Then I can use the  * SUS recommendation as default and test harnesses can override it  * to get predictable results.)  *  * Joerg Schilling has argued that this is unnecessary because, in  * practice, if the pax extended attributes get extracted as regular  * files, noone is going to bother reading those attributes to  * manually restore them.  Based on this, 'star' uses  * /tmp/PaxHeader/'basename' as the ustar header name.  This is a  * tempting argument, in part because it's simpler than the SUSv3  * recommendation, but I'm not entirely convinced.  I'm also  * uncomfortable with the fact that "/tmp" is a Unix-ism.  *  * The following routine leverages build_ustar_entry_name() above and  * so is simpler than you might think.  It just needs to provide the  * additional path element and handle a few pathological cases).  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|build_pax_attribute_name
parameter_list|(
name|char
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
name|char
name|buff
index|[
literal|64
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Handle the null filename case. */
if|if
condition|(
name|src
operator|==
name|NULL
operator|||
operator|*
name|src
operator|==
literal|'\0'
condition|)
block|{
name|strcpy
argument_list|(
name|dest
argument_list|,
literal|"PaxHeader/blank"
argument_list|)
expr_stmt|;
return|return
operator|(
name|dest
operator|)
return|;
block|}
comment|/* Prune final '/' and other unwanted final elements. */
name|p
operator|=
name|src
operator|+
name|strlen
argument_list|(
name|src
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Ends in "/", remove the '/' */
if|if
condition|(
name|p
operator|>
name|src
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
operator|--
name|p
expr_stmt|;
continue|continue;
block|}
comment|/* Ends in "/.", remove the '.' */
if|if
condition|(
name|p
operator|>
name|src
operator|+
literal|1
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
operator|-
literal|2
index|]
operator|==
literal|'/'
condition|)
block|{
operator|--
name|p
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
comment|/* Pathological case: After above, there was nothing left. 	 * This includes "/." "/./." "/.//./." etc. */
if|if
condition|(
name|p
operator|==
name|src
condition|)
block|{
name|strcpy
argument_list|(
name|dest
argument_list|,
literal|"/PaxHeader/rootdir"
argument_list|)
expr_stmt|;
return|return
operator|(
name|dest
operator|)
return|;
block|}
comment|/* Convert unadorned "." into a suitable filename. */
if|if
condition|(
operator|*
name|src
operator|==
literal|'.'
operator|&&
name|p
operator|==
name|src
operator|+
literal|1
condition|)
block|{
name|strcpy
argument_list|(
name|dest
argument_list|,
literal|"PaxHeader/currentdir"
argument_list|)
expr_stmt|;
return|return
operator|(
name|dest
operator|)
return|;
block|}
comment|/* 	 * TODO: Push this string into the 'pax' structure to avoid 	 * recomputing it every time.  That will also open the door 	 * to having clients override it. 	 */
if|#
directive|if
name|HAVE_GETPID
operator|&&
literal|0
comment|/* Disable this for now; see above comment. */
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"PaxHeader.%d"
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* If the platform can't fetch the pid, don't include it. */
name|strcpy
argument_list|(
name|buff
argument_list|,
literal|"PaxHeader"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* General case: build a ustar-compatible name adding "/PaxHeader/". */
name|build_ustar_entry_name
argument_list|(
name|dest
argument_list|,
name|src
argument_list|,
name|p
operator|-
name|src
argument_list|,
name|buff
argument_list|)
expr_stmt|;
return|return
operator|(
name|dest
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Write two null blocks for the end of archive */
end_comment

begin_function
specifier|static
name|int
name|archive_write_pax_finish
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|pax
modifier|*
name|pax
decl_stmt|;
name|int
name|r
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|compressor
operator|.
name|write
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
name|pax
operator|=
operator|(
expr|struct
name|pax
operator|*
operator|)
name|a
operator|->
name|format_data
expr_stmt|;
name|r
operator|=
name|write_nulls
argument_list|(
name|a
argument_list|,
literal|512
operator|*
literal|2
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_write_pax_destroy
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|pax
modifier|*
name|pax
decl_stmt|;
name|pax
operator|=
operator|(
expr|struct
name|pax
operator|*
operator|)
name|a
operator|->
name|format_data
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|pax
operator|->
name|pax_header
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pax
argument_list|)
expr_stmt|;
name|a
operator|->
name|format_data
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_write_pax_finish_entry
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|pax
modifier|*
name|pax
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|pax
operator|=
operator|(
expr|struct
name|pax
operator|*
operator|)
name|a
operator|->
name|format_data
expr_stmt|;
name|ret
operator|=
name|write_nulls
argument_list|(
name|a
argument_list|,
name|pax
operator|->
name|entry_bytes_remaining
operator|+
name|pax
operator|->
name|entry_padding
argument_list|)
expr_stmt|;
name|pax
operator|->
name|entry_bytes_remaining
operator|=
name|pax
operator|->
name|entry_padding
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|write_nulls
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|size_t
name|padding
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|to_write
decl_stmt|;
while|while
condition|(
name|padding
operator|>
literal|0
condition|)
block|{
name|to_write
operator|=
name|padding
operator|<
name|a
operator|->
name|null_length
condition|?
name|padding
else|:
name|a
operator|->
name|null_length
expr_stmt|;
name|ret
operator|=
call|(
name|a
operator|->
name|compressor
operator|.
name|write
call|)
argument_list|(
name|a
argument_list|,
name|a
operator|->
name|nulls
argument_list|,
name|to_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|padding
operator|-=
name|to_write
expr_stmt|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|archive_write_pax_data
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|buff
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
name|struct
name|pax
modifier|*
name|pax
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|pax
operator|=
operator|(
expr|struct
name|pax
operator|*
operator|)
name|a
operator|->
name|format_data
expr_stmt|;
if|if
condition|(
name|s
operator|>
name|pax
operator|->
name|entry_bytes_remaining
condition|)
name|s
operator|=
name|pax
operator|->
name|entry_bytes_remaining
expr_stmt|;
name|ret
operator|=
call|(
name|a
operator|->
name|compressor
operator|.
name|write
call|)
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|pax
operator|->
name|entry_bytes_remaining
operator|-=
name|s
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|s
operator|)
return|;
else|else
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|has_non_ASCII
parameter_list|(
specifier|const
name|wchar_t
modifier|*
name|wp
parameter_list|)
block|{
while|while
condition|(
operator|*
name|wp
operator|!=
literal|L'
expr|\0'
operator|&&
operator|*
name|wp
operator|<
literal|128
condition|)
name|wp
operator|++
expr_stmt|;
return|return
operator|(
operator|*
name|wp
operator|!=
literal|L'
expr|\0'
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Used by extended attribute support; encodes the name  * so that there will be no '=' characters in the result.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|url_encode
parameter_list|(
specifier|const
name|char
modifier|*
name|in
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|d
decl_stmt|;
name|int
name|out_len
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|out
decl_stmt|;
for|for
control|(
name|s
operator|=
name|in
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|<
literal|33
operator|||
operator|*
name|s
operator|>
literal|126
operator|||
operator|*
name|s
operator|==
literal|'%'
operator|||
operator|*
name|s
operator|==
literal|'='
condition|)
name|out_len
operator|+=
literal|3
expr_stmt|;
else|else
name|out_len
operator|++
expr_stmt|;
block|}
name|out
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|out_len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|s
operator|=
name|in
operator|,
name|d
operator|=
name|out
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|++
control|)
block|{
comment|/* encode any non-printable ASCII character or '%' or '=' */
if|if
condition|(
operator|*
name|s
operator|<
literal|33
operator|||
operator|*
name|s
operator|>
literal|126
operator|||
operator|*
name|s
operator|==
literal|'%'
operator|||
operator|*
name|s
operator|==
literal|'='
condition|)
block|{
comment|/* URL encoding is '%' followed by two hex digits */
operator|*
name|d
operator|++
operator|=
literal|'%'
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|"0123456789ABCDEF"
index|[
literal|0x0f
operator|&
operator|(
operator|*
name|s
operator|>>
literal|4
operator|)
index|]
expr_stmt|;
operator|*
name|d
operator|++
operator|=
literal|"0123456789ABCDEF"
index|[
literal|0x0f
operator|&
operator|*
name|s
index|]
expr_stmt|;
block|}
else|else
block|{
operator|*
name|d
operator|++
operator|=
operator|*
name|s
expr_stmt|;
block|}
block|}
operator|*
name|d
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|out
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Encode a sequence of bytes into a C string using base-64 encoding.  *  * Returns a null-terminated C string allocated with malloc(); caller  * is responsible for freeing the result.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|base64_encode
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|digits
index|[
literal|64
index|]
init|=
block|{
literal|'A'
block|,
literal|'B'
block|,
literal|'C'
block|,
literal|'D'
block|,
literal|'E'
block|,
literal|'F'
block|,
literal|'G'
block|,
literal|'H'
block|,
literal|'I'
block|,
literal|'J'
block|,
literal|'K'
block|,
literal|'L'
block|,
literal|'M'
block|,
literal|'N'
block|,
literal|'O'
block|,
literal|'P'
block|,
literal|'Q'
block|,
literal|'R'
block|,
literal|'S'
block|,
literal|'T'
block|,
literal|'U'
block|,
literal|'V'
block|,
literal|'W'
block|,
literal|'X'
block|,
literal|'Y'
block|,
literal|'Z'
block|,
literal|'a'
block|,
literal|'b'
block|,
literal|'c'
block|,
literal|'d'
block|,
literal|'e'
block|,
literal|'f'
block|,
literal|'g'
block|,
literal|'h'
block|,
literal|'i'
block|,
literal|'j'
block|,
literal|'k'
block|,
literal|'l'
block|,
literal|'m'
block|,
literal|'n'
block|,
literal|'o'
block|,
literal|'p'
block|,
literal|'q'
block|,
literal|'r'
block|,
literal|'s'
block|,
literal|'t'
block|,
literal|'u'
block|,
literal|'v'
block|,
literal|'w'
block|,
literal|'x'
block|,
literal|'y'
block|,
literal|'z'
block|,
literal|'0'
block|,
literal|'1'
block|,
literal|'2'
block|,
literal|'3'
block|,
literal|'4'
block|,
literal|'5'
block|,
literal|'6'
block|,
literal|'7'
block|,
literal|'8'
block|,
literal|'9'
block|,
literal|'+'
block|,
literal|'/'
block|}
decl_stmt|;
name|int
name|v
decl_stmt|;
name|char
modifier|*
name|d
decl_stmt|,
modifier|*
name|out
decl_stmt|;
comment|/* 3 bytes becomes 4 chars, but round up and allow for trailing NUL */
name|out
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|len
operator|*
literal|4
operator|+
literal|2
operator|)
operator|/
literal|3
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|d
operator|=
name|out
expr_stmt|;
comment|/* Convert each group of 3 bytes into 4 characters. */
while|while
condition|(
name|len
operator|>=
literal|3
condition|)
block|{
name|v
operator|=
operator|(
operator|(
operator|(
name|int
operator|)
name|s
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator|&
literal|0xff0000
operator|)
operator||
operator|(
operator|(
operator|(
name|int
operator|)
name|s
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|&
literal|0xff00
operator|)
operator||
operator|(
operator|(
operator|(
name|int
operator|)
name|s
index|[
literal|2
index|]
operator|)
operator|&
literal|0x00ff
operator|)
expr_stmt|;
name|s
operator|+=
literal|3
expr_stmt|;
name|len
operator|-=
literal|3
expr_stmt|;
operator|*
name|d
operator|++
operator|=
name|digits
index|[
operator|(
name|v
operator|>>
literal|18
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
operator|*
name|d
operator|++
operator|=
name|digits
index|[
operator|(
name|v
operator|>>
literal|12
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
operator|*
name|d
operator|++
operator|=
name|digits
index|[
operator|(
name|v
operator|>>
literal|6
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
operator|*
name|d
operator|++
operator|=
name|digits
index|[
operator|(
name|v
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
block|}
comment|/* Handle final group of 1 byte (2 chars) or 2 bytes (3 chars). */
switch|switch
condition|(
name|len
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
name|v
operator|=
operator|(
operator|(
operator|(
name|int
operator|)
name|s
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator|&
literal|0xff0000
operator|)
expr_stmt|;
operator|*
name|d
operator|++
operator|=
name|digits
index|[
operator|(
name|v
operator|>>
literal|18
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
operator|*
name|d
operator|++
operator|=
name|digits
index|[
operator|(
name|v
operator|>>
literal|12
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|v
operator|=
operator|(
operator|(
operator|(
name|int
operator|)
name|s
index|[
literal|0
index|]
operator|<<
literal|16
operator|)
operator|&
literal|0xff0000
operator|)
operator||
operator|(
operator|(
operator|(
name|int
operator|)
name|s
index|[
literal|1
index|]
operator|<<
literal|8
operator|)
operator|&
literal|0xff00
operator|)
expr_stmt|;
operator|*
name|d
operator|++
operator|=
name|digits
index|[
operator|(
name|v
operator|>>
literal|18
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
operator|*
name|d
operator|++
operator|=
name|digits
index|[
operator|(
name|v
operator|>>
literal|12
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
operator|*
name|d
operator|++
operator|=
name|digits
index|[
operator|(
name|v
operator|>>
literal|6
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
break|break;
block|}
comment|/* Add trailing NUL character so output is a valid C string. */
operator|*
name|d
operator|++
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|out
operator|)
return|;
block|}
end_function

end_unit

