begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2004 Tim Kientzle  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer  *    in this position and unchanged.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"archive_platform.h"
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<wchar.h>
end_include

begin_include
include|#
directive|include
file|"archive.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry.h"
end_include

begin_include
include|#
directive|include
file|"archive_private.h"
end_include

begin_struct
struct|struct
name|pax
block|{
name|uint64_t
name|entry_bytes_remaining
decl_stmt|;
name|uint64_t
name|entry_padding
decl_stmt|;
name|struct
name|archive_string
name|pax_header
decl_stmt|;
name|char
name|written
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|add_pax_attr
parameter_list|(
name|struct
name|archive_string
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_pax_attr_int
parameter_list|(
name|struct
name|archive_string
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|int64_t
name|value
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_pax_attr_time
parameter_list|(
name|struct
name|archive_string
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|int64_t
name|sec
parameter_list|,
name|unsigned
name|long
name|nanos
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_pax_attr_w
parameter_list|(
name|struct
name|archive_string
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|wvalue
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_write_pax_data
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_write_pax_finish
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_write_pax_finish_entry
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_write_pax_header
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|build_pax_attribute_name
parameter_list|(
specifier|const
name|char
modifier|*
name|abbreviated
parameter_list|,
name|struct
name|archive_string
modifier|*
name|work
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|build_ustar_entry_name
parameter_list|(
name|char
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|format_int
parameter_list|(
name|char
modifier|*
name|dest
parameter_list|,
name|int64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|write_nulls
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Set output format to 'restricted pax' format.  *  * This is the same as normal 'pax', but tries to suppress  * the pax header whenever possible.  This is the default for  * bsdtar, for instance.  */
end_comment

begin_function
name|int
name|archive_write_set_format_pax_restricted
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|r
operator|=
name|archive_write_set_format_pax
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|a
operator|->
name|archive_format
operator|=
name|ARCHIVE_FORMAT_TAR_PAX_RESTRICTED
expr_stmt|;
name|a
operator|->
name|archive_format_name
operator|=
literal|"restricted POSIX pax interchange"
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set output format to 'pax' format.  */
end_comment

begin_function
name|int
name|archive_write_set_format_pax
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|pax
modifier|*
name|pax
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|format_finish
operator|!=
name|NULL
condition|)
call|(
name|a
operator|->
name|format_finish
call|)
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|pax
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|pax
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pax
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate pax data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|memset
argument_list|(
name|pax
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pax
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|->
name|format_data
operator|=
name|pax
expr_stmt|;
name|a
operator|->
name|pad_uncompressed
operator|=
literal|1
expr_stmt|;
name|a
operator|->
name|format_write_header
operator|=
name|archive_write_pax_header
expr_stmt|;
name|a
operator|->
name|format_write_data
operator|=
name|archive_write_pax_data
expr_stmt|;
name|a
operator|->
name|format_finish
operator|=
name|archive_write_pax_finish
expr_stmt|;
name|a
operator|->
name|format_finish_entry
operator|=
name|archive_write_pax_finish_entry
expr_stmt|;
name|a
operator|->
name|archive_format
operator|=
name|ARCHIVE_FORMAT_TAR_PAX_INTERCHANGE
expr_stmt|;
name|a
operator|->
name|archive_format_name
operator|=
literal|"POSIX pax interchange"
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Note: This code assumes that 'nanos' has the same sign as 'sec',  * which implies that sec=-1, nanos=200000000 represents -1.2 seconds  * and not -0.8 seconds.  This is a pretty pedantic point, as we're  * unlikely to encounter many real files created before Jan 1, 1970,  * much less ones with timestamps recorded to sub-second resolution.  */
end_comment

begin_function
specifier|static
name|void
name|add_pax_attr_time
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|int64_t
name|sec
parameter_list|,
name|unsigned
name|long
name|nanos
parameter_list|)
block|{
name|int
name|digit
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|t
decl_stmt|;
comment|/* 	 * Note that each byte contributes fewer than 3 base-10 	 * digits, so this will always be big enough. 	 */
name|char
name|tmp
index|[
literal|1
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|sec
argument_list|)
operator|+
literal|1
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|nanos
argument_list|)
index|]
decl_stmt|;
name|tmp
index|[
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|tmp
operator|+
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* Skip trailing zeros in the fractional part. */
for|for
control|(
name|digit
operator|=
literal|0
operator|,
name|i
operator|=
literal|10
init|;
name|i
operator|>
literal|0
operator|&&
name|digit
operator|==
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|digit
operator|=
name|nanos
operator|%
literal|10
expr_stmt|;
name|nanos
operator|/=
literal|10
expr_stmt|;
block|}
comment|/* Only format the fraction if it's non-zero. */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
operator|*
operator|--
name|t
operator|=
literal|"0123456789"
index|[
name|digit
index|]
expr_stmt|;
name|digit
operator|=
name|nanos
operator|%
literal|10
expr_stmt|;
name|nanos
operator|/=
literal|10
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
operator|*
operator|--
name|t
operator|=
literal|'.'
expr_stmt|;
block|}
name|t
operator|=
name|format_int
argument_list|(
name|t
argument_list|,
name|sec
argument_list|)
expr_stmt|;
name|add_pax_attr
argument_list|(
name|as
argument_list|,
name|key
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|format_int
parameter_list|(
name|char
modifier|*
name|t
parameter_list|,
name|int64_t
name|i
parameter_list|)
block|{
name|int
name|sign
decl_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|sign
operator|=
operator|-
literal|1
expr_stmt|;
name|i
operator|=
operator|-
name|i
expr_stmt|;
block|}
else|else
name|sign
operator|=
literal|1
expr_stmt|;
do|do
block|{
operator|*
operator|--
name|t
operator|=
literal|"0123456789"
index|[
name|i
operator|%
literal|10
index|]
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|/=
literal|10
condition|)
do|;
if|if
condition|(
name|sign
operator|<
literal|0
condition|)
operator|*
operator|--
name|t
operator|=
literal|'-'
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_pax_attr_int
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|int64_t
name|value
parameter_list|)
block|{
name|char
name|tmp
index|[
literal|1
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|value
argument_list|)
index|]
decl_stmt|;
name|tmp
index|[
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|add_pax_attr
argument_list|(
name|as
argument_list|,
name|key
argument_list|,
name|format_int
argument_list|(
name|tmp
operator|+
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
operator|-
literal|1
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_pax_attr_w
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|wchar_t
modifier|*
name|wval
parameter_list|)
block|{
name|int
name|utf8len
decl_stmt|;
specifier|const
name|wchar_t
modifier|*
name|wp
decl_stmt|;
name|wchar_t
name|wc
decl_stmt|;
name|char
modifier|*
name|utf8_value
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|utf8len
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|wp
operator|=
name|wval
init|;
operator|*
name|wp
operator|!=
literal|L'
expr|\0'
condition|;
control|)
block|{
name|wc
operator|=
operator|*
name|wp
operator|++
expr_stmt|;
if|if
condition|(
name|wc
operator|<=
literal|0
condition|)
block|{
comment|/* Ignore negative values. */
block|}
elseif|else
if|if
condition|(
name|wc
operator|<=
literal|0x7f
condition|)
name|utf8len
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|wc
operator|<=
literal|0x7ff
condition|)
name|utf8len
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|wc
operator|<=
literal|0xffff
condition|)
name|utf8len
operator|+=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|wc
operator|<=
literal|0x1fffff
condition|)
name|utf8len
operator|+=
literal|4
expr_stmt|;
elseif|else
if|if
condition|(
name|wc
operator|<=
literal|0x3ffffff
condition|)
name|utf8len
operator|+=
literal|5
expr_stmt|;
else|else
name|utf8len
operator|+=
literal|6
expr_stmt|;
block|}
name|utf8_value
operator|=
name|malloc
argument_list|(
name|utf8len
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|wp
operator|=
name|wval
operator|,
name|p
operator|=
name|utf8_value
init|;
operator|*
name|wp
operator|!=
literal|L'
expr|\0'
condition|;
control|)
block|{
name|wc
operator|=
operator|*
name|wp
operator|++
expr_stmt|;
if|if
condition|(
name|wc
operator|<=
literal|0
condition|)
block|{
comment|/* Ignore negative values. */
block|}
elseif|else
if|if
condition|(
name|wc
operator|<=
literal|0x7f
condition|)
block|{
operator|*
name|p
operator|++
operator|=
operator|(
name|char
operator|)
name|wc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wc
operator|<=
literal|0x7ff
condition|)
block|{
name|p
index|[
literal|0
index|]
operator|=
literal|0xc0
operator||
operator|(
operator|(
name|wc
operator|>>
literal|6
operator|)
operator|&
literal|0x1f
operator|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|0x80
operator||
operator|(
name|wc
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wc
operator|<=
literal|0xffff
condition|)
block|{
name|p
index|[
literal|0
index|]
operator|=
literal|0xe0
operator||
operator|(
operator|(
name|wc
operator|>>
literal|12
operator|)
operator|&
literal|0x0f
operator|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|0x80
operator||
operator|(
operator|(
name|wc
operator|>>
literal|6
operator|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
literal|0x80
operator||
operator|(
name|wc
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|p
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wc
operator|<=
literal|0x1fffff
condition|)
block|{
name|p
index|[
literal|0
index|]
operator|=
literal|0xf0
operator||
operator|(
operator|(
name|wc
operator|>>
literal|18
operator|)
operator|&
literal|0x07
operator|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|0x80
operator||
operator|(
operator|(
name|wc
operator|>>
literal|12
operator|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
literal|0x80
operator||
operator|(
operator|(
name|wc
operator|>>
literal|6
operator|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
literal|0x80
operator||
operator|(
name|wc
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|p
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wc
operator|<=
literal|0x3ffffff
condition|)
block|{
name|p
index|[
literal|0
index|]
operator|=
literal|0xf8
operator||
operator|(
operator|(
name|wc
operator|>>
literal|24
operator|)
operator|&
literal|0x03
operator|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|0x80
operator||
operator|(
operator|(
name|wc
operator|>>
literal|18
operator|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
literal|0x80
operator||
operator|(
operator|(
name|wc
operator|>>
literal|12
operator|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
literal|0x80
operator||
operator|(
operator|(
name|wc
operator|>>
literal|6
operator|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|p
index|[
literal|4
index|]
operator|=
literal|0x80
operator||
operator|(
name|wc
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|p
operator|+=
literal|5
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wc
operator|<=
literal|0x7fffffff
condition|)
block|{
name|p
index|[
literal|0
index|]
operator|=
literal|0xfc
operator||
operator|(
operator|(
name|wc
operator|>>
literal|30
operator|)
operator|&
literal|0x01
operator|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|0x80
operator||
operator|(
operator|(
name|wc
operator|>>
literal|24
operator|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|0x80
operator||
operator|(
operator|(
name|wc
operator|>>
literal|18
operator|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|p
index|[
literal|2
index|]
operator|=
literal|0x80
operator||
operator|(
operator|(
name|wc
operator|>>
literal|12
operator|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|p
index|[
literal|3
index|]
operator|=
literal|0x80
operator||
operator|(
operator|(
name|wc
operator|>>
literal|6
operator|)
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|p
index|[
literal|4
index|]
operator|=
literal|0x80
operator||
operator|(
name|wc
operator|&
literal|0x3f
operator|)
expr_stmt|;
name|p
operator|+=
literal|6
expr_stmt|;
block|}
block|}
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|add_pax_attr
argument_list|(
name|as
argument_list|,
name|key
argument_list|,
name|utf8_value
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|utf8_value
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a key/value attribute to the pax header.  This function handles  * the length field and various other syntactic requirements.  */
end_comment

begin_function
specifier|static
name|void
name|add_pax_attr
parameter_list|(
name|struct
name|archive_string
modifier|*
name|as
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|int
name|digits
decl_stmt|,
name|i
decl_stmt|,
name|len
decl_stmt|,
name|next_ten
decl_stmt|;
name|char
name|tmp
index|[
literal|1
operator|+
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
index|]
decl_stmt|;
comment|/*< 3 base-10 digits per byte */
comment|/*- 	 * PAX attributes have the following layout: 	 *<len><space><key><=><value><nl> 	 */
name|len
operator|=
literal|1
operator|+
name|strlen
argument_list|(
name|key
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|value
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* 	 * The<len> field includes the length of the<len> field, so 	 * computing the correct length is tricky.  I start by 	 * counting the number of base-10 digits in 'len' and 	 * computing the next higher power of 10. 	 */
name|next_ten
operator|=
literal|1
expr_stmt|;
name|digits
operator|=
literal|0
expr_stmt|;
name|i
operator|=
name|len
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|i
operator|/
literal|10
expr_stmt|;
name|digits
operator|++
expr_stmt|;
name|next_ten
operator|=
name|next_ten
operator|*
literal|10
expr_stmt|;
block|}
comment|/* 	 * For example, if string without the length field is 99 	 * chars, then adding the 2 digit length "99" will force the 	 * total length past 100, requiring an extra digit.  The next 	 * statement adjusts for this effect. 	 */
if|if
condition|(
name|len
operator|+
name|digits
operator|>=
name|next_ten
condition|)
name|digits
operator|++
expr_stmt|;
comment|/* Now, we have the right length so we can build the line. */
name|tmp
index|[
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Null-terminate the work area. */
name|archive_strcat
argument_list|(
name|as
argument_list|,
name|format_int
argument_list|(
name|tmp
operator|+
sizeof|sizeof
argument_list|(
name|tmp
argument_list|)
operator|-
literal|1
argument_list|,
name|len
operator|+
name|digits
argument_list|)
argument_list|)
expr_stmt|;
name|archive_strappend_char
argument_list|(
name|as
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|archive_strcat
argument_list|(
name|as
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|archive_strappend_char
argument_list|(
name|as
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
name|archive_strcat
argument_list|(
name|as
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|archive_strappend_char
argument_list|(
name|as
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * TODO: Consider adding 'comment' and 'charset' fields to  * archive_entry so that clients can specify them.  Also, consider  * adding generic key/value tags so clients can add arbitrary  * key/value data.  */
end_comment

begin_function
specifier|static
name|int
name|archive_write_pax_header
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry_original
parameter_list|)
block|{
name|struct
name|archive_entry
modifier|*
name|entry_main
decl_stmt|;
specifier|const
name|char
modifier|*
name|linkname
decl_stmt|,
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|hardlink
decl_stmt|;
specifier|const
name|wchar_t
modifier|*
name|wp
decl_stmt|,
modifier|*
name|wp2
decl_stmt|,
modifier|*
name|wname_start
decl_stmt|;
name|int
name|need_extension
decl_stmt|,
name|oldstate
decl_stmt|,
name|r
decl_stmt|,
name|ret
decl_stmt|;
name|struct
name|pax
modifier|*
name|pax
decl_stmt|;
specifier|const
name|struct
name|stat
modifier|*
name|st_main
decl_stmt|,
modifier|*
name|st_original
decl_stmt|;
name|struct
name|archive_string
name|pax_entry_name
decl_stmt|;
name|char
name|paxbuff
index|[
literal|512
index|]
decl_stmt|;
name|char
name|ustarbuff
index|[
literal|512
index|]
decl_stmt|;
name|char
name|ustar_entry_name
index|[
literal|256
index|]
decl_stmt|;
name|archive_string_init
argument_list|(
operator|&
name|pax_entry_name
argument_list|)
expr_stmt|;
name|need_extension
operator|=
literal|0
expr_stmt|;
name|pax
operator|=
name|a
operator|->
name|format_data
expr_stmt|;
name|pax
operator|->
name|written
operator|=
literal|1
expr_stmt|;
name|st_original
operator|=
name|archive_entry_stat
argument_list|(
name|entry_original
argument_list|)
expr_stmt|;
name|hardlink
operator|=
name|archive_entry_hardlink
argument_list|(
name|entry_original
argument_list|)
expr_stmt|;
comment|/* Make sure this is a type of entry that we can handle here */
if|if
condition|(
name|hardlink
operator|==
name|NULL
condition|)
block|{
switch|switch
condition|(
name|st_original
operator|->
name|st_mode
operator|&
name|S_IFMT
condition|)
block|{
case|case
name|S_IFREG
case|:
case|case
name|S_IFLNK
case|:
case|case
name|S_IFCHR
case|:
case|case
name|S_IFBLK
case|:
case|case
name|S_IFDIR
case|:
case|case
name|S_IFIFO
case|:
break|break;
case|case
name|S_IFSOCK
case|:
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"tar format cannot archive socket"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
default|default:
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"tar format cannot archive this"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
block|}
comment|/* Copy entry so we can modify it as needed. */
name|entry_main
operator|=
name|archive_entry_clone
argument_list|(
name|entry_original
argument_list|)
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|)
expr_stmt|;
comment|/* Blank our work area. */
name|st_main
operator|=
name|archive_entry_stat
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
comment|/* 	 * Determining whether or not the name is too big is ugly 	 * because of the rules for dividing names between 'name' and 	 * 'prefix' fields.  Here, I pick out the longest possible 	 * suffix, then test whether the remaining prefix is too long. 	 */
name|wp
operator|=
name|archive_entry_pathname_w
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
name|p
operator|=
name|archive_entry_pathname
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
if|if
condition|(
name|wcslen
argument_list|(
name|wp
argument_list|)
operator|<=
literal|100
condition|)
comment|/* Short enough for just 'name' field */
name|wname_start
operator|=
name|wp
expr_stmt|;
comment|/* Record a zero-length prefix */
else|else
comment|/* Find the largest suffix that fits in 'name' field. */
name|wname_start
operator|=
name|wcschr
argument_list|(
name|wp
operator|+
name|wcslen
argument_list|(
name|wp
argument_list|)
operator|-
literal|100
operator|-
literal|1
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/* Find non-ASCII character, if any. */
name|wp2
operator|=
name|wp
expr_stmt|;
while|while
condition|(
operator|*
name|wp2
operator|!=
literal|L'
expr|\0'
operator|&&
operator|*
name|wp2
operator|<
literal|128
condition|)
name|wp2
operator|++
expr_stmt|;
comment|/* 	 * If name is too long, or has non-ASCII characters, add 	 * 'path' to pax extended attrs. 	 */
if|if
condition|(
name|wname_start
operator|==
name|NULL
operator|||
name|wname_start
operator|-
name|wp
operator|>
literal|155
operator|||
operator|*
name|wp2
operator|!=
literal|L'
expr|\0'
condition|)
block|{
name|add_pax_attr_w
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"path"
argument_list|,
name|wp
argument_list|)
expr_stmt|;
name|archive_entry_set_pathname
argument_list|(
name|entry_main
argument_list|,
name|build_ustar_entry_name
argument_list|(
name|ustar_entry_name
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|need_extension
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If link name is too long, add 'linkpath' to pax extended attrs. */
name|linkname
operator|=
name|hardlink
expr_stmt|;
if|if
condition|(
name|linkname
operator|==
name|NULL
condition|)
name|linkname
operator|=
name|archive_entry_symlink
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
if|if
condition|(
name|linkname
operator|!=
name|NULL
operator|&&
name|strlen
argument_list|(
name|linkname
argument_list|)
operator|>
literal|100
condition|)
block|{
name|add_pax_attr
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"linkpath"
argument_list|,
name|linkname
argument_list|)
expr_stmt|;
if|if
condition|(
name|hardlink
operator|!=
name|NULL
condition|)
name|archive_entry_set_hardlink
argument_list|(
name|entry_main
argument_list|,
literal|"././@LongHardLink"
argument_list|)
expr_stmt|;
else|else
name|archive_entry_set_symlink
argument_list|(
name|entry_main
argument_list|,
literal|"././@LongSymLink"
argument_list|)
expr_stmt|;
name|need_extension
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If file size is too large, add 'size' to pax extended attrs. */
if|if
condition|(
name|st_main
operator|->
name|st_size
operator|>=
operator|(
literal|1
operator|<<
literal|30
operator|)
condition|)
block|{
name|add_pax_attr_int
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"size"
argument_list|,
name|st_main
operator|->
name|st_size
argument_list|)
expr_stmt|;
name|need_extension
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If numeric GID is too large, add 'gid' to pax extended attrs. */
if|if
condition|(
name|st_main
operator|->
name|st_gid
operator|>=
operator|(
literal|1
operator|<<
literal|20
operator|)
condition|)
block|{
name|add_pax_attr_int
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"gid"
argument_list|,
name|st_main
operator|->
name|st_gid
argument_list|)
expr_stmt|;
name|need_extension
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If group name is too large, add 'gname' to pax extended attrs. */
comment|/* TODO: If gname has non-ASCII characters, use pax attribute. */
name|p
operator|=
name|archive_entry_gname
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|strlen
argument_list|(
name|p
argument_list|)
operator|>
literal|31
condition|)
block|{
name|add_pax_attr
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"gname"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|archive_entry_set_gname
argument_list|(
name|entry_main
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|need_extension
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If numeric UID is too large, add 'uid' to pax extended attrs. */
if|if
condition|(
name|st_main
operator|->
name|st_uid
operator|>=
operator|(
literal|1
operator|<<
literal|20
operator|)
condition|)
block|{
name|add_pax_attr_int
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"uid"
argument_list|,
name|st_main
operator|->
name|st_uid
argument_list|)
expr_stmt|;
name|need_extension
operator|=
literal|1
expr_stmt|;
block|}
comment|/* If user name is too large, add 'uname' to pax extended attrs. */
comment|/* TODO: If uname has non-ASCII characters, use pax attribute. */
name|p
operator|=
name|archive_entry_uname
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
name|strlen
argument_list|(
name|p
argument_list|)
operator|>
literal|31
condition|)
block|{
name|add_pax_attr
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"uname"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|archive_entry_set_uname
argument_list|(
name|entry_main
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|need_extension
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * POSIX/SUSv3 doesn't provide a standard key for large device 	 * numbers.  I use the same keys here that Joerg Schilling used for 	 * 'star.'  No doubt, other implementations use other keys.  Note that 	 * there's no reason we can't write the same information into a number 	 * of different keys. 	 * 	 * Of course, this is only needed for block or char device entries. 	 */
if|if
condition|(
name|S_ISBLK
argument_list|(
name|st_main
operator|->
name|st_mode
argument_list|)
operator|||
name|S_ISCHR
argument_list|(
name|st_main
operator|->
name|st_mode
argument_list|)
condition|)
block|{
comment|/* 		 * If devmajor is too large, add 'SCHILY.devmajor' to 		 * extended attributes. 		 */
name|dev_t
name|devmajor
decl_stmt|,
name|devminor
decl_stmt|;
name|devmajor
operator|=
name|major
argument_list|(
name|st_main
operator|->
name|st_rdev
argument_list|)
expr_stmt|;
name|devminor
operator|=
name|minor
argument_list|(
name|st_main
operator|->
name|st_rdev
argument_list|)
expr_stmt|;
if|if
condition|(
name|devmajor
operator|>=
operator|(
literal|1
operator|<<
literal|18
operator|)
condition|)
block|{
name|add_pax_attr_int
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"SCHILY.devmajor"
argument_list|,
name|devmajor
argument_list|)
expr_stmt|;
name|archive_entry_set_devmajor
argument_list|(
name|entry_main
argument_list|,
operator|(
literal|1
operator|<<
literal|18
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|need_extension
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 		 * If devminor is too large, add 'SCHILY.devminor' to 		 * extended attributes. 		 */
if|if
condition|(
name|devminor
operator|>=
operator|(
literal|1
operator|<<
literal|18
operator|)
condition|)
block|{
name|add_pax_attr_int
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"SCHILY.devminor"
argument_list|,
name|devminor
argument_list|)
expr_stmt|;
name|archive_entry_set_devminor
argument_list|(
name|entry_main
argument_list|,
operator|(
literal|1
operator|<<
literal|18
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|need_extension
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* 	 * Technically, the mtime field in the ustar header can 	 * support 33 bits, but many platforms use signed 32-bit time 	 * values.  The cutoff of 0x7fffffff here is a compromise. 	 * Yes, this check is duplicated just below; this helps to 	 * avoid writing an mtime attribute just to handle a 	 * high-resolution timestamp in "restricted pax" mode. 	 */
if|if
condition|(
operator|!
name|need_extension
operator|&&
operator|(
operator|(
name|st_main
operator|->
name|st_mtime
operator|<
literal|0
operator|)
operator|||
operator|(
name|st_main
operator|->
name|st_mtime
operator|>=
literal|0x7fffffff
operator|)
operator|)
condition|)
name|need_extension
operator|=
literal|1
expr_stmt|;
comment|/* I use a star-compatible file flag attribute. */
name|p
operator|=
name|archive_entry_fflags_text
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|need_extension
operator|&&
name|p
operator|!=
name|NULL
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
name|need_extension
operator|=
literal|1
expr_stmt|;
comment|/* If there are non-trivial ACL entries, we need an extension. */
if|if
condition|(
operator|!
name|need_extension
operator|&&
name|archive_entry_acl_count
argument_list|(
name|entry_original
argument_list|,
name|ARCHIVE_ENTRY_ACL_TYPE_ACCESS
argument_list|)
operator|>
literal|0
condition|)
name|need_extension
operator|=
literal|1
expr_stmt|;
comment|/* If there are non-trivial ACL entries, we need an extension. */
if|if
condition|(
operator|!
name|need_extension
operator|&&
name|archive_entry_acl_count
argument_list|(
name|entry_original
argument_list|,
name|ARCHIVE_ENTRY_ACL_TYPE_DEFAULT
argument_list|)
operator|>
literal|0
condition|)
name|need_extension
operator|=
literal|1
expr_stmt|;
comment|/* 	 * The following items are handled differently in "pax 	 * restricted" format.  In particular, in "pax restricted" 	 * format they won't be added unless need_extension is 	 * already set (we're already generated an extended header, so 	 * may as well include these). 	 */
if|if
condition|(
name|a
operator|->
name|archive_format
operator|!=
name|ARCHIVE_FORMAT_TAR_PAX_RESTRICTED
operator|||
name|need_extension
condition|)
block|{
if|if
condition|(
name|st_main
operator|->
name|st_mtime
operator|<
literal|0
operator|||
name|st_main
operator|->
name|st_mtime
operator|>=
literal|0x7fffffff
operator|||
name|ARCHIVE_STAT_MTIME_NANOS
argument_list|(
name|st_main
argument_list|)
operator|!=
literal|0
condition|)
name|add_pax_attr_time
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"mtime"
argument_list|,
name|st_main
operator|->
name|st_mtime
argument_list|,
name|ARCHIVE_STAT_MTIME_NANOS
argument_list|(
name|st_main
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|st_main
operator|->
name|st_ctime
operator|!=
literal|0
operator|||
name|ARCHIVE_STAT_CTIME_NANOS
argument_list|(
name|st_main
argument_list|)
operator|!=
literal|0
condition|)
name|add_pax_attr_time
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"ctime"
argument_list|,
name|st_main
operator|->
name|st_ctime
argument_list|,
name|ARCHIVE_STAT_CTIME_NANOS
argument_list|(
name|st_main
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|st_main
operator|->
name|st_atime
operator|!=
literal|0
operator|||
name|ARCHIVE_STAT_ATIME_NANOS
argument_list|(
name|st_main
argument_list|)
operator|!=
literal|0
condition|)
name|add_pax_attr_time
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"atime"
argument_list|,
name|st_main
operator|->
name|st_atime
argument_list|,
name|ARCHIVE_STAT_ATIME_NANOS
argument_list|(
name|st_main
argument_list|)
argument_list|)
expr_stmt|;
comment|/* I use a star-compatible file flag attribute. */
name|p
operator|=
name|archive_entry_fflags_text
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
operator|&&
operator|*
name|p
operator|!=
literal|'\0'
condition|)
name|add_pax_attr
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"SCHILY.fflags"
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* I use star-compatible ACL attributes. */
name|wp
operator|=
name|archive_entry_acl_text_w
argument_list|(
name|entry_original
argument_list|,
name|ARCHIVE_ENTRY_ACL_TYPE_ACCESS
operator||
name|ARCHIVE_ENTRY_ACL_STYLE_EXTRA_ID
argument_list|)
expr_stmt|;
if|if
condition|(
name|wp
operator|!=
name|NULL
operator|&&
operator|*
name|wp
operator|!=
literal|L'
expr|\0'
condition|)
name|add_pax_attr_w
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"SCHILY.acl.access"
argument_list|,
name|wp
argument_list|)
expr_stmt|;
name|wp
operator|=
name|archive_entry_acl_text_w
argument_list|(
name|entry_original
argument_list|,
name|ARCHIVE_ENTRY_ACL_TYPE_DEFAULT
operator||
name|ARCHIVE_ENTRY_ACL_STYLE_EXTRA_ID
argument_list|)
expr_stmt|;
if|if
condition|(
name|wp
operator|!=
name|NULL
operator|&&
operator|*
name|wp
operator|!=
literal|L'
expr|\0'
condition|)
name|add_pax_attr_w
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"SCHILY.acl.default"
argument_list|,
name|wp
argument_list|)
expr_stmt|;
comment|/* Include star-compatible metadata info. */
name|add_pax_attr_int
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"SCHILY.dev"
argument_list|,
name|st_main
operator|->
name|st_dev
argument_list|)
expr_stmt|;
name|add_pax_attr_int
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"SCHILY.ino"
argument_list|,
name|st_main
operator|->
name|st_ino
argument_list|)
expr_stmt|;
name|add_pax_attr_int
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|,
literal|"SCHILY.nlink"
argument_list|,
name|st_main
operator|->
name|st_nlink
argument_list|)
expr_stmt|;
block|}
comment|/* Only regular files have data. */
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|archive_entry_mode
argument_list|(
name|entry_main
argument_list|)
argument_list|)
condition|)
name|archive_entry_set_size
argument_list|(
name|entry_main
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Pax-restricted does not store data for hardlinks, in order 	 * to improve compatibility with ustar. 	 */
if|if
condition|(
name|a
operator|->
name|archive_format
operator|!=
name|ARCHIVE_FORMAT_TAR_PAX_INTERCHANGE
operator|&&
name|hardlink
operator|!=
name|NULL
condition|)
name|archive_entry_set_size
argument_list|(
name|entry_main
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * XXX Full pax interchange format does permit a hardlink 	 * entry to have data associated with it.  I'm not supporting 	 * that here because the client expects me to tell them whether 	 * or not this format expects data for hardlinks.  If I 	 * don't check here, then every pax archive will end up with 	 * duplicated data for hardlinks.  Someday, there may be 	 * need to select this behavior, in which case the following 	 * will need to be revisited. XXX 	 */
if|if
condition|(
name|hardlink
operator|!=
name|NULL
condition|)
name|archive_entry_set_size
argument_list|(
name|entry_main
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Format 'ustar' header for main entry. */
comment|/* We don't care if this returns an error. */
name|__archive_write_format_header_ustar
argument_list|(
name|a
argument_list|,
name|ustarbuff
argument_list|,
name|entry_main
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* If we built any extended attributes, write that entry first. */
name|ret
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|archive_strlen
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|)
operator|>
literal|0
condition|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|archive_entry
modifier|*
name|pax_attr_entry
decl_stmt|;
specifier|const
name|char
modifier|*
name|pax_attr_name
decl_stmt|;
name|memset
argument_list|(
operator|&
name|st
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|st
argument_list|)
argument_list|)
expr_stmt|;
name|pax_attr_entry
operator|=
name|archive_entry_new
argument_list|()
expr_stmt|;
name|p
operator|=
name|archive_entry_pathname
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
name|pax_attr_name
operator|=
name|build_pax_attribute_name
argument_list|(
name|p
argument_list|,
operator|&
name|pax_entry_name
argument_list|)
expr_stmt|;
name|archive_entry_set_pathname
argument_list|(
name|pax_attr_entry
argument_list|,
name|pax_attr_name
argument_list|)
expr_stmt|;
name|st
operator|.
name|st_size
operator|=
name|archive_strlen
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|)
expr_stmt|;
name|st
operator|.
name|st_uid
operator|=
name|st_main
operator|->
name|st_uid
expr_stmt|;
name|st
operator|.
name|st_gid
operator|=
name|st_main
operator|->
name|st_gid
expr_stmt|;
name|st
operator|.
name|st_mode
operator|=
name|st_main
operator|->
name|st_mode
expr_stmt|;
name|archive_entry_copy_stat
argument_list|(
name|pax_attr_entry
argument_list|,
operator|&
name|st
argument_list|)
expr_stmt|;
name|archive_entry_set_uname
argument_list|(
name|pax_attr_entry
argument_list|,
name|archive_entry_uname
argument_list|(
name|entry_main
argument_list|)
argument_list|)
expr_stmt|;
name|archive_entry_set_gname
argument_list|(
name|pax_attr_entry
argument_list|,
name|archive_entry_gname
argument_list|(
name|entry_main
argument_list|)
argument_list|)
expr_stmt|;
name|ret
operator|=
name|__archive_write_format_header_ustar
argument_list|(
name|a
argument_list|,
name|paxbuff
argument_list|,
name|pax_attr_entry
argument_list|,
literal|'x'
argument_list|)
expr_stmt|;
name|archive_entry_free
argument_list|(
name|pax_attr_entry
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|pax_entry_name
argument_list|)
expr_stmt|;
comment|/* Note that the 'x' header shouldn't ever fail to format */
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
literal|"archive_write_header_pax: "
literal|"'x' header failed?!  This can't happen.\n"
decl_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
name|msg
argument_list|,
name|strlen
argument_list|(
name|msg
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
call|(
name|a
operator|->
name|compression_write
call|)
argument_list|(
name|a
argument_list|,
name|paxbuff
argument_list|,
literal|512
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|512
condition|)
block|{
name|pax
operator|->
name|entry_bytes_remaining
operator|=
literal|0
expr_stmt|;
name|pax
operator|->
name|entry_padding
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|pax
operator|->
name|entry_bytes_remaining
operator|=
name|archive_strlen
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|)
expr_stmt|;
name|pax
operator|->
name|entry_padding
operator|=
literal|0x1ff
operator|&
operator|(
operator|-
name|pax
operator|->
name|entry_bytes_remaining
operator|)
expr_stmt|;
name|oldstate
operator|=
name|a
operator|->
name|state
expr_stmt|;
name|a
operator|->
name|state
operator|=
name|ARCHIVE_STATE_DATA
expr_stmt|;
name|r
operator|=
name|archive_write_data
argument_list|(
name|a
argument_list|,
name|pax
operator|->
name|pax_header
operator|.
name|s
argument_list|,
name|archive_strlen
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|->
name|state
operator|=
name|oldstate
expr_stmt|;
if|if
condition|(
name|r
operator|<
operator|(
name|int
operator|)
name|archive_strlen
argument_list|(
operator|&
operator|(
name|pax
operator|->
name|pax_header
operator|)
argument_list|)
condition|)
block|{
comment|/* If a write fails, we're pretty much toast. */
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|archive_write_pax_finish_entry
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
comment|/* Write the header for main entry. */
name|r
operator|=
call|(
name|a
operator|->
name|compression_write
call|)
argument_list|(
name|a
argument_list|,
name|ustarbuff
argument_list|,
literal|512
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
name|ret
operator|=
operator|(
name|r
operator|<
literal|512
operator|)
condition|?
name|ARCHIVE_FATAL
else|:
name|ARCHIVE_OK
expr_stmt|;
comment|/* 	 * Inform the client of the on-disk size we're using, so 	 * they can avoid unnecessarily writing a body for something 	 * that we're just going to ignore. 	 */
name|archive_entry_set_size
argument_list|(
name|entry_original
argument_list|,
name|archive_entry_size
argument_list|(
name|entry_main
argument_list|)
argument_list|)
expr_stmt|;
name|pax
operator|->
name|entry_bytes_remaining
operator|=
name|archive_entry_size
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
name|pax
operator|->
name|entry_padding
operator|=
literal|0x1ff
operator|&
operator|(
operator|-
name|pax
operator|->
name|entry_bytes_remaining
operator|)
expr_stmt|;
name|archive_entry_free
argument_list|(
name|entry_main
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We need a valid name for the regular 'ustar' entry.  This routine  * tries to hack something more-or-less reasonable.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|build_ustar_entry_name
parameter_list|(
name|char
modifier|*
name|dest
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|basename
decl_stmt|,
modifier|*
name|break_point
decl_stmt|,
modifier|*
name|prefix
decl_stmt|;
name|int
name|basename_length
decl_stmt|,
name|dirname_length
decl_stmt|,
name|prefix_length
decl_stmt|;
name|prefix
operator|=
name|src
expr_stmt|;
name|basename
operator|=
name|strrchr
argument_list|(
name|src
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|basename
operator|==
name|NULL
condition|)
block|{
name|basename
operator|=
name|src
expr_stmt|;
name|prefix_length
operator|=
literal|0
expr_stmt|;
name|basename_length
operator|=
name|strlen
argument_list|(
name|basename
argument_list|)
expr_stmt|;
if|if
condition|(
name|basename_length
operator|>
literal|100
condition|)
name|basename_length
operator|=
literal|100
expr_stmt|;
block|}
else|else
block|{
name|basename_length
operator|=
name|strlen
argument_list|(
name|basename
argument_list|)
expr_stmt|;
if|if
condition|(
name|basename_length
operator|>
literal|100
condition|)
name|basename_length
operator|=
literal|100
expr_stmt|;
name|dirname_length
operator|=
name|basename
operator|-
name|src
expr_stmt|;
name|break_point
operator|=
name|strchr
argument_list|(
name|src
operator|+
name|dirname_length
operator|+
name|basename_length
operator|-
literal|101
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|prefix_length
operator|=
name|break_point
operator|-
name|prefix
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|prefix_length
operator|>
literal|155
condition|)
block|{
name|prefix
operator|=
name|strchr
argument_list|(
name|prefix
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Drop 1st dir. */
name|prefix_length
operator|=
name|break_point
operator|-
name|prefix
operator|-
literal|1
expr_stmt|;
block|}
block|}
comment|/* The OpenBSD strlcpy function is safer, but less portable. */
comment|/* Rather than maintain two versions, just use the strncpy version. */
name|strncpy
argument_list|(
name|dest
argument_list|,
name|prefix
argument_list|,
name|basename
operator|-
name|prefix
operator|+
name|basename_length
argument_list|)
expr_stmt|;
name|dest
index|[
name|basename
operator|-
name|prefix
operator|+
name|basename_length
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|dest
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The ustar header for the pax extended attributes must have a  * reasonable name:  SUSv3 suggests 'dirname'/PaxHeaders/'basename'  *  * Joerg Schiling has argued that this is unnecessary because, in practice,  * if the pax extended attributes get extracted as regular files, noone is  * going to bother reading those attributes to manually restore them.  * This is a tempting argument, but I'm not entirely convinced.  *  * Of course, adding "PaxHeaders/" might force the name to be too big.  * Here, I start from the (possibly already-trimmed) name used in the  * main ustar header and delete some additional early path elements to  * fit in the extra "PaxHeader/" part.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|build_pax_attribute_name
parameter_list|(
specifier|const
name|char
modifier|*
name|abbreviated
parameter_list|,
comment|/* ustar-compat name */
name|struct
name|archive_string
modifier|*
name|work
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|basename
decl_stmt|,
modifier|*
name|break_point
decl_stmt|,
modifier|*
name|prefix
decl_stmt|;
name|int
name|prefix_length
decl_stmt|,
name|suffix_length
decl_stmt|;
comment|/* 	 * This is much simpler because I know that "abbreviated" is 	 * already small enough; I just need to determine if it needs 	 * any further trimming to fit the "PaxHeader/" portion. 	 */
comment|/* Identify the final prefix and suffix portions. */
name|prefix
operator|=
name|abbreviated
expr_stmt|;
comment|/* First guess: prefix starts at beginning */
if|if
condition|(
name|strlen
argument_list|(
name|abbreviated
argument_list|)
operator|>
literal|100
condition|)
block|{
name|break_point
operator|=
name|strchr
argument_list|(
name|prefix
operator|+
name|strlen
argument_list|(
name|prefix
argument_list|)
operator|-
literal|101
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|prefix_length
operator|=
name|break_point
operator|-
name|prefix
operator|-
literal|1
expr_stmt|;
name|suffix_length
operator|=
name|strlen
argument_list|(
name|break_point
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* 		 * The next loop keeps trimming until "/PaxHeader/" can 		 * be added to either the prefix or the suffix. 		 */
while|while
condition|(
name|prefix_length
operator|>
literal|144
operator|&&
name|suffix_length
operator|>
literal|89
condition|)
block|{
name|prefix
operator|=
name|strchr
argument_list|(
name|prefix
argument_list|,
literal|'/'
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Drop 1st dir. */
name|prefix_length
operator|=
name|break_point
operator|-
name|prefix
operator|-
literal|1
expr_stmt|;
block|}
block|}
name|archive_string_empty
argument_list|(
name|work
argument_list|)
expr_stmt|;
name|basename
operator|=
name|strrchr
argument_list|(
name|prefix
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|basename
operator|==
name|NULL
condition|)
block|{
name|archive_strcpy
argument_list|(
name|work
argument_list|,
literal|"PaxHeader/"
argument_list|)
expr_stmt|;
name|archive_strcat
argument_list|(
name|work
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|basename
operator|++
expr_stmt|;
name|archive_strncpy
argument_list|(
name|work
argument_list|,
name|prefix
argument_list|,
name|basename
operator|-
name|prefix
argument_list|)
expr_stmt|;
name|archive_strcat
argument_list|(
name|work
argument_list|,
literal|"PaxHeader/"
argument_list|)
expr_stmt|;
name|archive_strcat
argument_list|(
name|work
argument_list|,
name|basename
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|work
operator|->
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Write two null blocks for the end of archive */
end_comment

begin_function
specifier|static
name|int
name|archive_write_pax_finish
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|pax
modifier|*
name|pax
decl_stmt|;
name|int
name|r
decl_stmt|;
name|r
operator|=
name|ARCHIVE_OK
expr_stmt|;
name|pax
operator|=
name|a
operator|->
name|format_data
expr_stmt|;
if|if
condition|(
name|pax
operator|->
name|written
operator|&&
name|a
operator|->
name|compression_write
operator|!=
name|NULL
condition|)
name|r
operator|=
name|write_nulls
argument_list|(
name|a
argument_list|,
literal|512
operator|*
literal|2
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|pax
operator|->
name|pax_header
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|pax
argument_list|)
expr_stmt|;
name|a
operator|->
name|format_data
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_write_pax_finish_entry
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|pax
modifier|*
name|pax
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|pax
operator|=
name|a
operator|->
name|format_data
expr_stmt|;
name|ret
operator|=
name|write_nulls
argument_list|(
name|a
argument_list|,
name|pax
operator|->
name|entry_bytes_remaining
operator|+
name|pax
operator|->
name|entry_padding
argument_list|)
expr_stmt|;
name|pax
operator|->
name|entry_bytes_remaining
operator|=
name|pax
operator|->
name|entry_padding
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|write_nulls
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|size_t
name|padding
parameter_list|)
block|{
name|int
name|ret
decl_stmt|,
name|to_write
decl_stmt|;
while|while
condition|(
name|padding
operator|>
literal|0
condition|)
block|{
name|to_write
operator|=
name|padding
operator|<
name|a
operator|->
name|null_length
condition|?
name|padding
else|:
name|a
operator|->
name|null_length
expr_stmt|;
name|ret
operator|=
call|(
name|a
operator|->
name|compression_write
call|)
argument_list|(
name|a
argument_list|,
name|a
operator|->
name|nulls
argument_list|,
name|to_write
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<=
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
name|padding
operator|-=
name|ret
expr_stmt|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_write_pax_data
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|buff
parameter_list|,
name|size_t
name|s
parameter_list|)
block|{
name|struct
name|pax
modifier|*
name|pax
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|pax
operator|=
name|a
operator|->
name|format_data
expr_stmt|;
name|pax
operator|->
name|written
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|s
operator|>
name|pax
operator|->
name|entry_bytes_remaining
condition|)
name|s
operator|=
name|pax
operator|->
name|entry_bytes_remaining
expr_stmt|;
name|ret
operator|=
call|(
name|a
operator|->
name|compression_write
call|)
argument_list|(
name|a
argument_list|,
name|buff
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|pax
operator|->
name|entry_bytes_remaining
operator|-=
name|s
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

end_unit

