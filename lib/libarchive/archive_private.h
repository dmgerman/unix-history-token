begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2004 Tim Kientzle  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer  *    in this position and unchanged.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ARCHIVE_PRIVATE_H_INCLUDED
end_ifndef

begin_define
define|#
directive|define
name|ARCHIVE_PRIVATE_H_INCLUDED
end_define

begin_include
include|#
directive|include
file|<wchar.h>
end_include

begin_include
include|#
directive|include
file|"archive.h"
end_include

begin_include
include|#
directive|include
file|"archive_string.h"
end_include

begin_define
define|#
directive|define
name|ARCHIVE_WRITE_MAGIC
value|(0xb0c5c0deU)
end_define

begin_define
define|#
directive|define
name|ARCHIVE_READ_MAGIC
value|(0xdeb0c5U)
end_define

begin_comment
comment|/*  * This is used by archive_extract to keep track of non-writable  * directories so that they can be initially restored writable, then  * fixed up at end.  This also handles mtime/atime fixups.  */
end_comment

begin_struct_decl
struct_decl|struct
name|archive_extract_dir_entry
struct_decl|;
end_struct_decl

begin_struct
struct|struct
name|archive
block|{
comment|/* 	 * The magic/state values are used to sanity-check the 	 * client's usage.  If an API function is called at a 	 * rediculous time, or the client passes us an invalid 	 * pointer, these values allow me to catch that. 	 */
name|unsigned
name|magic
decl_stmt|;
name|unsigned
name|state
decl_stmt|;
name|struct
name|archive_entry
modifier|*
name|entry
decl_stmt|;
comment|/* Utility:  Pointer to a block of nulls. */
specifier|const
name|char
modifier|*
name|nulls
decl_stmt|;
name|size_t
name|null_length
decl_stmt|;
comment|/* 	 * Used to limit reads of entry data.   Eventually, each reader 	 * will be able to register it's own read_data routine and these 	 * will move into the per-format data for the formats that use them. 	 */
name|off_t
name|entry_bytes_remaining
decl_stmt|;
name|off_t
name|entry_padding
decl_stmt|;
comment|/* Skip this much after entry data. */
name|uid_t
name|user_uid
decl_stmt|;
comment|/* UID of current user. */
comment|/* Callbacks to open/read/write/close archive stream. */
name|archive_open_callback
modifier|*
name|client_opener
decl_stmt|;
name|archive_read_callback
modifier|*
name|client_reader
decl_stmt|;
name|archive_write_callback
modifier|*
name|client_writer
decl_stmt|;
name|archive_close_callback
modifier|*
name|client_closer
decl_stmt|;
name|void
modifier|*
name|client_data
decl_stmt|;
comment|/* 	 * Blocking information.  Note that bytes_in_last_block is 	 * misleadingly named; I should find a better name.  These 	 * control the final output from all compressors, including 	 * compression_none. 	 */
name|int
name|bytes_per_block
decl_stmt|;
name|int
name|bytes_in_last_block
decl_stmt|;
comment|/* 	 * These control whether data within a gzip/bzip2 compressed 	 * stream gets padded or not.  If pad_uncompressed is set, 	 * the data will be padded to a full block before being 	 * compressed.  The pad_uncompressed_byte determines the value 	 * that will be used for padding.  Note that these have no 	 * effect on compression "none." 	 */
name|int
name|pad_uncompressed
decl_stmt|;
name|int
name|pad_uncompressed_byte
decl_stmt|;
comment|/* TODO: Support this. */
comment|/* Position in UNCOMPRESSED data stream. */
name|off_t
name|file_position
decl_stmt|;
comment|/* Position in COMPRESSED data stream. */
name|off_t
name|raw_position
decl_stmt|;
comment|/* File offset of beginning of most recently-read header. */
name|off_t
name|header_position
decl_stmt|;
comment|/* 	 * Detection functions for decompression: bid functions are 	 * given a block of data from the beginning of the stream and 	 * can bid on whether or not they support the data stream. 	 * General guideline: bid the number of bits that you actually 	 * test, e.g., 16 if you test a 2-byte magic value.  The 	 * highest bidder will have their init function invoked, which 	 * can set up pointers to specific handlers. 	 * 	 * On write, the client just invokes an archive_write_set function 	 * which sets up the data here directly. 	 */
name|int
name|compression_code
decl_stmt|;
comment|/* Currently active compression. */
specifier|const
name|char
modifier|*
name|compression_name
decl_stmt|;
struct|struct
block|{
name|int
function_decl|(
modifier|*
name|bid
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
name|buff
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|init
function_decl|)
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
name|buff
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
block|}
name|decompressors
index|[
literal|4
index|]
struct|;
comment|/* Read/write data stream (with compression). */
name|void
modifier|*
name|compression_data
decl_stmt|;
comment|/* Data for (de)compressor. */
name|int
function_decl|(
modifier|*
name|compression_init
function_decl|)
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
comment|/* Initialize. */
name|int
function_decl|(
modifier|*
name|compression_finish
function_decl|)
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|ssize_t
function_decl|(
modifier|*
name|compression_write
function_decl|)
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
comment|/* 	 * Read uses a peek/consume I/O model: the decompression code 	 * returns a pointer to the requested block and advances the 	 * file position only when requested by a consume call.  This 	 * reduces copying and also simplifies look-ahead for format 	 * detection. 	 */
name|ssize_t
function_decl|(
modifier|*
name|compression_read_ahead
function_decl|)
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
parameter_list|,
name|size_t
name|request
parameter_list|)
function_decl|;
name|ssize_t
function_decl|(
modifier|*
name|compression_read_consume
function_decl|)
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
comment|/* 	 * Format detection is mostly the same as compression 	 * detection, with two significant differences: The bidders 	 * use the read_ahead calls above to examine the stream rather 	 * than having the supervisor hand them a block of data to 	 * examine, and the auction is repeated for every header. 	 * Winning bidders should set the archive_format and 	 * archive_format_name appropriately.  Bid routines should 	 * check archive_format and decline to bid if the format of 	 * the last header was incompatible. 	 * 	 * Again, write support is considerably simpler because there's 	 * no need for an auction. 	 */
name|int
name|archive_format
decl_stmt|;
specifier|const
name|char
modifier|*
name|archive_format_name
decl_stmt|;
struct|struct
name|archive_format_descriptor
block|{
name|int
function_decl|(
modifier|*
name|bid
function_decl|)
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|read_header
function_decl|)
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|cleanup
function_decl|)
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|format_data
decl_stmt|;
comment|/* Format-specific data for readers. */
block|}
name|formats
index|[
literal|4
index|]
struct|;
name|struct
name|archive_format_descriptor
modifier|*
name|format
decl_stmt|;
comment|/* Active format. */
comment|/* 	 * Storage for format-specific data.  Note that there can be 	 * multiple format readers active at one time, so we need to 	 * allow for multiple format readers to have their data 	 * available.  The pformat_data slot here is the solution: on 	 * read, it is gauranteed to always point to a void* variable 	 * that the format can use. 	 */
name|void
modifier|*
modifier|*
name|pformat_data
decl_stmt|;
comment|/* Pointer to current format_data. */
name|void
modifier|*
name|format_data
decl_stmt|;
comment|/* Used by writers. */
comment|/* 	 * Pointers to format-specific functions.  On read, these are 	 * initialized in the bid process.  On write, they're initialized by 	 * archive_write_set_format_XXX() calls. 	 */
name|int
function_decl|(
modifier|*
name|format_init
function_decl|)
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
comment|/* Only used on write. */
name|int
function_decl|(
modifier|*
name|format_finish
function_decl|)
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|format_finish_entry
function_decl|)
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|format_write_header
function_decl|)
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|int
function_decl|(
modifier|*
name|format_write_data
function_decl|)
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
name|buff
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
comment|/* 	 * Various information needed by archive_extract. 	 */
name|struct
name|archive_string
name|extract_mkdirpath
decl_stmt|;
name|struct
name|archive_extract_dir_entry
modifier|*
name|archive_extract_dir_list
decl_stmt|;
name|void
function_decl|(
modifier|*
name|cleanup_archive_extract
function_decl|)
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
name|int
name|archive_error_number
decl_stmt|;
specifier|const
name|char
modifier|*
name|error
decl_stmt|;
name|struct
name|archive_string
name|error_string
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Utility function to format a USTAR header into a buffer. */
end_comment

begin_function_decl
name|int
name|__archive_write_format_header_ustar
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|char
name|buff
index|[
literal|512
index|]
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
name|tartype
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|ARCHIVE_STATE_ANY
value|0xFFFFU
end_define

begin_define
define|#
directive|define
name|ARCHIVE_STATE_NEW
value|1U
end_define

begin_define
define|#
directive|define
name|ARCHIVE_STATE_HEADER
value|2U
end_define

begin_define
define|#
directive|define
name|ARCHIVE_STATE_DATA
value|4U
end_define

begin_define
define|#
directive|define
name|ARCHIVE_STATE_EOF
value|8U
end_define

begin_define
define|#
directive|define
name|ARCHIVE_STATE_CLOSED
value|0x10U
end_define

begin_define
define|#
directive|define
name|ARCHIVE_STATE_FATAL
value|0x8000U
end_define

begin_comment
comment|/* Check magic value and state; exit if it isn't valid. */
end_comment

begin_function_decl
name|void
name|__archive_check_magic
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|unsigned
name|magic
parameter_list|,
name|unsigned
name|state
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|archive_check_magic
parameter_list|(
name|a
parameter_list|,
name|m
parameter_list|,
name|s
parameter_list|)
define|\
value|__archive_check_magic((a), (m), (s), __func__)
end_define

begin_function_decl
name|int
name|__archive_read_register_format
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|void
modifier|*
name|format_data
parameter_list|,
name|int
function_decl|(
modifier|*
name|bid
function_decl|)
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
parameter_list|,
name|int
function_decl|(
modifier|*
name|read_header
function_decl|)
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
parameter_list|,
name|int
function_decl|(
modifier|*
name|cleanup
function_decl|)
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|__archive_read_register_compression
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|int
function_decl|(
modifier|*
name|bid
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
parameter_list|,
name|int
function_decl|(
modifier|*
name|init
function_decl|)
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|err_combine
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_endif
endif|#
directive|endif
end_endif

end_unit

