begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2007 Tim Kientzle  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"archive_platform.h"
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TYPES_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_ACL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/acl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ATTR_XATTR_H
end_ifdef

begin_include
include|#
directive|include
file|<attr/xattr.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_IOCTL_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_STAT_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TIME_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_EXT2FS_EXT2_FS_H
end_ifdef

begin_include
include|#
directive|include
file|<ext2fs/ext2_fs.h>
end_include

begin_comment
comment|/* for Linux file flags */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_ERRNO_H
end_ifdef

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_FCNTL_H
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GRP_H
end_ifdef

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LINUX_EXT2_FS_H
end_ifdef

begin_include
include|#
directive|include
file|<linux/ext2_fs.h>
end_include

begin_comment
comment|/* for Linux file flags */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_LIMITS_H
end_ifdef

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_PWD_H
end_ifdef

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STDLIB_H
end_ifdef

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_STRING_H
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"archive.h"
end_include

begin_include
include|#
directive|include
file|"archive_string.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry.h"
end_include

begin_include
include|#
directive|include
file|"archive_private.h"
end_include

begin_struct
struct|struct
name|fixup_entry
block|{
name|struct
name|fixup_entry
modifier|*
name|next
decl_stmt|;
name|mode_t
name|mode
decl_stmt|;
name|int64_t
name|mtime
decl_stmt|;
name|int64_t
name|atime
decl_stmt|;
name|unsigned
name|long
name|mtime_nanos
decl_stmt|;
name|unsigned
name|long
name|atime_nanos
decl_stmt|;
name|unsigned
name|long
name|fflags_set
decl_stmt|;
name|int
name|fixup
decl_stmt|;
comment|/* bitmask of what needs fixing */
name|char
modifier|*
name|name
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|FIXUP_MODE
value|1
end_define

begin_define
define|#
directive|define
name|FIXUP_TIMES
value|2
end_define

begin_define
define|#
directive|define
name|FIXUP_FFLAGS
value|4
end_define

begin_struct
struct|struct
name|bucket
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|hash
decl_stmt|;
name|id_t
name|id
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|extract
block|{
name|mode_t
name|umask
decl_stmt|;
name|mode_t
name|default_dir_mode_initial
decl_stmt|;
name|mode_t
name|default_dir_mode_final
decl_stmt|;
name|struct
name|archive_string
name|create_parent_dir
decl_stmt|;
name|struct
name|fixup_entry
modifier|*
name|fixup_list
decl_stmt|;
name|struct
name|fixup_entry
modifier|*
name|current_fixup
decl_stmt|;
name|struct
name|bucket
name|ucache
index|[
literal|127
index|]
decl_stmt|;
name|struct
name|bucket
name|gcache
index|[
literal|127
index|]
decl_stmt|;
comment|/* 	 * Cached stat data from disk for the current entry. 	 * If this is valid, pst points to st.  Otherwise, 	 * pst is null. 	 */
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|stat
modifier|*
name|pst
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Default mode for dirs created automatically (will be modified by umask). */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_DIR_MODE
value|0777
end_define

begin_comment
comment|/*  * Mode to use for newly-created dirs during extraction; the correct  * mode will be set at the end of the extraction.  */
end_comment

begin_define
define|#
directive|define
name|MINIMUM_DIR_MODE
value|0700
end_define

begin_define
define|#
directive|define
name|MAXIMUM_DIR_MODE
value|0775
end_define

begin_function_decl
specifier|static
name|int
name|archive_extract_cleanup
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|create_extract
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|extract_block_device
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|extract_char_device
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|extract_device
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
name|flags
parameter_list|,
name|mode_t
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|extract_dir
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|extract_fifo
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|extract_file
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|extract_hard_link
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|extract_symlink
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|unsigned
name|int
name|hash
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|gid_t
name|lookup_gid
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|uname
parameter_list|,
name|gid_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uid_t
name|lookup_uid
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|uname
parameter_list|,
name|uid_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|create_dir
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|create_dir_mutable
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|create_dir_recursive
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|create_parent_dir
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|create_parent_dir_mutable
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|restore_metadata
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|int
name|fd
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_POSIX_ACL
end_ifdef

begin_function_decl
specifier|static
name|int
name|set_acl
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|int
name|fd
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|acl_type_t
parameter_list|,
name|int
name|archive_entry_acl_type
parameter_list|,
specifier|const
name|char
modifier|*
name|tn
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|set_acls
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|int
name|fd
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_xattrs
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|int
name|fd
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_fflags
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|mode_t
parameter_list|,
name|unsigned
name|long
name|fflags_set
parameter_list|,
name|unsigned
name|long
name|fflags_clear
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_ownership
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|int
name|fd
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_perm
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|int
name|fd
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_time
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|int
name|fd
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|fixup_entry
modifier|*
name|sort_dir_list
parameter_list|(
name|struct
name|fixup_entry
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Extract this entry to disk.  *  * TODO: Validate hardlinks.  According to the standards, we're  * supposed to check each extracted hardlink and squawk if it refers  * to a file that we didn't restore.  I'm not entirely convinced this  * is a good idea, but more importantly: Is there any way to validate  * hardlinks without keeping a complete list of filenames from the  * entire archive?? Ugh.  *  */
end_comment

begin_function
name|int
name|archive_read_extract
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|mode_t
name|mode
decl_stmt|;
name|struct
name|extract
modifier|*
name|extract
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|restore_pwd
decl_stmt|;
name|char
modifier|*
name|original_filename
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|extract
operator|==
name|NULL
condition|)
block|{
name|ret
operator|=
name|create_extract
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|extract
operator|=
name|a
operator|->
name|extract
expr_stmt|;
name|extract
operator|->
name|pst
operator|=
name|NULL
expr_stmt|;
name|extract
operator|->
name|current_fixup
operator|=
name|NULL
expr_stmt|;
name|restore_pwd
operator|=
operator|-
literal|1
expr_stmt|;
name|original_filename
operator|=
name|NULL
expr_stmt|;
comment|/* The following is not possible without fchdir.<sigh> */
ifdef|#
directive|ifdef
name|HAVE_FCHDIR
comment|/* 	 * If pathname is longer than PATH_MAX, record starting directory 	 * and chdir to a suitable intermediate dir. 	 */
if|if
condition|(
name|strlen
argument_list|(
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
operator|>
name|PATH_MAX
condition|)
block|{
name|char
modifier|*
name|intdir
decl_stmt|,
modifier|*
name|tail
decl_stmt|;
name|restore_pwd
operator|=
name|open
argument_list|(
literal|"."
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
if|if
condition|(
name|restore_pwd
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"Unable to restore long pathname"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
comment|/* 		 * Yes, the copy here is necessary because we edit 		 * the pathname in-place to create intermediate dirnames. 		 */
name|original_filename
operator|=
name|strdup
argument_list|(
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * "intdir" points to the initial dir section we're going 		 * to remove, "tail" points to the remainder of the path. 		 */
name|intdir
operator|=
name|tail
operator|=
name|original_filename
expr_stmt|;
while|while
condition|(
name|strlen
argument_list|(
name|tail
argument_list|)
operator|>
name|PATH_MAX
condition|)
block|{
name|intdir
operator|=
name|tail
expr_stmt|;
comment|/* Locate a dir prefix shorter than PATH_MAX. */
name|tail
operator|=
name|intdir
operator|+
name|PATH_MAX
operator|-
literal|8
expr_stmt|;
while|while
condition|(
name|tail
operator|>
name|intdir
operator|&&
operator|*
name|tail
operator|!=
literal|'/'
condition|)
name|tail
operator|--
expr_stmt|;
if|if
condition|(
name|tail
operator|<=
name|intdir
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|EPERM
argument_list|,
literal|"Path element too long"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* Create intdir and chdir to it. */
operator|*
name|tail
operator|=
literal|'\0'
expr_stmt|;
comment|/* Terminate dir portion */
name|ret
operator|=
name|create_dir
argument_list|(
name|a
argument_list|,
name|intdir
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|ARCHIVE_OK
operator|&&
name|chdir
argument_list|(
name|intdir
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"Couldn't chdir"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
operator|*
name|tail
operator|=
literal|'/'
expr_stmt|;
comment|/* Restore the / we removed. */
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
goto|goto
name|cleanup
goto|;
name|tail
operator|++
expr_stmt|;
block|}
name|archive_entry_set_pathname
argument_list|(
name|entry
argument_list|,
name|tail
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|stat
argument_list|(
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|,
operator|&
name|extract
operator|->
name|st
argument_list|)
operator|==
literal|0
condition|)
name|extract
operator|->
name|pst
operator|=
operator|&
name|extract
operator|->
name|st
expr_stmt|;
if|if
condition|(
name|extract
operator|->
name|pst
operator|!=
name|NULL
operator|&&
name|extract
operator|->
name|pst
operator|->
name|st_dev
operator|==
name|a
operator|->
name|skip_file_dev
operator|&&
name|extract
operator|->
name|pst
operator|->
name|st_ino
operator|==
name|a
operator|->
name|skip_file_ino
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
literal|0
argument_list|,
literal|"Refusing to overwrite archive"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|archive_entry_hardlink
argument_list|(
name|entry
argument_list|)
operator|!=
name|NULL
condition|)
name|ret
operator|=
name|extract_hard_link
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
expr_stmt|;
else|else
block|{
name|mode
operator|=
name|archive_entry_mode
argument_list|(
name|entry
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
operator|&
name|S_IFMT
condition|)
block|{
default|default:
comment|/* Fall through, as required by POSIX. */
case|case
name|S_IFREG
case|:
name|ret
operator|=
name|extract_file
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_IFLNK
case|:
comment|/* Symlink */
name|ret
operator|=
name|extract_symlink
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_IFCHR
case|:
name|ret
operator|=
name|extract_char_device
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_IFBLK
case|:
name|ret
operator|=
name|extract_block_device
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_IFDIR
case|:
name|ret
operator|=
name|extract_dir
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_IFIFO
case|:
name|ret
operator|=
name|extract_fifo
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|cleanup
label|:
ifdef|#
directive|ifdef
name|HAVE_FCHDIR
comment|/* If we changed directory above, restore it here. */
if|if
condition|(
name|restore_pwd
operator|>=
literal|0
operator|&&
name|original_filename
operator|!=
name|NULL
condition|)
block|{
name|fchdir
argument_list|(
name|restore_pwd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|restore_pwd
argument_list|)
expr_stmt|;
name|archive_entry_copy_pathname
argument_list|(
name|entry
argument_list|,
name|original_filename
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|original_filename
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|create_extract
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|extract
modifier|*
name|extract
decl_stmt|;
name|extract
operator|=
operator|(
expr|struct
name|extract
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|extract
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|extract
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't extract"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|a
operator|->
name|cleanup_archive_extract
operator|=
name|archive_extract_cleanup
expr_stmt|;
name|memset
argument_list|(
name|extract
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|extract
argument_list|)
argument_list|)
expr_stmt|;
name|umask
argument_list|(
name|extract
operator|->
name|umask
operator|=
name|umask
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the current umask. */
comment|/* Final permission for default dirs. */
name|extract
operator|->
name|default_dir_mode_final
operator|=
name|DEFAULT_DIR_MODE
operator|&
operator|~
name|extract
operator|->
name|umask
expr_stmt|;
comment|/* Temporary permission for default dirs during extract. */
name|extract
operator|->
name|default_dir_mode_initial
operator|=
name|extract
operator|->
name|default_dir_mode_final
expr_stmt|;
name|extract
operator|->
name|default_dir_mode_initial
operator||=
name|MINIMUM_DIR_MODE
expr_stmt|;
name|extract
operator|->
name|default_dir_mode_initial
operator|&=
name|MAXIMUM_DIR_MODE
expr_stmt|;
comment|/* If the two permissions above are different, then 	 * the "final" permissions will be applied in the 	 * post-extract fixup pass. */
name|a
operator|->
name|extract
operator|=
name|extract
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Cleanup function for archive_extract.  Mostly, this involves processing  * the fixup list, which is used to address a number of problems:  *   * Dir permissions might prevent us from restoring a file in that  *     dir, so we restore the dir 0700 first, then correct the  *     mode at the end.  *   * Similarly, the act of restoring a file touches the directory  *     and changes the timestamp on the dir, so we have to touch-up dir  *     timestamps at the end as well.  *   * Some file flags can interfere with the restore by, for example,  *     preventing the creation of hardlinks to those files.  *  * Note that tar/cpio do not require that archives be in a particular  * order; there is no way to know when the last file has been restored  * within a directory, so there's no way to optimize the memory usage  * here by fixing up the directory any earlier than the  * end-of-archive.  *  * XXX TODO: Directory ACLs should be restored here, for the same  * reason we set directory perms here. XXX  *  * Registering this function (rather than calling it explicitly by  * name from archive_read_finish) reduces static link pollution, since  * applications that don't use this API won't get this file linked in.  */
end_comment

begin_function
specifier|static
name|int
name|archive_extract_cleanup
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|fixup_entry
modifier|*
name|next
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|struct
name|extract
modifier|*
name|extract
decl_stmt|;
comment|/* Sort dir list so directories are fixed up in depth-first order. */
name|extract
operator|=
name|a
operator|->
name|extract
expr_stmt|;
name|p
operator|=
name|sort_dir_list
argument_list|(
name|extract
operator|->
name|fixup_list
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
name|extract
operator|->
name|pst
operator|=
name|NULL
expr_stmt|;
comment|/* Mark stat cache as out-of-date. */
if|if
condition|(
name|p
operator|->
name|fixup
operator|&
name|FIXUP_TIMES
condition|)
block|{
name|struct
name|timeval
name|times
index|[
literal|2
index|]
decl_stmt|;
name|times
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|p
operator|->
name|mtime
expr_stmt|;
name|times
index|[
literal|1
index|]
operator|.
name|tv_usec
operator|=
name|p
operator|->
name|mtime_nanos
operator|/
literal|1000
expr_stmt|;
name|times
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|p
operator|->
name|atime
expr_stmt|;
name|times
index|[
literal|0
index|]
operator|.
name|tv_usec
operator|=
name|p
operator|->
name|atime_nanos
operator|/
literal|1000
expr_stmt|;
name|utimes
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|times
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|fixup
operator|&
name|FIXUP_MODE
condition|)
name|chmod
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|fixup
operator|&
name|FIXUP_FFLAGS
condition|)
name|set_fflags
argument_list|(
name|a
argument_list|,
operator|-
literal|1
argument_list|,
name|p
operator|->
name|name
argument_list|,
name|p
operator|->
name|mode
argument_list|,
name|p
operator|->
name|fflags_set
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|next
operator|=
name|p
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|p
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|=
name|next
expr_stmt|;
block|}
name|extract
operator|->
name|fixup_list
operator|=
name|NULL
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|extract
operator|->
name|create_parent_dir
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|a
operator|->
name|extract
argument_list|)
expr_stmt|;
name|a
operator|->
name|extract
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Simple O(n log n) merge sort to order the fixup list.  In  * particular, we want to restore dir timestamps depth-first.  */
end_comment

begin_function
specifier|static
name|struct
name|fixup_entry
modifier|*
name|sort_dir_list
parameter_list|(
name|struct
name|fixup_entry
modifier|*
name|p
parameter_list|)
block|{
name|struct
name|fixup_entry
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* A one-item list is already sorted. */
if|if
condition|(
name|p
operator|->
name|next
operator|==
name|NULL
condition|)
return|return
operator|(
name|p
operator|)
return|;
comment|/* Step 1: split the list. */
name|t
operator|=
name|p
expr_stmt|;
name|a
operator|=
name|p
operator|->
name|next
operator|->
name|next
expr_stmt|;
while|while
condition|(
name|a
operator|!=
name|NULL
condition|)
block|{
comment|/* Step a twice, t once. */
name|a
operator|=
name|a
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|a
operator|!=
name|NULL
condition|)
name|a
operator|=
name|a
operator|->
name|next
expr_stmt|;
name|t
operator|=
name|t
operator|->
name|next
expr_stmt|;
block|}
comment|/* Now, t is at the mid-point, so break the list here. */
name|b
operator|=
name|t
operator|->
name|next
expr_stmt|;
name|t
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|a
operator|=
name|p
expr_stmt|;
comment|/* Step 2: Recursively sort the two sub-lists. */
name|a
operator|=
name|sort_dir_list
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|b
operator|=
name|sort_dir_list
argument_list|(
name|b
argument_list|)
expr_stmt|;
comment|/* Step 3: Merge the returned lists. */
comment|/* Pick the first element for the merged list. */
if|if
condition|(
name|strcmp
argument_list|(
name|a
operator|->
name|name
argument_list|,
name|b
operator|->
name|name
argument_list|)
operator|>
literal|0
condition|)
block|{
name|t
operator|=
name|p
operator|=
name|a
expr_stmt|;
name|a
operator|=
name|a
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|t
operator|=
name|p
operator|=
name|b
expr_stmt|;
name|b
operator|=
name|b
operator|->
name|next
expr_stmt|;
block|}
comment|/* Always put the later element on the list first. */
while|while
condition|(
name|a
operator|!=
name|NULL
operator|&&
name|b
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|a
operator|->
name|name
argument_list|,
name|b
operator|->
name|name
argument_list|)
operator|>
literal|0
condition|)
block|{
name|t
operator|->
name|next
operator|=
name|a
expr_stmt|;
name|a
operator|=
name|a
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
name|t
operator|->
name|next
operator|=
name|b
expr_stmt|;
name|b
operator|=
name|b
operator|->
name|next
expr_stmt|;
block|}
name|t
operator|=
name|t
operator|->
name|next
expr_stmt|;
block|}
comment|/* Only one list is non-empty, so just splice it on. */
if|if
condition|(
name|a
operator|!=
name|NULL
condition|)
name|t
operator|->
name|next
operator|=
name|a
expr_stmt|;
if|if
condition|(
name|b
operator|!=
name|NULL
condition|)
name|t
operator|->
name|next
operator|=
name|b
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns a new, initialized fixup entry.  *  * TODO: Reduce the memory requirements for this list by using a tree  * structure rather than a simple list of names.  */
end_comment

begin_function
specifier|static
name|struct
name|fixup_entry
modifier|*
name|new_fixup
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|)
block|{
name|struct
name|extract
modifier|*
name|extract
decl_stmt|;
name|struct
name|fixup_entry
modifier|*
name|fe
decl_stmt|;
name|extract
operator|=
name|a
operator|->
name|extract
expr_stmt|;
name|fe
operator|=
operator|(
expr|struct
name|fixup_entry
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fixup_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fe
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|fe
operator|->
name|next
operator|=
name|extract
operator|->
name|fixup_list
expr_stmt|;
name|extract
operator|->
name|fixup_list
operator|=
name|fe
expr_stmt|;
name|fe
operator|->
name|fixup
operator|=
literal|0
expr_stmt|;
name|fe
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
return|return
operator|(
name|fe
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns a fixup structure for the current entry.  */
end_comment

begin_function
specifier|static
name|struct
name|fixup_entry
modifier|*
name|current_fixup
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|pathname
parameter_list|)
block|{
name|struct
name|extract
modifier|*
name|extract
decl_stmt|;
name|extract
operator|=
name|a
operator|->
name|extract
expr_stmt|;
if|if
condition|(
name|extract
operator|->
name|current_fixup
operator|==
name|NULL
condition|)
name|extract
operator|->
name|current_fixup
operator|=
name|new_fixup
argument_list|(
name|a
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
return|return
operator|(
name|extract
operator|->
name|current_fixup
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|extract_file
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|extract
modifier|*
name|extract
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|mode_t
name|mode
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|r
decl_stmt|,
name|r2
decl_stmt|;
name|extract
operator|=
name|a
operator|->
name|extract
expr_stmt|;
name|name
operator|=
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|mode
operator|=
name|archive_entry_mode
argument_list|(
name|entry
argument_list|)
operator|&
literal|0777
expr_stmt|;
name|r
operator|=
name|ARCHIVE_OK
expr_stmt|;
comment|/* 	 * If we're not supposed to overwrite pre-existing files, 	 * use O_EXCL.  Otherwise, use O_TRUNC. 	 */
if|if
condition|(
name|flags
operator|&
operator|(
name|ARCHIVE_EXTRACT_UNLINK
operator||
name|ARCHIVE_EXTRACT_NO_OVERWRITE
operator|)
condition|)
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
name|mode
argument_list|)
expr_stmt|;
else|else
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* Try removing a pre-existing file. */
if|if
condition|(
name|fd
operator|<
literal|0
operator|&&
operator|!
operator|(
name|flags
operator|&
name|ARCHIVE_EXTRACT_NO_OVERWRITE
operator|)
condition|)
block|{
name|unlink
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* Might be a non-existent parent dir; try fixing that. */
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|create_parent_dir
argument_list|(
name|a
argument_list|,
name|name
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"Can't open '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
name|r
operator|=
name|archive_read_data_into_fd
argument_list|(
name|a
argument_list|,
name|fd
argument_list|)
expr_stmt|;
name|extract
operator|->
name|pst
operator|=
name|NULL
expr_stmt|;
comment|/* Cached stat data no longer valid. */
name|r2
operator|=
name|restore_metadata
argument_list|(
name|a
argument_list|,
name|fd
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|err_combine
argument_list|(
name|r
argument_list|,
name|r2
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|extract_dir
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|extract
modifier|*
name|extract
decl_stmt|;
name|struct
name|fixup_entry
modifier|*
name|fe
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|mode_t
name|restore_mode
decl_stmt|,
name|final_mode
decl_stmt|;
name|extract
operator|=
name|a
operator|->
name|extract
expr_stmt|;
name|extract
operator|->
name|pst
operator|=
name|NULL
expr_stmt|;
comment|/* Invalidate cached stat data. */
comment|/* Copy path to mutable storage. */
name|archive_strcpy
argument_list|(
operator|&
operator|(
name|extract
operator|->
name|create_parent_dir
operator|)
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|path
operator|=
name|extract
operator|->
name|create_parent_dir
operator|.
name|s
expr_stmt|;
if|if
condition|(
operator|*
name|path
operator|==
literal|'\0'
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Invalid empty pathname"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
comment|/* Deal with any troublesome trailing path elements. */
comment|/* TODO: Someday, generalize this to remove '//' or '/./' from 	 * the middle of paths.  But, it should not compress '..' from 	 * the middle of paths.  It's a feature that restoring 	 * "a/../b" creates both 'a' and 'b' directories. */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Locate last element. */
name|p
operator|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
name|p
operator|++
expr_stmt|;
else|else
name|p
operator|=
name|path
expr_stmt|;
comment|/* Trim trailing '/' unless that's the entire path. */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|&&
name|p
operator|-
literal|1
operator|>
name|path
condition|)
block|{
name|p
index|[
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
continue|continue;
block|}
comment|/* Trim trailing '.' unless that's the entire path. */
if|if
condition|(
name|p
operator|>
name|path
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|p
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
continue|continue;
block|}
comment|/* Just exit on trailing '..'. */
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|ARCHIVE_ERRNO_MISC
argument_list|,
literal|"Can't restore directory '..'"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
break|break;
block|}
name|final_mode
operator|=
name|archive_entry_mode
argument_list|(
name|entry
argument_list|)
operator|&
operator|(
name|S_ISUID
operator||
name|S_ISGID
operator||
name|S_ISVTX
operator||
name|S_IRWXU
operator||
name|S_IRWXG
operator||
name|S_IRWXO
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|ARCHIVE_EXTRACT_PERM
operator|)
operator|==
literal|0
condition|)
name|final_mode
operator|&=
operator|~
name|extract
operator|->
name|umask
expr_stmt|;
comment|/* Constrain the permissions in effect during the restore. */
name|restore_mode
operator|=
name|final_mode
expr_stmt|;
name|restore_mode
operator||=
name|MINIMUM_DIR_MODE
expr_stmt|;
name|restore_mode
operator|&=
name|MAXIMUM_DIR_MODE
expr_stmt|;
if|if
condition|(
name|mkdir
argument_list|(
name|path
argument_list|,
name|restore_mode
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|success
goto|;
if|if
condition|(
name|extract
operator|->
name|pst
operator|==
name|NULL
operator|&&
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|extract
operator|->
name|st
argument_list|)
operator|==
literal|0
condition|)
name|extract
operator|->
name|pst
operator|=
operator|&
name|extract
operator|->
name|st
expr_stmt|;
if|if
condition|(
name|extract
operator|->
name|pst
operator|!=
name|NULL
condition|)
block|{
name|extract
operator|->
name|pst
operator|=
operator|&
name|extract
operator|->
name|st
expr_stmt|;
comment|/* If dir already exists, don't reset permissions. */
if|if
condition|(
name|S_ISDIR
argument_list|(
name|extract
operator|->
name|pst
operator|->
name|st_mode
argument_list|)
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
comment|/* It exists but isn't a dir. */
if|if
condition|(
operator|(
name|flags
operator|&
name|ARCHIVE_EXTRACT_UNLINK
operator|)
condition|)
name|unlink
argument_list|(
name|path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Doesn't already exist; try building the parent path. */
if|if
condition|(
name|create_parent_dir_mutable
argument_list|(
name|a
argument_list|,
name|path
argument_list|,
name|flags
argument_list|)
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
comment|/* One final attempt to create the dir. */
if|if
condition|(
name|mkdir
argument_list|(
name|path
argument_list|,
name|restore_mode
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"Can't create directory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
name|success
label|:
comment|/* Add this dir to the fixup list. */
if|if
condition|(
name|final_mode
operator|!=
name|restore_mode
condition|)
block|{
name|fe
operator|=
name|current_fixup
argument_list|(
name|a
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|fe
operator|->
name|fixup
operator||=
name|FIXUP_MODE
expr_stmt|;
name|fe
operator|->
name|mode
operator|=
name|final_mode
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|ARCHIVE_EXTRACT_TIME
condition|)
block|{
name|fe
operator|=
name|current_fixup
argument_list|(
name|a
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|fe
operator|->
name|fixup
operator||=
name|FIXUP_TIMES
expr_stmt|;
name|fe
operator|->
name|mtime
operator|=
name|archive_entry_mtime
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|fe
operator|->
name|mtime_nanos
operator|=
name|archive_entry_mtime_nsec
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|fe
operator|->
name|atime
operator|=
name|archive_entry_atime
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|fe
operator|->
name|atime_nanos
operator|=
name|archive_entry_atime_nsec
argument_list|(
name|entry
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|restore_metadata
argument_list|(
name|a
argument_list|,
operator|-
literal|1
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create the parent of the specified path.  Copy the provided  * path into mutable storage first.  */
end_comment

begin_function
specifier|static
name|int
name|create_parent_dir
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
comment|/* Copy path to mutable storage. */
name|archive_strcpy
argument_list|(
operator|&
operator|(
name|a
operator|->
name|extract
operator|->
name|create_parent_dir
operator|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|r
operator|=
name|create_parent_dir_mutable
argument_list|(
name|a
argument_list|,
name|a
operator|->
name|extract
operator|->
name|create_parent_dir
operator|.
name|s
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Like create_parent_dir, but creates the dir actually requested, not  * the parent.  */
end_comment

begin_function
specifier|static
name|int
name|create_dir
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
comment|/* Copy path to mutable storage. */
name|archive_strcpy
argument_list|(
operator|&
operator|(
name|a
operator|->
name|extract
operator|->
name|create_parent_dir
operator|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|r
operator|=
name|create_dir_mutable
argument_list|(
name|a
argument_list|,
name|a
operator|->
name|extract
operator|->
name|create_parent_dir
operator|.
name|s
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create the parent directory of the specified path, assuming path  * is already in mutable storage.  */
end_comment

begin_function
specifier|static
name|int
name|create_parent_dir_mutable
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|char
modifier|*
name|slash
decl_stmt|;
name|int
name|r
decl_stmt|;
comment|/* Remove tail element to obtain parent name. */
name|slash
operator|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
operator|*
name|slash
operator|=
literal|'\0'
expr_stmt|;
name|r
operator|=
name|create_dir_mutable
argument_list|(
name|a
argument_list|,
name|path
argument_list|,
name|flags
argument_list|)
expr_stmt|;
operator|*
name|slash
operator|=
literal|'/'
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create the specified dir, assuming path is already in  * mutable storage.  */
end_comment

begin_function
specifier|static
name|int
name|create_dir_mutable
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|r
operator|=
name|create_dir_recursive
argument_list|(
name|a
argument_list|,
name|path
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create the specified dir, recursing to create parents as necessary.  *  * Returns ARCHIVE_OK if the path exists when we're done here.  * Otherwise, returns ARCHIVE_WARN.  */
end_comment

begin_function
specifier|static
name|int
name|create_dir_recursive
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|char
modifier|*
name|path
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|struct
name|extract
modifier|*
name|extract
decl_stmt|;
name|struct
name|fixup_entry
modifier|*
name|le
decl_stmt|;
name|char
modifier|*
name|slash
decl_stmt|,
modifier|*
name|base
decl_stmt|;
name|int
name|r
decl_stmt|;
name|extract
operator|=
name|a
operator|->
name|extract
expr_stmt|;
name|r
operator|=
name|ARCHIVE_OK
expr_stmt|;
comment|/* Check for special names and just skip them. */
name|slash
operator|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|base
operator|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
operator|==
name|NULL
condition|)
name|base
operator|=
name|path
expr_stmt|;
else|else
name|base
operator|=
name|slash
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|base
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|base
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|base
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
operator|||
operator|(
name|base
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|base
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|base
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
comment|/* Don't bother trying to create null path, '.', or '..'. */
if|if
condition|(
name|slash
operator|!=
name|NULL
condition|)
block|{
operator|*
name|slash
operator|=
literal|'\0'
expr_stmt|;
name|r
operator|=
name|create_dir_recursive
argument_list|(
name|a
argument_list|,
name|path
argument_list|,
name|flags
argument_list|)
expr_stmt|;
operator|*
name|slash
operator|=
literal|'/'
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
comment|/* 	 * Yes, this should be stat() and not lstat().  Using lstat() 	 * here loses the ability to extract through symlinks.  Also note 	 * that this should not use the extract->st cache. 	 */
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|ARCHIVE_EXTRACT_NO_OVERWRITE
operator|)
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|EEXIST
argument_list|,
literal|"Can't create directory '%s'"
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
if|if
condition|(
name|unlink
argument_list|(
name|path
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"Can't create directory '%s': "
literal|"Conflicting file cannot be removed"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|errno
operator|!=
name|ENOENT
operator|&&
name|errno
operator|!=
name|ENOTDIR
condition|)
block|{
comment|/* Stat failed? */
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"Can't test directory '%s'"
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|slash
operator|!=
name|NULL
condition|)
block|{
operator|*
name|slash
operator|=
literal|'\0'
expr_stmt|;
name|r
operator|=
name|create_dir_recursive
argument_list|(
name|a
argument_list|,
name|path
argument_list|,
name|flags
argument_list|)
expr_stmt|;
operator|*
name|slash
operator|=
literal|'/'
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
if|if
condition|(
name|mkdir
argument_list|(
name|path
argument_list|,
name|extract
operator|->
name|default_dir_mode_initial
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|extract
operator|->
name|default_dir_mode_initial
operator|!=
name|extract
operator|->
name|default_dir_mode_final
condition|)
block|{
name|le
operator|=
name|new_fixup
argument_list|(
name|a
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|le
operator|->
name|fixup
operator||=
name|FIXUP_MODE
expr_stmt|;
name|le
operator|->
name|mode
operator|=
name|extract
operator|->
name|default_dir_mode_final
expr_stmt|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
comment|/* 	 * Without the following check, a/b/../b/c/d fails at the 	 * second visit to 'b', so 'd' can't be created.  Note that we 	 * don't add it to the fixup list here, as it's already been 	 * added. 	 */
if|if
condition|(
name|stat
argument_list|(
name|path
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
operator|&&
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"Failed to create dir '%s'"
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|extract_hard_link
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|extract
modifier|*
name|extract
decl_stmt|;
name|int
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|pathname
decl_stmt|;
specifier|const
name|char
modifier|*
name|linkname
decl_stmt|;
name|extract
operator|=
name|a
operator|->
name|extract
expr_stmt|;
name|pathname
operator|=
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|linkname
operator|=
name|archive_entry_hardlink
argument_list|(
name|entry
argument_list|)
expr_stmt|;
comment|/* Just remove any pre-existing file with this name. */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|ARCHIVE_EXTRACT_NO_OVERWRITE
operator|)
condition|)
name|unlink
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
name|r
operator|=
name|link
argument_list|(
name|linkname
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|extract
operator|->
name|pst
operator|=
name|NULL
expr_stmt|;
comment|/* Invalidate cached stat data. */
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
comment|/* Might be a non-existent parent dir; try fixing that. */
name|create_parent_dir
argument_list|(
name|a
argument_list|,
name|pathname
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|r
operator|=
name|link
argument_list|(
name|linkname
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
comment|/* XXX Better error message here XXX */
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"Can't restore hardlink to '%s'"
argument_list|,
name|linkname
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
comment|/* Set ownership, time, permission information. */
name|r
operator|=
name|restore_metadata
argument_list|(
name|a
argument_list|,
operator|-
literal|1
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|extract_symlink
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|extract
modifier|*
name|extract
decl_stmt|;
name|int
name|r
decl_stmt|;
specifier|const
name|char
modifier|*
name|pathname
decl_stmt|;
specifier|const
name|char
modifier|*
name|linkname
decl_stmt|;
name|extract
operator|=
name|a
operator|->
name|extract
expr_stmt|;
name|pathname
operator|=
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|linkname
operator|=
name|archive_entry_symlink
argument_list|(
name|entry
argument_list|)
expr_stmt|;
comment|/* Just remove any pre-existing file with this name. */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|ARCHIVE_EXTRACT_NO_OVERWRITE
operator|)
condition|)
name|unlink
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
name|r
operator|=
name|symlink
argument_list|(
name|linkname
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
name|extract
operator|->
name|pst
operator|=
name|NULL
expr_stmt|;
comment|/* Invalidate cached stat data. */
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
comment|/* Might be a non-existent parent dir; try fixing that. */
name|create_parent_dir
argument_list|(
name|a
argument_list|,
name|pathname
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|r
operator|=
name|symlink
argument_list|(
name|linkname
argument_list|,
name|pathname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
comment|/* XXX Better error message here XXX */
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"Can't restore symlink to '%s'"
argument_list|,
name|linkname
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
name|r
operator|=
name|restore_metadata
argument_list|(
name|a
argument_list|,
operator|-
literal|1
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|extract_device
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|int
name|flags
parameter_list|,
name|mode_t
name|mode
parameter_list|)
block|{
name|struct
name|extract
modifier|*
name|extract
decl_stmt|;
name|int
name|r
decl_stmt|;
name|extract
operator|=
name|a
operator|->
name|extract
expr_stmt|;
comment|/* Just remove any pre-existing file with this name. */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|ARCHIVE_EXTRACT_NO_OVERWRITE
operator|)
condition|)
name|unlink
argument_list|(
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|mknod
argument_list|(
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|,
name|mode
argument_list|,
name|archive_entry_rdev
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|extract
operator|->
name|pst
operator|=
name|NULL
expr_stmt|;
comment|/* Invalidate cached stat data. */
comment|/* Might be a non-existent parent dir; try fixing that. */
if|if
condition|(
name|r
operator|!=
literal|0
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|create_parent_dir
argument_list|(
name|a
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|r
operator|=
name|mknod
argument_list|(
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|,
name|mode
argument_list|,
name|archive_entry_rdev
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"Can't restore device node"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
name|r
operator|=
name|restore_metadata
argument_list|(
name|a
argument_list|,
operator|-
literal|1
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|extract_char_device
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|mode_t
name|mode
decl_stmt|;
name|mode
operator|=
operator|(
name|archive_entry_mode
argument_list|(
name|entry
argument_list|)
operator|&
operator|~
name|S_IFMT
operator|)
operator||
name|S_IFCHR
expr_stmt|;
return|return
operator|(
name|extract_device
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|extract_block_device
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|mode_t
name|mode
decl_stmt|;
name|mode
operator|=
operator|(
name|archive_entry_mode
argument_list|(
name|entry
argument_list|)
operator|&
operator|~
name|S_IFMT
operator|)
operator||
name|S_IFBLK
expr_stmt|;
return|return
operator|(
name|extract_device
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|extract_fifo
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|extract
modifier|*
name|extract
decl_stmt|;
name|int
name|r
decl_stmt|;
name|extract
operator|=
name|a
operator|->
name|extract
expr_stmt|;
comment|/* Just remove any pre-existing file with this name. */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|ARCHIVE_EXTRACT_NO_OVERWRITE
operator|)
condition|)
name|unlink
argument_list|(
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|mkfifo
argument_list|(
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|,
name|archive_entry_mode
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|extract
operator|->
name|pst
operator|=
name|NULL
expr_stmt|;
comment|/* Invalidate cached stat data. */
comment|/* Might be a non-existent parent dir; try fixing that. */
if|if
condition|(
name|r
operator|!=
literal|0
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|create_parent_dir
argument_list|(
name|a
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|r
operator|=
name|mkfifo
argument_list|(
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|,
name|archive_entry_mode
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"Can't restore fifo"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
name|r
operator|=
name|restore_metadata
argument_list|(
name|a
argument_list|,
operator|-
literal|1
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|restore_metadata
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|int
name|fd
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|r
decl_stmt|,
name|r2
decl_stmt|;
name|r
operator|=
name|set_ownership
argument_list|(
name|a
argument_list|,
name|fd
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|r2
operator|=
name|set_time
argument_list|(
name|a
argument_list|,
name|fd
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|r
operator|=
name|err_combine
argument_list|(
name|r
argument_list|,
name|r2
argument_list|)
expr_stmt|;
name|r2
operator|=
name|set_perm
argument_list|(
name|a
argument_list|,
name|fd
argument_list|,
name|entry
argument_list|,
name|archive_entry_mode
argument_list|(
name|entry
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|err_combine
argument_list|(
name|r
argument_list|,
name|r2
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_ownership
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|int
name|fd
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|uid_t
name|uid
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
comment|/* Not changed. */
if|if
condition|(
operator|(
name|flags
operator|&
name|ARCHIVE_EXTRACT_OWNER
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
name|uid
operator|=
name|lookup_uid
argument_list|(
name|a
argument_list|,
name|archive_entry_uname
argument_list|(
name|entry
argument_list|)
argument_list|,
name|archive_entry_uid
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|gid
operator|=
name|lookup_gid
argument_list|(
name|a
argument_list|,
name|archive_entry_gname
argument_list|(
name|entry
argument_list|)
argument_list|,
name|archive_entry_gid
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we know we can't change it, don't bother trying. */
if|if
condition|(
name|a
operator|->
name|user_uid
operator|!=
literal|0
operator|&&
name|a
operator|->
name|user_uid
operator|!=
name|uid
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
ifdef|#
directive|ifdef
name|HAVE_FCHOWN
if|if
condition|(
name|fd
operator|>=
literal|0
operator|&&
name|fchown
argument_list|(
name|fd
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_LCHOWN
if|if
condition|(
name|lchown
argument_list|(
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
operator|!
name|S_ISLNK
argument_list|(
name|archive_entry_mode
argument_list|(
name|entry
argument_list|)
argument_list|)
operator|&&
name|chown
argument_list|(
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|)
operator|!=
literal|0
condition|)
endif|#
directive|endif
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"Can't set user=%d/group=%d for %s"
argument_list|,
name|uid
argument_list|,
name|gid
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_time
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|int
name|fd
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
specifier|const
name|struct
name|stat
modifier|*
name|st
decl_stmt|;
name|struct
name|timeval
name|times
index|[
literal|2
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|a
expr_stmt|;
comment|/* UNUSED */
name|st
operator|=
name|archive_entry_stat
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|ARCHIVE_EXTRACT_TIME
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
comment|/* It's a waste of time to mess with dir timestamps here. */
if|if
condition|(
name|S_ISDIR
argument_list|(
name|archive_entry_mode
argument_list|(
name|entry
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
name|times
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|st
operator|->
name|st_mtime
expr_stmt|;
name|times
index|[
literal|1
index|]
operator|.
name|tv_usec
operator|=
name|ARCHIVE_STAT_MTIME_NANOS
argument_list|(
name|st
argument_list|)
operator|/
literal|1000
expr_stmt|;
name|times
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|st
operator|->
name|st_atime
expr_stmt|;
name|times
index|[
literal|0
index|]
operator|.
name|tv_usec
operator|=
name|ARCHIVE_STAT_ATIME_NANOS
argument_list|(
name|st
argument_list|)
operator|/
literal|1000
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_FUTIMES
if|if
condition|(
name|fd
operator|>=
literal|0
operator|&&
name|futimes
argument_list|(
name|fd
argument_list|,
name|times
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|HAVE_LUTIMES
if|if
condition|(
name|lutimes
argument_list|(
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|,
name|times
argument_list|)
operator|!=
literal|0
condition|)
block|{
else|#
directive|else
if|if
condition|(
operator|(
name|archive_entry_mode
argument_list|(
name|entry
argument_list|)
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFLNK
operator|&&
name|utimes
argument_list|(
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|,
name|times
argument_list|)
operator|!=
literal|0
condition|)
block|{
endif|#
directive|endif
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"Can't update time for %s"
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
comment|/* 	 * Note: POSIX does not provide a portable way to restore ctime. 	 * (Apart from resetting the system clock, which is distasteful.) 	 * So, any restoration of ctime will necessarily be OS-specific. 	 */
comment|/* XXX TODO: Can FreeBSD restore ctime? XXX */
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
specifier|static
name|int
name|set_perm
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|int
name|fd
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|extract
modifier|*
name|extract
decl_stmt|;
name|struct
name|fixup_entry
modifier|*
name|le
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|unsigned
name|long
name|set
decl_stmt|,
name|clear
decl_stmt|;
name|int
name|r
decl_stmt|;
name|int
name|critical_flags
decl_stmt|;
name|extract
operator|=
name|a
operator|->
name|extract
expr_stmt|;
comment|/* Obey umask unless ARCHIVE_EXTRACT_PERM. */
if|if
condition|(
operator|(
name|flags
operator|&
name|ARCHIVE_EXTRACT_PERM
operator|)
operator|==
literal|0
condition|)
name|mode
operator|&=
operator|~
name|extract
operator|->
name|umask
expr_stmt|;
comment|/* Enforce umask. */
name|name
operator|=
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
operator|(
name|S_ISUID
operator||
name|S_ISGID
operator|)
condition|)
block|{
if|if
condition|(
name|extract
operator|->
name|pst
operator|!=
name|NULL
condition|)
block|{
comment|/* Already have stat() data available. */
ifdef|#
directive|ifdef
name|HAVE_FSTAT
block|}
elseif|else
if|if
condition|(
name|fd
operator|>=
literal|0
operator|&&
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|extract
operator|->
name|st
argument_list|)
operator|==
literal|0
condition|)
block|{
name|extract
operator|->
name|pst
operator|=
operator|&
name|extract
operator|->
name|st
expr_stmt|;
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|extract
operator|->
name|st
argument_list|)
operator|==
literal|0
condition|)
block|{
name|extract
operator|->
name|pst
operator|=
operator|&
name|extract
operator|->
name|st
expr_stmt|;
block|}
else|else
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"Couldn't stat file"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
comment|/* 		 * TODO: Use the uid/gid looked up in set_ownership 		 * above rather than the uid/gid stored in the entry. 		 */
if|if
condition|(
name|extract
operator|->
name|pst
operator|->
name|st_uid
operator|!=
name|archive_entry_uid
argument_list|(
name|entry
argument_list|)
condition|)
name|mode
operator|&=
operator|~
name|S_ISUID
expr_stmt|;
if|if
condition|(
name|extract
operator|->
name|pst
operator|->
name|st_gid
operator|!=
name|archive_entry_gid
argument_list|(
name|entry
argument_list|)
condition|)
name|mode
operator|&=
operator|~
name|S_ISGID
expr_stmt|;
block|}
if|if
condition|(
name|S_ISLNK
argument_list|(
name|archive_entry_mode
argument_list|(
name|entry
argument_list|)
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_LCHMOD
comment|/* 		 * If this is a symlink, use lchmod().  If the 		 * platform doesn't support lchmod(), just skip it as 		 * permissions on symlinks are actually ignored on 		 * most platforms. 		 */
if|if
condition|(
name|lchmod
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"Can't set permissions"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
endif|#
directive|endif
block|}
elseif|else
if|if
condition|(
operator|!
name|S_ISDIR
argument_list|(
name|archive_entry_mode
argument_list|(
name|entry
argument_list|)
argument_list|)
condition|)
block|{
comment|/* 		 * If it's not a symlink and not a dir, then use 		 * fchmod() or chmod(), depending on whether we have 		 * an fd.  Dirs get their perms set during the 		 * post-extract fixup, which is handled elsewhere. 		 */
ifdef|#
directive|ifdef
name|HAVE_FCHMOD
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|fchmod
argument_list|(
name|fd
argument_list|,
name|mode
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"Can't set permissions"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
block|}
elseif|else
endif|#
directive|endif
comment|/* If this platform lacks fchmod(), then 			 * we'll just use chmod(). */
if|if
condition|(
name|chmod
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"Can't set permissions"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|ARCHIVE_EXTRACT_ACL
condition|)
block|{
name|r
operator|=
name|set_acls
argument_list|(
name|a
argument_list|,
name|fd
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|ARCHIVE_EXTRACT_XATTR
condition|)
block|{
name|r
operator|=
name|set_xattrs
argument_list|(
name|a
argument_list|,
name|fd
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
comment|/* 	 * Make 'critical_flags' hold all file flags that can't be 	 * immediately restored.  For example, on BSD systems, 	 * SF_IMMUTABLE prevents hardlinks from being created, so 	 * should not be set until after any hardlinks are created.  To 	 * preserve some semblance of portability, this uses #ifdef 	 * extensively.  Ugly, but it works. 	 * 	 * Yes, Virginia, this does create a security race.  It's mitigated 	 * somewhat by the practice of creating dirs 0700 until the extract 	 * is done, but it would be nice if we could do more than that. 	 * People restoring critical file systems should be wary of 	 * other programs that might try to muck with files as they're 	 * being restored. 	 */
comment|/* Hopefully, the compiler will optimize this mess into a constant. */
name|critical_flags
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|SF_IMMUTABLE
name|critical_flags
operator||=
name|SF_IMMUTABLE
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UF_IMMUTABLE
name|critical_flags
operator||=
name|UF_IMMUTABLE
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SF_APPEND
name|critical_flags
operator||=
name|SF_APPEND
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|UF_APPEND
name|critical_flags
operator||=
name|UF_APPEND
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EXT2_APPEND_FL
name|critical_flags
operator||=
name|EXT2_APPEND_FL
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EXT2_IMMUTABLE_FL
name|critical_flags
operator||=
name|EXT2_IMMUTABLE_FL
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|flags
operator|&
name|ARCHIVE_EXTRACT_FFLAGS
condition|)
block|{
name|archive_entry_fflags
argument_list|(
name|entry
argument_list|,
operator|&
name|set
argument_list|,
operator|&
name|clear
argument_list|)
expr_stmt|;
comment|/* 		 * The first test encourages the compiler to eliminate 		 * all of this if it's not necessary. 		 */
if|if
condition|(
operator|(
name|critical_flags
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|set
operator|&
name|critical_flags
operator|)
condition|)
block|{
name|le
operator|=
name|current_fixup
argument_list|(
name|a
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|le
operator|->
name|fixup
operator||=
name|FIXUP_FFLAGS
expr_stmt|;
name|le
operator|->
name|fflags_set
operator|=
name|set
expr_stmt|;
comment|/* Store the mode if it's not already there. */
if|if
condition|(
operator|(
name|le
operator|->
name|fixup
operator|&
name|FIXUP_MODE
operator|)
operator|==
literal|0
condition|)
name|le
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|set_fflags
argument_list|(
name|a
argument_list|,
name|fd
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|,
name|mode
argument_list|,
name|set
argument_list|,
name|clear
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|r
operator|)
return|;
block|}
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
if|#
directive|if
operator|(
name|defined
argument_list|(
name|HAVE_LCHFLAGS
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_CHFLAGS
argument_list|)
operator|||
name|defined
argument_list|(
name|HAVE_FCHFLAGS
argument_list|)
operator|)
operator|&&
operator|!
name|defined
argument_list|(
name|__linux
argument_list|)
specifier|static
name|int
name|set_fflags
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|mode_t
name|mode
parameter_list|,
name|unsigned
name|long
name|set
parameter_list|,
name|unsigned
name|long
name|clear
parameter_list|)
block|{
name|struct
name|extract
modifier|*
name|extract
decl_stmt|;
name|extract
operator|=
name|a
operator|->
name|extract
expr_stmt|;
if|if
condition|(
name|set
operator|==
literal|0
operator|&&
name|clear
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
operator|(
name|void
operator|)
name|mode
expr_stmt|;
comment|/* UNUSED */
comment|/* 	 * XXX Is the stat here really necessary?  Or can I just use 	 * the 'set' flags directly?  In particular, I'm not sure 	 * about the correct approach if we're overwriting an existing 	 * file that already has flags on it. XXX 	 */
if|if
condition|(
name|extract
operator|->
name|pst
operator|!=
name|NULL
condition|)
block|{
comment|/* Already have stat() data available. */
block|}
elseif|else
if|if
condition|(
name|fd
operator|>=
literal|0
operator|&&
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|extract
operator|->
name|st
argument_list|)
operator|==
literal|0
condition|)
name|extract
operator|->
name|pst
operator|=
operator|&
name|extract
operator|->
name|st
expr_stmt|;
elseif|else
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|extract
operator|->
name|st
argument_list|)
operator|==
literal|0
condition|)
name|extract
operator|->
name|pst
operator|=
operator|&
name|extract
operator|->
name|st
expr_stmt|;
else|else
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"Couldn't stat file"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
name|extract
operator|->
name|st
operator|.
name|st_flags
operator|&=
operator|~
name|clear
expr_stmt|;
name|extract
operator|->
name|st
operator|.
name|st_flags
operator||=
name|set
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_FCHFLAGS
comment|/* If platform has fchflags() and we were given an fd, use it. */
if|if
condition|(
name|fd
operator|>=
literal|0
operator|&&
name|fchflags
argument_list|(
name|fd
argument_list|,
name|extract
operator|->
name|st
operator|.
name|st_flags
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
endif|#
directive|endif
comment|/* 	 * If we can't use the fd to set the flags, we'll use the 	 * pathname to set flags.  We prefer lchflags() but will use 	 * chflags() if we must. 	 */
ifdef|#
directive|ifdef
name|HAVE_LCHFLAGS
if|if
condition|(
name|lchflags
argument_list|(
name|name
argument_list|,
name|extract
operator|->
name|st
operator|.
name|st_flags
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
elif|#
directive|elif
name|defined
argument_list|(
name|HAVE_CHFLAGS
argument_list|)
if|if
condition|(
name|chflags
argument_list|(
name|name
argument_list|,
name|extract
operator|->
name|st
operator|.
name|st_flags
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
endif|#
directive|endif
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"Failed to set file flags"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|__linux
argument_list|)
operator|&&
name|defined
argument_list|(
name|EXT2_IOC_GETFLAGS
argument_list|)
operator|&&
name|defined
argument_list|(
name|EXT2_IOC_SETFLAGS
argument_list|)
comment|/*  * Linux has flags too, but uses ioctl() to access them instead of  * having a separate chflags() system call.  */
specifier|static
name|int
name|set_fflags
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|mode_t
name|mode
parameter_list|,
name|unsigned
name|long
name|set
parameter_list|,
name|unsigned
name|long
name|clear
parameter_list|)
block|{
name|struct
name|extract
modifier|*
name|extract
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|myfd
init|=
name|fd
decl_stmt|;
name|unsigned
name|long
name|newflags
decl_stmt|,
name|oldflags
decl_stmt|;
name|unsigned
name|long
name|sf_mask
init|=
literal|0
decl_stmt|;
name|extract
operator|=
name|a
operator|->
name|extract
expr_stmt|;
if|if
condition|(
name|set
operator|==
literal|0
operator|&&
name|clear
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
comment|/* Only regular files and dirs can have flags. */
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|mode
argument_list|)
operator|&&
operator|!
name|S_ISDIR
argument_list|(
name|mode
argument_list|)
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
comment|/* If we weren't given an fd, open it ourselves. */
if|if
condition|(
name|myfd
operator|<
literal|0
condition|)
name|myfd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_RDONLY
operator||
name|O_NONBLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|myfd
operator|<
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
comment|/* 	 * Linux has no define for the flags that are only settable by 	 * the root user.  This code may seem a little complex, but 	 * there seem to be some Linux systems that lack these 	 * defines. (?)  The code below degrades reasonably gracefully 	 * if sf_mask is incomplete. 	 */
ifdef|#
directive|ifdef
name|EXT2_IMMUTABLE_FL
name|sf_mask
operator||=
name|EXT2_IMMUTABLE_FL
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|EXT2_APPEND_FL
name|sf_mask
operator||=
name|EXT2_APPEND_FL
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * XXX As above, this would be way simpler if we didn't have 	 * to read the current flags from disk. XXX 	 */
name|ret
operator|=
name|ARCHIVE_OK
expr_stmt|;
comment|/* Try setting the flags as given. */
if|if
condition|(
name|ioctl
argument_list|(
name|myfd
argument_list|,
name|EXT2_IOC_GETFLAGS
argument_list|,
operator|&
name|oldflags
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|newflags
operator|=
operator|(
name|oldflags
operator|&
operator|~
name|clear
operator|)
operator||
name|set
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|myfd
argument_list|,
name|EXT2_IOC_SETFLAGS
argument_list|,
operator|&
name|newflags
argument_list|)
operator|>=
literal|0
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|errno
operator|!=
name|EPERM
condition|)
goto|goto
name|fail
goto|;
block|}
comment|/* If we couldn't set all the flags, try again with a subset. */
if|if
condition|(
name|ioctl
argument_list|(
name|myfd
argument_list|,
name|EXT2_IOC_GETFLAGS
argument_list|,
operator|&
name|oldflags
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|newflags
operator|&=
operator|~
name|sf_mask
expr_stmt|;
name|oldflags
operator|&=
name|sf_mask
expr_stmt|;
name|newflags
operator||=
name|oldflags
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|myfd
argument_list|,
name|EXT2_IOC_SETFLAGS
argument_list|,
operator|&
name|newflags
argument_list|)
operator|>=
literal|0
condition|)
goto|goto
name|cleanup
goto|;
block|}
comment|/* We couldn't set the flags, so report the failure. */
name|fail
label|:
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"Failed to set file flags"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
name|cleanup
label|:
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
name|close
argument_list|(
name|myfd
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
else|#
directive|else
comment|/* Not HAVE_CHFLAGS&& Not __linux */
comment|/*  * Of course, some systems have neither BSD chflags() nor Linux' flags  * support through ioctl().  */
specifier|static
name|int
name|set_fflags
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|mode_t
name|mode
parameter_list|,
name|unsigned
name|long
name|set
parameter_list|,
name|unsigned
name|long
name|clear
parameter_list|)
block|{
operator|(
name|void
operator|)
name|a
expr_stmt|;
operator|(
name|void
operator|)
name|fd
expr_stmt|;
operator|(
name|void
operator|)
name|name
expr_stmt|;
operator|(
name|void
operator|)
name|mode
expr_stmt|;
operator|(
name|void
operator|)
name|set
expr_stmt|;
operator|(
name|void
operator|)
name|clear
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* __linux */
ifndef|#
directive|ifndef
name|HAVE_POSIX_ACL
comment|/* Default empty function body to satisfy mainline code. */
specifier|static
name|int
name|set_acls
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|int
name|fd
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
operator|(
name|void
operator|)
name|a
expr_stmt|;
operator|(
name|void
operator|)
name|fd
expr_stmt|;
operator|(
name|void
operator|)
name|entry
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
else|#
directive|else
comment|/*  * XXX TODO: What about ACL types other than ACCESS and DEFAULT?  */
specifier|static
name|int
name|set_acls
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|int
name|fd
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|set_acl
argument_list|(
name|a
argument_list|,
name|fd
argument_list|,
name|entry
argument_list|,
name|ACL_TYPE_ACCESS
argument_list|,
name|ARCHIVE_ENTRY_ACL_TYPE_ACCESS
argument_list|,
literal|"access"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ret
operator|)
return|;
name|ret
operator|=
name|set_acl
argument_list|(
name|a
argument_list|,
name|fd
argument_list|,
name|entry
argument_list|,
name|ACL_TYPE_DEFAULT
argument_list|,
name|ARCHIVE_ENTRY_ACL_TYPE_DEFAULT
argument_list|,
literal|"default"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
specifier|static
name|int
name|set_acl
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|int
name|fd
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|acl_type_t
name|acl_type
parameter_list|,
name|int
name|ae_requested_type
parameter_list|,
specifier|const
name|char
modifier|*
name|tname
parameter_list|)
block|{
name|acl_t
name|acl
decl_stmt|;
name|acl_entry_t
name|acl_entry
decl_stmt|;
name|acl_permset_t
name|acl_permset
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|ae_type
decl_stmt|,
name|ae_permset
decl_stmt|,
name|ae_tag
decl_stmt|,
name|ae_id
decl_stmt|;
name|uid_t
name|ae_uid
decl_stmt|;
name|gid_t
name|ae_gid
decl_stmt|;
specifier|const
name|char
modifier|*
name|ae_name
decl_stmt|;
name|int
name|entries
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|ret
operator|=
name|ARCHIVE_OK
expr_stmt|;
name|entries
operator|=
name|archive_entry_acl_reset
argument_list|(
name|entry
argument_list|,
name|ae_requested_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|entries
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
name|acl
operator|=
name|acl_init
argument_list|(
name|entries
argument_list|)
expr_stmt|;
while|while
condition|(
name|archive_entry_acl_next
argument_list|(
name|entry
argument_list|,
name|ae_requested_type
argument_list|,
operator|&
name|ae_type
argument_list|,
operator|&
name|ae_permset
argument_list|,
operator|&
name|ae_tag
argument_list|,
operator|&
name|ae_id
argument_list|,
operator|&
name|ae_name
argument_list|)
operator|==
name|ARCHIVE_OK
condition|)
block|{
name|acl_create_entry
argument_list|(
operator|&
name|acl
argument_list|,
operator|&
name|acl_entry
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ae_tag
condition|)
block|{
case|case
name|ARCHIVE_ENTRY_ACL_USER
case|:
name|acl_set_tag_type
argument_list|(
name|acl_entry
argument_list|,
name|ACL_USER
argument_list|)
expr_stmt|;
name|ae_uid
operator|=
name|lookup_uid
argument_list|(
name|a
argument_list|,
name|ae_name
argument_list|,
name|ae_id
argument_list|)
expr_stmt|;
name|acl_set_qualifier
argument_list|(
name|acl_entry
argument_list|,
operator|&
name|ae_uid
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARCHIVE_ENTRY_ACL_GROUP
case|:
name|acl_set_tag_type
argument_list|(
name|acl_entry
argument_list|,
name|ACL_GROUP
argument_list|)
expr_stmt|;
name|ae_gid
operator|=
name|lookup_gid
argument_list|(
name|a
argument_list|,
name|ae_name
argument_list|,
name|ae_id
argument_list|)
expr_stmt|;
name|acl_set_qualifier
argument_list|(
name|acl_entry
argument_list|,
operator|&
name|ae_gid
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARCHIVE_ENTRY_ACL_USER_OBJ
case|:
name|acl_set_tag_type
argument_list|(
name|acl_entry
argument_list|,
name|ACL_USER_OBJ
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARCHIVE_ENTRY_ACL_GROUP_OBJ
case|:
name|acl_set_tag_type
argument_list|(
name|acl_entry
argument_list|,
name|ACL_GROUP_OBJ
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARCHIVE_ENTRY_ACL_MASK
case|:
name|acl_set_tag_type
argument_list|(
name|acl_entry
argument_list|,
name|ACL_MASK
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARCHIVE_ENTRY_ACL_OTHER
case|:
name|acl_set_tag_type
argument_list|(
name|acl_entry
argument_list|,
name|ACL_OTHER
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* XXX */
break|break;
block|}
name|acl_get_permset
argument_list|(
name|acl_entry
argument_list|,
operator|&
name|acl_permset
argument_list|)
expr_stmt|;
name|acl_clear_perms
argument_list|(
name|acl_permset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ae_permset
operator|&
name|ARCHIVE_ENTRY_ACL_EXECUTE
condition|)
name|acl_add_perm
argument_list|(
name|acl_permset
argument_list|,
name|ACL_EXECUTE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ae_permset
operator|&
name|ARCHIVE_ENTRY_ACL_WRITE
condition|)
name|acl_add_perm
argument_list|(
name|acl_permset
argument_list|,
name|ACL_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ae_permset
operator|&
name|ARCHIVE_ENTRY_ACL_READ
condition|)
name|acl_add_perm
argument_list|(
name|acl_permset
argument_list|,
name|ACL_READ
argument_list|)
expr_stmt|;
block|}
name|name
operator|=
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
expr_stmt|;
comment|/* Try restoring the ACL through 'fd' if we can. */
if|#
directive|if
name|HAVE_ACL_SET_FD
if|if
condition|(
name|fd
operator|>=
literal|0
operator|&&
name|acl_type
operator|==
name|ACL_TYPE_ACCESS
operator|&&
name|acl_set_fd
argument_list|(
name|fd
argument_list|,
name|acl
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|=
name|ARCHIVE_OK
expr_stmt|;
elseif|else
else|#
directive|else
if|#
directive|if
name|HAVE_ACL_SET_FD_NP
if|if
condition|(
name|fd
operator|>=
literal|0
operator|&&
name|acl_set_fd_np
argument_list|(
name|fd
argument_list|,
name|acl
argument_list|,
name|acl_type
argument_list|)
operator|==
literal|0
condition|)
name|ret
operator|=
name|ARCHIVE_OK
expr_stmt|;
elseif|else
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|acl_set_file
argument_list|(
name|name
argument_list|,
name|acl_type
argument_list|,
name|acl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"Failed to set %s acl"
argument_list|,
name|tname
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
name|acl_free
argument_list|(
name|acl
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
endif|#
directive|endif
if|#
directive|if
name|HAVE_LSETXATTR
comment|/*  * Restore extended attributes -  Linux implementation  */
specifier|static
name|int
name|set_xattrs
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|int
name|fd
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
specifier|static
name|int
name|warning_done
init|=
literal|0
decl_stmt|;
name|int
name|ret
init|=
name|ARCHIVE_OK
decl_stmt|;
name|int
name|i
init|=
name|archive_entry_xattr_reset
argument_list|(
name|entry
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|void
modifier|*
name|value
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|archive_entry_xattr_next
argument_list|(
name|entry
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|value
argument_list|,
operator|&
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|!=
name|NULL
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"xfsroot."
argument_list|,
literal|8
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|name
argument_list|,
literal|"system."
argument_list|,
literal|7
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|e
decl_stmt|;
if|#
directive|if
name|HAVE_FSETXATTR
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
name|e
operator|=
name|fsetxattr
argument_list|(
name|fd
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
block|{
name|e
operator|=
name|lsetxattr
argument_list|(
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ENOTSUP
condition|)
block|{
if|if
condition|(
operator|!
name|warning_done
condition|)
block|{
name|warning_done
operator|=
literal|1
expr_stmt|;
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"Cannot restore extended "
literal|"attributes on this file "
literal|"system"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"Failed to set extended attribute"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
block|}
else|else
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Invalid extended attribute encountered"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
else|#
directive|else
comment|/*  * Restore extended attributes - stub implementation for unsupported systems  */
specifier|static
name|int
name|set_xattrs
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|int
name|fd
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
specifier|static
name|int
name|warning_done
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|a
expr_stmt|;
comment|/* UNUSED */
operator|(
name|void
operator|)
name|fd
expr_stmt|;
comment|/* UNUSED */
comment|/* If there aren't any extended attributes, then it's okay not 	 * to extract them, otherwise, issue a single warning. */
if|if
condition|(
name|archive_entry_xattr_count
argument_list|(
name|entry
argument_list|)
operator|!=
literal|0
operator|&&
operator|!
name|warning_done
condition|)
block|{
name|warning_done
operator|=
literal|1
expr_stmt|;
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|ARCHIVE_ERRNO_FILE_FORMAT
argument_list|,
literal|"Cannot restore extended attributes on this system"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
comment|/* Warning was already emitted; suppress further warnings. */
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
endif|#
directive|endif
comment|/*  * The following routines do some basic caching of uname/gname  * lookups.  All such lookups go through these routines, including ACL  * conversions.  Even a small cache here provides an enormous speedup,  * especially on systems using NIS, LDAP, or a similar networked  * directory system.  *  * TODO: Provide an API for clients to override these routines.  */
specifier|static
name|gid_t
name|lookup_gid
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|gname
parameter_list|,
name|gid_t
name|gid
parameter_list|)
block|{
name|struct
name|group
modifier|*
name|grent
decl_stmt|;
name|struct
name|extract
modifier|*
name|extract
decl_stmt|;
name|int
name|h
decl_stmt|;
name|struct
name|bucket
modifier|*
name|b
decl_stmt|;
name|int
name|cache_size
decl_stmt|;
name|extract
operator|=
name|a
operator|->
name|extract
expr_stmt|;
name|cache_size
operator|=
sizeof|sizeof
argument_list|(
name|extract
operator|->
name|gcache
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|extract
operator|->
name|gcache
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* If no gname, just use the gid provided. */
if|if
condition|(
name|gname
operator|==
name|NULL
operator|||
operator|*
name|gname
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|gid
operator|)
return|;
comment|/* Try to find gname in the cache. */
name|h
operator|=
name|hash
argument_list|(
name|gname
argument_list|)
expr_stmt|;
name|b
operator|=
operator|&
name|extract
operator|->
name|gcache
index|[
name|h
operator|%
name|cache_size
index|]
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|name
operator|!=
name|NULL
operator|&&
name|b
operator|->
name|hash
operator|==
name|h
operator|&&
name|strcmp
argument_list|(
name|gname
argument_list|,
name|b
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|gid_t
operator|)
name|b
operator|->
name|id
operator|)
return|;
comment|/* Free the cache slot for a new entry. */
if|if
condition|(
name|b
operator|->
name|name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|b
operator|->
name|name
argument_list|)
expr_stmt|;
name|b
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|gname
argument_list|)
expr_stmt|;
comment|/* Note: If strdup fails, that's okay; we just won't cache. */
name|b
operator|->
name|hash
operator|=
name|h
expr_stmt|;
name|grent
operator|=
name|getgrnam
argument_list|(
name|gname
argument_list|)
expr_stmt|;
if|if
condition|(
name|grent
operator|!=
name|NULL
condition|)
name|gid
operator|=
name|grent
operator|->
name|gr_gid
expr_stmt|;
name|b
operator|->
name|id
operator|=
name|gid
expr_stmt|;
return|return
operator|(
name|gid
operator|)
return|;
block|}
specifier|static
name|uid_t
name|lookup_uid
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|uname
parameter_list|,
name|uid_t
name|uid
parameter_list|)
block|{
name|struct
name|passwd
modifier|*
name|pwent
decl_stmt|;
name|struct
name|extract
modifier|*
name|extract
decl_stmt|;
name|int
name|h
decl_stmt|;
name|struct
name|bucket
modifier|*
name|b
decl_stmt|;
name|int
name|cache_size
decl_stmt|;
name|extract
operator|=
name|a
operator|->
name|extract
expr_stmt|;
name|cache_size
operator|=
sizeof|sizeof
argument_list|(
name|extract
operator|->
name|ucache
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|extract
operator|->
name|ucache
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* If no uname, just use the uid provided. */
if|if
condition|(
name|uname
operator|==
name|NULL
operator|||
operator|*
name|uname
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|uid
operator|)
return|;
comment|/* Try to find uname in the cache. */
name|h
operator|=
name|hash
argument_list|(
name|uname
argument_list|)
expr_stmt|;
name|b
operator|=
operator|&
name|extract
operator|->
name|ucache
index|[
name|h
operator|%
name|cache_size
index|]
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|name
operator|!=
name|NULL
operator|&&
name|b
operator|->
name|hash
operator|==
name|h
operator|&&
name|strcmp
argument_list|(
name|uname
argument_list|,
name|b
operator|->
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
name|uid_t
operator|)
name|b
operator|->
name|id
operator|)
return|;
comment|/* Free the cache slot for a new entry. */
if|if
condition|(
name|b
operator|->
name|name
operator|!=
name|NULL
condition|)
name|free
argument_list|(
name|b
operator|->
name|name
argument_list|)
expr_stmt|;
name|b
operator|->
name|name
operator|=
name|strdup
argument_list|(
name|uname
argument_list|)
expr_stmt|;
comment|/* Note: If strdup fails, that's okay; we just won't cache. */
name|b
operator|->
name|hash
operator|=
name|h
expr_stmt|;
name|pwent
operator|=
name|getpwnam
argument_list|(
name|uname
argument_list|)
expr_stmt|;
if|if
condition|(
name|pwent
operator|!=
name|NULL
condition|)
name|uid
operator|=
name|pwent
operator|->
name|pw_uid
expr_stmt|;
name|b
operator|->
name|id
operator|=
name|uid
expr_stmt|;
return|return
operator|(
name|uid
operator|)
return|;
block|}
specifier|static
name|unsigned
name|int
name|hash
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
comment|/* A 32-bit version of Peter Weinberger's (PJW) hash algorithm, 	   as used by ELF for hashing function names. */
name|unsigned
name|g
decl_stmt|,
name|h
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|h
operator|=
operator|(
name|h
operator|<<
literal|4
operator|)
operator|+
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|g
operator|=
name|h
operator|&
literal|0xF0000000
operator|)
condition|)
block|{
name|h
operator|^=
name|g
operator|>>
literal|24
expr_stmt|;
name|h
operator|&=
literal|0x0FFFFFFF
expr_stmt|;
block|}
block|}
return|return
name|h
return|;
block|}
name|void
name|archive_read_extract_set_progress_callback
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|void
function_decl|(
modifier|*
name|progress_func
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|user_data
parameter_list|)
block|{
name|a
operator|->
name|extract_progress
operator|=
name|progress_func
expr_stmt|;
name|a
operator|->
name|extract_progress_user_data
operator|=
name|user_data
expr_stmt|;
block|}
end_function

end_unit

