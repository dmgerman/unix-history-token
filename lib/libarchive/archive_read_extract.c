begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2004 Tim Kientzle  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer  *    in this position and unchanged.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/acl.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|DMALLOC
end_ifdef

begin_include
include|#
directive|include
file|<dmalloc.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<tar.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"archive.h"
end_include

begin_include
include|#
directive|include
file|"archive_string.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry.h"
end_include

begin_include
include|#
directive|include
file|"archive_private.h"
end_include

begin_function_decl
specifier|static
name|void
name|archive_extract_cleanup
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_extract_block_device
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_extract_char_device
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_extract_device
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
name|flags
parameter_list|,
name|mode_t
name|mode
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_extract_dir
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_extract_dir_create
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_extract_fifo
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_extract_hard_link
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_extract_regular
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_extract_regular_open
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|archive_read_extract_symbolic_link
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mkdirpath
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mkdirpath_recursive
parameter_list|(
name|char
modifier|*
name|path
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|mksubdir
parameter_list|(
name|char
modifier|*
name|path
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_acls
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_extended_perm
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_fflags
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_ownership
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_perm
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|set_time
parameter_list|(
name|struct
name|archive
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Extract this entry to disk.  *  * TODO: Validate hardlinks.  Is there any way to validate hardlinks  * without keeping a complete list of filenames from the entire archive?? Ugh.  *  */
end_comment

begin_function
name|int
name|archive_read_extract
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|mode_t
name|writable_mode
decl_stmt|;
name|struct
name|archive_extract_dir_entry
modifier|*
name|le
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|restore_pwd
decl_stmt|;
name|restore_pwd
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|archive_entry_stat
argument_list|(
name|entry
argument_list|)
operator|->
name|st_mode
argument_list|)
condition|)
block|{
comment|/* 		 * TODO: Does this really work under all conditions? 		 * 		 * E.g., root restores a dir owned by someone else? 		 */
name|writable_mode
operator|=
name|archive_entry_stat
argument_list|(
name|entry
argument_list|)
operator|->
name|st_mode
operator||
literal|0700
expr_stmt|;
comment|/* 		 * If this dir isn't writable, restore it with write 		 * permissions and add it to the fixup list for later 		 * handling. 		 */
if|if
condition|(
name|archive_entry_stat
argument_list|(
name|entry
argument_list|)
operator|->
name|st_mode
operator|!=
name|writable_mode
condition|)
block|{
name|le
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|archive_extract_dir_entry
argument_list|)
argument_list|)
expr_stmt|;
name|le
operator|->
name|next
operator|=
name|a
operator|->
name|archive_extract_dir_list
expr_stmt|;
name|a
operator|->
name|archive_extract_dir_list
operator|=
name|le
expr_stmt|;
name|le
operator|->
name|mode
operator|=
name|archive_entry_stat
argument_list|(
name|entry
argument_list|)
operator|->
name|st_mode
expr_stmt|;
name|le
operator|->
name|name
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|le
operator|->
name|name
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|->
name|cleanup_archive_extract
operator|=
name|archive_extract_cleanup
expr_stmt|;
comment|/* Make sure I can write to this directory. */
name|archive_entry_set_mode
argument_list|(
name|entry
argument_list|,
name|writable_mode
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|archive_entry_hardlink
argument_list|(
name|entry
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|archive_read_extract_hard_link
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
operator|)
return|;
comment|/* 	 * TODO: If pathname is longer than PATH_MAX, record starting 	 * directory and move to a suitable intermediate dir, which 	 * might require creating them! 	 */
if|if
condition|(
name|strlen
argument_list|(
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
operator|>
name|PATH_MAX
condition|)
block|{
name|restore_pwd
operator|=
name|open
argument_list|(
literal|"."
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
comment|/* XXX chdir() to a suitable intermediate dir XXX */
comment|/* XXX Update pathname in 'entry' XXX */
block|}
switch|switch
condition|(
name|archive_entry_stat
argument_list|(
name|entry
argument_list|)
operator|->
name|st_mode
operator|&
name|S_IFMT
condition|)
block|{
default|default:
comment|/* Fall through, as required by POSIX. */
case|case
name|S_IFREG
case|:
name|ret
operator|=
name|archive_read_extract_regular
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_IFLNK
case|:
comment|/* Symlink */
name|ret
operator|=
name|archive_read_extract_symbolic_link
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_IFCHR
case|:
name|ret
operator|=
name|archive_read_extract_char_device
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_IFBLK
case|:
name|ret
operator|=
name|archive_read_extract_block_device
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_IFDIR
case|:
name|ret
operator|=
name|archive_read_extract_dir
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_IFIFO
case|:
name|ret
operator|=
name|archive_read_extract_fifo
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* If we changed directory above, restore it here. */
if|if
condition|(
name|restore_pwd
operator|>=
literal|0
condition|)
name|fchdir
argument_list|(
name|restore_pwd
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Cleanup function for archive_extract.  Free name/mode list and  * restore permissions.  *  * TODO: Restore times here as well.  *  * Registering this function (rather than calling it explicitly by  * name from archive_read_finish) reduces link pollution, since  * applications that don't use this API won't get this file linked in.  */
end_comment

begin_function
specifier|static
name|void
name|archive_extract_cleanup
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|archive_extract_dir_entry
modifier|*
name|lp
decl_stmt|;
comment|/* 	 * TODO: Does dir list need to be sorted so permissions are restored 	 * depth-first? 	 */
while|while
condition|(
name|a
operator|->
name|archive_extract_dir_list
condition|)
block|{
name|lp
operator|=
name|a
operator|->
name|archive_extract_dir_list
operator|->
name|next
expr_stmt|;
name|chmod
argument_list|(
name|a
operator|->
name|archive_extract_dir_list
operator|->
name|name
argument_list|,
name|a
operator|->
name|archive_extract_dir_list
operator|->
name|mode
argument_list|)
expr_stmt|;
comment|/* 		 * TODO: Consider using this hook to restore dir 		 * timestamps as well.  However, dir timestamps don't 		 * really matter, and it would be a memory issue to 		 * record timestamps for every directory 		 * extracted... Ugh. 		 */
if|if
condition|(
name|a
operator|->
name|archive_extract_dir_list
operator|->
name|name
condition|)
name|free
argument_list|(
name|a
operator|->
name|archive_extract_dir_list
operator|->
name|name
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|a
operator|->
name|archive_extract_dir_list
argument_list|)
expr_stmt|;
name|a
operator|->
name|archive_extract_dir_list
operator|=
name|lp
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_extract_regular
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|fd
decl_stmt|,
name|r
decl_stmt|;
name|ssize_t
name|s
decl_stmt|;
name|r
operator|=
name|ARCHIVE_OK
expr_stmt|;
name|fd
operator|=
name|archive_read_extract_regular_open
argument_list|(
name|a
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|,
name|archive_entry_stat
argument_list|(
name|entry
argument_list|)
operator|->
name|st_mode
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"Can't open"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
name|s
operator|=
name|archive_read_data_into_fd
argument_list|(
name|a
argument_list|,
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
name|archive_entry_size
argument_list|(
name|entry
argument_list|)
condition|)
block|{
comment|/* Didn't read enough data?  Complain but keep going. */
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|EIO
argument_list|,
literal|"Archive data truncated"
argument_list|)
expr_stmt|;
name|r
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
name|set_ownership
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|set_time
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* set_perm(a, entry, mode, flags); */
comment|/* Handled implicitly by open.*/
name|set_extended_perm
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Keep trying until we either open the file or run out of tricks.  *  * Note: the GNU tar 'unlink first' option seems redundant  * with this strategy, since we never actually write over an  * existing file.  (If it already exists, we remove it.)  */
end_comment

begin_function
specifier|static
name|int
name|archive_read_extract_regular_open
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|fd
decl_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
return|return
operator|(
name|fd
operator|)
return|;
comment|/* Try removing a pre-existing file. */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|ARCHIVE_EXTRACT_NO_OVERWRITE
operator|)
condition|)
block|{
name|unlink
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
return|return
operator|(
name|fd
operator|)
return|;
block|}
comment|/* Might be a non-existent parent dir; try fixing that. */
name|mkdirpath
argument_list|(
name|a
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|name
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|>=
literal|0
condition|)
return|return
operator|(
name|fd
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_extract_dir
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|mode
decl_stmt|,
name|ret
decl_stmt|,
name|ret2
decl_stmt|;
name|mode
operator|=
name|archive_entry_stat
argument_list|(
name|entry
argument_list|)
operator|->
name|st_mode
expr_stmt|;
if|if
condition|(
name|archive_read_extract_dir_create
argument_list|(
name|a
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|,
name|mode
argument_list|,
name|flags
argument_list|)
condition|)
block|{
comment|/* Unable to create directory; just use the existing dir. */
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
name|set_ownership
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* 	 * There is no point in setting the time here. 	 * 	 * Note that future extracts into this directory will reset 	 * the times, so to get correct results, the client has to 	 * track timestamps for directories and update them at the end 	 * of the run anyway. 	 */
comment|/* set_time(t, flags); */
comment|/* 	 * This next line may appear redundant, but it's not.  If the 	 * directory already exists, it won't get re-created by 	 * mkdir(), so we have to manually set permissions to get 	 * everything right. 	 */
name|ret
operator|=
name|set_perm
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|mode
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|ret2
operator|=
name|set_extended_perm
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* XXXX TODO: Fix this to work the right way. XXXX */
if|if
condition|(
name|ret
operator|==
name|ARCHIVE_OK
condition|)
return|return
operator|(
name|ret2
operator|)
return|;
else|else
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create the directory: try until something works or we run out of magic.  */
end_comment

begin_function
specifier|static
name|int
name|archive_read_extract_dir_create
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
comment|/* Don't try to create '.' */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
if|if
condition|(
name|mkdir
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
if|if
condition|(
name|errno
operator|==
name|ENOENT
condition|)
block|{
comment|/* Missing parent directory. */
name|mkdirpath
argument_list|(
name|a
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|mkdir
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
if|if
condition|(
name|errno
operator|!=
name|EEXIST
condition|)
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
if|if
condition|(
operator|(
name|flags
operator|&
name|ARCHIVE_EXTRACT_NO_OVERWRITE
operator|)
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|EEXIST
argument_list|,
literal|"Directory already exists"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
comment|/* Could be a file; try unlinking. */
if|if
condition|(
name|unlink
argument_list|(
name|name
argument_list|)
operator|==
literal|0
operator|&&
name|mkdir
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
comment|/* Unlink failed. It's okay if it failed because it's already a dir. */
if|if
condition|(
name|errno
operator|!=
name|EPERM
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"Couldn't create dir"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
comment|/* Try removing the directory and recreating it from scratch. */
if|if
condition|(
name|rmdir
argument_list|(
name|name
argument_list|)
condition|)
block|{
comment|/* Failure to remove a non-empty directory is not a problem. */
if|if
condition|(
name|errno
operator|==
name|ENOTEMPTY
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
comment|/* Any other failure is a problem. */
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"Error attempting to remove existing directory"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
comment|/* We successfully removed the directory; now recreate it. */
if|if
condition|(
name|mkdir
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"Failed to create dir"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_extract_hard_link
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
comment|/* Just remove any pre-existing file with this name. */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|ARCHIVE_EXTRACT_NO_OVERWRITE
operator|)
condition|)
name|unlink
argument_list|(
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|link
argument_list|(
name|archive_entry_hardlink
argument_list|(
name|entry
argument_list|)
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"Can't restore hardlink"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
comment|/* Set ownership, time, permission information. */
name|set_ownership
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|set_time
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|set_perm
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|archive_entry_stat
argument_list|(
name|entry
argument_list|)
operator|->
name|st_mode
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|set_extended_perm
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_extract_symbolic_link
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
comment|/* Just remove any pre-existing file with this name. */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|ARCHIVE_EXTRACT_NO_OVERWRITE
operator|)
condition|)
name|unlink
argument_list|(
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|symlink
argument_list|(
name|archive_entry_symlink
argument_list|(
name|entry
argument_list|)
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
condition|)
block|{
comment|/* XXX Better error message here XXX */
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"Can't restore symlink to '%s'"
argument_list|,
name|archive_entry_symlink
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
comment|/* Set ownership, time, permission information. */
name|set_ownership
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|set_time
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|set_perm
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|archive_entry_stat
argument_list|(
name|entry
argument_list|)
operator|->
name|st_mode
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|set_extended_perm
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_extract_device
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|int
name|flags
parameter_list|,
name|mode_t
name|mode
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
comment|/* Just remove any pre-existing file with this name. */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|ARCHIVE_EXTRACT_NO_OVERWRITE
operator|)
condition|)
name|unlink
argument_list|(
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|mknod
argument_list|(
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|,
name|mode
argument_list|,
name|archive_entry_stat
argument_list|(
name|entry
argument_list|)
operator|->
name|st_rdev
argument_list|)
expr_stmt|;
comment|/* Might be a non-existent parent dir; try fixing that. */
if|if
condition|(
name|r
operator|!=
literal|0
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|mkdirpath
argument_list|(
name|a
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|mknod
argument_list|(
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|,
name|mode
argument_list|,
name|archive_entry_stat
argument_list|(
name|entry
argument_list|)
operator|->
name|st_rdev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"Can't recreate device node"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
comment|/* Set ownership, time, permission information. */
name|set_ownership
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|set_time
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|set_perm
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|archive_entry_stat
argument_list|(
name|entry
argument_list|)
operator|->
name|st_mode
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|set_extended_perm
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_extract_char_device
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|mode_t
name|mode
decl_stmt|;
name|mode
operator|=
operator|(
name|archive_entry_stat
argument_list|(
name|entry
argument_list|)
operator|->
name|st_mode
operator|&
operator|~
name|S_IFMT
operator|)
operator||
name|S_IFCHR
expr_stmt|;
return|return
operator|(
name|archive_read_extract_device
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_extract_block_device
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|mode_t
name|mode
decl_stmt|;
name|mode
operator|=
operator|(
name|archive_entry_stat
argument_list|(
name|entry
argument_list|)
operator|->
name|st_mode
operator|&
operator|~
name|S_IFMT
operator|)
operator||
name|S_IFBLK
expr_stmt|;
return|return
operator|(
name|archive_read_extract_device
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_read_extract_fifo
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
comment|/* Just remove any pre-existing file with this name. */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|ARCHIVE_EXTRACT_NO_OVERWRITE
operator|)
condition|)
name|unlink
argument_list|(
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|mkfifo
argument_list|(
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|,
name|archive_entry_stat
argument_list|(
name|entry
argument_list|)
operator|->
name|st_mode
argument_list|)
expr_stmt|;
comment|/* Might be a non-existent parent dir; try fixing that. */
if|if
condition|(
name|r
operator|!=
literal|0
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
block|{
name|mkdirpath
argument_list|(
name|a
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|=
name|mkfifo
argument_list|(
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|,
name|archive_entry_stat
argument_list|(
name|entry
argument_list|)
operator|->
name|st_mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"Can't restore fifo"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
comment|/* Set ownership, time, permission information. */
name|set_ownership
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|set_time
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* Done by mkfifo. */
comment|/* set_perm(a, entry, archive_entry_stat(entry)->st_mode, flags); */
name|set_extended_perm
argument_list|(
name|a
argument_list|,
name|entry
argument_list|,
name|flags
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns 0 if it successfully created necessary directories.  * Otherwise, returns ARCHIVE_WARN.  */
end_comment

begin_function
specifier|static
name|int
name|mkdirpath
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
comment|/* Copy path to mutable storage, then call mkdirpath_recursive. */
name|archive_strcpy
argument_list|(
operator|&
operator|(
name|a
operator|->
name|extract_mkdirpath
operator|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* Prune a trailing '/' character. */
name|p
operator|=
name|a
operator|->
name|extract_mkdirpath
operator|.
name|s
expr_stmt|;
if|if
condition|(
name|p
index|[
name|strlen
argument_list|(
name|p
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
name|p
index|[
name|strlen
argument_list|(
name|p
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Recursively try to build the path. */
return|return
operator|(
name|mkdirpath_recursive
argument_list|(
name|p
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * For efficiency, just try creating longest path first (usually,  * archives walk through directories in a reasonable order).  If that  * fails, prune the last element and recursively try again.  */
end_comment

begin_function
specifier|static
name|int
name|mkdirpath_recursive
parameter_list|(
name|char
modifier|*
name|path
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|r
decl_stmt|;
name|p
operator|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
comment|/* Terminate path name. */
name|r
operator|=
name|mksubdir
argument_list|(
name|path
argument_list|)
expr_stmt|;
comment|/* Try building path. */
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
comment|/* Restore the '/' we just overwrote. */
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|mksubdir
parameter_list|(
name|char
modifier|*
name|path
parameter_list|)
block|{
name|int
name|mode
init|=
literal|0755
decl_stmt|;
if|if
condition|(
name|mkdir
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|errno
operator|==
name|EEXIST
condition|)
comment|/* TODO: stat() here to verify it is dir */
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|mkdirpath_recursive
argument_list|(
name|path
argument_list|)
condition|)
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
if|if
condition|(
name|mkdir
argument_list|(
name|path
argument_list|,
name|mode
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
comment|/* Still failed.  Harumph. */
block|}
end_function

begin_comment
comment|/*  * Note that I only inspect entry->ae_uid and entry->ae_gid here; if  * the client wants POSIX compat, they'll need to do uname/gname  * lookups themselves.  I don't do it here because of the potential  * performance issues: if uname/gname lookup is expensive, then the  * results should be aggressively cached; if they're cheap, then we  * shouldn't waste memory on cache tables.  *  * Returns 0 if UID/GID successfully restored; ARCHIVE_WARN otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|set_ownership
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
comment|/* If UID/GID are already correct, return 0. */
comment|/* TODO: Fix this; need to stat() to find on-disk GID<sigh> */
if|if
condition|(
name|a
operator|->
name|user_uid
operator|==
name|archive_entry_stat
argument_list|(
name|entry
argument_list|)
operator|->
name|st_uid
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Not changed. */
if|if
condition|(
operator|(
name|flags
operator|&
name|ARCHIVE_EXTRACT_OWNER
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
comment|/* 	 * Root can change owner/group; owner can change group; 	 * otherwise, bail out now. 	 */
if|if
condition|(
operator|(
name|a
operator|->
name|user_uid
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|a
operator|->
name|user_uid
operator|!=
name|archive_entry_stat
argument_list|(
name|entry
argument_list|)
operator|->
name|st_uid
operator|)
condition|)
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
if|if
condition|(
name|lchown
argument_list|(
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|,
name|archive_entry_stat
argument_list|(
name|entry
argument_list|)
operator|->
name|st_uid
argument_list|,
name|archive_entry_stat
argument_list|(
name|entry
argument_list|)
operator|->
name|st_gid
argument_list|)
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"Can't set user=%d/group=%d for %s"
argument_list|,
name|archive_entry_stat
argument_list|(
name|entry
argument_list|)
operator|->
name|st_uid
argument_list|,
name|archive_entry_stat
argument_list|(
name|entry
argument_list|)
operator|->
name|st_gid
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_time
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
specifier|const
name|struct
name|stat
modifier|*
name|st
decl_stmt|;
name|struct
name|timeval
name|times
index|[
literal|2
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|a
expr_stmt|;
comment|/* UNUSED */
name|st
operator|=
name|archive_entry_stat
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|ARCHIVE_EXTRACT_TIME
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
name|times
index|[
literal|1
index|]
operator|.
name|tv_sec
operator|=
name|st
operator|->
name|st_mtime
expr_stmt|;
name|times
index|[
literal|1
index|]
operator|.
name|tv_usec
operator|=
name|st
operator|->
name|st_mtimespec
operator|.
name|tv_nsec
operator|/
literal|1000
expr_stmt|;
name|times
index|[
literal|0
index|]
operator|.
name|tv_sec
operator|=
name|st
operator|->
name|st_atime
expr_stmt|;
name|times
index|[
literal|0
index|]
operator|.
name|tv_usec
operator|=
name|st
operator|->
name|st_atimespec
operator|.
name|tv_nsec
operator|/
literal|1000
expr_stmt|;
if|if
condition|(
name|lutimes
argument_list|(
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|,
name|times
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"Can't update time for %s"
argument_list|,
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
comment|/* 	 * Note: POSIX does not provide a portable way to restore ctime. 	 * So, any restoration of ctime will necessarily be OS-specific. 	 */
comment|/* TODO: Can FreeBSD restore ctime? */
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_perm
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|ARCHIVE_EXTRACT_PERM
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
name|name
operator|=
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|lchmod
argument_list|(
name|name
argument_list|,
name|mode
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"Can't set permissions"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_extended_perm
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|ARCHIVE_EXTRACT_PERM
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
name|ret
operator|=
name|set_fflags
argument_list|(
name|a
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|ARCHIVE_OK
condition|)
name|ret
operator|=
name|set_acls
argument_list|(
name|a
argument_list|,
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|set_fflags
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
name|char
modifier|*
name|fflags
decl_stmt|;
specifier|const
name|char
modifier|*
name|fflagsc
decl_stmt|;
name|char
modifier|*
name|fflags_p
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|unsigned
name|long
name|set
decl_stmt|,
name|clear
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|name
operator|=
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_OK
expr_stmt|;
name|fflagsc
operator|=
name|archive_entry_fflags
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflagsc
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
name|fflags
operator|=
name|strdup
argument_list|(
name|fflagsc
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflags
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
name|fflags_p
operator|=
name|fflags
expr_stmt|;
if|if
condition|(
name|strtofflags
argument_list|(
operator|&
name|fflags_p
argument_list|,
operator|&
name|set
argument_list|,
operator|&
name|clear
argument_list|)
operator|!=
literal|0
operator|&&
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|st
argument_list|)
operator|==
literal|0
condition|)
block|{
name|st
operator|.
name|st_flags
operator|&=
operator|~
name|clear
expr_stmt|;
name|st
operator|.
name|st_flags
operator||=
name|set
expr_stmt|;
if|if
condition|(
name|chflags
argument_list|(
name|name
argument_list|,
name|st
operator|.
name|st_flags
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"Failed to set file flags"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|fflags
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * XXX TODO: What about ACL types other than ACCESS and DEFAULT?  */
end_comment

begin_function
specifier|static
name|int
name|set_acls
parameter_list|(
name|struct
name|archive
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|acldesc
decl_stmt|;
name|acl_t
name|acl
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|ARCHIVE_OK
expr_stmt|;
name|name
operator|=
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|acldesc
operator|=
name|archive_entry_acl
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|acldesc
operator|!=
name|NULL
condition|)
block|{
name|acl
operator|=
name|acl_from_text
argument_list|(
name|acldesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|acl
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"Error parsing acl '%s'"
argument_list|,
name|acldesc
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|acl_set_file
argument_list|(
name|name
argument_list|,
name|ACL_TYPE_ACCESS
argument_list|,
name|acl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"Failed to set acl"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
name|acl_free
argument_list|(
name|acl
argument_list|)
expr_stmt|;
block|}
block|}
name|acldesc
operator|=
name|archive_entry_acl_default
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|acldesc
operator|!=
name|NULL
condition|)
block|{
name|acl
operator|=
name|acl_from_text
argument_list|(
name|acldesc
argument_list|)
expr_stmt|;
if|if
condition|(
name|acl
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"error parsing acl '%s'"
argument_list|,
name|acldesc
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|acl_set_file
argument_list|(
name|name
argument_list|,
name|ACL_TYPE_DEFAULT
argument_list|,
name|acl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|archive_set_error
argument_list|(
name|a
argument_list|,
name|errno
argument_list|,
literal|"Failed to set acl"
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ARCHIVE_WARN
expr_stmt|;
block|}
name|acl_free
argument_list|(
name|acl
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

end_unit

