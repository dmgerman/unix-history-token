begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003-2008 Tim Kientzle  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|ARCHIVE_ENTRY_H_INCLUDED
end_ifndef

begin_define
define|#
directive|define
name|ARCHIVE_ENTRY_H_INCLUDED
end_define

begin_comment
comment|/*  * Note: archive_entry.h is for use outside of libarchive; the  * configuration headers (config.h, archive_platform.h, etc.) are  * purely internal.  Do NOT use HAVE_XXX configuration macros to  * control the behavior of this header!  If you must conditionalize,  * use predefined compiler and/or platform macros.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_comment
comment|/* for wchar_t */
end_comment

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_include
include|#
directive|include
file|<windows.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Get appropriate definitions of standard POSIX-style types. */
end_comment

begin_comment
comment|/* These should match the types used in 'struct stat' */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_define
define|#
directive|define
name|__LA_INT64_T
value|__int64
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__BORLANDC__
argument_list|)
end_if

begin_define
define|#
directive|define
name|__LA_UID_T
value|uid_t
end_define

begin_define
define|#
directive|define
name|__LA_GID_T
value|gid_t
end_define

begin_define
define|#
directive|define
name|__LA_DEV_T
value|dev_t
end_define

begin_define
define|#
directive|define
name|__LA_MODE_T
value|mode_t
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|__LA_UID_T
value|short
end_define

begin_define
define|#
directive|define
name|__LA_GID_T
value|short
end_define

begin_define
define|#
directive|define
name|__LA_DEV_T
value|unsigned int
end_define

begin_define
define|#
directive|define
name|__LA_MODE_T
value|unsigned short
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_define
define|#
directive|define
name|__LA_INT64_T
value|int64_t
end_define

begin_define
define|#
directive|define
name|__LA_UID_T
value|uid_t
end_define

begin_define
define|#
directive|define
name|__LA_GID_T
value|gid_t
end_define

begin_define
define|#
directive|define
name|__LA_DEV_T
value|dev_t
end_define

begin_define
define|#
directive|define
name|__LA_MODE_T
value|mode_t
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * XXX Is this defined for all Windows compilers?  If so, in what  * header?  It would be nice to remove the __LA_INO_T indirection and  * just use plain ino_t everywhere.  Likewise for the other types just  * above.  */
end_comment

begin_define
define|#
directive|define
name|__LA_INO_T
value|ino_t
end_define

begin_comment
comment|/*  * On Windows, define LIBARCHIVE_STATIC if you're building or using a  * .lib.  The default here assumes you're building a DLL.  Only  * libarchive source should ever define __LIBARCHIVE_BUILD.  */
end_comment

begin_if
if|#
directive|if
operator|(
operator|(
name|defined
name|__WIN32__
operator|)
operator|||
operator|(
name|defined
name|_WIN32
operator|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|defined
name|LIBARCHIVE_STATIC
operator|)
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|__LIBARCHIVE_BUILD
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|__LA_DECL
value|__attribute__((dllexport)) extern
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|__LA_DECL
value|__declspec(dllexport)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|__LA_DECL
value|__attribute__((dllimport)) extern
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|__LA_DECL
value|__declspec(dllimport)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Static libraries on all platforms and shared libraries on non-Windows. */
end_comment

begin_define
define|#
directive|define
name|__LA_DECL
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/*  * Description of an archive entry.  *  * You can think of this as "struct stat" with some text fields added in.  *  * TODO: Add "comment", "charset", and possibly other entries that are  * supported by "pax interchange" format.  However, GNU, ustar, cpio,  * and other variants don't support these features, so they're not an  * excruciatingly high priority right now.  *  * TODO: "pax interchange" format allows essentially arbitrary  * key/value attributes to be attached to any entry.  Supporting  * such extensions may make this library useful for special  * applications (e.g., a package manager could attach special  * package-management attributes to each entry).  */
struct_decl|struct
name|archive_entry
struct_decl|;
comment|/*  * File-type constants.  These are returned from archive_entry_filetype()  * and passed to archive_entry_set_filetype().  *  * These values match S_XXX defines on every platform I've checked,  * including Windows, AIX, Linux, Solaris, and BSD.  They're  * (re)defined here because platforms generally don't define the ones  * they don't support.  For example, Windows doesn't define S_IFLNK or  * S_IFBLK.  Instead of having a mass of conditional logic and system  * checks to define any S_XXX values that aren't supported locally,  * I've just defined a new set of such constants so that  * libarchive-based applications can manipulate and identify archive  * entries properly even if the hosting platform can't store them on  * disk.  *  * These values are also used directly within some portable formats,  * such as cpio.  If you find a platform that varies from these, the  * correct solution is to leave these alone and translate from these  * portable values to platform-native values when entries are read from  * or written to disk.  */
define|#
directive|define
name|AE_IFMT
value|0170000
define|#
directive|define
name|AE_IFREG
value|0100000
define|#
directive|define
name|AE_IFLNK
value|0120000
define|#
directive|define
name|AE_IFSOCK
value|0140000
define|#
directive|define
name|AE_IFCHR
value|0020000
define|#
directive|define
name|AE_IFBLK
value|0060000
define|#
directive|define
name|AE_IFDIR
value|0040000
define|#
directive|define
name|AE_IFIFO
value|0010000
comment|/*  * Basic object manipulation  */
name|__LA_DECL
name|struct
name|archive_entry
modifier|*
name|archive_entry_clear
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
comment|/* The 'clone' function does a deep copy; all of the strings are copied too. */
name|__LA_DECL
name|struct
name|archive_entry
modifier|*
name|archive_entry_clone
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_free
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|struct
name|archive_entry
modifier|*
name|archive_entry_new
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/*  * Retrieve fields from an archive_entry.  *  * There are a number of implicit conversions among these fields.  For  * example, if a regular string field is set and you read the _w wide  * character field, the entry will implicitly convert narrow-to-wide  * using the current locale.  Similarly, dev values are automatically  * updated when you write devmajor or devminor and vice versa.  *  * In addition, fields can be "set" or "unset."  Unset string fields  * return NULL, non-string fields have _is_set() functions to test  * whether they've been set.  You can "unset" a string field by  * assigning NULL; non-string fields have _unset() functions to  * unset them.  *  * Note: There is one ambiguity in the above; string fields will  * also return NULL when implicit character set conversions fail.  * This is usually what you want.  */
name|__LA_DECL
name|time_t
name|archive_entry_atime
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|long
name|archive_entry_atime_nsec
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_atime_is_set
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|time_t
name|archive_entry_birthtime
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|long
name|archive_entry_birthtime_nsec
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_birthtime_is_set
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|time_t
name|archive_entry_ctime
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|long
name|archive_entry_ctime_nsec
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_ctime_is_set
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|dev_t
name|archive_entry_dev
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|dev_t
name|archive_entry_devmajor
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|dev_t
name|archive_entry_devminor
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|__LA_MODE_T
name|archive_entry_filetype
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_fflags
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|unsigned
name|long
modifier|*
comment|/* set */
parameter_list|,
name|unsigned
name|long
modifier|*
comment|/* clear */
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|char
modifier|*
name|archive_entry_fflags_text
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|__LA_GID_T
name|archive_entry_gid
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|char
modifier|*
name|archive_entry_gname
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|wchar_t
modifier|*
name|archive_entry_gname_w
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|char
modifier|*
name|archive_entry_hardlink
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|wchar_t
modifier|*
name|archive_entry_hardlink_w
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|__LA_INO_T
name|archive_entry_ino
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|__LA_INT64_T
name|archive_entry_ino64
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|__LA_MODE_T
name|archive_entry_mode
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|time_t
name|archive_entry_mtime
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|long
name|archive_entry_mtime_nsec
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_mtime_is_set
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|unsigned
name|int
name|archive_entry_nlink
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|char
modifier|*
name|archive_entry_pathname
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|wchar_t
modifier|*
name|archive_entry_pathname_w
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|dev_t
name|archive_entry_rdev
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|dev_t
name|archive_entry_rdevmajor
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|dev_t
name|archive_entry_rdevminor
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|char
modifier|*
name|archive_entry_sourcepath
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|__LA_INT64_T
name|archive_entry_size
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_size_is_set
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|char
modifier|*
name|archive_entry_strmode
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|char
modifier|*
name|archive_entry_symlink
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|wchar_t
modifier|*
name|archive_entry_symlink_w
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|__LA_UID_T
name|archive_entry_uid
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|char
modifier|*
name|archive_entry_uname
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|wchar_t
modifier|*
name|archive_entry_uname_w
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
comment|/*  * Set fields in an archive_entry.  *  * Note that string 'set' functions do not copy the string, only the pointer.  * In contrast, 'copy' functions do copy the object pointed to.  *  * Note: As of libarchive 2.4, 'set' functions do copy the string and  * are therefore exact synonyms for the 'copy' versions.  The 'copy'  * names will be retired in libarchive 3.0.  */
name|__LA_DECL
name|void
name|archive_entry_set_atime
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|time_t
parameter_list|,
name|long
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_unset_atime
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
if|#
directive|if
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
name|__LA_DECL
name|void
name|archive_entry_copy_bhfi
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|BY_HANDLE_FILE_INFORMATION
modifier|*
parameter_list|)
function_decl|;
endif|#
directive|endif
name|__LA_DECL
name|void
name|archive_entry_set_birthtime
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|time_t
parameter_list|,
name|long
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_unset_birthtime
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_ctime
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|time_t
parameter_list|,
name|long
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_unset_ctime
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_dev
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|dev_t
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_devmajor
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|dev_t
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_devminor
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|dev_t
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_filetype
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_fflags
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|unsigned
name|long
comment|/* set */
parameter_list|,
name|unsigned
name|long
comment|/* clear */
parameter_list|)
function_decl|;
comment|/* Returns pointer to start of first invalid token, or NULL if none. */
comment|/* Note that all recognized tokens are processed, regardless. */
name|__LA_DECL
specifier|const
name|char
modifier|*
name|archive_entry_copy_fflags_text
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
specifier|const
name|wchar_t
modifier|*
name|archive_entry_copy_fflags_text_w
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|wchar_t
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_gid
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|__LA_GID_T
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_gname
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_copy_gname
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_copy_gname_w
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|wchar_t
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_update_gname_utf8
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_hardlink
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_copy_hardlink
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_copy_hardlink_w
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|wchar_t
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_update_hardlink_utf8
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
if|#
directive|if
name|ARCHIVE_VERSION_NUMBER
operator|>=
literal|3000000
comment|/* Starting with libarchive 3.0, this will be synonym for ino64. */
name|__LA_DECL
name|void
name|archive_entry_set_ino
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|__LA_INT64_T
parameter_list|)
function_decl|;
else|#
directive|else
name|__LA_DECL
name|void
name|archive_entry_set_ino
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|unsigned
name|long
parameter_list|)
function_decl|;
endif|#
directive|endif
name|__LA_DECL
name|void
name|archive_entry_set_ino64
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|__LA_INT64_T
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_link
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_copy_link
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_copy_link_w
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|wchar_t
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_update_link_utf8
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_mode
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|__LA_MODE_T
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_mtime
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|time_t
parameter_list|,
name|long
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_unset_mtime
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_nlink
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|unsigned
name|int
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_pathname
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_copy_pathname
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_copy_pathname_w
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|wchar_t
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_update_pathname_utf8
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_perm
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|__LA_MODE_T
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_rdev
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|dev_t
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_rdevmajor
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|dev_t
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_rdevminor
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|dev_t
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_size
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|__LA_INT64_T
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_unset_size
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_copy_sourcepath
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_symlink
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_copy_symlink
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_copy_symlink_w
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|wchar_t
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_update_symlink_utf8
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_uid
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|__LA_UID_T
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_set_uname
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_copy_uname
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_copy_uname_w
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|wchar_t
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_update_uname_utf8
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
comment|/*  * Routines to bulk copy fields to/from a platform-native "struct  * stat."  Libarchive used to just store a struct stat inside of each  * archive_entry object, but this created issues when trying to  * manipulate archives on systems different than the ones they were  * created on.  *  * TODO: On Linux, provide both stat32 and stat64 versions of these functions.  */
name|__LA_DECL
specifier|const
expr|struct
name|stat
operator|*
name|archive_entry_stat
argument_list|(
expr|struct
name|archive_entry
operator|*
argument_list|)
expr_stmt|;
name|__LA_DECL
name|void
name|archive_entry_copy_stat
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|struct
name|stat
modifier|*
parameter_list|)
function_decl|;
comment|/*  * ACL routines.  This used to simply store and return text-format ACL  * strings, but that proved insufficient for a number of reasons:  *   = clients need control over uname/uid and gname/gid mappings  *   = there are many different ACL text formats  *   = would like to be able to read/convert archives containing ACLs  *     on platforms that lack ACL libraries  *  *  This last point, in particular, forces me to implement a reasonably  *  complete set of ACL support routines.  *  *  TODO: Extend this to support NFSv4/NTFS permissions.  That should  *  allow full ACL support on Mac OS, in particular, which uses  *  POSIX.1e-style interfaces to manipulate NFSv4/NTFS permissions.  */
comment|/*  * Permission bits mimic POSIX.1e.  Note that I've not followed POSIX.1e's  * "permset"/"perm" abstract type nonsense.  A permset is just a simple  * bitmap, following long-standing Unix tradition.  */
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_EXECUTE
value|1
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_WRITE
value|2
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_READ
value|4
comment|/* We need to be able to specify either or both of these. */
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_TYPE_ACCESS
value|256
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_TYPE_DEFAULT
value|512
comment|/* Tag values mimic POSIX.1e */
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_USER
value|10001
comment|/* Specified user. */
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_USER_OBJ
value|10002
comment|/* User who owns the file. */
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_GROUP
value|10003
comment|/* Specified group. */
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_GROUP_OBJ
value|10004
comment|/* Group who owns the file. */
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_MASK
value|10005
comment|/* Modify group access. */
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_OTHER
value|10006
comment|/* Public. */
comment|/*  * Set the ACL by clearing it and adding entries one at a time.  * Unlike the POSIX.1e ACL routines, you must specify the type  * (access/default) for each entry.  Internally, the ACL data is just  * a soup of entries.  API calls here allow you to retrieve just the  * entries of interest.  This design (which goes against the spirit of  * POSIX.1e) is useful for handling archive formats that combine  * default and access information in a single ACL list.  */
name|__LA_DECL
name|void
name|archive_entry_acl_clear
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_acl_add_entry
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
comment|/* type */
parameter_list|,
name|int
comment|/* permset */
parameter_list|,
name|int
comment|/* tag */
parameter_list|,
name|int
comment|/* qual */
parameter_list|,
specifier|const
name|char
modifier|*
comment|/* name */
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_acl_add_entry_w
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
comment|/* type */
parameter_list|,
name|int
comment|/* permset */
parameter_list|,
name|int
comment|/* tag */
parameter_list|,
name|int
comment|/* qual */
parameter_list|,
specifier|const
name|wchar_t
modifier|*
comment|/* name */
parameter_list|)
function_decl|;
comment|/*  * To retrieve the ACL, first "reset", then repeatedly ask for the  * "next" entry.  The want_type parameter allows you to request only  * access entries or only default entries.  */
name|__LA_DECL
name|int
name|archive_entry_acl_reset
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
comment|/* want_type */
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_acl_next
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
comment|/* want_type */
parameter_list|,
name|int
modifier|*
comment|/* type */
parameter_list|,
name|int
modifier|*
comment|/* permset */
parameter_list|,
name|int
modifier|*
comment|/* tag */
parameter_list|,
name|int
modifier|*
comment|/* qual */
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
comment|/* name */
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_acl_next_w
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
comment|/* want_type */
parameter_list|,
name|int
modifier|*
comment|/* type */
parameter_list|,
name|int
modifier|*
comment|/* permset */
parameter_list|,
name|int
modifier|*
comment|/* tag */
parameter_list|,
name|int
modifier|*
comment|/* qual */
parameter_list|,
specifier|const
name|wchar_t
modifier|*
modifier|*
comment|/* name */
parameter_list|)
function_decl|;
comment|/*  * Construct a text-format ACL.  The flags argument is a bitmask that  * can include any of the following:  *  * ARCHIVE_ENTRY_ACL_TYPE_ACCESS - Include access entries.  * ARCHIVE_ENTRY_ACL_TYPE_DEFAULT - Include default entries.  * ARCHIVE_ENTRY_ACL_STYLE_EXTRA_ID - Include extra numeric ID field in  *    each ACL entry.  (As used by 'star'.)  * ARCHIVE_ENTRY_ACL_STYLE_MARK_DEFAULT - Include "default:" before each  *    default ACL entry.  */
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_STYLE_EXTRA_ID
value|1024
define|#
directive|define
name|ARCHIVE_ENTRY_ACL_STYLE_MARK_DEFAULT
value|2048
name|__LA_DECL
specifier|const
name|wchar_t
modifier|*
name|archive_entry_acl_text_w
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
comment|/* flags */
parameter_list|)
function_decl|;
comment|/* Return a count of entries matching 'want_type' */
name|__LA_DECL
name|int
name|archive_entry_acl_count
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
name|int
comment|/* want_type */
parameter_list|)
function_decl|;
comment|/*  * Private ACL parser.  This is private because it handles some  * very weird formats that clients should not be messing with.  * Clients should only deal with their platform-native formats.  * Because of the need to support many formats cleanly, new arguments  * are likely to get added on a regular basis.  Clients who try to use  * this interface are likely to be surprised when it changes.  *  * You were warned!  *  * TODO: Move this declaration out of the public header and into  * a private header.  Warnings above are silly.  */
name|__LA_DECL
name|int
name|__archive_entry_acl_parse_w
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|wchar_t
modifier|*
parameter_list|,
name|int
comment|/* type */
parameter_list|)
function_decl|;
comment|/*  * extended attributes  */
name|__LA_DECL
name|void
name|archive_entry_xattr_clear
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_xattr_add_entry
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
comment|/* name */
parameter_list|,
specifier|const
name|void
modifier|*
comment|/* value */
parameter_list|,
name|size_t
comment|/* size */
parameter_list|)
function_decl|;
comment|/*  * To retrieve the xattr list, first "reset", then repeatedly ask for the  * "next" entry.  */
name|__LA_DECL
name|int
name|archive_entry_xattr_count
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_xattr_reset
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|int
name|archive_entry_xattr_next
parameter_list|(
name|struct
name|archive_entry
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
comment|/* name */
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
comment|/* value */
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
comment|/*  * Utility to match up hardlinks.  *  * The 'struct archive_entry_linkresolver' is a cache of archive entries  * for files with multiple links.  Here's how to use it:  *   1. Create a lookup object with archive_entry_linkresolver_new()  *   2. Tell it the archive format you're using.  *   3. Hand each archive_entry to archive_entry_linkify().  *      That function will return 0, 1, or 2 entries that should  *      be written.  *   4. Call archive_entry_linkify(resolver, NULL) until  *      no more entries are returned.  *   5. Call archive_entry_link_resolver_free(resolver) to free resources.  *  * The entries returned have their hardlink and size fields updated  * appropriately.  If an entry is passed in that does not refer to  * a file with multiple links, it is returned unchanged.  The intention  * is that you should be able to simply filter all entries through  * this machine.  *  * To make things more efficient, be sure that each entry has a valid  * nlinks value.  The hardlink cache uses this to track when all links  * have been found.  If the nlinks value is zero, it will keep every  * name in the cache indefinitely, which can use a lot of memory.  *  * Note that archive_entry_size() is reset to zero if the file  * body should not be written to the archive.  Pay attention!  */
struct_decl|struct
name|archive_entry_linkresolver
struct_decl|;
comment|/*  * There are three different strategies for marking hardlinks.  * The descriptions below name them after the best-known  * formats that rely on each strategy:  *  * "Old cpio" is the simplest, it always returns any entry unmodified.  *    As far as I know, only cpio formats use this.  Old cpio archives  *    store every link with the full body; the onus is on the dearchiver  *    to detect and properly link the files as they are restored.  * "tar" is also pretty simple; it caches a copy the first time it sees  *    any link.  Subsequent appearances are modified to be hardlink  *    references to the first one without any body.  Used by all tar  *    formats, although the newest tar formats permit the "old cpio" strategy  *    as well.  This strategy is very simple for the dearchiver,  *    and reasonably straightforward for the archiver.  * "new cpio" is trickier.  It stores the body only with the last  *    occurrence.  The complication is that we might not  *    see every link to a particular file in a single session, so  *    there's no easy way to know when we've seen the last occurrence.  *    The solution here is to queue one link until we see the next.  *    At the end of the session, you can enumerate any remaining  *    entries by calling archive_entry_linkify(NULL) and store those  *    bodies.  If you have a file with three links l1, l2, and l3,  *    you'll get the following behavior if you see all three links:  *           linkify(l1) => NULL   (the resolver stores l1 internally)  *           linkify(l2) => l1     (resolver stores l2, you write l1)  *           linkify(l3) => l2, l3 (all links seen, you can write both).  *    If you only see l1 and l2, you'll get this behavior:  *           linkify(l1) => NULL  *           linkify(l2) => l1  *           linkify(NULL) => l2   (at end, you retrieve remaining links)  *    As the name suggests, this strategy is used by newer cpio variants.  *    It's noticably more complex for the archiver, slightly more complex  *    for the dearchiver than the tar strategy, but makes it straightforward  *    to restore a file using any link by simply continuing to scan until  *    you see a link that is stored with a body.  In contrast, the tar  *    strategy requires you to rescan the archive from the beginning to  *    correctly extract an arbitrary link.  */
name|__LA_DECL
name|struct
name|archive_entry_linkresolver
modifier|*
name|archive_entry_linkresolver_new
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_linkresolver_set_strategy
parameter_list|(
name|struct
name|archive_entry_linkresolver
modifier|*
parameter_list|,
name|int
comment|/* format_code */
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_linkresolver_free
parameter_list|(
name|struct
name|archive_entry_linkresolver
modifier|*
parameter_list|)
function_decl|;
name|__LA_DECL
name|void
name|archive_entry_linkify
parameter_list|(
name|struct
name|archive_entry_linkresolver
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
modifier|*
parameter_list|,
name|struct
name|archive_entry
modifier|*
modifier|*
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This is meaningless outside of this header. */
end_comment

begin_undef
undef|#
directive|undef
name|__LA_DECL
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !ARCHIVE_ENTRY_H_INCLUDED */
end_comment

end_unit

