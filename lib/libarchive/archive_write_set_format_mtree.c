begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2009 Michihiro NAKAJIMA  * Copyright (c) 2008 Joerg Sonnenberger  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  * IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT, INDIRECT,  * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT  * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,  * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY  * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF  * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"archive_platform.h"
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_SYS_TYPES_H
end_ifdef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"archive.h"
end_include

begin_include
include|#
directive|include
file|"archive_entry.h"
end_include

begin_include
include|#
directive|include
file|"archive_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_write_private.h"
end_include

begin_include
include|#
directive|include
file|"archive_hash.h"
end_include

begin_define
define|#
directive|define
name|INDENTNAMELEN
value|15
end_define

begin_define
define|#
directive|define
name|MAXLINELEN
value|80
end_define

begin_struct
struct|struct
name|mtree_writer
block|{
name|struct
name|archive_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|archive_string
name|ebuf
decl_stmt|;
name|struct
name|archive_string
name|buf
decl_stmt|;
name|int
name|first
decl_stmt|;
name|uint64_t
name|entry_bytes_remaining
decl_stmt|;
struct|struct
block|{
name|int
name|output
decl_stmt|;
name|int
name|processed
decl_stmt|;
name|struct
name|archive_string
name|parent
decl_stmt|;
name|mode_t
name|type
decl_stmt|;
name|int
name|keys
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
name|mode_t
name|mode
decl_stmt|;
name|unsigned
name|long
name|fflags_set
decl_stmt|;
name|unsigned
name|long
name|fflags_clear
decl_stmt|;
block|}
name|set
struct|;
comment|/* chekc sum */
name|int
name|compute_sum
decl_stmt|;
name|uint32_t
name|crc
decl_stmt|;
name|uint64_t
name|crc_len
decl_stmt|;
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_MD5
name|archive_md5_ctx
name|md5ctx
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_RMD160
name|archive_rmd160_ctx
name|rmd160ctx
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA1
name|archive_sha1_ctx
name|sha1ctx
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA256
name|archive_sha256_ctx
name|sha256ctx
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA384
name|archive_sha384_ctx
name|sha384ctx
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA512
name|archive_sha512_ctx
name|sha512ctx
decl_stmt|;
endif|#
directive|endif
comment|/* Keyword options */
name|int
name|keys
decl_stmt|;
define|#
directive|define
name|F_CKSUM
value|0x00000001
comment|/* check sum */
define|#
directive|define
name|F_DEV
value|0x00000002
comment|/* device type */
define|#
directive|define
name|F_DONE
value|0x00000004
comment|/* directory done */
define|#
directive|define
name|F_FLAGS
value|0x00000008
comment|/* file flags */
define|#
directive|define
name|F_GID
value|0x00000010
comment|/* gid */
define|#
directive|define
name|F_GNAME
value|0x00000020
comment|/* group name */
define|#
directive|define
name|F_IGN
value|0x00000040
comment|/* ignore */
define|#
directive|define
name|F_MAGIC
value|0x00000080
comment|/* name has magic chars */
define|#
directive|define
name|F_MD5
value|0x00000100
comment|/* MD5 digest */
define|#
directive|define
name|F_MODE
value|0x00000200
comment|/* mode */
define|#
directive|define
name|F_NLINK
value|0x00000400
comment|/* number of links */
define|#
directive|define
name|F_NOCHANGE
value|0x00000800
comment|/* If owner/mode "wrong", do 						 * not change */
define|#
directive|define
name|F_OPT
value|0x00001000
comment|/* existence optional */
define|#
directive|define
name|F_RMD160
value|0x00002000
comment|/* RIPEMD160 digest */
define|#
directive|define
name|F_SHA1
value|0x00004000
comment|/* SHA-1 digest */
define|#
directive|define
name|F_SIZE
value|0x00008000
comment|/* size */
define|#
directive|define
name|F_SLINK
value|0x00010000
comment|/* symbolic link */
define|#
directive|define
name|F_TAGS
value|0x00020000
comment|/* tags */
define|#
directive|define
name|F_TIME
value|0x00040000
comment|/* modification time */
define|#
directive|define
name|F_TYPE
value|0x00080000
comment|/* file type */
define|#
directive|define
name|F_UID
value|0x00100000
comment|/* uid */
define|#
directive|define
name|F_UNAME
value|0x00200000
comment|/* user name */
define|#
directive|define
name|F_VISIT
value|0x00400000
comment|/* file visited */
define|#
directive|define
name|F_SHA256
value|0x00800000
comment|/* SHA-256 digest */
define|#
directive|define
name|F_SHA384
value|0x01000000
comment|/* SHA-384 digest */
define|#
directive|define
name|F_SHA512
value|0x02000000
comment|/* SHA-512 digest */
comment|/* Options */
name|int
name|dironly
decl_stmt|;
comment|/* if the dironly is 1, ignore everything except 				 * directory type files. like mtree(8) -d option. 				 */
name|int
name|indent
decl_stmt|;
comment|/* if the indent is 1, indent writing data. */
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|DEFAULT_KEYS
value|(F_DEV | F_FLAGS | F_GID | F_GNAME | F_SLINK | F_MODE\ 			 | F_NLINK | F_SIZE | F_TIME | F_TYPE | F_UID\ 			 | F_UNAME)
end_define

begin_define
define|#
directive|define
name|COMPUTE_CRC
parameter_list|(
name|var
parameter_list|,
name|ch
parameter_list|)
value|(var) = (var)<< 8 ^ crctab[(var)>> 24 ^ (ch)]
end_define

begin_decl_stmt
specifier|static
specifier|const
name|uint32_t
name|crctab
index|[]
init|=
block|{
literal|0x0
block|,
literal|0x04c11db7
block|,
literal|0x09823b6e
block|,
literal|0x0d4326d9
block|,
literal|0x130476dc
block|,
literal|0x17c56b6b
block|,
literal|0x1a864db2
block|,
literal|0x1e475005
block|,
literal|0x2608edb8
block|,
literal|0x22c9f00f
block|,
literal|0x2f8ad6d6
block|,
literal|0x2b4bcb61
block|,
literal|0x350c9b64
block|,
literal|0x31cd86d3
block|,
literal|0x3c8ea00a
block|,
literal|0x384fbdbd
block|,
literal|0x4c11db70
block|,
literal|0x48d0c6c7
block|,
literal|0x4593e01e
block|,
literal|0x4152fda9
block|,
literal|0x5f15adac
block|,
literal|0x5bd4b01b
block|,
literal|0x569796c2
block|,
literal|0x52568b75
block|,
literal|0x6a1936c8
block|,
literal|0x6ed82b7f
block|,
literal|0x639b0da6
block|,
literal|0x675a1011
block|,
literal|0x791d4014
block|,
literal|0x7ddc5da3
block|,
literal|0x709f7b7a
block|,
literal|0x745e66cd
block|,
literal|0x9823b6e0
block|,
literal|0x9ce2ab57
block|,
literal|0x91a18d8e
block|,
literal|0x95609039
block|,
literal|0x8b27c03c
block|,
literal|0x8fe6dd8b
block|,
literal|0x82a5fb52
block|,
literal|0x8664e6e5
block|,
literal|0xbe2b5b58
block|,
literal|0xbaea46ef
block|,
literal|0xb7a96036
block|,
literal|0xb3687d81
block|,
literal|0xad2f2d84
block|,
literal|0xa9ee3033
block|,
literal|0xa4ad16ea
block|,
literal|0xa06c0b5d
block|,
literal|0xd4326d90
block|,
literal|0xd0f37027
block|,
literal|0xddb056fe
block|,
literal|0xd9714b49
block|,
literal|0xc7361b4c
block|,
literal|0xc3f706fb
block|,
literal|0xceb42022
block|,
literal|0xca753d95
block|,
literal|0xf23a8028
block|,
literal|0xf6fb9d9f
block|,
literal|0xfbb8bb46
block|,
literal|0xff79a6f1
block|,
literal|0xe13ef6f4
block|,
literal|0xe5ffeb43
block|,
literal|0xe8bccd9a
block|,
literal|0xec7dd02d
block|,
literal|0x34867077
block|,
literal|0x30476dc0
block|,
literal|0x3d044b19
block|,
literal|0x39c556ae
block|,
literal|0x278206ab
block|,
literal|0x23431b1c
block|,
literal|0x2e003dc5
block|,
literal|0x2ac12072
block|,
literal|0x128e9dcf
block|,
literal|0x164f8078
block|,
literal|0x1b0ca6a1
block|,
literal|0x1fcdbb16
block|,
literal|0x018aeb13
block|,
literal|0x054bf6a4
block|,
literal|0x0808d07d
block|,
literal|0x0cc9cdca
block|,
literal|0x7897ab07
block|,
literal|0x7c56b6b0
block|,
literal|0x71159069
block|,
literal|0x75d48dde
block|,
literal|0x6b93dddb
block|,
literal|0x6f52c06c
block|,
literal|0x6211e6b5
block|,
literal|0x66d0fb02
block|,
literal|0x5e9f46bf
block|,
literal|0x5a5e5b08
block|,
literal|0x571d7dd1
block|,
literal|0x53dc6066
block|,
literal|0x4d9b3063
block|,
literal|0x495a2dd4
block|,
literal|0x44190b0d
block|,
literal|0x40d816ba
block|,
literal|0xaca5c697
block|,
literal|0xa864db20
block|,
literal|0xa527fdf9
block|,
literal|0xa1e6e04e
block|,
literal|0xbfa1b04b
block|,
literal|0xbb60adfc
block|,
literal|0xb6238b25
block|,
literal|0xb2e29692
block|,
literal|0x8aad2b2f
block|,
literal|0x8e6c3698
block|,
literal|0x832f1041
block|,
literal|0x87ee0df6
block|,
literal|0x99a95df3
block|,
literal|0x9d684044
block|,
literal|0x902b669d
block|,
literal|0x94ea7b2a
block|,
literal|0xe0b41de7
block|,
literal|0xe4750050
block|,
literal|0xe9362689
block|,
literal|0xedf73b3e
block|,
literal|0xf3b06b3b
block|,
literal|0xf771768c
block|,
literal|0xfa325055
block|,
literal|0xfef34de2
block|,
literal|0xc6bcf05f
block|,
literal|0xc27dede8
block|,
literal|0xcf3ecb31
block|,
literal|0xcbffd686
block|,
literal|0xd5b88683
block|,
literal|0xd1799b34
block|,
literal|0xdc3abded
block|,
literal|0xd8fba05a
block|,
literal|0x690ce0ee
block|,
literal|0x6dcdfd59
block|,
literal|0x608edb80
block|,
literal|0x644fc637
block|,
literal|0x7a089632
block|,
literal|0x7ec98b85
block|,
literal|0x738aad5c
block|,
literal|0x774bb0eb
block|,
literal|0x4f040d56
block|,
literal|0x4bc510e1
block|,
literal|0x46863638
block|,
literal|0x42472b8f
block|,
literal|0x5c007b8a
block|,
literal|0x58c1663d
block|,
literal|0x558240e4
block|,
literal|0x51435d53
block|,
literal|0x251d3b9e
block|,
literal|0x21dc2629
block|,
literal|0x2c9f00f0
block|,
literal|0x285e1d47
block|,
literal|0x36194d42
block|,
literal|0x32d850f5
block|,
literal|0x3f9b762c
block|,
literal|0x3b5a6b9b
block|,
literal|0x0315d626
block|,
literal|0x07d4cb91
block|,
literal|0x0a97ed48
block|,
literal|0x0e56f0ff
block|,
literal|0x1011a0fa
block|,
literal|0x14d0bd4d
block|,
literal|0x19939b94
block|,
literal|0x1d528623
block|,
literal|0xf12f560e
block|,
literal|0xf5ee4bb9
block|,
literal|0xf8ad6d60
block|,
literal|0xfc6c70d7
block|,
literal|0xe22b20d2
block|,
literal|0xe6ea3d65
block|,
literal|0xeba91bbc
block|,
literal|0xef68060b
block|,
literal|0xd727bbb6
block|,
literal|0xd3e6a601
block|,
literal|0xdea580d8
block|,
literal|0xda649d6f
block|,
literal|0xc423cd6a
block|,
literal|0xc0e2d0dd
block|,
literal|0xcda1f604
block|,
literal|0xc960ebb3
block|,
literal|0xbd3e8d7e
block|,
literal|0xb9ff90c9
block|,
literal|0xb4bcb610
block|,
literal|0xb07daba7
block|,
literal|0xae3afba2
block|,
literal|0xaafbe615
block|,
literal|0xa7b8c0cc
block|,
literal|0xa379dd7b
block|,
literal|0x9b3660c6
block|,
literal|0x9ff77d71
block|,
literal|0x92b45ba8
block|,
literal|0x9675461f
block|,
literal|0x8832161a
block|,
literal|0x8cf30bad
block|,
literal|0x81b02d74
block|,
literal|0x857130c3
block|,
literal|0x5d8a9099
block|,
literal|0x594b8d2e
block|,
literal|0x5408abf7
block|,
literal|0x50c9b640
block|,
literal|0x4e8ee645
block|,
literal|0x4a4ffbf2
block|,
literal|0x470cdd2b
block|,
literal|0x43cdc09c
block|,
literal|0x7b827d21
block|,
literal|0x7f436096
block|,
literal|0x7200464f
block|,
literal|0x76c15bf8
block|,
literal|0x68860bfd
block|,
literal|0x6c47164a
block|,
literal|0x61043093
block|,
literal|0x65c52d24
block|,
literal|0x119b4be9
block|,
literal|0x155a565e
block|,
literal|0x18197087
block|,
literal|0x1cd86d30
block|,
literal|0x029f3d35
block|,
literal|0x065e2082
block|,
literal|0x0b1d065b
block|,
literal|0x0fdc1bec
block|,
literal|0x3793a651
block|,
literal|0x3352bbe6
block|,
literal|0x3e119d3f
block|,
literal|0x3ad08088
block|,
literal|0x2497d08d
block|,
literal|0x2056cd3a
block|,
literal|0x2d15ebe3
block|,
literal|0x29d4f654
block|,
literal|0xc5a92679
block|,
literal|0xc1683bce
block|,
literal|0xcc2b1d17
block|,
literal|0xc8ea00a0
block|,
literal|0xd6ad50a5
block|,
literal|0xd26c4d12
block|,
literal|0xdf2f6bcb
block|,
literal|0xdbee767c
block|,
literal|0xe3a1cbc1
block|,
literal|0xe760d676
block|,
literal|0xea23f0af
block|,
literal|0xeee2ed18
block|,
literal|0xf0a5bd1d
block|,
literal|0xf464a0aa
block|,
literal|0xf9278673
block|,
literal|0xfde69bc4
block|,
literal|0x89b8fd09
block|,
literal|0x8d79e0be
block|,
literal|0x803ac667
block|,
literal|0x84fbdbd0
block|,
literal|0x9abc8bd5
block|,
literal|0x9e7d9662
block|,
literal|0x933eb0bb
block|,
literal|0x97ffad0c
block|,
literal|0xafb010b1
block|,
literal|0xab710d06
block|,
literal|0xa6322bdf
block|,
literal|0xa2f33668
block|,
literal|0xbcb4666d
block|,
literal|0xb8757bda
block|,
literal|0xb5365d03
block|,
literal|0xb1f740b4
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|mtree_safe_char
parameter_list|(
name|char
name|c
parameter_list|)
block|{
if|if
condition|(
operator|(
name|c
operator|>=
literal|'a'
operator|&&
name|c
operator|<=
literal|'z'
operator|)
operator|||
operator|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
operator|)
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|c
operator|>=
literal|'0'
operator|&&
name|c
operator|<=
literal|'9'
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|c
operator|==
literal|35
operator|||
name|c
operator|==
literal|61
operator|||
name|c
operator|==
literal|92
condition|)
return|return
literal|0
return|;
comment|/* #, = and \ are always quoted */
if|if
condition|(
name|c
operator|>=
literal|33
operator|&&
name|c
operator|<=
literal|47
condition|)
comment|/* !"$%&'()*+,-./ */
return|return
literal|1
return|;
if|if
condition|(
name|c
operator|>=
literal|58
operator|&&
name|c
operator|<=
literal|64
condition|)
comment|/* :;<>?@ */
return|return
literal|1
return|;
if|if
condition|(
name|c
operator|>=
literal|91
operator|&&
name|c
operator|<=
literal|96
condition|)
comment|/* []^_` */
return|return
literal|1
return|;
if|if
condition|(
name|c
operator|>=
literal|123
operator|&&
name|c
operator|<=
literal|126
condition|)
comment|/* {|}~ */
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|mtree_quote
parameter_list|(
name|struct
name|archive_string
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
for|for
control|(
name|start
operator|=
name|str
init|;
operator|*
name|str
operator|!=
literal|'\0'
condition|;
operator|++
name|str
control|)
block|{
if|if
condition|(
name|mtree_safe_char
argument_list|(
operator|*
name|str
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|start
operator|!=
name|str
condition|)
name|archive_strncat
argument_list|(
name|s
argument_list|,
name|start
argument_list|,
name|str
operator|-
name|start
argument_list|)
expr_stmt|;
name|c
operator|=
operator|(
name|unsigned
name|char
operator|)
operator|*
name|str
expr_stmt|;
name|buf
index|[
literal|0
index|]
operator|=
literal|'\\'
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
operator|(
name|c
operator|/
literal|64
operator|)
operator|+
literal|'0'
expr_stmt|;
name|buf
index|[
literal|2
index|]
operator|=
operator|(
name|c
operator|/
literal|8
operator|%
literal|8
operator|)
operator|+
literal|'0'
expr_stmt|;
name|buf
index|[
literal|3
index|]
operator|=
operator|(
name|c
operator|%
literal|8
operator|)
operator|+
literal|'0'
expr_stmt|;
name|archive_strncat
argument_list|(
name|s
argument_list|,
name|buf
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|start
operator|=
name|str
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|start
operator|!=
name|str
condition|)
name|archive_strncat
argument_list|(
name|s
argument_list|,
name|start
argument_list|,
name|str
operator|-
name|start
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mtree_indent
parameter_list|(
name|struct
name|mtree_writer
modifier|*
name|mtree
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|fn
decl_stmt|;
specifier|const
name|char
modifier|*
name|r
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|x
decl_stmt|;
name|fn
operator|=
literal|1
expr_stmt|;
name|s
operator|=
name|r
operator|=
name|mtree
operator|->
name|ebuf
operator|.
name|s
expr_stmt|;
name|x
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|*
name|r
operator|==
literal|' '
condition|)
name|r
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|r
operator|=
name|strchr
argument_list|(
name|r
argument_list|,
literal|' '
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fn
condition|)
block|{
name|fn
operator|=
literal|0
expr_stmt|;
name|archive_strncat
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|,
name|s
argument_list|,
name|r
operator|-
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|-
name|s
operator|>
name|INDENTNAMELEN
condition|)
block|{
name|archive_strncat
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|,
literal|" \\\n"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|INDENTNAMELEN
operator|+
literal|1
operator|)
condition|;
name|i
operator|++
control|)
name|archive_strappend_char
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
name|r
operator|-
name|s
init|;
name|i
operator|<
operator|(
name|INDENTNAMELEN
operator|+
literal|1
operator|)
condition|;
name|i
operator|++
control|)
name|archive_strappend_char
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
operator|++
name|r
expr_stmt|;
name|x
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|r
operator|-
name|s
operator|<=
name|MAXLINELEN
operator|-
literal|3
operator|-
name|INDENTNAMELEN
condition|)
name|x
operator|=
name|r
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
name|x
operator|==
name|NULL
condition|)
name|x
operator|=
name|r
expr_stmt|;
name|archive_strncat
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|,
name|s
argument_list|,
name|x
operator|-
name|s
argument_list|)
expr_stmt|;
name|archive_strncat
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|,
literal|" \\\n"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|INDENTNAMELEN
operator|+
literal|1
operator|)
condition|;
name|i
operator|++
control|)
name|archive_strappend_char
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|s
operator|=
name|r
operator|=
operator|++
name|x
expr_stmt|;
name|x
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|x
operator|!=
name|NULL
operator|&&
name|strlen
argument_list|(
name|s
argument_list|)
operator|>
name|MAXLINELEN
operator|-
literal|3
operator|-
name|INDENTNAMELEN
condition|)
block|{
comment|/* Last keyword is longer. */
name|archive_strncat
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|,
name|s
argument_list|,
name|x
operator|-
name|s
argument_list|)
expr_stmt|;
name|archive_strncat
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|,
literal|" \\\n"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|INDENTNAMELEN
operator|+
literal|1
operator|)
condition|;
name|i
operator|++
control|)
name|archive_strappend_char
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|s
operator|=
operator|++
name|x
expr_stmt|;
block|}
name|archive_strcat
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
name|mtree
operator|->
name|ebuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_WIN32
argument_list|)
operator|||
name|defined
argument_list|(
name|__CYGWIN__
argument_list|)
end_if

begin_function
specifier|static
name|size_t
name|dir_len
parameter_list|(
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|path
operator|=
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|r
operator|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Include a separator size */
return|return
operator|(
name|r
operator|-
name|path
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* _WIN32&& !__CYGWIN__ */
end_comment

begin_comment
comment|/*  * Note: We should use wide-character for findng '\' character,  * a directory separator on Windows, because some character-set have  * been using the '\' character for a part of its multibyte character  * code.  */
end_comment

begin_function
specifier|static
name|size_t
name|dir_len
parameter_list|(
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
name|wchar_t
name|wc
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|rp
decl_stmt|;
name|size_t
name|al
decl_stmt|,
name|l
decl_stmt|,
name|size
decl_stmt|;
name|path
operator|=
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|al
operator|=
name|l
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|p
operator|=
name|path
init|;
operator|*
name|p
operator|!=
literal|'\0'
condition|;
operator|++
name|p
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
name|al
operator|=
name|l
operator|=
name|p
operator|-
name|path
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
name|al
operator|=
name|p
operator|-
name|path
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|==
operator|-
literal|1
condition|)
goto|goto
name|alen
goto|;
name|size
operator|=
name|p
operator|-
name|path
expr_stmt|;
name|rp
operator|=
name|p
operator|=
name|path
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|'\0'
condition|)
block|{
name|l
operator|=
name|mbtowc
argument_list|(
operator|&
name|wc
argument_list|,
name|p
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
operator|-
literal|1
condition|)
goto|goto
name|alen
goto|;
if|if
condition|(
name|l
operator|==
literal|1
operator|&&
operator|(
name|wc
operator|==
literal|L'
expr|/'
operator|||
name|wc
operator|==
literal|L'
expr|\\'
operator|)
condition|)
name|rp
operator|=
name|p
expr_stmt|;
name|p
operator|+=
name|l
expr_stmt|;
name|size
operator|-=
name|l
expr_stmt|;
block|}
return|return
operator|(
name|rp
operator|-
name|path
operator|+
literal|1
operator|)
return|;
name|alen
label|:
if|if
condition|(
name|al
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|al
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _WIN32&& !__CYGWIN__ */
end_comment

begin_function
specifier|static
name|int
name|parent_dir_changed
parameter_list|(
name|struct
name|archive_string
modifier|*
name|dir
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|size_t
name|l
decl_stmt|;
name|l
operator|=
name|dir_len
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|path
operator|=
name|archive_entry_pathname
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|archive_strlen
argument_list|(
name|dir
argument_list|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|l
operator|==
literal|0
condition|)
block|{
name|archive_string_empty
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|dir
operator|->
name|s
argument_list|,
name|path
argument_list|,
name|l
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* The parent directory is the same. */
block|}
elseif|else
if|if
condition|(
name|l
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* The parent directory is the same. */
name|archive_strncpy
argument_list|(
name|dir
argument_list|,
name|path
argument_list|,
name|l
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write /set keyword. It means set global datas.  * [directory-only mode]  *   - It is only once to write /set keyword. It is using values of the  *     first entry.  * [normal mode]  *   - Write /set keyword. It is using values of the first entry whose  *     filetype is a regular file.  *   - When a parent directory of the entry whose filetype is the regular  *     file is changed, check the global datas and write it again if its  *     values are different from the entry's.  */
end_comment

begin_function
specifier|static
name|void
name|set_global
parameter_list|(
name|struct
name|mtree_writer
modifier|*
name|mtree
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|archive_string
name|setstr
decl_stmt|;
name|struct
name|archive_string
name|unsetstr
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|keys
decl_stmt|,
name|oldkeys
decl_stmt|,
name|effkeys
decl_stmt|;
name|mode_t
name|set_type
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|archive_entry_filetype
argument_list|(
name|entry
argument_list|)
condition|)
block|{
case|case
name|AE_IFLNK
case|:
case|case
name|AE_IFSOCK
case|:
case|case
name|AE_IFCHR
case|:
case|case
name|AE_IFBLK
case|:
case|case
name|AE_IFIFO
case|:
break|break;
case|case
name|AE_IFDIR
case|:
if|if
condition|(
name|mtree
operator|->
name|dironly
condition|)
name|set_type
operator|=
name|AE_IFDIR
expr_stmt|;
break|break;
case|case
name|AE_IFREG
case|:
default|default:
comment|/* Handle unknown file types as regular files. */
if|if
condition|(
operator|!
name|mtree
operator|->
name|dironly
condition|)
name|set_type
operator|=
name|AE_IFREG
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|set_type
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|mtree
operator|->
name|set
operator|.
name|processed
operator|&&
operator|!
name|parent_dir_changed
argument_list|(
operator|&
name|mtree
operator|->
name|set
operator|.
name|parent
argument_list|,
name|entry
argument_list|)
condition|)
return|return;
comment|/* At first, save a parent directory of the entry for following 	 * entries. */
if|if
condition|(
operator|!
name|mtree
operator|->
name|set
operator|.
name|processed
operator|&&
name|set_type
operator|==
name|AE_IFREG
condition|)
name|parent_dir_changed
argument_list|(
operator|&
name|mtree
operator|->
name|set
operator|.
name|parent
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|archive_string_init
argument_list|(
operator|&
name|setstr
argument_list|)
expr_stmt|;
name|archive_string_init
argument_list|(
operator|&
name|unsetstr
argument_list|)
expr_stmt|;
name|keys
operator|=
name|mtree
operator|->
name|keys
operator|&
operator|(
name|F_FLAGS
operator||
name|F_GID
operator||
name|F_GNAME
operator||
name|F_NLINK
operator||
name|F_MODE
operator||
name|F_TYPE
operator||
name|F_UID
operator||
name|F_UNAME
operator|)
expr_stmt|;
name|oldkeys
operator|=
name|mtree
operator|->
name|set
operator|.
name|keys
expr_stmt|;
name|effkeys
operator|=
name|keys
expr_stmt|;
if|if
condition|(
name|mtree
operator|->
name|set
operator|.
name|processed
condition|)
block|{
comment|/* 		 * Check the global datas for whether it needs updating. 		 */
name|effkeys
operator|&=
operator|~
name|F_TYPE
expr_stmt|;
if|if
condition|(
operator|(
name|oldkeys
operator|&
operator|(
name|F_UNAME
operator||
name|F_UID
operator|)
operator|)
operator|!=
literal|0
operator|&&
name|mtree
operator|->
name|set
operator|.
name|uid
operator|==
name|archive_entry_uid
argument_list|(
name|entry
argument_list|)
condition|)
name|effkeys
operator|&=
operator|~
operator|(
name|F_UNAME
operator||
name|F_UID
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|oldkeys
operator|&
operator|(
name|F_GNAME
operator||
name|F_GID
operator|)
operator|)
operator|!=
literal|0
operator|&&
name|mtree
operator|->
name|set
operator|.
name|gid
operator|==
name|archive_entry_gid
argument_list|(
name|entry
argument_list|)
condition|)
name|effkeys
operator|&=
operator|~
operator|(
name|F_GNAME
operator||
name|F_GID
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|oldkeys
operator|&
name|F_MODE
operator|)
operator|!=
literal|0
operator|&&
name|mtree
operator|->
name|set
operator|.
name|mode
operator|==
operator|(
name|archive_entry_mode
argument_list|(
name|entry
argument_list|)
operator|&
literal|07777
operator|)
condition|)
name|effkeys
operator|&=
operator|~
name|F_MODE
expr_stmt|;
if|if
condition|(
operator|(
name|oldkeys
operator|&
name|F_FLAGS
operator|)
operator|!=
literal|0
condition|)
block|{
name|unsigned
name|long
name|fflags_set
decl_stmt|;
name|unsigned
name|long
name|fflags_clear
decl_stmt|;
name|archive_entry_fflags
argument_list|(
name|entry
argument_list|,
operator|&
name|fflags_set
argument_list|,
operator|&
name|fflags_clear
argument_list|)
expr_stmt|;
if|if
condition|(
name|fflags_set
operator|==
name|mtree
operator|->
name|set
operator|.
name|fflags_set
operator|&&
name|fflags_clear
operator|==
name|mtree
operator|->
name|set
operator|.
name|fflags_clear
condition|)
name|effkeys
operator|&=
operator|~
name|F_FLAGS
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|keys
operator|&
name|effkeys
operator|&
name|F_TYPE
operator|)
operator|!=
literal|0
condition|)
block|{
name|mtree
operator|->
name|set
operator|.
name|type
operator|=
name|set_type
expr_stmt|;
if|if
condition|(
name|set_type
operator|==
name|AE_IFDIR
condition|)
name|archive_strcat
argument_list|(
operator|&
name|setstr
argument_list|,
literal|" type=dir"
argument_list|)
expr_stmt|;
else|else
name|archive_strcat
argument_list|(
operator|&
name|setstr
argument_list|,
literal|" type=file"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|keys
operator|&
name|effkeys
operator|&
name|F_UNAME
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|name
operator|=
name|archive_entry_uname
argument_list|(
name|entry
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|archive_strcat
argument_list|(
operator|&
name|setstr
argument_list|,
literal|" uname="
argument_list|)
expr_stmt|;
name|mtree_quote
argument_list|(
operator|&
name|setstr
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|oldkeys
operator|&
name|F_UNAME
operator|)
operator|!=
literal|0
condition|)
name|archive_strcat
argument_list|(
operator|&
name|unsetstr
argument_list|,
literal|" uname"
argument_list|)
expr_stmt|;
else|else
name|keys
operator|&=
operator|~
name|F_UNAME
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|keys
operator|&
name|effkeys
operator|&
name|F_UID
operator|)
operator|!=
literal|0
condition|)
block|{
name|mtree
operator|->
name|set
operator|.
name|uid
operator|=
name|archive_entry_uid
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|archive_string_sprintf
argument_list|(
operator|&
name|setstr
argument_list|,
literal|" uid=%jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|mtree
operator|->
name|set
operator|.
name|uid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|keys
operator|&
name|effkeys
operator|&
name|F_GNAME
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|name
operator|=
name|archive_entry_gname
argument_list|(
name|entry
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|archive_strcat
argument_list|(
operator|&
name|setstr
argument_list|,
literal|" gname="
argument_list|)
expr_stmt|;
name|mtree_quote
argument_list|(
operator|&
name|setstr
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|oldkeys
operator|&
name|F_GNAME
operator|)
operator|!=
literal|0
condition|)
name|archive_strcat
argument_list|(
operator|&
name|unsetstr
argument_list|,
literal|" gname"
argument_list|)
expr_stmt|;
else|else
name|keys
operator|&=
operator|~
name|F_GNAME
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|keys
operator|&
name|effkeys
operator|&
name|F_GID
operator|)
operator|!=
literal|0
condition|)
block|{
name|mtree
operator|->
name|set
operator|.
name|gid
operator|=
name|archive_entry_gid
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|archive_string_sprintf
argument_list|(
operator|&
name|setstr
argument_list|,
literal|" gid=%jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|mtree
operator|->
name|set
operator|.
name|gid
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|keys
operator|&
name|effkeys
operator|&
name|F_MODE
operator|)
operator|!=
literal|0
condition|)
block|{
name|mtree
operator|->
name|set
operator|.
name|mode
operator|=
name|archive_entry_mode
argument_list|(
name|entry
argument_list|)
operator|&
literal|07777
expr_stmt|;
name|archive_string_sprintf
argument_list|(
operator|&
name|setstr
argument_list|,
literal|" mode=%o"
argument_list|,
name|mtree
operator|->
name|set
operator|.
name|mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|keys
operator|&
name|effkeys
operator|&
name|F_FLAGS
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|name
operator|=
name|archive_entry_fflags_text
argument_list|(
name|entry
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|archive_strcat
argument_list|(
operator|&
name|setstr
argument_list|,
literal|" flags="
argument_list|)
expr_stmt|;
name|mtree_quote
argument_list|(
operator|&
name|setstr
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|archive_entry_fflags
argument_list|(
name|entry
argument_list|,
operator|&
name|mtree
operator|->
name|set
operator|.
name|fflags_set
argument_list|,
operator|&
name|mtree
operator|->
name|set
operator|.
name|fflags_clear
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|oldkeys
operator|&
name|F_FLAGS
operator|)
operator|!=
literal|0
condition|)
name|archive_strcat
argument_list|(
operator|&
name|unsetstr
argument_list|,
literal|" flags"
argument_list|)
expr_stmt|;
else|else
name|keys
operator|&=
operator|~
name|F_FLAGS
expr_stmt|;
block|}
if|if
condition|(
name|unsetstr
operator|.
name|length
operator|>
literal|0
condition|)
name|archive_string_sprintf
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|,
literal|"/unset%s\n"
argument_list|,
name|unsetstr
operator|.
name|s
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|unsetstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|setstr
operator|.
name|length
operator|>
literal|0
condition|)
name|archive_string_sprintf
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|,
literal|"/set%s\n"
argument_list|,
name|setstr
operator|.
name|s
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|setstr
argument_list|)
expr_stmt|;
name|mtree
operator|->
name|set
operator|.
name|keys
operator|=
name|keys
expr_stmt|;
name|mtree
operator|->
name|set
operator|.
name|processed
operator|=
literal|1
expr_stmt|;
comment|/* On directory-only mode, it is only once to write /set keyword. */
if|if
condition|(
name|mtree
operator|->
name|dironly
condition|)
name|mtree
operator|->
name|set
operator|.
name|output
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|get_keys
parameter_list|(
name|struct
name|mtree_writer
modifier|*
name|mtree
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
name|int
name|keys
decl_stmt|;
name|keys
operator|=
name|mtree
operator|->
name|keys
expr_stmt|;
if|if
condition|(
name|mtree
operator|->
name|set
operator|.
name|keys
operator|==
literal|0
condition|)
return|return
operator|(
name|keys
operator|)
return|;
if|if
condition|(
operator|(
name|mtree
operator|->
name|set
operator|.
name|keys
operator|&
operator|(
name|F_GNAME
operator||
name|F_GID
operator|)
operator|)
operator|!=
literal|0
operator|&&
name|mtree
operator|->
name|set
operator|.
name|gid
operator|==
name|archive_entry_gid
argument_list|(
name|entry
argument_list|)
condition|)
name|keys
operator|&=
operator|~
operator|(
name|F_GNAME
operator||
name|F_GID
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|mtree
operator|->
name|set
operator|.
name|keys
operator|&
operator|(
name|F_UNAME
operator||
name|F_UID
operator|)
operator|)
operator|!=
literal|0
operator|&&
name|mtree
operator|->
name|set
operator|.
name|uid
operator|==
name|archive_entry_uid
argument_list|(
name|entry
argument_list|)
condition|)
name|keys
operator|&=
operator|~
operator|(
name|F_UNAME
operator||
name|F_UID
operator|)
expr_stmt|;
if|if
condition|(
name|mtree
operator|->
name|set
operator|.
name|keys
operator|&
name|F_FLAGS
condition|)
block|{
name|unsigned
name|long
name|set
decl_stmt|,
name|clear
decl_stmt|;
name|archive_entry_fflags
argument_list|(
name|entry
argument_list|,
operator|&
name|set
argument_list|,
operator|&
name|clear
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtree
operator|->
name|set
operator|.
name|fflags_set
operator|==
name|set
operator|&&
name|mtree
operator|->
name|set
operator|.
name|fflags_clear
operator|==
name|clear
condition|)
name|keys
operator|&=
operator|~
name|F_FLAGS
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|mtree
operator|->
name|set
operator|.
name|keys
operator|&
name|F_MODE
operator|)
operator|!=
literal|0
operator|&&
name|mtree
operator|->
name|set
operator|.
name|mode
operator|==
operator|(
name|archive_entry_mode
argument_list|(
name|entry
argument_list|)
operator|&
literal|07777
operator|)
condition|)
name|keys
operator|&=
operator|~
name|F_MODE
expr_stmt|;
switch|switch
condition|(
name|archive_entry_filetype
argument_list|(
name|entry
argument_list|)
condition|)
block|{
case|case
name|AE_IFLNK
case|:
case|case
name|AE_IFSOCK
case|:
case|case
name|AE_IFCHR
case|:
case|case
name|AE_IFBLK
case|:
case|case
name|AE_IFIFO
case|:
break|break;
case|case
name|AE_IFDIR
case|:
if|if
condition|(
operator|(
name|mtree
operator|->
name|set
operator|.
name|keys
operator|&
name|F_TYPE
operator|)
operator|!=
literal|0
operator|&&
name|mtree
operator|->
name|set
operator|.
name|type
operator|==
name|AE_IFDIR
condition|)
name|keys
operator|&=
operator|~
name|F_TYPE
expr_stmt|;
break|break;
case|case
name|AE_IFREG
case|:
default|default:
comment|/* Handle unknown file types as regular files. */
if|if
condition|(
operator|(
name|mtree
operator|->
name|set
operator|.
name|keys
operator|&
name|F_TYPE
operator|)
operator|!=
literal|0
operator|&&
name|mtree
operator|->
name|set
operator|.
name|type
operator|==
name|AE_IFREG
condition|)
name|keys
operator|&=
operator|~
name|F_TYPE
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|keys
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_write_mtree_header
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
name|struct
name|archive_entry
modifier|*
name|entry
parameter_list|)
block|{
name|struct
name|mtree_writer
modifier|*
name|mtree
init|=
name|a
operator|->
name|format_data
decl_stmt|;
name|struct
name|archive_string
modifier|*
name|str
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|mtree
operator|->
name|entry
operator|=
name|archive_entry_clone
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|path
operator|=
name|archive_entry_pathname
argument_list|(
name|mtree
operator|->
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtree
operator|->
name|first
condition|)
block|{
name|mtree
operator|->
name|first
operator|=
literal|0
expr_stmt|;
name|archive_strcat
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|,
literal|"#mtree\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mtree
operator|->
name|set
operator|.
name|output
condition|)
name|set_global
argument_list|(
name|mtree
argument_list|,
name|entry
argument_list|)
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
name|mtree
operator|->
name|ebuf
argument_list|)
expr_stmt|;
name|str
operator|=
operator|(
name|mtree
operator|->
name|indent
operator|)
condition|?
operator|&
name|mtree
operator|->
name|ebuf
else|:
operator|&
name|mtree
operator|->
name|buf
expr_stmt|;
if|if
condition|(
operator|!
name|mtree
operator|->
name|dironly
operator|||
name|archive_entry_filetype
argument_list|(
name|entry
argument_list|)
operator|==
name|AE_IFDIR
condition|)
name|mtree_quote
argument_list|(
name|str
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|mtree
operator|->
name|entry_bytes_remaining
operator|=
name|archive_entry_size
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mtree
operator|->
name|keys
operator|&
name|F_CKSUM
operator|)
operator|!=
literal|0
operator|&&
name|archive_entry_filetype
argument_list|(
name|entry
argument_list|)
operator|==
name|AE_IFREG
condition|)
block|{
name|mtree
operator|->
name|compute_sum
operator||=
name|F_CKSUM
expr_stmt|;
name|mtree
operator|->
name|crc
operator|=
literal|0
expr_stmt|;
name|mtree
operator|->
name|crc_len
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|mtree
operator|->
name|compute_sum
operator|&=
operator|~
name|F_CKSUM
expr_stmt|;
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_MD5
if|if
condition|(
operator|(
name|mtree
operator|->
name|keys
operator|&
name|F_MD5
operator|)
operator|!=
literal|0
operator|&&
name|archive_entry_filetype
argument_list|(
name|entry
argument_list|)
operator|==
name|AE_IFREG
condition|)
block|{
name|mtree
operator|->
name|compute_sum
operator||=
name|F_MD5
expr_stmt|;
name|archive_md5_init
argument_list|(
operator|&
name|mtree
operator|->
name|md5ctx
argument_list|)
expr_stmt|;
block|}
else|else
name|mtree
operator|->
name|compute_sum
operator|&=
operator|~
name|F_MD5
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_RMD160
if|if
condition|(
operator|(
name|mtree
operator|->
name|keys
operator|&
name|F_RMD160
operator|)
operator|!=
literal|0
operator|&&
name|archive_entry_filetype
argument_list|(
name|entry
argument_list|)
operator|==
name|AE_IFREG
condition|)
block|{
name|mtree
operator|->
name|compute_sum
operator||=
name|F_RMD160
expr_stmt|;
name|archive_rmd160_init
argument_list|(
operator|&
name|mtree
operator|->
name|rmd160ctx
argument_list|)
expr_stmt|;
block|}
else|else
name|mtree
operator|->
name|compute_sum
operator|&=
operator|~
name|F_RMD160
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA1
if|if
condition|(
operator|(
name|mtree
operator|->
name|keys
operator|&
name|F_SHA1
operator|)
operator|!=
literal|0
operator|&&
name|archive_entry_filetype
argument_list|(
name|entry
argument_list|)
operator|==
name|AE_IFREG
condition|)
block|{
name|mtree
operator|->
name|compute_sum
operator||=
name|F_SHA1
expr_stmt|;
name|archive_sha1_init
argument_list|(
operator|&
name|mtree
operator|->
name|sha1ctx
argument_list|)
expr_stmt|;
block|}
else|else
name|mtree
operator|->
name|compute_sum
operator|&=
operator|~
name|F_SHA1
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA256
if|if
condition|(
operator|(
name|mtree
operator|->
name|keys
operator|&
name|F_SHA256
operator|)
operator|!=
literal|0
operator|&&
name|archive_entry_filetype
argument_list|(
name|entry
argument_list|)
operator|==
name|AE_IFREG
condition|)
block|{
name|mtree
operator|->
name|compute_sum
operator||=
name|F_SHA256
expr_stmt|;
name|archive_sha256_init
argument_list|(
operator|&
name|mtree
operator|->
name|sha256ctx
argument_list|)
expr_stmt|;
block|}
else|else
name|mtree
operator|->
name|compute_sum
operator|&=
operator|~
name|F_SHA256
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA384
if|if
condition|(
operator|(
name|mtree
operator|->
name|keys
operator|&
name|F_SHA384
operator|)
operator|!=
literal|0
operator|&&
name|archive_entry_filetype
argument_list|(
name|entry
argument_list|)
operator|==
name|AE_IFREG
condition|)
block|{
name|mtree
operator|->
name|compute_sum
operator||=
name|F_SHA384
expr_stmt|;
name|archive_sha384_init
argument_list|(
operator|&
name|mtree
operator|->
name|sha384ctx
argument_list|)
expr_stmt|;
block|}
else|else
name|mtree
operator|->
name|compute_sum
operator|&=
operator|~
name|F_SHA384
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA512
if|if
condition|(
operator|(
name|mtree
operator|->
name|keys
operator|&
name|F_SHA512
operator|)
operator|!=
literal|0
operator|&&
name|archive_entry_filetype
argument_list|(
name|entry
argument_list|)
operator|==
name|AE_IFREG
condition|)
block|{
name|mtree
operator|->
name|compute_sum
operator||=
name|F_SHA512
expr_stmt|;
name|archive_sha512_init
argument_list|(
operator|&
name|mtree
operator|->
name|sha512ctx
argument_list|)
expr_stmt|;
block|}
else|else
name|mtree
operator|->
name|compute_sum
operator|&=
operator|~
name|F_SHA512
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|ARCHIVE_HAS_MD5
argument_list|)
operator|||
name|defined
argument_list|(
name|ARCHIVE_HAS_RMD160
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|ARCHIVE_HAS_SHA1
argument_list|)
operator|||
name|defined
argument_list|(
name|ARCHIVE_HAS_SHA256
argument_list|)
operator|||
expr|\
name|defined
argument_list|(
name|ARCHIVE_HAS_SHA384
argument_list|)
operator|||
name|defined
argument_list|(
name|ARCHIVE_HAS_SHA512
argument_list|)
end_if

begin_function
specifier|static
name|void
name|strappend_bin
parameter_list|(
name|struct
name|archive_string
modifier|*
name|s
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|bin
parameter_list|,
name|int
name|n
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|hex
index|[]
init|=
literal|"0123456789abcdef"
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|archive_strappend_char
argument_list|(
name|s
argument_list|,
name|hex
index|[
name|bin
index|[
name|i
index|]
operator|>>
literal|4
index|]
argument_list|)
expr_stmt|;
name|archive_strappend_char
argument_list|(
name|s
argument_list|,
name|hex
index|[
name|bin
index|[
name|i
index|]
operator|&
literal|0x0f
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|int
name|archive_write_mtree_finish_entry
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|mtree_writer
modifier|*
name|mtree
init|=
name|a
operator|->
name|format_data
decl_stmt|;
name|struct
name|archive_entry
modifier|*
name|entry
decl_stmt|;
name|struct
name|archive_string
modifier|*
name|str
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|keys
decl_stmt|,
name|ret
decl_stmt|;
name|entry
operator|=
name|mtree
operator|->
name|entry
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ARCHIVE_ERRNO_PROGRAMMER
argument_list|,
literal|"Finished entry without being open first."
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|mtree
operator|->
name|entry
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|mtree
operator|->
name|dironly
operator|&&
name|archive_entry_filetype
argument_list|(
name|entry
argument_list|)
operator|!=
name|AE_IFDIR
condition|)
block|{
name|archive_entry_free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
name|str
operator|=
operator|(
name|mtree
operator|->
name|indent
operator|)
condition|?
operator|&
name|mtree
operator|->
name|ebuf
else|:
operator|&
name|mtree
operator|->
name|buf
expr_stmt|;
name|keys
operator|=
name|get_keys
argument_list|(
name|mtree
argument_list|,
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|keys
operator|&
name|F_NLINK
operator|)
operator|!=
literal|0
operator|&&
name|archive_entry_nlink
argument_list|(
name|entry
argument_list|)
operator|!=
literal|1
operator|&&
name|archive_entry_filetype
argument_list|(
name|entry
argument_list|)
operator|!=
name|AE_IFDIR
condition|)
name|archive_string_sprintf
argument_list|(
name|str
argument_list|,
literal|" nlink=%u"
argument_list|,
name|archive_entry_nlink
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|keys
operator|&
name|F_GNAME
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|name
operator|=
name|archive_entry_gname
argument_list|(
name|entry
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|archive_strcat
argument_list|(
name|str
argument_list|,
literal|" gname="
argument_list|)
expr_stmt|;
name|mtree_quote
argument_list|(
name|str
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|keys
operator|&
name|F_UNAME
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|name
operator|=
name|archive_entry_uname
argument_list|(
name|entry
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|archive_strcat
argument_list|(
name|str
argument_list|,
literal|" uname="
argument_list|)
expr_stmt|;
name|mtree_quote
argument_list|(
name|str
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|keys
operator|&
name|F_FLAGS
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|name
operator|=
name|archive_entry_fflags_text
argument_list|(
name|entry
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|archive_strcat
argument_list|(
name|str
argument_list|,
literal|" flags="
argument_list|)
expr_stmt|;
name|mtree_quote
argument_list|(
name|str
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|keys
operator|&
name|F_TIME
operator|)
operator|!=
literal|0
condition|)
name|archive_string_sprintf
argument_list|(
name|str
argument_list|,
literal|" time=%jd.%jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|archive_entry_mtime
argument_list|(
name|entry
argument_list|)
argument_list|,
operator|(
name|intmax_t
operator|)
name|archive_entry_mtime_nsec
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|keys
operator|&
name|F_MODE
operator|)
operator|!=
literal|0
condition|)
name|archive_string_sprintf
argument_list|(
name|str
argument_list|,
literal|" mode=%o"
argument_list|,
name|archive_entry_mode
argument_list|(
name|entry
argument_list|)
operator|&
literal|07777
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|keys
operator|&
name|F_GID
operator|)
operator|!=
literal|0
condition|)
name|archive_string_sprintf
argument_list|(
name|str
argument_list|,
literal|" gid=%jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|archive_entry_gid
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|keys
operator|&
name|F_UID
operator|)
operator|!=
literal|0
condition|)
name|archive_string_sprintf
argument_list|(
name|str
argument_list|,
literal|" uid=%jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|archive_entry_uid
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|archive_entry_filetype
argument_list|(
name|entry
argument_list|)
condition|)
block|{
case|case
name|AE_IFLNK
case|:
if|if
condition|(
operator|(
name|keys
operator|&
name|F_TYPE
operator|)
operator|!=
literal|0
condition|)
name|archive_strcat
argument_list|(
name|str
argument_list|,
literal|" type=link"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|keys
operator|&
name|F_SLINK
operator|)
operator|!=
literal|0
condition|)
block|{
name|archive_strcat
argument_list|(
name|str
argument_list|,
literal|" link="
argument_list|)
expr_stmt|;
name|mtree_quote
argument_list|(
name|str
argument_list|,
name|archive_entry_symlink
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|AE_IFSOCK
case|:
if|if
condition|(
operator|(
name|keys
operator|&
name|F_TYPE
operator|)
operator|!=
literal|0
condition|)
name|archive_strcat
argument_list|(
name|str
argument_list|,
literal|" type=socket"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AE_IFCHR
case|:
if|if
condition|(
operator|(
name|keys
operator|&
name|F_TYPE
operator|)
operator|!=
literal|0
condition|)
name|archive_strcat
argument_list|(
name|str
argument_list|,
literal|" type=char"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|keys
operator|&
name|F_DEV
operator|)
operator|!=
literal|0
condition|)
block|{
name|archive_string_sprintf
argument_list|(
name|str
argument_list|,
literal|" device=native,%d,%d"
argument_list|,
name|archive_entry_rdevmajor
argument_list|(
name|entry
argument_list|)
argument_list|,
name|archive_entry_rdevminor
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|AE_IFBLK
case|:
if|if
condition|(
operator|(
name|keys
operator|&
name|F_TYPE
operator|)
operator|!=
literal|0
condition|)
name|archive_strcat
argument_list|(
name|str
argument_list|,
literal|" type=block"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|keys
operator|&
name|F_DEV
operator|)
operator|!=
literal|0
condition|)
block|{
name|archive_string_sprintf
argument_list|(
name|str
argument_list|,
literal|" device=native,%d,%d"
argument_list|,
name|archive_entry_rdevmajor
argument_list|(
name|entry
argument_list|)
argument_list|,
name|archive_entry_rdevminor
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|AE_IFDIR
case|:
if|if
condition|(
operator|(
name|keys
operator|&
name|F_TYPE
operator|)
operator|!=
literal|0
condition|)
name|archive_strcat
argument_list|(
name|str
argument_list|,
literal|" type=dir"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AE_IFIFO
case|:
if|if
condition|(
operator|(
name|keys
operator|&
name|F_TYPE
operator|)
operator|!=
literal|0
condition|)
name|archive_strcat
argument_list|(
name|str
argument_list|,
literal|" type=fifo"
argument_list|)
expr_stmt|;
break|break;
case|case
name|AE_IFREG
case|:
default|default:
comment|/* Handle unknown file types as regular files. */
if|if
condition|(
operator|(
name|keys
operator|&
name|F_TYPE
operator|)
operator|!=
literal|0
condition|)
name|archive_strcat
argument_list|(
name|str
argument_list|,
literal|" type=file"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|keys
operator|&
name|F_SIZE
operator|)
operator|!=
literal|0
condition|)
name|archive_string_sprintf
argument_list|(
name|str
argument_list|,
literal|" size=%jd"
argument_list|,
operator|(
name|intmax_t
operator|)
name|archive_entry_size
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|mtree
operator|->
name|compute_sum
operator|&
name|F_CKSUM
condition|)
block|{
name|uint64_t
name|len
decl_stmt|;
comment|/* Include the length of the file. */
for|for
control|(
name|len
operator|=
name|mtree
operator|->
name|crc_len
init|;
name|len
operator|!=
literal|0
condition|;
name|len
operator|>>=
literal|8
control|)
name|COMPUTE_CRC
argument_list|(
name|mtree
operator|->
name|crc
argument_list|,
name|len
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|mtree
operator|->
name|crc
operator|=
operator|~
name|mtree
operator|->
name|crc
expr_stmt|;
name|archive_string_sprintf
argument_list|(
name|str
argument_list|,
literal|" cksum=%ju"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|mtree
operator|->
name|crc
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_MD5
if|if
condition|(
name|mtree
operator|->
name|compute_sum
operator|&
name|F_MD5
condition|)
block|{
name|unsigned
name|char
name|buf
index|[
literal|16
index|]
decl_stmt|;
name|archive_md5_final
argument_list|(
operator|&
name|mtree
operator|->
name|md5ctx
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|archive_strcat
argument_list|(
name|str
argument_list|,
literal|" md5digest="
argument_list|)
expr_stmt|;
name|strappend_bin
argument_list|(
name|str
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_RMD160
if|if
condition|(
name|mtree
operator|->
name|compute_sum
operator|&
name|F_RMD160
condition|)
block|{
name|unsigned
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|archive_rmd160_final
argument_list|(
operator|&
name|mtree
operator|->
name|rmd160ctx
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|archive_strcat
argument_list|(
name|str
argument_list|,
literal|" rmd160digest="
argument_list|)
expr_stmt|;
name|strappend_bin
argument_list|(
name|str
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA1
if|if
condition|(
name|mtree
operator|->
name|compute_sum
operator|&
name|F_SHA1
condition|)
block|{
name|unsigned
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|archive_sha1_final
argument_list|(
operator|&
name|mtree
operator|->
name|sha1ctx
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|archive_strcat
argument_list|(
name|str
argument_list|,
literal|" sha1digest="
argument_list|)
expr_stmt|;
name|strappend_bin
argument_list|(
name|str
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA256
if|if
condition|(
name|mtree
operator|->
name|compute_sum
operator|&
name|F_SHA256
condition|)
block|{
name|unsigned
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|archive_sha256_final
argument_list|(
operator|&
name|mtree
operator|->
name|sha256ctx
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|archive_strcat
argument_list|(
name|str
argument_list|,
literal|" sha256digest="
argument_list|)
expr_stmt|;
name|strappend_bin
argument_list|(
name|str
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA384
if|if
condition|(
name|mtree
operator|->
name|compute_sum
operator|&
name|F_SHA384
condition|)
block|{
name|unsigned
name|char
name|buf
index|[
literal|48
index|]
decl_stmt|;
name|archive_sha384_final
argument_list|(
operator|&
name|mtree
operator|->
name|sha384ctx
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|archive_strcat
argument_list|(
name|str
argument_list|,
literal|" sha384digest="
argument_list|)
expr_stmt|;
name|strappend_bin
argument_list|(
name|str
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA512
if|if
condition|(
name|mtree
operator|->
name|compute_sum
operator|&
name|F_SHA512
condition|)
block|{
name|unsigned
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|archive_sha512_final
argument_list|(
operator|&
name|mtree
operator|->
name|sha512ctx
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|archive_strcat
argument_list|(
name|str
argument_list|,
literal|" sha512digest="
argument_list|)
expr_stmt|;
name|strappend_bin
argument_list|(
name|str
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|archive_strcat
argument_list|(
name|str
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtree
operator|->
name|indent
condition|)
name|mtree_indent
argument_list|(
name|mtree
argument_list|)
expr_stmt|;
name|archive_entry_free
argument_list|(
name|entry
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtree
operator|->
name|buf
operator|.
name|length
operator|>
literal|32768
condition|)
block|{
name|ret
operator|=
call|(
name|a
operator|->
name|compressor
operator|.
name|write
call|)
argument_list|(
name|a
argument_list|,
name|mtree
operator|->
name|buf
operator|.
name|s
argument_list|,
name|mtree
operator|->
name|buf
operator|.
name|length
argument_list|)
expr_stmt|;
name|archive_string_empty
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
name|ret
operator|=
name|ARCHIVE_OK
expr_stmt|;
return|return
operator|(
name|ret
operator|==
name|ARCHIVE_OK
condition|?
name|ret
else|:
name|ARCHIVE_FATAL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_write_mtree_finish
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|mtree_writer
modifier|*
name|mtree
init|=
name|a
operator|->
name|format_data
decl_stmt|;
name|archive_write_set_bytes_in_last_block
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
call|(
name|a
operator|->
name|compressor
operator|.
name|write
call|)
argument_list|(
name|a
argument_list|,
name|mtree
operator|->
name|buf
operator|.
name|s
argument_list|,
name|mtree
operator|->
name|buf
operator|.
name|length
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|ssize_t
name|archive_write_mtree_data
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|buff
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|struct
name|mtree_writer
modifier|*
name|mtree
init|=
name|a
operator|->
name|format_data
decl_stmt|;
if|if
condition|(
name|n
operator|>
name|mtree
operator|->
name|entry_bytes_remaining
condition|)
name|n
operator|=
name|mtree
operator|->
name|entry_bytes_remaining
expr_stmt|;
if|if
condition|(
name|mtree
operator|->
name|dironly
condition|)
comment|/* We don't need compute a regular file sum */
return|return
operator|(
name|n
operator|)
return|;
if|if
condition|(
name|mtree
operator|->
name|compute_sum
operator|&
name|F_CKSUM
condition|)
block|{
comment|/* 		 * Compute a POSIX 1003.2 checksum 		 */
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|size_t
name|nn
decl_stmt|;
for|for
control|(
name|nn
operator|=
name|n
operator|,
name|p
operator|=
name|buff
init|;
name|nn
operator|--
condition|;
operator|++
name|p
control|)
name|COMPUTE_CRC
argument_list|(
name|mtree
operator|->
name|crc
argument_list|,
operator|*
name|p
argument_list|)
expr_stmt|;
name|mtree
operator|->
name|crc_len
operator|+=
name|n
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_MD5
if|if
condition|(
name|mtree
operator|->
name|compute_sum
operator|&
name|F_MD5
condition|)
name|archive_md5_update
argument_list|(
operator|&
name|mtree
operator|->
name|md5ctx
argument_list|,
name|buff
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_RMD160
if|if
condition|(
name|mtree
operator|->
name|compute_sum
operator|&
name|F_RMD160
condition|)
name|archive_rmd160_update
argument_list|(
operator|&
name|mtree
operator|->
name|rmd160ctx
argument_list|,
name|buff
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA1
if|if
condition|(
name|mtree
operator|->
name|compute_sum
operator|&
name|F_SHA1
condition|)
name|archive_sha1_update
argument_list|(
operator|&
name|mtree
operator|->
name|sha1ctx
argument_list|,
name|buff
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA256
if|if
condition|(
name|mtree
operator|->
name|compute_sum
operator|&
name|F_SHA256
condition|)
name|archive_sha256_update
argument_list|(
operator|&
name|mtree
operator|->
name|sha256ctx
argument_list|,
name|buff
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA384
if|if
condition|(
name|mtree
operator|->
name|compute_sum
operator|&
name|F_SHA384
condition|)
name|archive_sha384_update
argument_list|(
operator|&
name|mtree
operator|->
name|sha384ctx
argument_list|,
name|buff
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ARCHIVE_HAS_SHA512
if|if
condition|(
name|mtree
operator|->
name|compute_sum
operator|&
name|F_SHA512
condition|)
name|archive_sha512_update
argument_list|(
operator|&
name|mtree
operator|->
name|sha512ctx
argument_list|,
name|buff
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_write_mtree_destroy
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|)
block|{
name|struct
name|mtree_writer
modifier|*
name|mtree
init|=
name|a
operator|->
name|format_data
decl_stmt|;
if|if
condition|(
name|mtree
operator|==
name|NULL
condition|)
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
name|archive_entry_free
argument_list|(
name|mtree
operator|->
name|entry
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|mtree
operator|->
name|ebuf
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|)
expr_stmt|;
name|archive_string_free
argument_list|(
operator|&
name|mtree
operator|->
name|set
operator|.
name|parent
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|mtree
argument_list|)
expr_stmt|;
name|a
operator|->
name|format_data
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|archive_write_mtree_options
parameter_list|(
name|struct
name|archive_write
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|mtree_writer
modifier|*
name|mtree
init|=
name|a
operator|->
name|format_data
decl_stmt|;
name|int
name|keybit
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|key
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'a'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"all"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
operator|~
literal|0
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"cksum"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
name|F_CKSUM
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"device"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
name|F_DEV
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"dironly"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mtree
operator|->
name|dironly
operator|=
operator|(
name|value
operator|!=
name|NULL
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"flags"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
name|F_FLAGS
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"gid"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
name|F_GID
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"gname"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
name|F_GNAME
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"indent"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mtree
operator|->
name|indent
operator|=
operator|(
name|value
operator|!=
name|NULL
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"link"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
name|F_SLINK
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"md5"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"md5digest"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
name|F_MD5
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"mode"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
name|F_MODE
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"nlink"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
name|F_NLINK
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"ripemd160digest"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"rmd160"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"rmd160digest"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
name|F_RMD160
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"sha1"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"sha1digest"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
name|F_SHA1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"sha256"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"sha256digest"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
name|F_SHA256
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"sha384"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"sha384digest"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
name|F_SHA384
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"sha512"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"sha512digest"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
name|F_SHA512
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"size"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
name|F_SIZE
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"time"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
name|F_TIME
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"type"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
name|F_TYPE
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"uid"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
name|F_UID
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"uname"
argument_list|)
operator|==
literal|0
condition|)
name|keybit
operator|=
name|F_UNAME
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|key
argument_list|,
literal|"use-set"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mtree
operator|->
name|set
operator|.
name|output
operator|=
operator|(
name|value
operator|!=
name|NULL
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
break|break;
block|}
if|if
condition|(
name|keybit
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
name|mtree
operator|->
name|keys
operator||=
name|keybit
expr_stmt|;
else|else
name|mtree
operator|->
name|keys
operator|&=
operator|~
name|keybit
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
return|return
operator|(
name|ARCHIVE_WARN
operator|)
return|;
block|}
end_function

begin_function
name|int
name|archive_write_set_format_mtree
parameter_list|(
name|struct
name|archive
modifier|*
name|_a
parameter_list|)
block|{
name|struct
name|archive_write
modifier|*
name|a
init|=
operator|(
expr|struct
name|archive_write
operator|*
operator|)
name|_a
decl_stmt|;
name|struct
name|mtree_writer
modifier|*
name|mtree
decl_stmt|;
if|if
condition|(
name|a
operator|->
name|format_destroy
operator|!=
name|NULL
condition|)
call|(
name|a
operator|->
name|format_destroy
call|)
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mtree
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|mtree
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|archive_set_error
argument_list|(
operator|&
name|a
operator|->
name|archive
argument_list|,
name|ENOMEM
argument_list|,
literal|"Can't allocate mtree data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ARCHIVE_FATAL
operator|)
return|;
block|}
name|mtree
operator|->
name|entry
operator|=
name|NULL
expr_stmt|;
name|mtree
operator|->
name|first
operator|=
literal|1
expr_stmt|;
name|memset
argument_list|(
operator|&
operator|(
name|mtree
operator|->
name|set
operator|)
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|mtree
operator|->
name|set
argument_list|)
argument_list|)
expr_stmt|;
name|archive_string_init
argument_list|(
operator|&
name|mtree
operator|->
name|set
operator|.
name|parent
argument_list|)
expr_stmt|;
name|mtree
operator|->
name|keys
operator|=
name|DEFAULT_KEYS
expr_stmt|;
name|mtree
operator|->
name|dironly
operator|=
literal|0
expr_stmt|;
name|mtree
operator|->
name|indent
operator|=
literal|0
expr_stmt|;
name|archive_string_init
argument_list|(
operator|&
name|mtree
operator|->
name|ebuf
argument_list|)
expr_stmt|;
name|archive_string_init
argument_list|(
operator|&
name|mtree
operator|->
name|buf
argument_list|)
expr_stmt|;
name|a
operator|->
name|format_data
operator|=
name|mtree
expr_stmt|;
name|a
operator|->
name|format_destroy
operator|=
name|archive_write_mtree_destroy
expr_stmt|;
name|a
operator|->
name|pad_uncompressed
operator|=
literal|0
expr_stmt|;
name|a
operator|->
name|format_name
operator|=
literal|"mtree"
expr_stmt|;
name|a
operator|->
name|format_options
operator|=
name|archive_write_mtree_options
expr_stmt|;
name|a
operator|->
name|format_write_header
operator|=
name|archive_write_mtree_header
expr_stmt|;
name|a
operator|->
name|format_finish
operator|=
name|archive_write_mtree_finish
expr_stmt|;
name|a
operator|->
name|format_write_data
operator|=
name|archive_write_mtree_data
expr_stmt|;
name|a
operator|->
name|format_finish_entry
operator|=
name|archive_write_mtree_finish_entry
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format
operator|=
name|ARCHIVE_FORMAT_MTREE
expr_stmt|;
name|a
operator|->
name|archive
operator|.
name|archive_format_name
operator|=
literal|"mtree"
expr_stmt|;
return|return
operator|(
name|ARCHIVE_OK
operator|)
return|;
block|}
end_function

end_unit

