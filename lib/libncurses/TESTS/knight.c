begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Knights Tour - a brain game */
end_comment

begin_include
include|#
directive|include
file|<ncurses.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__FreeBSD__
end_ifdef

begin_define
define|#
directive|define
name|srand48
value|srandom
end_define

begin_define
define|#
directive|define
name|lrand48
value|random
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|short
name|board
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the squares */
end_comment

begin_decl_stmt
name|char
name|row
decl_stmt|,
name|column
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input characters */
end_comment

begin_decl_stmt
name|int
name|rw
decl_stmt|,
name|col
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* numeric equivalent of row and column */
end_comment

begin_decl_stmt
name|int
name|curow
decl_stmt|,
name|curcol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current row and column integers */
end_comment

begin_decl_stmt
name|int
name|rdif
decl_stmt|,
name|cdif
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* difference between input and current */
end_comment

begin_decl_stmt
name|int
name|j
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index into board */
end_comment

begin_decl_stmt
name|char
name|script
index|[]
init|=
block|{
literal|"'_)//,/(-)/__/__(_<_(__),|/|/_///_/_<//_/_)__o__o'______///_(--_(_)___,(_/,_/__(_\0"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ypos
index|[]
init|=
block|{
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|2
block|,
literal|4
block|,
literal|5
block|,
literal|5
block|,
literal|4
block|,
literal|3
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|,
literal|3
block|,
literal|3
block|,
literal|2
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|6
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|6
block|,
literal|7
block|,
literal|7
block|,
literal|6
block|,
literal|6
block|,
literal|7
block|,
literal|7
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|xpos
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|0
block|,
literal|5
block|,
literal|4
block|,
literal|3
block|,
literal|2
block|,
literal|4
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|15
block|,
literal|16
block|,
literal|16
block|,
literal|16
block|,
literal|15
block|,
literal|14
block|,
literal|15
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|23
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|26
block|,
literal|28
block|,
literal|13
block|,
literal|23
block|,
literal|25
block|,
literal|27
block|,
literal|27
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|4
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|5
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|14
block|,
literal|15
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|instructions
index|[]
init|=
block|{
literal|"     Knight's Tour is a board game for one player.   It is played on"
block|,
literal|"an eight by eight board and is based on the allowable moves that a knight"
block|,
literal|"can make in the game of chess.  For those who are unfamiliar with the"
block|,
literal|"game, a knight may move either on a row or a column but not diagonally."
block|,
literal|"He may move one square in any direction and two squares in a perpendicular"
block|,
literal|"direction>or< two squares in any direction and one square in a"
block|,
literal|"perpendicular direction.  He may not, of course, move off the board."
block|,
literal|""
block|,
literal|"     At the beginning of a game you will be asked to either choose a"
block|,
literal|"starting square or allow the computer to select a random location."
block|,
literal|"Squares are designated by a letter-number combination where the row is"
block|,
literal|"specified by a letter A-H and the numbers 1-8 define a column.  Invalid"
block|,
literal|"entries are ignored and illegal moves produce a beep at the terminal."
block|,
literal|""
block|,
literal|"     The objective is to visit every square on the board.  When you claim"
block|,
literal|"a square a marker is placed on it to show where you've been.  You may"
block|,
literal|"not revisit a square that you've landed on before."
block|,
literal|""
block|,
literal|"     After each move the program checks to see if you have any legal"
block|,
literal|"moves left.  If not, the game ends and your squares are counted.  If"
block|,
literal|"you've made all the squares you win the game.  Otherwise, you are told"
block|,
literal|"the number of squares you did make."
block|,
literal|"END"
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|play
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|drawboard
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dosquares
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|getfirst
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|getrc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|putstars
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|evalmove
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|chkmoves
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|endgame
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|chksqr
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|instruct
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|title
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|()
block|{
name|init
argument_list|()
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
if|if
condition|(
operator|!
name|play
argument_list|()
condition|)
block|{
name|endwin
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|init
parameter_list|()
block|{
name|srand48
argument_list|(
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|initscr
argument_list|()
expr_stmt|;
name|cbreak
argument_list|()
expr_stmt|;
comment|/* immediate char return */
name|noecho
argument_list|()
expr_stmt|;
comment|/* no immediate echo */
name|traceon
argument_list|()
expr_stmt|;
name|title
argument_list|(
literal|1
argument_list|,
literal|23
argument_list|)
expr_stmt|;
name|traceoff
argument_list|()
expr_stmt|;
name|mvaddstr
argument_list|(
literal|23
argument_list|,
literal|25
argument_list|,
literal|"Would you like instructions? "
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|toupper
argument_list|(
name|getch
argument_list|()
argument_list|)
operator|)
operator|==
literal|'Y'
condition|)
name|instruct
argument_list|()
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|play
parameter_list|()
block|{
name|drawboard
argument_list|()
expr_stmt|;
comment|/* clear screen and drawboard */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|64
condition|;
name|j
operator|++
control|)
name|board
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|getfirst
argument_list|()
expr_stmt|;
comment|/* get the starting square */
for|for
control|(
init|;
condition|;
control|)
block|{
name|getrc
argument_list|()
expr_stmt|;
if|if
condition|(
name|evalmove
argument_list|()
condition|)
block|{
name|putstars
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|chkmoves
argument_list|()
condition|)
return|return
operator|(
name|endgame
argument_list|()
operator|)
return|;
block|}
else|else
name|beep
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|drawboard
parameter_list|()
block|{
name|erase
argument_list|()
expr_stmt|;
name|dosquares
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|mvaddstr
argument_list|(
literal|0
argument_list|,
literal|7
argument_list|,
literal|"1   2   3   4   5   6   7   8"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
name|mvaddch
argument_list|(
literal|2
operator|*
name|j
operator|+
literal|2
argument_list|,
literal|3
argument_list|,
name|j
operator|+
literal|'A'
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|mvaddstr
argument_list|(
literal|20
argument_list|,
literal|5
argument_list|,
literal|"ROW:"
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|20
argument_list|,
literal|27
argument_list|,
literal|"COLUMN:"
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|14
argument_list|,
literal|49
argument_list|,
literal|"CURRENT ROW"
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|16
argument_list|,
literal|49
argument_list|,
literal|"CURRENT COL"
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|22
argument_list|,
literal|5
argument_list|,
literal|"A - H or Q to quit"
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|22
argument_list|,
literal|27
argument_list|,
literal|"1 - 8 or ESC to cancel row"
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|title
argument_list|(
literal|1
argument_list|,
literal|40
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dosquares
parameter_list|()
block|{
name|mvaddstr
argument_list|(
literal|1
argument_list|,
literal|6
argument_list|,
literal|"-------------------------------"
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<
literal|9
condition|;
name|j
operator|++
control|)
block|{
name|mvaddstr
argument_list|(
literal|2
operator|*
name|j
argument_list|,
literal|5
argument_list|,
literal|"|   |   |   |   |   |   |   |   |"
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|2
operator|*
name|j
operator|+
literal|1
argument_list|,
literal|6
argument_list|,
literal|"-------------------------------"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|getfirst
parameter_list|()
comment|/* get first square */
block|{
name|mvaddstr
argument_list|(
literal|23
argument_list|,
literal|25
argument_list|,
literal|"(S)elect or (R)andom "
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
do|do
block|{
name|row
operator|=
name|toupper
argument_list|(
name|getch
argument_list|()
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|row
operator|!=
literal|'S'
operator|)
operator|&&
operator|(
name|row
operator|!=
literal|'R'
operator|)
condition|)
do|;
if|if
condition|(
name|row
operator|==
literal|'R'
condition|)
block|{
name|rw
operator|=
name|lrand48
argument_list|()
operator|%
literal|8
expr_stmt|;
name|col
operator|=
name|lrand48
argument_list|()
operator|%
literal|8
expr_stmt|;
name|j
operator|=
literal|8
operator|*
name|rw
operator|+
name|col
expr_stmt|;
name|row
operator|=
name|rw
operator|+
literal|'A'
expr_stmt|;
name|column
operator|=
name|col
operator|+
literal|'1'
expr_stmt|;
block|}
else|else
block|{
name|mvaddstr
argument_list|(
literal|23
argument_list|,
literal|25
argument_list|,
literal|"Enter starting row and column"
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|getrc
argument_list|()
expr_stmt|;
comment|/* get row and column */
block|}
name|putstars
argument_list|()
expr_stmt|;
name|move
argument_list|(
literal|23
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtobot
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|getrc
parameter_list|()
comment|/* get row and column */
block|{
name|noecho
argument_list|()
expr_stmt|;
do|do
block|{
name|mvaddstr
argument_list|(
literal|20
argument_list|,
literal|35
argument_list|,
literal|"  "
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
do|do
block|{
name|mvaddch
argument_list|(
literal|20
argument_list|,
literal|11
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|move
argument_list|(
literal|20
argument_list|,
literal|11
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|row
operator|=
name|toupper
argument_list|(
name|getch
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|row
operator|==
literal|'Q'
condition|)
block|{
name|endwin
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|row
operator|<
literal|'A'
operator|)
operator|||
operator|(
name|row
operator|>
literal|'H'
operator|)
condition|)
do|;
name|addch
argument_list|(
name|row
argument_list|)
expr_stmt|;
name|move
argument_list|(
literal|20
argument_list|,
literal|35
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
do|do
block|{
name|column
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|column
operator|==
literal|'\033'
condition|)
break|break;
block|}
do|while
condition|(
operator|(
name|column
operator|<
literal|'1'
operator|)
operator|||
operator|(
name|column
operator|>
literal|'8'
operator|)
condition|)
do|;
if|if
condition|(
name|column
operator|!=
literal|'\033'
condition|)
name|addch
argument_list|(
name|column
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|column
operator|==
literal|'\033'
condition|)
do|;
name|refresh
argument_list|()
expr_stmt|;
name|rw
operator|=
name|row
operator|-
literal|'A'
expr_stmt|;
name|col
operator|=
name|column
operator|-
literal|'1'
expr_stmt|;
name|j
operator|=
literal|8
operator|*
name|rw
operator|+
name|col
expr_stmt|;
block|}
end_function

begin_function
name|void
name|putstars
parameter_list|()
comment|/* place the stars, update board& currents */
block|{
name|mvaddch
argument_list|(
literal|2
operator|*
name|curow
operator|+
literal|2
argument_list|,
literal|38
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|mvaddch
argument_list|(
literal|2
operator|*
name|rw
operator|+
literal|2
argument_list|,
literal|38
argument_list|,
literal|'<'
argument_list|)
expr_stmt|;
name|mvaddch
argument_list|(
literal|18
argument_list|,
name|curcol
operator|*
literal|4
operator|+
literal|7
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|mvaddch
argument_list|(
literal|18
argument_list|,
name|col
operator|*
literal|4
operator|+
literal|7
argument_list|,
literal|'^'
argument_list|)
expr_stmt|;
name|curow
operator|=
name|rw
expr_stmt|;
name|curcol
operator|=
name|col
expr_stmt|;
name|mvaddstr
argument_list|(
literal|2
operator|*
name|rw
operator|+
literal|2
argument_list|,
literal|4
operator|*
name|col
operator|+
literal|6
argument_list|,
literal|"***"
argument_list|)
expr_stmt|;
name|mvaddch
argument_list|(
literal|14
argument_list|,
literal|61
argument_list|,
name|row
argument_list|)
expr_stmt|;
name|mvaddch
argument_list|(
literal|16
argument_list|,
literal|61
argument_list|,
name|column
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|board
index|[
name|j
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|int
name|evalmove
parameter_list|()
comment|/* convert row and column to integers */
comment|/* and evaluate move */
block|{
name|rdif
operator|=
name|rw
operator|-
name|curow
expr_stmt|;
name|cdif
operator|=
name|col
operator|-
name|curcol
expr_stmt|;
name|rdif
operator|=
name|abs
argument_list|(
name|rw
operator|-
name|curow
argument_list|)
expr_stmt|;
name|cdif
operator|=
name|abs
argument_list|(
name|col
operator|-
name|curcol
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|rdif
operator|==
literal|1
operator|)
operator|&&
operator|(
name|cdif
operator|==
literal|2
operator|)
condition|)
if|if
condition|(
name|board
index|[
name|j
index|]
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|rdif
operator|==
literal|2
operator|)
operator|&&
operator|(
name|cdif
operator|==
literal|1
operator|)
condition|)
if|if
condition|(
name|board
index|[
name|j
index|]
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|chkmoves
parameter_list|()
comment|/* check to see if valid moves are available */
block|{
if|if
condition|(
name|chksqr
argument_list|(
literal|2
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|chksqr
argument_list|(
literal|2
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|chksqr
argument_list|(
operator|-
literal|2
argument_list|,
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|chksqr
argument_list|(
operator|-
literal|2
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|chksqr
argument_list|(
literal|1
argument_list|,
literal|2
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|chksqr
argument_list|(
literal|1
argument_list|,
operator|-
literal|2
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|chksqr
argument_list|(
operator|-
literal|1
argument_list|,
literal|2
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|chksqr
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|2
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|endgame
parameter_list|()
comment|/* check for filled board or not */
block|{
name|rw
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|64
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|board
index|[
name|j
index|]
operator|!=
literal|0
condition|)
name|rw
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|rw
operator|==
literal|64
condition|)
name|mvaddstr
argument_list|(
literal|20
argument_list|,
literal|20
argument_list|,
literal|"Congratulations !! You got 'em all"
argument_list|)
expr_stmt|;
else|else
name|mvprintw
argument_list|(
literal|20
argument_list|,
literal|20
argument_list|,
literal|"You have ended up with %2d squares"
argument_list|,
name|rw
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|21
argument_list|,
literal|25
argument_list|,
literal|"Play again ? (y/n) "
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|row
operator|=
name|tolower
argument_list|(
name|getch
argument_list|()
argument_list|)
operator|)
operator|==
literal|'y'
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|abs
end_ifndef

begin_macro
name|abs
argument_list|(
argument|num
argument_list|)
end_macro

begin_decl_stmt
name|int
name|num
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|num
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
name|num
operator|)
return|;
else|else
return|return
operator|(
name|num
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|chksqr
parameter_list|(
name|int
name|n1
parameter_list|,
name|int
name|n2
parameter_list|)
block|{
name|int
name|r1
decl_stmt|,
name|c1
decl_stmt|;
name|r1
operator|=
name|rw
operator|+
name|n1
expr_stmt|;
name|c1
operator|=
name|col
operator|+
name|n2
expr_stmt|;
if|if
condition|(
operator|(
name|r1
operator|<
literal|0
operator|)
operator|||
operator|(
name|r1
operator|>
literal|7
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|(
name|c1
operator|<
literal|0
operator|)
operator|||
operator|(
name|c1
operator|>
literal|7
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|board
index|[
name|r1
operator|*
literal|8
operator|+
name|c1
index|]
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|instruct
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|instructions
index|[
name|i
index|]
argument_list|,
literal|"END"
argument_list|)
operator|)
condition|)
name|mvaddstr
argument_list|(
name|i
argument_list|,
literal|0
argument_list|,
name|instructions
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|mvaddstr
argument_list|(
literal|23
argument_list|,
literal|25
argument_list|,
literal|"Ready to play ? (y/n) "
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
if|if
condition|(
name|toupper
argument_list|(
name|getch
argument_list|()
argument_list|)
operator|==
literal|'Y'
condition|)
block|{
name|clear
argument_list|()
expr_stmt|;
return|return;
block|}
else|else
block|{
name|clear
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|title
parameter_list|(
name|y
parameter_list|,
name|x
parameter_list|)
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|c
operator|=
name|script
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
break|break ;
name|mvaddch
argument_list|(
name|ypos
index|[
name|j
index|]
operator|+
name|y
argument_list|,
name|xpos
index|[
name|j
index|]
operator|+
name|x
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
literal|0
condition|)
do|;
name|refresh
argument_list|()
expr_stmt|;
block|}
end_function

end_unit

