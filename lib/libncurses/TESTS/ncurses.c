begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************************  NAME    ncurses.c --- ncurses library exerciser  SYNOPSIS    ncurses  DESCRIPTION    An interactive test module for the ncurses library.  AUTHOR    This software is Copyright (C) 1993 by Eric S. Raymond, all rights reserved. It is issued with ncurses under the same terms and conditions as the ncurses library source.  ***************************************************************************/
end_comment

begin_comment
comment|/*LINTLIBRARY */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ncurses.h>
end_include

begin_define
define|#
directive|define
name|P
parameter_list|(
name|s
parameter_list|)
value|printw("%s\n", s)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|CTRL
end_ifndef

begin_define
define|#
directive|define
name|CTRL
parameter_list|(
name|x
parameter_list|)
value|((x)& 0x1f)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/****************************************************************************  *  * Character input test  *  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|getch_test
parameter_list|(
name|void
parameter_list|)
comment|/* test the keypad feature */
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|unsigned
name|int
name|c
decl_stmt|;
name|int
name|incount
init|=
literal|0
decl_stmt|,
name|firsttime
init|=
literal|0
decl_stmt|;
name|bool
name|blocking
init|=
name|TRUE
decl_stmt|;
name|refresh
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"Delay in 10ths of a second (<CR> for blocking input)? "
argument_list|)
expr_stmt|;
name|echo
argument_list|()
expr_stmt|;
name|getstr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|noecho
argument_list|()
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|timeout
argument_list|(
name|atoi
argument_list|(
name|buf
argument_list|)
operator|*
literal|100
argument_list|)
expr_stmt|;
name|blocking
operator|=
name|FALSE
expr_stmt|;
block|}
name|c
operator|=
literal|'?'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|firsttime
operator|++
condition|)
block|{
name|printw
argument_list|(
literal|"Key pressed: %04o "
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
name|KEY_MIN
condition|)
block|{
operator|(
name|void
operator|)
name|addstr
argument_list|(
name|keyname
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>
literal|0x80
condition|)
block|{
if|if
condition|(
name|isprint
argument_list|(
name|c
operator|&
operator|~
literal|0x80
argument_list|)
condition|)
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"M-%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"M-%s"
argument_list|,
name|unctrl
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|" (high-half character)\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"%c (ASCII printable character)\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"%s (ASCII control character)\n"
argument_list|,
name|unctrl
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|==
literal|'x'
operator|||
name|c
operator|==
literal|'q'
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'?'
condition|)
name|addstr
argument_list|(
literal|"Type any key to see its keypad value, `q' to quit, `?' for help.\n"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|==
name|ERR
condition|)
if|if
condition|(
operator|!
name|blocking
condition|)
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"%05d: input timed out\n"
argument_list|,
name|incount
operator|++
argument_list|)
expr_stmt|;
block|}
name|timeout
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|attr_test
parameter_list|(
name|void
parameter_list|)
comment|/* test text attributes */
block|{
name|refresh
argument_list|()
expr_stmt|;
name|mvaddstr
argument_list|(
literal|0
argument_list|,
literal|20
argument_list|,
literal|"Character attribute test display"
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|2
argument_list|,
literal|8
argument_list|,
literal|"This is STANDOUT mode: "
argument_list|)
expr_stmt|;
name|attron
argument_list|(
name|A_STANDOUT
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"abcde fghij klmno pqrst uvwxy x"
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_STANDOUT
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|4
argument_list|,
literal|8
argument_list|,
literal|"This is REVERSE mode: "
argument_list|)
expr_stmt|;
name|attron
argument_list|(
name|A_REVERSE
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"abcde fghij klmno pqrst uvwxy x"
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_REVERSE
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|6
argument_list|,
literal|8
argument_list|,
literal|"This is BOLD mode: "
argument_list|)
expr_stmt|;
name|attron
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"abcde fghij klmno pqrst uvwxy x"
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|8
argument_list|,
literal|8
argument_list|,
literal|"This is UNDERLINE mode: "
argument_list|)
expr_stmt|;
name|attron
argument_list|(
name|A_UNDERLINE
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"abcde fghij klmno pqrst uvwxy x"
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_UNDERLINE
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|10
argument_list|,
literal|8
argument_list|,
literal|"This is DIM mode: "
argument_list|)
expr_stmt|;
name|attron
argument_list|(
name|A_DIM
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"abcde fghij klmno pqrst uvwxy x"
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_DIM
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|12
argument_list|,
literal|8
argument_list|,
literal|"This is BLINK mode: "
argument_list|)
expr_stmt|;
name|attron
argument_list|(
name|A_BLINK
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"abcde fghij klmno pqrst uvwxy x"
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_BLINK
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|14
argument_list|,
literal|8
argument_list|,
literal|"This is BOLD UNDERLINE BLINK mode: "
argument_list|)
expr_stmt|;
name|attron
argument_list|(
name|A_BOLD
operator||
name|A_BLINK
operator||
name|A_UNDERLINE
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"abcde fghij klmno pqrst uvwxy x"
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_BOLD
operator||
name|A_BLINK
operator||
name|A_UNDERLINE
argument_list|)
expr_stmt|;
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|16
argument_list|,
literal|8
argument_list|,
literal|"This is NORMAL mode: "
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"abcde fghij klmno pqrst uvwxy x"
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"Press any key to continue... "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getch
argument_list|()
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * Color support tests  *  ****************************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|colors
index|[]
init|=
block|{
literal|"black"
block|,
literal|"red"
block|,
literal|"green"
block|,
literal|"yellow"
block|,
literal|"blue"
block|,
literal|"magenta"
block|,
literal|"cyan"
block|,
literal|"white"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|color_test
parameter_list|(
name|void
parameter_list|)
comment|/* generate a color test pattern */
block|{
name|int
name|i
decl_stmt|;
name|refresh
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"There are %d color pairs\n"
argument_list|,
name|COLOR_PAIRS
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mvprintw
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%dx%d matrix of foreground/background colors, bright *off*\n"
argument_list|,
name|COLORS
argument_list|,
name|COLORS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COLORS
condition|;
name|i
operator|++
control|)
name|mvaddstr
argument_list|(
literal|2
argument_list|,
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
literal|8
argument_list|,
name|colors
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COLORS
condition|;
name|i
operator|++
control|)
name|mvaddstr
argument_list|(
literal|3
operator|+
name|i
argument_list|,
literal|0
argument_list|,
name|colors
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|COLOR_PAIRS
condition|;
name|i
operator|++
control|)
block|{
name|init_pair
argument_list|(
name|i
argument_list|,
name|i
operator|%
name|COLORS
argument_list|,
name|i
operator|/
name|COLORS
argument_list|)
expr_stmt|;
name|attron
argument_list|(
name|COLOR_PAIR
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|3
operator|+
operator|(
name|i
operator|/
name|COLORS
operator|)
argument_list|,
operator|(
name|i
operator|%
name|COLORS
operator|+
literal|1
operator|)
operator|*
literal|8
argument_list|,
literal|"Hello"
argument_list|)
expr_stmt|;
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|mvprintw
argument_list|(
name|COLORS
operator|+
literal|4
argument_list|,
literal|0
argument_list|,
literal|"%dx%d matrix of foreground/background colors, bright *on*\n"
argument_list|,
name|COLORS
argument_list|,
name|COLORS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COLORS
condition|;
name|i
operator|++
control|)
name|mvaddstr
argument_list|(
literal|5
operator|+
name|COLORS
argument_list|,
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
literal|8
argument_list|,
name|colors
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COLORS
condition|;
name|i
operator|++
control|)
name|mvaddstr
argument_list|(
literal|6
operator|+
name|COLORS
operator|+
name|i
argument_list|,
literal|0
argument_list|,
name|colors
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|COLOR_PAIRS
condition|;
name|i
operator|++
control|)
block|{
name|init_pair
argument_list|(
name|i
argument_list|,
name|i
operator|%
name|COLORS
argument_list|,
name|i
operator|/
name|COLORS
argument_list|)
expr_stmt|;
name|attron
argument_list|(
name|COLOR_PAIR
argument_list|(
name|i
argument_list|)
operator||
name|A_BOLD
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|6
operator|+
name|COLORS
operator|+
operator|(
name|i
operator|/
name|COLORS
operator|)
argument_list|,
operator|(
name|i
operator|%
name|COLORS
operator|+
literal|1
operator|)
operator|*
literal|8
argument_list|,
literal|"Hello"
argument_list|)
expr_stmt|;
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
block|}
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"Press any key to continue... "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getch
argument_list|()
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|color_edit
parameter_list|(
name|void
parameter_list|)
comment|/* display the color test pattern, without trying to edit colors */
block|{
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|value
init|=
literal|0
decl_stmt|,
name|current
init|=
literal|0
decl_stmt|,
name|field
init|=
literal|0
decl_stmt|,
name|usebase
init|=
literal|0
decl_stmt|;
name|refresh
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COLORS
condition|;
name|i
operator|++
control|)
name|init_pair
argument_list|(
name|i
argument_list|,
name|COLOR_WHITE
argument_list|,
name|i
argument_list|)
expr_stmt|;
do|do
block|{
name|short
name|red
decl_stmt|,
name|green
decl_stmt|,
name|blue
decl_stmt|;
name|attron
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|0
argument_list|,
literal|20
argument_list|,
literal|"Color RGB Value Editing"
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COLORS
condition|;
name|i
operator|++
control|)
block|{
name|mvprintw
argument_list|(
literal|2
operator|+
name|i
argument_list|,
literal|0
argument_list|,
literal|"%c %-8s:"
argument_list|,
operator|(
name|i
operator|==
name|current
condition|?
literal|'>'
else|:
literal|' '
operator|)
argument_list|,
operator|(
name|i
operator|<
sizeof|sizeof
argument_list|(
name|colors
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|colors
index|[
literal|0
index|]
argument_list|)
condition|?
name|colors
index|[
name|i
index|]
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|attrset
argument_list|(
name|COLOR_PAIR
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"        "
argument_list|)
expr_stmt|;
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
comment|/* 	     * Note: this refresh should *not* be necessary!  It works around 	     * a bug in attribute handling that apparently causes the A_NORMAL 	     * attribute sets to interfere with the actual emission of the 	     * color setting somehow.  This needs to be fixed. 	     */
name|refresh
argument_list|()
expr_stmt|;
name|color_content
argument_list|(
name|i
argument_list|,
operator|&
name|red
argument_list|,
operator|&
name|green
argument_list|,
operator|&
name|blue
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"   R = "
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|==
name|i
operator|&&
name|field
operator|==
literal|0
condition|)
name|attron
argument_list|(
name|A_STANDOUT
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"%04d"
argument_list|,
name|red
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|==
name|i
operator|&&
name|field
operator|==
literal|0
condition|)
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|", G = "
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|==
name|i
operator|&&
name|field
operator|==
literal|1
condition|)
name|attron
argument_list|(
name|A_STANDOUT
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"%04d"
argument_list|,
name|green
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|==
name|i
operator|&&
name|field
operator|==
literal|1
condition|)
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|", B = "
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|==
name|i
operator|&&
name|field
operator|==
literal|2
condition|)
name|attron
argument_list|(
name|A_STANDOUT
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"%04d"
argument_list|,
name|blue
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|==
name|i
operator|&&
name|field
operator|==
literal|2
condition|)
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
name|mvaddstr
argument_list|(
name|COLORS
operator|+
literal|3
argument_list|,
literal|0
argument_list|,
literal|"Use up/down to select a color, left/right to change fields."
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|COLORS
operator|+
literal|4
argument_list|,
literal|0
argument_list|,
literal|"Modify field by typing nnn=, nnn-, or nnn+.  ? for help."
argument_list|)
expr_stmt|;
name|move
argument_list|(
literal|2
operator|+
name|current
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
operator|=
name|getch
argument_list|()
condition|)
block|{
case|case
name|KEY_UP
case|:
name|current
operator|=
operator|(
name|current
operator|==
literal|0
condition|?
operator|(
name|COLORS
operator|-
literal|1
operator|)
else|:
name|current
operator|-
literal|1
operator|)
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|KEY_DOWN
case|:
name|current
operator|=
operator|(
name|current
operator|==
operator|(
name|COLORS
operator|-
literal|1
operator|)
condition|?
literal|0
else|:
name|current
operator|+
literal|1
operator|)
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|KEY_RIGHT
case|:
name|field
operator|=
operator|(
name|field
operator|==
literal|2
condition|?
literal|0
else|:
name|field
operator|+
literal|1
operator|)
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|KEY_LEFT
case|:
name|field
operator|=
operator|(
name|field
operator|==
literal|0
condition|?
literal|2
else|:
name|field
operator|-
literal|1
operator|)
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
do|do
block|{
name|value
operator|=
name|value
operator|*
literal|10
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
do|;
if|if
condition|(
name|c
operator|!=
literal|'+'
operator|&&
name|c
operator|!=
literal|'-'
operator|&&
name|c
operator|!=
literal|'='
condition|)
name|beep
argument_list|()
expr_stmt|;
else|else
name|ungetch
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|usebase
operator|=
literal|1
expr_stmt|;
goto|goto
name|changeit
goto|;
case|case
literal|'-'
case|:
name|value
operator|=
operator|-
name|value
expr_stmt|;
name|usebase
operator|=
literal|1
expr_stmt|;
goto|goto
name|changeit
goto|;
case|case
literal|'='
case|:
name|usebase
operator|=
literal|0
expr_stmt|;
name|changeit
label|:
name|color_content
argument_list|(
name|current
argument_list|,
operator|&
name|red
argument_list|,
operator|&
name|green
argument_list|,
operator|&
name|blue
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|==
literal|0
condition|)
name|red
operator|=
name|red
operator|*
name|usebase
operator|+
name|value
expr_stmt|;
elseif|else
if|if
condition|(
name|field
operator|==
literal|1
condition|)
name|green
operator|=
name|green
operator|*
name|usebase
operator|+
name|value
expr_stmt|;
elseif|else
if|if
condition|(
name|field
operator|==
literal|2
condition|)
name|blue
operator|=
name|blue
operator|*
name|usebase
operator|+
name|value
expr_stmt|;
name|init_color
argument_list|(
name|current
argument_list|,
name|red
argument_list|,
name|green
argument_list|,
name|blue
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|erase
argument_list|()
expr_stmt|;
name|P
argument_list|(
literal|"                      RGB Value Editing Help"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"You are in the RGB value editor.  Use the arrow keys to select one of"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"the fields in one of the RGB triples of the current colors; the one"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"currently selected will be reverse-video highlighted."
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"To change a field, enter the digits of the new value; they won't be"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"echoed.  Finish by typing `='; the change will take effect instantly."
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"To increment or decrement a value, use the same procedure, but finish"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"with a `+' or `-'."
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"To quit, do `x' or 'q'"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"Press any key to continue... "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getch
argument_list|()
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'q'
case|:
break|break;
default|default:
name|beep
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|c
operator|!=
literal|'x'
operator|&&
name|c
operator|!=
literal|'q'
condition|)
do|;
name|erase
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * Soft-key label test  *  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|slk_test
parameter_list|(
name|void
parameter_list|)
comment|/* exercise the soft keys */
block|{
name|int
name|c
decl_stmt|,
name|fmt
init|=
literal|1
decl_stmt|;
name|char
name|buf
index|[
literal|9
index|]
decl_stmt|;
name|c
operator|=
name|CTRL
argument_list|(
literal|'l'
argument_list|)
expr_stmt|;
do|do
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|CTRL
argument_list|(
literal|'l'
argument_list|)
case|:
name|erase
argument_list|()
expr_stmt|;
name|attron
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|0
argument_list|,
literal|20
argument_list|,
literal|"Soft Key Exerciser"
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|move
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"Available commands are:"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"^L         -- refresh screen"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"a          -- activate or restore soft keys"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"d          -- disable soft keys"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"c          -- set centered format for labels"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"l          -- set left-justified format for labels"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"r          -- set right-justified format for labels"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"[12345678] -- set label; labels are numbered 1 through 8"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"e          -- erase stdscr (should not erase labels)"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"s          -- test scrolling of shortened screen"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"x, q       -- return to main menu"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"Note: if activating the soft keys causes your terminal to"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"scroll up one line, your terminal auto-scrolls when anything"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"is written to the last screen position.  The ncurses code"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"does not yet handle this gracefully."
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
comment|/* fall through */
case|case
literal|'a'
case|:
name|slk_restore
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|wclear
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|move
argument_list|(
literal|20
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|!=
literal|'Q'
condition|)
name|addch
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|slk_clear
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|fmt
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|fmt
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|fmt
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
operator|(
name|void
operator|)
name|mvaddstr
argument_list|(
literal|20
argument_list|,
literal|0
argument_list|,
literal|"Please enter the label value: "
argument_list|)
expr_stmt|;
name|wgetnstr
argument_list|(
name|stdscr
argument_list|,
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|slk_set
argument_list|(
operator|(
name|c
operator|-
literal|'0'
operator|)
argument_list|,
name|buf
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|slk_refresh
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'q'
case|:
goto|goto
name|done
goto|;
default|default:
name|beep
argument_list|()
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|!=
name|EOF
condition|)
do|;
name|done
label|:
name|erase
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * Alternate character-set stuff  *  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|acs_display
parameter_list|()
comment|/* display the ACS character set */
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|erase
argument_list|()
expr_stmt|;
name|attron
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|0
argument_list|,
literal|20
argument_list|,
literal|"Display of the ACS Character Set"
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
define|#
directive|define
name|ACSY
value|2
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|0
argument_list|,
literal|0
argument_list|,
literal|"ACS_ULCORNER: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_ULCORNER
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
literal|"ACS_LLCORNER: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_LLCORNER
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|2
argument_list|,
literal|0
argument_list|,
literal|"ACS_URCORNER: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_URCORNER
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|3
argument_list|,
literal|0
argument_list|,
literal|"ACS_LRCORNER: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_LRCORNER
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|4
argument_list|,
literal|0
argument_list|,
literal|"ACS_RTEE: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_RTEE
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|5
argument_list|,
literal|0
argument_list|,
literal|"ACS_LTEE: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_LTEE
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|6
argument_list|,
literal|0
argument_list|,
literal|"ACS_BTEE: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_BTEE
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|7
argument_list|,
literal|0
argument_list|,
literal|"ACS_TTEE: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_TTEE
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|8
argument_list|,
literal|0
argument_list|,
literal|"ACS_HLINE: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_HLINE
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|9
argument_list|,
literal|0
argument_list|,
literal|"ACS_VLINE: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_VLINE
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|10
argument_list|,
literal|0
argument_list|,
literal|"ACS_PLUS: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_PLUS
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|11
argument_list|,
literal|0
argument_list|,
literal|"ACS_S1: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_S1
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|12
argument_list|,
literal|0
argument_list|,
literal|"ACS_S9: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_S9
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|0
argument_list|,
literal|40
argument_list|,
literal|"ACS_DIAMOND: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_DIAMOND
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|1
argument_list|,
literal|40
argument_list|,
literal|"ACS_CKBOARD: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_CKBOARD
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|2
argument_list|,
literal|40
argument_list|,
literal|"ACS_DEGREE: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_DEGREE
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|3
argument_list|,
literal|40
argument_list|,
literal|"ACS_PLMINUS: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_PLMINUS
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|4
argument_list|,
literal|40
argument_list|,
literal|"ACS_BULLET: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_BULLET
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|5
argument_list|,
literal|40
argument_list|,
literal|"ACS_LARROW: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_LARROW
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|6
argument_list|,
literal|40
argument_list|,
literal|"ACS_RARROW: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_RARROW
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|7
argument_list|,
literal|40
argument_list|,
literal|"ACS_DARROW: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_DARROW
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|8
argument_list|,
literal|40
argument_list|,
literal|"ACS_UARROW: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_UARROW
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|9
argument_list|,
literal|40
argument_list|,
literal|"ACS_BOARD: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_BOARD
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|10
argument_list|,
literal|40
argument_list|,
literal|"ACS_LANTERN: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_LANTERN
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|11
argument_list|,
literal|40
argument_list|,
literal|"ACS_BLOCK: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_BLOCK
argument_list|)
expr_stmt|;
define|#
directive|define
name|HYBASE
value|(ACSY + 13)
name|mvprintw
argument_list|(
name|HYBASE
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
literal|"High-half characters via echochar:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
name|move
argument_list|(
name|HYBASE
operator|+
name|i
operator|+
literal|3
argument_list|,
literal|24
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|32
condition|;
name|j
operator|++
control|)
name|echochar
argument_list|(
literal|128
operator|+
literal|32
operator|*
name|i
operator|+
name|j
argument_list|)
expr_stmt|;
block|}
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"Press any key to continue... "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getch
argument_list|()
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * Windows and scrolling tester.  *  ****************************************************************************/
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
block|}
name|pair
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|report
parameter_list|(
name|void
parameter_list|)
comment|/* report on the cursor's current position, then restore it */
block|{
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|getyx
argument_list|(
name|stdscr
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
name|COLS
operator|-
literal|17
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"Y = %2d X = %2d"
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|pair
modifier|*
name|selectcell
parameter_list|(
name|uli
parameter_list|,
name|ulj
parameter_list|,
name|lri
parameter_list|,
name|lrj
parameter_list|)
comment|/* arrows keys move cursor, return location at current on non-arrow key */
name|int
name|uli
decl_stmt|,
name|ulj
decl_stmt|,
name|lri
decl_stmt|,
name|lrj
decl_stmt|;
comment|/* co-ordinates of corners */
block|{
specifier|static
name|pair
name|res
decl_stmt|;
comment|/* result cell */
name|int
name|si
init|=
name|lri
operator|-
name|uli
operator|+
literal|1
decl_stmt|;
comment|/* depth of the select area */
name|int
name|sj
init|=
name|lrj
operator|-
name|ulj
operator|+
literal|1
decl_stmt|;
comment|/* width of the select area */
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
comment|/* offsets into the select area */
for|for
control|(
init|;
condition|;
control|)
block|{
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
name|COLS
operator|-
literal|17
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"Y = %2d X = %2d"
argument_list|,
name|uli
operator|+
name|i
argument_list|,
name|ulj
operator|+
name|j
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|uli
operator|+
name|i
argument_list|,
name|ulj
operator|+
name|j
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|getch
argument_list|()
condition|)
block|{
case|case
name|KEY_UP
case|:
name|i
operator|+=
name|si
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|KEY_DOWN
case|:
name|i
operator|++
expr_stmt|;
break|break;
case|case
name|KEY_LEFT
case|:
name|j
operator|+=
name|sj
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|KEY_RIGHT
case|:
name|j
operator|++
expr_stmt|;
break|break;
case|case
literal|'\004'
case|:
return|return
operator|(
operator|(
name|pair
operator|*
operator|)
name|NULL
operator|)
return|;
default|default:
name|res
operator|.
name|y
operator|=
name|uli
operator|+
name|i
expr_stmt|;
name|res
operator|.
name|x
operator|=
name|ulj
operator|+
name|j
expr_stmt|;
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
name|i
operator|%=
name|si
expr_stmt|;
name|j
operator|%=
name|sj
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|WINDOW
modifier|*
name|getwindow
parameter_list|(
name|void
parameter_list|)
comment|/* Ask user for a window definition */
block|{
name|WINDOW
modifier|*
name|rwindow
decl_stmt|,
modifier|*
name|bwindow
decl_stmt|;
name|pair
name|ul
decl_stmt|,
name|lr
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|move
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
name|addstr
argument_list|(
literal|"Use arrows to move cursor, anything else to mark corner 1"
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|=
name|selectcell
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|LINES
operator|-
literal|1
argument_list|,
name|COLS
operator|-
literal|1
argument_list|)
operator|)
operator|==
operator|(
name|pair
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
operator|)
return|;
name|memcpy
argument_list|(
operator|&
name|ul
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|pair
argument_list|)
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_ULCORNER
argument_list|)
expr_stmt|;
name|move
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
name|addstr
argument_list|(
literal|"Use arrows to move cursor, anything else to mark corner 2"
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|tmp
operator|=
name|selectcell
argument_list|(
name|ul
operator|.
name|y
argument_list|,
name|ul
operator|.
name|x
argument_list|,
name|LINES
operator|-
literal|1
argument_list|,
name|COLS
operator|-
literal|1
argument_list|)
operator|)
operator|==
operator|(
name|pair
operator|*
operator|)
name|NULL
condition|)
return|return
operator|(
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
operator|)
return|;
name|memcpy
argument_list|(
operator|&
name|lr
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
argument_list|(
name|pair
argument_list|)
argument_list|)
expr_stmt|;
name|rwindow
operator|=
name|newwin
argument_list|(
name|lr
operator|.
name|y
operator|-
name|ul
operator|.
name|y
operator|+
literal|1
argument_list|,
name|lr
operator|.
name|x
operator|-
name|ul
operator|.
name|x
operator|+
literal|1
argument_list|,
name|ul
operator|.
name|y
argument_list|,
name|ul
operator|.
name|x
argument_list|)
expr_stmt|;
name|bwindow
operator|=
name|newwin
argument_list|(
name|lr
operator|.
name|y
operator|-
name|ul
operator|.
name|y
operator|+
literal|3
argument_list|,
name|lr
operator|.
name|x
operator|-
name|ul
operator|.
name|x
operator|+
literal|3
argument_list|,
name|ul
operator|.
name|y
operator|-
literal|1
argument_list|,
name|ul
operator|.
name|x
operator|-
literal|1
argument_list|)
expr_stmt|;
name|wborder
argument_list|(
name|bwindow
argument_list|,
name|ACS_VLINE
argument_list|,
name|ACS_VLINE
argument_list|,
name|ACS_HLINE
argument_list|,
name|ACS_HLINE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|bwindow
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|bwindow
argument_list|)
expr_stmt|;
name|scrollok
argument_list|(
name|rwindow
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/*    immedok(rwindow);	*/
name|wrefresh
argument_list|(
name|rwindow
argument_list|)
expr_stmt|;
return|return
operator|(
name|rwindow
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|acs_and_scroll
parameter_list|()
comment|/* Demonstrate windows */
block|{
name|int
name|c
decl_stmt|;
struct|struct
name|frame
block|{
name|struct
name|frame
modifier|*
name|next
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|WINDOW
modifier|*
name|wind
decl_stmt|;
block|}
modifier|*
name|oldw
init|=
operator|(
expr|struct
name|frame
operator|*
operator|)
name|NULL
struct|,
modifier|*
name|current
init|=
operator|(
expr|struct
name|frame
operator|*
operator|)
name|NULL
struct|,
modifier|*
name|neww
struct|;
name|refresh
argument_list|()
expr_stmt|;
name|mvaddstr
argument_list|(
name|LINES
operator|-
literal|2
argument_list|,
literal|0
argument_list|,
literal|"F1 = make new window, F2 = next window, F3 = previous window, Ctrl-D = exit"
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|"All other characters are echoed, windows should scroll."
argument_list|)
expr_stmt|;
name|c
operator|=
name|KEY_F
argument_list|(
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
name|report
argument_list|()
expr_stmt|;
if|if
condition|(
name|current
condition|)
name|wrefresh
argument_list|(
name|current
operator|->
name|wind
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|KEY_F
argument_list|(
literal|1
argument_list|)
case|:
name|neww
operator|=
operator|(
expr|struct
name|frame
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|frame
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|neww
operator|->
name|wind
operator|=
name|getwindow
argument_list|()
operator|)
operator|==
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
condition|)
goto|goto
name|breakout
goto|;
if|if
condition|(
name|oldw
operator|==
name|NULL
condition|)
comment|/* First element,  */
block|{
name|neww
operator|->
name|next
operator|=
name|neww
expr_stmt|;
comment|/*   so point it at itself */
name|neww
operator|->
name|last
operator|=
name|neww
expr_stmt|;
name|current
operator|=
name|neww
expr_stmt|;
block|}
else|else
block|{
name|neww
operator|->
name|last
operator|=
name|oldw
expr_stmt|;
name|oldw
operator|->
name|next
operator|=
name|neww
expr_stmt|;
name|neww
operator|->
name|next
operator|=
name|current
expr_stmt|;
name|current
operator|->
name|last
operator|=
name|neww
expr_stmt|;
block|}
name|oldw
operator|=
name|neww
expr_stmt|;
name|keypad
argument_list|(
name|neww
operator|->
name|wind
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_F
argument_list|(
literal|2
argument_list|)
case|:
name|current
operator|=
name|current
operator|->
name|next
expr_stmt|;
break|break;
case|case
name|KEY_F
argument_list|(
literal|3
argument_list|)
case|:
name|current
operator|=
name|current
operator|->
name|last
expr_stmt|;
break|break;
case|case
name|KEY_F
argument_list|(
literal|4
argument_list|)
case|:
comment|/* undocumented --- use this to test area clears */
name|selectcell
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|LINES
operator|-
literal|1
argument_list|,
name|COLS
operator|-
literal|1
argument_list|)
expr_stmt|;
name|clrtobot
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|c
operator|=
literal|'\n'
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
name|waddch
argument_list|(
name|current
operator|->
name|wind
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
name|report
argument_list|()
expr_stmt|;
name|wrefresh
argument_list|(
name|current
operator|->
name|wind
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|c
operator|=
name|wgetch
argument_list|(
name|current
operator|->
name|wind
argument_list|)
operator|)
operator|!=
literal|'\004'
condition|)
do|;
name|breakout
label|:
name|erase
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|GRIDSIZE
value|5
end_define

begin_function
specifier|static
name|void
name|panner
parameter_list|(
name|WINDOW
modifier|*
name|pad
parameter_list|,
name|int
name|iy
parameter_list|,
name|int
name|ix
parameter_list|,
name|int
function_decl|(
modifier|*
name|pgetc
function_decl|)
parameter_list|(
name|void
parameter_list|)
parameter_list|)
block|{
specifier|static
name|int
name|porty
decl_stmt|,
name|portx
decl_stmt|,
name|basex
init|=
literal|0
decl_stmt|,
name|basey
init|=
literal|0
decl_stmt|;
name|int
name|pxmax
decl_stmt|,
name|pymax
decl_stmt|,
name|c
decl_stmt|;
name|WINDOW
modifier|*
name|vscroll
init|=
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
decl_stmt|,
modifier|*
name|hscroll
init|=
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
decl_stmt|;
name|porty
operator|=
name|iy
expr_stmt|;
name|portx
operator|=
name|ix
expr_stmt|;
name|getmaxyx
argument_list|(
name|pad
argument_list|,
name|pymax
argument_list|,
name|pxmax
argument_list|)
expr_stmt|;
if|if
condition|(
name|pymax
operator|>
name|porty
condition|)
name|vscroll
operator|=
name|newwin
argument_list|(
name|porty
operator|-
operator|(
name|pxmax
operator|>
name|ix
operator|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|portx
operator|-
operator|(
name|pymax
operator|>
name|iy
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pxmax
operator|>
name|portx
condition|)
name|hscroll
operator|=
name|newwin
argument_list|(
literal|1
argument_list|,
name|portx
operator|-
operator|(
name|pymax
operator|>
name|iy
operator|)
argument_list|,
name|porty
operator|-
operator|(
name|pxmax
operator|>
name|ix
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|c
operator|=
name|KEY_REFRESH
expr_stmt|;
do|do
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|KEY_REFRESH
case|:
comment|/* do nothing */
break|break;
case|case
name|KEY_IC
case|:
if|if
condition|(
name|portx
operator|>=
name|pxmax
operator|||
name|portx
operator|>=
name|ix
condition|)
name|beep
argument_list|()
expr_stmt|;
else|else
block|{
name|mvwin
argument_list|(
name|vscroll
argument_list|,
literal|0
argument_list|,
operator|++
name|portx
operator|-
literal|1
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|hscroll
argument_list|)
expr_stmt|;
name|hscroll
operator|=
name|newwin
argument_list|(
literal|1
argument_list|,
name|portx
operator|-
operator|(
name|pymax
operator|>
name|porty
operator|)
argument_list|,
name|porty
operator|-
operator|(
name|pxmax
operator|>
name|portx
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|KEY_IL
case|:
if|if
condition|(
name|porty
operator|>=
name|pymax
operator|||
name|porty
operator|>=
name|iy
condition|)
name|beep
argument_list|()
expr_stmt|;
else|else
block|{
name|mvwin
argument_list|(
name|hscroll
argument_list|,
operator|++
name|porty
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|vscroll
argument_list|)
expr_stmt|;
name|vscroll
operator|=
name|newwin
argument_list|(
name|porty
operator|-
operator|(
name|pxmax
operator|>
name|portx
operator|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|portx
operator|-
operator|(
name|pymax
operator|>
name|porty
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|KEY_DC
case|:
if|if
condition|(
name|portx
operator|<=
literal|0
condition|)
name|beep
argument_list|()
expr_stmt|;
else|else
block|{
name|mvwin
argument_list|(
name|vscroll
argument_list|,
literal|0
argument_list|,
operator|--
name|portx
operator|-
literal|1
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|hscroll
argument_list|)
expr_stmt|;
name|hscroll
operator|=
name|newwin
argument_list|(
literal|1
argument_list|,
name|portx
operator|-
operator|(
name|pymax
operator|>
name|porty
operator|)
argument_list|,
name|porty
operator|-
operator|(
name|pxmax
operator|>
name|portx
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|KEY_DL
case|:
if|if
condition|(
name|porty
operator|<=
literal|0
condition|)
name|beep
argument_list|()
expr_stmt|;
else|else
block|{
name|mvwin
argument_list|(
name|hscroll
argument_list|,
operator|--
name|porty
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|vscroll
argument_list|)
expr_stmt|;
name|vscroll
operator|=
name|newwin
argument_list|(
name|porty
operator|-
operator|(
name|pxmax
operator|>
name|portx
operator|)
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|portx
operator|-
operator|(
name|pymax
operator|>
name|porty
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|KEY_LEFT
case|:
if|if
condition|(
name|basex
operator|>
literal|0
condition|)
name|basex
operator|--
expr_stmt|;
else|else
name|beep
argument_list|()
expr_stmt|;
break|break;
case|case
name|KEY_RIGHT
case|:
if|if
condition|(
name|basex
operator|+
name|portx
operator|<
name|pxmax
condition|)
name|basex
operator|++
expr_stmt|;
else|else
name|beep
argument_list|()
expr_stmt|;
break|break;
case|case
name|KEY_UP
case|:
if|if
condition|(
name|basey
operator|>
literal|0
condition|)
name|basey
operator|--
expr_stmt|;
else|else
name|beep
argument_list|()
expr_stmt|;
break|break;
case|case
name|KEY_DOWN
case|:
if|if
condition|(
name|basey
operator|+
name|porty
operator|<
name|pymax
condition|)
name|basey
operator|++
expr_stmt|;
else|else
name|beep
argument_list|()
expr_stmt|;
break|break;
block|}
name|prefresh
argument_list|(
name|pad
argument_list|,
name|basey
argument_list|,
name|basex
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|porty
operator|-
operator|(
name|hscroll
operator|!=
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
operator|)
operator|-
literal|1
argument_list|,
name|portx
operator|-
operator|(
name|vscroll
operator|!=
operator|(
name|WINDOW
operator|*
operator|)
name|NULL
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|vscroll
condition|)
block|{
name|int
name|lowend
decl_stmt|,
name|i
decl_stmt|,
name|highend
decl_stmt|;
name|lowend
operator|=
name|basey
operator|*
operator|(
operator|(
name|float
operator|)
name|porty
operator|/
operator|(
name|float
operator|)
name|pymax
operator|)
expr_stmt|;
name|highend
operator|=
operator|(
name|basey
operator|+
name|porty
operator|)
operator|*
operator|(
operator|(
name|float
operator|)
name|porty
operator|/
operator|(
name|float
operator|)
name|pymax
operator|)
expr_stmt|;
name|touchwin
argument_list|(
name|vscroll
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lowend
condition|;
name|i
operator|++
control|)
name|mvwaddch
argument_list|(
name|vscroll
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
name|ACS_VLINE
argument_list|)
expr_stmt|;
name|wattron
argument_list|(
name|vscroll
argument_list|,
name|A_REVERSE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|lowend
init|;
name|i
operator|<=
name|highend
condition|;
name|i
operator|++
control|)
name|mvwaddch
argument_list|(
name|vscroll
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|wattroff
argument_list|(
name|vscroll
argument_list|,
name|A_REVERSE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|highend
operator|+
literal|1
init|;
name|i
operator|<
name|porty
condition|;
name|i
operator|++
control|)
name|mvwaddch
argument_list|(
name|vscroll
argument_list|,
name|i
argument_list|,
literal|0
argument_list|,
name|ACS_VLINE
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|vscroll
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hscroll
condition|)
block|{
name|int
name|lowend
decl_stmt|,
name|j
decl_stmt|,
name|highend
decl_stmt|;
name|lowend
operator|=
name|basex
operator|*
operator|(
operator|(
name|float
operator|)
name|portx
operator|/
operator|(
name|float
operator|)
name|pxmax
operator|)
expr_stmt|;
name|highend
operator|=
operator|(
name|basex
operator|+
name|portx
operator|)
operator|*
operator|(
operator|(
name|float
operator|)
name|portx
operator|/
operator|(
name|float
operator|)
name|pxmax
operator|)
expr_stmt|;
name|touchwin
argument_list|(
name|hscroll
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|lowend
condition|;
name|j
operator|++
control|)
name|mvwaddch
argument_list|(
name|hscroll
argument_list|,
literal|0
argument_list|,
name|j
argument_list|,
name|ACS_HLINE
argument_list|)
expr_stmt|;
name|wattron
argument_list|(
name|hscroll
argument_list|,
name|A_REVERSE
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|lowend
init|;
name|j
operator|<=
name|highend
condition|;
name|j
operator|++
control|)
name|mvwaddch
argument_list|(
name|hscroll
argument_list|,
literal|0
argument_list|,
name|j
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
name|wattroff
argument_list|(
name|hscroll
argument_list|,
name|A_REVERSE
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
name|highend
operator|+
literal|1
init|;
name|j
operator|<
name|portx
condition|;
name|j
operator|++
control|)
name|mvwaddch
argument_list|(
name|hscroll
argument_list|,
literal|0
argument_list|,
name|j
argument_list|,
name|ACS_HLINE
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|hscroll
argument_list|)
expr_stmt|;
block|}
name|mvaddch
argument_list|(
name|porty
operator|-
literal|1
argument_list|,
name|portx
operator|-
literal|1
argument_list|,
name|ACS_LRCORNER
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|c
operator|=
name|pgetc
argument_list|()
operator|)
operator|!=
name|KEY_EXIT
condition|)
do|;
block|}
end_function

begin_function
name|int
name|padgetch
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
switch|switch
condition|(
name|c
operator|=
name|getch
argument_list|()
condition|)
block|{
case|case
literal|'u'
case|:
return|return
operator|(
name|KEY_UP
operator|)
return|;
case|case
literal|'d'
case|:
return|return
operator|(
name|KEY_DOWN
operator|)
return|;
case|case
literal|'r'
case|:
return|return
operator|(
name|KEY_RIGHT
operator|)
return|;
case|case
literal|'l'
case|:
return|return
operator|(
name|KEY_LEFT
operator|)
return|;
case|case
literal|'+'
case|:
return|return
operator|(
name|KEY_IL
operator|)
return|;
case|case
literal|'-'
case|:
return|return
operator|(
name|KEY_DL
operator|)
return|;
case|case
literal|'>'
case|:
return|return
operator|(
name|KEY_IC
operator|)
return|;
case|case
literal|'<'
case|:
return|return
operator|(
name|KEY_DC
operator|)
return|;
default|default:
return|return
operator|(
name|c
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|demo_pad
parameter_list|(
name|void
parameter_list|)
comment|/* Demonstrate pads. */
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|gridcount
init|=
literal|0
decl_stmt|;
name|WINDOW
modifier|*
name|panpad
init|=
name|newpad
argument_list|(
literal|200
argument_list|,
literal|200
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|200
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|200
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|i
operator|%
name|GRIDSIZE
operator|==
literal|0
operator|&&
name|j
operator|%
name|GRIDSIZE
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
operator|||
name|j
operator|==
literal|0
condition|)
name|waddch
argument_list|(
name|panpad
argument_list|,
literal|'+'
argument_list|)
expr_stmt|;
else|else
name|waddch
argument_list|(
name|panpad
argument_list|,
literal|'A'
operator|+
operator|(
name|gridcount
operator|++
operator|%
literal|26
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|%
name|GRIDSIZE
operator|==
literal|0
condition|)
name|waddch
argument_list|(
name|panpad
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|j
operator|%
name|GRIDSIZE
operator|==
literal|0
condition|)
name|waddch
argument_list|(
name|panpad
argument_list|,
literal|'|'
argument_list|)
expr_stmt|;
else|else
name|waddch
argument_list|(
name|panpad
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
block|}
name|mvprintw
argument_list|(
name|LINES
operator|-
literal|3
argument_list|,
literal|0
argument_list|,
literal|"Use arrow keys to pan over the test pattern"
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
name|LINES
operator|-
literal|2
argument_list|,
literal|0
argument_list|,
literal|"Use +,- to grow/shrink the panner vertically."
argument_list|)
expr_stmt|;
name|mvprintw
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|"Use<,> to grow/shrink the panner horizontally."
argument_list|)
expr_stmt|;
name|panner
argument_list|(
name|panpad
argument_list|,
name|LINES
operator|-
literal|4
argument_list|,
name|COLS
argument_list|,
name|padgetch
argument_list|)
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * Tests from John Burnell's PDCurses tester  *  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|Continue
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|wmove
argument_list|(
name|win
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|,
literal|" Press any key to continue"
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wgetch
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|input_test
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
comment|/* Input test, adapted from John Burnell's PDCurses tester */
block|{
name|int
name|w
decl_stmt|,
name|h
decl_stmt|,
name|bx
decl_stmt|,
name|by
decl_stmt|,
name|sw
decl_stmt|,
name|sh
decl_stmt|,
name|i
decl_stmt|;
name|WINDOW
modifier|*
name|subWin
decl_stmt|;
name|wclear
argument_list|(
name|win
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FOO
name|char
name|buffer
index|[
literal|80
index|]
decl_stmt|;
name|int
name|num
decl_stmt|;
endif|#
directive|endif
comment|/* FOO */
name|w
operator|=
name|win
operator|->
name|_maxx
expr_stmt|;
name|h
operator|=
name|win
operator|->
name|_maxy
expr_stmt|;
name|bx
operator|=
name|win
operator|->
name|_begx
expr_stmt|;
name|by
operator|=
name|win
operator|->
name|_begy
expr_stmt|;
name|sw
operator|=
name|w
operator|/
literal|3
expr_stmt|;
name|sh
operator|=
name|h
operator|/
literal|3
expr_stmt|;
if|if
condition|(
operator|(
name|subWin
operator|=
name|subwin
argument_list|(
name|win
argument_list|,
name|sh
argument_list|,
name|sw
argument_list|,
name|by
operator|+
name|h
operator|-
name|sh
operator|-
literal|2
argument_list|,
name|bx
operator|+
name|w
operator|-
name|sw
operator|-
literal|2
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
ifdef|#
directive|ifdef
name|A_COLOR
if|if
condition|(
name|has_colors
argument_list|()
condition|)
block|{
name|init_pair
argument_list|(
literal|2
argument_list|,
name|COLOR_CYAN
argument_list|,
name|COLOR_BLUE
argument_list|)
expr_stmt|;
name|wattrset
argument_list|(
name|subWin
argument_list|,
name|COLOR_PAIR
argument_list|(
literal|2
argument_list|)
operator||
name|A_BOLD
argument_list|)
expr_stmt|;
block|}
else|else
name|wattrset
argument_list|(
name|subWin
argument_list|,
name|A_BOLD
argument_list|)
expr_stmt|;
else|#
directive|else
name|wattrset
argument_list|(
name|subWin
argument_list|,
name|A_BOLD
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|box
argument_list|(
name|subWin
argument_list|,
name|ACS_VLINE
argument_list|,
name|ACS_HLINE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FOO
name|mvwaddstr
argument_list|(
name|subWin
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|"This is a subwindow"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FOO */
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|nocbreak
argument_list|()
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"Type random keys for 5 seconds."
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|"These should be discarded (not echoed) after the subwindow goes away."
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|mvwprintw
argument_list|(
name|subWin
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"Time = %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|subWin
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|flushinp
argument_list|()
expr_stmt|;
block|}
name|delwin
argument_list|(
name|subWin
argument_list|)
expr_stmt|;
name|werase
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|flash
argument_list|()
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|"Press a key"
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|9
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|echo
argument_list|()
expr_stmt|;
name|wgetch
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|flushinp
argument_list|()
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|12
argument_list|,
literal|0
argument_list|,
literal|"If you see any key other than what you typed, flushinp() is broken."
argument_list|)
expr_stmt|;
name|Continue
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|9
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|wdelch
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|12
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
name|waddstr
argument_list|(
name|win
argument_list|,
literal|"What you typed should now have been deleted; if not, wdelch() failed."
argument_list|)
expr_stmt|;
name|Continue
argument_list|(
name|win
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FOO
comment|/*      * This test won't be portable until vsscanf() is      */
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|6
argument_list|,
literal|2
argument_list|,
literal|"Enter a number then a string separated by space"
argument_list|)
expr_stmt|;
name|echo
argument_list|()
expr_stmt|;
name|mvwscanw
argument_list|(
name|win
argument_list|,
literal|7
argument_list|,
literal|6
argument_list|,
literal|"%d %s"
argument_list|,
operator|&
name|num
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|mvwprintw
argument_list|(
name|win
argument_list|,
literal|8
argument_list|,
literal|6
argument_list|,
literal|"String: %s Number: %d"
argument_list|,
name|buffer
argument_list|,
name|num
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FOO */
name|Continue
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * Main sequence  *  ****************************************************************************/
end_comment

begin_function
name|bool
name|do_single_test
parameter_list|(
specifier|const
name|char
name|c
parameter_list|)
comment|/* perform a single specified test */
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|getch_test
argument_list|()
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
case|case
literal|'b'
case|:
name|attr_test
argument_list|()
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
case|case
literal|'c'
case|:
if|if
condition|(
operator|!
name|has_colors
argument_list|()
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"This %s terminal does not support color.\n"
argument_list|,
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|color_test
argument_list|()
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
case|case
literal|'d'
case|:
if|if
condition|(
operator|!
name|has_colors
argument_list|()
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"This %s terminal does not support color.\n"
argument_list|,
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|can_change_color
argument_list|()
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"This %s terminal has hardwired color values.\n"
argument_list|,
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|color_edit
argument_list|()
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
case|case
literal|'e'
case|:
name|slk_test
argument_list|()
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
case|case
literal|'f'
case|:
name|acs_display
argument_list|()
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
case|case
literal|'g'
case|:
name|acs_and_scroll
argument_list|()
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
case|case
literal|'p'
case|:
name|demo_pad
argument_list|()
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
case|case
literal|'i'
case|:
name|input_test
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"This is the ncurses capability tester."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"You may select a test from the main menu by typing the"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"key letter of the choice (the letter to left of the =)"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"at the> prompt.  The commands `x' or `q' will exit."
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
specifier|const
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/* enable debugging */
name|trace
argument_list|(
name|TRACE_ORDINARY
argument_list|)
expr_stmt|;
comment|/* tell it we're going to play with soft keys */
name|slk_init
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* we must initialize the curses data structure only once */
name|initscr
argument_list|()
expr_stmt|;
comment|/* tests, in general, will want these modes */
name|start_color
argument_list|()
expr_stmt|;
name|cbreak
argument_list|()
expr_stmt|;
name|noecho
argument_list|()
expr_stmt|;
name|scrollok
argument_list|(
name|stdscr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|keypad
argument_list|(
name|stdscr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/*      * Return to terminal mode, so we're guaranteed of being able to      * select terminal commands even if the capabilities are wrong.      */
name|endwin
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"Welcome to ncurses.  Press ? for help."
argument_list|)
expr_stmt|;
do|do
block|{
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"This is the ncurses main menu"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"a = character input test"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"b = character attribute test"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"c = color test pattern"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"d = edit RGB color values"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"e = exercise soft keys"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"f = display ACS characters"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"g = display windows and scrolling"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"p = exercise pad features"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"i = subwindow input test"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"? = get help"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"> "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* necessary under SVr4 curses */
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|buf
argument_list|,
name|BUFSIZ
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_single_test
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|clear
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
do|while
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'q'
operator|&&
name|buf
index|[
literal|0
index|]
operator|!=
literal|'x'
condition|)
do|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ncurses.c ends here */
end_comment

end_unit

