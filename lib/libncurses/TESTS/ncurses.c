begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/****************************************************************************  NAME    ncurses.c --- ncurses library exerciser  SYNOPSIS    ncurses  DESCRIPTION    An interactive test module for the ncurses library.  AUTHOR    This software is Copyright (C) 1993 by Eric S. Raymond, all rights reserved. It is issued with ncurses under the same terms and conditions as the ncurses library source.  ***************************************************************************/
end_comment

begin_comment
comment|/*LINTLIBRARY */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ncurses.h>
end_include

begin_define
define|#
directive|define
name|P
parameter_list|(
name|s
parameter_list|)
value|printw("%s\n", s)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|CTRL
end_ifndef

begin_define
define|#
directive|define
name|CTRL
parameter_list|(
name|x
parameter_list|)
value|((x)& 0x1f)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/****************************************************************************  *  * Character input test  *  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|getch_test
parameter_list|(
name|void
parameter_list|)
comment|/* test the keypad feature */
block|{
name|unsigned
name|int
name|c
decl_stmt|;
name|int
name|firsttime
init|=
literal|0
decl_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|c
operator|=
literal|'?'
expr_stmt|;
do|do
block|{
if|if
condition|(
name|firsttime
operator|++
condition|)
block|{
name|printw
argument_list|(
literal|"Key pressed: %04o "
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
name|KEY_MIN
condition|)
block|{
operator|(
name|void
operator|)
name|addstr
argument_list|(
name|keyname
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>
literal|0x80
condition|)
block|{
if|if
condition|(
name|isprint
argument_list|(
name|c
operator|&
operator|~
literal|0x80
argument_list|)
condition|)
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"M-%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"M-%s"
argument_list|,
name|unctrl
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|" (high-half character)\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"%c (ASCII printable character)\n"
argument_list|,
name|c
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"%s (ASCII control character)\n"
argument_list|,
name|unctrl
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|c
operator|==
literal|'x'
operator|||
name|c
operator|==
literal|'q'
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'?'
condition|)
name|addstr
argument_list|(
literal|"Type any key to see its keypad value, `q' to quit, `?' for help.\n"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|!=
name|EOF
condition|)
do|;
name|erase
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|attr_test
parameter_list|(
name|void
parameter_list|)
comment|/* test text attrivutes */
block|{
name|refresh
argument_list|()
expr_stmt|;
name|mvaddstr
argument_list|(
literal|0
argument_list|,
literal|20
argument_list|,
literal|"Character attribute test display"
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|2
argument_list|,
literal|8
argument_list|,
literal|"This is STANDOUT mode: "
argument_list|)
expr_stmt|;
name|attron
argument_list|(
name|A_STANDOUT
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"abcde fghij klmno pqrst uvwxy x"
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_STANDOUT
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|4
argument_list|,
literal|8
argument_list|,
literal|"This is REVERSE mode: "
argument_list|)
expr_stmt|;
name|attron
argument_list|(
name|A_REVERSE
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"abcde fghij klmno pqrst uvwxy x"
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_REVERSE
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|6
argument_list|,
literal|8
argument_list|,
literal|"This is BOLD mode: "
argument_list|)
expr_stmt|;
name|attron
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"abcde fghij klmno pqrst uvwxy x"
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|8
argument_list|,
literal|8
argument_list|,
literal|"This is UNDERLINE mode: "
argument_list|)
expr_stmt|;
name|attron
argument_list|(
name|A_UNDERLINE
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"abcde fghij klmno pqrst uvwxy x"
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_UNDERLINE
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|10
argument_list|,
literal|8
argument_list|,
literal|"This is DIM mode: "
argument_list|)
expr_stmt|;
name|attron
argument_list|(
name|A_DIM
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"abcde fghij klmno pqrst uvwxy x"
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_DIM
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|12
argument_list|,
literal|8
argument_list|,
literal|"This is BLINK mode: "
argument_list|)
expr_stmt|;
name|attron
argument_list|(
name|A_BLINK
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"abcde fghij klmno pqrst uvwxy x"
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_BLINK
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|14
argument_list|,
literal|8
argument_list|,
literal|"This is BOLD UNDERLINE BLINK mode: "
argument_list|)
expr_stmt|;
name|attron
argument_list|(
name|A_BOLD
operator||
name|A_BLINK
operator||
name|A_UNDERLINE
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"abcde fghij klmno pqrst uvwxy x"
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_BOLD
operator||
name|A_BLINK
operator||
name|A_UNDERLINE
argument_list|)
expr_stmt|;
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|16
argument_list|,
literal|8
argument_list|,
literal|"This is NORMAL mode: "
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"abcde fghij klmno pqrst uvwxy x"
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"Press any key to continue... "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getch
argument_list|()
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * Color support tests  *  ****************************************************************************/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|colors
index|[]
init|=
block|{
literal|"black"
block|,
literal|"red"
block|,
literal|"green"
block|,
literal|"yellow"
block|,
literal|"blue"
block|,
literal|"magenta"
block|,
literal|"cyan"
block|,
literal|"white"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|color_test
parameter_list|(
name|void
parameter_list|)
comment|/* generate a color test pattern */
block|{
name|int
name|i
decl_stmt|;
name|refresh
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|printw
argument_list|(
literal|"There are %d color pairs\n"
argument_list|,
name|COLOR_PAIRS
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|mvprintw
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"%dx%d matrix of foreground/background colors, bright *off*\n"
argument_list|,
name|COLORS
argument_list|,
name|COLORS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COLORS
condition|;
name|i
operator|++
control|)
name|mvaddstr
argument_list|(
literal|2
argument_list|,
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
literal|8
argument_list|,
name|colors
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COLORS
condition|;
name|i
operator|++
control|)
name|mvaddstr
argument_list|(
literal|3
operator|+
name|i
argument_list|,
literal|0
argument_list|,
name|colors
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|COLOR_PAIRS
condition|;
name|i
operator|++
control|)
block|{
name|init_pair
argument_list|(
name|i
argument_list|,
name|i
operator|%
name|COLORS
argument_list|,
name|i
operator|/
name|COLORS
argument_list|)
expr_stmt|;
name|attron
argument_list|(
name|COLOR_PAIR
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|3
operator|+
operator|(
name|i
operator|/
name|COLORS
operator|)
argument_list|,
operator|(
name|i
operator|%
name|COLORS
operator|+
literal|1
operator|)
operator|*
literal|8
argument_list|,
literal|"Hello"
argument_list|)
expr_stmt|;
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|mvprintw
argument_list|(
name|COLORS
operator|+
literal|4
argument_list|,
literal|0
argument_list|,
literal|"%dx%d matrix of foreground/background colors, bright *on*\n"
argument_list|,
name|COLORS
argument_list|,
name|COLORS
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COLORS
condition|;
name|i
operator|++
control|)
name|mvaddstr
argument_list|(
literal|5
operator|+
name|COLORS
argument_list|,
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
literal|8
argument_list|,
name|colors
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COLORS
condition|;
name|i
operator|++
control|)
name|mvaddstr
argument_list|(
literal|6
operator|+
name|COLORS
operator|+
name|i
argument_list|,
literal|0
argument_list|,
name|colors
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|COLOR_PAIRS
condition|;
name|i
operator|++
control|)
block|{
name|init_pair
argument_list|(
name|i
argument_list|,
name|i
operator|%
name|COLORS
argument_list|,
name|i
operator|/
name|COLORS
argument_list|)
expr_stmt|;
name|attron
argument_list|(
name|COLOR_PAIR
argument_list|(
name|i
argument_list|)
operator||
name|A_BOLD
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|6
operator|+
name|COLORS
operator|+
operator|(
name|i
operator|/
name|COLORS
operator|)
argument_list|,
operator|(
name|i
operator|%
name|COLORS
operator|+
literal|1
operator|)
operator|*
literal|8
argument_list|,
literal|"Hello"
argument_list|)
expr_stmt|;
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
block|}
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"Press any key to continue... "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getch
argument_list|()
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|color_edit
parameter_list|(
name|void
parameter_list|)
comment|/* display the color test pattern, without trying to edit colors */
block|{
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|value
init|=
literal|0
decl_stmt|,
name|current
init|=
literal|0
decl_stmt|,
name|field
init|=
literal|0
decl_stmt|,
name|usebase
init|=
literal|0
decl_stmt|;
name|refresh
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COLORS
condition|;
name|i
operator|++
control|)
name|init_pair
argument_list|(
name|i
argument_list|,
name|COLOR_WHITE
argument_list|,
name|i
argument_list|)
expr_stmt|;
do|do
block|{
name|short
name|red
decl_stmt|,
name|green
decl_stmt|,
name|blue
decl_stmt|;
name|attron
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|0
argument_list|,
literal|20
argument_list|,
literal|"Color RGB Value Editing"
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|COLORS
condition|;
name|i
operator|++
control|)
block|{
name|mvprintw
argument_list|(
literal|2
operator|+
name|i
argument_list|,
literal|0
argument_list|,
literal|"%c %-8s:"
argument_list|,
operator|(
name|i
operator|==
name|current
condition|?
literal|'>'
else|:
literal|' '
operator|)
argument_list|,
operator|(
name|i
operator|<
sizeof|sizeof
argument_list|(
name|colors
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|colors
index|[
literal|0
index|]
argument_list|)
condition|?
name|colors
index|[
name|i
index|]
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|attrset
argument_list|(
name|COLOR_PAIR
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"        "
argument_list|)
expr_stmt|;
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
comment|/* 	     * Note: this refresh should *not* be necessary!  It works around 	     * a bug in attribute handling that apparently causes the A_NORMAL 	     * attribute sets to interfere with the actual emission of the 	     * color setting somehow.  This needs to be fixed. 	     */
name|refresh
argument_list|()
expr_stmt|;
name|color_content
argument_list|(
name|i
argument_list|,
operator|&
name|red
argument_list|,
operator|&
name|green
argument_list|,
operator|&
name|blue
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"   R = "
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|==
name|i
operator|&&
name|field
operator|==
literal|0
condition|)
name|attron
argument_list|(
name|A_STANDOUT
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"%04d"
argument_list|,
name|red
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|==
name|i
operator|&&
name|field
operator|==
literal|0
condition|)
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|", G = "
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|==
name|i
operator|&&
name|field
operator|==
literal|1
condition|)
name|attron
argument_list|(
name|A_STANDOUT
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"%04d"
argument_list|,
name|green
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|==
name|i
operator|&&
name|field
operator|==
literal|1
condition|)
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|", B = "
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|==
name|i
operator|&&
name|field
operator|==
literal|2
condition|)
name|attron
argument_list|(
name|A_STANDOUT
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"%04d"
argument_list|,
name|blue
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|==
name|i
operator|&&
name|field
operator|==
literal|2
condition|)
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
name|mvaddstr
argument_list|(
name|COLORS
operator|+
literal|3
argument_list|,
literal|0
argument_list|,
literal|"Use up/down to select a color, left/right to change fields."
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|COLORS
operator|+
literal|4
argument_list|,
literal|0
argument_list|,
literal|"Modify field by typing nnn=, nnn-, or nnn+.  ? for help."
argument_list|)
expr_stmt|;
name|move
argument_list|(
literal|2
operator|+
name|current
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
operator|=
name|getch
argument_list|()
condition|)
block|{
case|case
name|KEY_UP
case|:
name|current
operator|=
operator|(
name|current
operator|==
literal|0
condition|?
operator|(
name|COLORS
operator|-
literal|1
operator|)
else|:
name|current
operator|-
literal|1
operator|)
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|KEY_DOWN
case|:
name|current
operator|=
operator|(
name|current
operator|==
operator|(
name|COLORS
operator|-
literal|1
operator|)
condition|?
literal|0
else|:
name|current
operator|+
literal|1
operator|)
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|KEY_RIGHT
case|:
name|field
operator|=
operator|(
name|field
operator|==
literal|2
condition|?
literal|0
else|:
name|field
operator|+
literal|1
operator|)
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|KEY_LEFT
case|:
name|field
operator|=
operator|(
name|field
operator|==
literal|0
condition|?
literal|2
else|:
name|field
operator|-
literal|1
operator|)
expr_stmt|;
name|value
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
do|do
block|{
name|value
operator|=
name|value
operator|*
literal|10
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
do|;
if|if
condition|(
name|c
operator|!=
literal|'+'
operator|&&
name|c
operator|!=
literal|'-'
operator|&&
name|c
operator|!=
literal|'='
condition|)
name|beep
argument_list|()
expr_stmt|;
else|else
name|ungetch
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'+'
case|:
name|usebase
operator|=
literal|1
expr_stmt|;
goto|goto
name|changeit
goto|;
case|case
literal|'-'
case|:
name|value
operator|=
operator|-
name|value
expr_stmt|;
name|usebase
operator|=
literal|1
expr_stmt|;
goto|goto
name|changeit
goto|;
case|case
literal|'='
case|:
name|usebase
operator|=
literal|0
expr_stmt|;
name|changeit
label|:
name|color_content
argument_list|(
name|current
argument_list|,
operator|&
name|red
argument_list|,
operator|&
name|green
argument_list|,
operator|&
name|blue
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|==
literal|0
condition|)
name|red
operator|=
name|red
operator|*
name|usebase
operator|+
name|value
expr_stmt|;
elseif|else
if|if
condition|(
name|field
operator|==
literal|1
condition|)
name|green
operator|=
name|green
operator|*
name|usebase
operator|+
name|value
expr_stmt|;
elseif|else
if|if
condition|(
name|field
operator|==
literal|2
condition|)
name|blue
operator|=
name|blue
operator|*
name|usebase
operator|+
name|value
expr_stmt|;
name|init_color
argument_list|(
name|current
argument_list|,
name|red
argument_list|,
name|green
argument_list|,
name|blue
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|erase
argument_list|()
expr_stmt|;
name|P
argument_list|(
literal|"                      RGB Value Editing Help"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"You are in the RGB value editor.  Use the arrow keys to select one of"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"the fields in one of the RGB triples of the current colors; the one"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"currently selected will be reverse-video highlighted."
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"To change a field, enter the digits of the new value; they won't be"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"echoed.  Finish by typing `='; the change will take effect instantly."
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"To increment or decrement a value, use the same procedure, but finish"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"with a `+' or `-'."
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"To quit, do `x' or 'q'"
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"Press any key to continue... "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getch
argument_list|()
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'q'
case|:
break|break;
default|default:
name|beep
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
name|c
operator|!=
literal|'x'
operator|&&
name|c
operator|!=
literal|'q'
condition|)
do|;
name|erase
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * Soft-key label test  *  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|slk_test
parameter_list|(
name|void
parameter_list|)
comment|/* exercise the soft keys */
block|{
name|int
name|c
decl_stmt|,
name|fmt
init|=
literal|1
decl_stmt|;
name|char
name|buf
index|[
literal|9
index|]
decl_stmt|;
name|c
operator|=
name|CTRL
argument_list|(
literal|'l'
argument_list|)
expr_stmt|;
do|do
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|CTRL
argument_list|(
literal|'l'
argument_list|)
case|:
name|erase
argument_list|()
expr_stmt|;
name|attron
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|0
argument_list|,
literal|20
argument_list|,
literal|"Soft Key Exerciser"
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|move
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"Available commands are:"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"^L         -- refresh screen"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"a          -- activate or restore soft keys"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"d          -- disable soft keys"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"c          -- set centered format for labels"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"l          -- set left-justified format for labels"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"r          -- set right-justified format for labels"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"[12345678] -- set label; labels are numbered 1 through 8"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"e          -- erase stdscr (should not erase labels)"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"s          -- test scrolling of shortened screen"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"x, q       -- return to main menu"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"Note: if activating the soft keys causes your terminal to"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"scroll up one line, your terminal auto-scrolls when anything"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"is written to the last screen position.  The ncurses code"
argument_list|)
expr_stmt|;
name|P
argument_list|(
literal|"does not yet handle this gracefully."
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
comment|/* fall through */
case|case
literal|'a'
case|:
name|slk_restore
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|wclear
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|move
argument_list|(
literal|20
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|!=
literal|'Q'
condition|)
name|addch
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|slk_clear
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|fmt
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|fmt
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|fmt
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
operator|(
name|void
operator|)
name|mvaddstr
argument_list|(
literal|20
argument_list|,
literal|0
argument_list|,
literal|"Please enter the label value: "
argument_list|)
expr_stmt|;
name|wgetnstr
argument_list|(
name|stdscr
argument_list|,
name|buf
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|slk_set
argument_list|(
operator|(
name|c
operator|-
literal|'0'
operator|)
argument_list|,
name|buf
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|slk_refresh
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
case|case
literal|'q'
case|:
goto|goto
name|done
goto|;
default|default:
name|beep
argument_list|()
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|(
name|c
operator|=
name|getch
argument_list|()
operator|)
operator|!=
name|EOF
condition|)
do|;
name|done
label|:
name|erase
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * Alternate character-set stuff  *  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|acs_display
parameter_list|()
comment|/* display the ACS character set */
block|{
name|traceon
argument_list|()
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
name|attron
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|0
argument_list|,
literal|20
argument_list|,
literal|"Display of the ACS Character Set"
argument_list|)
expr_stmt|;
name|attroff
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
define|#
directive|define
name|ACSY
value|5
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|0
argument_list|,
literal|0
argument_list|,
literal|"ACS_ULCORNER: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_ULCORNER
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|1
argument_list|,
literal|0
argument_list|,
literal|"ACS_LLCORNER: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_LLCORNER
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|2
argument_list|,
literal|0
argument_list|,
literal|"ACS_URCORNER: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_URCORNER
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|3
argument_list|,
literal|0
argument_list|,
literal|"ACS_LRCORNER: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_LRCORNER
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|4
argument_list|,
literal|0
argument_list|,
literal|"ACS_RTEE: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_RTEE
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|5
argument_list|,
literal|0
argument_list|,
literal|"ACS_LTEE: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_LTEE
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|6
argument_list|,
literal|0
argument_list|,
literal|"ACS_BTEE: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_BTEE
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|7
argument_list|,
literal|0
argument_list|,
literal|"ACS_TTEE: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_TTEE
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|8
argument_list|,
literal|0
argument_list|,
literal|"ACS_HLINE: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_HLINE
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|9
argument_list|,
literal|0
argument_list|,
literal|"ACS_VLINE: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_VLINE
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|10
argument_list|,
literal|0
argument_list|,
literal|"ACS_PLUS: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_PLUS
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|11
argument_list|,
literal|0
argument_list|,
literal|"ACS_S1: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_S1
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|12
argument_list|,
literal|0
argument_list|,
literal|"ACS_S9: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_S9
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|0
argument_list|,
literal|40
argument_list|,
literal|"ACS_DIAMOND: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_DIAMOND
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|1
argument_list|,
literal|40
argument_list|,
literal|"ACS_CKBOARD: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_CKBOARD
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|2
argument_list|,
literal|40
argument_list|,
literal|"ACS_DEGREE: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_DEGREE
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|3
argument_list|,
literal|40
argument_list|,
literal|"ACS_PLMINUS: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_PLMINUS
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|4
argument_list|,
literal|40
argument_list|,
literal|"ACS_BULLET: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_BULLET
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|5
argument_list|,
literal|40
argument_list|,
literal|"ACS_LARROW: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_LARROW
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|6
argument_list|,
literal|40
argument_list|,
literal|"ACS_RARROW: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_RARROW
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|7
argument_list|,
literal|40
argument_list|,
literal|"ACS_DARROW: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_DARROW
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|8
argument_list|,
literal|40
argument_list|,
literal|"ACS_UARROW: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_UARROW
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|9
argument_list|,
literal|40
argument_list|,
literal|"ACS_BOARD: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_BOARD
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|10
argument_list|,
literal|40
argument_list|,
literal|"ACS_LANTERN: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_LANTERN
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|ACSY
operator|+
literal|11
argument_list|,
literal|40
argument_list|,
literal|"ACS_BLOCK: "
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_BLOCK
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"Press any key to continue... "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getch
argument_list|()
expr_stmt|;
name|erase
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * Windows and scrolling tester.  *  ****************************************************************************/
end_comment

begin_typedef
typedef|typedef
struct|struct
block|{
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
block|}
name|pair
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|report
parameter_list|(
name|void
parameter_list|)
comment|/* report on the cursor's current position, then restore it */
block|{
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|getyx
argument_list|(
name|stdscr
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
name|COLS
operator|-
literal|17
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"Y = %2d X = %2d"
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|pair
modifier|*
name|selectcell
parameter_list|(
name|uli
parameter_list|,
name|ulj
parameter_list|,
name|lri
parameter_list|,
name|lrj
parameter_list|)
comment|/* arrows keys move cursor, return location at current on non-arrow key */
name|int
name|uli
decl_stmt|,
name|ulj
decl_stmt|,
name|lri
decl_stmt|,
name|lrj
decl_stmt|;
comment|/* co-ordinates of corners */
block|{
specifier|static
name|pair
name|res
decl_stmt|;
comment|/* result cell */
name|int
name|si
init|=
name|lri
operator|-
name|uli
operator|+
literal|1
decl_stmt|;
comment|/* depth of the select area */
name|int
name|sj
init|=
name|lrj
operator|-
name|ulj
operator|+
literal|1
decl_stmt|;
comment|/* width of the select area */
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
comment|/* offsets into the select area */
for|for
control|(
init|;
condition|;
control|)
block|{
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
name|COLS
operator|-
literal|17
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"Y = %2d X = %2d"
argument_list|,
name|uli
operator|+
name|i
argument_list|,
name|ulj
operator|+
name|j
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|uli
operator|+
name|i
argument_list|,
name|ulj
operator|+
name|j
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|getch
argument_list|()
condition|)
block|{
case|case
name|KEY_UP
case|:
name|i
operator|+=
name|si
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|KEY_DOWN
case|:
name|i
operator|++
expr_stmt|;
break|break;
case|case
name|KEY_LEFT
case|:
name|j
operator|+=
name|sj
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|KEY_RIGHT
case|:
name|j
operator|++
expr_stmt|;
break|break;
default|default:
name|res
operator|.
name|y
operator|=
name|uli
operator|+
name|i
expr_stmt|;
name|res
operator|.
name|x
operator|=
name|ulj
operator|+
name|j
expr_stmt|;
return|return
operator|(
operator|&
name|res
operator|)
return|;
block|}
name|i
operator|%=
name|si
expr_stmt|;
name|j
operator|%=
name|sj
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|WINDOW
modifier|*
name|getwindow
parameter_list|(
name|void
parameter_list|)
comment|/* Ask user for a window definition */
block|{
name|WINDOW
modifier|*
name|rwindow
decl_stmt|,
modifier|*
name|bwindow
decl_stmt|;
name|pair
name|ul
decl_stmt|,
name|lr
decl_stmt|;
name|move
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
name|addstr
argument_list|(
literal|"Use arrows to move cursor, anything else to mark corner 1"
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|ul
argument_list|,
name|selectcell
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
name|LINES
operator|-
literal|1
argument_list|,
name|COLS
operator|-
literal|1
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|pair
argument_list|)
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ACS_ULCORNER
argument_list|)
expr_stmt|;
name|move
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
name|addstr
argument_list|(
literal|"Use arrows to move cursor, anything else to mark corner 2"
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|lr
argument_list|,
name|selectcell
argument_list|(
name|ul
operator|.
name|y
argument_list|,
name|ul
operator|.
name|x
argument_list|,
name|LINES
operator|-
literal|1
argument_list|,
name|COLS
operator|-
literal|1
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|pair
argument_list|)
argument_list|)
expr_stmt|;
name|rwindow
operator|=
name|newwin
argument_list|(
name|lr
operator|.
name|y
operator|-
name|ul
operator|.
name|y
operator|+
literal|1
argument_list|,
name|lr
operator|.
name|x
operator|-
name|ul
operator|.
name|x
operator|+
literal|1
argument_list|,
name|ul
operator|.
name|y
argument_list|,
name|ul
operator|.
name|x
argument_list|)
expr_stmt|;
name|bwindow
operator|=
name|newwin
argument_list|(
name|lr
operator|.
name|y
operator|-
name|ul
operator|.
name|y
operator|+
literal|3
argument_list|,
name|lr
operator|.
name|x
operator|-
name|ul
operator|.
name|x
operator|+
literal|3
argument_list|,
name|ul
operator|.
name|y
operator|-
literal|1
argument_list|,
name|ul
operator|.
name|x
operator|-
literal|1
argument_list|)
expr_stmt|;
name|wborder
argument_list|(
name|bwindow
argument_list|,
name|ACS_VLINE
argument_list|,
name|ACS_VLINE
argument_list|,
name|ACS_HLINE
argument_list|,
name|ACS_HLINE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|bwindow
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|bwindow
argument_list|)
expr_stmt|;
name|scrollok
argument_list|(
name|rwindow
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/*    immedok(rwindow);	*/
name|wrefresh
argument_list|(
name|rwindow
argument_list|)
expr_stmt|;
return|return
operator|(
name|rwindow
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|acs_and_scroll
parameter_list|()
comment|/* Demonstrate windows */
block|{
name|int
name|c
decl_stmt|;
struct|struct
name|frame
block|{
name|struct
name|frame
modifier|*
name|next
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|WINDOW
modifier|*
name|wind
decl_stmt|;
block|}
modifier|*
name|oldw
init|=
operator|(
expr|struct
name|frame
operator|*
operator|)
name|NULL
struct|,
modifier|*
name|current
init|=
operator|(
expr|struct
name|frame
operator|*
operator|)
name|NULL
struct|,
modifier|*
name|neww
struct|;
name|refresh
argument_list|()
expr_stmt|;
name|mvaddstr
argument_list|(
name|LINES
operator|-
literal|2
argument_list|,
literal|0
argument_list|,
literal|"F1 = make new window, F2 = next window, F3 = previous window"
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|,
literal|"All other characters are echoed, windows should scroll."
argument_list|)
expr_stmt|;
name|c
operator|=
name|KEY_F
argument_list|(
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
name|report
argument_list|()
expr_stmt|;
if|if
condition|(
name|current
condition|)
name|wrefresh
argument_list|(
name|current
operator|->
name|wind
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|KEY_F
argument_list|(
literal|1
argument_list|)
case|:
name|neww
operator|=
operator|(
expr|struct
name|frame
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|frame
argument_list|)
argument_list|)
expr_stmt|;
name|neww
operator|->
name|wind
operator|=
name|getwindow
argument_list|()
expr_stmt|;
if|if
condition|(
name|oldw
operator|==
name|NULL
condition|)
comment|/* First element,  */
block|{
name|neww
operator|->
name|next
operator|=
name|neww
expr_stmt|;
comment|/*   so point it at itself */
name|neww
operator|->
name|last
operator|=
name|neww
expr_stmt|;
name|current
operator|=
name|neww
expr_stmt|;
block|}
else|else
block|{
name|neww
operator|->
name|last
operator|=
name|oldw
expr_stmt|;
name|oldw
operator|->
name|next
operator|=
name|neww
expr_stmt|;
name|neww
operator|->
name|next
operator|=
name|current
expr_stmt|;
name|current
operator|->
name|last
operator|=
name|neww
expr_stmt|;
block|}
name|oldw
operator|=
name|neww
expr_stmt|;
name|keypad
argument_list|(
name|neww
operator|->
name|wind
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
break|break;
case|case
name|KEY_F
argument_list|(
literal|2
argument_list|)
case|:
name|current
operator|=
name|current
operator|->
name|next
expr_stmt|;
break|break;
case|case
name|KEY_F
argument_list|(
literal|3
argument_list|)
case|:
name|current
operator|=
name|current
operator|->
name|last
expr_stmt|;
break|break;
case|case
name|KEY_F
argument_list|(
literal|4
argument_list|)
case|:
comment|/* undocumented --- use this to test area clears */
name|selectcell
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|LINES
operator|-
literal|1
argument_list|,
name|COLS
operator|-
literal|1
argument_list|)
expr_stmt|;
name|clrtobot
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'\r'
case|:
name|c
operator|=
literal|'\n'
expr_stmt|;
comment|/* FALLTHROUGH */
default|default:
name|waddch
argument_list|(
name|current
operator|->
name|wind
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
name|report
argument_list|()
expr_stmt|;
name|wrefresh
argument_list|(
name|current
operator|->
name|wind
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|c
operator|=
name|wgetch
argument_list|(
name|current
operator|->
name|wind
argument_list|)
operator|)
operator|!=
literal|'\004'
condition|)
do|;
name|erase
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * Tests from John Burnell's PDCurses tester  *  ****************************************************************************/
end_comment

begin_function
specifier|static
name|void
name|demo_pad
parameter_list|(
name|void
parameter_list|)
comment|/* Demonstrate pads. */
block|{
name|WINDOW
modifier|*
name|pad
decl_stmt|;
name|pad
operator|=
name|newpad
argument_list|(
literal|50
argument_list|,
literal|100
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|pad
argument_list|,
literal|5
argument_list|,
literal|2
argument_list|,
literal|"This is a new pad"
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|pad
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|,
literal|"The end of this line should be truncated here:abcd"
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|pad
argument_list|,
literal|11
argument_list|,
literal|1
argument_list|,
literal|"This line should not appear."
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|pad
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wclrtoeol
argument_list|(
name|pad
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|pad
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|,
literal|" Press any key to continue"
argument_list|)
expr_stmt|;
name|prefresh
argument_list|(
name|pad
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
literal|45
argument_list|)
expr_stmt|;
name|keypad
argument_list|(
name|pad
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|wgetch
argument_list|(
name|pad
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|pad
argument_list|,
literal|35
argument_list|,
literal|2
argument_list|,
literal|"This is displayed at line 35 in the pad"
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|pad
argument_list|,
literal|40
argument_list|,
literal|1
argument_list|,
literal|" Press any key to continue"
argument_list|)
expr_stmt|;
name|prefresh
argument_list|(
name|pad
argument_list|,
literal|30
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
literal|45
argument_list|)
expr_stmt|;
name|keypad
argument_list|(
name|pad
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|wgetch
argument_list|(
name|pad
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|pad
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Continue
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|wmove
argument_list|(
name|win
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|,
literal|" Press any key to continue"
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wgetch
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|input_test
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
comment|/* Input test, adapted from John Burnell's PDCurses tester */
block|{
name|int
name|w
decl_stmt|,
name|h
decl_stmt|,
name|bx
decl_stmt|,
name|by
decl_stmt|,
name|sw
decl_stmt|,
name|sh
decl_stmt|,
name|i
decl_stmt|,
name|c
decl_stmt|,
name|num
decl_stmt|;
name|char
name|buffer
index|[
literal|80
index|]
decl_stmt|;
name|WINDOW
modifier|*
name|subWin
decl_stmt|;
name|wclear
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|w
operator|=
name|win
operator|->
name|_maxx
expr_stmt|;
name|h
operator|=
name|win
operator|->
name|_maxy
expr_stmt|;
name|bx
operator|=
name|win
operator|->
name|_begx
expr_stmt|;
name|by
operator|=
name|win
operator|->
name|_begy
expr_stmt|;
name|sw
operator|=
name|w
operator|/
literal|3
expr_stmt|;
name|sh
operator|=
name|h
operator|/
literal|3
expr_stmt|;
if|if
condition|(
operator|(
name|subWin
operator|=
name|subwin
argument_list|(
name|win
argument_list|,
name|sh
argument_list|,
name|sw
argument_list|,
name|by
operator|+
name|h
operator|-
name|sh
operator|-
literal|2
argument_list|,
name|bx
operator|+
name|w
operator|-
name|sw
operator|-
literal|2
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
ifdef|#
directive|ifdef
name|A_COLOR
if|if
condition|(
name|has_colors
argument_list|()
condition|)
block|{
name|init_pair
argument_list|(
literal|2
argument_list|,
name|COLOR_CYAN
argument_list|,
name|COLOR_BLUE
argument_list|)
expr_stmt|;
name|wattrset
argument_list|(
name|subWin
argument_list|,
name|COLOR_PAIR
argument_list|(
literal|2
argument_list|)
operator||
name|A_BOLD
argument_list|)
expr_stmt|;
block|}
else|else
name|wattrset
argument_list|(
name|subWin
argument_list|,
name|A_BOLD
argument_list|)
expr_stmt|;
else|#
directive|else
name|wattrset
argument_list|(
name|subWin
argument_list|,
name|A_BOLD
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|box
argument_list|(
name|subWin
argument_list|,
name|ACS_VLINE
argument_list|,
name|ACS_HLINE
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|nocbreak
argument_list|()
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|"Press some keys for 5 seconds"
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"Pressing ^C should do nothing"
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|werase
argument_list|(
name|subWin
argument_list|)
expr_stmt|;
name|box
argument_list|(
name|subWin
argument_list|,
name|ACS_VLINE
argument_list|,
name|ACS_HLINE
argument_list|)
expr_stmt|;
name|mvwprintw
argument_list|(
name|subWin
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"Time = %d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|subWin
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|flushinp
argument_list|()
expr_stmt|;
block|}
name|delwin
argument_list|(
name|subWin
argument_list|)
expr_stmt|;
name|werase
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|flash
argument_list|()
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|"Press a key"
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|9
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|echo
argument_list|()
expr_stmt|;
name|wgetch
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|flushinp
argument_list|()
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|9
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|wdelch
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
literal|"The character should now have been deleted"
argument_list|)
expr_stmt|;
name|Continue
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wclear
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|,
literal|"Press a function key or an arrow key"
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|keypad
argument_list|(
name|win
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|c
operator|=
name|wgetch
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|nodelay
argument_list|(
name|win
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|wgetch
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|nodelay
argument_list|(
name|win
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|wclear
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|3
argument_list|,
literal|2
argument_list|,
literal|"The window should have moved"
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|4
argument_list|,
literal|2
argument_list|,
literal|"This text should have appeared without you pressing a key"
argument_list|)
expr_stmt|;
name|mvwprintw
argument_list|(
name|win
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
literal|"Keycode = %d"
argument_list|,
name|c
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FOO
comment|/*      * This test won't be portable until vsscanf() is      */
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|6
argument_list|,
literal|2
argument_list|,
literal|"Enter a number then a string separated by space"
argument_list|)
expr_stmt|;
name|echo
argument_list|()
expr_stmt|;
name|mvwscanw
argument_list|(
name|win
argument_list|,
literal|7
argument_list|,
literal|6
argument_list|,
literal|"%d %s"
argument_list|,
operator|&
name|num
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
name|mvwprintw
argument_list|(
name|win
argument_list|,
literal|8
argument_list|,
literal|6
argument_list|,
literal|"String: %s Number: %d"
argument_list|,
name|buffer
argument_list|,
name|num
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FOO */
name|Continue
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|output_test
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|WINDOW
modifier|*
name|win1
decl_stmt|;
name|char
name|Buffer
index|[
literal|80
index|]
decl_stmt|;
name|chtype
name|ch
decl_stmt|;
name|wclear
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"You should now have a screen in the upper left corner, and this text should have wrapped"
argument_list|)
expr_stmt|;
name|mvwin
argument_list|(
name|win
argument_list|,
literal|2
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|Continue
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|nl
argument_list|()
expr_stmt|;
name|wclear
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"A new window will appear with this text in it"
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
literal|"Press any key to continue"
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wgetch
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|win1
operator|=
name|newwin
argument_list|(
literal|10
argument_list|,
literal|50
argument_list|,
literal|15
argument_list|,
literal|25
argument_list|)
expr_stmt|;
if|if
condition|(
name|win1
operator|==
name|NULL
condition|)
block|{
name|endwin
argument_list|()
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|A_COLOR
if|if
condition|(
name|has_colors
argument_list|()
condition|)
block|{
name|init_pair
argument_list|(
literal|3
argument_list|,
name|COLOR_BLUE
argument_list|,
name|COLOR_WHITE
argument_list|)
expr_stmt|;
name|wattrset
argument_list|(
name|win1
argument_list|,
name|COLOR_PAIR
argument_list|(
literal|3
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|wattrset
argument_list|(
name|win1
argument_list|,
name|A_NORMAL
argument_list|)
expr_stmt|;
else|#
directive|else
name|wattrset
argument_list|(
name|win1
argument_list|,
name|A_NORMAL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|wclear
argument_list|(
name|win1
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win1
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|,
literal|"This text should appear; using overlay option"
argument_list|)
expr_stmt|;
name|copywin
argument_list|(
name|win
argument_list|,
name|win1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|,
literal|50
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|box
argument_list|(
name|win1
argument_list|,
name|ACS_VLINE
argument_list|,
name|ACS_HLINE
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win1
argument_list|,
literal|8
argument_list|,
literal|26
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win1
argument_list|)
expr_stmt|;
name|wgetch
argument_list|(
name|win1
argument_list|)
expr_stmt|;
name|wclear
argument_list|(
name|win1
argument_list|)
expr_stmt|;
name|wattron
argument_list|(
name|win1
argument_list|,
name|A_BLINK
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win1
argument_list|,
literal|4
argument_list|,
literal|1
argument_list|,
literal|"This blinking text should appear in only the second window"
argument_list|)
expr_stmt|;
name|wattroff
argument_list|(
name|win1
argument_list|,
name|A_BLINK
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win1
argument_list|)
expr_stmt|;
name|wgetch
argument_list|(
name|win1
argument_list|)
expr_stmt|;
name|delwin
argument_list|(
name|win1
argument_list|)
expr_stmt|;
name|wclear
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|6
argument_list|,
literal|2
argument_list|,
literal|"This line shouldn't appear"
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|4
argument_list|,
literal|2
argument_list|,
literal|"Only half of the next line is visible"
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|5
argument_list|,
literal|2
argument_list|,
literal|"Only half of the next line is visible"
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|6
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wclrtobot
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|5
argument_list|,
literal|20
argument_list|)
expr_stmt|;
name|wclrtoeol
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|8
argument_list|,
literal|2
argument_list|,
literal|"This line also shouldn't appear"
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|wdeleteln
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|Continue
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|traceoff
argument_list|()
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|5
argument_list|,
literal|9
argument_list|)
expr_stmt|;
name|ch
operator|=
name|winch
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wclear
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|6
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|waddstr
argument_list|(
name|win
argument_list|,
literal|"The next char should be l:  "
argument_list|)
expr_stmt|;
name|winsch
argument_list|(
name|win
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|Continue
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|5
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|winsertln
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|5
argument_list|,
literal|2
argument_list|,
literal|"The lines below should have moved down"
argument_list|)
expr_stmt|;
name|Continue
argument_list|(
name|win
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FOO
comment|/*      * This test won't be portable until vsscanf() is      */
name|wclear
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wmove
argument_list|(
name|win
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|wprintw
argument_list|(
name|win
argument_list|,
literal|"This is a formatted string in a window: %d %s\n"
argument_list|,
literal|42
argument_list|,
literal|"is it"
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|,
literal|"Enter a string: "
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|echo
argument_list|()
expr_stmt|;
name|wscanw
argument_list|(
name|win
argument_list|,
literal|"%s"
argument_list|,
name|Buffer
argument_list|)
expr_stmt|;
name|wclear
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|10
argument_list|,
literal|1
argument_list|,
literal|"Enter a string"
argument_list|)
expr_stmt|;
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|clear
argument_list|()
expr_stmt|;
name|move
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|printw
argument_list|(
literal|"This is a formatted string in stdscr: %d %s\n"
argument_list|,
literal|42
argument_list|,
literal|"is it"
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|10
argument_list|,
literal|1
argument_list|,
literal|"Enter a string: "
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|echo
argument_list|()
expr_stmt|;
name|scanw
argument_list|(
literal|"%s"
argument_list|,
name|Buffer
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* FOO */
name|wclear
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|curs_set
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"The cursor should appear as a block"
argument_list|)
expr_stmt|;
name|Continue
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wclear
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|curs_set
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"The cursor should have disappeared"
argument_list|)
expr_stmt|;
name|Continue
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|wclear
argument_list|(
name|win
argument_list|)
expr_stmt|;
name|curs_set
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|mvwaddstr
argument_list|(
name|win
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|"The cursor should be an underline"
argument_list|)
expr_stmt|;
name|Continue
argument_list|(
name|win
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/****************************************************************************  *  * Main sequence  *  ****************************************************************************/
end_comment

begin_function
name|bool
name|do_single_test
parameter_list|(
specifier|const
name|char
name|c
parameter_list|)
comment|/* perform a single specified test */
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|getch_test
argument_list|()
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
case|case
literal|'b'
case|:
name|attr_test
argument_list|()
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
case|case
literal|'c'
case|:
if|if
condition|(
operator|!
name|has_colors
argument_list|()
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"This %s terminal does not support color.\n"
argument_list|,
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|color_test
argument_list|()
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
case|case
literal|'d'
case|:
if|if
condition|(
operator|!
name|has_colors
argument_list|()
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"This %s terminal does not support color.\n"
argument_list|,
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|can_change_color
argument_list|()
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"This %s terminal has hardwired color values.\n"
argument_list|,
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|color_edit
argument_list|()
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
case|case
literal|'e'
case|:
name|slk_test
argument_list|()
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
case|case
literal|'f'
case|:
name|acs_display
argument_list|()
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
case|case
literal|'g'
case|:
name|acs_and_scroll
argument_list|()
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
case|case
literal|'p'
case|:
name|demo_pad
argument_list|()
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
case|case
literal|'i'
case|:
name|input_test
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
case|case
literal|'o'
case|:
name|output_test
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
case|case
literal|'?'
case|:
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"This is the ncurses capability tester."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"You may select a test from the main menu by typing the"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"key letter of the choice (the letter to left of the =)"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"at the> prompt.  The commands `x' or `q' will exit."
argument_list|)
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
specifier|const
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/* enable debugging */
name|traceon
argument_list|()
expr_stmt|;
comment|/* tell it we're going to play with soft keys */
name|slk_init
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* we must initialize the curses data structure only once */
name|initscr
argument_list|()
expr_stmt|;
comment|/* tests, in general, will want these modes */
name|start_color
argument_list|()
expr_stmt|;
name|cbreak
argument_list|()
expr_stmt|;
name|noecho
argument_list|()
expr_stmt|;
name|scrollok
argument_list|(
name|stdscr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|keypad
argument_list|(
name|stdscr
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/*      * Return to terminal mode, so we're guaranteed of being able to      * select terminal commands even if the capabilities are wrong.      */
name|endwin
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"Welcome to ncurses.  Press ? for help."
argument_list|)
expr_stmt|;
do|do
block|{
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"This is the ncurses main menu"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"a = character input test"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"b = character attribute test"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"c = color test pattern"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"d = edit RGB color values"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"e = exercise soft keys"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"f = display ACS characters"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"g = display windows and scrolling"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"p = exercise pad features"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"i = subwindow input test"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"o = output test"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|puts
argument_list|(
literal|"? = get help"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"> "
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fgets
argument_list|(
name|buf
argument_list|,
name|BUFSIZ
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_single_test
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|clear
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
continue|continue;
block|}
block|}
do|while
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'q'
operator|&&
name|buf
index|[
literal|0
index|]
operator|!=
literal|'x'
condition|)
do|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ncurses.c ends here */
end_comment

end_unit

