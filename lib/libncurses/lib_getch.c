begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* This work is copyrighted. See COPYRIGHT.OLD& COPYRIGHT.NEW for   * *  details. If they are missing then this copy is in violation of    * *  the copyright conditions.                                        */
end_comment

begin_comment
comment|/* **	lib_getch.c ** **	The routine getch(). ** */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|BRAINDEAD
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"curses.priv.h"
end_include

begin_define
define|#
directive|define
name|head
value|SP->_fifohead
end_define

begin_define
define|#
directive|define
name|tail
value|SP->_fifotail
end_define

begin_define
define|#
directive|define
name|peek
value|SP->_fifopeek
end_define

begin_define
define|#
directive|define
name|h_inc
parameter_list|()
value|{ head == FIFO_SIZE-1 ? head = 0 : head++; if (head == tail) head = -1, tail = 0;}
end_define

begin_define
define|#
directive|define
name|h_dec
parameter_list|()
value|{ head == 0 ?  head = FIFO_SIZE-1 : head--; if (head == tail) tail = -1;}
end_define

begin_define
define|#
directive|define
name|t_inc
parameter_list|()
value|{ tail == FIFO_SIZE-1 ? tail = 0 : tail++; if (tail == head) tail = -1;}
end_define

begin_define
define|#
directive|define
name|p_inc
parameter_list|()
value|{ peek == FIFO_SIZE-1 ? peek = 0 : peek++;}
end_define

begin_function
specifier|static
name|int
name|fifo_peek
parameter_list|()
block|{
name|T
argument_list|(
operator|(
literal|"peeking at %d"
operator|,
name|peek
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
name|SP
operator|->
name|_fifo
index|[
operator|++
name|peek
index|]
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|fifo_dump
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|T
argument_list|(
operator|(
literal|"head = %d, tail = %d, peek = %d"
operator|,
name|head
operator|,
name|tail
operator|,
name|peek
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|10
condition|;
name|i
operator|++
control|)
name|T
argument_list|(
operator|(
literal|"char %d = %d (%c)"
operator|,
name|i
operator|,
name|SP
operator|->
name|_fifo
index|[
name|i
index|]
operator|,
operator|(
name|unsigned
name|char
operator|)
name|SP
operator|->
name|_fifo
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|fifo_pull
parameter_list|()
block|{
name|int
name|ch
decl_stmt|;
name|ch
operator|=
name|SP
operator|->
name|_fifo
index|[
name|head
index|]
expr_stmt|;
name|T
argument_list|(
operator|(
literal|"pulling %d from %d"
operator|,
name|ch
operator|,
name|head
operator|)
argument_list|)
expr_stmt|;
name|h_inc
argument_list|()
expr_stmt|;
name|fifo_dump
argument_list|()
expr_stmt|;
return|return
name|ch
return|;
block|}
end_function

begin_function
name|int
name|ungetch
parameter_list|(
name|int
name|ch
parameter_list|)
block|{
if|if
condition|(
name|tail
operator|==
operator|-
literal|1
condition|)
return|return
name|ERR
return|;
if|if
condition|(
name|head
operator|==
operator|-
literal|1
condition|)
block|{
name|head
operator|=
literal|0
expr_stmt|;
name|t_inc
argument_list|()
block|}
else|else
name|h_dec
argument_list|()
expr_stmt|;
name|SP
operator|->
name|_fifo
index|[
name|head
index|]
operator|=
name|ch
expr_stmt|;
name|T
argument_list|(
operator|(
literal|"ungetch ok"
operator|)
argument_list|)
expr_stmt|;
name|fifo_dump
argument_list|()
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|int
name|fifo_push
parameter_list|()
block|{
name|int
name|n
decl_stmt|;
name|unsigned
name|char
name|ch
decl_stmt|;
if|if
condition|(
name|tail
operator|==
operator|-
literal|1
condition|)
return|return
name|ERR
return|;
name|again
label|:
name|n
operator|=
name|read
argument_list|(
name|fileno
argument_list|(
name|SP
operator|->
name|_ifp
argument_list|)
argument_list|,
operator|&
name|ch
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
condition|)
goto|goto
name|again
goto|;
name|SP
operator|->
name|_fifo
index|[
name|tail
index|]
operator|=
name|ch
expr_stmt|;
if|if
condition|(
name|head
operator|==
operator|-
literal|1
condition|)
name|head
operator|=
name|tail
expr_stmt|;
name|t_inc
argument_list|()
expr_stmt|;
name|T
argument_list|(
operator|(
literal|"pushed %d at %d"
operator|,
name|ch
operator|,
name|tail
operator|)
argument_list|)
expr_stmt|;
name|fifo_dump
argument_list|()
expr_stmt|;
return|return
name|ch
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|fifo_clear
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIFO_SIZE
condition|;
name|i
operator|++
control|)
name|SP
operator|->
name|_fifo
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|head
operator|=
operator|-
literal|1
expr_stmt|;
name|tail
operator|=
name|peek
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function_decl
specifier|static
name|int
name|kgetch
parameter_list|(
name|WINDOW
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|wgetch
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|bool
name|setHere
init|=
name|FALSE
decl_stmt|;
comment|/* cbreak mode was set here */
name|int
name|ch
decl_stmt|;
name|T
argument_list|(
operator|(
literal|"wgetch(%x) called"
operator|,
name|win
operator|)
argument_list|)
expr_stmt|;
comment|/* this should be eliminated */
if|if
condition|(
operator|!
name|win
operator|->
name|_scroll
operator|&&
operator|(
name|SP
operator|->
name|_echo
operator|)
operator|&&
operator|(
name|win
operator|->
name|_flags
operator|&
name|_FULLWIN
operator|)
operator|&&
name|win
operator|->
name|_curx
operator|==
name|win
operator|->
name|_maxx
operator|&&
name|win
operator|->
name|_cury
operator|==
name|win
operator|->
name|_maxy
condition|)
return|return
operator|(
name|ERR
operator|)
return|;
if|if
condition|(
operator|(
name|is_wintouched
argument_list|(
name|win
argument_list|)
operator|||
operator|(
name|win
operator|->
name|_flags
operator|&
name|_HASMOVED
operator|)
operator|)
operator|&&
operator|!
operator|(
name|win
operator|->
name|_flags
operator|&
name|_ISPAD
operator|)
condition|)
name|wrefresh
argument_list|(
name|win
argument_list|)
expr_stmt|;
if|if
condition|(
name|SP
operator|->
name|_echo
operator|&&
operator|!
operator|(
name|SP
operator|->
name|_raw
operator|||
name|SP
operator|->
name|_cbreak
operator|)
condition|)
block|{
name|cbreak
argument_list|()
expr_stmt|;
name|setHere
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|win
operator|->
name|_delay
operator|>=
literal|0
operator|||
name|SP
operator|->
name|_cbreak
operator|>
literal|1
condition|)
block|{
name|int
name|delay
decl_stmt|;
name|T
argument_list|(
operator|(
literal|"timed delay in wgetch()"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SP
operator|->
name|_cbreak
operator|>
literal|1
condition|)
name|delay
operator|=
operator|(
name|SP
operator|->
name|_cbreak
operator|-
literal|1
operator|)
operator|*
literal|100
expr_stmt|;
else|else
name|delay
operator|=
name|win
operator|->
name|_delay
expr_stmt|;
name|T
argument_list|(
operator|(
literal|"delay is %d microseconds"
operator|,
name|delay
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|==
operator|-
literal|1
condition|)
comment|/* fifo is empty */
if|if
condition|(
name|timed_wait
argument_list|(
name|fileno
argument_list|(
name|SP
operator|->
name|_ifp
argument_list|)
argument_list|,
name|delay
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
return|return
name|ERR
return|;
comment|/* else go on to read data available */
block|}
if|if
condition|(
name|win
operator|->
name|_use_keypad
condition|)
name|ch
operator|=
name|kgetch
argument_list|(
name|win
argument_list|)
expr_stmt|;
else|else
block|{
name|fifo_push
argument_list|()
expr_stmt|;
name|ch
operator|=
name|fifo_pull
argument_list|()
expr_stmt|;
block|}
comment|/* This should be eliminated */
comment|/* handle 8-bit input */
if|if
condition|(
name|ch
operator|&
literal|0x80
condition|)
if|if
condition|(
operator|!
name|win
operator|->
name|_use_meta
condition|)
name|ch
operator|&=
literal|0x7f
expr_stmt|;
comment|/* there must be a simpler way of doing this */
if|if
condition|(
operator|!
operator|(
name|win
operator|->
name|_flags
operator|&
name|_ISPAD
operator|)
operator|&&
name|SP
operator|->
name|_echo
operator|&&
name|ch
operator|<
literal|0400
condition|)
block|{
comment|/* ch< 0400 => not a keypad key */
name|mvwaddch
argument_list|(
name|curscr
argument_list|,
name|win
operator|->
name|_begy
operator|+
name|win
operator|->
name|_cury
argument_list|,
name|win
operator|->
name|_begx
operator|+
name|win
operator|->
name|_curx
argument_list|,
name|ch
operator||
name|win
operator|->
name|_attrs
argument_list|)
expr_stmt|;
name|waddch
argument_list|(
name|win
argument_list|,
name|ch
operator||
name|win
operator|->
name|_attrs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|setHere
condition|)
name|nocbreak
argument_list|()
expr_stmt|;
name|T
argument_list|(
operator|(
literal|"wgetch returning : '%c', '0x%x'"
operator|,
name|ch
operator|,
name|ch
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ch
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **      int **      kgetch() ** **      Get an input character, but take care of keypad sequences, returning **      an appropriate code when one matches the input.  After each character **      is received, set a one-second alarm call.  If no more of the sequence **      is received by the time the alarm goes off, pass through the sequence **      gotten so far. ** */
end_comment

begin_function
specifier|static
name|int
name|kgetch
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|)
block|{
name|struct
name|try
modifier|*
name|ptr
decl_stmt|;
name|int
name|ch
init|=
literal|0
decl_stmt|;
name|int
name|timeleft
init|=
literal|2000
decl_stmt|;
name|T
argument_list|(
operator|(
literal|"kgetch(%x) called"
operator|,
name|win
operator|)
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|SP
operator|->
name|_keytry
expr_stmt|;
if|if
condition|(
name|head
operator|==
operator|-
literal|1
condition|)
block|{
name|ch
operator|=
name|fifo_push
argument_list|()
expr_stmt|;
name|peek
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|T
argument_list|(
operator|(
literal|"ch = %d"
operator|,
name|ch
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ptr
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|ptr
operator|->
name|ch
operator|!=
operator|(
name|unsigned
name|char
operator|)
name|ch
operator|)
condition|)
name|ptr
operator|=
name|ptr
operator|->
name|sibling
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
if|if
condition|(
name|ptr
operator|->
name|value
operator|!=
literal|0
condition|)
block|{
comment|/* sequence terminated */
name|T
argument_list|(
operator|(
literal|"end of sequence"
operator|)
argument_list|)
expr_stmt|;
name|fifo_clear
argument_list|()
expr_stmt|;
return|return
operator|(
name|ptr
operator|->
name|value
operator|)
return|;
block|}
else|else
block|{
comment|/* go back for another character */
name|ptr
operator|=
name|ptr
operator|->
name|child
expr_stmt|;
name|T
argument_list|(
operator|(
literal|"going back for more"
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
name|T
argument_list|(
operator|(
literal|"waiting for rest of sequence"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|timed_wait
argument_list|(
name|fileno
argument_list|(
name|SP
operator|->
name|_ifp
argument_list|)
argument_list|,
name|timeleft
argument_list|,
operator|&
name|timeleft
argument_list|)
operator|<
literal|1
condition|)
block|{
name|T
argument_list|(
operator|(
literal|"ran out of time"
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|fifo_pull
argument_list|()
operator|)
return|;
block|}
else|else
block|{
name|T
argument_list|(
operator|(
literal|"got more!"
operator|)
argument_list|)
expr_stmt|;
name|fifo_push
argument_list|()
expr_stmt|;
name|ch
operator|=
name|fifo_peek
argument_list|()
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|fifo_pull
argument_list|()
operator|)
return|;
block|}
end_function

end_unit

