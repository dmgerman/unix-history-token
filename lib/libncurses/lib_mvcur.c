begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*---------------------------------------------------------------------------  *  *	lib_mvcur.c  *  *	The routine mvcur() etc.  *  *	last edit-date: [Wed Jun 16 14:13:22 1993]  *  *	-hm	conversion from termcap -> terminfo  *	-hm	optimization debugging  *	-hm	zeyd's ncurses 0.7 update  *	-hm	eat_newline_glitch bugfix  *	-hm	hpux lint'ing ..  *  *---------------------------------------------------------------------------*/
end_comment

begin_comment
comment|/* This work is copyrighted. See COPYRIGHT.OLD& COPYRIGHT.NEW for   * *  details. If they are missing then this copy is in violation of    * *  the copyright conditions.                                         */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<nterm.h>
end_include

begin_include
include|#
directive|include
file|"curses.priv.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|OPT_MVCUR
end_ifndef

begin_comment
comment|/* ** **	mvcur(oldrow, oldcol, newrow, newcol) **	A hack for terminals that are smart enough **	to know how to move cursor. **	There is still a bug in the alternative long- **	winded code. ** */
end_comment

begin_function
name|int
name|mvcur
parameter_list|(
name|int
name|oldrow
parameter_list|,
name|int
name|oldcol
parameter_list|,
name|int
name|newrow
parameter_list|,
name|int
name|newcol
parameter_list|)
block|{
name|T
argument_list|(
operator|(
literal|"mvcur(%d,%d,%d,%d) called"
operator|,
name|oldrow
operator|,
name|oldcol
operator|,
name|newrow
operator|,
name|newcol
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cursor_address
condition|)
return|return
name|ERR
return|;
name|newrow
operator|%=
name|lines
expr_stmt|;
name|newcol
operator|%=
name|columns
expr_stmt|;
if|if
condition|(
name|cursor_address
condition|)
name|putp
argument_list|(
name|tparm
argument_list|(
name|cursor_address
argument_list|,
name|newrow
argument_list|,
name|newcol
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|BUFSIZE
value|128
end_define

begin_comment
comment|/* size of strategy buffer */
end_comment

begin_struct
struct|struct
name|Sequence
block|{
name|int
name|vec
index|[
name|BUFSIZE
index|]
decl_stmt|;
comment|/* vector of operations */
name|int
modifier|*
name|end
decl_stmt|;
comment|/* end of vector */
name|int
name|cost
decl_stmt|;
comment|/* cost of vector */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|void
name|row
parameter_list|(
name|struct
name|Sequence
modifier|*
name|outseq
parameter_list|,
name|int
name|orow
parameter_list|,
name|int
name|nrow
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|column
parameter_list|(
name|struct
name|Sequence
modifier|*
name|outseq
parameter_list|,
name|int
name|ocol
parameter_list|,
name|int
name|ncol
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|simp_col
parameter_list|(
name|struct
name|Sequence
modifier|*
name|outseq
parameter_list|,
name|int
name|oc
parameter_list|,
name|int
name|nc
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zero_seq
parameter_list|(
name|struct
name|Sequence
modifier|*
name|seq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_seq
parameter_list|(
name|struct
name|Sequence
modifier|*
name|seq1
parameter_list|,
name|struct
name|Sequence
modifier|*
name|seq2
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|out_seq
parameter_list|(
name|struct
name|Sequence
modifier|*
name|seq
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|update_ops
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|init_costs
parameter_list|(
name|int
name|costs
index|[]
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|countc
parameter_list|(
name|char
name|ch
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_op
parameter_list|(
name|struct
name|Sequence
modifier|*
name|seq
parameter_list|,
name|int
name|op
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|sequence
parameter_list|(
name|int
name|op
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|c_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used for counting tputs output */
end_comment

begin_define
define|#
directive|define
name|INFINITY
value|1000
end_define

begin_comment
comment|/* biggest, impossible sequence cost */
end_comment

begin_define
define|#
directive|define
name|NUM_OPS
value|16
end_define

begin_comment
comment|/* num. term. control sequences */
end_comment

begin_define
define|#
directive|define
name|NUM_NPARM
value|9
end_define

begin_comment
comment|/* num. ops wo/ parameters */
end_comment

begin_comment
comment|/* operator indexes into op_info */
end_comment

begin_define
define|#
directive|define
name|CARRIAGE_RETURN
value|0
end_define

begin_comment
comment|/* watch out for nl mapping */
end_comment

begin_define
define|#
directive|define
name|CURS_DOWN
value|1
end_define

begin_define
define|#
directive|define
name|CURS_HOME
value|2
end_define

begin_define
define|#
directive|define
name|CURS_LEFT
value|3
end_define

begin_define
define|#
directive|define
name|CURS_RIGHT
value|4
end_define

begin_define
define|#
directive|define
name|CURS_TO_LL
value|5
end_define

begin_define
define|#
directive|define
name|CURS_UP
value|6
end_define

begin_define
define|#
directive|define
name|TAB
value|7
end_define

begin_define
define|#
directive|define
name|BACK_TAB
value|8
end_define

begin_define
define|#
directive|define
name|ROW_ADDR
value|9
end_define

begin_define
define|#
directive|define
name|COL_ADDR
value|10
end_define

begin_define
define|#
directive|define
name|P_DOWN_CURS
value|11
end_define

begin_define
define|#
directive|define
name|P_LEFT_CURS
value|12
end_define

begin_define
define|#
directive|define
name|P_RIGHT_CURS
value|13
end_define

begin_define
define|#
directive|define
name|P_UP_CURS
value|14
end_define

begin_define
define|#
directive|define
name|CURS_ADDR
value|15
end_define

begin_decl_stmt
specifier|static
name|bool
name|loc_init
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set if op_info is init'ed */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|rel_ok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* set if we really know where we are */
end_comment

begin_comment
comment|/*  *	op_info[NUM_OPS]  *  *	op_info[] contains for operations with no parameters  *	the cost of the operation.  These ops should be first in the array.  *	For operations with parameters, op_info[] contains  *	the negative of the number of parameters.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|op_info
index|[
name|NUM_OPS
index|]
init|=
block|{
literal|0
block|,
comment|/* carriage_return */
literal|0
block|,
comment|/* cursor_down */
literal|0
block|,
comment|/* cursor_home */
literal|0
block|,
comment|/* cursor_left */
literal|0
block|,
comment|/* cursor_right */
literal|0
block|,
comment|/* cursor_to_ll */
literal|0
block|,
comment|/* cursor_up */
literal|0
block|,
comment|/* tab */
literal|0
block|,
comment|/* back_tab */
operator|-
literal|1
block|,
comment|/* row_address */
operator|-
literal|1
block|,
comment|/* column_address */
operator|-
literal|1
block|,
comment|/* parm_down_cursor */
operator|-
literal|1
block|,
comment|/* parm_left_cursor */
operator|-
literal|1
block|,
comment|/* parm_right_cursor */
operator|-
literal|1
block|,
comment|/* parm_up_cursor */
operator|-
literal|2
comment|/* cursor_address */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* **	Make_seq_best(best, try) **	 **	Make_seq_best() copies try to best if try->cost< best->cost ** **	fixed the old version, now it really runs .. (-hm/08.04.93) ** */
end_comment

begin_function
specifier|inline
name|void
name|Make_seq_best
parameter_list|(
name|struct
name|Sequence
modifier|*
name|best
parameter_list|,
name|struct
name|Sequence
modifier|*
name|try
parameter_list|)
block|{
if|if
condition|(
name|best
operator|->
name|cost
operator|>
name|try
operator|->
name|cost
condition|)
block|{
specifier|register
name|int
modifier|*
name|sptr
decl_stmt|;
name|sptr
operator|=
name|try
operator|->
name|vec
expr_stmt|;
comment|/* src ptr */
name|best
operator|->
name|end
operator|=
name|best
operator|->
name|vec
expr_stmt|;
comment|/* dst ptr */
while|while
condition|(
name|sptr
operator|!=
name|try
operator|->
name|end
condition|)
comment|/* copy src -> dst */
operator|*
operator|(
name|best
operator|->
name|end
operator|++
operator|)
operator|=
operator|*
operator|(
name|sptr
operator|++
operator|)
expr_stmt|;
name|best
operator|->
name|cost
operator|=
name|try
operator|->
name|cost
expr_stmt|;
comment|/* copy cost */
block|}
block|}
end_function

begin_comment
comment|/* ** **	mvcur(oldrow, oldcol, newrow, newcol) ** **	mvcur() optimally moves the cursor from the position **	specified by (oldrow, oldcol) to (newrow, newcol).  If **	(oldrow, oldcol) == (-1, -1), mvcur() does not use relative **	cursor motions.  If the coordinates are otherwise **	out of bounds, it mods them into range. ** **	Revisions needed: **		eat_newline_glitch, auto_right_margin */
end_comment

begin_function
name|int
name|mvcur
parameter_list|(
name|int
name|oldrow
parameter_list|,
name|int
name|oldcol
parameter_list|,
name|int
name|newrow
parameter_list|,
name|int
name|newcol
parameter_list|)
block|{
name|struct
name|Sequence
name|seqA
decl_stmt|,
name|seqB
decl_stmt|,
comment|/* allocate work structures */
name|col0seq
decl_stmt|,
comment|/* sequence to get from col0 to nc */
modifier|*
name|best
decl_stmt|,
comment|/* best sequence so far */
modifier|*
name|try
decl_stmt|;
comment|/* next try */
name|bool
name|nlstat
init|=
name|SP
operator|->
name|_nl
decl_stmt|;
comment|/* nl-output-mapping in effect ?*/
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|_tracing
condition|)
name|_tracef
argument_list|(
literal|"=============================\nmvcur(%d,%d,%d,%d) called"
argument_list|,
name|oldrow
argument_list|,
name|oldcol
argument_list|,
name|newrow
argument_list|,
name|newcol
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|oldrow
operator|==
name|newrow
operator|)
operator|&&
operator|(
name|oldcol
operator|==
name|newcol
operator|)
condition|)
return|return
name|OK
return|;
if|if
condition|(
name|oldcol
operator|==
name|columns
operator|-
literal|1
operator|&&
name|eat_newline_glitch
operator|&&
name|auto_right_margin
condition|)
block|{
name|tputs
argument_list|(
name|tparm
argument_list|(
name|cursor_address
argument_list|,
name|newrow
argument_list|,
name|newcol
argument_list|)
argument_list|,
literal|1
argument_list|,
name|_outc
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
if|#
directive|if
literal|0
block|if (nlstat) 		nonl();
endif|#
directive|endif
name|update_ops
argument_list|()
expr_stmt|;
comment|/* make sure op_info[] is current */
if|if
condition|(
name|oldrow
operator|<
literal|0
operator|||
name|oldcol
operator|<
literal|0
operator|||
operator|(
name|eat_newline_glitch
operator|&&
name|oldcol
operator|==
literal|0
operator|)
condition|)
block|{
name|rel_ok
operator|=
name|FALSE
expr_stmt|;
comment|/* relative ops ok? */
block|}
else|else
block|{
name|rel_ok
operator|=
name|TRUE
expr_stmt|;
name|oldrow
operator|%=
name|lines
expr_stmt|;
comment|/* mod values into range */
name|oldcol
operator|%=
name|columns
expr_stmt|;
block|}
name|newrow
operator|%=
name|lines
expr_stmt|;
name|newcol
operator|%=
name|columns
expr_stmt|;
name|best
operator|=
operator|&
name|seqA
expr_stmt|;
name|try
operator|=
operator|&
name|seqB
expr_stmt|;
comment|/* try out direct cursor addressing */
name|zero_seq
argument_list|(
name|best
argument_list|)
expr_stmt|;
name|add_op
argument_list|(
name|best
argument_list|,
name|CURS_ADDR
argument_list|,
name|newrow
argument_list|,
name|newcol
argument_list|)
expr_stmt|;
comment|/* try out independent row/column addressing */
if|if
condition|(
name|rel_ok
condition|)
block|{
name|zero_seq
argument_list|(
name|try
argument_list|)
expr_stmt|;
name|row
argument_list|(
name|try
argument_list|,
name|oldrow
argument_list|,
name|newrow
argument_list|)
expr_stmt|;
name|column
argument_list|(
name|try
argument_list|,
name|oldcol
argument_list|,
name|newcol
argument_list|)
expr_stmt|;
name|Make_seq_best
argument_list|(
name|best
argument_list|,
name|try
argument_list|)
expr_stmt|;
block|}
name|zero_seq
argument_list|(
operator|&
name|col0seq
argument_list|)
expr_stmt|;
comment|/* store seq. to get from c0 to nc */
name|column
argument_list|(
operator|&
name|col0seq
argument_list|,
literal|0
argument_list|,
name|newcol
argument_list|)
expr_stmt|;
if|if
condition|(
name|col0seq
operator|.
name|cost
operator|<
name|INFINITY
condition|)
block|{
comment|/* can get from col0 to newcol */
comment|/* try out homing and then row/column */
if|if
condition|(
operator|!
name|rel_ok
operator|||
name|newcol
operator|<
name|oldcol
operator|||
name|newrow
operator|<
name|oldrow
condition|)
block|{
name|zero_seq
argument_list|(
name|try
argument_list|)
expr_stmt|;
name|add_op
argument_list|(
name|try
argument_list|,
name|CURS_HOME
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|row
argument_list|(
name|try
argument_list|,
literal|0
argument_list|,
name|newrow
argument_list|)
expr_stmt|;
name|add_seq
argument_list|(
name|try
argument_list|,
operator|&
name|col0seq
argument_list|)
expr_stmt|;
name|Make_seq_best
argument_list|(
name|best
argument_list|,
name|try
argument_list|)
expr_stmt|;
block|}
comment|/* try out homing to last line  and then row/column */
if|if
condition|(
operator|!
name|rel_ok
operator|||
name|newcol
operator|<
name|oldcol
operator|||
name|newrow
operator|>
name|oldrow
condition|)
block|{
name|zero_seq
argument_list|(
name|try
argument_list|)
expr_stmt|;
name|add_op
argument_list|(
name|try
argument_list|,
name|CURS_TO_LL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|row
argument_list|(
name|try
argument_list|,
name|lines
operator|-
literal|1
argument_list|,
name|newrow
argument_list|)
expr_stmt|;
name|add_seq
argument_list|(
name|try
argument_list|,
operator|&
name|col0seq
argument_list|)
expr_stmt|;
name|Make_seq_best
argument_list|(
name|best
argument_list|,
name|try
argument_list|)
expr_stmt|;
block|}
block|}
name|out_seq
argument_list|(
name|best
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if(nlstat) 		nl();
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|_tracing
condition|)
name|_tracef
argument_list|(
literal|"==================================="
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/* **	row(outseq, oldrow, newrow) ** **	row() adds the best sequence for moving **  		the cursor from oldrow to newrow to seq. **	row() considers row_address, parm_up/down_cursor **  		and cursor_up/down. */
end_comment

begin_function
specifier|static
name|void
name|row
parameter_list|(
name|struct
name|Sequence
modifier|*
name|outseq
parameter_list|,
comment|/* where to put the output */
name|int
name|orow
parameter_list|,
name|int
name|nrow
parameter_list|)
comment|/* old, new cursor locations */
block|{
name|struct
name|Sequence
name|seqA
decl_stmt|,
name|seqB
decl_stmt|,
modifier|*
name|best
decl_stmt|,
comment|/* best sequence so far */
modifier|*
name|try
decl_stmt|;
comment|/* next try */
name|int
name|parm_cursor
decl_stmt|,
name|one_step
decl_stmt|;
name|best
operator|=
operator|&
name|seqA
expr_stmt|;
name|try
operator|=
operator|&
name|seqB
expr_stmt|;
if|if
condition|(
name|nrow
operator|==
name|orow
condition|)
return|return;
if|if
condition|(
name|nrow
operator|<
name|orow
condition|)
block|{
name|parm_cursor
operator|=
name|P_UP_CURS
expr_stmt|;
name|one_step
operator|=
name|CURS_UP
expr_stmt|;
block|}
else|else
block|{
name|parm_cursor
operator|=
name|P_DOWN_CURS
expr_stmt|;
name|one_step
operator|=
name|CURS_DOWN
expr_stmt|;
block|}
comment|/* try out direct row addressing */
name|zero_seq
argument_list|(
name|best
argument_list|)
expr_stmt|;
name|add_op
argument_list|(
name|best
argument_list|,
name|ROW_ADDR
argument_list|,
name|nrow
argument_list|)
expr_stmt|;
comment|/* try out paramaterized up or down motion */
if|if
condition|(
name|rel_ok
condition|)
block|{
name|zero_seq
argument_list|(
name|try
argument_list|)
expr_stmt|;
name|add_op
argument_list|(
name|try
argument_list|,
name|parm_cursor
argument_list|,
name|abs
argument_list|(
name|orow
operator|-
name|nrow
argument_list|)
argument_list|)
expr_stmt|;
name|Make_seq_best
argument_list|(
name|best
argument_list|,
name|try
argument_list|)
expr_stmt|;
block|}
comment|/* try getting there one step at a time... */
if|if
condition|(
name|rel_ok
condition|)
block|{
name|zero_seq
argument_list|(
name|try
argument_list|)
expr_stmt|;
name|add_op
argument_list|(
name|try
argument_list|,
name|one_step
argument_list|,
name|abs
argument_list|(
name|orow
operator|-
name|nrow
argument_list|)
argument_list|)
expr_stmt|;
name|Make_seq_best
argument_list|(
name|best
argument_list|,
name|try
argument_list|)
expr_stmt|;
block|}
name|add_seq
argument_list|(
name|outseq
argument_list|,
name|best
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	column(outseq, oldcol, newcol) ** **	column() adds the best sequence for moving **		the cursor from oldcol to newcol to outseq. **	column() considers column_address, parm_left/right_cursor, **		simp_col(), and carriage_return followed by simp_col(). */
end_comment

begin_function
specifier|static
name|void
name|column
parameter_list|(
name|struct
name|Sequence
modifier|*
name|outseq
parameter_list|,
comment|/* where to put the output */
name|int
name|ocol
parameter_list|,
name|int
name|ncol
parameter_list|)
comment|/* old, new cursor  column */
block|{
name|struct
name|Sequence
name|seqA
decl_stmt|,
name|seqB
decl_stmt|,
modifier|*
name|best
decl_stmt|,
modifier|*
name|try
decl_stmt|;
name|int
name|parm_cursor
decl_stmt|;
comment|/* set to either parm_up/down_cursor */
name|best
operator|=
operator|&
name|seqA
expr_stmt|;
name|try
operator|=
operator|&
name|seqB
expr_stmt|;
if|if
condition|(
name|ncol
operator|==
name|ocol
condition|)
return|return;
if|if
condition|(
name|ncol
operator|<
name|ocol
condition|)
name|parm_cursor
operator|=
name|P_LEFT_CURS
expr_stmt|;
else|else
name|parm_cursor
operator|=
name|P_RIGHT_CURS
expr_stmt|;
comment|/* try out direct column addressing */
name|zero_seq
argument_list|(
name|best
argument_list|)
expr_stmt|;
name|add_op
argument_list|(
name|best
argument_list|,
name|COL_ADDR
argument_list|,
name|ncol
argument_list|)
expr_stmt|;
comment|/* try carriage_return then simp_col() */
if|if
condition|(
operator|!
name|rel_ok
operator|||
operator|(
name|ncol
operator|<
name|ocol
operator|)
condition|)
block|{
name|zero_seq
argument_list|(
name|try
argument_list|)
expr_stmt|;
name|add_op
argument_list|(
name|try
argument_list|,
name|CARRIAGE_RETURN
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|simp_col
argument_list|(
name|try
argument_list|,
literal|0
argument_list|,
name|ncol
argument_list|)
expr_stmt|;
name|Make_seq_best
argument_list|(
name|best
argument_list|,
name|try
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rel_ok
condition|)
block|{
comment|/* try out paramaterized left or right motion */
name|zero_seq
argument_list|(
name|try
argument_list|)
expr_stmt|;
name|add_op
argument_list|(
name|try
argument_list|,
name|parm_cursor
argument_list|,
name|abs
argument_list|(
name|ocol
operator|-
name|ncol
argument_list|)
argument_list|)
expr_stmt|;
name|Make_seq_best
argument_list|(
name|best
argument_list|,
name|try
argument_list|)
expr_stmt|;
comment|/* try getting there with simp_col() */
name|zero_seq
argument_list|(
name|try
argument_list|)
expr_stmt|;
name|simp_col
argument_list|(
name|try
argument_list|,
name|ocol
argument_list|,
name|ncol
argument_list|)
expr_stmt|;
name|Make_seq_best
argument_list|(
name|best
argument_list|,
name|try
argument_list|)
expr_stmt|;
block|}
name|add_seq
argument_list|(
name|outseq
argument_list|,
name|best
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** 	simp_col(outseq, oldcol, newcol) ** **	simp_col() adds the best simple sequence for getting **		from oldcol to newcol to outseq. **	simp_col() considers (back_)tab and cursor_left/right. ** **  Revisions needed: **	Simp_col asssumes that the cost of a (back_)tab **	is less then the cost of one-stepping to get to the same column. **	Should sometimes use overprinting instead of cursor_right. */
end_comment

begin_function
specifier|static
name|void
name|simp_col
parameter_list|(
name|struct
name|Sequence
modifier|*
name|outseq
parameter_list|,
comment|/* place to put sequence */
name|int
name|oc
parameter_list|,
name|int
name|nc
parameter_list|)
comment|/* old column, new column */
block|{
name|struct
name|Sequence
name|seqA
decl_stmt|,
name|seqB
decl_stmt|,
name|tabseq
decl_stmt|,
modifier|*
name|best
decl_stmt|,
modifier|*
name|try
decl_stmt|;
name|int
name|mytab
decl_stmt|,
name|tabs
decl_stmt|,
name|onepast
decl_stmt|,
name|one_step
decl_stmt|,
name|opp_step
decl_stmt|;
name|onepast
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|oc
operator|==
name|nc
condition|)
return|return;
if|if
condition|(
operator|!
name|rel_ok
condition|)
block|{
name|outseq
operator|->
name|cost
operator|=
name|INFINITY
expr_stmt|;
return|return;
block|}
name|best
operator|=
operator|&
name|seqA
expr_stmt|;
name|try
operator|=
operator|&
name|seqB
expr_stmt|;
if|if
condition|(
name|oc
operator|<
name|nc
condition|)
block|{
name|mytab
operator|=
name|TAB
expr_stmt|;
if|if
condition|(
name|init_tabs
operator|>
literal|0
operator|&&
name|op_info
index|[
name|TAB
index|]
operator|<
name|INFINITY
condition|)
block|{
name|tabs
operator|=
operator|(
name|nc
operator|/
name|init_tabs
operator|)
operator|-
operator|(
name|oc
operator|/
name|init_tabs
operator|)
expr_stmt|;
name|onepast
operator|=
operator|(
operator|(
name|nc
operator|/
name|init_tabs
operator|)
operator|+
literal|1
operator|)
operator|*
name|init_tabs
expr_stmt|;
if|if
condition|(
name|tabs
condition|)
name|oc
operator|=
name|onepast
operator|-
name|init_tabs
expr_stmt|;
comment|/* consider it done */
block|}
else|else
block|{
name|tabs
operator|=
literal|0
expr_stmt|;
block|}
name|one_step
operator|=
name|CURS_RIGHT
expr_stmt|;
name|opp_step
operator|=
name|CURS_LEFT
expr_stmt|;
block|}
else|else
block|{
name|mytab
operator|=
name|BACK_TAB
expr_stmt|;
if|if
condition|(
name|init_tabs
operator|>
literal|0
operator|&&
name|op_info
index|[
name|BACK_TAB
index|]
operator|<
name|INFINITY
condition|)
block|{
name|tabs
operator|=
operator|(
name|oc
operator|/
name|init_tabs
operator|)
operator|-
operator|(
name|nc
operator|/
name|init_tabs
operator|)
expr_stmt|;
name|onepast
operator|=
operator|(
operator|(
name|nc
operator|-
literal|1
operator|)
operator|/
name|init_tabs
operator|)
operator|*
name|init_tabs
expr_stmt|;
if|if
condition|(
name|tabs
condition|)
name|oc
operator|=
name|onepast
operator|+
name|init_tabs
expr_stmt|;
comment|/* consider it done */
block|}
else|else
block|{
name|tabs
operator|=
literal|0
expr_stmt|;
block|}
name|one_step
operator|=
name|CURS_LEFT
expr_stmt|;
name|opp_step
operator|=
name|CURS_RIGHT
expr_stmt|;
block|}
comment|/* tab as close as possible to nc */
name|zero_seq
argument_list|(
operator|&
name|tabseq
argument_list|)
expr_stmt|;
name|add_op
argument_list|(
operator|&
name|tabseq
argument_list|,
name|mytab
argument_list|,
name|tabs
argument_list|)
expr_stmt|;
comment|/* try extra tab and backing up */
name|zero_seq
argument_list|(
name|best
argument_list|)
expr_stmt|;
if|if
condition|(
name|onepast
operator|>=
literal|0
operator|&&
name|onepast
operator|<
name|columns
condition|)
block|{
name|add_op
argument_list|(
name|best
argument_list|,
name|mytab
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|add_op
argument_list|(
name|best
argument_list|,
name|opp_step
argument_list|,
name|abs
argument_list|(
name|onepast
operator|-
name|nc
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|best
operator|->
name|cost
operator|=
name|INFINITY
expr_stmt|;
comment|/* make sure of next swap */
block|}
comment|/* try stepping to nc */
name|zero_seq
argument_list|(
name|try
argument_list|)
expr_stmt|;
name|add_op
argument_list|(
name|try
argument_list|,
name|one_step
argument_list|,
name|abs
argument_list|(
name|nc
operator|-
name|oc
argument_list|)
argument_list|)
expr_stmt|;
name|Make_seq_best
argument_list|(
name|best
argument_list|,
name|try
argument_list|)
expr_stmt|;
if|if
condition|(
name|tabseq
operator|.
name|cost
operator|<
name|INFINITY
condition|)
name|add_seq
argument_list|(
name|outseq
argument_list|,
operator|&
name|tabseq
argument_list|)
expr_stmt|;
name|add_seq
argument_list|(
name|outseq
argument_list|,
name|best
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	zero_seq(seq) empties seq. **	add_seq(seq1, seq2) adds seq1 to seq2. **	out_seq(seq) outputs a sequence. */
end_comment

begin_function
specifier|static
name|void
name|zero_seq
parameter_list|(
name|seq
parameter_list|)
name|struct
name|Sequence
modifier|*
name|seq
decl_stmt|;
block|{
name|seq
operator|->
name|end
operator|=
name|seq
operator|->
name|vec
expr_stmt|;
name|seq
operator|->
name|cost
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_seq
parameter_list|(
name|struct
name|Sequence
modifier|*
name|seq1
parameter_list|,
name|struct
name|Sequence
modifier|*
name|seq2
parameter_list|)
block|{
name|int
modifier|*
name|vptr
decl_stmt|;
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|_tracing
condition|)
name|_tracef
argument_list|(
literal|"add_seq(%x, %x)"
argument_list|,
name|seq1
argument_list|,
name|seq2
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|seq1
operator|->
name|cost
operator|>=
name|INFINITY
operator|||
name|seq2
operator|->
name|cost
operator|>=
name|INFINITY
condition|)
name|seq1
operator|->
name|cost
operator|=
name|INFINITY
expr_stmt|;
else|else
block|{
name|vptr
operator|=
name|seq2
operator|->
name|vec
expr_stmt|;
while|while
condition|(
name|vptr
operator|!=
name|seq2
operator|->
name|end
condition|)
operator|*
operator|(
name|seq1
operator|->
name|end
operator|++
operator|)
operator|=
operator|*
operator|(
name|vptr
operator|++
operator|)
expr_stmt|;
name|seq1
operator|->
name|cost
operator|+=
name|seq2
operator|->
name|cost
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|out_seq
parameter_list|(
name|struct
name|Sequence
modifier|*
name|seq
parameter_list|)
block|{
name|int
modifier|*
name|opptr
decl_stmt|,
name|prm
index|[
literal|9
index|]
decl_stmt|,
name|ps
decl_stmt|,
name|p
decl_stmt|,
name|op
decl_stmt|;
name|int
name|count
decl_stmt|;
name|char
modifier|*
name|sequence
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|_tracing
condition|)
name|_tracef
argument_list|(
literal|"out_seq(%x)"
argument_list|,
name|seq
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|seq
operator|->
name|cost
operator|>=
name|INFINITY
condition|)
return|return;
for|for
control|(
name|opptr
operator|=
name|seq
operator|->
name|vec
init|;
name|opptr
operator|<
name|seq
operator|->
name|end
condition|;
name|opptr
operator|++
control|)
block|{
name|op
operator|=
operator|*
name|opptr
expr_stmt|;
comment|/* grab operator */
name|ps
operator|=
operator|-
name|op_info
index|[
name|op
index|]
expr_stmt|;
if|if
condition|(
name|ps
operator|>
literal|0
condition|)
block|{
comment|/* parameterized */
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
name|ps
condition|;
name|p
operator|++
control|)
comment|/* fill in needed parms */
name|prm
index|[
name|p
index|]
operator|=
operator|*
operator|(
operator|++
name|opptr
operator|)
expr_stmt|;
name|tputs
argument_list|(
name|tparm
argument_list|(
name|sequence
argument_list|(
name|op
argument_list|)
argument_list|,
name|prm
index|[
literal|0
index|]
argument_list|,
name|prm
index|[
literal|1
index|]
argument_list|,
name|prm
index|[
literal|2
index|]
argument_list|,
name|prm
index|[
literal|3
index|]
argument_list|,
name|prm
index|[
literal|4
index|]
argument_list|,
name|prm
index|[
literal|5
index|]
argument_list|,
name|prm
index|[
literal|6
index|]
argument_list|,
name|prm
index|[
literal|7
index|]
argument_list|,
name|prm
index|[
literal|8
index|]
argument_list|)
argument_list|,
literal|1
argument_list|,
name|_outc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|count
operator|=
operator|*
operator|(
operator|++
name|opptr
operator|)
expr_stmt|;
comment|/*rev should save tputs output instead of mult calls */
while|while
condition|(
name|count
operator|--
condition|)
comment|/* do count times */
name|tputs
argument_list|(
name|sequence
argument_list|(
name|op
argument_list|)
argument_list|,
literal|1
argument_list|,
name|_outc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* **	update_ops() ** **	update_ops() makes sure that **	the op_info[] array is updated and initializes **	the cost array for SP if needed. */
end_comment

begin_function
specifier|static
name|void
name|update_ops
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|_tracing
condition|)
name|_tracef
argument_list|(
literal|"update_ops()"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|SP
condition|)
block|{
comment|/* SP structure exists */
name|int
name|op
decl_stmt|;
if|if
condition|(
operator|!
name|SP
operator|->
name|_costinit
condition|)
block|{
comment|/* this term not yet assigned costs */
name|loc_init
operator|=
name|FALSE
expr_stmt|;
comment|/* if !SP in the future, new term */
name|init_costs
argument_list|(
name|SP
operator|->
name|_costs
argument_list|)
expr_stmt|;
comment|/* fill term costs */
name|SP
operator|->
name|_costinit
operator|=
name|TRUE
expr_stmt|;
block|}
for|for
control|(
name|op
operator|=
literal|0
init|;
name|op
operator|<
name|NUM_NPARM
condition|;
name|op
operator|++
control|)
name|op_info
index|[
name|op
index|]
operator|=
name|SP
operator|->
name|_costs
index|[
name|op
index|]
expr_stmt|;
comment|/* set up op_info */
comment|/* check for newline that might be mapped... */
if|if
condition|(
name|SP
operator|->
name|_nlmapping
operator|&&
name|index
argument_list|(
name|sequence
argument_list|(
name|CURS_DOWN
argument_list|)
argument_list|,
literal|'\n'
argument_list|)
condition|)
name|op_info
index|[
name|CURS_DOWN
index|]
operator|=
name|INFINITY
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|loc_init
condition|)
block|{
comment|/* using local costs */
name|loc_init
operator|=
name|TRUE
expr_stmt|;
name|init_costs
argument_list|(
name|op_info
argument_list|)
expr_stmt|;
comment|/* set up op_info */
block|}
comment|/* check for newline that might be mapped... */
if|if
condition|(
name|index
argument_list|(
name|sequence
argument_list|(
name|CURS_DOWN
argument_list|)
argument_list|,
literal|'\n'
argument_list|)
condition|)
name|op_info
index|[
name|CURS_DOWN
index|]
operator|=
name|INFINITY
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **	init_costs(costs) ** **	init_costs() fills the array costs[NUM_NPARM] ** 	with costs calculated by doing tputs() calls. */
end_comment

begin_function
specifier|static
name|void
name|init_costs
parameter_list|(
name|int
name|costs
index|[]
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUM_NPARM
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|sequence
argument_list|(
name|i
argument_list|)
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
name|c_count
operator|=
literal|0
expr_stmt|;
name|tputs
argument_list|(
name|sequence
argument_list|(
name|i
argument_list|)
argument_list|,
literal|1
argument_list|,
name|countc
argument_list|)
expr_stmt|;
name|costs
index|[
name|i
index|]
operator|=
name|c_count
expr_stmt|;
block|}
else|else
name|costs
index|[
name|i
index|]
operator|=
name|INFINITY
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **	countc() increments global var c_count. */
end_comment

begin_function
specifier|static
name|int
name|countc
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
return|return
operator|(
name|c_count
operator|++
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **	add_op(seq, op, p0, p1, ... , p8) ** **	add_op() adds the operator op and the appropriate **  	number of paramaters to seq.  It also increases the  **  	cost appropriately. **	if op has no parameters, p0 is taken to be a count. */
end_comment

begin_function
specifier|static
name|void
name|add_op
parameter_list|(
name|struct
name|Sequence
modifier|*
name|seq
parameter_list|,
name|int
name|op
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|argp
decl_stmt|;
name|int
name|num_ps
decl_stmt|,
name|p
decl_stmt|;
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|_tracing
condition|)
name|_tracef
argument_list|(
literal|"adding op %d to sequence"
argument_list|,
name|op
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|va_start
argument_list|(
name|argp
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|num_ps
operator|=
operator|-
name|op_info
index|[
name|op
index|]
expr_stmt|;
comment|/* get parms or -cost */
operator|*
operator|(
name|seq
operator|->
name|end
operator|++
operator|)
operator|=
name|op
expr_stmt|;
if|if
condition|(
name|num_ps
operator|==
operator|(
operator|-
name|INFINITY
operator|)
operator|||
name|sequence
argument_list|(
name|op
argument_list|)
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
name|seq
operator|->
name|cost
operator|=
name|INFINITY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|num_ps
operator|<=
literal|0
condition|)
block|{
comment|/* no parms, -cost */
name|int
name|i
init|=
name|va_arg
argument_list|(
name|argp
argument_list|,
name|int
argument_list|)
decl_stmt|;
name|seq
operator|->
name|cost
operator|-=
name|i
operator|*
name|num_ps
expr_stmt|;
comment|/* ADD count * cost */
operator|*
operator|(
name|seq
operator|->
name|end
operator|++
operator|)
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
name|int
name|prm
index|[
literal|9
index|]
decl_stmt|;
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
name|num_ps
condition|;
name|p
operator|++
control|)
operator|*
operator|(
name|seq
operator|->
name|end
operator|++
operator|)
operator|=
name|prm
index|[
name|p
index|]
operator|=
name|va_arg
argument_list|(
name|argp
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|c_count
operator|=
literal|0
expr_stmt|;
name|tputs
argument_list|(
name|tparm
argument_list|(
name|sequence
argument_list|(
name|op
argument_list|)
argument_list|,
name|prm
index|[
literal|0
index|]
argument_list|,
name|prm
index|[
literal|1
index|]
argument_list|,
name|prm
index|[
literal|2
index|]
argument_list|,
name|prm
index|[
literal|3
index|]
argument_list|,
name|prm
index|[
literal|4
index|]
argument_list|,
name|prm
index|[
literal|5
index|]
argument_list|,
name|prm
index|[
literal|6
index|]
argument_list|,
name|prm
index|[
literal|7
index|]
argument_list|,
name|prm
index|[
literal|8
index|]
argument_list|)
argument_list|,
literal|1
argument_list|,
name|countc
argument_list|)
expr_stmt|;
name|seq
operator|->
name|cost
operator|+=
name|c_count
expr_stmt|;
block|}
name|va_end
argument_list|(
name|argp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	char	*sequence(op) ** **	sequence() returns a pointer to the op's **      terminal control sequence. */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|sequence
parameter_list|(
name|int
name|op
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|TRACE
if|if
condition|(
name|_tracing
condition|)
name|_tracef
argument_list|(
literal|"sequence(%d)"
argument_list|,
name|op
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|CARRIAGE_RETURN
case|:
return|return
operator|(
name|carriage_return
operator|)
return|;
case|case
name|CURS_DOWN
case|:
return|return
operator|(
name|cursor_down
operator|)
return|;
case|case
name|CURS_HOME
case|:
return|return
operator|(
name|cursor_home
operator|)
return|;
case|case
name|CURS_LEFT
case|:
return|return
operator|(
name|cursor_left
operator|)
return|;
case|case
name|CURS_RIGHT
case|:
return|return
operator|(
name|cursor_right
operator|)
return|;
case|case
name|CURS_TO_LL
case|:
return|return
operator|(
name|cursor_to_ll
operator|)
return|;
case|case
name|CURS_UP
case|:
return|return
operator|(
name|cursor_up
operator|)
return|;
case|case
name|TAB
case|:
return|return
operator|(
name|tab
operator|)
return|;
case|case
name|BACK_TAB
case|:
return|return
operator|(
name|back_tab
operator|)
return|;
case|case
name|ROW_ADDR
case|:
return|return
operator|(
name|row_address
operator|)
return|;
case|case
name|COL_ADDR
case|:
return|return
operator|(
name|column_address
operator|)
return|;
case|case
name|P_DOWN_CURS
case|:
return|return
operator|(
name|parm_down_cursor
operator|)
return|;
case|case
name|P_LEFT_CURS
case|:
return|return
operator|(
name|parm_left_cursor
operator|)
return|;
case|case
name|P_RIGHT_CURS
case|:
return|return
operator|(
name|parm_right_cursor
operator|)
return|;
case|case
name|P_UP_CURS
case|:
return|return
operator|(
name|parm_up_cursor
operator|)
return|;
case|case
name|CURS_ADDR
case|:
return|return
operator|(
name|cursor_address
operator|)
return|;
default|default:
return|return
operator|(
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

