begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* This work is copyrighted. See COPYRIGHT.OLD& COPYRIGHT.NEW for   * *  details. If they are missing then this copy is in violation of    * *  the copyright conditions.                                        */
end_comment

begin_comment
comment|/*-----------------------------------------------------------------  *  *	lib_doupdate.c  *  *	The routine doupdate() and its dependents  *  *-----------------------------------------------------------------*/
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SYS_SELECT
end_ifdef

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"curses.priv.h"
end_include

begin_include
include|#
directive|include
file|"terminfo.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SVR4_ACTION
end_ifdef

begin_define
define|#
directive|define
name|_POSIX_SOURCE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_function_decl
specifier|static
name|void
name|ClrUpdate
parameter_list|(
name|WINDOW
modifier|*
name|scr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|TransformLine
parameter_list|(
name|int
name|lineno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|NoIDcTransformLine
parameter_list|(
name|int
name|lineno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|IDcTransformLine
parameter_list|(
name|int
name|lineno
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ClearScreen
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|InsStr
parameter_list|(
name|chtype
modifier|*
name|line
parameter_list|,
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|DelChar
parameter_list|(
name|int
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
specifier|inline
name|void
name|PutAttrChar
parameter_list|(
name|chtype
name|ch
parameter_list|)
block|{
name|TR
argument_list|(
name|TRACE_CHARPUT
argument_list|,
operator|(
literal|"PutAttrChar(%s, %s)"
operator|,
name|_tracechar
argument_list|(
name|ch
operator|&
name|A_CHARTEXT
argument_list|)
operator|,
name|_traceattr
argument_list|(
operator|(
name|ch
operator|&
operator|(
name|chtype
operator|)
name|A_ATTRIBUTES
operator|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|curscr
operator|->
name|_attrs
operator|!=
operator|(
name|ch
operator|&
operator|(
name|chtype
operator|)
name|A_ATTRIBUTES
operator|)
condition|)
block|{
name|curscr
operator|->
name|_attrs
operator|=
name|ch
operator|&
operator|(
name|chtype
operator|)
name|A_ATTRIBUTES
expr_stmt|;
name|vidputs
argument_list|(
name|curscr
operator|->
name|_attrs
argument_list|,
name|_outch
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
name|ch
operator|&
name|A_CHARTEXT
argument_list|,
name|SP
operator|->
name|_ofp
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|LRCORNER
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|inline
name|void
name|PutChar
parameter_list|(
name|chtype
name|ch
parameter_list|)
block|{
if|if
condition|(
name|LRCORNER
operator|==
name|TRUE
operator|&&
name|SP
operator|->
name|_curscol
operator|==
name|columns
operator|-
literal|1
condition|)
block|{
name|int
name|i
init|=
name|lines
operator|-
literal|1
decl_stmt|;
name|int
name|j
init|=
name|columns
operator|-
literal|1
decl_stmt|;
name|LRCORNER
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|enter_insert_mode
operator|||
operator|!
name|exit_insert_mode
operator|)
operator|&&
operator|!
name|insert_character
condition|)
return|return;
if|if
condition|(
name|cursor_left
condition|)
name|putp
argument_list|(
name|cursor_left
argument_list|)
expr_stmt|;
else|else
name|mvcur
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|PutAttrChar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursor_left
condition|)
name|putp
argument_list|(
name|cursor_left
argument_list|)
expr_stmt|;
else|else
name|mvcur
argument_list|(
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
if|if
condition|(
name|enter_insert_mode
operator|&&
name|exit_insert_mode
condition|)
block|{
name|putp
argument_list|(
name|enter_insert_mode
argument_list|)
expr_stmt|;
name|PutAttrChar
argument_list|(
name|newscr
operator|->
name|_line
index|[
name|i
index|]
index|[
name|j
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|exit_insert_mode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|insert_character
condition|)
block|{
name|putp
argument_list|(
name|insert_character
argument_list|)
expr_stmt|;
name|PutAttrChar
argument_list|(
name|newscr
operator|->
name|_line
index|[
name|i
index|]
index|[
name|j
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|PutAttrChar
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_curscol
operator|++
expr_stmt|;
if|if
condition|(
name|SP
operator|->
name|_curscol
operator|>=
name|columns
condition|)
block|{
if|if
condition|(
name|auto_right_margin
condition|)
block|{
name|SP
operator|->
name|_curscol
operator|=
literal|0
expr_stmt|;
name|SP
operator|->
name|_cursrow
operator|++
expr_stmt|;
block|}
else|else
block|{
name|SP
operator|->
name|_curscol
operator|--
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|GoTo
parameter_list|(
name|int
name|row
parameter_list|,
name|int
name|col
parameter_list|)
block|{
name|mvcur
argument_list|(
name|SP
operator|->
name|_cursrow
argument_list|,
name|SP
operator|->
name|_curscol
argument_list|,
name|row
argument_list|,
name|col
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_cursrow
operator|=
name|row
expr_stmt|;
name|SP
operator|->
name|_curscol
operator|=
name|col
expr_stmt|;
block|}
end_function

begin_function
name|int
name|_outch
parameter_list|(
name|char
name|ch
parameter_list|)
block|{
if|if
condition|(
name|SP
operator|!=
name|NULL
condition|)
name|putc
argument_list|(
name|ch
argument_list|,
name|SP
operator|->
name|_ofp
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
name|ch
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_function
name|int
name|doupdate
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|sigaction_t
name|act
decl_stmt|,
name|oact
decl_stmt|;
name|T
argument_list|(
operator|(
literal|"doupdate() called"
operator|)
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_handler
operator|=
name|SIG_IGN
expr_stmt|;
name|sigemptyset
argument_list|(
operator|&
name|act
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
name|act
operator|.
name|sa_flags
operator|=
literal|0
expr_stmt|;
name|sigaction
argument_list|(
name|SIGTSTP
argument_list|,
operator|&
name|act
argument_list|,
operator|&
name|oact
argument_list|)
expr_stmt|;
if|if
condition|(
name|SP
operator|->
name|_endwin
operator|==
name|TRUE
condition|)
block|{
name|T
argument_list|(
operator|(
literal|"coming back from shell mode"
operator|)
argument_list|)
expr_stmt|;
name|reset_prog_mode
argument_list|()
expr_stmt|;
comment|/* is this necessary? */
if|if
condition|(
name|enter_alt_charset_mode
condition|)
name|init_acs
argument_list|()
expr_stmt|;
name|newscr
operator|->
name|_clear
operator|=
name|TRUE
expr_stmt|;
name|SP
operator|->
name|_endwin
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* check for pending input */
block|{
name|fd_set
name|fdset
decl_stmt|;
name|struct
name|timeval
name|timeout
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|fdset
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|SP
operator|->
name|_checkfd
argument_list|,
operator|&
name|fdset
argument_list|)
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
name|SP
operator|->
name|_checkfd
operator|+
literal|1
argument_list|,
operator|&
name|fdset
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|timeout
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fflush
argument_list|(
name|SP
operator|->
name|_ofp
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
block|}
if|if
condition|(
name|curscr
operator|->
name|_clear
condition|)
block|{
comment|/* force refresh ? */
name|T
argument_list|(
operator|(
literal|"clearing and updating curscr"
operator|)
argument_list|)
expr_stmt|;
name|ClrUpdate
argument_list|(
name|curscr
argument_list|)
expr_stmt|;
comment|/* yes, clear all& update */
name|curscr
operator|->
name|_clear
operator|=
name|FALSE
expr_stmt|;
comment|/* reset flag */
block|}
else|else
block|{
if|if
condition|(
name|newscr
operator|->
name|_clear
condition|)
block|{
name|T
argument_list|(
operator|(
literal|"clearing and updating newscr"
operator|)
argument_list|)
expr_stmt|;
name|ClrUpdate
argument_list|(
name|newscr
argument_list|)
expr_stmt|;
name|newscr
operator|->
name|_clear
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|T
argument_list|(
operator|(
literal|"Transforming lines"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lines
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|newscr
operator|->
name|_firstchar
index|[
name|i
index|]
operator|!=
name|_NOCHANGE
condition|)
name|TransformLine
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|T
argument_list|(
operator|(
literal|"marking screen as updated"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lines
condition|;
name|i
operator|++
control|)
block|{
name|newscr
operator|->
name|_firstchar
index|[
name|i
index|]
operator|=
name|_NOCHANGE
expr_stmt|;
name|newscr
operator|->
name|_lastchar
index|[
name|i
index|]
operator|=
name|_NOCHANGE
expr_stmt|;
block|}
name|curscr
operator|->
name|_curx
operator|=
name|newscr
operator|->
name|_curx
expr_stmt|;
name|curscr
operator|->
name|_cury
operator|=
name|newscr
operator|->
name|_cury
expr_stmt|;
name|GoTo
argument_list|(
name|curscr
operator|->
name|_cury
argument_list|,
name|curscr
operator|->
name|_curx
argument_list|)
expr_stmt|;
comment|/* perhaps we should turn attributes off here */
if|if
condition|(
name|curscr
operator|->
name|_attrs
operator|!=
name|A_NORMAL
condition|)
name|vidattr
argument_list|(
name|curscr
operator|->
name|_attrs
operator|=
name|A_NORMAL
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|SP
operator|->
name|_ofp
argument_list|)
expr_stmt|;
name|sigaction
argument_list|(
name|SIGTSTP
argument_list|,
operator|&
name|oact
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|move_right_cost
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|countc
parameter_list|(
name|char
name|c
parameter_list|)
block|{
return|return
operator|(
name|move_right_cost
operator|++
operator|)
return|;
block|}
end_function

begin_comment
comment|/* **	ClrUpdate(scr) ** **	Update by clearing and redrawing the entire screen. ** */
end_comment

begin_define
define|#
directive|define
name|BLANK
value|' '|A_NORMAL
end_define

begin_function
specifier|static
name|void
name|ClrUpdate
parameter_list|(
name|WINDOW
modifier|*
name|scr
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
name|int
name|lastNonBlank
decl_stmt|;
name|T
argument_list|(
operator|(
literal|"ClrUpdate(%x) called"
operator|,
name|scr
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|back_color_erase
operator|&&
name|curscr
operator|->
name|_attrs
operator|!=
name|A_NORMAL
condition|)
block|{
name|T
argument_list|(
operator|(
literal|"back_color_erase, turning attributes off"
operator|)
argument_list|)
expr_stmt|;
name|vidattr
argument_list|(
name|curscr
operator|->
name|_attrs
operator|=
name|A_NORMAL
argument_list|)
expr_stmt|;
block|}
name|ClearScreen
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|move_right_cost
operator|==
operator|-
literal|1
operator|)
operator|&&
name|parm_right_cursor
condition|)
block|{
name|move_right_cost
operator|=
literal|0
expr_stmt|;
name|tputs
argument_list|(
name|tparm
argument_list|(
name|parm_right_cursor
argument_list|,
literal|10
argument_list|)
argument_list|,
literal|1
argument_list|,
name|countc
argument_list|)
expr_stmt|;
block|}
name|T
argument_list|(
operator|(
literal|"updating screen from scratch"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lines
condition|;
name|i
operator|++
control|)
block|{
name|lastNonBlank
operator|=
name|columns
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|lastNonBlank
operator|>=
literal|0
operator|&&
name|scr
operator|->
name|_line
index|[
name|i
index|]
index|[
name|lastNonBlank
index|]
operator|==
name|BLANK
condition|)
name|lastNonBlank
operator|--
expr_stmt|;
comment|/* check if we are at the lr corner */
if|if
condition|(
name|i
operator|==
name|lines
operator|-
literal|1
condition|)
if|if
condition|(
operator|(
name|auto_right_margin
operator|)
operator|&&
operator|!
operator|(
name|eat_newline_glitch
operator|)
operator|&&
operator|(
name|lastNonBlank
operator|==
name|columns
operator|-
literal|1
operator|)
condition|)
block|{
name|T
argument_list|(
operator|(
literal|"Lower-right corner needs special handling"
operator|)
argument_list|)
expr_stmt|;
name|LRCORNER
operator|=
name|TRUE
expr_stmt|;
block|}
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|lastNonBlank
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|parm_right_cursor
condition|)
block|{
specifier|static
name|int
name|inspace
init|=
literal|0
decl_stmt|;
name|T
argument_list|(
operator|(
literal|"trying to use parm_right_cursor"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|scr
operator|->
name|_line
index|[
name|i
index|]
index|[
name|j
index|]
operator|)
operator|==
name|BLANK
condition|)
block|{
name|inspace
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|inspace
condition|)
block|{
if|if
condition|(
name|inspace
operator|<
name|move_right_cost
condition|)
block|{
for|for
control|(
init|;
name|inspace
operator|>
literal|0
condition|;
name|inspace
operator|--
control|)
name|PutChar
argument_list|(
name|scr
operator|->
name|_line
index|[
name|i
index|]
index|[
name|j
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putp
argument_list|(
name|tparm
argument_list|(
name|parm_right_cursor
argument_list|,
name|inspace
argument_list|)
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_curscol
operator|+=
name|inspace
expr_stmt|;
block|}
name|inspace
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|PutChar
argument_list|(
name|scr
operator|->
name|_line
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* move cursor to the next line */
if|if
condition|(
operator|(
operator|!
name|auto_right_margin
operator|)
operator|||
operator|(
name|lastNonBlank
operator|<
name|columns
operator|-
literal|1
operator|)
operator|||
operator|(
name|auto_right_margin
operator|&&
name|eat_newline_glitch
operator|&&
name|lastNonBlank
operator|==
name|columns
operator|-
literal|1
operator|)
condition|)
block|{
name|SP
operator|->
name|_curscol
operator|=
operator|(
name|lastNonBlank
operator|<
literal|0
operator|)
condition|?
literal|0
else|:
name|lastNonBlank
expr_stmt|;
name|SP
operator|->
name|_cursrow
operator|++
expr_stmt|;
name|GoTo
argument_list|(
name|i
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|scr
operator|!=
name|curscr
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lines
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|columns
condition|;
name|j
operator|++
control|)
name|curscr
operator|->
name|_line
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|scr
operator|->
name|_line
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **	TransformLine(lineno) ** **	Call either IDcTransformLine or NoIDcTransformLine to do the **	update, depending upon availability of insert/delete character. */
end_comment

begin_function
specifier|static
name|void
name|TransformLine
parameter_list|(
name|int
name|lineno
parameter_list|)
block|{
name|T
argument_list|(
operator|(
literal|"TransformLine(%d) called"
operator|,
name|lineno
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|insert_character
operator|||
operator|(
name|enter_insert_mode
operator|&&
name|exit_insert_mode
operator|)
operator|)
operator|&&
name|delete_character
condition|)
name|IDcTransformLine
argument_list|(
name|lineno
argument_list|)
expr_stmt|;
else|else
name|NoIDcTransformLine
argument_list|(
name|lineno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	NoIDcTransformLine(lineno) ** **	Transform the given line in curscr to the one in newscr, without **	using Insert/Delete Character. ** **		firstChar = position of first different character in line **		lastChar = position of last different character in line ** **		overwrite all characters between firstChar and lastChar. ** */
end_comment

begin_function
specifier|static
name|void
name|NoIDcTransformLine
parameter_list|(
name|int
name|lineno
parameter_list|)
block|{
name|int
name|firstChar
decl_stmt|,
name|lastChar
decl_stmt|;
name|chtype
modifier|*
name|newLine
init|=
name|newscr
operator|->
name|_line
index|[
name|lineno
index|]
decl_stmt|;
name|chtype
modifier|*
name|oldLine
init|=
name|curscr
operator|->
name|_line
index|[
name|lineno
index|]
decl_stmt|;
name|int
name|k
decl_stmt|;
name|int
name|attrchanged
init|=
literal|0
decl_stmt|;
name|T
argument_list|(
operator|(
literal|"NoIDcTransformLine(%d) called"
operator|,
name|lineno
operator|)
argument_list|)
expr_stmt|;
name|firstChar
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|firstChar
operator|<
name|columns
operator|-
literal|1
operator|&&
name|newLine
index|[
name|firstChar
index|]
operator|==
name|oldLine
index|[
name|firstChar
index|]
condition|)
block|{
if|if
condition|(
name|ceol_standout_glitch
condition|)
block|{
if|if
condition|(
operator|(
name|newLine
index|[
name|firstChar
index|]
operator|&
operator|(
name|chtype
operator|)
name|A_ATTRIBUTES
operator|)
operator|!=
operator|(
name|oldLine
index|[
name|firstChar
index|]
operator|&
operator|(
name|chtype
operator|)
name|A_ATTRIBUTES
operator|)
condition|)
name|attrchanged
operator|=
literal|1
expr_stmt|;
block|}
name|firstChar
operator|++
expr_stmt|;
block|}
name|T
argument_list|(
operator|(
literal|"first char at %d is %x"
operator|,
name|firstChar
operator|,
name|newLine
index|[
name|firstChar
index|]
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|firstChar
operator|>
name|columns
condition|)
return|return;
if|if
condition|(
name|ceol_standout_glitch
operator|&&
name|attrchanged
condition|)
block|{
name|firstChar
operator|=
literal|0
expr_stmt|;
name|lastChar
operator|=
name|columns
operator|-
literal|1
expr_stmt|;
name|GoTo
argument_list|(
name|lineno
argument_list|,
name|firstChar
argument_list|)
expr_stmt|;
if|if
condition|(
name|clr_eol
condition|)
block|{
if|if
condition|(
name|back_color_erase
operator|&&
name|curscr
operator|->
name|_attrs
operator|!=
name|A_NORMAL
condition|)
block|{
name|T
argument_list|(
operator|(
literal|"back_color_erase, turning attributes off"
operator|)
argument_list|)
expr_stmt|;
name|vidattr
argument_list|(
name|curscr
operator|->
name|_attrs
operator|=
name|A_NORMAL
argument_list|)
expr_stmt|;
block|}
name|putp
argument_list|(
name|clr_eol
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|lastChar
operator|=
name|columns
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|lastChar
operator|>
name|firstChar
operator|&&
name|newLine
index|[
name|lastChar
index|]
operator|==
name|oldLine
index|[
name|lastChar
index|]
condition|)
name|lastChar
operator|--
expr_stmt|;
name|GoTo
argument_list|(
name|lineno
argument_list|,
name|firstChar
argument_list|)
expr_stmt|;
block|}
comment|/* check if we are at the lr corner */
if|if
condition|(
name|lineno
operator|==
name|lines
operator|-
literal|1
condition|)
if|if
condition|(
operator|(
name|auto_right_margin
operator|)
operator|&&
operator|!
operator|(
name|eat_newline_glitch
operator|)
operator|&&
operator|(
name|lastChar
operator|==
name|columns
operator|-
literal|1
operator|)
condition|)
block|{
name|T
argument_list|(
operator|(
literal|"Lower-right corner needs special handling"
operator|)
argument_list|)
expr_stmt|;
name|LRCORNER
operator|=
name|TRUE
expr_stmt|;
block|}
name|T
argument_list|(
operator|(
literal|"updating chars %d to %d"
operator|,
name|firstChar
operator|,
name|lastChar
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
name|firstChar
init|;
name|k
operator|<=
name|lastChar
condition|;
name|k
operator|++
control|)
block|{
name|PutChar
argument_list|(
name|newLine
index|[
name|k
index|]
argument_list|)
expr_stmt|;
name|oldLine
index|[
name|k
index|]
operator|=
name|newLine
index|[
name|k
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* **	IDcTransformLine(lineno) ** **	Transform the given line in curscr to the one in newscr, using **	Insert/Delete Character. ** **		firstChar = position of first different character in line **		oLastChar = position of last different character in old line **		nLastChar = position of last different character in new line ** **		move to firstChar **		overwrite chars up to min(oLastChar, nLastChar) **		if oLastChar< nLastChar **			insert newLine[oLastChar+1..nLastChar] **		else **			delete oLastChar - nLastChar spaces */
end_comment

begin_function
specifier|static
name|void
name|IDcTransformLine
parameter_list|(
name|int
name|lineno
parameter_list|)
block|{
name|int
name|firstChar
decl_stmt|,
name|oLastChar
decl_stmt|,
name|nLastChar
decl_stmt|;
name|chtype
modifier|*
name|newLine
init|=
name|newscr
operator|->
name|_line
index|[
name|lineno
index|]
decl_stmt|;
name|chtype
modifier|*
name|oldLine
init|=
name|curscr
operator|->
name|_line
index|[
name|lineno
index|]
decl_stmt|;
name|int
name|k
decl_stmt|,
name|n
decl_stmt|;
name|int
name|attrchanged
init|=
literal|0
decl_stmt|;
name|T
argument_list|(
operator|(
literal|"IDcTransformLine(%d) called"
operator|,
name|lineno
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ceol_standout_glitch
operator|&&
name|clr_eol
condition|)
block|{
name|firstChar
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|firstChar
operator|<
name|columns
condition|)
block|{
if|if
condition|(
operator|(
name|newLine
index|[
name|firstChar
index|]
operator|&
operator|(
name|chtype
operator|)
name|A_ATTRIBUTES
operator|)
operator|!=
operator|(
name|oldLine
index|[
name|firstChar
index|]
operator|&
operator|(
name|chtype
operator|)
name|A_ATTRIBUTES
operator|)
condition|)
name|attrchanged
operator|=
literal|1
expr_stmt|;
name|firstChar
operator|++
expr_stmt|;
block|}
block|}
name|firstChar
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|attrchanged
condition|)
block|{
name|GoTo
argument_list|(
name|lineno
argument_list|,
name|firstChar
argument_list|)
expr_stmt|;
if|if
condition|(
name|back_color_erase
operator|&&
name|curscr
operator|->
name|_attrs
operator|!=
name|A_NORMAL
condition|)
block|{
name|T
argument_list|(
operator|(
literal|"back_color_erase, turning attributes off"
operator|)
argument_list|)
expr_stmt|;
name|vidattr
argument_list|(
name|curscr
operator|->
name|_attrs
operator|=
name|A_NORMAL
argument_list|)
expr_stmt|;
block|}
name|putp
argument_list|(
name|clr_eol
argument_list|)
expr_stmt|;
comment|/* check if we are at the lr corner */
if|if
condition|(
name|lineno
operator|==
name|lines
operator|-
literal|1
condition|)
if|if
condition|(
operator|(
name|auto_right_margin
operator|)
operator|&&
operator|!
operator|(
name|eat_newline_glitch
operator|)
condition|)
block|{
name|T
argument_list|(
operator|(
literal|"Lower-right corner needs special handling"
operator|)
argument_list|)
expr_stmt|;
name|LRCORNER
operator|=
name|TRUE
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<=
operator|(
name|columns
operator|-
literal|1
operator|)
condition|;
name|k
operator|++
control|)
name|PutChar
argument_list|(
name|newLine
index|[
name|k
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|firstChar
operator|<
name|columns
operator|&&
name|newLine
index|[
name|firstChar
index|]
operator|==
name|oldLine
index|[
name|firstChar
index|]
condition|)
name|firstChar
operator|++
expr_stmt|;
if|if
condition|(
name|firstChar
operator|>=
name|columns
condition|)
return|return;
name|oLastChar
operator|=
name|columns
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|oLastChar
operator|>
name|firstChar
operator|&&
name|oldLine
index|[
name|oLastChar
index|]
operator|==
name|BLANK
condition|)
name|oLastChar
operator|--
expr_stmt|;
name|nLastChar
operator|=
name|columns
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|nLastChar
operator|>
name|firstChar
operator|&&
name|newLine
index|[
name|nLastChar
index|]
operator|==
name|BLANK
condition|)
name|nLastChar
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|nLastChar
operator|==
name|firstChar
operator|)
operator|&&
name|clr_eol
condition|)
block|{
name|GoTo
argument_list|(
name|lineno
argument_list|,
name|firstChar
argument_list|)
expr_stmt|;
if|if
condition|(
name|back_color_erase
operator|&&
name|curscr
operator|->
name|_attrs
operator|!=
name|A_NORMAL
condition|)
block|{
name|T
argument_list|(
operator|(
literal|"back_color_erase, turning attributes off"
operator|)
argument_list|)
expr_stmt|;
name|vidattr
argument_list|(
name|curscr
operator|->
name|_attrs
operator|=
name|A_NORMAL
argument_list|)
expr_stmt|;
block|}
name|putp
argument_list|(
name|clr_eol
argument_list|)
expr_stmt|;
if|if
condition|(
name|newLine
index|[
name|firstChar
index|]
operator|!=
name|BLANK
condition|)
block|{
comment|/* check if we are at the lr corner */
if|if
condition|(
name|lineno
operator|==
name|lines
operator|-
literal|1
condition|)
if|if
condition|(
operator|(
name|auto_right_margin
operator|)
operator|&&
operator|!
operator|(
name|eat_newline_glitch
operator|)
operator|&&
operator|(
name|firstChar
operator|==
name|columns
operator|-
literal|1
operator|)
condition|)
block|{
name|T
argument_list|(
operator|(
literal|"Lower-right corner needs special handling"
operator|)
argument_list|)
expr_stmt|;
name|LRCORNER
operator|=
name|TRUE
expr_stmt|;
block|}
name|PutChar
argument_list|(
name|newLine
index|[
name|firstChar
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|newLine
index|[
name|nLastChar
index|]
operator|!=
name|oldLine
index|[
name|oLastChar
index|]
condition|)
block|{
name|n
operator|=
name|max
argument_list|(
name|nLastChar
argument_list|,
name|oLastChar
argument_list|)
expr_stmt|;
name|GoTo
argument_list|(
name|lineno
argument_list|,
name|firstChar
argument_list|)
expr_stmt|;
comment|/* check if we are at the lr corner */
if|if
condition|(
name|lineno
operator|==
name|lines
operator|-
literal|1
condition|)
if|if
condition|(
operator|(
name|auto_right_margin
operator|)
operator|&&
operator|!
operator|(
name|eat_newline_glitch
operator|)
operator|&&
operator|(
name|n
operator|==
name|columns
operator|-
literal|1
operator|)
condition|)
block|{
name|T
argument_list|(
operator|(
literal|"Lower-right corner needs special handling"
operator|)
argument_list|)
expr_stmt|;
name|LRCORNER
operator|=
name|TRUE
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
name|firstChar
init|;
name|k
operator|<=
name|n
condition|;
name|k
operator|++
control|)
name|PutChar
argument_list|(
name|newLine
index|[
name|k
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|newLine
index|[
name|nLastChar
index|]
operator|==
name|oldLine
index|[
name|oLastChar
index|]
condition|)
block|{
name|nLastChar
operator|--
expr_stmt|;
name|oLastChar
operator|--
expr_stmt|;
block|}
name|n
operator|=
name|min
argument_list|(
name|oLastChar
argument_list|,
name|nLastChar
argument_list|)
expr_stmt|;
name|GoTo
argument_list|(
name|lineno
argument_list|,
name|firstChar
argument_list|)
expr_stmt|;
comment|/* check if we are at the lr corner */
if|if
condition|(
name|lineno
operator|==
name|lines
operator|-
literal|1
condition|)
if|if
condition|(
operator|(
name|auto_right_margin
operator|)
operator|&&
operator|!
operator|(
name|eat_newline_glitch
operator|)
operator|&&
operator|(
name|n
operator|==
name|columns
operator|-
literal|1
operator|)
condition|)
block|{
name|T
argument_list|(
operator|(
literal|"Lower-right corner needs special handling"
operator|)
argument_list|)
expr_stmt|;
name|LRCORNER
operator|=
name|TRUE
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
name|firstChar
init|;
name|k
operator|<=
name|n
condition|;
name|k
operator|++
control|)
name|PutChar
argument_list|(
name|newLine
index|[
name|k
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|oLastChar
operator|<
name|nLastChar
condition|)
name|InsStr
argument_list|(
operator|&
name|newLine
index|[
name|k
index|]
argument_list|,
name|nLastChar
operator|-
name|oLastChar
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|oLastChar
operator|>
name|nLastChar
condition|)
name|DelChar
argument_list|(
name|oLastChar
operator|-
name|nLastChar
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|k
operator|=
name|firstChar
init|;
name|k
operator|<
name|columns
condition|;
name|k
operator|++
control|)
name|oldLine
index|[
name|k
index|]
operator|=
name|newLine
index|[
name|k
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	ClearScreen() ** **	Clear the physical screen and put cursor at home ** */
end_comment

begin_function
specifier|static
name|void
name|ClearScreen
parameter_list|()
block|{
name|T
argument_list|(
operator|(
literal|"ClearScreen() called"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|clear_screen
condition|)
block|{
name|putp
argument_list|(
name|clear_screen
argument_list|)
expr_stmt|;
name|SP
operator|->
name|_cursrow
operator|=
name|SP
operator|->
name|_curscol
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|clr_eos
condition|)
block|{
name|SP
operator|->
name|_cursrow
operator|=
name|SP
operator|->
name|_curscol
operator|=
operator|-
literal|1
expr_stmt|;
name|GoTo
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|clr_eos
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|clr_eol
condition|)
block|{
name|SP
operator|->
name|_cursrow
operator|=
name|SP
operator|->
name|_curscol
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|SP
operator|->
name|_cursrow
operator|<
name|lines
condition|)
block|{
name|GoTo
argument_list|(
name|SP
operator|->
name|_cursrow
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|clr_eol
argument_list|)
expr_stmt|;
block|}
name|GoTo
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|T
argument_list|(
operator|(
literal|"screen cleared"
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* **	InsStr(line, count) ** **	Insert the count characters pointed to by line. ** */
end_comment

begin_function
specifier|static
name|void
name|InsStr
parameter_list|(
name|chtype
modifier|*
name|line
parameter_list|,
name|int
name|count
parameter_list|)
block|{
name|T
argument_list|(
operator|(
literal|"InsStr(%x,%d) called"
operator|,
name|line
operator|,
name|count
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|enter_insert_mode
operator|&&
name|exit_insert_mode
condition|)
block|{
name|putp
argument_list|(
name|enter_insert_mode
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
name|PutChar
argument_list|(
operator|*
name|line
argument_list|)
expr_stmt|;
name|line
operator|++
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
name|putp
argument_list|(
name|exit_insert_mode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|parm_ich
condition|)
block|{
name|putp
argument_list|(
name|tparm
argument_list|(
name|parm_ich
argument_list|,
name|count
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|count
condition|)
block|{
name|PutChar
argument_list|(
operator|*
name|line
argument_list|)
expr_stmt|;
name|line
operator|++
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
while|while
condition|(
name|count
condition|)
block|{
name|putp
argument_list|(
name|insert_character
argument_list|)
expr_stmt|;
name|PutChar
argument_list|(
operator|*
name|line
argument_list|)
expr_stmt|;
name|line
operator|++
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* **	DelChar(count) ** **	Delete count characters at current position ** */
end_comment

begin_function
specifier|static
name|void
name|DelChar
parameter_list|(
name|int
name|count
parameter_list|)
block|{
name|T
argument_list|(
operator|(
literal|"DelChar(%d) called"
operator|,
name|count
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|back_color_erase
operator|&&
name|curscr
operator|->
name|_attrs
operator|!=
name|A_NORMAL
condition|)
block|{
name|T
argument_list|(
operator|(
literal|"back_color_erase, turning attributes off"
operator|)
argument_list|)
expr_stmt|;
name|vidattr
argument_list|(
name|curscr
operator|->
name|_attrs
operator|=
name|A_NORMAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|parm_dch
condition|)
block|{
name|putp
argument_list|(
name|tparm
argument_list|(
name|parm_dch
argument_list|,
name|count
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|count
operator|--
condition|)
name|putp
argument_list|(
name|delete_character
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

