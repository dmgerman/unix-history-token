begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* This work is copyrighted. See COPYRIGHT.OLD& COPYRIGHT.NEW for   * *  details. If they are missing then this copy is in violation of    * *  the copyright conditions.                                        */
end_comment

begin_comment
comment|/*  *	lib_kernel.c  *  *	Misc. low-level routines:  *		wattron()  *		reset_prog_mode()  *		reset_shell_mode()  *		baudrate()  *		erasechar()  *		killchar()  *		flushinp()  *		savetty()  *		resetty()  *  *  */
end_comment

begin_include
include|#
directive|include
file|"curses.priv.h"
end_include

begin_include
include|#
directive|include
file|<nterm.h>
end_include

begin_function
name|int
name|wattron
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|chtype
name|at
parameter_list|)
block|{
name|win
operator|->
name|_attrs
operator|&=
operator|(
name|unsigned
name|long
operator|)
literal|0xffff00ff
expr_stmt|;
name|win
operator|->
name|_attrs
operator||=
name|at
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|MYTINFO
end_ifndef

begin_function
name|int
name|reset_prog_mode
parameter_list|()
block|{
name|T
argument_list|(
operator|(
literal|"reset_prog_mode() called"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TERMIOS
name|tcsetattr
argument_list|(
name|cur_term
operator|->
name|Filedes
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|cur_term
operator|->
name|Nttyb
argument_list|)
expr_stmt|;
else|#
directive|else
name|stty
argument_list|(
name|cur_term
operator|->
name|Filedes
argument_list|,
operator|&
name|cur_term
operator|->
name|Nttyb
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|OK
return|;
block|}
end_function

begin_function
name|int
name|reset_shell_mode
parameter_list|()
block|{
name|T
argument_list|(
operator|(
literal|"reset_shell_mode() called"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TERMIOS
name|tcsetattr
argument_list|(
name|cur_term
operator|->
name|Filedes
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|cur_term
operator|->
name|Ottyb
argument_list|)
expr_stmt|;
else|#
directive|else
name|stty
argument_list|(
name|cur_term
operator|->
name|Filedes
argument_list|,
operator|&
name|cur_term
operator|->
name|Ottyb
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|curs_set
parameter_list|(
name|int
name|vis
parameter_list|)
block|{
name|T
argument_list|(
operator|(
literal|"curs_set(%d)"
operator|,
name|vis
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vis
operator|<
literal|0
operator|||
name|vis
operator|>
literal|2
condition|)
return|return
name|ERR
return|;
switch|switch
condition|(
name|vis
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
name|cursor_visible
condition|)
name|tputs
argument_list|(
name|cursor_visible
argument_list|,
literal|1
argument_list|,
name|_outc
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|cursor_normal
condition|)
name|tputs
argument_list|(
name|cursor_normal
argument_list|,
literal|1
argument_list|,
name|_outc
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
if|if
condition|(
name|cursor_invisible
condition|)
name|tputs
argument_list|(
name|cursor_invisible
argument_list|,
literal|1
argument_list|,
name|_outc
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*  *	erasechar()  *  *	Return erase character as given in cur_term->Ottyb.  *  */
end_comment

begin_function
name|char
name|erasechar
parameter_list|()
block|{
name|T
argument_list|(
operator|(
literal|"erasechar() called"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TERMIOS
return|return
operator|(
name|cur_term
operator|->
name|Ottyb
operator|.
name|c_cc
index|[
name|VERASE
index|]
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|cur_term
operator|->
name|Ottyb
operator|.
name|sg_erase
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *	killchar()  *  *	Return kill character as given in cur_term->Ottyb.  *  */
end_comment

begin_function
name|char
name|killchar
parameter_list|()
block|{
name|T
argument_list|(
operator|(
literal|"killchar() called"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TERMIOS
return|return
operator|(
name|cur_term
operator|->
name|Ottyb
operator|.
name|c_cc
index|[
name|VKILL
index|]
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|cur_term
operator|->
name|Ottyb
operator|.
name|sg_kill
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *	flushinp()  *  *	Flush any input on cur_term->Filedes  *  */
end_comment

begin_function
name|int
name|flushinp
parameter_list|()
block|{
name|T
argument_list|(
operator|(
literal|"flushinp() called"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TERMIOS
name|tcflush
argument_list|(
name|cur_term
operator|->
name|Filedes
argument_list|,
name|TCIFLUSH
argument_list|)
expr_stmt|;
else|#
directive|else
name|ioctl
argument_list|(
name|cur_term
operator|->
name|Filedes
argument_list|,
name|TIOCFLUSH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|SP
condition|)
block|{
name|SP
operator|->
name|_fifohead
operator|=
operator|-
literal|1
expr_stmt|;
name|SP
operator|->
name|_fifotail
operator|=
literal|0
expr_stmt|;
name|SP
operator|->
name|_fifopeek
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*  *	int  *	baudrate()  *  *	Returns the current terminal's baud rate.  *  */
end_comment

begin_struct
struct|struct
name|speed
block|{
name|speed_t
name|s
decl_stmt|;
name|int
name|sp
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|speed
name|speeds
index|[]
init|=
block|{
block|{
name|B0
block|,
literal|0
block|}
block|,
block|{
name|B50
block|,
literal|50
block|}
block|,
block|{
name|B75
block|,
literal|75
block|}
block|,
block|{
name|B110
block|,
literal|110
block|}
block|,
block|{
name|B134
block|,
literal|134
block|}
block|,
block|{
name|B150
block|,
literal|150
block|}
block|,
block|{
name|B200
block|,
literal|200
block|}
block|,
block|{
name|B300
block|,
literal|300
block|}
block|,
block|{
name|B600
block|,
literal|600
block|}
block|,
block|{
name|B1200
block|,
literal|1200
block|}
block|,
block|{
name|B1800
block|,
literal|1800
block|}
block|,
block|{
name|B2400
block|,
literal|2400
block|}
block|,
block|{
name|B4800
block|,
literal|4800
block|}
block|,
block|{
name|B9600
block|,
literal|9600
block|}
define|#
directive|define
name|MAX_BAUD
value|B9600
ifdef|#
directive|ifdef
name|B19200
undef|#
directive|undef
name|MAX_BAUD
define|#
directive|define
name|MAX_BAUD
value|B19200
block|,
block|{
name|B19200
block|,
literal|19200
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B38400
undef|#
directive|undef
name|MAX_BAUD
define|#
directive|define
name|MAX_BAUD
value|B38400
block|,
block|{
name|B38400
block|,
literal|38400
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B57600
undef|#
directive|undef
name|MAX_BAUD
define|#
directive|define
name|MAX_BAUD
value|B57600
block|,
block|{
name|B57600
block|,
literal|57600
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B115200
undef|#
directive|undef
name|MAX_BAUD
define|#
directive|define
name|MAX_BAUD
value|B115200
block|,
block|{
name|B115200
block|,
literal|115200
block|}
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|baudrate
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
ifdef|#
directive|ifdef
name|UNTRACE
if|if
condition|(
name|_tracing
condition|)
name|_tracef
argument_list|(
literal|"baudrate() called"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERMIOS
name|ret
operator|=
name|cfgetospeed
argument_list|(
operator|&
name|cur_term
operator|->
name|Nttyb
argument_list|)
expr_stmt|;
else|#
directive|else
name|ret
operator|=
name|cur_term
operator|->
name|Nttyb
operator|.
name|sg_ospeed
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ret
operator|<
literal|0
operator|||
name|ret
operator|>
name|MAX_BAUD
condition|)
return|return
name|ERR
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|speeds
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|speed
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|speeds
index|[
name|i
index|]
operator|.
name|s
operator|==
name|ret
condition|)
return|return
name|speeds
index|[
name|i
index|]
operator|.
name|sp
return|;
return|return
name|ERR
return|;
block|}
end_function

begin_comment
comment|/* **	savetty()  and  resetty() ** */
end_comment

begin_decl_stmt
specifier|static
name|TTY
name|buf
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|savetty
parameter_list|()
block|{
name|T
argument_list|(
operator|(
literal|"savetty() called"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TERMIOS
name|tcgetattr
argument_list|(
name|cur_term
operator|->
name|Filedes
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
else|#
directive|else
name|gtty
argument_list|(
name|cur_term
operator|->
name|Filedes
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|OK
return|;
block|}
end_function

begin_function
name|int
name|resetty
parameter_list|()
block|{
name|T
argument_list|(
operator|(
literal|"resetty() called"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TERMIOS
name|tcsetattr
argument_list|(
name|cur_term
operator|->
name|Filedes
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
else|#
directive|else
name|stty
argument_list|(
name|cur_term
operator|->
name|Filedes
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|OK
return|;
block|}
end_function

end_unit

