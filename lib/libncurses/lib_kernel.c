begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* This work is copyrighted. See COPYRIGHT.OLD& COPYRIGHT.NEW for   * *  details. If they are missing then this copy is in violation of    * *  the copyright conditions.                                        */
end_comment

begin_comment
comment|/*  *	lib_kernel.c  *  *	Misc. low-level routines:  *		reset_prog_mode()  *		reset_shell_mode()  *		baudrate()  *		erasechar()  *		killchar()  *		flushinp()  *		savetty()  *		resetty()  *  *  */
end_comment

begin_include
include|#
directive|include
file|"curses.priv.h"
end_include

begin_include
include|#
directive|include
file|"terminfo.h"
end_include

begin_function
name|int
name|wattron
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|chtype
name|at
parameter_list|)
block|{
name|T
argument_list|(
operator|(
literal|"wattron(%x,%s) current = %s"
operator|,
name|win
operator|,
name|_traceattr
argument_list|(
name|at
argument_list|)
operator|,
name|_traceattr
argument_list|(
name|win
operator|->
name|_attrs
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|PAIR_NUMBER
argument_list|(
name|at
argument_list|)
operator|>
literal|0x00
condition|)
block|{
name|win
operator|->
name|_attrs
operator|=
operator|(
name|win
operator|->
name|_attrs
operator|&
operator|~
name|A_COLOR
operator|)
operator||
name|at
expr_stmt|;
name|T
argument_list|(
operator|(
literal|"new attribute is %s"
operator|,
name|_traceattr
argument_list|(
name|win
operator|->
name|_attrs
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|win
operator|->
name|_attrs
operator||=
name|at
expr_stmt|;
name|T
argument_list|(
operator|(
literal|"new attribute is %s"
operator|,
name|_traceattr
argument_list|(
name|win
operator|->
name|_attrs
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
return|return
name|OK
return|;
block|}
end_function

begin_function
name|int
name|wattroff
parameter_list|(
name|WINDOW
modifier|*
name|win
parameter_list|,
name|chtype
name|at
parameter_list|)
block|{
define|#
directive|define
name|IGNORE_COLOR_OFF
value|FALSE
name|T
argument_list|(
operator|(
literal|"wattroff(%x,%s) current = %s"
operator|,
name|win
operator|,
name|_traceattr
argument_list|(
name|at
argument_list|)
operator|,
name|_traceattr
argument_list|(
name|win
operator|->
name|_attrs
argument_list|)
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|IGNORE_COLOR_OFF
operator|==
name|TRUE
condition|)
block|{
if|if
condition|(
name|PAIR_NUMBER
argument_list|(
name|at
argument_list|)
operator|==
literal|0xff
condition|)
comment|/* turn off color */
name|win
operator|->
name|_attrs
operator|&=
operator|~
name|at
expr_stmt|;
else|else
comment|/* leave color alone */
name|win
operator|->
name|_attrs
operator|&=
operator|~
operator|(
name|at
operator|&
operator|~
name|A_COLOR
operator|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|PAIR_NUMBER
argument_list|(
name|at
argument_list|)
operator|>
literal|0x00
condition|)
comment|/* turn off color */
name|win
operator|->
name|_attrs
operator|&=
operator|~
name|at
expr_stmt|;
else|else
comment|/* leave color alone */
name|win
operator|->
name|_attrs
operator|&=
operator|~
operator|(
name|at
operator|&
operator|~
name|A_COLOR
operator|)
expr_stmt|;
block|}
name|T
argument_list|(
operator|(
literal|"new attribute is %s"
operator|,
name|_traceattr
argument_list|(
name|win
operator|->
name|_attrs
argument_list|)
operator|)
argument_list|)
expr_stmt|;
return|return
name|OK
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|MYTINFO
end_ifndef

begin_function
name|int
name|reset_prog_mode
parameter_list|()
block|{
name|T
argument_list|(
operator|(
literal|"reset_prog_mode() called"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TERMIOS
name|tcsetattr
argument_list|(
name|cur_term
operator|->
name|Filedes
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|cur_term
operator|->
name|Nttyb
argument_list|)
expr_stmt|;
else|#
directive|else
name|stty
argument_list|(
name|cur_term
operator|->
name|Filedes
argument_list|,
operator|&
name|cur_term
operator|->
name|Nttyb
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|OK
return|;
block|}
end_function

begin_function
name|int
name|reset_shell_mode
parameter_list|()
block|{
name|T
argument_list|(
operator|(
literal|"reset_shell_mode() called"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TERMIOS
name|tcsetattr
argument_list|(
name|cur_term
operator|->
name|Filedes
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|cur_term
operator|->
name|Ottyb
argument_list|)
expr_stmt|;
else|#
directive|else
name|stty
argument_list|(
name|cur_term
operator|->
name|Filedes
argument_list|,
operator|&
name|cur_term
operator|->
name|Ottyb
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|OK
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|curs_set
parameter_list|(
name|int
name|vis
parameter_list|)
block|{
name|int
name|cursor
init|=
name|SP
operator|->
name|_cursor
decl_stmt|;
name|T
argument_list|(
operator|(
literal|"curs_set(%d)"
operator|,
name|vis
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vis
operator|<
literal|0
operator|||
name|vis
operator|>
literal|2
condition|)
return|return
name|ERR
return|;
switch|switch
condition|(
name|vis
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
name|cursor_visible
condition|)
name|putp
argument_list|(
name|cursor_visible
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
if|if
condition|(
name|cursor_normal
condition|)
name|putp
argument_list|(
name|cursor_normal
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
if|if
condition|(
name|cursor_invisible
condition|)
name|putp
argument_list|(
name|cursor_invisible
argument_list|)
expr_stmt|;
break|break;
block|}
name|SP
operator|->
name|_cursor
operator|=
name|vis
expr_stmt|;
return|return
name|cursor
return|;
block|}
end_function

begin_function
name|int
name|delay_output
parameter_list|(
name|int
name|ms
parameter_list|)
block|{
name|int
name|speed
decl_stmt|;
name|T
argument_list|(
operator|(
literal|"delay_output(%d) called"
operator|,
name|ms
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|no_pad_char
operator|&&
operator|(
name|speed
operator|=
name|baudrate
argument_list|()
operator|)
operator|==
name|ERR
condition|)
return|return
operator|(
name|ERR
operator|)
return|;
else|else
block|{
specifier|register
name|int
name|nullcount
decl_stmt|;
if|if
condition|(
operator|!
name|no_pad_char
condition|)
for|for
control|(
name|nullcount
operator|=
name|ms
operator|*
literal|1000
operator|/
name|speed
init|;
name|nullcount
operator|>
literal|0
condition|;
name|nullcount
operator|--
control|)
name|putc
argument_list|(
operator|*
name|pad_char
argument_list|,
name|SP
operator|->
name|_ofp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|SP
operator|->
name|_ofp
argument_list|)
expr_stmt|;
if|if
condition|(
name|no_pad_char
condition|)
name|napms
argument_list|(
name|ms
argument_list|)
expr_stmt|;
block|}
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*  *	erasechar()  *  *	Return erase character as given in cur_term->Ottyb.  *  */
end_comment

begin_function
name|char
name|erasechar
parameter_list|()
block|{
name|T
argument_list|(
operator|(
literal|"erasechar() called"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TERMIOS
return|return
operator|(
name|cur_term
operator|->
name|Ottyb
operator|.
name|c_cc
index|[
name|VERASE
index|]
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|cur_term
operator|->
name|Ottyb
operator|.
name|sg_erase
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *	killchar()  *  *	Return kill character as given in cur_term->Ottyb.  *  */
end_comment

begin_function
name|char
name|killchar
parameter_list|()
block|{
name|T
argument_list|(
operator|(
literal|"killchar() called"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TERMIOS
return|return
operator|(
name|cur_term
operator|->
name|Ottyb
operator|.
name|c_cc
index|[
name|VKILL
index|]
operator|)
return|;
else|#
directive|else
return|return
operator|(
name|cur_term
operator|->
name|Ottyb
operator|.
name|sg_kill
operator|)
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  *	flushinp()  *  *	Flush any input on cur_term->Filedes  *  */
end_comment

begin_function
name|int
name|flushinp
parameter_list|()
block|{
name|T
argument_list|(
operator|(
literal|"flushinp() called"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TERMIOS
name|tcflush
argument_list|(
name|cur_term
operator|->
name|Filedes
argument_list|,
name|TCIFLUSH
argument_list|)
expr_stmt|;
else|#
directive|else
name|ioctl
argument_list|(
name|cur_term
operator|->
name|Filedes
argument_list|,
name|TIOCFLUSH
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|SP
condition|)
block|{
name|SP
operator|->
name|_fifohead
operator|=
operator|-
literal|1
expr_stmt|;
name|SP
operator|->
name|_fifotail
operator|=
literal|0
expr_stmt|;
name|SP
operator|->
name|_fifopeek
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|OK
return|;
block|}
end_function

begin_comment
comment|/*  *	int  *	baudrate()  *  *	Returns the current terminal's baud rate.  *  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|TERMIOS
end_ifndef

begin_struct
struct|struct
name|speed
block|{
name|speed_t
name|s
decl_stmt|;
name|int
name|sp
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|speed
name|speeds
index|[]
init|=
block|{
block|{
name|B0
block|,
literal|0
block|}
block|,
block|{
name|B50
block|,
literal|50
block|}
block|,
block|{
name|B75
block|,
literal|75
block|}
block|,
block|{
name|B110
block|,
literal|110
block|}
block|,
block|{
name|B134
block|,
literal|134
block|}
block|,
block|{
name|B150
block|,
literal|150
block|}
block|,
block|{
name|B200
block|,
literal|200
block|}
block|,
block|{
name|B300
block|,
literal|300
block|}
block|,
block|{
name|B600
block|,
literal|600
block|}
block|,
block|{
name|B1200
block|,
literal|1200
block|}
block|,
block|{
name|B1800
block|,
literal|1800
block|}
block|,
block|{
name|B2400
block|,
literal|2400
block|}
block|,
block|{
name|B4800
block|,
literal|4800
block|}
block|,
block|{
name|B9600
block|,
literal|9600
block|}
define|#
directive|define
name|MAX_BAUD
value|B9600
ifdef|#
directive|ifdef
name|B19200
undef|#
directive|undef
name|MAX_BAUD
define|#
directive|define
name|MAX_BAUD
value|B19200
block|,
block|{
name|B19200
block|,
literal|19200
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B38400
undef|#
directive|undef
name|MAX_BAUD
define|#
directive|define
name|MAX_BAUD
value|B38400
block|,
block|{
name|B38400
block|,
literal|38400
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B57600
undef|#
directive|undef
name|MAX_BAUD
define|#
directive|define
name|MAX_BAUD
value|B57600
block|,
block|{
name|B57600
block|,
literal|57600
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|B115200
undef|#
directive|undef
name|MAX_BAUD
define|#
directive|define
name|MAX_BAUD
value|B115200
block|,
block|{
name|B115200
block|,
literal|115200
block|}
endif|#
directive|endif
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|baudrate
parameter_list|()
block|{
ifndef|#
directive|ifndef
name|TERMIOS
name|int
name|i
decl_stmt|,
name|ret
decl_stmt|;
endif|#
directive|endif
name|T
argument_list|(
operator|(
literal|"baudrate() called"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TERMIOS
return|return
name|cfgetospeed
argument_list|(
operator|&
name|cur_term
operator|->
name|Nttyb
argument_list|)
return|;
else|#
directive|else
name|ret
operator|=
name|cur_term
operator|->
name|Nttyb
operator|.
name|sg_ospeed
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
operator|||
name|ret
operator|>
name|MAX_BAUD
condition|)
return|return
name|ERR
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
sizeof|sizeof
argument_list|(
name|speeds
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|speed
argument_list|)
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|speeds
index|[
name|i
index|]
operator|.
name|s
operator|==
name|ret
condition|)
return|return
name|speeds
index|[
name|i
index|]
operator|.
name|sp
return|;
return|return
name|ERR
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* **	savetty()  and  resetty() ** */
end_comment

begin_decl_stmt
specifier|static
name|TTY
name|buf
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|savetty
parameter_list|()
block|{
name|T
argument_list|(
operator|(
literal|"savetty() called"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TERMIOS
name|tcgetattr
argument_list|(
name|cur_term
operator|->
name|Filedes
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
else|#
directive|else
name|gtty
argument_list|(
name|cur_term
operator|->
name|Filedes
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|OK
return|;
block|}
end_function

begin_function
name|int
name|resetty
parameter_list|()
block|{
name|T
argument_list|(
operator|(
literal|"resetty() called"
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TERMIOS
name|tcsetattr
argument_list|(
name|cur_term
operator|->
name|Filedes
argument_list|,
name|TCSANOW
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
else|#
directive|else
name|stty
argument_list|(
name|cur_term
operator|->
name|Filedes
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|OK
return|;
block|}
end_function

begin_function
name|int
name|resizeterm
parameter_list|(
name|int
name|ToLines
parameter_list|,
name|int
name|ToCols
parameter_list|)
block|{
return|return
name|OK
return|;
block|}
end_function

end_unit

