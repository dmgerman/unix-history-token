begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===- lld/Core/Parallel.h - Parallel utilities ---------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                             The LLVM Linker
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLD_CORE_PARALLEL_H
end_ifndef

begin_define
define|#
directive|define
name|LLD_CORE_PARALLEL_H
end_define

begin_include
include|#
directive|include
file|"lld/Core/Instrumentation.h"
end_include

begin_include
include|#
directive|include
file|"lld/Core/LLVM.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/MathExtras.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/thread.h"
end_include

begin_include
include|#
directive|include
file|<algorithm>
end_include

begin_include
include|#
directive|include
file|<atomic>
end_include

begin_include
include|#
directive|include
file|<condition_variable>
end_include

begin_include
include|#
directive|include
file|<mutex>
end_include

begin_include
include|#
directive|include
file|<stack>
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
operator|&&
name|LLVM_ENABLE_THREADS
end_if

begin_include
include|#
directive|include
file|<concrt.h>
end_include

begin_include
include|#
directive|include
file|<ppl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|namespace
name|lld
block|{
comment|/// \brief Allows one or more threads to wait on a potentially unknown number of
comment|///   events.
comment|///
comment|/// A latch starts at \p count. inc() increments this, and dec() decrements it.
comment|/// All calls to sync() will block while the count is not 0.
comment|///
comment|/// Calling dec() on a Latch with a count of 0 has undefined behaivor.
name|class
name|Latch
block|{
name|uint32_t
name|_count
decl_stmt|;
name|mutable
name|std
operator|::
name|mutex
name|_condMut
expr_stmt|;
name|mutable
name|std
operator|::
name|condition_variable
name|_cond
expr_stmt|;
name|public
label|:
name|explicit
name|Latch
argument_list|(
argument|uint32_t count =
literal|0
argument_list|)
block|:
name|_count
argument_list|(
argument|count
argument_list|)
block|{}
operator|~
name|Latch
argument_list|()
block|{
name|sync
argument_list|()
block|; }
name|void
name|inc
argument_list|()
block|{
name|std
operator|::
name|unique_lock
operator|<
name|std
operator|::
name|mutex
operator|>
name|lock
argument_list|(
name|_condMut
argument_list|)
block|;
operator|++
name|_count
block|;   }
name|void
name|dec
argument_list|()
block|{
name|std
operator|::
name|unique_lock
operator|<
name|std
operator|::
name|mutex
operator|>
name|lock
argument_list|(
name|_condMut
argument_list|)
block|;
if|if
condition|(
operator|--
name|_count
operator|==
literal|0
condition|)
name|_cond
operator|.
name|notify_all
argument_list|()
expr_stmt|;
block|}
name|void
name|sync
argument_list|()
specifier|const
block|{
name|std
operator|::
name|unique_lock
operator|<
name|std
operator|::
name|mutex
operator|>
name|lock
argument_list|(
name|_condMut
argument_list|)
block|;
name|_cond
operator|.
name|wait
argument_list|(
name|lock
argument_list|,
index|[
operator|&
index|]
block|{
return|return
name|_count
operator|==
literal|0
return|;
block|}
argument_list|)
block|;   }
block|}
empty_stmt|;
comment|// Classes in this namespace are implementation details of this header.
name|namespace
name|internal
block|{
comment|/// \brief An abstract class that takes closures and runs them asynchronously.
name|class
name|Executor
block|{
name|public
label|:
name|virtual
operator|~
name|Executor
argument_list|()
operator|=
expr|default
expr_stmt|;
name|virtual
name|void
name|add
argument_list|(
name|std
operator|::
name|function
operator|<
name|void
argument_list|()
operator|>
name|func
argument_list|)
init|=
literal|0
decl_stmt|;
block|}
empty_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LLVM_ENABLE_THREADS
argument_list|)
operator|||
name|LLVM_ENABLE_THREADS
operator|==
literal|0
name|class
name|SyncExecutor
range|:
name|public
name|Executor
block|{
name|public
operator|:
name|virtual
name|void
name|add
argument_list|(
argument|std::function<void()> func
argument_list|)
block|{
name|func
argument_list|()
block|;   }
block|}
decl_stmt|;
specifier|inline
name|Executor
modifier|*
name|getDefaultExecutor
parameter_list|()
block|{
specifier|static
name|SyncExecutor
name|exec
decl_stmt|;
return|return
operator|&
name|exec
return|;
block|}
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
comment|/// \brief An Executor that runs tasks via ConcRT.
name|class
name|ConcRTExecutor
range|:
name|public
name|Executor
block|{   struct
name|Taskish
block|{
name|Taskish
argument_list|(
name|std
operator|::
name|function
operator|<
name|void
argument_list|()
operator|>
name|task
argument_list|)
operator|:
name|_task
argument_list|(
argument|task
argument_list|)
block|{}
name|std
operator|::
name|function
operator|<
name|void
argument_list|()
operator|>
name|_task
block|;
specifier|static
name|void
name|run
argument_list|(
argument|void *p
argument_list|)
block|{
name|Taskish
operator|*
name|self
operator|=
name|static_cast
operator|<
name|Taskish
operator|*
operator|>
operator|(
name|p
operator|)
block|;
name|self
operator|->
name|_task
argument_list|()
block|;
name|concurrency
operator|::
name|Free
argument_list|(
name|self
argument_list|)
block|;     }
block|}
block|;
name|public
operator|:
name|virtual
name|void
name|add
argument_list|(
argument|std::function<void()> func
argument_list|)
block|{
name|Concurrency
operator|::
name|CurrentScheduler
operator|::
name|ScheduleTask
argument_list|(
name|Taskish
operator|::
name|run
argument_list|,
name|new
argument_list|(
argument|concurrency::Alloc(sizeof(Taskish))
argument_list|)
name|Taskish
argument_list|(
name|func
argument_list|)
argument_list|)
block|;   }
block|}
decl_stmt|;
specifier|inline
name|Executor
modifier|*
name|getDefaultExecutor
parameter_list|()
block|{
specifier|static
name|ConcRTExecutor
name|exec
decl_stmt|;
return|return
operator|&
name|exec
return|;
block|}
else|#
directive|else
comment|/// \brief An implementation of an Executor that runs closures on a thread pool
comment|///   in filo order.
name|class
name|ThreadPoolExecutor
range|:
name|public
name|Executor
block|{
name|public
operator|:
name|explicit
name|ThreadPoolExecutor
argument_list|(
argument|unsigned threadCount =                                   std::thread::hardware_concurrency()
argument_list|)
operator|:
name|_stop
argument_list|(
name|false
argument_list|)
block|,
name|_done
argument_list|(
argument|threadCount
argument_list|)
block|{
comment|// Spawn all but one of the threads in another thread as spawning threads
comment|// can take a while.
name|std
operator|::
name|thread
argument_list|(
index|[
operator|&
operator|,
name|threadCount
index|]
block|{
for|for
control|(
name|size_t
name|i
init|=
literal|1
init|;
name|i
operator|<
name|threadCount
condition|;
operator|++
name|i
control|)
block|{
name|std
operator|::
name|thread
argument_list|(
index|[
operator|=
index|]
block|{
name|work
argument_list|()
block|;         }
argument_list|)
operator|.
name|detach
argument_list|()
expr_stmt|;
block|}
name|work
argument_list|()
expr_stmt|;
block|}
argument_list|)
operator|.
name|detach
argument_list|()
block|;   }
operator|~
name|ThreadPoolExecutor
argument_list|()
name|override
block|{
name|std
operator|::
name|unique_lock
operator|<
name|std
operator|::
name|mutex
operator|>
name|lock
argument_list|(
name|_mutex
argument_list|)
block|;
name|_stop
operator|=
name|true
block|;
name|lock
operator|.
name|unlock
argument_list|()
block|;
name|_cond
operator|.
name|notify_all
argument_list|()
block|;
comment|// Wait for ~Latch.
block|}
name|void
name|add
argument_list|(
argument|std::function<void()> f
argument_list|)
name|override
block|{
name|std
operator|::
name|unique_lock
operator|<
name|std
operator|::
name|mutex
operator|>
name|lock
argument_list|(
name|_mutex
argument_list|)
block|;
name|_workStack
operator|.
name|push
argument_list|(
name|f
argument_list|)
block|;
name|lock
operator|.
name|unlock
argument_list|()
block|;
name|_cond
operator|.
name|notify_one
argument_list|()
block|;   }
name|private
operator|:
name|void
name|work
argument_list|()
block|{
while|while
condition|(
name|true
condition|)
block|{
name|std
operator|::
name|unique_lock
operator|<
name|std
operator|::
name|mutex
operator|>
name|lock
argument_list|(
name|_mutex
argument_list|)
expr_stmt|;
name|_cond
operator|.
name|wait
argument_list|(
name|lock
argument_list|,
index|[
operator|&
index|]
block|{
return|return
name|_stop
operator|||
operator|!
name|_workStack
operator|.
name|empty
argument_list|()
return|;
block|}
argument_list|)
expr_stmt|;
if|if
condition|(
name|_stop
condition|)
break|break;
name|auto
name|task
init|=
name|_workStack
operator|.
name|top
argument_list|()
decl_stmt|;
name|_workStack
operator|.
name|pop
argument_list|()
expr_stmt|;
name|lock
operator|.
name|unlock
argument_list|()
expr_stmt|;
name|task
argument_list|()
expr_stmt|;
block|}
name|_done
operator|.
name|dec
argument_list|()
expr_stmt|;
block|}
name|std
operator|::
name|atomic
operator|<
name|bool
operator|>
name|_stop
block|;
name|std
operator|::
name|stack
operator|<
name|std
operator|::
name|function
operator|<
name|void
argument_list|()
operator|>>
name|_workStack
block|;
name|std
operator|::
name|mutex
name|_mutex
block|;
name|std
operator|::
name|condition_variable
name|_cond
block|;
name|Latch
name|_done
block|; }
decl_stmt|;
specifier|inline
name|Executor
modifier|*
name|getDefaultExecutor
parameter_list|()
block|{
specifier|static
name|ThreadPoolExecutor
name|exec
decl_stmt|;
return|return
operator|&
name|exec
return|;
block|}
endif|#
directive|endif
block|}
comment|// namespace internal
comment|/// \brief Allows launching a number of tasks and waiting for them to finish
comment|///   either explicitly via sync() or implicitly on destruction.
name|class
name|TaskGroup
block|{
name|Latch
name|_latch
decl_stmt|;
name|public
label|:
name|void
name|spawn
argument_list|(
name|std
operator|::
name|function
operator|<
name|void
argument_list|()
operator|>
name|f
argument_list|)
block|{
name|_latch
operator|.
name|inc
argument_list|()
expr_stmt|;
name|internal
operator|::
name|getDefaultExecutor
argument_list|()
operator|->
name|add
argument_list|(
index|[
operator|&
operator|,
name|f
index|]
block|{
name|f
argument_list|()
block|;
name|_latch
operator|.
name|dec
argument_list|()
block|;     }
argument_list|)
expr_stmt|;
block|}
name|void
name|sync
argument_list|()
specifier|const
block|{
name|_latch
operator|.
name|sync
argument_list|()
block|; }
block|}
empty_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LLVM_ENABLE_THREADS
argument_list|)
operator|||
name|LLVM_ENABLE_THREADS
operator|==
literal|0
name|template
operator|<
name|class
name|RandomAccessIterator
operator|,
name|class
name|Comp
operator|>
name|void
name|parallel_sort
argument_list|(
argument|RandomAccessIterator start
argument_list|,
argument|RandomAccessIterator end
argument_list|,
argument|const Comp&comp = std::less<         typename std::iterator_traits<RandomAccessIterator>::value_type>()
argument_list|)
block|{
name|std
operator|::
name|sort
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|comp
argument_list|)
block|; }
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
comment|// Use ppl parallel_sort on Windows.
name|template
operator|<
name|class
name|RandomAccessIterator
operator|,
name|class
name|Comp
operator|>
name|void
name|parallel_sort
argument_list|(
argument|RandomAccessIterator start
argument_list|,
argument|RandomAccessIterator end
argument_list|,
argument|const Comp&comp = std::less<         typename std::iterator_traits<RandomAccessIterator>::value_type>()
argument_list|)
block|{
name|concurrency
operator|::
name|parallel_sort
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|comp
argument_list|)
block|; }
else|#
directive|else
name|namespace
name|detail
block|{
specifier|const
name|ptrdiff_t
name|minParallelSize
operator|=
literal|1024
block|;
comment|/// \brief Inclusive median.
name|template
operator|<
name|class
name|RandomAccessIterator
block|,
name|class
name|Comp
operator|>
name|RandomAccessIterator
name|medianOf3
argument_list|(
argument|RandomAccessIterator start
argument_list|,
argument|RandomAccessIterator end
argument_list|,
argument|const Comp&comp
argument_list|)
block|{
name|RandomAccessIterator
name|mid
operator|=
name|start
operator|+
operator|(
name|std
operator|::
name|distance
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
operator|/
literal|2
operator|)
block|;
return|return
name|comp
argument_list|(
operator|*
name|start
argument_list|,
operator|*
operator|(
name|end
operator|-
literal|1
operator|)
argument_list|)
condition|?
operator|(
name|comp
argument_list|(
operator|*
name|mid
argument_list|,
operator|*
operator|(
name|end
operator|-
literal|1
operator|)
argument_list|)
condition|?
operator|(
name|comp
argument_list|(
operator|*
name|start
argument_list|,
operator|*
name|mid
argument_list|)
condition|?
name|mid
else|:
name|start
operator|)
else|:
name|end
operator|-
literal|1
operator|)
else|:
operator|(
name|comp
argument_list|(
operator|*
name|mid
argument_list|,
operator|*
name|start
argument_list|)
condition|?
operator|(
name|comp
argument_list|(
operator|*
operator|(
name|end
operator|-
literal|1
operator|)
argument_list|,
operator|*
name|mid
argument_list|)
condition|?
name|mid
else|:
name|end
operator|-
literal|1
operator|)
else|:
name|start
operator|)
return|;
block|}
name|template
operator|<
name|class
name|RandomAccessIterator
block|,
name|class
name|Comp
operator|>
name|void
name|parallel_quick_sort
argument_list|(
argument|RandomAccessIterator start
argument_list|,
argument|RandomAccessIterator end
argument_list|,
argument|const Comp&comp
argument_list|,
argument|TaskGroup&tg
argument_list|,
argument|size_t depth
argument_list|)
block|{
comment|// Do a sequential sort for small inputs.
if|if
condition|(
name|std
operator|::
name|distance
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
operator|<
name|detail
operator|::
name|minParallelSize
operator|||
name|depth
operator|==
literal|0
condition|)
block|{
name|std
operator|::
name|sort
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|comp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|// Partition.
name|auto
name|pivot
init|=
name|medianOf3
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|comp
argument_list|)
decl_stmt|;
comment|// Move pivot to end.
name|std
operator|::
name|swap
argument_list|(
operator|*
operator|(
name|end
operator|-
literal|1
operator|)
argument_list|,
operator|*
name|pivot
argument_list|)
block|;
name|pivot
operator|=
name|std
operator|::
name|partition
argument_list|(
name|start
argument_list|,
name|end
operator|-
literal|1
argument_list|,
index|[
operator|&
name|comp
operator|,
name|end
index|]
operator|(
name|decltype
argument_list|(
argument|*start
argument_list|)
name|v
operator|)
block|{
return|return
name|comp
argument_list|(
name|v
argument_list|,
operator|*
operator|(
name|end
operator|-
literal|1
operator|)
argument_list|)
return|;
block|}
argument_list|)
block|;
comment|// Move pivot to middle of partition.
name|std
operator|::
name|swap
argument_list|(
operator|*
name|pivot
argument_list|,
operator|*
operator|(
name|end
operator|-
literal|1
operator|)
argument_list|)
block|;
comment|// Recurse.
name|tg
operator|.
name|spawn
argument_list|(
index|[
operator|=
operator|,
operator|&
name|comp
operator|,
operator|&
name|tg
index|]
block|{
name|parallel_quick_sort
argument_list|(
name|start
argument_list|,
name|pivot
argument_list|,
name|comp
argument_list|,
name|tg
argument_list|,
name|depth
operator|-
literal|1
argument_list|)
block|;   }
argument_list|)
block|;
name|parallel_quick_sort
argument_list|(
name|pivot
operator|+
literal|1
argument_list|,
name|end
argument_list|,
name|comp
argument_list|,
name|tg
argument_list|,
name|depth
operator|-
literal|1
argument_list|)
block|; }
block|}
end_decl_stmt

begin_expr_stmt
name|template
operator|<
name|class
name|RandomAccessIterator
operator|,
name|class
name|Comp
operator|>
name|void
name|parallel_sort
argument_list|(
argument|RandomAccessIterator start
argument_list|,
argument|RandomAccessIterator end
argument_list|,
argument|const Comp&comp = std::less<         typename std::iterator_traits<RandomAccessIterator>::value_type>()
argument_list|)
block|{
name|TaskGroup
name|tg
block|;
name|detail
operator|::
name|parallel_quick_sort
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|comp
argument_list|,
name|tg
argument_list|,
name|llvm
operator|::
name|Log2_64
argument_list|(
name|std
operator|::
name|distance
argument_list|(
name|start
argument_list|,
name|end
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
block|; }
endif|#
directive|endif
name|template
operator|<
name|class
name|T
operator|>
name|void
name|parallel_sort
argument_list|(
argument|T *start
argument_list|,
argument|T *end
argument_list|)
block|{
name|parallel_sort
argument_list|(
name|start
argument_list|,
name|end
argument_list|,
name|std
operator|::
name|less
operator|<
name|T
operator|>
operator|(
operator|)
argument_list|)
block|; }
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LLVM_ENABLE_THREADS
argument_list|)
operator|||
name|LLVM_ENABLE_THREADS
operator|==
literal|0
name|template
operator|<
name|class
name|IterTy
operator|,
name|class
name|FuncTy
operator|>
name|void
name|parallel_for_each
argument_list|(
argument|IterTy Begin
argument_list|,
argument|IterTy End
argument_list|,
argument|FuncTy Fn
argument_list|)
block|{
name|std
operator|::
name|for_each
argument_list|(
name|Begin
argument_list|,
name|End
argument_list|,
name|Fn
argument_list|)
block|; }
name|template
operator|<
name|class
name|IndexTy
operator|,
name|class
name|FuncTy
operator|>
name|void
name|parallel_for
argument_list|(
argument|IndexTy Begin
argument_list|,
argument|IndexTy End
argument_list|,
argument|FuncTy Fn
argument_list|)
block|{
for|for
control|(
name|IndexTy
name|I
init|=
name|Begin
init|;
name|I
operator|!=
name|End
condition|;
operator|++
name|I
control|)
name|Fn
argument_list|(
name|I
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|_MSC_VER
argument_list|)
end_elif

begin_comment
comment|// Use ppl parallel_for_each on Windows.
end_comment

begin_expr_stmt
name|template
operator|<
name|class
name|IterTy
operator|,
name|class
name|FuncTy
operator|>
name|void
name|parallel_for_each
argument_list|(
argument|IterTy Begin
argument_list|,
argument|IterTy End
argument_list|,
argument|FuncTy Fn
argument_list|)
block|{
name|concurrency
operator|::
name|parallel_for_each
argument_list|(
name|Begin
argument_list|,
name|End
argument_list|,
name|Fn
argument_list|)
block|; }
name|template
operator|<
name|class
name|IndexTy
operator|,
name|class
name|FuncTy
operator|>
name|void
name|parallel_for
argument_list|(
argument|IndexTy Begin
argument_list|,
argument|IndexTy End
argument_list|,
argument|FuncTy Fn
argument_list|)
block|{
name|concurrency
operator|::
name|parallel_for
argument_list|(
name|Begin
argument_list|,
name|End
argument_list|,
name|Fn
argument_list|)
block|; }
else|#
directive|else
name|template
operator|<
name|class
name|IterTy
operator|,
name|class
name|FuncTy
operator|>
name|void
name|parallel_for_each
argument_list|(
argument|IterTy Begin
argument_list|,
argument|IterTy End
argument_list|,
argument|FuncTy Fn
argument_list|)
block|{
comment|// TaskGroup has a relatively high overhead, so we want to reduce
comment|// the number of spawn() calls. We'll create up to 1024 tasks here.
comment|// (Note that 1024 is an arbitrary number. This code probably needs
comment|// improving to take the number of available cores into account.)
name|ptrdiff_t
name|TaskSize
operator|=
name|std
operator|::
name|distance
argument_list|(
name|Begin
argument_list|,
name|End
argument_list|)
operator|/
literal|1024
block|;
if|if
condition|(
name|TaskSize
operator|==
literal|0
condition|)
name|TaskSize
operator|=
literal|1
expr_stmt|;
name|TaskGroup
name|Tg
expr_stmt|;
end_expr_stmt

begin_while
while|while
condition|(
name|TaskSize
operator|<=
name|std
operator|::
name|distance
argument_list|(
name|Begin
argument_list|,
name|End
argument_list|)
condition|)
block|{
name|Tg
operator|.
name|spawn
argument_list|(
index|[
operator|=
operator|,
operator|&
name|Fn
index|]
block|{
name|std
operator|::
name|for_each
argument_list|(
name|Begin
argument_list|,
name|Begin
operator|+
name|TaskSize
argument_list|,
name|Fn
argument_list|)
block|; }
argument_list|)
expr_stmt|;
name|Begin
operator|+=
name|TaskSize
expr_stmt|;
block|}
end_while

begin_expr_stmt
name|Tg
operator|.
name|spawn
argument_list|(
index|[
operator|=
operator|,
operator|&
name|Fn
index|]
block|{
name|std
operator|::
name|for_each
argument_list|(
name|Begin
argument_list|,
name|End
argument_list|,
name|Fn
argument_list|)
block|; }
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}  template
operator|<
name|class
name|IndexTy
operator|,
name|class
name|FuncTy
operator|>
name|void
name|parallel_for
argument_list|(
argument|IndexTy Begin
argument_list|,
argument|IndexTy End
argument_list|,
argument|FuncTy Fn
argument_list|)
block|{
name|ptrdiff_t
name|TaskSize
operator|=
operator|(
name|End
operator|-
name|Begin
operator|)
operator|/
literal|1024
block|;
if|if
condition|(
name|TaskSize
operator|==
literal|0
condition|)
name|TaskSize
operator|=
literal|1
expr_stmt|;
name|TaskGroup
name|Tg
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|IndexTy
name|I
init|=
name|Begin
decl_stmt|;
end_decl_stmt

begin_for
for|for
control|(
init|;
name|I
operator|+
name|TaskSize
operator|<
name|End
condition|;
name|I
operator|+=
name|TaskSize
control|)
block|{
name|Tg
operator|.
name|spawn
argument_list|(
index|[
operator|=
operator|,
operator|&
name|Fn
index|]
block|{
for|for
control|(
name|IndexTy
name|J
init|=
name|I
init|,
name|E
init|=
name|I
operator|+
name|TaskSize
init|;
name|J
operator|!=
name|E
condition|;
operator|++
name|J
control|)
name|Fn
argument_list|(
name|J
argument_list|)
expr_stmt|;
block|}
block|)
empty_stmt|;
end_for

begin_expr_stmt
unit|}   Tg
operator|.
name|spawn
argument_list|(
index|[
operator|=
operator|,
operator|&
name|Fn
index|]
block|{
for|for
control|(
name|IndexTy
name|J
init|=
name|I
init|;
name|J
operator|<
name|End
condition|;
operator|++
name|J
control|)
name|Fn
argument_list|(
name|J
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_endif
unit|}
endif|#
directive|endif
end_endif

begin_comment
unit|}
comment|// end namespace lld
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|// LLD_CORE_PARALLEL_H
end_comment

end_unit

