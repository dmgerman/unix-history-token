begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- Parser.h - C Language Parser ---------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file defines the Parser interface.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_PARSE_PARSER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_PARSE_PARSER_H
end_define

begin_include
include|#
directive|include
file|"clang/AST/Availability.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/OpenMPKinds.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/OperatorPrecedence.h"
end_include

begin_include
include|#
directive|include
file|"clang/Basic/Specifiers.h"
end_include

begin_include
include|#
directive|include
file|"clang/Lex/CodeCompletionHandler.h"
end_include

begin_include
include|#
directive|include
file|"clang/Lex/Preprocessor.h"
end_include

begin_include
include|#
directive|include
file|"clang/Sema/DeclSpec.h"
end_include

begin_include
include|#
directive|include
file|"clang/Sema/LoopHint.h"
end_include

begin_include
include|#
directive|include
file|"clang/Sema/Sema.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Compiler.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/PrettyStackTrace.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/SaveAndRestore.h"
end_include

begin_include
include|#
directive|include
file|<memory>
end_include

begin_include
include|#
directive|include
file|<stack>
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|PragmaHandler
decl_stmt|;
name|class
name|Scope
decl_stmt|;
name|class
name|BalancedDelimiterTracker
decl_stmt|;
name|class
name|CorrectionCandidateCallback
decl_stmt|;
name|class
name|DeclGroupRef
decl_stmt|;
name|class
name|DiagnosticBuilder
decl_stmt|;
name|class
name|Parser
decl_stmt|;
name|class
name|ParsingDeclRAIIObject
decl_stmt|;
name|class
name|ParsingDeclSpec
decl_stmt|;
name|class
name|ParsingDeclarator
decl_stmt|;
name|class
name|ParsingFieldDeclarator
decl_stmt|;
name|class
name|ColonProtectionRAIIObject
decl_stmt|;
name|class
name|InMessageExpressionRAIIObject
decl_stmt|;
name|class
name|PoisonSEHIdentifiersRAIIObject
decl_stmt|;
name|class
name|VersionTuple
decl_stmt|;
name|class
name|OMPClause
decl_stmt|;
name|class
name|ObjCTypeParamList
decl_stmt|;
name|class
name|ObjCTypeParameter
decl_stmt|;
comment|/// Parser - This implements a parser for the C family of languages.  After
comment|/// parsing units of the grammar, productions are invoked to handle whatever has
comment|/// been read.
comment|///
name|class
name|Parser
range|:
name|public
name|CodeCompletionHandler
block|{
name|friend
name|class
name|ColonProtectionRAIIObject
block|;
name|friend
name|class
name|InMessageExpressionRAIIObject
block|;
name|friend
name|class
name|PoisonSEHIdentifiersRAIIObject
block|;
name|friend
name|class
name|ObjCDeclContextSwitch
block|;
name|friend
name|class
name|ParenBraceBracketBalancer
block|;
name|friend
name|class
name|BalancedDelimiterTracker
block|;
name|Preprocessor
operator|&
name|PP
block|;
comment|/// Tok - The current token we are peeking ahead.  All parsing methods assume
comment|/// that this is valid.
name|Token
name|Tok
block|;
comment|// PrevTokLocation - The location of the token we previously
comment|// consumed. This token is used for diagnostics where we expected to
comment|// see a token following another token (e.g., the ';' at the end of
comment|// a statement).
name|SourceLocation
name|PrevTokLocation
block|;
name|unsigned
name|short
name|ParenCount
operator|=
literal|0
block|,
name|BracketCount
operator|=
literal|0
block|,
name|BraceCount
operator|=
literal|0
block|;
name|unsigned
name|short
name|MisplacedModuleBeginCount
operator|=
literal|0
block|;
comment|/// Actions - These are the callbacks we invoke as we parse various constructs
comment|/// in the file.
name|Sema
operator|&
name|Actions
block|;
name|DiagnosticsEngine
operator|&
name|Diags
block|;
comment|/// ScopeCache - Cache scopes to reduce malloc traffic.
block|enum
block|{
name|ScopeCacheSize
operator|=
literal|16
block|}
block|;
name|unsigned
name|NumCachedScopes
block|;
name|Scope
operator|*
name|ScopeCache
index|[
name|ScopeCacheSize
index|]
block|;
comment|/// Identifiers used for SEH handling in Borland. These are only
comment|/// allowed in particular circumstances
comment|// __except block
name|IdentifierInfo
operator|*
name|Ident__exception_code
block|,
operator|*
name|Ident___exception_code
block|,
operator|*
name|Ident_GetExceptionCode
block|;
comment|// __except filter expression
name|IdentifierInfo
operator|*
name|Ident__exception_info
block|,
operator|*
name|Ident___exception_info
block|,
operator|*
name|Ident_GetExceptionInfo
block|;
comment|// __finally
name|IdentifierInfo
operator|*
name|Ident__abnormal_termination
block|,
operator|*
name|Ident___abnormal_termination
block|,
operator|*
name|Ident_AbnormalTermination
block|;
comment|/// Contextual keywords for Microsoft extensions.
name|IdentifierInfo
operator|*
name|Ident__except
block|;
name|mutable
name|IdentifierInfo
operator|*
name|Ident_sealed
block|;
comment|/// Ident_super - IdentifierInfo for "super", to support fast
comment|/// comparison.
name|IdentifierInfo
operator|*
name|Ident_super
block|;
comment|/// Ident_vector, Ident_bool - cached IdentifierInfos for "vector" and
comment|/// "bool" fast comparison.  Only present if AltiVec or ZVector are enabled.
name|IdentifierInfo
operator|*
name|Ident_vector
block|;
name|IdentifierInfo
operator|*
name|Ident_bool
block|;
comment|/// Ident_pixel - cached IdentifierInfos for "pixel" fast comparison.
comment|/// Only present if AltiVec enabled.
name|IdentifierInfo
operator|*
name|Ident_pixel
block|;
comment|/// Objective-C contextual keywords.
name|mutable
name|IdentifierInfo
operator|*
name|Ident_instancetype
block|;
comment|/// \brief Identifier for "introduced".
name|IdentifierInfo
operator|*
name|Ident_introduced
block|;
comment|/// \brief Identifier for "deprecated".
name|IdentifierInfo
operator|*
name|Ident_deprecated
block|;
comment|/// \brief Identifier for "obsoleted".
name|IdentifierInfo
operator|*
name|Ident_obsoleted
block|;
comment|/// \brief Identifier for "unavailable".
name|IdentifierInfo
operator|*
name|Ident_unavailable
block|;
comment|/// \brief Identifier for "message".
name|IdentifierInfo
operator|*
name|Ident_message
block|;
comment|/// \brief Identifier for "strict".
name|IdentifierInfo
operator|*
name|Ident_strict
block|;
comment|/// \brief Identifier for "replacement".
name|IdentifierInfo
operator|*
name|Ident_replacement
block|;
comment|/// C++0x contextual keywords.
name|mutable
name|IdentifierInfo
operator|*
name|Ident_final
block|;
name|mutable
name|IdentifierInfo
operator|*
name|Ident_GNU_final
block|;
name|mutable
name|IdentifierInfo
operator|*
name|Ident_override
block|;
comment|// C++ type trait keywords that can be reverted to identifiers and still be
comment|// used as type traits.
name|llvm
operator|::
name|SmallDenseMap
operator|<
name|IdentifierInfo
operator|*
block|,
name|tok
operator|::
name|TokenKind
operator|>
name|RevertibleTypeTraits
block|;
name|std
operator|::
name|unique_ptr
operator|<
name|PragmaHandler
operator|>
name|AlignHandler
block|;
name|std
operator|::
name|unique_ptr
operator|<
name|PragmaHandler
operator|>
name|GCCVisibilityHandler
block|;
name|std
operator|::
name|unique_ptr
operator|<
name|PragmaHandler
operator|>
name|OptionsHandler
block|;
name|std
operator|::
name|unique_ptr
operator|<
name|PragmaHandler
operator|>
name|PackHandler
block|;
name|std
operator|::
name|unique_ptr
operator|<
name|PragmaHandler
operator|>
name|MSStructHandler
block|;
name|std
operator|::
name|unique_ptr
operator|<
name|PragmaHandler
operator|>
name|UnusedHandler
block|;
name|std
operator|::
name|unique_ptr
operator|<
name|PragmaHandler
operator|>
name|WeakHandler
block|;
name|std
operator|::
name|unique_ptr
operator|<
name|PragmaHandler
operator|>
name|RedefineExtnameHandler
block|;
name|std
operator|::
name|unique_ptr
operator|<
name|PragmaHandler
operator|>
name|FPContractHandler
block|;
name|std
operator|::
name|unique_ptr
operator|<
name|PragmaHandler
operator|>
name|OpenCLExtensionHandler
block|;
name|std
operator|::
name|unique_ptr
operator|<
name|PragmaHandler
operator|>
name|OpenMPHandler
block|;
name|std
operator|::
name|unique_ptr
operator|<
name|PragmaHandler
operator|>
name|MSCommentHandler
block|;
name|std
operator|::
name|unique_ptr
operator|<
name|PragmaHandler
operator|>
name|MSDetectMismatchHandler
block|;
name|std
operator|::
name|unique_ptr
operator|<
name|PragmaHandler
operator|>
name|MSPointersToMembers
block|;
name|std
operator|::
name|unique_ptr
operator|<
name|PragmaHandler
operator|>
name|MSVtorDisp
block|;
name|std
operator|::
name|unique_ptr
operator|<
name|PragmaHandler
operator|>
name|MSInitSeg
block|;
name|std
operator|::
name|unique_ptr
operator|<
name|PragmaHandler
operator|>
name|MSDataSeg
block|;
name|std
operator|::
name|unique_ptr
operator|<
name|PragmaHandler
operator|>
name|MSBSSSeg
block|;
name|std
operator|::
name|unique_ptr
operator|<
name|PragmaHandler
operator|>
name|MSConstSeg
block|;
name|std
operator|::
name|unique_ptr
operator|<
name|PragmaHandler
operator|>
name|MSCodeSeg
block|;
name|std
operator|::
name|unique_ptr
operator|<
name|PragmaHandler
operator|>
name|MSSection
block|;
name|std
operator|::
name|unique_ptr
operator|<
name|PragmaHandler
operator|>
name|MSRuntimeChecks
block|;
name|std
operator|::
name|unique_ptr
operator|<
name|PragmaHandler
operator|>
name|MSIntrinsic
block|;
name|std
operator|::
name|unique_ptr
operator|<
name|PragmaHandler
operator|>
name|CUDAForceHostDeviceHandler
block|;
name|std
operator|::
name|unique_ptr
operator|<
name|PragmaHandler
operator|>
name|OptimizeHandler
block|;
name|std
operator|::
name|unique_ptr
operator|<
name|PragmaHandler
operator|>
name|LoopHintHandler
block|;
name|std
operator|::
name|unique_ptr
operator|<
name|PragmaHandler
operator|>
name|UnrollHintHandler
block|;
name|std
operator|::
name|unique_ptr
operator|<
name|PragmaHandler
operator|>
name|NoUnrollHintHandler
block|;
name|std
operator|::
name|unique_ptr
operator|<
name|CommentHandler
operator|>
name|CommentSemaHandler
block|;
comment|/// Whether the '>' token acts as an operator or not. This will be
comment|/// true except when we are parsing an expression within a C++
comment|/// template argument list, where the '>' closes the template
comment|/// argument list.
name|bool
name|GreaterThanIsOperator
block|;
comment|/// ColonIsSacred - When this is false, we aggressively try to recover from
comment|/// code like "foo : bar" as if it were a typo for "foo :: bar".  This is not
comment|/// safe in case statements and a few other things.  This is managed by the
comment|/// ColonProtectionRAIIObject RAII object.
name|bool
name|ColonIsSacred
block|;
comment|/// \brief When true, we are directly inside an Objective-C message
comment|/// send expression.
comment|///
comment|/// This is managed by the \c InMessageExpressionRAIIObject class, and
comment|/// should not be set directly.
name|bool
name|InMessageExpression
block|;
comment|/// The "depth" of the template parameters currently being parsed.
name|unsigned
name|TemplateParameterDepth
block|;
comment|/// \brief RAII class that manages the template parameter depth.
name|class
name|TemplateParameterDepthRAII
block|{
name|unsigned
operator|&
name|Depth
block|;
name|unsigned
name|AddedLevels
block|;
name|public
operator|:
name|explicit
name|TemplateParameterDepthRAII
argument_list|(
name|unsigned
operator|&
name|Depth
argument_list|)
operator|:
name|Depth
argument_list|(
name|Depth
argument_list|)
block|,
name|AddedLevels
argument_list|(
literal|0
argument_list|)
block|{}
operator|~
name|TemplateParameterDepthRAII
argument_list|()
block|{
name|Depth
operator|-=
name|AddedLevels
block|;     }
name|void
name|operator
operator|++
operator|(
operator|)
block|{
operator|++
name|Depth
block|;
operator|++
name|AddedLevels
block|;     }
name|void
name|addDepth
argument_list|(
argument|unsigned D
argument_list|)
block|{
name|Depth
operator|+=
name|D
block|;
name|AddedLevels
operator|+=
name|D
block|;     }
name|unsigned
name|getDepth
argument_list|()
specifier|const
block|{
return|return
name|Depth
return|;
block|}
expr|}
block|;
comment|/// Factory object for creating AttributeList objects.
name|AttributeFactory
name|AttrFactory
block|;
comment|/// \brief Gathers and cleans up TemplateIdAnnotations when parsing of a
comment|/// top-level declaration is finished.
name|SmallVector
operator|<
name|TemplateIdAnnotation
operator|*
block|,
literal|16
operator|>
name|TemplateIds
block|;
comment|/// \brief Identifiers which have been declared within a tentative parse.
name|SmallVector
operator|<
name|IdentifierInfo
operator|*
block|,
literal|8
operator|>
name|TentativelyDeclaredIdentifiers
block|;
name|IdentifierInfo
operator|*
name|getSEHExceptKeyword
argument_list|()
block|;
comment|/// True if we are within an Objective-C container while parsing C-like decls.
comment|///
comment|/// This is necessary because Sema thinks we have left the container
comment|/// to parse the C-like decls, meaning Actions.getObjCDeclContext() will
comment|/// be NULL.
name|bool
name|ParsingInObjCContainer
block|;
name|bool
name|SkipFunctionBodies
block|;
comment|/// The location of the expression statement that is being parsed right now.
comment|/// Used to determine if an expression that is being parsed is a statement or
comment|/// just a regular sub-expression.
name|SourceLocation
name|ExprStatementTokLoc
block|;
name|public
operator|:
name|Parser
argument_list|(
argument|Preprocessor&PP
argument_list|,
argument|Sema&Actions
argument_list|,
argument|bool SkipFunctionBodies
argument_list|)
block|;
operator|~
name|Parser
argument_list|()
name|override
block|;
specifier|const
name|LangOptions
operator|&
name|getLangOpts
argument_list|()
specifier|const
block|{
return|return
name|PP
operator|.
name|getLangOpts
argument_list|()
return|;
block|}
specifier|const
name|TargetInfo
operator|&
name|getTargetInfo
argument_list|()
specifier|const
block|{
return|return
name|PP
operator|.
name|getTargetInfo
argument_list|()
return|;
block|}
name|Preprocessor
operator|&
name|getPreprocessor
argument_list|()
specifier|const
block|{
return|return
name|PP
return|;
block|}
name|Sema
operator|&
name|getActions
argument_list|()
specifier|const
block|{
return|return
name|Actions
return|;
block|}
name|AttributeFactory
operator|&
name|getAttrFactory
argument_list|()
block|{
return|return
name|AttrFactory
return|;
block|}
specifier|const
name|Token
operator|&
name|getCurToken
argument_list|()
specifier|const
block|{
return|return
name|Tok
return|;
block|}
name|Scope
operator|*
name|getCurScope
argument_list|()
specifier|const
block|{
return|return
name|Actions
operator|.
name|getCurScope
argument_list|()
return|;
block|}
name|void
name|incrementMSManglingNumber
argument_list|()
specifier|const
block|{
return|return
name|Actions
operator|.
name|incrementMSManglingNumber
argument_list|()
return|;
block|}
name|Decl
operator|*
name|getObjCDeclContext
argument_list|()
specifier|const
block|{
return|return
name|Actions
operator|.
name|getObjCDeclContext
argument_list|()
return|;
block|}
comment|// Type forwarding.  All of these are statically 'void*', but they may all be
comment|// different actual classes based on the actions in place.
typedef|typedef
name|OpaquePtr
operator|<
name|DeclGroupRef
operator|>
name|DeclGroupPtrTy
expr_stmt|;
typedef|typedef
name|OpaquePtr
operator|<
name|TemplateName
operator|>
name|TemplateTy
expr_stmt|;
typedef|typedef
name|SmallVector
operator|<
name|TemplateParameterList
operator|*
operator|,
literal|4
operator|>
name|TemplateParameterLists
expr_stmt|;
typedef|typedef
name|Sema
operator|::
name|FullExprArg
name|FullExprArg
expr_stmt|;
comment|// Parsing methods.
comment|/// Initialize - Warm up the parser.
comment|///
name|void
name|Initialize
parameter_list|()
function_decl|;
comment|/// Parse the first top-level declaration in a translation unit.
name|bool
name|ParseFirstTopLevelDecl
parameter_list|(
name|DeclGroupPtrTy
modifier|&
name|Result
parameter_list|)
function_decl|;
comment|/// ParseTopLevelDecl - Parse one top-level declaration. Returns true if
comment|/// the EOF was encountered.
name|bool
name|ParseTopLevelDecl
parameter_list|(
name|DeclGroupPtrTy
modifier|&
name|Result
parameter_list|)
function_decl|;
name|bool
name|ParseTopLevelDecl
parameter_list|()
block|{
name|DeclGroupPtrTy
name|Result
decl_stmt|;
return|return
name|ParseTopLevelDecl
argument_list|(
name|Result
argument_list|)
return|;
block|}
comment|/// ConsumeToken - Consume the current 'peek token' and lex the next one.
comment|/// This does not work with special tokens: string literals, code completion
comment|/// and balanced tokens must be handled using the specific consume methods.
comment|/// Returns the location of the consumed token.
name|SourceLocation
name|ConsumeToken
parameter_list|()
block|{
name|assert
argument_list|(
operator|!
name|isTokenSpecial
argument_list|()
operator|&&
literal|"Should consume special tokens with Consume*Token"
argument_list|)
expr_stmt|;
name|PrevTokLocation
operator|=
name|Tok
operator|.
name|getLocation
argument_list|()
expr_stmt|;
name|PP
operator|.
name|Lex
argument_list|(
name|Tok
argument_list|)
expr_stmt|;
return|return
name|PrevTokLocation
return|;
block|}
name|bool
name|TryConsumeToken
argument_list|(
name|tok
operator|::
name|TokenKind
name|Expected
argument_list|)
block|{
if|if
condition|(
name|Tok
operator|.
name|isNot
argument_list|(
name|Expected
argument_list|)
condition|)
return|return
name|false
return|;
name|assert
argument_list|(
operator|!
name|isTokenSpecial
argument_list|()
operator|&&
literal|"Should consume special tokens with Consume*Token"
argument_list|)
expr_stmt|;
name|PrevTokLocation
operator|=
name|Tok
operator|.
name|getLocation
argument_list|()
expr_stmt|;
name|PP
operator|.
name|Lex
argument_list|(
name|Tok
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
name|bool
name|TryConsumeToken
argument_list|(
name|tok
operator|::
name|TokenKind
name|Expected
argument_list|,
name|SourceLocation
operator|&
name|Loc
argument_list|)
block|{
if|if
condition|(
operator|!
name|TryConsumeToken
argument_list|(
name|Expected
argument_list|)
condition|)
return|return
name|false
return|;
name|Loc
operator|=
name|PrevTokLocation
expr_stmt|;
return|return
name|true
return|;
block|}
name|SourceLocation
name|getEndOfPreviousToken
parameter_list|()
block|{
return|return
name|PP
operator|.
name|getLocForEndOfToken
argument_list|(
name|PrevTokLocation
argument_list|)
return|;
block|}
comment|/// Retrieve the underscored keyword (_Nonnull, _Nullable) that corresponds
comment|/// to the given nullability kind.
name|IdentifierInfo
modifier|*
name|getNullabilityKeyword
parameter_list|(
name|NullabilityKind
name|nullability
parameter_list|)
block|{
return|return
name|Actions
operator|.
name|getNullabilityKeyword
argument_list|(
name|nullability
argument_list|)
return|;
block|}
name|private
label|:
comment|//===--------------------------------------------------------------------===//
comment|// Low-Level token peeking and consumption methods.
comment|//
comment|/// isTokenParen - Return true if the cur token is '(' or ')'.
name|bool
name|isTokenParen
argument_list|()
specifier|const
block|{
return|return
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|l_paren
operator|||
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|r_paren
return|;
block|}
comment|/// isTokenBracket - Return true if the cur token is '[' or ']'.
name|bool
name|isTokenBracket
argument_list|()
specifier|const
block|{
return|return
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|l_square
operator|||
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|r_square
return|;
block|}
comment|/// isTokenBrace - Return true if the cur token is '{' or '}'.
name|bool
name|isTokenBrace
argument_list|()
specifier|const
block|{
return|return
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|l_brace
operator|||
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|r_brace
return|;
block|}
comment|/// isTokenStringLiteral - True if this token is a string-literal.
name|bool
name|isTokenStringLiteral
argument_list|()
specifier|const
block|{
return|return
name|tok
operator|::
name|isStringLiteral
argument_list|(
name|Tok
operator|.
name|getKind
argument_list|()
argument_list|)
return|;
block|}
comment|/// isTokenSpecial - True if this token requires special consumption methods.
name|bool
name|isTokenSpecial
argument_list|()
specifier|const
block|{
return|return
name|isTokenStringLiteral
argument_list|()
operator|||
name|isTokenParen
argument_list|()
operator|||
name|isTokenBracket
argument_list|()
operator|||
name|isTokenBrace
argument_list|()
operator|||
name|Tok
operator|.
name|is
argument_list|(
name|tok
operator|::
name|code_completion
argument_list|)
return|;
block|}
comment|/// \brief Returns true if the current token is '=' or is a type of '='.
comment|/// For typos, give a fixit to '='
name|bool
name|isTokenEqualOrEqualTypo
parameter_list|()
function_decl|;
comment|/// \brief Return the current token to the token stream and make the given
comment|/// token the current token.
name|void
name|UnconsumeToken
parameter_list|(
name|Token
modifier|&
name|Consumed
parameter_list|)
block|{
name|Token
name|Next
init|=
name|Tok
decl_stmt|;
name|PP
operator|.
name|EnterToken
argument_list|(
name|Consumed
argument_list|)
expr_stmt|;
name|PP
operator|.
name|Lex
argument_list|(
name|Tok
argument_list|)
expr_stmt|;
name|PP
operator|.
name|EnterToken
argument_list|(
name|Next
argument_list|)
expr_stmt|;
block|}
comment|/// ConsumeAnyToken - Dispatch to the right Consume* method based on the
comment|/// current token type.  This should only be used in cases where the type of
comment|/// the token really isn't known, e.g. in error recovery.
name|SourceLocation
name|ConsumeAnyToken
parameter_list|(
name|bool
name|ConsumeCodeCompletionTok
init|=
name|false
parameter_list|)
block|{
if|if
condition|(
name|isTokenParen
argument_list|()
condition|)
return|return
name|ConsumeParen
argument_list|()
return|;
if|if
condition|(
name|isTokenBracket
argument_list|()
condition|)
return|return
name|ConsumeBracket
argument_list|()
return|;
if|if
condition|(
name|isTokenBrace
argument_list|()
condition|)
return|return
name|ConsumeBrace
argument_list|()
return|;
if|if
condition|(
name|isTokenStringLiteral
argument_list|()
condition|)
return|return
name|ConsumeStringToken
argument_list|()
return|;
if|if
condition|(
name|Tok
operator|.
name|is
argument_list|(
name|tok
operator|::
name|code_completion
argument_list|)
condition|)
return|return
name|ConsumeCodeCompletionTok
condition|?
name|ConsumeCodeCompletionToken
argument_list|()
else|:
name|handleUnexpectedCodeCompletionToken
argument_list|()
return|;
return|return
name|ConsumeToken
argument_list|()
return|;
block|}
comment|/// ConsumeParen - This consume method keeps the paren count up-to-date.
comment|///
name|SourceLocation
name|ConsumeParen
parameter_list|()
block|{
name|assert
argument_list|(
name|isTokenParen
argument_list|()
operator|&&
literal|"wrong consume method"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|l_paren
condition|)
operator|++
name|ParenCount
expr_stmt|;
elseif|else
if|if
condition|(
name|ParenCount
condition|)
operator|--
name|ParenCount
expr_stmt|;
comment|// Don't let unbalanced )'s drive the count negative.
name|PrevTokLocation
operator|=
name|Tok
operator|.
name|getLocation
argument_list|()
expr_stmt|;
name|PP
operator|.
name|Lex
argument_list|(
name|Tok
argument_list|)
expr_stmt|;
return|return
name|PrevTokLocation
return|;
block|}
comment|/// ConsumeBracket - This consume method keeps the bracket count up-to-date.
comment|///
name|SourceLocation
name|ConsumeBracket
parameter_list|()
block|{
name|assert
argument_list|(
name|isTokenBracket
argument_list|()
operator|&&
literal|"wrong consume method"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|l_square
condition|)
operator|++
name|BracketCount
expr_stmt|;
elseif|else
if|if
condition|(
name|BracketCount
condition|)
operator|--
name|BracketCount
expr_stmt|;
comment|// Don't let unbalanced ]'s drive the count negative.
name|PrevTokLocation
operator|=
name|Tok
operator|.
name|getLocation
argument_list|()
expr_stmt|;
name|PP
operator|.
name|Lex
argument_list|(
name|Tok
argument_list|)
expr_stmt|;
return|return
name|PrevTokLocation
return|;
block|}
comment|/// ConsumeBrace - This consume method keeps the brace count up-to-date.
comment|///
name|SourceLocation
name|ConsumeBrace
parameter_list|()
block|{
name|assert
argument_list|(
name|isTokenBrace
argument_list|()
operator|&&
literal|"wrong consume method"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|l_brace
condition|)
operator|++
name|BraceCount
expr_stmt|;
elseif|else
if|if
condition|(
name|BraceCount
condition|)
operator|--
name|BraceCount
expr_stmt|;
comment|// Don't let unbalanced }'s drive the count negative.
name|PrevTokLocation
operator|=
name|Tok
operator|.
name|getLocation
argument_list|()
expr_stmt|;
name|PP
operator|.
name|Lex
argument_list|(
name|Tok
argument_list|)
expr_stmt|;
return|return
name|PrevTokLocation
return|;
block|}
comment|/// ConsumeStringToken - Consume the current 'peek token', lexing a new one
comment|/// and returning the token kind.  This method is specific to strings, as it
comment|/// handles string literal concatenation, as per C99 5.1.1.2, translation
comment|/// phase #6.
name|SourceLocation
name|ConsumeStringToken
parameter_list|()
block|{
name|assert
argument_list|(
name|isTokenStringLiteral
argument_list|()
operator|&&
literal|"Should only consume string literals with this method"
argument_list|)
expr_stmt|;
name|PrevTokLocation
operator|=
name|Tok
operator|.
name|getLocation
argument_list|()
expr_stmt|;
name|PP
operator|.
name|Lex
argument_list|(
name|Tok
argument_list|)
expr_stmt|;
return|return
name|PrevTokLocation
return|;
block|}
comment|/// \brief Consume the current code-completion token.
comment|///
comment|/// This routine can be called to consume the code-completion token and
comment|/// continue processing in special cases where \c cutOffParsing() isn't
comment|/// desired, such as token caching or completion with lookahead.
name|SourceLocation
name|ConsumeCodeCompletionToken
parameter_list|()
block|{
name|assert
argument_list|(
name|Tok
operator|.
name|is
argument_list|(
name|tok
operator|::
name|code_completion
argument_list|)
argument_list|)
expr_stmt|;
name|PrevTokLocation
operator|=
name|Tok
operator|.
name|getLocation
argument_list|()
expr_stmt|;
name|PP
operator|.
name|Lex
argument_list|(
name|Tok
argument_list|)
expr_stmt|;
return|return
name|PrevTokLocation
return|;
block|}
comment|///\ brief When we are consuming a code-completion token without having
comment|/// matched specific position in the grammar, provide code-completion results
comment|/// based on context.
comment|///
comment|/// \returns the source location of the code-completion token.
name|SourceLocation
name|handleUnexpectedCodeCompletionToken
parameter_list|()
function_decl|;
comment|/// \brief Abruptly cut off parsing; mainly used when we have reached the
comment|/// code-completion point.
name|void
name|cutOffParsing
parameter_list|()
block|{
if|if
condition|(
name|PP
operator|.
name|isCodeCompletionEnabled
argument_list|()
condition|)
name|PP
operator|.
name|setCodeCompletionReached
argument_list|()
expr_stmt|;
comment|// Cut off parsing by acting as if we reached the end-of-file.
name|Tok
operator|.
name|setKind
argument_list|(
name|tok
operator|::
name|eof
argument_list|)
expr_stmt|;
block|}
comment|/// \brief Determine if we're at the end of the file or at a transition
comment|/// between modules.
name|bool
name|isEofOrEom
parameter_list|()
block|{
name|tok
operator|::
name|TokenKind
name|Kind
operator|=
name|Tok
operator|.
name|getKind
argument_list|()
expr_stmt|;
return|return
name|Kind
operator|==
name|tok
operator|::
name|eof
operator|||
name|Kind
operator|==
name|tok
operator|::
name|annot_module_begin
operator|||
name|Kind
operator|==
name|tok
operator|::
name|annot_module_end
operator|||
name|Kind
operator|==
name|tok
operator|::
name|annot_module_include
return|;
block|}
comment|/// \brief Initialize all pragma handlers.
name|void
name|initializePragmaHandlers
parameter_list|()
function_decl|;
comment|/// \brief Destroy and reset all pragma handlers.
name|void
name|resetPragmaHandlers
parameter_list|()
function_decl|;
comment|/// \brief Handle the annotation token produced for #pragma unused(...)
name|void
name|HandlePragmaUnused
parameter_list|()
function_decl|;
comment|/// \brief Handle the annotation token produced for
comment|/// #pragma GCC visibility...
name|void
name|HandlePragmaVisibility
parameter_list|()
function_decl|;
comment|/// \brief Handle the annotation token produced for
comment|/// #pragma pack...
name|void
name|HandlePragmaPack
parameter_list|()
function_decl|;
comment|/// \brief Handle the annotation token produced for
comment|/// #pragma ms_struct...
name|void
name|HandlePragmaMSStruct
parameter_list|()
function_decl|;
comment|/// \brief Handle the annotation token produced for
comment|/// #pragma comment...
name|void
name|HandlePragmaMSComment
parameter_list|()
function_decl|;
name|void
name|HandlePragmaMSPointersToMembers
parameter_list|()
function_decl|;
name|void
name|HandlePragmaMSVtorDisp
parameter_list|()
function_decl|;
name|void
name|HandlePragmaMSPragma
parameter_list|()
function_decl|;
name|bool
name|HandlePragmaMSSection
parameter_list|(
name|StringRef
name|PragmaName
parameter_list|,
name|SourceLocation
name|PragmaLocation
parameter_list|)
function_decl|;
name|bool
name|HandlePragmaMSSegment
parameter_list|(
name|StringRef
name|PragmaName
parameter_list|,
name|SourceLocation
name|PragmaLocation
parameter_list|)
function_decl|;
name|bool
name|HandlePragmaMSInitSeg
parameter_list|(
name|StringRef
name|PragmaName
parameter_list|,
name|SourceLocation
name|PragmaLocation
parameter_list|)
function_decl|;
comment|/// \brief Handle the annotation token produced for
comment|/// #pragma align...
name|void
name|HandlePragmaAlign
parameter_list|()
function_decl|;
comment|/// \brief Handle the annotation token produced for
comment|/// #pragma clang __debug dump...
name|void
name|HandlePragmaDump
parameter_list|()
function_decl|;
comment|/// \brief Handle the annotation token produced for
comment|/// #pragma weak id...
name|void
name|HandlePragmaWeak
parameter_list|()
function_decl|;
comment|/// \brief Handle the annotation token produced for
comment|/// #pragma weak id = id...
name|void
name|HandlePragmaWeakAlias
parameter_list|()
function_decl|;
comment|/// \brief Handle the annotation token produced for
comment|/// #pragma redefine_extname...
name|void
name|HandlePragmaRedefineExtname
parameter_list|()
function_decl|;
comment|/// \brief Handle the annotation token produced for
comment|/// #pragma STDC FP_CONTRACT...
name|void
name|HandlePragmaFPContract
parameter_list|()
function_decl|;
comment|/// \brief Handle the annotation token produced for
comment|/// #pragma OPENCL EXTENSION...
name|void
name|HandlePragmaOpenCLExtension
parameter_list|()
function_decl|;
comment|/// \brief Handle the annotation token produced for
comment|/// #pragma clang __debug captured
name|StmtResult
name|HandlePragmaCaptured
parameter_list|()
function_decl|;
comment|/// \brief Handle the annotation token produced for
comment|/// #pragma clang loop and #pragma unroll.
name|bool
name|HandlePragmaLoopHint
parameter_list|(
name|LoopHint
modifier|&
name|Hint
parameter_list|)
function_decl|;
comment|/// GetLookAheadToken - This peeks ahead N tokens and returns that token
comment|/// without consuming any tokens.  LookAhead(0) returns 'Tok', LookAhead(1)
comment|/// returns the token after Tok, etc.
comment|///
comment|/// Note that this differs from the Preprocessor's LookAhead method, because
comment|/// the Parser always has one token lexed that the preprocessor doesn't.
comment|///
specifier|const
name|Token
modifier|&
name|GetLookAheadToken
parameter_list|(
name|unsigned
name|N
parameter_list|)
block|{
if|if
condition|(
name|N
operator|==
literal|0
operator|||
name|Tok
operator|.
name|is
argument_list|(
name|tok
operator|::
name|eof
argument_list|)
condition|)
return|return
name|Tok
return|;
return|return
name|PP
operator|.
name|LookAhead
argument_list|(
name|N
operator|-
literal|1
argument_list|)
return|;
block|}
name|public
label|:
comment|/// NextToken - This peeks ahead one token and returns it without
comment|/// consuming it.
specifier|const
name|Token
modifier|&
name|NextToken
parameter_list|()
block|{
return|return
name|PP
operator|.
name|LookAhead
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/// getTypeAnnotation - Read a parsed type out of an annotation token.
specifier|static
name|ParsedType
name|getTypeAnnotation
parameter_list|(
name|Token
modifier|&
name|Tok
parameter_list|)
block|{
return|return
name|ParsedType
operator|::
name|getFromOpaquePtr
argument_list|(
name|Tok
operator|.
name|getAnnotationValue
argument_list|()
argument_list|)
return|;
block|}
name|private
label|:
specifier|static
name|void
name|setTypeAnnotation
parameter_list|(
name|Token
modifier|&
name|Tok
parameter_list|,
name|ParsedType
name|T
parameter_list|)
block|{
name|Tok
operator|.
name|setAnnotationValue
argument_list|(
name|T
operator|.
name|getAsOpaquePtr
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/// \brief Read an already-translated primary expression out of an annotation
comment|/// token.
specifier|static
name|ExprResult
name|getExprAnnotation
parameter_list|(
name|Token
modifier|&
name|Tok
parameter_list|)
block|{
return|return
name|ExprResult
operator|::
name|getFromOpaquePointer
argument_list|(
name|Tok
operator|.
name|getAnnotationValue
argument_list|()
argument_list|)
return|;
block|}
comment|/// \brief Set the primary expression corresponding to the given annotation
comment|/// token.
specifier|static
name|void
name|setExprAnnotation
parameter_list|(
name|Token
modifier|&
name|Tok
parameter_list|,
name|ExprResult
name|ER
parameter_list|)
block|{
name|Tok
operator|.
name|setAnnotationValue
argument_list|(
name|ER
operator|.
name|getAsOpaquePointer
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|public
label|:
comment|// If NeedType is true, then TryAnnotateTypeOrScopeToken will try harder to
comment|// find a type name by attempting typo correction.
name|bool
name|TryAnnotateTypeOrScopeToken
parameter_list|(
name|bool
name|EnteringContext
init|=
name|false
parameter_list|,
name|bool
name|NeedType
init|=
name|false
parameter_list|)
function_decl|;
name|bool
name|TryAnnotateTypeOrScopeTokenAfterScopeSpec
parameter_list|(
name|bool
name|EnteringContext
parameter_list|,
name|bool
name|NeedType
parameter_list|,
name|CXXScopeSpec
modifier|&
name|SS
parameter_list|,
name|bool
name|IsNewScope
parameter_list|)
function_decl|;
name|bool
name|TryAnnotateCXXScopeToken
parameter_list|(
name|bool
name|EnteringContext
init|=
name|false
parameter_list|)
function_decl|;
name|private
label|:
enum|enum
name|AnnotatedNameKind
block|{
comment|/// Annotation has failed and emitted an error.
name|ANK_Error
block|,
comment|/// The identifier is a tentatively-declared name.
name|ANK_TentativeDecl
block|,
comment|/// The identifier is a template name. FIXME: Add an annotation for that.
name|ANK_TemplateName
block|,
comment|/// The identifier can't be resolved.
name|ANK_Unresolved
block|,
comment|/// Annotation was successful.
name|ANK_Success
block|}
enum|;
name|AnnotatedNameKind
name|TryAnnotateName
argument_list|(
name|bool
name|IsAddressOfOperand
argument_list|,
name|std
operator|::
name|unique_ptr
operator|<
name|CorrectionCandidateCallback
operator|>
name|CCC
operator|=
name|nullptr
argument_list|)
decl_stmt|;
comment|/// Push a tok::annot_cxxscope token onto the token stream.
name|void
name|AnnotateScopeToken
parameter_list|(
name|CXXScopeSpec
modifier|&
name|SS
parameter_list|,
name|bool
name|IsNewAnnotation
parameter_list|)
function_decl|;
comment|/// TryAltiVecToken - Check for context-sensitive AltiVec identifier tokens,
comment|/// replacing them with the non-context-sensitive keywords.  This returns
comment|/// true if the token was replaced.
name|bool
name|TryAltiVecToken
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|,
name|bool
modifier|&
name|isInvalid
parameter_list|)
block|{
if|if
condition|(
operator|!
name|getLangOpts
argument_list|()
operator|.
name|AltiVec
operator|&&
operator|!
name|getLangOpts
argument_list|()
operator|.
name|ZVector
condition|)
return|return
name|false
return|;
if|if
condition|(
name|Tok
operator|.
name|getIdentifierInfo
argument_list|()
operator|!=
name|Ident_vector
operator|&&
name|Tok
operator|.
name|getIdentifierInfo
argument_list|()
operator|!=
name|Ident_bool
operator|&&
operator|(
operator|!
name|getLangOpts
argument_list|()
operator|.
name|AltiVec
operator|||
name|Tok
operator|.
name|getIdentifierInfo
argument_list|()
operator|!=
name|Ident_pixel
operator|)
condition|)
return|return
name|false
return|;
return|return
name|TryAltiVecTokenOutOfLine
argument_list|(
name|DS
argument_list|,
name|Loc
argument_list|,
name|PrevSpec
argument_list|,
name|DiagID
argument_list|,
name|isInvalid
argument_list|)
return|;
block|}
comment|/// TryAltiVecVectorToken - Check for context-sensitive AltiVec vector
comment|/// identifier token, replacing it with the non-context-sensitive __vector.
comment|/// This returns true if the token was replaced.
name|bool
name|TryAltiVecVectorToken
parameter_list|()
block|{
if|if
condition|(
operator|(
operator|!
name|getLangOpts
argument_list|()
operator|.
name|AltiVec
operator|&&
operator|!
name|getLangOpts
argument_list|()
operator|.
name|ZVector
operator|)
operator|||
name|Tok
operator|.
name|getIdentifierInfo
argument_list|()
operator|!=
name|Ident_vector
condition|)
return|return
name|false
return|;
return|return
name|TryAltiVecVectorTokenOutOfLine
argument_list|()
return|;
block|}
name|bool
name|TryAltiVecVectorTokenOutOfLine
parameter_list|()
function_decl|;
name|bool
name|TryAltiVecTokenOutOfLine
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|,
name|bool
modifier|&
name|isInvalid
parameter_list|)
function_decl|;
comment|/// Returns true if the current token is the identifier 'instancetype'.
comment|///
comment|/// Should only be used in Objective-C language modes.
name|bool
name|isObjCInstancetype
parameter_list|()
block|{
name|assert
argument_list|(
name|getLangOpts
argument_list|()
operator|.
name|ObjC1
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tok
operator|.
name|isAnnotation
argument_list|()
condition|)
return|return
name|false
return|;
if|if
condition|(
operator|!
name|Ident_instancetype
condition|)
name|Ident_instancetype
operator|=
name|PP
operator|.
name|getIdentifierInfo
argument_list|(
literal|"instancetype"
argument_list|)
expr_stmt|;
return|return
name|Tok
operator|.
name|getIdentifierInfo
argument_list|()
operator|==
name|Ident_instancetype
return|;
block|}
comment|/// TryKeywordIdentFallback - For compatibility with system headers using
comment|/// keywords as identifiers, attempt to convert the current token to an
comment|/// identifier and optionally disable the keyword for the remainder of the
comment|/// translation unit. This returns false if the token was not replaced,
comment|/// otherwise emits a diagnostic and returns true.
name|bool
name|TryKeywordIdentFallback
parameter_list|(
name|bool
name|DisableKeyword
parameter_list|)
function_decl|;
comment|/// \brief Get the TemplateIdAnnotation from the token.
name|TemplateIdAnnotation
modifier|*
name|takeTemplateIdAnnotation
parameter_list|(
specifier|const
name|Token
modifier|&
name|tok
parameter_list|)
function_decl|;
comment|/// TentativeParsingAction - An object that is used as a kind of "tentative
comment|/// parsing transaction". It gets instantiated to mark the token position and
comment|/// after the token consumption is done, Commit() or Revert() is called to
comment|/// either "commit the consumed tokens" or revert to the previously marked
comment|/// token position. Example:
comment|///
comment|///   TentativeParsingAction TPA(*this);
comment|///   ConsumeToken();
comment|///   ....
comment|///   TPA.Revert();
comment|///
name|class
name|TentativeParsingAction
block|{
name|Parser
modifier|&
name|P
decl_stmt|;
name|Token
name|PrevTok
decl_stmt|;
name|size_t
name|PrevTentativelyDeclaredIdentifierCount
decl_stmt|;
name|unsigned
name|short
name|PrevParenCount
decl_stmt|,
name|PrevBracketCount
decl_stmt|,
name|PrevBraceCount
decl_stmt|;
name|bool
name|isActive
decl_stmt|;
name|public
label|:
name|explicit
name|TentativeParsingAction
argument_list|(
name|Parser
operator|&
name|p
argument_list|)
operator|:
name|P
argument_list|(
argument|p
argument_list|)
block|{
name|PrevTok
operator|=
name|P
operator|.
name|Tok
block|;
name|PrevTentativelyDeclaredIdentifierCount
operator|=
name|P
operator|.
name|TentativelyDeclaredIdentifiers
operator|.
name|size
argument_list|()
block|;
name|PrevParenCount
operator|=
name|P
operator|.
name|ParenCount
block|;
name|PrevBracketCount
operator|=
name|P
operator|.
name|BracketCount
block|;
name|PrevBraceCount
operator|=
name|P
operator|.
name|BraceCount
block|;
name|P
operator|.
name|PP
operator|.
name|EnableBacktrackAtThisPos
argument_list|()
block|;
name|isActive
operator|=
name|true
block|;     }
name|void
name|Commit
argument_list|()
block|{
name|assert
argument_list|(
name|isActive
operator|&&
literal|"Parsing action was finished!"
argument_list|)
block|;
name|P
operator|.
name|TentativelyDeclaredIdentifiers
operator|.
name|resize
argument_list|(
name|PrevTentativelyDeclaredIdentifierCount
argument_list|)
block|;
name|P
operator|.
name|PP
operator|.
name|CommitBacktrackedTokens
argument_list|()
block|;
name|isActive
operator|=
name|false
block|;     }
name|void
name|Revert
argument_list|()
block|{
name|assert
argument_list|(
name|isActive
operator|&&
literal|"Parsing action was finished!"
argument_list|)
block|;
name|P
operator|.
name|PP
operator|.
name|Backtrack
argument_list|()
block|;
name|P
operator|.
name|Tok
operator|=
name|PrevTok
block|;
name|P
operator|.
name|TentativelyDeclaredIdentifiers
operator|.
name|resize
argument_list|(
name|PrevTentativelyDeclaredIdentifierCount
argument_list|)
block|;
name|P
operator|.
name|ParenCount
operator|=
name|PrevParenCount
block|;
name|P
operator|.
name|BracketCount
operator|=
name|PrevBracketCount
block|;
name|P
operator|.
name|BraceCount
operator|=
name|PrevBraceCount
block|;
name|isActive
operator|=
name|false
block|;     }
operator|~
name|TentativeParsingAction
argument_list|()
block|{
name|assert
argument_list|(
operator|!
name|isActive
operator|&&
literal|"Forgot to call Commit or Revert!"
argument_list|)
block|;     }
block|}
empty_stmt|;
comment|/// A TentativeParsingAction that automatically reverts in its destructor.
comment|/// Useful for disambiguation parses that will always be reverted.
name|class
name|RevertingTentativeParsingAction
range|:
name|private
name|Parser
operator|::
name|TentativeParsingAction
block|{
name|public
operator|:
name|RevertingTentativeParsingAction
argument_list|(
name|Parser
operator|&
name|P
argument_list|)
operator|:
name|Parser
operator|::
name|TentativeParsingAction
argument_list|(
argument|P
argument_list|)
block|{}
operator|~
name|RevertingTentativeParsingAction
argument_list|()
block|{
name|Revert
argument_list|()
block|; }
block|}
decl_stmt|;
name|class
name|UnannotatedTentativeParsingAction
decl_stmt|;
comment|/// ObjCDeclContextSwitch - An object used to switch context from
comment|/// an objective-c decl context to its enclosing decl context and
comment|/// back.
name|class
name|ObjCDeclContextSwitch
block|{
name|Parser
modifier|&
name|P
decl_stmt|;
name|Decl
modifier|*
name|DC
decl_stmt|;
name|SaveAndRestore
operator|<
name|bool
operator|>
name|WithinObjCContainer
expr_stmt|;
name|public
label|:
name|explicit
name|ObjCDeclContextSwitch
argument_list|(
name|Parser
operator|&
name|p
argument_list|)
operator|:
name|P
argument_list|(
name|p
argument_list|)
operator|,
name|DC
argument_list|(
name|p
operator|.
name|getObjCDeclContext
argument_list|()
argument_list|)
operator|,
name|WithinObjCContainer
argument_list|(
argument|P.ParsingInObjCContainer
argument_list|,
argument|DC != nullptr
argument_list|)
block|{
if|if
condition|(
name|DC
condition|)
name|P
operator|.
name|Actions
operator|.
name|ActOnObjCTemporaryExitContainerContext
argument_list|(
name|cast
operator|<
name|DeclContext
operator|>
operator|(
name|DC
operator|)
argument_list|)
expr_stmt|;
block|}
operator|~
name|ObjCDeclContextSwitch
argument_list|()
block|{
if|if
condition|(
name|DC
condition|)
name|P
operator|.
name|Actions
operator|.
name|ActOnObjCReenterContainerContext
argument_list|(
name|cast
operator|<
name|DeclContext
operator|>
operator|(
name|DC
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
empty_stmt|;
comment|/// ExpectAndConsume - The parser expects that 'ExpectedTok' is next in the
comment|/// input.  If so, it is consumed and false is returned.
comment|///
comment|/// If a trivial punctuator misspelling is encountered, a FixIt error
comment|/// diagnostic is issued and false is returned after recovery.
comment|///
comment|/// If the input is malformed, this emits the specified diagnostic and true is
comment|/// returned.
name|bool
name|ExpectAndConsume
argument_list|(
name|tok
operator|::
name|TokenKind
name|ExpectedTok
argument_list|,
name|unsigned
name|Diag
operator|=
name|diag
operator|::
name|err_expected
argument_list|,
name|StringRef
name|DiagMsg
operator|=
literal|""
argument_list|)
decl_stmt|;
comment|/// \brief The parser expects a semicolon and, if present, will consume it.
comment|///
comment|/// If the next token is not a semicolon, this emits the specified diagnostic,
comment|/// or, if there's just some closing-delimiter noise (e.g., ')' or ']') prior
comment|/// to the semicolon, consumes that extra token.
name|bool
name|ExpectAndConsumeSemi
parameter_list|(
name|unsigned
name|DiagID
parameter_list|)
function_decl|;
comment|/// \brief The kind of extra semi diagnostic to emit.
enum|enum
name|ExtraSemiKind
block|{
name|OutsideFunction
init|=
literal|0
block|,
name|InsideStruct
init|=
literal|1
block|,
name|InstanceVariableList
init|=
literal|2
block|,
name|AfterMemberFunctionDefinition
init|=
literal|3
block|}
enum|;
comment|/// \brief Consume any extra semi-colons until the end of the line.
name|void
name|ConsumeExtraSemi
parameter_list|(
name|ExtraSemiKind
name|Kind
parameter_list|,
name|unsigned
name|TST
init|=
name|TST_unspecified
parameter_list|)
function_decl|;
name|public
label|:
comment|//===--------------------------------------------------------------------===//
comment|// Scope manipulation
comment|/// ParseScope - Introduces a new scope for parsing. The kind of
comment|/// scope is determined by ScopeFlags. Objects of this type should
comment|/// be created on the stack to coincide with the position where the
comment|/// parser enters the new scope, and this object's constructor will
comment|/// create that new scope. Similarly, once the object is destroyed
comment|/// the parser will exit the scope.
name|class
name|ParseScope
block|{
name|Parser
modifier|*
name|Self
decl_stmt|;
name|ParseScope
argument_list|(
specifier|const
name|ParseScope
operator|&
argument_list|)
operator|=
name|delete
expr_stmt|;
name|void
name|operator
init|=
operator|(
specifier|const
name|ParseScope
operator|&
operator|)
operator|=
name|delete
decl_stmt|;
name|public
label|:
comment|// ParseScope - Construct a new object to manage a scope in the
comment|// parser Self where the new Scope is created with the flags
comment|// ScopeFlags, but only when we aren't about to enter a compound statement.
name|ParseScope
argument_list|(
argument|Parser *Self
argument_list|,
argument|unsigned ScopeFlags
argument_list|,
argument|bool EnteredScope = true
argument_list|,
argument|bool BeforeCompoundStmt = false
argument_list|)
block|:
name|Self
argument_list|(
argument|Self
argument_list|)
block|{
if|if
condition|(
name|EnteredScope
operator|&&
operator|!
name|BeforeCompoundStmt
condition|)
name|Self
operator|->
name|EnterScope
argument_list|(
name|ScopeFlags
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|BeforeCompoundStmt
condition|)
name|Self
operator|->
name|incrementMSManglingNumber
argument_list|()
expr_stmt|;
name|this
operator|->
name|Self
operator|=
name|nullptr
expr_stmt|;
block|}
block|}
comment|// Exit - Exit the scope associated with this object now, rather
comment|// than waiting until the object is destroyed.
name|void
name|Exit
parameter_list|()
block|{
if|if
condition|(
name|Self
condition|)
block|{
name|Self
operator|->
name|ExitScope
argument_list|()
expr_stmt|;
name|Self
operator|=
name|nullptr
expr_stmt|;
block|}
block|}
operator|~
name|ParseScope
argument_list|()
block|{
name|Exit
argument_list|()
block|;     }
block|}
empty_stmt|;
comment|/// EnterScope - Start a new scope.
name|void
name|EnterScope
parameter_list|(
name|unsigned
name|ScopeFlags
parameter_list|)
function_decl|;
comment|/// ExitScope - Pop a scope off the scope stack.
name|void
name|ExitScope
parameter_list|()
function_decl|;
name|private
label|:
comment|/// \brief RAII object used to modify the scope flags for the current scope.
name|class
name|ParseScopeFlags
block|{
name|Scope
modifier|*
name|CurScope
decl_stmt|;
name|unsigned
name|OldFlags
decl_stmt|;
name|ParseScopeFlags
argument_list|(
specifier|const
name|ParseScopeFlags
operator|&
argument_list|)
operator|=
name|delete
expr_stmt|;
name|void
name|operator
init|=
operator|(
specifier|const
name|ParseScopeFlags
operator|&
operator|)
operator|=
name|delete
decl_stmt|;
name|public
label|:
name|ParseScopeFlags
argument_list|(
argument|Parser *Self
argument_list|,
argument|unsigned ScopeFlags
argument_list|,
argument|bool ManageFlags = true
argument_list|)
empty_stmt|;
operator|~
name|ParseScopeFlags
argument_list|()
expr_stmt|;
block|}
empty_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|// Diagnostic Emission and Error recovery.
name|public
label|:
name|DiagnosticBuilder
name|Diag
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
name|unsigned
name|DiagID
parameter_list|)
function_decl|;
name|DiagnosticBuilder
name|Diag
parameter_list|(
specifier|const
name|Token
modifier|&
name|Tok
parameter_list|,
name|unsigned
name|DiagID
parameter_list|)
function_decl|;
name|DiagnosticBuilder
name|Diag
parameter_list|(
name|unsigned
name|DiagID
parameter_list|)
block|{
return|return
name|Diag
argument_list|(
name|Tok
argument_list|,
name|DiagID
argument_list|)
return|;
block|}
name|private
label|:
name|void
name|SuggestParentheses
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
name|unsigned
name|DK
parameter_list|,
name|SourceRange
name|ParenRange
parameter_list|)
function_decl|;
name|void
name|CheckNestedObjCContexts
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|)
function_decl|;
name|public
label|:
comment|/// \brief Control flags for SkipUntil functions.
enum|enum
name|SkipUntilFlags
block|{
name|StopAtSemi
init|=
literal|1
operator|<<
literal|0
block|,
comment|///< Stop skipping at semicolon
comment|/// \brief Stop skipping at specified token, but don't skip the token itself
name|StopBeforeMatch
init|=
literal|1
operator|<<
literal|1
block|,
name|StopAtCodeCompletion
init|=
literal|1
operator|<<
literal|2
comment|///< Stop at code completion
block|}
enum|;
name|friend
name|constexpr
name|SkipUntilFlags
name|operator
operator||
operator|(
name|SkipUntilFlags
name|L
operator|,
name|SkipUntilFlags
name|R
operator|)
block|{
return|return
name|static_cast
operator|<
name|SkipUntilFlags
operator|>
operator|(
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|L
operator|)
operator||
name|static_cast
operator|<
name|unsigned
operator|>
operator|(
name|R
operator|)
operator|)
return|;
block|}
comment|/// SkipUntil - Read tokens until we get to the specified token, then consume
comment|/// it (unless StopBeforeMatch is specified).  Because we cannot guarantee
comment|/// that the token will ever occur, this skips to the next token, or to some
comment|/// likely good stopping point.  If Flags has StopAtSemi flag, skipping will
comment|/// stop at a ';' character.
comment|///
comment|/// If SkipUntil finds the specified token, it returns true, otherwise it
comment|/// returns false.
name|bool
name|SkipUntil
argument_list|(
name|tok
operator|::
name|TokenKind
name|T
argument_list|,
name|SkipUntilFlags
name|Flags
operator|=
name|static_cast
operator|<
name|SkipUntilFlags
operator|>
operator|(
literal|0
operator|)
argument_list|)
block|{
return|return
name|SkipUntil
argument_list|(
name|llvm
operator|::
name|makeArrayRef
argument_list|(
name|T
argument_list|)
argument_list|,
name|Flags
argument_list|)
return|;
block|}
name|bool
name|SkipUntil
argument_list|(
name|tok
operator|::
name|TokenKind
name|T1
argument_list|,
name|tok
operator|::
name|TokenKind
name|T2
argument_list|,
name|SkipUntilFlags
name|Flags
operator|=
name|static_cast
operator|<
name|SkipUntilFlags
operator|>
operator|(
literal|0
operator|)
argument_list|)
block|{
name|tok
operator|::
name|TokenKind
name|TokArray
index|[]
operator|=
block|{
name|T1
block|,
name|T2
block|}
expr_stmt|;
return|return
name|SkipUntil
argument_list|(
name|TokArray
argument_list|,
name|Flags
argument_list|)
return|;
block|}
name|bool
name|SkipUntil
argument_list|(
name|tok
operator|::
name|TokenKind
name|T1
argument_list|,
name|tok
operator|::
name|TokenKind
name|T2
argument_list|,
name|tok
operator|::
name|TokenKind
name|T3
argument_list|,
name|SkipUntilFlags
name|Flags
operator|=
name|static_cast
operator|<
name|SkipUntilFlags
operator|>
operator|(
literal|0
operator|)
argument_list|)
block|{
name|tok
operator|::
name|TokenKind
name|TokArray
index|[]
operator|=
block|{
name|T1
block|,
name|T2
block|,
name|T3
block|}
expr_stmt|;
return|return
name|SkipUntil
argument_list|(
name|TokArray
argument_list|,
name|Flags
argument_list|)
return|;
block|}
name|bool
name|SkipUntil
argument_list|(
name|ArrayRef
operator|<
name|tok
operator|::
name|TokenKind
operator|>
name|Toks
argument_list|,
name|SkipUntilFlags
name|Flags
operator|=
name|static_cast
operator|<
name|SkipUntilFlags
operator|>
operator|(
literal|0
operator|)
argument_list|)
decl_stmt|;
comment|/// SkipMalformedDecl - Read tokens until we get to some likely good stopping
comment|/// point for skipping past a simple-declaration.
name|void
name|SkipMalformedDecl
parameter_list|()
function_decl|;
name|private
label|:
comment|//===--------------------------------------------------------------------===//
comment|// Lexing and parsing of C++ inline methods.
struct_decl|struct
name|ParsingClass
struct_decl|;
comment|/// [class.mem]p1: "... the class is regarded as complete within
comment|/// - function bodies
comment|/// - default arguments
comment|/// - exception-specifications (TODO: C++0x)
comment|/// - and brace-or-equal-initializers for non-static data members
comment|/// (including such things in nested classes)."
comment|/// LateParsedDeclarations build the tree of those elements so they can
comment|/// be parsed after parsing the top-level class.
name|class
name|LateParsedDeclaration
block|{
name|public
label|:
name|virtual
operator|~
name|LateParsedDeclaration
argument_list|()
expr_stmt|;
name|virtual
name|void
name|ParseLexedMethodDeclarations
parameter_list|()
function_decl|;
name|virtual
name|void
name|ParseLexedMemberInitializers
parameter_list|()
function_decl|;
name|virtual
name|void
name|ParseLexedMethodDefs
parameter_list|()
function_decl|;
name|virtual
name|void
name|ParseLexedAttributes
parameter_list|()
function_decl|;
block|}
empty_stmt|;
comment|/// Inner node of the LateParsedDeclaration tree that parses
comment|/// all its members recursively.
name|class
name|LateParsedClass
range|:
name|public
name|LateParsedDeclaration
block|{
name|public
operator|:
name|LateParsedClass
argument_list|(
name|Parser
operator|*
name|P
argument_list|,
name|ParsingClass
operator|*
name|C
argument_list|)
block|;
operator|~
name|LateParsedClass
argument_list|()
name|override
block|;
name|void
name|ParseLexedMethodDeclarations
argument_list|()
name|override
block|;
name|void
name|ParseLexedMemberInitializers
argument_list|()
name|override
block|;
name|void
name|ParseLexedMethodDefs
argument_list|()
name|override
block|;
name|void
name|ParseLexedAttributes
argument_list|()
name|override
block|;
name|private
operator|:
name|Parser
operator|*
name|Self
block|;
name|ParsingClass
operator|*
name|Class
block|;   }
decl_stmt|;
comment|/// Contains the lexed tokens of an attribute with arguments that
comment|/// may reference member variables and so need to be parsed at the
comment|/// end of the class declaration after parsing all other member
comment|/// member declarations.
comment|/// FIXME: Perhaps we should change the name of LateParsedDeclaration to
comment|/// LateParsedTokens.
name|struct
name|LateParsedAttribute
range|:
name|public
name|LateParsedDeclaration
block|{
name|Parser
operator|*
name|Self
block|;
name|CachedTokens
name|Toks
block|;
name|IdentifierInfo
operator|&
name|AttrName
block|;
name|SourceLocation
name|AttrNameLoc
block|;
name|SmallVector
operator|<
name|Decl
operator|*
block|,
literal|2
operator|>
name|Decls
block|;
name|explicit
name|LateParsedAttribute
argument_list|(
argument|Parser *P
argument_list|,
argument|IdentifierInfo&Name
argument_list|,
argument|SourceLocation Loc
argument_list|)
operator|:
name|Self
argument_list|(
name|P
argument_list|)
block|,
name|AttrName
argument_list|(
name|Name
argument_list|)
block|,
name|AttrNameLoc
argument_list|(
argument|Loc
argument_list|)
block|{}
name|void
name|ParseLexedAttributes
argument_list|()
name|override
block|;
name|void
name|addDecl
argument_list|(
argument|Decl *D
argument_list|)
block|{
name|Decls
operator|.
name|push_back
argument_list|(
name|D
argument_list|)
block|; }
block|}
decl_stmt|;
comment|// A list of late-parsed attributes.  Used by ParseGNUAttributes.
name|class
name|LateParsedAttrList
range|:
name|public
name|SmallVector
operator|<
name|LateParsedAttribute
operator|*
decl_stmt|, 2>
block|{
name|public
label|:
name|LateParsedAttrList
argument_list|(
argument|bool PSoon = false
argument_list|)
block|:
name|ParseSoon
argument_list|(
argument|PSoon
argument_list|)
block|{ }
name|bool
name|parseSoon
parameter_list|()
block|{
return|return
name|ParseSoon
return|;
block|}
name|private
label|:
name|bool
name|ParseSoon
decl_stmt|;
comment|// Are we planning to parse these shortly after creation?
block|}
empty_stmt|;
comment|/// Contains the lexed tokens of a member function definition
comment|/// which needs to be parsed at the end of the class declaration
comment|/// after parsing all other member declarations.
name|struct
name|LexedMethod
range|:
name|public
name|LateParsedDeclaration
block|{
name|Parser
operator|*
name|Self
block|;
name|Decl
operator|*
name|D
block|;
name|CachedTokens
name|Toks
block|;
comment|/// \brief Whether this member function had an associated template
comment|/// scope. When true, D is a template declaration.
comment|/// otherwise, it is a member function declaration.
name|bool
name|TemplateScope
block|;
name|explicit
name|LexedMethod
argument_list|(
name|Parser
operator|*
name|P
argument_list|,
name|Decl
operator|*
name|MD
argument_list|)
operator|:
name|Self
argument_list|(
name|P
argument_list|)
block|,
name|D
argument_list|(
name|MD
argument_list|)
block|,
name|TemplateScope
argument_list|(
argument|false
argument_list|)
block|{}
name|void
name|ParseLexedMethodDefs
argument_list|()
name|override
block|;   }
decl_stmt|;
comment|/// LateParsedDefaultArgument - Keeps track of a parameter that may
comment|/// have a default argument that cannot be parsed yet because it
comment|/// occurs within a member function declaration inside the class
comment|/// (C++ [class.mem]p2).
struct|struct
name|LateParsedDefaultArgument
block|{
name|explicit
name|LateParsedDefaultArgument
argument_list|(
name|Decl
operator|*
name|P
argument_list|,
name|std
operator|::
name|unique_ptr
operator|<
name|CachedTokens
operator|>
name|Toks
operator|=
name|nullptr
argument_list|)
range|:
name|Param
argument_list|(
name|P
argument_list|)
decl_stmt|,
name|Toks
argument_list|(
name|std
operator|::
name|move
argument_list|(
name|Toks
argument_list|)
argument_list|)
block|{ }
comment|/// Param - The parameter declaration for this parameter.
name|Decl
modifier|*
name|Param
decl_stmt|;
comment|/// Toks - The sequence of tokens that comprises the default
comment|/// argument expression, not including the '=' or the terminating
comment|/// ')' or ','. This will be NULL for parameters that have no
comment|/// default argument.
name|std
operator|::
name|unique_ptr
operator|<
name|CachedTokens
operator|>
name|Toks
expr_stmt|;
block|}
struct|;
comment|/// LateParsedMethodDeclaration - A method declaration inside a class that
comment|/// contains at least one entity whose parsing needs to be delayed
comment|/// until the class itself is completely-defined, such as a default
comment|/// argument (C++ [class.mem]p2).
name|struct
name|LateParsedMethodDeclaration
range|:
name|public
name|LateParsedDeclaration
block|{
name|explicit
name|LateParsedMethodDeclaration
argument_list|(
name|Parser
operator|*
name|P
argument_list|,
name|Decl
operator|*
name|M
argument_list|)
operator|:
name|Self
argument_list|(
name|P
argument_list|)
block|,
name|Method
argument_list|(
name|M
argument_list|)
block|,
name|TemplateScope
argument_list|(
name|false
argument_list|)
block|,
name|ExceptionSpecTokens
argument_list|(
argument|nullptr
argument_list|)
block|{}
name|void
name|ParseLexedMethodDeclarations
argument_list|()
name|override
block|;
name|Parser
operator|*
name|Self
block|;
comment|/// Method - The method declaration.
name|Decl
operator|*
name|Method
block|;
comment|/// \brief Whether this member function had an associated template
comment|/// scope. When true, D is a template declaration.
comment|/// othewise, it is a member function declaration.
name|bool
name|TemplateScope
block|;
comment|/// DefaultArgs - Contains the parameters of the function and
comment|/// their default arguments. At least one of the parameters will
comment|/// have a default argument, but all of the parameters of the
comment|/// method will be stored so that they can be reintroduced into
comment|/// scope at the appropriate times.
name|SmallVector
operator|<
name|LateParsedDefaultArgument
block|,
literal|8
operator|>
name|DefaultArgs
block|;
comment|/// \brief The set of tokens that make up an exception-specification that
comment|/// has not yet been parsed.
name|CachedTokens
operator|*
name|ExceptionSpecTokens
block|;   }
decl_stmt|;
comment|/// LateParsedMemberInitializer - An initializer for a non-static class data
comment|/// member whose parsing must to be delayed until the class is completely
comment|/// defined (C++11 [class.mem]p2).
name|struct
name|LateParsedMemberInitializer
range|:
name|public
name|LateParsedDeclaration
block|{
name|LateParsedMemberInitializer
argument_list|(
name|Parser
operator|*
name|P
argument_list|,
name|Decl
operator|*
name|FD
argument_list|)
operator|:
name|Self
argument_list|(
name|P
argument_list|)
block|,
name|Field
argument_list|(
argument|FD
argument_list|)
block|{ }
name|void
name|ParseLexedMemberInitializers
argument_list|()
name|override
block|;
name|Parser
operator|*
name|Self
block|;
comment|/// Field - The field declaration.
name|Decl
operator|*
name|Field
block|;
comment|/// CachedTokens - The sequence of tokens that comprises the initializer,
comment|/// including any leading '='.
name|CachedTokens
name|Toks
block|;   }
decl_stmt|;
comment|/// LateParsedDeclarationsContainer - During parsing of a top (non-nested)
comment|/// C++ class, its method declarations that contain parts that won't be
comment|/// parsed until after the definition is completed (C++ [class.mem]p2),
comment|/// the method declarations and possibly attached inline definitions
comment|/// will be stored here with the tokens that will be parsed to create those
comment|/// entities.
typedef|typedef
name|SmallVector
operator|<
name|LateParsedDeclaration
operator|*
operator|,
literal|2
operator|>
name|LateParsedDeclarationsContainer
expr_stmt|;
comment|/// \brief Representation of a class that has been parsed, including
comment|/// any member function declarations or definitions that need to be
comment|/// parsed after the corresponding top-level class is complete.
struct|struct
name|ParsingClass
block|{
name|ParsingClass
argument_list|(
argument|Decl *TagOrTemplate
argument_list|,
argument|bool TopLevelClass
argument_list|,
argument|bool IsInterface
argument_list|)
block|:
name|TopLevelClass
argument_list|(
name|TopLevelClass
argument_list|)
operator|,
name|TemplateScope
argument_list|(
name|false
argument_list|)
operator|,
name|IsInterface
argument_list|(
name|IsInterface
argument_list|)
operator|,
name|TagOrTemplate
argument_list|(
argument|TagOrTemplate
argument_list|)
block|{ }
comment|/// \brief Whether this is a "top-level" class, meaning that it is
comment|/// not nested within another class.
name|bool
name|TopLevelClass
operator|:
literal|1
expr_stmt|;
comment|/// \brief Whether this class had an associated template
comment|/// scope. When true, TagOrTemplate is a template declaration;
comment|/// othewise, it is a tag declaration.
name|bool
name|TemplateScope
range|:
literal|1
decl_stmt|;
comment|/// \brief Whether this class is an __interface.
name|bool
name|IsInterface
range|:
literal|1
decl_stmt|;
comment|/// \brief The class or class template whose definition we are parsing.
name|Decl
modifier|*
name|TagOrTemplate
decl_stmt|;
comment|/// LateParsedDeclarations - Method declarations, inline definitions and
comment|/// nested classes that contain pieces whose parsing will be delayed until
comment|/// the top-level class is fully defined.
name|LateParsedDeclarationsContainer
name|LateParsedDeclarations
decl_stmt|;
block|}
struct|;
comment|/// \brief The stack of classes that is currently being
comment|/// parsed. Nested and local classes will be pushed onto this stack
comment|/// when they are parsed, and removed afterward.
name|std
operator|::
name|stack
operator|<
name|ParsingClass
operator|*
operator|>
name|ClassStack
expr_stmt|;
name|ParsingClass
modifier|&
name|getCurrentClass
parameter_list|()
block|{
name|assert
argument_list|(
operator|!
name|ClassStack
operator|.
name|empty
argument_list|()
operator|&&
literal|"No lexed method stacks!"
argument_list|)
expr_stmt|;
return|return
operator|*
name|ClassStack
operator|.
name|top
argument_list|()
return|;
block|}
comment|/// \brief RAII object used to manage the parsing of a class definition.
name|class
name|ParsingClassDefinition
block|{
name|Parser
modifier|&
name|P
decl_stmt|;
name|bool
name|Popped
decl_stmt|;
name|Sema
operator|::
name|ParsingClassState
name|State
expr_stmt|;
name|public
label|:
name|ParsingClassDefinition
argument_list|(
argument|Parser&P
argument_list|,
argument|Decl *TagOrTemplate
argument_list|,
argument|bool TopLevelClass
argument_list|,
argument|bool IsInterface
argument_list|)
block|:
name|P
argument_list|(
name|P
argument_list|)
operator|,
name|Popped
argument_list|(
name|false
argument_list|)
operator|,
name|State
argument_list|(
argument|P.PushParsingClass(TagOrTemplate, TopLevelClass, IsInterface)
argument_list|)
block|{     }
comment|/// \brief Pop this class of the stack.
name|void
name|Pop
argument_list|()
block|{
name|assert
argument_list|(
operator|!
name|Popped
operator|&&
literal|"Nested class has already been popped"
argument_list|)
block|;
name|Popped
operator|=
name|true
block|;
name|P
operator|.
name|PopParsingClass
argument_list|(
name|State
argument_list|)
block|;     }
operator|~
name|ParsingClassDefinition
argument_list|()
block|{
if|if
condition|(
operator|!
name|Popped
condition|)
name|P
operator|.
name|PopParsingClass
argument_list|(
name|State
argument_list|)
expr_stmt|;
block|}
block|}
empty_stmt|;
comment|/// \brief Contains information about any template-specific
comment|/// information that has been parsed prior to parsing declaration
comment|/// specifiers.
struct|struct
name|ParsedTemplateInfo
block|{
name|ParsedTemplateInfo
argument_list|()
operator|:
name|Kind
argument_list|(
name|NonTemplate
argument_list|)
operator|,
name|TemplateParams
argument_list|(
name|nullptr
argument_list|)
operator|,
name|TemplateLoc
argument_list|()
block|{ }
name|ParsedTemplateInfo
argument_list|(
argument|TemplateParameterLists *TemplateParams
argument_list|,
argument|bool isSpecialization
argument_list|,
argument|bool lastParameterListWasEmpty = false
argument_list|)
operator|:
name|Kind
argument_list|(
name|isSpecialization
operator|?
name|ExplicitSpecialization
operator|:
name|Template
argument_list|)
operator|,
name|TemplateParams
argument_list|(
name|TemplateParams
argument_list|)
operator|,
name|LastParameterListWasEmpty
argument_list|(
argument|lastParameterListWasEmpty
argument_list|)
block|{ }
name|explicit
name|ParsedTemplateInfo
argument_list|(
argument|SourceLocation ExternLoc
argument_list|,
argument|SourceLocation TemplateLoc
argument_list|)
operator|:
name|Kind
argument_list|(
name|ExplicitInstantiation
argument_list|)
operator|,
name|TemplateParams
argument_list|(
name|nullptr
argument_list|)
operator|,
name|ExternLoc
argument_list|(
name|ExternLoc
argument_list|)
operator|,
name|TemplateLoc
argument_list|(
name|TemplateLoc
argument_list|)
operator|,
name|LastParameterListWasEmpty
argument_list|(
argument|false
argument_list|)
block|{ }
comment|/// \brief The kind of template we are parsing.
expr|enum
block|{
comment|/// \brief We are not parsing a template at all.
name|NonTemplate
operator|=
literal|0
block|,
comment|/// \brief We are parsing a template declaration.
name|Template
block|,
comment|/// \brief We are parsing an explicit specialization.
name|ExplicitSpecialization
block|,
comment|/// \brief We are parsing an explicit instantiation.
name|ExplicitInstantiation
block|}
name|Kind
expr_stmt|;
comment|/// \brief The template parameter lists, for template declarations
comment|/// and explicit specializations.
name|TemplateParameterLists
modifier|*
name|TemplateParams
decl_stmt|;
comment|/// \brief The location of the 'extern' keyword, if any, for an explicit
comment|/// instantiation
name|SourceLocation
name|ExternLoc
decl_stmt|;
comment|/// \brief The location of the 'template' keyword, for an explicit
comment|/// instantiation.
name|SourceLocation
name|TemplateLoc
decl_stmt|;
comment|/// \brief Whether the last template parameter list was empty.
name|bool
name|LastParameterListWasEmpty
decl_stmt|;
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
name|LLVM_READONLY
expr_stmt|;
block|}
struct|;
name|void
name|LexTemplateFunctionForLateParsing
parameter_list|(
name|CachedTokens
modifier|&
name|Toks
parameter_list|)
function_decl|;
name|void
name|ParseLateTemplatedFuncDef
parameter_list|(
name|LateParsedTemplate
modifier|&
name|LPT
parameter_list|)
function_decl|;
specifier|static
name|void
name|LateTemplateParserCallback
parameter_list|(
name|void
modifier|*
name|P
parameter_list|,
name|LateParsedTemplate
modifier|&
name|LPT
parameter_list|)
function_decl|;
specifier|static
name|void
name|LateTemplateParserCleanupCallback
parameter_list|(
name|void
modifier|*
name|P
parameter_list|)
function_decl|;
name|Sema
operator|::
name|ParsingClassState
name|PushParsingClass
argument_list|(
argument|Decl *TagOrTemplate
argument_list|,
argument|bool TopLevelClass
argument_list|,
argument|bool IsInterface
argument_list|)
expr_stmt|;
name|void
name|DeallocateParsedClasses
parameter_list|(
name|ParsingClass
modifier|*
name|Class
parameter_list|)
function_decl|;
name|void
name|PopParsingClass
argument_list|(
name|Sema
operator|::
name|ParsingClassState
argument_list|)
decl_stmt|;
enum|enum
name|CachedInitKind
block|{
name|CIK_DefaultArgument
block|,
name|CIK_DefaultInitializer
block|}
enum|;
name|NamedDecl
modifier|*
name|ParseCXXInlineMethodDef
parameter_list|(
name|AccessSpecifier
name|AS
parameter_list|,
name|AttributeList
modifier|*
name|AccessAttrs
parameter_list|,
name|ParsingDeclarator
modifier|&
name|D
parameter_list|,
specifier|const
name|ParsedTemplateInfo
modifier|&
name|TemplateInfo
parameter_list|,
specifier|const
name|VirtSpecifiers
modifier|&
name|VS
parameter_list|,
name|SourceLocation
name|PureSpecLoc
parameter_list|)
function_decl|;
name|void
name|ParseCXXNonStaticMemberInitializer
parameter_list|(
name|Decl
modifier|*
name|VarD
parameter_list|)
function_decl|;
name|void
name|ParseLexedAttributes
parameter_list|(
name|ParsingClass
modifier|&
name|Class
parameter_list|)
function_decl|;
name|void
name|ParseLexedAttributeList
parameter_list|(
name|LateParsedAttrList
modifier|&
name|LAs
parameter_list|,
name|Decl
modifier|*
name|D
parameter_list|,
name|bool
name|EnterScope
parameter_list|,
name|bool
name|OnDefinition
parameter_list|)
function_decl|;
name|void
name|ParseLexedAttribute
parameter_list|(
name|LateParsedAttribute
modifier|&
name|LA
parameter_list|,
name|bool
name|EnterScope
parameter_list|,
name|bool
name|OnDefinition
parameter_list|)
function_decl|;
name|void
name|ParseLexedMethodDeclarations
parameter_list|(
name|ParsingClass
modifier|&
name|Class
parameter_list|)
function_decl|;
name|void
name|ParseLexedMethodDeclaration
parameter_list|(
name|LateParsedMethodDeclaration
modifier|&
name|LM
parameter_list|)
function_decl|;
name|void
name|ParseLexedMethodDefs
parameter_list|(
name|ParsingClass
modifier|&
name|Class
parameter_list|)
function_decl|;
name|void
name|ParseLexedMethodDef
parameter_list|(
name|LexedMethod
modifier|&
name|LM
parameter_list|)
function_decl|;
name|void
name|ParseLexedMemberInitializers
parameter_list|(
name|ParsingClass
modifier|&
name|Class
parameter_list|)
function_decl|;
name|void
name|ParseLexedMemberInitializer
parameter_list|(
name|LateParsedMemberInitializer
modifier|&
name|MI
parameter_list|)
function_decl|;
name|void
name|ParseLexedObjCMethodDefs
parameter_list|(
name|LexedMethod
modifier|&
name|LM
parameter_list|,
name|bool
name|parseMethod
parameter_list|)
function_decl|;
name|bool
name|ConsumeAndStoreFunctionPrologue
parameter_list|(
name|CachedTokens
modifier|&
name|Toks
parameter_list|)
function_decl|;
name|bool
name|ConsumeAndStoreInitializer
parameter_list|(
name|CachedTokens
modifier|&
name|Toks
parameter_list|,
name|CachedInitKind
name|CIK
parameter_list|)
function_decl|;
name|bool
name|ConsumeAndStoreConditional
parameter_list|(
name|CachedTokens
modifier|&
name|Toks
parameter_list|)
function_decl|;
name|bool
name|ConsumeAndStoreUntil
argument_list|(
name|tok
operator|::
name|TokenKind
name|T1
argument_list|,
name|CachedTokens
operator|&
name|Toks
argument_list|,
name|bool
name|StopAtSemi
operator|=
name|true
argument_list|,
name|bool
name|ConsumeFinalToken
operator|=
name|true
argument_list|)
block|{
return|return
name|ConsumeAndStoreUntil
argument_list|(
name|T1
argument_list|,
name|T1
argument_list|,
name|Toks
argument_list|,
name|StopAtSemi
argument_list|,
name|ConsumeFinalToken
argument_list|)
return|;
block|}
name|bool
name|ConsumeAndStoreUntil
argument_list|(
name|tok
operator|::
name|TokenKind
name|T1
argument_list|,
name|tok
operator|::
name|TokenKind
name|T2
argument_list|,
name|CachedTokens
operator|&
name|Toks
argument_list|,
name|bool
name|StopAtSemi
operator|=
name|true
argument_list|,
name|bool
name|ConsumeFinalToken
operator|=
name|true
argument_list|)
decl_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|// C99 6.9: External Definitions.
name|struct
name|ParsedAttributesWithRange
range|:
name|ParsedAttributes
block|{
name|ParsedAttributesWithRange
argument_list|(
name|AttributeFactory
operator|&
name|factory
argument_list|)
operator|:
name|ParsedAttributes
argument_list|(
argument|factory
argument_list|)
block|{}
name|void
name|clear
argument_list|()
block|{
name|ParsedAttributes
operator|::
name|clear
argument_list|()
block|;
name|Range
operator|=
name|SourceRange
argument_list|()
block|;     }
name|SourceRange
name|Range
block|;   }
decl_stmt|;
name|DeclGroupPtrTy
name|ParseExternalDeclaration
parameter_list|(
name|ParsedAttributesWithRange
modifier|&
name|attrs
parameter_list|,
name|ParsingDeclSpec
modifier|*
name|DS
init|=
name|nullptr
parameter_list|)
function_decl|;
name|bool
name|isDeclarationAfterDeclarator
parameter_list|()
function_decl|;
name|bool
name|isStartOfFunctionDefinition
parameter_list|(
specifier|const
name|ParsingDeclarator
modifier|&
name|Declarator
parameter_list|)
function_decl|;
name|DeclGroupPtrTy
name|ParseDeclarationOrFunctionDefinition
parameter_list|(
name|ParsedAttributesWithRange
modifier|&
name|attrs
parameter_list|,
name|ParsingDeclSpec
modifier|*
name|DS
init|=
name|nullptr
parameter_list|,
name|AccessSpecifier
name|AS
init|=
name|AS_none
parameter_list|)
function_decl|;
name|DeclGroupPtrTy
name|ParseDeclOrFunctionDefInternal
parameter_list|(
name|ParsedAttributesWithRange
modifier|&
name|attrs
parameter_list|,
name|ParsingDeclSpec
modifier|&
name|DS
parameter_list|,
name|AccessSpecifier
name|AS
parameter_list|)
function_decl|;
name|void
name|SkipFunctionBody
parameter_list|()
function_decl|;
name|Decl
modifier|*
name|ParseFunctionDefinition
parameter_list|(
name|ParsingDeclarator
modifier|&
name|D
parameter_list|,
specifier|const
name|ParsedTemplateInfo
modifier|&
name|TemplateInfo
init|=
name|ParsedTemplateInfo
argument_list|()
parameter_list|,
name|LateParsedAttrList
modifier|*
name|LateParsedAttrs
init|=
name|nullptr
parameter_list|)
function_decl|;
name|void
name|ParseKNRParamDeclarations
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|)
function_decl|;
comment|// EndLoc, if non-NULL, is filled with the location of the last token of
comment|// the simple-asm.
name|ExprResult
name|ParseSimpleAsm
parameter_list|(
name|SourceLocation
modifier|*
name|EndLoc
init|=
name|nullptr
parameter_list|)
function_decl|;
name|ExprResult
name|ParseAsmStringLiteral
parameter_list|()
function_decl|;
comment|// Objective-C External Declarations
name|void
name|MaybeSkipAttributes
argument_list|(
name|tok
operator|::
name|ObjCKeywordKind
name|Kind
argument_list|)
decl_stmt|;
name|DeclGroupPtrTy
name|ParseObjCAtDirectives
parameter_list|()
function_decl|;
name|DeclGroupPtrTy
name|ParseObjCAtClassDeclaration
parameter_list|(
name|SourceLocation
name|atLoc
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseObjCAtInterfaceDeclaration
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|,
name|ParsedAttributes
modifier|&
name|prefixAttrs
parameter_list|)
function_decl|;
name|class
name|ObjCTypeParamListScope
decl_stmt|;
name|ObjCTypeParamList
modifier|*
name|parseObjCTypeParamList
parameter_list|()
function_decl|;
name|ObjCTypeParamList
modifier|*
name|parseObjCTypeParamListOrProtocolRefs
argument_list|(
name|ObjCTypeParamListScope
operator|&
name|Scope
argument_list|,
name|SourceLocation
operator|&
name|lAngleLoc
argument_list|,
name|SmallVectorImpl
operator|<
name|IdentifierLocPair
operator|>
operator|&
name|protocolIdents
argument_list|,
name|SourceLocation
operator|&
name|rAngleLoc
argument_list|,
name|bool
name|mayBeProtocolList
operator|=
name|true
argument_list|)
decl_stmt|;
name|void
name|HelperActionsForIvarDeclarations
argument_list|(
name|Decl
operator|*
name|interfaceDecl
argument_list|,
name|SourceLocation
name|atLoc
argument_list|,
name|BalancedDelimiterTracker
operator|&
name|T
argument_list|,
name|SmallVectorImpl
operator|<
name|Decl
operator|*
operator|>
operator|&
name|AllIvarDecls
argument_list|,
name|bool
name|RBraceMissing
argument_list|)
decl_stmt|;
name|void
name|ParseObjCClassInstanceVariables
argument_list|(
name|Decl
operator|*
name|interfaceDecl
argument_list|,
name|tok
operator|::
name|ObjCKeywordKind
name|visibility
argument_list|,
name|SourceLocation
name|atLoc
argument_list|)
decl_stmt|;
name|bool
name|ParseObjCProtocolReferences
argument_list|(
name|SmallVectorImpl
operator|<
name|Decl
operator|*
operator|>
operator|&
name|P
argument_list|,
name|SmallVectorImpl
operator|<
name|SourceLocation
operator|>
operator|&
name|PLocs
argument_list|,
name|bool
name|WarnOnDeclarations
argument_list|,
name|bool
name|ForObjCContainer
argument_list|,
name|SourceLocation
operator|&
name|LAngleLoc
argument_list|,
name|SourceLocation
operator|&
name|EndProtoLoc
argument_list|,
name|bool
name|consumeLastToken
argument_list|)
decl_stmt|;
comment|/// Parse the first angle-bracket-delimited clause for an
comment|/// Objective-C object or object pointer type, which may be either
comment|/// type arguments or protocol qualifiers.
name|void
name|parseObjCTypeArgsOrProtocolQualifiers
argument_list|(
name|ParsedType
name|baseType
argument_list|,
name|SourceLocation
operator|&
name|typeArgsLAngleLoc
argument_list|,
name|SmallVectorImpl
operator|<
name|ParsedType
operator|>
operator|&
name|typeArgs
argument_list|,
name|SourceLocation
operator|&
name|typeArgsRAngleLoc
argument_list|,
name|SourceLocation
operator|&
name|protocolLAngleLoc
argument_list|,
name|SmallVectorImpl
operator|<
name|Decl
operator|*
operator|>
operator|&
name|protocols
argument_list|,
name|SmallVectorImpl
operator|<
name|SourceLocation
operator|>
operator|&
name|protocolLocs
argument_list|,
name|SourceLocation
operator|&
name|protocolRAngleLoc
argument_list|,
name|bool
name|consumeLastToken
argument_list|,
name|bool
name|warnOnIncompleteProtocols
argument_list|)
decl_stmt|;
comment|/// Parse either Objective-C type arguments or protocol qualifiers; if the
comment|/// former, also parse protocol qualifiers afterward.
name|void
name|parseObjCTypeArgsAndProtocolQualifiers
argument_list|(
name|ParsedType
name|baseType
argument_list|,
name|SourceLocation
operator|&
name|typeArgsLAngleLoc
argument_list|,
name|SmallVectorImpl
operator|<
name|ParsedType
operator|>
operator|&
name|typeArgs
argument_list|,
name|SourceLocation
operator|&
name|typeArgsRAngleLoc
argument_list|,
name|SourceLocation
operator|&
name|protocolLAngleLoc
argument_list|,
name|SmallVectorImpl
operator|<
name|Decl
operator|*
operator|>
operator|&
name|protocols
argument_list|,
name|SmallVectorImpl
operator|<
name|SourceLocation
operator|>
operator|&
name|protocolLocs
argument_list|,
name|SourceLocation
operator|&
name|protocolRAngleLoc
argument_list|,
name|bool
name|consumeLastToken
argument_list|)
decl_stmt|;
comment|/// Parse a protocol qualifier type such as '<NSCopying>', which is
comment|/// an anachronistic way of writing 'id<NSCopying>'.
name|TypeResult
name|parseObjCProtocolQualifierType
parameter_list|(
name|SourceLocation
modifier|&
name|rAngleLoc
parameter_list|)
function_decl|;
comment|/// Parse Objective-C type arguments and protocol qualifiers, extending the
comment|/// current type with the parsed result.
name|TypeResult
name|parseObjCTypeArgsAndProtocolQualifiers
parameter_list|(
name|SourceLocation
name|loc
parameter_list|,
name|ParsedType
name|type
parameter_list|,
name|bool
name|consumeLastToken
parameter_list|,
name|SourceLocation
modifier|&
name|endLoc
parameter_list|)
function_decl|;
name|void
name|ParseObjCInterfaceDeclList
argument_list|(
name|tok
operator|::
name|ObjCKeywordKind
name|contextKey
argument_list|,
name|Decl
operator|*
name|CDecl
argument_list|)
decl_stmt|;
name|DeclGroupPtrTy
name|ParseObjCAtProtocolDeclaration
parameter_list|(
name|SourceLocation
name|atLoc
parameter_list|,
name|ParsedAttributes
modifier|&
name|prefixAttrs
parameter_list|)
function_decl|;
struct|struct
name|ObjCImplParsingDataRAII
block|{
name|Parser
modifier|&
name|P
decl_stmt|;
name|Decl
modifier|*
name|Dcl
decl_stmt|;
name|bool
name|HasCFunction
decl_stmt|;
typedef|typedef
name|SmallVector
operator|<
name|LexedMethod
operator|*
operator|,
literal|8
operator|>
name|LateParsedObjCMethodContainer
expr_stmt|;
name|LateParsedObjCMethodContainer
name|LateParsedObjCMethods
decl_stmt|;
name|ObjCImplParsingDataRAII
argument_list|(
name|Parser
operator|&
name|parser
argument_list|,
name|Decl
operator|*
name|D
argument_list|)
operator|:
name|P
argument_list|(
name|parser
argument_list|)
operator|,
name|Dcl
argument_list|(
name|D
argument_list|)
operator|,
name|HasCFunction
argument_list|(
argument|false
argument_list|)
block|{
name|P
operator|.
name|CurParsedObjCImpl
operator|=
name|this
block|;
name|Finished
operator|=
name|false
block|;     }
operator|~
name|ObjCImplParsingDataRAII
argument_list|()
expr_stmt|;
name|void
name|finish
parameter_list|(
name|SourceRange
name|AtEnd
parameter_list|)
function_decl|;
name|bool
name|isFinished
argument_list|()
specifier|const
block|{
return|return
name|Finished
return|;
block|}
name|private
label|:
name|bool
name|Finished
decl_stmt|;
block|}
struct|;
name|ObjCImplParsingDataRAII
modifier|*
name|CurParsedObjCImpl
decl_stmt|;
name|void
name|StashAwayMethodOrFunctionBodyTokens
parameter_list|(
name|Decl
modifier|*
name|MDecl
parameter_list|)
function_decl|;
name|DeclGroupPtrTy
name|ParseObjCAtImplementationDeclaration
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|)
function_decl|;
name|DeclGroupPtrTy
name|ParseObjCAtEndDeclaration
parameter_list|(
name|SourceRange
name|atEnd
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseObjCAtAliasDeclaration
parameter_list|(
name|SourceLocation
name|atLoc
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseObjCPropertySynthesize
parameter_list|(
name|SourceLocation
name|atLoc
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseObjCPropertyDynamic
parameter_list|(
name|SourceLocation
name|atLoc
parameter_list|)
function_decl|;
name|IdentifierInfo
modifier|*
name|ParseObjCSelectorPiece
parameter_list|(
name|SourceLocation
modifier|&
name|MethodLocation
parameter_list|)
function_decl|;
comment|// Definitions for Objective-c context sensitive keywords recognition.
enum|enum
name|ObjCTypeQual
block|{
name|objc_in
init|=
literal|0
block|,
name|objc_out
block|,
name|objc_inout
block|,
name|objc_oneway
block|,
name|objc_bycopy
block|,
name|objc_byref
block|,
name|objc_nonnull
block|,
name|objc_nullable
block|,
name|objc_null_unspecified
block|,
name|objc_NumQuals
block|}
enum|;
name|IdentifierInfo
modifier|*
name|ObjCTypeQuals
index|[
name|objc_NumQuals
index|]
decl_stmt|;
name|bool
name|isTokIdentifier_in
argument_list|()
specifier|const
expr_stmt|;
name|ParsedType
name|ParseObjCTypeName
argument_list|(
name|ObjCDeclSpec
operator|&
name|DS
argument_list|,
name|Declarator
operator|::
name|TheContext
name|Ctx
argument_list|,
name|ParsedAttributes
operator|*
name|ParamAttrs
argument_list|)
decl_stmt|;
name|void
name|ParseObjCMethodRequirement
parameter_list|()
function_decl|;
name|Decl
modifier|*
name|ParseObjCMethodPrototype
argument_list|(
name|tok
operator|::
name|ObjCKeywordKind
name|MethodImplKind
operator|=
name|tok
operator|::
name|objc_not_keyword
argument_list|,
name|bool
name|MethodDefinition
operator|=
name|true
argument_list|)
decl_stmt|;
name|Decl
modifier|*
name|ParseObjCMethodDecl
argument_list|(
name|SourceLocation
name|mLoc
argument_list|,
name|tok
operator|::
name|TokenKind
name|mType
argument_list|,
name|tok
operator|::
name|ObjCKeywordKind
name|MethodImplKind
operator|=
name|tok
operator|::
name|objc_not_keyword
argument_list|,
name|bool
name|MethodDefinition
operator|=
name|true
argument_list|)
decl_stmt|;
name|void
name|ParseObjCPropertyAttribute
parameter_list|(
name|ObjCDeclSpec
modifier|&
name|DS
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseObjCMethodDefinition
parameter_list|()
function_decl|;
name|public
label|:
comment|//===--------------------------------------------------------------------===//
comment|// C99 6.5: Expressions.
comment|/// TypeCastState - State whether an expression is or may be a type cast.
enum|enum
name|TypeCastState
block|{
name|NotTypeCast
init|=
literal|0
block|,
name|MaybeTypeCast
block|,
name|IsTypeCast
block|}
enum|;
name|ExprResult
name|ParseExpression
parameter_list|(
name|TypeCastState
name|isTypeCast
init|=
name|NotTypeCast
parameter_list|)
function_decl|;
name|ExprResult
name|ParseConstantExpression
parameter_list|(
name|TypeCastState
name|isTypeCast
init|=
name|NotTypeCast
parameter_list|)
function_decl|;
name|ExprResult
name|ParseConstraintExpression
parameter_list|()
function_decl|;
comment|// Expr that doesn't include commas.
name|ExprResult
name|ParseAssignmentExpression
parameter_list|(
name|TypeCastState
name|isTypeCast
init|=
name|NotTypeCast
parameter_list|)
function_decl|;
name|ExprResult
name|ParseMSAsmIdentifier
argument_list|(
name|llvm
operator|::
name|SmallVectorImpl
operator|<
name|Token
operator|>
operator|&
name|LineToks
argument_list|,
name|unsigned
operator|&
name|NumLineToksConsumed
argument_list|,
name|void
operator|*
name|Info
argument_list|,
name|bool
name|IsUnevaluated
argument_list|)
decl_stmt|;
name|private
label|:
name|ExprResult
name|ParseExpressionWithLeadingAt
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|)
function_decl|;
name|ExprResult
name|ParseExpressionWithLeadingExtension
parameter_list|(
name|SourceLocation
name|ExtLoc
parameter_list|)
function_decl|;
name|ExprResult
name|ParseRHSOfBinaryExpression
argument_list|(
name|ExprResult
name|LHS
argument_list|,
name|prec
operator|::
name|Level
name|MinPrec
argument_list|)
decl_stmt|;
name|ExprResult
name|ParseCastExpression
parameter_list|(
name|bool
name|isUnaryExpression
parameter_list|,
name|bool
name|isAddressOfOperand
parameter_list|,
name|bool
modifier|&
name|NotCastExpr
parameter_list|,
name|TypeCastState
name|isTypeCast
parameter_list|)
function_decl|;
name|ExprResult
name|ParseCastExpression
parameter_list|(
name|bool
name|isUnaryExpression
parameter_list|,
name|bool
name|isAddressOfOperand
init|=
name|false
parameter_list|,
name|TypeCastState
name|isTypeCast
init|=
name|NotTypeCast
parameter_list|)
function_decl|;
comment|/// Returns true if the next token cannot start an expression.
name|bool
name|isNotExpressionStart
parameter_list|()
function_decl|;
comment|/// Returns true if the next token would start a postfix-expression
comment|/// suffix.
name|bool
name|isPostfixExpressionSuffixStart
parameter_list|()
block|{
name|tok
operator|::
name|TokenKind
name|K
operator|=
name|Tok
operator|.
name|getKind
argument_list|()
expr_stmt|;
return|return
operator|(
name|K
operator|==
name|tok
operator|::
name|l_square
operator|||
name|K
operator|==
name|tok
operator|::
name|l_paren
operator|||
name|K
operator|==
name|tok
operator|::
name|period
operator|||
name|K
operator|==
name|tok
operator|::
name|arrow
operator|||
name|K
operator|==
name|tok
operator|::
name|plusplus
operator|||
name|K
operator|==
name|tok
operator|::
name|minusminus
operator|)
return|;
block|}
name|ExprResult
name|ParsePostfixExpressionSuffix
parameter_list|(
name|ExprResult
name|LHS
parameter_list|)
function_decl|;
name|ExprResult
name|ParseUnaryExprOrTypeTraitExpression
parameter_list|()
function_decl|;
name|ExprResult
name|ParseBuiltinPrimaryExpression
parameter_list|()
function_decl|;
name|ExprResult
name|ParseExprAfterUnaryExprOrTypeTrait
parameter_list|(
specifier|const
name|Token
modifier|&
name|OpTok
parameter_list|,
name|bool
modifier|&
name|isCastExpr
parameter_list|,
name|ParsedType
modifier|&
name|CastTy
parameter_list|,
name|SourceRange
modifier|&
name|CastRange
parameter_list|)
function_decl|;
typedef|typedef
name|SmallVector
operator|<
name|Expr
operator|*
operator|,
literal|20
operator|>
name|ExprListTy
expr_stmt|;
typedef|typedef
name|SmallVector
operator|<
name|SourceLocation
operator|,
literal|20
operator|>
name|CommaLocsTy
expr_stmt|;
comment|/// ParseExpressionList - Used for C/C++ (argument-)expression-list.
name|bool
name|ParseExpressionList
argument_list|(
name|SmallVectorImpl
operator|<
name|Expr
operator|*
operator|>
operator|&
name|Exprs
argument_list|,
name|SmallVectorImpl
operator|<
name|SourceLocation
operator|>
operator|&
name|CommaLocs
argument_list|,
name|std
operator|::
name|function
operator|<
name|void
argument_list|()
operator|>
name|Completer
operator|=
name|nullptr
argument_list|)
decl_stmt|;
comment|/// ParseSimpleExpressionList - A simple comma-separated list of expressions,
comment|/// used for misc language extensions.
name|bool
name|ParseSimpleExpressionList
argument_list|(
name|SmallVectorImpl
operator|<
name|Expr
operator|*
operator|>
operator|&
name|Exprs
argument_list|,
name|SmallVectorImpl
operator|<
name|SourceLocation
operator|>
operator|&
name|CommaLocs
argument_list|)
decl_stmt|;
comment|/// ParenParseOption - Control what ParseParenExpression will parse.
enum|enum
name|ParenParseOption
block|{
name|SimpleExpr
block|,
comment|// Only parse '(' expression ')'
name|CompoundStmt
block|,
comment|// Also allow '(' compound-statement ')'
name|CompoundLiteral
block|,
comment|// Also allow '(' type-name ')' '{' ... '}'
name|CastExpr
comment|// Also allow '(' type-name ')'<anything>
block|}
enum|;
name|ExprResult
name|ParseParenExpression
parameter_list|(
name|ParenParseOption
modifier|&
name|ExprType
parameter_list|,
name|bool
name|stopIfCastExpr
parameter_list|,
name|bool
name|isTypeCast
parameter_list|,
name|ParsedType
modifier|&
name|CastTy
parameter_list|,
name|SourceLocation
modifier|&
name|RParenLoc
parameter_list|)
function_decl|;
name|ExprResult
name|ParseCXXAmbiguousParenExpression
parameter_list|(
name|ParenParseOption
modifier|&
name|ExprType
parameter_list|,
name|ParsedType
modifier|&
name|CastTy
parameter_list|,
name|BalancedDelimiterTracker
modifier|&
name|Tracker
parameter_list|,
name|ColonProtectionRAIIObject
modifier|&
name|ColonProt
parameter_list|)
function_decl|;
name|ExprResult
name|ParseCompoundLiteralExpression
parameter_list|(
name|ParsedType
name|Ty
parameter_list|,
name|SourceLocation
name|LParenLoc
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
function_decl|;
name|ExprResult
name|ParseStringLiteralExpression
parameter_list|(
name|bool
name|AllowUserDefinedLiteral
init|=
name|false
parameter_list|)
function_decl|;
name|ExprResult
name|ParseGenericSelectionExpression
parameter_list|()
function_decl|;
name|ExprResult
name|ParseObjCBoolLiteral
parameter_list|()
function_decl|;
name|ExprResult
name|ParseFoldExpression
parameter_list|(
name|ExprResult
name|LHS
parameter_list|,
name|BalancedDelimiterTracker
modifier|&
name|T
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ Expressions
name|ExprResult
name|tryParseCXXIdExpression
parameter_list|(
name|CXXScopeSpec
modifier|&
name|SS
parameter_list|,
name|bool
name|isAddressOfOperand
parameter_list|,
name|Token
modifier|&
name|Replacement
parameter_list|)
function_decl|;
name|ExprResult
name|ParseCXXIdExpression
parameter_list|(
name|bool
name|isAddressOfOperand
init|=
name|false
parameter_list|)
function_decl|;
name|bool
name|areTokensAdjacent
parameter_list|(
specifier|const
name|Token
modifier|&
name|A
parameter_list|,
specifier|const
name|Token
modifier|&
name|B
parameter_list|)
function_decl|;
name|void
name|CheckForTemplateAndDigraph
parameter_list|(
name|Token
modifier|&
name|Next
parameter_list|,
name|ParsedType
name|ObjectTypePtr
parameter_list|,
name|bool
name|EnteringContext
parameter_list|,
name|IdentifierInfo
modifier|&
name|II
parameter_list|,
name|CXXScopeSpec
modifier|&
name|SS
parameter_list|)
function_decl|;
name|bool
name|ParseOptionalCXXScopeSpecifier
parameter_list|(
name|CXXScopeSpec
modifier|&
name|SS
parameter_list|,
name|ParsedType
name|ObjectType
parameter_list|,
name|bool
name|EnteringContext
parameter_list|,
name|bool
modifier|*
name|MayBePseudoDestructor
init|=
name|nullptr
parameter_list|,
name|bool
name|IsTypename
init|=
name|false
parameter_list|,
name|IdentifierInfo
modifier|*
modifier|*
name|LastII
init|=
name|nullptr
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++0x 5.1.2: Lambda expressions
comment|// [...] () -> type {...}
name|ExprResult
name|ParseLambdaExpression
parameter_list|()
function_decl|;
name|ExprResult
name|TryParseLambdaExpression
parameter_list|()
function_decl|;
name|Optional
operator|<
name|unsigned
operator|>
name|ParseLambdaIntroducer
argument_list|(
name|LambdaIntroducer
operator|&
name|Intro
argument_list|,
name|bool
operator|*
name|SkippedInits
operator|=
name|nullptr
argument_list|)
expr_stmt|;
name|bool
name|TryParseLambdaIntroducer
parameter_list|(
name|LambdaIntroducer
modifier|&
name|Intro
parameter_list|)
function_decl|;
name|ExprResult
name|ParseLambdaExpressionAfterIntroducer
parameter_list|(
name|LambdaIntroducer
modifier|&
name|Intro
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 5.2p1: C++ Casts
name|ExprResult
name|ParseCXXCasts
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 5.2p1: C++ Type Identification
name|ExprResult
name|ParseCXXTypeid
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|//  C++ : Microsoft __uuidof Expression
name|ExprResult
name|ParseCXXUuidof
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 5.2.4: C++ Pseudo-Destructor Expressions
name|ExprResult
name|ParseCXXPseudoDestructor
argument_list|(
name|Expr
operator|*
name|Base
argument_list|,
name|SourceLocation
name|OpLoc
argument_list|,
name|tok
operator|::
name|TokenKind
name|OpKind
argument_list|,
name|CXXScopeSpec
operator|&
name|SS
argument_list|,
name|ParsedType
name|ObjectType
argument_list|)
decl_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 9.3.2: C++ 'this' pointer
name|ExprResult
name|ParseCXXThis
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 15: C++ Throw Expression
name|ExprResult
name|ParseThrowExpression
parameter_list|()
function_decl|;
name|ExceptionSpecificationType
name|tryParseExceptionSpecification
argument_list|(
name|bool
name|Delayed
argument_list|,
name|SourceRange
operator|&
name|SpecificationRange
argument_list|,
name|SmallVectorImpl
operator|<
name|ParsedType
operator|>
operator|&
name|DynamicExceptions
argument_list|,
name|SmallVectorImpl
operator|<
name|SourceRange
operator|>
operator|&
name|DynamicExceptionRanges
argument_list|,
name|ExprResult
operator|&
name|NoexceptExpr
argument_list|,
name|CachedTokens
operator|*
operator|&
name|ExceptionSpecTokens
argument_list|)
decl_stmt|;
comment|// EndLoc is filled with the location of the last token of the specification.
name|ExceptionSpecificationType
name|ParseDynamicExceptionSpecification
argument_list|(
name|SourceRange
operator|&
name|SpecificationRange
argument_list|,
name|SmallVectorImpl
operator|<
name|ParsedType
operator|>
operator|&
name|Exceptions
argument_list|,
name|SmallVectorImpl
operator|<
name|SourceRange
operator|>
operator|&
name|Ranges
argument_list|)
decl_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|// C++0x 8: Function declaration trailing-return-type
name|TypeResult
name|ParseTrailingReturnType
parameter_list|(
name|SourceRange
modifier|&
name|Range
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 2.13.5: C++ Boolean Literals
name|ExprResult
name|ParseCXXBoolLiteral
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 5.2.3: Explicit type conversion (functional notation)
name|ExprResult
name|ParseCXXTypeConstructExpression
parameter_list|(
specifier|const
name|DeclSpec
modifier|&
name|DS
parameter_list|)
function_decl|;
comment|/// ParseCXXSimpleTypeSpecifier - [C++ 7.1.5.2] Simple type specifiers.
comment|/// This should only be called when the current token is known to be part of
comment|/// simple-type-specifier.
name|void
name|ParseCXXSimpleTypeSpecifier
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|)
function_decl|;
name|bool
name|ParseCXXTypeSpecifierSeq
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 5.3.4 and 5.3.5: C++ new and delete
name|bool
name|ParseExpressionListOrTypeId
argument_list|(
name|SmallVectorImpl
operator|<
name|Expr
operator|*
operator|>
operator|&
name|Exprs
argument_list|,
name|Declarator
operator|&
name|D
argument_list|)
decl_stmt|;
name|void
name|ParseDirectNewDeclarator
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|)
function_decl|;
name|ExprResult
name|ParseCXXNewExpression
parameter_list|(
name|bool
name|UseGlobal
parameter_list|,
name|SourceLocation
name|Start
parameter_list|)
function_decl|;
name|ExprResult
name|ParseCXXDeleteExpression
parameter_list|(
name|bool
name|UseGlobal
parameter_list|,
name|SourceLocation
name|Start
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ if/switch/while condition expression.
name|Sema
operator|::
name|ConditionResult
name|ParseCXXCondition
argument_list|(
argument|StmtResult *InitStmt
argument_list|,
argument|SourceLocation Loc
argument_list|,
argument|Sema::ConditionKind CK
argument_list|)
expr_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ Coroutines
name|ExprResult
name|ParseCoyieldExpression
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C99 6.7.8: Initialization.
comment|/// ParseInitializer
comment|///       initializer: [C99 6.7.8]
comment|///         assignment-expression
comment|///         '{' ...
name|ExprResult
name|ParseInitializer
parameter_list|()
block|{
if|if
condition|(
name|Tok
operator|.
name|isNot
argument_list|(
name|tok
operator|::
name|l_brace
argument_list|)
condition|)
return|return
name|ParseAssignmentExpression
argument_list|()
return|;
return|return
name|ParseBraceInitializer
argument_list|()
return|;
block|}
name|bool
name|MayBeDesignationStart
parameter_list|()
function_decl|;
name|ExprResult
name|ParseBraceInitializer
parameter_list|()
function_decl|;
name|ExprResult
name|ParseInitializerWithPotentialDesignator
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// clang Expressions
name|ExprResult
name|ParseBlockLiteralExpression
parameter_list|()
function_decl|;
comment|// ^{...}
comment|//===--------------------------------------------------------------------===//
comment|// Objective-C Expressions
name|ExprResult
name|ParseObjCAtExpression
parameter_list|(
name|SourceLocation
name|AtLocation
parameter_list|)
function_decl|;
name|ExprResult
name|ParseObjCStringLiteral
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|)
function_decl|;
name|ExprResult
name|ParseObjCCharacterLiteral
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|)
function_decl|;
name|ExprResult
name|ParseObjCNumericLiteral
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|)
function_decl|;
name|ExprResult
name|ParseObjCBooleanLiteral
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|,
name|bool
name|ArgValue
parameter_list|)
function_decl|;
name|ExprResult
name|ParseObjCArrayLiteral
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|)
function_decl|;
name|ExprResult
name|ParseObjCDictionaryLiteral
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|)
function_decl|;
name|ExprResult
name|ParseObjCBoxedExpr
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|)
function_decl|;
name|ExprResult
name|ParseObjCEncodeExpression
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|)
function_decl|;
name|ExprResult
name|ParseObjCSelectorExpression
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|)
function_decl|;
name|ExprResult
name|ParseObjCProtocolExpression
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|)
function_decl|;
name|bool
name|isSimpleObjCMessageExpression
parameter_list|()
function_decl|;
name|ExprResult
name|ParseObjCMessageExpression
parameter_list|()
function_decl|;
name|ExprResult
name|ParseObjCMessageExpressionBody
parameter_list|(
name|SourceLocation
name|LBracloc
parameter_list|,
name|SourceLocation
name|SuperLoc
parameter_list|,
name|ParsedType
name|ReceiverType
parameter_list|,
name|Expr
modifier|*
name|ReceiverExpr
parameter_list|)
function_decl|;
name|ExprResult
name|ParseAssignmentExprWithObjCMessageExprStart
parameter_list|(
name|SourceLocation
name|LBracloc
parameter_list|,
name|SourceLocation
name|SuperLoc
parameter_list|,
name|ParsedType
name|ReceiverType
parameter_list|,
name|Expr
modifier|*
name|ReceiverExpr
parameter_list|)
function_decl|;
name|bool
name|ParseObjCXXMessageReceiver
parameter_list|(
name|bool
modifier|&
name|IsExpr
parameter_list|,
name|void
modifier|*
modifier|&
name|TypeOrExpr
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C99 6.8: Statements and Blocks.
comment|/// A SmallVector of statements, with stack size 32 (as that is the only one
comment|/// used.)
typedef|typedef
name|SmallVector
operator|<
name|Stmt
operator|*
operator|,
literal|32
operator|>
name|StmtVector
expr_stmt|;
comment|/// A SmallVector of expressions, with stack size 12 (the maximum used.)
typedef|typedef
name|SmallVector
operator|<
name|Expr
operator|*
operator|,
literal|12
operator|>
name|ExprVector
expr_stmt|;
comment|/// A SmallVector of types.
typedef|typedef
name|SmallVector
operator|<
name|ParsedType
operator|,
literal|12
operator|>
name|TypeVector
expr_stmt|;
name|StmtResult
name|ParseStatement
parameter_list|(
name|SourceLocation
modifier|*
name|TrailingElseLoc
init|=
name|nullptr
parameter_list|,
name|bool
name|AllowOpenMPStandalone
init|=
name|false
parameter_list|)
function_decl|;
enum|enum
name|AllowedContsructsKind
block|{
comment|/// \brief Allow any declarations, statements, OpenMP directives.
name|ACK_Any
block|,
comment|/// \brief Allow only statements and non-standalone OpenMP directives.
name|ACK_StatementsOpenMPNonStandalone
block|,
comment|/// \brief Allow statements and all executable OpenMP directives
name|ACK_StatementsOpenMPAnyExecutable
block|}
enum|;
name|StmtResult
name|ParseStatementOrDeclaration
parameter_list|(
name|StmtVector
modifier|&
name|Stmts
parameter_list|,
name|AllowedContsructsKind
name|Allowed
parameter_list|,
name|SourceLocation
modifier|*
name|TrailingElseLoc
init|=
name|nullptr
parameter_list|)
function_decl|;
name|StmtResult
name|ParseStatementOrDeclarationAfterAttributes
parameter_list|(
name|StmtVector
modifier|&
name|Stmts
parameter_list|,
name|AllowedContsructsKind
name|Allowed
parameter_list|,
name|SourceLocation
modifier|*
name|TrailingElseLoc
parameter_list|,
name|ParsedAttributesWithRange
modifier|&
name|Attrs
parameter_list|)
function_decl|;
name|StmtResult
name|ParseExprStatement
parameter_list|()
function_decl|;
name|StmtResult
name|ParseLabeledStatement
parameter_list|(
name|ParsedAttributesWithRange
modifier|&
name|attrs
parameter_list|)
function_decl|;
name|StmtResult
name|ParseCaseStatement
parameter_list|(
name|bool
name|MissingCase
init|=
name|false
parameter_list|,
name|ExprResult
name|Expr
init|=
name|ExprResult
argument_list|()
parameter_list|)
function_decl|;
name|StmtResult
name|ParseDefaultStatement
parameter_list|()
function_decl|;
name|StmtResult
name|ParseCompoundStatement
parameter_list|(
name|bool
name|isStmtExpr
init|=
name|false
parameter_list|)
function_decl|;
name|StmtResult
name|ParseCompoundStatement
parameter_list|(
name|bool
name|isStmtExpr
parameter_list|,
name|unsigned
name|ScopeFlags
parameter_list|)
function_decl|;
name|void
name|ParseCompoundStatementLeadingPragmas
parameter_list|()
function_decl|;
name|StmtResult
name|ParseCompoundStatementBody
parameter_list|(
name|bool
name|isStmtExpr
init|=
name|false
parameter_list|)
function_decl|;
name|bool
name|ParseParenExprOrCondition
argument_list|(
name|StmtResult
operator|*
name|InitStmt
argument_list|,
name|Sema
operator|::
name|ConditionResult
operator|&
name|CondResult
argument_list|,
name|SourceLocation
name|Loc
argument_list|,
name|Sema
operator|::
name|ConditionKind
name|CK
argument_list|)
decl_stmt|;
name|StmtResult
name|ParseIfStatement
parameter_list|(
name|SourceLocation
modifier|*
name|TrailingElseLoc
parameter_list|)
function_decl|;
name|StmtResult
name|ParseSwitchStatement
parameter_list|(
name|SourceLocation
modifier|*
name|TrailingElseLoc
parameter_list|)
function_decl|;
name|StmtResult
name|ParseWhileStatement
parameter_list|(
name|SourceLocation
modifier|*
name|TrailingElseLoc
parameter_list|)
function_decl|;
name|StmtResult
name|ParseDoStatement
parameter_list|()
function_decl|;
name|StmtResult
name|ParseForStatement
parameter_list|(
name|SourceLocation
modifier|*
name|TrailingElseLoc
parameter_list|)
function_decl|;
name|StmtResult
name|ParseGotoStatement
parameter_list|()
function_decl|;
name|StmtResult
name|ParseContinueStatement
parameter_list|()
function_decl|;
name|StmtResult
name|ParseBreakStatement
parameter_list|()
function_decl|;
name|StmtResult
name|ParseReturnStatement
parameter_list|()
function_decl|;
name|StmtResult
name|ParseAsmStatement
parameter_list|(
name|bool
modifier|&
name|msAsm
parameter_list|)
function_decl|;
name|StmtResult
name|ParseMicrosoftAsmStatement
parameter_list|(
name|SourceLocation
name|AsmLoc
parameter_list|)
function_decl|;
name|StmtResult
name|ParsePragmaLoopHint
parameter_list|(
name|StmtVector
modifier|&
name|Stmts
parameter_list|,
name|AllowedContsructsKind
name|Allowed
parameter_list|,
name|SourceLocation
modifier|*
name|TrailingElseLoc
parameter_list|,
name|ParsedAttributesWithRange
modifier|&
name|Attrs
parameter_list|)
function_decl|;
comment|/// \brief Describes the behavior that should be taken for an __if_exists
comment|/// block.
enum|enum
name|IfExistsBehavior
block|{
comment|/// \brief Parse the block; this code is always used.
name|IEB_Parse
block|,
comment|/// \brief Skip the block entirely; this code is never used.
name|IEB_Skip
block|,
comment|/// \brief Parse the block as a dependent block, which may be used in
comment|/// some template instantiations but not others.
name|IEB_Dependent
block|}
enum|;
comment|/// \brief Describes the condition of a Microsoft __if_exists or
comment|/// __if_not_exists block.
struct|struct
name|IfExistsCondition
block|{
comment|/// \brief The location of the initial keyword.
name|SourceLocation
name|KeywordLoc
decl_stmt|;
comment|/// \brief Whether this is an __if_exists block (rather than an
comment|/// __if_not_exists block).
name|bool
name|IsIfExists
decl_stmt|;
comment|/// \brief Nested-name-specifier preceding the name.
name|CXXScopeSpec
name|SS
decl_stmt|;
comment|/// \brief The name we're looking for.
name|UnqualifiedId
name|Name
decl_stmt|;
comment|/// \brief The behavior of this __if_exists or __if_not_exists block
comment|/// should.
name|IfExistsBehavior
name|Behavior
decl_stmt|;
block|}
struct|;
name|bool
name|ParseMicrosoftIfExistsCondition
parameter_list|(
name|IfExistsCondition
modifier|&
name|Result
parameter_list|)
function_decl|;
name|void
name|ParseMicrosoftIfExistsStatement
parameter_list|(
name|StmtVector
modifier|&
name|Stmts
parameter_list|)
function_decl|;
name|void
name|ParseMicrosoftIfExistsExternalDeclaration
parameter_list|()
function_decl|;
name|void
name|ParseMicrosoftIfExistsClassDeclaration
argument_list|(
name|DeclSpec
operator|::
name|TST
name|TagType
argument_list|,
name|AccessSpecifier
operator|&
name|CurAS
argument_list|)
decl_stmt|;
name|bool
name|ParseMicrosoftIfExistsBraceInitializer
parameter_list|(
name|ExprVector
modifier|&
name|InitExprs
parameter_list|,
name|bool
modifier|&
name|InitExprsOk
parameter_list|)
function_decl|;
name|bool
name|ParseAsmOperandsOpt
argument_list|(
name|SmallVectorImpl
operator|<
name|IdentifierInfo
operator|*
operator|>
operator|&
name|Names
argument_list|,
name|SmallVectorImpl
operator|<
name|Expr
operator|*
operator|>
operator|&
name|Constraints
argument_list|,
name|SmallVectorImpl
operator|<
name|Expr
operator|*
operator|>
operator|&
name|Exprs
argument_list|)
decl_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 6: Statements and Blocks
name|StmtResult
name|ParseCXXTryBlock
parameter_list|()
function_decl|;
name|StmtResult
name|ParseCXXTryBlockCommon
parameter_list|(
name|SourceLocation
name|TryLoc
parameter_list|,
name|bool
name|FnTry
init|=
name|false
parameter_list|)
function_decl|;
name|StmtResult
name|ParseCXXCatchBlock
parameter_list|(
name|bool
name|FnCatch
init|=
name|false
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// MS: SEH Statements and Blocks
name|StmtResult
name|ParseSEHTryBlock
parameter_list|()
function_decl|;
name|StmtResult
name|ParseSEHExceptBlock
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|)
function_decl|;
name|StmtResult
name|ParseSEHFinallyBlock
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|)
function_decl|;
name|StmtResult
name|ParseSEHLeaveStatement
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// Objective-C Statements
name|StmtResult
name|ParseObjCAtStatement
parameter_list|(
name|SourceLocation
name|atLoc
parameter_list|)
function_decl|;
name|StmtResult
name|ParseObjCTryStmt
parameter_list|(
name|SourceLocation
name|atLoc
parameter_list|)
function_decl|;
name|StmtResult
name|ParseObjCThrowStmt
parameter_list|(
name|SourceLocation
name|atLoc
parameter_list|)
function_decl|;
name|StmtResult
name|ParseObjCSynchronizedStmt
parameter_list|(
name|SourceLocation
name|atLoc
parameter_list|)
function_decl|;
name|StmtResult
name|ParseObjCAutoreleasePoolStmt
parameter_list|(
name|SourceLocation
name|atLoc
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C99 6.7: Declarations.
comment|/// A context for parsing declaration specifiers.  TODO: flesh this
comment|/// out, there are other significant restrictions on specifiers than
comment|/// would be best implemented in the parser.
enum|enum
name|DeclSpecContext
block|{
name|DSC_normal
block|,
comment|// normal context
name|DSC_class
block|,
comment|// class context, enables 'friend'
name|DSC_type_specifier
block|,
comment|// C++ type-specifier-seq or C specifier-qualifier-list
name|DSC_trailing
block|,
comment|// C++11 trailing-type-specifier in a trailing return type
name|DSC_alias_declaration
block|,
comment|// C++11 type-specifier-seq in an alias-declaration
name|DSC_top_level
block|,
comment|// top-level/namespace declaration context
name|DSC_template_type_arg
block|,
comment|// template type argument context
name|DSC_objc_method_result
block|,
comment|// ObjC method result context, enables 'instancetype'
name|DSC_condition
comment|// condition declaration context
block|}
enum|;
comment|/// Is this a context in which we are parsing just a type-specifier (or
comment|/// trailing-type-specifier)?
specifier|static
name|bool
name|isTypeSpecifier
parameter_list|(
name|DeclSpecContext
name|DSC
parameter_list|)
block|{
switch|switch
condition|(
name|DSC
condition|)
block|{
case|case
name|DSC_normal
case|:
case|case
name|DSC_class
case|:
case|case
name|DSC_top_level
case|:
case|case
name|DSC_objc_method_result
case|:
case|case
name|DSC_condition
case|:
return|return
name|false
return|;
case|case
name|DSC_template_type_arg
case|:
case|case
name|DSC_type_specifier
case|:
case|case
name|DSC_trailing
case|:
case|case
name|DSC_alias_declaration
case|:
return|return
name|true
return|;
block|}
name|llvm_unreachable
argument_list|(
literal|"Missing DeclSpecContext case"
argument_list|)
expr_stmt|;
block|}
comment|/// Information on a C++0x for-range-initializer found while parsing a
comment|/// declaration which turns out to be a for-range-declaration.
struct|struct
name|ForRangeInit
block|{
name|SourceLocation
name|ColonLoc
decl_stmt|;
name|ExprResult
name|RangeExpr
decl_stmt|;
name|bool
name|ParsedForRangeDecl
parameter_list|()
block|{
return|return
operator|!
name|ColonLoc
operator|.
name|isInvalid
argument_list|()
return|;
block|}
block|}
struct|;
name|DeclGroupPtrTy
name|ParseDeclaration
parameter_list|(
name|unsigned
name|Context
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|,
name|ParsedAttributesWithRange
modifier|&
name|attrs
parameter_list|)
function_decl|;
name|DeclGroupPtrTy
name|ParseSimpleDeclaration
parameter_list|(
name|unsigned
name|Context
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|,
name|ParsedAttributesWithRange
modifier|&
name|attrs
parameter_list|,
name|bool
name|RequireSemi
parameter_list|,
name|ForRangeInit
modifier|*
name|FRI
init|=
name|nullptr
parameter_list|)
function_decl|;
name|bool
name|MightBeDeclarator
parameter_list|(
name|unsigned
name|Context
parameter_list|)
function_decl|;
name|DeclGroupPtrTy
name|ParseDeclGroup
parameter_list|(
name|ParsingDeclSpec
modifier|&
name|DS
parameter_list|,
name|unsigned
name|Context
parameter_list|,
name|SourceLocation
modifier|*
name|DeclEnd
init|=
name|nullptr
parameter_list|,
name|ForRangeInit
modifier|*
name|FRI
init|=
name|nullptr
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseDeclarationAfterDeclarator
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|,
specifier|const
name|ParsedTemplateInfo
modifier|&
name|TemplateInfo
init|=
name|ParsedTemplateInfo
argument_list|()
parameter_list|)
function_decl|;
name|bool
name|ParseAsmAttributesAfterDeclarator
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseDeclarationAfterDeclaratorAndAttributes
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|,
specifier|const
name|ParsedTemplateInfo
modifier|&
name|TemplateInfo
init|=
name|ParsedTemplateInfo
argument_list|()
parameter_list|,
name|ForRangeInit
modifier|*
name|FRI
init|=
name|nullptr
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseFunctionStatementBody
parameter_list|(
name|Decl
modifier|*
name|Decl
parameter_list|,
name|ParseScope
modifier|&
name|BodyScope
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseFunctionTryBlock
parameter_list|(
name|Decl
modifier|*
name|Decl
parameter_list|,
name|ParseScope
modifier|&
name|BodyScope
parameter_list|)
function_decl|;
comment|/// \brief When in code-completion, skip parsing of the function/method body
comment|/// unless the body contains the code-completion point.
comment|///
comment|/// \returns true if the function body was skipped.
name|bool
name|trySkippingFunctionBody
parameter_list|()
function_decl|;
name|bool
name|ParseImplicitInt
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|,
name|CXXScopeSpec
modifier|*
name|SS
parameter_list|,
specifier|const
name|ParsedTemplateInfo
modifier|&
name|TemplateInfo
parameter_list|,
name|AccessSpecifier
name|AS
parameter_list|,
name|DeclSpecContext
name|DSC
parameter_list|,
name|ParsedAttributesWithRange
modifier|&
name|Attrs
parameter_list|)
function_decl|;
name|DeclSpecContext
name|getDeclSpecContextFromDeclaratorContext
parameter_list|(
name|unsigned
name|Context
parameter_list|)
function_decl|;
name|void
name|ParseDeclarationSpecifiers
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|,
specifier|const
name|ParsedTemplateInfo
modifier|&
name|TemplateInfo
init|=
name|ParsedTemplateInfo
argument_list|()
parameter_list|,
name|AccessSpecifier
name|AS
init|=
name|AS_none
parameter_list|,
name|DeclSpecContext
name|DSC
init|=
name|DSC_normal
parameter_list|,
name|LateParsedAttrList
modifier|*
name|LateAttrs
init|=
name|nullptr
parameter_list|)
function_decl|;
name|bool
name|DiagnoseMissingSemiAfterTagDefinition
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|,
name|AccessSpecifier
name|AS
parameter_list|,
name|DeclSpecContext
name|DSContext
parameter_list|,
name|LateParsedAttrList
modifier|*
name|LateAttrs
init|=
name|nullptr
parameter_list|)
function_decl|;
name|void
name|ParseSpecifierQualifierList
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|,
name|AccessSpecifier
name|AS
init|=
name|AS_none
parameter_list|,
name|DeclSpecContext
name|DSC
init|=
name|DSC_normal
parameter_list|)
function_decl|;
name|void
name|ParseObjCTypeQualifierList
argument_list|(
name|ObjCDeclSpec
operator|&
name|DS
argument_list|,
name|Declarator
operator|::
name|TheContext
name|Context
argument_list|)
decl_stmt|;
name|void
name|ParseEnumSpecifier
parameter_list|(
name|SourceLocation
name|TagLoc
parameter_list|,
name|DeclSpec
modifier|&
name|DS
parameter_list|,
specifier|const
name|ParsedTemplateInfo
modifier|&
name|TemplateInfo
parameter_list|,
name|AccessSpecifier
name|AS
parameter_list|,
name|DeclSpecContext
name|DSC
parameter_list|)
function_decl|;
name|void
name|ParseEnumBody
parameter_list|(
name|SourceLocation
name|StartLoc
parameter_list|,
name|Decl
modifier|*
name|TagDecl
parameter_list|)
function_decl|;
name|void
name|ParseStructUnionBody
parameter_list|(
name|SourceLocation
name|StartLoc
parameter_list|,
name|unsigned
name|TagType
parameter_list|,
name|Decl
modifier|*
name|TagDecl
parameter_list|)
function_decl|;
name|void
name|ParseStructDeclaration
argument_list|(
name|ParsingDeclSpec
operator|&
name|DS
argument_list|,
name|llvm
operator|::
name|function_ref
operator|<
name|void
argument_list|(
name|ParsingFieldDeclarator
operator|&
argument_list|)
operator|>
name|FieldsCallback
argument_list|)
decl_stmt|;
name|bool
name|isDeclarationSpecifier
parameter_list|(
name|bool
name|DisambiguatingWithExpression
init|=
name|false
parameter_list|)
function_decl|;
name|bool
name|isTypeSpecifierQualifier
parameter_list|()
function_decl|;
comment|/// isKnownToBeTypeSpecifier - Return true if we know that the specified token
comment|/// is definitely a type-specifier.  Return false if it isn't part of a type
comment|/// specifier or if we're not sure.
name|bool
name|isKnownToBeTypeSpecifier
argument_list|(
specifier|const
name|Token
operator|&
name|Tok
argument_list|)
decl|const
decl_stmt|;
comment|/// \brief Return true if we know that we are definitely looking at a
comment|/// decl-specifier, and isn't part of an expression such as a function-style
comment|/// cast. Return false if it's no a decl-specifier, or we're not sure.
name|bool
name|isKnownToBeDeclarationSpecifier
parameter_list|()
block|{
if|if
condition|(
name|getLangOpts
argument_list|()
operator|.
name|CPlusPlus
condition|)
return|return
name|isCXXDeclarationSpecifier
argument_list|()
operator|==
name|TPResult
operator|::
name|True
return|;
return|return
name|isDeclarationSpecifier
argument_list|(
name|true
argument_list|)
return|;
block|}
comment|/// isDeclarationStatement - Disambiguates between a declaration or an
comment|/// expression statement, when parsing function bodies.
comment|/// Returns true for declaration, false for expression.
name|bool
name|isDeclarationStatement
parameter_list|()
block|{
if|if
condition|(
name|getLangOpts
argument_list|()
operator|.
name|CPlusPlus
condition|)
return|return
name|isCXXDeclarationStatement
argument_list|()
return|;
return|return
name|isDeclarationSpecifier
argument_list|(
name|true
argument_list|)
return|;
block|}
comment|/// isForInitDeclaration - Disambiguates between a declaration or an
comment|/// expression in the context of the C 'clause-1' or the C++
comment|// 'for-init-statement' part of a 'for' statement.
comment|/// Returns true for declaration, false for expression.
name|bool
name|isForInitDeclaration
parameter_list|()
block|{
if|if
condition|(
name|getLangOpts
argument_list|()
operator|.
name|CPlusPlus
condition|)
return|return
name|isCXXSimpleDeclaration
argument_list|(
comment|/*AllowForRangeDecl=*/
name|true
argument_list|)
return|;
return|return
name|isDeclarationSpecifier
argument_list|(
name|true
argument_list|)
return|;
block|}
comment|/// \brief Determine whether this is a C++1z for-range-identifier.
name|bool
name|isForRangeIdentifier
parameter_list|()
function_decl|;
comment|/// \brief Determine whether we are currently at the start of an Objective-C
comment|/// class message that appears to be missing the open bracket '['.
name|bool
name|isStartOfObjCClassMessageMissingOpenBracket
parameter_list|()
function_decl|;
comment|/// \brief Starting with a scope specifier, identifier, or
comment|/// template-id that refers to the current class, determine whether
comment|/// this is a constructor declarator.
name|bool
name|isConstructorDeclarator
parameter_list|(
name|bool
name|Unqualified
parameter_list|)
function_decl|;
comment|/// \brief Specifies the context in which type-id/expression
comment|/// disambiguation will occur.
enum|enum
name|TentativeCXXTypeIdContext
block|{
name|TypeIdInParens
block|,
name|TypeIdUnambiguous
block|,
name|TypeIdAsTemplateArgument
block|}
enum|;
comment|/// isTypeIdInParens - Assumes that a '(' was parsed and now we want to know
comment|/// whether the parens contain an expression or a type-id.
comment|/// Returns true for a type-id and false for an expression.
name|bool
name|isTypeIdInParens
parameter_list|(
name|bool
modifier|&
name|isAmbiguous
parameter_list|)
block|{
if|if
condition|(
name|getLangOpts
argument_list|()
operator|.
name|CPlusPlus
condition|)
return|return
name|isCXXTypeId
argument_list|(
name|TypeIdInParens
argument_list|,
name|isAmbiguous
argument_list|)
return|;
name|isAmbiguous
operator|=
name|false
expr_stmt|;
return|return
name|isTypeSpecifierQualifier
argument_list|()
return|;
block|}
name|bool
name|isTypeIdInParens
parameter_list|()
block|{
name|bool
name|isAmbiguous
decl_stmt|;
return|return
name|isTypeIdInParens
argument_list|(
name|isAmbiguous
argument_list|)
return|;
block|}
comment|/// \brief Checks if the current tokens form type-id or expression.
comment|/// It is similar to isTypeIdInParens but does not suppose that type-id
comment|/// is in parenthesis.
name|bool
name|isTypeIdUnambiguously
parameter_list|()
block|{
name|bool
name|IsAmbiguous
decl_stmt|;
if|if
condition|(
name|getLangOpts
argument_list|()
operator|.
name|CPlusPlus
condition|)
return|return
name|isCXXTypeId
argument_list|(
name|TypeIdUnambiguous
argument_list|,
name|IsAmbiguous
argument_list|)
return|;
return|return
name|isTypeSpecifierQualifier
argument_list|()
return|;
block|}
comment|/// isCXXDeclarationStatement - C++-specialized function that disambiguates
comment|/// between a declaration or an expression statement, when parsing function
comment|/// bodies. Returns true for declaration, false for expression.
name|bool
name|isCXXDeclarationStatement
parameter_list|()
function_decl|;
comment|/// isCXXSimpleDeclaration - C++-specialized function that disambiguates
comment|/// between a simple-declaration or an expression-statement.
comment|/// If during the disambiguation process a parsing error is encountered,
comment|/// the function returns true to let the declaration parsing code handle it.
comment|/// Returns false if the statement is disambiguated as expression.
name|bool
name|isCXXSimpleDeclaration
parameter_list|(
name|bool
name|AllowForRangeDecl
parameter_list|)
function_decl|;
comment|/// isCXXFunctionDeclarator - Disambiguates between a function declarator or
comment|/// a constructor-style initializer, when parsing declaration statements.
comment|/// Returns true for function declarator and false for constructor-style
comment|/// initializer. Sets 'IsAmbiguous' to true to indicate that this declaration
comment|/// might be a constructor-style initializer.
comment|/// If during the disambiguation process a parsing error is encountered,
comment|/// the function returns true to let the declaration parsing code handle it.
name|bool
name|isCXXFunctionDeclarator
parameter_list|(
name|bool
modifier|*
name|IsAmbiguous
init|=
name|nullptr
parameter_list|)
function_decl|;
struct_decl|struct
name|ConditionDeclarationOrInitStatementState
struct_decl|;
name|enum
name|class
name|ConditionOrInitStatement
block|{
name|Expression
operator|,
comment|///< Disambiguated as an expression (either kind).
name|ConditionDecl
operator|,
comment|///< Disambiguated as the declaration form of condition.
name|InitStmtDecl
operator|,
comment|///< Disambiguated as a simple-declaration init-statement.
name|Error
comment|///< Can't be any of the above!
block|}
empty_stmt|;
comment|/// \brief Disambiguates between the different kinds of things that can happen
comment|/// after 'if (' or 'switch ('. This could be one of two different kinds of
comment|/// declaration (depending on whether there is a ';' later) or an expression.
name|ConditionOrInitStatement
name|isCXXConditionDeclarationOrInitStatement
parameter_list|(
name|bool
name|CanBeInitStmt
parameter_list|)
function_decl|;
name|bool
name|isCXXTypeId
parameter_list|(
name|TentativeCXXTypeIdContext
name|Context
parameter_list|,
name|bool
modifier|&
name|isAmbiguous
parameter_list|)
function_decl|;
name|bool
name|isCXXTypeId
parameter_list|(
name|TentativeCXXTypeIdContext
name|Context
parameter_list|)
block|{
name|bool
name|isAmbiguous
decl_stmt|;
return|return
name|isCXXTypeId
argument_list|(
name|Context
argument_list|,
name|isAmbiguous
argument_list|)
return|;
block|}
comment|/// TPResult - Used as the result value for functions whose purpose is to
comment|/// disambiguate C++ constructs by "tentatively parsing" them.
name|enum
name|class
name|TPResult
block|{
name|True
operator|,
name|False
operator|,
name|Ambiguous
operator|,
name|Error
block|}
empty_stmt|;
comment|/// \brief Based only on the given token kind, determine whether we know that
comment|/// we're at the start of an expression or a type-specifier-seq (which may
comment|/// be an expression, in C++).
comment|///
comment|/// This routine does not attempt to resolve any of the trick cases, e.g.,
comment|/// those involving lookup of identifiers.
comment|///
comment|/// \returns \c TPR_true if this token starts an expression, \c TPR_false if
comment|/// this token starts a type-specifier-seq, or \c TPR_ambiguous if it cannot
comment|/// tell.
name|TPResult
name|isExpressionOrTypeSpecifierSimple
argument_list|(
name|tok
operator|::
name|TokenKind
name|Kind
argument_list|)
decl_stmt|;
comment|/// isCXXDeclarationSpecifier - Returns TPResult::True if it is a
comment|/// declaration specifier, TPResult::False if it is not,
comment|/// TPResult::Ambiguous if it could be either a decl-specifier or a
comment|/// function-style cast, and TPResult::Error if a parsing error was
comment|/// encountered. If it could be a braced C++11 function-style cast, returns
comment|/// BracedCastResult.
comment|/// Doesn't consume tokens.
name|TPResult
name|isCXXDeclarationSpecifier
parameter_list|(
name|TPResult
name|BracedCastResult
init|=
name|TPResult
operator|::
name|False
parameter_list|,
name|bool
modifier|*
name|HasMissingTypename
init|=
name|nullptr
parameter_list|)
function_decl|;
comment|/// Given that isCXXDeclarationSpecifier returns \c TPResult::True or
comment|/// \c TPResult::Ambiguous, determine whether the decl-specifier would be
comment|/// a type-specifier other than a cv-qualifier.
name|bool
name|isCXXDeclarationSpecifierAType
parameter_list|()
function_decl|;
comment|/// \brief Determine whether an identifier has been tentatively declared as a
comment|/// non-type. Such tentative declarations should not be found to name a type
comment|/// during a tentative parse, but also should not be annotated as a non-type.
name|bool
name|isTentativelyDeclared
parameter_list|(
name|IdentifierInfo
modifier|*
name|II
parameter_list|)
function_decl|;
comment|// "Tentative parsing" functions, used for disambiguation. If a parsing error
comment|// is encountered they will return TPResult::Error.
comment|// Returning TPResult::True/False indicates that the ambiguity was
comment|// resolved and tentative parsing may stop. TPResult::Ambiguous indicates
comment|// that more tentative parsing is necessary for disambiguation.
comment|// They all consume tokens, so backtracking should be used after calling them.
name|TPResult
name|TryParseSimpleDeclaration
parameter_list|(
name|bool
name|AllowForRangeDecl
parameter_list|)
function_decl|;
name|TPResult
name|TryParseTypeofSpecifier
parameter_list|()
function_decl|;
name|TPResult
name|TryParseProtocolQualifiers
parameter_list|()
function_decl|;
name|TPResult
name|TryParsePtrOperatorSeq
parameter_list|()
function_decl|;
name|TPResult
name|TryParseOperatorId
parameter_list|()
function_decl|;
name|TPResult
name|TryParseInitDeclaratorList
parameter_list|()
function_decl|;
name|TPResult
name|TryParseDeclarator
parameter_list|(
name|bool
name|mayBeAbstract
parameter_list|,
name|bool
name|mayHaveIdentifier
init|=
name|true
parameter_list|)
function_decl|;
name|TPResult
name|TryParseParameterDeclarationClause
parameter_list|(
name|bool
modifier|*
name|InvalidAsDeclaration
init|=
name|nullptr
parameter_list|,
name|bool
name|VersusTemplateArg
init|=
name|false
parameter_list|)
function_decl|;
name|TPResult
name|TryParseFunctionDeclarator
parameter_list|()
function_decl|;
name|TPResult
name|TryParseBracketDeclarator
parameter_list|()
function_decl|;
name|TPResult
name|TryConsumeDeclarationSpecifier
parameter_list|()
function_decl|;
name|public
label|:
name|TypeResult
name|ParseTypeName
argument_list|(
name|SourceRange
operator|*
name|Range
operator|=
name|nullptr
argument_list|,
name|Declarator
operator|::
name|TheContext
name|Context
operator|=
name|Declarator
operator|::
name|TypeNameContext
argument_list|,
name|AccessSpecifier
name|AS
operator|=
name|AS_none
argument_list|,
name|Decl
operator|*
operator|*
name|OwnedType
operator|=
name|nullptr
argument_list|,
name|ParsedAttributes
operator|*
name|Attrs
operator|=
name|nullptr
argument_list|)
decl_stmt|;
name|private
label|:
name|void
name|ParseBlockId
parameter_list|(
name|SourceLocation
name|CaretLoc
parameter_list|)
function_decl|;
comment|// Check for the start of a C++11 attribute-specifier-seq in a context where
comment|// an attribute is not allowed.
name|bool
name|CheckProhibitedCXX11Attribute
parameter_list|()
block|{
name|assert
argument_list|(
name|Tok
operator|.
name|is
argument_list|(
name|tok
operator|::
name|l_square
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getLangOpts
argument_list|()
operator|.
name|CPlusPlus11
operator|||
name|NextToken
argument_list|()
operator|.
name|isNot
argument_list|(
name|tok
operator|::
name|l_square
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|DiagnoseProhibitedCXX11Attribute
argument_list|()
return|;
block|}
name|bool
name|DiagnoseProhibitedCXX11Attribute
parameter_list|()
function_decl|;
name|void
name|CheckMisplacedCXX11Attribute
parameter_list|(
name|ParsedAttributesWithRange
modifier|&
name|Attrs
parameter_list|,
name|SourceLocation
name|CorrectLocation
parameter_list|)
block|{
if|if
condition|(
operator|!
name|getLangOpts
argument_list|()
operator|.
name|CPlusPlus11
condition|)
return|return;
if|if
condition|(
operator|(
name|Tok
operator|.
name|isNot
argument_list|(
name|tok
operator|::
name|l_square
argument_list|)
operator|||
name|NextToken
argument_list|()
operator|.
name|isNot
argument_list|(
name|tok
operator|::
name|l_square
argument_list|)
operator|)
operator|&&
name|Tok
operator|.
name|isNot
argument_list|(
name|tok
operator|::
name|kw_alignas
argument_list|)
condition|)
return|return;
name|DiagnoseMisplacedCXX11Attribute
argument_list|(
name|Attrs
argument_list|,
name|CorrectLocation
argument_list|)
expr_stmt|;
block|}
name|void
name|DiagnoseMisplacedCXX11Attribute
parameter_list|(
name|ParsedAttributesWithRange
modifier|&
name|Attrs
parameter_list|,
name|SourceLocation
name|CorrectLocation
parameter_list|)
function_decl|;
name|void
name|stripTypeAttributesOffDeclSpec
argument_list|(
name|ParsedAttributesWithRange
operator|&
name|Attrs
argument_list|,
name|DeclSpec
operator|&
name|DS
argument_list|,
name|Sema
operator|::
name|TagUseKind
name|TUK
argument_list|)
decl_stmt|;
name|void
name|ProhibitAttributes
parameter_list|(
name|ParsedAttributesWithRange
modifier|&
name|attrs
parameter_list|)
block|{
if|if
condition|(
operator|!
name|attrs
operator|.
name|Range
operator|.
name|isValid
argument_list|()
condition|)
return|return;
name|DiagnoseProhibitedAttributes
argument_list|(
name|attrs
argument_list|)
expr_stmt|;
name|attrs
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|void
name|DiagnoseProhibitedAttributes
parameter_list|(
name|ParsedAttributesWithRange
modifier|&
name|attrs
parameter_list|)
function_decl|;
comment|// Forbid C++11 attributes that appear on certain syntactic
comment|// locations which standard permits but we don't supported yet,
comment|// for example, attributes appertain to decl specifiers.
name|void
name|ProhibitCXX11Attributes
parameter_list|(
name|ParsedAttributesWithRange
modifier|&
name|Attrs
parameter_list|,
name|unsigned
name|DiagID
parameter_list|)
function_decl|;
comment|/// \brief Skip C++11 attributes and return the end location of the last one.
comment|/// \returns SourceLocation() if there are no attributes.
name|SourceLocation
name|SkipCXX11Attributes
parameter_list|()
function_decl|;
comment|/// \brief Diagnose and skip C++11 attributes that appear in syntactic
comment|/// locations where attributes are not allowed.
name|void
name|DiagnoseAndSkipCXX11Attributes
parameter_list|()
function_decl|;
comment|/// \brief Parses syntax-generic attribute arguments for attributes which are
comment|/// known to the implementation, and adds them to the given ParsedAttributes
comment|/// list with the given attribute syntax. Returns the number of arguments
comment|/// parsed for the attribute.
name|unsigned
name|ParseAttributeArgsCommon
argument_list|(
name|IdentifierInfo
operator|*
name|AttrName
argument_list|,
name|SourceLocation
name|AttrNameLoc
argument_list|,
name|ParsedAttributes
operator|&
name|Attrs
argument_list|,
name|SourceLocation
operator|*
name|EndLoc
argument_list|,
name|IdentifierInfo
operator|*
name|ScopeName
argument_list|,
name|SourceLocation
name|ScopeLoc
argument_list|,
name|AttributeList
operator|::
name|Syntax
name|Syntax
argument_list|)
decl_stmt|;
name|void
name|MaybeParseGNUAttributes
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|,
name|LateParsedAttrList
modifier|*
name|LateAttrs
init|=
name|nullptr
parameter_list|)
block|{
if|if
condition|(
name|Tok
operator|.
name|is
argument_list|(
name|tok
operator|::
name|kw___attribute
argument_list|)
condition|)
block|{
name|ParsedAttributes
name|attrs
argument_list|(
name|AttrFactory
argument_list|)
decl_stmt|;
name|SourceLocation
name|endLoc
decl_stmt|;
name|ParseGNUAttributes
argument_list|(
name|attrs
argument_list|,
operator|&
name|endLoc
argument_list|,
name|LateAttrs
argument_list|,
operator|&
name|D
argument_list|)
expr_stmt|;
name|D
operator|.
name|takeAttributes
argument_list|(
name|attrs
argument_list|,
name|endLoc
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|MaybeParseGNUAttributes
parameter_list|(
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|,
name|SourceLocation
modifier|*
name|endLoc
init|=
name|nullptr
parameter_list|,
name|LateParsedAttrList
modifier|*
name|LateAttrs
init|=
name|nullptr
parameter_list|)
block|{
if|if
condition|(
name|Tok
operator|.
name|is
argument_list|(
name|tok
operator|::
name|kw___attribute
argument_list|)
condition|)
name|ParseGNUAttributes
argument_list|(
name|attrs
argument_list|,
name|endLoc
argument_list|,
name|LateAttrs
argument_list|)
expr_stmt|;
block|}
name|void
name|ParseGNUAttributes
parameter_list|(
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|,
name|SourceLocation
modifier|*
name|endLoc
init|=
name|nullptr
parameter_list|,
name|LateParsedAttrList
modifier|*
name|LateAttrs
init|=
name|nullptr
parameter_list|,
name|Declarator
modifier|*
name|D
init|=
name|nullptr
parameter_list|)
function_decl|;
name|void
name|ParseGNUAttributeArgs
argument_list|(
name|IdentifierInfo
operator|*
name|AttrName
argument_list|,
name|SourceLocation
name|AttrNameLoc
argument_list|,
name|ParsedAttributes
operator|&
name|Attrs
argument_list|,
name|SourceLocation
operator|*
name|EndLoc
argument_list|,
name|IdentifierInfo
operator|*
name|ScopeName
argument_list|,
name|SourceLocation
name|ScopeLoc
argument_list|,
name|AttributeList
operator|::
name|Syntax
name|Syntax
argument_list|,
name|Declarator
operator|*
name|D
argument_list|)
decl_stmt|;
name|IdentifierLoc
modifier|*
name|ParseIdentifierLoc
parameter_list|()
function_decl|;
name|void
name|MaybeParseCXX11Attributes
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|)
block|{
if|if
condition|(
name|getLangOpts
argument_list|()
operator|.
name|CPlusPlus11
operator|&&
name|isCXX11AttributeSpecifier
argument_list|()
condition|)
block|{
name|ParsedAttributesWithRange
name|attrs
argument_list|(
name|AttrFactory
argument_list|)
decl_stmt|;
name|SourceLocation
name|endLoc
decl_stmt|;
name|ParseCXX11Attributes
argument_list|(
name|attrs
argument_list|,
operator|&
name|endLoc
argument_list|)
expr_stmt|;
name|D
operator|.
name|takeAttributes
argument_list|(
name|attrs
argument_list|,
name|endLoc
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|MaybeParseCXX11Attributes
parameter_list|(
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|,
name|SourceLocation
modifier|*
name|endLoc
init|=
name|nullptr
parameter_list|)
block|{
if|if
condition|(
name|getLangOpts
argument_list|()
operator|.
name|CPlusPlus11
operator|&&
name|isCXX11AttributeSpecifier
argument_list|()
condition|)
block|{
name|ParsedAttributesWithRange
name|attrsWithRange
argument_list|(
name|AttrFactory
argument_list|)
decl_stmt|;
name|ParseCXX11Attributes
argument_list|(
name|attrsWithRange
argument_list|,
name|endLoc
argument_list|)
expr_stmt|;
name|attrs
operator|.
name|takeAllFrom
argument_list|(
name|attrsWithRange
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|MaybeParseCXX11Attributes
parameter_list|(
name|ParsedAttributesWithRange
modifier|&
name|attrs
parameter_list|,
name|SourceLocation
modifier|*
name|endLoc
init|=
name|nullptr
parameter_list|,
name|bool
name|OuterMightBeMessageSend
init|=
name|false
parameter_list|)
block|{
if|if
condition|(
name|getLangOpts
argument_list|()
operator|.
name|CPlusPlus11
operator|&&
name|isCXX11AttributeSpecifier
argument_list|(
name|false
argument_list|,
name|OuterMightBeMessageSend
argument_list|)
condition|)
name|ParseCXX11Attributes
argument_list|(
name|attrs
argument_list|,
name|endLoc
argument_list|)
expr_stmt|;
block|}
name|void
name|ParseCXX11AttributeSpecifier
parameter_list|(
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|,
name|SourceLocation
modifier|*
name|EndLoc
init|=
name|nullptr
parameter_list|)
function_decl|;
name|void
name|ParseCXX11Attributes
parameter_list|(
name|ParsedAttributesWithRange
modifier|&
name|attrs
parameter_list|,
name|SourceLocation
modifier|*
name|EndLoc
init|=
name|nullptr
parameter_list|)
function_decl|;
comment|/// \brief Parses a C++-style attribute argument list. Returns true if this
comment|/// results in adding an attribute to the ParsedAttributes list.
name|bool
name|ParseCXX11AttributeArgs
parameter_list|(
name|IdentifierInfo
modifier|*
name|AttrName
parameter_list|,
name|SourceLocation
name|AttrNameLoc
parameter_list|,
name|ParsedAttributes
modifier|&
name|Attrs
parameter_list|,
name|SourceLocation
modifier|*
name|EndLoc
parameter_list|,
name|IdentifierInfo
modifier|*
name|ScopeName
parameter_list|,
name|SourceLocation
name|ScopeLoc
parameter_list|)
function_decl|;
name|IdentifierInfo
modifier|*
name|TryParseCXX11AttributeIdentifier
parameter_list|(
name|SourceLocation
modifier|&
name|Loc
parameter_list|)
function_decl|;
name|void
name|MaybeParseMicrosoftAttributes
parameter_list|(
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|,
name|SourceLocation
modifier|*
name|endLoc
init|=
name|nullptr
parameter_list|)
block|{
if|if
condition|(
name|getLangOpts
argument_list|()
operator|.
name|MicrosoftExt
operator|&&
name|Tok
operator|.
name|is
argument_list|(
name|tok
operator|::
name|l_square
argument_list|)
condition|)
name|ParseMicrosoftAttributes
argument_list|(
name|attrs
argument_list|,
name|endLoc
argument_list|)
expr_stmt|;
block|}
name|void
name|ParseMicrosoftUuidAttributeArgs
parameter_list|(
name|ParsedAttributes
modifier|&
name|Attrs
parameter_list|)
function_decl|;
name|void
name|ParseMicrosoftAttributes
parameter_list|(
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|,
name|SourceLocation
modifier|*
name|endLoc
init|=
name|nullptr
parameter_list|)
function_decl|;
name|void
name|MaybeParseMicrosoftDeclSpecs
parameter_list|(
name|ParsedAttributes
modifier|&
name|Attrs
parameter_list|,
name|SourceLocation
modifier|*
name|End
init|=
name|nullptr
parameter_list|)
block|{
specifier|const
specifier|auto
modifier|&
name|LO
init|=
name|getLangOpts
argument_list|()
decl_stmt|;
if|if
condition|(
name|LO
operator|.
name|DeclSpecKeyword
operator|&&
name|Tok
operator|.
name|is
argument_list|(
name|tok
operator|::
name|kw___declspec
argument_list|)
condition|)
name|ParseMicrosoftDeclSpecs
argument_list|(
name|Attrs
argument_list|,
name|End
argument_list|)
expr_stmt|;
block|}
name|void
name|ParseMicrosoftDeclSpecs
parameter_list|(
name|ParsedAttributes
modifier|&
name|Attrs
parameter_list|,
name|SourceLocation
modifier|*
name|End
init|=
name|nullptr
parameter_list|)
function_decl|;
name|bool
name|ParseMicrosoftDeclSpecArgs
parameter_list|(
name|IdentifierInfo
modifier|*
name|AttrName
parameter_list|,
name|SourceLocation
name|AttrNameLoc
parameter_list|,
name|ParsedAttributes
modifier|&
name|Attrs
parameter_list|)
function_decl|;
name|void
name|ParseMicrosoftTypeAttributes
parameter_list|(
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|)
function_decl|;
name|void
name|DiagnoseAndSkipExtendedMicrosoftTypeAttributes
parameter_list|()
function_decl|;
name|SourceLocation
name|SkipExtendedMicrosoftTypeAttributes
parameter_list|()
function_decl|;
name|void
name|ParseMicrosoftInheritanceClassAttributes
parameter_list|(
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|)
function_decl|;
name|void
name|ParseBorlandTypeAttributes
parameter_list|(
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|)
function_decl|;
name|void
name|ParseOpenCLKernelAttributes
parameter_list|(
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|)
function_decl|;
name|void
name|ParseOpenCLQualifiers
parameter_list|(
name|ParsedAttributes
modifier|&
name|Attrs
parameter_list|)
function_decl|;
comment|/// \brief Parses opencl_unroll_hint attribute if language is OpenCL v2.0
comment|/// or higher.
comment|/// \return false if error happens.
name|bool
name|MaybeParseOpenCLUnrollHintAttribute
parameter_list|(
name|ParsedAttributes
modifier|&
name|Attrs
parameter_list|)
block|{
if|if
condition|(
name|getLangOpts
argument_list|()
operator|.
name|OpenCL
condition|)
return|return
name|ParseOpenCLUnrollHintAttribute
argument_list|(
name|Attrs
argument_list|)
return|;
return|return
name|true
return|;
block|}
comment|/// \brief Parses opencl_unroll_hint attribute.
comment|/// \return false if error happens.
name|bool
name|ParseOpenCLUnrollHintAttribute
parameter_list|(
name|ParsedAttributes
modifier|&
name|Attrs
parameter_list|)
function_decl|;
name|void
name|ParseNullabilityTypeSpecifiers
parameter_list|(
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|)
function_decl|;
name|VersionTuple
name|ParseVersionTuple
parameter_list|(
name|SourceRange
modifier|&
name|Range
parameter_list|)
function_decl|;
name|void
name|ParseAvailabilityAttribute
argument_list|(
name|IdentifierInfo
operator|&
name|Availability
argument_list|,
name|SourceLocation
name|AvailabilityLoc
argument_list|,
name|ParsedAttributes
operator|&
name|attrs
argument_list|,
name|SourceLocation
operator|*
name|endLoc
argument_list|,
name|IdentifierInfo
operator|*
name|ScopeName
argument_list|,
name|SourceLocation
name|ScopeLoc
argument_list|,
name|AttributeList
operator|::
name|Syntax
name|Syntax
argument_list|)
decl_stmt|;
name|Optional
operator|<
name|AvailabilitySpec
operator|>
name|ParseAvailabilitySpec
argument_list|()
expr_stmt|;
name|ExprResult
name|ParseAvailabilityCheckExpr
parameter_list|(
name|SourceLocation
name|StartLoc
parameter_list|)
function_decl|;
name|void
name|ParseObjCBridgeRelatedAttribute
argument_list|(
name|IdentifierInfo
operator|&
name|ObjCBridgeRelated
argument_list|,
name|SourceLocation
name|ObjCBridgeRelatedLoc
argument_list|,
name|ParsedAttributes
operator|&
name|attrs
argument_list|,
name|SourceLocation
operator|*
name|endLoc
argument_list|,
name|IdentifierInfo
operator|*
name|ScopeName
argument_list|,
name|SourceLocation
name|ScopeLoc
argument_list|,
name|AttributeList
operator|::
name|Syntax
name|Syntax
argument_list|)
decl_stmt|;
name|void
name|ParseTypeTagForDatatypeAttribute
argument_list|(
name|IdentifierInfo
operator|&
name|AttrName
argument_list|,
name|SourceLocation
name|AttrNameLoc
argument_list|,
name|ParsedAttributes
operator|&
name|Attrs
argument_list|,
name|SourceLocation
operator|*
name|EndLoc
argument_list|,
name|IdentifierInfo
operator|*
name|ScopeName
argument_list|,
name|SourceLocation
name|ScopeLoc
argument_list|,
name|AttributeList
operator|::
name|Syntax
name|Syntax
argument_list|)
decl_stmt|;
name|void
name|ParseAttributeWithTypeArg
argument_list|(
name|IdentifierInfo
operator|&
name|AttrName
argument_list|,
name|SourceLocation
name|AttrNameLoc
argument_list|,
name|ParsedAttributes
operator|&
name|Attrs
argument_list|,
name|SourceLocation
operator|*
name|EndLoc
argument_list|,
name|IdentifierInfo
operator|*
name|ScopeName
argument_list|,
name|SourceLocation
name|ScopeLoc
argument_list|,
name|AttributeList
operator|::
name|Syntax
name|Syntax
argument_list|)
decl_stmt|;
name|void
name|ParseTypeofSpecifier
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|)
function_decl|;
name|SourceLocation
name|ParseDecltypeSpecifier
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|)
function_decl|;
name|void
name|AnnotateExistingDecltypeSpecifier
parameter_list|(
specifier|const
name|DeclSpec
modifier|&
name|DS
parameter_list|,
name|SourceLocation
name|StartLoc
parameter_list|,
name|SourceLocation
name|EndLoc
parameter_list|)
function_decl|;
name|void
name|ParseUnderlyingTypeSpecifier
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|)
function_decl|;
name|void
name|ParseAtomicSpecifier
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|)
function_decl|;
name|ExprResult
name|ParseAlignArgument
parameter_list|(
name|SourceLocation
name|Start
parameter_list|,
name|SourceLocation
modifier|&
name|EllipsisLoc
parameter_list|)
function_decl|;
name|void
name|ParseAlignmentSpecifier
parameter_list|(
name|ParsedAttributes
modifier|&
name|Attrs
parameter_list|,
name|SourceLocation
modifier|*
name|endLoc
init|=
name|nullptr
parameter_list|)
function_decl|;
name|VirtSpecifiers
operator|::
name|Specifier
name|isCXX11VirtSpecifier
argument_list|(
argument|const Token&Tok
argument_list|)
specifier|const
expr_stmt|;
name|VirtSpecifiers
operator|::
name|Specifier
name|isCXX11VirtSpecifier
argument_list|()
specifier|const
block|{
return|return
name|isCXX11VirtSpecifier
argument_list|(
name|Tok
argument_list|)
return|;
block|}
name|void
name|ParseOptionalCXX11VirtSpecifierSeq
parameter_list|(
name|VirtSpecifiers
modifier|&
name|VS
parameter_list|,
name|bool
name|IsInterface
parameter_list|,
name|SourceLocation
name|FriendLoc
parameter_list|)
function_decl|;
name|bool
name|isCXX11FinalKeyword
parameter_list|()
function|const;
comment|/// DeclaratorScopeObj - RAII object used in Parser::ParseDirectDeclarator to
comment|/// enter a new C++ declarator scope and exit it when the function is
comment|/// finished.
name|class
name|DeclaratorScopeObj
block|{
name|Parser
modifier|&
name|P
decl_stmt|;
name|CXXScopeSpec
modifier|&
name|SS
decl_stmt|;
name|bool
name|EnteredScope
decl_stmt|;
name|bool
name|CreatedScope
decl_stmt|;
name|public
label|:
name|DeclaratorScopeObj
argument_list|(
name|Parser
operator|&
name|p
argument_list|,
name|CXXScopeSpec
operator|&
name|ss
argument_list|)
operator|:
name|P
argument_list|(
name|p
argument_list|)
operator|,
name|SS
argument_list|(
name|ss
argument_list|)
operator|,
name|EnteredScope
argument_list|(
name|false
argument_list|)
operator|,
name|CreatedScope
argument_list|(
argument|false
argument_list|)
block|{}
name|void
name|EnterDeclaratorScope
argument_list|()
block|{
name|assert
argument_list|(
operator|!
name|EnteredScope
operator|&&
literal|"Already entered the scope!"
argument_list|)
block|;
name|assert
argument_list|(
name|SS
operator|.
name|isSet
argument_list|()
operator|&&
literal|"C++ scope was not set!"
argument_list|)
block|;
name|CreatedScope
operator|=
name|true
block|;
name|P
operator|.
name|EnterScope
argument_list|(
literal|0
argument_list|)
block|;
comment|// Not a decl scope.
if|if
condition|(
operator|!
name|P
operator|.
name|Actions
operator|.
name|ActOnCXXEnterDeclaratorScope
argument_list|(
name|P
operator|.
name|getCurScope
argument_list|()
argument_list|,
name|SS
argument_list|)
condition|)
name|EnteredScope
operator|=
name|true
expr_stmt|;
block|}
operator|~
name|DeclaratorScopeObj
argument_list|()
block|{
if|if
condition|(
name|EnteredScope
condition|)
block|{
name|assert
argument_list|(
name|SS
operator|.
name|isSet
argument_list|()
operator|&&
literal|"C++ scope was cleared ?"
argument_list|)
expr_stmt|;
name|P
operator|.
name|Actions
operator|.
name|ActOnCXXExitDeclaratorScope
argument_list|(
name|P
operator|.
name|getCurScope
argument_list|()
argument_list|,
name|SS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CreatedScope
condition|)
name|P
operator|.
name|ExitScope
argument_list|()
expr_stmt|;
block|}
block|}
empty_stmt|;
comment|/// ParseDeclarator - Parse and verify a newly-initialized declarator.
name|void
name|ParseDeclarator
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|)
function_decl|;
comment|/// A function that parses a variant of direct-declarator.
typedef|typedef
name|void
argument_list|(
name|Parser
operator|::
operator|*
name|DirectDeclParseFunction
argument_list|)
argument_list|(
name|Declarator
operator|&
argument_list|)
expr_stmt|;
name|void
name|ParseDeclaratorInternal
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|,
name|DirectDeclParseFunction
name|DirectDeclParser
parameter_list|)
function_decl|;
enum|enum
name|AttrRequirements
block|{
name|AR_NoAttributesParsed
init|=
literal|0
block|,
comment|///< No attributes are diagnosed.
name|AR_GNUAttributesParsedAndRejected
init|=
literal|1
operator|<<
literal|0
block|,
comment|///< Diagnose GNU attributes.
name|AR_GNUAttributesParsed
init|=
literal|1
operator|<<
literal|1
block|,
name|AR_CXX11AttributesParsed
init|=
literal|1
operator|<<
literal|2
block|,
name|AR_DeclspecAttributesParsed
init|=
literal|1
operator|<<
literal|3
block|,
name|AR_AllAttributesParsed
init|=
name|AR_GNUAttributesParsed
operator||
name|AR_CXX11AttributesParsed
operator||
name|AR_DeclspecAttributesParsed
block|,
name|AR_VendorAttributesParsed
init|=
name|AR_GNUAttributesParsed
operator||
name|AR_DeclspecAttributesParsed
block|}
enum|;
name|void
name|ParseTypeQualifierListOpt
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|,
name|unsigned
name|AttrReqs
init|=
name|AR_AllAttributesParsed
parameter_list|,
name|bool
name|AtomicAllowed
init|=
name|true
parameter_list|,
name|bool
name|IdentifierRequired
init|=
name|false
parameter_list|)
function_decl|;
name|void
name|ParseDirectDeclarator
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|)
function_decl|;
name|void
name|ParseDecompositionDeclarator
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|)
function_decl|;
name|void
name|ParseParenDeclarator
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|)
function_decl|;
name|void
name|ParseFunctionDeclarator
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|,
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|,
name|BalancedDelimiterTracker
modifier|&
name|Tracker
parameter_list|,
name|bool
name|IsAmbiguous
parameter_list|,
name|bool
name|RequiresArg
init|=
name|false
parameter_list|)
function_decl|;
name|bool
name|ParseRefQualifier
parameter_list|(
name|bool
modifier|&
name|RefQualifierIsLValueRef
parameter_list|,
name|SourceLocation
modifier|&
name|RefQualifierLoc
parameter_list|)
function_decl|;
name|bool
name|isFunctionDeclaratorIdentifierList
parameter_list|()
function_decl|;
name|void
name|ParseFunctionDeclaratorIdentifierList
argument_list|(
name|Declarator
operator|&
name|D
argument_list|,
name|SmallVectorImpl
operator|<
name|DeclaratorChunk
operator|::
name|ParamInfo
operator|>
operator|&
name|ParamInfo
argument_list|)
decl_stmt|;
name|void
name|ParseParameterDeclarationClause
argument_list|(
name|Declarator
operator|&
name|D
argument_list|,
name|ParsedAttributes
operator|&
name|attrs
argument_list|,
name|SmallVectorImpl
operator|<
name|DeclaratorChunk
operator|::
name|ParamInfo
operator|>
operator|&
name|ParamInfo
argument_list|,
name|SourceLocation
operator|&
name|EllipsisLoc
argument_list|)
decl_stmt|;
name|void
name|ParseBracketDeclarator
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|)
function_decl|;
name|void
name|ParseMisplacedBracketDeclarator
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 7: Declarations [dcl.dcl]
comment|/// The kind of attribute specifier we have found.
enum|enum
name|CXX11AttributeKind
block|{
comment|/// This is not an attribute specifier.
name|CAK_NotAttributeSpecifier
block|,
comment|/// This should be treated as an attribute-specifier.
name|CAK_AttributeSpecifier
block|,
comment|/// The next tokens are '[[', but this is not an attribute-specifier. This
comment|/// is ill-formed by C++11 [dcl.attr.grammar]p6.
name|CAK_InvalidAttributeSpecifier
block|}
enum|;
name|CXX11AttributeKind
name|isCXX11AttributeSpecifier
parameter_list|(
name|bool
name|Disambiguate
init|=
name|false
parameter_list|,
name|bool
name|OuterMightBeMessageSend
init|=
name|false
parameter_list|)
function_decl|;
name|void
name|DiagnoseUnexpectedNamespace
parameter_list|(
name|NamedDecl
modifier|*
name|Context
parameter_list|)
function_decl|;
name|DeclGroupPtrTy
name|ParseNamespace
parameter_list|(
name|unsigned
name|Context
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|,
name|SourceLocation
name|InlineLoc
init|=
name|SourceLocation
argument_list|()
parameter_list|)
function_decl|;
name|void
name|ParseInnerNamespace
argument_list|(
name|std
operator|::
name|vector
operator|<
name|SourceLocation
operator|>
operator|&
name|IdentLoc
argument_list|,
name|std
operator|::
name|vector
operator|<
name|IdentifierInfo
operator|*
operator|>
operator|&
name|Ident
argument_list|,
name|std
operator|::
name|vector
operator|<
name|SourceLocation
operator|>
operator|&
name|NamespaceLoc
argument_list|,
name|unsigned
name|int
name|index
argument_list|,
name|SourceLocation
operator|&
name|InlineLoc
argument_list|,
name|ParsedAttributes
operator|&
name|attrs
argument_list|,
name|BalancedDelimiterTracker
operator|&
name|Tracker
argument_list|)
decl_stmt|;
name|Decl
modifier|*
name|ParseLinkage
parameter_list|(
name|ParsingDeclSpec
modifier|&
name|DS
parameter_list|,
name|unsigned
name|Context
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseExportDeclaration
parameter_list|()
function_decl|;
name|DeclGroupPtrTy
name|ParseUsingDirectiveOrDeclaration
parameter_list|(
name|unsigned
name|Context
parameter_list|,
specifier|const
name|ParsedTemplateInfo
modifier|&
name|TemplateInfo
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|,
name|ParsedAttributesWithRange
modifier|&
name|attrs
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseUsingDirective
parameter_list|(
name|unsigned
name|Context
parameter_list|,
name|SourceLocation
name|UsingLoc
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|,
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|)
function_decl|;
struct|struct
name|UsingDeclarator
block|{
name|SourceLocation
name|TypenameLoc
decl_stmt|;
name|CXXScopeSpec
name|SS
decl_stmt|;
name|SourceLocation
name|TemplateKWLoc
decl_stmt|;
name|UnqualifiedId
name|Name
decl_stmt|;
name|SourceLocation
name|EllipsisLoc
decl_stmt|;
name|void
name|clear
parameter_list|()
block|{
name|TypenameLoc
operator|=
name|TemplateKWLoc
operator|=
name|EllipsisLoc
operator|=
name|SourceLocation
argument_list|()
expr_stmt|;
name|SS
operator|.
name|clear
argument_list|()
expr_stmt|;
name|Name
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
block|}
struct|;
name|bool
name|ParseUsingDeclarator
parameter_list|(
name|unsigned
name|Context
parameter_list|,
name|UsingDeclarator
modifier|&
name|D
parameter_list|)
function_decl|;
name|DeclGroupPtrTy
name|ParseUsingDeclaration
parameter_list|(
name|unsigned
name|Context
parameter_list|,
specifier|const
name|ParsedTemplateInfo
modifier|&
name|TemplateInfo
parameter_list|,
name|SourceLocation
name|UsingLoc
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|,
name|AccessSpecifier
name|AS
init|=
name|AS_none
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseAliasDeclarationAfterDeclarator
parameter_list|(
specifier|const
name|ParsedTemplateInfo
modifier|&
name|TemplateInfo
parameter_list|,
name|SourceLocation
name|UsingLoc
parameter_list|,
name|UsingDeclarator
modifier|&
name|D
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|,
name|AccessSpecifier
name|AS
parameter_list|,
name|ParsedAttributes
modifier|&
name|Attrs
parameter_list|,
name|Decl
modifier|*
modifier|*
name|OwnedType
init|=
name|nullptr
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseStaticAssertDeclaration
parameter_list|(
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseNamespaceAlias
parameter_list|(
name|SourceLocation
name|NamespaceLoc
parameter_list|,
name|SourceLocation
name|AliasLoc
parameter_list|,
name|IdentifierInfo
modifier|*
name|Alias
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 9: classes [class] and C structs/unions.
name|bool
name|isValidAfterTypeSpecifier
parameter_list|(
name|bool
name|CouldBeBitfield
parameter_list|)
function_decl|;
name|void
name|ParseClassSpecifier
argument_list|(
name|tok
operator|::
name|TokenKind
name|TagTokKind
argument_list|,
name|SourceLocation
name|TagLoc
argument_list|,
name|DeclSpec
operator|&
name|DS
argument_list|,
specifier|const
name|ParsedTemplateInfo
operator|&
name|TemplateInfo
argument_list|,
name|AccessSpecifier
name|AS
argument_list|,
name|bool
name|EnteringContext
argument_list|,
name|DeclSpecContext
name|DSC
argument_list|,
name|ParsedAttributesWithRange
operator|&
name|Attributes
argument_list|)
decl_stmt|;
name|void
name|SkipCXXMemberSpecification
parameter_list|(
name|SourceLocation
name|StartLoc
parameter_list|,
name|SourceLocation
name|AttrFixitLoc
parameter_list|,
name|unsigned
name|TagType
parameter_list|,
name|Decl
modifier|*
name|TagDecl
parameter_list|)
function_decl|;
name|void
name|ParseCXXMemberSpecification
parameter_list|(
name|SourceLocation
name|StartLoc
parameter_list|,
name|SourceLocation
name|AttrFixitLoc
parameter_list|,
name|ParsedAttributesWithRange
modifier|&
name|Attrs
parameter_list|,
name|unsigned
name|TagType
parameter_list|,
name|Decl
modifier|*
name|TagDecl
parameter_list|)
function_decl|;
name|ExprResult
name|ParseCXXMemberInitializer
parameter_list|(
name|Decl
modifier|*
name|D
parameter_list|,
name|bool
name|IsFunction
parameter_list|,
name|SourceLocation
modifier|&
name|EqualLoc
parameter_list|)
function_decl|;
name|bool
name|ParseCXXMemberDeclaratorBeforeInitializer
parameter_list|(
name|Declarator
modifier|&
name|DeclaratorInfo
parameter_list|,
name|VirtSpecifiers
modifier|&
name|VS
parameter_list|,
name|ExprResult
modifier|&
name|BitfieldSize
parameter_list|,
name|LateParsedAttrList
modifier|&
name|LateAttrs
parameter_list|)
function_decl|;
name|void
name|MaybeParseAndDiagnoseDeclSpecAfterCXX11VirtSpecifierSeq
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|,
name|VirtSpecifiers
modifier|&
name|VS
parameter_list|)
function_decl|;
name|DeclGroupPtrTy
name|ParseCXXClassMemberDeclaration
parameter_list|(
name|AccessSpecifier
name|AS
parameter_list|,
name|AttributeList
modifier|*
name|Attr
parameter_list|,
specifier|const
name|ParsedTemplateInfo
modifier|&
name|TemplateInfo
init|=
name|ParsedTemplateInfo
argument_list|()
parameter_list|,
name|ParsingDeclRAIIObject
modifier|*
name|DiagsFromTParams
init|=
name|nullptr
parameter_list|)
function_decl|;
name|DeclGroupPtrTy
name|ParseCXXClassMemberDeclarationWithPragmas
argument_list|(
name|AccessSpecifier
operator|&
name|AS
argument_list|,
name|ParsedAttributesWithRange
operator|&
name|AccessAttrs
argument_list|,
name|DeclSpec
operator|::
name|TST
name|TagType
argument_list|,
name|Decl
operator|*
name|Tag
argument_list|)
decl_stmt|;
name|void
name|ParseConstructorInitializer
parameter_list|(
name|Decl
modifier|*
name|ConstructorDecl
parameter_list|)
function_decl|;
name|MemInitResult
name|ParseMemInitializer
parameter_list|(
name|Decl
modifier|*
name|ConstructorDecl
parameter_list|)
function_decl|;
name|void
name|HandleMemberFunctionDeclDelays
parameter_list|(
name|Declarator
modifier|&
name|DeclaratorInfo
parameter_list|,
name|Decl
modifier|*
name|ThisDecl
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 10: Derived classes [class.derived]
name|TypeResult
name|ParseBaseTypeSpecifier
parameter_list|(
name|SourceLocation
modifier|&
name|BaseLoc
parameter_list|,
name|SourceLocation
modifier|&
name|EndLocation
parameter_list|)
function_decl|;
name|void
name|ParseBaseClause
parameter_list|(
name|Decl
modifier|*
name|ClassDecl
parameter_list|)
function_decl|;
name|BaseResult
name|ParseBaseSpecifier
parameter_list|(
name|Decl
modifier|*
name|ClassDecl
parameter_list|)
function_decl|;
name|AccessSpecifier
name|getAccessSpecifierIfPresent
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|ParseUnqualifiedIdTemplateId
parameter_list|(
name|CXXScopeSpec
modifier|&
name|SS
parameter_list|,
name|SourceLocation
name|TemplateKWLoc
parameter_list|,
name|IdentifierInfo
modifier|*
name|Name
parameter_list|,
name|SourceLocation
name|NameLoc
parameter_list|,
name|bool
name|EnteringContext
parameter_list|,
name|ParsedType
name|ObjectType
parameter_list|,
name|UnqualifiedId
modifier|&
name|Id
parameter_list|,
name|bool
name|AssumeTemplateId
parameter_list|)
function_decl|;
name|bool
name|ParseUnqualifiedIdOperator
parameter_list|(
name|CXXScopeSpec
modifier|&
name|SS
parameter_list|,
name|bool
name|EnteringContext
parameter_list|,
name|ParsedType
name|ObjectType
parameter_list|,
name|UnqualifiedId
modifier|&
name|Result
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// OpenMP: Directives and clauses.
comment|/// Parse clauses for '#pragma omp declare simd'.
name|DeclGroupPtrTy
name|ParseOMPDeclareSimdClauses
parameter_list|(
name|DeclGroupPtrTy
name|Ptr
parameter_list|,
name|CachedTokens
modifier|&
name|Toks
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|)
function_decl|;
comment|/// \brief Parses declarative OpenMP directives.
name|DeclGroupPtrTy
name|ParseOpenMPDeclarativeDirectiveWithExtDecl
argument_list|(
name|AccessSpecifier
operator|&
name|AS
argument_list|,
name|ParsedAttributesWithRange
operator|&
name|Attrs
argument_list|,
name|DeclSpec
operator|::
name|TST
name|TagType
operator|=
name|DeclSpec
operator|::
name|TST_unspecified
argument_list|,
name|Decl
operator|*
name|TagDecl
operator|=
name|nullptr
argument_list|)
decl_stmt|;
comment|/// \brief Parse 'omp declare reduction' construct.
name|DeclGroupPtrTy
name|ParseOpenMPDeclareReductionDirective
parameter_list|(
name|AccessSpecifier
name|AS
parameter_list|)
function_decl|;
comment|/// \brief Parses simple list of variables.
comment|///
comment|/// \param Kind Kind of the directive.
comment|/// \param Callback Callback function to be called for the list elements.
comment|/// \param AllowScopeSpecifier true, if the variables can have fully
comment|/// qualified names.
comment|///
name|bool
name|ParseOpenMPSimpleVarList
argument_list|(
name|OpenMPDirectiveKind
name|Kind
argument_list|,
specifier|const
name|llvm
operator|::
name|function_ref
operator|<
name|void
argument_list|(
name|CXXScopeSpec
operator|&
argument_list|,
name|DeclarationNameInfo
argument_list|)
operator|>
operator|&
name|Callback
argument_list|,
name|bool
name|AllowScopeSpecifier
argument_list|)
decl_stmt|;
comment|/// \brief Parses declarative or executable directive.
comment|///
comment|/// \param Allowed ACK_Any, if any directives are allowed,
comment|/// ACK_StatementsOpenMPAnyExecutable - if any executable directives are
comment|/// allowed, ACK_StatementsOpenMPNonStandalone - if only non-standalone
comment|/// executable directives are allowed.
comment|///
name|StmtResult
name|ParseOpenMPDeclarativeOrExecutableDirective
parameter_list|(
name|AllowedContsructsKind
name|Allowed
parameter_list|)
function_decl|;
comment|/// \brief Parses clause of kind \a CKind for directive of a kind \a Kind.
comment|///
comment|/// \param DKind Kind of current directive.
comment|/// \param CKind Kind of current clause.
comment|/// \param FirstClause true, if this is the first clause of a kind \a CKind
comment|/// in current directive.
comment|///
name|OMPClause
modifier|*
name|ParseOpenMPClause
parameter_list|(
name|OpenMPDirectiveKind
name|DKind
parameter_list|,
name|OpenMPClauseKind
name|CKind
parameter_list|,
name|bool
name|FirstClause
parameter_list|)
function_decl|;
comment|/// \brief Parses clause with a single expression of a kind \a Kind.
comment|///
comment|/// \param Kind Kind of current clause.
comment|///
name|OMPClause
modifier|*
name|ParseOpenMPSingleExprClause
parameter_list|(
name|OpenMPClauseKind
name|Kind
parameter_list|)
function_decl|;
comment|/// \brief Parses simple clause of a kind \a Kind.
comment|///
comment|/// \param Kind Kind of current clause.
comment|///
name|OMPClause
modifier|*
name|ParseOpenMPSimpleClause
parameter_list|(
name|OpenMPClauseKind
name|Kind
parameter_list|)
function_decl|;
comment|/// \brief Parses clause with a single expression and an additional argument
comment|/// of a kind \a Kind.
comment|///
comment|/// \param Kind Kind of current clause.
comment|///
name|OMPClause
modifier|*
name|ParseOpenMPSingleExprWithArgClause
parameter_list|(
name|OpenMPClauseKind
name|Kind
parameter_list|)
function_decl|;
comment|/// \brief Parses clause without any additional arguments.
comment|///
comment|/// \param Kind Kind of current clause.
comment|///
name|OMPClause
modifier|*
name|ParseOpenMPClause
parameter_list|(
name|OpenMPClauseKind
name|Kind
parameter_list|)
function_decl|;
comment|/// \brief Parses clause with the list of variables of a kind \a Kind.
comment|///
comment|/// \param Kind Kind of current clause.
comment|///
name|OMPClause
modifier|*
name|ParseOpenMPVarListClause
parameter_list|(
name|OpenMPDirectiveKind
name|DKind
parameter_list|,
name|OpenMPClauseKind
name|Kind
parameter_list|)
function_decl|;
name|public
label|:
comment|/// Parses simple expression in parens for single-expression clauses of OpenMP
comment|/// constructs.
comment|/// \param RLoc Returned location of right paren.
name|ExprResult
name|ParseOpenMPParensExpr
parameter_list|(
name|StringRef
name|ClauseName
parameter_list|,
name|SourceLocation
modifier|&
name|RLoc
parameter_list|)
function_decl|;
comment|/// Data used for parsing list of variables in OpenMP clauses.
struct|struct
name|OpenMPVarListDataTy
block|{
name|Expr
modifier|*
name|TailExpr
init|=
name|nullptr
decl_stmt|;
name|SourceLocation
name|ColonLoc
decl_stmt|;
name|CXXScopeSpec
name|ReductionIdScopeSpec
decl_stmt|;
name|DeclarationNameInfo
name|ReductionId
decl_stmt|;
name|OpenMPDependClauseKind
name|DepKind
init|=
name|OMPC_DEPEND_unknown
decl_stmt|;
name|OpenMPLinearClauseKind
name|LinKind
init|=
name|OMPC_LINEAR_val
decl_stmt|;
name|OpenMPMapClauseKind
name|MapTypeModifier
init|=
name|OMPC_MAP_unknown
decl_stmt|;
name|OpenMPMapClauseKind
name|MapType
init|=
name|OMPC_MAP_unknown
decl_stmt|;
name|bool
name|IsMapTypeImplicit
init|=
name|false
decl_stmt|;
name|SourceLocation
name|DepLinMapLoc
decl_stmt|;
block|}
struct|;
comment|/// Parses clauses with list.
name|bool
name|ParseOpenMPVarList
argument_list|(
name|OpenMPDirectiveKind
name|DKind
argument_list|,
name|OpenMPClauseKind
name|Kind
argument_list|,
name|SmallVectorImpl
operator|<
name|Expr
operator|*
operator|>
operator|&
name|Vars
argument_list|,
name|OpenMPVarListDataTy
operator|&
name|Data
argument_list|)
decl_stmt|;
name|bool
name|ParseUnqualifiedId
parameter_list|(
name|CXXScopeSpec
modifier|&
name|SS
parameter_list|,
name|bool
name|EnteringContext
parameter_list|,
name|bool
name|AllowDestructorName
parameter_list|,
name|bool
name|AllowConstructorName
parameter_list|,
name|ParsedType
name|ObjectType
parameter_list|,
name|SourceLocation
modifier|&
name|TemplateKWLoc
parameter_list|,
name|UnqualifiedId
modifier|&
name|Result
parameter_list|)
function_decl|;
name|private
label|:
comment|//===--------------------------------------------------------------------===//
comment|// C++ 14: Templates [temp]
comment|// C++ 14.1: Template Parameters [temp.param]
name|Decl
modifier|*
name|ParseDeclarationStartingWithTemplate
parameter_list|(
name|unsigned
name|Context
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|,
name|AccessSpecifier
name|AS
init|=
name|AS_none
parameter_list|,
name|AttributeList
modifier|*
name|AccessAttrs
init|=
name|nullptr
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseTemplateDeclarationOrSpecialization
parameter_list|(
name|unsigned
name|Context
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|,
name|AccessSpecifier
name|AS
parameter_list|,
name|AttributeList
modifier|*
name|AccessAttrs
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseSingleDeclarationAfterTemplate
parameter_list|(
name|unsigned
name|Context
parameter_list|,
specifier|const
name|ParsedTemplateInfo
modifier|&
name|TemplateInfo
parameter_list|,
name|ParsingDeclRAIIObject
modifier|&
name|DiagsFromParams
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|,
name|AccessSpecifier
name|AS
init|=
name|AS_none
parameter_list|,
name|AttributeList
modifier|*
name|AccessAttrs
init|=
name|nullptr
parameter_list|)
function_decl|;
name|bool
name|ParseTemplateParameters
argument_list|(
name|unsigned
name|Depth
argument_list|,
name|SmallVectorImpl
operator|<
name|Decl
operator|*
operator|>
operator|&
name|TemplateParams
argument_list|,
name|SourceLocation
operator|&
name|LAngleLoc
argument_list|,
name|SourceLocation
operator|&
name|RAngleLoc
argument_list|)
decl_stmt|;
name|bool
name|ParseTemplateParameterList
argument_list|(
name|unsigned
name|Depth
argument_list|,
name|SmallVectorImpl
operator|<
name|Decl
operator|*
operator|>
operator|&
name|TemplateParams
argument_list|)
decl_stmt|;
name|bool
name|isStartOfTemplateTypeParameter
parameter_list|()
function_decl|;
name|Decl
modifier|*
name|ParseTemplateParameter
parameter_list|(
name|unsigned
name|Depth
parameter_list|,
name|unsigned
name|Position
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseTypeParameter
parameter_list|(
name|unsigned
name|Depth
parameter_list|,
name|unsigned
name|Position
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseTemplateTemplateParameter
parameter_list|(
name|unsigned
name|Depth
parameter_list|,
name|unsigned
name|Position
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseNonTypeTemplateParameter
parameter_list|(
name|unsigned
name|Depth
parameter_list|,
name|unsigned
name|Position
parameter_list|)
function_decl|;
name|void
name|DiagnoseMisplacedEllipsis
parameter_list|(
name|SourceLocation
name|EllipsisLoc
parameter_list|,
name|SourceLocation
name|CorrectLoc
parameter_list|,
name|bool
name|AlreadyHasEllipsis
parameter_list|,
name|bool
name|IdentifierHasName
parameter_list|)
function_decl|;
name|void
name|DiagnoseMisplacedEllipsisInDeclarator
parameter_list|(
name|SourceLocation
name|EllipsisLoc
parameter_list|,
name|Declarator
modifier|&
name|D
parameter_list|)
function_decl|;
comment|// C++ 14.3: Template arguments [temp.arg]
typedef|typedef
name|SmallVector
operator|<
name|ParsedTemplateArgument
operator|,
literal|16
operator|>
name|TemplateArgList
expr_stmt|;
name|bool
name|ParseGreaterThanInTemplateList
parameter_list|(
name|SourceLocation
modifier|&
name|RAngleLoc
parameter_list|,
name|bool
name|ConsumeLastToken
parameter_list|,
name|bool
name|ObjCGenericList
parameter_list|)
function_decl|;
name|bool
name|ParseTemplateIdAfterTemplateName
parameter_list|(
name|TemplateTy
name|Template
parameter_list|,
name|SourceLocation
name|TemplateNameLoc
parameter_list|,
specifier|const
name|CXXScopeSpec
modifier|&
name|SS
parameter_list|,
name|bool
name|ConsumeLastToken
parameter_list|,
name|SourceLocation
modifier|&
name|LAngleLoc
parameter_list|,
name|TemplateArgList
modifier|&
name|TemplateArgs
parameter_list|,
name|SourceLocation
modifier|&
name|RAngleLoc
parameter_list|)
function_decl|;
name|bool
name|AnnotateTemplateIdToken
parameter_list|(
name|TemplateTy
name|Template
parameter_list|,
name|TemplateNameKind
name|TNK
parameter_list|,
name|CXXScopeSpec
modifier|&
name|SS
parameter_list|,
name|SourceLocation
name|TemplateKWLoc
parameter_list|,
name|UnqualifiedId
modifier|&
name|TemplateName
parameter_list|,
name|bool
name|AllowTypeAnnotation
init|=
name|true
parameter_list|)
function_decl|;
name|void
name|AnnotateTemplateIdTokenAsType
parameter_list|()
function_decl|;
name|bool
name|IsTemplateArgumentList
parameter_list|(
name|unsigned
name|Skip
init|=
literal|0
parameter_list|)
function_decl|;
name|bool
name|ParseTemplateArgumentList
parameter_list|(
name|TemplateArgList
modifier|&
name|TemplateArgs
parameter_list|)
function_decl|;
name|ParsedTemplateArgument
name|ParseTemplateTemplateArgument
parameter_list|()
function_decl|;
name|ParsedTemplateArgument
name|ParseTemplateArgument
parameter_list|()
function_decl|;
name|Decl
modifier|*
name|ParseExplicitInstantiation
parameter_list|(
name|unsigned
name|Context
parameter_list|,
name|SourceLocation
name|ExternLoc
parameter_list|,
name|SourceLocation
name|TemplateLoc
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|,
name|AccessSpecifier
name|AS
init|=
name|AS_none
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// Modules
name|DeclGroupPtrTy
name|ParseModuleDecl
parameter_list|()
function_decl|;
name|DeclGroupPtrTy
name|ParseModuleImport
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|)
function_decl|;
name|bool
name|parseMisplacedModuleImport
parameter_list|()
function_decl|;
name|bool
name|tryParseMisplacedModuleImport
parameter_list|()
block|{
name|tok
operator|::
name|TokenKind
name|Kind
operator|=
name|Tok
operator|.
name|getKind
argument_list|()
expr_stmt|;
if|if
condition|(
name|Kind
operator|==
name|tok
operator|::
name|annot_module_begin
operator|||
name|Kind
operator|==
name|tok
operator|::
name|annot_module_end
operator|||
name|Kind
operator|==
name|tok
operator|::
name|annot_module_include
condition|)
return|return
name|parseMisplacedModuleImport
argument_list|()
return|;
return|return
name|false
return|;
block|}
name|bool
name|ParseModuleName
argument_list|(
name|SourceLocation
name|UseLoc
argument_list|,
name|SmallVectorImpl
operator|<
name|std
operator|::
name|pair
operator|<
name|IdentifierInfo
operator|*
argument_list|,
name|SourceLocation
operator|>>
operator|&
name|Path
argument_list|,
name|bool
name|IsImport
argument_list|)
decl_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|// C++11/G++: Type Traits [Type-Traits.html in the GCC manual]
name|ExprResult
name|ParseTypeTrait
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// Embarcadero: Arary and Expression Traits
name|ExprResult
name|ParseArrayTypeTrait
parameter_list|()
function_decl|;
name|ExprResult
name|ParseExpressionTrait
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// Preprocessor code-completion pass-through
name|void
name|CodeCompleteDirective
argument_list|(
name|bool
name|InConditional
argument_list|)
name|override
decl_stmt|;
name|void
name|CodeCompleteInConditionalExclusion
argument_list|()
name|override
expr_stmt|;
name|void
name|CodeCompleteMacroName
argument_list|(
name|bool
name|IsDefinition
argument_list|)
name|override
decl_stmt|;
name|void
name|CodeCompletePreprocessorExpression
argument_list|()
name|override
expr_stmt|;
name|void
name|CodeCompleteMacroArgument
argument_list|(
name|IdentifierInfo
operator|*
name|Macro
argument_list|,
name|MacroInfo
operator|*
name|MacroInfo
argument_list|,
name|unsigned
name|ArgumentIndex
argument_list|)
name|override
decl_stmt|;
name|void
name|CodeCompleteNaturalLanguage
argument_list|()
name|override
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

