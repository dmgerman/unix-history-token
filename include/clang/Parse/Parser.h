begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- Parser.h - C Language Parser ---------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file defines the Parser interface.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_PARSE_PARSER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_PARSE_PARSER_H
end_define

begin_include
include|#
directive|include
file|"clang/Basic/Specifiers.h"
end_include

begin_include
include|#
directive|include
file|"clang/Lex/Preprocessor.h"
end_include

begin_include
include|#
directive|include
file|"clang/Lex/CodeCompletionHandler.h"
end_include

begin_include
include|#
directive|include
file|"clang/Sema/Sema.h"
end_include

begin_include
include|#
directive|include
file|"clang/Sema/DeclSpec.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/OwningPtr.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Compiler.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/PrettyStackTrace.h"
end_include

begin_include
include|#
directive|include
file|<stack>
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|PragmaHandler
decl_stmt|;
name|class
name|Scope
decl_stmt|;
name|class
name|DeclGroupRef
decl_stmt|;
name|class
name|DiagnosticBuilder
decl_stmt|;
name|class
name|Parser
decl_stmt|;
name|class
name|PragmaUnusedHandler
decl_stmt|;
name|class
name|ColonProtectionRAIIObject
decl_stmt|;
name|class
name|InMessageExpressionRAIIObject
decl_stmt|;
name|class
name|PoisonSEHIdentifiersRAIIObject
decl_stmt|;
name|class
name|VersionTuple
decl_stmt|;
comment|/// PrettyStackTraceParserEntry - If a crash happens while the parser is active,
comment|/// an entry is printed for it.
name|class
name|PrettyStackTraceParserEntry
range|:
name|public
name|llvm
operator|::
name|PrettyStackTraceEntry
block|{
specifier|const
name|Parser
operator|&
name|P
block|;
name|public
operator|:
name|PrettyStackTraceParserEntry
argument_list|(
specifier|const
name|Parser
operator|&
name|p
argument_list|)
operator|:
name|P
argument_list|(
argument|p
argument_list|)
block|{}
name|virtual
name|void
name|print
argument_list|(
argument|raw_ostream&OS
argument_list|)
specifier|const
block|; }
decl_stmt|;
comment|/// PrecedenceLevels - These are precedences for the binary/ternary
comment|/// operators in the C99 grammar.  These have been named to relate
comment|/// with the C99 grammar productions.  Low precedences numbers bind
comment|/// more weakly than high numbers.
name|namespace
name|prec
block|{
enum|enum
name|Level
block|{
name|Unknown
init|=
literal|0
block|,
comment|// Not binary operator.
name|Comma
init|=
literal|1
block|,
comment|// ,
name|Assignment
init|=
literal|2
block|,
comment|// =, *=, /=, %=, +=, -=,<<=,>>=,&=, ^=, |=
name|Conditional
init|=
literal|3
block|,
comment|// ?
name|LogicalOr
init|=
literal|4
block|,
comment|// ||
name|LogicalAnd
init|=
literal|5
block|,
comment|//&&
name|InclusiveOr
init|=
literal|6
block|,
comment|// |
name|ExclusiveOr
init|=
literal|7
block|,
comment|// ^
name|And
init|=
literal|8
block|,
comment|//&
name|Equality
init|=
literal|9
block|,
comment|// ==, !=
name|Relational
init|=
literal|10
block|,
comment|//>=,<=,>,<
name|Shift
init|=
literal|11
block|,
comment|//<<,>>
name|Additive
init|=
literal|12
block|,
comment|// -, +
name|Multiplicative
init|=
literal|13
block|,
comment|// *, /, %
name|PointerToMember
init|=
literal|14
comment|// .*, ->*
block|}
enum|;
block|}
comment|/// Parser - This implements a parser for the C family of languages.  After
comment|/// parsing units of the grammar, productions are invoked to handle whatever has
comment|/// been read.
comment|///
name|class
name|Parser
range|:
name|public
name|CodeCompletionHandler
block|{
name|friend
name|class
name|PragmaUnusedHandler
block|;
name|friend
name|class
name|ColonProtectionRAIIObject
block|;
name|friend
name|class
name|InMessageExpressionRAIIObject
block|;
name|friend
name|class
name|PoisonSEHIdentifiersRAIIObject
block|;
name|friend
name|class
name|ParenBraceBracketBalancer
block|;
name|Preprocessor
operator|&
name|PP
block|;
comment|/// Tok - The current token we are peeking ahead.  All parsing methods assume
comment|/// that this is valid.
name|Token
name|Tok
block|;
comment|// PrevTokLocation - The location of the token we previously
comment|// consumed. This token is used for diagnostics where we expected to
comment|// see a token following another token (e.g., the ';' at the end of
comment|// a statement).
name|SourceLocation
name|PrevTokLocation
block|;
name|unsigned
name|short
name|ParenCount
block|,
name|BracketCount
block|,
name|BraceCount
block|;
comment|/// Actions - These are the callbacks we invoke as we parse various constructs
comment|/// in the file.
name|Sema
operator|&
name|Actions
block|;
name|DiagnosticsEngine
operator|&
name|Diags
block|;
comment|/// ScopeCache - Cache scopes to reduce malloc traffic.
block|enum
block|{
name|ScopeCacheSize
operator|=
literal|16
block|}
block|;
name|unsigned
name|NumCachedScopes
block|;
name|Scope
operator|*
name|ScopeCache
index|[
name|ScopeCacheSize
index|]
block|;
comment|/// Identifiers used for SEH handling in Borland. These are only
comment|/// allowed in particular circumstances
comment|// __except block
name|IdentifierInfo
operator|*
name|Ident__exception_code
block|,
operator|*
name|Ident___exception_code
block|,
operator|*
name|Ident_GetExceptionCode
block|;
comment|// __except filter expression
name|IdentifierInfo
operator|*
name|Ident__exception_info
block|,
operator|*
name|Ident___exception_info
block|,
operator|*
name|Ident_GetExceptionInfo
block|;
comment|// __finally
name|IdentifierInfo
operator|*
name|Ident__abnormal_termination
block|,
operator|*
name|Ident___abnormal_termination
block|,
operator|*
name|Ident_AbnormalTermination
block|;
comment|/// Contextual keywords for Microsoft extensions.
name|IdentifierInfo
operator|*
name|Ident__except
block|;
comment|/// Ident_super - IdentifierInfo for "super", to support fast
comment|/// comparison.
name|IdentifierInfo
operator|*
name|Ident_super
block|;
comment|/// Ident_vector and Ident_pixel - cached IdentifierInfo's for
comment|/// "vector" and "pixel" fast comparison.  Only present if
comment|/// AltiVec enabled.
name|IdentifierInfo
operator|*
name|Ident_vector
block|;
name|IdentifierInfo
operator|*
name|Ident_pixel
block|;
comment|/// Objective-C contextual keywords.
name|mutable
name|IdentifierInfo
operator|*
name|Ident_instancetype
block|;
comment|/// \brief Identifier for "introduced".
name|IdentifierInfo
operator|*
name|Ident_introduced
block|;
comment|/// \brief Identifier for "deprecated".
name|IdentifierInfo
operator|*
name|Ident_deprecated
block|;
comment|/// \brief Identifier for "obsoleted".
name|IdentifierInfo
operator|*
name|Ident_obsoleted
block|;
comment|/// \brief Identifier for "unavailable".
name|IdentifierInfo
operator|*
name|Ident_unavailable
block|;
comment|/// \brief Identifier for "message".
name|IdentifierInfo
operator|*
name|Ident_message
block|;
comment|/// C++0x contextual keywords.
name|mutable
name|IdentifierInfo
operator|*
name|Ident_final
block|;
name|mutable
name|IdentifierInfo
operator|*
name|Ident_override
block|;
name|OwningPtr
operator|<
name|PragmaHandler
operator|>
name|AlignHandler
block|;
name|OwningPtr
operator|<
name|PragmaHandler
operator|>
name|GCCVisibilityHandler
block|;
name|OwningPtr
operator|<
name|PragmaHandler
operator|>
name|OptionsHandler
block|;
name|OwningPtr
operator|<
name|PragmaHandler
operator|>
name|PackHandler
block|;
name|OwningPtr
operator|<
name|PragmaHandler
operator|>
name|MSStructHandler
block|;
name|OwningPtr
operator|<
name|PragmaHandler
operator|>
name|UnusedHandler
block|;
name|OwningPtr
operator|<
name|PragmaHandler
operator|>
name|WeakHandler
block|;
name|OwningPtr
operator|<
name|PragmaHandler
operator|>
name|RedefineExtnameHandler
block|;
name|OwningPtr
operator|<
name|PragmaHandler
operator|>
name|FPContractHandler
block|;
name|OwningPtr
operator|<
name|PragmaHandler
operator|>
name|OpenCLExtensionHandler
block|;
comment|/// Whether the '>' token acts as an operator or not. This will be
comment|/// true except when we are parsing an expression within a C++
comment|/// template argument list, where the '>' closes the template
comment|/// argument list.
name|bool
name|GreaterThanIsOperator
block|;
comment|/// ColonIsSacred - When this is false, we aggressively try to recover from
comment|/// code like "foo : bar" as if it were a typo for "foo :: bar".  This is not
comment|/// safe in case statements and a few other things.  This is managed by the
comment|/// ColonProtectionRAIIObject RAII object.
name|bool
name|ColonIsSacred
block|;
comment|/// \brief When true, we are directly inside an Objective-C messsage
comment|/// send expression.
comment|///
comment|/// This is managed by the \c InMessageExpressionRAIIObject class, and
comment|/// should not be set directly.
name|bool
name|InMessageExpression
block|;
comment|/// The "depth" of the template parameters currently being parsed.
name|unsigned
name|TemplateParameterDepth
block|;
comment|/// Factory object for creating AttributeList objects.
name|AttributeFactory
name|AttrFactory
block|;
comment|/// \brief Gathers and cleans up TemplateIdAnnotations when parsing of a
comment|/// top-level declaration is finished.
name|SmallVector
operator|<
name|TemplateIdAnnotation
operator|*
block|,
literal|16
operator|>
name|TemplateIds
block|;
name|IdentifierInfo
operator|*
name|getSEHExceptKeyword
argument_list|()
block|;
name|bool
name|SkipFunctionBodies
block|;
name|public
operator|:
name|Parser
argument_list|(
argument|Preprocessor&PP
argument_list|,
argument|Sema&Actions
argument_list|,
argument|bool SkipFunctionBodies
argument_list|)
block|;
operator|~
name|Parser
argument_list|()
block|;
specifier|const
name|LangOptions
operator|&
name|getLangOpts
argument_list|()
specifier|const
block|{
return|return
name|PP
operator|.
name|getLangOpts
argument_list|()
return|;
block|}
specifier|const
name|TargetInfo
operator|&
name|getTargetInfo
argument_list|()
specifier|const
block|{
return|return
name|PP
operator|.
name|getTargetInfo
argument_list|()
return|;
block|}
name|Preprocessor
operator|&
name|getPreprocessor
argument_list|()
specifier|const
block|{
return|return
name|PP
return|;
block|}
name|Sema
operator|&
name|getActions
argument_list|()
specifier|const
block|{
return|return
name|Actions
return|;
block|}
specifier|const
name|Token
operator|&
name|getCurToken
argument_list|()
specifier|const
block|{
return|return
name|Tok
return|;
block|}
name|Scope
operator|*
name|getCurScope
argument_list|()
specifier|const
block|{
return|return
name|Actions
operator|.
name|getCurScope
argument_list|()
return|;
block|}
name|Decl
operator|*
name|getObjCDeclContext
argument_list|()
specifier|const
block|{
return|return
name|Actions
operator|.
name|getObjCDeclContext
argument_list|()
return|;
block|}
comment|// Type forwarding.  All of these are statically 'void*', but they may all be
comment|// different actual classes based on the actions in place.
typedef|typedef
name|OpaquePtr
operator|<
name|DeclGroupRef
operator|>
name|DeclGroupPtrTy
expr_stmt|;
typedef|typedef
name|OpaquePtr
operator|<
name|TemplateName
operator|>
name|TemplateTy
expr_stmt|;
typedef|typedef
name|SmallVector
operator|<
name|TemplateParameterList
operator|*
operator|,
literal|4
operator|>
name|TemplateParameterLists
expr_stmt|;
typedef|typedef
name|clang
operator|::
name|ExprResult
name|ExprResult
expr_stmt|;
typedef|typedef
name|clang
operator|::
name|StmtResult
name|StmtResult
expr_stmt|;
typedef|typedef
name|clang
operator|::
name|BaseResult
name|BaseResult
expr_stmt|;
typedef|typedef
name|clang
operator|::
name|MemInitResult
name|MemInitResult
expr_stmt|;
typedef|typedef
name|clang
operator|::
name|TypeResult
name|TypeResult
expr_stmt|;
typedef|typedef
name|Expr
modifier|*
name|ExprArg
typedef|;
typedef|typedef
name|ASTMultiPtr
operator|<
name|Stmt
operator|*
operator|>
name|MultiStmtArg
expr_stmt|;
typedef|typedef
name|Sema
operator|::
name|FullExprArg
name|FullExprArg
expr_stmt|;
comment|/// Adorns a ExprResult with Actions to make it an ExprResult
name|ExprResult
name|Owned
parameter_list|(
name|ExprResult
name|res
parameter_list|)
block|{
return|return
name|ExprResult
argument_list|(
name|res
argument_list|)
return|;
block|}
comment|/// Adorns a StmtResult with Actions to make it an StmtResult
name|StmtResult
name|Owned
parameter_list|(
name|StmtResult
name|res
parameter_list|)
block|{
return|return
name|StmtResult
argument_list|(
name|res
argument_list|)
return|;
block|}
name|ExprResult
name|ExprError
parameter_list|()
block|{
return|return
name|ExprResult
argument_list|(
name|true
argument_list|)
return|;
block|}
name|StmtResult
name|StmtError
parameter_list|()
block|{
return|return
name|StmtResult
argument_list|(
name|true
argument_list|)
return|;
block|}
name|ExprResult
name|ExprError
parameter_list|(
specifier|const
name|DiagnosticBuilder
modifier|&
parameter_list|)
block|{
return|return
name|ExprError
argument_list|()
return|;
block|}
name|StmtResult
name|StmtError
parameter_list|(
specifier|const
name|DiagnosticBuilder
modifier|&
parameter_list|)
block|{
return|return
name|StmtError
argument_list|()
return|;
block|}
name|ExprResult
name|ExprEmpty
parameter_list|()
block|{
return|return
name|ExprResult
argument_list|(
name|false
argument_list|)
return|;
block|}
comment|// Parsing methods.
comment|/// ParseTranslationUnit - All in one method that initializes parses, and
comment|/// shuts down the parser.
name|void
name|ParseTranslationUnit
parameter_list|()
function_decl|;
comment|/// Initialize - Warm up the parser.
comment|///
name|void
name|Initialize
parameter_list|()
function_decl|;
comment|/// ParseTopLevelDecl - Parse one top-level declaration. Returns true if
comment|/// the EOF was encountered.
name|bool
name|ParseTopLevelDecl
parameter_list|(
name|DeclGroupPtrTy
modifier|&
name|Result
parameter_list|)
function_decl|;
name|private
label|:
comment|//===--------------------------------------------------------------------===//
comment|// Low-Level token peeking and consumption methods.
comment|//
comment|/// isTokenParen - Return true if the cur token is '(' or ')'.
name|bool
name|isTokenParen
argument_list|()
specifier|const
block|{
return|return
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|l_paren
operator|||
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|r_paren
return|;
block|}
comment|/// isTokenBracket - Return true if the cur token is '[' or ']'.
name|bool
name|isTokenBracket
argument_list|()
specifier|const
block|{
return|return
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|l_square
operator|||
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|r_square
return|;
block|}
comment|/// isTokenBrace - Return true if the cur token is '{' or '}'.
name|bool
name|isTokenBrace
argument_list|()
specifier|const
block|{
return|return
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|l_brace
operator|||
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|r_brace
return|;
block|}
comment|/// isTokenStringLiteral - True if this token is a string-literal.
comment|///
name|bool
name|isTokenStringLiteral
argument_list|()
specifier|const
block|{
return|return
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|string_literal
operator|||
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|wide_string_literal
operator|||
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|utf8_string_literal
operator|||
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|utf16_string_literal
operator|||
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|utf32_string_literal
return|;
block|}
comment|/// \brief Returns true if the current token is '=' or is a type of '='.
comment|/// For typos, give a fixit to '='
name|bool
name|isTokenEqualOrEqualTypo
parameter_list|()
function_decl|;
comment|/// ConsumeToken - Consume the current 'peek token' and lex the next one.
comment|/// This does not work with all kinds of tokens: strings and specific other
comment|/// tokens must be consumed with custom methods below.  This returns the
comment|/// location of the consumed token.
name|SourceLocation
name|ConsumeToken
parameter_list|()
block|{
name|assert
argument_list|(
operator|!
name|isTokenStringLiteral
argument_list|()
operator|&&
operator|!
name|isTokenParen
argument_list|()
operator|&&
operator|!
name|isTokenBracket
argument_list|()
operator|&&
operator|!
name|isTokenBrace
argument_list|()
operator|&&
literal|"Should consume special tokens with Consume*Token"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tok
operator|.
name|is
argument_list|(
name|tok
operator|::
name|code_completion
argument_list|)
condition|)
return|return
name|handleUnexpectedCodeCompletionToken
argument_list|()
return|;
name|PrevTokLocation
operator|=
name|Tok
operator|.
name|getLocation
argument_list|()
expr_stmt|;
name|PP
operator|.
name|Lex
argument_list|(
name|Tok
argument_list|)
expr_stmt|;
return|return
name|PrevTokLocation
return|;
block|}
comment|/// ConsumeAnyToken - Dispatch to the right Consume* method based on the
comment|/// current token type.  This should only be used in cases where the type of
comment|/// the token really isn't known, e.g. in error recovery.
name|SourceLocation
name|ConsumeAnyToken
parameter_list|()
block|{
if|if
condition|(
name|isTokenParen
argument_list|()
condition|)
return|return
name|ConsumeParen
argument_list|()
return|;
elseif|else
if|if
condition|(
name|isTokenBracket
argument_list|()
condition|)
return|return
name|ConsumeBracket
argument_list|()
return|;
elseif|else
if|if
condition|(
name|isTokenBrace
argument_list|()
condition|)
return|return
name|ConsumeBrace
argument_list|()
return|;
elseif|else
if|if
condition|(
name|isTokenStringLiteral
argument_list|()
condition|)
return|return
name|ConsumeStringToken
argument_list|()
return|;
else|else
return|return
name|ConsumeToken
argument_list|()
return|;
block|}
comment|/// ConsumeParen - This consume method keeps the paren count up-to-date.
comment|///
name|SourceLocation
name|ConsumeParen
parameter_list|()
block|{
name|assert
argument_list|(
name|isTokenParen
argument_list|()
operator|&&
literal|"wrong consume method"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|l_paren
condition|)
operator|++
name|ParenCount
expr_stmt|;
elseif|else
if|if
condition|(
name|ParenCount
condition|)
operator|--
name|ParenCount
expr_stmt|;
comment|// Don't let unbalanced )'s drive the count negative.
name|PrevTokLocation
operator|=
name|Tok
operator|.
name|getLocation
argument_list|()
expr_stmt|;
name|PP
operator|.
name|Lex
argument_list|(
name|Tok
argument_list|)
expr_stmt|;
return|return
name|PrevTokLocation
return|;
block|}
comment|/// ConsumeBracket - This consume method keeps the bracket count up-to-date.
comment|///
name|SourceLocation
name|ConsumeBracket
parameter_list|()
block|{
name|assert
argument_list|(
name|isTokenBracket
argument_list|()
operator|&&
literal|"wrong consume method"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|l_square
condition|)
operator|++
name|BracketCount
expr_stmt|;
elseif|else
if|if
condition|(
name|BracketCount
condition|)
operator|--
name|BracketCount
expr_stmt|;
comment|// Don't let unbalanced ]'s drive the count negative.
name|PrevTokLocation
operator|=
name|Tok
operator|.
name|getLocation
argument_list|()
expr_stmt|;
name|PP
operator|.
name|Lex
argument_list|(
name|Tok
argument_list|)
expr_stmt|;
return|return
name|PrevTokLocation
return|;
block|}
comment|/// ConsumeBrace - This consume method keeps the brace count up-to-date.
comment|///
name|SourceLocation
name|ConsumeBrace
parameter_list|()
block|{
name|assert
argument_list|(
name|isTokenBrace
argument_list|()
operator|&&
literal|"wrong consume method"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|l_brace
condition|)
operator|++
name|BraceCount
expr_stmt|;
elseif|else
if|if
condition|(
name|BraceCount
condition|)
operator|--
name|BraceCount
expr_stmt|;
comment|// Don't let unbalanced }'s drive the count negative.
name|PrevTokLocation
operator|=
name|Tok
operator|.
name|getLocation
argument_list|()
expr_stmt|;
name|PP
operator|.
name|Lex
argument_list|(
name|Tok
argument_list|)
expr_stmt|;
return|return
name|PrevTokLocation
return|;
block|}
comment|/// ConsumeStringToken - Consume the current 'peek token', lexing a new one
comment|/// and returning the token kind.  This method is specific to strings, as it
comment|/// handles string literal concatenation, as per C99 5.1.1.2, translation
comment|/// phase #6.
name|SourceLocation
name|ConsumeStringToken
parameter_list|()
block|{
name|assert
argument_list|(
name|isTokenStringLiteral
argument_list|()
operator|&&
literal|"Should only consume string literals with this method"
argument_list|)
expr_stmt|;
name|PrevTokLocation
operator|=
name|Tok
operator|.
name|getLocation
argument_list|()
expr_stmt|;
name|PP
operator|.
name|Lex
argument_list|(
name|Tok
argument_list|)
expr_stmt|;
return|return
name|PrevTokLocation
return|;
block|}
comment|/// \brief Consume the current code-completion token.
comment|///
comment|/// This routine should be called to consume the code-completion token once
comment|/// a code-completion action has already been invoked.
name|SourceLocation
name|ConsumeCodeCompletionToken
parameter_list|()
block|{
name|assert
argument_list|(
name|Tok
operator|.
name|is
argument_list|(
name|tok
operator|::
name|code_completion
argument_list|)
argument_list|)
expr_stmt|;
name|PrevTokLocation
operator|=
name|Tok
operator|.
name|getLocation
argument_list|()
expr_stmt|;
name|PP
operator|.
name|Lex
argument_list|(
name|Tok
argument_list|)
expr_stmt|;
return|return
name|PrevTokLocation
return|;
block|}
comment|///\ brief When we are consuming a code-completion token without having
comment|/// matched specific position in the grammar, provide code-completion results
comment|/// based on context.
comment|///
comment|/// \returns the source location of the code-completion token.
name|SourceLocation
name|handleUnexpectedCodeCompletionToken
parameter_list|()
function_decl|;
comment|/// \brief Abruptly cut off parsing; mainly used when we have reached the
comment|/// code-completion point.
name|void
name|cutOffParsing
parameter_list|()
block|{
name|PP
operator|.
name|setCodeCompletionReached
argument_list|()
expr_stmt|;
comment|// Cut off parsing by acting as if we reached the end-of-file.
name|Tok
operator|.
name|setKind
argument_list|(
name|tok
operator|::
name|eof
argument_list|)
expr_stmt|;
block|}
comment|/// \brief Handle the annotation token produced for #pragma unused(...)
name|void
name|HandlePragmaUnused
parameter_list|()
function_decl|;
comment|/// \brief Handle the annotation token produced for
comment|/// #pragma GCC visibility...
name|void
name|HandlePragmaVisibility
parameter_list|()
function_decl|;
comment|/// \brief Handle the annotation token produced for
comment|/// #pragma pack...
name|void
name|HandlePragmaPack
parameter_list|()
function_decl|;
comment|/// GetLookAheadToken - This peeks ahead N tokens and returns that token
comment|/// without consuming any tokens.  LookAhead(0) returns 'Tok', LookAhead(1)
comment|/// returns the token after Tok, etc.
comment|///
comment|/// Note that this differs from the Preprocessor's LookAhead method, because
comment|/// the Parser always has one token lexed that the preprocessor doesn't.
comment|///
specifier|const
name|Token
modifier|&
name|GetLookAheadToken
parameter_list|(
name|unsigned
name|N
parameter_list|)
block|{
if|if
condition|(
name|N
operator|==
literal|0
operator|||
name|Tok
operator|.
name|is
argument_list|(
name|tok
operator|::
name|eof
argument_list|)
condition|)
return|return
name|Tok
return|;
return|return
name|PP
operator|.
name|LookAhead
argument_list|(
name|N
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/// NextToken - This peeks ahead one token and returns it without
comment|/// consuming it.
specifier|const
name|Token
modifier|&
name|NextToken
parameter_list|()
block|{
return|return
name|PP
operator|.
name|LookAhead
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/// \brief RAII class that helps handle the parsing of an open/close delimiter
comment|/// pair, such as braces { ... } or parentheses ( ... ).
name|class
name|BalancedDelimiterTracker
block|{
name|Parser
modifier|&
name|P
decl_stmt|;
name|tok
operator|::
name|TokenKind
name|Kind
operator|,
name|Close
expr_stmt|;
name|SourceLocation
argument_list|(
name|Parser
operator|::
operator|*
name|Consumer
argument_list|)
argument_list|()
expr_stmt|;
name|SourceLocation
name|LOpen
decl_stmt|,
name|LClose
decl_stmt|;
name|unsigned
name|short
modifier|&
name|getDepth
parameter_list|()
block|{
switch|switch
condition|(
name|Kind
condition|)
block|{
case|case
name|tok
operator|::
name|l_brace
case|:
return|return
name|P
operator|.
name|BraceCount
return|;
case|case
name|tok
operator|::
name|l_square
case|:
return|return
name|P
operator|.
name|BracketCount
return|;
case|case
name|tok
operator|::
name|l_paren
case|:
return|return
name|P
operator|.
name|ParenCount
return|;
default|default:
name|llvm_unreachable
argument_list|(
literal|"Wrong token kind"
argument_list|)
expr_stmt|;
block|}
block|}
enum|enum
block|{
name|MaxDepth
init|=
literal|256
block|}
enum|;
name|bool
name|diagnoseOverflow
parameter_list|()
function_decl|;
name|bool
name|diagnoseMissingClose
parameter_list|()
function_decl|;
name|public
label|:
name|BalancedDelimiterTracker
argument_list|(
argument|Parser& p
argument_list|,
argument|tok::TokenKind k
argument_list|)
block|:
name|P
argument_list|(
name|p
argument_list|)
operator|,
name|Kind
argument_list|(
argument|k
argument_list|)
block|{
switch|switch
condition|(
name|Kind
condition|)
block|{
default|default:
name|llvm_unreachable
argument_list|(
literal|"Unexpected balanced token"
argument_list|)
expr_stmt|;
case|case
name|tok
operator|::
name|l_brace
case|:
name|Close
operator|=
name|tok
operator|::
name|r_brace
expr_stmt|;
name|Consumer
operator|=
operator|&
name|Parser
operator|::
name|ConsumeBrace
expr_stmt|;
break|break;
case|case
name|tok
operator|::
name|l_paren
case|:
name|Close
operator|=
name|tok
operator|::
name|r_paren
expr_stmt|;
name|Consumer
operator|=
operator|&
name|Parser
operator|::
name|ConsumeParen
expr_stmt|;
break|break;
case|case
name|tok
operator|::
name|l_square
case|:
name|Close
operator|=
name|tok
operator|::
name|r_square
expr_stmt|;
name|Consumer
operator|=
operator|&
name|Parser
operator|::
name|ConsumeBracket
expr_stmt|;
break|break;
block|}
block|}
name|SourceLocation
name|getOpenLocation
argument_list|()
specifier|const
block|{
return|return
name|LOpen
return|;
block|}
name|SourceLocation
name|getCloseLocation
argument_list|()
specifier|const
block|{
return|return
name|LClose
return|;
block|}
name|SourceRange
name|getRange
argument_list|()
specifier|const
block|{
return|return
name|SourceRange
argument_list|(
name|LOpen
argument_list|,
name|LClose
argument_list|)
return|;
block|}
name|bool
name|consumeOpen
parameter_list|()
block|{
if|if
condition|(
operator|!
name|P
operator|.
name|Tok
operator|.
name|is
argument_list|(
name|Kind
argument_list|)
condition|)
return|return
name|true
return|;
if|if
condition|(
name|getDepth
argument_list|()
operator|<
name|MaxDepth
condition|)
block|{
name|LOpen
operator|=
operator|(
name|P
operator|.*
name|Consumer
operator|)
operator|(
operator|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|diagnoseOverflow
argument_list|()
return|;
block|}
name|bool
name|expectAndConsume
argument_list|(
name|unsigned
name|DiagID
argument_list|,
specifier|const
name|char
operator|*
name|Msg
operator|=
literal|""
argument_list|,
name|tok
operator|::
name|TokenKind
name|SkipToTok
operator|=
name|tok
operator|::
name|unknown
argument_list|)
decl_stmt|;
name|bool
name|consumeClose
parameter_list|()
block|{
if|if
condition|(
name|P
operator|.
name|Tok
operator|.
name|is
argument_list|(
name|Close
argument_list|)
condition|)
block|{
name|LClose
operator|=
operator|(
name|P
operator|.*
name|Consumer
operator|)
operator|(
operator|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|diagnoseMissingClose
argument_list|()
return|;
block|}
name|void
name|skipToEnd
parameter_list|()
function_decl|;
block|}
empty_stmt|;
comment|/// getTypeAnnotation - Read a parsed type out of an annotation token.
specifier|static
name|ParsedType
name|getTypeAnnotation
parameter_list|(
name|Token
modifier|&
name|Tok
parameter_list|)
block|{
return|return
name|ParsedType
operator|::
name|getFromOpaquePtr
argument_list|(
name|Tok
operator|.
name|getAnnotationValue
argument_list|()
argument_list|)
return|;
block|}
specifier|static
name|void
name|setTypeAnnotation
parameter_list|(
name|Token
modifier|&
name|Tok
parameter_list|,
name|ParsedType
name|T
parameter_list|)
block|{
name|Tok
operator|.
name|setAnnotationValue
argument_list|(
name|T
operator|.
name|getAsOpaquePtr
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/// \brief Read an already-translated primary expression out of an annotation
comment|/// token.
specifier|static
name|ExprResult
name|getExprAnnotation
parameter_list|(
name|Token
modifier|&
name|Tok
parameter_list|)
block|{
if|if
condition|(
name|Tok
operator|.
name|getAnnotationValue
argument_list|()
condition|)
return|return
name|ExprResult
argument_list|(
operator|(
name|Expr
operator|*
operator|)
name|Tok
operator|.
name|getAnnotationValue
argument_list|()
argument_list|)
return|;
return|return
name|ExprResult
argument_list|(
name|true
argument_list|)
return|;
block|}
comment|/// \brief Set the primary expression corresponding to the given annotation
comment|/// token.
specifier|static
name|void
name|setExprAnnotation
parameter_list|(
name|Token
modifier|&
name|Tok
parameter_list|,
name|ExprResult
name|ER
parameter_list|)
block|{
if|if
condition|(
name|ER
operator|.
name|isInvalid
argument_list|()
condition|)
name|Tok
operator|.
name|setAnnotationValue
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
name|Tok
operator|.
name|setAnnotationValue
argument_list|(
name|ER
operator|.
name|get
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|// If NeedType is true, then TryAnnotateTypeOrScopeToken will try harder to
comment|// find a type name by attempting typo correction.
name|bool
name|TryAnnotateTypeOrScopeToken
parameter_list|(
name|bool
name|EnteringContext
init|=
name|false
parameter_list|,
name|bool
name|NeedType
init|=
name|false
parameter_list|)
function_decl|;
name|bool
name|TryAnnotateCXXScopeToken
parameter_list|(
name|bool
name|EnteringContext
init|=
name|false
parameter_list|)
function_decl|;
comment|/// TryAltiVecToken - Check for context-sensitive AltiVec identifier tokens,
comment|/// replacing them with the non-context-sensitive keywords.  This returns
comment|/// true if the token was replaced.
name|bool
name|TryAltiVecToken
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|,
name|bool
modifier|&
name|isInvalid
parameter_list|)
block|{
if|if
condition|(
operator|!
name|getLangOpts
argument_list|()
operator|.
name|AltiVec
operator|||
operator|(
name|Tok
operator|.
name|getIdentifierInfo
argument_list|()
operator|!=
name|Ident_vector
operator|&&
name|Tok
operator|.
name|getIdentifierInfo
argument_list|()
operator|!=
name|Ident_pixel
operator|)
condition|)
return|return
name|false
return|;
return|return
name|TryAltiVecTokenOutOfLine
argument_list|(
name|DS
argument_list|,
name|Loc
argument_list|,
name|PrevSpec
argument_list|,
name|DiagID
argument_list|,
name|isInvalid
argument_list|)
return|;
block|}
comment|/// TryAltiVecVectorToken - Check for context-sensitive AltiVec vector
comment|/// identifier token, replacing it with the non-context-sensitive __vector.
comment|/// This returns true if the token was replaced.
name|bool
name|TryAltiVecVectorToken
parameter_list|()
block|{
if|if
condition|(
operator|!
name|getLangOpts
argument_list|()
operator|.
name|AltiVec
operator|||
name|Tok
operator|.
name|getIdentifierInfo
argument_list|()
operator|!=
name|Ident_vector
condition|)
return|return
name|false
return|;
return|return
name|TryAltiVecVectorTokenOutOfLine
argument_list|()
return|;
block|}
name|bool
name|TryAltiVecVectorTokenOutOfLine
parameter_list|()
function_decl|;
name|bool
name|TryAltiVecTokenOutOfLine
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
name|unsigned
modifier|&
name|DiagID
parameter_list|,
name|bool
modifier|&
name|isInvalid
parameter_list|)
function_decl|;
comment|/// \brief Get the TemplateIdAnnotation from the token.
name|TemplateIdAnnotation
modifier|*
name|takeTemplateIdAnnotation
parameter_list|(
specifier|const
name|Token
modifier|&
name|tok
parameter_list|)
function_decl|;
comment|/// TentativeParsingAction - An object that is used as a kind of "tentative
comment|/// parsing transaction". It gets instantiated to mark the token position and
comment|/// after the token consumption is done, Commit() or Revert() is called to
comment|/// either "commit the consumed tokens" or revert to the previously marked
comment|/// token position. Example:
comment|///
comment|///   TentativeParsingAction TPA(*this);
comment|///   ConsumeToken();
comment|///   ....
comment|///   TPA.Revert();
comment|///
name|class
name|TentativeParsingAction
block|{
name|Parser
modifier|&
name|P
decl_stmt|;
name|Token
name|PrevTok
decl_stmt|;
name|unsigned
name|short
name|PrevParenCount
decl_stmt|,
name|PrevBracketCount
decl_stmt|,
name|PrevBraceCount
decl_stmt|;
name|bool
name|isActive
decl_stmt|;
name|public
label|:
name|explicit
name|TentativeParsingAction
argument_list|(
name|Parser
operator|&
name|p
argument_list|)
operator|:
name|P
argument_list|(
argument|p
argument_list|)
block|{
name|PrevTok
operator|=
name|P
operator|.
name|Tok
block|;
name|PrevParenCount
operator|=
name|P
operator|.
name|ParenCount
block|;
name|PrevBracketCount
operator|=
name|P
operator|.
name|BracketCount
block|;
name|PrevBraceCount
operator|=
name|P
operator|.
name|BraceCount
block|;
name|P
operator|.
name|PP
operator|.
name|EnableBacktrackAtThisPos
argument_list|()
block|;
name|isActive
operator|=
name|true
block|;     }
name|void
name|Commit
argument_list|()
block|{
name|assert
argument_list|(
name|isActive
operator|&&
literal|"Parsing action was finished!"
argument_list|)
block|;
name|P
operator|.
name|PP
operator|.
name|CommitBacktrackedTokens
argument_list|()
block|;
name|isActive
operator|=
name|false
block|;     }
name|void
name|Revert
argument_list|()
block|{
name|assert
argument_list|(
name|isActive
operator|&&
literal|"Parsing action was finished!"
argument_list|)
block|;
name|P
operator|.
name|PP
operator|.
name|Backtrack
argument_list|()
block|;
name|P
operator|.
name|Tok
operator|=
name|PrevTok
block|;
name|P
operator|.
name|ParenCount
operator|=
name|PrevParenCount
block|;
name|P
operator|.
name|BracketCount
operator|=
name|PrevBracketCount
block|;
name|P
operator|.
name|BraceCount
operator|=
name|PrevBraceCount
block|;
name|isActive
operator|=
name|false
block|;     }
operator|~
name|TentativeParsingAction
argument_list|()
block|{
name|assert
argument_list|(
operator|!
name|isActive
operator|&&
literal|"Forgot to call Commit or Revert!"
argument_list|)
block|;     }
block|}
empty_stmt|;
comment|/// ObjCDeclContextSwitch - An object used to switch context from
comment|/// an objective-c decl context to its enclosing decl context and
comment|/// back.
name|class
name|ObjCDeclContextSwitch
block|{
name|Parser
modifier|&
name|P
decl_stmt|;
name|Decl
modifier|*
name|DC
decl_stmt|;
name|public
label|:
name|explicit
name|ObjCDeclContextSwitch
argument_list|(
name|Parser
operator|&
name|p
argument_list|)
operator|:
name|P
argument_list|(
name|p
argument_list|)
operator|,
name|DC
argument_list|(
argument|p.getObjCDeclContext()
argument_list|)
block|{
if|if
condition|(
name|DC
condition|)
name|P
operator|.
name|Actions
operator|.
name|ActOnObjCTemporaryExitContainerContext
argument_list|(
name|cast
operator|<
name|DeclContext
operator|>
operator|(
name|DC
operator|)
argument_list|)
expr_stmt|;
block|}
operator|~
name|ObjCDeclContextSwitch
argument_list|()
block|{
if|if
condition|(
name|DC
condition|)
name|P
operator|.
name|Actions
operator|.
name|ActOnObjCReenterContainerContext
argument_list|(
name|cast
operator|<
name|DeclContext
operator|>
operator|(
name|DC
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
empty_stmt|;
comment|/// ExpectAndConsume - The parser expects that 'ExpectedTok' is next in the
comment|/// input.  If so, it is consumed and false is returned.
comment|///
comment|/// If the input is malformed, this emits the specified diagnostic.  Next, if
comment|/// SkipToTok is specified, it calls SkipUntil(SkipToTok).  Finally, true is
comment|/// returned.
name|bool
name|ExpectAndConsume
argument_list|(
name|tok
operator|::
name|TokenKind
name|ExpectedTok
argument_list|,
name|unsigned
name|Diag
argument_list|,
specifier|const
name|char
operator|*
name|DiagMsg
operator|=
literal|""
argument_list|,
name|tok
operator|::
name|TokenKind
name|SkipToTok
operator|=
name|tok
operator|::
name|unknown
argument_list|)
decl_stmt|;
comment|/// \brief The parser expects a semicolon and, if present, will consume it.
comment|///
comment|/// If the next token is not a semicolon, this emits the specified diagnostic,
comment|/// or, if there's just some closing-delimiter noise (e.g., ')' or ']') prior
comment|/// to the semicolon, consumes that extra token.
name|bool
name|ExpectAndConsumeSemi
parameter_list|(
name|unsigned
name|DiagID
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// Scope manipulation
comment|/// ParseScope - Introduces a new scope for parsing. The kind of
comment|/// scope is determined by ScopeFlags. Objects of this type should
comment|/// be created on the stack to coincide with the position where the
comment|/// parser enters the new scope, and this object's constructor will
comment|/// create that new scope. Similarly, once the object is destroyed
comment|/// the parser will exit the scope.
name|class
name|ParseScope
block|{
name|Parser
modifier|*
name|Self
decl_stmt|;
name|ParseScope
argument_list|(
specifier|const
name|ParseScope
operator|&
argument_list|)
expr_stmt|;
comment|// do not implement
name|ParseScope
modifier|&
name|operator
init|=
operator|(
specifier|const
name|ParseScope
operator|&
operator|)
decl_stmt|;
comment|// do not implement
name|public
label|:
comment|// ParseScope - Construct a new object to manage a scope in the
comment|// parser Self where the new Scope is created with the flags
comment|// ScopeFlags, but only when ManageScope is true (the default). If
comment|// ManageScope is false, this object does nothing.
name|ParseScope
argument_list|(
argument|Parser *Self
argument_list|,
argument|unsigned ScopeFlags
argument_list|,
argument|bool ManageScope = true
argument_list|)
block|:
name|Self
argument_list|(
argument|Self
argument_list|)
block|{
if|if
condition|(
name|ManageScope
condition|)
name|Self
operator|->
name|EnterScope
argument_list|(
name|ScopeFlags
argument_list|)
expr_stmt|;
else|else
name|this
operator|->
name|Self
operator|=
literal|0
expr_stmt|;
block|}
comment|// Exit - Exit the scope associated with this object now, rather
comment|// than waiting until the object is destroyed.
name|void
name|Exit
parameter_list|()
block|{
if|if
condition|(
name|Self
condition|)
block|{
name|Self
operator|->
name|ExitScope
argument_list|()
expr_stmt|;
name|Self
operator|=
literal|0
expr_stmt|;
block|}
block|}
operator|~
name|ParseScope
argument_list|()
block|{
name|Exit
argument_list|()
block|;     }
block|}
empty_stmt|;
comment|/// EnterScope - Start a new scope.
name|void
name|EnterScope
parameter_list|(
name|unsigned
name|ScopeFlags
parameter_list|)
function_decl|;
comment|/// ExitScope - Pop a scope off the scope stack.
name|void
name|ExitScope
parameter_list|()
function_decl|;
comment|/// \brief RAII object used to modify the scope flags for the current scope.
name|class
name|ParseScopeFlags
block|{
name|Scope
modifier|*
name|CurScope
decl_stmt|;
name|unsigned
name|OldFlags
decl_stmt|;
name|ParseScopeFlags
argument_list|(
specifier|const
name|ParseScopeFlags
operator|&
argument_list|)
expr_stmt|;
comment|// do not implement
name|void
name|operator
init|=
operator|(
specifier|const
name|ParseScopeFlags
operator|&
operator|)
decl_stmt|;
comment|// do not implement
name|public
label|:
name|ParseScopeFlags
argument_list|(
argument|Parser *Self
argument_list|,
argument|unsigned ScopeFlags
argument_list|,
argument|bool ManageFlags = true
argument_list|)
empty_stmt|;
operator|~
name|ParseScopeFlags
argument_list|()
expr_stmt|;
block|}
empty_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|// Diagnostic Emission and Error recovery.
name|public
label|:
name|DiagnosticBuilder
name|Diag
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
name|unsigned
name|DiagID
parameter_list|)
function_decl|;
name|DiagnosticBuilder
name|Diag
parameter_list|(
specifier|const
name|Token
modifier|&
name|Tok
parameter_list|,
name|unsigned
name|DiagID
parameter_list|)
function_decl|;
name|private
label|:
name|void
name|SuggestParentheses
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
name|unsigned
name|DK
parameter_list|,
name|SourceRange
name|ParenRange
parameter_list|)
function_decl|;
name|void
name|CheckNestedObjCContexts
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|)
function_decl|;
comment|/// SkipUntil - Read tokens until we get to the specified token, then consume
comment|/// it (unless DontConsume is true).  Because we cannot guarantee that the
comment|/// token will ever occur, this skips to the next token, or to some likely
comment|/// good stopping point.  If StopAtSemi is true, skipping will stop at a ';'
comment|/// character.
comment|///
comment|/// If SkipUntil finds the specified token, it returns true, otherwise it
comment|/// returns false.
name|bool
name|SkipUntil
argument_list|(
name|tok
operator|::
name|TokenKind
name|T
argument_list|,
name|bool
name|StopAtSemi
operator|=
name|true
argument_list|,
name|bool
name|DontConsume
operator|=
name|false
argument_list|,
name|bool
name|StopAtCodeCompletion
operator|=
name|false
argument_list|)
block|{
return|return
name|SkipUntil
argument_list|(
name|llvm
operator|::
name|makeArrayRef
argument_list|(
name|T
argument_list|)
argument_list|,
name|StopAtSemi
argument_list|,
name|DontConsume
argument_list|,
name|StopAtCodeCompletion
argument_list|)
return|;
block|}
name|bool
name|SkipUntil
argument_list|(
name|tok
operator|::
name|TokenKind
name|T1
argument_list|,
name|tok
operator|::
name|TokenKind
name|T2
argument_list|,
name|bool
name|StopAtSemi
operator|=
name|true
argument_list|,
name|bool
name|DontConsume
operator|=
name|false
argument_list|,
name|bool
name|StopAtCodeCompletion
operator|=
name|false
argument_list|)
block|{
name|tok
operator|::
name|TokenKind
name|TokArray
index|[]
operator|=
block|{
name|T1
block|,
name|T2
block|}
expr_stmt|;
return|return
name|SkipUntil
argument_list|(
name|TokArray
argument_list|,
name|StopAtSemi
argument_list|,
name|DontConsume
argument_list|,
name|StopAtCodeCompletion
argument_list|)
return|;
block|}
name|bool
name|SkipUntil
argument_list|(
name|tok
operator|::
name|TokenKind
name|T1
argument_list|,
name|tok
operator|::
name|TokenKind
name|T2
argument_list|,
name|tok
operator|::
name|TokenKind
name|T3
argument_list|,
name|bool
name|StopAtSemi
operator|=
name|true
argument_list|,
name|bool
name|DontConsume
operator|=
name|false
argument_list|,
name|bool
name|StopAtCodeCompletion
operator|=
name|false
argument_list|)
block|{
name|tok
operator|::
name|TokenKind
name|TokArray
index|[]
operator|=
block|{
name|T1
block|,
name|T2
block|,
name|T3
block|}
expr_stmt|;
return|return
name|SkipUntil
argument_list|(
name|TokArray
argument_list|,
name|StopAtSemi
argument_list|,
name|DontConsume
argument_list|,
name|StopAtCodeCompletion
argument_list|)
return|;
block|}
name|bool
name|SkipUntil
argument_list|(
name|ArrayRef
operator|<
name|tok
operator|::
name|TokenKind
operator|>
name|Toks
argument_list|,
name|bool
name|StopAtSemi
operator|=
name|true
argument_list|,
name|bool
name|DontConsume
operator|=
name|false
argument_list|,
name|bool
name|StopAtCodeCompletion
operator|=
name|false
argument_list|)
decl_stmt|;
comment|/// SkipMalformedDecl - Read tokens until we get to some likely good stopping
comment|/// point for skipping past a simple-declaration.
name|void
name|SkipMalformedDecl
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// Lexing and parsing of C++ inline methods.
struct_decl|struct
name|ParsingClass
struct_decl|;
comment|/// [class.mem]p1: "... the class is regarded as complete within
comment|/// - function bodies
comment|/// - default arguments
comment|/// - exception-specifications (TODO: C++0x)
comment|/// - and brace-or-equal-initializers for non-static data members
comment|/// (including such things in nested classes)."
comment|/// LateParsedDeclarations build the tree of those elements so they can
comment|/// be parsed after parsing the top-level class.
name|class
name|LateParsedDeclaration
block|{
name|public
label|:
name|virtual
operator|~
name|LateParsedDeclaration
argument_list|()
expr_stmt|;
name|virtual
name|void
name|ParseLexedMethodDeclarations
parameter_list|()
function_decl|;
name|virtual
name|void
name|ParseLexedMemberInitializers
parameter_list|()
function_decl|;
name|virtual
name|void
name|ParseLexedMethodDefs
parameter_list|()
function_decl|;
name|virtual
name|void
name|ParseLexedAttributes
parameter_list|()
function_decl|;
block|}
empty_stmt|;
comment|/// Inner node of the LateParsedDeclaration tree that parses
comment|/// all its members recursively.
name|class
name|LateParsedClass
range|:
name|public
name|LateParsedDeclaration
block|{
name|public
operator|:
name|LateParsedClass
argument_list|(
name|Parser
operator|*
name|P
argument_list|,
name|ParsingClass
operator|*
name|C
argument_list|)
block|;
name|virtual
operator|~
name|LateParsedClass
argument_list|()
block|;
name|virtual
name|void
name|ParseLexedMethodDeclarations
argument_list|()
block|;
name|virtual
name|void
name|ParseLexedMemberInitializers
argument_list|()
block|;
name|virtual
name|void
name|ParseLexedMethodDefs
argument_list|()
block|;
name|virtual
name|void
name|ParseLexedAttributes
argument_list|()
block|;
name|private
operator|:
name|Parser
operator|*
name|Self
block|;
name|ParsingClass
operator|*
name|Class
block|;   }
decl_stmt|;
comment|/// Contains the lexed tokens of an attribute with arguments that
comment|/// may reference member variables and so need to be parsed at the
comment|/// end of the class declaration after parsing all other member
comment|/// member declarations.
comment|/// FIXME: Perhaps we should change the name of LateParsedDeclaration to
comment|/// LateParsedTokens.
name|struct
name|LateParsedAttribute
range|:
name|public
name|LateParsedDeclaration
block|{
name|Parser
operator|*
name|Self
block|;
name|CachedTokens
name|Toks
block|;
name|IdentifierInfo
operator|&
name|AttrName
block|;
name|SourceLocation
name|AttrNameLoc
block|;
name|SmallVector
operator|<
name|Decl
operator|*
block|,
literal|2
operator|>
name|Decls
block|;
name|explicit
name|LateParsedAttribute
argument_list|(
argument|Parser *P
argument_list|,
argument|IdentifierInfo&Name
argument_list|,
argument|SourceLocation Loc
argument_list|)
operator|:
name|Self
argument_list|(
name|P
argument_list|)
block|,
name|AttrName
argument_list|(
name|Name
argument_list|)
block|,
name|AttrNameLoc
argument_list|(
argument|Loc
argument_list|)
block|{}
name|virtual
name|void
name|ParseLexedAttributes
argument_list|()
block|;
name|void
name|addDecl
argument_list|(
argument|Decl *D
argument_list|)
block|{
name|Decls
operator|.
name|push_back
argument_list|(
name|D
argument_list|)
block|; }
block|}
decl_stmt|;
comment|/// A list of late parsed attributes.  Used by ParseGNUAttributes.
typedef|typedef
name|llvm
operator|::
name|SmallVector
operator|<
name|LateParsedAttribute
operator|*
operator|,
literal|2
operator|>
name|LateParsedAttrList
expr_stmt|;
comment|/// Contains the lexed tokens of a member function definition
comment|/// which needs to be parsed at the end of the class declaration
comment|/// after parsing all other member declarations.
name|struct
name|LexedMethod
range|:
name|public
name|LateParsedDeclaration
block|{
name|Parser
operator|*
name|Self
block|;
name|Decl
operator|*
name|D
block|;
name|CachedTokens
name|Toks
block|;
comment|/// \brief Whether this member function had an associated template
comment|/// scope. When true, D is a template declaration.
comment|/// othewise, it is a member function declaration.
name|bool
name|TemplateScope
block|;
name|explicit
name|LexedMethod
argument_list|(
name|Parser
operator|*
name|P
argument_list|,
name|Decl
operator|*
name|MD
argument_list|)
operator|:
name|Self
argument_list|(
name|P
argument_list|)
block|,
name|D
argument_list|(
name|MD
argument_list|)
block|,
name|TemplateScope
argument_list|(
argument|false
argument_list|)
block|{}
name|virtual
name|void
name|ParseLexedMethodDefs
argument_list|()
block|;   }
decl_stmt|;
comment|/// LateParsedDefaultArgument - Keeps track of a parameter that may
comment|/// have a default argument that cannot be parsed yet because it
comment|/// occurs within a member function declaration inside the class
comment|/// (C++ [class.mem]p2).
struct|struct
name|LateParsedDefaultArgument
block|{
name|explicit
name|LateParsedDefaultArgument
argument_list|(
name|Decl
operator|*
name|P
argument_list|,
name|CachedTokens
operator|*
name|Toks
operator|=
literal|0
argument_list|)
operator|:
name|Param
argument_list|(
name|P
argument_list|)
operator|,
name|Toks
argument_list|(
argument|Toks
argument_list|)
block|{ }
comment|/// Param - The parameter declaration for this parameter.
name|Decl
operator|*
name|Param
expr_stmt|;
comment|/// Toks - The sequence of tokens that comprises the default
comment|/// argument expression, not including the '=' or the terminating
comment|/// ')' or ','. This will be NULL for parameters that have no
comment|/// default argument.
name|CachedTokens
modifier|*
name|Toks
decl_stmt|;
block|}
struct|;
comment|/// LateParsedMethodDeclaration - A method declaration inside a class that
comment|/// contains at least one entity whose parsing needs to be delayed
comment|/// until the class itself is completely-defined, such as a default
comment|/// argument (C++ [class.mem]p2).
name|struct
name|LateParsedMethodDeclaration
range|:
name|public
name|LateParsedDeclaration
block|{
name|explicit
name|LateParsedMethodDeclaration
argument_list|(
name|Parser
operator|*
name|P
argument_list|,
name|Decl
operator|*
name|M
argument_list|)
operator|:
name|Self
argument_list|(
name|P
argument_list|)
block|,
name|Method
argument_list|(
name|M
argument_list|)
block|,
name|TemplateScope
argument_list|(
name|false
argument_list|)
block|,
name|ExceptionSpecTokens
argument_list|(
literal|0
argument_list|)
block|{ }
name|virtual
name|void
name|ParseLexedMethodDeclarations
argument_list|()
block|;
name|Parser
operator|*
name|Self
block|;
comment|/// Method - The method declaration.
name|Decl
operator|*
name|Method
block|;
comment|/// \brief Whether this member function had an associated template
comment|/// scope. When true, D is a template declaration.
comment|/// othewise, it is a member function declaration.
name|bool
name|TemplateScope
block|;
comment|/// DefaultArgs - Contains the parameters of the function and
comment|/// their default arguments. At least one of the parameters will
comment|/// have a default argument, but all of the parameters of the
comment|/// method will be stored so that they can be reintroduced into
comment|/// scope at the appropriate times.
name|SmallVector
operator|<
name|LateParsedDefaultArgument
block|,
literal|8
operator|>
name|DefaultArgs
block|;
comment|/// \brief The set of tokens that make up an exception-specification that
comment|/// has not yet been parsed.
name|CachedTokens
operator|*
name|ExceptionSpecTokens
block|;   }
decl_stmt|;
comment|/// LateParsedMemberInitializer - An initializer for a non-static class data
comment|/// member whose parsing must to be delayed until the class is completely
comment|/// defined (C++11 [class.mem]p2).
name|struct
name|LateParsedMemberInitializer
range|:
name|public
name|LateParsedDeclaration
block|{
name|LateParsedMemberInitializer
argument_list|(
name|Parser
operator|*
name|P
argument_list|,
name|Decl
operator|*
name|FD
argument_list|)
operator|:
name|Self
argument_list|(
name|P
argument_list|)
block|,
name|Field
argument_list|(
argument|FD
argument_list|)
block|{ }
name|virtual
name|void
name|ParseLexedMemberInitializers
argument_list|()
block|;
name|Parser
operator|*
name|Self
block|;
comment|/// Field - The field declaration.
name|Decl
operator|*
name|Field
block|;
comment|/// CachedTokens - The sequence of tokens that comprises the initializer,
comment|/// including any leading '='.
name|CachedTokens
name|Toks
block|;   }
decl_stmt|;
comment|/// LateParsedDeclarationsContainer - During parsing of a top (non-nested)
comment|/// C++ class, its method declarations that contain parts that won't be
comment|/// parsed until after the definition is completed (C++ [class.mem]p2),
comment|/// the method declarations and possibly attached inline definitions
comment|/// will be stored here with the tokens that will be parsed to create those
comment|/// entities.
typedef|typedef
name|SmallVector
operator|<
name|LateParsedDeclaration
operator|*
operator|,
literal|2
operator|>
name|LateParsedDeclarationsContainer
expr_stmt|;
comment|/// \brief Representation of a class that has been parsed, including
comment|/// any member function declarations or definitions that need to be
comment|/// parsed after the corresponding top-level class is complete.
struct|struct
name|ParsingClass
block|{
name|ParsingClass
argument_list|(
argument|Decl *TagOrTemplate
argument_list|,
argument|bool TopLevelClass
argument_list|)
block|:
name|TopLevelClass
argument_list|(
name|TopLevelClass
argument_list|)
operator|,
name|TemplateScope
argument_list|(
name|false
argument_list|)
operator|,
name|TagOrTemplate
argument_list|(
argument|TagOrTemplate
argument_list|)
block|{ }
comment|/// \brief Whether this is a "top-level" class, meaning that it is
comment|/// not nested within another class.
name|bool
name|TopLevelClass
operator|:
literal|1
expr_stmt|;
comment|/// \brief Whether this class had an associated template
comment|/// scope. When true, TagOrTemplate is a template declaration;
comment|/// othewise, it is a tag declaration.
name|bool
name|TemplateScope
range|:
literal|1
decl_stmt|;
comment|/// \brief The class or class template whose definition we are parsing.
name|Decl
modifier|*
name|TagOrTemplate
decl_stmt|;
comment|/// LateParsedDeclarations - Method declarations, inline definitions and
comment|/// nested classes that contain pieces whose parsing will be delayed until
comment|/// the top-level class is fully defined.
name|LateParsedDeclarationsContainer
name|LateParsedDeclarations
decl_stmt|;
block|}
struct|;
comment|/// \brief The stack of classes that is currently being
comment|/// parsed. Nested and local classes will be pushed onto this stack
comment|/// when they are parsed, and removed afterward.
name|std
operator|::
name|stack
operator|<
name|ParsingClass
operator|*
operator|>
name|ClassStack
expr_stmt|;
name|ParsingClass
modifier|&
name|getCurrentClass
parameter_list|()
block|{
name|assert
argument_list|(
operator|!
name|ClassStack
operator|.
name|empty
argument_list|()
operator|&&
literal|"No lexed method stacks!"
argument_list|)
expr_stmt|;
return|return
operator|*
name|ClassStack
operator|.
name|top
argument_list|()
return|;
block|}
comment|/// \brief RAII object used to inform the actions that we're
comment|/// currently parsing a declaration.  This is active when parsing a
comment|/// variable's initializer, but not when parsing the body of a
comment|/// class or function definition.
name|class
name|ParsingDeclRAIIObject
block|{
name|Sema
modifier|&
name|Actions
decl_stmt|;
name|Sema
operator|::
name|ParsingDeclState
name|State
expr_stmt|;
name|bool
name|Popped
decl_stmt|;
name|public
label|:
name|ParsingDeclRAIIObject
argument_list|(
name|Parser
operator|&
name|P
argument_list|)
operator|:
name|Actions
argument_list|(
argument|P.Actions
argument_list|)
block|{
name|push
argument_list|()
block|;     }
name|ParsingDeclRAIIObject
argument_list|(
name|Parser
operator|&
name|P
argument_list|,
name|ParsingDeclRAIIObject
operator|*
name|Other
argument_list|)
operator|:
name|Actions
argument_list|(
argument|P.Actions
argument_list|)
block|{
if|if
condition|(
name|Other
condition|)
name|steal
argument_list|(
operator|*
name|Other
argument_list|)
expr_stmt|;
else|else
name|push
argument_list|()
expr_stmt|;
block|}
comment|/// Creates a RAII object which steals the state from a different
comment|/// object instead of pushing.
name|ParsingDeclRAIIObject
argument_list|(
name|ParsingDeclRAIIObject
operator|&
name|Other
argument_list|)
operator|:
name|Actions
argument_list|(
argument|Other.Actions
argument_list|)
block|{
name|steal
argument_list|(
name|Other
argument_list|)
block|;     }
operator|~
name|ParsingDeclRAIIObject
argument_list|()
block|{
name|abort
argument_list|()
block|;     }
comment|/// Resets the RAII object for a new declaration.
name|void
name|reset
argument_list|()
block|{
name|abort
argument_list|()
block|;
name|push
argument_list|()
block|;     }
comment|/// Signals that the context was completed without an appropriate
comment|/// declaration being parsed.
name|void
name|abort
argument_list|()
block|{
name|pop
argument_list|(
literal|0
argument_list|)
block|;     }
name|void
name|complete
argument_list|(
argument|Decl *D
argument_list|)
block|{
name|assert
argument_list|(
operator|!
name|Popped
operator|&&
literal|"ParsingDeclaration has already been popped!"
argument_list|)
block|;
name|pop
argument_list|(
name|D
argument_list|)
block|;     }
name|private
operator|:
name|void
name|steal
argument_list|(
argument|ParsingDeclRAIIObject&Other
argument_list|)
block|{
name|State
operator|=
name|Other
operator|.
name|State
block|;
name|Popped
operator|=
name|Other
operator|.
name|Popped
block|;
name|Other
operator|.
name|Popped
operator|=
name|true
block|;     }
name|void
name|push
argument_list|()
block|{
name|State
operator|=
name|Actions
operator|.
name|PushParsingDeclaration
argument_list|()
block|;
name|Popped
operator|=
name|false
block|;     }
name|void
name|pop
argument_list|(
argument|Decl *D
argument_list|)
block|{
if|if
condition|(
operator|!
name|Popped
condition|)
block|{
name|Actions
operator|.
name|PopParsingDeclaration
argument_list|(
name|State
argument_list|,
name|D
argument_list|)
expr_stmt|;
name|Popped
operator|=
name|true
expr_stmt|;
block|}
block|}
block|}
empty_stmt|;
comment|/// A class for parsing a DeclSpec.
name|class
name|ParsingDeclSpec
range|:
name|public
name|DeclSpec
block|{
name|ParsingDeclRAIIObject
name|ParsingRAII
block|;
name|public
operator|:
name|ParsingDeclSpec
argument_list|(
name|Parser
operator|&
name|P
argument_list|)
operator|:
name|DeclSpec
argument_list|(
name|P
operator|.
name|AttrFactory
argument_list|)
block|,
name|ParsingRAII
argument_list|(
argument|P
argument_list|)
block|{}
name|ParsingDeclSpec
argument_list|(
name|Parser
operator|&
name|P
argument_list|,
name|ParsingDeclRAIIObject
operator|*
name|RAII
argument_list|)
operator|:
name|DeclSpec
argument_list|(
name|P
operator|.
name|AttrFactory
argument_list|)
block|,
name|ParsingRAII
argument_list|(
argument|P
argument_list|,
argument|RAII
argument_list|)
block|{}
name|void
name|complete
argument_list|(
argument|Decl *D
argument_list|)
block|{
name|ParsingRAII
operator|.
name|complete
argument_list|(
name|D
argument_list|)
block|;     }
name|void
name|abort
argument_list|()
block|{
name|ParsingRAII
operator|.
name|abort
argument_list|()
block|;     }
block|}
decl_stmt|;
comment|/// A class for parsing a declarator.
name|class
name|ParsingDeclarator
range|:
name|public
name|Declarator
block|{
name|ParsingDeclRAIIObject
name|ParsingRAII
block|;
name|public
operator|:
name|ParsingDeclarator
argument_list|(
argument|Parser&P
argument_list|,
argument|const ParsingDeclSpec&DS
argument_list|,
argument|TheContext C
argument_list|)
operator|:
name|Declarator
argument_list|(
name|DS
argument_list|,
name|C
argument_list|)
block|,
name|ParsingRAII
argument_list|(
argument|P
argument_list|)
block|{     }
specifier|const
name|ParsingDeclSpec
operator|&
name|getDeclSpec
argument_list|()
specifier|const
block|{
return|return
name|static_cast
operator|<
specifier|const
name|ParsingDeclSpec
operator|&
operator|>
operator|(
name|Declarator
operator|::
name|getDeclSpec
argument_list|()
operator|)
return|;
block|}
name|ParsingDeclSpec
operator|&
name|getMutableDeclSpec
argument_list|()
specifier|const
block|{
return|return
name|const_cast
operator|<
name|ParsingDeclSpec
operator|&
operator|>
operator|(
name|getDeclSpec
argument_list|()
operator|)
return|;
block|}
name|void
name|clear
argument_list|()
block|{
name|Declarator
operator|::
name|clear
argument_list|()
block|;
name|ParsingRAII
operator|.
name|reset
argument_list|()
block|;     }
name|void
name|complete
argument_list|(
argument|Decl *D
argument_list|)
block|{
name|ParsingRAII
operator|.
name|complete
argument_list|(
name|D
argument_list|)
block|;     }
expr|}
block|;
comment|/// \brief RAII object used to
name|class
name|ParsingClassDefinition
block|{
name|Parser
operator|&
name|P
block|;
name|bool
name|Popped
block|;
name|Sema
operator|::
name|ParsingClassState
name|State
block|;
name|public
operator|:
name|ParsingClassDefinition
argument_list|(
argument|Parser&P
argument_list|,
argument|Decl *TagOrTemplate
argument_list|,
argument|bool TopLevelClass
argument_list|)
operator|:
name|P
argument_list|(
name|P
argument_list|)
block|,
name|Popped
argument_list|(
name|false
argument_list|)
block|,
name|State
argument_list|(
argument|P.PushParsingClass(TagOrTemplate, TopLevelClass)
argument_list|)
block|{     }
comment|/// \brief Pop this class of the stack.
name|void
name|Pop
argument_list|()
block|{
name|assert
argument_list|(
operator|!
name|Popped
operator|&&
literal|"Nested class has already been popped"
argument_list|)
block|;
name|Popped
operator|=
name|true
block|;
name|P
operator|.
name|PopParsingClass
argument_list|(
name|State
argument_list|)
block|;     }
operator|~
name|ParsingClassDefinition
argument_list|()
block|{
if|if
condition|(
operator|!
name|Popped
condition|)
name|P
operator|.
name|PopParsingClass
argument_list|(
name|State
argument_list|)
expr_stmt|;
block|}
expr|}
block|;
comment|/// \brief Contains information about any template-specific
comment|/// information that has been parsed prior to parsing declaration
comment|/// specifiers.
block|struct
name|ParsedTemplateInfo
block|{
name|ParsedTemplateInfo
argument_list|()
operator|:
name|Kind
argument_list|(
name|NonTemplate
argument_list|)
block|,
name|TemplateParams
argument_list|(
literal|0
argument_list|)
block|,
name|TemplateLoc
argument_list|()
block|{ }
name|ParsedTemplateInfo
argument_list|(
argument|TemplateParameterLists *TemplateParams
argument_list|,
argument|bool isSpecialization
argument_list|,
argument|bool lastParameterListWasEmpty = false
argument_list|)
operator|:
name|Kind
argument_list|(
name|isSpecialization
operator|?
name|ExplicitSpecialization
operator|:
name|Template
argument_list|)
block|,
name|TemplateParams
argument_list|(
name|TemplateParams
argument_list|)
block|,
name|LastParameterListWasEmpty
argument_list|(
argument|lastParameterListWasEmpty
argument_list|)
block|{ }
name|explicit
name|ParsedTemplateInfo
argument_list|(
argument|SourceLocation ExternLoc
argument_list|,
argument|SourceLocation TemplateLoc
argument_list|)
operator|:
name|Kind
argument_list|(
name|ExplicitInstantiation
argument_list|)
block|,
name|TemplateParams
argument_list|(
literal|0
argument_list|)
block|,
name|ExternLoc
argument_list|(
name|ExternLoc
argument_list|)
block|,
name|TemplateLoc
argument_list|(
name|TemplateLoc
argument_list|)
block|,
name|LastParameterListWasEmpty
argument_list|(
argument|false
argument_list|)
block|{ }
comment|/// \brief The kind of template we are parsing.
expr|enum
block|{
comment|/// \brief We are not parsing a template at all.
name|NonTemplate
operator|=
literal|0
block|,
comment|/// \brief We are parsing a template declaration.
name|Template
block|,
comment|/// \brief We are parsing an explicit specialization.
name|ExplicitSpecialization
block|,
comment|/// \brief We are parsing an explicit instantiation.
name|ExplicitInstantiation
block|}
name|Kind
block|;
comment|/// \brief The template parameter lists, for template declarations
comment|/// and explicit specializations.
name|TemplateParameterLists
operator|*
name|TemplateParams
block|;
comment|/// \brief The location of the 'extern' keyword, if any, for an explicit
comment|/// instantiation
name|SourceLocation
name|ExternLoc
block|;
comment|/// \brief The location of the 'template' keyword, for an explicit
comment|/// instantiation.
name|SourceLocation
name|TemplateLoc
block|;
comment|/// \brief Whether the last template parameter list was empty.
name|bool
name|LastParameterListWasEmpty
block|;
name|SourceRange
name|getSourceRange
argument_list|()
specifier|const
name|LLVM_READONLY
block|;   }
block|;
comment|/// \brief Contains a late templated function.
comment|/// Will be parsed at the end of the translation unit.
block|struct
name|LateParsedTemplatedFunction
block|{
name|explicit
name|LateParsedTemplatedFunction
argument_list|(
name|Decl
operator|*
name|MD
argument_list|)
operator|:
name|D
argument_list|(
argument|MD
argument_list|)
block|{}
name|CachedTokens
name|Toks
block|;
comment|/// \brief The template function declaration to be late parsed.
name|Decl
operator|*
name|D
block|;   }
block|;
name|void
name|LexTemplateFunctionForLateParsing
argument_list|(
name|CachedTokens
operator|&
name|Toks
argument_list|)
block|;
name|void
name|ParseLateTemplatedFuncDef
argument_list|(
name|LateParsedTemplatedFunction
operator|&
name|LMT
argument_list|)
block|;
typedef|typedef
name|llvm
operator|::
name|DenseMap
operator|<
specifier|const
name|FunctionDecl
operator|*
operator|,
name|LateParsedTemplatedFunction
operator|*
operator|>
name|LateParsedTemplateMapT
expr_stmt|;
name|LateParsedTemplateMapT
name|LateParsedTemplateMap
block|;
specifier|static
name|void
name|LateTemplateParserCallback
argument_list|(
name|void
operator|*
name|P
argument_list|,
specifier|const
name|FunctionDecl
operator|*
name|FD
argument_list|)
block|;
name|void
name|LateTemplateParser
argument_list|(
specifier|const
name|FunctionDecl
operator|*
name|FD
argument_list|)
block|;
name|Sema
operator|::
name|ParsingClassState
name|PushParsingClass
argument_list|(
argument|Decl *TagOrTemplate
argument_list|,
argument|bool TopLevelClass
argument_list|)
block|;
name|void
name|DeallocateParsedClasses
argument_list|(
name|ParsingClass
operator|*
name|Class
argument_list|)
block|;
name|void
name|PopParsingClass
argument_list|(
name|Sema
operator|::
name|ParsingClassState
argument_list|)
block|;
name|Decl
operator|*
name|ParseCXXInlineMethodDef
argument_list|(
argument|AccessSpecifier AS
argument_list|,
argument|AttributeList *AccessAttrs
argument_list|,
argument|ParsingDeclarator&D
argument_list|,
argument|const ParsedTemplateInfo&TemplateInfo
argument_list|,
argument|const VirtSpecifiers& VS
argument_list|,
argument|FunctionDefinitionKind DefinitionKind
argument_list|,
argument|ExprResult& Init
argument_list|)
block|;
name|void
name|ParseCXXNonStaticMemberInitializer
argument_list|(
name|Decl
operator|*
name|VarD
argument_list|)
block|;
name|void
name|ParseLexedAttributes
argument_list|(
name|ParsingClass
operator|&
name|Class
argument_list|)
block|;
name|void
name|ParseLexedAttributeList
argument_list|(
argument|LateParsedAttrList&LAs
argument_list|,
argument|Decl *D
argument_list|,
argument|bool EnterScope
argument_list|,
argument|bool OnDefinition
argument_list|)
block|;
name|void
name|ParseLexedAttribute
argument_list|(
argument|LateParsedAttribute&LA
argument_list|,
argument|bool EnterScope
argument_list|,
argument|bool OnDefinition
argument_list|)
block|;
name|void
name|ParseLexedMethodDeclarations
argument_list|(
name|ParsingClass
operator|&
name|Class
argument_list|)
block|;
name|void
name|ParseLexedMethodDeclaration
argument_list|(
name|LateParsedMethodDeclaration
operator|&
name|LM
argument_list|)
block|;
name|void
name|ParseLexedMethodDefs
argument_list|(
name|ParsingClass
operator|&
name|Class
argument_list|)
block|;
name|void
name|ParseLexedMethodDef
argument_list|(
name|LexedMethod
operator|&
name|LM
argument_list|)
block|;
name|void
name|ParseLexedMemberInitializers
argument_list|(
name|ParsingClass
operator|&
name|Class
argument_list|)
block|;
name|void
name|ParseLexedMemberInitializer
argument_list|(
name|LateParsedMemberInitializer
operator|&
name|MI
argument_list|)
block|;
name|Decl
operator|*
name|ParseLexedObjCMethodDefs
argument_list|(
name|LexedMethod
operator|&
name|LM
argument_list|)
block|;
name|bool
name|ConsumeAndStoreFunctionPrologue
argument_list|(
name|CachedTokens
operator|&
name|Toks
argument_list|)
block|;
name|bool
name|ConsumeAndStoreUntil
argument_list|(
argument|tok::TokenKind T1
argument_list|,
argument|CachedTokens&Toks
argument_list|,
argument|bool StopAtSemi = true
argument_list|,
argument|bool ConsumeFinalToken = true
argument_list|)
block|{
return|return
name|ConsumeAndStoreUntil
argument_list|(
name|T1
argument_list|,
name|T1
argument_list|,
name|Toks
argument_list|,
name|StopAtSemi
argument_list|,
name|ConsumeFinalToken
argument_list|)
return|;
block|}
name|bool
name|ConsumeAndStoreUntil
argument_list|(
argument|tok::TokenKind T1
argument_list|,
argument|tok::TokenKind T2
argument_list|,
argument|CachedTokens&Toks
argument_list|,
argument|bool StopAtSemi = true
argument_list|,
argument|bool ConsumeFinalToken = true
argument_list|)
block|;
comment|//===--------------------------------------------------------------------===//
comment|// C99 6.9: External Definitions.
block|struct
name|ParsedAttributesWithRange
operator|:
name|ParsedAttributes
block|{
name|ParsedAttributesWithRange
argument_list|(
name|AttributeFactory
operator|&
name|factory
argument_list|)
operator|:
name|ParsedAttributes
argument_list|(
argument|factory
argument_list|)
block|{}
name|SourceRange
name|Range
block|;   }
block|;
name|DeclGroupPtrTy
name|ParseExternalDeclaration
argument_list|(
name|ParsedAttributesWithRange
operator|&
name|attrs
argument_list|,
name|ParsingDeclSpec
operator|*
name|DS
operator|=
literal|0
argument_list|)
block|;
name|bool
name|isDeclarationAfterDeclarator
argument_list|()
block|;
name|bool
name|isStartOfFunctionDefinition
argument_list|(
specifier|const
name|ParsingDeclarator
operator|&
name|Declarator
argument_list|)
block|;
name|DeclGroupPtrTy
name|ParseDeclarationOrFunctionDefinition
argument_list|(
argument|ParsedAttributes&attrs
argument_list|,
argument|AccessSpecifier AS = AS_none
argument_list|)
block|;
name|DeclGroupPtrTy
name|ParseDeclarationOrFunctionDefinition
argument_list|(
argument|ParsingDeclSpec&DS
argument_list|,
argument|AccessSpecifier AS = AS_none
argument_list|)
block|;
name|Decl
operator|*
name|ParseFunctionDefinition
argument_list|(
name|ParsingDeclarator
operator|&
name|D
argument_list|,
specifier|const
name|ParsedTemplateInfo
operator|&
name|TemplateInfo
operator|=
name|ParsedTemplateInfo
argument_list|()
argument_list|,
name|LateParsedAttrList
operator|*
name|LateParsedAttrs
operator|=
literal|0
argument_list|)
block|;
name|void
name|ParseKNRParamDeclarations
argument_list|(
name|Declarator
operator|&
name|D
argument_list|)
block|;
comment|// EndLoc, if non-NULL, is filled with the location of the last token of
comment|// the simple-asm.
name|ExprResult
name|ParseSimpleAsm
argument_list|(
name|SourceLocation
operator|*
name|EndLoc
operator|=
literal|0
argument_list|)
block|;
name|ExprResult
name|ParseAsmStringLiteral
argument_list|()
block|;
comment|// Objective-C External Declarations
name|DeclGroupPtrTy
name|ParseObjCAtDirectives
argument_list|()
block|;
name|DeclGroupPtrTy
name|ParseObjCAtClassDeclaration
argument_list|(
argument|SourceLocation atLoc
argument_list|)
block|;
name|Decl
operator|*
name|ParseObjCAtInterfaceDeclaration
argument_list|(
argument|SourceLocation AtLoc
argument_list|,
argument|ParsedAttributes&prefixAttrs
argument_list|)
block|;
name|void
name|ParseObjCClassInstanceVariables
argument_list|(
argument|Decl *interfaceDecl
argument_list|,
argument|tok::ObjCKeywordKind visibility
argument_list|,
argument|SourceLocation atLoc
argument_list|)
block|;
name|bool
name|ParseObjCProtocolReferences
argument_list|(
argument|SmallVectorImpl<Decl *>&P
argument_list|,
argument|SmallVectorImpl<SourceLocation>&PLocs
argument_list|,
argument|bool WarnOnDeclarations
argument_list|,
argument|SourceLocation&LAngleLoc
argument_list|,
argument|SourceLocation&EndProtoLoc
argument_list|)
block|;
name|bool
name|ParseObjCProtocolQualifiers
argument_list|(
name|DeclSpec
operator|&
name|DS
argument_list|)
block|;
name|void
name|ParseObjCInterfaceDeclList
argument_list|(
argument|tok::ObjCKeywordKind contextKey
argument_list|,
argument|Decl *CDecl
argument_list|)
block|;
name|DeclGroupPtrTy
name|ParseObjCAtProtocolDeclaration
argument_list|(
argument|SourceLocation atLoc
argument_list|,
argument|ParsedAttributes&prefixAttrs
argument_list|)
block|;    struct
name|ObjCImplParsingDataRAII
block|{
name|Parser
operator|&
name|P
block|;
name|Decl
operator|*
name|Dcl
block|;
typedef|typedef
name|SmallVector
operator|<
name|LexedMethod
operator|*
operator|,
literal|8
operator|>
name|LateParsedObjCMethodContainer
expr_stmt|;
name|LateParsedObjCMethodContainer
name|LateParsedObjCMethods
block|;
name|ObjCImplParsingDataRAII
argument_list|(
name|Parser
operator|&
name|parser
argument_list|,
name|Decl
operator|*
name|D
argument_list|)
operator|:
name|P
argument_list|(
name|parser
argument_list|)
block|,
name|Dcl
argument_list|(
argument|D
argument_list|)
block|{
name|P
operator|.
name|CurParsedObjCImpl
operator|=
name|this
block|;
name|Finished
operator|=
name|false
block|;     }
operator|~
name|ObjCImplParsingDataRAII
argument_list|()
block|;
name|void
name|finish
argument_list|(
argument|SourceRange AtEnd
argument_list|)
block|;
name|bool
name|isFinished
argument_list|()
specifier|const
block|{
return|return
name|Finished
return|;
block|}
name|private
operator|:
name|bool
name|Finished
block|;   }
decl_stmt|;
name|ObjCImplParsingDataRAII
modifier|*
name|CurParsedObjCImpl
decl_stmt|;
name|DeclGroupPtrTy
name|ParseObjCAtImplementationDeclaration
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|)
function_decl|;
name|DeclGroupPtrTy
name|ParseObjCAtEndDeclaration
parameter_list|(
name|SourceRange
name|atEnd
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseObjCAtAliasDeclaration
parameter_list|(
name|SourceLocation
name|atLoc
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseObjCPropertySynthesize
parameter_list|(
name|SourceLocation
name|atLoc
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseObjCPropertyDynamic
parameter_list|(
name|SourceLocation
name|atLoc
parameter_list|)
function_decl|;
name|IdentifierInfo
modifier|*
name|ParseObjCSelectorPiece
parameter_list|(
name|SourceLocation
modifier|&
name|MethodLocation
parameter_list|)
function_decl|;
comment|// Definitions for Objective-c context sensitive keywords recognition.
enum|enum
name|ObjCTypeQual
block|{
name|objc_in
init|=
literal|0
block|,
name|objc_out
block|,
name|objc_inout
block|,
name|objc_oneway
block|,
name|objc_bycopy
block|,
name|objc_byref
block|,
name|objc_NumQuals
block|}
enum|;
name|IdentifierInfo
modifier|*
name|ObjCTypeQuals
index|[
name|objc_NumQuals
index|]
decl_stmt|;
name|bool
name|isTokIdentifier_in
argument_list|()
specifier|const
expr_stmt|;
name|ParsedType
name|ParseObjCTypeName
argument_list|(
name|ObjCDeclSpec
operator|&
name|DS
argument_list|,
name|Declarator
operator|::
name|TheContext
name|Ctx
argument_list|,
name|ParsedAttributes
operator|*
name|ParamAttrs
argument_list|)
decl_stmt|;
name|void
name|ParseObjCMethodRequirement
parameter_list|()
function_decl|;
name|Decl
modifier|*
name|ParseObjCMethodPrototype
argument_list|(
name|tok
operator|::
name|ObjCKeywordKind
name|MethodImplKind
operator|=
name|tok
operator|::
name|objc_not_keyword
argument_list|,
name|bool
name|MethodDefinition
operator|=
name|true
argument_list|)
decl_stmt|;
name|Decl
modifier|*
name|ParseObjCMethodDecl
argument_list|(
name|SourceLocation
name|mLoc
argument_list|,
name|tok
operator|::
name|TokenKind
name|mType
argument_list|,
name|tok
operator|::
name|ObjCKeywordKind
name|MethodImplKind
operator|=
name|tok
operator|::
name|objc_not_keyword
argument_list|,
name|bool
name|MethodDefinition
operator|=
name|true
argument_list|)
decl_stmt|;
name|void
name|ParseObjCPropertyAttribute
parameter_list|(
name|ObjCDeclSpec
modifier|&
name|DS
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseObjCMethodDefinition
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C99 6.5: Expressions.
comment|/// TypeCastState - State whether an expression is or may be a type cast.
enum|enum
name|TypeCastState
block|{
name|NotTypeCast
init|=
literal|0
block|,
name|MaybeTypeCast
block|,
name|IsTypeCast
block|}
enum|;
name|ExprResult
name|ParseExpression
parameter_list|(
name|TypeCastState
name|isTypeCast
init|=
name|NotTypeCast
parameter_list|)
function_decl|;
name|ExprResult
name|ParseConstantExpression
parameter_list|(
name|TypeCastState
name|isTypeCast
init|=
name|NotTypeCast
parameter_list|)
function_decl|;
comment|// Expr that doesn't include commas.
name|ExprResult
name|ParseAssignmentExpression
parameter_list|(
name|TypeCastState
name|isTypeCast
init|=
name|NotTypeCast
parameter_list|)
function_decl|;
name|ExprResult
name|ParseExpressionWithLeadingAt
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|)
function_decl|;
name|ExprResult
name|ParseExpressionWithLeadingExtension
parameter_list|(
name|SourceLocation
name|ExtLoc
parameter_list|)
function_decl|;
name|ExprResult
name|ParseRHSOfBinaryExpression
argument_list|(
name|ExprResult
name|LHS
argument_list|,
name|prec
operator|::
name|Level
name|MinPrec
argument_list|)
decl_stmt|;
name|ExprResult
name|ParseCastExpression
parameter_list|(
name|bool
name|isUnaryExpression
parameter_list|,
name|bool
name|isAddressOfOperand
parameter_list|,
name|bool
modifier|&
name|NotCastExpr
parameter_list|,
name|TypeCastState
name|isTypeCast
parameter_list|)
function_decl|;
name|ExprResult
name|ParseCastExpression
parameter_list|(
name|bool
name|isUnaryExpression
parameter_list|,
name|bool
name|isAddressOfOperand
init|=
name|false
parameter_list|,
name|TypeCastState
name|isTypeCast
init|=
name|NotTypeCast
parameter_list|)
function_decl|;
comment|/// Returns true if the next token would start a postfix-expression
comment|/// suffix.
name|bool
name|isPostfixExpressionSuffixStart
parameter_list|()
block|{
name|tok
operator|::
name|TokenKind
name|K
operator|=
name|Tok
operator|.
name|getKind
argument_list|()
expr_stmt|;
return|return
operator|(
name|K
operator|==
name|tok
operator|::
name|l_square
operator|||
name|K
operator|==
name|tok
operator|::
name|l_paren
operator|||
name|K
operator|==
name|tok
operator|::
name|period
operator|||
name|K
operator|==
name|tok
operator|::
name|arrow
operator|||
name|K
operator|==
name|tok
operator|::
name|plusplus
operator|||
name|K
operator|==
name|tok
operator|::
name|minusminus
operator|)
return|;
block|}
name|ExprResult
name|ParsePostfixExpressionSuffix
parameter_list|(
name|ExprResult
name|LHS
parameter_list|)
function_decl|;
name|ExprResult
name|ParseUnaryExprOrTypeTraitExpression
parameter_list|()
function_decl|;
name|ExprResult
name|ParseBuiltinPrimaryExpression
parameter_list|()
function_decl|;
name|ExprResult
name|ParseExprAfterUnaryExprOrTypeTrait
parameter_list|(
specifier|const
name|Token
modifier|&
name|OpTok
parameter_list|,
name|bool
modifier|&
name|isCastExpr
parameter_list|,
name|ParsedType
modifier|&
name|CastTy
parameter_list|,
name|SourceRange
modifier|&
name|CastRange
parameter_list|)
function_decl|;
typedef|typedef
name|SmallVector
operator|<
name|Expr
operator|*
operator|,
literal|20
operator|>
name|ExprListTy
expr_stmt|;
typedef|typedef
name|SmallVector
operator|<
name|SourceLocation
operator|,
literal|20
operator|>
name|CommaLocsTy
expr_stmt|;
comment|/// ParseExpressionList - Used for C/C++ (argument-)expression-list.
name|bool
name|ParseExpressionList
argument_list|(
name|SmallVectorImpl
operator|<
name|Expr
operator|*
operator|>
operator|&
name|Exprs
argument_list|,
name|SmallVectorImpl
operator|<
name|SourceLocation
operator|>
operator|&
name|CommaLocs
argument_list|,
name|void
argument_list|(
name|Sema
operator|::
operator|*
name|Completer
argument_list|)
argument_list|(
name|Scope
operator|*
name|S
argument_list|,
name|Expr
operator|*
name|Data
argument_list|,
name|llvm
operator|::
name|ArrayRef
operator|<
name|Expr
operator|*
operator|>
name|Args
argument_list|)
operator|=
literal|0
argument_list|,
name|Expr
operator|*
name|Data
operator|=
literal|0
argument_list|)
decl_stmt|;
comment|/// ParenParseOption - Control what ParseParenExpression will parse.
enum|enum
name|ParenParseOption
block|{
name|SimpleExpr
block|,
comment|// Only parse '(' expression ')'
name|CompoundStmt
block|,
comment|// Also allow '(' compound-statement ')'
name|CompoundLiteral
block|,
comment|// Also allow '(' type-name ')' '{' ... '}'
name|CastExpr
comment|// Also allow '(' type-name ')'<anything>
block|}
enum|;
name|ExprResult
name|ParseParenExpression
parameter_list|(
name|ParenParseOption
modifier|&
name|ExprType
parameter_list|,
name|bool
name|stopIfCastExpr
parameter_list|,
name|bool
name|isTypeCast
parameter_list|,
name|ParsedType
modifier|&
name|CastTy
parameter_list|,
name|SourceLocation
modifier|&
name|RParenLoc
parameter_list|)
function_decl|;
name|ExprResult
name|ParseCXXAmbiguousParenExpression
parameter_list|(
name|ParenParseOption
modifier|&
name|ExprType
parameter_list|,
name|ParsedType
modifier|&
name|CastTy
parameter_list|,
name|BalancedDelimiterTracker
modifier|&
name|Tracker
parameter_list|)
function_decl|;
name|ExprResult
name|ParseCompoundLiteralExpression
parameter_list|(
name|ParsedType
name|Ty
parameter_list|,
name|SourceLocation
name|LParenLoc
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
function_decl|;
name|ExprResult
name|ParseStringLiteralExpression
parameter_list|(
name|bool
name|AllowUserDefinedLiteral
init|=
name|false
parameter_list|)
function_decl|;
name|ExprResult
name|ParseGenericSelectionExpression
parameter_list|()
function_decl|;
name|ExprResult
name|ParseObjCBoolLiteral
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ Expressions
name|ExprResult
name|ParseCXXIdExpression
parameter_list|(
name|bool
name|isAddressOfOperand
init|=
name|false
parameter_list|)
function_decl|;
name|void
name|CheckForTemplateAndDigraph
parameter_list|(
name|Token
modifier|&
name|Next
parameter_list|,
name|ParsedType
name|ObjectTypePtr
parameter_list|,
name|bool
name|EnteringContext
parameter_list|,
name|IdentifierInfo
modifier|&
name|II
parameter_list|,
name|CXXScopeSpec
modifier|&
name|SS
parameter_list|)
function_decl|;
name|bool
name|ParseOptionalCXXScopeSpecifier
parameter_list|(
name|CXXScopeSpec
modifier|&
name|SS
parameter_list|,
name|ParsedType
name|ObjectType
parameter_list|,
name|bool
name|EnteringContext
parameter_list|,
name|bool
modifier|*
name|MayBePseudoDestructor
init|=
literal|0
parameter_list|,
name|bool
name|IsTypename
init|=
name|false
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++0x 5.1.2: Lambda expressions
comment|// [...] () -> type {...}
name|ExprResult
name|ParseLambdaExpression
parameter_list|()
function_decl|;
name|ExprResult
name|TryParseLambdaExpression
parameter_list|()
function_decl|;
name|llvm
operator|::
name|Optional
operator|<
name|unsigned
operator|>
name|ParseLambdaIntroducer
argument_list|(
name|LambdaIntroducer
operator|&
name|Intro
argument_list|)
expr_stmt|;
name|bool
name|TryParseLambdaIntroducer
parameter_list|(
name|LambdaIntroducer
modifier|&
name|Intro
parameter_list|)
function_decl|;
name|ExprResult
name|ParseLambdaExpressionAfterIntroducer
parameter_list|(
name|LambdaIntroducer
modifier|&
name|Intro
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 5.2p1: C++ Casts
name|ExprResult
name|ParseCXXCasts
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 5.2p1: C++ Type Identification
name|ExprResult
name|ParseCXXTypeid
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|//  C++ : Microsoft __uuidof Expression
name|ExprResult
name|ParseCXXUuidof
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 5.2.4: C++ Pseudo-Destructor Expressions
name|ExprResult
name|ParseCXXPseudoDestructor
argument_list|(
name|ExprArg
name|Base
argument_list|,
name|SourceLocation
name|OpLoc
argument_list|,
name|tok
operator|::
name|TokenKind
name|OpKind
argument_list|,
name|CXXScopeSpec
operator|&
name|SS
argument_list|,
name|ParsedType
name|ObjectType
argument_list|)
decl_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 9.3.2: C++ 'this' pointer
name|ExprResult
name|ParseCXXThis
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 15: C++ Throw Expression
name|ExprResult
name|ParseThrowExpression
parameter_list|()
function_decl|;
name|ExceptionSpecificationType
name|tryParseExceptionSpecification
argument_list|(
name|SourceRange
operator|&
name|SpecificationRange
argument_list|,
name|SmallVectorImpl
operator|<
name|ParsedType
operator|>
operator|&
name|DynamicExceptions
argument_list|,
name|SmallVectorImpl
operator|<
name|SourceRange
operator|>
operator|&
name|DynamicExceptionRanges
argument_list|,
name|ExprResult
operator|&
name|NoexceptExpr
argument_list|)
decl_stmt|;
comment|// EndLoc is filled with the location of the last token of the specification.
name|ExceptionSpecificationType
name|ParseDynamicExceptionSpecification
argument_list|(
name|SourceRange
operator|&
name|SpecificationRange
argument_list|,
name|SmallVectorImpl
operator|<
name|ParsedType
operator|>
operator|&
name|Exceptions
argument_list|,
name|SmallVectorImpl
operator|<
name|SourceRange
operator|>
operator|&
name|Ranges
argument_list|)
decl_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|// C++0x 8: Function declaration trailing-return-type
name|TypeResult
name|ParseTrailingReturnType
parameter_list|(
name|SourceRange
modifier|&
name|Range
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 2.13.5: C++ Boolean Literals
name|ExprResult
name|ParseCXXBoolLiteral
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 5.2.3: Explicit type conversion (functional notation)
name|ExprResult
name|ParseCXXTypeConstructExpression
parameter_list|(
specifier|const
name|DeclSpec
modifier|&
name|DS
parameter_list|)
function_decl|;
name|bool
name|isCXXSimpleTypeSpecifier
argument_list|()
specifier|const
expr_stmt|;
comment|/// ParseCXXSimpleTypeSpecifier - [C++ 7.1.5.2] Simple type specifiers.
comment|/// This should only be called when the current token is known to be part of
comment|/// simple-type-specifier.
name|void
name|ParseCXXSimpleTypeSpecifier
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|)
function_decl|;
name|bool
name|ParseCXXTypeSpecifierSeq
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 5.3.4 and 5.3.5: C++ new and delete
name|bool
name|ParseExpressionListOrTypeId
argument_list|(
name|SmallVectorImpl
operator|<
name|Expr
operator|*
operator|>
operator|&
name|Exprs
argument_list|,
name|Declarator
operator|&
name|D
argument_list|)
decl_stmt|;
name|void
name|ParseDirectNewDeclarator
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|)
function_decl|;
name|ExprResult
name|ParseCXXNewExpression
parameter_list|(
name|bool
name|UseGlobal
parameter_list|,
name|SourceLocation
name|Start
parameter_list|)
function_decl|;
name|ExprResult
name|ParseCXXDeleteExpression
parameter_list|(
name|bool
name|UseGlobal
parameter_list|,
name|SourceLocation
name|Start
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ if/switch/while condition expression.
name|bool
name|ParseCXXCondition
parameter_list|(
name|ExprResult
modifier|&
name|ExprResult
parameter_list|,
name|Decl
modifier|*
modifier|&
name|DeclResult
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
name|bool
name|ConvertToBoolean
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ types
comment|//===--------------------------------------------------------------------===//
comment|// C99 6.7.8: Initialization.
comment|/// ParseInitializer
comment|///       initializer: [C99 6.7.8]
comment|///         assignment-expression
comment|///         '{' ...
name|ExprResult
name|ParseInitializer
parameter_list|()
block|{
if|if
condition|(
name|Tok
operator|.
name|isNot
argument_list|(
name|tok
operator|::
name|l_brace
argument_list|)
condition|)
return|return
name|ParseAssignmentExpression
argument_list|()
return|;
return|return
name|ParseBraceInitializer
argument_list|()
return|;
block|}
name|bool
name|MayBeDesignationStart
parameter_list|()
function_decl|;
name|ExprResult
name|ParseBraceInitializer
parameter_list|()
function_decl|;
name|ExprResult
name|ParseInitializerWithPotentialDesignator
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// clang Expressions
name|ExprResult
name|ParseBlockLiteralExpression
parameter_list|()
function_decl|;
comment|// ^{...}
comment|//===--------------------------------------------------------------------===//
comment|// Objective-C Expressions
name|ExprResult
name|ParseObjCAtExpression
parameter_list|(
name|SourceLocation
name|AtLocation
parameter_list|)
function_decl|;
name|ExprResult
name|ParseObjCStringLiteral
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|)
function_decl|;
name|ExprResult
name|ParseObjCCharacterLiteral
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|)
function_decl|;
name|ExprResult
name|ParseObjCNumericLiteral
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|)
function_decl|;
name|ExprResult
name|ParseObjCBooleanLiteral
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|,
name|bool
name|ArgValue
parameter_list|)
function_decl|;
name|ExprResult
name|ParseObjCArrayLiteral
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|)
function_decl|;
name|ExprResult
name|ParseObjCDictionaryLiteral
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|)
function_decl|;
name|ExprResult
name|ParseObjCEncodeExpression
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|)
function_decl|;
name|ExprResult
name|ParseObjCSelectorExpression
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|)
function_decl|;
name|ExprResult
name|ParseObjCProtocolExpression
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|)
function_decl|;
name|bool
name|isSimpleObjCMessageExpression
parameter_list|()
function_decl|;
name|ExprResult
name|ParseObjCMessageExpression
parameter_list|()
function_decl|;
name|ExprResult
name|ParseObjCMessageExpressionBody
parameter_list|(
name|SourceLocation
name|LBracloc
parameter_list|,
name|SourceLocation
name|SuperLoc
parameter_list|,
name|ParsedType
name|ReceiverType
parameter_list|,
name|ExprArg
name|ReceiverExpr
parameter_list|)
function_decl|;
name|ExprResult
name|ParseAssignmentExprWithObjCMessageExprStart
parameter_list|(
name|SourceLocation
name|LBracloc
parameter_list|,
name|SourceLocation
name|SuperLoc
parameter_list|,
name|ParsedType
name|ReceiverType
parameter_list|,
name|ExprArg
name|ReceiverExpr
parameter_list|)
function_decl|;
name|bool
name|ParseObjCXXMessageReceiver
parameter_list|(
name|bool
modifier|&
name|IsExpr
parameter_list|,
name|void
modifier|*
modifier|&
name|TypeOrExpr
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C99 6.8: Statements and Blocks.
name|StmtResult
name|ParseStatement
parameter_list|(
name|SourceLocation
modifier|*
name|TrailingElseLoc
init|=
literal|0
parameter_list|)
block|{
name|StmtVector
name|Stmts
argument_list|(
name|Actions
argument_list|)
decl_stmt|;
return|return
name|ParseStatementOrDeclaration
argument_list|(
name|Stmts
argument_list|,
name|true
argument_list|,
name|TrailingElseLoc
argument_list|)
return|;
block|}
name|StmtResult
name|ParseStatementOrDeclaration
parameter_list|(
name|StmtVector
modifier|&
name|Stmts
parameter_list|,
name|bool
name|OnlyStatement
parameter_list|,
name|SourceLocation
modifier|*
name|TrailingElseLoc
init|=
literal|0
parameter_list|)
function_decl|;
name|StmtResult
name|ParseStatementOrDeclarationAfterAttributes
parameter_list|(
name|StmtVector
modifier|&
name|Stmts
parameter_list|,
name|bool
name|OnlyStatement
parameter_list|,
name|SourceLocation
modifier|*
name|TrailingElseLoc
parameter_list|,
name|ParsedAttributesWithRange
modifier|&
name|Attrs
parameter_list|)
function_decl|;
name|StmtResult
name|ParseExprStatement
parameter_list|()
function_decl|;
name|StmtResult
name|ParseLabeledStatement
parameter_list|(
name|ParsedAttributesWithRange
modifier|&
name|attrs
parameter_list|)
function_decl|;
name|StmtResult
name|ParseCaseStatement
parameter_list|(
name|bool
name|MissingCase
init|=
name|false
parameter_list|,
name|ExprResult
name|Expr
init|=
name|ExprResult
argument_list|()
parameter_list|)
function_decl|;
name|StmtResult
name|ParseDefaultStatement
parameter_list|()
function_decl|;
name|StmtResult
name|ParseCompoundStatement
parameter_list|(
name|bool
name|isStmtExpr
init|=
name|false
parameter_list|)
function_decl|;
name|StmtResult
name|ParseCompoundStatement
parameter_list|(
name|bool
name|isStmtExpr
parameter_list|,
name|unsigned
name|ScopeFlags
parameter_list|)
function_decl|;
name|StmtResult
name|ParseCompoundStatementBody
parameter_list|(
name|bool
name|isStmtExpr
init|=
name|false
parameter_list|)
function_decl|;
name|bool
name|ParseParenExprOrCondition
parameter_list|(
name|ExprResult
modifier|&
name|ExprResult
parameter_list|,
name|Decl
modifier|*
modifier|&
name|DeclResult
parameter_list|,
name|SourceLocation
name|Loc
parameter_list|,
name|bool
name|ConvertToBoolean
parameter_list|)
function_decl|;
name|StmtResult
name|ParseIfStatement
parameter_list|(
name|SourceLocation
modifier|*
name|TrailingElseLoc
parameter_list|)
function_decl|;
name|StmtResult
name|ParseSwitchStatement
parameter_list|(
name|SourceLocation
modifier|*
name|TrailingElseLoc
parameter_list|)
function_decl|;
name|StmtResult
name|ParseWhileStatement
parameter_list|(
name|SourceLocation
modifier|*
name|TrailingElseLoc
parameter_list|)
function_decl|;
name|StmtResult
name|ParseDoStatement
parameter_list|()
function_decl|;
name|StmtResult
name|ParseForStatement
parameter_list|(
name|SourceLocation
modifier|*
name|TrailingElseLoc
parameter_list|)
function_decl|;
name|StmtResult
name|ParseGotoStatement
parameter_list|()
function_decl|;
name|StmtResult
name|ParseContinueStatement
parameter_list|()
function_decl|;
name|StmtResult
name|ParseBreakStatement
parameter_list|()
function_decl|;
name|StmtResult
name|ParseReturnStatement
parameter_list|()
function_decl|;
name|StmtResult
name|ParseAsmStatement
parameter_list|(
name|bool
modifier|&
name|msAsm
parameter_list|)
function_decl|;
name|StmtResult
name|ParseMicrosoftAsmStatement
parameter_list|(
name|SourceLocation
name|AsmLoc
parameter_list|)
function_decl|;
comment|/// \brief Describes the behavior that should be taken for an __if_exists
comment|/// block.
enum|enum
name|IfExistsBehavior
block|{
comment|/// \brief Parse the block; this code is always used.
name|IEB_Parse
block|,
comment|/// \brief Skip the block entirely; this code is never used.
name|IEB_Skip
block|,
comment|/// \brief Parse the block as a dependent block, which may be used in
comment|/// some template instantiations but not others.
name|IEB_Dependent
block|}
enum|;
comment|/// \brief Describes the condition of a Microsoft __if_exists or
comment|/// __if_not_exists block.
struct|struct
name|IfExistsCondition
block|{
comment|/// \brief The location of the initial keyword.
name|SourceLocation
name|KeywordLoc
decl_stmt|;
comment|/// \brief Whether this is an __if_exists block (rather than an
comment|/// __if_not_exists block).
name|bool
name|IsIfExists
decl_stmt|;
comment|/// \brief Nested-name-specifier preceding the name.
name|CXXScopeSpec
name|SS
decl_stmt|;
comment|/// \brief The name we're looking for.
name|UnqualifiedId
name|Name
decl_stmt|;
comment|/// \brief The behavior of this __if_exists or __if_not_exists block
comment|/// should.
name|IfExistsBehavior
name|Behavior
decl_stmt|;
block|}
struct|;
name|bool
name|ParseMicrosoftIfExistsCondition
parameter_list|(
name|IfExistsCondition
modifier|&
name|Result
parameter_list|)
function_decl|;
name|void
name|ParseMicrosoftIfExistsStatement
parameter_list|(
name|StmtVector
modifier|&
name|Stmts
parameter_list|)
function_decl|;
name|void
name|ParseMicrosoftIfExistsExternalDeclaration
parameter_list|()
function_decl|;
name|void
name|ParseMicrosoftIfExistsClassDeclaration
argument_list|(
name|DeclSpec
operator|::
name|TST
name|TagType
argument_list|,
name|AccessSpecifier
operator|&
name|CurAS
argument_list|)
decl_stmt|;
name|bool
name|ParseMicrosoftIfExistsBraceInitializer
parameter_list|(
name|ExprVector
modifier|&
name|InitExprs
parameter_list|,
name|bool
modifier|&
name|InitExprsOk
parameter_list|)
function_decl|;
name|bool
name|ParseAsmOperandsOpt
argument_list|(
name|SmallVectorImpl
operator|<
name|IdentifierInfo
operator|*
operator|>
operator|&
name|Names
argument_list|,
name|SmallVectorImpl
operator|<
name|Expr
operator|*
operator|>
operator|&
name|Constraints
argument_list|,
name|SmallVectorImpl
operator|<
name|Expr
operator|*
operator|>
operator|&
name|Exprs
argument_list|)
decl_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 6: Statements and Blocks
name|StmtResult
name|ParseCXXTryBlock
parameter_list|()
function_decl|;
name|StmtResult
name|ParseCXXTryBlockCommon
parameter_list|(
name|SourceLocation
name|TryLoc
parameter_list|)
function_decl|;
name|StmtResult
name|ParseCXXCatchBlock
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// MS: SEH Statements and Blocks
name|StmtResult
name|ParseSEHTryBlock
parameter_list|()
function_decl|;
name|StmtResult
name|ParseSEHTryBlockCommon
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|)
function_decl|;
name|StmtResult
name|ParseSEHExceptBlock
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|)
function_decl|;
name|StmtResult
name|ParseSEHFinallyBlock
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// Objective-C Statements
name|StmtResult
name|ParseObjCAtStatement
parameter_list|(
name|SourceLocation
name|atLoc
parameter_list|)
function_decl|;
name|StmtResult
name|ParseObjCTryStmt
parameter_list|(
name|SourceLocation
name|atLoc
parameter_list|)
function_decl|;
name|StmtResult
name|ParseObjCThrowStmt
parameter_list|(
name|SourceLocation
name|atLoc
parameter_list|)
function_decl|;
name|StmtResult
name|ParseObjCSynchronizedStmt
parameter_list|(
name|SourceLocation
name|atLoc
parameter_list|)
function_decl|;
name|StmtResult
name|ParseObjCAutoreleasePoolStmt
parameter_list|(
name|SourceLocation
name|atLoc
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C99 6.7: Declarations.
comment|/// A context for parsing declaration specifiers.  TODO: flesh this
comment|/// out, there are other significant restrictions on specifiers than
comment|/// would be best implemented in the parser.
enum|enum
name|DeclSpecContext
block|{
name|DSC_normal
block|,
comment|// normal context
name|DSC_class
block|,
comment|// class context, enables 'friend'
name|DSC_type_specifier
block|,
comment|// C++ type-specifier-seq
name|DSC_trailing
block|,
comment|// C++11 trailing-type-specifier in a trailing return type
name|DSC_top_level
comment|// top-level/namespace declaration context
block|}
enum|;
comment|/// Information on a C++0x for-range-initializer found while parsing a
comment|/// declaration which turns out to be a for-range-declaration.
struct|struct
name|ForRangeInit
block|{
name|SourceLocation
name|ColonLoc
decl_stmt|;
name|ExprResult
name|RangeExpr
decl_stmt|;
name|bool
name|ParsedForRangeDecl
parameter_list|()
block|{
return|return
operator|!
name|ColonLoc
operator|.
name|isInvalid
argument_list|()
return|;
block|}
block|}
struct|;
name|DeclGroupPtrTy
name|ParseDeclaration
parameter_list|(
name|StmtVector
modifier|&
name|Stmts
parameter_list|,
name|unsigned
name|Context
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|,
name|ParsedAttributesWithRange
modifier|&
name|attrs
parameter_list|)
function_decl|;
name|DeclGroupPtrTy
name|ParseSimpleDeclaration
parameter_list|(
name|StmtVector
modifier|&
name|Stmts
parameter_list|,
name|unsigned
name|Context
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|,
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|,
name|bool
name|RequireSemi
parameter_list|,
name|ForRangeInit
modifier|*
name|FRI
init|=
literal|0
parameter_list|)
function_decl|;
name|bool
name|MightBeDeclarator
parameter_list|(
name|unsigned
name|Context
parameter_list|)
function_decl|;
name|DeclGroupPtrTy
name|ParseDeclGroup
parameter_list|(
name|ParsingDeclSpec
modifier|&
name|DS
parameter_list|,
name|unsigned
name|Context
parameter_list|,
name|bool
name|AllowFunctionDefinitions
parameter_list|,
name|SourceLocation
modifier|*
name|DeclEnd
init|=
literal|0
parameter_list|,
name|ForRangeInit
modifier|*
name|FRI
init|=
literal|0
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseDeclarationAfterDeclarator
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|,
specifier|const
name|ParsedTemplateInfo
modifier|&
name|TemplateInfo
init|=
name|ParsedTemplateInfo
argument_list|()
parameter_list|)
function_decl|;
name|bool
name|ParseAsmAttributesAfterDeclarator
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseDeclarationAfterDeclaratorAndAttributes
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|,
specifier|const
name|ParsedTemplateInfo
modifier|&
name|TemplateInfo
init|=
name|ParsedTemplateInfo
argument_list|()
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseFunctionStatementBody
parameter_list|(
name|Decl
modifier|*
name|Decl
parameter_list|,
name|ParseScope
modifier|&
name|BodyScope
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseFunctionTryBlock
parameter_list|(
name|Decl
modifier|*
name|Decl
parameter_list|,
name|ParseScope
modifier|&
name|BodyScope
parameter_list|)
function_decl|;
comment|/// \brief When in code-completion, skip parsing of the function/method body
comment|/// unless the body contains the code-completion point.
comment|///
comment|/// \returns true if the function body was skipped.
name|bool
name|trySkippingFunctionBody
parameter_list|()
function_decl|;
name|bool
name|ParseImplicitInt
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|,
name|CXXScopeSpec
modifier|*
name|SS
parameter_list|,
specifier|const
name|ParsedTemplateInfo
modifier|&
name|TemplateInfo
parameter_list|,
name|AccessSpecifier
name|AS
parameter_list|,
name|DeclSpecContext
name|DSC
parameter_list|)
function_decl|;
name|DeclSpecContext
name|getDeclSpecContextFromDeclaratorContext
parameter_list|(
name|unsigned
name|Context
parameter_list|)
function_decl|;
name|void
name|ParseDeclarationSpecifiers
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|,
specifier|const
name|ParsedTemplateInfo
modifier|&
name|TemplateInfo
init|=
name|ParsedTemplateInfo
argument_list|()
parameter_list|,
name|AccessSpecifier
name|AS
init|=
name|AS_none
parameter_list|,
name|DeclSpecContext
name|DSC
init|=
name|DSC_normal
parameter_list|,
name|LateParsedAttrList
modifier|*
name|LateAttrs
init|=
literal|0
parameter_list|)
function_decl|;
name|void
name|ParseSpecifierQualifierList
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|,
name|AccessSpecifier
name|AS
init|=
name|AS_none
parameter_list|,
name|DeclSpecContext
name|DSC
init|=
name|DSC_normal
parameter_list|)
function_decl|;
name|void
name|ParseObjCTypeQualifierList
argument_list|(
name|ObjCDeclSpec
operator|&
name|DS
argument_list|,
name|Declarator
operator|::
name|TheContext
name|Context
argument_list|)
decl_stmt|;
name|void
name|ParseEnumSpecifier
parameter_list|(
name|SourceLocation
name|TagLoc
parameter_list|,
name|DeclSpec
modifier|&
name|DS
parameter_list|,
specifier|const
name|ParsedTemplateInfo
modifier|&
name|TemplateInfo
parameter_list|,
name|AccessSpecifier
name|AS
parameter_list|,
name|DeclSpecContext
name|DSC
parameter_list|)
function_decl|;
name|void
name|ParseEnumBody
parameter_list|(
name|SourceLocation
name|StartLoc
parameter_list|,
name|Decl
modifier|*
name|TagDecl
parameter_list|)
function_decl|;
name|void
name|ParseStructUnionBody
parameter_list|(
name|SourceLocation
name|StartLoc
parameter_list|,
name|unsigned
name|TagType
parameter_list|,
name|Decl
modifier|*
name|TagDecl
parameter_list|)
function_decl|;
struct|struct
name|FieldCallback
block|{
name|virtual
name|Decl
modifier|*
name|invoke
parameter_list|(
name|FieldDeclarator
modifier|&
name|Field
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
operator|~
name|FieldCallback
argument_list|()
block|{}
name|private
operator|:
name|virtual
name|void
name|_anchor
argument_list|()
expr_stmt|;
block|}
struct|;
struct_decl|struct
name|ObjCPropertyCallback
struct_decl|;
name|void
name|ParseStructDeclaration
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|,
name|FieldCallback
modifier|&
name|Callback
parameter_list|)
function_decl|;
name|bool
name|isDeclarationSpecifier
parameter_list|(
name|bool
name|DisambiguatingWithExpression
init|=
name|false
parameter_list|)
function_decl|;
name|bool
name|isTypeSpecifierQualifier
parameter_list|()
function_decl|;
name|bool
name|isTypeQualifier
argument_list|()
specifier|const
expr_stmt|;
comment|/// isKnownToBeTypeSpecifier - Return true if we know that the specified token
comment|/// is definitely a type-specifier.  Return false if it isn't part of a type
comment|/// specifier or if we're not sure.
name|bool
name|isKnownToBeTypeSpecifier
argument_list|(
specifier|const
name|Token
operator|&
name|Tok
argument_list|)
decl|const
decl_stmt|;
comment|/// isDeclarationStatement - Disambiguates between a declaration or an
comment|/// expression statement, when parsing function bodies.
comment|/// Returns true for declaration, false for expression.
name|bool
name|isDeclarationStatement
parameter_list|()
block|{
if|if
condition|(
name|getLangOpts
argument_list|()
operator|.
name|CPlusPlus
condition|)
return|return
name|isCXXDeclarationStatement
argument_list|()
return|;
return|return
name|isDeclarationSpecifier
argument_list|(
name|true
argument_list|)
return|;
block|}
comment|/// isForInitDeclaration - Disambiguates between a declaration or an
comment|/// expression in the context of the C 'clause-1' or the C++
comment|// 'for-init-statement' part of a 'for' statement.
comment|/// Returns true for declaration, false for expression.
name|bool
name|isForInitDeclaration
parameter_list|()
block|{
if|if
condition|(
name|getLangOpts
argument_list|()
operator|.
name|CPlusPlus
condition|)
return|return
name|isCXXSimpleDeclaration
argument_list|(
comment|/*AllowForRangeDecl=*/
name|true
argument_list|)
return|;
return|return
name|isDeclarationSpecifier
argument_list|(
name|true
argument_list|)
return|;
block|}
comment|/// \brief Determine whether we are currently at the start of an Objective-C
comment|/// class message that appears to be missing the open bracket '['.
name|bool
name|isStartOfObjCClassMessageMissingOpenBracket
parameter_list|()
function_decl|;
comment|/// \brief Starting with a scope specifier, identifier, or
comment|/// template-id that refers to the current class, determine whether
comment|/// this is a constructor declarator.
name|bool
name|isConstructorDeclarator
parameter_list|()
function_decl|;
comment|/// \brief Specifies the context in which type-id/expression
comment|/// disambiguation will occur.
enum|enum
name|TentativeCXXTypeIdContext
block|{
name|TypeIdInParens
block|,
name|TypeIdAsTemplateArgument
block|}
enum|;
comment|/// isTypeIdInParens - Assumes that a '(' was parsed and now we want to know
comment|/// whether the parens contain an expression or a type-id.
comment|/// Returns true for a type-id and false for an expression.
name|bool
name|isTypeIdInParens
parameter_list|(
name|bool
modifier|&
name|isAmbiguous
parameter_list|)
block|{
if|if
condition|(
name|getLangOpts
argument_list|()
operator|.
name|CPlusPlus
condition|)
return|return
name|isCXXTypeId
argument_list|(
name|TypeIdInParens
argument_list|,
name|isAmbiguous
argument_list|)
return|;
name|isAmbiguous
operator|=
name|false
expr_stmt|;
return|return
name|isTypeSpecifierQualifier
argument_list|()
return|;
block|}
name|bool
name|isTypeIdInParens
parameter_list|()
block|{
name|bool
name|isAmbiguous
decl_stmt|;
return|return
name|isTypeIdInParens
argument_list|(
name|isAmbiguous
argument_list|)
return|;
block|}
comment|/// isCXXDeclarationStatement - C++-specialized function that disambiguates
comment|/// between a declaration or an expression statement, when parsing function
comment|/// bodies. Returns true for declaration, false for expression.
name|bool
name|isCXXDeclarationStatement
parameter_list|()
function_decl|;
comment|/// isCXXSimpleDeclaration - C++-specialized function that disambiguates
comment|/// between a simple-declaration or an expression-statement.
comment|/// If during the disambiguation process a parsing error is encountered,
comment|/// the function returns true to let the declaration parsing code handle it.
comment|/// Returns false if the statement is disambiguated as expression.
name|bool
name|isCXXSimpleDeclaration
parameter_list|(
name|bool
name|AllowForRangeDecl
parameter_list|)
function_decl|;
comment|/// isCXXFunctionDeclarator - Disambiguates between a function declarator or
comment|/// a constructor-style initializer, when parsing declaration statements.
comment|/// Returns true for function declarator and false for constructor-style
comment|/// initializer. If 'warnIfAmbiguous' is true a warning will be emitted to
comment|/// indicate that the parens were disambiguated as function declarator.
comment|/// If during the disambiguation process a parsing error is encountered,
comment|/// the function returns true to let the declaration parsing code handle it.
name|bool
name|isCXXFunctionDeclarator
parameter_list|(
name|bool
name|warnIfAmbiguous
parameter_list|)
function_decl|;
comment|/// isCXXConditionDeclaration - Disambiguates between a declaration or an
comment|/// expression for a condition of a if/switch/while/for statement.
comment|/// If during the disambiguation process a parsing error is encountered,
comment|/// the function returns true to let the declaration parsing code handle it.
name|bool
name|isCXXConditionDeclaration
parameter_list|()
function_decl|;
name|bool
name|isCXXTypeId
parameter_list|(
name|TentativeCXXTypeIdContext
name|Context
parameter_list|,
name|bool
modifier|&
name|isAmbiguous
parameter_list|)
function_decl|;
name|bool
name|isCXXTypeId
parameter_list|(
name|TentativeCXXTypeIdContext
name|Context
parameter_list|)
block|{
name|bool
name|isAmbiguous
decl_stmt|;
return|return
name|isCXXTypeId
argument_list|(
name|Context
argument_list|,
name|isAmbiguous
argument_list|)
return|;
block|}
comment|/// TPResult - Used as the result value for functions whose purpose is to
comment|/// disambiguate C++ constructs by "tentatively parsing" them.
comment|/// This is a class instead of a simple enum because the implicit enum-to-bool
comment|/// conversions may cause subtle bugs.
name|class
name|TPResult
block|{
enum|enum
name|Result
block|{
name|TPR_true
block|,
name|TPR_false
block|,
name|TPR_ambiguous
block|,
name|TPR_error
block|}
enum|;
name|Result
name|Res
decl_stmt|;
name|TPResult
argument_list|(
argument|Result result
argument_list|)
block|:
name|Res
argument_list|(
argument|result
argument_list|)
block|{}
name|public
label|:
specifier|static
name|TPResult
name|True
parameter_list|()
block|{
return|return
name|TPR_true
return|;
block|}
specifier|static
name|TPResult
name|False
parameter_list|()
block|{
return|return
name|TPR_false
return|;
block|}
specifier|static
name|TPResult
name|Ambiguous
parameter_list|()
block|{
return|return
name|TPR_ambiguous
return|;
block|}
specifier|static
name|TPResult
name|Error
parameter_list|()
block|{
return|return
name|TPR_error
return|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|TPResult
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|Res
operator|==
name|RHS
operator|.
name|Res
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|TPResult
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|Res
operator|!=
name|RHS
operator|.
name|Res
return|;
block|}
block|}
empty_stmt|;
comment|/// \brief Based only on the given token kind, determine whether we know that
comment|/// we're at the start of an expression or a type-specifier-seq (which may
comment|/// be an expression, in C++).
comment|///
comment|/// This routine does not attempt to resolve any of the trick cases, e.g.,
comment|/// those involving lookup of identifiers.
comment|///
comment|/// \returns \c TPR_true if this token starts an expression, \c TPR_false if
comment|/// this token starts a type-specifier-seq, or \c TPR_ambiguous if it cannot
comment|/// tell.
name|TPResult
name|isExpressionOrTypeSpecifierSimple
argument_list|(
name|tok
operator|::
name|TokenKind
name|Kind
argument_list|)
decl_stmt|;
comment|/// isCXXDeclarationSpecifier - Returns TPResult::True() if it is a
comment|/// declaration specifier, TPResult::False() if it is not,
comment|/// TPResult::Ambiguous() if it could be either a decl-specifier or a
comment|/// function-style cast, and TPResult::Error() if a parsing error was
comment|/// encountered. If it could be a braced C++11 function-style cast, returns
comment|/// BracedCastResult.
comment|/// Doesn't consume tokens.
name|TPResult
name|isCXXDeclarationSpecifier
parameter_list|(
name|TPResult
name|BracedCastResult
init|=
name|TPResult
operator|::
name|False
argument_list|()
parameter_list|)
function_decl|;
comment|// "Tentative parsing" functions, used for disambiguation. If a parsing error
comment|// is encountered they will return TPResult::Error().
comment|// Returning TPResult::True()/False() indicates that the ambiguity was
comment|// resolved and tentative parsing may stop. TPResult::Ambiguous() indicates
comment|// that more tentative parsing is necessary for disambiguation.
comment|// They all consume tokens, so backtracking should be used after calling them.
name|TPResult
name|TryParseDeclarationSpecifier
parameter_list|()
function_decl|;
name|TPResult
name|TryParseSimpleDeclaration
parameter_list|(
name|bool
name|AllowForRangeDecl
parameter_list|)
function_decl|;
name|TPResult
name|TryParseTypeofSpecifier
parameter_list|()
function_decl|;
name|TPResult
name|TryParseProtocolQualifiers
parameter_list|()
function_decl|;
name|TPResult
name|TryParseInitDeclaratorList
parameter_list|()
function_decl|;
name|TPResult
name|TryParseDeclarator
parameter_list|(
name|bool
name|mayBeAbstract
parameter_list|,
name|bool
name|mayHaveIdentifier
init|=
name|true
parameter_list|)
function_decl|;
name|TPResult
name|TryParseParameterDeclarationClause
parameter_list|()
function_decl|;
name|TPResult
name|TryParseFunctionDeclarator
parameter_list|()
function_decl|;
name|TPResult
name|TryParseBracketDeclarator
parameter_list|()
function_decl|;
name|TypeResult
name|ParseTypeName
argument_list|(
name|SourceRange
operator|*
name|Range
operator|=
literal|0
argument_list|,
name|Declarator
operator|::
name|TheContext
name|Context
operator|=
name|Declarator
operator|::
name|TypeNameContext
argument_list|,
name|AccessSpecifier
name|AS
operator|=
name|AS_none
argument_list|,
name|Decl
operator|*
operator|*
name|OwnedType
operator|=
literal|0
argument_list|)
decl_stmt|;
name|void
name|ParseBlockId
parameter_list|()
function_decl|;
comment|// Check for the start of a C++11 attribute-specifier-seq in a context where
comment|// an attribute is not allowed.
name|bool
name|CheckProhibitedCXX11Attribute
parameter_list|()
block|{
name|assert
argument_list|(
name|Tok
operator|.
name|is
argument_list|(
name|tok
operator|::
name|l_square
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getLangOpts
argument_list|()
operator|.
name|CPlusPlus0x
operator|||
name|NextToken
argument_list|()
operator|.
name|isNot
argument_list|(
name|tok
operator|::
name|l_square
argument_list|)
condition|)
return|return
name|false
return|;
return|return
name|DiagnoseProhibitedCXX11Attribute
argument_list|()
return|;
block|}
name|bool
name|DiagnoseProhibitedCXX11Attribute
parameter_list|()
function_decl|;
name|void
name|ProhibitAttributes
parameter_list|(
name|ParsedAttributesWithRange
modifier|&
name|attrs
parameter_list|)
block|{
if|if
condition|(
operator|!
name|attrs
operator|.
name|Range
operator|.
name|isValid
argument_list|()
condition|)
return|return;
name|DiagnoseProhibitedAttributes
argument_list|(
name|attrs
argument_list|)
expr_stmt|;
name|attrs
operator|.
name|clear
argument_list|()
expr_stmt|;
block|}
name|void
name|DiagnoseProhibitedAttributes
parameter_list|(
name|ParsedAttributesWithRange
modifier|&
name|attrs
parameter_list|)
function_decl|;
name|void
name|MaybeParseGNUAttributes
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|,
name|LateParsedAttrList
modifier|*
name|LateAttrs
init|=
literal|0
parameter_list|)
block|{
if|if
condition|(
name|Tok
operator|.
name|is
argument_list|(
name|tok
operator|::
name|kw___attribute
argument_list|)
condition|)
block|{
name|ParsedAttributes
name|attrs
argument_list|(
name|AttrFactory
argument_list|)
decl_stmt|;
name|SourceLocation
name|endLoc
decl_stmt|;
name|ParseGNUAttributes
argument_list|(
name|attrs
argument_list|,
operator|&
name|endLoc
argument_list|,
name|LateAttrs
argument_list|)
expr_stmt|;
name|D
operator|.
name|takeAttributes
argument_list|(
name|attrs
argument_list|,
name|endLoc
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|MaybeParseGNUAttributes
parameter_list|(
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|,
name|SourceLocation
modifier|*
name|endLoc
init|=
literal|0
parameter_list|,
name|LateParsedAttrList
modifier|*
name|LateAttrs
init|=
literal|0
parameter_list|)
block|{
if|if
condition|(
name|Tok
operator|.
name|is
argument_list|(
name|tok
operator|::
name|kw___attribute
argument_list|)
condition|)
name|ParseGNUAttributes
argument_list|(
name|attrs
argument_list|,
name|endLoc
argument_list|,
name|LateAttrs
argument_list|)
expr_stmt|;
block|}
name|void
name|ParseGNUAttributes
parameter_list|(
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|,
name|SourceLocation
modifier|*
name|endLoc
init|=
literal|0
parameter_list|,
name|LateParsedAttrList
modifier|*
name|LateAttrs
init|=
literal|0
parameter_list|)
function_decl|;
name|void
name|ParseGNUAttributeArgs
parameter_list|(
name|IdentifierInfo
modifier|*
name|AttrName
parameter_list|,
name|SourceLocation
name|AttrNameLoc
parameter_list|,
name|ParsedAttributes
modifier|&
name|Attrs
parameter_list|,
name|SourceLocation
modifier|*
name|EndLoc
parameter_list|)
function_decl|;
name|void
name|MaybeParseCXX0XAttributes
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|)
block|{
if|if
condition|(
name|getLangOpts
argument_list|()
operator|.
name|CPlusPlus0x
operator|&&
name|isCXX11AttributeSpecifier
argument_list|()
condition|)
block|{
name|ParsedAttributesWithRange
name|attrs
argument_list|(
name|AttrFactory
argument_list|)
decl_stmt|;
name|SourceLocation
name|endLoc
decl_stmt|;
name|ParseCXX11Attributes
argument_list|(
name|attrs
argument_list|,
operator|&
name|endLoc
argument_list|)
expr_stmt|;
name|D
operator|.
name|takeAttributes
argument_list|(
name|attrs
argument_list|,
name|endLoc
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|MaybeParseCXX0XAttributes
parameter_list|(
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|,
name|SourceLocation
modifier|*
name|endLoc
init|=
literal|0
parameter_list|)
block|{
if|if
condition|(
name|getLangOpts
argument_list|()
operator|.
name|CPlusPlus0x
operator|&&
name|isCXX11AttributeSpecifier
argument_list|()
condition|)
block|{
name|ParsedAttributesWithRange
name|attrsWithRange
argument_list|(
name|AttrFactory
argument_list|)
decl_stmt|;
name|ParseCXX11Attributes
argument_list|(
name|attrsWithRange
argument_list|,
name|endLoc
argument_list|)
expr_stmt|;
name|attrs
operator|.
name|takeAllFrom
argument_list|(
name|attrsWithRange
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|MaybeParseCXX0XAttributes
parameter_list|(
name|ParsedAttributesWithRange
modifier|&
name|attrs
parameter_list|,
name|SourceLocation
modifier|*
name|endLoc
init|=
literal|0
parameter_list|,
name|bool
name|OuterMightBeMessageSend
init|=
name|false
parameter_list|)
block|{
if|if
condition|(
name|getLangOpts
argument_list|()
operator|.
name|CPlusPlus0x
operator|&&
name|isCXX11AttributeSpecifier
argument_list|(
name|false
argument_list|,
name|OuterMightBeMessageSend
argument_list|)
condition|)
name|ParseCXX11Attributes
argument_list|(
name|attrs
argument_list|,
name|endLoc
argument_list|)
expr_stmt|;
block|}
name|void
name|ParseCXX11AttributeSpecifier
parameter_list|(
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|,
name|SourceLocation
modifier|*
name|EndLoc
init|=
literal|0
parameter_list|)
function_decl|;
name|void
name|ParseCXX11Attributes
parameter_list|(
name|ParsedAttributesWithRange
modifier|&
name|attrs
parameter_list|,
name|SourceLocation
modifier|*
name|EndLoc
init|=
literal|0
parameter_list|)
function_decl|;
name|IdentifierInfo
modifier|*
name|TryParseCXX11AttributeIdentifier
parameter_list|(
name|SourceLocation
modifier|&
name|Loc
parameter_list|)
function_decl|;
name|void
name|MaybeParseMicrosoftAttributes
parameter_list|(
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|,
name|SourceLocation
modifier|*
name|endLoc
init|=
literal|0
parameter_list|)
block|{
if|if
condition|(
name|getLangOpts
argument_list|()
operator|.
name|MicrosoftExt
operator|&&
name|Tok
operator|.
name|is
argument_list|(
name|tok
operator|::
name|l_square
argument_list|)
condition|)
name|ParseMicrosoftAttributes
argument_list|(
name|attrs
argument_list|,
name|endLoc
argument_list|)
expr_stmt|;
block|}
name|void
name|ParseMicrosoftAttributes
parameter_list|(
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|,
name|SourceLocation
modifier|*
name|endLoc
init|=
literal|0
parameter_list|)
function_decl|;
name|void
name|ParseMicrosoftDeclSpec
parameter_list|(
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|)
function_decl|;
name|void
name|ParseMicrosoftTypeAttributes
parameter_list|(
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|)
function_decl|;
name|void
name|ParseBorlandTypeAttributes
parameter_list|(
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|)
function_decl|;
name|void
name|ParseOpenCLAttributes
parameter_list|(
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|)
function_decl|;
name|void
name|ParseOpenCLQualifiers
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|)
function_decl|;
name|VersionTuple
name|ParseVersionTuple
parameter_list|(
name|SourceRange
modifier|&
name|Range
parameter_list|)
function_decl|;
name|void
name|ParseAvailabilityAttribute
parameter_list|(
name|IdentifierInfo
modifier|&
name|Availability
parameter_list|,
name|SourceLocation
name|AvailabilityLoc
parameter_list|,
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|,
name|SourceLocation
modifier|*
name|endLoc
parameter_list|)
function_decl|;
name|bool
name|IsThreadSafetyAttribute
argument_list|(
name|llvm
operator|::
name|StringRef
name|AttrName
argument_list|)
decl_stmt|;
name|void
name|ParseThreadSafetyAttribute
parameter_list|(
name|IdentifierInfo
modifier|&
name|AttrName
parameter_list|,
name|SourceLocation
name|AttrNameLoc
parameter_list|,
name|ParsedAttributes
modifier|&
name|Attrs
parameter_list|,
name|SourceLocation
modifier|*
name|EndLoc
parameter_list|)
function_decl|;
name|void
name|ParseTypeofSpecifier
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|)
function_decl|;
name|SourceLocation
name|ParseDecltypeSpecifier
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|)
function_decl|;
name|void
name|AnnotateExistingDecltypeSpecifier
parameter_list|(
specifier|const
name|DeclSpec
modifier|&
name|DS
parameter_list|,
name|SourceLocation
name|StartLoc
parameter_list|,
name|SourceLocation
name|EndLoc
parameter_list|)
function_decl|;
name|void
name|ParseUnderlyingTypeSpecifier
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|)
function_decl|;
name|void
name|ParseAtomicSpecifier
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|)
function_decl|;
name|ExprResult
name|ParseAlignArgument
parameter_list|(
name|SourceLocation
name|Start
parameter_list|,
name|SourceLocation
modifier|&
name|EllipsisLoc
parameter_list|)
function_decl|;
name|void
name|ParseAlignmentSpecifier
parameter_list|(
name|ParsedAttributes
modifier|&
name|Attrs
parameter_list|,
name|SourceLocation
modifier|*
name|endLoc
init|=
literal|0
parameter_list|)
function_decl|;
name|VirtSpecifiers
operator|::
name|Specifier
name|isCXX0XVirtSpecifier
argument_list|(
argument|const Token&Tok
argument_list|)
specifier|const
expr_stmt|;
name|VirtSpecifiers
operator|::
name|Specifier
name|isCXX0XVirtSpecifier
argument_list|()
specifier|const
block|{
return|return
name|isCXX0XVirtSpecifier
argument_list|(
name|Tok
argument_list|)
return|;
block|}
name|void
name|ParseOptionalCXX0XVirtSpecifierSeq
parameter_list|(
name|VirtSpecifiers
modifier|&
name|VS
parameter_list|)
function_decl|;
name|bool
name|isCXX0XFinalKeyword
parameter_list|()
function|const;
comment|/// DeclaratorScopeObj - RAII object used in Parser::ParseDirectDeclarator to
comment|/// enter a new C++ declarator scope and exit it when the function is
comment|/// finished.
name|class
name|DeclaratorScopeObj
block|{
name|Parser
modifier|&
name|P
decl_stmt|;
name|CXXScopeSpec
modifier|&
name|SS
decl_stmt|;
name|bool
name|EnteredScope
decl_stmt|;
name|bool
name|CreatedScope
decl_stmt|;
name|public
label|:
name|DeclaratorScopeObj
argument_list|(
name|Parser
operator|&
name|p
argument_list|,
name|CXXScopeSpec
operator|&
name|ss
argument_list|)
operator|:
name|P
argument_list|(
name|p
argument_list|)
operator|,
name|SS
argument_list|(
name|ss
argument_list|)
operator|,
name|EnteredScope
argument_list|(
name|false
argument_list|)
operator|,
name|CreatedScope
argument_list|(
argument|false
argument_list|)
block|{}
name|void
name|EnterDeclaratorScope
argument_list|()
block|{
name|assert
argument_list|(
operator|!
name|EnteredScope
operator|&&
literal|"Already entered the scope!"
argument_list|)
block|;
name|assert
argument_list|(
name|SS
operator|.
name|isSet
argument_list|()
operator|&&
literal|"C++ scope was not set!"
argument_list|)
block|;
name|CreatedScope
operator|=
name|true
block|;
name|P
operator|.
name|EnterScope
argument_list|(
literal|0
argument_list|)
block|;
comment|// Not a decl scope.
if|if
condition|(
operator|!
name|P
operator|.
name|Actions
operator|.
name|ActOnCXXEnterDeclaratorScope
argument_list|(
name|P
operator|.
name|getCurScope
argument_list|()
argument_list|,
name|SS
argument_list|)
condition|)
name|EnteredScope
operator|=
name|true
expr_stmt|;
block|}
operator|~
name|DeclaratorScopeObj
argument_list|()
block|{
if|if
condition|(
name|EnteredScope
condition|)
block|{
name|assert
argument_list|(
name|SS
operator|.
name|isSet
argument_list|()
operator|&&
literal|"C++ scope was cleared ?"
argument_list|)
expr_stmt|;
name|P
operator|.
name|Actions
operator|.
name|ActOnCXXExitDeclaratorScope
argument_list|(
name|P
operator|.
name|getCurScope
argument_list|()
argument_list|,
name|SS
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|CreatedScope
condition|)
name|P
operator|.
name|ExitScope
argument_list|()
expr_stmt|;
block|}
block|}
empty_stmt|;
comment|/// ParseDeclarator - Parse and verify a newly-initialized declarator.
name|void
name|ParseDeclarator
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|)
function_decl|;
comment|/// A function that parses a variant of direct-declarator.
typedef|typedef
name|void
argument_list|(
name|Parser
operator|::
operator|*
name|DirectDeclParseFunction
argument_list|)
argument_list|(
name|Declarator
operator|&
argument_list|)
expr_stmt|;
name|void
name|ParseDeclaratorInternal
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|,
name|DirectDeclParseFunction
name|DirectDeclParser
parameter_list|)
function_decl|;
name|void
name|ParseTypeQualifierListOpt
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|,
name|bool
name|GNUAttributesAllowed
init|=
name|true
parameter_list|,
name|bool
name|CXX0XAttributesAllowed
init|=
name|true
parameter_list|)
function_decl|;
name|void
name|ParseDirectDeclarator
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|)
function_decl|;
name|void
name|ParseParenDeclarator
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|)
function_decl|;
name|void
name|ParseFunctionDeclarator
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|,
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|,
name|BalancedDelimiterTracker
modifier|&
name|Tracker
parameter_list|,
name|bool
name|RequiresArg
init|=
name|false
parameter_list|)
function_decl|;
name|bool
name|isFunctionDeclaratorIdentifierList
parameter_list|()
function_decl|;
name|void
name|ParseFunctionDeclaratorIdentifierList
argument_list|(
name|Declarator
operator|&
name|D
argument_list|,
name|SmallVector
operator|<
name|DeclaratorChunk
operator|::
name|ParamInfo
argument_list|,
literal|16
operator|>
operator|&
name|ParamInfo
argument_list|)
decl_stmt|;
name|void
name|ParseParameterDeclarationClause
argument_list|(
name|Declarator
operator|&
name|D
argument_list|,
name|ParsedAttributes
operator|&
name|attrs
argument_list|,
name|SmallVector
operator|<
name|DeclaratorChunk
operator|::
name|ParamInfo
argument_list|,
literal|16
operator|>
operator|&
name|ParamInfo
argument_list|,
name|SourceLocation
operator|&
name|EllipsisLoc
argument_list|)
decl_stmt|;
name|void
name|ParseBracketDeclarator
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 7: Declarations [dcl.dcl]
comment|/// The kind of attribute specifier we have found.
enum|enum
name|CXX11AttributeKind
block|{
comment|/// This is not an attribute specifier.
name|CAK_NotAttributeSpecifier
block|,
comment|/// This should be treated as an attribute-specifier.
name|CAK_AttributeSpecifier
block|,
comment|/// The next tokens are '[[', but this is not an attribute-specifier. This
comment|/// is ill-formed by C++11 [dcl.attr.grammar]p6.
name|CAK_InvalidAttributeSpecifier
block|}
enum|;
name|CXX11AttributeKind
name|isCXX11AttributeSpecifier
parameter_list|(
name|bool
name|Disambiguate
init|=
name|false
parameter_list|,
name|bool
name|OuterMightBeMessageSend
init|=
name|false
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseNamespace
parameter_list|(
name|unsigned
name|Context
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|,
name|SourceLocation
name|InlineLoc
init|=
name|SourceLocation
argument_list|()
parameter_list|)
function_decl|;
name|void
name|ParseInnerNamespace
argument_list|(
name|std
operator|::
name|vector
operator|<
name|SourceLocation
operator|>
operator|&
name|IdentLoc
argument_list|,
name|std
operator|::
name|vector
operator|<
name|IdentifierInfo
operator|*
operator|>
operator|&
name|Ident
argument_list|,
name|std
operator|::
name|vector
operator|<
name|SourceLocation
operator|>
operator|&
name|NamespaceLoc
argument_list|,
name|unsigned
name|int
name|index
argument_list|,
name|SourceLocation
operator|&
name|InlineLoc
argument_list|,
name|ParsedAttributes
operator|&
name|attrs
argument_list|,
name|BalancedDelimiterTracker
operator|&
name|Tracker
argument_list|)
decl_stmt|;
name|Decl
modifier|*
name|ParseLinkage
parameter_list|(
name|ParsingDeclSpec
modifier|&
name|DS
parameter_list|,
name|unsigned
name|Context
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseUsingDirectiveOrDeclaration
parameter_list|(
name|unsigned
name|Context
parameter_list|,
specifier|const
name|ParsedTemplateInfo
modifier|&
name|TemplateInfo
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|,
name|ParsedAttributesWithRange
modifier|&
name|attrs
parameter_list|,
name|Decl
modifier|*
modifier|*
name|OwnedType
init|=
literal|0
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseUsingDirective
parameter_list|(
name|unsigned
name|Context
parameter_list|,
name|SourceLocation
name|UsingLoc
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|,
name|ParsedAttributes
modifier|&
name|attrs
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseUsingDeclaration
parameter_list|(
name|unsigned
name|Context
parameter_list|,
specifier|const
name|ParsedTemplateInfo
modifier|&
name|TemplateInfo
parameter_list|,
name|SourceLocation
name|UsingLoc
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|,
name|AccessSpecifier
name|AS
init|=
name|AS_none
parameter_list|,
name|Decl
modifier|*
modifier|*
name|OwnedType
init|=
literal|0
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseStaticAssertDeclaration
parameter_list|(
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseNamespaceAlias
parameter_list|(
name|SourceLocation
name|NamespaceLoc
parameter_list|,
name|SourceLocation
name|AliasLoc
parameter_list|,
name|IdentifierInfo
modifier|*
name|Alias
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 9: classes [class] and C structs/unions.
name|void
name|ParseClassSpecifier
argument_list|(
name|tok
operator|::
name|TokenKind
name|TagTokKind
argument_list|,
name|SourceLocation
name|TagLoc
argument_list|,
name|DeclSpec
operator|&
name|DS
argument_list|,
specifier|const
name|ParsedTemplateInfo
operator|&
name|TemplateInfo
argument_list|,
name|AccessSpecifier
name|AS
argument_list|,
name|bool
name|EnteringContext
argument_list|,
name|DeclSpecContext
name|DSC
argument_list|)
decl_stmt|;
name|void
name|ParseCXXMemberSpecification
parameter_list|(
name|SourceLocation
name|StartLoc
parameter_list|,
name|unsigned
name|TagType
parameter_list|,
name|Decl
modifier|*
name|TagDecl
parameter_list|)
function_decl|;
name|ExprResult
name|ParseCXXMemberInitializer
parameter_list|(
name|Decl
modifier|*
name|D
parameter_list|,
name|bool
name|IsFunction
parameter_list|,
name|SourceLocation
modifier|&
name|EqualLoc
parameter_list|)
function_decl|;
name|void
name|ParseCXXClassMemberDeclaration
parameter_list|(
name|AccessSpecifier
name|AS
parameter_list|,
name|AttributeList
modifier|*
name|Attr
parameter_list|,
specifier|const
name|ParsedTemplateInfo
modifier|&
name|TemplateInfo
init|=
name|ParsedTemplateInfo
argument_list|()
parameter_list|,
name|ParsingDeclRAIIObject
modifier|*
name|DiagsFromTParams
init|=
literal|0
parameter_list|)
function_decl|;
name|void
name|ParseConstructorInitializer
parameter_list|(
name|Decl
modifier|*
name|ConstructorDecl
parameter_list|)
function_decl|;
name|MemInitResult
name|ParseMemInitializer
parameter_list|(
name|Decl
modifier|*
name|ConstructorDecl
parameter_list|)
function_decl|;
name|void
name|HandleMemberFunctionDeclDelays
parameter_list|(
name|Declarator
modifier|&
name|DeclaratorInfo
parameter_list|,
name|Decl
modifier|*
name|ThisDecl
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 10: Derived classes [class.derived]
name|TypeResult
name|ParseBaseTypeSpecifier
parameter_list|(
name|SourceLocation
modifier|&
name|BaseLoc
parameter_list|,
name|SourceLocation
modifier|&
name|EndLocation
parameter_list|)
function_decl|;
name|void
name|ParseBaseClause
parameter_list|(
name|Decl
modifier|*
name|ClassDecl
parameter_list|)
function_decl|;
name|BaseResult
name|ParseBaseSpecifier
parameter_list|(
name|Decl
modifier|*
name|ClassDecl
parameter_list|)
function_decl|;
name|AccessSpecifier
name|getAccessSpecifierIfPresent
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|ParseUnqualifiedIdTemplateId
parameter_list|(
name|CXXScopeSpec
modifier|&
name|SS
parameter_list|,
name|SourceLocation
name|TemplateKWLoc
parameter_list|,
name|IdentifierInfo
modifier|*
name|Name
parameter_list|,
name|SourceLocation
name|NameLoc
parameter_list|,
name|bool
name|EnteringContext
parameter_list|,
name|ParsedType
name|ObjectType
parameter_list|,
name|UnqualifiedId
modifier|&
name|Id
parameter_list|,
name|bool
name|AssumeTemplateId
parameter_list|)
function_decl|;
name|bool
name|ParseUnqualifiedIdOperator
parameter_list|(
name|CXXScopeSpec
modifier|&
name|SS
parameter_list|,
name|bool
name|EnteringContext
parameter_list|,
name|ParsedType
name|ObjectType
parameter_list|,
name|UnqualifiedId
modifier|&
name|Result
parameter_list|)
function_decl|;
name|bool
name|ParseUnqualifiedId
parameter_list|(
name|CXXScopeSpec
modifier|&
name|SS
parameter_list|,
name|bool
name|EnteringContext
parameter_list|,
name|bool
name|AllowDestructorName
parameter_list|,
name|bool
name|AllowConstructorName
parameter_list|,
name|ParsedType
name|ObjectType
parameter_list|,
name|SourceLocation
modifier|&
name|TemplateKWLoc
parameter_list|,
name|UnqualifiedId
modifier|&
name|Result
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 14: Templates [temp]
comment|// C++ 14.1: Template Parameters [temp.param]
name|Decl
modifier|*
name|ParseDeclarationStartingWithTemplate
parameter_list|(
name|unsigned
name|Context
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|,
name|AccessSpecifier
name|AS
init|=
name|AS_none
parameter_list|,
name|AttributeList
modifier|*
name|AccessAttrs
init|=
literal|0
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseTemplateDeclarationOrSpecialization
parameter_list|(
name|unsigned
name|Context
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|,
name|AccessSpecifier
name|AS
parameter_list|,
name|AttributeList
modifier|*
name|AccessAttrs
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseSingleDeclarationAfterTemplate
parameter_list|(
name|unsigned
name|Context
parameter_list|,
specifier|const
name|ParsedTemplateInfo
modifier|&
name|TemplateInfo
parameter_list|,
name|ParsingDeclRAIIObject
modifier|&
name|DiagsFromParams
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|,
name|AccessSpecifier
name|AS
init|=
name|AS_none
parameter_list|,
name|AttributeList
modifier|*
name|AccessAttrs
init|=
literal|0
parameter_list|)
function_decl|;
name|bool
name|ParseTemplateParameters
argument_list|(
name|unsigned
name|Depth
argument_list|,
name|SmallVectorImpl
operator|<
name|Decl
operator|*
operator|>
operator|&
name|TemplateParams
argument_list|,
name|SourceLocation
operator|&
name|LAngleLoc
argument_list|,
name|SourceLocation
operator|&
name|RAngleLoc
argument_list|)
decl_stmt|;
name|bool
name|ParseTemplateParameterList
argument_list|(
name|unsigned
name|Depth
argument_list|,
name|SmallVectorImpl
operator|<
name|Decl
operator|*
operator|>
operator|&
name|TemplateParams
argument_list|)
decl_stmt|;
name|bool
name|isStartOfTemplateTypeParameter
parameter_list|()
function_decl|;
name|Decl
modifier|*
name|ParseTemplateParameter
parameter_list|(
name|unsigned
name|Depth
parameter_list|,
name|unsigned
name|Position
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseTypeParameter
parameter_list|(
name|unsigned
name|Depth
parameter_list|,
name|unsigned
name|Position
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseTemplateTemplateParameter
parameter_list|(
name|unsigned
name|Depth
parameter_list|,
name|unsigned
name|Position
parameter_list|)
function_decl|;
name|Decl
modifier|*
name|ParseNonTypeTemplateParameter
parameter_list|(
name|unsigned
name|Depth
parameter_list|,
name|unsigned
name|Position
parameter_list|)
function_decl|;
comment|// C++ 14.3: Template arguments [temp.arg]
typedef|typedef
name|SmallVector
operator|<
name|ParsedTemplateArgument
operator|,
literal|16
operator|>
name|TemplateArgList
expr_stmt|;
name|bool
name|ParseTemplateIdAfterTemplateName
parameter_list|(
name|TemplateTy
name|Template
parameter_list|,
name|SourceLocation
name|TemplateNameLoc
parameter_list|,
specifier|const
name|CXXScopeSpec
modifier|&
name|SS
parameter_list|,
name|bool
name|ConsumeLastToken
parameter_list|,
name|SourceLocation
modifier|&
name|LAngleLoc
parameter_list|,
name|TemplateArgList
modifier|&
name|TemplateArgs
parameter_list|,
name|SourceLocation
modifier|&
name|RAngleLoc
parameter_list|)
function_decl|;
name|bool
name|AnnotateTemplateIdToken
parameter_list|(
name|TemplateTy
name|Template
parameter_list|,
name|TemplateNameKind
name|TNK
parameter_list|,
name|CXXScopeSpec
modifier|&
name|SS
parameter_list|,
name|SourceLocation
name|TemplateKWLoc
parameter_list|,
name|UnqualifiedId
modifier|&
name|TemplateName
parameter_list|,
name|bool
name|AllowTypeAnnotation
init|=
name|true
parameter_list|)
function_decl|;
name|void
name|AnnotateTemplateIdTokenAsType
parameter_list|()
function_decl|;
name|bool
name|IsTemplateArgumentList
parameter_list|(
name|unsigned
name|Skip
init|=
literal|0
parameter_list|)
function_decl|;
name|bool
name|ParseTemplateArgumentList
parameter_list|(
name|TemplateArgList
modifier|&
name|TemplateArgs
parameter_list|)
function_decl|;
name|ParsedTemplateArgument
name|ParseTemplateTemplateArgument
parameter_list|()
function_decl|;
name|ParsedTemplateArgument
name|ParseTemplateArgument
parameter_list|()
function_decl|;
name|Decl
modifier|*
name|ParseExplicitInstantiation
parameter_list|(
name|unsigned
name|Context
parameter_list|,
name|SourceLocation
name|ExternLoc
parameter_list|,
name|SourceLocation
name|TemplateLoc
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|,
name|AccessSpecifier
name|AS
init|=
name|AS_none
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// Modules
name|DeclGroupPtrTy
name|ParseModuleImport
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// GNU G++: Type Traits [Type-Traits.html in the GCC manual]
name|ExprResult
name|ParseUnaryTypeTrait
parameter_list|()
function_decl|;
name|ExprResult
name|ParseBinaryTypeTrait
parameter_list|()
function_decl|;
name|ExprResult
name|ParseTypeTrait
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// Embarcadero: Arary and Expression Traits
name|ExprResult
name|ParseArrayTypeTrait
parameter_list|()
function_decl|;
name|ExprResult
name|ParseExpressionTrait
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// Preprocessor code-completion pass-through
name|virtual
name|void
name|CodeCompleteDirective
parameter_list|(
name|bool
name|InConditional
parameter_list|)
function_decl|;
name|virtual
name|void
name|CodeCompleteInConditionalExclusion
parameter_list|()
function_decl|;
name|virtual
name|void
name|CodeCompleteMacroName
parameter_list|(
name|bool
name|IsDefinition
parameter_list|)
function_decl|;
name|virtual
name|void
name|CodeCompletePreprocessorExpression
parameter_list|()
function_decl|;
name|virtual
name|void
name|CodeCompleteMacroArgument
parameter_list|(
name|IdentifierInfo
modifier|*
name|Macro
parameter_list|,
name|MacroInfo
modifier|*
name|MacroInfo
parameter_list|,
name|unsigned
name|ArgumentIndex
parameter_list|)
function_decl|;
name|virtual
name|void
name|CodeCompleteNaturalLanguage
parameter_list|()
function_decl|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

