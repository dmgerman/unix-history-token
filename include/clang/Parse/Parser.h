begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- Parser.h - C Language Parser ---------------------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file defines the Parser interface.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_PARSE_PARSER_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_PARSE_PARSER_H
end_define

begin_include
include|#
directive|include
file|"clang/Lex/Preprocessor.h"
end_include

begin_include
include|#
directive|include
file|"clang/Parse/AccessSpecifier.h"
end_include

begin_include
include|#
directive|include
file|"clang/Parse/Action.h"
end_include

begin_include
include|#
directive|include
file|"clang/Parse/DeclSpec.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/OwningPtr.h"
end_include

begin_include
include|#
directive|include
file|<stack>
end_include

begin_include
include|#
directive|include
file|<list>
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|AttributeList
decl_stmt|;
name|class
name|PragmaHandler
decl_stmt|;
name|class
name|Scope
decl_stmt|;
name|class
name|DiagnosticBuilder
decl_stmt|;
name|class
name|Parser
decl_stmt|;
name|class
name|PragmaUnusedHandler
decl_stmt|;
comment|/// PrettyStackTraceParserEntry - If a crash happens while the parser is active,
comment|/// an entry is printed for it.
name|class
name|PrettyStackTraceParserEntry
range|:
name|public
name|llvm
operator|::
name|PrettyStackTraceEntry
block|{
specifier|const
name|Parser
operator|&
name|P
block|;
name|public
operator|:
name|PrettyStackTraceParserEntry
argument_list|(
specifier|const
name|Parser
operator|&
name|p
argument_list|)
operator|:
name|P
argument_list|(
argument|p
argument_list|)
block|{}
name|virtual
name|void
name|print
argument_list|(
argument|llvm::raw_ostream&OS
argument_list|)
specifier|const
block|; }
decl_stmt|;
comment|/// Parser - This implements a parser for the C family of languages.  After
comment|/// parsing units of the grammar, productions are invoked to handle whatever has
comment|/// been read.
comment|///
name|class
name|Parser
block|{
name|friend
name|class
name|PragmaUnusedHandler
decl_stmt|;
name|PrettyStackTraceParserEntry
name|CrashInfo
decl_stmt|;
name|Preprocessor
modifier|&
name|PP
decl_stmt|;
comment|/// Tok - The current token we are peeking ahead.  All parsing methods assume
comment|/// that this is valid.
name|Token
name|Tok
decl_stmt|;
comment|// PrevTokLocation - The location of the token we previously
comment|// consumed. This token is used for diagnostics where we expected to
comment|// see a token following another token (e.g., the ';' at the end of
comment|// a statement).
name|SourceLocation
name|PrevTokLocation
decl_stmt|;
name|unsigned
name|short
name|ParenCount
decl_stmt|,
name|BracketCount
decl_stmt|,
name|BraceCount
decl_stmt|;
comment|/// Actions - These are the callbacks we invoke as we parse various constructs
comment|/// in the file.  This refers to the common base class between MinimalActions
comment|/// and SemaActions for those uses that don't matter.
name|Action
modifier|&
name|Actions
decl_stmt|;
name|Scope
modifier|*
name|CurScope
decl_stmt|;
name|Diagnostic
modifier|&
name|Diags
decl_stmt|;
comment|/// ScopeCache - Cache scopes to reduce malloc traffic.
enum|enum
block|{
name|ScopeCacheSize
init|=
literal|16
block|}
enum|;
name|unsigned
name|NumCachedScopes
decl_stmt|;
name|Scope
modifier|*
name|ScopeCache
index|[
name|ScopeCacheSize
index|]
decl_stmt|;
comment|/// Ident_super - IdentifierInfo for "super", to support fast
comment|/// comparison.
name|IdentifierInfo
modifier|*
name|Ident_super
decl_stmt|;
name|llvm
operator|::
name|OwningPtr
operator|<
name|PragmaHandler
operator|>
name|PackHandler
expr_stmt|;
name|llvm
operator|::
name|OwningPtr
operator|<
name|PragmaHandler
operator|>
name|UnusedHandler
expr_stmt|;
name|llvm
operator|::
name|OwningPtr
operator|<
name|PragmaHandler
operator|>
name|WeakHandler
expr_stmt|;
comment|/// Whether the '>' token acts as an operator or not. This will be
comment|/// true except when we are parsing an expression within a C++
comment|/// template argument list, where the '>' closes the template
comment|/// argument list.
name|bool
name|GreaterThanIsOperator
decl_stmt|;
comment|/// \brief RAII object that makes '>' behave either as an operator
comment|/// or as the closing angle bracket for a template argument list.
struct|struct
name|GreaterThanIsOperatorScope
block|{
name|bool
modifier|&
name|GreaterThanIsOperator
decl_stmt|;
name|bool
name|OldGreaterThanIsOperator
decl_stmt|;
name|GreaterThanIsOperatorScope
argument_list|(
argument|bool&GTIO
argument_list|,
argument|bool Val
argument_list|)
block|:
name|GreaterThanIsOperator
argument_list|(
name|GTIO
argument_list|)
operator|,
name|OldGreaterThanIsOperator
argument_list|(
argument|GTIO
argument_list|)
block|{
name|GreaterThanIsOperator
operator|=
name|Val
block|;     }
operator|~
name|GreaterThanIsOperatorScope
argument_list|()
block|{
name|GreaterThanIsOperator
operator|=
name|OldGreaterThanIsOperator
block|;     }
block|}
struct|;
name|public
label|:
name|Parser
argument_list|(
name|Preprocessor
operator|&
name|PP
argument_list|,
name|Action
operator|&
name|Actions
argument_list|)
expr_stmt|;
operator|~
name|Parser
argument_list|()
expr_stmt|;
specifier|const
name|LangOptions
operator|&
name|getLang
argument_list|()
specifier|const
block|{
return|return
name|PP
operator|.
name|getLangOptions
argument_list|()
return|;
block|}
name|TargetInfo
operator|&
name|getTargetInfo
argument_list|()
specifier|const
block|{
return|return
name|PP
operator|.
name|getTargetInfo
argument_list|()
return|;
block|}
name|Preprocessor
operator|&
name|getPreprocessor
argument_list|()
specifier|const
block|{
return|return
name|PP
return|;
block|}
name|Action
operator|&
name|getActions
argument_list|()
specifier|const
block|{
return|return
name|Actions
return|;
block|}
specifier|const
name|Token
operator|&
name|getCurToken
argument_list|()
specifier|const
block|{
return|return
name|Tok
return|;
block|}
comment|// Type forwarding.  All of these are statically 'void*', but they may all be
comment|// different actual classes based on the actions in place.
typedef|typedef
name|Action
operator|::
name|ExprTy
name|ExprTy
expr_stmt|;
typedef|typedef
name|Action
operator|::
name|StmtTy
name|StmtTy
expr_stmt|;
typedef|typedef
name|Action
operator|::
name|DeclPtrTy
name|DeclPtrTy
expr_stmt|;
typedef|typedef
name|Action
operator|::
name|DeclGroupPtrTy
name|DeclGroupPtrTy
expr_stmt|;
typedef|typedef
name|Action
operator|::
name|TypeTy
name|TypeTy
expr_stmt|;
typedef|typedef
name|Action
operator|::
name|BaseTy
name|BaseTy
expr_stmt|;
typedef|typedef
name|Action
operator|::
name|MemInitTy
name|MemInitTy
expr_stmt|;
typedef|typedef
name|Action
operator|::
name|CXXScopeTy
name|CXXScopeTy
expr_stmt|;
typedef|typedef
name|Action
operator|::
name|TemplateParamsTy
name|TemplateParamsTy
expr_stmt|;
typedef|typedef
name|Action
operator|::
name|TemplateTy
name|TemplateTy
expr_stmt|;
typedef|typedef
name|llvm
operator|::
name|SmallVector
operator|<
name|TemplateParamsTy
operator|*
operator|,
literal|4
operator|>
name|TemplateParameterLists
expr_stmt|;
typedef|typedef
name|Action
operator|::
name|ExprResult
name|ExprResult
expr_stmt|;
typedef|typedef
name|Action
operator|::
name|StmtResult
name|StmtResult
expr_stmt|;
typedef|typedef
name|Action
operator|::
name|BaseResult
name|BaseResult
expr_stmt|;
typedef|typedef
name|Action
operator|::
name|MemInitResult
name|MemInitResult
expr_stmt|;
typedef|typedef
name|Action
operator|::
name|TypeResult
name|TypeResult
expr_stmt|;
typedef|typedef
name|Action
operator|::
name|OwningExprResult
name|OwningExprResult
expr_stmt|;
typedef|typedef
name|Action
operator|::
name|OwningStmtResult
name|OwningStmtResult
expr_stmt|;
typedef|typedef
name|Action
operator|::
name|ExprArg
name|ExprArg
expr_stmt|;
typedef|typedef
name|Action
operator|::
name|MultiStmtArg
name|MultiStmtArg
expr_stmt|;
typedef|typedef
name|Action
operator|::
name|FullExprArg
name|FullExprArg
expr_stmt|;
comment|/// Adorns a ExprResult with Actions to make it an OwningExprResult
name|OwningExprResult
name|Owned
parameter_list|(
name|ExprResult
name|res
parameter_list|)
block|{
return|return
name|OwningExprResult
argument_list|(
name|Actions
argument_list|,
name|res
argument_list|)
return|;
block|}
comment|/// Adorns a StmtResult with Actions to make it an OwningStmtResult
name|OwningStmtResult
name|Owned
parameter_list|(
name|StmtResult
name|res
parameter_list|)
block|{
return|return
name|OwningStmtResult
argument_list|(
name|Actions
argument_list|,
name|res
argument_list|)
return|;
block|}
name|OwningExprResult
name|ExprError
parameter_list|()
block|{
return|return
name|OwningExprResult
argument_list|(
name|Actions
argument_list|,
name|true
argument_list|)
return|;
block|}
name|OwningStmtResult
name|StmtError
parameter_list|()
block|{
return|return
name|OwningStmtResult
argument_list|(
name|Actions
argument_list|,
name|true
argument_list|)
return|;
block|}
name|OwningExprResult
name|ExprError
parameter_list|(
specifier|const
name|DiagnosticBuilder
modifier|&
parameter_list|)
block|{
return|return
name|ExprError
argument_list|()
return|;
block|}
name|OwningStmtResult
name|StmtError
parameter_list|(
specifier|const
name|DiagnosticBuilder
modifier|&
parameter_list|)
block|{
return|return
name|StmtError
argument_list|()
return|;
block|}
name|OwningExprResult
name|ExprEmpty
parameter_list|()
block|{
return|return
name|OwningExprResult
argument_list|(
name|Actions
argument_list|,
name|false
argument_list|)
return|;
block|}
comment|// Parsing methods.
comment|/// ParseTranslationUnit - All in one method that initializes parses, and
comment|/// shuts down the parser.
name|void
name|ParseTranslationUnit
parameter_list|()
function_decl|;
comment|/// Initialize - Warm up the parser.
comment|///
name|void
name|Initialize
parameter_list|()
function_decl|;
comment|/// ParseTopLevelDecl - Parse one top-level declaration. Returns true if
comment|/// the EOF was encountered.
name|bool
name|ParseTopLevelDecl
parameter_list|(
name|DeclGroupPtrTy
modifier|&
name|Result
parameter_list|)
function_decl|;
name|private
label|:
comment|//===--------------------------------------------------------------------===//
comment|// Low-Level token peeking and consumption methods.
comment|//
comment|/// isTokenParen - Return true if the cur token is '(' or ')'.
name|bool
name|isTokenParen
argument_list|()
specifier|const
block|{
return|return
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|l_paren
operator|||
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|r_paren
return|;
block|}
comment|/// isTokenBracket - Return true if the cur token is '[' or ']'.
name|bool
name|isTokenBracket
argument_list|()
specifier|const
block|{
return|return
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|l_square
operator|||
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|r_square
return|;
block|}
comment|/// isTokenBrace - Return true if the cur token is '{' or '}'.
name|bool
name|isTokenBrace
argument_list|()
specifier|const
block|{
return|return
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|l_brace
operator|||
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|r_brace
return|;
block|}
comment|/// isTokenStringLiteral - True if this token is a string-literal.
comment|///
name|bool
name|isTokenStringLiteral
argument_list|()
specifier|const
block|{
return|return
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|string_literal
operator|||
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|wide_string_literal
return|;
block|}
comment|/// ConsumeToken - Consume the current 'peek token' and lex the next one.
comment|/// This does not work with all kinds of tokens: strings and specific other
comment|/// tokens must be consumed with custom methods below.  This returns the
comment|/// location of the consumed token.
name|SourceLocation
name|ConsumeToken
parameter_list|()
block|{
name|assert
argument_list|(
operator|!
name|isTokenStringLiteral
argument_list|()
operator|&&
operator|!
name|isTokenParen
argument_list|()
operator|&&
operator|!
name|isTokenBracket
argument_list|()
operator|&&
operator|!
name|isTokenBrace
argument_list|()
operator|&&
literal|"Should consume special tokens with Consume*Token"
argument_list|)
expr_stmt|;
name|PrevTokLocation
operator|=
name|Tok
operator|.
name|getLocation
argument_list|()
expr_stmt|;
name|PP
operator|.
name|Lex
argument_list|(
name|Tok
argument_list|)
expr_stmt|;
return|return
name|PrevTokLocation
return|;
block|}
comment|/// ConsumeAnyToken - Dispatch to the right Consume* method based on the
comment|/// current token type.  This should only be used in cases where the type of
comment|/// the token really isn't known, e.g. in error recovery.
name|SourceLocation
name|ConsumeAnyToken
parameter_list|()
block|{
if|if
condition|(
name|isTokenParen
argument_list|()
condition|)
return|return
name|ConsumeParen
argument_list|()
return|;
elseif|else
if|if
condition|(
name|isTokenBracket
argument_list|()
condition|)
return|return
name|ConsumeBracket
argument_list|()
return|;
elseif|else
if|if
condition|(
name|isTokenBrace
argument_list|()
condition|)
return|return
name|ConsumeBrace
argument_list|()
return|;
elseif|else
if|if
condition|(
name|isTokenStringLiteral
argument_list|()
condition|)
return|return
name|ConsumeStringToken
argument_list|()
return|;
else|else
return|return
name|ConsumeToken
argument_list|()
return|;
block|}
comment|/// ConsumeParen - This consume method keeps the paren count up-to-date.
comment|///
name|SourceLocation
name|ConsumeParen
parameter_list|()
block|{
name|assert
argument_list|(
name|isTokenParen
argument_list|()
operator|&&
literal|"wrong consume method"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|l_paren
condition|)
operator|++
name|ParenCount
expr_stmt|;
elseif|else
if|if
condition|(
name|ParenCount
condition|)
operator|--
name|ParenCount
expr_stmt|;
comment|// Don't let unbalanced )'s drive the count negative.
name|PrevTokLocation
operator|=
name|Tok
operator|.
name|getLocation
argument_list|()
expr_stmt|;
name|PP
operator|.
name|Lex
argument_list|(
name|Tok
argument_list|)
expr_stmt|;
return|return
name|PrevTokLocation
return|;
block|}
comment|/// ConsumeBracket - This consume method keeps the bracket count up-to-date.
comment|///
name|SourceLocation
name|ConsumeBracket
parameter_list|()
block|{
name|assert
argument_list|(
name|isTokenBracket
argument_list|()
operator|&&
literal|"wrong consume method"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|l_square
condition|)
operator|++
name|BracketCount
expr_stmt|;
elseif|else
if|if
condition|(
name|BracketCount
condition|)
operator|--
name|BracketCount
expr_stmt|;
comment|// Don't let unbalanced ]'s drive the count negative.
name|PrevTokLocation
operator|=
name|Tok
operator|.
name|getLocation
argument_list|()
expr_stmt|;
name|PP
operator|.
name|Lex
argument_list|(
name|Tok
argument_list|)
expr_stmt|;
return|return
name|PrevTokLocation
return|;
block|}
comment|/// ConsumeBrace - This consume method keeps the brace count up-to-date.
comment|///
name|SourceLocation
name|ConsumeBrace
parameter_list|()
block|{
name|assert
argument_list|(
name|isTokenBrace
argument_list|()
operator|&&
literal|"wrong consume method"
argument_list|)
expr_stmt|;
if|if
condition|(
name|Tok
operator|.
name|getKind
argument_list|()
operator|==
name|tok
operator|::
name|l_brace
condition|)
operator|++
name|BraceCount
expr_stmt|;
elseif|else
if|if
condition|(
name|BraceCount
condition|)
operator|--
name|BraceCount
expr_stmt|;
comment|// Don't let unbalanced }'s drive the count negative.
name|PrevTokLocation
operator|=
name|Tok
operator|.
name|getLocation
argument_list|()
expr_stmt|;
name|PP
operator|.
name|Lex
argument_list|(
name|Tok
argument_list|)
expr_stmt|;
return|return
name|PrevTokLocation
return|;
block|}
comment|/// ConsumeStringToken - Consume the current 'peek token', lexing a new one
comment|/// and returning the token kind.  This method is specific to strings, as it
comment|/// handles string literal concatenation, as per C99 5.1.1.2, translation
comment|/// phase #6.
name|SourceLocation
name|ConsumeStringToken
parameter_list|()
block|{
name|assert
argument_list|(
name|isTokenStringLiteral
argument_list|()
operator|&&
literal|"Should only consume string literals with this method"
argument_list|)
expr_stmt|;
name|PrevTokLocation
operator|=
name|Tok
operator|.
name|getLocation
argument_list|()
expr_stmt|;
name|PP
operator|.
name|Lex
argument_list|(
name|Tok
argument_list|)
expr_stmt|;
return|return
name|PrevTokLocation
return|;
block|}
comment|/// GetLookAheadToken - This peeks ahead N tokens and returns that token
comment|/// without consuming any tokens.  LookAhead(0) returns 'Tok', LookAhead(1)
comment|/// returns the token after Tok, etc.
comment|///
comment|/// Note that this differs from the Preprocessor's LookAhead method, because
comment|/// the Parser always has one token lexed that the preprocessor doesn't.
comment|///
specifier|const
name|Token
modifier|&
name|GetLookAheadToken
parameter_list|(
name|unsigned
name|N
parameter_list|)
block|{
if|if
condition|(
name|N
operator|==
literal|0
operator|||
name|Tok
operator|.
name|is
argument_list|(
name|tok
operator|::
name|eof
argument_list|)
condition|)
return|return
name|Tok
return|;
return|return
name|PP
operator|.
name|LookAhead
argument_list|(
name|N
operator|-
literal|1
argument_list|)
return|;
block|}
comment|/// NextToken - This peeks ahead one token and returns it without
comment|/// consuming it.
specifier|const
name|Token
modifier|&
name|NextToken
parameter_list|()
block|{
return|return
name|PP
operator|.
name|LookAhead
argument_list|(
literal|0
argument_list|)
return|;
block|}
comment|/// TryAnnotateTypeOrScopeToken - If the current token position is on a
comment|/// typename (possibly qualified in C++) or a C++ scope specifier not followed
comment|/// by a typename, TryAnnotateTypeOrScopeToken will replace one or more tokens
comment|/// with a single annotation token representing the typename or C++ scope
comment|/// respectively.
comment|/// This simplifies handling of C++ scope specifiers and allows efficient
comment|/// backtracking without the need to re-parse and resolve nested-names and
comment|/// typenames.
comment|/// It will mainly be called when we expect to treat identifiers as typenames
comment|/// (if they are typenames). For example, in C we do not expect identifiers
comment|/// inside expressions to be treated as typenames so it will not be called
comment|/// for expressions in C.
comment|///
comment|/// This returns true if the token was annotated.
name|bool
name|TryAnnotateTypeOrScopeToken
parameter_list|()
function_decl|;
comment|/// TryAnnotateCXXScopeToken - Like TryAnnotateTypeOrScopeToken but only
comment|/// annotates C++ scope specifiers.  This returns true if the token was
comment|/// annotated.
name|bool
name|TryAnnotateCXXScopeToken
parameter_list|()
function_decl|;
comment|/// TentativeParsingAction - An object that is used as a kind of "tentative
comment|/// parsing transaction". It gets instantiated to mark the token position and
comment|/// after the token consumption is done, Commit() or Revert() is called to
comment|/// either "commit the consumed tokens" or revert to the previously marked
comment|/// token position. Example:
comment|///
comment|///   TentativeParsingAction TPA;
comment|///   ConsumeToken();
comment|///   ....
comment|///   TPA.Revert();
comment|///
name|class
name|TentativeParsingAction
block|{
name|Parser
modifier|&
name|P
decl_stmt|;
name|Token
name|PrevTok
decl_stmt|;
name|bool
name|isActive
decl_stmt|;
name|public
label|:
name|explicit
name|TentativeParsingAction
argument_list|(
name|Parser
operator|&
name|p
argument_list|)
operator|:
name|P
argument_list|(
argument|p
argument_list|)
block|{
name|PrevTok
operator|=
name|P
operator|.
name|Tok
block|;
name|P
operator|.
name|PP
operator|.
name|EnableBacktrackAtThisPos
argument_list|()
block|;
name|isActive
operator|=
name|true
block|;     }
name|void
name|Commit
argument_list|()
block|{
name|assert
argument_list|(
name|isActive
operator|&&
literal|"Parsing action was finished!"
argument_list|)
block|;
name|P
operator|.
name|PP
operator|.
name|CommitBacktrackedTokens
argument_list|()
block|;
name|isActive
operator|=
name|false
block|;     }
name|void
name|Revert
argument_list|()
block|{
name|assert
argument_list|(
name|isActive
operator|&&
literal|"Parsing action was finished!"
argument_list|)
block|;
name|P
operator|.
name|PP
operator|.
name|Backtrack
argument_list|()
block|;
name|P
operator|.
name|Tok
operator|=
name|PrevTok
block|;
name|isActive
operator|=
name|false
block|;     }
operator|~
name|TentativeParsingAction
argument_list|()
block|{
name|assert
argument_list|(
operator|!
name|isActive
operator|&&
literal|"Forgot to call Commit or Revert!"
argument_list|)
block|;     }
block|}
empty_stmt|;
comment|/// MatchRHSPunctuation - For punctuation with a LHS and RHS (e.g. '['/']'),
comment|/// this helper function matches and consumes the specified RHS token if
comment|/// present.  If not present, it emits the specified diagnostic indicating
comment|/// that the parser failed to match the RHS of the token at LHSLoc.  LHSName
comment|/// should be the name of the unmatched LHS token.  This returns the location
comment|/// of the consumed token.
name|SourceLocation
name|MatchRHSPunctuation
argument_list|(
name|tok
operator|::
name|TokenKind
name|RHSTok
argument_list|,
name|SourceLocation
name|LHSLoc
argument_list|)
decl_stmt|;
comment|/// ExpectAndConsume - The parser expects that 'ExpectedTok' is next in the
comment|/// input.  If so, it is consumed and false is returned.
comment|///
comment|/// If the input is malformed, this emits the specified diagnostic.  Next, if
comment|/// SkipToTok is specified, it calls SkipUntil(SkipToTok).  Finally, true is
comment|/// returned.
name|bool
name|ExpectAndConsume
argument_list|(
name|tok
operator|::
name|TokenKind
name|ExpectedTok
argument_list|,
name|unsigned
name|Diag
argument_list|,
specifier|const
name|char
operator|*
name|DiagMsg
operator|=
literal|""
argument_list|,
name|tok
operator|::
name|TokenKind
name|SkipToTok
operator|=
name|tok
operator|::
name|unknown
argument_list|)
decl_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|// Scope manipulation
comment|/// ParseScope - Introduces a new scope for parsing. The kind of
comment|/// scope is determined by ScopeFlags. Objects of this type should
comment|/// be created on the stack to coincide with the position where the
comment|/// parser enters the new scope, and this object's constructor will
comment|/// create that new scope. Similarly, once the object is destroyed
comment|/// the parser will exit the scope.
name|class
name|ParseScope
block|{
name|Parser
modifier|*
name|Self
decl_stmt|;
name|ParseScope
argument_list|(
specifier|const
name|ParseScope
operator|&
argument_list|)
expr_stmt|;
comment|// do not implement
name|ParseScope
modifier|&
name|operator
init|=
operator|(
specifier|const
name|ParseScope
operator|&
operator|)
decl_stmt|;
comment|// do not implement
name|public
label|:
comment|// ParseScope - Construct a new object to manage a scope in the
comment|// parser Self where the new Scope is created with the flags
comment|// ScopeFlags, but only when ManageScope is true (the default). If
comment|// ManageScope is false, this object does nothing.
name|ParseScope
argument_list|(
argument|Parser *Self
argument_list|,
argument|unsigned ScopeFlags
argument_list|,
argument|bool ManageScope = true
argument_list|)
block|:
name|Self
argument_list|(
argument|Self
argument_list|)
block|{
if|if
condition|(
name|ManageScope
condition|)
name|Self
operator|->
name|EnterScope
argument_list|(
name|ScopeFlags
argument_list|)
expr_stmt|;
else|else
name|this
operator|->
name|Self
operator|=
literal|0
expr_stmt|;
block|}
comment|// Exit - Exit the scope associated with this object now, rather
comment|// than waiting until the object is destroyed.
name|void
name|Exit
parameter_list|()
block|{
if|if
condition|(
name|Self
condition|)
block|{
name|Self
operator|->
name|ExitScope
argument_list|()
expr_stmt|;
name|Self
operator|=
literal|0
expr_stmt|;
block|}
block|}
operator|~
name|ParseScope
argument_list|()
block|{
name|Exit
argument_list|()
block|;     }
block|}
empty_stmt|;
comment|/// EnterScope - Start a new scope.
name|void
name|EnterScope
parameter_list|(
name|unsigned
name|ScopeFlags
parameter_list|)
function_decl|;
comment|/// ExitScope - Pop a scope off the scope stack.
name|void
name|ExitScope
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// Diagnostic Emission and Error recovery.
name|DiagnosticBuilder
name|Diag
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
name|unsigned
name|DiagID
parameter_list|)
function_decl|;
name|DiagnosticBuilder
name|Diag
parameter_list|(
specifier|const
name|Token
modifier|&
name|Tok
parameter_list|,
name|unsigned
name|DiagID
parameter_list|)
function_decl|;
name|void
name|SuggestParentheses
parameter_list|(
name|SourceLocation
name|Loc
parameter_list|,
name|unsigned
name|DK
parameter_list|,
name|SourceRange
name|ParenRange
parameter_list|)
function_decl|;
comment|/// SkipUntil - Read tokens until we get to the specified token, then consume
comment|/// it (unless DontConsume is true).  Because we cannot guarantee that the
comment|/// token will ever occur, this skips to the next token, or to some likely
comment|/// good stopping point.  If StopAtSemi is true, skipping will stop at a ';'
comment|/// character.
comment|///
comment|/// If SkipUntil finds the specified token, it returns true, otherwise it
comment|/// returns false.
name|bool
name|SkipUntil
argument_list|(
name|tok
operator|::
name|TokenKind
name|T
argument_list|,
name|bool
name|StopAtSemi
operator|=
name|true
argument_list|,
name|bool
name|DontConsume
operator|=
name|false
argument_list|)
block|{
return|return
name|SkipUntil
argument_list|(
operator|&
name|T
argument_list|,
literal|1
argument_list|,
name|StopAtSemi
argument_list|,
name|DontConsume
argument_list|)
return|;
block|}
name|bool
name|SkipUntil
argument_list|(
name|tok
operator|::
name|TokenKind
name|T1
argument_list|,
name|tok
operator|::
name|TokenKind
name|T2
argument_list|,
name|bool
name|StopAtSemi
operator|=
name|true
argument_list|,
name|bool
name|DontConsume
operator|=
name|false
argument_list|)
block|{
name|tok
operator|::
name|TokenKind
name|TokArray
index|[]
operator|=
block|{
name|T1
block|,
name|T2
block|}
expr_stmt|;
return|return
name|SkipUntil
argument_list|(
name|TokArray
argument_list|,
literal|2
argument_list|,
name|StopAtSemi
argument_list|,
name|DontConsume
argument_list|)
return|;
block|}
name|bool
name|SkipUntil
argument_list|(
specifier|const
name|tok
operator|::
name|TokenKind
operator|*
name|Toks
argument_list|,
name|unsigned
name|NumToks
argument_list|,
name|bool
name|StopAtSemi
operator|=
name|true
argument_list|,
name|bool
name|DontConsume
operator|=
name|false
argument_list|)
decl_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|// Lexing and parsing of C++ inline methods.
struct|struct
name|LexedMethod
block|{
name|Action
operator|::
name|DeclPtrTy
name|D
expr_stmt|;
name|CachedTokens
name|Toks
decl_stmt|;
name|explicit
name|LexedMethod
argument_list|(
name|Action
operator|::
name|DeclPtrTy
name|MD
argument_list|)
range|:
name|D
argument_list|(
argument|MD
argument_list|)
block|{}
block|}
struct|;
comment|/// LateParsedDefaultArgument - Keeps track of a parameter that may
comment|/// have a default argument that cannot be parsed yet because it
comment|/// occurs within a member function declaration inside the class
comment|/// (C++ [class.mem]p2).
struct|struct
name|LateParsedDefaultArgument
block|{
name|explicit
name|LateParsedDefaultArgument
argument_list|(
name|Action
operator|::
name|DeclPtrTy
name|P
argument_list|,
name|CachedTokens
operator|*
name|Toks
operator|=
literal|0
argument_list|)
range|:
name|Param
argument_list|(
name|P
argument_list|)
decl_stmt|,
name|Toks
argument_list|(
name|Toks
argument_list|)
block|{ }
comment|/// Param - The parameter declaration for this parameter.
name|Action
operator|::
name|DeclPtrTy
name|Param
expr_stmt|;
comment|/// Toks - The sequence of tokens that comprises the default
comment|/// argument expression, not including the '=' or the terminating
comment|/// ')' or ','. This will be NULL for parameters that have no
comment|/// default argument.
name|CachedTokens
modifier|*
name|Toks
decl_stmt|;
block|}
struct|;
comment|/// LateParsedMethodDeclaration - A method declaration inside a class that
comment|/// contains at least one entity whose parsing needs to be delayed
comment|/// until the class itself is completely-defined, such as a default
comment|/// argument (C++ [class.mem]p2).
struct|struct
name|LateParsedMethodDeclaration
block|{
name|explicit
name|LateParsedMethodDeclaration
argument_list|(
name|Action
operator|::
name|DeclPtrTy
name|M
argument_list|)
range|:
name|Method
argument_list|(
argument|M
argument_list|)
block|{ }
comment|/// Method - The method declaration.
name|Action
operator|::
name|DeclPtrTy
name|Method
decl_stmt|;
comment|/// DefaultArgs - Contains the parameters of the function and
comment|/// their default arguments. At least one of the parameters will
comment|/// have a default argument, but all of the parameters of the
comment|/// method will be stored so that they can be reintroduced into
comment|/// scope at the appropriate times.
name|llvm
operator|::
name|SmallVector
operator|<
name|LateParsedDefaultArgument
operator|,
literal|8
operator|>
name|DefaultArgs
expr_stmt|;
block|}
struct|;
comment|/// LateParsedMethodDecls - During parsing of a top (non-nested) C++
comment|/// class, its method declarations that contain parts that won't be
comment|/// parsed until after the definiton is completed (C++ [class.mem]p2),
comment|/// the method declarations will be stored here with the tokens that
comment|/// will be parsed to create those entities.
typedef|typedef
name|std
operator|::
name|list
operator|<
name|LateParsedMethodDeclaration
operator|>
name|LateParsedMethodDecls
expr_stmt|;
comment|/// LexedMethodsForTopClass - During parsing of a top (non-nested) C++ class,
comment|/// its inline method definitions and the inline method definitions of its
comment|/// nested classes are lexed and stored here.
typedef|typedef
name|std
operator|::
name|list
operator|<
name|LexedMethod
operator|>
name|LexedMethodsForTopClass
expr_stmt|;
comment|/// \brief Representation of a class that has been parsed, including
comment|/// any member function declarations or definitions that need to be
comment|/// parsed after the corresponding top-level class is complete.
struct|struct
name|ParsingClass
block|{
name|ParsingClass
argument_list|(
argument|DeclPtrTy TagOrTemplate
argument_list|,
argument|bool TopLevelClass
argument_list|)
block|:
name|TopLevelClass
argument_list|(
name|TopLevelClass
argument_list|)
operator|,
name|TemplateScope
argument_list|(
name|false
argument_list|)
operator|,
name|TagOrTemplate
argument_list|(
argument|TagOrTemplate
argument_list|)
block|{ }
comment|/// \brief Whether this is a "top-level" class, meaning that it is
comment|/// not nested within another class.
name|bool
name|TopLevelClass
operator|:
literal|1
expr_stmt|;
comment|/// \brief Whether this class had an associated template
comment|/// scope. When true, TagOrTemplate is a template declaration;
comment|/// othewise, it is a tag declaration.
name|bool
name|TemplateScope
range|:
literal|1
decl_stmt|;
comment|/// \brief The class or class template whose definition we are parsing.
name|DeclPtrTy
name|TagOrTemplate
decl_stmt|;
comment|/// MethodDecls - Method declarations that contain pieces whose
comment|/// parsing will be delayed until the class is fully defined.
name|LateParsedMethodDecls
name|MethodDecls
decl_stmt|;
comment|/// MethodDefs - Methods whose definitions will be parsed once the
comment|/// class has been fully defined.
name|LexedMethodsForTopClass
name|MethodDefs
decl_stmt|;
comment|/// \brief Nested classes inside this class.
name|llvm
operator|::
name|SmallVector
operator|<
name|ParsingClass
operator|*
operator|,
literal|4
operator|>
name|NestedClasses
expr_stmt|;
block|}
struct|;
comment|/// \brief The stack of classes that is currently being
comment|/// parsed. Nested and local classes will be pushed onto this stack
comment|/// when they are parsed, and removed afterward.
name|std
operator|::
name|stack
operator|<
name|ParsingClass
operator|*
operator|>
name|ClassStack
expr_stmt|;
name|ParsingClass
modifier|&
name|getCurrentClass
parameter_list|()
block|{
name|assert
argument_list|(
operator|!
name|ClassStack
operator|.
name|empty
argument_list|()
operator|&&
literal|"No lexed method stacks!"
argument_list|)
expr_stmt|;
return|return
operator|*
name|ClassStack
operator|.
name|top
argument_list|()
return|;
block|}
comment|/// \brief RAII object used to
name|class
name|ParsingClassDefinition
block|{
name|Parser
modifier|&
name|P
decl_stmt|;
name|bool
name|Popped
decl_stmt|;
name|public
label|:
name|ParsingClassDefinition
argument_list|(
argument|Parser&P
argument_list|,
argument|DeclPtrTy TagOrTemplate
argument_list|,
argument|bool TopLevelClass
argument_list|)
block|:
name|P
argument_list|(
name|P
argument_list|)
operator|,
name|Popped
argument_list|(
argument|false
argument_list|)
block|{
name|P
operator|.
name|PushParsingClass
argument_list|(
name|TagOrTemplate
argument_list|,
name|TopLevelClass
argument_list|)
block|;     }
comment|/// \brief Pop this class of the stack.
name|void
name|Pop
argument_list|()
block|{
name|assert
argument_list|(
operator|!
name|Popped
operator|&&
literal|"Nested class has already been popped"
argument_list|)
block|;
name|Popped
operator|=
name|true
block|;
name|P
operator|.
name|PopParsingClass
argument_list|()
block|;     }
operator|~
name|ParsingClassDefinition
argument_list|()
block|{
if|if
condition|(
operator|!
name|Popped
condition|)
name|P
operator|.
name|PopParsingClass
argument_list|()
expr_stmt|;
block|}
block|}
empty_stmt|;
name|void
name|PushParsingClass
parameter_list|(
name|DeclPtrTy
name|TagOrTemplate
parameter_list|,
name|bool
name|TopLevelClass
parameter_list|)
function_decl|;
name|void
name|DeallocateParsedClasses
parameter_list|(
name|ParsingClass
modifier|*
name|Class
parameter_list|)
function_decl|;
name|void
name|PopParsingClass
parameter_list|()
function_decl|;
name|DeclPtrTy
name|ParseCXXInlineMethodDef
parameter_list|(
name|AccessSpecifier
name|AS
parameter_list|,
name|Declarator
modifier|&
name|D
parameter_list|)
function_decl|;
name|void
name|ParseLexedMethodDeclarations
parameter_list|(
name|ParsingClass
modifier|&
name|Class
parameter_list|)
function_decl|;
name|void
name|ParseLexedMethodDefs
parameter_list|(
name|ParsingClass
modifier|&
name|Class
parameter_list|)
function_decl|;
name|bool
name|ConsumeAndStoreUntil
argument_list|(
name|tok
operator|::
name|TokenKind
name|T1
argument_list|,
name|tok
operator|::
name|TokenKind
name|T2
argument_list|,
name|CachedTokens
operator|&
name|Toks
argument_list|,
name|tok
operator|::
name|TokenKind
name|EarlyAbortIf
operator|=
name|tok
operator|::
name|unknown
argument_list|,
name|bool
name|ConsumeFinalToken
operator|=
name|true
argument_list|)
decl_stmt|;
comment|/// \brief Contains information about any template-specific
comment|/// information that has been parsed prior to parsing declaration
comment|/// specifiers.
struct|struct
name|ParsedTemplateInfo
block|{
name|ParsedTemplateInfo
argument_list|()
operator|:
name|Kind
argument_list|(
name|NonTemplate
argument_list|)
operator|,
name|TemplateParams
argument_list|(
literal|0
argument_list|)
operator|,
name|TemplateLoc
argument_list|()
block|{ }
name|ParsedTemplateInfo
argument_list|(
argument|TemplateParameterLists *TemplateParams
argument_list|,
argument|bool isSpecialization
argument_list|)
operator|:
name|Kind
argument_list|(
name|isSpecialization
operator|?
name|ExplicitSpecialization
operator|:
name|Template
argument_list|)
operator|,
name|TemplateParams
argument_list|(
argument|TemplateParams
argument_list|)
block|{ }
name|explicit
name|ParsedTemplateInfo
argument_list|(
argument|SourceLocation TemplateLoc
argument_list|)
operator|:
name|Kind
argument_list|(
name|ExplicitInstantiation
argument_list|)
operator|,
name|TemplateParams
argument_list|(
literal|0
argument_list|)
operator|,
name|TemplateLoc
argument_list|(
argument|TemplateLoc
argument_list|)
block|{ }
comment|/// \brief The kind of template we are parsing.
expr|enum
block|{
comment|/// \brief We are not parsing a template at all.
name|NonTemplate
operator|=
literal|0
block|,
comment|/// \brief We are parsing a template declaration.
name|Template
block|,
comment|/// \brief We are parsing an explicit specialization.
name|ExplicitSpecialization
block|,
comment|/// \brief We are parsing an explicit instantiation.
name|ExplicitInstantiation
block|}
name|Kind
expr_stmt|;
comment|/// \brief The template parameter lists, for template declarations
comment|/// and explicit specializations.
name|TemplateParameterLists
modifier|*
name|TemplateParams
decl_stmt|;
comment|/// \brief The location of the 'template' keyword, for an explicit
comment|/// instantiation.
name|SourceLocation
name|TemplateLoc
decl_stmt|;
block|}
struct|;
comment|//===--------------------------------------------------------------------===//
comment|// C99 6.9: External Definitions.
name|DeclGroupPtrTy
name|ParseExternalDeclaration
parameter_list|()
function_decl|;
name|bool
name|isDeclarationAfterDeclarator
parameter_list|()
function_decl|;
name|bool
name|isStartOfFunctionDefinition
parameter_list|()
function_decl|;
name|DeclGroupPtrTy
name|ParseDeclarationOrFunctionDefinition
parameter_list|(
name|AccessSpecifier
name|AS
init|=
name|AS_none
parameter_list|)
function_decl|;
name|DeclPtrTy
name|ParseFunctionDefinition
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|)
function_decl|;
name|void
name|ParseKNRParamDeclarations
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|)
function_decl|;
comment|// EndLoc, if non-NULL, is filled with the location of the last token of
comment|// the simple-asm.
name|OwningExprResult
name|ParseSimpleAsm
parameter_list|(
name|SourceLocation
modifier|*
name|EndLoc
init|=
literal|0
parameter_list|)
function_decl|;
name|OwningExprResult
name|ParseAsmStringLiteral
parameter_list|()
function_decl|;
comment|// Objective-C External Declarations
name|DeclPtrTy
name|ParseObjCAtDirectives
parameter_list|()
function_decl|;
name|DeclPtrTy
name|ParseObjCAtClassDeclaration
parameter_list|(
name|SourceLocation
name|atLoc
parameter_list|)
function_decl|;
name|DeclPtrTy
name|ParseObjCAtInterfaceDeclaration
parameter_list|(
name|SourceLocation
name|atLoc
parameter_list|,
name|AttributeList
modifier|*
name|prefixAttrs
init|=
literal|0
parameter_list|)
function_decl|;
name|void
name|ParseObjCClassInstanceVariables
parameter_list|(
name|DeclPtrTy
name|interfaceDecl
parameter_list|,
name|SourceLocation
name|atLoc
parameter_list|)
function_decl|;
name|bool
name|ParseObjCProtocolReferences
argument_list|(
name|llvm
operator|::
name|SmallVectorImpl
operator|<
name|Action
operator|::
name|DeclPtrTy
operator|>
operator|&
name|P
argument_list|,
name|bool
name|WarnOnDeclarations
argument_list|,
name|SourceLocation
operator|&
name|EndProtoLoc
argument_list|)
decl_stmt|;
name|void
name|ParseObjCInterfaceDeclList
argument_list|(
name|DeclPtrTy
name|interfaceDecl
argument_list|,
name|tok
operator|::
name|ObjCKeywordKind
name|contextKey
argument_list|)
decl_stmt|;
name|DeclPtrTy
name|ParseObjCAtProtocolDeclaration
parameter_list|(
name|SourceLocation
name|atLoc
parameter_list|,
name|AttributeList
modifier|*
name|prefixAttrs
init|=
literal|0
parameter_list|)
function_decl|;
name|DeclPtrTy
name|ObjCImpDecl
decl_stmt|;
name|DeclPtrTy
name|ParseObjCAtImplementationDeclaration
parameter_list|(
name|SourceLocation
name|atLoc
parameter_list|)
function_decl|;
name|DeclPtrTy
name|ParseObjCAtEndDeclaration
parameter_list|(
name|SourceLocation
name|atLoc
parameter_list|)
function_decl|;
name|DeclPtrTy
name|ParseObjCAtAliasDeclaration
parameter_list|(
name|SourceLocation
name|atLoc
parameter_list|)
function_decl|;
name|DeclPtrTy
name|ParseObjCPropertySynthesize
parameter_list|(
name|SourceLocation
name|atLoc
parameter_list|)
function_decl|;
name|DeclPtrTy
name|ParseObjCPropertyDynamic
parameter_list|(
name|SourceLocation
name|atLoc
parameter_list|)
function_decl|;
name|IdentifierInfo
modifier|*
name|ParseObjCSelectorPiece
parameter_list|(
name|SourceLocation
modifier|&
name|MethodLocation
parameter_list|)
function_decl|;
comment|// Definitions for Objective-c context sensitive keywords recognition.
enum|enum
name|ObjCTypeQual
block|{
name|objc_in
init|=
literal|0
block|,
name|objc_out
block|,
name|objc_inout
block|,
name|objc_oneway
block|,
name|objc_bycopy
block|,
name|objc_byref
block|,
name|objc_NumQuals
block|}
enum|;
name|IdentifierInfo
modifier|*
name|ObjCTypeQuals
index|[
name|objc_NumQuals
index|]
decl_stmt|;
name|bool
name|isTokIdentifier_in
argument_list|()
specifier|const
expr_stmt|;
name|TypeTy
modifier|*
name|ParseObjCTypeName
parameter_list|(
name|ObjCDeclSpec
modifier|&
name|DS
parameter_list|)
function_decl|;
name|void
name|ParseObjCMethodRequirement
parameter_list|()
function_decl|;
name|DeclPtrTy
name|ParseObjCMethodPrototype
argument_list|(
name|DeclPtrTy
name|classOrCat
argument_list|,
name|tok
operator|::
name|ObjCKeywordKind
name|MethodImplKind
operator|=
name|tok
operator|::
name|objc_not_keyword
argument_list|)
decl_stmt|;
name|DeclPtrTy
name|ParseObjCMethodDecl
argument_list|(
name|SourceLocation
name|mLoc
argument_list|,
name|tok
operator|::
name|TokenKind
name|mType
argument_list|,
name|DeclPtrTy
name|classDecl
argument_list|,
name|tok
operator|::
name|ObjCKeywordKind
name|MethodImplKind
operator|=
name|tok
operator|::
name|objc_not_keyword
argument_list|)
decl_stmt|;
name|void
name|ParseObjCPropertyAttribute
parameter_list|(
name|ObjCDeclSpec
modifier|&
name|DS
parameter_list|)
function_decl|;
name|DeclPtrTy
name|ParseObjCMethodDefinition
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C99 6.5: Expressions.
name|OwningExprResult
name|ParseExpression
parameter_list|()
function_decl|;
name|OwningExprResult
name|ParseConstantExpression
parameter_list|()
function_decl|;
comment|// Expr that doesn't include commas.
name|OwningExprResult
name|ParseAssignmentExpression
parameter_list|()
function_decl|;
name|OwningExprResult
name|ParseExpressionWithLeadingAt
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|)
function_decl|;
name|OwningExprResult
name|ParseExpressionWithLeadingExtension
parameter_list|(
name|SourceLocation
name|ExtLoc
parameter_list|)
function_decl|;
name|OwningExprResult
name|ParseRHSOfBinaryExpression
parameter_list|(
name|OwningExprResult
name|LHS
parameter_list|,
name|unsigned
name|MinPrec
parameter_list|)
function_decl|;
name|OwningExprResult
name|ParseCastExpression
parameter_list|(
name|bool
name|isUnaryExpression
parameter_list|,
name|bool
name|isAddressOfOperand
parameter_list|,
name|bool
modifier|&
name|NotCastExpr
parameter_list|)
function_decl|;
name|OwningExprResult
name|ParseCastExpression
parameter_list|(
name|bool
name|isUnaryExpression
parameter_list|,
name|bool
name|isAddressOfOperand
init|=
name|false
parameter_list|)
function_decl|;
name|OwningExprResult
name|ParsePostfixExpressionSuffix
parameter_list|(
name|OwningExprResult
name|LHS
parameter_list|)
function_decl|;
name|OwningExprResult
name|ParseSizeofAlignofExpression
parameter_list|()
function_decl|;
name|OwningExprResult
name|ParseBuiltinPrimaryExpression
parameter_list|()
function_decl|;
name|OwningExprResult
name|ParseExprAfterTypeofSizeofAlignof
parameter_list|(
specifier|const
name|Token
modifier|&
name|OpTok
parameter_list|,
name|bool
modifier|&
name|isCastExpr
parameter_list|,
name|TypeTy
modifier|*
modifier|&
name|CastTy
parameter_list|,
name|SourceRange
modifier|&
name|CastRange
parameter_list|)
function_decl|;
specifier|static
specifier|const
name|unsigned
name|ExprListSize
init|=
literal|12
decl_stmt|;
typedef|typedef
name|llvm
operator|::
name|SmallVector
operator|<
name|ExprTy
operator|*
operator|,
name|ExprListSize
operator|>
name|ExprListTy
expr_stmt|;
typedef|typedef
name|llvm
operator|::
name|SmallVector
operator|<
name|SourceLocation
operator|,
name|ExprListSize
operator|>
name|CommaLocsTy
expr_stmt|;
comment|/// ParseExpressionList - Used for C/C++ (argument-)expression-list.
name|bool
name|ParseExpressionList
parameter_list|(
name|ExprListTy
modifier|&
name|Exprs
parameter_list|,
name|CommaLocsTy
modifier|&
name|CommaLocs
parameter_list|)
function_decl|;
comment|/// ParenParseOption - Control what ParseParenExpression will parse.
enum|enum
name|ParenParseOption
block|{
name|SimpleExpr
block|,
comment|// Only parse '(' expression ')'
name|CompoundStmt
block|,
comment|// Also allow '(' compound-statement ')'
name|CompoundLiteral
block|,
comment|// Also allow '(' type-name ')' '{' ... '}'
name|CastExpr
comment|// Also allow '(' type-name ')'<anything>
block|}
enum|;
name|OwningExprResult
name|ParseParenExpression
parameter_list|(
name|ParenParseOption
modifier|&
name|ExprType
parameter_list|,
name|bool
name|stopIfCastExpr
parameter_list|,
name|TypeTy
modifier|*
modifier|&
name|CastTy
parameter_list|,
name|SourceLocation
modifier|&
name|RParenLoc
parameter_list|)
function_decl|;
name|OwningExprResult
name|ParseCXXAmbiguousParenExpression
parameter_list|(
name|ParenParseOption
modifier|&
name|ExprType
parameter_list|,
name|TypeTy
modifier|*
modifier|&
name|CastTy
parameter_list|,
name|SourceLocation
name|LParenLoc
parameter_list|,
name|SourceLocation
modifier|&
name|RParenLoc
parameter_list|)
function_decl|;
name|OwningExprResult
name|ParseCompoundLiteralExpression
parameter_list|(
name|TypeTy
modifier|*
name|Ty
parameter_list|,
name|SourceLocation
name|LParenLoc
parameter_list|,
name|SourceLocation
name|RParenLoc
parameter_list|)
function_decl|;
name|OwningExprResult
name|ParseStringLiteralExpression
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ Expressions
name|OwningExprResult
name|ParseCXXIdExpression
parameter_list|(
name|bool
name|isAddressOfOperand
init|=
name|false
parameter_list|)
function_decl|;
comment|/// ParseOptionalCXXScopeSpecifier - Parse global scope or
comment|/// nested-name-specifier if present.  Returns true if a nested-name-specifier
comment|/// was parsed from the token stream.  Note that this routine will not parse
comment|/// ::new or ::delete, it will just leave them in the token stream.
comment|///
name|bool
name|ParseOptionalCXXScopeSpecifier
parameter_list|(
name|CXXScopeSpec
modifier|&
name|SS
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 5.2p1: C++ Casts
name|OwningExprResult
name|ParseCXXCasts
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 5.2p1: C++ Type Identification
name|OwningExprResult
name|ParseCXXTypeid
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 9.3.2: C++ 'this' pointer
name|OwningExprResult
name|ParseCXXThis
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 15: C++ Throw Expression
name|OwningExprResult
name|ParseThrowExpression
parameter_list|()
function_decl|;
comment|// EndLoc is filled with the location of the last token of the specification.
name|bool
name|ParseExceptionSpecification
argument_list|(
name|SourceLocation
operator|&
name|EndLoc
argument_list|,
name|llvm
operator|::
name|SmallVector
operator|<
name|TypeTy
operator|*
argument_list|,
literal|2
operator|>
operator|&
name|Exceptions
argument_list|,
name|llvm
operator|::
name|SmallVector
operator|<
name|SourceRange
argument_list|,
literal|2
operator|>
operator|&
name|Ranges
argument_list|,
name|bool
operator|&
name|hasAnyExceptionSpec
argument_list|)
decl_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 2.13.5: C++ Boolean Literals
name|OwningExprResult
name|ParseCXXBoolLiteral
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 5.2.3: Explicit type conversion (functional notation)
name|OwningExprResult
name|ParseCXXTypeConstructExpression
parameter_list|(
specifier|const
name|DeclSpec
modifier|&
name|DS
parameter_list|)
function_decl|;
comment|/// ParseCXXSimpleTypeSpecifier - [C++ 7.1.5.2] Simple type specifiers.
comment|/// This should only be called when the current token is known to be part of
comment|/// simple-type-specifier.
name|void
name|ParseCXXSimpleTypeSpecifier
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|)
function_decl|;
name|bool
name|ParseCXXTypeSpecifierSeq
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 5.3.4 and 5.3.5: C++ new and delete
name|bool
name|ParseExpressionListOrTypeId
parameter_list|(
name|ExprListTy
modifier|&
name|Exprs
parameter_list|,
name|Declarator
modifier|&
name|D
parameter_list|)
function_decl|;
name|void
name|ParseDirectNewDeclarator
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|)
function_decl|;
name|OwningExprResult
name|ParseCXXNewExpression
parameter_list|(
name|bool
name|UseGlobal
parameter_list|,
name|SourceLocation
name|Start
parameter_list|)
function_decl|;
name|OwningExprResult
name|ParseCXXDeleteExpression
parameter_list|(
name|bool
name|UseGlobal
parameter_list|,
name|SourceLocation
name|Start
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ if/switch/while/for condition expression.
name|OwningExprResult
name|ParseCXXCondition
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ types
comment|//===--------------------------------------------------------------------===//
comment|// C99 6.7.8: Initialization.
comment|/// ParseInitializer
comment|///       initializer: [C99 6.7.8]
comment|///         assignment-expression
comment|///         '{' ...
name|OwningExprResult
name|ParseInitializer
parameter_list|()
block|{
if|if
condition|(
name|Tok
operator|.
name|isNot
argument_list|(
name|tok
operator|::
name|l_brace
argument_list|)
condition|)
return|return
name|ParseAssignmentExpression
argument_list|()
return|;
return|return
name|ParseBraceInitializer
argument_list|()
return|;
block|}
name|OwningExprResult
name|ParseBraceInitializer
parameter_list|()
function_decl|;
name|OwningExprResult
name|ParseInitializerWithPotentialDesignator
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// clang Expressions
name|OwningExprResult
name|ParseBlockLiteralExpression
parameter_list|()
function_decl|;
comment|// ^{...}
comment|//===--------------------------------------------------------------------===//
comment|// Objective-C Expressions
name|bool
name|isTokObjCMessageIdentifierReceiver
argument_list|()
specifier|const
block|{
if|if
condition|(
operator|!
name|Tok
operator|.
name|is
argument_list|(
name|tok
operator|::
name|identifier
argument_list|)
condition|)
return|return
name|false
return|;
name|IdentifierInfo
operator|*
name|II
operator|=
name|Tok
operator|.
name|getIdentifierInfo
argument_list|()
expr_stmt|;
if|if
condition|(
name|Actions
operator|.
name|getTypeName
argument_list|(
operator|*
name|II
argument_list|,
name|Tok
operator|.
name|getLocation
argument_list|()
argument_list|,
name|CurScope
argument_list|)
condition|)
return|return
name|true
return|;
return|return
name|II
operator|==
name|Ident_super
return|;
block|}
name|OwningExprResult
name|ParseObjCAtExpression
parameter_list|(
name|SourceLocation
name|AtLocation
parameter_list|)
function_decl|;
name|OwningExprResult
name|ParseObjCStringLiteral
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|)
function_decl|;
name|OwningExprResult
name|ParseObjCEncodeExpression
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|)
function_decl|;
name|OwningExprResult
name|ParseObjCSelectorExpression
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|)
function_decl|;
name|OwningExprResult
name|ParseObjCProtocolExpression
parameter_list|(
name|SourceLocation
name|AtLoc
parameter_list|)
function_decl|;
name|OwningExprResult
name|ParseObjCMessageExpression
parameter_list|()
function_decl|;
name|OwningExprResult
name|ParseObjCMessageExpressionBody
parameter_list|(
name|SourceLocation
name|LBracloc
parameter_list|,
name|SourceLocation
name|NameLoc
parameter_list|,
name|IdentifierInfo
modifier|*
name|ReceiverName
parameter_list|,
name|ExprArg
name|ReceiverExpr
parameter_list|)
function_decl|;
name|OwningExprResult
name|ParseAssignmentExprWithObjCMessageExprStart
parameter_list|(
name|SourceLocation
name|LBracloc
parameter_list|,
name|SourceLocation
name|NameLoc
parameter_list|,
name|IdentifierInfo
modifier|*
name|ReceiverName
parameter_list|,
name|ExprArg
name|ReceiverExpr
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C99 6.8: Statements and Blocks.
name|OwningStmtResult
name|ParseStatement
parameter_list|()
block|{
return|return
name|ParseStatementOrDeclaration
argument_list|(
name|true
argument_list|)
return|;
block|}
name|OwningStmtResult
name|ParseStatementOrDeclaration
parameter_list|(
name|bool
name|OnlyStatement
init|=
name|false
parameter_list|)
function_decl|;
name|OwningStmtResult
name|ParseLabeledStatement
parameter_list|()
function_decl|;
name|OwningStmtResult
name|ParseCaseStatement
parameter_list|()
function_decl|;
name|OwningStmtResult
name|ParseDefaultStatement
parameter_list|()
function_decl|;
name|OwningStmtResult
name|ParseCompoundStatement
parameter_list|(
name|bool
name|isStmtExpr
init|=
name|false
parameter_list|)
function_decl|;
name|OwningStmtResult
name|ParseCompoundStatementBody
parameter_list|(
name|bool
name|isStmtExpr
init|=
name|false
parameter_list|)
function_decl|;
name|bool
name|ParseParenExprOrCondition
parameter_list|(
name|OwningExprResult
modifier|&
name|CondExp
parameter_list|,
name|bool
name|OnlyAllowCondition
init|=
name|false
parameter_list|,
name|SourceLocation
modifier|*
name|LParenLoc
init|=
literal|0
parameter_list|,
name|SourceLocation
modifier|*
name|RParenLoc
init|=
literal|0
parameter_list|)
function_decl|;
name|OwningStmtResult
name|ParseIfStatement
parameter_list|()
function_decl|;
name|OwningStmtResult
name|ParseSwitchStatement
parameter_list|()
function_decl|;
name|OwningStmtResult
name|ParseWhileStatement
parameter_list|()
function_decl|;
name|OwningStmtResult
name|ParseDoStatement
parameter_list|()
function_decl|;
name|OwningStmtResult
name|ParseForStatement
parameter_list|()
function_decl|;
name|OwningStmtResult
name|ParseGotoStatement
parameter_list|()
function_decl|;
name|OwningStmtResult
name|ParseContinueStatement
parameter_list|()
function_decl|;
name|OwningStmtResult
name|ParseBreakStatement
parameter_list|()
function_decl|;
name|OwningStmtResult
name|ParseReturnStatement
parameter_list|()
function_decl|;
name|OwningStmtResult
name|ParseAsmStatement
parameter_list|(
name|bool
modifier|&
name|msAsm
parameter_list|)
function_decl|;
name|OwningStmtResult
name|FuzzyParseMicrosoftAsmStatement
parameter_list|()
function_decl|;
name|bool
name|ParseAsmOperandsOpt
argument_list|(
name|llvm
operator|::
name|SmallVectorImpl
operator|<
name|std
operator|::
name|string
operator|>
operator|&
name|Names
argument_list|,
name|llvm
operator|::
name|SmallVectorImpl
operator|<
name|ExprTy
operator|*
operator|>
operator|&
name|Constraints
argument_list|,
name|llvm
operator|::
name|SmallVectorImpl
operator|<
name|ExprTy
operator|*
operator|>
operator|&
name|Exprs
argument_list|)
decl_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 6: Statements and Blocks
name|OwningStmtResult
name|ParseCXXTryBlock
parameter_list|()
function_decl|;
name|OwningStmtResult
name|ParseCXXTryBlockCommon
parameter_list|(
name|SourceLocation
name|TryLoc
parameter_list|)
function_decl|;
name|OwningStmtResult
name|ParseCXXCatchBlock
parameter_list|()
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// Objective-C Statements
name|OwningStmtResult
name|ParseObjCAtStatement
parameter_list|(
name|SourceLocation
name|atLoc
parameter_list|)
function_decl|;
name|OwningStmtResult
name|ParseObjCTryStmt
parameter_list|(
name|SourceLocation
name|atLoc
parameter_list|)
function_decl|;
name|OwningStmtResult
name|ParseObjCThrowStmt
parameter_list|(
name|SourceLocation
name|atLoc
parameter_list|)
function_decl|;
name|OwningStmtResult
name|ParseObjCSynchronizedStmt
parameter_list|(
name|SourceLocation
name|atLoc
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C99 6.7: Declarations.
name|DeclGroupPtrTy
name|ParseDeclaration
parameter_list|(
name|unsigned
name|Context
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|)
function_decl|;
name|DeclGroupPtrTy
name|ParseSimpleDeclaration
parameter_list|(
name|unsigned
name|Context
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|,
name|bool
name|RequireSemi
init|=
name|true
parameter_list|)
function_decl|;
name|DeclPtrTy
name|ParseDeclarationAfterDeclarator
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|)
function_decl|;
name|DeclGroupPtrTy
name|ParseInitDeclaratorListAfterFirstDeclarator
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|)
function_decl|;
name|DeclPtrTy
name|ParseFunctionStatementBody
parameter_list|(
name|DeclPtrTy
name|Decl
parameter_list|)
function_decl|;
name|DeclPtrTy
name|ParseFunctionTryBlock
parameter_list|(
name|DeclPtrTy
name|Decl
parameter_list|)
function_decl|;
name|bool
name|ParseImplicitInt
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|,
name|CXXScopeSpec
modifier|*
name|SS
parameter_list|,
specifier|const
name|ParsedTemplateInfo
modifier|&
name|TemplateInfo
parameter_list|,
name|AccessSpecifier
name|AS
parameter_list|)
function_decl|;
name|void
name|ParseDeclarationSpecifiers
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|,
specifier|const
name|ParsedTemplateInfo
modifier|&
name|TemplateInfo
init|=
name|ParsedTemplateInfo
argument_list|()
parameter_list|,
name|AccessSpecifier
name|AS
init|=
name|AS_none
parameter_list|)
function_decl|;
name|bool
name|ParseOptionalTypeSpecifier
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|,
name|int
modifier|&
name|isInvalid
parameter_list|,
specifier|const
name|char
modifier|*
modifier|&
name|PrevSpec
parameter_list|,
specifier|const
name|ParsedTemplateInfo
modifier|&
name|TemplateInfo
init|=
name|ParsedTemplateInfo
argument_list|()
parameter_list|)
function_decl|;
name|void
name|ParseSpecifierQualifierList
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|)
function_decl|;
name|void
name|ParseObjCTypeQualifierList
parameter_list|(
name|ObjCDeclSpec
modifier|&
name|DS
parameter_list|)
function_decl|;
name|void
name|ParseEnumSpecifier
parameter_list|(
name|SourceLocation
name|TagLoc
parameter_list|,
name|DeclSpec
modifier|&
name|DS
parameter_list|,
name|AccessSpecifier
name|AS
init|=
name|AS_none
parameter_list|)
function_decl|;
name|void
name|ParseEnumBody
parameter_list|(
name|SourceLocation
name|StartLoc
parameter_list|,
name|DeclPtrTy
name|TagDecl
parameter_list|)
function_decl|;
name|void
name|ParseStructUnionBody
parameter_list|(
name|SourceLocation
name|StartLoc
parameter_list|,
name|unsigned
name|TagType
parameter_list|,
name|DeclPtrTy
name|TagDecl
parameter_list|)
function_decl|;
name|void
name|ParseStructDeclaration
argument_list|(
name|DeclSpec
operator|&
name|DS
argument_list|,
name|llvm
operator|::
name|SmallVectorImpl
operator|<
name|FieldDeclarator
operator|>
operator|&
name|Fields
argument_list|)
decl_stmt|;
name|bool
name|isDeclarationSpecifier
parameter_list|()
function_decl|;
name|bool
name|isTypeSpecifierQualifier
parameter_list|()
function_decl|;
name|bool
name|isTypeQualifier
argument_list|()
specifier|const
expr_stmt|;
comment|/// isDeclarationStatement - Disambiguates between a declaration or an
comment|/// expression statement, when parsing function bodies.
comment|/// Returns true for declaration, false for expression.
name|bool
name|isDeclarationStatement
parameter_list|()
block|{
if|if
condition|(
name|getLang
argument_list|()
operator|.
name|CPlusPlus
condition|)
return|return
name|isCXXDeclarationStatement
argument_list|()
return|;
return|return
name|isDeclarationSpecifier
argument_list|()
return|;
block|}
comment|/// isSimpleDeclaration - Disambiguates between a declaration or an
comment|/// expression, mainly used for the C 'clause-1' or the C++
comment|// 'for-init-statement' part of a 'for' statement.
comment|/// Returns true for declaration, false for expression.
name|bool
name|isSimpleDeclaration
parameter_list|()
block|{
if|if
condition|(
name|getLang
argument_list|()
operator|.
name|CPlusPlus
condition|)
return|return
name|isCXXSimpleDeclaration
argument_list|()
return|;
return|return
name|isDeclarationSpecifier
argument_list|()
return|;
block|}
comment|/// \brief Specifies the context in which type-id/expression
comment|/// disambiguation will occur.
enum|enum
name|TentativeCXXTypeIdContext
block|{
name|TypeIdInParens
block|,
name|TypeIdAsTemplateArgument
block|}
enum|;
comment|/// isTypeIdInParens - Assumes that a '(' was parsed and now we want to know
comment|/// whether the parens contain an expression or a type-id.
comment|/// Returns true for a type-id and false for an expression.
name|bool
name|isTypeIdInParens
parameter_list|(
name|bool
modifier|&
name|isAmbiguous
parameter_list|)
block|{
if|if
condition|(
name|getLang
argument_list|()
operator|.
name|CPlusPlus
condition|)
return|return
name|isCXXTypeId
argument_list|(
name|TypeIdInParens
argument_list|,
name|isAmbiguous
argument_list|)
return|;
name|isAmbiguous
operator|=
name|false
expr_stmt|;
return|return
name|isTypeSpecifierQualifier
argument_list|()
return|;
block|}
name|bool
name|isTypeIdInParens
parameter_list|()
block|{
name|bool
name|isAmbiguous
decl_stmt|;
return|return
name|isTypeIdInParens
argument_list|(
name|isAmbiguous
argument_list|)
return|;
block|}
comment|/// isCXXDeclarationStatement - C++-specialized function that disambiguates
comment|/// between a declaration or an expression statement, when parsing function
comment|/// bodies. Returns true for declaration, false for expression.
name|bool
name|isCXXDeclarationStatement
parameter_list|()
function_decl|;
comment|/// isCXXSimpleDeclaration - C++-specialized function that disambiguates
comment|/// between a simple-declaration or an expression-statement.
comment|/// If during the disambiguation process a parsing error is encountered,
comment|/// the function returns true to let the declaration parsing code handle it.
comment|/// Returns false if the statement is disambiguated as expression.
name|bool
name|isCXXSimpleDeclaration
parameter_list|()
function_decl|;
comment|/// isCXXFunctionDeclarator - Disambiguates between a function declarator or
comment|/// a constructor-style initializer, when parsing declaration statements.
comment|/// Returns true for function declarator and false for constructor-style
comment|/// initializer. If 'warnIfAmbiguous' is true a warning will be emitted to
comment|/// indicate that the parens were disambiguated as function declarator.
comment|/// If during the disambiguation process a parsing error is encountered,
comment|/// the function returns true to let the declaration parsing code handle it.
name|bool
name|isCXXFunctionDeclarator
parameter_list|(
name|bool
name|warnIfAmbiguous
parameter_list|)
function_decl|;
comment|/// isCXXConditionDeclaration - Disambiguates between a declaration or an
comment|/// expression for a condition of a if/switch/while/for statement.
comment|/// If during the disambiguation process a parsing error is encountered,
comment|/// the function returns true to let the declaration parsing code handle it.
name|bool
name|isCXXConditionDeclaration
parameter_list|()
function_decl|;
name|bool
name|isCXXTypeId
parameter_list|(
name|TentativeCXXTypeIdContext
name|Context
parameter_list|,
name|bool
modifier|&
name|isAmbiguous
parameter_list|)
function_decl|;
name|bool
name|isCXXTypeId
parameter_list|(
name|TentativeCXXTypeIdContext
name|Context
parameter_list|)
block|{
name|bool
name|isAmbiguous
decl_stmt|;
return|return
name|isCXXTypeId
argument_list|(
name|Context
argument_list|,
name|isAmbiguous
argument_list|)
return|;
block|}
comment|/// TPResult - Used as the result value for functions whose purpose is to
comment|/// disambiguate C++ constructs by "tentatively parsing" them.
comment|/// This is a class instead of a simple enum because the implicit enum-to-bool
comment|/// conversions may cause subtle bugs.
name|class
name|TPResult
block|{
enum|enum
name|Result
block|{
name|TPR_true
block|,
name|TPR_false
block|,
name|TPR_ambiguous
block|,
name|TPR_error
block|}
enum|;
name|Result
name|Res
decl_stmt|;
name|TPResult
argument_list|(
argument|Result result
argument_list|)
block|:
name|Res
argument_list|(
argument|result
argument_list|)
block|{}
name|public
label|:
specifier|static
name|TPResult
name|True
parameter_list|()
block|{
return|return
name|TPR_true
return|;
block|}
specifier|static
name|TPResult
name|False
parameter_list|()
block|{
return|return
name|TPR_false
return|;
block|}
specifier|static
name|TPResult
name|Ambiguous
parameter_list|()
block|{
return|return
name|TPR_ambiguous
return|;
block|}
specifier|static
name|TPResult
name|Error
parameter_list|()
block|{
return|return
name|TPR_error
return|;
block|}
name|bool
name|operator
operator|==
operator|(
specifier|const
name|TPResult
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|Res
operator|==
name|RHS
operator|.
name|Res
return|;
block|}
name|bool
name|operator
operator|!=
operator|(
specifier|const
name|TPResult
operator|&
name|RHS
operator|)
specifier|const
block|{
return|return
name|Res
operator|!=
name|RHS
operator|.
name|Res
return|;
block|}
block|}
empty_stmt|;
comment|/// isCXXDeclarationSpecifier - Returns TPResult::True() if it is a
comment|/// declaration specifier, TPResult::False() if it is not,
comment|/// TPResult::Ambiguous() if it could be either a decl-specifier or a
comment|/// function-style cast, and TPResult::Error() if a parsing error was
comment|/// encountered.
comment|/// Doesn't consume tokens.
name|TPResult
name|isCXXDeclarationSpecifier
parameter_list|()
function_decl|;
comment|// "Tentative parsing" functions, used for disambiguation. If a parsing error
comment|// is encountered they will return TPResult::Error().
comment|// Returning TPResult::True()/False() indicates that the ambiguity was
comment|// resolved and tentative parsing may stop. TPResult::Ambiguous() indicates
comment|// that more tentative parsing is necessary for disambiguation.
comment|// They all consume tokens, so backtracking should be used after calling them.
name|TPResult
name|TryParseDeclarationSpecifier
parameter_list|()
function_decl|;
name|TPResult
name|TryParseSimpleDeclaration
parameter_list|()
function_decl|;
name|TPResult
name|TryParseTypeofSpecifier
parameter_list|()
function_decl|;
name|TPResult
name|TryParseInitDeclaratorList
parameter_list|()
function_decl|;
name|TPResult
name|TryParseDeclarator
parameter_list|(
name|bool
name|mayBeAbstract
parameter_list|,
name|bool
name|mayHaveIdentifier
init|=
name|true
parameter_list|)
function_decl|;
name|TPResult
name|TryParseParameterDeclarationClause
parameter_list|()
function_decl|;
name|TPResult
name|TryParseFunctionDeclarator
parameter_list|()
function_decl|;
name|TPResult
name|TryParseBracketDeclarator
parameter_list|()
function_decl|;
name|TypeResult
name|ParseTypeName
parameter_list|(
name|SourceRange
modifier|*
name|Range
init|=
literal|0
parameter_list|)
function_decl|;
name|void
name|ParseBlockId
parameter_list|()
function_decl|;
comment|// EndLoc, if non-NULL, is filled with the location of the last token of
comment|// the attribute list.
name|AttributeList
modifier|*
name|ParseAttributes
parameter_list|(
name|SourceLocation
modifier|*
name|EndLoc
init|=
literal|0
parameter_list|)
function_decl|;
name|AttributeList
modifier|*
name|ParseMicrosoftDeclSpec
parameter_list|(
name|AttributeList
modifier|*
name|CurrAttr
init|=
literal|0
parameter_list|)
function_decl|;
name|AttributeList
modifier|*
name|ParseMicrosoftTypeAttributes
parameter_list|(
name|AttributeList
modifier|*
name|CurrAttr
init|=
literal|0
parameter_list|)
function_decl|;
name|void
name|ParseTypeofSpecifier
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|)
function_decl|;
comment|/// DeclaratorScopeObj - RAII object used in Parser::ParseDirectDeclarator to
comment|/// enter a new C++ declarator scope and exit it when the function is
comment|/// finished.
name|class
name|DeclaratorScopeObj
block|{
name|Parser
modifier|&
name|P
decl_stmt|;
name|CXXScopeSpec
modifier|&
name|SS
decl_stmt|;
name|public
label|:
name|DeclaratorScopeObj
argument_list|(
name|Parser
operator|&
name|p
argument_list|,
name|CXXScopeSpec
operator|&
name|ss
argument_list|)
operator|:
name|P
argument_list|(
name|p
argument_list|)
operator|,
name|SS
argument_list|(
argument|ss
argument_list|)
block|{}
name|void
name|EnterDeclaratorScope
argument_list|()
block|{
if|if
condition|(
name|SS
operator|.
name|isSet
argument_list|()
condition|)
name|P
operator|.
name|Actions
operator|.
name|ActOnCXXEnterDeclaratorScope
argument_list|(
name|P
operator|.
name|CurScope
argument_list|,
name|SS
argument_list|)
expr_stmt|;
block|}
operator|~
name|DeclaratorScopeObj
argument_list|()
block|{
if|if
condition|(
name|SS
operator|.
name|isSet
argument_list|()
condition|)
name|P
operator|.
name|Actions
operator|.
name|ActOnCXXExitDeclaratorScope
argument_list|(
name|P
operator|.
name|CurScope
argument_list|,
name|SS
argument_list|)
expr_stmt|;
block|}
block|}
empty_stmt|;
comment|/// ParseDeclarator - Parse and verify a newly-initialized declarator.
name|void
name|ParseDeclarator
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|)
function_decl|;
comment|/// A function that parses a variant of direct-declarator.
typedef|typedef
name|void
argument_list|(
name|Parser
operator|::
operator|*
name|DirectDeclParseFunction
argument_list|)
argument_list|(
name|Declarator
operator|&
argument_list|)
expr_stmt|;
name|void
name|ParseDeclaratorInternal
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|,
name|DirectDeclParseFunction
name|DirectDeclParser
parameter_list|)
function_decl|;
name|void
name|ParseTypeQualifierListOpt
parameter_list|(
name|DeclSpec
modifier|&
name|DS
parameter_list|,
name|bool
name|AttributesAllowed
init|=
name|true
parameter_list|)
function_decl|;
name|void
name|ParseDirectDeclarator
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|)
function_decl|;
name|void
name|ParseParenDeclarator
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|)
function_decl|;
name|void
name|ParseFunctionDeclarator
parameter_list|(
name|SourceLocation
name|LParenLoc
parameter_list|,
name|Declarator
modifier|&
name|D
parameter_list|,
name|AttributeList
modifier|*
name|AttrList
init|=
literal|0
parameter_list|,
name|bool
name|RequiresArg
init|=
name|false
parameter_list|)
function_decl|;
name|void
name|ParseFunctionDeclaratorIdentifierList
parameter_list|(
name|SourceLocation
name|LParenLoc
parameter_list|,
name|Declarator
modifier|&
name|D
parameter_list|)
function_decl|;
name|void
name|ParseBracketDeclarator
parameter_list|(
name|Declarator
modifier|&
name|D
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 7: Declarations [dcl.dcl]
name|DeclPtrTy
name|ParseNamespace
parameter_list|(
name|unsigned
name|Context
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|)
function_decl|;
name|DeclPtrTy
name|ParseLinkage
parameter_list|(
name|unsigned
name|Context
parameter_list|)
function_decl|;
name|DeclPtrTy
name|ParseUsingDirectiveOrDeclaration
parameter_list|(
name|unsigned
name|Context
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|)
function_decl|;
name|DeclPtrTy
name|ParseUsingDirective
parameter_list|(
name|unsigned
name|Context
parameter_list|,
name|SourceLocation
name|UsingLoc
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|)
function_decl|;
name|DeclPtrTy
name|ParseUsingDeclaration
parameter_list|(
name|unsigned
name|Context
parameter_list|,
name|SourceLocation
name|UsingLoc
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|)
function_decl|;
name|DeclPtrTy
name|ParseStaticAssertDeclaration
parameter_list|(
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|)
function_decl|;
name|DeclPtrTy
name|ParseNamespaceAlias
parameter_list|(
name|SourceLocation
name|NamespaceLoc
parameter_list|,
name|SourceLocation
name|AliasLoc
parameter_list|,
name|IdentifierInfo
modifier|*
name|Alias
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 9: classes [class] and C structs/unions.
name|TypeResult
name|ParseClassName
parameter_list|(
name|SourceLocation
modifier|&
name|EndLocation
parameter_list|,
specifier|const
name|CXXScopeSpec
modifier|*
name|SS
init|=
literal|0
parameter_list|)
function_decl|;
name|void
name|ParseClassSpecifier
argument_list|(
name|tok
operator|::
name|TokenKind
name|TagTokKind
argument_list|,
name|SourceLocation
name|TagLoc
argument_list|,
name|DeclSpec
operator|&
name|DS
argument_list|,
specifier|const
name|ParsedTemplateInfo
operator|&
name|TemplateInfo
operator|=
name|ParsedTemplateInfo
argument_list|()
argument_list|,
name|AccessSpecifier
name|AS
operator|=
name|AS_none
argument_list|)
decl_stmt|;
name|void
name|ParseCXXMemberSpecification
parameter_list|(
name|SourceLocation
name|StartLoc
parameter_list|,
name|unsigned
name|TagType
parameter_list|,
name|DeclPtrTy
name|TagDecl
parameter_list|)
function_decl|;
name|void
name|ParseCXXClassMemberDeclaration
parameter_list|(
name|AccessSpecifier
name|AS
parameter_list|)
function_decl|;
name|void
name|ParseConstructorInitializer
parameter_list|(
name|DeclPtrTy
name|ConstructorDecl
parameter_list|)
function_decl|;
name|MemInitResult
name|ParseMemInitializer
parameter_list|(
name|DeclPtrTy
name|ConstructorDecl
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 10: Derived classes [class.derived]
name|void
name|ParseBaseClause
parameter_list|(
name|DeclPtrTy
name|ClassDecl
parameter_list|)
function_decl|;
name|BaseResult
name|ParseBaseSpecifier
parameter_list|(
name|DeclPtrTy
name|ClassDecl
parameter_list|)
function_decl|;
name|AccessSpecifier
name|getAccessSpecifierIfPresent
argument_list|()
specifier|const
expr_stmt|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 13.5: Overloaded operators [over.oper]
comment|// EndLoc, if non-NULL, is filled with the location of the last token of
comment|// the ID.
name|OverloadedOperatorKind
name|TryParseOperatorFunctionId
parameter_list|(
name|SourceLocation
modifier|*
name|EndLoc
init|=
literal|0
parameter_list|)
function_decl|;
name|TypeTy
modifier|*
name|ParseConversionFunctionId
parameter_list|(
name|SourceLocation
modifier|*
name|EndLoc
init|=
literal|0
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// C++ 14: Templates [temp]
typedef|typedef
name|llvm
operator|::
name|SmallVector
operator|<
name|DeclPtrTy
operator|,
literal|4
operator|>
name|TemplateParameterList
expr_stmt|;
comment|// C++ 14.1: Template Parameters [temp.param]
name|DeclPtrTy
name|ParseDeclarationStartingWithTemplate
parameter_list|(
name|unsigned
name|Context
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|,
name|AccessSpecifier
name|AS
init|=
name|AS_none
parameter_list|)
function_decl|;
name|DeclPtrTy
name|ParseTemplateDeclarationOrSpecialization
parameter_list|(
name|unsigned
name|Context
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|,
name|AccessSpecifier
name|AS
parameter_list|)
function_decl|;
name|DeclPtrTy
name|ParseSingleDeclarationAfterTemplate
parameter_list|(
name|unsigned
name|Context
parameter_list|,
specifier|const
name|ParsedTemplateInfo
modifier|&
name|TemplateInfo
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|,
name|AccessSpecifier
name|AS
init|=
name|AS_none
parameter_list|)
function_decl|;
name|bool
name|ParseTemplateParameters
parameter_list|(
name|unsigned
name|Depth
parameter_list|,
name|TemplateParameterList
modifier|&
name|TemplateParams
parameter_list|,
name|SourceLocation
modifier|&
name|LAngleLoc
parameter_list|,
name|SourceLocation
modifier|&
name|RAngleLoc
parameter_list|)
function_decl|;
name|bool
name|ParseTemplateParameterList
parameter_list|(
name|unsigned
name|Depth
parameter_list|,
name|TemplateParameterList
modifier|&
name|TemplateParams
parameter_list|)
function_decl|;
name|DeclPtrTy
name|ParseTemplateParameter
parameter_list|(
name|unsigned
name|Depth
parameter_list|,
name|unsigned
name|Position
parameter_list|)
function_decl|;
name|DeclPtrTy
name|ParseTypeParameter
parameter_list|(
name|unsigned
name|Depth
parameter_list|,
name|unsigned
name|Position
parameter_list|)
function_decl|;
name|DeclPtrTy
name|ParseTemplateTemplateParameter
parameter_list|(
name|unsigned
name|Depth
parameter_list|,
name|unsigned
name|Position
parameter_list|)
function_decl|;
name|DeclPtrTy
name|ParseNonTypeTemplateParameter
parameter_list|(
name|unsigned
name|Depth
parameter_list|,
name|unsigned
name|Position
parameter_list|)
function_decl|;
comment|// C++ 14.3: Template arguments [temp.arg]
typedef|typedef
name|llvm
operator|::
name|SmallVector
operator|<
name|void
operator|*
operator|,
literal|16
operator|>
name|TemplateArgList
expr_stmt|;
typedef|typedef
name|llvm
operator|::
name|SmallVector
operator|<
name|bool
operator|,
literal|16
operator|>
name|TemplateArgIsTypeList
expr_stmt|;
typedef|typedef
name|llvm
operator|::
name|SmallVector
operator|<
name|SourceLocation
operator|,
literal|16
operator|>
name|TemplateArgLocationList
expr_stmt|;
name|bool
name|ParseTemplateIdAfterTemplateName
parameter_list|(
name|TemplateTy
name|Template
parameter_list|,
name|SourceLocation
name|TemplateNameLoc
parameter_list|,
specifier|const
name|CXXScopeSpec
modifier|*
name|SS
parameter_list|,
name|bool
name|ConsumeLastToken
parameter_list|,
name|SourceLocation
modifier|&
name|LAngleLoc
parameter_list|,
name|TemplateArgList
modifier|&
name|TemplateArgs
parameter_list|,
name|TemplateArgIsTypeList
modifier|&
name|TemplateArgIsType
parameter_list|,
name|TemplateArgLocationList
modifier|&
name|TemplateArgLocations
parameter_list|,
name|SourceLocation
modifier|&
name|RAngleLoc
parameter_list|)
function_decl|;
name|void
name|AnnotateTemplateIdToken
parameter_list|(
name|TemplateTy
name|Template
parameter_list|,
name|TemplateNameKind
name|TNK
parameter_list|,
specifier|const
name|CXXScopeSpec
modifier|*
name|SS
parameter_list|,
name|SourceLocation
name|TemplateKWLoc
init|=
name|SourceLocation
argument_list|()
parameter_list|,
name|bool
name|AllowTypeAnnotation
init|=
name|true
parameter_list|)
function_decl|;
name|void
name|AnnotateTemplateIdTokenAsType
parameter_list|(
specifier|const
name|CXXScopeSpec
modifier|*
name|SS
init|=
literal|0
parameter_list|)
function_decl|;
name|bool
name|ParseTemplateArgumentList
parameter_list|(
name|TemplateArgList
modifier|&
name|TemplateArgs
parameter_list|,
name|TemplateArgIsTypeList
modifier|&
name|TemplateArgIsType
parameter_list|,
name|TemplateArgLocationList
modifier|&
name|TemplateArgLocations
parameter_list|)
function_decl|;
name|void
modifier|*
name|ParseTemplateArgument
parameter_list|(
name|bool
modifier|&
name|ArgIsType
parameter_list|)
function_decl|;
name|DeclPtrTy
name|ParseExplicitInstantiation
parameter_list|(
name|SourceLocation
name|TemplateLoc
parameter_list|,
name|SourceLocation
modifier|&
name|DeclEnd
parameter_list|)
function_decl|;
comment|//===--------------------------------------------------------------------===//
comment|// GNU G++: Type Traits [Type-Traits.html in the GCC manual]
name|OwningExprResult
name|ParseUnaryTypeTrait
parameter_list|()
function_decl|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
unit|}
comment|// end namespace clang
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

