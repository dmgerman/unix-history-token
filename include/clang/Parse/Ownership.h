begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//===--- Ownership.h - Parser Ownership Helpers -----------------*- C++ -*-===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//  This file contains classes for managing ownership of Stmt and Expr nodes.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_PARSE_OWNERSHIP_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_PARSE_OWNERSHIP_H
end_define

begin_include
include|#
directive|include
file|"llvm/ADT/SmallVector.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/PointerIntPair.h"
end_include

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|// OpaquePtr
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|ActionBase
decl_stmt|;
comment|/// OpaquePtr - This is a very simple POD type that wraps a pointer that the
comment|/// Parser doesn't know about but that Sema or another client does.  The UID
comment|/// template argument is used to make sure that "Decl" pointers are not
comment|/// compatible with "Type" pointers for example.
name|template
operator|<
name|int
name|UID
operator|>
name|class
name|OpaquePtr
block|{
name|void
operator|*
name|Ptr
block|;
name|public
operator|:
name|OpaquePtr
argument_list|()
operator|:
name|Ptr
argument_list|(
literal|0
argument_list|)
block|{}
name|template
operator|<
name|typename
name|T
operator|>
name|T
operator|*
name|getAs
argument_list|()
specifier|const
block|{
return|return
name|llvm
operator|::
name|PointerLikeTypeTraits
operator|<
name|T
operator|*
operator|>
operator|::
name|getFromVoidPointer
argument_list|(
name|Ptr
argument_list|)
return|;
block|}
name|template
operator|<
name|typename
name|T
operator|>
name|T
name|getAsVal
argument_list|()
specifier|const
block|{
return|return
name|llvm
operator|::
name|PointerLikeTypeTraits
operator|<
name|T
operator|>
operator|::
name|getFromVoidPointer
argument_list|(
name|Ptr
argument_list|)
return|;
block|}
name|void
operator|*
name|get
argument_list|()
specifier|const
block|{
return|return
name|Ptr
return|;
block|}
name|template
operator|<
name|typename
name|T
operator|>
specifier|static
name|OpaquePtr
name|make
argument_list|(
argument|T P
argument_list|)
block|{
name|OpaquePtr
name|R
block|;
name|R
operator|.
name|set
argument_list|(
name|P
argument_list|)
block|;
return|return
name|R
return|;
block|}
name|template
operator|<
name|typename
name|T
operator|>
name|void
name|set
argument_list|(
argument|T P
argument_list|)
block|{
name|Ptr
operator|=
name|llvm
operator|::
name|PointerLikeTypeTraits
operator|<
name|T
operator|>
operator|::
name|getAsVoidPointer
argument_list|(
name|P
argument_list|)
block|;     }
name|operator
name|bool
argument_list|()
specifier|const
block|{
return|return
name|Ptr
operator|!=
literal|0
return|;
block|}
expr|}
block|; }
name|namespace
name|llvm
block|{
name|template
operator|<
name|int
name|UID
operator|>
name|class
name|PointerLikeTypeTraits
operator|<
name|clang
operator|::
name|OpaquePtr
operator|<
name|UID
operator|>
expr|>
block|{
name|public
operator|:
specifier|static
specifier|inline
name|void
operator|*
name|getAsVoidPointer
argument_list|(
argument|clang::OpaquePtr<UID> P
argument_list|)
block|{
comment|// FIXME: Doesn't work? return P.getAs< void>();
return|return
name|P
operator|.
name|get
argument_list|()
return|;
block|}
specifier|static
specifier|inline
name|clang
operator|::
name|OpaquePtr
operator|<
name|UID
operator|>
name|getFromVoidPointer
argument_list|(
argument|void *P
argument_list|)
block|{
return|return
name|clang
operator|::
name|OpaquePtr
operator|<
name|UID
operator|>
operator|::
name|make
argument_list|(
name|P
argument_list|)
return|;
block|}
expr|enum
block|{
name|NumLowBitsAvailable
operator|=
literal|3
block|}
block|;   }
block|; }
comment|// -------------------------- About Move Emulation -------------------------- //
comment|// The smart pointer classes in this file attempt to emulate move semantics
comment|// as they appear in C++0x with rvalue references. Since C++03 doesn't have
comment|// rvalue references, some tricks are needed to get similar results.
comment|// Move semantics in C++0x have the following properties:
comment|// 1) "Moving" means transferring the value of an object to another object,
comment|//    similar to copying, but without caring what happens to the old object.
comment|//    In particular, this means that the new object can steal the old object's
comment|//    resources instead of creating a copy.
comment|// 2) Since moving can modify the source object, it must either be explicitly
comment|//    requested by the user, or the modifications must be unnoticeable.
comment|// 3) As such, C++0x moving is only allowed in three contexts:
comment|//    * By explicitly using std::move() to request it.
comment|//    * From a temporary object, since that object cannot be accessed
comment|//      afterwards anyway, thus making the state unobservable.
comment|//    * On function return, since the object is not observable afterwards.
comment|//
comment|// To sum up: moving from a named object should only be possible with an
comment|// explicit std::move(), or on function return. Moving from a temporary should
comment|// be implicitly done. Moving from a const object is forbidden.
comment|//
comment|// The emulation is not perfect, and has the following shortcomings:
comment|// * move() is not in namespace std.
comment|// * move() is required on function return.
comment|// * There are difficulties with implicit conversions.
comment|// * Microsoft's compiler must be given the /Za switch to successfully compile.
comment|//
comment|// -------------------------- Implementation -------------------------------- //
comment|// The move emulation relies on the peculiar reference binding semantics of
comment|// C++03: as a rule, a non-const reference may not bind to a temporary object,
comment|// except for the implicit object parameter in a member function call, which
comment|// can refer to a temporary even when not being const.
comment|// The moveable object has five important functions to facilitate moving:
comment|// * A private, unimplemented constructor taking a non-const reference to its
comment|//   own class. This constructor serves a two-fold purpose.
comment|//   - It prevents the creation of a copy constructor that takes a const
comment|//     reference. Temporaries would be able to bind to the argument of such a
comment|//     constructor, and that would be bad.
comment|//   - Named objects will bind to the non-const reference, but since it's
comment|//     private, this will fail to compile. This prevents implicit moving from
comment|//     named objects.
comment|//   There's also a copy assignment operator for the same purpose.
comment|// * An implicit, non-const conversion operator to a special mover type. This
comment|//   type represents the rvalue reference of C++0x. Being a non-const member,
comment|//   its implicit this parameter can bind to temporaries.
comment|// * A constructor that takes an object of this mover type. This constructor
comment|//   performs the actual move operation. There is an equivalent assignment
comment|//   operator.
comment|// There is also a free move() function that takes a non-const reference to
comment|// an object and returns a temporary. Internally, this function uses explicit
comment|// constructor calls to move the value from the referenced object to the return
comment|// value.
comment|//
comment|// There are now three possible scenarios of use.
comment|// * Copying from a const object. Constructor overload resolution will find the
comment|//   non-const copy constructor, and the move constructor. The first is not
comment|//   viable because the const object cannot be bound to the non-const reference.
comment|//   The second fails because the conversion to the mover object is non-const.
comment|//   Moving from a const object fails as intended.
comment|// * Copying from a named object. Constructor overload resolution will select
comment|//   the non-const copy constructor, but fail as intended, because this
comment|//   constructor is private.
comment|// * Copying from a temporary. Constructor overload resolution cannot select
comment|//   the non-const copy constructor, because the temporary cannot be bound to
comment|//   the non-const reference. It thus selects the move constructor. The
comment|//   temporary can be bound to the implicit this parameter of the conversion
comment|//   operator, because of the special binding rule. Construction succeeds.
comment|//   Note that the Microsoft compiler, as an extension, allows binding
comment|//   temporaries against non-const references. The compiler thus selects the
comment|//   non-const copy constructor and fails, because the constructor is private.
comment|//   Passing /Za (disable extensions) disables this behaviour.
comment|// The free move() function is used to move from a named object.
comment|//
comment|// Note that when passing an object of a different type (the classes below
comment|// have OwningResult and OwningPtr, which should be mixable), you get a problem.
comment|// Argument passing and function return use copy initialization rules. The
comment|// effect of this is that, when the source object is not already of the target
comment|// type, the compiler will first seek a way to convert the source object to the
comment|// target type, and only then attempt to copy the resulting object. This means
comment|// that when passing an OwningResult where an OwningPtr is expected, the
comment|// compiler will first seek a conversion from OwningResult to OwningPtr, then
comment|// copy the OwningPtr. The resulting conversion sequence is:
comment|// OwningResult object -> ResultMover -> OwningResult argument to
comment|// OwningPtr(OwningResult) -> OwningPtr -> PtrMover -> final OwningPtr
comment|// This conversion sequence is too complex to be allowed. Thus the special
comment|// move_* functions, which help the compiler out with some explicit
comment|// conversions.
comment|// Flip this switch to measure performance impact of the smart pointers.
comment|//#define DISABLE_SMART_POINTERS
name|namespace
name|llvm
block|{
name|template
operator|<
operator|>
name|class
name|PointerLikeTypeTraits
operator|<
name|clang
operator|::
name|ActionBase
operator|*
operator|>
block|{
typedef|typedef
name|clang
operator|::
name|ActionBase
operator|*
name|PT
expr_stmt|;
name|public
operator|:
specifier|static
specifier|inline
name|void
operator|*
name|getAsVoidPointer
argument_list|(
argument|PT P
argument_list|)
block|{
return|return
name|P
return|;
block|}
specifier|static
specifier|inline
name|PT
name|getFromVoidPointer
argument_list|(
argument|void *P
argument_list|)
block|{
return|return
name|static_cast
operator|<
name|PT
operator|>
operator|(
name|P
operator|)
return|;
block|}
expr|enum
block|{
name|NumLowBitsAvailable
operator|=
literal|2
block|}
block|;   }
expr_stmt|;
block|}
end_decl_stmt

begin_decl_stmt
name|namespace
name|clang
block|{
comment|// Basic
name|class
name|DiagnosticBuilder
decl_stmt|;
comment|// Determines whether the low bit of the result pointer for the
comment|// given UID is always zero. If so, ActionResult will use that bit
comment|// for it's "invalid" flag.
name|template
operator|<
name|unsigned
name|UID
operator|>
expr|struct
name|IsResultPtrLowBitFree
block|{
specifier|static
specifier|const
name|bool
name|value
operator|=
name|false
block|;   }
expr_stmt|;
comment|/// ActionBase - A small part split from Action because of the horrible
comment|/// definition order dependencies between Action and the smart pointers.
name|class
name|ActionBase
block|{
name|public
label|:
comment|/// Out-of-line virtual destructor to provide home for this class.
name|virtual
operator|~
name|ActionBase
argument_list|()
expr_stmt|;
comment|// Types - Though these don't actually enforce strong typing, they document
comment|// what types are required to be identical for the actions.
typedef|typedef
name|OpaquePtr
operator|<
literal|0
operator|>
name|DeclPtrTy
expr_stmt|;
typedef|typedef
name|OpaquePtr
operator|<
literal|1
operator|>
name|DeclGroupPtrTy
expr_stmt|;
typedef|typedef
name|OpaquePtr
operator|<
literal|2
operator|>
name|TemplateTy
expr_stmt|;
typedef|typedef
name|void
name|AttrTy
typedef|;
typedef|typedef
name|void
name|BaseTy
typedef|;
typedef|typedef
name|void
name|MemInitTy
typedef|;
typedef|typedef
name|void
name|ExprTy
typedef|;
typedef|typedef
name|void
name|StmtTy
typedef|;
typedef|typedef
name|void
name|TemplateParamsTy
typedef|;
typedef|typedef
name|void
name|CXXScopeTy
typedef|;
typedef|typedef
name|void
name|TypeTy
typedef|;
comment|// FIXME: Change TypeTy to use OpaquePtr<N>.
comment|/// ActionResult - This structure is used while parsing/acting on
comment|/// expressions, stmts, etc.  It encapsulates both the object returned by
comment|/// the action, plus a sense of whether or not it is valid.
comment|/// When CompressInvalid is true, the "invalid" flag will be
comment|/// stored in the low bit of the Val pointer.
name|template
operator|<
name|unsigned
name|UID
operator|,
name|typename
name|PtrTy
operator|=
name|void
operator|*
operator|,
name|bool
name|CompressInvalid
operator|=
name|IsResultPtrLowBitFree
operator|<
name|UID
operator|>
operator|::
name|value
operator|>
name|class
name|ActionResult
block|{
name|PtrTy
name|Val
block|;
name|bool
name|Invalid
block|;
name|public
operator|:
name|ActionResult
argument_list|(
argument|bool Invalid = false
argument_list|)
operator|:
name|Val
argument_list|(
name|PtrTy
argument_list|()
argument_list|)
block|,
name|Invalid
argument_list|(
argument|Invalid
argument_list|)
block|{}
name|template
operator|<
name|typename
name|ActualExprTy
operator|>
name|ActionResult
argument_list|(
argument|ActualExprTy val
argument_list|)
operator|:
name|Val
argument_list|(
name|val
argument_list|)
block|,
name|Invalid
argument_list|(
argument|false
argument_list|)
block|{}
name|ActionResult
argument_list|(
specifier|const
name|DiagnosticBuilder
operator|&
argument_list|)
operator|:
name|Val
argument_list|(
name|PtrTy
argument_list|()
argument_list|)
block|,
name|Invalid
argument_list|(
argument|true
argument_list|)
block|{}
name|PtrTy
name|get
argument_list|()
specifier|const
block|{
return|return
name|Val
return|;
block|}
name|void
name|set
argument_list|(
argument|PtrTy V
argument_list|)
block|{
name|Val
operator|=
name|V
block|; }
name|bool
name|isInvalid
argument_list|()
specifier|const
block|{
return|return
name|Invalid
return|;
block|}
specifier|const
name|ActionResult
operator|&
name|operator
operator|=
operator|(
name|PtrTy
name|RHS
operator|)
block|{
name|Val
operator|=
name|RHS
block|;
name|Invalid
operator|=
name|false
block|;
return|return
operator|*
name|this
return|;
block|}
expr|}
block|;
comment|// This ActionResult partial specialization places the "invalid"
comment|// flag into the low bit of the pointer.
name|template
operator|<
name|unsigned
name|UID
block|,
name|typename
name|PtrTy
operator|>
name|class
name|ActionResult
operator|<
name|UID
block|,
name|PtrTy
block|,
name|true
operator|>
block|{
comment|// A pointer whose low bit is 1 if this result is invalid, 0
comment|// otherwise.
name|uintptr_t
name|PtrWithInvalid
block|;
typedef|typedef
name|llvm
operator|::
name|PointerLikeTypeTraits
operator|<
name|PtrTy
operator|>
name|PtrTraits
expr_stmt|;
name|public
operator|:
name|ActionResult
argument_list|(
argument|bool Invalid = false
argument_list|)
operator|:
name|PtrWithInvalid
argument_list|(
argument|static_cast<uintptr_t>(Invalid)
argument_list|)
block|{ }
name|template
operator|<
name|typename
name|ActualExprTy
operator|>
name|ActionResult
argument_list|(
argument|ActualExprTy *val
argument_list|)
block|{
name|PtrTy
name|V
argument_list|(
name|val
argument_list|)
block|;
name|void
operator|*
name|VP
operator|=
name|PtrTraits
operator|::
name|getAsVoidPointer
argument_list|(
name|V
argument_list|)
block|;
name|PtrWithInvalid
operator|=
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|VP
operator|)
block|;
name|assert
argument_list|(
operator|(
name|PtrWithInvalid
operator|&
literal|0x01
operator|)
operator|==
literal|0
operator|&&
literal|"Badly aligned pointer"
argument_list|)
block|;       }
name|ActionResult
argument_list|(
argument|PtrTy V
argument_list|)
block|{
name|void
operator|*
name|VP
operator|=
name|PtrTraits
operator|::
name|getAsVoidPointer
argument_list|(
name|V
argument_list|)
block|;
name|PtrWithInvalid
operator|=
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|VP
operator|)
block|;
name|assert
argument_list|(
operator|(
name|PtrWithInvalid
operator|&
literal|0x01
operator|)
operator|==
literal|0
operator|&&
literal|"Badly aligned pointer"
argument_list|)
block|;       }
name|ActionResult
argument_list|(
specifier|const
name|DiagnosticBuilder
operator|&
argument_list|)
operator|:
name|PtrWithInvalid
argument_list|(
literal|0x01
argument_list|)
block|{ }
name|PtrTy
name|get
argument_list|()
specifier|const
block|{
name|void
operator|*
name|VP
operator|=
name|reinterpret_cast
operator|<
name|void
operator|*
operator|>
operator|(
name|PtrWithInvalid
operator|&
operator|~
literal|0x01
operator|)
block|;
return|return
name|PtrTraits
operator|::
name|getFromVoidPointer
argument_list|(
name|VP
argument_list|)
return|;
block|}
name|void
name|set
argument_list|(
argument|PtrTy V
argument_list|)
block|{
name|void
operator|*
name|VP
operator|=
name|PtrTraits
operator|::
name|getAsVoidPointer
argument_list|(
name|V
argument_list|)
block|;
name|PtrWithInvalid
operator|=
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|VP
operator|)
block|;
name|assert
argument_list|(
operator|(
name|PtrWithInvalid
operator|&
literal|0x01
operator|)
operator|==
literal|0
operator|&&
literal|"Badly aligned pointer"
argument_list|)
block|;       }
name|bool
name|isInvalid
argument_list|()
specifier|const
block|{
return|return
name|PtrWithInvalid
operator|&
literal|0x01
return|;
block|}
specifier|const
name|ActionResult
operator|&
name|operator
operator|=
operator|(
name|PtrTy
name|RHS
operator|)
block|{
name|void
operator|*
name|VP
operator|=
name|PtrTraits
operator|::
name|getAsVoidPointer
argument_list|(
name|RHS
argument_list|)
block|;
name|PtrWithInvalid
operator|=
name|reinterpret_cast
operator|<
name|uintptr_t
operator|>
operator|(
name|VP
operator|)
block|;
name|assert
argument_list|(
operator|(
name|PtrWithInvalid
operator|&
literal|0x01
operator|)
operator|==
literal|0
operator|&&
literal|"Badly aligned pointer"
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
expr|}
block|;
comment|/// Deletion callbacks - Since the parser doesn't know the concrete types of
comment|/// the AST nodes being generated, it must do callbacks to delete objects
comment|/// when recovering from errors. These are in ActionBase because the smart
comment|/// pointers need access to them.
name|virtual
name|void
name|DeleteExpr
argument_list|(
argument|ExprTy *E
argument_list|)
block|{}
name|virtual
name|void
name|DeleteStmt
argument_list|(
argument|StmtTy *S
argument_list|)
block|{}
name|virtual
name|void
name|DeleteTemplateParams
argument_list|(
argument|TemplateParamsTy *P
argument_list|)
block|{}
block|}
expr_stmt|;
comment|/// ASTDestroyer - The type of an AST node destruction function pointer.
typedef|typedef
name|void
argument_list|(
name|ActionBase
operator|::
operator|*
name|ASTDestroyer
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
expr_stmt|;
comment|/// For the transition phase: translate from an ASTDestroyer to its
comment|/// ActionResult UID.
name|template
operator|<
name|ASTDestroyer
name|Destroyer
operator|>
expr|struct
name|DestroyerToUID
expr_stmt|;
name|template
operator|<
operator|>
expr|struct
name|DestroyerToUID
operator|<
operator|&
name|ActionBase
operator|::
name|DeleteExpr
operator|>
block|{
specifier|static
specifier|const
name|unsigned
name|UID
operator|=
literal|0
block|;   }
expr_stmt|;
name|template
operator|<
operator|>
expr|struct
name|DestroyerToUID
operator|<
operator|&
name|ActionBase
operator|::
name|DeleteStmt
operator|>
block|{
specifier|static
specifier|const
name|unsigned
name|UID
operator|=
literal|1
block|;   }
expr_stmt|;
comment|/// ASTOwningResult - A moveable smart pointer for AST nodes that also
comment|/// has an extra flag to indicate an additional success status.
name|template
operator|<
name|ASTDestroyer
name|Destroyer
operator|>
name|class
name|ASTOwningResult
expr_stmt|;
comment|/// ASTMultiPtr - A moveable smart pointer to multiple AST nodes. Only owns
comment|/// the individual pointers, not the array holding them.
name|template
operator|<
name|ASTDestroyer
name|Destroyer
operator|>
name|class
name|ASTMultiPtr
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SMART_POINTERS
argument_list|)
name|namespace
name|moving
block|{
comment|/// Move emulation helper for ASTOwningResult. NEVER EVER use this class
comment|/// directly if you don't know what you're doing.
name|template
operator|<
name|ASTDestroyer
name|Destroyer
operator|>
name|class
name|ASTResultMover
block|{
name|ASTOwningResult
operator|<
name|Destroyer
operator|>
operator|&
name|Moved
block|;
name|public
operator|:
name|ASTResultMover
argument_list|(
name|ASTOwningResult
operator|<
name|Destroyer
operator|>
operator|&
name|moved
argument_list|)
operator|:
name|Moved
argument_list|(
argument|moved
argument_list|)
block|{}
name|ASTOwningResult
operator|<
name|Destroyer
operator|>
operator|*
name|operator
operator|->
expr|(
block|)
block|{
return|return
operator|&
name|Moved
return|;
block|}
block|}
empty_stmt|;
comment|/// Move emulation helper for ASTMultiPtr. NEVER EVER use this class
comment|/// directly if you don't know what you're doing.
name|template
operator|<
name|ASTDestroyer
name|Destroyer
operator|>
name|class
name|ASTMultiMover
block|{
name|ASTMultiPtr
operator|<
name|Destroyer
operator|>
operator|&
name|Moved
block|;
name|public
operator|:
name|ASTMultiMover
argument_list|(
name|ASTMultiPtr
operator|<
name|Destroyer
operator|>
operator|&
name|moved
argument_list|)
operator|:
name|Moved
argument_list|(
argument|moved
argument_list|)
block|{}
name|ASTMultiPtr
operator|<
name|Destroyer
operator|>
operator|*
name|operator
operator|->
expr|(
block|)
block|{
return|return
operator|&
name|Moved
return|;
block|}
comment|/// Reset the moved object's internal structures.
name|void
name|release
argument_list|()
expr_stmt|;
block|}
empty_stmt|;
block|}
else|#
directive|else
comment|/// Kept only as a type-safe wrapper for a void pointer, when smart pointers
comment|/// are disabled. When they are enabled, ASTOwningResult takes over.
name|template
operator|<
name|ASTDestroyer
name|Destroyer
operator|>
name|class
name|ASTOwningPtr
block|{
name|void
operator|*
name|Node
block|;
name|public
operator|:
name|explicit
name|ASTOwningPtr
argument_list|(
name|ActionBase
operator|&
argument_list|)
operator|:
name|Node
argument_list|(
literal|0
argument_list|)
block|{}
name|ASTOwningPtr
argument_list|(
name|ActionBase
operator|&
argument_list|,
name|void
operator|*
name|node
argument_list|)
operator|:
name|Node
argument_list|(
argument|node
argument_list|)
block|{}
comment|// Normal copying operators are defined implicitly.
name|ASTOwningPtr
argument_list|(
specifier|const
name|ASTOwningResult
operator|<
name|Destroyer
operator|>
operator|&
name|o
argument_list|)
block|;
name|ASTOwningPtr
operator|&
name|operator
operator|=
operator|(
name|void
operator|*
name|raw
operator|)
block|{
name|Node
operator|=
name|raw
block|;
return|return
operator|*
name|this
return|;
block|}
comment|/// Access to the raw pointer.
name|void
operator|*
name|get
argument_list|()
specifier|const
block|{
return|return
name|Node
return|;
block|}
comment|/// Release the raw pointer.
name|void
operator|*
name|take
argument_list|()
block|{
return|return
name|Node
return|;
block|}
comment|/// Take outside ownership of the raw pointer and cast it down.
name|template
operator|<
name|typename
name|T
operator|>
name|T
operator|*
name|takeAs
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|Node
operator|)
return|;
block|}
comment|/// Alias for interface familiarity with unique_ptr.
name|void
operator|*
name|release
argument_list|()
block|{
return|return
name|take
argument_list|()
return|;
block|}
expr|}
block|;
endif|#
directive|endif
comment|// Important: There are two different implementations of
comment|// ASTOwningResult below, depending on whether
comment|// DISABLE_SMART_POINTERS is defined. If you make changes that
comment|// affect the interface, be sure to compile and test both ways!
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SMART_POINTERS
argument_list|)
name|template
operator|<
name|ASTDestroyer
name|Destroyer
operator|>
name|class
name|ASTOwningResult
block|{
name|llvm
operator|::
name|PointerIntPair
operator|<
name|ActionBase
operator|*
block|,
literal|1
block|,
name|bool
operator|>
name|ActionInv
block|;
name|void
operator|*
name|Ptr
block|;
name|friend
name|class
name|moving
operator|::
name|ASTResultMover
operator|<
name|Destroyer
operator|>
block|;
name|ASTOwningResult
argument_list|(
name|ASTOwningResult
operator|&
argument_list|)
block|;
comment|// DO NOT IMPLEMENT
name|ASTOwningResult
operator|&
name|operator
operator|=
operator|(
name|ASTOwningResult
operator|&
operator|)
block|;
comment|// DO NOT IMPLEMENT
name|void
name|destroy
argument_list|()
block|{
if|if
condition|(
name|Ptr
condition|)
block|{
name|assert
argument_list|(
name|ActionInv
operator|.
name|getPointer
argument_list|()
operator|&&
literal|"Smart pointer has node but no action."
argument_list|)
expr_stmt|;
operator|(
name|ActionInv
operator|.
name|getPointer
argument_list|()
operator|->*
name|Destroyer
operator|)
operator|(
name|Ptr
operator|)
expr_stmt|;
name|Ptr
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|public
operator|:
typedef|typedef
name|ActionBase
operator|::
name|ActionResult
operator|<
name|DestroyerToUID
operator|<
name|Destroyer
operator|>
operator|::
name|UID
operator|>
name|DumbResult
expr_stmt|;
name|explicit
name|ASTOwningResult
argument_list|(
argument|ActionBase&actions
argument_list|,
argument|bool invalid = false
argument_list|)
operator|:
name|ActionInv
argument_list|(
operator|&
name|actions
argument_list|,
name|invalid
argument_list|)
operator|,
name|Ptr
argument_list|(
literal|0
argument_list|)
block|{}
name|ASTOwningResult
argument_list|(
name|ActionBase
operator|&
name|actions
argument_list|,
name|void
operator|*
name|node
argument_list|)
operator|:
name|ActionInv
argument_list|(
operator|&
name|actions
argument_list|,
name|false
argument_list|)
block|,
name|Ptr
argument_list|(
argument|node
argument_list|)
block|{}
name|ASTOwningResult
argument_list|(
name|ActionBase
operator|&
name|actions
argument_list|,
specifier|const
name|DumbResult
operator|&
name|res
argument_list|)
operator|:
name|ActionInv
argument_list|(
operator|&
name|actions
argument_list|,
name|res
operator|.
name|isInvalid
argument_list|()
argument_list|)
block|,
name|Ptr
argument_list|(
argument|res.get()
argument_list|)
block|{}
comment|/// Move from another owning result
name|ASTOwningResult
argument_list|(
name|moving
operator|::
name|ASTResultMover
operator|<
name|Destroyer
operator|>
name|mover
argument_list|)
operator|:
name|ActionInv
argument_list|(
name|mover
operator|->
name|ActionInv
argument_list|)
block|,
name|Ptr
argument_list|(
argument|mover->Ptr
argument_list|)
block|{
name|mover
operator|->
name|Ptr
operator|=
literal|0
block|;     }
operator|~
name|ASTOwningResult
argument_list|()
block|{
name|destroy
argument_list|()
block|;     }
comment|/// Move assignment from another owning result
name|ASTOwningResult
operator|&
name|operator
operator|=
operator|(
name|moving
operator|::
name|ASTResultMover
operator|<
name|Destroyer
operator|>
name|mover
operator|)
block|{
name|destroy
argument_list|()
block|;
name|ActionInv
operator|=
name|mover
operator|->
name|ActionInv
block|;
name|Ptr
operator|=
name|mover
operator|->
name|Ptr
block|;
name|mover
operator|->
name|Ptr
operator|=
literal|0
block|;
return|return
operator|*
name|this
return|;
block|}
comment|/// Assignment from a raw pointer. Takes ownership - beware!
name|ASTOwningResult
operator|&
name|operator
operator|=
operator|(
name|void
operator|*
name|raw
operator|)
block|{
name|destroy
argument_list|()
block|;
name|Ptr
operator|=
name|raw
block|;
name|ActionInv
operator|.
name|setInt
argument_list|(
name|false
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
comment|/// Assignment from an ActionResult. Takes ownership - beware!
name|ASTOwningResult
operator|&
name|operator
operator|=
operator|(
specifier|const
name|DumbResult
operator|&
name|res
operator|)
block|{
name|destroy
argument_list|()
block|;
name|Ptr
operator|=
name|res
operator|.
name|get
argument_list|()
block|;
name|ActionInv
operator|.
name|setInt
argument_list|(
name|res
operator|.
name|isInvalid
argument_list|()
argument_list|)
block|;
return|return
operator|*
name|this
return|;
block|}
comment|/// Access to the raw pointer.
name|void
operator|*
name|get
argument_list|()
specifier|const
block|{
return|return
name|Ptr
return|;
block|}
name|bool
name|isInvalid
argument_list|()
specifier|const
block|{
return|return
name|ActionInv
operator|.
name|getInt
argument_list|()
return|;
block|}
comment|/// Does this point to a usable AST node? To be usable, the node must be
comment|/// valid and non-null.
name|bool
name|isUsable
argument_list|()
specifier|const
block|{
return|return
operator|!
name|isInvalid
argument_list|()
operator|&&
name|get
argument_list|()
return|;
block|}
comment|/// Take outside ownership of the raw pointer.
name|void
operator|*
name|take
argument_list|()
block|{
if|if
condition|(
name|isInvalid
argument_list|()
condition|)
return|return
literal|0
return|;
name|void
operator|*
name|tmp
operator|=
name|Ptr
block|;
name|Ptr
operator|=
literal|0
block|;
return|return
name|tmp
return|;
block|}
comment|/// Take outside ownership of the raw pointer and cast it down.
name|template
operator|<
name|typename
name|T
operator|>
name|T
operator|*
name|takeAs
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|take
argument_list|()
operator|)
return|;
block|}
comment|/// Alias for interface familiarity with unique_ptr.
name|void
modifier|*
name|release
parameter_list|()
block|{
return|return
name|take
argument_list|()
return|;
block|}
comment|/// Pass ownership to a classical ActionResult.
name|DumbResult
name|result
parameter_list|()
block|{
if|if
condition|(
name|isInvalid
argument_list|()
condition|)
return|return
name|true
return|;
return|return
name|take
argument_list|()
return|;
block|}
comment|/// Move hook
name|operator
name|moving
operator|::
name|ASTResultMover
operator|<
name|Destroyer
operator|>
operator|(
operator|)
block|{
return|return
name|moving
operator|::
name|ASTResultMover
operator|<
name|Destroyer
operator|>
operator|(
operator|*
name|this
operator|)
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|template
operator|<
name|ASTDestroyer
name|Destroyer
operator|>
name|class
name|ASTOwningResult
block|{
name|public
operator|:
typedef|typedef
name|ActionBase
operator|::
name|ActionResult
operator|<
name|DestroyerToUID
operator|<
name|Destroyer
operator|>
operator|::
name|UID
operator|>
name|DumbResult
expr_stmt|;
name|private
operator|:
name|DumbResult
name|Result
expr_stmt|;
end_expr_stmt

begin_label
name|public
label|:
end_label

begin_macro
name|explicit
end_macro

begin_macro
name|ASTOwningResult
argument_list|(
argument|ActionBase&actions
argument_list|,
argument|bool invalid = false
argument_list|)
end_macro

begin_macro
unit|:
name|Result
argument_list|(
argument|invalid
argument_list|)
end_macro

begin_block
block|{ }
end_block

begin_expr_stmt
name|ASTOwningResult
argument_list|(
name|ActionBase
operator|&
name|actions
argument_list|,
name|void
operator|*
name|node
argument_list|)
operator|:
name|Result
argument_list|(
argument|node
argument_list|)
block|{ }
name|ASTOwningResult
argument_list|(
name|ActionBase
operator|&
name|actions
argument_list|,
specifier|const
name|DumbResult
operator|&
name|res
argument_list|)
operator|:
name|Result
argument_list|(
argument|res
argument_list|)
block|{ }
comment|// Normal copying semantics are defined implicitly.
name|ASTOwningResult
argument_list|(
specifier|const
name|ASTOwningPtr
operator|<
name|Destroyer
operator|>
operator|&
name|o
argument_list|)
operator|:
name|Result
argument_list|(
argument|o.get()
argument_list|)
block|{ }
comment|/// Assignment from a raw pointer. Takes ownership - beware!
name|ASTOwningResult
operator|&
name|operator
operator|=
operator|(
name|void
operator|*
name|raw
operator|)
block|{
name|Result
operator|=
name|raw
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Assignment from an ActionResult. Takes ownership - beware!
end_comment

begin_decl_stmt
name|ASTOwningResult
modifier|&
name|operator
init|=
operator|(
specifier|const
name|DumbResult
operator|&
name|res
operator|)
block|{
name|Result
operator|=
name|res
block|;
return|return
operator|*
name|this
return|;
block|}
end_decl_stmt

begin_comment
comment|/// Access to the raw pointer.
end_comment

begin_expr_stmt
name|void
operator|*
name|get
argument_list|()
specifier|const
block|{
return|return
name|Result
operator|.
name|get
argument_list|()
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|bool
name|isInvalid
argument_list|()
specifier|const
block|{
return|return
name|Result
operator|.
name|isInvalid
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Does this point to a usable AST node? To be usable, the node must be
end_comment

begin_comment
comment|/// valid and non-null.
end_comment

begin_expr_stmt
name|bool
name|isUsable
argument_list|()
specifier|const
block|{
return|return
operator|!
name|Result
operator|.
name|isInvalid
argument_list|()
operator|&&
name|get
argument_list|()
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Take outside ownership of the raw pointer.
end_comment

begin_function
name|void
modifier|*
name|take
parameter_list|()
block|{
return|return
name|Result
operator|.
name|get
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/// Take outside ownership of the raw pointer and cast it down.
end_comment

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|T
operator|*
name|takeAs
argument_list|()
block|{
return|return
name|static_cast
operator|<
name|T
operator|*
operator|>
operator|(
name|take
argument_list|()
operator|)
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Alias for interface familiarity with unique_ptr.
end_comment

begin_function
name|void
modifier|*
name|release
parameter_list|()
block|{
return|return
name|take
argument_list|()
return|;
block|}
end_function

begin_comment
comment|/// Pass ownership to a classical ActionResult.
end_comment

begin_function
name|DumbResult
name|result
parameter_list|()
block|{
return|return
name|Result
return|;
block|}
end_function

begin_endif
unit|};
endif|#
directive|endif
end_endif

begin_expr_stmt
name|template
operator|<
name|ASTDestroyer
name|Destroyer
operator|>
name|class
name|ASTMultiPtr
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SMART_POINTERS
argument_list|)
name|ActionBase
operator|&
name|Actions
block|;
endif|#
directive|endif
name|void
operator|*
operator|*
name|Nodes
block|;
name|unsigned
name|Count
block|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SMART_POINTERS
argument_list|)
name|friend
name|class
name|moving
operator|::
name|ASTMultiMover
operator|<
name|Destroyer
operator|>
block|;
name|ASTMultiPtr
argument_list|(
name|ASTMultiPtr
operator|&
argument_list|)
block|;
comment|// DO NOT IMPLEMENT
comment|// Reference member prevents copy assignment.
name|void
name|destroy
argument_list|()
block|{
name|assert
argument_list|(
operator|(
name|Count
operator|==
literal|0
operator|||
name|Nodes
operator|)
operator|&&
literal|"No nodes when count is not zero."
argument_list|)
block|;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|<
name|Count
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|Nodes
index|[
name|i
index|]
condition|)
operator|(
name|Actions
operator|.*
name|Destroyer
operator|)
operator|(
name|Nodes
index|[
name|i
index|]
operator|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|public
operator|:
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SMART_POINTERS
argument_list|)
name|explicit
name|ASTMultiPtr
argument_list|(
name|ActionBase
operator|&
name|actions
argument_list|)
operator|:
name|Actions
argument_list|(
name|actions
argument_list|)
operator|,
name|Nodes
argument_list|(
literal|0
argument_list|)
operator|,
name|Count
argument_list|(
literal|0
argument_list|)
block|{}
name|ASTMultiPtr
argument_list|(
argument|ActionBase&actions
argument_list|,
argument|void **nodes
argument_list|,
argument|unsigned count
argument_list|)
operator|:
name|Actions
argument_list|(
name|actions
argument_list|)
operator|,
name|Nodes
argument_list|(
name|nodes
argument_list|)
operator|,
name|Count
argument_list|(
argument|count
argument_list|)
block|{}
comment|/// Move constructor
name|ASTMultiPtr
argument_list|(
name|moving
operator|::
name|ASTMultiMover
operator|<
name|Destroyer
operator|>
name|mover
argument_list|)
operator|:
name|Actions
argument_list|(
name|mover
operator|->
name|Actions
argument_list|)
operator|,
name|Nodes
argument_list|(
name|mover
operator|->
name|Nodes
argument_list|)
operator|,
name|Count
argument_list|(
argument|mover->Count
argument_list|)
block|{
name|mover
operator|.
name|release
argument_list|()
block|;     }
else|#
directive|else
comment|// Normal copying implicitly defined
name|explicit
name|ASTMultiPtr
argument_list|(
name|ActionBase
operator|&
argument_list|)
operator|:
name|Nodes
argument_list|(
literal|0
argument_list|)
operator|,
name|Count
argument_list|(
literal|0
argument_list|)
block|{}
name|ASTMultiPtr
argument_list|(
argument|ActionBase&
argument_list|,
argument|void **nodes
argument_list|,
argument|unsigned count
argument_list|)
operator|:
name|Nodes
argument_list|(
name|nodes
argument_list|)
operator|,
name|Count
argument_list|(
argument|count
argument_list|)
block|{}
comment|// Fake mover in Parse/AstGuard.h needs this:
name|ASTMultiPtr
argument_list|(
argument|void **nodes
argument_list|,
argument|unsigned count
argument_list|)
operator|:
name|Nodes
argument_list|(
name|nodes
argument_list|)
operator|,
name|Count
argument_list|(
argument|count
argument_list|)
block|{}
endif|#
directive|endif
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SMART_POINTERS
argument_list|)
comment|/// Move assignment
name|ASTMultiPtr
operator|&
name|operator
operator|=
operator|(
name|moving
operator|::
name|ASTMultiMover
operator|<
name|Destroyer
operator|>
name|mover
operator|)
block|{
name|destroy
argument_list|()
block|;
name|Nodes
operator|=
name|mover
operator|->
name|Nodes
block|;
name|Count
operator|=
name|mover
operator|->
name|Count
block|;
name|mover
operator|.
name|release
argument_list|()
block|;
return|return
operator|*
name|this
return|;
block|}
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/// Access to the raw pointers.
end_comment

begin_expr_stmt
name|void
operator|*
operator|*
name|get
argument_list|()
specifier|const
block|{
return|return
name|Nodes
return|;
block|}
end_expr_stmt

begin_comment
comment|/// Access to the count.
end_comment

begin_expr_stmt
name|unsigned
name|size
argument_list|()
specifier|const
block|{
return|return
name|Count
return|;
block|}
end_expr_stmt

begin_function
name|void
modifier|*
modifier|*
name|release
parameter_list|()
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SMART_POINTERS
argument_list|)
name|void
modifier|*
modifier|*
name|tmp
init|=
name|Nodes
decl_stmt|;
name|Nodes
operator|=
literal|0
expr_stmt|;
name|Count
operator|=
literal|0
expr_stmt|;
return|return
name|tmp
return|;
else|#
directive|else
return|return
name|Nodes
return|;
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SMART_POINTERS
argument_list|)
end_if

begin_comment
comment|/// Move hook
end_comment

begin_expr_stmt
name|operator
name|moving
operator|::
name|ASTMultiMover
operator|<
name|Destroyer
operator|>
operator|(
operator|)
block|{
return|return
name|moving
operator|::
name|ASTMultiMover
operator|<
name|Destroyer
operator|>
operator|(
operator|*
name|this
operator|)
return|;
block|}
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
unit|};
name|class
name|ASTTemplateArgsPtr
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SMART_POINTERS
argument_list|)
name|ActionBase
modifier|&
name|Actions
decl_stmt|;
endif|#
directive|endif
name|void
modifier|*
modifier|*
name|Args
decl_stmt|;
name|bool
modifier|*
name|ArgIsType
decl_stmt|;
name|mutable
name|unsigned
name|Count
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SMART_POINTERS
argument_list|)
name|void
name|destroy
parameter_list|()
block|{
if|if
condition|(
operator|!
name|Count
condition|)
return|return;
for|for
control|(
name|unsigned
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|Count
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|Args
index|[
name|i
index|]
operator|&&
operator|!
name|ArgIsType
index|[
name|i
index|]
condition|)
name|Actions
operator|.
name|DeleteExpr
argument_list|(
operator|(
name|ActionBase
operator|::
name|ExprTy
operator|*
operator|)
name|Args
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|Count
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|public
label|:
name|ASTTemplateArgsPtr
argument_list|(
argument|ActionBase&actions
argument_list|,
argument|void **args
argument_list|,
argument|bool *argIsType
argument_list|,
argument|unsigned count
argument_list|)
block|:
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SMART_POINTERS
argument_list|)
name|Actions
argument_list|(
name|actions
argument_list|)
operator|,
endif|#
directive|endif
name|Args
argument_list|(
name|args
argument_list|)
operator|,
name|ArgIsType
argument_list|(
name|argIsType
argument_list|)
operator|,
name|Count
argument_list|(
argument|count
argument_list|)
block|{ }
comment|// FIXME: Lame, not-fully-type-safe emulation of 'move semantics'.
name|ASTTemplateArgsPtr
argument_list|(
name|ASTTemplateArgsPtr
operator|&
name|Other
argument_list|)
operator|:
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SMART_POINTERS
argument_list|)
name|Actions
argument_list|(
name|Other
operator|.
name|Actions
argument_list|)
operator|,
endif|#
directive|endif
name|Args
argument_list|(
name|Other
operator|.
name|Args
argument_list|)
operator|,
name|ArgIsType
argument_list|(
name|Other
operator|.
name|ArgIsType
argument_list|)
operator|,
name|Count
argument_list|(
argument|Other.Count
argument_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SMART_POINTERS
argument_list|)
name|Other
operator|.
name|Count
operator|=
literal|0
block|;
endif|#
directive|endif
block|}
comment|// FIXME: Lame, not-fully-type-safe emulation of 'move semantics'.
name|ASTTemplateArgsPtr
operator|&
name|operator
operator|=
operator|(
name|ASTTemplateArgsPtr
operator|&
name|Other
operator|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SMART_POINTERS
argument_list|)
name|Actions
operator|=
name|Other
operator|.
name|Actions
block|;
endif|#
directive|endif
name|Args
operator|=
name|Other
operator|.
name|Args
block|;
name|ArgIsType
operator|=
name|Other
operator|.
name|ArgIsType
block|;
name|Count
operator|=
name|Other
operator|.
name|Count
block|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SMART_POINTERS
argument_list|)
name|Other
operator|.
name|Count
operator|=
literal|0
block|;
endif|#
directive|endif
return|return
operator|*
name|this
return|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SMART_POINTERS
argument_list|)
operator|~
name|ASTTemplateArgsPtr
argument_list|()
block|{
name|destroy
argument_list|()
block|; }
endif|#
directive|endif
name|void
operator|*
operator|*
name|getArgs
argument_list|()
specifier|const
block|{
return|return
name|Args
return|;
block|}
name|bool
operator|*
name|getArgIsType
argument_list|()
specifier|const
block|{
return|return
name|ArgIsType
return|;
block|}
name|unsigned
name|size
argument_list|()
specifier|const
block|{
return|return
name|Count
return|;
block|}
name|void
name|reset
parameter_list|(
name|void
modifier|*
modifier|*
name|args
parameter_list|,
name|bool
modifier|*
name|argIsType
parameter_list|,
name|unsigned
name|count
parameter_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SMART_POINTERS
argument_list|)
name|destroy
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|Args
operator|=
name|args
expr_stmt|;
name|ArgIsType
operator|=
name|argIsType
expr_stmt|;
name|Count
operator|=
name|count
expr_stmt|;
block|}
name|void
modifier|*
name|operator
index|[]
argument_list|(
name|unsigned
name|Arg
argument_list|)
decl|const
block|{
return|return
name|Args
index|[
name|Arg
index|]
return|;
block|}
name|void
operator|*
operator|*
name|release
argument_list|()
specifier|const
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SMART_POINTERS
argument_list|)
name|Count
operator|=
literal|0
block|;
endif|#
directive|endif
return|return
name|Args
return|;
block|}
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_comment
comment|/// \brief A small vector that owns a set of AST nodes.
end_comment

begin_expr_stmt
name|template
operator|<
name|ASTDestroyer
name|Destroyer
operator|,
name|unsigned
name|N
operator|=
literal|8
operator|>
name|class
name|ASTOwningVector
operator|:
name|public
name|llvm
operator|::
name|SmallVector
operator|<
name|void
operator|*
operator|,
name|N
operator|>
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SMART_POINTERS
argument_list|)
name|ActionBase
operator|&
name|Actions
block|;
name|bool
name|Owned
block|;
endif|#
directive|endif
name|ASTOwningVector
argument_list|(
name|ASTOwningVector
operator|&
argument_list|)
block|;
comment|// do not implement
name|ASTOwningVector
operator|&
name|operator
operator|=
operator|(
name|ASTOwningVector
operator|&
operator|)
block|;
comment|// do not implement
name|public
operator|:
name|explicit
name|ASTOwningVector
argument_list|(
name|ActionBase
operator|&
name|Actions
argument_list|)
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SMART_POINTERS
argument_list|)
operator|:
name|Actions
argument_list|(
name|Actions
argument_list|)
block|,
name|Owned
argument_list|(
argument|true
argument_list|)
endif|#
directive|endif
block|{ }
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SMART_POINTERS
argument_list|)
operator|~
name|ASTOwningVector
argument_list|()
block|{
if|if
condition|(
operator|!
name|Owned
condition|)
return|return;
for|for
control|(
name|unsigned
name|I
init|=
literal|0
init|,
name|Last
init|=
name|this
operator|->
name|size
argument_list|()
init|;
name|I
operator|!=
name|Last
condition|;
operator|++
name|I
control|)
operator|(
name|Actions
operator|.*
name|Destroyer
operator|)
operator|(
operator|(
operator|*
name|this
operator|)
index|[
name|I
index|]
operator|)
expr_stmt|;
block|}
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
modifier|*
modifier|*
name|take
parameter_list|()
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SMART_POINTERS
argument_list|)
name|Owned
operator|=
name|false
expr_stmt|;
endif|#
directive|endif
return|return
operator|&
name|this
operator|->
name|front
argument_list|()
return|;
block|}
end_function

begin_expr_stmt
name|template
operator|<
name|typename
name|T
operator|>
name|T
operator|*
operator|*
name|takeAs
argument_list|()
block|{
return|return
operator|(
name|T
operator|*
operator|*
operator|)
name|take
argument_list|()
return|;
block|}
end_expr_stmt

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SMART_POINTERS
argument_list|)
end_if

begin_expr_stmt
name|ActionBase
operator|&
name|getActions
argument_list|()
specifier|const
block|{
return|return
name|Actions
return|;
block|}
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
unit|};
comment|/// A SmallVector of statements, with stack size 32 (as that is the only one
end_comment

begin_comment
comment|/// used.)
end_comment

begin_typedef
typedef|typedef
name|ASTOwningVector
operator|<
operator|&
name|ActionBase
operator|::
name|DeleteStmt
operator|,
literal|32
operator|>
name|StmtVector
expr_stmt|;
end_typedef

begin_comment
comment|/// A SmallVector of expressions, with stack size 12 (the maximum used.)
end_comment

begin_typedef
typedef|typedef
name|ASTOwningVector
operator|<
operator|&
name|ActionBase
operator|::
name|DeleteExpr
operator|,
literal|12
operator|>
name|ExprVector
expr_stmt|;
end_typedef

begin_expr_stmt
name|template
operator|<
name|ASTDestroyer
name|Destroyer
operator|,
name|unsigned
name|N
operator|>
specifier|inline
name|ASTMultiPtr
operator|<
name|Destroyer
operator|>
name|move_arg
argument_list|(
argument|ASTOwningVector<Destroyer
argument_list|,
argument|N>&vec
argument_list|)
block|{
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SMART_POINTERS
argument_list|)
return|return
name|ASTMultiPtr
operator|<
name|Destroyer
operator|>
operator|(
name|vec
operator|.
name|getActions
argument_list|()
operator|,
name|vec
operator|.
name|take
argument_list|()
operator|,
name|vec
operator|.
name|size
argument_list|()
operator|)
return|;
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_return
return|return
name|ASTMultiPtr
operator|<
name|Destroyer
operator|>
operator|(
name|vec
operator|.
name|take
argument_list|()
operator|,
name|vec
operator|.
name|size
argument_list|()
operator|)
return|;
end_return

begin_endif
endif|#
directive|endif
end_endif

begin_if
unit|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|DISABLE_SMART_POINTERS
argument_list|)
end_if

begin_comment
comment|// Out-of-line implementations due to definition dependencies
end_comment

begin_expr_stmt
unit|template
operator|<
name|ASTDestroyer
name|Destroyer
operator|>
specifier|inline
name|void
name|moving
operator|::
name|ASTMultiMover
operator|<
name|Destroyer
operator|>
operator|::
name|release
argument_list|()
block|{
name|Moved
operator|.
name|Nodes
operator|=
literal|0
block|;
name|Moved
operator|.
name|Count
operator|=
literal|0
block|;   }
comment|// Move overloads.
name|template
operator|<
name|ASTDestroyer
name|Destroyer
operator|>
specifier|inline
name|ASTOwningResult
operator|<
name|Destroyer
operator|>
name|move
argument_list|(
argument|ASTOwningResult<Destroyer>&ptr
argument_list|)
block|{
return|return
name|ASTOwningResult
operator|<
name|Destroyer
operator|>
operator|(
name|moving
operator|::
name|ASTResultMover
operator|<
name|Destroyer
operator|>
operator|(
name|ptr
operator|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|ASTDestroyer
name|Destroyer
operator|>
specifier|inline
name|ASTMultiPtr
operator|<
name|Destroyer
operator|>
name|move
argument_list|(
argument|ASTMultiPtr<Destroyer>&ptr
argument_list|)
block|{
return|return
name|ASTMultiPtr
operator|<
name|Destroyer
operator|>
operator|(
name|moving
operator|::
name|ASTMultiMover
operator|<
name|Destroyer
operator|>
operator|(
name|ptr
operator|)
operator|)
return|;
block|}
end_expr_stmt

begin_else
else|#
directive|else
end_else

begin_expr_stmt
name|template
operator|<
name|ASTDestroyer
name|Destroyer
operator|>
specifier|inline
name|ASTOwningPtr
operator|<
name|Destroyer
operator|>
operator|::
name|ASTOwningPtr
argument_list|(
specifier|const
name|ASTOwningResult
operator|<
name|Destroyer
operator|>
operator|&
name|o
argument_list|)
operator|:
name|Node
argument_list|(
argument|o.get()
argument_list|)
block|{}
comment|// These versions are hopefully no-ops.
name|template
operator|<
name|ASTDestroyer
name|Destroyer
operator|>
specifier|inline
name|ASTOwningResult
operator|<
name|Destroyer
operator|>
operator|&
name|move
argument_list|(
argument|ASTOwningResult<Destroyer>&ptr
argument_list|)
block|{
return|return
name|ptr
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|ASTDestroyer
name|Destroyer
operator|>
specifier|inline
name|ASTOwningPtr
operator|<
name|Destroyer
operator|>
operator|&
name|move
argument_list|(
argument|ASTOwningPtr<Destroyer>&ptr
argument_list|)
block|{
return|return
name|ptr
return|;
block|}
end_expr_stmt

begin_expr_stmt
name|template
operator|<
name|ASTDestroyer
name|Destroyer
operator|>
specifier|inline
name|ASTMultiPtr
operator|<
name|Destroyer
operator|>
operator|&
name|move
argument_list|(
argument|ASTMultiPtr<Destroyer>&ptr
argument_list|)
block|{
return|return
name|ptr
return|;
block|}
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
unit|}
endif|#
directive|endif
end_endif

end_unit

