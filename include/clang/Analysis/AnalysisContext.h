begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//=== AnalysisContext.h - Analysis context for Path Sens analysis --*- C++ -*-//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file defines AnalysisContext, a class that manages the analysis context
end_comment

begin_comment
comment|// data for path sensitive analysis.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_ANALYSIS_ANALYSISCONTEXT_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_ANALYSIS_ANALYSISCONTEXT_H
end_define

begin_include
include|#
directive|include
file|"clang/AST/Decl.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/OwningPtr.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/FoldingSet.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/PointerUnion.h"
end_include

begin_include
include|#
directive|include
file|"llvm/ADT/DenseMap.h"
end_include

begin_include
include|#
directive|include
file|"llvm/Support/Allocator.h"
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|Decl
decl_stmt|;
name|class
name|Stmt
decl_stmt|;
name|class
name|CFG
decl_stmt|;
name|class
name|CFGBlock
decl_stmt|;
name|class
name|LiveVariables
decl_stmt|;
name|class
name|ParentMap
decl_stmt|;
name|class
name|ImplicitParamDecl
decl_stmt|;
name|class
name|LocationContextManager
decl_stmt|;
name|class
name|StackFrameContext
decl_stmt|;
comment|/// AnalysisContext contains the context data for the function or method under
comment|/// analysis.
name|class
name|AnalysisContext
block|{
specifier|const
name|Decl
modifier|*
name|D
decl_stmt|;
comment|// AnalysisContext owns the following data.
name|CFG
modifier|*
name|cfg
decl_stmt|;
name|bool
name|builtCFG
decl_stmt|;
name|LiveVariables
modifier|*
name|liveness
decl_stmt|;
name|ParentMap
modifier|*
name|PM
decl_stmt|;
name|llvm
operator|::
name|DenseMap
operator|<
specifier|const
name|BlockDecl
operator|*
operator|,
name|void
operator|*
operator|>
operator|*
name|ReferencedBlockVars
expr_stmt|;
name|llvm
operator|::
name|BumpPtrAllocator
name|A
expr_stmt|;
name|bool
name|AddEHEdges
decl_stmt|;
name|public
label|:
name|AnalysisContext
argument_list|(
argument|const Decl *d
argument_list|,
argument|bool addehedges = false
argument_list|)
block|:
name|D
argument_list|(
name|d
argument_list|)
operator|,
name|cfg
argument_list|(
literal|0
argument_list|)
operator|,
name|builtCFG
argument_list|(
name|false
argument_list|)
operator|,
name|liveness
argument_list|(
literal|0
argument_list|)
operator|,
name|PM
argument_list|(
literal|0
argument_list|)
operator|,
name|ReferencedBlockVars
argument_list|(
literal|0
argument_list|)
operator|,
name|AddEHEdges
argument_list|(
argument|addehedges
argument_list|)
block|{}
operator|~
name|AnalysisContext
argument_list|()
expr_stmt|;
name|ASTContext
modifier|&
name|getASTContext
parameter_list|()
block|{
return|return
name|D
operator|->
name|getASTContext
argument_list|()
return|;
block|}
specifier|const
name|Decl
modifier|*
name|getDecl
parameter_list|()
block|{
return|return
name|D
return|;
block|}
comment|/// getAddEHEdges - Return true iff we are adding exceptional edges from
comment|/// callExprs.  If this is false, then try/catch statements and blocks
comment|/// reachable from them can appear to be dead in the CFG, analysis passes must
comment|/// cope with that.
name|bool
name|getAddEHEdges
argument_list|()
specifier|const
block|{
return|return
name|AddEHEdges
return|;
block|}
name|Stmt
modifier|*
name|getBody
parameter_list|()
function_decl|;
name|CFG
modifier|*
name|getCFG
parameter_list|()
function_decl|;
name|ParentMap
modifier|&
name|getParentMap
parameter_list|()
function_decl|;
name|LiveVariables
modifier|*
name|getLiveVariables
parameter_list|()
function_decl|;
typedef|typedef
specifier|const
name|VarDecl
modifier|*
specifier|const
modifier|*
name|referenced_decls_iterator
typedef|;
name|std
operator|::
name|pair
operator|<
name|referenced_decls_iterator
operator|,
name|referenced_decls_iterator
operator|>
name|getReferencedBlockVars
argument_list|(
specifier|const
name|BlockDecl
operator|*
name|BD
argument_list|)
expr_stmt|;
comment|/// Return the ImplicitParamDecl* associated with 'self' if this
comment|/// AnalysisContext wraps an ObjCMethodDecl.  Returns NULL otherwise.
specifier|const
name|ImplicitParamDecl
operator|*
name|getSelfDecl
argument_list|()
specifier|const
expr_stmt|;
block|}
empty_stmt|;
name|class
name|AnalysisContextManager
block|{
typedef|typedef
name|llvm
operator|::
name|DenseMap
operator|<
specifier|const
name|Decl
operator|*
operator|,
name|AnalysisContext
operator|*
operator|>
name|ContextMap
expr_stmt|;
name|ContextMap
name|Contexts
decl_stmt|;
name|public
label|:
operator|~
name|AnalysisContextManager
argument_list|()
expr_stmt|;
name|AnalysisContext
modifier|*
name|getContext
parameter_list|(
specifier|const
name|Decl
modifier|*
name|D
parameter_list|)
function_decl|;
comment|// Discard all previously created AnalysisContexts.
name|void
name|clear
parameter_list|()
function_decl|;
block|}
empty_stmt|;
name|class
name|LocationContext
range|:
name|public
name|llvm
operator|::
name|FoldingSetNode
block|{
name|public
operator|:
expr|enum
name|ContextKind
block|{
name|StackFrame
block|,
name|Scope
block|,
name|Block
block|}
block|;
name|private
operator|:
name|ContextKind
name|Kind
block|;
name|AnalysisContext
operator|*
name|Ctx
block|;
specifier|const
name|LocationContext
operator|*
name|Parent
block|;
name|protected
operator|:
name|LocationContext
argument_list|(
argument|ContextKind k
argument_list|,
argument|AnalysisContext *ctx
argument_list|,
argument|const LocationContext *parent
argument_list|)
operator|:
name|Kind
argument_list|(
name|k
argument_list|)
block|,
name|Ctx
argument_list|(
name|ctx
argument_list|)
block|,
name|Parent
argument_list|(
argument|parent
argument_list|)
block|{}
name|public
operator|:
name|virtual
operator|~
name|LocationContext
argument_list|()
block|;
name|ContextKind
name|getKind
argument_list|()
specifier|const
block|{
return|return
name|Kind
return|;
block|}
name|AnalysisContext
operator|*
name|getAnalysisContext
argument_list|()
specifier|const
block|{
return|return
name|Ctx
return|;
block|}
specifier|const
name|LocationContext
operator|*
name|getParent
argument_list|()
specifier|const
block|{
return|return
name|Parent
return|;
block|}
name|bool
name|isParentOf
argument_list|(
argument|const LocationContext *LC
argument_list|)
specifier|const
block|;
specifier|const
name|Decl
operator|*
name|getDecl
argument_list|()
specifier|const
block|{
return|return
name|getAnalysisContext
argument_list|()
operator|->
name|getDecl
argument_list|()
return|;
block|}
name|CFG
operator|*
name|getCFG
argument_list|()
specifier|const
block|{
return|return
name|getAnalysisContext
argument_list|()
operator|->
name|getCFG
argument_list|()
return|;
block|}
name|LiveVariables
operator|*
name|getLiveVariables
argument_list|()
specifier|const
block|{
return|return
name|getAnalysisContext
argument_list|()
operator|->
name|getLiveVariables
argument_list|()
return|;
block|}
name|ParentMap
operator|&
name|getParentMap
argument_list|()
specifier|const
block|{
return|return
name|getAnalysisContext
argument_list|()
operator|->
name|getParentMap
argument_list|()
return|;
block|}
specifier|const
name|ImplicitParamDecl
operator|*
name|getSelfDecl
argument_list|()
specifier|const
block|{
return|return
name|Ctx
operator|->
name|getSelfDecl
argument_list|()
return|;
block|}
specifier|const
name|StackFrameContext
operator|*
name|getCurrentStackFrame
argument_list|()
specifier|const
block|;
specifier|const
name|StackFrameContext
operator|*
name|getStackFrameForDeclContext
argument_list|(
argument|const DeclContext *DC
argument_list|)
specifier|const
block|;
name|virtual
name|void
name|Profile
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|)
operator|=
literal|0
block|;
specifier|static
name|bool
name|classof
argument_list|(
argument|const LocationContext*
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|public
operator|:
specifier|static
name|void
name|ProfileCommon
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|,
argument|ContextKind ck
argument_list|,
argument|AnalysisContext *ctx
argument_list|,
argument|const LocationContext *parent
argument_list|,
argument|const void* data
argument_list|)
block|; }
decl_stmt|;
name|class
name|StackFrameContext
range|:
name|public
name|LocationContext
block|{
comment|// The callsite where this stack frame is established.
specifier|const
name|Stmt
operator|*
name|CallSite
block|;
comment|// The parent block of the callsite.
specifier|const
name|CFGBlock
operator|*
name|Block
block|;
comment|// The index of the callsite in the CFGBlock.
name|unsigned
name|Index
block|;
name|friend
name|class
name|LocationContextManager
block|;
name|StackFrameContext
argument_list|(
argument|AnalysisContext *ctx
argument_list|,
argument|const LocationContext *parent
argument_list|,
argument|const Stmt *s
argument_list|,
argument|const CFGBlock *blk
argument_list|,
argument|unsigned idx
argument_list|)
operator|:
name|LocationContext
argument_list|(
name|StackFrame
argument_list|,
name|ctx
argument_list|,
name|parent
argument_list|)
block|,
name|CallSite
argument_list|(
name|s
argument_list|)
block|,
name|Block
argument_list|(
name|blk
argument_list|)
block|,
name|Index
argument_list|(
argument|idx
argument_list|)
block|{}
name|public
operator|:
operator|~
name|StackFrameContext
argument_list|()
block|{}
specifier|const
name|Stmt
operator|*
name|getCallSite
argument_list|()
specifier|const
block|{
return|return
name|CallSite
return|;
block|}
specifier|const
name|CFGBlock
operator|*
name|getCallSiteBlock
argument_list|()
specifier|const
block|{
return|return
name|Block
return|;
block|}
name|unsigned
name|getIndex
argument_list|()
specifier|const
block|{
return|return
name|Index
return|;
block|}
name|void
name|Profile
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|)
block|;
specifier|static
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|,
argument|AnalysisContext *ctx
argument_list|,
argument|const LocationContext *parent
argument_list|,
argument|const Stmt *s
argument_list|,
argument|const CFGBlock *blk
argument_list|,
argument|unsigned idx
argument_list|)
block|{
name|ProfileCommon
argument_list|(
name|ID
argument_list|,
name|StackFrame
argument_list|,
name|ctx
argument_list|,
name|parent
argument_list|,
name|s
argument_list|)
block|;
name|ID
operator|.
name|AddPointer
argument_list|(
name|blk
argument_list|)
block|;
name|ID
operator|.
name|AddInteger
argument_list|(
name|idx
argument_list|)
block|;   }
specifier|static
name|bool
name|classof
argument_list|(
argument|const LocationContext* Ctx
argument_list|)
block|{
return|return
name|Ctx
operator|->
name|getKind
argument_list|()
operator|==
name|StackFrame
return|;
block|}
expr|}
block|;
name|class
name|ScopeContext
operator|:
name|public
name|LocationContext
block|{
specifier|const
name|Stmt
operator|*
name|Enter
block|;
name|friend
name|class
name|LocationContextManager
block|;
name|ScopeContext
argument_list|(
name|AnalysisContext
operator|*
name|ctx
argument_list|,
specifier|const
name|LocationContext
operator|*
name|parent
argument_list|,
specifier|const
name|Stmt
operator|*
name|s
argument_list|)
operator|:
name|LocationContext
argument_list|(
name|Scope
argument_list|,
name|ctx
argument_list|,
name|parent
argument_list|)
block|,
name|Enter
argument_list|(
argument|s
argument_list|)
block|{}
name|public
operator|:
operator|~
name|ScopeContext
argument_list|()
block|{}
name|void
name|Profile
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|)
block|;
specifier|static
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|,
argument|AnalysisContext *ctx
argument_list|,
argument|const LocationContext *parent
argument_list|,
argument|const Stmt *s
argument_list|)
block|{
name|ProfileCommon
argument_list|(
name|ID
argument_list|,
name|Scope
argument_list|,
name|ctx
argument_list|,
name|parent
argument_list|,
name|s
argument_list|)
block|;   }
specifier|static
name|bool
name|classof
argument_list|(
argument|const LocationContext* Ctx
argument_list|)
block|{
return|return
name|Ctx
operator|->
name|getKind
argument_list|()
operator|==
name|Scope
return|;
block|}
expr|}
block|;
name|class
name|BlockInvocationContext
operator|:
name|public
name|LocationContext
block|{
comment|// FIXME: Add back context-sensivity (we don't want libAnalysis to know
comment|//  about MemRegion).
specifier|const
name|BlockDecl
operator|*
name|BD
block|;
name|friend
name|class
name|LocationContextManager
block|;
name|BlockInvocationContext
argument_list|(
name|AnalysisContext
operator|*
name|ctx
argument_list|,
specifier|const
name|LocationContext
operator|*
name|parent
argument_list|,
specifier|const
name|BlockDecl
operator|*
name|bd
argument_list|)
operator|:
name|LocationContext
argument_list|(
name|Block
argument_list|,
name|ctx
argument_list|,
name|parent
argument_list|)
block|,
name|BD
argument_list|(
argument|bd
argument_list|)
block|{}
name|public
operator|:
operator|~
name|BlockInvocationContext
argument_list|()
block|{}
specifier|const
name|BlockDecl
operator|*
name|getBlockDecl
argument_list|()
specifier|const
block|{
return|return
name|BD
return|;
block|}
name|void
name|Profile
argument_list|(
name|llvm
operator|::
name|FoldingSetNodeID
operator|&
name|ID
argument_list|)
block|;
specifier|static
name|void
name|Profile
argument_list|(
argument|llvm::FoldingSetNodeID&ID
argument_list|,
argument|AnalysisContext *ctx
argument_list|,
argument|const LocationContext *parent
argument_list|,
argument|const BlockDecl *bd
argument_list|)
block|{
name|ProfileCommon
argument_list|(
name|ID
argument_list|,
name|Block
argument_list|,
name|ctx
argument_list|,
name|parent
argument_list|,
name|bd
argument_list|)
block|;   }
specifier|static
name|bool
name|classof
argument_list|(
argument|const LocationContext* Ctx
argument_list|)
block|{
return|return
name|Ctx
operator|->
name|getKind
argument_list|()
operator|==
name|Block
return|;
block|}
expr|}
block|;
name|class
name|LocationContextManager
block|{
name|llvm
operator|::
name|FoldingSet
operator|<
name|LocationContext
operator|>
name|Contexts
block|;
name|public
operator|:
operator|~
name|LocationContextManager
argument_list|()
block|;
specifier|const
name|StackFrameContext
operator|*
name|getStackFrame
argument_list|(
argument|AnalysisContext *ctx
argument_list|,
argument|const LocationContext *parent
argument_list|,
argument|const Stmt *s
argument_list|,
argument|const CFGBlock *blk
argument_list|,
argument|unsigned idx
argument_list|)
block|;
specifier|const
name|ScopeContext
operator|*
name|getScope
argument_list|(
name|AnalysisContext
operator|*
name|ctx
argument_list|,
specifier|const
name|LocationContext
operator|*
name|parent
argument_list|,
specifier|const
name|Stmt
operator|*
name|s
argument_list|)
block|;
comment|/// Discard all previously created LocationContext objects.
name|void
name|clear
argument_list|()
block|;
name|private
operator|:
name|template
operator|<
name|typename
name|LOC
block|,
name|typename
name|DATA
operator|>
specifier|const
name|LOC
operator|*
name|getLocationContext
argument_list|(
name|AnalysisContext
operator|*
name|ctx
argument_list|,
specifier|const
name|LocationContext
operator|*
name|parent
argument_list|,
specifier|const
name|DATA
operator|*
name|d
argument_list|)
block|; }
block|;  }
end_decl_stmt

begin_comment
comment|// end clang namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

