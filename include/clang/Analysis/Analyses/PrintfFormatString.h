begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|//==- PrintfFormatStrings.h - Analysis of printf format strings --*- C++ -*-==//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//                     The LLVM Compiler Infrastructure
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This file is distributed under the University of Illinois Open Source
end_comment

begin_comment
comment|// License. See LICENSE.TXT for details.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Handling of format string in printf and friends.  The structure of format
end_comment

begin_comment
comment|// strings for fprintf() are described in C99 7.19.6.1.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|//===----------------------------------------------------------------------===//
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|LLVM_CLANG_FPRINTF_FORMAT_H
end_ifndef

begin_define
define|#
directive|define
name|LLVM_CLANG_FPRINTF_FORMAT_H
end_define

begin_include
include|#
directive|include
file|"clang/AST/CanonicalType.h"
end_include

begin_decl_stmt
name|namespace
name|clang
block|{
name|class
name|ASTContext
decl_stmt|;
name|namespace
name|analyze_printf
block|{
name|class
name|ArgTypeResult
block|{
name|public
label|:
enum|enum
name|Kind
block|{
name|UnknownTy
block|,
name|InvalidTy
block|,
name|SpecificTy
block|,
name|ObjCPointerTy
block|,
name|CPointerTy
block|,
name|CStrTy
block|,
name|WCStrTy
block|}
enum|;
name|private
label|:
specifier|const
name|Kind
name|K
decl_stmt|;
name|QualType
name|T
decl_stmt|;
name|ArgTypeResult
argument_list|(
name|bool
argument_list|)
operator|:
name|K
argument_list|(
argument|InvalidTy
argument_list|)
block|{}
name|public
operator|:
name|ArgTypeResult
argument_list|(
argument|Kind k = UnknownTy
argument_list|)
operator|:
name|K
argument_list|(
argument|k
argument_list|)
block|{}
name|ArgTypeResult
argument_list|(
argument|QualType t
argument_list|)
operator|:
name|K
argument_list|(
name|SpecificTy
argument_list|)
operator|,
name|T
argument_list|(
argument|t
argument_list|)
block|{}
name|ArgTypeResult
argument_list|(
argument|CanQualType t
argument_list|)
operator|:
name|K
argument_list|(
name|SpecificTy
argument_list|)
operator|,
name|T
argument_list|(
argument|t
argument_list|)
block|{}
specifier|static
name|ArgTypeResult
name|Invalid
argument_list|()
block|{
return|return
name|ArgTypeResult
argument_list|(
name|true
argument_list|)
return|;
block|}
name|bool
name|isValid
argument_list|()
specifier|const
block|{
return|return
name|K
operator|!=
name|InvalidTy
return|;
block|}
specifier|const
name|QualType
operator|*
name|getSpecificType
argument_list|()
specifier|const
block|{
return|return
name|K
operator|==
name|SpecificTy
operator|?
operator|&
name|T
operator|:
literal|0
return|;
block|}
name|bool
name|matchesType
argument_list|(
name|ASTContext
operator|&
name|C
argument_list|,
name|QualType
name|argTy
argument_list|)
decl|const
decl_stmt|;
name|bool
name|matchesAnyObjCObjectRef
argument_list|()
specifier|const
block|{
return|return
name|K
operator|==
name|ObjCPointerTy
return|;
block|}
name|QualType
name|getRepresentativeType
argument_list|(
name|ASTContext
operator|&
name|C
argument_list|)
decl|const
decl_stmt|;
block|}
empty_stmt|;
name|class
name|ConversionSpecifier
block|{
name|public
label|:
enum|enum
name|Kind
block|{
name|InvalidSpecifier
init|=
literal|0
block|,
comment|// C99 conversion specifiers.
name|dArg
block|,
comment|// 'd'
name|IntAsCharArg
block|,
comment|// 'c'
name|iArg
block|,
comment|// 'i',
name|oArg
block|,
comment|// 'o',
name|uArg
block|,
comment|// 'u',
name|xArg
block|,
comment|// 'x',
name|XArg
block|,
comment|// 'X',
name|fArg
block|,
comment|// 'f',
name|FArg
block|,
comment|// 'F',
name|eArg
block|,
comment|// 'e',
name|EArg
block|,
comment|// 'E',
name|gArg
block|,
comment|// 'g',
name|GArg
block|,
comment|// 'G',
name|aArg
block|,
comment|// 'a',
name|AArg
block|,
comment|// 'A',
name|CStrArg
block|,
comment|// 's'
name|VoidPtrArg
block|,
comment|// 'p'
name|OutIntPtrArg
block|,
comment|// 'n'
name|PercentArg
block|,
comment|// '%'
comment|// MacOS X unicode extensions.
name|CArg
block|,
comment|// 'C'
name|UnicodeStrArg
block|,
comment|// 'S'
comment|// Objective-C specific specifiers.
name|ObjCObjArg
block|,
comment|// '@'
comment|// GlibC specific specifiers.
name|PrintErrno
block|,
comment|// 'm'
comment|// Specifier ranges.
name|IntArgBeg
init|=
name|dArg
block|,
name|IntArgEnd
init|=
name|iArg
block|,
name|UIntArgBeg
init|=
name|oArg
block|,
name|UIntArgEnd
init|=
name|XArg
block|,
name|DoubleArgBeg
init|=
name|fArg
block|,
name|DoubleArgEnd
init|=
name|AArg
block|,
name|C99Beg
init|=
name|IntArgBeg
block|,
name|C99End
init|=
name|DoubleArgEnd
block|,
name|ObjCBeg
init|=
name|ObjCObjArg
block|,
name|ObjCEnd
init|=
name|ObjCObjArg
block|}
enum|;
name|ConversionSpecifier
argument_list|()
operator|:
name|Position
argument_list|(
literal|0
argument_list|)
operator|,
name|kind
argument_list|(
argument|InvalidSpecifier
argument_list|)
block|{}
name|ConversionSpecifier
argument_list|(
argument|const char *pos
argument_list|,
argument|Kind k
argument_list|)
operator|:
name|Position
argument_list|(
name|pos
argument_list|)
operator|,
name|kind
argument_list|(
argument|k
argument_list|)
block|{}
specifier|const
name|char
operator|*
name|getStart
argument_list|()
specifier|const
block|{
return|return
name|Position
return|;
block|}
name|llvm
operator|::
name|StringRef
name|getCharacters
argument_list|()
specifier|const
block|{
return|return
name|llvm
operator|::
name|StringRef
argument_list|(
name|getStart
argument_list|()
argument_list|,
name|getLength
argument_list|()
argument_list|)
return|;
block|}
name|bool
name|consumesDataArgument
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|PercentArg
case|:
case|case
name|PrintErrno
case|:
return|return
name|false
return|;
default|default:
return|return
name|true
return|;
block|}
block|}
name|bool
name|isObjCArg
argument_list|()
specifier|const
block|{
return|return
name|kind
operator|>=
name|ObjCBeg
operator|&&
name|kind
operator|<=
name|ObjCEnd
return|;
block|}
name|bool
name|isIntArg
argument_list|()
specifier|const
block|{
return|return
name|kind
operator|>=
name|dArg
operator|&&
name|kind
operator|<=
name|iArg
return|;
block|}
name|bool
name|isUIntArg
argument_list|()
specifier|const
block|{
return|return
name|kind
operator|>=
name|oArg
operator|&&
name|kind
operator|<=
name|XArg
return|;
block|}
name|bool
name|isDoubleArg
argument_list|()
specifier|const
block|{
return|return
name|kind
operator|>=
name|fArg
operator|&&
name|kind
operator|<=
name|AArg
return|;
block|}
name|Kind
name|getKind
argument_list|()
specifier|const
block|{
return|return
name|kind
return|;
block|}
name|void
name|setKind
parameter_list|(
name|Kind
name|k
parameter_list|)
block|{
name|kind
operator|=
name|k
expr_stmt|;
block|}
name|unsigned
name|getLength
argument_list|()
specifier|const
block|{
comment|// Conversion specifiers currently only are represented by
comment|// single characters, but we be flexible.
return|return
literal|1
return|;
block|}
specifier|const
name|char
operator|*
name|toString
argument_list|()
specifier|const
expr_stmt|;
name|private
label|:
specifier|const
name|char
modifier|*
name|Position
decl_stmt|;
name|Kind
name|kind
decl_stmt|;
block|}
empty_stmt|;
name|class
name|LengthModifier
block|{
name|public
label|:
enum|enum
name|Kind
block|{
name|None
block|,
name|AsChar
block|,
comment|// 'hh'
name|AsShort
block|,
comment|// 'h'
name|AsLong
block|,
comment|// 'l'
name|AsLongLong
block|,
comment|// 'll', 'q' (BSD, deprecated)
name|AsIntMax
block|,
comment|// 'j'
name|AsSizeT
block|,
comment|// 'z'
name|AsPtrDiff
block|,
comment|// 't'
name|AsLongDouble
block|,
comment|// 'L'
name|AsWideChar
init|=
name|AsLong
comment|// for '%ls'
block|}
enum|;
name|LengthModifier
argument_list|()
operator|:
name|Position
argument_list|(
literal|0
argument_list|)
operator|,
name|kind
argument_list|(
argument|None
argument_list|)
block|{}
name|LengthModifier
argument_list|(
argument|const char *pos
argument_list|,
argument|Kind k
argument_list|)
operator|:
name|Position
argument_list|(
name|pos
argument_list|)
operator|,
name|kind
argument_list|(
argument|k
argument_list|)
block|{}
specifier|const
name|char
operator|*
name|getStart
argument_list|()
specifier|const
block|{
return|return
name|Position
return|;
block|}
name|unsigned
name|getLength
argument_list|()
specifier|const
block|{
switch|switch
condition|(
name|kind
condition|)
block|{
default|default:
return|return
literal|1
return|;
case|case
name|AsLongLong
case|:
case|case
name|AsChar
case|:
return|return
literal|2
return|;
case|case
name|None
case|:
return|return
literal|0
return|;
block|}
block|}
name|Kind
name|getKind
argument_list|()
specifier|const
block|{
return|return
name|kind
return|;
block|}
name|void
name|setKind
parameter_list|(
name|Kind
name|k
parameter_list|)
block|{
name|kind
operator|=
name|k
expr_stmt|;
block|}
specifier|const
name|char
operator|*
name|toString
argument_list|()
specifier|const
expr_stmt|;
name|private
label|:
specifier|const
name|char
modifier|*
name|Position
decl_stmt|;
name|Kind
name|kind
decl_stmt|;
block|}
empty_stmt|;
name|class
name|OptionalAmount
block|{
name|public
label|:
enum|enum
name|HowSpecified
block|{
name|NotSpecified
block|,
name|Constant
block|,
name|Arg
block|,
name|Invalid
block|}
enum|;
name|OptionalAmount
argument_list|(
argument|HowSpecified howSpecified
argument_list|,
argument|unsigned amount
argument_list|,
argument|const char *amountStart
argument_list|,
argument|unsigned amountLength
argument_list|,
argument|bool usesPositionalArg
argument_list|)
block|:
name|start
argument_list|(
name|amountStart
argument_list|)
operator|,
name|length
argument_list|(
name|amountLength
argument_list|)
operator|,
name|hs
argument_list|(
name|howSpecified
argument_list|)
operator|,
name|amt
argument_list|(
name|amount
argument_list|)
operator|,
name|UsesPositionalArg
argument_list|(
name|usesPositionalArg
argument_list|)
operator|,
name|UsesDotPrefix
argument_list|(
literal|0
argument_list|)
block|{}
name|OptionalAmount
argument_list|(
argument|bool valid = true
argument_list|)
operator|:
name|start
argument_list|(
literal|0
argument_list|)
operator|,
name|length
argument_list|(
literal|0
argument_list|)
operator|,
name|hs
argument_list|(
name|valid
operator|?
name|NotSpecified
operator|:
name|Invalid
argument_list|)
operator|,
name|amt
argument_list|(
literal|0
argument_list|)
operator|,
name|UsesPositionalArg
argument_list|(
literal|0
argument_list|)
operator|,
name|UsesDotPrefix
argument_list|(
literal|0
argument_list|)
block|{}
name|bool
name|isInvalid
argument_list|()
specifier|const
block|{
return|return
name|hs
operator|==
name|Invalid
return|;
block|}
name|HowSpecified
name|getHowSpecified
argument_list|()
specifier|const
block|{
return|return
name|hs
return|;
block|}
name|void
name|setHowSpecified
parameter_list|(
name|HowSpecified
name|h
parameter_list|)
block|{
name|hs
operator|=
name|h
expr_stmt|;
block|}
name|bool
name|hasDataArgument
argument_list|()
specifier|const
block|{
return|return
name|hs
operator|==
name|Arg
return|;
block|}
name|unsigned
name|getArgIndex
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|hasDataArgument
argument_list|()
argument_list|)
block|;
return|return
name|amt
return|;
block|}
name|unsigned
name|getConstantAmount
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|hs
operator|==
name|Constant
argument_list|)
block|;
return|return
name|amt
return|;
block|}
specifier|const
name|char
operator|*
name|getStart
argument_list|()
specifier|const
block|{
comment|// We include the . character if it is given.
return|return
name|start
operator|-
name|UsesDotPrefix
return|;
block|}
name|unsigned
name|getConstantLength
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|hs
operator|==
name|Constant
argument_list|)
block|;
return|return
name|length
operator|+
name|UsesDotPrefix
return|;
block|}
name|ArgTypeResult
name|getArgType
argument_list|(
name|ASTContext
operator|&
name|Ctx
argument_list|)
decl|const
decl_stmt|;
name|void
name|toString
argument_list|(
name|llvm
operator|::
name|raw_ostream
operator|&
name|os
argument_list|)
decl|const
decl_stmt|;
name|bool
name|usesPositionalArg
argument_list|()
specifier|const
block|{
return|return
operator|(
name|bool
operator|)
name|UsesPositionalArg
return|;
block|}
name|unsigned
name|getPositionalArgIndex
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|hasDataArgument
argument_list|()
argument_list|)
block|;
return|return
name|amt
operator|+
literal|1
return|;
block|}
name|bool
name|usesDotPrefix
argument_list|()
specifier|const
block|{
return|return
name|UsesDotPrefix
return|;
block|}
name|void
name|setUsesDotPrefix
parameter_list|()
block|{
name|UsesDotPrefix
operator|=
name|true
expr_stmt|;
block|}
name|private
label|:
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
name|unsigned
name|length
decl_stmt|;
name|HowSpecified
name|hs
decl_stmt|;
name|unsigned
name|amt
decl_stmt|;
name|bool
name|UsesPositionalArg
range|:
literal|1
decl_stmt|;
name|bool
name|UsesDotPrefix
decl_stmt|;
block|}
empty_stmt|;
comment|// Class representing optional flags with location and representation
comment|// information.
name|class
name|OptionalFlag
block|{
name|public
label|:
name|OptionalFlag
argument_list|(
specifier|const
name|char
operator|*
name|Representation
argument_list|)
operator|:
name|representation
argument_list|(
name|Representation
argument_list|)
operator|,
name|flag
argument_list|(
argument|false
argument_list|)
block|{}
name|bool
name|isSet
argument_list|()
block|{
return|return
name|flag
return|;
block|}
name|void
name|set
parameter_list|()
block|{
name|flag
operator|=
name|true
expr_stmt|;
block|}
name|void
name|clear
parameter_list|()
block|{
name|flag
operator|=
name|false
expr_stmt|;
block|}
name|void
name|setPosition
parameter_list|(
specifier|const
name|char
modifier|*
name|position
parameter_list|)
block|{
name|assert
argument_list|(
name|position
argument_list|)
expr_stmt|;
name|this
operator|->
name|position
operator|=
name|position
expr_stmt|;
block|}
specifier|const
name|char
operator|*
name|getPosition
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|position
argument_list|)
block|;
return|return
name|position
return|;
block|}
specifier|const
name|char
operator|*
name|toString
argument_list|()
specifier|const
block|{
return|return
name|representation
return|;
block|}
comment|// Overloaded operators for bool like qualities
name|operator
name|bool
argument_list|()
specifier|const
block|{
return|return
name|flag
return|;
block|}
name|OptionalFlag
modifier|&
name|operator
init|=
operator|(
specifier|const
name|bool
operator|&
name|rhs
operator|)
block|{
name|flag
operator|=
name|rhs
block|;
return|return
operator|*
name|this
return|;
comment|// Return a reference to myself.
block|}
name|private
label|:
specifier|const
name|char
modifier|*
name|representation
decl_stmt|;
specifier|const
name|char
modifier|*
name|position
decl_stmt|;
name|bool
name|flag
decl_stmt|;
block|}
empty_stmt|;
name|class
name|FormatSpecifier
block|{
name|LengthModifier
name|LM
decl_stmt|;
name|OptionalFlag
name|IsLeftJustified
decl_stmt|;
comment|// '-'
name|OptionalFlag
name|HasPlusPrefix
decl_stmt|;
comment|// '+'
name|OptionalFlag
name|HasSpacePrefix
decl_stmt|;
comment|// ' '
name|OptionalFlag
name|HasAlternativeForm
decl_stmt|;
comment|// '#'
name|OptionalFlag
name|HasLeadingZeroes
decl_stmt|;
comment|// '0'
comment|/// Positional arguments, an IEEE extension:
comment|///  IEEE Std 1003.1, 2004 Edition
comment|///  http://www.opengroup.org/onlinepubs/009695399/functions/printf.html
name|bool
name|UsesPositionalArg
decl_stmt|;
name|unsigned
name|argIndex
decl_stmt|;
name|ConversionSpecifier
name|CS
decl_stmt|;
name|OptionalAmount
name|FieldWidth
decl_stmt|;
name|OptionalAmount
name|Precision
decl_stmt|;
name|public
label|:
name|FormatSpecifier
argument_list|()
operator|:
name|IsLeftJustified
argument_list|(
literal|"-"
argument_list|)
operator|,
name|HasPlusPrefix
argument_list|(
literal|"+"
argument_list|)
operator|,
name|HasSpacePrefix
argument_list|(
literal|" "
argument_list|)
operator|,
name|HasAlternativeForm
argument_list|(
literal|"#"
argument_list|)
operator|,
name|HasLeadingZeroes
argument_list|(
literal|"0"
argument_list|)
operator|,
name|UsesPositionalArg
argument_list|(
name|false
argument_list|)
operator|,
name|argIndex
argument_list|(
literal|0
argument_list|)
block|{}
specifier|static
name|FormatSpecifier
name|Parse
argument_list|(
specifier|const
name|char
operator|*
name|beg
argument_list|,
specifier|const
name|char
operator|*
name|end
argument_list|)
expr_stmt|;
comment|// Methods for incrementally constructing the FormatSpecifier.
name|void
name|setConversionSpecifier
parameter_list|(
specifier|const
name|ConversionSpecifier
modifier|&
name|cs
parameter_list|)
block|{
name|CS
operator|=
name|cs
expr_stmt|;
block|}
name|void
name|setLengthModifier
parameter_list|(
name|LengthModifier
name|lm
parameter_list|)
block|{
name|LM
operator|=
name|lm
expr_stmt|;
block|}
name|void
name|setIsLeftJustified
parameter_list|(
specifier|const
name|char
modifier|*
name|position
parameter_list|)
block|{
name|IsLeftJustified
operator|=
name|true
expr_stmt|;
name|IsLeftJustified
operator|.
name|setPosition
argument_list|(
name|position
argument_list|)
expr_stmt|;
block|}
name|void
name|setHasPlusPrefix
parameter_list|(
specifier|const
name|char
modifier|*
name|position
parameter_list|)
block|{
name|HasPlusPrefix
operator|=
name|true
expr_stmt|;
name|HasPlusPrefix
operator|.
name|setPosition
argument_list|(
name|position
argument_list|)
expr_stmt|;
block|}
name|void
name|setHasSpacePrefix
parameter_list|(
specifier|const
name|char
modifier|*
name|position
parameter_list|)
block|{
name|HasSpacePrefix
operator|=
name|true
expr_stmt|;
name|HasSpacePrefix
operator|.
name|setPosition
argument_list|(
name|position
argument_list|)
expr_stmt|;
block|}
name|void
name|setHasAlternativeForm
parameter_list|(
specifier|const
name|char
modifier|*
name|position
parameter_list|)
block|{
name|HasAlternativeForm
operator|=
name|true
expr_stmt|;
name|HasAlternativeForm
operator|.
name|setPosition
argument_list|(
name|position
argument_list|)
expr_stmt|;
block|}
name|void
name|setHasLeadingZeros
parameter_list|(
specifier|const
name|char
modifier|*
name|position
parameter_list|)
block|{
name|HasLeadingZeroes
operator|=
name|true
expr_stmt|;
name|HasLeadingZeroes
operator|.
name|setPosition
argument_list|(
name|position
argument_list|)
expr_stmt|;
block|}
name|void
name|setUsesPositionalArg
parameter_list|()
block|{
name|UsesPositionalArg
operator|=
name|true
expr_stmt|;
block|}
name|void
name|setArgIndex
parameter_list|(
name|unsigned
name|i
parameter_list|)
block|{
name|assert
argument_list|(
name|CS
operator|.
name|consumesDataArgument
argument_list|()
argument_list|)
expr_stmt|;
name|argIndex
operator|=
name|i
expr_stmt|;
block|}
name|unsigned
name|getArgIndex
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|CS
operator|.
name|consumesDataArgument
argument_list|()
argument_list|)
block|;
return|return
name|argIndex
return|;
block|}
name|unsigned
name|getPositionalArgIndex
argument_list|()
specifier|const
block|{
name|assert
argument_list|(
name|CS
operator|.
name|consumesDataArgument
argument_list|()
argument_list|)
block|;
return|return
name|argIndex
operator|+
literal|1
return|;
block|}
comment|// Methods for querying the format specifier.
specifier|const
name|ConversionSpecifier
operator|&
name|getConversionSpecifier
argument_list|()
specifier|const
block|{
return|return
name|CS
return|;
block|}
specifier|const
name|LengthModifier
operator|&
name|getLengthModifier
argument_list|()
specifier|const
block|{
return|return
name|LM
return|;
block|}
specifier|const
name|OptionalAmount
operator|&
name|getFieldWidth
argument_list|()
specifier|const
block|{
return|return
name|FieldWidth
return|;
block|}
name|void
name|setFieldWidth
parameter_list|(
specifier|const
name|OptionalAmount
modifier|&
name|Amt
parameter_list|)
block|{
name|FieldWidth
operator|=
name|Amt
expr_stmt|;
block|}
name|void
name|setPrecision
parameter_list|(
specifier|const
name|OptionalAmount
modifier|&
name|Amt
parameter_list|)
block|{
name|Precision
operator|=
name|Amt
expr_stmt|;
name|Precision
operator|.
name|setUsesDotPrefix
argument_list|()
expr_stmt|;
block|}
specifier|const
name|OptionalAmount
operator|&
name|getPrecision
argument_list|()
specifier|const
block|{
return|return
name|Precision
return|;
block|}
comment|/// \brief Returns the builtin type that a data argument
comment|/// paired with this format specifier should have.  This method
comment|/// will return null if the format specifier does not have
comment|/// a matching data argument or the matching argument matches
comment|/// more than one type.
name|ArgTypeResult
name|getArgType
argument_list|(
name|ASTContext
operator|&
name|Ctx
argument_list|)
decl|const
decl_stmt|;
specifier|const
name|OptionalFlag
operator|&
name|isLeftJustified
argument_list|()
specifier|const
block|{
return|return
name|IsLeftJustified
return|;
block|}
specifier|const
name|OptionalFlag
operator|&
name|hasPlusPrefix
argument_list|()
specifier|const
block|{
return|return
name|HasPlusPrefix
return|;
block|}
specifier|const
name|OptionalFlag
operator|&
name|hasAlternativeForm
argument_list|()
specifier|const
block|{
return|return
name|HasAlternativeForm
return|;
block|}
specifier|const
name|OptionalFlag
operator|&
name|hasLeadingZeros
argument_list|()
specifier|const
block|{
return|return
name|HasLeadingZeroes
return|;
block|}
specifier|const
name|OptionalFlag
operator|&
name|hasSpacePrefix
argument_list|()
specifier|const
block|{
return|return
name|HasSpacePrefix
return|;
block|}
name|bool
name|usesPositionalArg
argument_list|()
specifier|const
block|{
return|return
name|UsesPositionalArg
return|;
block|}
comment|/// Changes the specifier and length according to a QualType, retaining any
comment|/// flags or options. Returns true on success, or false when a conversion
comment|/// was not successful.
name|bool
name|fixType
parameter_list|(
name|QualType
name|QT
parameter_list|)
function_decl|;
name|void
name|toString
argument_list|(
name|llvm
operator|::
name|raw_ostream
operator|&
name|os
argument_list|)
decl|const
decl_stmt|;
comment|// Validation methods - to check if any element results in undefined behavior
name|bool
name|hasValidPlusPrefix
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|hasValidAlternativeForm
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|hasValidLeadingZeros
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|hasValidSpacePrefix
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|hasValidLeftJustified
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|hasValidLengthModifier
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|hasValidPrecision
argument_list|()
specifier|const
expr_stmt|;
name|bool
name|hasValidFieldWidth
argument_list|()
specifier|const
expr_stmt|;
block|}
empty_stmt|;
enum|enum
name|PositionContext
block|{
name|FieldWidthPos
init|=
literal|0
block|,
name|PrecisionPos
init|=
literal|1
block|}
enum|;
name|class
name|FormatStringHandler
block|{
name|public
label|:
name|FormatStringHandler
argument_list|()
block|{}
name|virtual
operator|~
name|FormatStringHandler
argument_list|()
expr_stmt|;
name|virtual
name|void
name|HandleIncompleteFormatSpecifier
parameter_list|(
specifier|const
name|char
modifier|*
name|startSpecifier
parameter_list|,
name|unsigned
name|specifierLen
parameter_list|)
block|{}
name|virtual
name|void
name|HandleNullChar
parameter_list|(
specifier|const
name|char
modifier|*
name|nullCharacter
parameter_list|)
block|{}
name|virtual
name|void
name|HandleInvalidPosition
parameter_list|(
specifier|const
name|char
modifier|*
name|startPos
parameter_list|,
name|unsigned
name|posLen
parameter_list|,
name|PositionContext
name|p
parameter_list|)
block|{}
name|virtual
name|void
name|HandleZeroPosition
parameter_list|(
specifier|const
name|char
modifier|*
name|startPos
parameter_list|,
name|unsigned
name|posLen
parameter_list|)
block|{}
name|virtual
name|bool
name|HandleInvalidConversionSpecifier
argument_list|(
specifier|const
name|analyze_printf
operator|::
name|FormatSpecifier
operator|&
name|FS
argument_list|,
specifier|const
name|char
operator|*
name|startSpecifier
argument_list|,
name|unsigned
name|specifierLen
argument_list|)
block|{
return|return
name|true
return|;
block|}
name|virtual
name|bool
name|HandleFormatSpecifier
argument_list|(
specifier|const
name|analyze_printf
operator|::
name|FormatSpecifier
operator|&
name|FS
argument_list|,
specifier|const
name|char
operator|*
name|startSpecifier
argument_list|,
name|unsigned
name|specifierLen
argument_list|)
block|{
return|return
name|true
return|;
block|}
block|}
empty_stmt|;
name|bool
name|ParseFormatString
parameter_list|(
name|FormatStringHandler
modifier|&
name|H
parameter_list|,
specifier|const
name|char
modifier|*
name|beg
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|)
function_decl|;
block|}
comment|// end printf namespace
block|}
end_decl_stmt

begin_comment
comment|// end clang namespace
end_comment

begin_endif
endif|#
directive|endif
end_endif

end_unit

